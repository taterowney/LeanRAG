{"name":"CategoryTheory.MorphismProperty.costructuredArrow_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} A\nT : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} T\nP : CategoryTheory.MorphismProperty T\ninst‚úù : P.RespectsIso\nL : CategoryTheory.Functor A T\nX : T\nf g : CategoryTheory.CostructuredArrow L X\ne : CategoryTheory.Iso f g\n‚ä¢ Iff (P f.hom) (P g.hom)","decl":"lemma costructuredArrow_iso_iff (P : MorphismProperty T) [P.RespectsIso]\n    {L : A ‚•§ T} {X : T} {f g : CostructuredArrow L X} (e : f ‚âÖ g) :\n    P f.hom ‚Üî P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.over_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} T\nP : CategoryTheory.MorphismProperty T\ninst‚úù : P.RespectsIso\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\n‚ä¢ Iff (P f.hom) (P g.hom)","decl":"lemma over_iso_iff (P : MorphismProperty T) [P.RespectsIso] {X : T} {f g : Over X} (e : f ‚âÖ g) :\n    P f.hom ‚Üî P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ntoComma‚úù : CategoryTheory.Comma L R\nprop‚úù : P toComma‚úù.hom\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\n‚ä¢ Eq (Eq { toComma := toComma‚úù, prop := prop‚úù } { toComma := toComma, prop := prop }) (Eq toComma‚úù toComma)","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ntoComma‚úù : CategoryTheory.Comma L R\nprop‚úù : P toComma‚úù.hom\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\nx‚úù : Eq { toComma := toComma‚úù, prop := prop‚úù } { toComma := toComma, prop := prop }\n‚ä¢ Eq toComma‚úù toComma","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù‚Åµ : SizeOf A\ninst‚úù‚Å¥ : SizeOf B\ninst‚úù¬≥ : SizeOf T\ninst‚úù¬≤ : ‚¶ÉX Y : T‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (P x)\ninst‚úù¬π : ‚¶ÉX Y : A‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (Q x)\ninst‚úù : ‚¶ÉX Y : B‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W x)\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\n‚ä¢ Eq (SizeOf.sizeOf { toComma := toComma, prop := prop }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toComma)) (SizeOf.sizeOf prop))","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.prop","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nself : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ P self.hom","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nx y : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ Iff (Eq x y) (And (Eq x.left y.left) (And (Eq x.right y.right) (HEq x.hom y.hom)))","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nx y : CategoryTheory.MorphismProperty.Comma L R P Q W\nleft : Eq x.left y.left\nright : Eq x.right y.right\nhom : HEq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nx y : X.Hom Y\nleft : Eq x.left y.left\nright : Eq x.right y.right\n‚ä¢ Eq x y","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ntoCommaMorphism‚úù : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left‚úù : Q toCommaMorphism‚úù.left\nprop_hom_right‚úù : W toCommaMorphism‚úù.right\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\n‚ä¢ Eq (Eq { toCommaMorphism := toCommaMorphism‚úù, prop_hom_left := prop_hom_left‚úù, prop_hom_right := prop_hom_right‚úù } { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }) (Eq toCommaMorphism‚úù toCommaMorphism)","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ninst‚úù‚Åµ : SizeOf A\ninst‚úù‚Å¥ : SizeOf B\ninst‚úù¬≥ : SizeOf T\ninst‚úù¬≤ : ‚¶ÉX Y : T‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (P x)\ninst‚úù¬π : ‚¶ÉX Y : A‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (Q x)\ninst‚úù : ‚¶ÉX Y : B‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W x)\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\n‚ä¢ Eq (SizeOf.sizeOf { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCommaMorphism)) (SizeOf.sizeOf prop_hom_left)) (SizeOf.sizeOf prop_hom_right))","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ntoCommaMorphism‚úù : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left‚úù : Q toCommaMorphism‚úù.left\nprop_hom_right‚úù : W toCommaMorphism‚úù.right\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\nx‚úù : Eq { toCommaMorphism := toCommaMorphism‚úù, prop_hom_left := prop_hom_left‚úù, prop_hom_right := prop_hom_right‚úù } { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }\n‚ä¢ Eq toCommaMorphism‚úù toCommaMorphism","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.prop_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nself : X.Hom Y\n‚ä¢ W self.right","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (And (Eq x.left y.left) (Eq x.right y.right))","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.prop_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nself : X.Hom Y\n‚ä¢ Q self.left","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : CategoryTheory.CommaMorphism X.toComma Y.toComma\nhf : Q f.left\nhg : W f.right\n‚ä¢ Eq { toCommaMorphism := f, prop_hom_left := hf, prop_hom_right := hg }.hom f","decl":"@[simp, nolint simpVarHead]\nlemma Hom.hom_mk {X Y : P.Comma L R Q W}\n    (f : CommaMorphism X.toComma Y.toComma) (hf) (hg) :\n  Comma.Hom.hom ‚ü®f, hf, hg‚ü© = f := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\n‚ä¢ Eq f.hom.left f.left","decl":"lemma Hom.hom_left {X Y : P.Comma L R Q W} (f : Comma.Hom X Y) : f.hom.left = f.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\n‚ä¢ Eq f.hom.right f.right","decl":"lemma Hom.hom_right {X Y : P.Comma L R Q W} (f : Comma.Hom X Y) : f.hom.right = f.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.ContainsIdentities\ninst‚úù : W.ContainsIdentities\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ Eq X.id.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The identity morphism of an object in `P.Comma L R Q W`. -/\n@[simps]\ndef id [Q.ContainsIdentities] [W.ContainsIdentities] (X : P.Comma L R Q W) : Comma.Hom X X where\n  left := ùüô X.left\n  prop_hom_left := Q.id_mem X.toComma.left\n  prop_hom_right := W.id_mem X.toComma.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.ContainsIdentities\ninst‚úù : W.ContainsIdentities\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ Eq X.id.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The identity morphism of an object in `P.Comma L R Q W`. -/\n@[simps]\ndef id [Q.ContainsIdentities] [W.ContainsIdentities] (X : P.Comma L R Q W) : Comma.Hom X X where\n  left := ùüô X.left\n  prop_hom_left := Q.id_mem X.toComma.left\n  prop_hom_right := W.id_mem X.toComma.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.comp_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsStableUnderComposition\ninst‚úù : W.IsStableUnderComposition\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\ng : Y.Hom Z\n‚ä¢ Eq (f.comp g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"/-- Composition of morphisms in `P.Comma L R Q W`. -/\n@[simps]\ndef Hom.comp [Q.IsStableUnderComposition] [W.IsStableUnderComposition] {X Y Z : P.Comma L R Q W}\n    (f : Comma.Hom X Y) (g : Comma.Hom Y Z) :\n    Comma.Hom X Z where\n  left := f.left ‚â´ g.left\n  right := f.right ‚â´ g.right\n  prop_hom_left := Q.comp_mem _ _ f.prop_hom_left g.prop_hom_left\n  prop_hom_right := W.comp_mem _ _ f.prop_hom_right g.prop_hom_right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.comp_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsStableUnderComposition\ninst‚úù : W.IsStableUnderComposition\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\ng : Y.Hom Z\n‚ä¢ Eq (f.comp g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"/-- Composition of morphisms in `P.Comma L R Q W`. -/\n@[simps]\ndef Hom.comp [Q.IsStableUnderComposition] [W.IsStableUnderComposition] {X Y Z : P.Comma L R Q W}\n    (f : Comma.Hom X Y) (g : Comma.Hom Y Z) :\n    Comma.Hom X Z where\n  left := f.left ‚â´ g.left\n  right := f.right ‚â´ g.right\n  prop_hom_left := Q.comp_mem _ _ f.prop_hom_left g.prop_hom_left\n  prop_hom_right := W.comp_mem _ _ f.prop_hom_right g.prop_hom_right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.toCommaMorphism_eq_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\n‚ä¢ Eq f.toCommaMorphism (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"lemma toCommaMorphism_eq_hom {X Y : P.Comma L R Q W} (f : X ‚ü∂ Y) : f.toCommaMorphism = f.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext'","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf g : Quiver.Hom X Y\nh : Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g)\n‚ä¢ Eq f g","decl":"/-- Alternative `ext` lemma for `Comma.Hom`. -/\n@[ext]\nlemma Hom.ext' {X Y : P.Comma L R Q W} {f g : X ‚ü∂ Y} (h : f.hom = g.hom) :\n    f = g := Comma.Hom.ext\n  (congrArg CommaMorphism.left h)\n  (congrArg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext'_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g))","decl":"/-- Alternative `ext` lemma for `Comma.Hom`. -/\n@[ext]\nlemma Hom.ext' {X Y : P.Comma L R Q W} {f g : X ‚ü∂ Y} (h : f.hom = g.hom) :\n    f = g := Comma.Hom.ext\n  (congrArg CommaMorphism.left h)\n  (congrArg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id X.toComma)","decl":"@[simp]\nlemma id_hom (X : P.Comma L R Q W) : (ùüô X : X ‚ü∂ X).hom = ùüô X.toComma := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g))","decl":"@[simp]\nlemma comp_hom {X Y Z : P.Comma L R Q W} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).hom = f.hom ‚â´ g.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_left_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y Z‚úù : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : A\nh : Quiver.Hom Z‚úù.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).left h) (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp g.left h))","decl":"@[reassoc]\nlemma comp_left {X Y Z : P.Comma L R Q W} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).left = f.left ‚â´ g.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[reassoc]\nlemma comp_left {X Y Z : P.Comma L R Q W} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).left = f.left ‚â´ g.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[reassoc]\nlemma comp_right {X Y Z : P.Comma L R Q W} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).right = f.right ‚â´ g.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_right_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y Z‚úù : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : B\nh : Quiver.Hom Z‚úù.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).right h) (CategoryTheory.CategoryStruct.comp f.right (CategoryTheory.CategoryStruct.comp g.right h))","decl":"@[reassoc]\nlemma comp_right {X Y Z : P.Comma L R Q W} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).right = f.right ‚â´ g.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù‚Å¥ : Q.IsMultiplicative\ninst‚úù¬≥ : W.IsMultiplicative\ninst‚úù¬≤ : Q.RespectsIso\ninst‚úù¬π : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X.toComma Y.toComma\ninst‚úù : CategoryTheory.IsIso i\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i)) i","decl":"/-- If `i` is an isomorphism in `Comma L R`, it is also a morphism in `P.Comma L R Q W`. -/\n@[simps hom]\ndef homFromCommaOfIsIso [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ‚ü∂ Y.toComma) [IsIso i] :\n    X ‚ü∂ Y where\n  __ := i\n  prop_hom_left := Q.of_isIso i.left\n  prop_hom_right := W.of_isIso i.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instIsIsoHomFromCommaOfIsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù‚Å¥ : Q.IsMultiplicative\ninst‚úù¬≥ : W.IsMultiplicative\ninst‚úù¬≤ : Q.RespectsIso\ninst‚úù¬π : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X.toComma Y.toComma\ninst‚úù : CategoryTheory.IsIso i\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i)","decl":"instance [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (i : X.toComma ‚ü∂ Y.toComma)\n    [IsIso i] : IsIso (homFromCommaOfIsIso i) := by\n  constructor\n  use homFromCommaOfIsIso (inv i)\n  constructor <;> ext : 1 <;> simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoFromComma_inv","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : CategoryTheory.Iso X.toComma Y.toComma\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoFromComma i).inv (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i.inv)","decl":"/-- Any isomorphism between objects of `P.Comma L R Q W` in `Comma L R` is also an isomorphism\nin `P.Comma L R Q W`.  -/\n@[simps]\ndef isoFromComma [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ‚âÖ Y.toComma) : X ‚âÖ Y where\n  hom := homFromCommaOfIsIso i.hom\n  inv := homFromCommaOfIsIso i.inv\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoFromComma_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : CategoryTheory.Iso X.toComma Y.toComma\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoFromComma i).hom (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i.hom)","decl":"/-- Any isomorphism between objects of `P.Comma L R Q W` in `Comma L R` is also an isomorphism\nin `P.Comma L R Q W`.  -/\n@[simps]\ndef isoFromComma [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ‚âÖ Y.toComma) : X ‚âÖ Y where\n  hom := homFromCommaOfIsIso i.hom\n  inv := homFromCommaOfIsIso i.inv\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).hom.right r.hom","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ‚âÖ Y.left)\n    (r : X.right ‚âÖ Y.right) (h : L.map l.hom ‚â´ Y.hom = X.hom ‚â´ R.map r.hom := by aesop_cat) :\n    X ‚âÖ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_inv_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).inv.right r.inv","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ‚âÖ Y.left)\n    (r : X.right ‚âÖ Y.right) (h : L.map l.hom ‚â´ Y.hom = X.hom ‚â´ R.map r.hom := by aesop_cat) :\n    X ‚âÖ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_inv_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).inv.left l.inv","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ‚âÖ Y.left)\n    (r : X.right ‚âÖ Y.right) (h : L.map l.hom ‚â´ Y.hom = X.hom ‚â´ R.map r.hom := by aesop_cat) :\n    X ‚âÖ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).hom.left l.hom","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ‚âÖ Y.left)\n    (r : X.right ‚âÖ Y.right) (h : L.map l.hom ‚â´ Y.hom = X.hom ‚â´ R.map r.hom := by aesop_cat) :\n    X ‚âÖ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.forget_map","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX‚úù Y‚úù : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.forget L R P Q W).map f) (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"/-- The forgetful functor. -/\n@[simps]\ndef forget : P.Comma L R Q W ‚•§ Comma L R where\n  obj X := X.toComma\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.forget_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.forget L R P Q W).obj X) X.toComma","decl":"/-- The forgetful functor. -/\n@[simps]\ndef forget : P.Comma L R Q W ‚•§ Comma L R where\n  obj X := X.toComma\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instFaithfulCommaForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\n‚ä¢ (CategoryTheory.MorphismProperty.Comma.forget L R P Q W).Faithful","decl":"instance : (forget L R P Q W).Faithful where\n  map_injective := Comma.Hom.ext'\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instIsIsoCommaHom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≤ : Q.IsMultiplicative\ninst‚úù¬π : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"instance {X Y : P.Comma L R Q W} (f : X ‚ü∂ Y) [IsIso f] : IsIso f.hom :=\n  (forget L R P Q W).map_isIso f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.hom_homFromCommaOfIsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù‚Å¥ : Q.IsMultiplicative\ninst‚úù¬≥ : W.IsMultiplicative\ninst‚úù¬≤ : Q.RespectsIso\ninst‚úù¬π : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom i)\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom i)) i","decl":"lemma hom_homFromCommaOfIsIso [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X ‚ü∂ Y) [IsIso i.hom] :\n    homFromCommaOfIsIso i.hom = i :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.inv_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≤ : Q.IsMultiplicative\ninst‚úù¬π : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.inv f)) (CategoryTheory.inv (CategoryTheory.MorphismProperty.Comma.Hom.hom f))","decl":"lemma inv_hom {X Y : P.Comma L R Q W} (f : X ‚ü∂ Y) [IsIso f] : (inv f).hom = inv f.hom := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [‚Üê comp_hom, IsIso.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instReflectsIsomorphismsCommaForgetOfRespectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≥ : Q.IsMultiplicative\ninst‚úù¬≤ : W.IsMultiplicative\ninst‚úù¬π : Q.RespectsIso\ninst‚úù : W.RespectsIso\n‚ä¢ (CategoryTheory.MorphismProperty.Comma.forget L R P Q W).ReflectsIsomorphisms","decl":"instance [Q.RespectsIso] [W.RespectsIso] : (forget L R P Q W).ReflectsIsomorphisms where\n  reflects f hf := by\n    simp only [forget_obj, forget_map] at hf\n    rw [‚Üê hom_homFromCommaOfIsIso f]\n    infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instFullTopCommaForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\n‚ä¢ (CategoryTheory.MorphismProperty.Comma.forget L R P Top.top Top.top).Full","decl":"instance : (forget L R P ‚ä§ ‚ä§).Full :=\n  Functor.FullyFaithful.full (forgetFullyFaithful L R P)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.eqToHom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).left (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\nlemma eqToHom_left {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.eqToHom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).right (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\nlemma eqToHom_right {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.lift_obj_toComma","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} A\nB : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} B\nT : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≤ : Q.IsMultiplicative\ninst‚úù¬π : W.IsMultiplicative\nC : Type u_4\ninst‚úù : CategoryTheory.Category.{u_8, u_4} C\nF : CategoryTheory.Functor C (CategoryTheory.Comma L R)\nhP : ‚àÄ (X : C), P (F.obj X).hom\nhQ : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), Q (F.map f).left\nhW : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), W (F.map f).right\nX : C\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.lift F hP hQ hW).obj X).toComma (F.obj X)","decl":"/-- Lift a functor `F : C ‚•§ Comma L R` to the subcategory `P.Comma L R Q W` under\nsuitable assumptions on `F`. -/\n@[simps obj_toComma map_hom]\ndef lift {C : Type*} [Category C] (F : C ‚•§ Comma L R)\n    (hP : ‚àÄ X, P (F.obj X).hom)\n    (hQ : ‚àÄ {X Y} (f : X ‚ü∂ Y), Q (F.map f).left)\n    (hW : ‚àÄ {X Y} (f : X ‚ü∂ Y), W (F.map f).right) :\n    C ‚•§ P.Comma L R Q W where\n  obj X :=\n    { __ := F.obj X\n      prop := hP X }\n  map {X Y} f :=\n    { __ := F.map f\n      prop_hom_left := hQ f\n      prop_hom_right := hW f }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.lift_map_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} A\nB : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} B\nT : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬≤ : Q.IsMultiplicative\ninst‚úù¬π : W.IsMultiplicative\nC : Type u_4\ninst‚úù : CategoryTheory.Category.{u_8, u_4} C\nF : CategoryTheory.Functor C (CategoryTheory.Comma L R)\nhP : ‚àÄ (X : C), P (F.obj X).hom\nhQ : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), Q (F.map f).left\nhW : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), W (F.map f).right\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom ((CategoryTheory.MorphismProperty.Comma.lift F hP hQ hW).map f)) (F.map f)","decl":"/-- Lift a functor `F : C ‚•§ Comma L R` to the subcategory `P.Comma L R Q W` under\nsuitable assumptions on `F`. -/\n@[simps obj_toComma map_hom]\ndef lift {C : Type*} [Category C] (F : C ‚•§ Comma L R)\n    (hP : ‚àÄ X, P (F.obj X).hom)\n    (hQ : ‚àÄ {X Y} (f : X ‚ü∂ Y), Q (F.map f).left)\n    (hW : ‚àÄ {X Y} (f : X ‚ü∂ Y), W (F.map f).right) :\n    C ‚•§ P.Comma L R Q W where\n  obj X :=\n    { __ := F.obj X\n      prop := hP X }\n  map {X Y} f :=\n    { __ := F.map f\n      prop_hom_left := hQ f\n      prop_hom_right := hW f }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor A T\nl : Quiver.Hom L‚ÇÅ L‚ÇÇ\nhl : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX Y : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).map f).left (CategoryTheory.MorphismProperty.Comma.Hom.hom f).left","decl":"variable (R) in\n/-- A natural transformation `L‚ÇÅ ‚ü∂ L‚ÇÇ` induces a functor `P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hl : ‚àÄ X : P.Comma L‚ÇÇ R Q W, P (l.app X.left ‚â´ X.hom)) :\n    P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor A T\nl : Quiver.Hom L‚ÇÅ L‚ÇÇ\nhl : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).hom (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)","decl":"variable (R) in\n/-- A natural transformation `L‚ÇÅ ‚ü∂ L‚ÇÇ` induces a functor `P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hl : ‚àÄ X : P.Comma L‚ÇÇ R Q W, P (l.app X.left ‚â´ X.hom)) :\n    P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_map_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor A T\nl : Quiver.Hom L‚ÇÅ L‚ÇÇ\nhl : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX Y : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).map f).right (CategoryTheory.MorphismProperty.Comma.Hom.hom f).right","decl":"variable (R) in\n/-- A natural transformation `L‚ÇÅ ‚ü∂ L‚ÇÇ` induces a functor `P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hl : ‚àÄ X : P.Comma L‚ÇÇ R Q W, P (l.app X.left ‚â´ X.hom)) :\n    P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor A T\nl : Quiver.Hom L‚ÇÅ L‚ÇÇ\nhl : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).left X.left","decl":"variable (R) in\n/-- A natural transformation `L‚ÇÅ ‚ü∂ L‚ÇÇ` induces a functor `P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hl : ‚àÄ X : P.Comma L‚ÇÇ R Q W, P (l.app X.left ‚â´ X.hom)) :\n    P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor A T\nl : Quiver.Hom L‚ÇÅ L‚ÇÇ\nhl : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L‚ÇÇ R P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).right X.right","decl":"variable (R) in\n/-- A natural transformation `L‚ÇÅ ‚ü∂ L‚ÇÇ` induces a functor `P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hl : ‚àÄ X : P.Comma L‚ÇÇ R Q W, P (l.app X.left ‚â´ X.hom)) :\n    P.Comma L‚ÇÇ R Q W ‚•§ P.Comma L‚ÇÅ R Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T\nr : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhr : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))","decl":"variable (L) in\n/-- A natural transformation `R‚ÇÅ ‚ü∂ R‚ÇÇ` induces a functor `P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W`. -/\n@[simps!]\ndef mapRight (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (hr : ‚àÄ X : P.Comma L R‚ÇÅ Q W, P (X.hom ‚â´ r.app X.right)) :\n    P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapRight L r) hr\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_map_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T\nr : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhr : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX Y : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).map f).right (CategoryTheory.MorphismProperty.Comma.Hom.hom f).right","decl":"variable (L) in\n/-- A natural transformation `R‚ÇÅ ‚ü∂ R‚ÇÇ` induces a functor `P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W`. -/\n@[simps!]\ndef mapRight (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (hr : ‚àÄ X : P.Comma L R‚ÇÅ Q W, P (X.hom ‚â´ r.app X.right)) :\n    P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapRight L r) hr\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T\nr : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhr : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).left X.left","decl":"variable (L) in\n/-- A natural transformation `R‚ÇÅ ‚ü∂ R‚ÇÇ` induces a functor `P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W`. -/\n@[simps!]\ndef mapRight (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (hr : ‚àÄ X : P.Comma L R‚ÇÅ Q W, P (X.hom ‚â´ r.app X.right)) :\n    P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapRight L r) hr\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T\nr : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhr : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).right X.right","decl":"variable (L) in\n/-- A natural transformation `R‚ÇÅ ‚ü∂ R‚ÇÇ` induces a functor `P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W`. -/\n@[simps!]\ndef mapRight (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (hr : ‚àÄ X : P.Comma L R‚ÇÅ Q W, P (X.hom ‚â´ r.app X.right)) :\n    P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapRight L r) hr\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : W.IsMultiplicative\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T\nr : Quiver.Hom R‚ÇÅ R‚ÇÇ\nhr : ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX Y : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).map f).left (CategoryTheory.MorphismProperty.Comma.Hom.hom f).left","decl":"variable (L) in\n/-- A natural transformation `R‚ÇÅ ‚ü∂ R‚ÇÇ` induces a functor `P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W`. -/\n@[simps!]\ndef mapRight (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (hr : ‚àÄ X : P.Comma L R‚ÇÅ Q W, P (X.hom ‚â´ r.app X.right)) :\n    P.Comma L R‚ÇÅ Q W ‚•§ P.Comma L R‚ÇÇ Q W :=\n  lift (forget _ _ _ _ _ ‚ãô CategoryTheory.Comma.mapRight L r) hr\n    (fun f ‚Ü¶ f.prop_hom_left) (fun f ‚Ü¶ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instFaithfulOverTopOverForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n‚ä¢ (CategoryTheory.MorphismProperty.Over.forget P Top.top X).Faithful","decl":"instance : (Over.forget P ‚ä§ X).Faithful := inferInstanceAs <| (Comma.forget _ _ _ _ _).Faithful\n"}
{"name":"CategoryTheory.MorphismProperty.instFullOverTopOverForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n‚ä¢ (CategoryTheory.MorphismProperty.Over.forget P Top.top X).Full","decl":"instance : (Over.forget P ‚ä§ X).Full := inferInstanceAs <| (Comma.forget _ _ _ _ _).Full\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A.toComma B.toComma\nhf : Q f.left\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Over.Hom.mk f hf)) f","decl":"/-- Construct a morphism in `P.Over Q X` from a morphism in `Over.X`. -/\n@[simps hom]\ndef Over.Hom.mk {A B : P.Over Q X} (f : A.toComma ‚ü∂ B.toComma) (hf : Q f.left) : A ‚ü∂ B where\n  __ := f\n  prop_hom_left := hf\n  prop_hom_right := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom A X\nhf : P f\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Over.mk Q f hf).hom f","decl":"variable (Q) in\n/-- Make an object of `P.Over Q X` from a morphism `f : A ‚ü∂ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Over.mk {A : T} (f : A ‚ü∂ X) (hf : P f) : P.Over Q X where\n  left := A\n  right := ‚ü®‚ü®‚ü©‚ü©\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mk_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom A X\nhf : P f\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Over.mk Q f hf).left A","decl":"variable (Q) in\n/-- Make an object of `P.Over Q X` from a morphism `f : A ‚ü∂ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Over.mk {A : T} (f : A ‚ü∂ X) (hf : P f) : P.Over Q X where\n  left := A\n  right := ‚ü®‚ü®‚ü©‚ü©\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.homMk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f B.hom) A.hom) _auto‚úù\nhf : autoParam (Q f) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Over.homMk f w hf)) (CategoryTheory.Over.homMk f w)","decl":"/-- Make a morphism in `P.Over Q X` from a morphism in `T` with compatibilities. -/\n@[simps hom]\nprotected def Over.homMk {A B : P.Over Q X} (f : A.left ‚ü∂ B.left)\n    (w : f ‚â´ B.hom = A.hom := by aesop_cat) (hf : Q f := by trivial) : A ‚ü∂ B where\n  __ := CategoryTheory.Over.homMk f w\n  prop_hom_left := hf\n  prop_hom_right := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.isoMk_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : Q.RespectsIso\nA B : P.Over Q X\nf : CategoryTheory.Iso A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom B.hom) A.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Over.isoMk f w).hom.left f.hom","decl":"/-- Make an isomorphism in `P.Over Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_left inv_left]\nprotected def Over.isoMk [Q.RespectsIso] {A B : P.Over Q X} (f : A.left ‚âÖ B.left)\n    (w : f.hom ‚â´ B.hom = A.hom := by aesop_cat) : A ‚âÖ B :=\n  Comma.isoMk f (Discrete.eqToIso' rfl)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.isoMk_inv_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : Q.RespectsIso\nA B : P.Over Q X\nf : CategoryTheory.Iso A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom B.hom) A.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Over.isoMk f w).inv.left f.inv","decl":"/-- Make an isomorphism in `P.Over Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_left inv_left]\nprotected def Over.isoMk [Q.RespectsIso] {A B : P.Over Q X} (f : A.left ‚âÖ B.left)\n    (w : f.hom ‚â´ B.hom = A.hom := by aesop_cat) : A ‚âÖ B :=\n  Comma.isoMk f (Discrete.eqToIso' rfl)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[ext]\nlemma Over.Hom.ext {A B : P.Over Q X} {f g : A ‚ü∂ B} (h : f.left = g.left) : f = g := by\n  ext\n  ¬∑ exact h\n  ¬∑ simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf g : Quiver.Hom A B\nh : Eq f.left g.left\n‚ä¢ Eq f g","decl":"@[ext]\nlemma Over.Hom.ext {A B : P.Over Q X} {f g : A ‚ü∂ B} (h : f.left = g.left) : f = g := by\n  ext\n  ¬∑ exact h\n  ¬∑ simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.w","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.left B.hom) A.hom","decl":"@[reassoc]\nlemma Over.w {A B : P.Over Q X} (f : A ‚ü∂ B) :\n    f.left ‚â´ B.hom = A.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit X).obj B.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp B.hom h)) (CategoryTheory.CategoryStruct.comp A.hom h)","decl":"@[reassoc]\nlemma Over.w {A B : P.Over Q X} (f : A ‚ü∂ B) :\n    f.left ‚â´ B.hom = A.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.instFaithfulUnderTopUnderForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n‚ä¢ (CategoryTheory.MorphismProperty.Under.forget P Top.top X).Faithful","decl":"instance : (Under.forget P ‚ä§ X).Faithful := inferInstanceAs <| (Comma.forget _ _ _ _ _).Faithful\n"}
{"name":"CategoryTheory.MorphismProperty.instFullUnderTopUnderForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n‚ä¢ (CategoryTheory.MorphismProperty.Under.forget P Top.top X).Full","decl":"instance : (Under.forget P ‚ä§ X).Full := inferInstanceAs <| (Comma.forget _ _ _ _ _).Full\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A.toComma B.toComma\nhf : Q f.right\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Under.Hom.mk f hf)) f","decl":"/-- Construct a morphism in `P.Under Q X` from a morphism in `Under.X`. -/\n@[simps hom]\ndef Under.Hom.mk {A B : P.Under Q X} (f : A.toComma ‚ü∂ B.toComma) (hf : Q f.right) : A ‚ü∂ B where\n  __ := f\n  prop_hom_left := trivial\n  prop_hom_right := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom X A\nhf : P f\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Under.mk Q f hf).hom f","decl":"variable (Q) in\n/-- Make an object of `P.Under Q X` from a morphism `f : A ‚ü∂ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Under.mk {A : T} (f : X ‚ü∂ A) (hf : P f) : P.Under Q X where\n  left := ‚ü®‚ü®‚ü©‚ü©\n  right := A\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.mk_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom X A\nhf : P f\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Under.mk Q f hf).left { as := PUnit.unit }","decl":"variable (Q) in\n/-- Make an object of `P.Under Q X` from a morphism `f : A ‚ü∂ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Under.mk {A : T} (f : X ‚ü∂ A) (hf : P f) : P.Under Q X where\n  left := ‚ü®‚ü®‚ü©‚ü©\n  right := A\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.homMk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f) B.hom) _auto‚úù\nhf : autoParam (Q f) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Under.homMk f w hf)) (CategoryTheory.Under.homMk f w)","decl":"/-- Make a morphism in `P.Under Q X` from a morphism in `T` with compatibilities. -/\n@[simps hom]\nprotected def Under.homMk {A B : P.Under Q X} (f : A.right ‚ü∂ B.right)\n    (w : A.hom ‚â´ f = B.hom := by aesop_cat) (hf : Q f := by trivial) : A ‚ü∂ B where\n  __ := CategoryTheory.Under.homMk f w\n  prop_hom_left := trivial\n  prop_hom_right := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.isoMk_inv_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : Q.RespectsIso\nA B : P.Under Q X\nf : CategoryTheory.Iso A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f.hom) B.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Under.isoMk f w).inv.right f.inv","decl":"/-- Make an isomorphism in `P.Under Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_right inv_right]\nprotected def Under.isoMk [Q.RespectsIso] {A B : P.Under Q X} (f : A.right ‚âÖ B.right)\n    (w : A.hom ‚â´ f.hom = B.hom := by aesop_cat) : A ‚âÖ B :=\n  Comma.isoMk (Discrete.eqToIso' rfl) f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.isoMk_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù¬π : Q.IsMultiplicative\ninst‚úù : Q.RespectsIso\nA B : P.Under Q X\nf : CategoryTheory.Iso A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f.hom) B.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MorphismProperty.Under.isoMk f w).hom.right f.hom","decl":"/-- Make an isomorphism in `P.Under Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_right inv_right]\nprotected def Under.isoMk [Q.RespectsIso] {A B : P.Under Q X} (f : A.right ‚âÖ B.right)\n    (w : A.hom ‚â´ f.hom = B.hom := by aesop_cat) : A ‚âÖ B :=\n  Comma.isoMk (Discrete.eqToIso' rfl) f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[ext]\nlemma Under.Hom.ext {A B : P.Under Q X} {f g : A ‚ü∂ B} (h : f.right = g.right) : f = g := by\n  ext\n  ¬∑ simp\n  ¬∑ exact h\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf g : Quiver.Hom A B\nh : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\nlemma Under.Hom.ext {A B : P.Under Q X} {f g : A ‚ü∂ B} (h : f.right = g.right) : f = g := by\n  ext\n  ¬∑ simp\n  ¬∑ exact h\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom B.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom (CategoryTheory.CategoryStruct.comp f.right h)) (CategoryTheory.CategoryStruct.comp B.hom h)","decl":"@[reassoc]\nlemma Under.w {A B : P.Under Q X} (f : A ‚ü∂ B) :\n    A.hom ‚â´ f.right = B.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.w","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst‚úù : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom f.right) B.hom","decl":"@[reassoc]\nlemma Under.w {A B : P.Under Q X} (f : A ‚ü∂ B) :\n    A.hom ‚â´ f.right = B.hom := by\n  simp\n\n"}
