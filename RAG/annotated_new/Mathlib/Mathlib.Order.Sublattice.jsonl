{"name":"Sublattice.mk.inj","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ncarrier✝ : Set α\nsupClosed'✝ : SupClosed carrier✝\ninfClosed'✝ : InfClosed carrier✝\ncarrier : Set α\nsupClosed' : SupClosed carrier\ninfClosed' : InfClosed carrier\nx✝ : Eq { carrier := carrier✝, supClosed' := supClosed'✝, infClosed' := infClosed'✝ } { carrier := carrier, supClosed' := supClosed', infClosed' := infClosed' }\n⊢ Eq carrier✝ carrier","decl":"/-- A sublattice of a lattice is a set containing the suprema and infima of any of its elements. -/\nstructure Sublattice where\n  /-- The underlying set of a sublattice. **Do not use directly**. Instead, use the coercion\n  `Sublattice α → Set α`, which Lean should automatically insert for you in most cases. -/\n  carrier : Set α\n  supClosed' : SupClosed carrier\n  infClosed' : InfClosed carrier\n\n"}
{"name":"Sublattice.mk.sizeOf_spec","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : SizeOf α\ncarrier : Set α\nsupClosed' : SupClosed carrier\ninfClosed' : InfClosed carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, supClosed' := supClosed', infClosed' := infClosed' }) 1","decl":"/-- A sublattice of a lattice is a set containing the suprema and infima of any of its elements. -/\nstructure Sublattice where\n  /-- The underlying set of a sublattice. **Do not use directly**. Instead, use the coercion\n  `Sublattice α → Set α`, which Lean should automatically insert for you in most cases. -/\n  carrier : Set α\n  supClosed' : SupClosed carrier\n  infClosed' : InfClosed carrier\n\n"}
{"name":"Sublattice.supClosed'","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : Sublattice α\n⊢ SupClosed self.carrier","decl":"/-- A sublattice of a lattice is a set containing the suprema and infima of any of its elements. -/\nstructure Sublattice where\n  /-- The underlying set of a sublattice. **Do not use directly**. Instead, use the coercion\n  `Sublattice α → Set α`, which Lean should automatically insert for you in most cases. -/\n  carrier : Set α\n  supClosed' : SupClosed carrier\n  infClosed' : InfClosed carrier\n\n"}
{"name":"Sublattice.mk.injEq","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ncarrier✝ : Set α\nsupClosed'✝ : SupClosed carrier✝\ninfClosed'✝ : InfClosed carrier✝\ncarrier : Set α\nsupClosed' : SupClosed carrier\ninfClosed' : InfClosed carrier\n⊢ Eq (Eq { carrier := carrier✝, supClosed' := supClosed'✝, infClosed' := infClosed'✝ } { carrier := carrier, supClosed' := supClosed', infClosed' := infClosed' }) (Eq carrier✝ carrier)","decl":"/-- A sublattice of a lattice is a set containing the suprema and infima of any of its elements. -/\nstructure Sublattice where\n  /-- The underlying set of a sublattice. **Do not use directly**. Instead, use the coercion\n  `Sublattice α → Set α`, which Lean should automatically insert for you in most cases. -/\n  carrier : Set α\n  supClosed' : SupClosed carrier\n  infClosed' : InfClosed carrier\n\n"}
{"name":"Sublattice.infClosed'","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : Sublattice α\n⊢ InfClosed self.carrier","decl":"/-- A sublattice of a lattice is a set containing the suprema and infima of any of its elements. -/\nstructure Sublattice where\n  /-- The underlying set of a sublattice. **Do not use directly**. Instead, use the coercion\n  `Sublattice α → Set α`, which Lean should automatically insert for you in most cases. -/\n  carrier : Set α\n  supClosed' : SupClosed carrier\n  infClosed' : InfClosed carrier\n\n"}
{"name":"Sublattice.coe_inj","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\n⊢ Iff (Eq ↑L ↑M) (Eq L M)","decl":"lemma coe_inj : (L : Set α) = M ↔ L = M := SetLike.coe_set_eq\n\n"}
{"name":"Sublattice.supClosed","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ SupClosed ↑L","decl":"@[simp] lemma supClosed (L : Sublattice α) : SupClosed (L : Set α) := L.supClosed'\n"}
{"name":"Sublattice.infClosed","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ InfClosed ↑L","decl":"@[simp] lemma infClosed (L : Sublattice α) : InfClosed (L : Set α) := L.infClosed'\n"}
{"name":"Sublattice.sup_mem","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : α\nha : Membership.mem L a\nhb : Membership.mem L b\n⊢ Membership.mem L (Max.max a b)","decl":"lemma sup_mem (ha : a ∈ L) (hb : b ∈ L) : a ⊔ b ∈ L := L.supClosed ha hb\n"}
{"name":"Sublattice.inf_mem","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : α\nha : Membership.mem L a\nhb : Membership.mem L b\n⊢ Membership.mem L (Min.min a b)","decl":"lemma inf_mem (ha : a ∈ L) (hb : b ∈ L) : a ⊓ b ∈ L := L.infClosed ha hb\n"}
{"name":"Sublattice.isSublattice","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ IsSublattice ↑L","decl":"@[simp] lemma isSublattice (L : Sublattice α) : IsSublattice (L : Set α) :=\n  ⟨L.supClosed, L.infClosed⟩\n\n"}
{"name":"Sublattice.mem_carrier","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na : α\n⊢ Iff (Membership.mem L.carrier a) (Membership.mem L a)","decl":"@[simp] lemma mem_carrier : a ∈ L.carrier ↔ a ∈ L := Iff.rfl\n"}
{"name":"Sublattice.mem_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ns : Set α\na : α\nh_sup : SupClosed s\nh_inf : InfClosed s\n⊢ Iff (Membership.mem { carrier := s, supClosed' := h_sup, infClosed' := h_inf } a) (Membership.mem s a)","decl":"@[simp] lemma mem_mk (h_sup h_inf) : a ∈ mk s h_sup h_inf ↔ a ∈ s := Iff.rfl\n"}
{"name":"Sublattice.coe_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ns : Set α\nh_sup : SupClosed s\nh_inf : InfClosed s\n⊢ Eq (↑{ carrier := s, supClosed' := h_sup, infClosed' := h_inf }) s","decl":"@[simp, norm_cast] lemma coe_mk (h_sup h_inf) : mk s h_sup h_inf = s := rfl\n"}
{"name":"Sublattice.mk_le_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ns t : Set α\nhs_sup : SupClosed s\nhs_inf : InfClosed s\nht_sup : SupClosed t\nht_inf : InfClosed t\n⊢ Iff (LE.le { carrier := s, supClosed' := hs_sup, infClosed' := hs_inf } { carrier := t, supClosed' := ht_sup, infClosed' := ht_inf }) (HasSubset.Subset s t)","decl":"@[simp] lemma mk_le_mk (hs_sup hs_inf ht_sup ht_inf) :\n    mk s hs_sup hs_inf ≤ mk t ht_sup ht_inf ↔ s ⊆ t := Iff.rfl\n"}
{"name":"Sublattice.mk_lt_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\ns t : Set α\nhs_sup : SupClosed s\nhs_inf : InfClosed s\nht_sup : SupClosed t\nht_inf : InfClosed t\n⊢ Iff (LT.lt { carrier := s, supClosed' := hs_sup, infClosed' := hs_inf } { carrier := t, supClosed' := ht_sup, infClosed' := ht_inf }) (HasSSubset.SSubset s t)","decl":"@[simp] lemma mk_lt_mk (hs_sup hs_inf ht_sup ht_inf) :\n    mk s hs_sup hs_inf < mk t ht_sup ht_inf ↔ s ⊂ t := Iff.rfl\n\n"}
{"name":"Sublattice.coe_copy","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\ns : Set α\nhs : Eq s ↑L\n⊢ Eq (↑(L.copy s hs)) s","decl":"@[simp, norm_cast] lemma coe_copy (L : Sublattice α) (s : Set α) (hs) : L.copy s hs = s := rfl\n\n"}
{"name":"Sublattice.copy_eq","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\ns : Set α\nhs : Eq s ↑L\n⊢ Eq (L.copy s hs) L","decl":"lemma copy_eq (L : Sublattice α) (s : Set α) (hs) : L.copy s hs = L := SetLike.coe_injective hs\n\n"}
{"name":"Sublattice.ext","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\na✝ : ∀ (a : α), Iff (Membership.mem L a) (Membership.mem M a)\n⊢ Eq L M","decl":"/-- Two sublattices are equal if they have the same elements. -/\nlemma ext : (∀ a, a ∈ L ↔ a ∈ M) → L = M := SetLike.ext\n\n"}
{"name":"Sublattice.coe_sup","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : Subtype fun x => Membership.mem L x\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_sup (a b : L) : a ⊔ b = (a : α) ⊔ b := rfl\n"}
{"name":"Sublattice.coe_inf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : Subtype fun x => Membership.mem L x\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_inf (a b : L) : a ⊓ b = (a : α) ⊓ b := rfl\n"}
{"name":"Sublattice.mk_sup_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : α\nha : Membership.mem L a\nhb : Membership.mem L b\n⊢ Eq (Max.max ⟨a, ha⟩ ⟨b, hb⟩) ⟨Max.max a b, ⋯⟩","decl":"@[simp] lemma mk_sup_mk (a b : α) (ha hb) : (⟨a, ha⟩ ⊔ ⟨b, hb⟩ : L) = ⟨a ⊔ b, L.supClosed ha hb⟩ :=\n  rfl\n"}
{"name":"Sublattice.mk_inf_mk","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na b : α\nha : Membership.mem L a\nhb : Membership.mem L b\n⊢ Eq (Min.min ⟨a, ha⟩ ⟨b, hb⟩) ⟨Min.min a b, ⋯⟩","decl":"@[simp] lemma mk_inf_mk (a b : α) (ha hb) : (⟨a, ha⟩ ⊓ ⟨b, hb⟩ : L) = ⟨a ⊓ b, L.infClosed ha hb⟩ :=\n  rfl\n\n"}
{"name":"Sublattice.coe_subtype","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Eq (⇑L.subtype) Subtype.val","decl":"@[simp, norm_cast] lemma coe_subtype (L : Sublattice α) : L.subtype = ((↑) : L → α) := rfl\n"}
{"name":"Sublattice.subtype_apply","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\na : Subtype fun x => Membership.mem L x\n⊢ Eq (L.subtype a) ↑a","decl":"lemma subtype_apply (L : Sublattice α) (a : L) : L.subtype a = a := rfl\n\n"}
{"name":"Sublattice.subtype_injective","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Function.Injective ⇑L.subtype","decl":"lemma subtype_injective (L : Sublattice α) : Injective <| subtype L := Subtype.coe_injective\n\n"}
{"name":"Sublattice.coe_inclusion","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\nh : LE.le L M\n⊢ Eq (⇑(Sublattice.inclusion h)) (Set.inclusion h)","decl":"@[simp] lemma coe_inclusion (h : L ≤ M) : inclusion h = Set.inclusion h := rfl\n"}
{"name":"Sublattice.inclusion_apply","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\nh : LE.le L M\na : Subtype fun x => Membership.mem L x\n⊢ Eq ((Sublattice.inclusion h) a) (Set.inclusion h a)","decl":"lemma inclusion_apply (h : L ≤ M) (a : L) : inclusion h a = Set.inclusion h a := rfl\n\n"}
{"name":"Sublattice.inclusion_injective","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\nh : LE.le L M\n⊢ Function.Injective ⇑(Sublattice.inclusion h)","decl":"lemma inclusion_injective (h : L ≤ M) : Injective <| inclusion h := Set.inclusion_injective h\n\n"}
{"name":"Sublattice.inclusion_rfl","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Eq (Sublattice.inclusion ⋯) (LatticeHom.id (Subtype fun x => Membership.mem L x))","decl":"@[simp] lemma inclusion_rfl (L : Sublattice α) : inclusion le_rfl = LatticeHom.id L := rfl\n"}
{"name":"Sublattice.subtype_comp_inclusion","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\nh : LE.le L M\n⊢ Eq (M.subtype.comp (Sublattice.inclusion h)) L.subtype","decl":"@[simp] lemma subtype_comp_inclusion (h : L ≤ M) : M.subtype.comp (inclusion h) = L.subtype := rfl\n\n"}
{"name":"Sublattice.coe_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast] lemma coe_top : (⊤ : Sublattice α) = (univ : Set α) := rfl\n"}
{"name":"Sublattice.coe_bot","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast] lemma coe_bot : (⊥ : Sublattice α) = (∅ : Set α) := rfl\n"}
{"name":"Sublattice.coe_inf'","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\n⊢ Eq (↑(Min.min L M)) (Inter.inter ↑L ↑M)","decl":"@[simp, norm_cast] lemma coe_inf' (L M : Sublattice α) : L ⊓ M = (L : Set α) ∩ M := rfl\n"}
{"name":"Sublattice.coe_sInf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nS : Set (Sublattice α)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun L => Set.iInter fun h => ↑L)","decl":"@[simp, norm_cast] lemma coe_sInf (S : Set (Sublattice α)) : sInf S = ⋂ L ∈ S, (L : Set α) := rfl\n"}
{"name":"Sublattice.coe_iInf","module":"Mathlib.Order.Sublattice","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : Lattice α\nf : ι → Sublattice α\n⊢ Eq (↑(iInf fun i => f i)) (Set.iInter fun i => ↑(f i))","decl":"@[simp, norm_cast] lemma coe_iInf (f : ι → Sublattice α) : ⨅ i, f i = ⋂ i, (f i : Set α) := by\n  simp [iInf]\n\n"}
{"name":"Sublattice.coe_eq_univ","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Iff (Eq (↑L) Set.univ) (Eq L Top.top)","decl":"@[simp, norm_cast] lemma coe_eq_univ : L = (univ : Set α) ↔ L = ⊤ := by rw [← coe_top, coe_inj]\n"}
{"name":"Sublattice.coe_eq_empty","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Iff (Eq (↑L) EmptyCollection.emptyCollection) (Eq L Bot.bot)","decl":"@[simp, norm_cast] lemma coe_eq_empty : L = (∅ : Set α) ↔ L = ⊥ := by rw [← coe_bot, coe_inj]\n\n"}
{"name":"Sublattice.not_mem_bot","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\na : α\n⊢ Not (Membership.mem Bot.bot a)","decl":"@[simp] lemma not_mem_bot (a : α) : a ∉ (⊥ : Sublattice α) := id\n"}
{"name":"Sublattice.mem_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\na : α\n⊢ Membership.mem Top.top a","decl":"@[simp] lemma mem_top (a : α) : a ∈ (⊤ : Sublattice α) := mem_univ _\n"}
{"name":"Sublattice.mem_inf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL M : Sublattice α\na : α\n⊢ Iff (Membership.mem (Min.min L M) a) (And (Membership.mem L a) (Membership.mem M a))","decl":"@[simp] lemma mem_inf : a ∈ L ⊓ M ↔ a ∈ L ∧ a ∈ M := Iff.rfl\n"}
{"name":"Sublattice.mem_sInf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\na : α\nS : Set (Sublattice α)\n⊢ Iff (Membership.mem (InfSet.sInf S) a) (∀ (L : Sublattice α), Membership.mem S L → Membership.mem L a)","decl":"@[simp] lemma mem_sInf {S : Set (Sublattice α)} : a ∈ sInf S ↔ ∀ L ∈ S, a ∈ L := by\n  rw [← SetLike.mem_coe]; simp\n"}
{"name":"Sublattice.mem_iInf","module":"Mathlib.Order.Sublattice","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : Lattice α\na : α\nf : ι → Sublattice α\n⊢ Iff (Membership.mem (iInf fun i => f i) a) (∀ (i : ι), Membership.mem (f i) a)","decl":"@[simp] lemma mem_iInf {f : ι → Sublattice α} : a ∈ ⨅ i, f i ↔ ∀ i, a ∈ f i := by\n  rw [← SetLike.mem_coe]; simp\n\n"}
{"name":"Sublattice.subsingleton_iff","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\n⊢ Iff (Subsingleton (Sublattice α)) (IsEmpty α)","decl":"lemma subsingleton_iff : Subsingleton (Sublattice α) ↔ IsEmpty α :=\n  ⟨fun _ ↦ univ_eq_empty_iff.1 <| coe_inj.2 <| Subsingleton.elim ⊤ ⊥,\n    fun _ ↦ SetLike.coe_injective.subsingleton⟩\n\n"}
{"name":"Sublattice.coe_comap","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice β\nf : LatticeHom α β\n⊢ Eq (↑(Sublattice.comap f L)) (Set.preimage ⇑f ↑L)","decl":"@[simp, norm_cast] lemma coe_comap (L : Sublattice β) (f : LatticeHom α β) : L.comap f = f ⁻¹' L :=\n  rfl\n\n"}
{"name":"Sublattice.mem_comap","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\na : α\nL : Sublattice β\n⊢ Iff (Membership.mem (Sublattice.comap f L) a) (Membership.mem L (f a))","decl":"@[simp] lemma mem_comap {L : Sublattice β} : a ∈ L.comap f ↔ f a ∈ L := Iff.rfl\n\n"}
{"name":"Sublattice.comap_mono","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\n⊢ Monotone (Sublattice.comap f)","decl":"lemma comap_mono : Monotone (comap f) := fun _ _ ↦ preimage_mono\n\n"}
{"name":"Sublattice.comap_id","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Eq (Sublattice.comap (LatticeHom.id α) L) L","decl":"@[simp] lemma comap_id (L : Sublattice α) : L.comap (LatticeHom.id _) = L := rfl\n\n"}
{"name":"Sublattice.comap_comap","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Lattice α\ninst✝¹ : Lattice β\ninst✝ : Lattice γ\nL : Sublattice γ\ng : LatticeHom β γ\nf : LatticeHom α β\n⊢ Eq (Sublattice.comap f (Sublattice.comap g L)) (Sublattice.comap (g.comp f) L)","decl":"@[simp] lemma comap_comap (L : Sublattice γ) (g : LatticeHom β γ) (f : LatticeHom α β) :\n    (L.comap g).comap f = L.comap (g.comp f) := rfl\n\n"}
{"name":"Sublattice.coe_map","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\nL : Sublattice α\n⊢ Eq (↑(Sublattice.map f L)) (Set.image ⇑f ↑L)","decl":"@[simp] lemma coe_map (f : LatticeHom α β) (L : Sublattice α) : (L.map f : Set β) = f '' L := rfl\n"}
{"name":"Sublattice.mem_map","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : LatticeHom α β\nb : β\n⊢ Iff (Membership.mem (Sublattice.map f L) b) (Exists fun a => And (Membership.mem L a) (Eq (f a) b))","decl":"@[simp] lemma mem_map {b : β} : b ∈ L.map f ↔ ∃ a ∈ L, f a = b := Iff.rfl\n\n"}
{"name":"Sublattice.mem_map_of_mem","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : LatticeHom α β\na : α\na✝ : Membership.mem L a\n⊢ Membership.mem (Sublattice.map f L) (f a)","decl":"lemma mem_map_of_mem (f : LatticeHom α β) {a : α} : a ∈ L → f a ∈ L.map f := mem_image_of_mem f\n"}
{"name":"Sublattice.apply_coe_mem_map","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : LatticeHom α β\na : Subtype fun x => Membership.mem L x\n⊢ Membership.mem (Sublattice.map f L) (f ↑a)","decl":"lemma apply_coe_mem_map (f : LatticeHom α β) (a : L) : f a ∈ L.map f := mem_map_of_mem f a.prop\n\n"}
{"name":"Sublattice.map_mono","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\n⊢ Monotone (Sublattice.map f)","decl":"lemma map_mono : Monotone (map f) := fun _ _ ↦ image_subset _\n\n"}
{"name":"Sublattice.map_id","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nL : Sublattice α\n⊢ Eq (Sublattice.map (LatticeHom.id α) L) L","decl":"@[simp] lemma map_id : L.map (LatticeHom.id α) = L := SetLike.coe_injective <| image_id _\n\n"}
{"name":"Sublattice.map_map","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Lattice α\ninst✝¹ : Lattice β\ninst✝ : Lattice γ\nL : Sublattice α\ng : LatticeHom β γ\nf : LatticeHom α β\n⊢ Eq (Sublattice.map g (Sublattice.map f L)) (Sublattice.map (g.comp f) L)","decl":"@[simp] lemma map_map (g : LatticeHom β γ) (f : LatticeHom α β) :\n    (L.map f).map g = L.map (g.comp f) := SetLike.coe_injective <| image_image _ _ _\n\n"}
{"name":"Sublattice.mem_map_equiv","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : OrderIso α β\na : β\n⊢ Iff (Membership.mem (Sublattice.map { toFun := ⇑f, map_sup' := ⋯, map_inf' := ⋯ } L) a) (Membership.mem L (f.symm a))","decl":"lemma mem_map_equiv {f : α ≃o β} {a : β} : a ∈ L.map f ↔ f.symm a ∈ L := Set.mem_image_equiv\n\n"}
{"name":"Sublattice.apply_mem_map_iff","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : LatticeHom α β\na : α\nhf : Function.Injective ⇑f\n⊢ Iff (Membership.mem (Sublattice.map f L) (f a)) (Membership.mem L a)","decl":"lemma apply_mem_map_iff (hf : Injective f) : f a ∈ L.map f ↔ a ∈ L := hf.mem_set_image\n\n"}
{"name":"Sublattice.map_equiv_eq_comap_symm","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : OrderIso α β\nL : Sublattice α\n⊢ Eq (Sublattice.map { toFun := ⇑f, map_sup' := ⋯, map_inf' := ⋯ } L) (Sublattice.comap { toFun := ⇑f.symm, map_sup' := ⋯, map_inf' := ⋯ } L)","decl":"lemma map_equiv_eq_comap_symm (f : α ≃o β) (L : Sublattice α) :\n    L.map f = L.comap (f.symm : LatticeHom β α) :=\n  SetLike.coe_injective <| f.toEquiv.image_eq_preimage L\n\n"}
{"name":"Sublattice.comap_equiv_eq_map_symm","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : OrderIso β α\nL : Sublattice α\n⊢ Eq (Sublattice.comap { toFun := ⇑f, map_sup' := ⋯, map_inf' := ⋯ } L) (Sublattice.map { toFun := ⇑f.symm, map_sup' := ⋯, map_inf' := ⋯ } L)","decl":"lemma comap_equiv_eq_map_symm (f : β ≃o α) (L : Sublattice α) :\n    L.comap f = L.map (f.symm : LatticeHom α β) := (map_equiv_eq_comap_symm f.symm L).symm\n\n"}
{"name":"Sublattice.map_symm_eq_iff_eq_map","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\ne : OrderIso β α\n⊢ Iff (Eq (Sublattice.map { toFun := ⇑e.symm, map_sup' := ⋯, map_inf' := ⋯ } L) M) (Eq L (Sublattice.map { toFun := ⇑e, map_sup' := ⋯, map_inf' := ⋯ } M))","decl":"lemma map_symm_eq_iff_eq_map {M : Sublattice β} {e : β ≃o α} :\n    L.map ↑e.symm = M ↔ L = M.map ↑e := by\n  simp_rw [← coe_inj]; exact (Equiv.eq_image_iff_symm_image_eq _ _ _).symm\n\n"}
{"name":"Sublattice.map_le_iff_le_comap","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nf : LatticeHom α β\nM : Sublattice β\n⊢ Iff (LE.le (Sublattice.map f L) M) (LE.le L (Sublattice.comap f M))","decl":"lemma map_le_iff_le_comap {f : LatticeHom α β} {M : Sublattice β} : L.map f ≤ M ↔ L ≤ M.comap f :=\n  image_subset_iff\n\n"}
{"name":"Sublattice.gc_map_comap","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\n⊢ GaloisConnection (Sublattice.map f) (Sublattice.comap f)","decl":"lemma gc_map_comap (f : LatticeHom α β) : GaloisConnection (map f) (comap f) :=\n  fun _ _ ↦ map_le_iff_le_comap\n\n"}
{"name":"Sublattice.map_bot","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\n⊢ Eq (Sublattice.map f Bot.bot) Bot.bot","decl":"@[simp] lemma map_bot (f : LatticeHom α β) : (⊥ : Sublattice α).map f = ⊥ := (gc_map_comap f).l_bot\n\n"}
{"name":"Sublattice.map_sup","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\nL M : Sublattice α\n⊢ Eq (Sublattice.map f (Max.max L M)) (Max.max (Sublattice.map f L) (Sublattice.map f M))","decl":"lemma map_sup (f : LatticeHom α β) (L M : Sublattice α) : (L ⊔ M).map f = L.map f ⊔ M.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Sublattice.map_iSup","module":"Mathlib.Order.Sublattice","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\nL : ι → Sublattice α\n⊢ Eq (Sublattice.map f (iSup fun i => L i)) (iSup fun i => Sublattice.map f (L i))","decl":"lemma map_iSup (f : LatticeHom α β) (L : ι → Sublattice α) : (⨆ i, L i).map f = ⨆ i, (L i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Sublattice.comap_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\n⊢ Eq (Sublattice.comap f Top.top) Top.top","decl":"@[simp] lemma comap_top (f : LatticeHom α β) : (⊤ : Sublattice β).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Sublattice.comap_inf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL M : Sublattice β\nf : LatticeHom α β\n⊢ Eq (Sublattice.comap f (Min.min L M)) (Min.min (Sublattice.comap f L) (Sublattice.comap f M))","decl":"lemma comap_inf (L M : Sublattice β) (f : LatticeHom α β) :\n    (L ⊓ M).comap f = L.comap f ⊓ M.comap f := (gc_map_comap f).u_inf\n\n"}
{"name":"Sublattice.comap_iInf","module":"Mathlib.Order.Sublattice","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\ns : ι → Sublattice β\n⊢ Eq (Sublattice.comap f (iInf s)) (iInf fun i => Sublattice.comap f (s i))","decl":"lemma comap_iInf (f : LatticeHom α β) (s : ι → Sublattice β) :\n    (iInf s).comap f = ⨅ i, (s i).comap f := (gc_map_comap f).u_iInf\n\n"}
{"name":"Sublattice.map_inf_le","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL M : Sublattice α\nf : LatticeHom α β\n⊢ LE.le (Sublattice.map f (Min.min L M)) (Min.min (Sublattice.map f L) (Sublattice.map f M))","decl":"lemma map_inf_le (L M : Sublattice α) (f : LatticeHom α β) : map f (L ⊓ M) ≤ map f L ⊓ map f M :=\n  map_mono.map_inf_le _ _\n\n"}
{"name":"Sublattice.le_comap_sup","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL M : Sublattice β\nf : LatticeHom α β\n⊢ LE.le (Max.max (Sublattice.comap f L) (Sublattice.comap f M)) (Sublattice.comap f (Max.max L M))","decl":"lemma le_comap_sup (L M : Sublattice β) (f : LatticeHom α β) :\n    comap f L ⊔ comap f M ≤ comap f (L ⊔ M) := comap_mono.le_map_sup _ _\n\n"}
{"name":"Sublattice.le_comap_iSup","module":"Mathlib.Order.Sublattice","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\nL : ι → Sublattice β\n⊢ LE.le (iSup fun i => Sublattice.comap f (L i)) (Sublattice.comap f (iSup fun i => L i))","decl":"lemma le_comap_iSup (f : LatticeHom α β) (L : ι → Sublattice β) :\n    ⨆ i, (L i).comap f ≤ (⨆ i, L i).comap f := comap_mono.le_map_iSup\n\n"}
{"name":"Sublattice.map_inf","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL M : Sublattice α\nf : LatticeHom α β\nhf : Function.Injective ⇑f\n⊢ Eq (Sublattice.map f (Min.min L M)) (Min.min (Sublattice.map f L) (Sublattice.map f M))","decl":"lemma map_inf (L M : Sublattice α) (f : LatticeHom α β) (hf : Injective f) :\n    map f (L ⊓ M) = map f L ⊓ map f M := by\n  rw [← SetLike.coe_set_eq]\n  simp [Set.image_inter hf]\n\n"}
{"name":"Sublattice.map_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nf : LatticeHom α β\nh : Function.Surjective ⇑f\n⊢ Eq (Sublattice.map f Top.top) Top.top","decl":"lemma map_top (f : LatticeHom α β) (h : Surjective f) : Sublattice.map f ⊤ = ⊤ :=\n  SetLike.coe_injective <| by simp [h.range_eq]\n\n"}
{"name":"Sublattice.coe_prod","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\n⊢ Eq (↑(L.prod M)) (SProd.sprod ↑L ↑M)","decl":"/-- Binary product of sublattices as a sublattice. -/\n@[simps]\ndef prod (L : Sublattice α) (M : Sublattice β) : Sublattice (α × β) where\n  carrier := L ×ˢ M\n  supClosed' := L.supClosed.prod M.supClosed\n  infClosed' := L.infClosed.prod M.infClosed\n\n"}
{"name":"Sublattice.mem_prod","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\np : Prod α β\n⊢ Iff (Membership.mem (L.prod M) p) (And (Membership.mem L p.1) (Membership.mem M p.2))","decl":"@[simp] lemma mem_prod {M : Sublattice β} {p : α × β} : p ∈ L.prod M ↔ p.1 ∈ L ∧ p.2 ∈ M := Iff.rfl\n\n"}
{"name":"Sublattice.prod_mono","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL₁ L₂ : Sublattice α\nM₁ M₂ : Sublattice β\nhL : LE.le L₁ L₂\nhM : LE.le M₁ M₂\n⊢ LE.le (L₁.prod M₁) (L₂.prod M₂)","decl":"@[gcongr]\nlemma prod_mono {L₁ L₂ : Sublattice α} {M₁ M₂ : Sublattice β} (hL : L₁ ≤ L₂) (hM : M₁ ≤ M₂) :\n    L₁.prod M₁ ≤ L₂.prod M₂ := Set.prod_mono hL hM\n\n"}
{"name":"Sublattice.prod_mono_left","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL₁ L₂ : Sublattice α\nM : Sublattice β\nhL : LE.le L₁ L₂\n⊢ LE.le (L₁.prod M) (L₂.prod M)","decl":"@[gcongr]\nlemma prod_mono_left {L₁ L₂ : Sublattice α} {M : Sublattice β} (hL : L₁ ≤ L₂) :\n    L₁.prod M ≤ L₂.prod M := prod_mono hL le_rfl\n\n"}
{"name":"Sublattice.prod_mono_right","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM₁ M₂ : Sublattice β\nhM : LE.le M₁ M₂\n⊢ LE.le (L.prod M₁) (L.prod M₂)","decl":"@[gcongr]\nlemma prod_mono_right {M₁ M₂ : Sublattice β} (hM : M₁ ≤ M₂) : L.prod M₁ ≤ L.prod M₂ :=\n  prod_mono le_rfl hM\n\n"}
{"name":"Sublattice.prod_left_mono","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nM : Sublattice α\n⊢ Monotone fun L => L.prod M","decl":"lemma prod_left_mono : Monotone fun L : Sublattice α ↦ L.prod M := fun _ _ ↦ prod_mono_left\n"}
{"name":"Sublattice.prod_right_mono","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\n⊢ Monotone fun M => L.prod M","decl":"lemma prod_right_mono : Monotone fun M : Sublattice β ↦ L.prod M := fun _ _ ↦ prod_mono_right\n\n"}
{"name":"Sublattice.prod_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\n⊢ Eq (L.prod Top.top) (Sublattice.comap LatticeHom.fst L)","decl":"lemma prod_top (L : Sublattice α) : L.prod (⊤ : Sublattice β) = L.comap LatticeHom.fst :=\n  ext fun a ↦ by simp [mem_prod, LatticeHom.coe_fst]\n\n"}
{"name":"Sublattice.top_prod","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice β\n⊢ Eq (Top.top.prod L) (Sublattice.comap LatticeHom.snd L)","decl":"lemma top_prod (L : Sublattice β) : (⊤ : Sublattice α).prod L = L.comap LatticeHom.snd :=\n  ext fun a ↦ by simp [mem_prod, LatticeHom.coe_snd]\n\n"}
{"name":"Sublattice.top_prod_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp] lemma top_prod_top : (⊤ : Sublattice α).prod (⊤ : Sublattice β) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"Sublattice.prod_bot","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\n⊢ Eq (L.prod Bot.bot) Bot.bot","decl":"@[simp] lemma prod_bot (L : Sublattice α) : L.prod (⊥ : Sublattice β) = ⊥ :=\n  SetLike.coe_injective prod_empty\n\n"}
{"name":"Sublattice.bot_prod","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nM : Sublattice β\n⊢ Eq (Bot.bot.prod M) Bot.bot","decl":"@[simp] lemma bot_prod (M : Sublattice β) : (⊥ : Sublattice α).prod M = ⊥ :=\n  SetLike.coe_injective empty_prod\n\n"}
{"name":"Sublattice.le_prod_iff","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\nN : Sublattice (Prod α β)\n⊢ Iff (LE.le N (L.prod M)) (And (LE.le N (Sublattice.comap LatticeHom.fst L)) (LE.le N (Sublattice.comap LatticeHom.snd M)))","decl":"lemma le_prod_iff {M : Sublattice β} {N : Sublattice (α × β)} :\n    N ≤ L.prod M ↔ N ≤ comap LatticeHom.fst L ∧ N ≤ comap LatticeHom.snd M := by\n  simp [SetLike.le_def, forall_and]\n\n"}
{"name":"Sublattice.prod_eq_bot","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\n⊢ Iff (Eq (L.prod M) Bot.bot) (Or (Eq L Bot.bot) (Eq M Bot.bot))","decl":"@[simp] lemma prod_eq_bot {M : Sublattice β} : L.prod M = ⊥ ↔ L = ⊥ ∨ M = ⊥ := by\n  simpa only [← coe_inj] using Set.prod_eq_empty_iff\n\n"}
{"name":"Sublattice.prod_eq_top","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Lattice α\ninst✝² : Lattice β\nL : Sublattice α\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\nM : Sublattice β\n⊢ Iff (Eq (L.prod M) Top.top) (And (Eq L Top.top) (Eq M Top.top))","decl":"@[simp] lemma prod_eq_top [Nonempty α] [Nonempty β] {M : Sublattice β} :\n    L.prod M = ⊤ ↔ L = ⊤ ∧ M = ⊤ := by simpa only [← coe_inj] using Set.prod_eq_univ\n\n"}
{"name":"Sublattice.prodEquiv_symm_apply","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\nx : Prod (Subtype fun a => ↑L a) (Subtype fun b => ↑M b)\n⊢ Eq ((RelIso.symm (L.prodEquiv M)) x) ⟨{ fst := ↑x.1, snd := ↑x.2 }, ⋯⟩","decl":"/-- The product of sublattices is isomorphic to their product as lattices. -/\n@[simps! toEquiv apply symm_apply]\ndef prodEquiv (L : Sublattice α) (M : Sublattice β) : L.prod M ≃o L × M where\n  toEquiv := Equiv.Set.prod _ _\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Sublattice.prodEquiv_toEquiv","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\n⊢ Eq (L.prodEquiv M).toEquiv (Equiv.Set.prod ↑L ↑M)","decl":"/-- The product of sublattices is isomorphic to their product as lattices. -/\n@[simps! toEquiv apply symm_apply]\ndef prodEquiv (L : Sublattice α) (M : Sublattice β) : L.prod M ≃o L × M where\n  toEquiv := Equiv.Set.prod _ _\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Sublattice.prodEquiv_apply","module":"Mathlib.Order.Sublattice","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Lattice α\ninst✝ : Lattice β\nL : Sublattice α\nM : Sublattice β\nx : Subtype fun c => And (↑L c.1) (↑M c.2)\n⊢ Eq ((L.prodEquiv M) x) { fst := ⟨(↑x).1, ⋯⟩, snd := ⟨(↑x).2, ⋯⟩ }","decl":"/-- The product of sublattices is isomorphic to their product as lattices. -/\n@[simps! toEquiv apply symm_apply]\ndef prodEquiv (L : Sublattice α) (M : Sublattice β) : L.prod M ≃o L × M where\n  toEquiv := Equiv.Set.prod _ _\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Sublattice.coe_pi","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\ns : Set κ\nL : (i : κ) → Sublattice (π i)\n⊢ Eq (↑(Sublattice.pi s L)) (s.pi fun i => ↑(L i))","decl":"/-- Arbitrary product of sublattices. Given an index set `s` and a family of sublattices\n`L : Π i, Sublattice (α i)`, `pi s L` is the sublattice of dependent functions `f : Π i, α i` such\nthat `f i` belongs to `L i` whenever `i ∈ s`. -/\n@[simps]\ndef pi (s : Set κ) (L : ∀ i, Sublattice (π i)) : Sublattice (∀ i, π i) where\n  carrier := s.pi fun i ↦ L i\n  supClosed' := supClosed_pi fun i _ ↦ (L i).supClosed\n  infClosed' := infClosed_pi fun i _ ↦ (L i).infClosed\n\n"}
{"name":"Sublattice.mem_pi","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\ns : Set κ\nL : (i : κ) → Sublattice (π i)\nx : (i : κ) → π i\n⊢ Iff (Membership.mem (Sublattice.pi s L) x) (∀ (i : κ), Membership.mem s i → Membership.mem (L i) (x i))","decl":"@[simp] lemma mem_pi {s : Set κ} {L : ∀ i, Sublattice (π i)} {x : ∀ i, π i} :\n    x ∈ pi s L ↔ ∀ i, i ∈ s → x i ∈ L i := Iff.rfl\n\n"}
{"name":"Sublattice.pi_empty","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\nL : (i : κ) → Sublattice (π i)\n⊢ Eq (Sublattice.pi EmptyCollection.emptyCollection L) Top.top","decl":"@[simp] lemma pi_empty (L : ∀ i, Sublattice (π i)) : pi ∅ L = ⊤ := ext fun a ↦ by simp [mem_pi]\n\n"}
{"name":"Sublattice.pi_top","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\ns : Set κ\n⊢ Eq (Sublattice.pi s fun x => Top.top) Top.top","decl":"@[simp] lemma pi_top (s : Set κ) : (pi s fun _ ↦ ⊤ : Sublattice (∀ i, π i)) = ⊤ :=\n  ext fun a ↦ by simp [mem_pi]\n\n"}
{"name":"Sublattice.pi_bot","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\ns : Set κ\nhs : s.Nonempty\n⊢ Eq (Sublattice.pi s fun x => Bot.bot) Bot.bot","decl":"@[simp] lemma pi_bot {s : Set κ} (hs : s.Nonempty) : (pi s fun _ ↦ ⊥ : Sublattice (∀ i, π i)) = ⊥ :=\n  ext fun a ↦ by simpa [mem_pi] using hs\n\n"}
{"name":"Sublattice.pi_univ_bot","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝¹ : (i : κ) → Lattice (π i)\ninst✝ : Nonempty κ\n⊢ Eq (Sublattice.pi Set.univ fun x => Bot.bot) Bot.bot","decl":"lemma pi_univ_bot [Nonempty κ] : (pi univ fun _ ↦ ⊥ : Sublattice (∀ i, π i)) = ⊥ := by simp\n\n"}
{"name":"Sublattice.le_pi","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\ns : Set κ\nL : (i : κ) → Sublattice (π i)\nM : Sublattice ((i : κ) → π i)\n⊢ Iff (LE.le M (Sublattice.pi s L)) (∀ (i : κ), Membership.mem s i → LE.le M (Sublattice.comap (Pi.evalLatticeHom i) (L i)))","decl":"lemma le_pi {s : Set κ} {L : ∀ i, Sublattice (π i)} {M : Sublattice (∀ i, π i)} :\n    M ≤ pi s L ↔ ∀ i ∈ s, M ≤ comap (Pi.evalLatticeHom i) (L i) := by simp [SetLike.le_def]; aesop\n\n"}
{"name":"Sublattice.pi_univ_eq_bot_iff","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\nL : (i : κ) → Sublattice (π i)\n⊢ Iff (Eq (Sublattice.pi Set.univ L) Bot.bot) (Exists fun i => Eq (L i) Bot.bot)","decl":"@[simp] lemma pi_univ_eq_bot_iff {L : ∀ i, Sublattice (π i)} : pi univ L = ⊥ ↔ ∃ i, L i = ⊥ := by\n  simp_rw [← coe_inj]; simp\n\n"}
{"name":"Sublattice.pi_univ_eq_bot","module":"Mathlib.Order.Sublattice","initialProofState":"κ : Type u_5\nπ : κ → Type u_6\ninst✝ : (i : κ) → Lattice (π i)\nL : (i : κ) → Sublattice (π i)\ni : κ\nhL : Eq (L i) Bot.bot\n⊢ Eq (Sublattice.pi Set.univ L) Bot.bot","decl":"lemma pi_univ_eq_bot {L : ∀ i, Sublattice (π i)} {i : κ} (hL : L i = ⊥) : pi univ L = ⊥ :=\n  pi_univ_eq_bot_iff.2 ⟨i, hL⟩\n\n"}
