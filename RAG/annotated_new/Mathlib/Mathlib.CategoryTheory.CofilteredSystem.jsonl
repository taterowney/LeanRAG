{"name":"nonempty_sections_of_finite_cofiltered_system.init","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nF : CategoryTheory.Functor J (Type u)\nhf : ‚àÄ (j : J), Finite (F.obj j)\nhne : ‚àÄ (j : J), Nonempty (F.obj j)\n‚ä¢ F.sections.Nonempty","decl":"/-- This bootstraps `nonempty_sections_of_finite_inverse_system`. In this version,\nthe `F` functor is between categories of the same universe, and it is an easy\ncorollary to `TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system`. -/\ntheorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J]\n    [IsCofilteredOrEmpty J] (F : J ‚•§ Type u) [hf : ‚àÄ j, Finite (F.obj j)]\n    [hne : ‚àÄ j, Nonempty (F.obj j)] : F.sections.Nonempty := by\n  let F' : J ‚•§ TopCat := F ‚ãô TopCat.discrete\n  haveI : ‚àÄ j, DiscreteTopology (F'.obj j) := fun _ => ‚ü®rfl‚ü©\n  haveI : ‚àÄ j, Finite (F'.obj j) := hf\n  haveI : ‚àÄ j, Nonempty (F'.obj j) := hne\n  obtain ‚ü®‚ü®u, hu‚ü©‚ü© := TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system.{u} F'\n  exact ‚ü®u, hu‚ü©\n\n"}
{"name":"nonempty_sections_of_finite_cofiltered_system","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{w, u} J\ninst‚úù¬≤ : CategoryTheory.IsCofilteredOrEmpty J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù¬π : ‚àÄ (j : J), Finite (F.obj j)\ninst‚úù : ‚àÄ (j : J), Nonempty (F.obj j)\n‚ä¢ F.sections.Nonempty","decl":"/-- The cofiltered limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_inverse_system` for a specialization to inverse limits. -/\ntheorem nonempty_sections_of_finite_cofiltered_system {J : Type u} [Category.{w} J]\n    [IsCofilteredOrEmpty J] (F : J ‚•§ Type v) [‚àÄ j : J, Finite (F.obj j)]\n    [‚àÄ j : J, Nonempty (F.obj j)] : F.sections.Nonempty := by\n  -- Step 1: lift everything to the `max u v w` universe.\n  let J' : Type max w v u := AsSmall.{max w v} J\n  let down : J' ‚•§ J := AsSmall.down\n  let F' : J' ‚•§ Type max u v w := down ‚ãô F ‚ãô uliftFunctor.{max u w, v}\n  haveI : ‚àÄ i, Nonempty (F'.obj i) := fun i => ‚ü®‚ü®Classical.arbitrary (F.obj (down.obj i))‚ü©‚ü©\n  haveI : ‚àÄ i, Finite (F'.obj i) := fun i => Finite.of_equiv (F.obj (down.obj i)) Equiv.ulift.symm\n  -- Step 2: apply the bootstrap theorem\n  cases isEmpty_or_nonempty J\n  ¬∑ fconstructor <;> apply isEmptyElim\n  haveI : IsCofiltered J := ‚ü®‚ü©\n  obtain ‚ü®u, hu‚ü© := nonempty_sections_of_finite_cofiltered_system.init F'\n  -- Step 3: interpret the results\n  use fun j => (u ‚ü®j‚ü©).down\n  intro j j' f\n  have h := @hu (‚ü®j‚ü© : J') (‚ü®j'‚ü© : J') (ULift.up f)\n  simp only [F', down, AsSmall.down, Functor.comp_map, uliftFunctor_map, Functor.op_map] at h\n  simp_rw [‚Üê h]\n\n"}
{"name":"nonempty_sections_of_finite_inverse_system","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬≥ : Preorder J\ninst‚úù¬≤ : IsDirected J fun x1 x2 => LE.le x1 x2\nF : CategoryTheory.Functor (Opposite J) (Type v)\ninst‚úù¬π : ‚àÄ (j : Opposite J), Finite (F.obj j)\ninst‚úù : ‚àÄ (j : Opposite J), Nonempty (F.obj j)\n‚ä¢ F.sections.Nonempty","decl":"/-- The inverse limit of nonempty finite types is nonempty.\n\nSee `nonempty_sections_of_finite_cofiltered_system` for a generalization to cofiltered limits.\nThat version applies in almost all cases, and the only difference is that this version\nallows `J` to be empty.\n\nThis may be regarded as a generalization of K≈ënig's lemma.\nTo specialize: given a locally finite connected graph, take `J·µí·µñ` to be `‚Ñï` and\n`F j` to be length-`j` paths that start from an arbitrary fixed vertex.\nElements of `F.sections` can be read off as infinite rays in the graph. -/\ntheorem nonempty_sections_of_finite_inverse_system {J : Type u} [Preorder J] [IsDirected J (¬∑ ‚â§ ¬∑)]\n    (F : J·µí·µñ ‚•§ Type v) [‚àÄ j : J·µí·µñ, Finite (F.obj j)] [‚àÄ j : J·µí·µñ, Nonempty (F.obj j)] :\n    F.sections.Nonempty := by\n  cases isEmpty_or_nonempty J\n  ¬∑ haveI : IsEmpty J·µí·µñ := ‚ü®fun j => isEmptyElim j.unop‚ü© -- TODO: this should be a global instance\n    exact ‚ü®isEmptyElim, by apply isEmptyElim‚ü©\n  ¬∑ exact nonempty_sections_of_finite_cofiltered_system _\n\n"}
{"name":"CategoryTheory.Functor.mem_eventualRange_iff","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\nj : J\nx : F.obj j\n‚ä¢ Iff (Membership.mem (F.eventualRange j) x) (‚àÄ ‚¶Éi : J‚¶Ñ (f : Quiver.Hom i j), Membership.mem (Set.range (F.map f)) x)","decl":"theorem mem_eventualRange_iff {x : F.obj j} :\n    x ‚àà F.eventualRange j ‚Üî ‚àÄ ‚¶Éi‚¶Ñ (f : i ‚ü∂ j), x ‚àà range (F.map f) :=\n  mem_iInter‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.isMittagLeffler_iff_eventualRange","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\n‚ä¢ Iff F.IsMittagLeffler (‚àÄ (j : J), Exists fun i => Exists fun f => Eq (F.eventualRange j) (Set.range (F.map f)))","decl":"theorem isMittagLeffler_iff_eventualRange :\n    F.IsMittagLeffler ‚Üî ‚àÄ j : J, ‚àÉ (i : _) (f : i ‚ü∂ j), F.eventualRange j = range (F.map f) :=\n  forall_congr' fun _ =>\n    exists‚ÇÇ_congr fun _ _ =>\n      ‚ü®fun h => (iInter‚ÇÇ_subset _ _).antisymm <| subset_iInter‚ÇÇ h, fun h => h ‚ñ∏ iInter‚ÇÇ_subset‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsMittagLeffler.subset_image_eventualRange","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni j : J\nh : F.IsMittagLeffler\nf : Quiver.Hom j i\n‚ä¢ HasSubset.Subset (F.eventualRange i) (Set.image (F.map f) (F.eventualRange j))","decl":"theorem IsMittagLeffler.subset_image_eventualRange (h : F.IsMittagLeffler) (f : j ‚ü∂ i) :\n    F.eventualRange i ‚äÜ F.map f '' F.eventualRange j := by\n  obtain ‚ü®k, g, hg‚ü© := F.isMittagLeffler_iff_eventualRange.1 h j\n  rw [hg]; intro x hx\n  obtain ‚ü®x, rfl‚ü© := F.mem_eventualRange_iff.1 hx (g ‚â´ f)\n  exact ‚ü®_, ‚ü®x, rfl‚ü©, by rw [map_comp_apply]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.eventualRange_eq_range_precomp","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni j k : J\nf : Quiver.Hom i j\ng : Quiver.Hom j k\nh : Eq (F.eventualRange k) (Set.range (F.map g))\n‚ä¢ Eq (F.eventualRange k) (Set.range (F.map (CategoryTheory.CategoryStruct.comp f g)))","decl":"theorem eventualRange_eq_range_precomp (f : i ‚ü∂ j) (g : j ‚ü∂ k)\n    (h : F.eventualRange k = range (F.map g)) : F.eventualRange k = range (F.map <| f ‚â´ g) := by\n  apply subset_antisymm\n  ¬∑ apply iInter‚ÇÇ_subset\n  ¬∑ rw [h, F.map_comp]\n    apply range_comp_subset_range\n\n"}
{"name":"CategoryTheory.Functor.isMittagLeffler_of_surjective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\nh : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : Quiver.Hom i j), Function.Surjective (F.map f)\n‚ä¢ F.IsMittagLeffler","decl":"theorem isMittagLeffler_of_surjective (h : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : i ‚ü∂ j), (F.map f).Surjective) :\n    F.IsMittagLeffler :=\n  fun j => ‚ü®j, ùüô j, fun k g => by rw [map_id, types_id, range_id, (h g).range_eq]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.toPreimages_map","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni : J\ns : Set (F.obj i)\nX‚úù Y‚úù : J\ng : Quiver.Hom X‚úù Y‚úù\na‚úù : ‚Üë(Set.iInter fun f => Set.preimage (F.map f) s)\n‚ä¢ Eq ((F.toPreimages s).map g a‚úù) (Set.MapsTo.restrict (F.map g) (Set.iInter fun f => Set.preimage (F.map f) s) (Set.iInter fun f => Set.preimage (F.map f) s) ‚ãØ a‚úù)","decl":"/-- The subfunctor of `F` obtained by restricting to the preimages of a set `s ‚àà F.obj i`. -/\n@[simps]\ndef toPreimages : J ‚•§ Type v where\n  obj j := ‚ãÇ f : j ‚ü∂ i, F.map f ‚Åª¬π' s\n  map g := MapsTo.restrict (F.map g) _ _ fun x h => by\n    rw [mem_iInter] at h ‚ä¢\n    intro f\n    rw [‚Üê mem_preimage, preimage_preimage, mem_preimage]\n    convert h (g ‚â´ f); rw [F.map_comp]; rfl\n  map_id j := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp f g := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.toPreimages_obj","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni : J\ns : Set (F.obj i)\nj : J\n‚ä¢ Eq ((F.toPreimages s).obj j) ‚Üë(Set.iInter fun f => Set.preimage (F.map f) s)","decl":"/-- The subfunctor of `F` obtained by restricting to the preimages of a set `s ‚àà F.obj i`. -/\n@[simps]\ndef toPreimages : J ‚•§ Type v where\n  obj j := ‚ãÇ f : j ‚ü∂ i, F.map f ‚Åª¬π' s\n  map g := MapsTo.restrict (F.map g) _ _ fun x h => by\n    rw [mem_iInter] at h ‚ä¢\n    intro f\n    rw [‚Üê mem_preimage, preimage_preimage, mem_preimage]\n    convert h (g ‚â´ f); rw [F.map_comp]; rfl\n  map_id j := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp f g := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.toPreimages_finite","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni : J\ns : Set (F.obj i)\ninst‚úù : ‚àÄ (j : J), Finite (F.obj j)\nj : J\n‚ä¢ Finite ((F.toPreimages s).obj j)","decl":"instance toPreimages_finite [‚àÄ j, Finite (F.obj j)] : ‚àÄ j, Finite ((F.toPreimages s).obj j) :=\n  fun _ => Subtype.finite\n\n"}
{"name":"CategoryTheory.Functor.eventualRange_mapsTo","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni j : J\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nf : Quiver.Hom j i\n‚ä¢ Set.MapsTo (F.map f) (F.eventualRange j) (F.eventualRange i)","decl":"theorem eventualRange_mapsTo (f : j ‚ü∂ i) :\n    (F.eventualRange j).MapsTo (F.map f) (F.eventualRange i) := fun x hx => by\n  rw [mem_eventualRange_iff] at hx ‚ä¢\n  intro k f'\n  obtain ‚ü®l, g, g', he‚ü© := cospan f f'\n  obtain ‚ü®x, rfl‚ü© := hx g\n  rw [‚Üê map_comp_apply, he, F.map_comp]\n  exact ‚ü®_, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsMittagLeffler.eq_image_eventualRange","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni j : J\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nh : F.IsMittagLeffler\nf : Quiver.Hom j i\n‚ä¢ Eq (F.eventualRange i) (Set.image (F.map f) (F.eventualRange j))","decl":"theorem IsMittagLeffler.eq_image_eventualRange (h : F.IsMittagLeffler) (f : j ‚ü∂ i) :\n    F.eventualRange i = F.map f '' F.eventualRange j :=\n  (h.subset_image_eventualRange F f).antisymm <| mapsTo'.1 (F.eventualRange_mapsTo f)\n\n"}
{"name":"CategoryTheory.Functor.eventualRange_eq_iff","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni j : J\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nf : Quiver.Hom i j\n‚ä¢ Iff (Eq (F.eventualRange j) (Set.range (F.map f))) (‚àÄ ‚¶Ék : J‚¶Ñ (g : Quiver.Hom k i), HasSubset.Subset (Set.range (F.map f)) (Set.range (F.map (CategoryTheory.CategoryStruct.comp g f))))","decl":"theorem eventualRange_eq_iff {f : i ‚ü∂ j} :\n    F.eventualRange j = range (F.map f) ‚Üî\n      ‚àÄ ‚¶Ék‚¶Ñ (g : k ‚ü∂ i), range (F.map f) ‚äÜ range (F.map <| g ‚â´ f) := by\n  rw [subset_antisymm_iff, eventualRange, and_iff_right (iInter‚ÇÇ_subset _ _), subset_iInter‚ÇÇ_iff]\n  refine ‚ü®fun h k g => h _ _, fun h j' f' => ?_‚ü©\n  obtain ‚ü®k, g, g', he‚ü© := cospan f f'\n  refine (h g).trans ?_\n  rw [he, F.map_comp]\n  apply range_comp_subset_range\n\n"}
{"name":"CategoryTheory.Functor.isMittagLeffler_iff_subset_range_comp","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\n‚ä¢ Iff F.IsMittagLeffler (‚àÄ (j : J), Exists fun i => Exists fun f => ‚àÄ ‚¶Ék : J‚¶Ñ (g : Quiver.Hom k i), HasSubset.Subset (Set.range (F.map f)) (Set.range (F.map (CategoryTheory.CategoryStruct.comp g f))))","decl":"theorem isMittagLeffler_iff_subset_range_comp : F.IsMittagLeffler ‚Üî ‚àÄ j : J, ‚àÉ (i : _) (f : i ‚ü∂ j),\n    ‚àÄ ‚¶Ék‚¶Ñ (g : k ‚ü∂ i), range (F.map f) ‚äÜ range (F.map <| g ‚â´ f) := by\n  simp_rw [isMittagLeffler_iff_eventualRange, eventualRange_eq_iff]\n\n"}
{"name":"CategoryTheory.Functor.IsMittagLeffler.toPreimages","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni : J\ns : Set (F.obj i)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nh : F.IsMittagLeffler\n‚ä¢ (F.toPreimages s).IsMittagLeffler","decl":"theorem IsMittagLeffler.toPreimages (h : F.IsMittagLeffler) : (F.toPreimages s).IsMittagLeffler :=\n  (isMittagLeffler_iff_subset_range_comp _).2 fun j => by\n    obtain ‚ü®j‚ÇÅ, g‚ÇÅ, f‚ÇÅ, -‚ü© := IsCofilteredOrEmpty.cone_objs i j\n    obtain ‚ü®j‚ÇÇ, f‚ÇÇ, h‚ÇÇ‚ü© := F.isMittagLeffler_iff_eventualRange.1 h j‚ÇÅ\n    refine ‚ü®j‚ÇÇ, f‚ÇÇ ‚â´ f‚ÇÅ, fun j‚ÇÉ f‚ÇÉ => ?_‚ü©\n    rintro _ ‚ü®‚ü®x, hx‚ü©, rfl‚ü©\n    have : F.map f‚ÇÇ x ‚àà F.eventualRange j‚ÇÅ := by\n      rw [h‚ÇÇ]\n      exact ‚ü®_, rfl‚ü©\n    obtain ‚ü®y, hy, h‚ÇÉ‚ü© := h.subset_image_eventualRange F (f‚ÇÉ ‚â´ f‚ÇÇ) this\n    refine ‚ü®‚ü®y, mem_iInter.2 fun g‚ÇÇ => ?_‚ü©, Subtype.ext ?_‚ü©\n    ¬∑ obtain ‚ü®j‚ÇÑ, f‚ÇÑ, h‚ÇÑ‚ü© := IsCofilteredOrEmpty.cone_maps g‚ÇÇ ((f‚ÇÉ ‚â´ f‚ÇÇ) ‚â´ g‚ÇÅ)\n      obtain ‚ü®y, rfl‚ü© := F.mem_eventualRange_iff.1 hy f‚ÇÑ\n      rw [‚Üê map_comp_apply] at h‚ÇÉ\n      rw [mem_preimage, ‚Üê map_comp_apply, h‚ÇÑ, ‚Üê Category.assoc, map_comp_apply, h‚ÇÉ,\n        ‚Üê map_comp_apply]\n      apply mem_iInter.1 hx\n    ¬∑ simp_rw [toPreimages_map, MapsTo.val_restrict_apply]\n      rw [‚Üê Category.assoc, map_comp_apply, h‚ÇÉ, map_comp_apply]\n\n"}
{"name":"CategoryTheory.Functor.isMittagLeffler_of_exists_finite_range","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nh : ‚àÄ (j : J), Exists fun i => Exists fun f => (Set.range (F.map f)).Finite\n‚ä¢ F.IsMittagLeffler","decl":"theorem isMittagLeffler_of_exists_finite_range\n    (h : ‚àÄ j : J, ‚àÉ (i : _) (f : i ‚ü∂ j), (range <| F.map f).Finite) : F.IsMittagLeffler := by\n  intro j\n  obtain ‚ü®i, hi, hf‚ü© := h j\n  obtain ‚ü®m, ‚ü®i, f, hm‚ü©, hmin‚ü© := Finset.wellFoundedLT.wf.has_min\n    { s : Finset (F.obj j) | ‚àÉ (i : _) (f : i ‚ü∂ j), ‚Üës = range (F.map f) }\n    ‚ü®_, i, hi, hf.coe_toFinset‚ü©\n  refine ‚ü®i, f, fun k g =>\n    (directedOn_range.mp <| F.ranges_directed j).is_bot_of_is_min ‚ü®‚ü®i, f‚ü©, rfl‚ü© ?_ _ ‚ü®‚ü®k, g‚ü©, rfl‚ü©‚ü©\n  rintro _ ‚ü®‚ü®k', g'‚ü©, rfl‚ü© hl\n  refine (eq_of_le_of_not_lt hl ?_).ge\n  have := hmin _ ‚ü®k', g', (m.finite_toSet.subset <| hm.substr hl).coe_toFinset‚ü©\n  rwa [Finset.lt_iff_ssubset, ‚Üê Finset.coe_ssubset, Set.Finite.coe_toFinset, hm] at this\n\n"}
{"name":"CategoryTheory.Functor.toEventualRanges_obj","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nj : J\n‚ä¢ Eq (F.toEventualRanges.obj j) ‚Üë(F.eventualRange j)","decl":"/-- The subfunctor of `F` obtained by restricting to the eventual range at each index. -/\n@[simps]\ndef toEventualRanges : J ‚•§ Type v where\n  obj j := F.eventualRange j\n  map f := (F.eventualRange_mapsTo f).restrict _ _ _\n  map_id i := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp _ _ := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.toEventualRanges_map","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nX‚úù Y‚úù : J\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : ‚Üë(F.eventualRange X‚úù)\n‚ä¢ Eq (F.toEventualRanges.map f a‚úù) (Set.MapsTo.restrict (F.map f) (F.eventualRange X‚úù) (F.eventualRange Y‚úù) ‚ãØ a‚úù)","decl":"/-- The subfunctor of `F` obtained by restricting to the eventual range at each index. -/\n@[simps]\ndef toEventualRanges : J ‚•§ Type v where\n  obj j := F.eventualRange j\n  map f := (F.eventualRange_mapsTo f).restrict _ _ _\n  map_id i := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp _ _ := by\n    simp +unfoldPartialApp only [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.toEventualRanges_finite","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù¬π : CategoryTheory.IsCofilteredOrEmpty J\ninst‚úù : ‚àÄ (j : J), Finite (F.obj j)\nj : J\n‚ä¢ Finite (F.toEventualRanges.obj j)","decl":"instance toEventualRanges_finite [‚àÄ j, Finite (F.obj j)] : ‚àÄ j, Finite (F.toEventualRanges.obj j) :=\n  fun _ => Subtype.finite\n\n"}
{"name":"CategoryTheory.Functor.surjective_toEventualRanges","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nh : F.IsMittagLeffler\ni j : J\nf : Quiver.Hom i j\n‚ä¢ Function.Surjective (F.toEventualRanges.map f)","decl":"/-- If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a\nsurjective functor. -/\ntheorem surjective_toEventualRanges (h : F.IsMittagLeffler) ‚¶Éi j‚¶Ñ (f : i ‚ü∂ j) :\n    (F.toEventualRanges.map f).Surjective := fun ‚ü®x, hx‚ü© => by\n  obtain ‚ü®y, hy, rfl‚ü© := h.subset_image_eventualRange F f hx\n  exact ‚ü®‚ü®y, hy‚ü©, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Functor.toEventualRanges_nonempty","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù¬π : CategoryTheory.IsCofilteredOrEmpty J\nh : F.IsMittagLeffler\ninst‚úù : ‚àÄ (j : J), Nonempty (F.obj j)\nj : J\n‚ä¢ Nonempty (F.toEventualRanges.obj j)","decl":"/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.toEventualRanges`. -/\ntheorem toEventualRanges_nonempty (h : F.IsMittagLeffler) [‚àÄ j : J, Nonempty (F.obj j)] (j : J) :\n    Nonempty (F.toEventualRanges.obj j) := by\n  let ‚ü®i, f, h‚ü© := F.isMittagLeffler_iff_eventualRange.1 h j\n  rw [toEventualRanges_obj, h]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.thin_diagram_of_surjective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nFsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : Quiver.Hom i j), Function.Surjective (F.map f)\ni j : J\nf g : Quiver.Hom i j\n‚ä¢ Eq (F.map f) (F.map g)","decl":"/-- If `F` has all arrows surjective, then it \"factors through a poset\". -/\ntheorem thin_diagram_of_surjective (Fsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : i ‚ü∂ j), (F.map f).Surjective) {i j}\n    (f g : i ‚ü∂ j) : F.map f = F.map g :=\n  let ‚ü®k, œÜ, hœÜ‚ü© := IsCofilteredOrEmpty.cone_maps f g\n  (Fsur œÜ).injective_comp_right <| by simp_rw [‚Üê types_comp, ‚Üê F.map_comp, hœÜ]\n\n"}
{"name":"CategoryTheory.Functor.toPreimages_nonempty_of_surjective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ni : J\ns : Set (F.obj i)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nhFn : ‚àÄ (j : J), Nonempty (F.obj j)\nFsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : Quiver.Hom i j), Function.Surjective (F.map f)\nhs : s.Nonempty\nj : J\n‚ä¢ Nonempty ((F.toPreimages s).obj j)","decl":"theorem toPreimages_nonempty_of_surjective [hFn : ‚àÄ j : J, Nonempty (F.obj j)]\n    (Fsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : i ‚ü∂ j), (F.map f).Surjective) (hs : s.Nonempty) (j) :\n    Nonempty ((F.toPreimages s).obj j) := by\n  simp only [toPreimages_obj, nonempty_coe_sort, nonempty_iInter, mem_preimage]\n  obtain h | ‚ü®‚ü®ji‚ü©‚ü© := isEmpty_or_nonempty (j ‚ü∂ i)\n  ¬∑ exact ‚ü®(hFn j).some, fun ji => h.elim ji‚ü©\n  ¬∑ obtain ‚ü®y, ys‚ü© := hs\n    obtain ‚ü®x, rfl‚ü© := Fsur ji y\n    exact ‚ü®x, fun ji' => (F.thin_diagram_of_surjective Fsur ji' ji).symm ‚ñ∏ ys‚ü©\n\n"}
{"name":"CategoryTheory.Functor.eval_section_injective_of_eventually_injective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬π : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù : CategoryTheory.IsCofilteredOrEmpty J\nj : J\nFinj : ‚àÄ (i : J) (f : Quiver.Hom i j), Function.Injective (F.map f)\ni : J\nf : Quiver.Hom i j\n‚ä¢ Function.Injective fun s => ‚Üës j","decl":"theorem eval_section_injective_of_eventually_injective {j}\n    (Finj : ‚àÄ (i) (f : i ‚ü∂ j), (F.map f).Injective) (i) (f : i ‚ü∂ j) :\n    (fun s : F.sections => s.val j).Injective := by\n  refine fun s‚ÇÄ s‚ÇÅ h => Subtype.ext <| funext fun k => ?_\n  obtain ‚ü®m, mi, mk, _‚ü© := IsCofilteredOrEmpty.cone_objs i k\n  dsimp at h\n  rw [‚Üê s‚ÇÄ.prop (mi ‚â´ f), ‚Üê s‚ÇÅ.prop (mi ‚â´ f)] at h\n  rw [‚Üê s‚ÇÄ.prop mk, ‚Üê s‚ÇÅ.prop mk]\n  exact congr_arg _ (Finj m (mi ‚â´ f) h)\n\n"}
{"name":"CategoryTheory.Functor.eval_section_surjective_of_surjective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù¬≤ : CategoryTheory.IsCofilteredOrEmpty J\ninst‚úù¬π : ‚àÄ (j : J), Nonempty (F.obj j)\ninst‚úù : ‚àÄ (j : J), Finite (F.obj j)\nFsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : Quiver.Hom i j), Function.Surjective (F.map f)\ni : J\n‚ä¢ Function.Surjective fun s => ‚Üës i","decl":"theorem eval_section_surjective_of_surjective (i : J) :\n    (fun s : F.sections => s.val i).Surjective := fun x => by\n  let s : Set (F.obj i) := {x}\n  haveI := F.toPreimages_nonempty_of_surjective s Fsur (singleton_nonempty x)\n  obtain ‚ü®sec, h‚ü© := nonempty_sections_of_finite_cofiltered_system (F.toPreimages s)\n  refine ‚ü®‚ü®fun j => (sec j).val, fun jk => by simpa [Subtype.ext_iff] using h jk‚ü©, ?_‚ü©\n  ¬∑ have := (sec i).prop\n    simp only [mem_iInter, mem_preimage, mem_singleton_iff] at this\n    have := this (ùüô i)\n    rwa [map_id_apply] at this\n\n"}
{"name":"CategoryTheory.Functor.eventually_injective","module":"Mathlib.CategoryTheory.CofilteredSystem","initialProofState":"J : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{u_1, u} J\nF : CategoryTheory.Functor J (Type v)\ninst‚úù‚Å¥ : CategoryTheory.IsCofilteredOrEmpty J\ninst‚úù¬≥ : ‚àÄ (j : J), Nonempty (F.obj j)\ninst‚úù¬≤ : ‚àÄ (j : J), Finite (F.obj j)\nFsur : ‚àÄ ‚¶Éi j : J‚¶Ñ (f : Quiver.Hom i j), Function.Surjective (F.map f)\ninst‚úù¬π : Nonempty J\ninst‚úù : Finite ‚ÜëF.sections\n‚ä¢ Exists fun j => ‚àÄ (i : J) (f : Quiver.Hom i j), Function.Injective (F.map f)","decl":"theorem eventually_injective [Nonempty J] [Finite F.sections] :\n    ‚àÉ j, ‚àÄ (i) (f : i ‚ü∂ j), (F.map f).Injective := by\n  haveI : ‚àÄ j, Fintype (F.obj j) := fun j => Fintype.ofFinite (F.obj j)\n  haveI : Fintype F.sections := Fintype.ofFinite F.sections\n  have card_le : ‚àÄ j, Fintype.card (F.obj j) ‚â§ Fintype.card F.sections :=\n    fun j => Fintype.card_le_of_surjective _ (F.eval_section_surjective_of_surjective Fsur j)\n  let fn j := Fintype.card F.sections - Fintype.card (F.obj j)\n  refine ‚ü®fn.argmin,\n    fun i f => ((Fintype.bijective_iff_surjective_and_card _).2\n      ‚ü®Fsur f, le_antisymm ?_ (Fintype.card_le_of_surjective _ <| Fsur f)‚ü©).1‚ü©\n  rw [‚Üê Nat.sub_le_sub_iff_left (card_le i)]\n  apply fn.argmin_le\n\n"}
