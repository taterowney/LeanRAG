{"name":"ZMod.euler_criterion_units","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : Units (ZMod p)\n⊢ Iff (Exists fun y => Eq (HPow.hPow y 2) x) (Eq (HPow.hPow x (HDiv.hDiv p 2)) 1)","decl":"/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem euler_criterion_units (x : (ZMod p)ˣ) : (∃ y : (ZMod p)ˣ, y ^ 2 = x) ↔ x ^ (p / 2) = 1 := by\n  by_cases hc : p = 2\n  · subst hc\n    simp only [eq_iff_true_of_subsingleton, exists_const]\n  · have h₀ := FiniteField.unit_isSquare_iff (by rwa [ringChar_zmod_n]) x\n    have hs : (∃ y : (ZMod p)ˣ, y ^ 2 = x) ↔ IsSquare x := by\n      rw [isSquare_iff_exists_sq x]\n      simp_rw [eq_comm]\n    rw [hs]\n    rwa [card p] at h₀\n\n"}
{"name":"ZMod.euler_criterion","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : ZMod p\nha : Ne a 0\n⊢ Iff (IsSquare a) (Eq (HPow.hPow a (HDiv.hDiv p 2)) 1)","decl":"/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem euler_criterion {a : ZMod p} (ha : a ≠ 0) : IsSquare (a : ZMod p) ↔ a ^ (p / 2) = 1 := by\n  apply (iff_congr _ (by simp [Units.ext_iff])).mp (euler_criterion_units p (Units.mk0 a ha))\n  simp only [Units.ext_iff, sq, Units.val_mk0, Units.val_mul]\n  constructor\n  · rintro ⟨y, hy⟩; exact ⟨y, hy.symm⟩\n  · rintro ⟨y, rfl⟩\n    have hy : y ≠ 0 := by\n      rintro rfl\n      simp [zero_pow, mul_zero, ne_eq, not_true] at ha\n    refine ⟨Units.mk0 y hy, ?_⟩; simp\n\n"}
{"name":"ZMod.pow_div_two_eq_neg_one_or_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : ZMod p\nha : Ne a 0\n⊢ Or (Eq (HPow.hPow a (HDiv.hDiv p 2)) 1) (Eq (HPow.hPow a (HDiv.hDiv p 2)) (-1))","decl":"/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem pow_div_two_eq_neg_one_or_one {a : ZMod p} (ha : a ≠ 0) :\n    a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1 := by\n  cases' Prime.eq_two_or_odd (@Fact.out p.Prime _) with hp2 hp_odd\n  · subst p; revert a ha; intro a; fin_cases a\n    · tauto\n    · simp\n  rw [← mul_self_eq_one_iff, ← pow_add, ← two_mul, two_mul_odd_div_two hp_odd]\n  exact pow_card_sub_one_eq_one ha\n\n"}
{"name":"legendreSym.eq_pow","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\n⊢ Eq (↑(legendreSym p a)) (HPow.hPow (↑a) (HDiv.hDiv p 2))","decl":"/-- We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. -/\ntheorem eq_pow (a : ℤ) : (legendreSym p a : ZMod p) = (a : ZMod p) ^ (p / 2) := by\n  rcases eq_or_ne (ringChar (ZMod p)) 2 with hc | hc\n  · by_cases ha : (a : ZMod p) = 0\n    · rw [legendreSym, ha, quadraticChar_zero,\n        zero_pow (Nat.div_pos (@Fact.out p.Prime).two_le (succ_pos 1)).ne']\n      norm_cast\n    · have := (ringChar_zmod_n p).symm.trans hc\n      -- p = 2\n      subst p\n      rw [legendreSym, quadraticChar_eq_one_of_char_two hc ha]\n      revert ha\n      push_cast\n      generalize (a : ZMod 2) = b; fin_cases b\n      · tauto\n      · simp\n  · convert quadraticChar_eq_pow_of_char_ne_two' hc (a : ZMod p)\n    exact (card p).symm\n\n"}
{"name":"legendreSym.eq_one_or_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\n⊢ Or (Eq (legendreSym p a) 1) (Eq (legendreSym p a) (-1))","decl":"/-- If `p ∤ a`, then `legendreSym p a` is `1` or `-1`. -/\ntheorem eq_one_or_neg_one {a : ℤ} (ha : (a : ZMod p) ≠ 0) :\n    legendreSym p a = 1 ∨ legendreSym p a = -1 :=\n  quadraticChar_dichotomy ha\n\n"}
{"name":"legendreSym.eq_neg_one_iff_not_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\n⊢ Iff (Eq (legendreSym p a) (-1)) (Not (Eq (legendreSym p a) 1))","decl":"theorem eq_neg_one_iff_not_one {a : ℤ} (ha : (a : ZMod p) ≠ 0) :\n    legendreSym p a = -1 ↔ ¬legendreSym p a = 1 :=\n  quadraticChar_eq_neg_one_iff_not_one ha\n\n"}
{"name":"legendreSym.eq_zero_iff","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\n⊢ Iff (Eq (legendreSym p a) 0) (Eq (↑a) 0)","decl":"/-- The Legendre symbol of `p` and `a` is zero iff `p ∣ a`. -/\ntheorem eq_zero_iff (a : ℤ) : legendreSym p a = 0 ↔ (a : ZMod p) = 0 :=\n  quadraticChar_eq_zero_iff\n\n"}
{"name":"legendreSym.at_zero","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (legendreSym p 0) 0","decl":"@[simp]\ntheorem at_zero : legendreSym p 0 = 0 := by rw [legendreSym, Int.cast_zero, MulChar.map_zero]\n\n"}
{"name":"legendreSym.at_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (legendreSym p 1) 1","decl":"@[simp]\ntheorem at_one : legendreSym p 1 = 1 := by rw [legendreSym, Int.cast_one, MulChar.map_one]\n\n"}
{"name":"legendreSym.mul","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na b : Int\n⊢ Eq (legendreSym p (HMul.hMul a b)) (HMul.hMul (legendreSym p a) (legendreSym p b))","decl":"/-- The Legendre symbol is multiplicative in `a` for `p` fixed. -/\nprotected theorem mul (a b : ℤ) : legendreSym p (a * b) = legendreSym p a * legendreSym p b := by\n  simp [legendreSym, Int.cast_mul, map_mul, quadraticCharFun_mul]\n\n"}
{"name":"legendreSym.hom_apply","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\n⊢ Eq ((legendreSym.hom p) a) (legendreSym p a)","decl":"/-- The Legendre symbol is a homomorphism of monoids with zero. -/\n@[simps]\ndef hom : ℤ →*₀ ℤ where\n  toFun := legendreSym p\n  map_zero' := at_zero p\n  map_one' := at_one p\n  map_mul' := legendreSym.mul p\n\n"}
{"name":"legendreSym.sq_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\n⊢ Eq (HPow.hPow (legendreSym p a) 2) 1","decl":"/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem sq_one {a : ℤ} (ha : (a : ZMod p) ≠ 0) : legendreSym p a ^ 2 = 1 :=\n  quadraticChar_sq_one ha\n\n"}
{"name":"legendreSym.sq_one'","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\n⊢ Eq (legendreSym p (HPow.hPow a 2)) 1","decl":"/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem sq_one' {a : ℤ} (ha : (a : ZMod p) ≠ 0) : legendreSym p (a ^ 2) = 1 := by\n  dsimp only [legendreSym]\n  rw [Int.cast_pow]\n  exact quadraticChar_sq_one' ha\n\n"}
{"name":"legendreSym.mod","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\n⊢ Eq (legendreSym p a) (legendreSym p (HMod.hMod a ↑p))","decl":"/-- The Legendre symbol depends only on `a` mod `p`. -/\nprotected theorem mod (a : ℤ) : legendreSym p a = legendreSym p (a % p) := by\n  simp only [legendreSym, intCast_mod]\n\n"}
{"name":"legendreSym.eq_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha0 : Ne (↑a) 0\n⊢ Iff (Eq (legendreSym p a) 1) (IsSquare ↑a)","decl":"/-- When `p ∤ a`, then `legendreSym p a = 1` iff `a` is a square mod `p`. -/\ntheorem eq_one_iff {a : ℤ} (ha0 : (a : ZMod p) ≠ 0) : legendreSym p a = 1 ↔ IsSquare (a : ZMod p) :=\n  quadraticChar_one_iff_isSquare ha0\n\n"}
{"name":"legendreSym.eq_one_iff'","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\nha0 : Ne (↑a) 0\n⊢ Iff (Eq (legendreSym p ↑a) 1) (IsSquare ↑a)","decl":"theorem eq_one_iff' {a : ℕ} (ha0 : (a : ZMod p) ≠ 0) :\n    legendreSym p a = 1 ↔ IsSquare (a : ZMod p) := by\n      rw [eq_one_iff]\n      · norm_cast\n      · exact mod_cast ha0\n\n"}
{"name":"legendreSym.eq_neg_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\n⊢ Iff (Eq (legendreSym p a) (-1)) (Not (IsSquare ↑a))","decl":"/-- `legendreSym p a = -1` iff `a` is a nonsquare mod `p`. -/\ntheorem eq_neg_one_iff {a : ℤ} : legendreSym p a = -1 ↔ ¬IsSquare (a : ZMod p) :=\n  quadraticChar_neg_one_iff_not_isSquare\n\n"}
{"name":"legendreSym.eq_neg_one_iff'","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Nat\n⊢ Iff (Eq (legendreSym p ↑a) (-1)) (Not (IsSquare ↑a))","decl":"theorem eq_neg_one_iff' {a : ℕ} : legendreSym p a = -1 ↔ ¬IsSquare (a : ZMod p) := by\n  rw [eq_neg_one_iff]; norm_cast\n\n"}
{"name":"legendreSym.card_sqrts","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Ne p 2\na : Int\n⊢ Eq (↑(setOf fun x => Eq (HPow.hPow x 2) ↑a).toFinset.card) (HAdd.hAdd (legendreSym p a) 1)","decl":"/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem card_sqrts (hp : p ≠ 2) (a : ℤ) :\n    ↑{x : ZMod p | x ^ 2 = a}.toFinset.card = legendreSym p a + 1 :=\n  quadraticChar_card_sqrts ((ringChar_zmod_n p).substr hp) a\n\n"}
{"name":"legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\nx y : ZMod p\nhy : Ne y 0\nhxy : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul (↑a) (HPow.hPow y 2))) 0\n⊢ Eq (legendreSym p a) 1","decl":"/-- The Legendre symbol `legendreSym p a = 1` if there is a solution in `ℤ/pℤ`\nof the equation `x^2 - a*y^2 = 0` with `y ≠ 0`. -/\ntheorem eq_one_of_sq_sub_mul_sq_eq_zero {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0)\n    {x y : ZMod p} (hy : y ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 := by\n  apply_fun (· * y⁻¹ ^ 2) at hxy\n  simp only [zero_mul] at hxy\n  rw [(by ring : (x ^ 2 - ↑a * y ^ 2) * y⁻¹ ^ 2 = (x * y⁻¹) ^ 2 - a * (y * y⁻¹) ^ 2),\n    mul_inv_cancel₀ hy, one_pow, mul_one, sub_eq_zero, pow_two] at hxy\n  exact (eq_one_iff p ha).mpr ⟨x * y⁻¹, hxy.symm⟩\n\n"}
{"name":"legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero'","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nha : Ne (↑a) 0\nx y : ZMod p\nhx : Ne x 0\nhxy : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul (↑a) (HPow.hPow y 2))) 0\n⊢ Eq (legendreSym p a) 1","decl":"/-- The Legendre symbol `legendreSym p a = 1` if there is a solution in `ℤ/pℤ`\nof the equation `x^2 - a*y^2 = 0` with `x ≠ 0`. -/\ntheorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0)\n    {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 := by\n  haveI hy : y ≠ 0 := by\n    rintro rfl\n    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy\n    exact hx hxy\n  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy\n\n"}
{"name":"legendreSym.eq_zero_mod_of_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nh : Eq (legendreSym p a) (-1)\nx y : ZMod p\nhxy : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul (↑a) (HPow.hPow y 2))) 0\n⊢ And (Eq x 0) (Eq y 0)","decl":"/-- If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `ℤ/pℤ`\nis the trivial one. -/\ntheorem eq_zero_mod_of_eq_neg_one {p : ℕ} [Fact p.Prime] {a : ℤ} (h : legendreSym p a = -1)\n    {x y : ZMod p} (hxy : x ^ 2 - a * y ^ 2 = 0) : x = 0 ∧ y = 0 := by\n  have ha : (a : ZMod p) ≠ 0 := by\n    intro hf\n    rw [(eq_zero_iff p a).mpr hf] at h\n    simp at h\n  by_contra hf\n  cases' imp_iff_or_not.mp (not_and'.mp hf) with hx hy\n  · rw [eq_one_of_sq_sub_mul_sq_eq_zero' ha hx hxy, CharZero.eq_neg_self_iff] at h\n    exact one_ne_zero h\n  · rw [eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy, CharZero.eq_neg_self_iff] at h\n    exact one_ne_zero h\n\n"}
{"name":"legendreSym.prime_dvd_of_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nh : Eq (legendreSym p a) (-1)\nx y : Int\nhxy : Dvd.dvd (↑p) (HSub.hSub (HPow.hPow x 2) (HMul.hMul a (HPow.hPow y 2)))\n⊢ And (Dvd.dvd (↑p) x) (Dvd.dvd (↑p) y)","decl":"/-- If `legendreSym p a = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide `x` and `y`. -/\ntheorem prime_dvd_of_eq_neg_one {p : ℕ} [Fact p.Prime] {a : ℤ} (h : legendreSym p a = -1) {x y : ℤ}\n    (hxy : (p : ℤ) ∣ x ^ 2 - a * y ^ 2) : ↑p ∣ x ∧ ↑p ∣ y := by\n  simp_rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hxy ⊢\n  push_cast at hxy\n  exact eq_zero_mod_of_eq_neg_one h hxy\n\n"}
{"name":"legendreSym.at_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Ne p 2\n⊢ Eq (legendreSym p (-1)) (ZMod.χ₄ ↑p)","decl":"/-- `legendreSym p (-1)` is given by `χ₄ p`. -/\ntheorem legendreSym.at_neg_one (hp : p ≠ 2) : legendreSym p (-1) = χ₄ p := by\n  simp only [legendreSym, card p, quadraticChar_neg_one ((ringChar_zmod_n p).substr hp),\n    Int.cast_neg, Int.cast_one]\n\n"}
{"name":"ZMod.exists_sq_eq_neg_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Iff (IsSquare (-1)) (Ne (HMod.hMod p 4) 3)","decl":"/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem exists_sq_eq_neg_one_iff : IsSquare (-1 : ZMod p) ↔ p % 4 ≠ 3 := by\n  rw [FiniteField.isSquare_neg_one_iff, card p]\n\n"}
{"name":"ZMod.mod_four_ne_three_of_sq_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\ny : ZMod p\nhy : Eq (HPow.hPow y 2) (-1)\n⊢ Ne (HMod.hMod p 4) 3","decl":"theorem mod_four_ne_three_of_sq_eq_neg_one {y : ZMod p} (hy : y ^ 2 = -1) : p % 4 ≠ 3 :=\n  exists_sq_eq_neg_one_iff.1 ⟨y, hy ▸ pow_two y⟩\n\n"}
{"name":"ZMod.mod_four_ne_three_of_sq_eq_neg_sq'","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : ZMod p\nhy : Ne y 0\nhxy : Eq (HPow.hPow x 2) (Neg.neg (HPow.hPow y 2))\n⊢ Ne (HMod.hMod p 4) 3","decl":"/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. -/\ntheorem mod_four_ne_three_of_sq_eq_neg_sq' {x y : ZMod p} (hy : y ≠ 0) (hxy : x ^ 2 = -y ^ 2) :\n    p % 4 ≠ 3 :=\n  @mod_four_ne_three_of_sq_eq_neg_one p _ (x / y)\n    (by\n      apply_fun fun z => z / y ^ 2 at hxy\n      rwa [neg_div, ← div_pow, ← div_pow, div_self hy, one_pow] at hxy)\n\n"}
{"name":"ZMod.mod_four_ne_three_of_sq_eq_neg_sq","module":"Mathlib.NumberTheory.LegendreSymbol.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : ZMod p\nhx : Ne x 0\nhxy : Eq (HPow.hPow x 2) (Neg.neg (HPow.hPow y 2))\n⊢ Ne (HMod.hMod p 4) 3","decl":"theorem mod_four_ne_three_of_sq_eq_neg_sq {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 = -y ^ 2) :\n    p % 4 ≠ 3 :=\n  mod_four_ne_three_of_sq_eq_neg_sq' hx (neg_eq_iff_eq_neg.mpr hxy).symm\n\n"}
