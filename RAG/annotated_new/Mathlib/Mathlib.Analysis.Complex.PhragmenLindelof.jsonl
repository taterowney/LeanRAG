{"name":"PhragmenLindelof.isBigO_sub_exp_exp","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\na : Real\nf g : Complex ‚Üí E\nl : Filter Complex\nu : Complex ‚Üí Real\nhBf : Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO l f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs (u z))))))\nhBg : Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO l g fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs (u z))))))\n‚ä¢ Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO l (HSub.hSub f g) fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs (u z))))))","decl":"/-- An auxiliary lemma that combines two double exponential estimates into a similar estimate\non the difference of the functions. -/\ntheorem isBigO_sub_exp_exp {a : ‚Ñù} {f g : ‚ÑÇ ‚Üí E} {l : Filter ‚ÑÇ} {u : ‚ÑÇ ‚Üí ‚Ñù}\n    (hBf : ‚àÉ c < a, ‚àÉ B, f =O[l] fun z => expR (B * expR (c * |u z|)))\n    (hBg : ‚àÉ c < a, ‚àÉ B, g =O[l] fun z => expR (B * expR (c * |u z|))) :\n    ‚àÉ c < a, ‚àÉ B, (f - g) =O[l] fun z => expR (B * expR (c * |u z|)) := by\n  have : ‚àÄ {c‚ÇÅ c‚ÇÇ B‚ÇÅ B‚ÇÇ}, c‚ÇÅ ‚â§ c‚ÇÇ ‚Üí 0 ‚â§ B‚ÇÇ ‚Üí B‚ÇÅ ‚â§ B‚ÇÇ ‚Üí ‚àÄ z,\n      ‚ÄñexpR (B‚ÇÅ * expR (c‚ÇÅ * |u z|))‚Äñ ‚â§ ‚ÄñexpR (B‚ÇÇ * expR (c‚ÇÇ * |u z|))‚Äñ := fun hc hB‚ÇÄ hB z ‚Ü¶ by\n    simp only [Real.norm_eq_abs, Real.abs_exp]; gcongr\n  rcases hBf with ‚ü®cf, hcf, Bf, hOf‚ü©; rcases hBg with ‚ü®cg, hcg, Bg, hOg‚ü©\n  refine ‚ü®max cf cg, max_lt hcf hcg, max 0 (max Bf Bg), ?_‚ü©\n  refine (hOf.trans_le <| this ?_ ?_ ?_).sub (hOg.trans_le <| this ?_ ?_ ?_)\n  exacts [le_max_left _ _, le_max_left _ _, (le_max_left _ _).trans (le_max_right _ _),\n    le_max_right _ _, le_max_left _ _, (le_max_right _ _).trans (le_max_right _ _)]\n\n"}
{"name":"PhragmenLindelof.isBigO_sub_exp_rpow","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\na : Real\nf g : Complex ‚Üí E\nl : Filter Complex\nhBf : Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) l) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhBg : Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) l) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\n‚ä¢ Exists fun c => And (LT.lt c a) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) l) (HSub.hSub f g) fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))","decl":"/-- An auxiliary lemma that combines two ‚Äúexponential of a power‚Äù estimates into a similar estimate\non the difference of the functions. -/\ntheorem isBigO_sub_exp_rpow {a : ‚Ñù} {f g : ‚ÑÇ ‚Üí E} {l : Filter ‚ÑÇ}\n    (hBf : ‚àÉ c < a, ‚àÉ B, f =O[cobounded ‚ÑÇ ‚äì l] fun z => expR (B * abs z ^ c))\n    (hBg : ‚àÉ c < a, ‚àÉ B, g =O[cobounded ‚ÑÇ ‚äì l] fun z => expR (B * abs z ^ c)) :\n    ‚àÉ c < a, ‚àÉ B, (f - g) =O[cobounded ‚ÑÇ ‚äì l] fun z => expR (B * abs z ^ c) := by\n  have : ‚àÄ {c‚ÇÅ c‚ÇÇ B‚ÇÅ B‚ÇÇ : ‚Ñù}, c‚ÇÅ ‚â§ c‚ÇÇ ‚Üí 0 ‚â§ B‚ÇÇ ‚Üí B‚ÇÅ ‚â§ B‚ÇÇ ‚Üí\n      (fun z : ‚ÑÇ => expR (B‚ÇÅ * abs z ^ c‚ÇÅ)) =O[cobounded ‚ÑÇ ‚äì l]\n        fun z => expR (B‚ÇÇ * abs z ^ c‚ÇÇ) := fun hc hB‚ÇÄ hB ‚Ü¶ .of_norm_eventuallyLE <| by\n    filter_upwards [(eventually_cobounded_le_norm 1).filter_mono inf_le_left] with z hz\n    simp only [Real.norm_eq_abs, Real.abs_exp]\n    gcongr; assumption\n  rcases hBf with ‚ü®cf, hcf, Bf, hOf‚ü©; rcases hBg with ‚ü®cg, hcg, Bg, hOg‚ü©\n  refine ‚ü®max cf cg, max_lt hcf hcg, max 0 (max Bf Bg), ?_‚ü©\n  refine (hOf.trans <| this ?_ ?_ ?_).sub (hOg.trans <| this ?_ ?_ ?_)\n  exacts [le_max_left _ _, le_max_left _ _, (le_max_left _ _).trans (le_max_right _ _),\n    le_max_right _ _, le_max_left _ _, (le_max_right _ _).trans (le_max_right _ _)]\n\n"}
{"name":"PhragmenLindelof.horizontal_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b C : Real\nf : Complex ‚Üí E\nz : Complex\nhfd : DiffContOnCl Complex f (Set.preimage Complex.im (Set.Ioo a b))\nhB : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.re) Filter.atTop) (Filter.principal (Set.preimage Complex.im (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.re)))))\nhle_a : ‚àÄ (z : Complex), Eq z.im a ‚Üí LE.le (Norm.norm (f z)) C\nhle_b : ‚àÄ (z : Complex), Eq z.im b ‚Üí LE.le (Norm.norm (f z)) C\nhza : LE.le a z.im\nhzb : LE.le z.im b\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < im z < b}`.\nLet `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some `c < œÄ / (b - a)`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `‚Äñf z‚Äñ` is bounded by the same constant on the closed strip\n`{z : ‚ÑÇ | a ‚â§ im z ‚â§ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|re z|`.\n-/\ntheorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))\n    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))\n    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)\n    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C := by\n  -- If `im z = a` or `im z = b`, then we apply `hle_a` or `hle_b`, otherwise `im z ‚àà Ioo a b`.\n  rw [le_iff_eq_or_lt] at hza hzb\n  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm\n  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb\n  wlog hC‚ÇÄ : 0 < C generalizing C\n  ¬∑ refine le_of_forall_gt_imp_ge_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_\n    ¬∑ exact (hle_a _ hw).trans hC'.le\n    ¬∑ exact (hle_b _ hw).trans hC'.le\n    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'\n      rw [mul_I_im, ofReal_re]\n  -- After a change of variables, we deal with the strip `a - b < im z < a + b` instead\n  -- of `a < im z < b`\n  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=\n    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©\n  have hab : a - b < a + b := hza.trans hzb\n  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab\n  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB\n  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb\n  -- Choose some `c B : ‚Ñù` satisfying `hB`, then choose `max c 0 < d < œÄ / 2 / b`.\n  rcases hB with ‚ü®c, hc, B, hO‚ü©\n  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by\n    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)\n  have hb' : d * b < œÄ / 2 := (lt_div_iff‚ÇÄ hb).1 hd\n  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)\n  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))\n  /- Since `g Œµ z ‚Üí 1` as `Œµ ‚Üí 0‚Åª`, it suffices to prove that `‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C`\n    for all negative `Œµ`. -/\n  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by\n    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this\n    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'\n    simp\n  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ\n  -- An upper estimate on `‚Äñg Œµ w‚Äñ` that will be used in two branches of the proof.\n  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :\n    ‚àÉ Œ¥ : ‚Ñù,\n      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by\n    refine\n      ‚ü®Œµ * Real.cos (d * b),\n        mul_neg_of_neg_of_pos Œµ‚ÇÄ\n          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),\n        fun w hw => ?_‚ü©\n    replace hw : |im (aff w)| ‚â§ d * b := by\n      rw [‚Üê Real.closedBall_eq_Icc] at hw\n      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,\n        mul_le_mul_left hd‚ÇÄ]\n    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,\n      zero_mul, neg_zero, sub_zero] using\n      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le\n  -- `abs (g Œµ w) ‚â§ 1` on the lines `w.im = a ¬± b` (actually, it holds everywhere in the strip)\n  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by\n    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)\n    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,\n      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]\n  /- Our apriori estimate on `f` implies that `g Œµ w ‚Ä¢ f w ‚Üí 0` as `|w.re| ‚Üí ‚àû` along the strip. In\n    particular, its norm is less than or equal to `C` for sufficiently large `|w.re|`. -/\n  obtain ‚ü®R, hzR, hR‚ü© :\n    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by\n    refine ((eventually_gt_atTop _).and ?_).exists\n    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©\n    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,\n      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA\n    suffices\n        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by\n      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him\n      calc\n        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_\n        _ ‚â§ C := hR\n      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]\n      gcongr\n      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]\n    refine Real.tendsto_exp_atBot.comp ?_\n    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by\n      rw [mul_zero, add_zero] at H\n      refine Tendsto.atBot_add ?_ tendsto_const_nhds\n      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,\n        sub_sub_cancel]\n        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|\n          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id\n    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)\n    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|\n      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id\n  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR\n  /- Finally, we apply the bounded version of the maximum modulus principle to the rectangle\n    `(-R, R) √ó (a - b, a + b)`. The function is bounded by `C` on the horizontal sides by assumption\n    (and because `‚Äñg Œµ w‚Äñ ‚â§ 1`) and on the vertical sides by the choice of `R`. -/\n  have hgd : Differentiable ‚ÑÇ (g Œµ) :=\n    ((((differentiable_id.sub_const _).const_mul _).cexp.add\n            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp\n  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=\n    (hgd.diffContOnCl.smul hfd).mono inter_subset_right\n  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))\n    hd (fun w hw => _) _\n  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,\n      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw\n    by_cases him : w.im = a - b ‚à® w.im = a + b\n    ¬∑ rw [norm_smul, ‚Üê one_mul C]\n      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one\n    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2\n      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'\n      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)\n  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]\n    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_horizontal_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Set.preimage Complex.im (Set.Ioo a b))\nhB : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.re) Filter.atTop) (Filter.principal (Set.preimage Complex.im (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.re)))))\nha : ‚àÄ (z : Complex), Eq z.im a ‚Üí Eq (f z) 0\nhb : ‚àÄ (z : Complex), Eq z.im b ‚Üí Eq (f z) 0\n‚ä¢ Set.EqOn f 0 (Set.preimage Complex.im (Set.Icc a b))","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < im z < b}`.\nLet `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some `c < œÄ / (b - a)`;\n* `f z = 0` on the boundary of `U`.\n\nThen `f` is equal to zero on the closed strip `{z : ‚ÑÇ | a ‚â§ im z ‚â§ b}`.\n-/\ntheorem eq_zero_on_horizontal_strip (hd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))\n    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))\n    (ha : ‚àÄ z : ‚ÑÇ, z.im = a ‚Üí f z = 0) (hb : ‚àÄ z : ‚ÑÇ, z.im = b ‚Üí f z = 0) :\n    EqOn f 0 (im ‚Åª¬π' Icc a b) := fun _z hz =>\n  norm_le_zero_iff.1 <| horizontal_strip hd hB (fun z hz => (ha z hz).symm ‚ñ∏ norm_zero.le)\n    (fun z hz => (hb z hz).symm ‚ñ∏ norm_zero.le) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_horizontal_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Set.preimage Complex.im (Set.Ioo a b))\nhBf : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.re) Filter.atTop) (Filter.principal (Set.preimage Complex.im (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.re)))))\nhdg : DiffContOnCl Complex g (Set.preimage Complex.im (Set.Ioo a b))\nhBg : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.re) Filter.atTop) (Filter.principal (Set.preimage Complex.im (Set.Ioo a b)))) g fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.re)))))\nha : ‚àÄ (z : Complex), Eq z.im a ‚Üí Eq (f z) (g z)\nhb : ‚àÄ (z : Complex), Eq z.im b ‚Üí Eq (f z) (g z)\n‚ä¢ Set.EqOn f g (Set.preimage Complex.im (Set.Icc a b))","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < im z < b}`.\nLet `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable on `U` and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * exp(c * |re z|))` on `U` for some\n  `c < œÄ / (b - a)`;\n* `f z = g z` on the boundary of `U`.\n\nThen `f` is equal to `g` on the closed strip `{z : ‚ÑÇ | a ‚â§ im z ‚â§ b}`.\n-/\ntheorem eqOn_horizontal_strip {g : ‚ÑÇ ‚Üí E} (hdf : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))\n    (hBf : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))\n    (hdg : DiffContOnCl ‚ÑÇ g (im ‚Åª¬π' Ioo a b))\n    (hBg : ‚àÉ c < œÄ / (b - a), ‚àÉ B, g =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))\n    (ha : ‚àÄ z : ‚ÑÇ, z.im = a ‚Üí f z = g z) (hb : ‚àÄ z : ‚ÑÇ, z.im = b ‚Üí f z = g z) :\n    EqOn f g (im ‚Åª¬π' Icc a b) := fun _z hz =>\n  sub_eq_zero.1 (eq_zero_on_horizontal_strip (hdf.sub hdg) (isBigO_sub_exp_exp hBf hBg)\n    (fun w hw => sub_eq_zero.2 (ha w hw)) (fun w hw => sub_eq_zero.2 (hb w hw)) hz)\n\n"}
{"name":"PhragmenLindelof.vertical_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b C : Real\nf : Complex ‚Üí E\nz : Complex\nhfd : DiffContOnCl Complex f (Set.preimage Complex.re (Set.Ioo a b))\nhB : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.im) Filter.atTop) (Filter.principal (Set.preimage Complex.re (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.im)))))\nhle_a : ‚àÄ (z : Complex), Eq z.re a ‚Üí LE.le (Norm.norm (f z)) C\nhle_b : ‚àÄ (z : Complex), Eq z.re b ‚Üí LE.le (Norm.norm (f z)) C\nhza : LE.le a z.re\nhzb : LE.le z.re b\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < re z < b}`.\nLet `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < œÄ / (b - a)`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `‚Äñf z‚Äñ` is bounded by the same constant on the closed strip\n`{z : ‚ÑÇ | a ‚â§ re z ‚â§ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|im z|`.\n-/\ntheorem vertical_strip (hfd : DiffContOnCl ‚ÑÇ f (re ‚Åª¬π' Ioo a b))\n    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò im) atTop ‚äì ùìü (re ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.im|)))\n    (hle_a : ‚àÄ z : ‚ÑÇ, re z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, re z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ re z)\n    (hzb : re z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C := by\n  suffices ‚Äñf (z * I * -I)‚Äñ ‚â§ C by simpa [mul_assoc] using this\n  have H : MapsTo (¬∑ * -I) (im ‚Åª¬π' Ioo a b) (re ‚Åª¬π' Ioo a b) := fun z hz ‚Ü¶ by simpa using hz\n  refine horizontal_strip (f := fun z ‚Ü¶ f (z * -I))\n    (hfd.comp (differentiable_id.mul_const _).diffContOnCl H) ?_ (fun z hz => hle_a _ ?_)\n    (fun z hz => hle_b _ ?_) ?_ ?_\n  ¬∑ rcases hB with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®c, hc, B, ?_‚ü©\n    have : Tendsto (¬∑ * -I) (comap (|re ¬∑|) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b))\n        (comap (|im ¬∑|) atTop ‚äì ùìü (re ‚Åª¬π' Ioo a b)) := by\n      refine (tendsto_comap_iff.2 ?_).inf H.tendsto\n      simpa [Function.comp_def] using tendsto_comap\n    simpa [Function.comp_def] using hO.comp_tendsto this\n  all_goals simpa\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_vertical_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Set.preimage Complex.re (Set.Ioo a b))\nhB : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.im) Filter.atTop) (Filter.principal (Set.preimage Complex.re (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.im)))))\nha : ‚àÄ (z : Complex), Eq z.re a ‚Üí Eq (f z) 0\nhb : ‚àÄ (z : Complex), Eq z.re b ‚Üí Eq (f z) 0\n‚ä¢ Set.EqOn f 0 (Set.preimage Complex.re (Set.Icc a b))","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < re z < b}`.\nLet `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < œÄ / (b - a)`;\n* `f z = 0` on the boundary of `U`.\n\nThen `f` is equal to zero on the closed strip `{z : ‚ÑÇ | a ‚â§ re z ‚â§ b}`.\n-/\ntheorem eq_zero_on_vertical_strip (hd : DiffContOnCl ‚ÑÇ f (re ‚Åª¬π' Ioo a b))\n    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò im) atTop ‚äì ùìü (re ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.im|)))\n    (ha : ‚àÄ z : ‚ÑÇ, re z = a ‚Üí f z = 0) (hb : ‚àÄ z : ‚ÑÇ, re z = b ‚Üí f z = 0) :\n    EqOn f 0 (re ‚Åª¬π' Icc a b) := fun _z hz =>\n  norm_le_zero_iff.1 <| vertical_strip hd hB (fun z hz => (ha z hz).symm ‚ñ∏ norm_zero.le)\n    (fun z hz => (hb z hz).symm ‚ñ∏ norm_zero.le) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_vertical_strip","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Set.preimage Complex.re (Set.Ioo a b))\nhBf : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.im) Filter.atTop) (Filter.principal (Set.preimage Complex.re (Set.Ioo a b)))) f fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.im)))))\nhdg : DiffContOnCl Complex g (Set.preimage Complex.re (Set.Ioo a b))\nhBg : Exists fun c => And (LT.lt c (HDiv.hDiv Real.pi (HSub.hSub b a))) (Exists fun B => Asymptotics.IsBigO (Min.min (Filter.comap (Function.comp abs Complex.im) Filter.atTop) (Filter.principal (Set.preimage Complex.re (Set.Ioo a b)))) g fun z => Real.exp (HMul.hMul B (Real.exp (HMul.hMul c (abs z.im)))))\nha : ‚àÄ (z : Complex), Eq z.re a ‚Üí Eq (f z) (g z)\nhb : ‚àÄ (z : Complex), Eq z.re b ‚Üí Eq (f z) (g z)\n‚ä¢ Set.EqOn f g (Set.preimage Complex.re (Set.Icc a b))","decl":"/-- **Phragmen-Lindel√∂f principle** in a strip `U = {z : ‚ÑÇ | a < re z < b}`.\nLet `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable on `U` and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some\n  `c < œÄ / (b - a)`;\n* `f z = g z` on the boundary of `U`.\n\nThen `f` is equal to `g` on the closed strip `{z : ‚ÑÇ | a ‚â§ re z ‚â§ b}`.\n-/\ntheorem eqOn_vertical_strip {g : ‚ÑÇ ‚Üí E} (hdf : DiffContOnCl ‚ÑÇ f (re ‚Åª¬π' Ioo a b))\n    (hBf : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò im) atTop ‚äì ùìü (re ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.im|)))\n    (hdg : DiffContOnCl ‚ÑÇ g (re ‚Åª¬π' Ioo a b))\n    (hBg : ‚àÉ c < œÄ / (b - a), ‚àÉ B, g =O[comap (_root_.abs ‚àò im) atTop ‚äì ùìü (re ‚Åª¬π' Ioo a b)]\n      fun z ‚Ü¶ expR (B * expR (c * |z.im|)))\n    (ha : ‚àÄ z : ‚ÑÇ, re z = a ‚Üí f z = g z) (hb : ‚àÄ z : ‚ÑÇ, re z = b ‚Üí f z = g z) :\n    EqOn f g (re ‚Åª¬π' Icc a b) := fun _z hz =>\n  sub_eq_zero.1 (eq_zero_on_vertical_strip (hdf.sub hdg) (isBigO_sub_exp_exp hBf hBg)\n    (fun w hw => sub_eq_zero.2 (ha w hw)) (fun w hw => sub_eq_zero.2 (hb w hw)) hz)\n\n"}
{"name":"PhragmenLindelof.quadrant_I","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí LE.le (Norm.norm (f ‚Üëx)) C\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz_re : LE.le 0 z.re\nhz_im : LE.le 0 z.im\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the first quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `‚Äñf z‚Äñ` is bounded from above by the same constant on the closed first quadrant. -/\nnonrec theorem quadrant_I (hd : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Ioi 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí ‚Äñf x‚Äñ ‚â§ C) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí ‚Äñf (x * I)‚Äñ ‚â§ C) (hz_re : 0 ‚â§ z.re)\n    (hz_im : 0 ‚â§ z.im) : ‚Äñf z‚Äñ ‚â§ C := by\n  -- The case `z = 0` is trivial.\n  rcases eq_or_ne z 0 with (rfl | hzne)\n  ¬∑ exact hre 0 le_rfl\n  -- Otherwise, `z = e ^ Œ∂` for some `Œ∂ : ‚ÑÇ`, `0 < Im Œ∂ < œÄ / 2`.\n  obtain ‚ü®Œ∂, hŒ∂, rfl‚ü© : ‚àÉ Œ∂ : ‚ÑÇ, Œ∂.im ‚àà Icc 0 (œÄ / 2) ‚àß exp Œ∂ = z := by\n    refine ‚ü®log z, ?_, exp_log hzne‚ü©\n    rw [log_im]\n    exact ‚ü®arg_nonneg_iff.2 hz_im, arg_le_pi_div_two_iff.2 (Or.inl hz_re)‚ü©\n  -- Porting note: failed to clear `clear hz_re hz_im hzne`\n  -- We are going to apply `PhragmenLindelof.horizontal_strip` to `f ‚àò Complex.exp` and `Œ∂`.\n  change ‚Äñ(f ‚àò exp) Œ∂‚Äñ ‚â§ C\n  have H : MapsTo exp (im ‚Åª¬π' Ioo 0 (œÄ / 2)) (Ioi 0 √ó‚ÑÇ Ioi 0) := fun z hz ‚Ü¶ by\n    rw [mem_reProdIm, exp_re, exp_im, mem_Ioi, mem_Ioi]\n    have : 0 < Real.cos z.im := Real.cos_pos_of_mem_Ioo ‚ü®by linarith [hz.1, hz.2], hz.2‚ü©\n    have : 0 < Real.sin z.im :=\n      Real.sin_pos_of_mem_Ioo ‚ü®hz.1, hz.2.trans (half_lt_self Real.pi_pos)‚ü©\n    constructor <;> positivity\n  refine horizontal_strip (hd.comp differentiable_exp.diffContOnCl H) ?_ ?_ ?_ hŒ∂.1 hŒ∂.2\n  -- Porting note: failed to clear hŒ∂ Œ∂\n  ¬∑ -- The estimate `hB` on `f` implies the required estimate on\n    -- `f ‚àò exp` with the same `c` and `B' = max B 0`.\n    rw [sub_zero, div_div_cancel‚ÇÄ Real.pi_pos.ne']\n    rcases hB with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®c, hc, max B 0, ?_‚ü©\n    rw [‚Üê comap_comap, comap_abs_atTop, comap_sup, inf_sup_right]\n    -- We prove separately the estimates as `Œ∂.re ‚Üí ‚àû` and as `Œ∂.re ‚Üí -‚àû`\n    refine IsBigO.sup ?_ <| (hO.comp_tendsto <| tendsto_exp_comap_re_atTop.inf H.tendsto).trans <|\n      .of_norm_eventuallyLE ?_\n    ¬∑ -- For the estimate as `Œ∂.re ‚Üí -‚àû`, note that `f` is continuous within the first quadrant at\n      -- zero, hence `f (exp Œ∂)` has a limit as `Œ∂.re ‚Üí -‚àû`, `0 < Œ∂.im < œÄ / 2`.\n      have hc : ContinuousWithinAt f (Ioi 0 √ó‚ÑÇ Ioi 0) 0 := by\n        refine (hd.continuousOn _ ?_).mono subset_closure\n        simp [closure_reProdIm, mem_reProdIm]\n      refine ((hc.tendsto.comp <| tendsto_exp_comap_re_atBot.inf H.tendsto).isBigO_one ‚Ñù).trans\n        (isBigO_of_le _ fun w => ?_)\n      rw [norm_one, Real.norm_of_nonneg (Real.exp_pos _).le, Real.one_le_exp_iff]\n      positivity\n    ¬∑ -- For the estimate as `Œ∂.re ‚Üí ‚àû`, we reuse the upper estimate on `f`\n      simp only [EventuallyLE, eventually_inf_principal, eventually_comap, comp_apply, one_mul,\n        Real.norm_of_nonneg (Real.exp_pos _).le, abs_exp, ‚Üê Real.exp_mul, Real.exp_le_exp]\n      filter_upwards [eventually_ge_atTop 0] with x hx z hz _\n      rw [hz, _root_.abs_of_nonneg hx, mul_comm _ c]\n      gcongr; apply le_max_left\n  ¬∑ -- If `Œ∂.im = 0`, then `Complex.exp Œ∂` is a positive real number\n    intro Œ∂ hŒ∂; lift Œ∂ to ‚Ñù using hŒ∂\n    rw [comp_apply, ‚Üê ofReal_exp]\n    exact hre _ (Real.exp_pos _).le\n  ¬∑ -- If `Œ∂.im = œÄ / 2`, then `Complex.exp Œ∂` is a purely imaginary number with positive `im`\n    intro Œ∂ hŒ∂\n    rw [‚Üê re_add_im Œ∂, hŒ∂, comp_apply, exp_add_mul_I, ‚Üê ofReal_cos, ‚Üê ofReal_sin,\n      Real.cos_pi_div_two, Real.sin_pi_div_two, ofReal_zero, ofReal_one, one_mul, zero_add, ‚Üê\n      ofReal_exp]\n    exact him _ (Real.exp_pos _).le\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_quadrant_I","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f ‚Üëx) 0\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) 0\n‚ä¢ Set.EqOn f 0 (setOf fun z => And (LE.le 0 z.re) (LE.le 0 z.im))","decl":"/-- **Phragmen-Lindel√∂f principle** in the first quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem eq_zero_on_quadrant_I (hd : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Ioi 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f x = 0) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f (x * I) = 0) :\n    EqOn f 0 {z | 0 ‚â§ z.re ‚àß 0 ‚â§ z.im} := fun _z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_I hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx)\n      (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_quadrant_I","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0))\nhBf : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhdg : DiffContOnCl Complex g (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0))\nhBg : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Ioi 0)))) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f ‚Üëx) (g ‚Üëx)\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) (g (HMul.hMul (‚Üëx) Complex.I))\n‚ä¢ Set.EqOn f g (setOf fun z => And (LE.le 0 z.re) (LE.le 0 z.im))","decl":"/-- **Phragmen-Lindel√∂f principle** in the first quadrant. Let `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable in the open first quadrant and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open first\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the first quadrant.\n\nThen `f` is equal to `g` on the closed first quadrant. -/\ntheorem eqOn_quadrant_I (hdf : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Ioi 0))\n    (hBf : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl ‚ÑÇ g (Ioi 0 √ó‚ÑÇ Ioi 0))\n    (hBg : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      g =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f x = g x) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f (x * I) = g (x * I)) :\n    EqOn f g {z | 0 ‚â§ z.re ‚àß 0 ‚â§ z.im} := fun _z hz =>\n  sub_eq_zero.1 <|\n    eq_zero_on_quadrant_I (hdf.sub hdg) (isBigO_sub_exp_rpow hBf hBg)\n      (fun x hx => sub_eq_zero.2 <| hre x hx) (fun x hx => sub_eq_zero.2 <| him x hx) hz\n\n"}
{"name":"PhragmenLindelof.quadrant_II","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí LE.le (Norm.norm (f ‚Üëx)) C\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz_re : LE.le z.re 0\nhz_im : LE.le 0 z.im\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the second quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of the second quadrant.\n\nThen `‚Äñf z‚Äñ` is bounded from above by the same constant on the closed second quadrant. -/\ntheorem quadrant_II (hd : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Ioi 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí ‚Äñf x‚Äñ ‚â§ C) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí ‚Äñf (x * I)‚Äñ ‚â§ C) (hz_re : z.re ‚â§ 0)\n    (hz_im : 0 ‚â§ z.im) : ‚Äñf z‚Äñ ‚â§ C := by\n  obtain ‚ü®z, rfl‚ü© : ‚àÉ z', z' * I = z := ‚ü®z / I, div_mul_cancel‚ÇÄ _ I_ne_zero‚ü©\n  simp only [mul_I_re, mul_I_im, neg_nonpos] at hz_re hz_im\n  change ‚Äñ(f ‚àò (¬∑ * I)) z‚Äñ ‚â§ C\n  have H : MapsTo (¬∑ * I) (Ioi 0 √ó‚ÑÇ Ioi 0) (Iio 0 √ó‚ÑÇ Ioi 0) := fun w hw ‚Ü¶ by\n    simpa only [mem_reProdIm, mul_I_re, mul_I_im, neg_lt_zero, mem_Iio] using hw.symm\n  rcases hB with ‚ü®c, hc, B, hO‚ü©\n  refine quadrant_I (hd.comp (differentiable_id.mul_const _).diffContOnCl H) ‚ü®c, hc, B, ?_‚ü© him\n    (fun x hx => ?_) hz_im hz_re\n  ¬∑ simpa only [Function.comp_def, map_mul, abs_I, mul_one]\n      using hO.comp_tendsto ((tendsto_mul_right_cobounded I_ne_zero).inf H.tendsto)\n  ¬∑ rw [comp_apply, mul_assoc, I_mul_I, mul_neg_one, ‚Üê ofReal_neg]\n    exact hre _ (neg_nonpos.2 hx)\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_quadrant_II","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f ‚Üëx) 0\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) 0\n‚ä¢ Set.EqOn f 0 (setOf fun z => And (LE.le z.re 0) (LE.le 0 z.im))","decl":"/-- **Phragmen-Lindel√∂f principle** in the second quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the second quadrant.\n\nThen `f` is equal to zero on the closed second quadrant. -/\ntheorem eq_zero_on_quadrant_II (hd : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Ioi 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f x = 0) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f (x * I) = 0) :\n    EqOn f 0 {z | z.re ‚â§ 0 ‚àß 0 ‚â§ z.im} := fun _z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_II hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx)\n      (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_quadrant_II","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0))\nhBf : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhdg : DiffContOnCl Complex g (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0))\nhBg : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Ioi 0)))) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f ‚Üëx) (g ‚Üëx)\nhim : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) (g (HMul.hMul (‚Üëx) Complex.I))\n‚ä¢ Set.EqOn f g (setOf fun z => And (LE.le z.re 0) (LE.le 0 z.im))","decl":"/-- **Phragmen-Lindel√∂f principle** in the second quadrant. Let `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable in the open second quadrant and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open second\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the second quadrant.\n\nThen `f` is equal to `g` on the closed second quadrant. -/\ntheorem eqOn_quadrant_II (hdf : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Ioi 0))\n    (hBf : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl ‚ÑÇ g (Iio 0 √ó‚ÑÇ Ioi 0))\n    (hBg : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      g =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f x = g x) (him : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f (x * I) = g (x * I)) :\n    EqOn f g {z | z.re ‚â§ 0 ‚àß 0 ‚â§ z.im} := fun _z hz =>\n  sub_eq_zero.1 <| eq_zero_on_quadrant_II (hdf.sub hdg) (isBigO_sub_exp_rpow hBf hBg)\n    (fun x hx => sub_eq_zero.2 <| hre x hx) (fun x hx => sub_eq_zero.2 <| him x hx) hz\n\n"}
{"name":"PhragmenLindelof.quadrant_III","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Iio 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí LE.le (Norm.norm (f ‚Üëx)) C\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz_re : LE.le z.re 0\nhz_im : LE.le z.im 0\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the third quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‚Äñf z‚Äñ` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem quadrant_III (hd : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Iio 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí ‚Äñf x‚Äñ ‚â§ C) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí ‚Äñf (x * I)‚Äñ ‚â§ C) (hz_re : z.re ‚â§ 0)\n    (hz_im : z.im ‚â§ 0) : ‚Äñf z‚Äñ ‚â§ C := by\n  obtain ‚ü®z, rfl‚ü© : ‚àÉ z', -z' = z := ‚ü®-z, neg_neg z‚ü©\n  simp only [neg_re, neg_im, neg_nonpos] at hz_re hz_im\n  change ‚Äñ(f ‚àò Neg.neg) z‚Äñ ‚â§ C\n  have H : MapsTo Neg.neg (Ioi 0 √ó‚ÑÇ Ioi 0) (Iio 0 √ó‚ÑÇ Iio 0) := by\n    intro w hw\n    simpa only [mem_reProdIm, neg_re, neg_im, neg_lt_zero, mem_Iio] using hw\n  refine\n    quadrant_I (hd.comp differentiable_neg.diffContOnCl H) ?_ (fun x hx => ?_) (fun x hx => ?_)\n      hz_re hz_im\n  ¬∑ rcases hB with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®c, hc, B, ?_‚ü©\n    simpa only [Function.comp_def, Complex.abs.map_neg]\n      using hO.comp_tendsto (tendsto_neg_cobounded.inf H.tendsto)\n  ¬∑ rw [comp_apply, ‚Üê ofReal_neg]\n    exact hre (-x) (neg_nonpos.2 hx)\n  ¬∑ rw [comp_apply, ‚Üê neg_mul, ‚Üê ofReal_neg]\n    exact him (-x) (neg_nonpos.2 hx)\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_quadrant_III","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Iio 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f ‚Üëx) 0\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) 0\n‚ä¢ Set.EqOn f 0 (setOf fun z => And (LE.le z.re 0) (LE.le z.im 0))","decl":"/-- **Phragmen-Lindel√∂f principle** in the third quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem eq_zero_on_quadrant_III (hd : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Iio 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f x = 0) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f (x * I) = 0) :\n    EqOn f 0 {z | z.re ‚â§ 0 ‚àß z.im ‚â§ 0} := fun _z hz =>\n  norm_le_zero_iff.1 <| quadrant_III hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx)\n    (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_quadrant_III","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Complex.reProdIm (Set.Iio 0) (Set.Iio 0))\nhBf : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhdg : DiffContOnCl Complex g (Complex.reProdIm (Set.Iio 0) (Set.Iio 0))\nhBg : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Iio 0) (Set.Iio 0)))) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f ‚Üëx) (g ‚Üëx)\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) (g (HMul.hMul (‚Üëx) Complex.I))\n‚ä¢ Set.EqOn f g (setOf fun z => And (LE.le z.re 0) (LE.le z.im 0))","decl":"/-- **Phragmen-Lindel√∂f principle** in the third quadrant. Let `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem eqOn_quadrant_III (hdf : DiffContOnCl ‚ÑÇ f (Iio 0 √ó‚ÑÇ Iio 0))\n    (hBf : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl ‚ÑÇ g (Iio 0 √ó‚ÑÇ Iio 0))\n    (hBg : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      g =O[cobounded ‚ÑÇ ‚äì ùìü (Iio 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f x = g x) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f (x * I) = g (x * I)) :\n    EqOn f g {z | z.re ‚â§ 0 ‚àß z.im ‚â§ 0} := fun _z hz =>\n  sub_eq_zero.1 <| eq_zero_on_quadrant_III (hdf.sub hdg) (isBigO_sub_exp_rpow hBf hBg)\n    (fun x hx => sub_eq_zero.2 <| hre x hx) (fun x hx => sub_eq_zero.2 <| him x hx) hz\n\n"}
{"name":"PhragmenLindelof.quadrant_IV","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí LE.le (Norm.norm (f ‚Üëx)) C\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz_re : LE.le 0 z.re\nhz_im : LE.le z.im 0\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the fourth quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the boundary of the fourth quadrant.\n\nThen `‚Äñf z‚Äñ` is bounded from above by the same constant on the closed fourth quadrant. -/\ntheorem quadrant_IV (hd : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Iio 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí ‚Äñf x‚Äñ ‚â§ C) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí ‚Äñf (x * I)‚Äñ ‚â§ C) (hz_re : 0 ‚â§ z.re)\n    (hz_im : z.im ‚â§ 0) : ‚Äñf z‚Äñ ‚â§ C := by\n  obtain ‚ü®z, rfl‚ü© : ‚àÉ z', -z' = z := ‚ü®-z, neg_neg z‚ü©\n  simp only [neg_re, neg_im, neg_nonpos, neg_nonneg] at hz_re hz_im\n  change ‚Äñ(f ‚àò Neg.neg) z‚Äñ ‚â§ C\n  have H : MapsTo Neg.neg (Iio 0 √ó‚ÑÇ Ioi 0) (Ioi 0 √ó‚ÑÇ Iio 0) := fun w hw ‚Ü¶ by\n    simpa only [mem_reProdIm, neg_re, neg_im, neg_lt_zero, neg_pos, mem_Ioi, mem_Iio] using hw\n  refine quadrant_II\n    (hd.comp differentiable_neg.diffContOnCl H) ?_ (fun x hx => ?_) (fun x hx => ?_) hz_re hz_im\n  ¬∑ rcases hB with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®c, hc, B, ?_‚ü©\n    simpa only [Function.comp_def, Complex.abs.map_neg]\n      using hO.comp_tendsto (tendsto_neg_cobounded.inf H.tendsto)\n  ¬∑ rw [comp_apply, ‚Üê ofReal_neg]\n    exact hre (-x) (neg_nonneg.2 hx)\n  ¬∑ rw [comp_apply, ‚Üê neg_mul, ‚Üê ofReal_neg]\n    exact him (-x) (neg_nonpos.2 hx)\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_quadrant_IV","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0))\nhB : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f ‚Üëx) 0\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) 0\n‚ä¢ Set.EqOn f 0 (setOf fun z => And (LE.le 0 z.re) (LE.le z.im 0))","decl":"/-- **Phragmen-Lindel√∂f principle** in the fourth quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open fourth quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the fourth quadrant.\n\nThen `f` is equal to zero on the closed fourth quadrant. -/\ntheorem eq_zero_on_quadrant_IV (hd : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Iio 0))\n    (hB : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f x = 0) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f (x * I) = 0) :\n    EqOn f 0 {z | 0 ‚â§ z.re ‚àß z.im ‚â§ 0} := fun _z hz =>\n  norm_le_zero_iff.1 <|\n    quadrant_IV hd hB (fun x hx => norm_le_zero_iff.2 <| hre x hx)\n      (fun x hx => norm_le_zero_iff.2 <| him x hx) hz.1 hz.2\n\n"}
{"name":"PhragmenLindelof.eqOn_quadrant_IV","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Complex ‚Üí E\nhdf : DiffContOnCl Complex f (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0))\nhBf : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0)))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhdg : DiffContOnCl Complex g (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0))\nhBg : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (Complex.reProdIm (Set.Ioi 0) (Set.Iio 0)))) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : ‚àÄ (x : Real), LE.le 0 x ‚Üí Eq (f ‚Üëx) (g ‚Üëx)\nhim : ‚àÄ (x : Real), LE.le x 0 ‚Üí Eq (f (HMul.hMul (‚Üëx) Complex.I)) (g (HMul.hMul (‚Üëx) Complex.I))\n‚ä¢ Set.EqOn f g (setOf fun z => And (LE.le 0 z.re) (LE.le z.im 0))","decl":"/-- **Phragmen-Lindel√∂f principle** in the fourth quadrant. Let `f g : ‚ÑÇ ‚Üí E` be functions such that\n\n* `f` and `g` are differentiable in the open fourth quadrant and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open fourth\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the fourth quadrant.\n\nThen `f` is equal to `g` on the closed fourth quadrant. -/\ntheorem eqOn_quadrant_IV (hdf : DiffContOnCl ‚ÑÇ f (Ioi 0 √ó‚ÑÇ Iio 0))\n    (hBf : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl ‚ÑÇ g (Ioi 0 √ó‚ÑÇ Iio 0))\n    (hBg : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      g =O[cobounded ‚ÑÇ ‚äì ùìü (Ioi 0 √ó‚ÑÇ Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f x = g x) (him : ‚àÄ x : ‚Ñù, x ‚â§ 0 ‚Üí f (x * I) = g (x * I)) :\n    EqOn f g {z | 0 ‚â§ z.re ‚àß z.im ‚â§ 0} := fun _z hz =>\n  sub_eq_zero.1 <| eq_zero_on_quadrant_IV (hdf.sub hdg) (isBigO_sub_exp_rpow hBf hBg)\n    (fun x hx => sub_eq_zero.2 <| hre x hx) (fun x hx => sub_eq_zero.2 <| him x hx) hz\n\n"}
{"name":"PhragmenLindelof.right_half_plane_of_tendsto_zero_on_real","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (setOf fun z => LT.lt 0 z.re)\nhexp : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (setOf fun z => LT.lt 0 z.re))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : Filter.Tendsto (fun x => f ‚Üëx) Filter.atTop (nhds 0)\nhim : ‚àÄ (x : Real), LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz : LE.le 0 z.re\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the right half-plane. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the imaginary axis;\n* `f x ‚Üí 0` as `x : ‚Ñù` tends to infinity.\n\nThen `‚Äñf z‚Äñ` is bounded from above by the same constant on the closed right half-plane.\nSee also `PhragmenLindelof.right_half_plane_of_bounded_on_real` for a stronger version. -/\ntheorem right_half_plane_of_tendsto_zero_on_real (hd : DiffContOnCl ‚ÑÇ f {z | 0 < z.re})\n    (hexp : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : Tendsto (fun x : ‚Ñù => f x) atTop (ùìù 0)) (him : ‚àÄ x : ‚Ñù, ‚Äñf (x * I)‚Äñ ‚â§ C)\n    (hz : 0 ‚â§ z.re) : ‚Äñf z‚Äñ ‚â§ C := by\n  /- We are going to apply the Phragmen-Lindel√∂f principle in the first and fourth quadrants.\n    The lemmas immediately imply that for any upper estimate `C'` on `‚Äñf x‚Äñ`, `x : ‚Ñù`, `0 ‚â§ x`,\n    the number `max C C'` is an upper estimate on `f` in the whole right half-plane. -/\n  revert z\n  have hle : ‚àÄ C', (‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí ‚Äñf x‚Äñ ‚â§ C') ‚Üí\n      ‚àÄ z : ‚ÑÇ, 0 ‚â§ z.re ‚Üí ‚Äñf z‚Äñ ‚â§ max C C' := fun C' hC' z hz ‚Ü¶ by\n    rcases hexp with ‚ü®c, hc, B, hO‚ü©\n    rcases le_total z.im 0 with h | h\n    ¬∑ refine quadrant_IV (hd.mono fun _ => And.left) ‚ü®c, hc, B, ?_‚ü©\n          (fun x hx => (hC' x hx).trans <| le_max_right _ _)\n          (fun x _ => (him x).trans (le_max_left _ _)) hz h\n      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)\n    ¬∑ refine quadrant_I (hd.mono fun _ => And.left) ‚ü®c, hc, B, ?_‚ü©\n          (fun x hx => (hC' x hx).trans <| le_max_right _ _)\n          (fun x _ => (him x).trans (le_max_left _ _)) hz h\n      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)\n  -- Since `f` is continuous on `Ici 0` and `‚Äñf x‚Äñ` tends to zero as `x ‚Üí ‚àû`,\n  -- the norm `‚Äñf x‚Äñ` takes its maximum value at some `x‚ÇÄ : ‚Ñù`.\n  obtain ‚ü®x‚ÇÄ, hx‚ÇÄ, hmax‚ü© : ‚àÉ x : ‚Ñù, 0 ‚â§ x ‚àß ‚àÄ y : ‚Ñù, 0 ‚â§ y ‚Üí ‚Äñf y‚Äñ ‚â§ ‚Äñf x‚Äñ := by\n    have hfc : ContinuousOn (fun x : ‚Ñù => f x) (Ici 0) := by\n      refine hd.continuousOn.comp continuous_ofReal.continuousOn fun x hx => ?_\n      rwa [closure_setOf_lt_re]\n    by_cases h‚ÇÄ : ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí f x = 0\n    ¬∑ refine ‚ü®0, le_rfl, fun y hy => ?_‚ü©; rw [h‚ÇÄ y hy, h‚ÇÄ 0 le_rfl]\n    push_neg at h‚ÇÄ\n    rcases h‚ÇÄ with ‚ü®x‚ÇÄ, hx‚ÇÄ, hne‚ü©\n    have hlt : ‚Äñ(0 : E)‚Äñ < ‚Äñf x‚ÇÄ‚Äñ := by rwa [norm_zero, norm_pos_iff]\n    suffices ‚àÄ·∂† x : ‚Ñù in cocompact ‚Ñù ‚äì ùìü (Ici 0), ‚Äñf x‚Äñ ‚â§ ‚Äñf x‚ÇÄ‚Äñ by\n      simpa only [exists_prop] using hfc.norm.exists_isMaxOn' isClosed_Ici hx‚ÇÄ this\n    rw [cocompact_eq_atBot_atTop, inf_sup_right, (disjoint_atBot_principal_Ici (0 : ‚Ñù)).eq_bot,\n      bot_sup_eq]\n    exact (hre.norm.eventually <| ge_mem_nhds hlt).filter_mono inf_le_left\n  rcases le_or_lt ‚Äñf x‚ÇÄ‚Äñ C with h | h\n  ¬∑-- If `‚Äñf x‚ÇÄ‚Äñ ‚â§ C`, then `hle` implies the required estimate\n    simpa only [max_eq_left h] using hle _ hmax\n  ¬∑ -- Otherwise, `‚Äñf z‚Äñ ‚â§ ‚Äñf x‚ÇÄ‚Äñ` for all `z` in the right half-plane due to `hle`.\n    replace hmax : IsMaxOn (norm ‚àò f) {z | 0 < z.re} x‚ÇÄ := by\n      rintro z (hz : 0 < z.re)\n      simpa [max_eq_right h.le] using hle _ hmax _ hz.le\n    -- Due to the maximum modulus principle applied to the closed ball of radius `x‚ÇÄ.re`,\n    -- `‚Äñf 0‚Äñ = ‚Äñf x‚ÇÄ‚Äñ`.\n    have : ‚Äñf 0‚Äñ = ‚Äñf x‚ÇÄ‚Äñ := by\n      apply norm_eq_norm_of_isMaxOn_of_ball_subset hd hmax\n      -- move to a lemma?\n      intro z hz\n      rw [mem_ball, dist_zero_left, dist_eq, norm_eq_abs, Complex.abs_of_nonneg hx‚ÇÄ] at hz\n      rw [mem_setOf_eq]\n      contrapose! hz\n      calc\n        x‚ÇÄ ‚â§ x‚ÇÄ - z.re := (le_sub_self_iff _).2 hz\n        _ ‚â§ |x‚ÇÄ - z.re| := le_abs_self _\n        _ = |(z - x‚ÇÄ).re| := by rw [sub_re, ofReal_re, _root_.abs_sub_comm]\n        _ ‚â§ abs (z - x‚ÇÄ) := abs_re_le_abs _\n    -- Thus we have `C < ‚Äñf x‚ÇÄ‚Äñ = ‚Äñf 0‚Äñ ‚â§ C`. Contradiction completes the proof.\n    refine (h.not_le <| this ‚ñ∏ ?_).elim\n    simpa using him 0\n\n"}
{"name":"PhragmenLindelof.right_half_plane_of_bounded_on_real","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nC : Real\nf : Complex ‚Üí E\nz : Complex\nhd : DiffContOnCl Complex f (setOf fun z => LT.lt 0 z.re)\nhexp : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (setOf fun z => LT.lt 0 z.re))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.atTop fun x => Norm.norm (f ‚Üëx)\nhim : ‚àÄ (x : Real), LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhz : LE.le 0 z.re\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Phragmen-Lindel√∂f principle** in the right half-plane. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant `C` on the imaginary axis;\n* `‚Äñf x‚Äñ` is bounded from above by a constant for large real values of `x`.\n\nThen `‚Äñf z‚Äñ` is bounded from above by `C` on the closed right half-plane.\nSee also `PhragmenLindelof.right_half_plane_of_tendsto_zero_on_real` for a weaker version. -/\ntheorem right_half_plane_of_bounded_on_real (hd : DiffContOnCl ‚ÑÇ f {z | 0 < z.re})\n    (hexp : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : IsBoundedUnder (¬∑ ‚â§ ¬∑) atTop fun x : ‚Ñù => ‚Äñf x‚Äñ) (him : ‚àÄ x : ‚Ñù, ‚Äñf (x * I)‚Äñ ‚â§ C)\n    (hz : 0 ‚â§ z.re) : ‚Äñf z‚Äñ ‚â§ C := by\n  -- For each `Œµ < 0`, the function `fun z ‚Ü¶ exp (Œµ * z) ‚Ä¢ f z` satisfies assumptions of\n  -- `right_half_plane_of_tendsto_zero_on_real`, hence `‚Äñexp (Œµ * z) ‚Ä¢ f z‚Äñ ‚â§ C` for all `Œµ < 0`.\n  -- Taking the limit as `Œµ ‚Üí 0`, we obtain the required inequality.\n  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] 0, ‚Äñexp (Œµ * z) ‚Ä¢ f z‚Äñ ‚â§ C by\n    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this\n    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'\n    simp\n  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ\n  set g : ‚ÑÇ ‚Üí E := fun z => exp (Œµ * z) ‚Ä¢ f z; change ‚Äñg z‚Äñ ‚â§ C\n  replace hd : DiffContOnCl ‚ÑÇ g {z : ‚ÑÇ | 0 < z.re} :=\n    (differentiable_id.const_mul _).cexp.diffContOnCl.smul hd\n  have hgn : ‚àÄ z, ‚Äñg z‚Äñ = expR (Œµ * z.re) * ‚Äñf z‚Äñ := fun z ‚Ü¶ by\n    rw [norm_smul, norm_eq_abs, abs_exp, re_ofReal_mul]\n  refine right_half_plane_of_tendsto_zero_on_real hd ?_ ?_ (fun y => ?_) hz\n  ¬∑ rcases hexp with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®c, hc, B, .trans (.of_bound' ?_) hO‚ü©\n    refine eventually_inf_principal.2 <| Eventually.of_forall fun z hz => ?_\n    rw [hgn]\n    refine mul_le_of_le_one_left (norm_nonneg _) (Real.exp_le_one_iff.2 ?_)\n    exact mul_nonpos_of_nonpos_of_nonneg Œµ‚ÇÄ.le (le_of_lt hz)\n  ¬∑ simp_rw [g, ‚Üê ofReal_mul, ‚Üê ofReal_exp, coe_smul]\n    have h‚ÇÄ : Tendsto (fun x : ‚Ñù => expR (Œµ * x)) atTop (ùìù 0) :=\n      Real.tendsto_exp_atBot.comp (tendsto_const_nhds.neg_mul_atTop Œµ‚ÇÄ tendsto_id)\n    exact h‚ÇÄ.zero_smul_isBoundedUnder_le hre\n  ¬∑ rw [hgn, re_ofReal_mul, I_re, mul_zero, mul_zero, Real.exp_zero,\n      one_mul]\n    exact him y\n\n"}
{"name":"PhragmenLindelof.eq_zero_on_right_half_plane_of_superexponential_decay","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nhd : DiffContOnCl Complex f (setOf fun z => LT.lt 0 z.re)\nhexp : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (setOf fun z => LT.lt 0 z.re))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : Asymptotics.SuperpolynomialDecay Filter.atTop Real.exp fun x => Norm.norm (f ‚Üëx)\nhim : Exists fun C => ‚àÄ (x : Real), LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\n‚ä¢ Set.EqOn f 0 (setOf fun z => LE.le 0 z.re)","decl":"/-- **Phragmen-Lindel√∂f principle** in the right half-plane. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open right half-plane and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open right half-plane\n  for some `c < 2`;\n* `‚Äñf z‚Äñ` is bounded from above by a constant on the imaginary axis;\n* `f x`, `x : ‚Ñù`, tends to zero superexponentially fast as `x ‚Üí ‚àû`:\n  for any natural `n`, `exp (n * x) * ‚Äñf x‚Äñ` tends to zero as `x ‚Üí ‚àû`.\n\nThen `f` is equal to zero on the closed right half-plane. -/\ntheorem eq_zero_on_right_half_plane_of_superexponential_decay (hd : DiffContOnCl ‚ÑÇ f {z | 0 < z.re})\n    (hexp : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop expR fun x => ‚Äñf x‚Äñ) (him : ‚àÉ C, ‚àÄ x : ‚Ñù, ‚Äñf (x * I)‚Äñ ‚â§ C) :\n    EqOn f 0 {z : ‚ÑÇ | 0 ‚â§ z.re} := by\n  rcases him with ‚ü®C, hC‚ü©\n  -- Due to continuity, it suffices to prove the equality on the open right half-plane.\n  suffices ‚àÄ z : ‚ÑÇ, 0 < z.re ‚Üí f z = 0 by\n    simpa only [closure_setOf_lt_re] using\n      EqOn.of_subset_closure this hd.continuousOn continuousOn_const subset_closure Subset.rfl\n  -- Consider $g_n(z)=e^{nz}f(z)$.\n  set g : ‚Ñï ‚Üí ‚ÑÇ ‚Üí E := fun (n : ‚Ñï) (z : ‚ÑÇ) => exp z ^ n ‚Ä¢ f z\n  have hg : ‚àÄ n z, ‚Äñg n z‚Äñ = expR z.re ^ n * ‚Äñf z‚Äñ := fun n z ‚Ü¶ by\n    simp only [g, norm_smul, norm_eq_abs, Complex.abs_pow, abs_exp]\n  intro z hz\n  -- Since `e^{nz} ‚Üí ‚àû` as `n ‚Üí ‚àû`, it suffices to show that each `g_n` is bounded from above by `C`\n  suffices H : ‚àÄ n : ‚Ñï, ‚Äñg n z‚Äñ ‚â§ C by\n    contrapose! H\n    simp only [hg]\n    exact (((tendsto_pow_atTop_atTop_of_one_lt (Real.one_lt_exp_iff.2 hz)).atTop_mul\n      (norm_pos_iff.2 H) tendsto_const_nhds).eventually (eventually_gt_atTop C)).exists\n  intro n\n  -- This estimate follows from the Phragmen-Lindel√∂f principle in the right half-plane.\n  refine right_half_plane_of_tendsto_zero_on_real ((differentiable_exp.pow n).diffContOnCl.smul hd)\n    ?_ ?_ (fun y => ?_) hz.le\n  ¬∑ rcases hexp with ‚ü®c, hc, B, hO‚ü©\n    refine ‚ü®max c 1, max_lt hc one_lt_two, n + max B 0, .of_norm_left ?_‚ü©\n    simp only [hg]\n    refine ((isBigO_refl (fun z : ‚ÑÇ => expR z.re ^ n) _).mul hO.norm_left).trans (.of_bound' ?_)\n    filter_upwards [(eventually_cobounded_le_norm 1).filter_mono inf_le_left] with z hz\n    simp only [‚Üê Real.exp_nat_mul, ‚Üê Real.exp_add, Real.norm_eq_abs, Real.abs_exp, add_mul]\n    gcongr\n    ¬∑ calc\n        z.re ‚â§ abs z := re_le_abs _\n        _ = abs z ^ (1 : ‚Ñù) := (Real.rpow_one _).symm\n        _ ‚â§ abs z ^ max c 1 := Real.rpow_le_rpow_of_exponent_le hz (le_max_right _ _)\n    exacts [le_max_left _ _, hz, le_max_left _ _]\n  ¬∑ rw [tendsto_zero_iff_norm_tendsto_zero]; simp only [hg]\n    exact hre n\n  ¬∑ rw [hg, re_ofReal_mul, I_re, mul_zero, Real.exp_zero, one_pow, one_mul]\n    exact hC y\n\n"}
{"name":"PhragmenLindelof.eqOn_right_half_plane_of_superexponential_decay","module":"Mathlib.Analysis.Complex.PhragmenLindelof","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Complex ‚Üí E\nhfd : DiffContOnCl Complex f (setOf fun z => LT.lt 0 z.re)\nhgd : DiffContOnCl Complex g (setOf fun z => LT.lt 0 z.re)\nhfexp : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (setOf fun z => LT.lt 0 z.re))) f fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhgexp : Exists fun c => And (LT.lt c 2) (Exists fun B => Asymptotics.IsBigO (Min.min (Bornology.cobounded Complex) (Filter.principal (setOf fun z => LT.lt 0 z.re))) g fun z => Real.exp (HMul.hMul B (HPow.hPow (Complex.abs z) c)))\nhre : Asymptotics.SuperpolynomialDecay Filter.atTop Real.exp fun x => Norm.norm (HSub.hSub (f ‚Üëx) (g ‚Üëx))\nhfim : Exists fun C => ‚àÄ (x : Real), LE.le (Norm.norm (f (HMul.hMul (‚Üëx) Complex.I))) C\nhgim : Exists fun C => ‚àÄ (x : Real), LE.le (Norm.norm (g (HMul.hMul (‚Üëx) Complex.I))) C\n‚ä¢ Set.EqOn f g (setOf fun z => LE.le 0 z.re)","decl":"/-- **Phragmen-Lindel√∂f principle** in the right half-plane. Let `f g : ‚ÑÇ ‚Üí E` be functions such\nthat\n\n* `f` and `g` are differentiable in the open right half-plane and are continuous on its closure;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open right\n  half-plane for some `c < 2`;\n* `‚Äñf z‚Äñ` and `‚Äñg z‚Äñ` are bounded from above by constants on the imaginary axis;\n* `f x - g x`, `x : ‚Ñù`, tends to zero superexponentially fast as `x ‚Üí ‚àû`:\n  for any natural `n`, `exp (n * x) * ‚Äñf x - g x‚Äñ` tends to zero as `x ‚Üí ‚àû`.\n\nThen `f` is equal to `g` on the closed right half-plane. -/\ntheorem eqOn_right_half_plane_of_superexponential_decay {g : ‚ÑÇ ‚Üí E}\n    (hfd : DiffContOnCl ‚ÑÇ f {z | 0 < z.re}) (hgd : DiffContOnCl ‚ÑÇ g {z | 0 < z.re})\n    (hfexp : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      f =O[cobounded ‚ÑÇ ‚äì ùìü {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hgexp : ‚àÉ c < (2 : ‚Ñù), ‚àÉ B,\n      g =O[cobounded ‚ÑÇ ‚äì ùìü {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop expR fun x => ‚Äñf x - g x‚Äñ)\n    (hfim : ‚àÉ C, ‚àÄ x : ‚Ñù, ‚Äñf (x * I)‚Äñ ‚â§ C) (hgim : ‚àÉ C, ‚àÄ x : ‚Ñù, ‚Äñg (x * I)‚Äñ ‚â§ C) :\n    EqOn f g {z : ‚ÑÇ | 0 ‚â§ z.re} := by\n  suffices EqOn (f - g) 0 {z : ‚ÑÇ | 0 ‚â§ z.re} by\n    simpa only [EqOn, Pi.sub_apply, Pi.zero_apply, sub_eq_zero] using this\n  refine eq_zero_on_right_half_plane_of_superexponential_decay (hfd.sub hgd) ?_ hre ?_\n  ¬∑ exact isBigO_sub_exp_rpow hfexp hgexp\n  ¬∑ rcases hfim with ‚ü®Cf, hCf‚ü©; rcases hgim with ‚ü®Cg, hCg‚ü©\n    exact ‚ü®Cf + Cg, fun x => norm_sub_le_of_le (hCf x) (hCg x)‚ü©\n\n"}
