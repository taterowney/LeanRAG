{"name":"List.Vector.get_mem","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\ni : Fin n\nv : List.Vector α n\n⊢ Membership.mem v.toList (v.get i)","decl":"@[simp]\ntheorem get_mem (i : Fin n) (v : Vector α n) : v.get i ∈ v.toList := List.get_mem _ _\n\n"}
{"name":"List.Vector.mem_iff_get","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Iff (Membership.mem v.toList a) (Exists fun i => Eq (v.get i) a)","decl":"theorem mem_iff_get (v : Vector α n) : a ∈ v.toList ↔ ∃ i, v.get i = a := by\n  simp only [List.mem_iff_get, Fin.exists_iff, Vector.get_eq_get_toList]\n  exact\n    ⟨fun ⟨i, hi, h⟩ => ⟨i, by rwa [toList_length] at hi, h⟩, fun ⟨i, hi, h⟩ =>\n      ⟨i, by rwa [toList_length], h⟩⟩\n\n"}
{"name":"List.Vector.not_mem_nil","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem List.Vector.nil.toList a)","decl":"theorem not_mem_nil : a ∉ (Vector.nil : Vector α 0).toList := by\n  unfold Vector.nil\n  dsimp\n  simp\n\n"}
{"name":"List.Vector.not_mem_zero","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\na : α\nv : List.Vector α 0\n⊢ Not (Membership.mem v.toList a)","decl":"theorem not_mem_zero (v : Vector α 0) : a ∉ v.toList :=\n  (Vector.eq_nil v).symm ▸ not_mem_nil a\n\n"}
{"name":"List.Vector.mem_cons_iff","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na a' : α\nv : List.Vector α n\n⊢ Iff (Membership.mem (List.Vector.cons a v).toList a') (Or (Eq a' a) (Membership.mem v.toList a'))","decl":"theorem mem_cons_iff (v : Vector α n) : a' ∈ (a ::ᵥ v).toList ↔ a' = a ∨ a' ∈ v.toList := by\n  rw [Vector.toList_cons, List.mem_cons]\n\n"}
{"name":"List.Vector.mem_succ_iff","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Iff (Membership.mem v.toList a) (Or (Eq a v.head) (Membership.mem v.tail.toList a))","decl":"theorem mem_succ_iff (v : Vector α (n + 1)) : a ∈ v.toList ↔ a = v.head ∨ a ∈ v.tail.toList := by\n  obtain ⟨a', v', h⟩ := exists_eq_cons v\n  simp_rw [h, Vector.mem_cons_iff, Vector.head_cons, Vector.tail_cons]\n\n"}
{"name":"List.Vector.mem_cons_self","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Membership.mem (List.Vector.cons a v).toList a","decl":"theorem mem_cons_self (v : Vector α n) : a ∈ (a ::ᵥ v).toList :=\n  (Vector.mem_iff_get a (a ::ᵥ v)).2 ⟨0, Vector.get_cons_zero a v⟩\n\n"}
{"name":"List.Vector.head_mem","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Membership.mem v.toList v.head","decl":"@[simp]\ntheorem head_mem (v : Vector α (n + 1)) : v.head ∈ v.toList :=\n  (Vector.mem_iff_get v.head v).2 ⟨0, Vector.get_zero v⟩\n\n"}
{"name":"List.Vector.mem_cons_of_mem","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na a' : α\nv : List.Vector α n\nha' : Membership.mem v.toList a'\n⊢ Membership.mem (List.Vector.cons a v).toList a'","decl":"theorem mem_cons_of_mem (v : Vector α n) (ha' : a' ∈ v.toList) : a' ∈ (a ::ᵥ v).toList :=\n  (Vector.mem_cons_iff a a' v).2 (Or.inr ha')\n\n"}
{"name":"List.Vector.mem_of_mem_tail","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\nha : Membership.mem v.tail.toList a\n⊢ Membership.mem v.toList a","decl":"theorem mem_of_mem_tail (v : Vector α n) (ha : a ∈ v.tail.toList) : a ∈ v.toList := by\n  induction n with\n  | zero => exact False.elim (Vector.not_mem_zero a v.tail ha)\n  | succ n _ => exact (mem_succ_iff a v).2 (Or.inr ha)\n\n"}
{"name":"List.Vector.mem_map_iff","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nb : β\nv : List.Vector α n\nf : α → β\n⊢ Iff (Membership.mem (List.Vector.map f v).toList b) (Exists fun a => And (Membership.mem v.toList a) (Eq (f a) b))","decl":"theorem mem_map_iff (b : β) (v : Vector α n) (f : α → β) :\n    b ∈ (v.map f).toList ↔ ∃ a : α, a ∈ v.toList ∧ f a = b := by\n  rw [Vector.toList_map, List.mem_map]\n\n"}
{"name":"List.Vector.not_mem_map_zero","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nv : List.Vector α 0\nf : α → β\n⊢ Not (Membership.mem (List.Vector.map f v).toList b)","decl":"theorem not_mem_map_zero (b : β) (v : Vector α 0) (f : α → β) : b ∉ (v.map f).toList := by\n  simpa only [Vector.eq_nil v, Vector.map_nil, Vector.toList_nil] using List.not_mem_nil b\n\n"}
{"name":"List.Vector.mem_map_succ_iff","module":"Mathlib.Data.Vector.Mem","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nb : β\nv : List.Vector α (HAdd.hAdd n 1)\nf : α → β\n⊢ Iff (Membership.mem (List.Vector.map f v).toList b) (Or (Eq (f v.head) b) (Exists fun a => And (Membership.mem v.tail.toList a) (Eq (f a) b)))","decl":"theorem mem_map_succ_iff (b : β) (v : Vector α (n + 1)) (f : α → β) :\n    b ∈ (v.map f).toList ↔ f v.head = b ∨ ∃ a : α, a ∈ v.tail.toList ∧ f a = b := by\n  rw [mem_succ_iff, head_map, tail_map, mem_map_iff, @eq_comm _ b]\n\n"}
