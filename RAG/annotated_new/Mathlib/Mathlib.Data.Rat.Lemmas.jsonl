{"name":"Rat.num_dvd","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Int\nb0 : Ne b 0\n⊢ Dvd.dvd (Rat.divInt a b).num a","decl":"theorem num_dvd (a) {b : ℤ} (b0 : b ≠ 0) : (a /. b).num ∣ a := by\n  cases' e : a /. b with n d h c\n  rw [Rat.mk'_eq_divInt, divInt_eq_iff b0 (mod_cast h)] at e\n  refine Int.natAbs_dvd.1 <| Int.dvd_natAbs.1 <| Int.natCast_dvd_natCast.2 <|\n    c.dvd_of_dvd_mul_right ?_\n  have := congr_arg Int.natAbs e\n  simp only [Int.natAbs_mul, Int.natAbs_ofNat] at this; simp [this]\n\n"}
{"name":"Rat.den_dvd","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Int\n⊢ Dvd.dvd (↑(Rat.divInt a b).den) b","decl":"theorem den_dvd (a b : ℤ) : ((a /. b).den : ℤ) ∣ b := by\n  by_cases b0 : b = 0; · simp [b0]\n  cases' e : a /. b with n d h c\n  rw [mk'_eq_divInt, divInt_eq_iff b0 (ne_of_gt (Int.natCast_pos.2 (Nat.pos_of_ne_zero h)))] at e\n  refine Int.dvd_natAbs.1 <| Int.natCast_dvd_natCast.2 <| c.symm.dvd_of_dvd_mul_left ?_\n  rw [← Int.natAbs_mul, ← Int.natCast_dvd_natCast, Int.dvd_natAbs, ← e]; simp\n\n"}
{"name":"Rat.num_den_mk","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q : Rat\nn d : Int\nhd : Ne d 0\nqdf : Eq q (Rat.divInt n d)\n⊢ Exists fun c => And (Eq n (HMul.hMul c q.num)) (Eq d (HMul.hMul c ↑q.den))","decl":"theorem num_den_mk {q : ℚ} {n d : ℤ} (hd : d ≠ 0) (qdf : q = n /. d) :\n    ∃ c : ℤ, n = c * q.num ∧ d = c * q.den := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp [qdf]\n  have : q.num * d = n * ↑q.den := by\n    refine (divInt_eq_iff ?_ hd).mp ?_\n    · exact Int.natCast_ne_zero.mpr (Rat.den_nz _)\n    · rwa [num_divInt_den]\n  have hqdn : q.num ∣ n := by\n    rw [qdf]\n    exact Rat.num_dvd _ hd\n  refine ⟨n / q.num, ?_, ?_⟩\n  · rw [Int.ediv_mul_cancel hqdn]\n  · refine Int.eq_mul_div_of_mul_eq_mul_of_dvd_left ?_ hqdn this\n    rw [qdf]\n    exact Rat.num_ne_zero.2 ((divInt_ne_zero hd).mpr hn)\n\n"}
{"name":"Rat.num_mk","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n d : Int\n⊢ Eq (Rat.divInt n d).num (HDiv.hDiv (HMul.hMul d.sign n) ↑(n.gcd d))","decl":"theorem num_mk (n d : ℤ) : (n /. d).num = d.sign * n / n.gcd d := by\n  have (m : ℕ) : Int.natAbs (m + 1) = m + 1 := by\n    rw [← Nat.cast_one, ← Nat.cast_add, Int.natAbs_cast]\n  rcases d with ((_ | _) | _) <;>\n  rw [← Int.tdiv_eq_ediv_of_dvd] <;>\n  simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,\n    Int.zero_ediv, Int.ofNat_dvd_left, Nat.gcd_dvd_left, this]\n\n"}
{"name":"Rat.den_mk","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n d : Int\n⊢ Eq (Rat.divInt n d).den (ite (Eq d 0) 1 (HDiv.hDiv d.natAbs (n.gcd d)))","decl":"theorem den_mk (n d : ℤ) : (n /. d).den = if d = 0 then 1 else d.natAbs / n.gcd d := by\n  have (m : ℕ) : Int.natAbs (m + 1) = m + 1 := by\n    rw [← Nat.cast_one, ← Nat.cast_add, Int.natAbs_cast]\n  rcases d with ((_ | _) | _) <;>\n    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,\n      if_neg (Nat.cast_add_one_ne_zero _), this]\n\n"}
{"name":"Rat.add_den_dvd_lcm","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q₁ q₂ : Rat\n⊢ Dvd.dvd (HAdd.hAdd q₁ q₂).den (q₁.den.lcm q₂.den)","decl":"theorem add_den_dvd_lcm (q₁ q₂ : ℚ) : (q₁ + q₂).den ∣ q₁.den.lcm q₂.den := by\n  rw [add_def, normalize_eq, Nat.div_dvd_iff_dvd_mul (Nat.gcd_dvd_right _ _)\n    (Nat.gcd_ne_zero_right (by simp)), ← Nat.gcd_mul_lcm,\n    mul_dvd_mul_iff_right (Nat.lcm_ne_zero (by simp) (by simp)), Nat.dvd_gcd_iff]\n  refine ⟨?_, dvd_mul_right _ _⟩\n  rw [← Int.natCast_dvd_natCast, Int.dvd_natAbs]\n  apply Int.dvd_add\n    <;> apply dvd_mul_of_dvd_right <;> rw [Int.natCast_dvd_natCast]\n    <;> [exact Nat.gcd_dvd_right _ _; exact Nat.gcd_dvd_left _ _]\n\n"}
{"name":"Rat.add_den_dvd","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q₁ q₂ : Rat\n⊢ Dvd.dvd (HAdd.hAdd q₁ q₂).den (HMul.hMul q₁.den q₂.den)","decl":"theorem add_den_dvd (q₁ q₂ : ℚ) : (q₁ + q₂).den ∣ q₁.den * q₂.den := by\n  rw [add_def, normalize_eq]\n  apply Nat.div_dvd_of_dvd\n  apply Nat.gcd_dvd_right\n\n"}
{"name":"Rat.mul_den_dvd","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q₁ q₂ : Rat\n⊢ Dvd.dvd (HMul.hMul q₁ q₂).den (HMul.hMul q₁.den q₂.den)","decl":"theorem mul_den_dvd (q₁ q₂ : ℚ) : (q₁ * q₂).den ∣ q₁.den * q₂.den := by\n  rw [mul_def, normalize_eq]\n  apply Nat.div_dvd_of_dvd\n  apply Nat.gcd_dvd_right\n\n"}
{"name":"Rat.mul_num","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q₁ q₂ : Rat\n⊢ Eq (HMul.hMul q₁ q₂).num (HDiv.hDiv (HMul.hMul q₁.num q₂.num) ↑((HMul.hMul q₁.num q₂.num).natAbs.gcd (HMul.hMul q₁.den q₂.den)))","decl":"theorem mul_num (q₁ q₂ : ℚ) :\n    (q₁ * q₂).num = q₁.num * q₂.num / Nat.gcd (q₁.num * q₂.num).natAbs (q₁.den * q₂.den) := by\n  rw [mul_def, normalize_eq]\n\n"}
{"name":"Rat.mul_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q₁ q₂ : Rat\n⊢ Eq (HMul.hMul q₁ q₂).den (HDiv.hDiv (HMul.hMul q₁.den q₂.den) ((HMul.hMul q₁.num q₂.num).natAbs.gcd (HMul.hMul q₁.den q₂.den)))","decl":"theorem mul_den (q₁ q₂ : ℚ) :\n    (q₁ * q₂).den =\n      q₁.den * q₂.den / Nat.gcd (q₁.num * q₂.num).natAbs (q₁.den * q₂.den) := by\n  rw [mul_def, normalize_eq]\n\n"}
{"name":"Rat.mul_self_num","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q : Rat\n⊢ Eq (HMul.hMul q q).num (HMul.hMul q.num q.num)","decl":"theorem mul_self_num (q : ℚ) : (q * q).num = q.num * q.num := by\n  rw [mul_num, Int.natAbs_mul, Nat.Coprime.gcd_eq_one, Int.ofNat_one, Int.ediv_one]\n  exact (q.reduced.mul_right q.reduced).mul (q.reduced.mul_right q.reduced)\n\n"}
{"name":"Rat.mul_self_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q : Rat\n⊢ Eq (HMul.hMul q q).den (HMul.hMul q.den q.den)","decl":"theorem mul_self_den (q : ℚ) : (q * q).den = q.den * q.den := by\n  rw [Rat.mul_den, Int.natAbs_mul, Nat.Coprime.gcd_eq_one, Nat.div_one]\n  exact (q.reduced.mul_right q.reduced).mul (q.reduced.mul_right q.reduced)\n\n"}
{"name":"Rat.add_num_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q r : Rat\n⊢ Eq (HAdd.hAdd q r) (Rat.divInt (HAdd.hAdd (HMul.hMul q.num ↑r.den) (HMul.hMul (↑q.den) r.num)) (HMul.hMul ↑q.den ↑r.den))","decl":"theorem add_num_den (q r : ℚ) :\n    q + r = (q.num * r.den + q.den * r.num : ℤ) /. (↑q.den * ↑r.den : ℤ) := by\n  have hqd : (q.den : ℤ) ≠ 0 := Int.natCast_ne_zero_iff_pos.2 q.den_pos\n  have hrd : (r.den : ℤ) ≠ 0 := Int.natCast_ne_zero_iff_pos.2 r.den_pos\n  conv_lhs => rw [← num_divInt_den q, ← num_divInt_den r, divInt_add_divInt _ _ hqd hrd]\n  rw [mul_comm r.num q.den]\n\n\n"}
{"name":"Rat.isSquare_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q : Rat\n⊢ Iff (IsSquare q) (And (IsSquare q.num) (IsSquare q.den))","decl":"theorem isSquare_iff {q : ℚ} : IsSquare q ↔ IsSquare q.num ∧ IsSquare q.den := by\n  constructor\n  · rintro ⟨qr, rfl⟩\n    rw [Rat.mul_self_num, mul_self_den]\n    simp only [IsSquare.mul_self, and_self]\n  · rintro ⟨⟨nr, hnr⟩, ⟨dr, hdr⟩⟩\n    refine ⟨nr / dr, ?_⟩\n    rw [div_mul_div_comm, ← Int.cast_mul, ← Nat.cast_mul, ← hnr, ← hdr, num_div_den]\n\n"}
{"name":"Rat.isSquare_natCast_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n : Nat\n⊢ Iff (IsSquare ↑n) (IsSquare n)","decl":"@[norm_cast, simp]\ntheorem isSquare_natCast_iff {n : ℕ} : IsSquare (n : ℚ) ↔ IsSquare n := by\n  simp_rw [isSquare_iff, num_natCast, den_natCast, IsSquare.one, and_true, Int.isSquare_natCast_iff]\n\n"}
{"name":"Rat.isSquare_intCast_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"z : Int\n⊢ Iff (IsSquare ↑z) (IsSquare z)","decl":"@[norm_cast, simp]\ntheorem isSquare_intCast_iff {z : ℤ} : IsSquare (z : ℚ) ↔ IsSquare z := by\n  simp_rw [isSquare_iff, intCast_num, intCast_den, IsSquare.one, and_true]\n\n"}
{"name":"Rat.isSquare_ofNat_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n : Nat\n⊢ Iff (IsSquare (OfNat.ofNat n)) (IsSquare (OfNat.ofNat n))","decl":"@[simp]\ntheorem isSquare_ofNat_iff {n : ℕ} :\n    IsSquare (ofNat(n) : ℚ) ↔ IsSquare (OfNat.ofNat n : ℕ) :=\n  isSquare_natCast_iff\n\n"}
{"name":"Rat.exists_eq_mul_div_num_and_eq_mul_div_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n d : Int\nd_ne_zero : Ne d 0\n⊢ Exists fun c => And (Eq n (HMul.hMul c (HDiv.hDiv ↑n ↑d).num)) (Eq d (HMul.hMul c ↑(HDiv.hDiv ↑n ↑d).den))","decl":"theorem exists_eq_mul_div_num_and_eq_mul_div_den (n : ℤ) {d : ℤ} (d_ne_zero : d ≠ 0) :\n    ∃ c : ℤ, n = c * ((n : ℚ) / d).num ∧ (d : ℤ) = c * ((n : ℚ) / d).den :=\n  haveI : (n : ℚ) / d = Rat.divInt n d := by rw [← Rat.divInt_eq_div]\n  Rat.num_den_mk d_ne_zero this\n\n"}
{"name":"Rat.mul_num_den'","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q r : Rat\n⊢ Eq (HMul.hMul (HMul.hMul (HMul.hMul q r).num ↑q.den) ↑r.den) (HMul.hMul (HMul.hMul q.num r.num) ↑(HMul.hMul q r).den)","decl":"theorem mul_num_den' (q r : ℚ) :\n    (q * r).num * q.den * r.den = q.num * r.num * (q * r).den := by\n  let s := q.num * r.num /. (q.den * r.den : ℤ)\n  have hs : (q.den * r.den : ℤ) ≠ 0 := Int.natCast_ne_zero_iff_pos.mpr (Nat.mul_pos q.pos r.pos)\n  obtain ⟨c, ⟨c_mul_num, c_mul_den⟩⟩ :=\n    exists_eq_mul_div_num_and_eq_mul_div_den (q.num * r.num) hs\n  rw [c_mul_num, mul_assoc, mul_comm]\n  nth_rw 1 [c_mul_den]\n  rw [Int.mul_assoc, Int.mul_assoc, mul_eq_mul_left_iff, or_iff_not_imp_right]\n  intro\n  have h : _ = s := divInt_mul_divInt q.num r.num (mod_cast q.den_ne_zero) (mod_cast r.den_ne_zero)\n  rw [num_divInt_den, num_divInt_den] at h\n  rw [h, mul_comm, ← Rat.eq_iff_mul_eq_mul, ← divInt_eq_div]\n\n"}
{"name":"Rat.add_num_den'","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q r : Rat\n⊢ Eq (HMul.hMul (HMul.hMul (HAdd.hAdd q r).num ↑q.den) ↑r.den) (HMul.hMul (HAdd.hAdd (HMul.hMul q.num ↑r.den) (HMul.hMul r.num ↑q.den)) ↑(HAdd.hAdd q r).den)","decl":"theorem add_num_den' (q r : ℚ) :\n    (q + r).num * q.den * r.den = (q.num * r.den + r.num * q.den) * (q + r).den := by\n  let s := divInt (q.num * r.den + r.num * q.den) (q.den * r.den : ℤ)\n  have hs : (q.den * r.den : ℤ) ≠ 0 := Int.natCast_ne_zero_iff_pos.mpr (Nat.mul_pos q.pos r.pos)\n  obtain ⟨c, ⟨c_mul_num, c_mul_den⟩⟩ :=\n    exists_eq_mul_div_num_and_eq_mul_div_den (q.num * r.den + r.num * q.den) hs\n  rw [c_mul_num, mul_assoc, mul_comm]\n  nth_rw 1 [c_mul_den]\n  repeat rw [Int.mul_assoc]\n  apply mul_eq_mul_left_iff.2\n  rw [or_iff_not_imp_right]\n  intro\n  have h : _ = s := divInt_add_divInt q.num r.num (mod_cast q.den_ne_zero) (mod_cast r.den_ne_zero)\n  rw [num_divInt_den, num_divInt_den] at h\n  rw [h]\n  rw [mul_comm]\n  apply Rat.eq_iff_mul_eq_mul.mp\n  rw [← divInt_eq_div]\n\n"}
{"name":"Rat.substr_num_den'","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q r : Rat\n⊢ Eq (HMul.hMul (HMul.hMul (HSub.hSub q r).num ↑q.den) ↑r.den) (HMul.hMul (HSub.hSub (HMul.hMul q.num ↑r.den) (HMul.hMul r.num ↑q.den)) ↑(HSub.hSub q r).den)","decl":"theorem substr_num_den' (q r : ℚ) :\n    (q - r).num * q.den * r.den = (q.num * r.den - r.num * q.den) * (q - r).den := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, ← neg_mul, ← num_neg_eq_neg_num, ← den_neg_eq_den r,\n    add_num_den' q (-r)]\n\n"}
{"name":"Rat.inv_neg","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"q : Rat\n⊢ Eq (Inv.inv (Neg.neg q)) (Neg.neg (Inv.inv q))","decl":"protected theorem inv_neg (q : ℚ) : (-q)⁻¹ = -q⁻¹ := by\n  rw [← num_divInt_den q]\n  simp only [Rat.neg_divInt, Rat.inv_divInt', eq_self_iff_true, Rat.divInt_neg]\n\n"}
{"name":"Rat.num_div_eq_of_coprime","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Int\nhb0 : LT.lt 0 b\nh : a.natAbs.Coprime b.natAbs\n⊢ Eq (HDiv.hDiv ↑a ↑b).num a","decl":"theorem num_div_eq_of_coprime {a b : ℤ} (hb0 : 0 < b) (h : Nat.Coprime a.natAbs b.natAbs) :\n    (a / b : ℚ).num = a := by\n  -- Porting note: was `lift b to ℕ using le_of_lt hb0`\n  rw [← Int.natAbs_of_nonneg hb0.le, ← Rat.divInt_eq_div,\n    ← mk_eq_divInt _ _ (Int.natAbs_ne_zero.mpr hb0.ne') h]\n\n"}
{"name":"Rat.den_div_eq_of_coprime","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Int\nhb0 : LT.lt 0 b\nh : a.natAbs.Coprime b.natAbs\n⊢ Eq (↑(HDiv.hDiv ↑a ↑b).den) b","decl":"theorem den_div_eq_of_coprime {a b : ℤ} (hb0 : 0 < b) (h : Nat.Coprime a.natAbs b.natAbs) :\n    ((a / b : ℚ).den : ℤ) = b := by\n  -- Porting note: was `lift b to ℕ using le_of_lt hb0`\n  rw [← Int.natAbs_of_nonneg hb0.le, ← Rat.divInt_eq_div,\n    ← mk_eq_divInt _ _ (Int.natAbs_ne_zero.mpr hb0.ne') h]\n\n"}
{"name":"Rat.div_int_inj","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b c d : Int\nhb0 : LT.lt 0 b\nhd0 : LT.lt 0 d\nh1 : a.natAbs.Coprime b.natAbs\nh2 : c.natAbs.Coprime d.natAbs\nh : Eq (HDiv.hDiv ↑a ↑b) (HDiv.hDiv ↑c ↑d)\n⊢ And (Eq a c) (Eq b d)","decl":"theorem div_int_inj {a b c d : ℤ} (hb0 : 0 < b) (hd0 : 0 < d) (h1 : Nat.Coprime a.natAbs b.natAbs)\n    (h2 : Nat.Coprime c.natAbs d.natAbs) (h : (a : ℚ) / b = (c : ℚ) / d) : a = c ∧ b = d := by\n  apply And.intro\n  · rw [← num_div_eq_of_coprime hb0 h1, h, num_div_eq_of_coprime hd0 h2]\n  · rw [← den_div_eq_of_coprime hb0 h1, h, den_div_eq_of_coprime hd0 h2]\n\n"}
{"name":"Rat.intCast_div_self","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n : Int\n⊢ Eq (↑(HDiv.hDiv n n)) (HDiv.hDiv ↑n ↑n)","decl":"@[norm_cast]\ntheorem intCast_div_self (n : ℤ) : ((n / n : ℤ) : ℚ) = n / n := by\n  by_cases hn : n = 0\n  · subst hn\n    simp only [Int.cast_zero, Int.zero_tdiv, zero_div, Int.ediv_zero]\n  · have : (n : ℚ) ≠ 0 := by rwa [← coe_int_inj] at hn\n    simp only [Int.ediv_self hn, Int.cast_one, Ne, not_false_iff, div_self this]\n\n"}
{"name":"Rat.natCast_div_self","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"n : Nat\n⊢ Eq (↑(HDiv.hDiv n n)) (HDiv.hDiv ↑n ↑n)","decl":"@[norm_cast]\ntheorem natCast_div_self (n : ℕ) : ((n / n : ℕ) : ℚ) = n / n :=\n  intCast_div_self n\n\n"}
{"name":"Rat.intCast_div","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Int\nh : Dvd.dvd b a\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"theorem intCast_div (a b : ℤ) (h : b ∣ a) : ((a / b : ℤ) : ℚ) = a / b := by\n  rcases h with ⟨c, rfl⟩\n  rw [mul_comm b, Int.mul_ediv_assoc c (dvd_refl b), Int.cast_mul,\n    intCast_div_self, Int.cast_mul, mul_div_assoc]\n\n"}
{"name":"Rat.natCast_div","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a b : Nat\nh : Dvd.dvd b a\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"theorem natCast_div (a b : ℕ) (h : b ∣ a) : ((a / b : ℕ) : ℚ) = a / b :=\n  intCast_div a b (Int.ofNat_dvd.mpr h)\n\n"}
{"name":"Rat.den_div_intCast_eq_one_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"m n : Int\nhn : Ne n 0\n⊢ Iff (Eq (HDiv.hDiv ↑m ↑n).den 1) (Dvd.dvd n m)","decl":"theorem den_div_intCast_eq_one_iff (m n : ℤ) (hn : n ≠ 0) : ((m : ℚ) / n).den = 1 ↔ n ∣ m := by\n  replace hn : (n : ℚ) ≠ 0 := num_ne_zero.mp hn\n  constructor\n  · rw [Rat.den_eq_one_iff, eq_div_iff hn]\n    exact mod_cast (Dvd.intro_left _)\n  · exact (intCast_div _ _ · ▸ rfl)\n\n"}
{"name":"Rat.den_div_natCast_eq_one_iff","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HDiv.hDiv ↑m ↑n).den 1) (Dvd.dvd n m)","decl":"theorem den_div_natCast_eq_one_iff (m n : ℕ) (hn : n ≠ 0) : ((m : ℚ) / n).den = 1 ↔ n ∣ m :=\n  (den_div_intCast_eq_one_iff m n (Int.ofNat_ne_zero.mpr hn)).trans Int.ofNat_dvd\n\n"}
{"name":"Rat.inv_intCast_num_of_pos","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Int\nha0 : LT.lt 0 a\n⊢ Eq (Inv.inv ↑a).num 1","decl":"theorem inv_intCast_num_of_pos {a : ℤ} (ha0 : 0 < a) : (a : ℚ)⁻¹.num = 1 := by\n  rw [← ofInt_eq_cast, ofInt, mk_eq_divInt, Rat.inv_divInt', divInt_eq_div, Nat.cast_one]\n  apply num_div_eq_of_coprime ha0\n  rw [Int.natAbs_one]\n  exact Nat.coprime_one_left _\n\n"}
{"name":"Rat.inv_natCast_num_of_pos","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\nha0 : LT.lt 0 a\n⊢ Eq (Inv.inv ↑a).num 1","decl":"theorem inv_natCast_num_of_pos {a : ℕ} (ha0 : 0 < a) : (a : ℚ)⁻¹.num = 1 :=\n  inv_intCast_num_of_pos (mod_cast ha0 : 0 < (a : ℤ))\n\n"}
{"name":"Rat.inv_intCast_den_of_pos","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Int\nha0 : LT.lt 0 a\n⊢ Eq (↑(Inv.inv ↑a).den) a","decl":"theorem inv_intCast_den_of_pos {a : ℤ} (ha0 : 0 < a) : ((a : ℚ)⁻¹.den : ℤ) = a := by\n  rw [← ofInt_eq_cast, ofInt, mk_eq_divInt, Rat.inv_divInt', divInt_eq_div, Nat.cast_one]\n  apply den_div_eq_of_coprime ha0\n  rw [Int.natAbs_one]\n  exact Nat.coprime_one_left _\n\n"}
{"name":"Rat.inv_natCast_den_of_pos","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\nha0 : LT.lt 0 a\n⊢ Eq (Inv.inv ↑a).den a","decl":"theorem inv_natCast_den_of_pos {a : ℕ} (ha0 : 0 < a) : (a : ℚ)⁻¹.den = a := by\n  rw [← Int.ofNat_inj, ← Int.cast_natCast a, inv_intCast_den_of_pos]\n  rwa [Int.natCast_pos]\n\n"}
{"name":"Rat.inv_intCast_num","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Int\n⊢ Eq (Inv.inv ↑a).num a.sign","decl":"@[simp]\ntheorem inv_intCast_num (a : ℤ) : (a : ℚ)⁻¹.num = Int.sign a := by\n  rcases lt_trichotomy a 0 with lt | rfl | gt\n  · obtain ⟨a, rfl⟩ : ∃ b, -b = a := ⟨-a, a.neg_neg⟩\n    simp at lt\n    simp [Rat.inv_neg, inv_intCast_num_of_pos lt, Int.sign_eq_one_iff_pos.mpr lt]\n  · simp\n  · simp [inv_intCast_num_of_pos gt, Int.sign_eq_one_iff_pos.mpr gt]\n\n"}
{"name":"Rat.inv_natCast_num","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\n⊢ Eq (Inv.inv ↑a).num (↑a).sign","decl":"@[simp]\ntheorem inv_natCast_num (a : ℕ) : (a : ℚ)⁻¹.num = Int.sign a :=\n  inv_intCast_num a\n\n"}
{"name":"Rat.inv_ofNat_num","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\ninst✝ : a.AtLeastTwo\n⊢ Eq (Inv.inv (OfNat.ofNat a)).num 1","decl":"@[simp]\ntheorem inv_ofNat_num (a : ℕ) [a.AtLeastTwo] : (ofNat(a) : ℚ)⁻¹.num = 1 :=\n  inv_natCast_num_of_pos (Nat.pos_of_neZero a)\n\n"}
{"name":"Rat.inv_intCast_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Int\n⊢ Eq (Inv.inv ↑a).den (ite (Eq a 0) 1 a.natAbs)","decl":"@[simp]\ntheorem inv_intCast_den (a : ℤ) : (a : ℚ)⁻¹.den = if a = 0 then 1 else a.natAbs := by\n  rw [← Int.ofNat_inj]\n  rcases lt_trichotomy a 0 with lt | rfl | gt\n  · obtain ⟨a, rfl⟩ : ∃ b, -b = a := ⟨-a, a.neg_neg⟩\n    simp at lt\n    rw [if_neg (by omega)]\n    simp only [Int.cast_neg, Rat.inv_neg, neg_den, inv_intCast_den_of_pos lt, Int.natAbs_neg]\n    exact Int.eq_natAbs_of_zero_le (by omega)\n  · simp\n  · rw [if_neg (by omega)]\n    simp only [inv_intCast_den_of_pos gt]\n    exact Int.eq_natAbs_of_zero_le (by omega)\n\n"}
{"name":"Rat.inv_natCast_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\n⊢ Eq (Inv.inv ↑a).den (ite (Eq a 0) 1 a)","decl":"@[simp]\ntheorem inv_natCast_den (a : ℕ) : (a : ℚ)⁻¹.den = if a = 0 then 1 else a := by\n  simpa [-inv_intCast_den, ofInt_eq_cast] using inv_intCast_den a\n\n"}
{"name":"Rat.inv_ofNat_den","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"a : Nat\ninst✝ : a.AtLeastTwo\n⊢ Eq (Inv.inv (OfNat.ofNat a)).den (OfNat.ofNat a)","decl":"@[simp]\ntheorem inv_ofNat_den (a : ℕ) [a.AtLeastTwo] :\n    (ofNat(a) : ℚ)⁻¹.den = OfNat.ofNat a :=\n  inv_natCast_den_of_pos (Nat.pos_of_neZero a)\n\n"}
{"name":"Rat.forall","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"p : Rat → Prop\n⊢ Iff (∀ (r : Rat), p r) (∀ (a b : Int), p (HDiv.hDiv ↑a ↑b))","decl":"protected theorem «forall» {p : ℚ → Prop} : (∀ r, p r) ↔ ∀ a b : ℤ, p (a / b) :=\n  ⟨fun h _ _ => h _,\n   fun h q => by\n    have := h q.num q.den\n    rwa [Int.cast_natCast, num_div_den q] at this⟩\n\n"}
{"name":"Rat.exists","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"p : Rat → Prop\n⊢ Iff (Exists fun r => p r) (Exists fun a => Exists fun b => p (HDiv.hDiv ↑a ↑b))","decl":"protected theorem «exists» {p : ℚ → Prop} : (∃ r, p r) ↔ ∃ a b : ℤ, p (a / b) :=\n  ⟨fun ⟨r, hr⟩ => ⟨r.num, r.den, by convert hr; convert num_div_den r⟩, fun ⟨_, _, h⟩ => ⟨_, h⟩⟩\n\n"}
{"name":"Rat.coe_pnatDen","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"x : Rat\n⊢ Eq (↑x.pnatDen) x.den","decl":"@[simp]\ntheorem coe_pnatDen (x : ℚ) : (x.pnatDen : ℕ) = x.den :=\n  rfl\n\n"}
{"name":"Rat.pnatDen_eq_iff_den_eq","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"x : Rat\nn : PNat\n⊢ Iff (Eq x.pnatDen n) (Eq x.den ↑n)","decl":"theorem pnatDen_eq_iff_den_eq {x : ℚ} {n : ℕ+} : x.pnatDen = n ↔ x.den = ↑n :=\n  Subtype.ext_iff\n\n"}
{"name":"Rat.pnatDen_one","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"⊢ Eq (Rat.pnatDen 1) 1","decl":"@[simp]\ntheorem pnatDen_one : (1 : ℚ).pnatDen = 1 :=\n  rfl\n\n"}
{"name":"Rat.pnatDen_zero","module":"Mathlib.Data.Rat.Lemmas","initialProofState":"⊢ Eq (Rat.pnatDen 0) 1","decl":"@[simp]\ntheorem pnatDen_zero : (0 : ℚ).pnatDen = 1 :=\n  rfl\n\n"}
