{"name":"coevaluation_apply_one","module":"Mathlib.LinearAlgebra.Coevaluation","initialProofState":"K : Type u\ninst✝³ : Field K\nV : Type v\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ Eq ((coevaluation K V) 1)\n    (let bV := Basis.ofVectorSpace K V;\n    Finset.univ.sum fun i => TensorProduct.tmul K (bV i) (bV.coord i))","decl":"theorem coevaluation_apply_one :\n    (coevaluation K V) (1 : K) =\n      let bV := Basis.ofVectorSpace K V\n      ∑ i : Basis.ofVectorSpaceIndex K V, bV i ⊗ₜ[K] bV.coord i := by\n  simp only [coevaluation, id]\n  rw [(Basis.singleton Unit K).constr_apply_fintype K]\n  simp only [Fintype.univ_punit, Finset.sum_const, one_smul, Basis.singleton_repr,\n    Basis.equivFun_apply, Basis.coe_ofVectorSpace, one_nsmul, Finset.card_singleton]\n\n"}
{"name":"contractLeft_assoc_coevaluation","module":"Mathlib.LinearAlgebra.Coevaluation","initialProofState":"K : Type u\ninst✝³ : Field K\nV : Type v\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ Eq ((LinearMap.rTensor (Module.Dual K V) (contractLeft K V)).comp ((↑(TensorProduct.assoc K (Module.Dual K V) V (Module.Dual K V)).symm).comp (LinearMap.lTensor (Module.Dual K V) (coevaluation K V)))) ((↑(TensorProduct.lid K (Module.Dual K V)).symm).comp ↑(TensorProduct.rid K (Module.Dual K V)))","decl":"/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `CategoryTheory.Monoidal.Rigid`. -/\ntheorem contractLeft_assoc_coevaluation :\n    (contractLeft K V).rTensor _ ∘ₗ\n        (TensorProduct.assoc K _ _ _).symm.toLinearMap ∘ₗ\n          (coevaluation K V).lTensor (Module.Dual K V) =\n      (TensorProduct.lid K _).symm.toLinearMap ∘ₗ (TensorProduct.rid K _).toLinearMap := by\n  letI := Classical.decEq (Basis.ofVectorSpaceIndex K V)\n  apply TensorProduct.ext\n  apply (Basis.ofVectorSpace K V).dualBasis.ext; intro j; apply LinearMap.ext_ring\n  rw [LinearMap.compr₂_apply, LinearMap.compr₂_apply, TensorProduct.mk_apply]\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearEquiv.coe_toLinearMap]\n  rw [rid_tmul, one_smul, lid_symm_apply]\n  simp only [LinearEquiv.coe_toLinearMap, LinearMap.lTensor_tmul, coevaluation_apply_one]\n  rw [TensorProduct.tmul_sum, map_sum]; simp only [assoc_symm_tmul]\n  rw [map_sum]; simp only [LinearMap.rTensor_tmul, contractLeft_apply]\n  simp only [Basis.coe_dualBasis, Basis.coord_apply, Basis.repr_self_apply, TensorProduct.ite_tmul]\n  rw [Finset.sum_ite_eq']; simp only [Finset.mem_univ, if_true]\n\n"}
{"name":"contractLeft_assoc_coevaluation'","module":"Mathlib.LinearAlgebra.Coevaluation","initialProofState":"K : Type u\ninst✝³ : Field K\nV : Type v\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ Eq ((LinearMap.lTensor V (contractLeft K V)).comp ((↑(TensorProduct.assoc K V (Module.Dual K V) V)).comp (LinearMap.rTensor V (coevaluation K V)))) ((↑(TensorProduct.rid K V).symm).comp ↑(TensorProduct.lid K V))","decl":"/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `CategoryTheory.Monoidal.Rigid`. -/\ntheorem contractLeft_assoc_coevaluation' :\n    (contractLeft K V).lTensor _ ∘ₗ\n        (TensorProduct.assoc K _ _ _).toLinearMap ∘ₗ (coevaluation K V).rTensor V =\n      (TensorProduct.rid K _).symm.toLinearMap ∘ₗ (TensorProduct.lid K _).toLinearMap := by\n  letI := Classical.decEq (Basis.ofVectorSpaceIndex K V)\n  apply TensorProduct.ext\n  apply LinearMap.ext_ring; apply (Basis.ofVectorSpace K V).ext; intro j\n  rw [LinearMap.compr₂_apply, LinearMap.compr₂_apply, TensorProduct.mk_apply]\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearEquiv.coe_toLinearMap]\n  rw [lid_tmul, one_smul, rid_symm_apply]\n  simp only [LinearEquiv.coe_toLinearMap, LinearMap.rTensor_tmul, coevaluation_apply_one]\n  rw [TensorProduct.sum_tmul, map_sum]; simp only [assoc_tmul]\n  rw [map_sum]; simp only [LinearMap.lTensor_tmul, contractLeft_apply]\n  simp only [Basis.coord_apply, Basis.repr_self_apply, TensorProduct.tmul_ite]\n  rw [Finset.sum_ite_eq]; simp only [Finset.mem_univ, if_true]\n\n"}
