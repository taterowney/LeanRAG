{"name":"CliffordAlgebra.involute_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (CliffordAlgebra.involute ((CliffordAlgebra.ι Q) m)) (Neg.neg ((CliffordAlgebra.ι Q) m))","decl":"@[simp]\ntheorem involute_ι (m : M) : involute (ι Q m) = -ι Q m :=\n  lift_ι_apply _ _ m\n\n"}
{"name":"CliffordAlgebra.involute_comp_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.involute.comp CliffordAlgebra.involute) (AlgHom.id R (CliffordAlgebra Q))","decl":"@[simp]\ntheorem involute_comp_involute : involute.comp involute = AlgHom.id R (CliffordAlgebra Q) := by\n  ext; simp\n\n"}
{"name":"CliffordAlgebra.involute_involutive","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Function.Involutive ⇑CliffordAlgebra.involute","decl":"theorem involute_involutive : Function.Involutive (involute : _ → CliffordAlgebra Q) :=\n  AlgHom.congr_fun involute_comp_involute\n\n"}
{"name":"CliffordAlgebra.involute_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.involute (CliffordAlgebra.involute a)) a","decl":"@[simp]\ntheorem involute_involute : ∀ a : CliffordAlgebra Q, involute (involute a) = a :=\n  involute_involutive\n\n"}
{"name":"CliffordAlgebra.involuteEquiv_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.involuteEquiv.symm a) (CliffordAlgebra.involute a)","decl":"/-- `CliffordAlgebra.involute` as an `AlgEquiv`. -/\n@[simps!]\ndef involuteEquiv : CliffordAlgebra Q ≃ₐ[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom involute involute (AlgHom.ext <| involute_involute)\n    (AlgHom.ext <| involute_involute)\n\n"}
{"name":"CliffordAlgebra.involuteEquiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.involuteEquiv a) (CliffordAlgebra.involute a)","decl":"/-- `CliffordAlgebra.involute` as an `AlgEquiv`. -/\n@[simps!]\ndef involuteEquiv : CliffordAlgebra Q ≃ₐ[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom involute involute (AlgHom.ext <| involute_involute)\n    (AlgHom.ext <| involute_involute)\n\n"}
{"name":"CliffordAlgebra.reverseOp_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (CliffordAlgebra.reverseOp ((CliffordAlgebra.ι Q) m)) (MulOpposite.op ((CliffordAlgebra.ι Q) m))","decl":"@[simp]\ntheorem reverseOp_ι (m : M) : reverseOp (ι Q m) = op (ι Q m) := lift_ι_apply _ _ _\n\n"}
{"name":"CliffordAlgebra.reverseOpEquiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverseOpEquiv a) (CliffordAlgebra.reverseOp a)","decl":"/-- `CliffordAlgebra.reverseEquiv` as an `AlgEquiv` to the opposite algebra -/\n@[simps! apply]\ndef reverseOpEquiv : CliffordAlgebra Q ≃ₐ[R] (CliffordAlgebra Q)ᵐᵒᵖ :=\n  AlgEquiv.ofAlgHom reverseOp (AlgHom.opComm reverseOp)\n    (AlgHom.unop.injective <| hom_ext <| LinearMap.ext fun _ => by simp)\n    (hom_ext <| LinearMap.ext fun _ => by simp)\n\n"}
{"name":"CliffordAlgebra.reverseOpEquiv_opComm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (AlgEquiv.opComm CliffordAlgebra.reverseOpEquiv) CliffordAlgebra.reverseOpEquiv.symm","decl":"@[simp]\ntheorem reverseOpEquiv_opComm :\n    AlgEquiv.opComm (reverseOpEquiv (Q := Q)) = reverseOpEquiv.symm := rfl\n\n"}
{"name":"CliffordAlgebra.unop_reverseOp","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Eq (MulOpposite.unop (CliffordAlgebra.reverseOp x)) (CliffordAlgebra.reverse x)","decl":"@[simp] theorem unop_reverseOp (x : CliffordAlgebra Q) : (reverseOp x).unop = reverse x := rfl\n\n"}
{"name":"CliffordAlgebra.op_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Eq (MulOpposite.op (CliffordAlgebra.reverse x)) (CliffordAlgebra.reverseOp x)","decl":"@[simp] theorem op_reverse (x : CliffordAlgebra Q) : op (reverse x) = reverseOp x := rfl\n\n"}
{"name":"CliffordAlgebra.reverse_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (CliffordAlgebra.reverse ((CliffordAlgebra.ι Q) m)) ((CliffordAlgebra.ι Q) m)","decl":"@[simp]\ntheorem reverse_ι (m : M) : reverse (ι Q m) = ι Q m := by simp [reverse]\n\n"}
{"name":"CliffordAlgebra.reverse.commutes","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nr : R\n⊢ Eq (CliffordAlgebra.reverse ((algebraMap R (CliffordAlgebra Q)) r)) ((algebraMap R (CliffordAlgebra Q)) r)","decl":"@[simp]\ntheorem reverse.commutes (r : R) :\n    reverse (algebraMap R (CliffordAlgebra Q) r) = algebraMap R _ r :=\n  op_injective <| reverseOp.commutes r\n\n"}
{"name":"CliffordAlgebra.reverse.map_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.reverse 1) 1","decl":"@[simp]\ntheorem reverse.map_one : reverse (1 : CliffordAlgebra Q) = 1 :=\n  op_injective (_root_.map_one reverseOp)\n\n"}
{"name":"CliffordAlgebra.reverse.map_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverse (HMul.hMul a b)) (HMul.hMul (CliffordAlgebra.reverse b) (CliffordAlgebra.reverse a))","decl":"@[simp]\ntheorem reverse.map_mul (a b : CliffordAlgebra Q) :\n    reverse (a * b) = reverse b * reverse a :=\n  op_injective (_root_.map_mul reverseOp a b)\n\n"}
{"name":"CliffordAlgebra.reverse_involutive","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Function.Involutive ⇑CliffordAlgebra.reverse","decl":"@[simp]\ntheorem reverse_involutive : Function.Involutive (reverse (Q := Q)) :=\n  AlgHom.congr_fun reverseOpEquiv.symm_comp\n\n"}
{"name":"CliffordAlgebra.reverse_comp_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.reverse.comp CliffordAlgebra.reverse) LinearMap.id","decl":"@[simp]\ntheorem reverse_comp_reverse :\n    reverse.comp reverse = (LinearMap.id : _ →ₗ[R] CliffordAlgebra Q) :=\n  LinearMap.ext reverse_involutive\n\n"}
{"name":"CliffordAlgebra.reverse_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverse (CliffordAlgebra.reverse a)) a","decl":"@[simp]\ntheorem reverse_reverse : ∀ a : CliffordAlgebra Q, reverse (reverse a) = a :=\n  reverse_involutive\n\n"}
{"name":"CliffordAlgebra.reverseEquiv_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na✝ : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverseEquiv.symm a✝) (CliffordAlgebra.reverse a✝)","decl":"/-- `CliffordAlgebra.reverse` as a `LinearEquiv`. -/\n@[simps!]\ndef reverseEquiv : CliffordAlgebra Q ≃ₗ[R] CliffordAlgebra Q :=\n  LinearEquiv.ofInvolutive reverse reverse_involutive\n\n"}
{"name":"CliffordAlgebra.reverseEquiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na✝ : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverseEquiv a✝) (CliffordAlgebra.reverse a✝)","decl":"/-- `CliffordAlgebra.reverse` as a `LinearEquiv`. -/\n@[simps!]\ndef reverseEquiv : CliffordAlgebra Q ≃ₗ[R] CliffordAlgebra Q :=\n  LinearEquiv.ofInvolutive reverse reverse_involutive\n\n"}
{"name":"CliffordAlgebra.reverse_comp_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.reverse.comp CliffordAlgebra.involute.toLinearMap) (CliffordAlgebra.involute.toLinearMap.comp CliffordAlgebra.reverse)","decl":"theorem reverse_comp_involute :\n    reverse.comp involute.toLinearMap =\n      (involute.toLinearMap.comp reverse : _ →ₗ[R] CliffordAlgebra Q) := by\n  ext x\n  simp only [LinearMap.comp_apply, AlgHom.toLinearMap_apply]\n  induction x using CliffordAlgebra.induction with\n  | algebraMap => simp\n  | ι => simp\n  | mul a b ha hb => simp only [ha, hb, reverse.map_mul, map_mul]\n  | add a b ha hb => simp only [ha, hb, reverse.map_add, map_add]\n\n"}
{"name":"CliffordAlgebra.reverse_involute_commute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Function.Commute ⇑CliffordAlgebra.reverse ⇑CliffordAlgebra.involute","decl":"/-- `CliffordAlgebra.reverse` and `CliffordAlgebra.involute` commute. Note that the composition\nis sometimes referred to as the \"clifford conjugate\". -/\ntheorem reverse_involute_commute : Function.Commute (reverse (Q := Q)) involute :=\n  LinearMap.congr_fun reverse_comp_involute\n\n"}
{"name":"CliffordAlgebra.reverse_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : CliffordAlgebra Q\n⊢ Eq (CliffordAlgebra.reverse (CliffordAlgebra.involute a)) (CliffordAlgebra.involute (CliffordAlgebra.reverse a))","decl":"theorem reverse_involute :\n    ∀ a : CliffordAlgebra Q, reverse (involute a) = involute (reverse a) :=\n  reverse_involute_commute\n\n"}
{"name":"CliffordAlgebra.reverse_prod_map_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nl : List M\n⊢ Eq (CliffordAlgebra.reverse (List.map (⇑(CliffordAlgebra.ι Q)) l).prod) (List.map (⇑(CliffordAlgebra.ι Q)) l).reverse.prod","decl":"/-- Taking the reverse of the product a list of $n$ vectors lifted via `ι` is equivalent to\ntaking the product of the reverse of that list. -/\ntheorem reverse_prod_map_ι :\n    ∀ l : List M, reverse (l.map <| ι Q).prod = (l.map <| ι Q).reverse.prod\n  | [] => by simp\n  | x::xs => by simp [reverse_prod_map_ι xs]\n\n"}
{"name":"CliffordAlgebra.involute_prod_map_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nl : List M\n⊢ Eq (CliffordAlgebra.involute (List.map (⇑(CliffordAlgebra.ι Q)) l).prod) (HSMul.hSMul (HPow.hPow (-1) l.length) (List.map (⇑(CliffordAlgebra.ι Q)) l).prod)","decl":"/-- Taking the involute of the product a list of $n$ vectors lifted via `ι` is equivalent to\npremultiplying by ${-1}^n$. -/\ntheorem involute_prod_map_ι :\n    ∀ l : List M, involute (l.map <| ι Q).prod = (-1 : R) ^ l.length • (l.map <| ι Q).prod\n  | [] => by simp\n  | x::xs => by simp [pow_succ, involute_prod_map_ι xs]\n\n"}
{"name":"CliffordAlgebra.submodule_map_involute_eq_comap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np : Submodule R (CliffordAlgebra Q)\n⊢ Eq (Submodule.map CliffordAlgebra.involute.toLinearMap p) (Submodule.comap CliffordAlgebra.involute.toLinearMap p)","decl":"theorem submodule_map_involute_eq_comap (p : Submodule R (CliffordAlgebra Q)) :\n    p.map (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap =\n      p.comap (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap :=\n  Submodule.map_equiv_eq_comap_symm involuteEquiv.toLinearEquiv _\n\n"}
{"name":"CliffordAlgebra.ι_range_map_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (Submodule.map CliffordAlgebra.involute.toLinearMap (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"@[simp]\ntheorem ι_range_map_involute :\n    (ι Q).range.map (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap =\n      LinearMap.range (ι Q) :=\n  (ι_range_map_lift _ _).trans (LinearMap.range_neg _)\n\n"}
{"name":"CliffordAlgebra.ι_range_comap_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (Submodule.comap CliffordAlgebra.involute.toLinearMap (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"@[simp]\ntheorem ι_range_comap_involute :\n    (ι Q).range.comap (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap =\n      LinearMap.range (ι Q) := by\n  rw [← submodule_map_involute_eq_comap, ι_range_map_involute]\n\n"}
{"name":"CliffordAlgebra.evenOdd_map_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nn : ZMod 2\n⊢ Eq (Submodule.map CliffordAlgebra.involute.toLinearMap (CliffordAlgebra.evenOdd Q n)) (CliffordAlgebra.evenOdd Q n)","decl":"@[simp]\ntheorem evenOdd_map_involute (n : ZMod 2) :\n    (evenOdd Q n).map (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap =\n      evenOdd Q n := by\n  simp_rw [evenOdd, Submodule.map_iSup, Submodule.map_pow, ι_range_map_involute]\n\n"}
{"name":"CliffordAlgebra.evenOdd_comap_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nn : ZMod 2\n⊢ Eq (Submodule.comap CliffordAlgebra.involute.toLinearMap (CliffordAlgebra.evenOdd Q n)) (CliffordAlgebra.evenOdd Q n)","decl":"@[simp]\ntheorem evenOdd_comap_involute (n : ZMod 2) :\n    (evenOdd Q n).comap (involute : CliffordAlgebra Q →ₐ[R] CliffordAlgebra Q).toLinearMap =\n      evenOdd Q n := by\n  rw [← submodule_map_involute_eq_comap, evenOdd_map_involute]\n\n"}
{"name":"CliffordAlgebra.submodule_map_reverse_eq_comap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np : Submodule R (CliffordAlgebra Q)\n⊢ Eq (Submodule.map CliffordAlgebra.reverse p) (Submodule.comap CliffordAlgebra.reverse p)","decl":"theorem submodule_map_reverse_eq_comap (p : Submodule R (CliffordAlgebra Q)) :\n    p.map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) =\n      p.comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) :=\n  Submodule.map_equiv_eq_comap_symm (reverseEquiv : _ ≃ₗ[R] _) _\n\n"}
{"name":"CliffordAlgebra.ι_range_map_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (Submodule.map CliffordAlgebra.reverse (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"@[simp]\ntheorem ι_range_map_reverse :\n    (ι Q).range.map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q)\n      = LinearMap.range (ι Q) := by\n  rw [reverse, reverseOp, Submodule.map_comp, ι_range_map_lift, LinearMap.range_comp,\n    ← Submodule.map_comp]\n  exact Submodule.map_id _\n\n"}
{"name":"CliffordAlgebra.ι_range_comap_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (Submodule.comap CliffordAlgebra.reverse (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"@[simp]\ntheorem ι_range_comap_reverse :\n    (ι Q).range.comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q)\n      = LinearMap.range (ι Q) := by\n  rw [← submodule_map_reverse_eq_comap, ι_range_map_reverse]\n\n"}
{"name":"CliffordAlgebra.submodule_map_mul_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np q : Submodule R (CliffordAlgebra Q)\n⊢ Eq (Submodule.map CliffordAlgebra.reverse (HMul.hMul p q)) (HMul.hMul (Submodule.map CliffordAlgebra.reverse q) (Submodule.map CliffordAlgebra.reverse p))","decl":"/-- Like `Submodule.map_mul`, but with the multiplication reversed. -/\ntheorem submodule_map_mul_reverse (p q : Submodule R (CliffordAlgebra Q)) :\n    (p * q).map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) =\n      q.map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) *\n        p.map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) := by\n  simp_rw [reverse, Submodule.map_comp, Submodule.map_mul, Submodule.map_unop_mul]\n\n"}
{"name":"CliffordAlgebra.submodule_comap_mul_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np q : Submodule R (CliffordAlgebra Q)\n⊢ Eq (Submodule.comap CliffordAlgebra.reverse (HMul.hMul p q)) (HMul.hMul (Submodule.comap CliffordAlgebra.reverse q) (Submodule.comap CliffordAlgebra.reverse p))","decl":"theorem submodule_comap_mul_reverse (p q : Submodule R (CliffordAlgebra Q)) :\n    (p * q).comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) =\n      q.comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) *\n        p.comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) := by\n  simp_rw [← submodule_map_reverse_eq_comap, submodule_map_mul_reverse]\n\n"}
{"name":"CliffordAlgebra.submodule_map_pow_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np : Submodule R (CliffordAlgebra Q)\nn : Nat\n⊢ Eq (Submodule.map CliffordAlgebra.reverse (HPow.hPow p n)) (HPow.hPow (Submodule.map CliffordAlgebra.reverse p) n)","decl":"/-- Like `Submodule.map_pow` -/\ntheorem submodule_map_pow_reverse (p : Submodule R (CliffordAlgebra Q)) (n : ℕ) :\n    (p ^ n).map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) =\n      p.map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) ^ n := by\n  simp_rw [reverse, Submodule.map_comp, Submodule.map_pow, Submodule.map_unop_pow]\n\n"}
{"name":"CliffordAlgebra.submodule_comap_pow_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\np : Submodule R (CliffordAlgebra Q)\nn : Nat\n⊢ Eq (Submodule.comap CliffordAlgebra.reverse (HPow.hPow p n)) (HPow.hPow (Submodule.comap CliffordAlgebra.reverse p) n)","decl":"theorem submodule_comap_pow_reverse (p : Submodule R (CliffordAlgebra Q)) (n : ℕ) :\n    (p ^ n).comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) =\n      p.comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) ^ n := by\n  simp_rw [← submodule_map_reverse_eq_comap, submodule_map_pow_reverse]\n\n"}
{"name":"CliffordAlgebra.evenOdd_map_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nn : ZMod 2\n⊢ Eq (Submodule.map CliffordAlgebra.reverse (CliffordAlgebra.evenOdd Q n)) (CliffordAlgebra.evenOdd Q n)","decl":"@[simp]\ntheorem evenOdd_map_reverse (n : ZMod 2) :\n    (evenOdd Q n).map (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) = evenOdd Q n := by\n  simp_rw [evenOdd, Submodule.map_iSup, submodule_map_pow_reverse, ι_range_map_reverse]\n\n"}
{"name":"CliffordAlgebra.evenOdd_comap_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nn : ZMod 2\n⊢ Eq (Submodule.comap CliffordAlgebra.reverse (CliffordAlgebra.evenOdd Q n)) (CliffordAlgebra.evenOdd Q n)","decl":"@[simp]\ntheorem evenOdd_comap_reverse (n : ZMod 2) :\n    (evenOdd Q n).comap (reverse : CliffordAlgebra Q →ₗ[R] CliffordAlgebra Q) = evenOdd Q n := by\n  rw [← submodule_map_reverse_eq_comap, evenOdd_map_reverse]\n\n"}
{"name":"CliffordAlgebra.involute_mem_evenOdd_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nn : ZMod 2\n⊢ Iff (Membership.mem (CliffordAlgebra.evenOdd Q n) (CliffordAlgebra.involute x)) (Membership.mem (CliffordAlgebra.evenOdd Q n) x)","decl":"@[simp]\ntheorem involute_mem_evenOdd_iff {x : CliffordAlgebra Q} {n : ZMod 2} :\n    involute x ∈ evenOdd Q n ↔ x ∈ evenOdd Q n :=\n  SetLike.ext_iff.mp (evenOdd_comap_involute Q n) x\n\n"}
{"name":"CliffordAlgebra.reverse_mem_evenOdd_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nn : ZMod 2\n⊢ Iff (Membership.mem (CliffordAlgebra.evenOdd Q n) (CliffordAlgebra.reverse x)) (Membership.mem (CliffordAlgebra.evenOdd Q n) x)","decl":"@[simp]\ntheorem reverse_mem_evenOdd_iff {x : CliffordAlgebra Q} {n : ZMod 2} :\n    reverse x ∈ evenOdd Q n ↔ x ∈ evenOdd Q n :=\n  SetLike.ext_iff.mp (evenOdd_comap_reverse Q n) x\n\n"}
{"name":"CliffordAlgebra.involute_eq_of_mem_even","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nh : Membership.mem (CliffordAlgebra.evenOdd Q 0) x\n⊢ Eq (CliffordAlgebra.involute x) x","decl":"theorem involute_eq_of_mem_even {x : CliffordAlgebra Q} (h : x ∈ evenOdd Q 0) : involute x = x := by\n  induction x, h using even_induction with\n  | algebraMap r => exact AlgHom.commutes _ _\n  | add x y _hx _hy ihx ihy =>\n    rw [map_add, ihx, ihy]\n  | ι_mul_ι_mul m₁ m₂ x _hx ihx =>\n    rw [map_mul, map_mul, involute_ι, involute_ι, ihx, neg_mul_neg]\n\n"}
{"name":"CliffordAlgebra.involute_eq_of_mem_odd","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nh : Membership.mem (CliffordAlgebra.evenOdd Q 1) x\n⊢ Eq (CliffordAlgebra.involute x) (Neg.neg x)","decl":"theorem involute_eq_of_mem_odd {x : CliffordAlgebra Q} (h : x ∈ evenOdd Q 1) : involute x = -x := by\n  induction x, h using odd_induction with\n  | ι m => exact involute_ι _\n  | add x y _hx _hy ihx ihy =>\n    rw [map_add, ihx, ihy, neg_add]\n  | ι_mul_ι_mul m₁ m₂ x _hx ihx =>\n    rw [map_mul, map_mul, involute_ι, involute_ι, ihx, neg_mul_neg, mul_neg]\n\n"}
