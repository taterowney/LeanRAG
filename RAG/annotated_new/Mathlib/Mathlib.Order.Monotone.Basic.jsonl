{"name":"monotone_inclusion_le_le_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nk j : α\nhkj : LE.le k j\n⊢ Monotone fun x => monotone_inclusion_le_le_of_le.match_1 (fun x => Subtype fun i => LE.le i j) x fun i hi => ⟨i, ⋯⟩","decl":"lemma monotone_inclusion_le_le_of_le [Preorder α] {k j : α} (hkj : k ≤ j) :\n    Monotone (fun ⟨i, hi⟩ => ⟨i, hi.trans hkj⟩ : { i // i ≤ k } → { i // i ≤ j}) :=\n  fun _ _ h => h\n\n"}
{"name":"monotone_inclusion_lt_le_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nk j : α\nhkj : LE.le k j\n⊢ Monotone fun x => monotone_inclusion_lt_le_of_le.match_1 (fun x => Subtype fun i => LE.le i j) x fun i hi => ⟨i, ⋯⟩","decl":"lemma monotone_inclusion_lt_le_of_le [Preorder α] {k j : α} (hkj : k ≤ j) :\n    Monotone (fun ⟨i, hi⟩ => ⟨i, hi.le.trans hkj⟩ : { i // i < k } → { i // i ≤ j}) :=\n  fun _ _ h => h\n\n"}
{"name":"monotone_inclusion_lt_lt_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nk j : α\nhkj : LE.le k j\n⊢ Monotone fun x => monotone_inclusion_lt_le_of_le.match_1 (fun x => Subtype fun i => LT.lt i j) x fun i hi => ⟨i, ⋯⟩","decl":"lemma monotone_inclusion_lt_lt_of_le [Preorder α] {k j : α} (hkj : k ≤ j) :\n    Monotone (fun ⟨i, hi⟩ => ⟨i, lt_of_lt_of_le hi hkj⟩ : { i // i < k } → { i // i < j}) :=\n  fun _ _ h => h\n\n"}
{"name":"monotone_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone (Function.comp f ⇑OrderDual.ofDual)) (Antitone f)","decl":"@[simp]\ntheorem monotone_comp_ofDual_iff : Monotone (f ∘ ofDual) ↔ Antitone f :=\n  forall_swap\n\n"}
{"name":"antitone_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone (Function.comp f ⇑OrderDual.ofDual)) (Monotone f)","decl":"@[simp]\ntheorem antitone_comp_ofDual_iff : Antitone (f ∘ ofDual) ↔ Monotone f :=\n  forall_swap\n\n-- Porting note:\n-- Here (and below) without the type ascription, Lean is seeing through the\n-- defeq `βᵒᵈ = β` and picking up the wrong `Preorder` instance.\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631/near/311744939\n"}
{"name":"monotone_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone (Function.comp (⇑OrderDual.toDual) f)) (Antitone f)","decl":"@[simp]\ntheorem monotone_toDual_comp_iff : Monotone (toDual ∘ f : α → βᵒᵈ) ↔ Antitone f :=\n  Iff.rfl\n\n"}
{"name":"antitone_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone (Function.comp (⇑OrderDual.toDual) f)) (Monotone f)","decl":"@[simp]\ntheorem antitone_toDual_comp_iff : Antitone (toDual ∘ f : α → βᵒᵈ) ↔ Monotone f :=\n  Iff.rfl\n\n"}
{"name":"monotoneOn_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (MonotoneOn (Function.comp f ⇑OrderDual.ofDual) s) (AntitoneOn f s)","decl":"@[simp]\ntheorem monotoneOn_comp_ofDual_iff : MonotoneOn (f ∘ ofDual) s ↔ AntitoneOn f s :=\n  forall₂_swap\n\n"}
{"name":"antitoneOn_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (AntitoneOn (Function.comp f ⇑OrderDual.ofDual) s) (MonotoneOn f s)","decl":"@[simp]\ntheorem antitoneOn_comp_ofDual_iff : AntitoneOn (f ∘ ofDual) s ↔ MonotoneOn f s :=\n  forall₂_swap\n\n"}
{"name":"monotoneOn_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (MonotoneOn (Function.comp (⇑OrderDual.toDual) f) s) (AntitoneOn f s)","decl":"@[simp]\ntheorem monotoneOn_toDual_comp_iff : MonotoneOn (toDual ∘ f : α → βᵒᵈ) s ↔ AntitoneOn f s :=\n  Iff.rfl\n\n"}
{"name":"antitoneOn_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (AntitoneOn (Function.comp (⇑OrderDual.toDual) f) s) (MonotoneOn f s)","decl":"@[simp]\ntheorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual ∘ f : α → βᵒᵈ) s ↔ MonotoneOn f s :=\n  Iff.rfl\n\n"}
{"name":"strictMono_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono (Function.comp f ⇑OrderDual.ofDual)) (StrictAnti f)","decl":"@[simp]\ntheorem strictMono_comp_ofDual_iff : StrictMono (f ∘ ofDual) ↔ StrictAnti f :=\n  forall_swap\n\n"}
{"name":"strictAnti_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAnti (Function.comp f ⇑OrderDual.ofDual)) (StrictMono f)","decl":"@[simp]\ntheorem strictAnti_comp_ofDual_iff : StrictAnti (f ∘ ofDual) ↔ StrictMono f :=\n  forall_swap\n\n"}
{"name":"strictMono_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono (Function.comp (⇑OrderDual.toDual) f)) (StrictAnti f)","decl":"@[simp]\ntheorem strictMono_toDual_comp_iff : StrictMono (toDual ∘ f : α → βᵒᵈ) ↔ StrictAnti f :=\n  Iff.rfl\n\n"}
{"name":"strictAnti_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAnti (Function.comp (⇑OrderDual.toDual) f)) (StrictMono f)","decl":"@[simp]\ntheorem strictAnti_toDual_comp_iff : StrictAnti (toDual ∘ f : α → βᵒᵈ) ↔ StrictMono f :=\n  Iff.rfl\n\n"}
{"name":"strictMonoOn_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictMonoOn (Function.comp f ⇑OrderDual.ofDual) s) (StrictAntiOn f s)","decl":"@[simp]\ntheorem strictMonoOn_comp_ofDual_iff : StrictMonoOn (f ∘ ofDual) s ↔ StrictAntiOn f s :=\n  forall₂_swap\n\n"}
{"name":"strictAntiOn_comp_ofDual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictAntiOn (Function.comp f ⇑OrderDual.ofDual) s) (StrictMonoOn f s)","decl":"@[simp]\ntheorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f ∘ ofDual) s ↔ StrictMonoOn f s :=\n  forall₂_swap\n\n"}
{"name":"strictMonoOn_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictMonoOn (Function.comp (⇑OrderDual.toDual) f) s) (StrictAntiOn f s)","decl":"@[simp]\ntheorem strictMonoOn_toDual_comp_iff : StrictMonoOn (toDual ∘ f : α → βᵒᵈ) s ↔ StrictAntiOn f s :=\n  Iff.rfl\n\n"}
{"name":"strictAntiOn_toDual_comp_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictAntiOn (Function.comp (⇑OrderDual.toDual) f) s) (StrictMonoOn f s)","decl":"@[simp]\ntheorem strictAntiOn_toDual_comp_iff : StrictAntiOn (toDual ∘ f : α → βᵒᵈ) s ↔ StrictMonoOn f s :=\n  Iff.rfl\n\n"}
{"name":"monotone_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))) (Monotone f)","decl":"theorem monotone_dual_iff : Monotone (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) ↔ Monotone f := by\n  rw [monotone_toDual_comp_iff, antitone_comp_ofDual_iff]\n\n"}
{"name":"antitone_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))) (Antitone f)","decl":"theorem antitone_dual_iff : Antitone (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) ↔ Antitone f := by\n  rw [antitone_toDual_comp_iff, monotone_comp_ofDual_iff]\n\n"}
{"name":"monotoneOn_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (MonotoneOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s) (MonotoneOn f s)","decl":"theorem monotoneOn_dual_iff : MonotoneOn (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) s ↔ MonotoneOn f s := by\n  rw [monotoneOn_toDual_comp_iff, antitoneOn_comp_ofDual_iff]\n\n"}
{"name":"antitoneOn_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (AntitoneOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s) (AntitoneOn f s)","decl":"theorem antitoneOn_dual_iff : AntitoneOn (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) s ↔ AntitoneOn f s := by\n  rw [antitoneOn_toDual_comp_iff, monotoneOn_comp_ofDual_iff]\n\n"}
{"name":"strictMono_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))) (StrictMono f)","decl":"theorem strictMono_dual_iff : StrictMono (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) ↔ StrictMono f := by\n  rw [strictMono_toDual_comp_iff, strictAnti_comp_ofDual_iff]\n\n"}
{"name":"strictAnti_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAnti (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))) (StrictAnti f)","decl":"theorem strictAnti_dual_iff : StrictAnti (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) ↔ StrictAnti f := by\n  rw [strictAnti_toDual_comp_iff, strictMono_comp_ofDual_iff]\n\n"}
{"name":"strictMonoOn_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictMonoOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s) (StrictMonoOn f s)","decl":"theorem strictMonoOn_dual_iff :\n    StrictMonoOn (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) s ↔ StrictMonoOn f s := by\n  rw [strictMonoOn_toDual_comp_iff, strictAntiOn_comp_ofDual_iff]\n\n"}
{"name":"strictAntiOn_dual_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (StrictAntiOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s) (StrictAntiOn f s)","decl":"theorem strictAntiOn_dual_iff :\n    StrictAntiOn (toDual ∘ f ∘ ofDual : αᵒᵈ → βᵒᵈ) s ↔ StrictAntiOn f s := by\n  rw [strictAntiOn_toDual_comp_iff, strictMonoOn_comp_ofDual_iff]\n\n"}
{"name":"Monotone.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Antitone (Function.comp f ⇑OrderDual.ofDual)","decl":"alias ⟨_, Monotone.dual_left⟩ := antitone_comp_ofDual_iff\n\n"}
{"name":"Antitone.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Antitone f\n⊢ Monotone (Function.comp f ⇑OrderDual.ofDual)","decl":"alias ⟨_, Antitone.dual_left⟩ := monotone_comp_ofDual_iff\n\n"}
{"name":"Monotone.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Antitone (Function.comp (⇑OrderDual.toDual) f)","decl":"alias ⟨_, Monotone.dual_right⟩ := antitone_toDual_comp_iff\n\n"}
{"name":"Antitone.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Antitone f\n⊢ Monotone (Function.comp (⇑OrderDual.toDual) f)","decl":"alias ⟨_, Antitone.dual_right⟩ := monotone_toDual_comp_iff\n\n"}
{"name":"MonotoneOn.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : MonotoneOn f s\n⊢ AntitoneOn (Function.comp f ⇑OrderDual.ofDual) s","decl":"alias ⟨_, MonotoneOn.dual_left⟩ := antitoneOn_comp_ofDual_iff\n\n"}
{"name":"AntitoneOn.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : AntitoneOn f s\n⊢ MonotoneOn (Function.comp f ⇑OrderDual.ofDual) s","decl":"alias ⟨_, AntitoneOn.dual_left⟩ := monotoneOn_comp_ofDual_iff\n\n"}
{"name":"MonotoneOn.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : MonotoneOn f s\n⊢ AntitoneOn (Function.comp (⇑OrderDual.toDual) f) s","decl":"alias ⟨_, MonotoneOn.dual_right⟩ := antitoneOn_toDual_comp_iff\n\n"}
{"name":"AntitoneOn.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : AntitoneOn f s\n⊢ MonotoneOn (Function.comp (⇑OrderDual.toDual) f) s","decl":"alias ⟨_, AntitoneOn.dual_right⟩ := monotoneOn_toDual_comp_iff\n\n"}
{"name":"StrictMono.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictMono f\n⊢ StrictAnti (Function.comp f ⇑OrderDual.ofDual)","decl":"alias ⟨_, StrictMono.dual_left⟩ := strictAnti_comp_ofDual_iff\n\n"}
{"name":"StrictAnti.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictAnti f\n⊢ StrictMono (Function.comp f ⇑OrderDual.ofDual)","decl":"alias ⟨_, StrictAnti.dual_left⟩ := strictMono_comp_ofDual_iff\n\n"}
{"name":"StrictMono.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictMono f\n⊢ StrictAnti (Function.comp (⇑OrderDual.toDual) f)","decl":"alias ⟨_, StrictMono.dual_right⟩ := strictAnti_toDual_comp_iff\n\n"}
{"name":"StrictAnti.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictAnti f\n⊢ StrictMono (Function.comp (⇑OrderDual.toDual) f)","decl":"alias ⟨_, StrictAnti.dual_right⟩ := strictMono_toDual_comp_iff\n\n"}
{"name":"StrictMonoOn.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictMonoOn f s\n⊢ StrictAntiOn (Function.comp f ⇑OrderDual.ofDual) s","decl":"alias ⟨_, StrictMonoOn.dual_left⟩ := strictAntiOn_comp_ofDual_iff\n\n"}
{"name":"StrictAntiOn.dual_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictAntiOn f s\n⊢ StrictMonoOn (Function.comp f ⇑OrderDual.ofDual) s","decl":"alias ⟨_, StrictAntiOn.dual_left⟩ := strictMonoOn_comp_ofDual_iff\n\n"}
{"name":"StrictMonoOn.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictMonoOn f s\n⊢ StrictAntiOn (Function.comp (⇑OrderDual.toDual) f) s","decl":"alias ⟨_, StrictMonoOn.dual_right⟩ := strictAntiOn_toDual_comp_iff\n\n"}
{"name":"StrictAntiOn.dual_right","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictAntiOn f s\n⊢ StrictMonoOn (Function.comp (⇑OrderDual.toDual) f) s","decl":"alias ⟨_, StrictAntiOn.dual_right⟩ := strictMonoOn_toDual_comp_iff\n\n"}
{"name":"Monotone.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Monotone (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"alias ⟨_, Monotone.dual⟩ := monotone_dual_iff\n\n"}
{"name":"Antitone.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : Antitone f\n⊢ Antitone (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"alias ⟨_, Antitone.dual⟩ := antitone_dual_iff\n\n"}
{"name":"MonotoneOn.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : MonotoneOn f s\n⊢ MonotoneOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s","decl":"alias ⟨_, MonotoneOn.dual⟩ := monotoneOn_dual_iff\n\n"}
{"name":"AntitoneOn.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : AntitoneOn f s\n⊢ AntitoneOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s","decl":"alias ⟨_, AntitoneOn.dual⟩ := antitoneOn_dual_iff\n\n"}
{"name":"StrictMono.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictMono f\n⊢ StrictMono (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"alias ⟨_, StrictMono.dual⟩ := strictMono_dual_iff\n\n"}
{"name":"StrictAnti.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : StrictAnti f\n⊢ StrictAnti (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"alias ⟨_, StrictAnti.dual⟩ := strictAnti_dual_iff\n\n"}
{"name":"StrictMonoOn.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictMonoOn f s\n⊢ StrictMonoOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s","decl":"alias ⟨_, StrictMonoOn.dual⟩ := strictMonoOn_dual_iff\n\n"}
{"name":"StrictAntiOn.dual","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\na✝ : StrictAntiOn f s\n⊢ StrictAntiOn (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual)) s","decl":"alias ⟨_, StrictAntiOn.dual⟩ := strictAntiOn_dual_iff\n\n"}
{"name":"StrictMono.wellFoundedLT","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : α → β\ninst✝ : WellFoundedLT β\nhf : StrictMono f\n⊢ WellFoundedLT α","decl":"theorem StrictMono.wellFoundedLT [WellFoundedLT β] (hf : StrictMono f) : WellFoundedLT α :=\n  Subrelation.isWellFounded (InvImage (· < ·) f) @hf\n\n"}
{"name":"StrictAnti.wellFoundedLT","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : α → β\ninst✝ : WellFoundedGT β\nhf : StrictAnti f\n⊢ WellFoundedLT α","decl":"theorem StrictAnti.wellFoundedLT [WellFoundedGT β] (hf : StrictAnti f) : WellFoundedLT α :=\n  StrictMono.wellFoundedLT (β := βᵒᵈ) hf\n\n"}
{"name":"StrictMono.wellFoundedGT","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : α → β\ninst✝ : WellFoundedGT β\nhf : StrictMono f\n⊢ WellFoundedGT α","decl":"theorem StrictMono.wellFoundedGT [WellFoundedGT β] (hf : StrictMono f) : WellFoundedGT α :=\n  StrictMono.wellFoundedLT (α := αᵒᵈ) (β := βᵒᵈ) (fun _ _ h ↦ hf h)\n\n"}
{"name":"StrictAnti.wellFoundedGT","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : α → β\ninst✝ : WellFoundedLT β\nhf : StrictAnti f\n⊢ WellFoundedGT α","decl":"theorem StrictAnti.wellFoundedGT [WellFoundedLT β] (hf : StrictAnti f) : WellFoundedGT α :=\n  StrictMono.wellFoundedLT (α := αᵒᵈ) (fun _ _ h ↦ hf h)\n\n"}
{"name":"Monotone.comp_le_comp_left","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : β → α\ng h : γ → β\nhf : Monotone f\nle_gh : LE.le g h\n⊢ LE.le (Function.comp f g) (Function.comp f h)","decl":"theorem Monotone.comp_le_comp_left\n    [Preorder β] {f : β → α} {g h : γ → β} (hf : Monotone f) (le_gh : g ≤ h) :\n    LE.le.{max w u} (f ∘ g) (f ∘ h) :=\n  fun x ↦ hf (le_gh x)\n\n"}
{"name":"monotone_lam","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder α\ninst✝ : Preorder γ\nf : α → β → γ\nhf : ∀ (b : β), Monotone fun a => f a b\n⊢ Monotone f","decl":"theorem monotone_lam {f : α → β → γ} (hf : ∀ b, Monotone fun a ↦ f a b) : Monotone f :=\n  fun _ _ h b ↦ hf b h\n\n"}
{"name":"monotone_app","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder α\ninst✝ : Preorder γ\nf : β → α → γ\nb : β\nhf : Monotone fun a b => f b a\n⊢ Monotone (f b)","decl":"theorem monotone_app (f : β → α → γ) (b : β) (hf : Monotone fun a b ↦ f b a) : Monotone (f b) :=\n  fun _ _ h ↦ hf h b\n\n"}
{"name":"antitone_lam","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder α\ninst✝ : Preorder γ\nf : α → β → γ\nhf : ∀ (b : β), Antitone fun a => f a b\n⊢ Antitone f","decl":"theorem antitone_lam {f : α → β → γ} (hf : ∀ b, Antitone fun a ↦ f a b) : Antitone f :=\n  fun _ _ h b ↦ hf b h\n\n"}
{"name":"antitone_app","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder α\ninst✝ : Preorder γ\nf : β → α → γ\nb : β\nhf : Antitone fun a b => f b a\n⊢ Antitone (f b)","decl":"theorem antitone_app (f : β → α → γ) (b : β) (hf : Antitone fun a b ↦ f b a) : Antitone (f b) :=\n  fun _ _ h ↦ hf h b\n\n"}
{"name":"Function.monotone_eval","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : (i : ι) → Preorder (α i)\ni : ι\n⊢ Monotone (Function.eval i)","decl":"theorem Function.monotone_eval {ι : Type u} {α : ι → Type v} [∀ i, Preorder (α i)] (i : ι) :\n    Monotone (Function.eval i : (∀ i, α i) → α i) := fun _ _ H ↦ H i\n\n"}
{"name":"Monotone.imp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na b : α\nhf : Monotone f\nh : LE.le a b\n⊢ LE.le (f a) (f b)","decl":"theorem Monotone.imp (hf : Monotone f) (h : a ≤ b) : f a ≤ f b :=\n  hf h\n\n"}
{"name":"Antitone.imp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na b : α\nhf : Antitone f\nh : LE.le a b\n⊢ LE.le (f b) (f a)","decl":"theorem Antitone.imp (hf : Antitone f) (h : a ≤ b) : f b ≤ f a :=\n  hf h\n\n"}
{"name":"StrictMono.imp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na b : α\nhf : StrictMono f\nh : LT.lt a b\n⊢ LT.lt (f a) (f b)","decl":"theorem StrictMono.imp (hf : StrictMono f) (h : a < b) : f a < f b :=\n  hf h\n\n"}
{"name":"StrictAnti.imp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na b : α\nhf : StrictAnti f\nh : LT.lt a b\n⊢ LT.lt (f b) (f a)","decl":"theorem StrictAnti.imp (hf : StrictAnti f) (h : a < b) : f b < f a :=\n  hf h\n\n"}
{"name":"Monotone.monotoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\ns : Set α\n⊢ MonotoneOn f s","decl":"protected theorem Monotone.monotoneOn (hf : Monotone f) (s : Set α) : MonotoneOn f s :=\n  fun _ _ _ _ ↦ hf.imp\n\n"}
{"name":"Antitone.antitoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\ns : Set α\n⊢ AntitoneOn f s","decl":"protected theorem Antitone.antitoneOn (hf : Antitone f) (s : Set α) : AntitoneOn f s :=\n  fun _ _ _ _ ↦ hf.imp\n\n"}
{"name":"monotoneOn_univ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (MonotoneOn f Set.univ) (Monotone f)","decl":"@[simp] theorem monotoneOn_univ : MonotoneOn f Set.univ ↔ Monotone f :=\n  ⟨fun h _ _ ↦ h trivial trivial, fun h ↦ h.monotoneOn _⟩\n\n"}
{"name":"antitoneOn_univ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (AntitoneOn f Set.univ) (Antitone f)","decl":"@[simp] theorem antitoneOn_univ : AntitoneOn f Set.univ ↔ Antitone f :=\n  ⟨fun h _ _ ↦ h trivial trivial, fun h ↦ h.antitoneOn _⟩\n\n"}
{"name":"StrictMono.strictMonoOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\ns : Set α\n⊢ StrictMonoOn f s","decl":"protected theorem StrictMono.strictMonoOn (hf : StrictMono f) (s : Set α) : StrictMonoOn f s :=\n  fun _ _ _ _ ↦ hf.imp\n\n"}
{"name":"StrictAnti.strictAntiOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\ns : Set α\n⊢ StrictAntiOn f s","decl":"protected theorem StrictAnti.strictAntiOn (hf : StrictAnti f) (s : Set α) : StrictAntiOn f s :=\n  fun _ _ _ _ ↦ hf.imp\n\n"}
{"name":"strictMonoOn_univ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMonoOn f Set.univ) (StrictMono f)","decl":"@[simp] theorem strictMonoOn_univ : StrictMonoOn f Set.univ ↔ StrictMono f :=\n  ⟨fun h _ _ ↦ h trivial trivial, fun h ↦ h.strictMonoOn _⟩\n\n"}
{"name":"strictAntiOn_univ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAntiOn f Set.univ) (StrictAnti f)","decl":"@[simp] theorem strictAntiOn_univ : StrictAntiOn f Set.univ ↔ StrictAnti f :=\n  ⟨fun h _ _ ↦ h trivial trivial, fun h ↦ h.strictAntiOn _⟩\n\n"}
{"name":"Monotone.strictMono_of_injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nf : α → β\nh₁ : Monotone f\nh₂ : Function.Injective f\n⊢ StrictMono f","decl":"theorem Monotone.strictMono_of_injective (h₁ : Monotone f) (h₂ : Injective f) : StrictMono f :=\n  fun _ _ h ↦ (h₁ h.le).lt_of_ne fun H ↦ h.ne <| h₂ H\n\n"}
{"name":"Antitone.strictAnti_of_injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : PartialOrder β\nf : α → β\nh₁ : Antitone f\nh₂ : Function.Injective f\n⊢ StrictAnti f","decl":"theorem Antitone.strictAnti_of_injective (h₁ : Antitone f) (h₂ : Injective f) : StrictAnti f :=\n  fun _ _ h ↦ (h₁ h.le).lt_of_ne fun H ↦ h.ne <| h₂ H.symm\n\n"}
{"name":"monotone_iff_forall_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone f) (∀ ⦃a b : α⦄, LT.lt a b → LE.le (f a) (f b))","decl":"theorem monotone_iff_forall_lt : Monotone f ↔ ∀ ⦃a b⦄, a < b → f a ≤ f b :=\n  forall₂_congr fun _ _ ↦\n    ⟨fun hf h ↦ hf h.le, fun hf h ↦ h.eq_or_lt.elim (fun H ↦ (congr_arg _ H).le) hf⟩\n\n"}
{"name":"antitone_iff_forall_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone f) (∀ ⦃a b : α⦄, LT.lt a b → LE.le (f b) (f a))","decl":"theorem antitone_iff_forall_lt : Antitone f ↔ ∀ ⦃a b⦄, a < b → f b ≤ f a :=\n  forall₂_congr fun _ _ ↦\n    ⟨fun hf h ↦ hf h.le, fun hf h ↦ h.eq_or_lt.elim (fun H ↦ (congr_arg _ H).ge) hf⟩\n\n"}
{"name":"monotoneOn_iff_forall_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (MonotoneOn f s) (∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem s b → LT.lt a b → LE.le (f a) (f b))","decl":"theorem monotoneOn_iff_forall_lt :\n    MonotoneOn f s ↔ ∀ ⦃a⦄ (_ : a ∈ s) ⦃b⦄ (_ : b ∈ s), a < b → f a ≤ f b :=\n  ⟨fun hf _ ha _ hb h ↦ hf ha hb h.le,\n   fun hf _ ha _ hb h ↦ h.eq_or_lt.elim (fun H ↦ (congr_arg _ H).le) (hf ha hb)⟩\n\n"}
{"name":"antitoneOn_iff_forall_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\n⊢ Iff (AntitoneOn f s) (∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem s b → LT.lt a b → LE.le (f b) (f a))","decl":"theorem antitoneOn_iff_forall_lt :\n    AntitoneOn f s ↔ ∀ ⦃a⦄ (_ : a ∈ s) ⦃b⦄ (_ : b ∈ s), a < b → f b ≤ f a :=\n  ⟨fun hf _ ha _ hb h ↦ hf ha hb h.le,\n   fun hf _ ha _ hb h ↦ h.eq_or_lt.elim (fun H ↦ (congr_arg _ H).ge) (hf ha hb)⟩\n\n-- `Preorder α` isn't strong enough: if the preorder on `α` is an equivalence relation,\n-- then `StrictMono f` is vacuously true.\n"}
{"name":"StrictMonoOn.monotoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\n⊢ MonotoneOn f s","decl":"protected theorem StrictMonoOn.monotoneOn (hf : StrictMonoOn f s) : MonotoneOn f s :=\n  monotoneOn_iff_forall_lt.2 fun _ ha _ hb h ↦ (hf ha hb h).le\n\n"}
{"name":"StrictAntiOn.antitoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictAntiOn f s\n⊢ AntitoneOn f s","decl":"protected theorem StrictAntiOn.antitoneOn (hf : StrictAntiOn f s) : AntitoneOn f s :=\n  antitoneOn_iff_forall_lt.2 fun _ ha _ hb h ↦ (hf ha hb h).le\n\n"}
{"name":"StrictMono.monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\n⊢ Monotone f","decl":"protected theorem StrictMono.monotone (hf : StrictMono f) : Monotone f :=\n  monotone_iff_forall_lt.2 fun _ _ h ↦ (hf h).le\n\n"}
{"name":"StrictAnti.antitone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\n⊢ Antitone f","decl":"protected theorem StrictAnti.antitone (hf : StrictAnti f) : Antitone f :=\n  antitone_iff_forall_lt.2 fun _ _ h ↦ (hf h).le\n\n"}
{"name":"Subsingleton.monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton α\nf : α → β\n⊢ Monotone f","decl":"protected theorem monotone [Subsingleton α] (f : α → β) : Monotone f :=\n  fun _ _ _ ↦ (congr_arg _ <| Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.antitone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton α\nf : α → β\n⊢ Antitone f","decl":"protected theorem antitone [Subsingleton α] (f : α → β) : Antitone f :=\n  fun _ _ _ ↦ (congr_arg _ <| Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.monotone'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton β\nf : α → β\n⊢ Monotone f","decl":"theorem monotone' [Subsingleton β] (f : α → β) : Monotone f :=\n  fun _ _ _ ↦ (Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.antitone'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton β\nf : α → β\n⊢ Antitone f","decl":"theorem antitone' [Subsingleton β] (f : α → β) : Antitone f :=\n  fun _ _ _ ↦ (Subsingleton.elim _ _).le\n\n"}
{"name":"Subsingleton.strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton α\nf : α → β\n⊢ StrictMono f","decl":"protected theorem strictMono [Subsingleton α] (f : α → β) : StrictMono f :=\n  fun _ _ h ↦ (h.ne <| Subsingleton.elim _ _).elim\n\n"}
{"name":"Subsingleton.strictAnti","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Subsingleton α\nf : α → β\n⊢ StrictAnti f","decl":"protected theorem strictAnti [Subsingleton α] (f : α → β) : StrictAnti f :=\n  fun _ _ h ↦ (h.ne <| Subsingleton.elim _ _).elim\n\n"}
{"name":"monotone_id","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Monotone id","decl":"theorem monotone_id [Preorder α] : Monotone (id : α → α) := fun _ _ ↦ id\n\n"}
{"name":"monotoneOn_id","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ MonotoneOn id s","decl":"theorem monotoneOn_id [Preorder α] {s : Set α} : MonotoneOn id s := fun _ _ _ _ ↦ id\n\n"}
{"name":"strictMono_id","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ StrictMono id","decl":"theorem strictMono_id [Preorder α] : StrictMono (id : α → α) := fun _ _ ↦ id\n\n"}
{"name":"strictMonoOn_id","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\n⊢ StrictMonoOn id s","decl":"theorem strictMonoOn_id [Preorder α] {s : Set α} : StrictMonoOn id s := fun _ _ _ _ ↦ id\n\n"}
{"name":"monotone_const","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : β\n⊢ Monotone fun x => c","decl":"theorem monotone_const [Preorder α] [Preorder β] {c : β} : Monotone fun _ : α ↦ c :=\n  fun _ _ _ ↦ le_rfl\n\n"}
{"name":"monotoneOn_const","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : β\ns : Set α\n⊢ MonotoneOn (fun x => c) s","decl":"theorem monotoneOn_const [Preorder α] [Preorder β] {c : β} {s : Set α} :\n    MonotoneOn (fun _ : α ↦ c) s :=\n  fun _ _ _ _ _ ↦ le_rfl\n\n"}
{"name":"antitone_const","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : β\n⊢ Antitone fun x => c","decl":"theorem antitone_const [Preorder α] [Preorder β] {c : β} : Antitone fun _ : α ↦ c :=\n  fun _ _ _ ↦ le_refl c\n\n"}
{"name":"antitoneOn_const","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : β\ns : Set α\n⊢ AntitoneOn (fun x => c) s","decl":"theorem antitoneOn_const [Preorder α] [Preorder β] {c : β} {s : Set α} :\n    AntitoneOn (fun _ : α ↦ c) s :=\n  fun _ _ _ _ _ ↦ le_rfl\n\n"}
{"name":"strictMono_of_le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : ∀ (x y : α), Iff (LE.le x y) (LE.le (f x) (f y))\n⊢ StrictMono f","decl":"theorem strictMono_of_le_iff_le [Preorder α] [Preorder β] {f : α → β}\n    (h : ∀ x y, x ≤ y ↔ f x ≤ f y) : StrictMono f :=\n  fun _ _ ↦ (lt_iff_lt_of_le_iff_le' (h _ _) (h _ _)).1\n\n"}
{"name":"strictAnti_of_le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : ∀ (x y : α), Iff (LE.le x y) (LE.le (f y) (f x))\n⊢ StrictAnti f","decl":"theorem strictAnti_of_le_iff_le [Preorder α] [Preorder β] {f : α → β}\n    (h : ∀ x y, x ≤ y ↔ f y ≤ f x) : StrictAnti f :=\n  fun _ _ ↦ (lt_iff_lt_of_le_iff_le' (h _ _) (h _ _)).1\n\n-- Porting note: mathlib3 proof uses `contrapose` tactic\n"}
{"name":"injective_of_lt_imp_ne","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder α\nf : α → β\nh : ∀ (x y : α), LT.lt x y → Ne (f x) (f y)\n⊢ Function.Injective f","decl":"theorem injective_of_lt_imp_ne [LinearOrder α] {f : α → β} (h : ∀ x y, x < y → f x ≠ f y) :\n    Injective f := by\n  intro x y hf\n  rcases lt_trichotomy x y with (hxy | rfl | hxy)\n  · exact absurd hf <| h _ _ hxy\n  · rfl\n  · exact absurd hf.symm <| h _ _ hxy\n\n"}
{"name":"injective_of_le_imp_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\nh : ∀ {x y : α}, LE.le (f x) (f y) → LE.le x y\n⊢ Function.Injective f","decl":"theorem injective_of_le_imp_le [PartialOrder α] [Preorder β] (f : α → β)\n    (h : ∀ {x y}, f x ≤ f y → x ≤ y) : Injective f :=\n  fun _ _ hxy ↦ (h hxy.le).antisymm (h hxy.ge)\n\n"}
{"name":"StrictMono.isMax_of_apply","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictMono f\nha : IsMax (f a)\n⊢ IsMax a","decl":"theorem StrictMono.isMax_of_apply (hf : StrictMono f) (ha : IsMax (f a)) : IsMax a :=\n  of_not_not fun h ↦\n    let ⟨_, hb⟩ := not_isMax_iff.1 h\n    (hf hb).not_isMax ha\n\n"}
{"name":"StrictMono.isMin_of_apply","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictMono f\nha : IsMin (f a)\n⊢ IsMin a","decl":"theorem StrictMono.isMin_of_apply (hf : StrictMono f) (ha : IsMin (f a)) : IsMin a :=\n  of_not_not fun h ↦\n    let ⟨_, hb⟩ := not_isMin_iff.1 h\n    (hf hb).not_isMin ha\n\n"}
{"name":"StrictAnti.isMax_of_apply","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictAnti f\nha : IsMin (f a)\n⊢ IsMax a","decl":"theorem StrictAnti.isMax_of_apply (hf : StrictAnti f) (ha : IsMin (f a)) : IsMax a :=\n  of_not_not fun h ↦\n    let ⟨_, hb⟩ := not_isMax_iff.1 h\n    (hf hb).not_isMin ha\n\n"}
{"name":"StrictAnti.isMin_of_apply","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictAnti f\nha : IsMax (f a)\n⊢ IsMin a","decl":"theorem StrictAnti.isMin_of_apply (hf : StrictAnti f) (ha : IsMax (f a)) : IsMin a :=\n  of_not_not fun h ↦\n    let ⟨_, hb⟩ := not_isMin_iff.1 h\n    (hf hb).not_isMax ha\n\n"}
{"name":"StrictMono.add_le_nat","module":"Mathlib.Order.Monotone.Basic","initialProofState":"f : Nat → Nat\nhf : StrictMono f\nm n : Nat\n⊢ LE.le (HAdd.hAdd m (f n)) (f (HAdd.hAdd m n))","decl":"lemma StrictMono.add_le_nat {f : ℕ → ℕ} (hf : StrictMono f) (m n : ℕ) : m + f n ≤ f (m + n)  := by\n  rw [Nat.add_comm m, Nat.add_comm m]\n  induction m with\n  | zero => rw [Nat.add_zero, Nat.add_zero]\n  | succ m ih =>\n    rw [← Nat.add_assoc, ← Nat.add_assoc, Nat.succ_le]\n    exact ih.trans_lt (hf (n + m).lt_succ_self)\n\n"}
{"name":"StrictMono.ite'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf g : α → β\nhf : StrictMono f\nhg : StrictMono g\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ ⦃x y : α⦄, LT.lt x y → p y → p x\nhfg : ∀ ⦃x y : α⦄, p x → Not (p y) → LT.lt x y → LT.lt (f x) (g y)\n⊢ StrictMono fun x => ite (p x) (f x) (g x)","decl":"protected theorem StrictMono.ite' (hf : StrictMono f) (hg : StrictMono g) {p : α → Prop}\n    [DecidablePred p]\n    (hp : ∀ ⦃x y⦄, x < y → p y → p x) (hfg : ∀ ⦃x y⦄, p x → ¬p y → x < y → f x < g y) :\n    StrictMono fun x ↦ if p x then f x else g x := by\n  intro x y h\n  by_cases hy : p y\n  · have hx : p x := hp h hy\n    simpa [hx, hy] using hf h\n  by_cases hx : p x\n  · simpa [hx, hy] using hfg hx hy h\n  · simpa [hx, hy] using hg h\n\n"}
{"name":"StrictMono.ite","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf g : α → β\nhf : StrictMono f\nhg : StrictMono g\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ ⦃x y : α⦄, LT.lt x y → p y → p x\nhfg : ∀ (x : α), LE.le (f x) (g x)\n⊢ StrictMono fun x => ite (p x) (f x) (g x)","decl":"protected theorem StrictMono.ite (hf : StrictMono f) (hg : StrictMono g) {p : α → Prop}\n    [DecidablePred p] (hp : ∀ ⦃x y⦄, x < y → p y → p x) (hfg : ∀ x, f x ≤ g x) :\n    StrictMono fun x ↦ if p x then f x else g x :=\n  (hf.ite' hg hp) fun _ y _ _ h ↦ (hf h).trans_le (hfg y)\n\n-- Porting note: `Strict*.dual_right` dot notation is not working here for some reason\n"}
{"name":"StrictAnti.ite'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf g : α → β\nhf : StrictAnti f\nhg : StrictAnti g\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ ⦃x y : α⦄, LT.lt x y → p y → p x\nhfg : ∀ ⦃x y : α⦄, p x → Not (p y) → LT.lt x y → LT.lt (g y) (f x)\n⊢ StrictAnti fun x => ite (p x) (f x) (g x)","decl":"protected theorem StrictAnti.ite' (hf : StrictAnti f) (hg : StrictAnti g) {p : α → Prop}\n    [DecidablePred p]\n    (hp : ∀ ⦃x y⦄, x < y → p y → p x) (hfg : ∀ ⦃x y⦄, p x → ¬p y → x < y → g y < f x) :\n    StrictAnti fun x ↦ if p x then f x else g x :=\n  StrictMono.ite' (StrictAnti.dual_right hf) (StrictAnti.dual_right hg) hp hfg\n\n"}
{"name":"StrictAnti.ite","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf g : α → β\nhf : StrictAnti f\nhg : StrictAnti g\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ ⦃x y : α⦄, LT.lt x y → p y → p x\nhfg : ∀ (x : α), LE.le (g x) (f x)\n⊢ StrictAnti fun x => ite (p x) (f x) (g x)","decl":"protected theorem StrictAnti.ite (hf : StrictAnti f) (hg : StrictAnti g) {p : α → Prop}\n    [DecidablePred p] (hp : ∀ ⦃x y⦄, x < y → p y → p x) (hfg : ∀ x, g x ≤ f x) :\n    StrictAnti fun x ↦ if p x then f x else g x :=\n  (hf.ite' hg hp) fun _ y _ _ h ↦ (hfg y).trans_lt (hf h)\n\n"}
{"name":"Monotone.comp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : Monotone g\nhf : Monotone f\n⊢ Monotone (Function.comp g f)","decl":"protected theorem Monotone.comp (hg : Monotone g) (hf : Monotone f) : Monotone (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"Monotone.comp_antitone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : Monotone g\nhf : Antitone f\n⊢ Antitone (Function.comp g f)","decl":"theorem Monotone.comp_antitone (hg : Monotone g) (hf : Antitone f) : Antitone (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"Antitone.comp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : Antitone g\nhf : Antitone f\n⊢ Monotone (Function.comp g f)","decl":"protected theorem Antitone.comp (hg : Antitone g) (hf : Antitone f) : Monotone (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"Antitone.comp_monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : Antitone g\nhf : Monotone f\n⊢ Antitone (Function.comp g f)","decl":"theorem Antitone.comp_monotone (hg : Antitone g) (hf : Monotone f) : Antitone (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"Monotone.iterate","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : α → α\nhf : Monotone f\nn : Nat\n⊢ Monotone (Nat.iterate f n)","decl":"protected theorem Monotone.iterate {f : α → α} (hf : Monotone f) (n : ℕ) : Monotone f^[n] :=\n  Nat.recOn n monotone_id fun _ h ↦ h.comp hf\n\n"}
{"name":"Monotone.comp_monotoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : Monotone g\nhf : MonotoneOn f s\n⊢ MonotoneOn (Function.comp g f) s","decl":"protected theorem Monotone.comp_monotoneOn (hg : Monotone g) (hf : MonotoneOn f s) :\n    MonotoneOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"Monotone.comp_antitoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : Monotone g\nhf : AntitoneOn f s\n⊢ AntitoneOn (Function.comp g f) s","decl":"theorem Monotone.comp_antitoneOn (hg : Monotone g) (hf : AntitoneOn f s) : AntitoneOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"Antitone.comp_antitoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : Antitone g\nhf : AntitoneOn f s\n⊢ MonotoneOn (Function.comp g f) s","decl":"protected theorem Antitone.comp_antitoneOn (hg : Antitone g) (hf : AntitoneOn f s) :\n    MonotoneOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"Antitone.comp_monotoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : Antitone g\nhf : MonotoneOn f s\n⊢ AntitoneOn (Function.comp g f) s","decl":"theorem Antitone.comp_monotoneOn (hg : Antitone g) (hf : MonotoneOn f s) : AntitoneOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"StrictMono.comp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : StrictMono g\nhf : StrictMono f\n⊢ StrictMono (Function.comp g f)","decl":"protected theorem StrictMono.comp (hg : StrictMono g) (hf : StrictMono f) : StrictMono (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"StrictMono.comp_strictAnti","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : StrictMono g\nhf : StrictAnti f\n⊢ StrictAnti (Function.comp g f)","decl":"theorem StrictMono.comp_strictAnti (hg : StrictMono g) (hf : StrictAnti f) : StrictAnti (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"StrictAnti.comp","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : StrictAnti g\nhf : StrictAnti f\n⊢ StrictMono (Function.comp g f)","decl":"protected theorem StrictAnti.comp (hg : StrictAnti g) (hf : StrictAnti f) : StrictMono (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"StrictAnti.comp_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : StrictAnti g\nhf : StrictMono f\n⊢ StrictAnti (Function.comp g f)","decl":"theorem StrictAnti.comp_strictMono (hg : StrictAnti g) (hf : StrictMono f) : StrictAnti (g ∘ f) :=\n  fun _ _ h ↦ hg (hf h)\n\n"}
{"name":"StrictMono.iterate","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : α → α\nhf : StrictMono f\nn : Nat\n⊢ StrictMono (Nat.iterate f n)","decl":"protected theorem StrictMono.iterate {f : α → α} (hf : StrictMono f) (n : ℕ) : StrictMono f^[n] :=\n  Nat.recOn n strictMono_id fun _ h ↦ h.comp hf\n\n"}
{"name":"StrictMono.comp_strictMonoOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : StrictMono g\nhf : StrictMonoOn f s\n⊢ StrictMonoOn (Function.comp g f) s","decl":"protected theorem StrictMono.comp_strictMonoOn (hg : StrictMono g) (hf : StrictMonoOn f s) :\n    StrictMonoOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"StrictMono.comp_strictAntiOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : StrictMono g\nhf : StrictAntiOn f s\n⊢ StrictAntiOn (Function.comp g f) s","decl":"theorem StrictMono.comp_strictAntiOn (hg : StrictMono g) (hf : StrictAntiOn f s) :\n    StrictAntiOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"StrictAnti.comp_strictAntiOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : StrictAnti g\nhf : StrictAntiOn f s\n⊢ StrictMonoOn (Function.comp g f) s","decl":"protected theorem StrictAnti.comp_strictAntiOn (hg : StrictAnti g) (hf : StrictAntiOn f s) :\n    StrictMonoOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"StrictAnti.comp_strictMonoOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\ns : Set α\nhg : StrictAnti g\nhf : StrictMonoOn f s\n⊢ StrictAntiOn (Function.comp g f) s","decl":"theorem StrictAnti.comp_strictMonoOn (hg : StrictAnti g) (hf : StrictMonoOn f s) :\n    StrictAntiOn (g ∘ f) s :=\n  fun _ ha _ hb h ↦ hg (hf ha hb h)\n\n"}
{"name":"List.foldl_monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nf : α → β → α\nH : ∀ (b : β), Monotone fun a => f a b\nl : List β\n⊢ Monotone fun a => List.foldl f a l","decl":"theorem foldl_monotone [Preorder α] {f : α → β → α} (H : ∀ b, Monotone fun a ↦ f a b)\n    (l : List β) : Monotone fun a ↦ l.foldl f a :=\n  List.recOn l (fun _ _ ↦ id) fun _ _ hl _ _ h ↦ hl (H _ h)\n\n"}
{"name":"List.foldr_monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β → β\nH : ∀ (a : α), Monotone (f a)\nl : List α\n⊢ Monotone fun b => List.foldr f b l","decl":"theorem foldr_monotone [Preorder β] {f : α → β → β} (H : ∀ a, Monotone (f a)) (l : List α) :\n    Monotone fun b ↦ l.foldr f b := fun _ _ h ↦ List.recOn l h fun i _ hl ↦ H i hl\n\n"}
{"name":"List.foldl_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nf : α → β → α\nH : ∀ (b : β), StrictMono fun a => f a b\nl : List β\n⊢ StrictMono fun a => List.foldl f a l","decl":"theorem foldl_strictMono [Preorder α] {f : α → β → α} (H : ∀ b, StrictMono fun a ↦ f a b)\n    (l : List β) : StrictMono fun a ↦ l.foldl f a :=\n  List.recOn l (fun _ _ ↦ id) fun _ _ hl _ _ h ↦ hl (H _ h)\n\n"}
{"name":"List.foldr_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β → β\nH : ∀ (a : α), StrictMono (f a)\nl : List α\n⊢ StrictMono fun b => List.foldr f b l","decl":"theorem foldr_strictMono [Preorder β] {f : α → β → β} (H : ∀ a, StrictMono (f a)) (l : List α) :\n    StrictMono fun b ↦ l.foldr f b := fun _ _ h ↦ List.recOn l h fun i _ hl ↦ H i hl\n\n"}
{"name":"Monotone.reflect_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\na b : α\nh : LT.lt (f a) (f b)\n⊢ LT.lt a b","decl":"theorem Monotone.reflect_lt (hf : Monotone f) {a b : α} (h : f a < f b) : a < b :=\n  lt_of_not_ge fun h' ↦ h.not_le (hf h')\n\n"}
{"name":"Antitone.reflect_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\na b : α\nh : LT.lt (f a) (f b)\n⊢ LT.lt b a","decl":"theorem Antitone.reflect_lt (hf : Antitone f) {a b : α} (h : f a < f b) : b < a :=\n  lt_of_not_ge fun h' ↦ h.not_le (hf h')\n\n"}
{"name":"MonotoneOn.reflect_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : MonotoneOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nh : LT.lt (f a) (f b)\n⊢ LT.lt a b","decl":"theorem MonotoneOn.reflect_lt (hf : MonotoneOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s)\n    (h : f a < f b) : a < b :=\n  lt_of_not_ge fun h' ↦ h.not_le <| hf hb ha h'\n\n"}
{"name":"AntitoneOn.reflect_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : AntitoneOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nh : LT.lt (f a) (f b)\n⊢ LT.lt b a","decl":"theorem AntitoneOn.reflect_lt (hf : AntitoneOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s)\n    (h : f a < f b) : b < a :=\n  lt_of_not_ge fun h' ↦ h.not_le <| hf ha hb h'\n\n"}
{"name":"StrictMonoOn.le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LE.le (f a) (f b)) (LE.le a b)","decl":"theorem StrictMonoOn.le_iff_le (hf : StrictMonoOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a ≤ f b ↔ a ≤ b :=\n  ⟨fun h ↦ le_of_not_gt fun h' ↦ (hf hb ha h').not_le h, fun h ↦\n    h.lt_or_eq_dec.elim (fun h' ↦ (hf ha hb h').le) fun h' ↦ h' ▸ le_rfl⟩\n\n"}
{"name":"StrictAntiOn.le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictAntiOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LE.le (f a) (f b)) (LE.le b a)","decl":"theorem StrictAntiOn.le_iff_le (hf : StrictAntiOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a ≤ f b ↔ b ≤ a :=\n  hf.dual_right.le_iff_le hb ha\n\n"}
{"name":"StrictMonoOn.eq_iff_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem StrictMonoOn.eq_iff_eq (hf : StrictMonoOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a = f b ↔ a = b :=\n  ⟨fun h ↦ le_antisymm ((hf.le_iff_le ha hb).mp h.le) ((hf.le_iff_le hb ha).mp h.ge), by\n    rintro rfl\n    rfl⟩\n\n"}
{"name":"StrictAntiOn.eq_iff_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictAntiOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (Eq (f a) (f b)) (Eq b a)","decl":"theorem StrictAntiOn.eq_iff_eq (hf : StrictAntiOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a = f b ↔ b = a :=\n  (hf.dual_right.eq_iff_eq ha hb).trans eq_comm\n\n"}
{"name":"StrictMonoOn.lt_iff_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt a b)","decl":"theorem StrictMonoOn.lt_iff_lt (hf : StrictMonoOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a < f b ↔ a < b := by\n  rw [lt_iff_le_not_le, lt_iff_le_not_le, hf.le_iff_le ha hb, hf.le_iff_le hb ha]\n\n"}
{"name":"StrictAntiOn.lt_iff_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictAntiOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt b a)","decl":"theorem StrictAntiOn.lt_iff_lt (hf : StrictAntiOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    f a < f b ↔ b < a :=\n  hf.dual_right.lt_iff_lt hb ha\n\n"}
{"name":"StrictMono.le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\na b : α\n⊢ Iff (LE.le (f a) (f b)) (LE.le a b)","decl":"theorem StrictMono.le_iff_le (hf : StrictMono f) {a b : α} : f a ≤ f b ↔ a ≤ b :=\n  (hf.strictMonoOn Set.univ).le_iff_le trivial trivial\n\n"}
{"name":"StrictAnti.le_iff_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\na b : α\n⊢ Iff (LE.le (f a) (f b)) (LE.le b a)","decl":"theorem StrictAnti.le_iff_le (hf : StrictAnti f) {a b : α} : f a ≤ f b ↔ b ≤ a :=\n  (hf.strictAntiOn Set.univ).le_iff_le trivial trivial\n\n"}
{"name":"StrictMono.lt_iff_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\na b : α\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt a b)","decl":"theorem StrictMono.lt_iff_lt (hf : StrictMono f) {a b : α} : f a < f b ↔ a < b :=\n  (hf.strictMonoOn Set.univ).lt_iff_lt trivial trivial\n\n"}
{"name":"StrictAnti.lt_iff_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\na b : α\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt b a)","decl":"theorem StrictAnti.lt_iff_lt (hf : StrictAnti f) {a b : α} : f a < f b ↔ b < a :=\n  (hf.strictAntiOn Set.univ).lt_iff_lt trivial trivial\n\n"}
{"name":"StrictMonoOn.compares","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictMonoOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\no : Ordering\n⊢ Iff (o.Compares (f a) (f b)) (o.Compares a b)","decl":"protected theorem StrictMonoOn.compares (hf : StrictMonoOn f s) {a b : α} (ha : a ∈ s)\n    (hb : b ∈ s) : ∀ {o : Ordering}, o.Compares (f a) (f b) ↔ o.Compares a b\n  | Ordering.lt => hf.lt_iff_lt ha hb\n  | Ordering.eq => ⟨fun h ↦ ((hf.le_iff_le ha hb).1 h.le).antisymm\n                      ((hf.le_iff_le hb ha).1 h.symm.le), congr_arg _⟩\n  | Ordering.gt => hf.lt_iff_lt hb ha\n\n"}
{"name":"StrictAntiOn.compares","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\ns : Set α\nhf : StrictAntiOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\no : Ordering\n⊢ Iff (o.Compares (f a) (f b)) (o.Compares b a)","decl":"protected theorem StrictAntiOn.compares (hf : StrictAntiOn f s) {a b : α} (ha : a ∈ s)\n    (hb : b ∈ s) {o : Ordering} : o.Compares (f a) (f b) ↔ o.Compares b a :=\n  toDual_compares_toDual.trans <| hf.dual_right.compares hb ha\n\n"}
{"name":"StrictMono.compares","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\na b : α\no : Ordering\n⊢ Iff (o.Compares (f a) (f b)) (o.Compares a b)","decl":"protected theorem StrictMono.compares (hf : StrictMono f) {a b : α} {o : Ordering} :\n    o.Compares (f a) (f b) ↔ o.Compares a b :=\n  (hf.strictMonoOn Set.univ).compares trivial trivial\n\n"}
{"name":"StrictAnti.compares","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\na b : α\no : Ordering\n⊢ Iff (o.Compares (f a) (f b)) (o.Compares b a)","decl":"protected theorem StrictAnti.compares (hf : StrictAnti f) {a b : α} {o : Ordering} :\n    o.Compares (f a) (f b) ↔ o.Compares b a :=\n  (hf.strictAntiOn Set.univ).compares trivial trivial\n\n"}
{"name":"StrictMono.injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\n⊢ Function.Injective f","decl":"theorem StrictMono.injective (hf : StrictMono f) : Injective f :=\n  fun x y h ↦ show Compares eq x y from hf.compares.1 h\n\n"}
{"name":"StrictAnti.injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\n⊢ Function.Injective f","decl":"theorem StrictAnti.injective (hf : StrictAnti f) : Injective f :=\n  fun x y h ↦ show Compares eq x y from hf.compares.1 h.symm\n\n"}
{"name":"StrictMono.maximal_of_maximal_image","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\na : α\nhmax : ∀ (p : β), LE.le p (f a)\nx : α\n⊢ LE.le x a","decl":"theorem StrictMono.maximal_of_maximal_image (hf : StrictMono f) {a} (hmax : ∀ p, p ≤ f a) (x : α) :\n    x ≤ a :=\n  hf.le_iff_le.mp (hmax (f x))\n\n"}
{"name":"StrictMono.minimal_of_minimal_image","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\na : α\nhmin : ∀ (p : β), LE.le (f a) p\nx : α\n⊢ LE.le a x","decl":"theorem StrictMono.minimal_of_minimal_image (hf : StrictMono f) {a} (hmin : ∀ p, f a ≤ p) (x : α) :\n    a ≤ x :=\n  hf.le_iff_le.mp (hmin (f x))\n\n"}
{"name":"StrictAnti.minimal_of_maximal_image","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\na : α\nhmax : ∀ (p : β), LE.le p (f a)\nx : α\n⊢ LE.le a x","decl":"theorem StrictAnti.minimal_of_maximal_image (hf : StrictAnti f) {a} (hmax : ∀ p, p ≤ f a) (x : α) :\n    a ≤ x :=\n  hf.le_iff_le.mp (hmax (f x))\n\n"}
{"name":"StrictAnti.maximal_of_minimal_image","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictAnti f\na : α\nhmin : ∀ (p : β), LE.le (f a) p\nx : α\n⊢ LE.le x a","decl":"theorem StrictAnti.maximal_of_minimal_image (hf : StrictAnti f) {a} (hmin : ∀ p, f a ≤ p) (x : α) :\n    x ≤ a :=\n  hf.le_iff_le.mp (hmin (f x))\n\n"}
{"name":"Monotone.strictMono_iff_injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder β\nf : α → β\nhf : Monotone f\n⊢ Iff (StrictMono f) (Function.Injective f)","decl":"theorem Monotone.strictMono_iff_injective (hf : Monotone f) : StrictMono f ↔ Injective f :=\n  ⟨fun h ↦ h.injective, hf.strictMono_of_injective⟩\n\n"}
{"name":"Antitone.strictAnti_iff_injective","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder β\nf : α → β\nhf : Antitone f\n⊢ Iff (StrictAnti f) (Function.Injective f)","decl":"theorem Antitone.strictAnti_iff_injective (hf : Antitone f) : StrictAnti f ↔ Injective f :=\n  ⟨fun h ↦ h.injective, hf.strictAnti_of_injective⟩\n\n"}
{"name":"Monotone.eq_of_le_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder β\nf : α → β\na₁ a₂ : α\nh_mon : Monotone f\nh_fa : Eq (f a₁) (f a₂)\ni : α\nh₁ : LE.le a₁ i\nh₂ : LE.le i a₂\n⊢ Eq (f i) (f a₁)","decl":"/-- If a monotone function is equal at two points, it is equal between all of them -/\ntheorem Monotone.eq_of_le_of_le {a₁ a₂ : α} (h_mon : Monotone f) (h_fa : f a₁ = f a₂) {i : α}\n    (h₁ : a₁ ≤ i) (h₂ : i ≤ a₂) : f i = f a₁ := by\n  apply le_antisymm\n  · rw [h_fa]; exact h_mon h₂\n  · exact h_mon h₁\n\n"}
{"name":"Antitone.eq_of_le_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder β\nf : α → β\na₁ a₂ : α\nh_anti : Antitone f\nh_fa : Eq (f a₁) (f a₂)\ni : α\nh₁ : LE.le a₁ i\nh₂ : LE.le i a₂\n⊢ Eq (f i) (f a₁)","decl":"/-- If an antitone function is equal at two points, it is equal between all of them -/\ntheorem Antitone.eq_of_le_of_le {a₁ a₂ : α} (h_anti : Antitone f) (h_fa : f a₁ = f a₂) {i : α}\n    (h₁ : a₁ ≤ i) (h₂ : i ≤ a₂) : f i = f a₁ := by\n  apply le_antisymm\n  · exact h_anti h₁\n  · rw [h_fa]; exact h_anti h₂\n\n"}
{"name":"not_monotone_not_antitone_iff_exists_le_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Iff (And (Not (Monotone f)) (Not (Antitone f))) (Exists fun a => Exists fun b => Exists fun c => And (LE.le a b) (And (LE.le b c) (Or (And (LT.lt (f a) (f b)) (LT.lt (f c) (f b))) (And (LT.lt (f b) (f a)) (LT.lt (f b) (f c))))))","decl":"/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\nlemma not_monotone_not_antitone_iff_exists_le_le :\n    ¬ Monotone f ∧ ¬ Antitone f ↔\n      ∃ a b c, a ≤ b ∧ b ≤ c ∧ ((f a < f b ∧ f c < f b) ∨ (f b < f a ∧ f b < f c)) := by\n  simp_rw [Monotone, Antitone, not_forall, not_le]\n  refine Iff.symm ⟨?_, ?_⟩\n  · rintro ⟨a, b, c, hab, hbc, ⟨hfab, hfcb⟩ | ⟨hfba, hfbc⟩⟩\n    exacts [⟨⟨_, _, hbc, hfcb⟩, _, _, hab, hfab⟩, ⟨⟨_, _, hab, hfba⟩, _, _, hbc, hfbc⟩]\n  rintro ⟨⟨a, b, hab, hfba⟩, c, d, hcd, hfcd⟩\n  obtain hda | had := le_total d a\n  · obtain hfad | hfda := le_total (f a) (f d)\n    · exact ⟨c, d, b, hcd, hda.trans hab, Or.inl ⟨hfcd, hfba.trans_le hfad⟩⟩\n    · exact ⟨c, a, b, hcd.trans hda, hab, Or.inl ⟨hfcd.trans_le hfda, hfba⟩⟩\n  obtain hac | hca := le_total a c\n  · obtain hfdb | hfbd := le_or_lt (f d) (f b)\n    · exact ⟨a, c, d, hac, hcd, Or.inr ⟨hfcd.trans <| hfdb.trans_lt hfba, hfcd⟩⟩\n    obtain hfca | hfac := lt_or_le (f c) (f a)\n    · exact ⟨a, c, d, hac, hcd, Or.inr ⟨hfca, hfcd⟩⟩\n    obtain hbd | hdb := le_total b d\n    · exact ⟨a, b, d, hab, hbd, Or.inr ⟨hfba, hfbd⟩⟩\n    · exact ⟨a, d, b, had, hdb, Or.inl ⟨hfac.trans_lt hfcd, hfbd⟩⟩\n  · obtain hfdb | hfbd := le_or_lt (f d) (f b)\n    · exact ⟨c, a, b, hca, hab, Or.inl ⟨hfcd.trans <| hfdb.trans_lt hfba, hfba⟩⟩\n    obtain hfca | hfac := lt_or_le (f c) (f a)\n    · exact ⟨c, a, b, hca, hab, Or.inl ⟨hfca, hfba⟩⟩\n    obtain hbd | hdb := le_total b d\n    · exact ⟨a, b, d, hab, hbd, Or.inr ⟨hfba, hfbd⟩⟩\n    · exact ⟨a, d, b, had, hdb, Or.inl ⟨hfac.trans_lt hfcd, hfbd⟩⟩\n\n"}
{"name":"not_monotone_not_antitone_iff_exists_lt_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Iff (And (Not (Monotone f)) (Not (Antitone f))) (Exists fun a => Exists fun b => Exists fun c => And (LT.lt a b) (And (LT.lt b c) (Or (And (LT.lt (f a) (f b)) (LT.lt (f c) (f b))) (And (LT.lt (f b) (f a)) (LT.lt (f b) (f c))))))","decl":"/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\nlemma not_monotone_not_antitone_iff_exists_lt_lt :\n    ¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a < b ∧ b < c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by\n  simp_rw [not_monotone_not_antitone_iff_exists_le_le, ← and_assoc]\n  refine exists₃_congr (fun a b c ↦ and_congr_left <|\n    fun h ↦ (Ne.le_iff_lt ?_).and <| Ne.le_iff_lt ?_) <;>\n  (rintro rfl; simp at h)\n\n"}
{"name":"StrictMonoOn.cmp_map_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\ns : Set α\nx y : α\nhf : StrictMonoOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (cmp (f x) (f y)) (cmp x y)","decl":"theorem StrictMonoOn.cmp_map_eq (hf : StrictMonoOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    cmp (f x) (f y) = cmp x y :=\n  ((hf.compares hx hy).2 (cmp_compares x y)).cmp_eq\n\n"}
{"name":"StrictMono.cmp_map_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : StrictMono f\nx y : α\n⊢ Eq (cmp (f x) (f y)) (cmp x y)","decl":"theorem StrictMono.cmp_map_eq (hf : StrictMono f) (x y : α) : cmp (f x) (f y) = cmp x y :=\n  (hf.strictMonoOn Set.univ).cmp_map_eq trivial trivial\n\n"}
{"name":"StrictAntiOn.cmp_map_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\ns : Set α\nx y : α\nhf : StrictAntiOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (cmp (f x) (f y)) (cmp y x)","decl":"theorem StrictAntiOn.cmp_map_eq (hf : StrictAntiOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    cmp (f x) (f y) = cmp y x :=\n  hf.dual_right.cmp_map_eq hy hx\n\n"}
{"name":"StrictAnti.cmp_map_eq","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : StrictAnti f\nx y : α\n⊢ Eq (cmp (f x) (f y)) (cmp y x)","decl":"theorem StrictAnti.cmp_map_eq (hf : StrictAnti f) (x y : α) : cmp (f x) (f y) = cmp y x :=\n  (hf.strictAntiOn Set.univ).cmp_map_eq trivial trivial\n\n"}
{"name":"Nat.rel_of_forall_rel_succ_of_le_of_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝ : IsTrans β r\nf : Nat → β\na : Nat\nh : ∀ (n : Nat), LE.le a n → r (f n) (f (HAdd.hAdd n 1))\nb c : Nat\nhab : LE.le a b\nhbc : LT.lt b c\n⊢ r (f b) (f c)","decl":"theorem Nat.rel_of_forall_rel_succ_of_le_of_lt (r : β → β → Prop) [IsTrans β r] {f : ℕ → β} {a : ℕ}\n    (h : ∀ n, a ≤ n → r (f n) (f (n + 1))) ⦃b c : ℕ⦄ (hab : a ≤ b) (hbc : b < c) :\n    r (f b) (f c) := by\n  induction hbc with\n  | refl => exact h _ hab\n  | step b_lt_k r_b_k => exact _root_.trans r_b_k (h _ (hab.trans_lt b_lt_k).le)\n\n"}
{"name":"Nat.rel_of_forall_rel_succ_of_le_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝¹ : IsRefl β r\ninst✝ : IsTrans β r\nf : Nat → β\na : Nat\nh : ∀ (n : Nat), LE.le a n → r (f n) (f (HAdd.hAdd n 1))\nb c : Nat\nhab : LE.le a b\nhbc : LE.le b c\n⊢ r (f b) (f c)","decl":"theorem Nat.rel_of_forall_rel_succ_of_le_of_le (r : β → β → Prop) [IsRefl β r] [IsTrans β r]\n    {f : ℕ → β} {a : ℕ} (h : ∀ n, a ≤ n → r (f n) (f (n + 1)))\n    ⦃b c : ℕ⦄ (hab : a ≤ b) (hbc : b ≤ c) : r (f b) (f c) :=\n  hbc.eq_or_lt.elim (fun h ↦ h ▸ refl _) (Nat.rel_of_forall_rel_succ_of_le_of_lt r h hab)\n\n"}
{"name":"Nat.rel_of_forall_rel_succ_of_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝ : IsTrans β r\nf : Nat → β\nh : ∀ (n : Nat), r (f n) (f (HAdd.hAdd n 1))\na b : Nat\nhab : LT.lt a b\n⊢ r (f a) (f b)","decl":"theorem Nat.rel_of_forall_rel_succ_of_lt (r : β → β → Prop) [IsTrans β r] {f : ℕ → β}\n    (h : ∀ n, r (f n) (f (n + 1))) ⦃a b : ℕ⦄ (hab : a < b) : r (f a) (f b) :=\n  Nat.rel_of_forall_rel_succ_of_le_of_lt r (fun n _ ↦ h n) le_rfl hab\n\n"}
{"name":"Nat.rel_of_forall_rel_succ_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝¹ : IsRefl β r\ninst✝ : IsTrans β r\nf : Nat → β\nh : ∀ (n : Nat), r (f n) (f (HAdd.hAdd n 1))\na b : Nat\nhab : LE.le a b\n⊢ r (f a) (f b)","decl":"theorem Nat.rel_of_forall_rel_succ_of_le (r : β → β → Prop) [IsRefl β r] [IsTrans β r] {f : ℕ → β}\n    (h : ∀ n, r (f n) (f (n + 1))) ⦃a b : ℕ⦄ (hab : a ≤ b) : r (f a) (f b) :=\n  Nat.rel_of_forall_rel_succ_of_le_of_le r (fun n _ ↦ h n) le_rfl hab\n\n"}
{"name":"monotone_nat_of_le_succ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : ∀ (n : Nat), LE.le (f n) (f (HAdd.hAdd n 1))\n⊢ Monotone f","decl":"theorem monotone_nat_of_le_succ {f : ℕ → α} (hf : ∀ n, f n ≤ f (n + 1)) : Monotone f :=\n  Nat.rel_of_forall_rel_succ_of_le (· ≤ ·) hf\n\n"}
{"name":"antitone_nat_of_succ_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : ∀ (n : Nat), LE.le (f (HAdd.hAdd n 1)) (f n)\n⊢ Antitone f","decl":"theorem antitone_nat_of_succ_le {f : ℕ → α} (hf : ∀ n, f (n + 1) ≤ f n) : Antitone f :=\n  @monotone_nat_of_le_succ αᵒᵈ _ _ hf\n\n"}
{"name":"strictMono_nat_of_lt_succ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : ∀ (n : Nat), LT.lt (f n) (f (HAdd.hAdd n 1))\n⊢ StrictMono f","decl":"theorem strictMono_nat_of_lt_succ {f : ℕ → α} (hf : ∀ n, f n < f (n + 1)) : StrictMono f :=\n  Nat.rel_of_forall_rel_succ_of_lt (· < ·) hf\n\n"}
{"name":"strictAnti_nat_of_succ_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : ∀ (n : Nat), LT.lt (f (HAdd.hAdd n 1)) (f n)\n⊢ StrictAnti f","decl":"theorem strictAnti_nat_of_succ_lt {f : ℕ → α} (hf : ∀ n, f (n + 1) < f n) : StrictAnti f :=\n  @strictMono_nat_of_lt_succ αᵒᵈ _ f hf\n\n"}
{"name":"Nat.exists_strictMono'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Exists fun f => And (StrictMono f) (Eq (f 0) a)","decl":"/-- If `α` is a preorder with no maximal elements, then there exists a strictly monotone function\n`ℕ → α` with any prescribed value of `f 0`. -/\ntheorem exists_strictMono' [NoMaxOrder α] (a : α) : ∃ f : ℕ → α, StrictMono f ∧ f 0 = a := by\n  choose g hg using fun x : α ↦ exists_gt x\n  exact ⟨fun n ↦ Nat.recOn n a fun _ ↦ g, strictMono_nat_of_lt_succ fun n ↦ hg _, rfl⟩\n\n"}
{"name":"Nat.exists_strictAnti'","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na : α\n⊢ Exists fun f => And (StrictAnti f) (Eq (f 0) a)","decl":"/-- If `α` is a preorder with no maximal elements, then there exists a strictly antitone function\n`ℕ → α` with any prescribed value of `f 0`. -/\ntheorem exists_strictAnti' [NoMinOrder α] (a : α) : ∃ f : ℕ → α, StrictAnti f ∧ f 0 = a :=\n  exists_strictMono' (OrderDual.toDual a)\n\n"}
{"name":"Nat.exists_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : NoMaxOrder α\n⊢ Exists fun f => StrictMono f","decl":"/-- If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone\nfunction `ℕ → α`. -/\ntheorem exists_strictMono [Nonempty α] [NoMaxOrder α] : ∃ f : ℕ → α, StrictMono f :=\n  let ⟨a⟩ := ‹Nonempty α›\n  let ⟨f, hf, _⟩ := exists_strictMono' a\n  ⟨f, hf⟩\n\n"}
{"name":"Nat.exists_strictAnti","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : NoMinOrder α\n⊢ Exists fun f => StrictAnti f","decl":"/-- If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone\nfunction `ℕ → α`. -/\ntheorem exists_strictAnti [Nonempty α] [NoMinOrder α] : ∃ f : ℕ → α, StrictAnti f :=\n  exists_strictMono αᵒᵈ\n\n"}
{"name":"Nat.pow_self_mono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"⊢ Monotone fun n => HPow.hPow n n","decl":"lemma pow_self_mono : Monotone fun n : ℕ ↦ n ^ n := by\n  refine monotone_nat_of_le_succ fun n ↦ ?_\n  rw [Nat.pow_succ]\n  exact (Nat.pow_le_pow_left n.le_succ _).trans (Nat.le_mul_of_pos_right _ n.succ_pos)\n\n"}
{"name":"Nat.pow_monotoneOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"⊢ MonotoneOn (fun p => HPow.hPow p.fst p.snd) (setOf fun p => Ne p.fst 0)","decl":"lemma pow_monotoneOn : MonotoneOn (fun p : ℕ × ℕ ↦ p.1 ^ p.2) {p | p.1 ≠ 0} := fun _p _ _q hq hpq ↦\n  (Nat.pow_le_pow_left hpq.1 _).trans (Nat.pow_le_pow_right (Nat.pos_iff_ne_zero.2 hq) hpq.2)\n\n"}
{"name":"Nat.pow_self_strictMonoOn","module":"Mathlib.Order.Monotone.Basic","initialProofState":"⊢ StrictMonoOn (fun n => HPow.hPow n n) (setOf fun n => Ne n 0)","decl":"lemma pow_self_strictMonoOn : StrictMonoOn (fun n : ℕ ↦ n ^ n) {n : ℕ | n ≠ 0} :=\n  fun _m hm _n hn hmn ↦\n    (Nat.pow_lt_pow_left hmn hm).trans_le (Nat.pow_le_pow_right (Nat.pos_iff_ne_zero.2 hn) hmn.le)\n\n"}
{"name":"Int.rel_of_forall_rel_succ_of_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝ : IsTrans β r\nf : Int → β\nh : ∀ (n : Int), r (f n) (f (HAdd.hAdd n 1))\na b : Int\nhab : LT.lt a b\n⊢ r (f a) (f b)","decl":"theorem Int.rel_of_forall_rel_succ_of_lt (r : β → β → Prop) [IsTrans β r] {f : ℤ → β}\n    (h : ∀ n, r (f n) (f (n + 1))) ⦃a b : ℤ⦄ (hab : a < b) : r (f a) (f b) := by\n  rcases lt.dest hab with ⟨n, rfl⟩\n  clear hab\n  induction n with\n  | zero => rw [Int.ofNat_one]; apply h\n  | succ n ihn => rw [Int.ofNat_succ, ← Int.add_assoc]; exact _root_.trans ihn (h _)\n\n"}
{"name":"Int.rel_of_forall_rel_succ_of_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"β : Type v\nr : β → β → Prop\ninst✝¹ : IsRefl β r\ninst✝ : IsTrans β r\nf : Int → β\nh : ∀ (n : Int), r (f n) (f (HAdd.hAdd n 1))\na b : Int\nhab : LE.le a b\n⊢ r (f a) (f b)","decl":"theorem Int.rel_of_forall_rel_succ_of_le (r : β → β → Prop) [IsRefl β r] [IsTrans β r] {f : ℤ → β}\n    (h : ∀ n, r (f n) (f (n + 1))) ⦃a b : ℤ⦄ (hab : a ≤ b) : r (f a) (f b) :=\n  hab.eq_or_lt.elim (fun h ↦ h ▸ refl _) fun h' ↦ Int.rel_of_forall_rel_succ_of_lt r h h'\n\n"}
{"name":"monotone_int_of_le_succ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : ∀ (n : Int), LE.le (f n) (f (HAdd.hAdd n 1))\n⊢ Monotone f","decl":"theorem monotone_int_of_le_succ {f : ℤ → α} (hf : ∀ n, f n ≤ f (n + 1)) : Monotone f :=\n  Int.rel_of_forall_rel_succ_of_le (· ≤ ·) hf\n\n"}
{"name":"antitone_int_of_succ_le","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : ∀ (n : Int), LE.le (f (HAdd.hAdd n 1)) (f n)\n⊢ Antitone f","decl":"theorem antitone_int_of_succ_le {f : ℤ → α} (hf : ∀ n, f (n + 1) ≤ f n) : Antitone f :=\n  Int.rel_of_forall_rel_succ_of_le (· ≥ ·) hf\n\n"}
{"name":"strictMono_int_of_lt_succ","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : ∀ (n : Int), LT.lt (f n) (f (HAdd.hAdd n 1))\n⊢ StrictMono f","decl":"theorem strictMono_int_of_lt_succ {f : ℤ → α} (hf : ∀ n, f n < f (n + 1)) : StrictMono f :=\n  Int.rel_of_forall_rel_succ_of_lt (· < ·) hf\n\n"}
{"name":"strictAnti_int_of_succ_lt","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : ∀ (n : Int), LT.lt (f (HAdd.hAdd n 1)) (f n)\n⊢ StrictAnti f","decl":"theorem strictAnti_int_of_succ_lt {f : ℤ → α} (hf : ∀ n, f (n + 1) < f n) : StrictAnti f :=\n  Int.rel_of_forall_rel_succ_of_lt (· > ·) hf\n\n"}
{"name":"Int.exists_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : NoMinOrder α\ninst✝ : NoMaxOrder α\n⊢ Exists fun f => StrictMono f","decl":"/-- If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nmonotone function `f : ℤ → α`. -/\ntheorem exists_strictMono : ∃ f : ℤ → α, StrictMono f := by\n  inhabit α\n  rcases Nat.exists_strictMono' (default : α) with ⟨f, hf, hf₀⟩\n  rcases Nat.exists_strictAnti' (default : α) with ⟨g, hg, hg₀⟩\n  refine ⟨fun n ↦ Int.casesOn n f fun n ↦ g (n + 1), strictMono_int_of_lt_succ ?_⟩\n  rintro (n | _ | n)\n  · exact hf n.lt_succ_self\n  · show g 1 < f 0\n    rw [hf₀, ← hg₀]\n    exact hg Nat.zero_lt_one\n  · exact hg (Nat.lt_succ_self _)\n\n"}
{"name":"Int.exists_strictAnti","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : NoMinOrder α\ninst✝ : NoMaxOrder α\n⊢ Exists fun f => StrictAnti f","decl":"/-- If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nantitone function `f : ℤ → α`. -/\ntheorem exists_strictAnti : ∃ f : ℤ → α, StrictAnti f :=\n  exists_strictMono αᵒᵈ\n\n"}
{"name":"Monotone.ne_of_lt_of_lt_nat","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : Monotone f\nn : Nat\nx : α\nh1 : LT.lt (f n) x\nh2 : LT.lt x (f (HAdd.hAdd n 1))\na : Nat\n⊢ Ne (f a) x","decl":"/-- If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\n  `f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem Monotone.ne_of_lt_of_lt_nat {f : ℕ → α} (hf : Monotone f) (n : ℕ) {x : α} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x := by\n  rintro rfl\n  exact (hf.reflect_lt h1).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h2)\n\n"}
{"name":"Antitone.ne_of_lt_of_lt_nat","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Nat → α\nhf : Antitone f\nn : Nat\nx : α\nh1 : LT.lt (f (HAdd.hAdd n 1)) x\nh2 : LT.lt x (f n)\na : Nat\n⊢ Ne (f a) x","decl":"/-- If `f` is an antitone function from `ℕ` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem Antitone.ne_of_lt_of_lt_nat {f : ℕ → α} (hf : Antitone f) (n : ℕ) {x : α}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℕ) : f a ≠ x := by\n  rintro rfl\n  exact (hf.reflect_lt h2).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h1)\n\n"}
{"name":"Monotone.ne_of_lt_of_lt_int","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : Monotone f\nn : Int\nx : α\nh1 : LT.lt (f n) x\nh2 : LT.lt x (f (HAdd.hAdd n 1))\na : Int\n⊢ Ne (f a) x","decl":"/-- If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\n  `f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem Monotone.ne_of_lt_of_lt_int {f : ℤ → α} (hf : Monotone f) (n : ℤ) {x : α} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x := by\n  rintro rfl\n  exact (hf.reflect_lt h1).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h2)\n\n"}
{"name":"Antitone.ne_of_lt_of_lt_int","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : Int → α\nhf : Antitone f\nn : Int\nx : α\nh1 : LT.lt (f (HAdd.hAdd n 1)) x\nh2 : LT.lt x (f n)\na : Int\n⊢ Ne (f a) x","decl":"/-- If `f` is an antitone function from `ℤ` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem Antitone.ne_of_lt_of_lt_int {f : ℤ → α} (hf : Antitone f) (n : ℤ) {x : α}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x := by\n  rintro rfl\n  exact (hf.reflect_lt h2).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h1)\n\n"}
{"name":"Subtype.mono_coe","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nt : Set α\n⊢ Monotone Subtype.val","decl":"theorem Subtype.mono_coe [Preorder α] (t : Set α) : Monotone ((↑) : Subtype t → α) :=\n  fun _ _ ↦ id\n\n"}
{"name":"Subtype.strictMono_coe","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\ninst✝ : Preorder α\nt : Set α\n⊢ StrictMono Subtype.val","decl":"theorem Subtype.strictMono_coe [Preorder α] (t : Set α) :\n    StrictMono ((↑) : Subtype t → α) :=\n  fun _ _ ↦ id\n\n"}
{"name":"monotone_fst","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone Prod.fst","decl":"theorem monotone_fst : Monotone (@Prod.fst α β) := fun _ _ ↦ And.left\n\n"}
{"name":"monotone_snd","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Monotone Prod.snd","decl":"theorem monotone_snd : Monotone (@Prod.snd α β) := fun _ _ ↦ And.right\n\n"}
{"name":"Monotone.prod_map","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : α → γ\ng : β → δ\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone (Prod.map f g)","decl":"theorem Monotone.prod_map (hf : Monotone f) (hg : Monotone g) : Monotone (Prod.map f g) :=\n  fun _ _ h ↦ ⟨hf h.1, hg h.2⟩\n\n"}
{"name":"Antitone.prod_map","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : α → γ\ng : β → δ\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone (Prod.map f g)","decl":"theorem Antitone.prod_map (hf : Antitone f) (hg : Antitone g) : Antitone (Prod.map f g) :=\n  fun _ _ h ↦ ⟨hf h.1, hg h.2⟩\n\n"}
{"name":"monotone_prod_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nh : Prod α β → γ\n⊢ Iff (Monotone h) (And (∀ (a : α), Monotone fun b => h { fst := a, snd := b }) (∀ (b : β), Monotone fun a => h { fst := a, snd := b }))","decl":"lemma monotone_prod_iff {h : α × β → γ} :\n    Monotone h ↔ (∀ a, Monotone (fun b => h (a, b))) ∧ (∀ b, Monotone (fun a => h (a, b))) where\n  mp h := ⟨fun _ _ _ hab => h (Prod.mk_le_mk_iff_right.mpr hab),\n    fun _ _ _ hab => h (Prod.mk_le_mk_iff_left.mpr hab)⟩\n  mpr h _ _ hab := le_trans (h.1 _ (Prod.mk_le_mk.mp hab).2) (h.2 _ (Prod.mk_le_mk.mp hab).1)\n\n"}
{"name":"antitone_prod_iff","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nh : Prod α β → γ\n⊢ Iff (Antitone h) (And (∀ (a : α), Antitone fun b => h { fst := a, snd := b }) (∀ (b : β), Antitone fun a => h { fst := a, snd := b }))","decl":"lemma antitone_prod_iff {h : α × β → γ} :\n    Antitone h ↔ (∀ a, Antitone (fun b => h (a, b))) ∧ (∀ b, Antitone (fun a => h (a, b))) where\n  mp h := ⟨fun _ _ _ hab => h (Prod.mk_le_mk_iff_right.mpr hab),\n    fun _ _ _ hab => h (Prod.mk_le_mk_iff_left.mpr hab)⟩\n  mpr h _ _ hab:= le_trans (h.1 _ (Prod.mk_le_mk.mp hab).2) (h.2 _ (Prod.mk_le_mk.mp hab).1)\n\n"}
{"name":"StrictMono.prod_map","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_2\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : α → γ\ng : β → δ\nhf : StrictMono f\nhg : StrictMono g\n⊢ StrictMono (Prod.map f g)","decl":"theorem StrictMono.prod_map (hf : StrictMono f) (hg : StrictMono g) : StrictMono (Prod.map f g) :=\n  fun a b ↦ by\n  simp only [Prod.lt_iff]\n  exact Or.imp (And.imp hf.imp hg.monotone.imp) (And.imp hf.monotone.imp hg.imp)\n\n"}
{"name":"StrictAnti.prod_map","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_2\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : α → γ\ng : β → δ\nhf : StrictAnti f\nhg : StrictAnti g\n⊢ StrictAnti (Prod.map f g)","decl":"theorem StrictAnti.prod_map (hf : StrictAnti f) (hg : StrictAnti g) : StrictAnti (Prod.map f g) :=\n  fun a b ↦ by\n  simp only [Prod.lt_iff]\n  exact Or.imp (And.imp hf.imp hg.antitone.imp) (And.imp hf.antitone.imp hg.imp)\n\n"}
{"name":"Function.update_mono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nf : (i : ι) → π i\ni : ι\n⊢ Monotone (Function.update f i)","decl":"theorem update_mono : Monotone (update f i) := fun _ _ => update_le_update_iff'.2\n\n"}
{"name":"Function.update_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nf : (i : ι) → π i\ni : ι\n⊢ StrictMono (Function.update f i)","decl":"theorem update_strictMono : StrictMono (update f i) := fun _ _ => update_lt_update_iff.2\n\n"}
{"name":"Function.const_mono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\n⊢ Monotone (Function.const β)","decl":"theorem const_mono : Monotone (const β : α → β → α) := fun _ _ h _ ↦ h\n\n"}
{"name":"Function.const_strictMono","module":"Mathlib.Order.Monotone.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Nonempty β\n⊢ StrictMono (Function.const β)","decl":"theorem const_strictMono [Nonempty β] : StrictMono (const β : α → β → α) :=\n  fun _ _ ↦ const_lt_const.2\n\n"}
{"name":"monotone_iff_apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\n⊢ Iff (Monotone f) (∀ (i : ι), Monotone fun x => f x i)","decl":"lemma monotone_iff_apply₂ : Monotone f ↔ ∀ i, Monotone (f · i) := by\n  simp [Monotone, Pi.le_def, @forall_swap ι]\n\n"}
{"name":"antitone_iff_apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\n⊢ Iff (Antitone f) (∀ (i : ι), Antitone fun x => f x i)","decl":"lemma antitone_iff_apply₂ : Antitone f ↔ ∀ i, Antitone (f · i) := by\n  simp [Antitone, Pi.le_def, @forall_swap ι]\n\n"}
{"name":"Monotone.of_apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\na✝ : ∀ (i : ι), Monotone fun x => f x i\n⊢ Monotone f","decl":"alias ⟨Monotone.apply₂, Monotone.of_apply₂⟩ := monotone_iff_apply₂\n"}
{"name":"Monotone.apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\na✝ : Monotone f\ni : ι\n⊢ Monotone fun x => f x i","decl":"alias ⟨Monotone.apply₂, Monotone.of_apply₂⟩ := monotone_iff_apply₂\n"}
{"name":"Antitone.apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\na✝ : Antitone f\ni : ι\n⊢ Antitone fun x => f x i","decl":"alias ⟨Antitone.apply₂, Antitone.of_apply₂⟩ := antitone_iff_apply₂\n\n"}
{"name":"Antitone.of_apply₂","module":"Mathlib.Order.Monotone.Basic","initialProofState":"ι : Type u_1\nα : Type u\nβ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (β i)\ninst✝ : Preorder α\nf : α → (i : ι) → β i\na✝ : ∀ (i : ι), Antitone fun x => f x i\n⊢ Antitone f","decl":"alias ⟨Antitone.apply₂, Antitone.of_apply₂⟩ := antitone_iff_apply₂\n\n"}
{"name":"Nat.stabilises_of_monotone","module":"Mathlib.Order.Monotone.Basic","initialProofState":"f : Nat → Nat\nb n : Nat\nhfmono : Monotone f\nhfb : ∀ (m : Nat), LE.le (f m) b\nhfstab : ∀ (m : Nat), Eq (f m) (f (HAdd.hAdd m 1)) → Eq (f (HAdd.hAdd m 1)) (f (HAdd.hAdd m 2))\nhbn : LE.le b n\n⊢ Eq (f n) (f b)","decl":"/-- A monotone function `f : ℕ → ℕ` bounded by `b`, which is constant after stabilising for the\nfirst time, stabilises in at most `b` steps. -/\nlemma Nat.stabilises_of_monotone {f : ℕ → ℕ} {b n : ℕ} (hfmono : Monotone f) (hfb : ∀ m, f m ≤ b)\n    (hfstab : ∀ m, f m = f (m + 1) → f (m + 1) = f (m + 2)) (hbn : b ≤ n) : f n = f b := by\n  obtain ⟨m, hmb, hm⟩ : ∃ m ≤ b, f m = f (m + 1) := by\n    contrapose! hfb\n    let rec strictMono : ∀ m ≤ b + 1, m ≤ f m\n    | 0, _ => Nat.zero_le _\n    | m + 1, hmb => (strictMono _ <| m.le_succ.trans hmb).trans_lt <| (hfmono m.le_succ).lt_of_ne <|\n        hfb _ <| Nat.le_of_succ_le_succ hmb\n    exact ⟨b + 1, strictMono _ le_rfl⟩\n  replace key : ∀ k : ℕ, f (m + k) = f (m + k + 1) ∧ f (m + k) = f m := fun k =>\n    Nat.rec ⟨hm, rfl⟩ (fun k ih => ⟨hfstab _ ih.1, ih.1.symm.trans ih.2⟩) k\n  replace key : ∀ k ≥ m, f k = f m := fun k hk =>\n    (congr_arg f (Nat.add_sub_of_le hk)).symm.trans (key (k - m)).2\n  exact (key n (hmb.trans hbn)).trans (key b hmb).symm\n\n"}
{"name":"Group.card_pow_eq_card_pow_card_univ_aux","module":"Mathlib.Order.Monotone.Basic","initialProofState":"f : Nat → Nat\nb n : Nat\nhfmono : Monotone f\nhfb : ∀ (m : Nat), LE.le (f m) b\nhfstab : ∀ (m : Nat), Eq (f m) (f (HAdd.hAdd m 1)) → Eq (f (HAdd.hAdd m 1)) (f (HAdd.hAdd m 2))\nhbn : LE.le b n\n⊢ Eq (f n) (f b)","decl":"@[deprecated (since := \"2024-11-27\")]\nalias Group.card_pow_eq_card_pow_card_univ_aux := Nat.stabilises_of_monotone\n\n"}
{"name":"Group.card_nsmul_eq_card_nsmulpow_card_univ_aux","module":"Mathlib.Order.Monotone.Basic","initialProofState":"f : Nat → Nat\nb n : Nat\nhfmono : Monotone f\nhfb : ∀ (m : Nat), LE.le (f m) b\nhfstab : ∀ (m : Nat), Eq (f m) (f (HAdd.hAdd m 1)) → Eq (f (HAdd.hAdd m 1)) (f (HAdd.hAdd m 2))\nhbn : LE.le b n\n⊢ Eq (f n) (f b)","decl":"@[deprecated (since := \"2024-11-27\")]\nalias Group.card_nsmul_eq_card_nsmulpow_card_univ_aux := Nat.stabilises_of_monotone\n"}
