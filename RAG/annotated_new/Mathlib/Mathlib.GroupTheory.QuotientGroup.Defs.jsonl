{"name":"QuotientAddGroup.coe_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (⇑(QuotientAddGroup.mk' N)) QuotientAddGroup.mk","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk' : (mk' N : G → G ⧸ N) = mk :=\n  rfl\n\n"}
{"name":"QuotientGroup.coe_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (⇑(QuotientGroup.mk' N)) QuotientGroup.mk","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk' : (mk' N : G → G ⧸ N) = mk :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk'_apply","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nx : G\n⊢ Eq ((QuotientAddGroup.mk' N) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem mk'_apply (x : G) : mk' N x = x :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk'_apply","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nx : G\n⊢ Eq ((QuotientGroup.mk' N) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem mk'_apply (x : G) : mk' N x = x :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk'_surjective","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Function.Surjective ⇑(QuotientGroup.mk' N)","decl":"@[to_additive]\ntheorem mk'_surjective : Surjective <| mk' N :=\n  @mk_surjective _ _ N\n\n"}
{"name":"QuotientAddGroup.mk'_surjective","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Function.Surjective ⇑(QuotientAddGroup.mk' N)","decl":"@[to_additive]\ntheorem mk'_surjective : Surjective <| mk' N :=\n  @mk_surjective _ _ N\n\n"}
{"name":"QuotientAddGroup.mk'_eq_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nx y : G\n⊢ Iff (Eq ((QuotientAddGroup.mk' N) x) ((QuotientAddGroup.mk' N) y)) (Exists fun z => And (Membership.mem N z) (Eq (HAdd.hAdd x z) y))","decl":"@[to_additive]\ntheorem mk'_eq_mk' {x y : G} : mk' N x = mk' N y ↔ ∃ z ∈ N, x * z = y :=\n  QuotientGroup.eq.trans <| by\n    simp only [← _root_.eq_inv_mul_iff_mul_eq, exists_prop, exists_eq_right]\n\n"}
{"name":"QuotientGroup.mk'_eq_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nx y : G\n⊢ Iff (Eq ((QuotientGroup.mk' N) x) ((QuotientGroup.mk' N) y)) (Exists fun z => And (Membership.mem N z) (Eq (HMul.hMul x z) y))","decl":"@[to_additive]\ntheorem mk'_eq_mk' {x y : G} : mk' N x = mk' N y ↔ ∃ z ∈ N, x * z = y :=\n  QuotientGroup.eq.trans <| by\n    simp only [← _root_.eq_inv_mul_iff_mul_eq, exists_prop, exists_eq_right]\n\n"}
{"name":"QuotientGroup.monoidHom_ext_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Type x\ninst✝ : Monoid M\nf g : MonoidHom (HasQuotient.Quotient G N) M\n⊢ Iff (Eq f g) (Eq (f.comp (QuotientGroup.mk' N)) (g.comp (QuotientGroup.mk' N)))","decl":"/-- Two `MonoidHom`s from a quotient group are equal if their compositions with\n`QuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext 1100) \"Two `AddMonoidHom`s from an additive quotient group are equal if\n their compositions with `AddQuotientGroup.mk'` are equal.\n\n See note [partially-applied ext lemmas]. \"]\ntheorem monoidHom_ext ⦃f g : G ⧸ N →* M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (DFunLike.congr_fun h :)\n\n"}
{"name":"QuotientAddGroup.addMonoidHom_ext","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : Type x\ninst✝ : AddMonoid M\nf g : AddMonoidHom (HasQuotient.Quotient G N) M\nh : Eq (f.comp (QuotientAddGroup.mk' N)) (g.comp (QuotientAddGroup.mk' N))\n⊢ Eq f g","decl":"/-- Two `MonoidHom`s from a quotient group are equal if their compositions with\n`QuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext 1100) \"Two `AddMonoidHom`s from an additive quotient group are equal if\n their compositions with `AddQuotientGroup.mk'` are equal.\n\n See note [partially-applied ext lemmas]. \"]\ntheorem monoidHom_ext ⦃f g : G ⧸ N →* M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (DFunLike.congr_fun h :)\n\n"}
{"name":"QuotientAddGroup.addMonoidHom_ext_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : Type x\ninst✝ : AddMonoid M\nf g : AddMonoidHom (HasQuotient.Quotient G N) M\n⊢ Iff (Eq f g) (Eq (f.comp (QuotientAddGroup.mk' N)) (g.comp (QuotientAddGroup.mk' N)))","decl":"/-- Two `MonoidHom`s from a quotient group are equal if their compositions with\n`QuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext 1100) \"Two `AddMonoidHom`s from an additive quotient group are equal if\n their compositions with `AddQuotientGroup.mk'` are equal.\n\n See note [partially-applied ext lemmas]. \"]\ntheorem monoidHom_ext ⦃f g : G ⧸ N →* M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (DFunLike.congr_fun h :)\n\n"}
{"name":"QuotientGroup.monoidHom_ext","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Type x\ninst✝ : Monoid M\nf g : MonoidHom (HasQuotient.Quotient G N) M\nh : Eq (f.comp (QuotientGroup.mk' N)) (g.comp (QuotientGroup.mk' N))\n⊢ Eq f g","decl":"/-- Two `MonoidHom`s from a quotient group are equal if their compositions with\n`QuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext 1100) \"Two `AddMonoidHom`s from an additive quotient group are equal if\n their compositions with `AddQuotientGroup.mk'` are equal.\n\n See note [partially-applied ext lemmas]. \"]\ntheorem monoidHom_ext ⦃f g : G ⧸ N →* M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (DFunLike.congr_fun h :)\n\n"}
{"name":"QuotientGroup.eq_one_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : N.Normal\nx : G\n⊢ Iff (Eq (↑x) 1) (Membership.mem N x)","decl":"@[to_additive (attr := simp)]\ntheorem eq_one_iff {N : Subgroup G} [N.Normal] (x : G) : (x : G ⧸ N) = 1 ↔ x ∈ N := by\n  refine QuotientGroup.eq.trans ?_\n  rw [mul_one, Subgroup.inv_mem_iff]\n\n/- Note: `range_mk'` is a lemma about the primed constructor `QuotientGroup.mk'`, not a\n  modified version of some `range_mk`. -/\n"}
{"name":"QuotientAddGroup.eq_zero_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\ninst✝ : N.Normal\nx : G\n⊢ Iff (Eq (↑x) 0) (Membership.mem N x)","decl":"@[to_additive (attr := simp)]\ntheorem eq_one_iff {N : Subgroup G} [N.Normal] (x : G) : (x : G ⧸ N) = 1 ↔ x ∈ N := by\n  refine QuotientGroup.eq.trans ?_\n  rw [mul_one, Subgroup.inv_mem_iff]\n\n/- Note: `range_mk'` is a lemma about the primed constructor `QuotientGroup.mk'`, not a\n  modified version of some `range_mk`. -/\n"}
{"name":"QuotientGroup.range_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (QuotientGroup.mk' N).range Top.top","decl":"set_option linter.docPrime false in\n@[to_additive (attr := simp)]\ntheorem range_mk' : (QuotientGroup.mk' N).range = ⊤ :=\n  MonoidHom.range_eq_top.mpr (mk'_surjective N)\n\n"}
{"name":"QuotientAddGroup.range_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (QuotientAddGroup.mk' N).range Top.top","decl":"set_option linter.docPrime false in\n@[to_additive (attr := simp)]\ntheorem range_mk' : (QuotientGroup.mk' N).range = ⊤ :=\n  MonoidHom.range_eq_top.mpr (mk'_surjective N)\n\n"}
{"name":"QuotientGroup.ker_le_range_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : Group G\nH : Type v\ninst✝² : Group H\nI : Type w\ninst✝¹ : Group I\nf : MonoidHom G H\ninst✝ : f.range.Normal\ng : MonoidHom H I\n⊢ Iff (LE.le g.ker f.range) (Eq ((QuotientGroup.mk' f.range).comp g.ker.subtype) 1)","decl":"@[to_additive]\ntheorem ker_le_range_iff {I : Type w} [Group I] (f : G →* H) [f.range.Normal] (g : H →* I) :\n    g.ker ≤ f.range ↔ (mk' f.range).comp g.ker.subtype = 1 :=\n  ⟨fun h => MonoidHom.ext fun ⟨_, hx⟩ => (eq_one_iff _).mpr <| h hx,\n    fun h x hx => (eq_one_iff _).mp <| by exact DFunLike.congr_fun h ⟨x, hx⟩⟩\n\n"}
{"name":"QuotientAddGroup.ker_le_range_iff","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : AddGroup G\nH : Type v\ninst✝² : AddGroup H\nI : Type w\ninst✝¹ : AddGroup I\nf : AddMonoidHom G H\ninst✝ : f.range.Normal\ng : AddMonoidHom H I\n⊢ Iff (LE.le g.ker f.range) (Eq ((QuotientAddGroup.mk' f.range).comp g.ker.subtype) 0)","decl":"@[to_additive]\ntheorem ker_le_range_iff {I : Type w} [Group I] (f : G →* H) [f.range.Normal] (g : H →* I) :\n    g.ker ≤ f.range ↔ (mk' f.range).comp g.ker.subtype = 1 :=\n  ⟨fun h => MonoidHom.ext fun ⟨_, hx⟩ => (eq_one_iff _).mpr <| h hx,\n    fun h x hx => (eq_one_iff _).mp <| by exact DFunLike.congr_fun h ⟨x, hx⟩⟩\n\n"}
{"name":"QuotientAddGroup.ker_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (QuotientAddGroup.mk' N).ker N","decl":"@[to_additive (attr := simp)]\ntheorem ker_mk' : MonoidHom.ker (QuotientGroup.mk' N : G →* G ⧸ N) = N :=\n  Subgroup.ext eq_one_iff\n-- Porting note: I think this is misnamed without the prime\n\n"}
{"name":"QuotientGroup.ker_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (QuotientGroup.mk' N).ker N","decl":"@[to_additive (attr := simp)]\ntheorem ker_mk' : MonoidHom.ker (QuotientGroup.mk' N : G →* G ⧸ N) = N :=\n  Subgroup.ext eq_one_iff\n-- Porting note: I think this is misnamed without the prime\n\n"}
{"name":"QuotientAddGroup.eq_iff_sub_mem","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nx y : G\n⊢ Iff (Eq ↑x ↑y) (Membership.mem N (HSub.hSub x y))","decl":"@[to_additive]\ntheorem eq_iff_div_mem {N : Subgroup G} [nN : N.Normal] {x y : G} :\n    (x : G ⧸ N) = y ↔ x / y ∈ N := by\n  refine eq_comm.trans (QuotientGroup.eq.trans ?_)\n  rw [nN.mem_comm_iff, div_eq_mul_inv]\n\n-- for commutative groups we don't need normality assumption\n\n"}
{"name":"QuotientGroup.eq_iff_div_mem","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nx y : G\n⊢ Iff (Eq ↑x ↑y) (Membership.mem N (HDiv.hDiv x y))","decl":"@[to_additive]\ntheorem eq_iff_div_mem {N : Subgroup G} [nN : N.Normal] {x y : G} :\n    (x : G ⧸ N) = y ↔ x / y ∈ N := by\n  refine eq_comm.trans (QuotientGroup.eq.trans ?_)\n  rw [nN.mem_comm_iff, div_eq_mul_inv]\n\n-- for commutative groups we don't need normality assumption\n\n"}
{"name":"QuotientGroup.mk_one","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp)]\ntheorem mk_one : ((1 : G) : Q) = 1 :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_zero","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp)]\ntheorem mk_one : ((1 : G) : Q) = 1 :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk_mul","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\na b : G\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul (a b : G) : ((a * b : G) : Q) = a * b :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_add","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\na b : G\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul (a b : G) : ((a * b : G) : Q) = a * b :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk_inv","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\na : G\n⊢ Eq (↑(Inv.inv a)) (Inv.inv ↑a)","decl":"@[to_additive (attr := simp)]\ntheorem mk_inv (a : G) : ((a⁻¹ : G) : Q) = (a : Q)⁻¹ :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_neg","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\na : G\n⊢ Eq (↑(Neg.neg a)) (Neg.neg ↑a)","decl":"@[to_additive (attr := simp)]\ntheorem mk_inv (a : G) : ((a⁻¹ : G) : Q) = (a : Q)⁻¹ :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk_div","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\na b : G\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[to_additive (attr := simp)]\ntheorem mk_div (a b : G) : ((a / b : G) : Q) = a / b :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_sub","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\na b : G\n⊢ Eq (↑(HSub.hSub a b)) (HSub.hSub ↑a ↑b)","decl":"@[to_additive (attr := simp)]\ntheorem mk_div (a b : G) : ((a / b : G) : Q) = a / b :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk_pow","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\na : G\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[to_additive (attr := simp)]\ntheorem mk_pow (a : G) (n : ℕ) : ((a ^ n : G) : Q) = (a : Q) ^ n :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_nsmul","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\na : G\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[to_additive (attr := simp)]\ntheorem mk_pow (a : G) (n : ℕ) : ((a ^ n : G) : Q) = (a : Q) ^ n :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.mk_zsmul","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\na : G\nn : Int\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[to_additive (attr := simp)]\ntheorem mk_zpow (a : G) (n : ℤ) : ((a ^ n : G) : Q) = (a : Q) ^ n :=\n  rfl\n\n"}
{"name":"QuotientGroup.mk_zpow","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\na : G\nn : Int\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[to_additive (attr := simp)]\ntheorem mk_zpow (a : G) (n : ℤ) : ((a ^ n : G) : Q) = (a : Q) ^ n :=\n  rfl\n\n"}
{"name":"QuotientGroup.map_mk'_self","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (Subgroup.map (QuotientGroup.mk' N) N) Bot.bot","decl":"@[to_additive (attr := simp)] lemma map_mk'_self : N.map (mk' N) = ⊥ := by aesop\n\n"}
{"name":"QuotientAddGroup.map_mk'_self","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (AddSubgroup.map (QuotientAddGroup.mk' N) N) Bot.bot","decl":"@[to_additive (attr := simp)] lemma map_mk'_self : N.map (mk' N) = ⊥ := by aesop\n\n"}
{"name":"QuotientAddGroup.lift_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : Type x\ninst✝ : AddMonoid M\nφ : AddMonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientAddGroup.lift N φ HN) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_mk {φ : G →* M} (HN : N ≤ φ.ker) (g : G) : lift N φ HN (g : Q) = φ g :=\n  rfl\n\n"}
{"name":"QuotientGroup.lift_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Type x\ninst✝ : Monoid M\nφ : MonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientGroup.lift N φ HN) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_mk {φ : G →* M} (HN : N ≤ φ.ker) (g : G) : lift N φ HN (g : Q) = φ g :=\n  rfl\n\n"}
{"name":"QuotientGroup.lift_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Type x\ninst✝ : Monoid M\nφ : MonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientGroup.lift N φ HN) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_mk' {φ : G →* M} (HN : N ≤ φ.ker) (g : G) : lift N φ HN (mk g : Q) = φ g :=\n  rfl\n-- TODO: replace `mk` with `mk'`)\n\n"}
{"name":"QuotientAddGroup.lift_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : Type x\ninst✝ : AddMonoid M\nφ : AddMonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientAddGroup.lift N φ HN) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_mk' {φ : G →* M} (HN : N ≤ φ.ker) (g : G) : lift N φ HN (mk g : Q) = φ g :=\n  rfl\n-- TODO: replace `mk` with `mk'`)\n\n"}
{"name":"QuotientGroup.lift_quot_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Type x\ninst✝ : Monoid M\nφ : MonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientGroup.lift N φ HN) (Quot.mk (⇑(QuotientGroup.leftRel N)) g)) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_quot_mk {φ : G →* M} (HN : N ≤ φ.ker) (g : G) :\n    lift N φ HN (Quot.mk _ g : Q) = φ g :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.lift_quot_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : Type x\ninst✝ : AddMonoid M\nφ : AddMonoidHom G M\nHN : LE.le N φ.ker\ng : G\n⊢ Eq ((QuotientAddGroup.lift N φ HN) (Quot.mk (⇑(QuotientAddGroup.leftRel N)) g)) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem lift_quot_mk {φ : G →* M} (HN : N ≤ φ.ker) (g : G) :\n    lift N φ HN (Quot.mk _ g : Q) = φ g :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.map_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝² : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nH : Type v\ninst✝¹ : AddGroup H\nM : AddSubgroup H\ninst✝ : M.Normal\nf : AddMonoidHom G H\nh : LE.le N (AddSubgroup.comap f M)\nx : G\n⊢ Eq ((QuotientAddGroup.map N M f h) ↑x) ↑(f x)","decl":"@[to_additive (attr := simp)]\ntheorem map_mk (M : Subgroup H) [M.Normal] (f : G →* H) (h : N ≤ M.comap f) (x : G) :\n    map N M f h ↑x = ↑(f x) :=\n  rfl\n\n"}
{"name":"QuotientGroup.map_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝² : Group G\nN : Subgroup G\nnN : N.Normal\nH : Type v\ninst✝¹ : Group H\nM : Subgroup H\ninst✝ : M.Normal\nf : MonoidHom G H\nh : LE.le N (Subgroup.comap f M)\nx : G\n⊢ Eq ((QuotientGroup.map N M f h) ↑x) ↑(f x)","decl":"@[to_additive (attr := simp)]\ntheorem map_mk (M : Subgroup H) [M.Normal] (f : G →* H) (h : N ≤ M.comap f) (x : G) :\n    map N M f h ↑x = ↑(f x) :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.map_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝² : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nH : Type v\ninst✝¹ : AddGroup H\nM : AddSubgroup H\ninst✝ : M.Normal\nf : AddMonoidHom G H\nh : LE.le N (AddSubgroup.comap f M)\nx : G\n⊢ Eq ((QuotientAddGroup.map N M f h) ((QuotientAddGroup.mk' N) x)) ↑(f x)","decl":"@[to_additive]\ntheorem map_mk' (M : Subgroup H) [M.Normal] (f : G →* H) (h : N ≤ M.comap f) (x : G) :\n    map N M f h (mk' _ x) = ↑(f x) :=\n  rfl\n\n"}
{"name":"QuotientGroup.map_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝² : Group G\nN : Subgroup G\nnN : N.Normal\nH : Type v\ninst✝¹ : Group H\nM : Subgroup H\ninst✝ : M.Normal\nf : MonoidHom G H\nh : LE.le N (Subgroup.comap f M)\nx : G\n⊢ Eq ((QuotientGroup.map N M f h) ((QuotientGroup.mk' N) x)) ↑(f x)","decl":"@[to_additive]\ntheorem map_mk' (M : Subgroup H) [M.Normal] (f : G →* H) (h : N ≤ M.comap f) (x : G) :\n    map N M f h (mk' _ x) = ↑(f x) :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.map_id_apply","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nh : optParam (LE.le N (AddSubgroup.comap (AddMonoidHom.id G) N)) ⋯\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientAddGroup.map N N (AddMonoidHom.id G) h) x) x","decl":"@[to_additive]\ntheorem map_id_apply (h : N ≤ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) (x) :\n    map N N (MonoidHom.id _) h x = x :=\n  induction_on x fun _x => rfl\n\n"}
{"name":"QuotientGroup.map_id_apply","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nh : optParam (LE.le N (Subgroup.comap (MonoidHom.id G) N)) ⋯\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientGroup.map N N (MonoidHom.id G) h) x) x","decl":"@[to_additive]\ntheorem map_id_apply (h : N ≤ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) (x) :\n    map N N (MonoidHom.id _) h x = x :=\n  induction_on x fun _x => rfl\n\n"}
{"name":"QuotientGroup.map_id","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nh : optParam (LE.le N (Subgroup.comap (MonoidHom.id G) N)) ⋯\n⊢ Eq (QuotientGroup.map N N (MonoidHom.id G) h) (MonoidHom.id (HasQuotient.Quotient G N))","decl":"@[to_additive (attr := simp)]\ntheorem map_id (h : N ≤ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) :\n    map N N (MonoidHom.id _) h = MonoidHom.id _ :=\n  MonoidHom.ext (map_id_apply N h)\n\n"}
{"name":"QuotientAddGroup.map_id","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nh : optParam (LE.le N (AddSubgroup.comap (AddMonoidHom.id G) N)) ⋯\n⊢ Eq (QuotientAddGroup.map N N (AddMonoidHom.id G) h) (AddMonoidHom.id (HasQuotient.Quotient G N))","decl":"@[to_additive (attr := simp)]\ntheorem map_id (h : N ≤ Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) :\n    map N N (MonoidHom.id _) h = MonoidHom.id _ :=\n  MonoidHom.ext (map_id_apply N h)\n\n"}
{"name":"QuotientAddGroup.map_map","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝⁴ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nH : Type v\ninst✝³ : AddGroup H\nI : Type u_1\ninst✝² : AddGroup I\nM : AddSubgroup H\nO : AddSubgroup I\ninst✝¹ : M.Normal\ninst✝ : O.Normal\nf : AddMonoidHom G H\ng : AddMonoidHom H I\nhf : LE.le N (AddSubgroup.comap f M)\nhg : LE.le M (AddSubgroup.comap g O)\nhgf : optParam (LE.le N (AddSubgroup.comap (g.comp f) O)) ⋯\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientAddGroup.map M O g hg) ((QuotientAddGroup.map N M f hf) x)) ((QuotientAddGroup.map N O (g.comp f) hgf) x)","decl":"@[to_additive (attr := simp)]\ntheorem map_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G →* H) (g : H →* I) (hf : N ≤ Subgroup.comap f M) (hg : M ≤ Subgroup.comap g O)\n    (hgf : N ≤ Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _)))\n    (x : G ⧸ N) : map M O g hg (map N M f hf x) = map N O (g.comp f) hgf x := by\n  refine induction_on x fun x => ?_\n  simp only [map_mk, MonoidHom.comp_apply]\n\n"}
{"name":"QuotientGroup.map_map","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝⁴ : Group G\nN : Subgroup G\nnN : N.Normal\nH : Type v\ninst✝³ : Group H\nI : Type u_1\ninst✝² : Group I\nM : Subgroup H\nO : Subgroup I\ninst✝¹ : M.Normal\ninst✝ : O.Normal\nf : MonoidHom G H\ng : MonoidHom H I\nhf : LE.le N (Subgroup.comap f M)\nhg : LE.le M (Subgroup.comap g O)\nhgf : optParam (LE.le N (Subgroup.comap (g.comp f) O)) ⋯\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientGroup.map M O g hg) ((QuotientGroup.map N M f hf) x)) ((QuotientGroup.map N O (g.comp f) hgf) x)","decl":"@[to_additive (attr := simp)]\ntheorem map_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G →* H) (g : H →* I) (hf : N ≤ Subgroup.comap f M) (hg : M ≤ Subgroup.comap g O)\n    (hgf : N ≤ Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _)))\n    (x : G ⧸ N) : map M O g hg (map N M f hf x) = map N O (g.comp f) hgf x := by\n  refine induction_on x fun x => ?_\n  simp only [map_mk, MonoidHom.comp_apply]\n\n"}
{"name":"QuotientGroup.map_comp_map","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝⁴ : Group G\nN : Subgroup G\nnN : N.Normal\nH : Type v\ninst✝³ : Group H\nI : Type u_1\ninst✝² : Group I\nM : Subgroup H\nO : Subgroup I\ninst✝¹ : M.Normal\ninst✝ : O.Normal\nf : MonoidHom G H\ng : MonoidHom H I\nhf : LE.le N (Subgroup.comap f M)\nhg : LE.le M (Subgroup.comap g O)\nhgf : optParam (LE.le N (Subgroup.comap (g.comp f) O)) ⋯\n⊢ Eq ((QuotientGroup.map M O g hg).comp (QuotientGroup.map N M f hf)) (QuotientGroup.map N O (g.comp f) hgf)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G →* H) (g : H →* I) (hf : N ≤ Subgroup.comap f M) (hg : M ≤ Subgroup.comap g O)\n    (hgf : N ≤ Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _))) :\n    (map M O g hg).comp (map N M f hf) = map N O (g.comp f) hgf :=\n  MonoidHom.ext (map_map N M O f g hf hg hgf)\n\n"}
{"name":"QuotientAddGroup.map_comp_map","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝⁴ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nH : Type v\ninst✝³ : AddGroup H\nI : Type u_1\ninst✝² : AddGroup I\nM : AddSubgroup H\nO : AddSubgroup I\ninst✝¹ : M.Normal\ninst✝ : O.Normal\nf : AddMonoidHom G H\ng : AddMonoidHom H I\nhf : LE.le N (AddSubgroup.comap f M)\nhg : LE.le M (AddSubgroup.comap g O)\nhgf : optParam (LE.le N (AddSubgroup.comap (g.comp f) O)) ⋯\n⊢ Eq ((QuotientAddGroup.map M O g hg).comp (QuotientAddGroup.map N M f hf)) (QuotientAddGroup.map N O (g.comp f) hgf)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G →* H) (g : H →* I) (hf : N ≤ Subgroup.comap f M) (hg : M ≤ Subgroup.comap g O)\n    (hgf : N ≤ Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _))) :\n    (map M O g hg).comp (map N M f hf) = map N O (g.comp f) hgf :=\n  MonoidHom.ext (map_map N M O f g hf hg hgf)\n\n"}
{"name":"QuotientAddGroup.image_coe","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ Eq (Set.image QuotientAddGroup.mk ↑N) 0","decl":"@[to_additive (attr := simp)] lemma image_coe : ((↑) : G → Q) '' N = 1 :=\n  congr_arg ((↑) : Subgroup Q → Set Q) <| map_mk'_self N\n\n"}
{"name":"QuotientGroup.image_coe","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ Eq (Set.image QuotientGroup.mk ↑N) 1","decl":"@[to_additive (attr := simp)] lemma image_coe : ((↑) : G → Q) '' N = 1 :=\n  congr_arg ((↑) : Subgroup Q → Set Q) <| map_mk'_self N\n\n"}
{"name":"QuotientGroup.preimage_image_coe","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\ns : Set G\n⊢ Eq (Set.preimage QuotientGroup.mk (Set.image QuotientGroup.mk s)) (HMul.hMul (↑N) s)","decl":"@[to_additive]\nlemma preimage_image_coe (s : Set G) : ((↑) : G → Q) ⁻¹' ((↑) '' s) = N * s := by\n  ext a\n  constructor\n  · rintro ⟨b, hb, h⟩\n    refine ⟨a / b, (QuotientGroup.eq_one_iff _).1 ?_, b, hb, div_mul_cancel _ _⟩\n    simp only [h, QuotientGroup.mk_div, div_self']\n  · rintro ⟨a, ha, b, hb, rfl⟩\n    refine ⟨b, hb, ?_⟩\n    simpa only [QuotientGroup.mk_mul, self_eq_mul_left, QuotientGroup.eq_one_iff]\n\n"}
{"name":"QuotientAddGroup.preimage_image_coe","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\ns : Set G\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Set.image QuotientAddGroup.mk s)) (HAdd.hAdd (↑N) s)","decl":"@[to_additive]\nlemma preimage_image_coe (s : Set G) : ((↑) : G → Q) ⁻¹' ((↑) '' s) = N * s := by\n  ext a\n  constructor\n  · rintro ⟨b, hb, h⟩\n    refine ⟨a / b, (QuotientGroup.eq_one_iff _).1 ?_, b, hb, div_mul_cancel _ _⟩\n    simp only [h, QuotientGroup.mk_div, div_self']\n  · rintro ⟨a, ha, b, hb, rfl⟩\n    refine ⟨b, hb, ?_⟩\n    simpa only [QuotientGroup.mk_mul, self_eq_mul_left, QuotientGroup.eq_one_iff]\n\n"}
{"name":"QuotientAddGroup.image_coe_inj","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\ns t : Set G\n⊢ Iff (Eq (Set.image QuotientAddGroup.mk s) (Set.image QuotientAddGroup.mk t)) (Eq (HAdd.hAdd (↑N) s) (HAdd.hAdd (↑N) t))","decl":"@[to_additive]\nlemma image_coe_inj {s t : Set G} : ((↑) : G → Q) '' s = ((↑) : G → Q) '' t ↔ ↑N * s = N * t := by\n  simp_rw [← preimage_image_coe]\n  exact QuotientGroup.mk_surjective.preimage_injective.eq_iff.symm\n\n"}
{"name":"QuotientGroup.image_coe_inj","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\ns t : Set G\n⊢ Iff (Eq (Set.image QuotientGroup.mk s) (Set.image QuotientGroup.mk t)) (Eq (HMul.hMul (↑N) s) (HMul.hMul (↑N) t))","decl":"@[to_additive]\nlemma image_coe_inj {s t : Set G} : ((↑) : G → Q) '' s = ((↑) : G → Q) '' t ↔ ↑N * s = N * t := by\n  simp_rw [← preimage_image_coe]\n  exact QuotientGroup.mk_surjective.preimage_injective.eq_iff.symm\n\n"}
{"name":"QuotientGroup.congr_mk","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : Group G\nH : Type v\ninst✝² : Group H\nG' : Subgroup G\nH' : Subgroup H\ninst✝¹ : G'.Normal\ninst✝ : H'.Normal\ne : MulEquiv G H\nhe : Eq (Subgroup.map (↑e) G') H'\nx : G\n⊢ Eq ((QuotientGroup.congr G' H' e he) ↑x) ↑(e x)","decl":"@[simp]\ntheorem congr_mk (e : G ≃* H) (he : G'.map ↑e = H') (x) : congr G' H' e he (mk x) = e x :=\n  rfl\n\n"}
{"name":"QuotientGroup.congr_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : Group G\nH : Type v\ninst✝² : Group H\nG' : Subgroup G\nH' : Subgroup H\ninst✝¹ : G'.Normal\ninst✝ : H'.Normal\ne : MulEquiv G H\nhe : Eq (Subgroup.map (↑e) G') H'\nx : G\n⊢ Eq ((QuotientGroup.congr G' H' e he) ((QuotientGroup.mk' G') x)) ((QuotientGroup.mk' H') (e x))","decl":"theorem congr_mk' (e : G ≃* H) (he : G'.map ↑e = H') (x) :\n    congr G' H' e he (mk' G' x) = mk' H' (e x) :=\n  rfl\n\n"}
{"name":"QuotientGroup.congr_apply","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : Group G\nH : Type v\ninst✝² : Group H\nG' : Subgroup G\nH' : Subgroup H\ninst✝¹ : G'.Normal\ninst✝ : H'.Normal\ne : MulEquiv G H\nhe : Eq (Subgroup.map (↑e) G') H'\nx : G\n⊢ Eq ((QuotientGroup.congr G' H' e he) ↑x) ((QuotientGroup.mk' H') (e x))","decl":"@[simp]\ntheorem congr_apply (e : G ≃* H) (he : G'.map ↑e = H') (x : G) :\n    congr G' H' e he x = mk' H' (e x) :=\n  rfl\n\n"}
{"name":"QuotientGroup.congr_refl","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝¹ : Group G\nG' : Subgroup G\ninst✝ : G'.Normal\nhe : optParam (Eq (Subgroup.map (↑(MulEquiv.refl G)) G') G') ⋯\n⊢ Eq (QuotientGroup.congr G' G' (MulEquiv.refl G) he) (MulEquiv.refl (HasQuotient.Quotient G G'))","decl":"@[simp]\ntheorem congr_refl (he : G'.map (MulEquiv.refl G : G →* G) = G' := Subgroup.map_id G') :\n    congr G' G' (MulEquiv.refl G) he = MulEquiv.refl (G ⧸ G') := by\n  ext ⟨x⟩\n  rfl\n\n"}
{"name":"QuotientGroup.congr_symm","module":"Mathlib.GroupTheory.QuotientGroup.Defs","initialProofState":"G : Type u\ninst✝³ : Group G\nH : Type v\ninst✝² : Group H\nG' : Subgroup G\nH' : Subgroup H\ninst✝¹ : G'.Normal\ninst✝ : H'.Normal\ne : MulEquiv G H\nhe : Eq (Subgroup.map (↑e) G') H'\n⊢ Eq (QuotientGroup.congr G' H' e he).symm (QuotientGroup.congr H' G' e.symm ⋯)","decl":"@[simp]\ntheorem congr_symm (e : G ≃* H) (he : G'.map ↑e = H') :\n    (congr G' H' e he).symm = congr H' G' e.symm ((Subgroup.map_symm_eq_iff_map_eq _).mpr he) :=\n  rfl\n\n"}
