{"name":"LieAlgebra.restrict_killingForm","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\n⊢ Eq ((killingForm R L).restrict H.toSubmodule) (LieModule.traceForm R (Subtype fun x => Membership.mem H x) L)","decl":"lemma restrict_killingForm (H : LieSubalgebra R L) :\n    (killingForm R L).restrict H = LieModule.traceForm R H L :=\n  rfl\n\n"}
{"name":"LieAlgebra.IsKilling.ker_restrict_eq_bot_of_isCartanSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : LieAlgebra.IsKilling R L\ninst✝² : IsNoetherian R L\ninst✝¹ : IsArtinian R L\nH : LieSubalgebra R L\ninst✝ : H.IsCartanSubalgebra\n⊢ Eq (LinearMap.ker ((killingForm R L).restrict H.toSubmodule)) Bot.bot","decl":"/-- If the Killing form of a Lie algebra is non-singular, it remains non-singular when restricted\nto a Cartan subalgebra. -/\nlemma ker_restrict_eq_bot_of_isCartanSubalgebra\n    [IsNoetherian R L] [IsArtinian R L] (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    LinearMap.ker ((killingForm R L).restrict H) = ⊥ := by\n  have h : Codisjoint (rootSpace H 0) (LieModule.posFittingComp R H L) :=\n    (LieModule.isCompl_genWeightSpace_zero_posFittingComp R H L).codisjoint\n  replace h : Codisjoint (H : Submodule R L) (LieModule.posFittingComp R H L : Submodule R L) := by\n    rwa [codisjoint_iff, ← LieSubmodule.toSubmodule_inj, LieSubmodule.sup_toSubmodule,\n      LieSubmodule.top_toSubmodule, rootSpace_zero_eq R L H, LieSubalgebra.coe_toLieSubmodule,\n      ← codisjoint_iff] at h\n  suffices this : ∀ m₀ ∈ H, ∀ m₁ ∈ LieModule.posFittingComp R H L, killingForm R L m₀ m₁ = 0 by\n    simp [LinearMap.BilinForm.ker_restrict_eq_of_codisjoint h this]\n  intro m₀ h₀ m₁ h₁\n  exact killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting R L H (le_zeroRootSubalgebra R L H h₀) h₁\n\n"}
{"name":"LieAlgebra.IsKilling.ker_traceForm_eq_bot_of_isCartanSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : LieAlgebra.IsKilling R L\ninst✝² : IsNoetherian R L\ninst✝¹ : IsArtinian R L\nH : LieSubalgebra R L\ninst✝ : H.IsCartanSubalgebra\n⊢ Eq (LinearMap.ker (LieModule.traceForm R (Subtype fun x => Membership.mem H x) L)) Bot.bot","decl":"@[simp] lemma ker_traceForm_eq_bot_of_isCartanSubalgebra\n    [IsNoetherian R L] [IsArtinian R L] (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    LinearMap.ker (LieModule.traceForm R H L) = ⊥ :=\n  ker_restrict_eq_bot_of_isCartanSubalgebra R L H\n\n"}
{"name":"LieAlgebra.IsKilling.traceForm_cartan_nondegenerate","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : LieAlgebra.IsKilling R L\ninst✝² : IsNoetherian R L\ninst✝¹ : IsArtinian R L\nH : LieSubalgebra R L\ninst✝ : H.IsCartanSubalgebra\n⊢ (LieModule.traceForm R (Subtype fun x => Membership.mem H x) L).Nondegenerate","decl":"lemma traceForm_cartan_nondegenerate\n    [IsNoetherian R L] [IsArtinian R L] (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    (LieModule.traceForm R H L).Nondegenerate := by\n  simp [LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot]\n\n"}
{"name":"LieAlgebra.IsKilling.instIsLieAbelianOfIsCartanSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : LieAlgebra.IsKilling R L\ninst✝⁵ : Module.Free R L\ninst✝⁴ : Module.Finite R L\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : IsArtinian R L\nH : LieSubalgebra R L\ninst✝ : H.IsCartanSubalgebra\n⊢ IsLieAbelian (Subtype fun x => Membership.mem H x)","decl":"instance instIsLieAbelianOfIsCartanSubalgebra\n    [IsDomain R] [IsPrincipalIdealRing R] [IsArtinian R L]\n    (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    IsLieAbelian H :=\n  LieModule.isLieAbelian_of_ker_traceForm_eq_bot R H L <|\n    ker_restrict_eq_bot_of_isCartanSubalgebra R L H\n\n"}
{"name":"LieAlgebra.killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα β : (Subtype fun x => Membership.mem H x) → K\nx y : L\nhx : Membership.mem (LieAlgebra.rootSpace H α) x\nhy : Membership.mem (LieAlgebra.rootSpace H β) y\nhαβ : Ne (HAdd.hAdd α β) 0\n⊢ Eq (((killingForm K L) x) y) 0","decl":"/-- For any `α` and `β`, the corresponding root spaces are orthogonal with respect to the Killing\nform, provided `α + β ≠ 0`. -/\nlemma killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero {α β : H → K} {x y : L}\n    (hx : x ∈ rootSpace H α) (hy : y ∈ rootSpace H β) (hαβ : α + β ≠ 0) :\n    killingForm K L x y = 0 := by\n  /- If `ad R L z` is semisimple for all `z ∈ H` then writing `⟪x, y⟫ = killingForm K L x y`, there\n  is a slick proof of this lemma that requires only invariance of the Killing form as follows.\n  For any `z ∈ H`, we have:\n  `α z • ⟪x, y⟫ = ⟪α z • x, y⟫ = ⟪⁅z, x⁆, y⟫ = - ⟪x, ⁅z, y⁆⟫ = - ⟪x, β z • y⟫ = - β z • ⟪x, y⟫`.\n  Since this is true for any `z`, we thus have: `(α + β) • ⟪x, y⟫ = 0`, and hence the result.\n  However the semisimplicity of `ad R L z` is (a) non-trivial and (b) requires the assumption\n  that `K` is a perfect field and `L` has non-degenerate Killing form. -/\n  let σ : (H → K) → (H → K) := fun γ ↦ α + (β + γ)\n  have hσ : ∀ γ, σ γ ≠ γ := fun γ ↦ by simpa only [σ, ← add_assoc] using add_left_ne_self.mpr hαβ\n  let f : Module.End K L := (ad K L x) ∘ₗ (ad K L y)\n  have hf : ∀ γ, MapsTo f (rootSpace H γ) (rootSpace H (σ γ)) := fun γ ↦\n    (mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace K L H L α (β + γ) hx).comp <|\n      mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace K L H L β γ hy\n  classical\n  have hds := DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top\n    (LieSubmodule.iSupIndep_iff_toSubmodule.mp <| iSupIndep_genWeightSpace K H L)\n    (LieSubmodule.iSup_eq_top_iff_toSubmodule.mp <| iSup_genWeightSpace_eq_top K H L)\n  exact LinearMap.trace_eq_zero_of_mapsTo_ne hds σ hσ hf\n\n"}
{"name":"LieAlgebra.mem_ker_killingForm_of_mem_rootSpace_of_forall_rootSpace_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : (Subtype fun x => Membership.mem H x) → K\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H α) x\nhx' : ∀ (y : L), Membership.mem (LieAlgebra.rootSpace H (Neg.neg α)) y → Eq (((killingForm K L) x) y) 0\n⊢ Membership.mem (LinearMap.ker (killingForm K L)) x","decl":"/-- Elements of the `α` root space which are Killing-orthogonal to the `-α` root space are\nKilling-orthogonal to all of `L`. -/\nlemma mem_ker_killingForm_of_mem_rootSpace_of_forall_rootSpace_neg\n    {α : H → K} {x : L} (hx : x ∈ rootSpace H α)\n    (hx' : ∀ y ∈ rootSpace H (-α), killingForm K L x y = 0) :\n    x ∈ LinearMap.ker (killingForm K L) := by\n  rw [LinearMap.mem_ker]\n  ext y\n  have hy : y ∈ ⨆ β, rootSpace H β := by simp [iSup_genWeightSpace_eq_top K H L]\n  induction hy using LieSubmodule.iSup_induction' with\n  | hN β y hy =>\n    by_cases hαβ : α + β = 0\n    · exact hx' _ (add_eq_zero_iff_neg_eq.mp hαβ ▸ hy)\n    · exact killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero K L H hx hy hαβ\n  | h0 => simp\n  | hadd => simp_all\n"}
{"name":"LieAlgebra.IsKilling.eq_zero_of_isNilpotent_ad_of_mem_isCartanSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieAlgebra.IsKilling K L\nx : L\nhx : Membership.mem H x\nhx' : IsNilpotent ((LieAlgebra.ad K L) x)\n⊢ Eq x 0","decl":"/-- If a Lie algebra `L` has non-degenerate Killing form, the only element of a Cartan subalgebra\nwhose adjoint action on `L` is nilpotent, is the zero element.\n\nOver a perfect field a much stronger result is true, see\n`LieAlgebra.IsKilling.isSemisimple_ad_of_mem_isCartanSubalgebra`. -/\nlemma eq_zero_of_isNilpotent_ad_of_mem_isCartanSubalgebra {x : L} (hx : x ∈ H)\n    (hx' : _root_.IsNilpotent (ad K L x)) : x = 0 := by\n  suffices ⟨x, hx⟩ ∈ LinearMap.ker (traceForm K H L) by\n    simp at this\n    exact (AddSubmonoid.mk_eq_zero H.toAddSubmonoid).mp this\n  simp only [LinearMap.mem_ker]\n  ext y\n  have comm : Commute (toEnd K H L ⟨x, hx⟩) (toEnd K H L y) := by\n    rw [commute_iff_lie_eq, ← LieHom.map_lie, trivial_lie_zero, LieHom.map_zero]\n  rw [traceForm_apply_apply, ← LinearMap.mul_eq_comp, LinearMap.zero_apply]\n  exact (LinearMap.isNilpotent_trace_of_isNilpotent (comm.isNilpotent_mul_left hx')).eq_zero\n\n"}
{"name":"LieAlgebra.IsKilling.corootSpace_zero_eq_bot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieAlgebra.IsKilling K L\n⊢ Eq (LieAlgebra.corootSpace 0) Bot.bot","decl":"@[simp]\nlemma corootSpace_zero_eq_bot :\n    corootSpace (0 : H → K) = ⊥ := by\n  refine eq_bot_iff.mpr fun x hx ↦ ?_\n  suffices {x | ∃ y ∈ H, ∃ z ∈ H, ⁅y, z⁆ = x} = {0} by simpa [mem_corootSpace, this] using hx\n  refine eq_singleton_iff_unique_mem.mpr ⟨⟨0, H.zero_mem, 0, H.zero_mem, zero_lie 0⟩, ?_⟩\n  rintro - ⟨y, hy, z, hz, rfl⟩\n  suffices ⁅(⟨y, hy⟩ : H), (⟨z, hz⟩ : H)⁆ = 0 by\n    simpa only [Subtype.ext_iff, LieSubalgebra.coe_bracket, ZeroMemClass.coe_zero] using this\n  simp\n\n"}
{"name":"LieAlgebra.IsKilling.cartanEquivDual_apply_apply","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieAlgebra.IsKilling K L\na✝ m : Subtype fun x => Membership.mem H x\n⊢ Eq (((LieAlgebra.IsKilling.cartanEquivDual H) a✝) m) ((LinearMap.trace K L) (HMul.hMul ((LieModule.toEnd K (Subtype fun x => Membership.mem H x) L) a✝) ((LieModule.toEnd K (Subtype fun x => Membership.mem H x) L) m)))","decl":"variable {K L} in\n/-- The restriction of the Killing form to a Cartan subalgebra, as a linear equivalence to the\ndual. -/\n@[simps! apply_apply]\nnoncomputable def cartanEquivDual :\n    H ≃ₗ[K] Module.Dual K H :=\n  (traceForm K H L).toDual <| traceForm_cartan_nondegenerate K L H\n\n"}
{"name":"LieAlgebra.IsKilling.traceForm_coroot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁵ : LieRing L\ninst✝⁴ : Field K\ninst✝³ : LieAlgebra K L\ninst✝² : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieAlgebra.IsKilling K L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (((LieModule.traceForm K (Subtype fun x => Membership.mem H x) L) (LieAlgebra.IsKilling.coroot α)) x) (HSMul.hSMul 2 (HSMul.hSMul (Inv.inv (α ((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α)))) (α x)))","decl":"lemma traceForm_coroot (α : Weight K H L) (x : H) :\n    traceForm K H L (coroot α) x = 2 • (α <| (cartanEquivDual H).symm α)⁻¹ • α x := by\n  have : cartanEquivDual H ((cartanEquivDual H).symm α) x = α x := by\n    rw [LinearEquiv.apply_symm_apply, Weight.toLinear_apply]\n  rw [coroot, map_nsmul, map_smul, LinearMap.smul_apply, LinearMap.smul_apply]\n  congr 2\n\n"}
{"name":"LieAlgebra.IsKilling.lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieAlgebra.IsKilling K L\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ne f : L\nheα : Membership.mem (LieAlgebra.rootSpace H ⇑α) e\nhfα : Membership.mem (LieAlgebra.rootSpace H (Neg.neg ⇑α)) f\naux : ∀ (h : Subtype fun x => Membership.mem H x), Eq (Bracket.bracket h e) (HSMul.hSMul (α h) e)\n⊢ Eq (Bracket.bracket e f) (HSMul.hSMul (((killingForm K L) e) f) ↑((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α)))","decl":"lemma lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux\n    {α : Weight K H L} {e f : L} (heα : e ∈ rootSpace H α) (hfα : f ∈ rootSpace H (-α))\n    (aux : ∀ (h : H), ⁅h, e⁆ = α h • e) :\n    ⁅e, f⁆ = killingForm K L e f • (cartanEquivDual H).symm α := by\n  set α' := (cartanEquivDual H).symm α\n  rw [← sub_eq_zero, ← Submodule.mem_bot (R := K), ← ker_killingForm_eq_bot]\n  apply mem_ker_killingForm_of_mem_rootSpace_of_forall_rootSpace_neg (α := (0 : H → K))\n  · simp only [rootSpace_zero_eq, LieSubalgebra.mem_toLieSubmodule]\n    refine sub_mem ?_ (H.smul_mem _ α'.property)\n    simpa using mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace K L H L α (-α) heα hfα\n  · intro z hz\n    replace hz : z ∈ H := by simpa using hz\n    have he : ⁅z, e⁆ = α ⟨z, hz⟩ • e := aux ⟨z, hz⟩\n    have hαz : killingForm K L α' (⟨z, hz⟩ : H) = α ⟨z, hz⟩ :=\n      LinearMap.BilinForm.apply_toDual_symm_apply (hB := traceForm_cartan_nondegenerate K L H) _ _\n    simp [traceForm_comm K L L ⁅e, f⁆, ← traceForm_apply_lie_apply, he, mul_comm _ (α ⟨z, hz⟩), hαz]\n\n"}
{"name":"LieAlgebra.IsKilling.cartanEquivDual_symm_apply_mem_corootSpace","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieAlgebra.IsKilling K L\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Membership.mem (LieAlgebra.corootSpace ⇑α) ((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α))","decl":"/-- This is Proposition 4.18 from [carter2005] except that we use\n`LieModule.exists_forall_lie_eq_smul` instead of Lie's theorem (and so avoid\nassuming `K` has characteristic zero). -/\nlemma cartanEquivDual_symm_apply_mem_corootSpace (α : Weight K H L) :\n    (cartanEquivDual H).symm α ∈ corootSpace α := by\n  obtain ⟨e : L, he₀ : e ≠ 0, he : ∀ x, ⁅x, e⁆ = α x • e⟩ := exists_forall_lie_eq_smul K H L α\n  have heα : e ∈ rootSpace H α := (mem_genWeightSpace L α e).mpr fun x ↦ ⟨1, by simp [← he x]⟩\n  obtain ⟨f, hfα, hf⟩ : ∃ f ∈ rootSpace H (-α), killingForm K L e f ≠ 0 := by\n    contrapose! he₀\n    simpa using mem_ker_killingForm_of_mem_rootSpace_of_forall_rootSpace_neg K L H heα he₀\n  suffices ⁅e, f⁆ = killingForm K L e f • ((cartanEquivDual H).symm α : L) from\n    (mem_corootSpace α).mpr <| Submodule.subset_span ⟨(killingForm K L e f)⁻¹ • e,\n      Submodule.smul_mem _ _ heα, f, hfα, by simpa [inv_smul_eq_iff₀ hf]⟩\n  exact lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux heα hfα he\n\n"}
{"name":"LieAlgebra.IsKilling.span_weight_eq_top","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieAlgebra.IsKilling K L\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (Submodule.span K (Set.range (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L))) Top.top","decl":"/-- Given a splitting Cartan subalgebra `H` of a finite-dimensional Lie algebra with non-singular\nKilling form, the corresponding roots span the dual space of `H`. -/\n@[simp]\nlemma span_weight_eq_top :\n    span K (range (Weight.toLinear K H L)) = ⊤ := by\n  refine eq_top_iff.mpr (le_trans ?_ (LieModule.range_traceForm_le_span_weight K H L))\n  rw [← traceForm_flip K H L, ← LinearMap.dualAnnihilator_ker_eq_range_flip,\n    ker_traceForm_eq_bot_of_isCartanSubalgebra, Submodule.dualAnnihilator_bot]\n\n"}
{"name":"LieAlgebra.IsKilling.span_weight_isNonZero_eq_top","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieAlgebra.IsKilling K L\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (Submodule.span K (Set.image (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L) (setOf fun α => α.IsNonZero))) Top.top","decl":"variable (K L H) in\n@[simp]\nlemma span_weight_isNonZero_eq_top :\n    span K ({α : Weight K H L | α.IsNonZero}.image (Weight.toLinear K H L)) = ⊤ := by\n  rw [← span_weight_eq_top]\n  refine le_antisymm (Submodule.span_mono <| by simp) ?_\n  suffices range (Weight.toLinear K H L) ⊆\n    insert 0 ({α : Weight K H L | α.IsNonZero}.image (Weight.toLinear K H L)) by\n    simpa only [Submodule.span_insert_zero] using Submodule.span_mono this\n  rintro - ⟨α, rfl⟩\n  simp only [mem_insert_iff, Weight.coe_toLinear_eq_zero_iff, mem_image, mem_setOf_eq]\n  tauto\n\n"}
{"name":"LieAlgebra.IsKilling.iInf_ker_weight_eq_bot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieAlgebra.IsKilling K L\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (iInf fun α => LieModule.Weight.ker) Bot.bot","decl":"@[simp]\nlemma iInf_ker_weight_eq_bot :\n    ⨅ α : Weight K H L, α.ker = ⊥ := by\n  rw [← Subspace.dualAnnihilator_inj, Subspace.dualAnnihilator_iInf_eq,\n    Submodule.dualAnnihilator_bot]\n  simp [← LinearMap.range_dualMap_eq_dualAnnihilator_ker, ← Submodule.span_range_eq_iSup]\n\n"}
{"name":"LieAlgebra.IsKilling.isSemisimple_ad_of_mem_isCartanSubalgebra","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : PerfectField K\nx : L\nhx : Membership.mem H x\n⊢ ((LieAlgebra.ad K L) x).IsSemisimple","decl":"open Module.End in\nlemma isSemisimple_ad_of_mem_isCartanSubalgebra {x : L} (hx : x ∈ H) :\n    (ad K L x).IsSemisimple := by\n  /- Using Jordan-Chevalley, write `ad K L x` as a sum of its semisimple and nilpotent parts. -/\n  obtain ⟨N, -, S, hS₀, hN, hS, hSN⟩ := (ad K L x).exists_isNilpotent_isSemisimple\n  replace hS₀ : Commute (ad K L x) S := Algebra.commute_of_mem_adjoin_self hS₀\n  set x' : H := ⟨x, hx⟩\n  rw [eq_sub_of_add_eq hSN.symm] at hN\n  /- Note that the semisimple part `S` is just a scalar action on each root space. -/\n  have aux {α : H → K} {y : L} (hy : y ∈ rootSpace H α) : S y = α x' • y := by\n    replace hy : y ∈ (ad K L x).maxGenEigenspace (α x') :=\n      (genWeightSpace_le_genWeightSpaceOf L x' α) hy\n    rw [maxGenEigenspace_eq] at hy\n    set k := maxGenEigenspaceIndex (ad K L x) (α x')\n    rw [apply_eq_of_mem_of_comm_of_isFinitelySemisimple_of_isNil hy hS₀ hS.isFinitelySemisimple hN]\n  /- So `S` obeys the derivation axiom if we restrict to root spaces. -/\n  have h_der (y z : L) (α β : H → K) (hy : y ∈ rootSpace H α) (hz : z ∈ rootSpace H β) :\n      S ⁅y, z⁆ = ⁅S y, z⁆ + ⁅y, S z⁆ := by\n    have hyz : ⁅y, z⁆ ∈ rootSpace H (α + β) :=\n      mapsTo_toEnd_genWeightSpace_add_of_mem_rootSpace K L H L α β hy hz\n    rw [aux hy, aux hz, aux hyz, smul_lie, lie_smul, ← add_smul, ← Pi.add_apply]\n  /- Thus `S` is a derivation since root spaces span. -/\n  replace h_der (y z : L) : S ⁅y, z⁆ = ⁅S y, z⁆ + ⁅y, S z⁆ := by\n    have hy : y ∈ ⨆ α : H → K, rootSpace H α := by simp [iSup_genWeightSpace_eq_top]\n    have hz : z ∈ ⨆ α : H → K, rootSpace H α := by simp [iSup_genWeightSpace_eq_top]\n    induction hy using LieSubmodule.iSup_induction' with\n    | hN α y hy =>\n      induction hz using LieSubmodule.iSup_induction' with\n      | hN β z hz => exact h_der y z α β hy hz\n      | h0 => simp\n      | hadd _ _ _ _ h h' => simp only [lie_add, map_add, h, h']; abel\n    | h0 => simp\n    | hadd _ _ _ _ h h' => simp only [add_lie, map_add, h, h']; abel\n  /- An equivalent form of the derivation axiom used in `LieDerivation`. -/\n  replace h_der : ∀ y z : L, S ⁅y, z⁆ = ⁅y, S z⁆ - ⁅z, S y⁆ := by\n    simp_rw [← lie_skew (S _) _, add_comm, ← sub_eq_add_neg] at h_der; assumption\n  /- Bundle `S` as a `LieDerivation`. -/\n  let S' : LieDerivation K L L := ⟨S, h_der⟩\n  /- Since `L` has non-degenerate Killing form, `S` must be inner, corresponding to some `y : L`. -/\n  obtain ⟨y, hy⟩ := LieDerivation.IsKilling.exists_eq_ad S'\n  /- `y` commutes with all elements of `H` because `S` has eigenvalue 0 on `H`, `S = ad K L y`. -/\n  have hy' (z : L) (hz : z ∈ H) : ⁅y, z⁆ = 0 := by\n    rw [← LieSubalgebra.mem_toLieSubmodule, ← rootSpace_zero_eq] at hz\n    simp [S', ← ad_apply (R := K), ← LieDerivation.coe_ad_apply_eq_ad_apply, hy, aux hz]\n  /- Thus `y` belongs to `H` since `H` is self-normalizing. -/\n  replace hy' : y ∈ H := by\n    suffices y ∈ H.normalizer by rwa [LieSubalgebra.IsCartanSubalgebra.self_normalizing] at this\n    exact (H.mem_normalizer_iff y).mpr fun z hz ↦ hy' z hz ▸ LieSubalgebra.zero_mem H\n  /- It suffices to show `x = y` since `S = ad K L y` is semisimple. -/\n  suffices x = y by rwa [this, ← LieDerivation.coe_ad_apply_eq_ad_apply y, hy]\n  rw [← sub_eq_zero]\n  /- This will follow if we can show that `ad K L (x - y)` is nilpotent. -/\n  apply eq_zero_of_isNilpotent_ad_of_mem_isCartanSubalgebra K L H (H.sub_mem hx hy')\n  /- Which is true because `ad K L (x - y) = N`. -/\n  replace hy : S = ad K L y := by rw [← LieDerivation.coe_ad_apply_eq_ad_apply y, hy]\n  rwa [LieHom.map_sub, hSN, hy, add_sub_cancel_right, eq_sub_of_add_eq hSN.symm]\n\n"}
{"name":"LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : PerfectField K\nα : (Subtype fun x => Membership.mem H x) → K\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H α) x\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (Bracket.bracket h x) (HSMul.hSMul (α h) x)","decl":"lemma lie_eq_smul_of_mem_rootSpace {α : H → K} {x : L} (hx : x ∈ rootSpace H α) (h : H) :\n    ⁅h, x⁆ = α h • x := by\n  replace hx : x ∈ (ad K L h).maxGenEigenspace (α h) :=\n    genWeightSpace_le_genWeightSpaceOf L h α hx\n  rw [(isSemisimple_ad_of_mem_isCartanSubalgebra\n    h.property).isFinitelySemisimple.maxGenEigenspace_eq_eigenspace,\n    Module.End.mem_eigenspace_iff] at hx\n  simpa using hx\n\n"}
{"name":"LieAlgebra.IsKilling.lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : PerfectField K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\ne f : L\nheα : Membership.mem (LieAlgebra.rootSpace H ⇑α) e\nhfα : Membership.mem (LieAlgebra.rootSpace H (Neg.neg ⇑α)) f\n⊢ Eq (Bracket.bracket e f) (HSMul.hSMul (((killingForm K L) e) f) ↑((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α)))","decl":"lemma lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg\n    {α : Weight K H L} {e f : L} (heα : e ∈ rootSpace H α) (hfα : f ∈ rootSpace H (-α)) :\n    ⁅e, f⁆ = killingForm K L e f • (cartanEquivDual H).symm α := by\n  apply lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux heα hfα\n  exact lie_eq_smul_of_mem_rootSpace heα\n\n"}
{"name":"LieAlgebra.IsKilling.coe_corootSpace_eq_span_singleton'","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : PerfectField K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (↑(LieAlgebra.corootSpace ⇑α)) (Submodule.span K (Singleton.singleton ((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α))))","decl":"lemma coe_corootSpace_eq_span_singleton' (α : Weight K H L) :\n    (corootSpace α).toSubmodule = K ∙ (cartanEquivDual H).symm α := by\n  refine le_antisymm ?_ ?_\n  · intro ⟨x, hx⟩ hx'\n    have : {⁅y, z⁆ | (y ∈ rootSpace H α) (z ∈ rootSpace H (-α))} ⊆\n        K ∙ ((cartanEquivDual H).symm α : L) := by\n      rintro - ⟨e, heα, f, hfα, rfl⟩\n      rw [lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg heα hfα, SetLike.mem_coe,\n        Submodule.mem_span_singleton]\n      exact ⟨killingForm K L e f, rfl⟩\n    simp only [LieSubmodule.mem_toSubmodule, mem_corootSpace] at hx'\n    replace this := Submodule.span_mono this hx'\n    rw [Submodule.span_span] at this\n    rw [Submodule.mem_span_singleton] at this ⊢\n    obtain ⟨t, rfl⟩ := this\n    use t\n    simp only [Subtype.ext_iff]\n    rw [Submodule.coe_smul_of_tower]\n  · simp only [Submodule.span_singleton_le_iff_mem, LieSubmodule.mem_toSubmodule]\n    exact cartanEquivDual_symm_apply_mem_corootSpace α\n\n"}
{"name":"LieAlgebra.IsKilling.eq_zero_of_apply_eq_zero_of_mem_corootSpace","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nx : Subtype fun x => Membership.mem H x\nα : (Subtype fun x => Membership.mem H x) → K\nhαx : Eq (α x) 0\nhx : Membership.mem (LieAlgebra.corootSpace α) x\n⊢ Eq x 0","decl":"/-- The contrapositive of this result is very useful, taking `x` to be the element of `H`\ncorresponding to a root `α` under the identification between `H` and `H^*` provided by the Killing\nform. -/\nlemma eq_zero_of_apply_eq_zero_of_mem_corootSpace\n    (x : H) (α : H → K) (hαx : α x = 0) (hx : x ∈ corootSpace α) :\n    x = 0 := by\n  rcases eq_or_ne α 0 with rfl | hα; · simpa using hx\n  replace hx : x ∈ ⨅ β : Weight K H L, β.ker := by\n    refine (Submodule.mem_iInf _).mpr fun β ↦ ?_\n    obtain ⟨a, b, hb, hab⟩ :=\n      exists_forall_mem_corootSpace_smul_add_eq_zero L α β hα β.genWeightSpace_ne_bot\n    simpa [hαx, hb.ne'] using hab _ hx\n  simpa using hx\n\n"}
{"name":"LieAlgebra.IsKilling.disjoint_ker_weight_corootSpace","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Disjoint LieModule.Weight.ker (LieIdeal.toLieSubalgebra K (Subtype fun x => Membership.mem H x) (LieAlgebra.corootSpace ⇑α)).toSubmodule","decl":"lemma disjoint_ker_weight_corootSpace (α : Weight K H L) :\n    Disjoint α.ker (corootSpace α) := by\n  rw [disjoint_iff]\n  refine (Submodule.eq_bot_iff _).mpr fun x ⟨hαx, hx⟩ ↦ ?_\n  replace hαx : α x = 0 := by simpa using hαx\n  exact eq_zero_of_apply_eq_zero_of_mem_corootSpace x α hαx hx\n\n"}
{"name":"LieAlgebra.IsKilling.root_apply_cartanEquivDual_symm_ne_zero","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Ne (α ((LieAlgebra.IsKilling.cartanEquivDual H).symm (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α))) 0","decl":"lemma root_apply_cartanEquivDual_symm_ne_zero {α : Weight K H L} (hα : α.IsNonZero) :\n    α ((cartanEquivDual H).symm α) ≠ 0 := by\n  contrapose! hα\n  suffices (cartanEquivDual H).symm α ∈ α.ker ⊓ corootSpace α by\n    rw [(disjoint_ker_weight_corootSpace α).eq_bot] at this\n    simpa using this\n  exact Submodule.mem_inf.mp ⟨hα, cartanEquivDual_symm_apply_mem_corootSpace α⟩\n\n"}
{"name":"LieAlgebra.IsKilling.root_apply_coroot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Eq (α (LieAlgebra.IsKilling.coroot α)) 2","decl":"lemma root_apply_coroot {α : Weight K H L} (hα : α.IsNonZero) :\n    α (coroot α) = 2 := by\n  rw [← Weight.coe_coe]\n  simpa [coroot] using inv_mul_cancel₀ (root_apply_cartanEquivDual_symm_ne_zero hα)\n\n"}
{"name":"LieAlgebra.IsKilling.coroot_eq_zero_iff","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Iff (Eq (LieAlgebra.IsKilling.coroot α) 0) α.IsZero","decl":"@[simp] lemma coroot_eq_zero_iff {α : Weight K H L} :\n    coroot α = 0 ↔ α.IsZero := by\n  refine ⟨fun hα ↦ ?_, fun hα ↦ ?_⟩\n  · by_contra contra\n    simpa [hα, ← α.coe_coe, map_zero] using root_apply_coroot contra\n  · simp [coroot, Weight.coe_toLinear_eq_zero_iff.mpr hα]\n\n"}
{"name":"LieAlgebra.IsKilling.coroot_zero","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁸ : LieRing L\ninst✝⁷ : Field K\ninst✝⁶ : LieAlgebra K L\ninst✝⁵ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝⁴ : H.IsCartanSubalgebra\ninst✝³ : LieAlgebra.IsKilling K L\ninst✝² : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝¹ : CharZero K\ninst✝ : Nontrivial L\n⊢ Eq (LieAlgebra.IsKilling.coroot 0) 0","decl":"@[simp]\nlemma coroot_zero [Nontrivial L] : coroot (0 : Weight K H L) = 0 := by simp [Weight.isZero_zero]\n\n"}
{"name":"LieAlgebra.IsKilling.coe_corootSpace_eq_span_singleton","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (↑(LieAlgebra.corootSpace ⇑α)) (Submodule.span K (Singleton.singleton (LieAlgebra.IsKilling.coroot α)))","decl":"lemma coe_corootSpace_eq_span_singleton (α : Weight K H L) :\n    (corootSpace α).toSubmodule = K ∙ coroot α := by\n  if hα : α.IsZero then\n    simp [hα.eq, coroot_eq_zero_iff.mpr hα]\n  else\n    set α' := (cartanEquivDual H).symm α\n    suffices (K ∙ coroot α) = K ∙ α' by rw [coe_corootSpace_eq_span_singleton']; exact this.symm\n    have : IsUnit (2 * (α α')⁻¹) := by simpa using root_apply_cartanEquivDual_symm_ne_zero hα\n    change (K ∙ (2 • (α α')⁻¹ • α')) = _\n    simpa [← Nat.cast_smul_eq_nsmul K, smul_smul] using Submodule.span_singleton_smul_eq this _\n\n"}
{"name":"LieAlgebra.IsKilling.corootSpace_eq_bot_iff","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Iff (Eq (LieAlgebra.corootSpace ⇑α) Bot.bot) α.IsZero","decl":"@[simp]\nlemma corootSpace_eq_bot_iff {α : Weight K H L} :\n    corootSpace α = ⊥ ↔ α.IsZero := by\n  simp [← LieSubmodule.toSubmodule_eq_bot, coe_corootSpace_eq_span_singleton α]\n\n"}
{"name":"LieAlgebra.IsKilling.isCompl_ker_weight_span_coroot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ IsCompl LieModule.Weight.ker (Submodule.span K (Singleton.singleton (LieAlgebra.IsKilling.coroot α)))","decl":"lemma isCompl_ker_weight_span_coroot (α : Weight K H L) :\n    IsCompl α.ker (K ∙ coroot α) := by\n  if hα : α.IsZero then\n    simpa [Weight.coe_toLinear_eq_zero_iff.mpr hα, coroot_eq_zero_iff.mpr hα, Weight.ker]\n      using isCompl_top_bot\n  else\n    rw [← coe_corootSpace_eq_span_singleton]\n    apply Module.Dual.isCompl_ker_of_disjoint_of_ne_bot (by aesop)\n      (disjoint_ker_weight_corootSpace α)\n    replace hα : corootSpace α ≠ ⊥ := by simpa using hα\n    rwa [ne_eq, ← LieSubmodule.toSubmodule_inj] at hα\n\n"}
{"name":"LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nx y : Subtype fun x => Membership.mem H x\nhx : Membership.mem LieModule.Weight.ker x\nhy : Membership.mem (Submodule.span K (Singleton.singleton (LieAlgebra.IsKilling.coroot α))) y\n⊢ Eq (((LieModule.traceForm K (Subtype fun x => Membership.mem H x) L) x) y) 0","decl":"lemma traceForm_eq_zero_of_mem_ker_of_mem_span_coroot {α : Weight K H L} {x y : H}\n    (hx : x ∈ α.ker) (hy : y ∈ K ∙ coroot α) :\n    traceForm K H L x y = 0 := by\n  rw [← coe_corootSpace_eq_span_singleton, LieSubmodule.mem_toSubmodule, mem_corootSpace'] at hy\n  induction hy using Submodule.span_induction with\n  | mem z hz =>\n    obtain ⟨u, hu, v, -, huv⟩ := hz\n    change killingForm K L (x : L) (z : L) = 0\n    replace hx : α x = 0 := by simpa using hx\n    rw [← huv, ← traceForm_apply_lie_apply, ← LieSubalgebra.coe_bracket_of_module,\n      lie_eq_smul_of_mem_rootSpace hu, hx, zero_smul, map_zero, LinearMap.zero_apply]\n  | zero => simp\n  | add _ _ _ _ hx hy => simp [hx, hy]\n  | smul _ _ _ hz => simp [hz]\n\n"}
{"name":"LieAlgebra.IsKilling.orthogonal_span_coroot_eq_ker","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq ((LieModule.traceForm K (Subtype fun x => Membership.mem H x) L).orthogonal (Submodule.span K (Singleton.singleton (LieAlgebra.IsKilling.coroot α)))) LieModule.Weight.ker","decl":"@[simp] lemma orthogonal_span_coroot_eq_ker (α : Weight K H L) :\n    (traceForm K H L).orthogonal (K ∙ coroot α) = α.ker := by\n  if hα : α.IsZero then\n    have hα' : coroot α = 0 := by simpa\n    replace hα : α.ker = ⊤ := by ext; simp [hα]\n    simp [hα, hα']\n  else\n    refine le_antisymm (fun x hx ↦ ?_) (fun x hx y hy ↦ ?_)\n    · simp only [LinearMap.BilinForm.mem_orthogonal_iff] at hx\n      specialize hx (coroot α) (Submodule.mem_span_singleton_self _)\n      simp only [LinearMap.BilinForm.isOrtho_def, traceForm_coroot, smul_eq_mul, nsmul_eq_mul,\n        Nat.cast_ofNat, mul_eq_zero, OfNat.ofNat_ne_zero, inv_eq_zero, false_or] at hx\n      simpa using hx.resolve_left (root_apply_cartanEquivDual_symm_ne_zero hα)\n    · have := traceForm_eq_zero_of_mem_ker_of_mem_span_coroot hx hy\n      rwa [traceForm_comm] at this\n\n"}
{"name":"LieAlgebra.IsKilling.coroot_eq_iff","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα β : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Iff (Eq (LieAlgebra.IsKilling.coroot α) (LieAlgebra.IsKilling.coroot β)) (Eq α β)","decl":"@[simp] lemma coroot_eq_iff (α β : Weight K H L) :\n    coroot α = coroot β ↔ α = β := by\n  refine ⟨fun hyp ↦ ?_, fun h ↦ by rw [h]⟩\n  if hα : α.IsZero then\n    have hβ : β.IsZero := by\n      rw [← coroot_eq_zero_iff] at hα ⊢\n      rwa [← hyp]\n    ext\n    simp [hα.eq, hβ.eq]\n  else\n    have hβ : β.IsNonZero := by\n      contrapose! hα\n      simp only [not_not, ← coroot_eq_zero_iff] at hα ⊢\n      rwa [hyp]\n    have : α.ker = β.ker := by\n      rw [← orthogonal_span_coroot_eq_ker α, hyp, orthogonal_span_coroot_eq_ker]\n    suffices (α : H →ₗ[K] K) = β by ext x; simpa using LinearMap.congr_fun this x\n    apply Module.Dual.eq_of_ker_eq_of_apply_eq (coroot α) this\n    · rw [Weight.toLinear_apply, root_apply_coroot hα, hyp, Weight.toLinear_apply,\n        root_apply_coroot hβ]\n    · simp [root_apply_coroot hα]\n\n"}
{"name":"LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Exists fun h => Exists fun e => Exists fun f => And (IsSl2Triple h e f) (And (Membership.mem (LieAlgebra.rootSpace H ⇑α) e) (Membership.mem (LieAlgebra.rootSpace H (Neg.neg ⇑α)) f))","decl":"lemma exists_isSl2Triple_of_weight_isNonZero {α : Weight K H L} (hα : α.IsNonZero) :\n    ∃ h e f : L, IsSl2Triple h e f ∧ e ∈ rootSpace H α ∧ f ∈ rootSpace H (- α) := by\n  obtain ⟨e, heα : e ∈ rootSpace H α, he₀ : e ≠ 0⟩ := α.exists_ne_zero\n  obtain ⟨f', hfα, hf⟩ : ∃ f ∈ rootSpace H (-α), killingForm K L e f ≠ 0 := by\n    contrapose! he₀\n    simpa using mem_ker_killingForm_of_mem_rootSpace_of_forall_rootSpace_neg K L H heα he₀\n  have hef := lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg heα hfα\n  let h : H := ⟨⁅e, f'⁆, hef ▸ Submodule.smul_mem _ _ (Submodule.coe_mem _)⟩\n  have hh : α h ≠ 0 := by\n    have : h = killingForm K L e f' • (cartanEquivDual H).symm α := by\n      simp only [h, Subtype.ext_iff, hef]\n      rw [Submodule.coe_smul_of_tower]\n    rw [this, map_smul, smul_eq_mul, ne_eq, mul_eq_zero, not_or]\n    exact ⟨hf, root_apply_cartanEquivDual_symm_ne_zero hα⟩\n  let f := (2 * (α h)⁻¹) • f'\n  replace hef : ⁅⁅e, f⁆, e⁆ = 2 • e := by\n    have : ⁅⁅e, f'⁆, e⁆ = α h • e := lie_eq_smul_of_mem_rootSpace heα h\n    rw [lie_smul, smul_lie, this, ← smul_assoc, smul_eq_mul, mul_assoc, inv_mul_cancel₀ hh,\n      mul_one, two_smul, two_smul]\n  refine ⟨⁅e, f⁆, e, f, ⟨fun contra ↦ ?_, rfl, hef, ?_⟩, heα, Submodule.smul_mem _ _ hfα⟩\n  · rw [contra] at hef\n    have _i : NoZeroSMulDivisors ℤ L := NoZeroSMulDivisors.int_of_charZero K L\n    simp only [zero_lie, eq_comm (a := (0 : L)), smul_eq_zero, OfNat.ofNat_ne_zero, false_or] at hef\n    contradiction\n  · have : ⁅⁅e, f'⁆, f'⁆ = - α h • f' := lie_eq_smul_of_mem_rootSpace hfα h\n    rw [lie_smul, lie_smul, smul_lie, this]\n    simp [← smul_assoc, f, hh, mul_comm _ (2 * (α h)⁻¹)]\n\n"}
{"name":"IsSl2Triple.h_eq_coroot","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\nh e f : L\nht : IsSl2Triple h e f\nheα : Membership.mem (LieAlgebra.rootSpace H ⇑α) e\nhfα : Membership.mem (LieAlgebra.rootSpace H (Neg.neg ⇑α)) f\n⊢ Eq h ↑(LieAlgebra.IsKilling.coroot α)","decl":"lemma _root_.IsSl2Triple.h_eq_coroot {α : Weight K H L} (hα : α.IsNonZero)\n    {h e f : L} (ht : IsSl2Triple h e f) (heα : e ∈ rootSpace H α) (hfα : f ∈ rootSpace H (- α)) :\n    h = coroot α := by\n  have hef := lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg heα hfα\n  lift h to H using by simpa only [← ht.lie_e_f, hef] using H.smul_mem _ (Submodule.coe_mem _)\n  congr 1\n  have key : α h = 2 := by\n    have := lie_eq_smul_of_mem_rootSpace heα h\n    rw [LieSubalgebra.coe_bracket_of_module, ht.lie_h_e_smul K] at this\n    exact smul_left_injective K ht.e_ne_zero this.symm\n  suffices ∃ s : K, s • h = coroot α by\n    obtain ⟨s, hs⟩ := this\n    replace this : s = 1 := by simpa [root_apply_coroot hα, key] using congr_arg α hs\n    rwa [this, one_smul] at hs\n  set α' := (cartanEquivDual H).symm α with hα'\n  have h_eq : h = killingForm K L e f • α' := by\n    simp only [hα', Subtype.ext_iff, ← ht.lie_e_f, hef]\n    rw [Submodule.coe_smul_of_tower]\n  use (2 • (α α')⁻¹) * (killingForm K L e f)⁻¹\n  have hef₀ : killingForm K L e f ≠ 0 := by\n    have := ht.h_ne_zero\n    contrapose! this\n    simpa [this] using h_eq\n  rw [h_eq, smul_smul, mul_assoc, inv_mul_cancel₀ hef₀, mul_one, smul_assoc, coroot]\n\n"}
{"name":"LieAlgebra.IsKilling.finrank_rootSpace_eq_one","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nhα : α.IsNonZero\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (LieAlgebra.rootSpace H ⇑α) x)) 1","decl":"lemma finrank_rootSpace_eq_one (α : Weight K H L) (hα : α.IsNonZero) :\n    finrank K (rootSpace H α) = 1 := by\n  suffices ¬ 1 < finrank K (rootSpace H α) by\n    have h₀ : finrank K (rootSpace H α) ≠ 0 := by\n      convert_to finrank K (rootSpace H α).toSubmodule ≠ 0\n      simpa using α.genWeightSpace_ne_bot\n    omega\n  intro contra\n  obtain ⟨h, e, f, ht, heα, hfα⟩ := exists_isSl2Triple_of_weight_isNonZero hα\n  let F : rootSpace H α →ₗ[K] K := killingForm K L f ∘ₗ (rootSpace H α).subtype\n  have hF : LinearMap.ker F ≠ ⊥ := F.ker_ne_bot_of_finrank_lt <| by rwa [finrank_self]\n  obtain ⟨⟨y, hyα⟩, hy, hy₀⟩ := (Submodule.ne_bot_iff _).mp hF\n  replace hy : ⁅y, f⁆ = 0 := by\n    have : killingForm K L y f = 0 := by simpa [F, traceForm_comm] using hy\n    simpa [this] using lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg hyα hfα\n  have P : ht.symm.HasPrimitiveVectorWith y (-2 : K) :=\n    { ne_zero := by simpa [LieSubmodule.mk_eq_zero] using hy₀\n      lie_h := by simp only [neg_smul, neg_lie, neg_inj, ht.h_eq_coroot hα heα hfα,\n        ← H.coe_bracket_of_module, lie_eq_smul_of_mem_rootSpace hyα (coroot α),\n        root_apply_coroot hα]\n      lie_e := by rw [← lie_skew, hy, neg_zero] }\n  obtain ⟨n, hn⟩ := P.exists_nat\n  replace hn : -2 = (n : ℤ) := by norm_cast at hn\n  omega\n\n"}
{"name":"LieAlgebra.IsKilling.restrict_killingForm_eq_sum","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\nH : LieSubalgebra K L\ninst✝³ : H.IsCartanSubalgebra\ninst✝² : LieAlgebra.IsKilling K L\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\n⊢ Eq ((killingForm K L).restrict H.toSubmodule) (LieSubalgebra.root.sum fun α => (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α).smulRight (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α))","decl":"lemma restrict_killingForm_eq_sum :\n    (killingForm K L).restrict H = ∑ α ∈ H.root, (α : H →ₗ[K] K).smulRight (α : H →ₗ[K] K) := by\n  rw [restrict_killingForm, traceForm_eq_sum_finrank_nsmul' K H L]\n  refine Finset.sum_congr rfl fun χ hχ ↦ ?_\n  replace hχ : χ.IsNonZero := by simpa [LieSubalgebra.root] using hχ\n  simp [finrank_rootSpace_eq_one _ hχ]\n\n"}
{"name":"LieModule.Weight.coe_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (⇑(Neg.neg α)) (Neg.neg ⇑α)","decl":"@[simp] lemma coe_neg : ((-α : Weight K H L) : H → K) = -α := rfl\n\n"}
{"name":"LieModule.Weight.IsZero.neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nh : α.IsZero\n⊢ (Neg.neg α).IsZero","decl":"lemma IsZero.neg (h : α.IsZero) : (-α).IsZero := by ext; rw [coe_neg, h, neg_zero]\n\n"}
{"name":"LieModule.Weight.isZero_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Iff (Neg.neg α).IsZero α.IsZero","decl":"@[simp] lemma isZero_neg : (-α).IsZero ↔ α.IsZero := ⟨fun h ↦ neg_neg α ▸ h.neg, fun h ↦ h.neg⟩\n\n"}
{"name":"LieModule.Weight.IsNonZero.neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\nh : α.IsNonZero\n⊢ (Neg.neg α).IsNonZero","decl":"lemma IsNonZero.neg (h : α.IsNonZero) : (-α).IsNonZero := fun e ↦ h (by simpa using e.neg)\n\n"}
{"name":"LieModule.Weight.isNonZero_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Iff (Neg.neg α).IsNonZero α.IsNonZero","decl":"@[simp] lemma isNonZero_neg {α : Weight K H L} : (-α).IsNonZero ↔ α.IsNonZero := isZero_neg.not\n\n"}
{"name":"LieModule.Weight.toLinear_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁶ : LieRing L\ninst✝⁵ : Field K\ninst✝⁴ : LieAlgebra K L\ninst✝³ : FiniteDimensional K L\ninst✝² : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L (Neg.neg α)) (Neg.neg (LieModule.Weight.toLinear K (Subtype fun x => Membership.mem H x) L α))","decl":"@[simp] lemma toLinear_neg {α : Weight K H L} : (-α).toLinear = -α.toLinear := rfl\n\n"}
{"name":"LieAlgebra.IsKilling.coroot_neg","module":"Mathlib.Algebra.Lie.Weights.Killing","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝⁷ : LieRing L\ninst✝⁶ : Field K\ninst✝⁵ : LieAlgebra K L\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : LieAlgebra.IsKilling K L\nH : LieSubalgebra K L\ninst✝² : H.IsCartanSubalgebra\ninst✝¹ : LieModule.IsTriangularizable K (Subtype fun x => Membership.mem H x) L\ninst✝ : CharZero K\nα : LieModule.Weight K (Subtype fun x => Membership.mem H x) L\n⊢ Eq (LieAlgebra.IsKilling.coroot (Neg.neg α)) (Neg.neg (LieAlgebra.IsKilling.coroot α))","decl":"@[simp]\nlemma _root_.LieAlgebra.IsKilling.coroot_neg (α : Weight K H L) : coroot (-α) = -coroot α := by\n  simp [coroot]\n\n"}
