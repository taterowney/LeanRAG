{"name":"CategoryTheory.prodComonad_ε_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nx✝ : C\n⊢ Eq ((CategoryTheory.prodComonad X).ε.app x✝) CategoryTheory.Limits.prod.snd","decl":"/-- `X ⨯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  ε := { app := fun _ => Limits.prod.snd }\n  δ := { app := fun _ => prod.lift Limits.prod.fst (𝟙 _) }\n\n"}
{"name":"CategoryTheory.prodComonad_δ_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nx✝ : C\n⊢ Eq ((CategoryTheory.prodComonad X).δ.app x✝) (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X x✝)))","decl":"/-- `X ⨯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  ε := { app := fun _ => Limits.prod.snd }\n  δ := { app := fun _ => prod.lift Limits.prod.fst (𝟙 _) }\n\n"}
{"name":"CategoryTheory.prodComonad_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nY : C\n⊢ Eq ((CategoryTheory.prodComonad X).obj Y) (CategoryTheory.Limits.prod X Y)","decl":"/-- `X ⨯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  ε := { app := fun _ => Limits.prod.snd }\n  δ := { app := fun _ => prod.lift Limits.prod.fst (𝟙 _) }\n\n"}
{"name":"CategoryTheory.prodComonad_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nx✝¹ x✝ : C\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.prodComonad X).map g) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- `X ⨯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  ε := { app := fun _ => Limits.prod.snd }\n  δ := { app := fun _ => prod.lift Limits.prod.fst (𝟙 _) }\n\n"}
{"name":"CategoryTheory.coalgebraToOver_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX✝ Y✝ : (CategoryTheory.prodComonad X).Coalgebra\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.coalgebraToOver X).map f) (CategoryTheory.Over.homMk f.f ⋯)","decl":"/-- The forward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef coalgebraToOver : Coalgebra (prodComonad X) ⥤ Over X where\n  obj A := Over.mk (A.a ≫ Limits.prod.fst)\n  map f :=\n    Over.homMk f.f\n      (by\n        rw [Over.mk_hom, ← f.h_assoc]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.coalgebraToOver_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nA : (CategoryTheory.prodComonad X).Coalgebra\n⊢ Eq ((CategoryTheory.coalgebraToOver X).obj A) (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.comp A.a CategoryTheory.Limits.prod.fst))","decl":"/-- The forward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef coalgebraToOver : Coalgebra (prodComonad X) ⥤ Over X where\n  obj A := Over.mk (A.a ≫ Limits.prod.fst)\n  map f :=\n    Over.homMk f.f\n      (by\n        rw [Over.mk_hom, ← f.h_assoc]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.overToCoalgebra_map_f","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX✝ Y✝ : CategoryTheory.Over X\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.overToCoalgebra X).map g).f g.left","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X ⥤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (𝟙 _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.overToCoalgebra_obj_a","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : CategoryTheory.Over X\n⊢ Eq ((CategoryTheory.overToCoalgebra X).obj f).a (CategoryTheory.Limits.prod.lift f.hom (CategoryTheory.CategoryStruct.id f.left))","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X ⥤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (𝟙 _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.overToCoalgebra_obj_A","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : CategoryTheory.Over X\n⊢ Eq ((CategoryTheory.overToCoalgebra X).obj f).A f.left","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X ⥤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (𝟙 _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_inverse","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq (CategoryTheory.coalgebraEquivOver X).inverse (CategoryTheory.overToCoalgebra X)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) ≌ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_unitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq (CategoryTheory.coalgebraEquivOver X).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Comonad.Coalgebra.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.prodComonad X).Coalgebra).obj A).A) ⋯) ⋯)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) ≌ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_counitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq (CategoryTheory.coalgebraEquivOver X).counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Over.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.overToCoalgebra X).comp (CategoryTheory.coalgebraToOver X)).obj f).left) ⋯) ⋯)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) ≌ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_functor","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq (CategoryTheory.coalgebraEquivOver X).functor (CategoryTheory.coalgebraToOver X)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) ≌ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coprodMonad_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nx✝¹ x✝ : C\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.coprodMonad X).map g) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- `X ⨿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  η := { app := fun _ => coprod.inr }\n  μ := { app := fun _ => coprod.desc coprod.inl (𝟙 _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_μ_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nx✝ : C\n⊢ Eq ((CategoryTheory.coprodMonad X).μ.app x✝) (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X x✝)))","decl":"/-- `X ⨿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  η := { app := fun _ => coprod.inr }\n  μ := { app := fun _ => coprod.desc coprod.inl (𝟙 _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nY : C\n⊢ Eq ((CategoryTheory.coprodMonad X).obj Y) (CategoryTheory.Limits.coprod X Y)","decl":"/-- `X ⨿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  η := { app := fun _ => coprod.inr }\n  μ := { app := fun _ => coprod.desc coprod.inl (𝟙 _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_η_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nx✝ : C\n⊢ Eq ((CategoryTheory.coprodMonad X).η.app x✝) CategoryTheory.Limits.coprod.inr","decl":"/-- `X ⨿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  η := { app := fun _ => coprod.inr }\n  μ := { app := fun _ => coprod.desc coprod.inl (𝟙 _) }\n\n"}
{"name":"CategoryTheory.algebraToUnder_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX✝ Y✝ : (CategoryTheory.coprodMonad X).Algebra\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.algebraToUnder X).map f) (CategoryTheory.Under.homMk f.f ⋯)","decl":"/-- The forward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef algebraToUnder : Monad.Algebra (coprodMonad X) ⥤ Under X where\n  obj A := Under.mk (coprod.inl ≫ A.a)\n  map f :=\n    Under.homMk f.f\n      (by\n        rw [Under.mk_hom, Category.assoc, ← f.h]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.algebraToUnder_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : (CategoryTheory.coprodMonad X).Algebra\n⊢ Eq ((CategoryTheory.algebraToUnder X).obj A) (CategoryTheory.Under.mk (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl A.a))","decl":"/-- The forward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef algebraToUnder : Monad.Algebra (coprodMonad X) ⥤ Under X where\n  obj A := Under.mk (coprod.inl ≫ A.a)\n  map f :=\n    Under.homMk f.f\n      (by\n        rw [Under.mk_hom, Category.assoc, ← f.h]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.underToAlgebra_obj_a","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nf : CategoryTheory.Under X\n⊢ Eq ((CategoryTheory.underToAlgebra X).obj f).a (CategoryTheory.Limits.coprod.desc f.hom (CategoryTheory.CategoryStruct.id f.right))","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X ⥤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (𝟙 _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.underToAlgebra_obj_A","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nf : CategoryTheory.Under X\n⊢ Eq ((CategoryTheory.underToAlgebra X).obj f).A f.right","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X ⥤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (𝟙 _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.underToAlgebra_map_f","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX✝ Y✝ : CategoryTheory.Under X\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.underToAlgebra X).map g).f g.right","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X ⥤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (𝟙 _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_inverse","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ Eq (CategoryTheory.algebraEquivUnder X).inverse (CategoryTheory.underToAlgebra X)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) ≌ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_unitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ Eq (CategoryTheory.algebraEquivUnder X).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Monad.Algebra.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.coprodMonad X).Algebra).obj A).A) ⋯) ⋯)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) ≌ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_counitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ Eq (CategoryTheory.algebraEquivUnder X).counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Under.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.underToAlgebra X).comp (CategoryTheory.algebraToUnder X)).obj f).right) ⋯) ⋯)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) ≌ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_functor","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ Eq (CategoryTheory.algebraEquivUnder X).functor (CategoryTheory.algebraToUnder X)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) ≌ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
