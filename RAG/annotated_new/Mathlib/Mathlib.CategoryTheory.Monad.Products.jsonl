{"name":"CategoryTheory.prodComonad_Îµ_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nxâœ : C\nâŠ¢ Eq ((CategoryTheory.prodComonad X).Îµ.app xâœ) CategoryTheory.Limits.prod.snd","decl":"/-- `X â¨¯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  Îµ := { app := fun _ => Limits.prod.snd }\n  Î´ := { app := fun _ => prod.lift Limits.prod.fst (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.prodComonad_Î´_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nxâœ : C\nâŠ¢ Eq ((CategoryTheory.prodComonad X).Î´.app xâœ) (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X xâœ)))","decl":"/-- `X â¨¯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  Îµ := { app := fun _ => Limits.prod.snd }\n  Î´ := { app := fun _ => prod.lift Limits.prod.fst (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.prodComonad_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nY : C\nâŠ¢ Eq ((CategoryTheory.prodComonad X).obj Y) (CategoryTheory.Limits.prod X Y)","decl":"/-- `X â¨¯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  Îµ := { app := fun _ => Limits.prod.snd }\n  Î´ := { app := fun _ => prod.lift Limits.prod.fst (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.prodComonad_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nxâœÂ¹ xâœ : C\ng : Quiver.Hom xâœÂ¹ xâœ\nâŠ¢ Eq ((CategoryTheory.prodComonad X).map g) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- `X â¨¯ -` has a comonad structure. This is sometimes called the writer comonad. -/\n@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  Îµ := { app := fun _ => Limits.prod.snd }\n  Î´ := { app := fun _ => prod.lift Limits.prod.fst (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.coalgebraToOver_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nXâœ Yâœ : (CategoryTheory.prodComonad X).Coalgebra\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.coalgebraToOver X).map f) (CategoryTheory.Over.homMk f.f â‹¯)","decl":"/-- The forward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef coalgebraToOver : Coalgebra (prodComonad X) â¥¤ Over X where\n  obj A := Over.mk (A.a â‰« Limits.prod.fst)\n  map f :=\n    Over.homMk f.f\n      (by\n        rw [Over.mk_hom, â† f.h_assoc]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.coalgebraToOver_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nA : (CategoryTheory.prodComonad X).Coalgebra\nâŠ¢ Eq ((CategoryTheory.coalgebraToOver X).obj A) (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.comp A.a CategoryTheory.Limits.prod.fst))","decl":"/-- The forward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef coalgebraToOver : Coalgebra (prodComonad X) â¥¤ Over X where\n  obj A := Over.mk (A.a â‰« Limits.prod.fst)\n  map f :=\n    Over.homMk f.f\n      (by\n        rw [Over.mk_hom, â† f.h_assoc]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.overToCoalgebra_map_f","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nXâœ Yâœ : CategoryTheory.Over X\ng : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.overToCoalgebra X).map g).f g.left","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X â¥¤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (ðŸ™ _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.overToCoalgebra_obj_a","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nf : CategoryTheory.Over X\nâŠ¢ Eq ((CategoryTheory.overToCoalgebra X).obj f).a (CategoryTheory.Limits.prod.lift f.hom (CategoryTheory.CategoryStruct.id f.left))","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X â¥¤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (ðŸ™ _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.overToCoalgebra_obj_A","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nf : CategoryTheory.Over X\nâŠ¢ Eq ((CategoryTheory.overToCoalgebra X).obj f).A f.left","decl":"/-- The backward direction of the equivalence from coalgebras for the product comonad to the over\ncategory.\n-/\n@[simps]\ndef overToCoalgebra : Over X â¥¤ Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (ðŸ™ _) }\n  map g := { f := g.left }\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_inverse","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq (CategoryTheory.coalgebraEquivOver X).inverse (CategoryTheory.overToCoalgebra X)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) â‰Œ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_unitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq (CategoryTheory.coalgebraEquivOver X).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Comonad.Coalgebra.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.prodComonad X).Coalgebra).obj A).A) â‹¯) â‹¯)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) â‰Œ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_counitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq (CategoryTheory.coalgebraEquivOver X).counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Over.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.overToCoalgebra X).comp (CategoryTheory.coalgebraToOver X)).obj f).left) â‹¯) â‹¯)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) â‰Œ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coalgebraEquivOver_functor","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq (CategoryTheory.coalgebraEquivOver X).functor (CategoryTheory.coalgebraToOver X)","decl":"/-- The equivalence from coalgebras for the product comonad to the over category. -/\n@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) â‰Œ Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (Limits.prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.coprodMonad_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nxâœÂ¹ xâœ : C\ng : Quiver.Hom xâœÂ¹ xâœ\nâŠ¢ Eq ((CategoryTheory.coprodMonad X).map g) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- `X â¨¿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  Î· := { app := fun _ => coprod.inr }\n  Î¼ := { app := fun _ => coprod.desc coprod.inl (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_Î¼_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nxâœ : C\nâŠ¢ Eq ((CategoryTheory.coprodMonad X).Î¼.app xâœ) (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X xâœ)))","decl":"/-- `X â¨¿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  Î· := { app := fun _ => coprod.inr }\n  Î¼ := { app := fun _ => coprod.desc coprod.inl (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nY : C\nâŠ¢ Eq ((CategoryTheory.coprodMonad X).obj Y) (CategoryTheory.Limits.coprod X Y)","decl":"/-- `X â¨¿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  Î· := { app := fun _ => coprod.inr }\n  Î¼ := { app := fun _ => coprod.desc coprod.inl (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.coprodMonad_Î·_app","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nxâœ : C\nâŠ¢ Eq ((CategoryTheory.coprodMonad X).Î·.app xâœ) CategoryTheory.Limits.coprod.inr","decl":"/-- `X â¨¿ -` has a monad structure. This is sometimes called the either monad. -/\n@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  Î· := { app := fun _ => coprod.inr }\n  Î¼ := { app := fun _ => coprod.desc coprod.inl (ðŸ™ _) }\n\n"}
{"name":"CategoryTheory.algebraToUnder_map","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nXâœ Yâœ : (CategoryTheory.coprodMonad X).Algebra\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.algebraToUnder X).map f) (CategoryTheory.Under.homMk f.f â‹¯)","decl":"/-- The forward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef algebraToUnder : Monad.Algebra (coprodMonad X) â¥¤ Under X where\n  obj A := Under.mk (coprod.inl â‰« A.a)\n  map f :=\n    Under.homMk f.f\n      (by\n        rw [Under.mk_hom, Category.assoc, â† f.h]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.algebraToUnder_obj","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : (CategoryTheory.coprodMonad X).Algebra\nâŠ¢ Eq ((CategoryTheory.algebraToUnder X).obj A) (CategoryTheory.Under.mk (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl A.a))","decl":"/-- The forward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef algebraToUnder : Monad.Algebra (coprodMonad X) â¥¤ Under X where\n  obj A := Under.mk (coprod.inl â‰« A.a)\n  map f :=\n    Under.homMk f.f\n      (by\n        rw [Under.mk_hom, Category.assoc, â† f.h]\n        dsimp\n        simp)\n\n"}
{"name":"CategoryTheory.underToAlgebra_obj_a","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nf : CategoryTheory.Under X\nâŠ¢ Eq ((CategoryTheory.underToAlgebra X).obj f).a (CategoryTheory.Limits.coprod.desc f.hom (CategoryTheory.CategoryStruct.id f.right))","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X â¥¤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (ðŸ™ _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.underToAlgebra_obj_A","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nf : CategoryTheory.Under X\nâŠ¢ Eq ((CategoryTheory.underToAlgebra X).obj f).A f.right","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X â¥¤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (ðŸ™ _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.underToAlgebra_map_f","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nXâœ Yâœ : CategoryTheory.Under X\ng : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.underToAlgebra X).map g).f g.right","decl":"/-- The backward direction of the equivalence from algebras for the coproduct monad to the under\ncategory.\n-/\n@[simps]\ndef underToAlgebra : Under X â¥¤ Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (ðŸ™ _) }\n  map g := { f := g.right }\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_inverse","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nâŠ¢ Eq (CategoryTheory.algebraEquivUnder X).inverse (CategoryTheory.underToAlgebra X)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) â‰Œ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_unitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nâŠ¢ Eq (CategoryTheory.algebraEquivUnder X).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Monad.Algebra.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.coprodMonad X).Algebra).obj A).A) â‹¯) â‹¯)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) â‰Œ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_counitIso","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nâŠ¢ Eq (CategoryTheory.algebraEquivUnder X).counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Under.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.underToAlgebra X).comp (CategoryTheory.algebraToUnder X)).obj f).right) â‹¯) â‹¯)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) â‰Œ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.algebraEquivUnder_functor","module":"Mathlib.CategoryTheory.Monad.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nâŠ¢ Eq (CategoryTheory.algebraEquivUnder X).functor (CategoryTheory.algebraToUnder X)","decl":"/-- The equivalence from algebras for the coproduct monad to the under category.\n-/\n@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) â‰Œ Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)\n\n"}
