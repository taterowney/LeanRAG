{"name":"not_differentiableAt_norm_zero","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : Nontrivial E\n⊢ Not (DifferentiableAt Real (fun x => Norm.norm x) 0)","decl":"variable (E) in\ntheorem not_differentiableAt_norm_zero [Nontrivial E] :\n    ¬DifferentiableAt ℝ (‖·‖) (0 : E) := by\n  obtain ⟨x, hx⟩ := NormedSpace.exists_lt_norm ℝ E 0\n  intro h\n  have : DifferentiableAt ℝ (fun t : ℝ ↦ ‖t • x‖) 0 := DifferentiableAt.comp _ (by simpa) (by simp)\n  have : DifferentiableAt ℝ (|·|) (0 : ℝ) := by\n    simp_rw [norm_smul, norm_eq_abs] at this\n    have aux : abs = fun t ↦ (1 / ‖x‖) * (|t| * ‖x‖) := by field_simp\n    rw [aux]\n    exact this.const_mul _\n  exact not_differentiableAt_abs_zero this\n\n"}
{"name":"ContDiffAt.contDiffAt_norm_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nn : WithTop ENat\nx : E\nt : Real\nht : Ne t 0\nh : ContDiffAt Real n (fun x => Norm.norm x) x\n⊢ ContDiffAt Real n (fun x => Norm.norm x) (HSMul.hSMul t x)","decl":"theorem ContDiffAt.contDiffAt_norm_smul (ht : t ≠ 0) (h : ContDiffAt ℝ n (‖·‖) x) :\n    ContDiffAt ℝ n (‖·‖) (t • x) := by\n  have h1 : ContDiffAt ℝ n (fun y ↦ t⁻¹ • y) (t • x) := (contDiff_const_smul t⁻¹).contDiffAt\n  have h2 : ContDiffAt ℝ n (fun y ↦ |t| * ‖y‖) x := h.const_smul |t|\n  conv at h2 => enter [4]; rw [← one_smul ℝ x, ← inv_mul_cancel₀ ht, mul_smul]\n  convert h2.comp (t • x) h1 using 1\n  ext y\n  simp only [Function.comp_apply]\n  rw [norm_smul, ← mul_assoc, norm_eq_abs, ← abs_mul, mul_inv_cancel₀ ht, abs_one, one_mul]\n\n"}
{"name":"contDiffAt_norm_smul_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nn : WithTop ENat\nx : E\nt : Real\nht : Ne t 0\n⊢ Iff (ContDiffAt Real n (fun x => Norm.norm x) x) (ContDiffAt Real n (fun x => Norm.norm x) (HSMul.hSMul t x))","decl":"theorem contDiffAt_norm_smul_iff (ht : t ≠ 0) :\n    ContDiffAt ℝ n (‖·‖) x ↔ ContDiffAt ℝ n (‖·‖) (t • x) where\n  mp h := h.contDiffAt_norm_smul ht\n  mpr hd := by\n    convert hd.contDiffAt_norm_smul (inv_ne_zero ht)\n    rw [smul_smul, inv_mul_cancel₀ ht, one_smul]\n\n"}
{"name":"ContDiffAt.contDiffAt_norm_of_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nn : WithTop ENat\nx : E\nt : Real\nh : ContDiffAt Real n (fun x => Norm.norm x) (HSMul.hSMul t x)\n⊢ ContDiffAt Real n (fun x => Norm.norm x) x","decl":"theorem ContDiffAt.contDiffAt_norm_of_smul (h : ContDiffAt ℝ n (‖·‖) (t • x)) :\n    ContDiffAt ℝ n (‖·‖) x := by\n  rcases eq_bot_or_bot_lt n with rfl | hn\n  · apply contDiffAt_zero.2\n    exact ⟨univ, univ_mem, continuous_norm.continuousOn⟩\n  replace hn : 1 ≤ n := ENat.add_one_natCast_le_withTop_of_lt hn\n  obtain rfl | ht := eq_or_ne t 0\n  · by_cases hE : Nontrivial E\n    · rw [zero_smul] at h\n      exact (mt (ContDiffAt.differentiableAt · (mod_cast hn)))\n        (not_differentiableAt_norm_zero E) h |>.elim\n    · rw [not_nontrivial_iff_subsingleton] at hE\n      rw [eq_const_of_subsingleton (‖·‖) 0]\n      exact contDiffAt_const\n  · exact contDiffAt_norm_smul_iff ht |>.2 h\n\n"}
{"name":"HasStrictFDerivAt.hasStrictFDerivAt_norm_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : Ne t 0\nh : HasStrictFDerivAt (fun x => Norm.norm x) f x\n⊢ HasStrictFDerivAt (fun x => Norm.norm x) (HSMul.hSMul (↑(SignType.sign t)) f) (HSMul.hSMul t x)","decl":"theorem HasStrictFDerivAt.hasStrictFDerivAt_norm_smul\n    (ht : t ≠ 0) (h : HasStrictFDerivAt (‖·‖) f x) :\n    HasStrictFDerivAt (‖·‖) ((SignType.sign t : ℝ) • f) (t • x) := by\n  have h1 : HasStrictFDerivAt (fun y ↦ t⁻¹ • y) (t⁻¹ • ContinuousLinearMap.id ℝ E) (t • x) :=\n    hasStrictFDerivAt_id (t • x) |>.const_smul t⁻¹\n  have h2 : HasStrictFDerivAt (fun y ↦ |t| * ‖y‖) (|t| • f) x := h.const_smul |t|\n  conv at h2 => enter [3]; rw [← one_smul ℝ x, ← inv_mul_cancel₀ ht, mul_smul]\n  convert h2.comp (t • x) h1 with y\n  · rw [norm_smul, ← mul_assoc, norm_eq_abs, ← abs_mul, mul_inv_cancel₀ ht, abs_one, one_mul]\n  ext y\n  simp only [coe_smul', Pi.smul_apply, smul_eq_mul, comp_smulₛₗ, map_inv₀, RingHom.id_apply,\n    comp_id]\n  rw [eq_inv_mul_iff_mul_eq₀ ht, ← mul_assoc, self_mul_sign]\n\n"}
{"name":"HasStrictFDerivAt.hasStrictDerivAt_norm_smul_neg","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : LT.lt t 0\nh : HasStrictFDerivAt (fun x => Norm.norm x) f x\n⊢ HasStrictFDerivAt (fun x => Norm.norm x) (Neg.neg f) (HSMul.hSMul t x)","decl":"theorem HasStrictFDerivAt.hasStrictDerivAt_norm_smul_neg\n    (ht : t < 0) (h : HasStrictFDerivAt (‖·‖) f x) :\n    HasStrictFDerivAt (‖·‖) (-f) (t • x) := by\n  simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne\n\n"}
{"name":"HasStrictFDerivAt.hasStrictDerivAt_norm_smul_pos","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : LT.lt 0 t\nh : HasStrictFDerivAt (fun x => Norm.norm x) f x\n⊢ HasStrictFDerivAt (fun x => Norm.norm x) f (HSMul.hSMul t x)","decl":"theorem HasStrictFDerivAt.hasStrictDerivAt_norm_smul_pos\n    (ht : 0 < t) (h : HasStrictFDerivAt (‖·‖) f x) :\n    HasStrictFDerivAt (‖·‖) f (t • x) := by\n  simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne'\n\n"}
{"name":"HasFDerivAt.hasFDerivAt_norm_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : Ne t 0\nh : HasFDerivAt (fun x => Norm.norm x) f x\n⊢ HasFDerivAt (fun x => Norm.norm x) (HSMul.hSMul (↑(SignType.sign t)) f) (HSMul.hSMul t x)","decl":"theorem HasFDerivAt.hasFDerivAt_norm_smul\n    (ht : t ≠ 0) (h : HasFDerivAt (‖·‖) f x) :\n    HasFDerivAt (‖·‖) ((SignType.sign t : ℝ) • f) (t • x) := by\n  have h1 : HasFDerivAt (fun y ↦ t⁻¹ • y) (t⁻¹ • ContinuousLinearMap.id ℝ E) (t • x) :=\n    hasFDerivAt_id (t • x) |>.const_smul t⁻¹\n  have h2 : HasFDerivAt (fun y ↦ |t| * ‖y‖) (|t| • f) x := h.const_smul |t|\n  conv at h2 => enter [3]; rw [← one_smul ℝ x, ← inv_mul_cancel₀ ht, mul_smul]\n  convert h2.comp (t • x) h1 using 2 with y\n  · simp only [Function.comp_apply]\n    rw [norm_smul, ← mul_assoc, norm_eq_abs, ← abs_mul, mul_inv_cancel₀ ht, abs_one, one_mul]\n  · ext y\n    simp only [coe_smul', Pi.smul_apply, smul_eq_mul, comp_smulₛₗ, map_inv₀, RingHom.id_apply,\n      comp_id]\n    rw [eq_inv_mul_iff_mul_eq₀ ht, ← mul_assoc, self_mul_sign]\n\n"}
{"name":"HasFDerivAt.hasFDerivAt_norm_smul_neg","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : LT.lt t 0\nh : HasFDerivAt (fun x => Norm.norm x) f x\n⊢ HasFDerivAt (fun x => Norm.norm x) (Neg.neg f) (HSMul.hSMul t x)","decl":"theorem HasFDerivAt.hasFDerivAt_norm_smul_neg\n    (ht : t < 0) (h : HasFDerivAt (‖·‖) f x) :\n    HasFDerivAt (‖·‖) (-f) (t • x) := by\n  simpa [ht] using h.hasFDerivAt_norm_smul ht.ne\n\n"}
{"name":"HasFDerivAt.hasFDerivAt_norm_smul_pos","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nt : Real\nht : LT.lt 0 t\nh : HasFDerivAt (fun x => Norm.norm x) f x\n⊢ HasFDerivAt (fun x => Norm.norm x) f (HSMul.hSMul t x)","decl":"theorem HasFDerivAt.hasFDerivAt_norm_smul_pos\n    (ht : 0 < t) (h : HasFDerivAt (‖·‖) f x) :\n    HasFDerivAt (‖·‖) f (t • x) := by\n  simpa [ht] using h.hasFDerivAt_norm_smul ht.ne'\n\n"}
{"name":"differentiableAt_norm_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nt : Real\nht : Ne t 0\n⊢ Iff (DifferentiableAt Real (fun x => Norm.norm x) x) (DifferentiableAt Real (fun x => Norm.norm x) (HSMul.hSMul t x))","decl":"theorem differentiableAt_norm_smul (ht : t ≠ 0) :\n    DifferentiableAt ℝ (‖·‖) x ↔ DifferentiableAt ℝ (‖·‖) (t • x) where\n  mp hd := (hd.hasFDerivAt.hasFDerivAt_norm_smul ht).differentiableAt\n  mpr hd := by\n    convert (hd.hasFDerivAt.hasFDerivAt_norm_smul (inv_ne_zero ht)).differentiableAt\n    rw [smul_smul, inv_mul_cancel₀ ht, one_smul]\n\n"}
{"name":"DifferentiableAt.differentiableAt_norm_of_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nt : Real\nh : DifferentiableAt Real (fun x => Norm.norm x) (HSMul.hSMul t x)\n⊢ DifferentiableAt Real (fun x => Norm.norm x) x","decl":"theorem DifferentiableAt.differentiableAt_norm_of_smul (h : DifferentiableAt ℝ (‖·‖) (t • x)) :\n    DifferentiableAt ℝ (‖·‖) x := by\n  obtain rfl | ht := eq_or_ne t 0\n  · by_cases hE : Nontrivial E\n    · rw [zero_smul] at h\n      exact not_differentiableAt_norm_zero E h |>.elim\n    · rw [not_nontrivial_iff_subsingleton] at hE\n      exact (hasFDerivAt_of_subsingleton _ _).differentiableAt\n  · exact differentiableAt_norm_smul ht |>.2 h\n\n"}
{"name":"DifferentiableAt.fderiv_norm_self","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nh : DifferentiableAt Real (fun x => Norm.norm x) x\n⊢ Eq ((fderiv Real (fun x => Norm.norm x) x) x) (Norm.norm x)","decl":"theorem DifferentiableAt.fderiv_norm_self {x : E} (h : DifferentiableAt ℝ (‖·‖) x) :\n    fderiv ℝ (‖·‖) x x = ‖x‖ := by\n  rw [← h.lineDeriv_eq_fderiv, lineDeriv]\n  have this (t : ℝ) : ‖x + t • x‖ = |1 + t| * ‖x‖ := by\n    rw [← norm_eq_abs, ← norm_smul, add_smul, one_smul]\n  simp_rw [this]\n  rw [deriv_mul_const]\n  · conv_lhs => enter [1, 1]; change _root_.abs ∘ (fun t ↦ 1 + t)\n    rw [deriv_comp, deriv_abs, deriv_const_add]\n    · simp\n    · exact differentiableAt_abs (by norm_num)\n    · exact differentiableAt_id.const_add _\n  · exact (differentiableAt_abs (by norm_num)).comp _ (differentiableAt_id.const_add _)\n\n"}
{"name":"fderiv_norm_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nt : Real\n⊢ Eq (fderiv Real (fun x => Norm.norm x) (HSMul.hSMul t x)) (HSMul.hSMul (↑(SignType.sign t)) (fderiv Real (fun x => Norm.norm x) x))","decl":"variable (x t) in\ntheorem fderiv_norm_smul :\n    fderiv ℝ (‖·‖) (t • x) = (SignType.sign t : ℝ) • (fderiv ℝ (‖·‖) x) := by\n  by_cases hE : Nontrivial E\n  · by_cases hd : DifferentiableAt ℝ (‖·‖) x\n    · obtain rfl | ht := eq_or_ne t 0\n      · simp only [zero_smul, _root_.sign_zero, SignType.coe_zero]\n        exact fderiv_zero_of_not_differentiableAt <| not_differentiableAt_norm_zero E\n      · rw [(hd.hasFDerivAt.hasFDerivAt_norm_smul ht).fderiv]\n    · rw [fderiv_zero_of_not_differentiableAt hd, fderiv_zero_of_not_differentiableAt]\n      · simp\n      · exact mt DifferentiableAt.differentiableAt_norm_of_smul hd\n  · rw [not_nontrivial_iff_subsingleton] at hE\n    simp_rw [(hasFDerivAt_of_subsingleton _ _).fderiv, smul_zero]\n\n"}
{"name":"fderiv_norm_smul_pos","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nt : Real\nht : LT.lt 0 t\n⊢ Eq (fderiv Real (fun x => Norm.norm x) (HSMul.hSMul t x)) (fderiv Real (fun x => Norm.norm x) x)","decl":"theorem fderiv_norm_smul_pos (ht : 0 < t) :\n    fderiv ℝ (‖·‖) (t • x) = fderiv ℝ (‖·‖) x := by\n  simp [fderiv_norm_smul, ht]\n\n"}
{"name":"fderiv_norm_smul_neg","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\nt : Real\nht : LT.lt t 0\n⊢ Eq (fderiv Real (fun x => Norm.norm x) (HSMul.hSMul t x)) (Neg.neg (fderiv Real (fun x => Norm.norm x) x))","decl":"theorem fderiv_norm_smul_neg (ht : t < 0) :\n    fderiv ℝ (‖·‖) (t • x) = -fderiv ℝ (‖·‖) x := by\n  simp [fderiv_norm_smul, ht]\n\n"}
{"name":"norm_fderiv_norm","module":"Mathlib.Analysis.Calculus.FDeriv.Norm","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nx : E\ninst✝ : Nontrivial E\nh : DifferentiableAt Real (fun x => Norm.norm x) x\n⊢ Eq (Norm.norm (fderiv Real (fun x => Norm.norm x) x)) 1","decl":"theorem norm_fderiv_norm [Nontrivial E] (h : DifferentiableAt ℝ (‖·‖) x) :\n    ‖fderiv ℝ (‖·‖) x‖ = 1 := by\n  have : x ≠ 0 := fun hx ↦ not_differentiableAt_norm_zero E (hx ▸ h)\n  refine le_antisymm (NNReal.coe_one ▸ norm_fderiv_le_of_lipschitz ℝ lipschitzWith_one_norm) ?_\n  apply le_of_mul_le_mul_right _ (norm_pos_iff.2 this)\n  calc\n    1 * ‖x‖ = fderiv ℝ (‖·‖) x x := by rw [one_mul, h.fderiv_norm_self]\n    _ ≤ ‖fderiv ℝ (‖·‖) x x‖ := le_norm_self _\n    _ ≤ ‖fderiv ℝ (‖·‖) x‖ * ‖x‖ := le_opNorm _ _\n"}
