{"name":"ConditionallyCompleteLinearOrderedField.csSup_of_not_bddAbove","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na✝ : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) (SupSet.sSup EmptyCollection.emptyCollection)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.le_sup_left","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b : α\n⊢ LE.le a (ConditionallyCompleteLinearOrderedField.sup a b)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.sup_le","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b c : α\na✝¹ : LE.le a c\na✝ : LE.le b c\n⊢ LE.le (ConditionallyCompleteLinearOrderedField.sup a b) c","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.le_sup_right","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b : α\n⊢ LE.le b (ConditionallyCompleteLinearOrderedField.sup a b)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.csInf_of_not_bddBelow","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na✝ : Not (BddBelow s)\n⊢ Eq (InfSet.sInf s) (InfSet.sInf EmptyCollection.emptyCollection)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.csSup_le","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na : α\na✝¹ : s.Nonempty\na✝ : Membership.mem (upperBounds s) a\n⊢ LE.le (SupSet.sSup s) a","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.csInf_le","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na : α\na✝¹ : BddBelow s\na✝ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.le_csSup","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na : α\na✝¹ : BddAbove s\na✝ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.le_inf","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le a c\n⊢ LE.le a (ConditionallyCompleteLinearOrderedField.inf b c)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.inf_le_right","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b : α\n⊢ LE.le (ConditionallyCompleteLinearOrderedField.inf a b) b","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.inf_le_left","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\na b : α\n⊢ LE.le (ConditionallyCompleteLinearOrderedField.inf a b) a","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.le_csInf","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderedField α\ns : Set α\na : α\na✝¹ : s.Nonempty\na✝ : Membership.mem (lowerBounds s) a\n⊢ LE.le a (InfSet.sInf s)","decl":"/-- A field which is both linearly ordered and conditionally complete with respect to the order.\nThis axiomatizes the reals. -/\n-- @[protect_proj] -- Porting note: does not exist anymore\nclass ConditionallyCompleteLinearOrderedField (α : Type*) extends\n    LinearOrderedField α, ConditionallyCompleteLinearOrder α\n\n-- see Note [lower instance priority]\n"}
{"name":"ConditionallyCompleteLinearOrderedField.to_archimedean","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrderedField α\n⊢ Archimedean α","decl":"/-- Any conditionally complete linearly ordered field is archimedean. -/\ninstance (priority := 100) ConditionallyCompleteLinearOrderedField.to_archimedean\n    [ConditionallyCompleteLinearOrderedField α] : Archimedean α :=\n  archimedean_iff_nat_lt.2\n    (by\n      by_contra! h\n      obtain ⟨x, h⟩ := h\n      have := csSup_le _ _ (range_nonempty Nat.cast)\n        (forall_mem_range.2 fun m =>\n          le_sub_iff_add_le.2 <| le_csSup _ _ ⟨x, forall_mem_range.2 h⟩ ⟨m+1, Nat.cast_succ m⟩)\n      linarith)\n\n"}
{"name":"LinearOrderedField.cutMap_mono","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrderedField α\ninst✝ : DivisionRing β\na₁ a₂ : α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (LinearOrderedField.cutMap β a₁) (LinearOrderedField.cutMap β a₂)","decl":"theorem cutMap_mono (h : a₁ ≤ a₂) : cutMap β a₁ ⊆ cutMap β a₂ := image_subset _ fun _ => h.trans_lt'\n\n"}
{"name":"LinearOrderedField.mem_cutMap_iff","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrderedField α\ninst✝ : DivisionRing β\na : α\nb : β\n⊢ Iff (Membership.mem (LinearOrderedField.cutMap β a) b) (Exists fun q => And (LT.lt (↑q) a) (Eq (↑q) b))","decl":"@[simp]\ntheorem mem_cutMap_iff : b ∈ cutMap β a ↔ ∃ q : ℚ, (q : α) < a ∧ (q : β) = b := Iff.rfl\n\n"}
{"name":"LinearOrderedField.coe_mem_cutMap_iff","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\na : α\nq : Rat\ninst✝ : CharZero β\n⊢ Iff (Membership.mem (LinearOrderedField.cutMap β a) ↑q) (LT.lt (↑q) a)","decl":"theorem coe_mem_cutMap_iff [CharZero β] : (q : β) ∈ cutMap β a ↔ (q : α) < a :=\n  Rat.cast_injective.mem_set_image\n\n"}
{"name":"LinearOrderedField.cutMap_self","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedField α\na : α\n⊢ Eq (LinearOrderedField.cutMap α a) (Inter.inter (Set.Iio a) (Set.range Rat.cast))","decl":"theorem cutMap_self (a : α) : cutMap α a = Iio a ∩ range (Rat.cast : ℚ → α) := by\n  ext\n  constructor\n  · rintro ⟨q, h, rfl⟩\n    exact ⟨h, q, rfl⟩\n  · rintro ⟨h, q, rfl⟩\n    exact ⟨q, h, rfl⟩\n\n"}
{"name":"LinearOrderedField.cutMap_coe","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrderedField α\ninst✝ : LinearOrderedField β\nq : Rat\n⊢ Eq (LinearOrderedField.cutMap β ↑q) (Set.image Rat.cast (setOf fun r => LT.lt ↑r ↑q))","decl":"theorem cutMap_coe (q : ℚ) : cutMap β (q : α) = Rat.cast '' {r : ℚ | (r : β) < q} := by\n  simp_rw [cutMap, Rat.cast_lt]\n\n"}
{"name":"LinearOrderedField.cutMap_nonempty","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : LinearOrderedField β\ninst✝ : Archimedean α\na : α\n⊢ (LinearOrderedField.cutMap β a).Nonempty","decl":"theorem cutMap_nonempty (a : α) : (cutMap β a).Nonempty :=\n  Nonempty.image _ <| exists_rat_lt a\n\n"}
{"name":"LinearOrderedField.cutMap_bddAbove","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : LinearOrderedField β\ninst✝ : Archimedean α\na : α\n⊢ BddAbove (LinearOrderedField.cutMap β a)","decl":"theorem cutMap_bddAbove (a : α) : BddAbove (cutMap β a) := by\n  obtain ⟨q, hq⟩ := exists_rat_gt a\n  exact ⟨q, forall_mem_image.2 fun r hr => mod_cast (hq.trans' hr).le⟩\n\n"}
{"name":"LinearOrderedField.cutMap_add","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : LinearOrderedField β\ninst✝ : Archimedean α\na b : α\n⊢ Eq (LinearOrderedField.cutMap β (HAdd.hAdd a b)) (HAdd.hAdd (LinearOrderedField.cutMap β a) (LinearOrderedField.cutMap β b))","decl":"theorem cutMap_add (a b : α) : cutMap β (a + b) = cutMap β a + cutMap β b := by\n  refine (image_subset_iff.2 fun q hq => ?_).antisymm ?_\n  · rw [mem_setOf_eq, ← sub_lt_iff_lt_add] at hq\n    obtain ⟨q₁, hq₁q, hq₁ab⟩ := exists_rat_btwn hq\n    refine ⟨q₁, by rwa [coe_mem_cutMap_iff], q - q₁, ?_, add_sub_cancel _ _⟩\n    norm_cast\n    rw [coe_mem_cutMap_iff]\n    exact mod_cast sub_lt_comm.mp hq₁q\n  · rintro _ ⟨_, ⟨qa, ha, rfl⟩, _, ⟨qb, hb, rfl⟩, rfl⟩\n    -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n    refine ⟨qa + qb, ?_, by beta_reduce; norm_cast⟩\n    rw [mem_setOf_eq, cast_add]\n    exact add_lt_add ha hb\n\n"}
{"name":"LinearOrderedField.inducedMap_mono","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\n⊢ Monotone (LinearOrderedField.inducedMap α β)","decl":"theorem inducedMap_mono : Monotone (inducedMap α β) := fun _ _ h =>\n  csSup_le_csSup (cutMap_bddAbove β _) (cutMap_nonempty β _) (cutMap_mono β h)\n\n"}
{"name":"LinearOrderedField.inducedMap_rat","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\nq : Rat\n⊢ Eq (LinearOrderedField.inducedMap α β ↑q) ↑q","decl":"theorem inducedMap_rat (q : ℚ) : inducedMap α β (q : α) = q := by\n  refine csSup_eq_of_forall_le_of_forall_lt_exists_gt\n    (cutMap_nonempty β (q : α)) (fun x h => ?_) fun w h => ?_\n  · rw [cutMap_coe] at h\n    obtain ⟨r, h, rfl⟩ := h\n    exact le_of_lt h\n  · obtain ⟨q', hwq, hq⟩ := exists_rat_btwn h\n    rw [cutMap_coe]\n    exact ⟨q', ⟨_, hq, rfl⟩, hwq⟩\n\n"}
{"name":"LinearOrderedField.inducedMap_zero","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\n⊢ Eq (LinearOrderedField.inducedMap α β 0) 0","decl":"@[simp]\ntheorem inducedMap_zero : inducedMap α β 0 = 0 := mod_cast inducedMap_rat α β 0\n\n"}
{"name":"LinearOrderedField.inducedMap_one","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\n⊢ Eq (LinearOrderedField.inducedMap α β 1) 1","decl":"@[simp]\ntheorem inducedMap_one : inducedMap α β 1 = 1 := mod_cast inducedMap_rat α β 1\n\n"}
{"name":"LinearOrderedField.inducedMap_nonneg","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na : α\nha : LE.le 0 a\n⊢ LE.le 0 (LinearOrderedField.inducedMap α β a)","decl":"theorem inducedMap_nonneg (ha : 0 ≤ a) : 0 ≤ inducedMap α β a :=\n  (inducedMap_zero α _).ge.trans <| inducedMap_mono _ _ ha\n\n"}
{"name":"LinearOrderedField.coe_lt_inducedMap_iff","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na : α\nq : Rat\n⊢ Iff (LT.lt (↑q) (LinearOrderedField.inducedMap α β a)) (LT.lt (↑q) a)","decl":"theorem coe_lt_inducedMap_iff : (q : β) < inducedMap α β a ↔ (q : α) < a := by\n  refine ⟨fun h => ?_, fun hq => ?_⟩\n  · rw [← inducedMap_rat α] at h\n    exact (inducedMap_mono α β).reflect_lt h\n  · obtain ⟨q', hq, hqa⟩ := exists_rat_btwn hq\n    apply lt_csSup_of_lt (cutMap_bddAbove β a) (coe_mem_cutMap_iff.mpr hqa)\n    exact mod_cast hq\n\n"}
{"name":"LinearOrderedField.lt_inducedMap_iff","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na : α\nb : β\n⊢ Iff (LT.lt b (LinearOrderedField.inducedMap α β a)) (Exists fun q => And (LT.lt b ↑q) (LT.lt (↑q) a))","decl":"theorem lt_inducedMap_iff : b < inducedMap α β a ↔ ∃ q : ℚ, b < q ∧ (q : α) < a :=\n  ⟨fun h => (exists_rat_btwn h).imp fun _ => And.imp_right coe_lt_inducedMap_iff.1,\n    fun ⟨q, hbq, hqa⟩ => hbq.trans <| by rwa [coe_lt_inducedMap_iff]⟩\n\n"}
{"name":"LinearOrderedField.inducedMap_self","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"β : Type u_3\ninst✝ : ConditionallyCompleteLinearOrderedField β\nb : β\n⊢ Eq (LinearOrderedField.inducedMap β β b) b","decl":"@[simp]\ntheorem inducedMap_self (b : β) : inducedMap β β b = b :=\n  eq_of_forall_rat_lt_iff_lt fun _ => coe_lt_inducedMap_iff\n\n"}
{"name":"LinearOrderedField.inducedMap_inducedMap","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : LinearOrderedField α\ninst✝² : ConditionallyCompleteLinearOrderedField β\ninst✝¹ : ConditionallyCompleteLinearOrderedField γ\ninst✝ : Archimedean α\na : α\n⊢ Eq (LinearOrderedField.inducedMap β γ (LinearOrderedField.inducedMap α β a)) (LinearOrderedField.inducedMap α γ a)","decl":"@[simp]\ntheorem inducedMap_inducedMap (a : α) : inducedMap β γ (inducedMap α β a) = inducedMap α γ a :=\n  eq_of_forall_rat_lt_iff_lt fun q => by\n    rw [coe_lt_inducedMap_iff, coe_lt_inducedMap_iff, Iff.comm, coe_lt_inducedMap_iff]\n\n"}
{"name":"LinearOrderedField.inducedMap_inv_self","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : ConditionallyCompleteLinearOrderedField γ\nb : β\n⊢ Eq (LinearOrderedField.inducedMap γ β (LinearOrderedField.inducedMap β γ b)) b","decl":"theorem inducedMap_inv_self (b : β) : inducedMap γ β (inducedMap β γ b) = b := by\n  rw [inducedMap_inducedMap, inducedMap_self]\n\n"}
{"name":"LinearOrderedField.inducedMap_add","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\nx y : α\n⊢ Eq (LinearOrderedField.inducedMap α β (HAdd.hAdd x y)) (HAdd.hAdd (LinearOrderedField.inducedMap α β x) (LinearOrderedField.inducedMap α β y))","decl":"theorem inducedMap_add (x y : α) :\n    inducedMap α β (x + y) = inducedMap α β x + inducedMap α β y := by\n  rw [inducedMap, cutMap_add]\n  exact csSup_add (cutMap_nonempty β x) (cutMap_bddAbove β x) (cutMap_nonempty β y)\n    (cutMap_bddAbove β y)\n\n"}
{"name":"LinearOrderedField.le_inducedMap_mul_self_of_mem_cutMap","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb : β\nhb : Membership.mem (LinearOrderedField.cutMap β (HMul.hMul a a)) b\n⊢ LE.le b (HMul.hMul (LinearOrderedField.inducedMap α β a) (LinearOrderedField.inducedMap α β a))","decl":"/-- Preparatory lemma for `inducedOrderRingHom`. -/\ntheorem le_inducedMap_mul_self_of_mem_cutMap (ha : 0 < a) (b : β) (hb : b ∈ cutMap β (a * a)) :\n    b ≤ inducedMap α β a * inducedMap α β a := by\n  obtain ⟨q, hb, rfl⟩ := hb\n  obtain ⟨q', hq', hqq', hqa⟩ := exists_rat_pow_btwn two_ne_zero hb (mul_self_pos.2 ha.ne')\n  trans (q' : β) ^ 2\n  · exact mod_cast hqq'.le\n  · rw [pow_two] at hqa ⊢\n    exact mul_self_le_mul_self (mod_cast hq'.le)\n      (le_csSup (cutMap_bddAbove β a) <|\n        coe_mem_cutMap_iff.2 <| lt_of_mul_self_lt_mul_self₀ ha.le hqa)\n\n"}
{"name":"LinearOrderedField.exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb : β\nhba : LT.lt b (HMul.hMul (LinearOrderedField.inducedMap α β a) (LinearOrderedField.inducedMap α β a))\n⊢ Exists fun c => And (Membership.mem (LinearOrderedField.cutMap β (HMul.hMul a a)) c) (LT.lt b c)","decl":"/-- Preparatory lemma for `inducedOrderRingHom`. -/\ntheorem exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self (ha : 0 < a) (b : β)\n    (hba : b < inducedMap α β a * inducedMap α β a) : ∃ c ∈ cutMap β (a * a), b < c := by\n  obtain hb | hb := lt_or_le b 0\n  · refine ⟨0, ?_, hb⟩\n    rw [← Rat.cast_zero, coe_mem_cutMap_iff, Rat.cast_zero]\n    exact mul_self_pos.2 ha.ne'\n  obtain ⟨q, hq, hbq, hqa⟩ := exists_rat_pow_btwn two_ne_zero hba (hb.trans_lt hba)\n  rw [← cast_pow] at hbq\n  refine ⟨(q ^ 2 : ℚ), coe_mem_cutMap_iff.2 ?_, hbq⟩\n  rw [pow_two] at hqa ⊢\n  push_cast\n  obtain ⟨q', hq', hqa'⟩ := lt_inducedMap_iff.1 (lt_of_mul_self_lt_mul_self₀\n    (inducedMap_nonneg ha.le) hqa)\n  exact mul_self_lt_mul_self (mod_cast hq.le) (hqa'.trans' <| by assumption_mod_cast)\n\n"}
{"name":"LinearOrderedField.inducedOrderRingHom_toFun","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : LinearOrderedField α\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : Archimedean α\na✝ : α\n⊢ Eq ((LinearOrderedField.inducedOrderRingHom α β) a✝) ((LinearOrderedField.inducedAddHom α β) a✝)","decl":"/-- `inducedMap` as an `OrderRingHom`. -/\n@[simps!]\ndef inducedOrderRingHom : α →+*o β :=\n  { AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero (inducedAddHom α β) (by\n      suffices ∀ x, 0 < x → inducedAddHom α β (x * x) = inducedAddHom α β x * inducedAddHom α β x by\n        intro x\n        obtain h | rfl | h := lt_trichotomy x 0\n        · convert this (-x) (neg_pos.2 h) using 1\n          · rw [neg_mul, mul_neg, neg_neg]\n          · simp_rw [AddMonoidHom.map_neg, neg_mul, mul_neg, neg_neg]\n        · simp only [mul_zero, AddMonoidHom.map_zero]\n        · exact this x h\n        -- prove that the (Sup of rationals less than x) ^ 2 is the Sup of the set of rationals less\n        -- than (x ^ 2) by showing it is an upper bound and any smaller number is not an upper bound\n      refine fun x hx => csSup_eq_of_forall_le_of_forall_lt_exists_gt (cutMap_nonempty β _) ?_ ?_\n      · exact le_inducedMap_mul_self_of_mem_cutMap hx\n      · exact exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self hx)\n      (two_ne_zero) (inducedMap_one _ _) with\n    monotone' := inducedMap_mono _ _ }\n\n"}
{"name":"LinearOrderedField.coe_inducedOrderRingIso","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : ConditionallyCompleteLinearOrderedField γ\n⊢ Eq (⇑(LinearOrderedField.inducedOrderRingIso β γ)) (LinearOrderedField.inducedMap β γ)","decl":"@[simp]\ntheorem coe_inducedOrderRingIso : ⇑(inducedOrderRingIso β γ) = inducedMap β γ := rfl\n\n"}
{"name":"LinearOrderedField.inducedOrderRingIso_symm","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : ConditionallyCompleteLinearOrderedField β\ninst✝ : ConditionallyCompleteLinearOrderedField γ\n⊢ Eq (LinearOrderedField.inducedOrderRingIso β γ).symm (LinearOrderedField.inducedOrderRingIso γ β)","decl":"@[simp]\ntheorem inducedOrderRingIso_symm : (inducedOrderRingIso β γ).symm = inducedOrderRingIso γ β := rfl\n\n"}
{"name":"LinearOrderedField.inducedOrderRingIso_self","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"β : Type u_3\ninst✝ : ConditionallyCompleteLinearOrderedField β\n⊢ Eq (LinearOrderedField.inducedOrderRingIso β β) (OrderRingIso.refl β)","decl":"@[simp]\ntheorem inducedOrderRingIso_self : inducedOrderRingIso β β = OrderRingIso.refl β :=\n  OrderRingIso.ext inducedMap_self\n\n"}
{"name":"ringHom_monotone","module":"Mathlib.Algebra.Order.CompleteField","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : OrderedRing R\ninst✝ : LinearOrderedRing S\nhR : ∀ (r : R), LE.le 0 r → Exists fun s => Eq (HPow.hPow s 2) r\nf : RingHom R S\n⊢ Monotone ⇑f","decl":"theorem ringHom_monotone (hR : ∀ r : R, 0 ≤ r → ∃ s : R, s ^ 2 = r) (f : R →+* S) : Monotone f :=\n  (monotone_iff_map_nonneg f).2 fun r h => by\n    obtain ⟨s, rfl⟩ := hR r h; rw [map_pow]; apply sq_nonneg\n\n"}
