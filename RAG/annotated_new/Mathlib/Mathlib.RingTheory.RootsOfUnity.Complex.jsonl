{"name":"Complex.isPrimitiveRoot_exp_of_coprime","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"i n : Nat\nh0 : Ne n 0\nhi : i.Coprime n\n⊢ IsPrimitiveRoot (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (HDiv.hDiv ↑i ↑n))) n","decl":"theorem isPrimitiveRoot_exp_of_coprime (i n : ℕ) (h0 : n ≠ 0) (hi : i.Coprime n) :\n    IsPrimitiveRoot (exp (2 * π * I * (i / n))) n := by\n  rw [IsPrimitiveRoot.iff_def]\n  simp only [← exp_nat_mul, exp_eq_one_iff]\n  have hn0 : (n : ℂ) ≠ 0 := mod_cast h0\n  constructor\n  · use i\n    field_simp [hn0, mul_comm (i : ℂ), mul_comm (n : ℂ)]\n  · simp only [hn0, mul_right_comm _ _ ↑n, mul_left_inj' two_pi_I_ne_zero, Ne, not_false_iff,\n      mul_comm _ (i : ℂ), ← mul_assoc _ (i : ℂ), exists_imp, field_simps]\n    norm_cast\n    rintro l k hk\n    conv_rhs at hk => rw [mul_comm, ← mul_assoc]\n    have hz : 2 * ↑π * I ≠ 0 := by simp [pi_pos.ne.symm, I_ne_zero]\n    field_simp [hz] at hk\n    norm_cast at hk\n    have : n ∣ i * l := by rw [← Int.natCast_dvd_natCast, hk, mul_comm]; apply dvd_mul_left\n    exact hi.symm.dvd_of_dvd_mul_left this\n\n"}
{"name":"Complex.isPrimitiveRoot_exp","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\nh0 : Ne n 0\n⊢ IsPrimitiveRoot (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑n)) n","decl":"theorem isPrimitiveRoot_exp (n : ℕ) (h0 : n ≠ 0) : IsPrimitiveRoot (exp (2 * π * I / n)) n := by\n  simpa only [Nat.cast_one, one_div] using\n    isPrimitiveRoot_exp_of_coprime 1 n h0 n.coprime_one_left\n\n"}
{"name":"Complex.isPrimitiveRoot_iff","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"ζ : Complex\nn : Nat\nhn : Ne n 0\n⊢ Iff (IsPrimitiveRoot ζ n) (Exists fun i => And (LT.lt i n) (Exists fun x => Eq (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (HDiv.hDiv ↑i ↑n))) ζ))","decl":"theorem isPrimitiveRoot_iff (ζ : ℂ) (n : ℕ) (hn : n ≠ 0) :\n    IsPrimitiveRoot ζ n ↔ ∃ i < n, ∃ _ : i.Coprime n, exp (2 * π * I * (i / n)) = ζ := by\n  have hn0 : (n : ℂ) ≠ 0 := mod_cast hn\n  constructor; swap\n  · rintro ⟨i, -, hi, rfl⟩; exact isPrimitiveRoot_exp_of_coprime i n hn hi\n  intro h\n  have : NeZero n := ⟨hn⟩\n  obtain ⟨i, hi, rfl⟩ :=\n    (isPrimitiveRoot_exp n hn).eq_pow_of_pow_eq_one h.pow_eq_one\n  refine ⟨i, hi, ((isPrimitiveRoot_exp n hn).pow_iff_coprime (Nat.pos_of_ne_zero hn) i).mp h, ?_⟩\n  rw [← exp_nat_mul]\n  congr 1\n  field_simp [hn0, mul_comm (i : ℂ)]\n\n"}
{"name":"Complex.mem_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : Units Complex\n⊢ Iff (Membership.mem (rootsOfUnity n Complex) x) (Exists fun i => And (LT.lt i n) (Eq (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (HDiv.hDiv ↑i ↑n))) ↑x))","decl":"/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\nnonrec theorem mem_rootsOfUnity (n : ℕ) [NeZero n] (x : Units ℂ) :\n    x ∈ rootsOfUnity n ℂ ↔ ∃ i < n, exp (2 * π * I * (i / n)) = x := by\n  rw [mem_rootsOfUnity, Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one]\n  have hn0 : (n : ℂ) ≠ 0 := mod_cast NeZero.out\n  constructor\n  · intro h\n    obtain ⟨i, hi, H⟩ : ∃ i < (n : ℕ), exp (2 * π * I / n) ^ i = x := by\n      simpa only using (isPrimitiveRoot_exp n NeZero.out).eq_pow_of_pow_eq_one h\n    refine ⟨i, hi, ?_⟩\n    rw [← H, ← exp_nat_mul]\n    congr 1\n    field_simp [hn0, mul_comm (i : ℂ)]\n  · rintro ⟨i, _, H⟩\n    rw [← H, ← exp_nat_mul, exp_eq_one_iff]\n    use i\n    field_simp [hn0, mul_comm ((n : ℕ) : ℂ), mul_comm (i : ℂ)]\n\n"}
{"name":"Complex.card_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n Complex) x)) n","decl":"theorem card_rootsOfUnity (n : ℕ) [NeZero n] : Fintype.card (rootsOfUnity n ℂ) = n :=\n  (isPrimitiveRoot_exp n NeZero.out).card_rootsOfUnity\n\n"}
{"name":"Complex.card_primitiveRoots","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"k : Nat\n⊢ Eq (primitiveRoots k Complex).card k.totient","decl":"theorem card_primitiveRoots (k : ℕ) : (primitiveRoots k ℂ).card = φ k := by\n  by_cases h : k = 0\n  · simp [h]\n  exact (isPrimitiveRoot_exp k h).card_primitiveRoots\n\n"}
{"name":"IsPrimitiveRoot.norm'_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"ζ : Complex\nn : Nat\nh : IsPrimitiveRoot ζ n\nhn : Ne n 0\n⊢ Eq (Norm.norm ζ) 1","decl":"theorem IsPrimitiveRoot.norm'_eq_one {ζ : ℂ} {n : ℕ} (h : IsPrimitiveRoot ζ n) (hn : n ≠ 0) :\n    ‖ζ‖ = 1 :=\n  Complex.norm_eq_one_of_pow_eq_one h.pow_eq_one hn\n\n"}
{"name":"IsPrimitiveRoot.nnnorm_eq_one","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"ζ : Complex\nn : Nat\nh : IsPrimitiveRoot ζ n\nhn : Ne n 0\n⊢ Eq (NNNorm.nnnorm ζ) 1","decl":"theorem IsPrimitiveRoot.nnnorm_eq_one {ζ : ℂ} {n : ℕ} (h : IsPrimitiveRoot ζ n) (hn : n ≠ 0) :\n    ‖ζ‖₊ = 1 :=\n  Subtype.ext <| h.norm'_eq_one hn\n\n"}
{"name":"IsPrimitiveRoot.arg_ext","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n m : Nat\nζ μ : Complex\nhζ : IsPrimitiveRoot ζ n\nhμ : IsPrimitiveRoot μ m\nhn : Ne n 0\nhm : Ne m 0\nh : Eq ζ.arg μ.arg\n⊢ Eq ζ μ","decl":"theorem IsPrimitiveRoot.arg_ext {n m : ℕ} {ζ μ : ℂ} (hζ : IsPrimitiveRoot ζ n)\n    (hμ : IsPrimitiveRoot μ m) (hn : n ≠ 0) (hm : m ≠ 0) (h : ζ.arg = μ.arg) : ζ = μ :=\n  Complex.ext_abs_arg ((hζ.norm'_eq_one hn).trans (hμ.norm'_eq_one hm).symm) h\n\n"}
{"name":"IsPrimitiveRoot.arg_eq_zero_iff","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\nζ : Complex\nhζ : IsPrimitiveRoot ζ n\nhn : Ne n 0\n⊢ Iff (Eq ζ.arg 0) (Eq ζ 1)","decl":"theorem IsPrimitiveRoot.arg_eq_zero_iff {n : ℕ} {ζ : ℂ} (hζ : IsPrimitiveRoot ζ n) (hn : n ≠ 0) :\n    ζ.arg = 0 ↔ ζ = 1 :=\n  ⟨fun h => hζ.arg_ext IsPrimitiveRoot.one hn one_ne_zero (h.trans Complex.arg_one.symm), fun h =>\n    h.symm ▸ Complex.arg_one⟩\n\n"}
{"name":"IsPrimitiveRoot.arg_eq_pi_iff","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\nζ : Complex\nhζ : IsPrimitiveRoot ζ n\nhn : Ne n 0\n⊢ Iff (Eq ζ.arg Real.pi) (Eq ζ (-1))","decl":"theorem IsPrimitiveRoot.arg_eq_pi_iff {n : ℕ} {ζ : ℂ} (hζ : IsPrimitiveRoot ζ n) (hn : n ≠ 0) :\n    ζ.arg = Real.pi ↔ ζ = -1 :=\n  ⟨fun h =>\n    hζ.arg_ext (IsPrimitiveRoot.neg_one 0 two_ne_zero.symm) hn two_ne_zero\n      (h.trans Complex.arg_neg_one.symm),\n    fun h => h.symm ▸ Complex.arg_neg_one⟩\n\n"}
{"name":"IsPrimitiveRoot.arg","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"n : Nat\nζ : Complex\nh : IsPrimitiveRoot ζ n\nhn : Ne n 0\n⊢ Exists fun i => And (Eq ζ.arg (HMul.hMul (HDiv.hDiv ↑i ↑n) (HMul.hMul 2 Real.pi))) (And (IsCoprime i ↑n) (LT.lt i.natAbs n))","decl":"theorem IsPrimitiveRoot.arg {n : ℕ} {ζ : ℂ} (h : IsPrimitiveRoot ζ n) (hn : n ≠ 0) :\n    ∃ i : ℤ, ζ.arg = i / n * (2 * Real.pi) ∧ IsCoprime i n ∧ i.natAbs < n := by\n  rw [Complex.isPrimitiveRoot_iff _ _ hn] at h\n  obtain ⟨i, h, hin, rfl⟩ := h\n  rw [mul_comm, ← mul_assoc, Complex.exp_mul_I]\n  refine ⟨if i * 2 ≤ n then i else i - n, ?_, ?_, ?_⟩\n  on_goal 2 =>\n    replace hin := Nat.isCoprime_iff_coprime.mpr hin\n    split_ifs\n    · exact hin\n    · convert hin.add_mul_left_left (-1) using 1\n      rw [mul_neg_one, sub_eq_add_neg]\n  on_goal 2 => omega\n  split_ifs with h₂\n  · convert Complex.arg_cos_add_sin_mul_I _\n    · push_cast; rfl\n    · push_cast; rfl\n    field_simp [hn]\n    refine ⟨(neg_lt_neg Real.pi_pos).trans_le ?_, ?_⟩\n    · rw [neg_zero]\n      exact mul_nonneg (mul_nonneg i.cast_nonneg <| by simp [Real.pi_pos.le])\n        (by rw [inv_nonneg]; simp only [Nat.cast_nonneg])\n    rw [← mul_rotate', mul_div_assoc]\n    rw [← mul_one n] at h₂\n    exact mul_le_of_le_one_right Real.pi_pos.le\n      ((div_le_iff₀' <| mod_cast pos_of_gt h).mpr <| mod_cast h₂)\n  rw [← Complex.cos_sub_two_pi, ← Complex.sin_sub_two_pi]\n  convert Complex.arg_cos_add_sin_mul_I _\n  · push_cast\n    rw [← sub_one_mul, sub_div, div_self]\n    exact mod_cast hn\n  · push_cast\n    rw [← sub_one_mul, sub_div, div_self]\n    exact mod_cast hn\n  field_simp [hn]\n  refine ⟨?_, le_trans ?_ Real.pi_pos.le⟩\n  on_goal 2 =>\n    rw [mul_div_assoc]\n    exact mul_nonpos_of_nonpos_of_nonneg (sub_nonpos.mpr <| mod_cast h.le)\n      (div_nonneg (by simp [Real.pi_pos.le]) <| by simp)\n  rw [← mul_rotate', mul_div_assoc, neg_lt, ← mul_neg, mul_lt_iff_lt_one_right Real.pi_pos, ←\n    neg_div, ← neg_mul, neg_sub, div_lt_iff₀, one_mul, sub_mul, sub_lt_comm, ← mul_sub_one]\n  · norm_num\n    exact mod_cast not_le.mp h₂\n  · exact Nat.cast_pos.mpr hn.bot_lt\n\n"}
{"name":"Complex.norm_eq_one_of_mem_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Complex","initialProofState":"ζ : Units Complex\nn : Nat\ninst✝ : NeZero n\nhζ : Membership.mem (rootsOfUnity n Complex) ζ\n⊢ Eq (Norm.norm ↑ζ) 1","decl":"lemma Complex.norm_eq_one_of_mem_rootsOfUnity {ζ : ℂˣ} {n : ℕ} [NeZero n]\n    (hζ : ζ ∈ rootsOfUnity n ℂ) :\n    ‖(ζ : ℂ)‖ = 1 := by\n  refine norm_eq_one_of_pow_eq_one ?_ <| NeZero.ne n\n  norm_cast\n  rw [_root_.mem_rootsOfUnity] at hζ\n  rw [hζ, Units.val_one]\n"}
