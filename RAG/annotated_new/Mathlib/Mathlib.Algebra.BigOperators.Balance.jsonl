{"name":"Fintype.balance_apply","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf : ι → G\nx : ι\n⊢ Eq (Fintype.balance f x) (HSub.hSub (f x) (Finset.univ.expect fun y => f y))","decl":"lemma balance_apply (f : ι → G) (x : ι) : balance f x = f x - 𝔼 y, f y := rfl\n\n"}
{"name":"Fintype.balance_zero","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\n⊢ Eq (Fintype.balance 0) 0","decl":"@[simp] lemma balance_zero : balance (0 : ι → G) = 0 := by simp [balance]\n\n"}
{"name":"Fintype.balance_add","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf g : ι → G\n⊢ Eq (Fintype.balance (HAdd.hAdd f g)) (HAdd.hAdd (Fintype.balance f) (Fintype.balance g))","decl":"@[simp] lemma balance_add (f g : ι → G) : balance (f + g) = balance f + balance g := by\n  simp only [balance, expect_add_distrib, ← const_add, add_sub_add_comm, Pi.add_apply]\n\n"}
{"name":"Fintype.balance_sub","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf g : ι → G\n⊢ Eq (Fintype.balance (HSub.hSub f g)) (HSub.hSub (Fintype.balance f) (Fintype.balance g))","decl":"@[simp] lemma balance_sub (f g : ι → G) : balance (f - g) = balance f - balance g := by\n  simp only [balance, expect_sub_distrib, const_sub, sub_sub_sub_comm, Pi.sub_apply]\n\n"}
{"name":"Fintype.balance_neg","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf : ι → G\n⊢ Eq (Fintype.balance (Neg.neg f)) (Neg.neg (Fintype.balance f))","decl":"@[simp] lemma balance_neg (f : ι → G) : balance (-f) = -balance f := by\n  simp only [balance, expect_neg_distrib, const_neg, neg_sub', Pi.neg_apply]\n\n"}
{"name":"Fintype.sum_balance","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf : ι → G\n⊢ Eq (Finset.univ.sum fun x => Fintype.balance f x) 0","decl":"@[simp] lemma sum_balance (f : ι → G) : ∑ x, balance f x = 0 := by\n  cases isEmpty_or_nonempty ι <;> simp [balance_apply]\n\n"}
{"name":"Fintype.expect_balance","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf : ι → G\n⊢ Eq (Finset.univ.expect fun x => Fintype.balance f x) 0","decl":"@[simp] lemma expect_balance (f : ι → G) : 𝔼 x, balance f x = 0 := by simp [expect]\n\n"}
{"name":"Fintype.balance_idem","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup G\ninst✝ : Module NNRat G\nf : ι → G\n⊢ Eq (Fintype.balance (Fintype.balance f)) (Fintype.balance f)","decl":"@[simp] lemma balance_idem (f : ι → G) : balance (balance f) = balance f := by\n  cases isEmpty_or_nonempty ι <;> ext x <;> simp [balance, expect_sub_distrib, univ_nonempty]\n\n"}
{"name":"Fintype.map_balance","module":"Mathlib.Algebra.BigOperators.Balance","initialProofState":"ι : Type u_1\nH : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : AddCommGroup G\ninst✝⁴ : Module NNRat G\ninst✝³ : AddCommGroup H\ninst✝² : Module NNRat H\ninst✝¹ : FunLike F G H\ninst✝ : LinearMapClass F NNRat G H\ng : F\nf : ι → G\na : ι\n⊢ Eq (g (Fintype.balance f a)) (Fintype.balance (Function.comp (⇑g) f) a)","decl":"@[simp] lemma map_balance [FunLike F G H] [LinearMapClass F ℚ≥0 G H] (g : F) (f : ι → G) (a : ι) :\n    g (balance f a) = balance (g ∘ f) a := by simp [balance, map_expect]\n\n"}
