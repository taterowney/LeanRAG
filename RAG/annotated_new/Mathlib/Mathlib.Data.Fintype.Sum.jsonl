{"name":"Finset.univ_disjSum_univ","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (Finset.univ.disjSum Finset.univ) Finset.univ","decl":"@[simp]\ntheorem Finset.univ_disjSum_univ {α β : Type*} [Fintype α] [Fintype β] :\n    univ.disjSum univ = (univ : Finset (α ⊕ β)) :=\n  rfl\n\n"}
{"name":"Fintype.card_sum","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (Fintype.card (Sum α β)) (HAdd.hAdd (Fintype.card α) (Fintype.card β))","decl":"@[simp]\ntheorem Fintype.card_sum [Fintype α] [Fintype β] :\n    Fintype.card (α ⊕ β) = Fintype.card α + Fintype.card β :=\n  card_disjSum _ _\n\n"}
{"name":"image_subtype_ne_univ_eq_image_erase","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nk : β\nb : α → β\n⊢ Eq (Finset.image (fun i => b ↑i) Finset.univ) ((Finset.image b Finset.univ).erase k)","decl":"theorem image_subtype_ne_univ_eq_image_erase [Fintype α] [DecidableEq β] (k : β) (b : α → β) :\n    image (fun i : { a // b a ≠ k } => b ↑i) univ = (image b univ).erase k := by\n  apply subset_antisymm\n  · rw [image_subset_iff]\n    intro i _\n    apply mem_erase_of_ne_of_mem i.2 (mem_image_of_mem _ (mem_univ _))\n  · intro i hi\n    rw [mem_image]\n    rcases mem_image.1 (erase_subset _ _ hi) with ⟨a, _, ha⟩\n    subst ha\n    exact ⟨⟨a, ne_of_mem_erase hi⟩, mem_univ _, rfl⟩\n\n"}
{"name":"image_subtype_univ_ssubset_image_univ","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\nk : β\nb : α → β\nhk : Membership.mem (Finset.image b Finset.univ) k\np : β → Prop\ninst✝ : DecidablePred p\nhp : Not (p k)\n⊢ HasSSubset.SSubset (Finset.image (fun i => b ↑i) Finset.univ) (Finset.image b Finset.univ)","decl":"theorem image_subtype_univ_ssubset_image_univ [Fintype α] [DecidableEq β] (k : β) (b : α → β)\n    (hk : k ∈ Finset.image b univ) (p : β → Prop) [DecidablePred p] (hp : ¬p k) :\n    image (fun i : { a // p (b a) } => b ↑i) univ ⊂ image b univ := by\n  constructor\n  · intro x hx\n    rcases mem_image.1 hx with ⟨y, _, hy⟩\n    exact hy ▸ mem_image_of_mem b (mem_univ (y : α))\n  · intro h\n    rw [mem_image] at hk\n    rcases hk with ⟨k', _, hk'⟩\n    subst hk'\n    have := h (mem_image_of_mem b (mem_univ k'))\n    rw [mem_image] at this\n    rcases this with ⟨j, _, hj'⟩\n    exact hp (hj' ▸ j.2)\n\n"}
{"name":"Finset.exists_equiv_extend_of_card_eq","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nt : Finset β\nhαt : Eq (Fintype.card α) t.card\ns : Finset α\nf : α → β\nhfst : HasSubset.Subset (Finset.image f s) t\nhfs : Set.InjOn f ↑s\n⊢ Exists fun g => ∀ (i : α), Membership.mem s i → Eq (↑(g i)) (f i)","decl":"/-- Any injection from a finset `s` in a fintype `α` to a finset `t` of the same cardinality as `α`\ncan be extended to a bijection between `α` and `t`. -/\ntheorem Finset.exists_equiv_extend_of_card_eq [Fintype α] [DecidableEq β] {t : Finset β}\n    (hαt : Fintype.card α = #t) {s : Finset α} {f : α → β} (hfst : Finset.image f s ⊆ t)\n    (hfs : Set.InjOn f s) : ∃ g : α ≃ t, ∀ i ∈ s, (g i : β) = f i := by\n  classical\n    induction' s using Finset.induction with a s has H generalizing f\n    · obtain ⟨e⟩ : Nonempty (α ≃ ↥t) := by rwa [← Fintype.card_eq, Fintype.card_coe]\n      use e\n      simp\n    have hfst' : Finset.image f s ⊆ t := (Finset.image_mono _ (s.subset_insert a)).trans hfst\n    have hfs' : Set.InjOn f s := hfs.mono (s.subset_insert a)\n    obtain ⟨g', hg'⟩ := H hfst' hfs'\n    have hfat : f a ∈ t := hfst (mem_image_of_mem _ (s.mem_insert_self a))\n    use g'.trans (Equiv.swap (⟨f a, hfat⟩ : t) (g' a))\n    simp_rw [mem_insert]\n    rintro i (rfl | hi)\n    · simp\n    rw [Equiv.trans_apply, Equiv.swap_apply_of_ne_of_ne, hg' _ hi]\n    · exact\n        ne_of_apply_ne Subtype.val\n          (ne_of_eq_of_ne (hg' _ hi) <|\n            hfs.ne (subset_insert _ _ hi) (mem_insert_self _ _) <| ne_of_mem_of_not_mem hi has)\n    · exact g'.injective.ne (ne_of_mem_of_not_mem hi has)\n\n"}
{"name":"Set.MapsTo.exists_equiv_extend_of_card_eq","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Fintype α\nt : Finset β\nhαt : Eq (Fintype.card α) t.card\ns : Set α\nf : α → β\nhfst : Set.MapsTo f s ↑t\nhfs : Set.InjOn f s\n⊢ Exists fun g => ∀ (i : α), Membership.mem s i → Eq (↑(g i)) (f i)","decl":"/-- Any injection from a set `s` in a fintype `α` to a finset `t` of the same cardinality as `α`\ncan be extended to a bijection between `α` and `t`. -/\ntheorem Set.MapsTo.exists_equiv_extend_of_card_eq [Fintype α] {t : Finset β}\n    (hαt : Fintype.card α = #t) {s : Set α} {f : α → β} (hfst : s.MapsTo f t)\n    (hfs : Set.InjOn f s) : ∃ g : α ≃ t, ∀ i ∈ s, (g i : β) = f i := by\n  classical\n    let s' : Finset α := s.toFinset\n    have hfst' : s'.image f ⊆ t := by simpa [s', ← Finset.coe_subset] using hfst\n    have hfs' : Set.InjOn f s' := by simpa [s'] using hfs\n    obtain ⟨g, hg⟩ := Finset.exists_equiv_extend_of_card_eq hαt hfst' hfs'\n    refine ⟨g, fun i hi => ?_⟩\n    apply hg\n    simpa [s'] using hi\n\n"}
{"name":"Fintype.card_subtype_or","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝² : Fintype (Subtype fun x => p x)\ninst✝¹ : Fintype (Subtype fun x => q x)\ninst✝ : Fintype (Subtype fun x => Or (p x) (q x))\n⊢ LE.le (Fintype.card (Subtype fun x => Or (p x) (q x))) (HAdd.hAdd (Fintype.card (Subtype fun x => p x)) (Fintype.card (Subtype fun x => q x)))","decl":"theorem Fintype.card_subtype_or (p q : α → Prop) [Fintype { x // p x }] [Fintype { x // q x }]\n    [Fintype { x // p x ∨ q x }] :\n    Fintype.card { x // p x ∨ q x } ≤ Fintype.card { x // p x } + Fintype.card { x // q x } := by\n  classical\n    convert Fintype.card_le_of_embedding (subtypeOrLeftEmbedding p q)\n    rw [Fintype.card_sum]\n\n"}
{"name":"Fintype.card_subtype_or_disjoint","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\np q : α → Prop\nh : Disjoint p q\ninst✝² : Fintype (Subtype fun x => p x)\ninst✝¹ : Fintype (Subtype fun x => q x)\ninst✝ : Fintype (Subtype fun x => Or (p x) (q x))\n⊢ Eq (Fintype.card (Subtype fun x => Or (p x) (q x))) (HAdd.hAdd (Fintype.card (Subtype fun x => p x)) (Fintype.card (Subtype fun x => q x)))","decl":"theorem Fintype.card_subtype_or_disjoint (p q : α → Prop) (h : Disjoint p q) [Fintype { x // p x }]\n    [Fintype { x // q x }] [Fintype { x // p x ∨ q x }] :\n    Fintype.card { x // p x ∨ q x } = Fintype.card { x // p x } + Fintype.card { x // q x } := by\n  classical\n    convert Fintype.card_congr (subtypeOrEquiv p q h)\n    simp\n\n"}
{"name":"infinite_sum","module":"Mathlib.Data.Fintype.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Iff (Infinite (Sum α β)) (Or (Infinite α) (Infinite β))","decl":"@[simp]\ntheorem infinite_sum : Infinite (α ⊕ β) ↔ Infinite α ∨ Infinite β := by\n  refine ⟨fun H => ?_, fun H => H.elim (@Sum.infinite_of_left α β) (@Sum.infinite_of_right α β)⟩\n  contrapose! H; haveI := fintypeOfNotInfinite H.1; haveI := fintypeOfNotInfinite H.2\n  exact Infinite.false\n\n"}
