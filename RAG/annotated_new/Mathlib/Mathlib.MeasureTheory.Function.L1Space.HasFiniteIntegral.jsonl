{"name":"MeasureTheory.lintegral_enorm_eq_lintegral_edist","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) 0)","decl":"lemma lintegral_enorm_eq_lintegral_edist (f : Î± â†’ Î²) :\n    âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ = âˆ«â» a, edist (f a) 0 âˆ‚Î¼ := by simp only [edist_zero_eq_enorm]\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_eq_lintegral_edist","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) 0)","decl":"@[deprecated (since := \"2025-01-20\")]\nalias lintegral_nnnorm_eq_lintegral_edist := lintegral_enorm_eq_lintegral_edist\n\n"}
{"name":"MeasureTheory.lintegral_norm_eq_lintegral_edist","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (Norm.norm (f a))) (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) 0)","decl":"theorem lintegral_norm_eq_lintegral_edist (f : Î± â†’ Î²) :\n    âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼ = âˆ«â» a, edist (f a) 0 âˆ‚Î¼ := by\n  simp only [ofReal_norm_eq_enorm, edist_zero_eq_enorm]\n\n"}
{"name":"MeasureTheory.lintegral_edist_triangle","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g h : Î± â†’ Î²\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhh : MeasureTheory.AEStronglyMeasurable h Î¼\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) (h a)) (MeasureTheory.lintegral Î¼ fun a => EDist.edist (g a) (h a)))","decl":"theorem lintegral_edist_triangle {f g h : Î± â†’ Î²} (hf : AEStronglyMeasurable f Î¼)\n    (hh : AEStronglyMeasurable h Î¼) :\n    (âˆ«â» a, edist (f a) (g a) âˆ‚Î¼) â‰¤ (âˆ«â» a, edist (f a) (h a) âˆ‚Î¼) + âˆ«â» a, edist (g a) (h a) âˆ‚Î¼ := by\n  rw [â† lintegral_add_left' (hf.edist hh)]\n  refine lintegral_mono fun a => ?_\n  apply edist_triangle_right\n\n-- YaÃ«l: Why do the following four lemmas even exist?\n"}
{"name":"MeasureTheory.lintegral_enorm_zero","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm 0) 0","decl":"theorem lintegral_enorm_zero : âˆ«â» _ : Î±, â€–(0 : Î²)â€–â‚‘ âˆ‚Î¼ = 0 := by simp\n\n"}
{"name":"MeasureTheory.lintegral_enorm_add_left","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\ng : Î± â†’ Î³\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (ENorm.enorm (f a)) (ENorm.enorm (g a))) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (g a)))","decl":"theorem lintegral_enorm_add_left {f : Î± â†’ Î²} (hf : AEStronglyMeasurable f Î¼) (g : Î± â†’ Î³) :\n    âˆ«â» a, â€–f aâ€–â‚‘ + â€–g aâ€–â‚‘ âˆ‚Î¼ = âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ + âˆ«â» a, â€–g aâ€–â‚‘ âˆ‚Î¼ :=\n  lintegral_add_left' hf.enorm _\n\n"}
{"name":"MeasureTheory.lintegral_enorm_add_right","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (ENorm.enorm (f a)) (ENorm.enorm (g a))) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (g a)))","decl":"theorem lintegral_enorm_add_right (f : Î± â†’ Î²) {g : Î± â†’ Î³} (hg : AEStronglyMeasurable g Î¼) :\n    âˆ«â» a, â€–f aâ€–â‚‘ + â€–g aâ€–â‚‘ âˆ‚Î¼ = âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ + âˆ«â» a, â€–g aâ€–â‚‘ âˆ‚Î¼ :=\n  lintegral_add_right' _ hg.enorm\n\n"}
{"name":"MeasureTheory.lintegral_enorm_neg","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (Neg.neg f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a))","decl":"theorem lintegral_enorm_neg {f : Î± â†’ Î²} : âˆ«â» a, â€–(-f) aâ€–â‚‘ âˆ‚Î¼ = âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ := by simp\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_zero","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm 0) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias lintegral_nnnorm_zero := lintegral_enorm_zero\n"}
{"name":"MeasureTheory.lintegral_nnnorm_add_left","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\ng : Î± â†’ Î³\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (ENorm.enorm (f a)) (ENorm.enorm (g a))) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (g a)))","decl":"@[deprecated (since := \"2025-01-21\")] alias lintegral_nnnorm_add_left := lintegral_enorm_add_left\n"}
{"name":"MeasureTheory.lintegral_nnnorm_add_right","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (ENorm.enorm (f a)) (ENorm.enorm (g a))) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (g a)))","decl":"@[deprecated (since := \"2025-01-21\")] alias lintegral_nnnorm_add_right := lintegral_enorm_add_right\n"}
{"name":"MeasureTheory.lintegral_nnnorm_neg","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (Neg.neg f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a))","decl":"@[deprecated (since := \"2025-01-21\")] alias lintegral_nnnorm_neg := lintegral_enorm_neg\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_def","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎµ : Type u_4\ninstâœ : ENorm Îµ\nxâœ : MeasurableSpace Î±\nf : Î± â†’ Îµ\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) Top.top)","decl":"theorem hasFiniteIntegral_def {_ : MeasurableSpace Î±} (f : Î± â†’ Îµ) (Î¼ : Measure Î±) :\n    HasFiniteIntegral f Î¼ â†” (âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ < âˆ) :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_enorm","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) Top.top)","decl":"theorem hasFiniteIntegral_iff_enorm {f : Î± â†’ Î²} : HasFiniteIntegral f Î¼ â†” âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ < âˆ := by\n  simp only [HasFiniteIntegral, ofReal_norm_eq_enorm, enorm_eq_nnnorm]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_nnnorm","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a)) Top.top)","decl":"@[deprecated (since := \"2025-01-20\")]\nalias hasFiniteIntegral_iff_nnnorm := hasFiniteIntegral_iff_enorm\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_norm","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (Norm.norm (f a))) Top.top)","decl":"theorem hasFiniteIntegral_iff_norm (f : Î± â†’ Î²) :\n    HasFiniteIntegral f Î¼ â†” (âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼) < âˆ := by\n  simp only [hasFiniteIntegral_iff_enorm, ofReal_norm_eq_enorm]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_edist","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) 0) Top.top)","decl":"theorem hasFiniteIntegral_iff_edist (f : Î± â†’ Î²) :\n    HasFiniteIntegral f Î¼ â†” (âˆ«â» a, edist (f a) 0 âˆ‚Î¼) < âˆ := by\n  simp only [hasFiniteIntegral_iff_norm, edist_dist, dist_zero_right]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_ofReal","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (f a)) Top.top)","decl":"theorem hasFiniteIntegral_iff_ofReal {f : Î± â†’ â„} (h : 0 â‰¤áµ[Î¼] f) :\n    HasFiniteIntegral f Î¼ â†” (âˆ«â» a, ENNReal.ofReal (f a) âˆ‚Î¼) < âˆ := by\n  rw [hasFiniteIntegral_iff_enorm, lintegral_enorm_of_ae_nonneg h]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_iff_ofNNReal","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ NNReal\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (fun x => â†‘(f x)) Î¼) (LT.lt (MeasureTheory.lintegral Î¼ fun a => â†‘(f a)) Top.top)","decl":"theorem hasFiniteIntegral_iff_ofNNReal {f : Î± â†’ â„â‰¥0} :\n    HasFiniteIntegral (fun x => (f x : â„)) Î¼ â†” (âˆ«â» a, f a âˆ‚Î¼) < âˆ := by\n  simp [hasFiniteIntegral_iff_norm]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.mono","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhg : MeasureTheory.HasFiniteIntegral g Î¼\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem HasFiniteIntegral.mono {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hg : HasFiniteIntegral g Î¼)\n    (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– â‰¤ â€–g aâ€–) : HasFiniteIntegral f Î¼ := by\n  simp only [hasFiniteIntegral_iff_norm] at *\n  calc\n    (âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼) â‰¤ âˆ«â» a : Î±, ENNReal.ofReal â€–g aâ€– âˆ‚Î¼ :=\n      lintegral_mono_ae (h.mono fun a h => ofReal_le_ofReal h)\n    _ < âˆ := hg\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.mono'","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\ng : Î± â†’ Real\nhg : MeasureTheory.HasFiniteIntegral g Î¼\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (g a)) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem HasFiniteIntegral.mono' {f : Î± â†’ Î²} {g : Î± â†’ â„} (hg : HasFiniteIntegral g Î¼)\n    (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– â‰¤ g a) : HasFiniteIntegral f Î¼ :=\n  hg.mono <| h.mono fun _x hx => le_trans hx (le_abs_self _)\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.congr'","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : MeasureTheory.HasFiniteIntegral f Î¼\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral g Î¼","decl":"theorem HasFiniteIntegral.congr' {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : HasFiniteIntegral f Î¼)\n    (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– = â€–g aâ€–) : HasFiniteIntegral g Î¼ :=\n  hf.mono <| EventuallyEq.le <| EventuallyEq.symm h\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_congr'","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (MeasureTheory.HasFiniteIntegral g Î¼)","decl":"theorem hasFiniteIntegral_congr' {f : Î± â†’ Î²} {g : Î± â†’ Î³} (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– = â€–g aâ€–) :\n    HasFiniteIntegral f Î¼ â†” HasFiniteIntegral g Î¼ :=\n  âŸ¨fun hf => hf.congr' h, fun hg => hg.congr' <| EventuallyEq.symm hâŸ©\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.congr","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.HasFiniteIntegral f Î¼\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ MeasureTheory.HasFiniteIntegral g Î¼","decl":"theorem HasFiniteIntegral.congr {f g : Î± â†’ Î²} (hf : HasFiniteIntegral f Î¼) (h : f =áµ[Î¼] g) :\n    HasFiniteIntegral g Î¼ :=\n  hf.congr' <| h.fun_comp norm\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_congr","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f Î¼) (MeasureTheory.HasFiniteIntegral g Î¼)","decl":"theorem hasFiniteIntegral_congr {f g : Î± â†’ Î²} (h : f =áµ[Î¼] g) :\n    HasFiniteIntegral f Î¼ â†” HasFiniteIntegral g Î¼ :=\n  hasFiniteIntegral_congr' <| h.fun_comp norm\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nc : Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (fun x => c) Î¼) (Or (Eq c 0) (MeasureTheory.IsFiniteMeasure Î¼))","decl":"theorem hasFiniteIntegral_const_iff {c : Î²} :\n    HasFiniteIntegral (fun _ : Î± => c) Î¼ â†” c = 0 âˆ¨ IsFiniteMeasure Î¼ := by\n  simp [hasFiniteIntegral_iff_enorm, lintegral_const, lt_top_iff_ne_top, ENNReal.mul_eq_top,\n    or_iff_not_imp_left, isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_const_iff_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nc : Î²\nhc : Ne c 0\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (fun x => c) Î¼) (MeasureTheory.IsFiniteMeasure Î¼)","decl":"lemma hasFiniteIntegral_const_iff_isFiniteMeasure {c : Î²} (hc : c â‰  0) :\n    HasFiniteIntegral (fun _ â†¦ c) Î¼ â†” IsFiniteMeasure Î¼ := by\n  simp [hasFiniteIntegral_const_iff, hc, isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_const","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nc : Î²\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun x => c) Î¼","decl":"theorem hasFiniteIntegral_const [IsFiniteMeasure Î¼] (c : Î²) :\n    HasFiniteIntegral (fun _ : Î± => c) Î¼ :=\n  hasFiniteIntegral_const_iff.2 <| .inr â€¹_â€º\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.of_mem_Icc","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\na b : Real\nX : Î± â†’ Real\nh : Filter.Eventually (fun Ï‰ => Membership.mem (Set.Icc a b) (X Ï‰)) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral X Î¼","decl":"theorem HasFiniteIntegral.of_mem_Icc [IsFiniteMeasure Î¼] (a b : â„) {X : Î± â†’ â„}\n    (h : âˆ€áµ Ï‰ âˆ‚Î¼, X Ï‰ âˆˆ Set.Icc a b) :\n    HasFiniteIntegral X Î¼ := by\n  apply (hasFiniteIntegral_const (max â€–aâ€– â€–bâ€–)).mono'\n  filter_upwards [h.mono fun Ï‰ h â†¦ h.1, h.mono fun Ï‰ h â†¦ h.2] with Ï‰ using abs_le_max_abs_abs\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_of_bounded","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nC : Real\nhC : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) C) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem hasFiniteIntegral_of_bounded [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} {C : â„}\n    (hC : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– â‰¤ C) : HasFiniteIntegral f Î¼ :=\n  (hasFiniteIntegral_const C).mono' hC\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.of_finite","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup Î²\ninstâœÂ¹ : Finite Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem HasFiniteIntegral.of_finite [Finite Î±] [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} :\n    HasFiniteIntegral f Î¼ :=\n  let âŸ¨_âŸ© := nonempty_fintype Î±\n  hasFiniteIntegral_of_bounded <| ae_of_all Î¼ <| norm_le_pi_norm f\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.mono_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.HasFiniteIntegral f Î½\nhÎ¼ : LE.le Î¼ Î½\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem HasFiniteIntegral.mono_measure {f : Î± â†’ Î²} (h : HasFiniteIntegral f Î½) (hÎ¼ : Î¼ â‰¤ Î½) :\n    HasFiniteIntegral f Î¼ :=\n  lt_of_le_of_lt (lintegral_mono' hÎ¼ le_rfl) h\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhÎ¼ : MeasureTheory.HasFiniteIntegral f Î¼\nhÎ½ : MeasureTheory.HasFiniteIntegral f Î½\nâŠ¢ MeasureTheory.HasFiniteIntegral f (HAdd.hAdd Î¼ Î½)","decl":"theorem HasFiniteIntegral.add_measure {f : Î± â†’ Î²} (hÎ¼ : HasFiniteIntegral f Î¼)\n    (hÎ½ : HasFiniteIntegral f Î½) : HasFiniteIntegral f (Î¼ + Î½) := by\n  simp only [HasFiniteIntegral, lintegral_add_measure] at *\n  exact add_lt_top.2 âŸ¨hÎ¼, hÎ½âŸ©\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.left_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.HasFiniteIntegral f (HAdd.hAdd Î¼ Î½)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem HasFiniteIntegral.left_of_add_measure {f : Î± â†’ Î²} (h : HasFiniteIntegral f (Î¼ + Î½)) :\n    HasFiniteIntegral f Î¼ :=\n  h.mono_measure <| Measure.le_add_right <| le_rfl\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.right_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.HasFiniteIntegral f (HAdd.hAdd Î¼ Î½)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î½","decl":"theorem HasFiniteIntegral.right_of_add_measure {f : Î± â†’ Î²} (h : HasFiniteIntegral f (Î¼ + Î½)) :\n    HasFiniteIntegral f Î½ :=\n  h.mono_measure <| Measure.le_add_left <| le_rfl\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f (HAdd.hAdd Î¼ Î½)) (And (MeasureTheory.HasFiniteIntegral f Î¼) (MeasureTheory.HasFiniteIntegral f Î½))","decl":"@[simp]\ntheorem hasFiniteIntegral_add_measure {f : Î± â†’ Î²} :\n    HasFiniteIntegral f (Î¼ + Î½) â†” HasFiniteIntegral f Î¼ âˆ§ HasFiniteIntegral f Î½ :=\n  âŸ¨fun h => âŸ¨h.left_of_add_measure, h.right_of_add_measureâŸ©, fun h => h.1.add_measure h.2âŸ©\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.HasFiniteIntegral f Î¼\nc : ENNReal\nhc : Ne c Top.top\nâŠ¢ MeasureTheory.HasFiniteIntegral f (HSMul.hSMul c Î¼)","decl":"theorem HasFiniteIntegral.smul_measure {f : Î± â†’ Î²} (h : HasFiniteIntegral f Î¼) {c : â„â‰¥0âˆ}\n    (hc : c â‰  âˆ) : HasFiniteIntegral f (c â€¢ Î¼) := by\n  simp only [HasFiniteIntegral, lintegral_smul_measure] at *\n  exact mul_lt_top hc.lt_top h\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_zero_measure","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : NormedAddCommGroup Î²\nm : MeasurableSpace Î±\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.HasFiniteIntegral f 0","decl":"@[simp]\ntheorem hasFiniteIntegral_zero_measure {m : MeasurableSpace Î±} (f : Î± â†’ Î²) :\n    HasFiniteIntegral f (0 : Measure Î±) := by\n  simp only [HasFiniteIntegral, lintegral_zero_measure, zero_lt_top]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_zero","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun x => 0) Î¼","decl":"@[simp]\ntheorem hasFiniteIntegral_zero : HasFiniteIntegral (fun _ : Î± => (0 : Î²)) Î¼ := by\n  simp [hasFiniteIntegral_iff_enorm]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.neg","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhfi : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (Neg.neg f) Î¼","decl":"theorem HasFiniteIntegral.neg {f : Î± â†’ Î²} (hfi : HasFiniteIntegral f Î¼) :\n    HasFiniteIntegral (-f) Î¼ := by simpa [hasFiniteIntegral_iff_enorm] using hfi\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_neg_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (Neg.neg f) Î¼) (MeasureTheory.HasFiniteIntegral f Î¼)","decl":"@[simp]\ntheorem hasFiniteIntegral_neg_iff {f : Î± â†’ Î²} : HasFiniteIntegral (-f) Î¼ â†” HasFiniteIntegral f Î¼ :=\n  âŸ¨fun h => neg_neg f â–¸ h.neg, HasFiniteIntegral.negâŸ©\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.norm","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhfi : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun a => Norm.norm (f a)) Î¼","decl":"theorem HasFiniteIntegral.norm {f : Î± â†’ Î²} (hfi : HasFiniteIntegral f Î¼) :\n    HasFiniteIntegral (fun a => â€–f aâ€–) Î¼ := by simpa [hasFiniteIntegral_iff_enorm] using hfi\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_norm_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (fun a => Norm.norm (f a)) Î¼) (MeasureTheory.HasFiniteIntegral f Î¼)","decl":"theorem hasFiniteIntegral_norm_iff (f : Î± â†’ Î²) :\n    HasFiniteIntegral (fun a => â€–f aâ€–) Î¼ â†” HasFiniteIntegral f Î¼ :=\n  hasFiniteIntegral_congr' <| Eventually.of_forall fun x => norm_norm (f x)\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_toReal_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun x => (f x).toReal) Î¼","decl":"theorem hasFiniteIntegral_toReal_of_lintegral_ne_top {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) :\n    HasFiniteIntegral (fun x â†¦ (f x).toReal) Î¼ := by\n  have h x : â€–(f x).toRealâ€–â‚‘ = .ofReal (f x).toReal := by\n    rw [Real.enorm_of_nonneg ENNReal.toReal_nonneg]\n  simp_rw [hasFiniteIntegral_iff_enorm, h]\n  refine lt_of_le_of_lt (lintegral_mono fun x => ?_) (lt_top_iff_ne_top.2 hf)\n  by_cases hfx : f x = âˆ\n  Â· simp [hfx]\n  Â· lift f x to â„â‰¥0 using hfx with fx h\n    simp [â† h, â† NNReal.coe_le_coe]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_toReal_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae Î¼)\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (fun x => (f x).toReal) Î¼) (Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top)","decl":"lemma hasFiniteIntegral_toReal_iff {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€áµ x âˆ‚Î¼, f x â‰  âˆ) :\n    HasFiniteIntegral (fun x â†¦ (f x).toReal) Î¼ â†” âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ := by\n  have : âˆ€áµ x âˆ‚Î¼, .ofReal (f x).toReal = f x := by filter_upwards [hf] with x hx; simp [hx]\n  simp [hasFiniteIntegral_iff_enorm, Real.enorm_of_nonneg ENNReal.toReal_nonneg,\n    lintegral_congr_ae this, lt_top_iff_ne_top]\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_withDensity_ofReal","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhfi : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.IsFiniteMeasure (Î¼.withDensity fun x => ENNReal.ofReal (f x))","decl":"theorem isFiniteMeasure_withDensity_ofReal {f : Î± â†’ â„} (hfi : HasFiniteIntegral f Î¼) :\n    IsFiniteMeasure (Î¼.withDensity fun x => ENNReal.ofReal <| f x) := by\n  refine isFiniteMeasure_withDensity ((lintegral_mono fun x => ?_).trans_lt hfi).ne\n  exact Real.ofReal_le_enorm (f x)\n\n"}
{"name":"MeasureTheory.all_ae_ofReal_F_le_bound","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nF : Nat â†’ Î± â†’ Î²\nbound : Î± â†’ Real\nh : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)\nn : Nat\nâŠ¢ Filter.Eventually (fun a => LE.le (ENNReal.ofReal (Norm.norm (F n a))) (ENNReal.ofReal (bound a))) (MeasureTheory.ae Î¼)","decl":"theorem all_ae_ofReal_F_le_bound (h : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a) :\n    âˆ€ n, âˆ€áµ a âˆ‚Î¼, ENNReal.ofReal â€–F n aâ€– â‰¤ ENNReal.ofReal (bound a) := fun n =>\n  (h n).mono fun _ h => ENNReal.ofReal_le_ofReal h\n\n"}
{"name":"MeasureTheory.all_ae_tendsto_ofReal_norm","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nF : Nat â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nh : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun n => ENNReal.ofReal (Norm.norm (F n a))) Filter.atTop (nhds (ENNReal.ofReal (Norm.norm (f a))))) (MeasureTheory.ae Î¼)","decl":"theorem all_ae_tendsto_ofReal_norm (h : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop <| ğ“ <| f a) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => ENNReal.ofReal â€–F n aâ€–) atTop <| ğ“ <| ENNReal.ofReal â€–f aâ€– :=\n  h.mono fun _ h => tendsto_ofReal <| Tendsto.comp (Continuous.tendsto continuous_norm _) h\n\n"}
{"name":"MeasureTheory.all_ae_ofReal_f_le_bound","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nF : Nat â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nbound : Î± â†’ Real\nh_bound : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun a => LE.le (ENNReal.ofReal (Norm.norm (f a))) (ENNReal.ofReal (bound a))) (MeasureTheory.ae Î¼)","decl":"theorem all_ae_ofReal_f_le_bound (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) :\n    âˆ€áµ a âˆ‚Î¼, ENNReal.ofReal â€–f aâ€– â‰¤ ENNReal.ofReal (bound a) := by\n  have F_le_bound := all_ae_ofReal_F_le_bound h_bound\n  rw [â† ae_all_iff] at F_le_bound\n  apply F_le_bound.mp ((all_ae_tendsto_ofReal_norm h_lim).mono _)\n  intro a tendsto_norm F_le_bound\n  exact le_of_tendsto' tendsto_norm F_le_bound\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nF : Nat â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nbound : Î± â†’ Real\nbound_hasFiniteIntegral : MeasureTheory.HasFiniteIntegral bound Î¼\nh_bound : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem hasFiniteIntegral_of_dominated_convergence {F : â„• â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {bound : Î± â†’ â„}\n    (bound_hasFiniteIntegral : HasFiniteIntegral bound Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) : HasFiniteIntegral f Î¼ := by\n  /- `â€–F n aâ€– â‰¤ bound a` and `â€–F n aâ€– --> â€–f aâ€–` implies `â€–f aâ€– â‰¤ bound a`,\n    and so `âˆ« â€–fâ€– â‰¤ âˆ« bound < âˆ` since `bound` is has_finite_integral -/\n  rw [hasFiniteIntegral_iff_norm]\n  calc\n    (âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼) â‰¤ âˆ«â» a, ENNReal.ofReal (bound a) âˆ‚Î¼ :=\n      lintegral_mono_ae <| all_ae_ofReal_f_le_bound h_bound h_lim\n    _ < âˆ := by\n      rw [â† hasFiniteIntegral_iff_ofReal]\n      Â· exact bound_hasFiniteIntegral\n      exact (h_bound 0).mono fun a h => le_trans (norm_nonneg _) h\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_norm_of_dominated_convergence","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nF : Nat â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nbound : Î± â†’ Real\nF_measurable : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (F n) Î¼\nbound_hasFiniteIntegral : MeasureTheory.HasFiniteIntegral bound Î¼\nh_bound : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (Norm.norm (HSub.hSub (F n a) (f a)))) Filter.atTop (nhds 0)","decl":"theorem tendsto_lintegral_norm_of_dominated_convergence {F : â„• â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {bound : Î± â†’ â„}\n    (F_measurable : âˆ€ n, AEStronglyMeasurable (F n) Î¼)\n    (bound_hasFiniteIntegral : HasFiniteIntegral bound Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => âˆ«â» a, ENNReal.ofReal â€–F n a - f aâ€– âˆ‚Î¼) atTop (ğ“ 0) := by\n  have f_measurable : AEStronglyMeasurable f Î¼ :=\n    aestronglyMeasurable_of_tendsto_ae _ F_measurable h_lim\n  let b a := 2 * ENNReal.ofReal (bound a)\n  /- `â€–F n aâ€– â‰¤ bound a` and `F n a --> f a` implies `â€–f aâ€– â‰¤ bound a`, and thus by the\n    triangle inequality, have `â€–F n a - f aâ€– â‰¤ 2 * (bound a)`. -/\n  have hb : âˆ€ n, âˆ€áµ a âˆ‚Î¼, ENNReal.ofReal â€–F n a - f aâ€– â‰¤ b a := by\n    intro n\n    filter_upwards [all_ae_ofReal_F_le_bound h_bound n,\n      all_ae_ofReal_f_le_bound h_bound h_lim] with a hâ‚ hâ‚‚\n    calc\n      ENNReal.ofReal â€–F n a - f aâ€– â‰¤ ENNReal.ofReal â€–F n aâ€– + ENNReal.ofReal â€–f aâ€– := by\n        rw [â† ENNReal.ofReal_add]\n        Â· apply ofReal_le_ofReal\n          apply norm_sub_le\n        Â· exact norm_nonneg _\n        Â· exact norm_nonneg _\n      _ â‰¤ ENNReal.ofReal (bound a) + ENNReal.ofReal (bound a) := add_le_add hâ‚ hâ‚‚\n      _ = b a := by rw [â† two_mul]\n  -- On the other hand, `F n a --> f a` implies that `â€–F n a - f aâ€– --> 0`\n  have h : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => ENNReal.ofReal â€–F n a - f aâ€–) atTop (ğ“ 0) := by\n    rw [â† ENNReal.ofReal_zero]\n    refine h_lim.mono fun a h => (continuous_ofReal.tendsto _).comp ?_\n    rwa [â† tendsto_iff_norm_sub_tendsto_zero]\n  /- Therefore, by the dominated convergence theorem for nonnegative integration, have\n    ` âˆ« â€–f a - F n aâ€– --> 0 ` -/\n  suffices Tendsto (fun n => âˆ«â» a, ENNReal.ofReal â€–F n a - f aâ€– âˆ‚Î¼) atTop (ğ“ (âˆ«â» _ : Î±, 0 âˆ‚Î¼)) by\n    rwa [lintegral_zero] at this\n  -- Using the dominated convergence theorem.\n  refine tendsto_lintegral_of_dominated_convergence' _ ?_ hb ?_ ?_\n  -- Show `fun a => â€–f a - F n aâ€–` is almost everywhere measurable for all `n`\n  Â· exact fun n =>\n      measurable_ofReal.comp_aemeasurable ((F_measurable n).sub f_measurable).norm.aemeasurable\n  -- Show `2 * bound` `HasFiniteIntegral`\n  Â· rw [hasFiniteIntegral_iff_ofReal] at bound_hasFiniteIntegral\n    Â· calc\n        âˆ«â» a, b a âˆ‚Î¼ = 2 * âˆ«â» a, ENNReal.ofReal (bound a) âˆ‚Î¼ := by\n          rw [lintegral_const_mul']\n          exact coe_ne_top\n        _ â‰  âˆ := mul_ne_top coe_ne_top bound_hasFiniteIntegral.ne\n    filter_upwards [h_bound 0] with _ h using le_trans (norm_nonneg _) h\n  -- Show `â€–f a - F n aâ€– --> 0`\n  Â· exact h\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.max_zero","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun a => Max.max (f a) 0) Î¼","decl":"theorem HasFiniteIntegral.max_zero {f : Î± â†’ â„} (hf : HasFiniteIntegral f Î¼) :\n    HasFiniteIntegral (fun a => max (f a) 0) Î¼ :=\n  hf.mono <| Eventually.of_forall fun x => by simp [abs_le, le_abs_self]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.min_zero","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun a => Min.min (f a) 0) Î¼","decl":"theorem HasFiniteIntegral.min_zero {f : Î± â†’ â„} (hf : HasFiniteIntegral f Î¼) :\n    HasFiniteIntegral (fun a => min (f a) 0) Î¼ :=\n  hf.mono <| Eventually.of_forall fun x => by simpa [abs_le] using neg_abs_le _\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.smul","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_5\ninstâœÂ² : NormedAddCommGroup ğ•œ\ninstâœÂ¹ : SMulZeroClass ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nf : Î± â†’ Î²\naâœ : MeasureTheory.HasFiniteIntegral f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (HSMul.hSMul c f) Î¼","decl":"theorem HasFiniteIntegral.smul [NormedAddCommGroup ğ•œ] [SMulZeroClass ğ•œ Î²] [BoundedSMul ğ•œ Î²] (c : ğ•œ)\n    {f : Î± â†’ Î²} : HasFiniteIntegral f Î¼ â†’ HasFiniteIntegral (c â€¢ f) Î¼ := by\n  simp only [HasFiniteIntegral]; intro hfi\n  calc\n    âˆ«â» a : Î±, â€–c â€¢ f aâ€–â‚‘ âˆ‚Î¼ â‰¤ âˆ«â» a : Î±, â€–câ€–â‚‘ * â€–f aâ€–â‚‘ âˆ‚Î¼ := lintegral_mono fun i â†¦ enorm_smul_le\n    _ < âˆ := by\n      rw [lintegral_const_mul']\n      exacts [mul_lt_top coe_lt_top hfi, coe_ne_top]\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_smul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_5\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : MulActionWithZero ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nhc : IsUnit c\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral (HSMul.hSMul c f) Î¼) (MeasureTheory.HasFiniteIntegral f Î¼)","decl":"theorem hasFiniteIntegral_smul_iff [NormedRing ğ•œ] [MulActionWithZero ğ•œ Î²] [BoundedSMul ğ•œ Î²] {c : ğ•œ}\n    (hc : IsUnit c) (f : Î± â†’ Î²) : HasFiniteIntegral (c â€¢ f) Î¼ â†” HasFiniteIntegral f Î¼ := by\n  obtain âŸ¨c, rflâŸ© := hc\n  constructor\n  Â· intro h\n    simpa only [smul_smul, Units.inv_mul, one_smul] using h.smul ((câ»Â¹ : ğ•œË£) : ğ•œ)\n  exact HasFiniteIntegral.smul _\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.const_mul","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_5\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.HasFiniteIntegral f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun x => HMul.hMul c (f x)) Î¼","decl":"theorem HasFiniteIntegral.const_mul [NormedRing ğ•œ] {f : Î± â†’ ğ•œ} (h : HasFiniteIntegral f Î¼) (c : ğ•œ) :\n    HasFiniteIntegral (fun x => c * f x) Î¼ :=\n  h.smul c\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.mul_const","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_5\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.HasFiniteIntegral f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun x => HMul.hMul (f x) c) Î¼","decl":"theorem HasFiniteIntegral.mul_const [NormedRing ğ•œ] {f : Î± â†’ ğ•œ} (h : HasFiniteIntegral f Î¼) (c : ğ•œ) :\n    HasFiniteIntegral (fun x => f x * c) Î¼ :=\n  h.smul (MulOpposite.op c)\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_count_iff","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f MeasureTheory.Measure.count) (Summable fun x => Norm.norm (f x))","decl":"/-- A function has finite integral for the counting measure iff its norm is summable. -/\nlemma hasFiniteIntegral_count_iff :\n    HasFiniteIntegral f Measure.count â†” Summable (â€–f Â·â€–) := by\n  simp only [hasFiniteIntegral_iff_enorm, enorm, lintegral_count, lt_top_iff_ne_top,\n    tsum_coe_ne_top_iff_summable, â† summable_coe, coe_nnnorm]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.restrict","module":"Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœ : NormedAddCommGroup E\nf : Î± â†’ E\nh : MeasureTheory.HasFiniteIntegral f Î¼\ns : Set Î±\nâŠ¢ MeasureTheory.HasFiniteIntegral f (Î¼.restrict s)","decl":"lemma HasFiniteIntegral.restrict (h : HasFiniteIntegral f Î¼) {s : Set Î±} :\n    HasFiniteIntegral f (Î¼.restrict s) := by\n  refine lt_of_le_of_lt ?_ h\n  simpa [Measure.restrict_univ] using lintegral_mono_set (subset_univ s)\n\n"}
