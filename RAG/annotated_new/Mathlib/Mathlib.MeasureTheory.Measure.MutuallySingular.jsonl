{"name":"MeasureTheory.Measure.MutuallySingular.mk","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nhs : Eq (μ s) 0\nht : Eq (ν t) 0\nhst : HasSubset.Subset Set.univ (Union.union s t)\n⊢ μ.MutuallySingular ν","decl":"theorem mk {s t : Set α} (hs : μ s = 0) (ht : ν t = 0) (hst : univ ⊆ s ∪ t) :\n    MutuallySingular μ ν := by\n  use toMeasurable μ s, measurableSet_toMeasurable _ _, (measure_toMeasurable _).trans hs\n  refine measure_mono_null (fun x hx => (hst trivial).resolve_left fun hxs => hx ?_) ht\n  exact subset_toMeasurable _ _ hxs\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.measurableSet_nullSet","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ MeasurableSet h.nullSet","decl":"lemma measurableSet_nullSet (h : μ ⟂ₘ ν) : MeasurableSet h.nullSet := h.choose_spec.1\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.measure_nullSet","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Eq (μ h.nullSet) 0","decl":"@[simp]\nlemma measure_nullSet (h : μ ⟂ₘ ν) : μ h.nullSet = 0 := h.choose_spec.2.1\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.measure_compl_nullSet","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Eq (ν (HasCompl.compl h.nullSet)) 0","decl":"@[simp]\nlemma measure_compl_nullSet (h : μ ⟂ₘ ν) : ν h.nullSetᶜ = 0 := h.choose_spec.2.2\n\n-- TODO: this is proved by simp, but is not simplified in other contexts without the @[simp]\n-- attribute. Also, the linter does not complain about that attribute.\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.restrict_nullSet","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Eq (μ.restrict h.nullSet) 0","decl":"@[simp]\nlemma restrict_nullSet (h : μ ⟂ₘ ν) : μ.restrict h.nullSet = 0 := by simp\n\n-- TODO: this is proved by simp, but is not simplified in other contexts without the @[simp]\n-- attribute. Also, the linter does not complain about that attribute.\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.restrict_compl_nullSet","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Eq (ν.restrict (HasCompl.compl h.nullSet)) 0","decl":"@[simp]\nlemma restrict_compl_nullSet (h : μ ⟂ₘ ν) : ν.restrict h.nullSetᶜ = 0 := by simp\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.zero_right","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ μ.MutuallySingular 0","decl":"@[simp]\ntheorem zero_right : μ ⟂ₘ 0 :=\n  ⟨∅, MeasurableSet.empty, measure_empty, rfl⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.symm","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : ν.MutuallySingular μ\n⊢ μ.MutuallySingular ν","decl":"@[symm]\ntheorem symm (h : ν ⟂ₘ μ) : μ ⟂ₘ ν :=\n  let ⟨i, hi, his, hit⟩ := h\n  ⟨iᶜ, hi.compl, hit, (compl_compl i).symm ▸ his⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.comm","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular ν) (ν.MutuallySingular μ)","decl":"theorem comm : μ ⟂ₘ ν ↔ ν ⟂ₘ μ :=\n  ⟨fun h => h.symm, fun h => h.symm⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.zero_left","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Measure.MutuallySingular 0 μ","decl":"@[simp]\ntheorem zero_left : 0 ⟂ₘ μ :=\n  zero_right.symm\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.mono_ac","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ ν₁ ν₂ : MeasureTheory.Measure α\nh : μ₁.MutuallySingular ν₁\nhμ : μ₂.AbsolutelyContinuous μ₁\nhν : ν₂.AbsolutelyContinuous ν₁\n⊢ μ₂.MutuallySingular ν₂","decl":"theorem mono_ac (h : μ₁ ⟂ₘ ν₁) (hμ : μ₂ ≪ μ₁) (hν : ν₂ ≪ ν₁) : μ₂ ⟂ₘ ν₂ :=\n  let ⟨s, hs, h₁, h₂⟩ := h\n  ⟨s, hs, hμ h₁, hν h₂⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.congr_ac","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ μ₂ ν ν₂ : MeasureTheory.Measure α\nhμμ₂ : μ.AbsolutelyContinuous μ₂\nhμ₂μ : μ₂.AbsolutelyContinuous μ\nhνν₂ : ν.AbsolutelyContinuous ν₂\nhν₂ν : ν₂.AbsolutelyContinuous ν\n⊢ Iff (μ.MutuallySingular ν) (μ₂.MutuallySingular ν₂)","decl":"lemma congr_ac (hμμ₂ : μ ≪ μ₂) (hμ₂μ : μ₂ ≪ μ) (hνν₂ : ν ≪ ν₂) (hν₂ν : ν₂ ≪ ν) :\n    μ ⟂ₘ ν ↔ μ₂ ⟂ₘ ν₂ :=\n  ⟨fun h ↦ h.mono_ac hμ₂μ hν₂ν, fun h ↦ h.mono_ac hμμ₂ hνν₂⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.mono","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ ν₁ ν₂ : MeasureTheory.Measure α\nh : μ₁.MutuallySingular ν₁\nhμ : LE.le μ₂ μ₁\nhν : LE.le ν₂ ν₁\n⊢ μ₂.MutuallySingular ν₂","decl":"theorem mono (h : μ₁ ⟂ₘ ν₁) (hμ : μ₂ ≤ μ₁) (hν : ν₂ ≤ ν₁) : μ₂ ⟂ₘ ν₂ :=\n  h.mono_ac hμ.absolutelyContinuous hν.absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.self_iff","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular μ) (Eq μ 0)","decl":"@[simp]\nlemma self_iff (μ : Measure α) : μ ⟂ₘ μ ↔ μ = 0 := by\n  refine ⟨?_, fun h ↦ by (rw [h]; exact zero_left)⟩\n  rintro ⟨s, hs, hμs, hμs_compl⟩\n  suffices μ Set.univ = 0 by rwa [measure_univ_eq_zero] at this\n  rw [← Set.union_compl_self s, measure_union disjoint_compl_right hs.compl, hμs, hμs_compl,\n    add_zero]\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.sum_left","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nν : MeasureTheory.Measure α\nι : Type u_2\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\n⊢ Iff ((MeasureTheory.Measure.sum μ).MutuallySingular ν) (∀ (i : ι), (μ i).MutuallySingular ν)","decl":"@[simp]\ntheorem sum_left {ι : Type*} [Countable ι] {μ : ι → Measure α} : sum μ ⟂ₘ ν ↔ ∀ i, μ i ⟂ₘ ν := by\n  refine ⟨fun h i => h.mono (le_sum _ _) le_rfl, fun H => ?_⟩\n  choose s hsm hsμ hsν using H\n  refine ⟨⋂ i, s i, MeasurableSet.iInter hsm, ?_, ?_⟩\n  · rw [sum_apply _ (MeasurableSet.iInter hsm), ENNReal.tsum_eq_zero]\n    exact fun i => measure_mono_null (iInter_subset _ _) (hsμ i)\n  · rwa [compl_iInter, measure_iUnion_null_iff]\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.sum_right","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_2\ninst✝ : Countable ι\nν : ι → MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular (MeasureTheory.Measure.sum ν)) (∀ (i : ι), μ.MutuallySingular (ν i))","decl":"@[simp]\ntheorem sum_right {ι : Type*} [Countable ι] {ν : ι → Measure α} : μ ⟂ₘ sum ν ↔ ∀ i, μ ⟂ₘ ν i :=\n  comm.trans <| sum_left.trans <| forall_congr' fun _ => comm\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.add_left_iff","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ ν : MeasureTheory.Measure α\n⊢ Iff ((HAdd.hAdd μ₁ μ₂).MutuallySingular ν) (And (μ₁.MutuallySingular ν) (μ₂.MutuallySingular ν))","decl":"@[simp]\ntheorem add_left_iff : μ₁ + μ₂ ⟂ₘ ν ↔ μ₁ ⟂ₘ ν ∧ μ₂ ⟂ₘ ν := by\n  rw [← sum_cond, sum_left, Bool.forall_bool, cond, cond, and_comm]\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.add_right_iff","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular (HAdd.hAdd ν₁ ν₂)) (And (μ.MutuallySingular ν₁) (μ.MutuallySingular ν₂))","decl":"@[simp]\ntheorem add_right_iff : μ ⟂ₘ ν₁ + ν₂ ↔ μ ⟂ₘ ν₁ ∧ μ ⟂ₘ ν₂ :=\n  comm.trans <| add_left_iff.trans <| and_congr comm comm\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.add_left","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\nh₁ : ν₁.MutuallySingular μ\nh₂ : ν₂.MutuallySingular μ\n⊢ (HAdd.hAdd ν₁ ν₂).MutuallySingular μ","decl":"theorem add_left (h₁ : ν₁ ⟂ₘ μ) (h₂ : ν₂ ⟂ₘ μ) : ν₁ + ν₂ ⟂ₘ μ :=\n  add_left_iff.2 ⟨h₁, h₂⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.add_right","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\nh₁ : μ.MutuallySingular ν₁\nh₂ : μ.MutuallySingular ν₂\n⊢ μ.MutuallySingular (HAdd.hAdd ν₁ ν₂)","decl":"theorem add_right (h₁ : μ ⟂ₘ ν₁) (h₂ : μ ⟂ₘ ν₂) : μ ⟂ₘ ν₁ + ν₂ :=\n  add_right_iff.2 ⟨h₁, h₂⟩\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.smul","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nr : ENNReal\nh : ν.MutuallySingular μ\n⊢ (HSMul.hSMul r ν).MutuallySingular μ","decl":"theorem smul (r : ℝ≥0∞) (h : ν ⟂ₘ μ) : r • ν ⟂ₘ μ :=\n  h.mono_ac (AbsolutelyContinuous.rfl.smul_left r) AbsolutelyContinuous.rfl\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.smul_nnreal","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nr : NNReal\nh : ν.MutuallySingular μ\n⊢ (HSMul.hSMul r ν).MutuallySingular μ","decl":"theorem smul_nnreal (r : ℝ≥0) (h : ν ⟂ₘ μ) : r • ν ⟂ₘ μ :=\n  h.smul r\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.restrict","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\ns : Set α\n⊢ (μ.restrict s).MutuallySingular ν","decl":"lemma restrict (h : μ ⟂ₘ ν) (s : Set α) : μ.restrict s ⟂ₘ ν := by\n  refine ⟨h.nullSet, h.measurableSet_nullSet, ?_, h.measure_compl_nullSet⟩\n  rw [Measure.restrict_apply h.measurableSet_nullSet]\n  exact measure_mono_null Set.inter_subset_left h.measure_nullSet\n\n"}
{"name":"MeasureTheory.Measure.eq_zero_of_absolutelyContinuous_of_mutuallySingular","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh_ac : μ.AbsolutelyContinuous ν\nh_ms : μ.MutuallySingular ν\n⊢ Eq μ 0","decl":"lemma eq_zero_of_absolutelyContinuous_of_mutuallySingular {μ ν : Measure α}\n    (h_ac : μ ≪ ν) (h_ms : μ ⟂ₘ ν) :\n    μ = 0 := by\n  rw [← Measure.MutuallySingular.self_iff]\n  exact h_ms.mono_ac Measure.AbsolutelyContinuous.rfl h_ac\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_of_add_of_mutuallySingular","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν₁ ν₂ : MeasureTheory.Measure α\nh : μ.AbsolutelyContinuous (HAdd.hAdd ν₁ ν₂)\nh_ms : μ.MutuallySingular ν₂\n⊢ μ.AbsolutelyContinuous ν₁","decl":"lemma absolutelyContinuous_of_add_of_mutuallySingular {ν₁ ν₂ : Measure α}\n    (h : μ ≪ ν₁ + ν₂) (h_ms : μ ⟂ₘ ν₂) : μ ≪ ν₁ := by\n  refine AbsolutelyContinuous.mk fun s hs hs_zero ↦ ?_\n  let t := h_ms.nullSet\n  have ht : MeasurableSet t := h_ms.measurableSet_nullSet\n  have htμ : μ t = 0 := h_ms.measure_nullSet\n  have htν₂ : ν₂ tᶜ = 0 := h_ms.measure_compl_nullSet\n  have : μ s = μ (s ∩ tᶜ) := by\n    conv_lhs => rw [← inter_union_compl s t]\n    rw [measure_union, measure_inter_null_of_null_right _ htμ, zero_add]\n    · exact (disjoint_compl_right.inter_right' _ ).inter_left' _\n    · exact hs.inter ht.compl\n  rw [this]\n  refine h ?_\n  simp only [Measure.coe_add, Pi.add_apply, add_eq_zero]\n  exact ⟨measure_inter_null_of_null_left _ hs_zero, measure_inter_null_of_null_right _ htν₂⟩\n\n"}
{"name":"MeasurableEmbedding.mutuallySingular_map","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nβ : Type u_2\nx✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nhμν : μ.MutuallySingular ν\n⊢ (MeasureTheory.Measure.map f μ).MutuallySingular (MeasureTheory.Measure.map f ν)","decl":"lemma _root_.MeasurableEmbedding.mutuallySingular_map {β : Type*} {_ : MeasurableSpace β}\n    {f : α → β} (hf : MeasurableEmbedding f) (hμν : μ ⟂ₘ ν) :\n    μ.map f ⟂ₘ ν.map f := by\n  refine ⟨f '' hμν.nullSet, hf.measurableSet_image' hμν.measurableSet_nullSet, ?_, ?_⟩\n  · rw [hf.map_apply, hf.injective.preimage_image, hμν.measure_nullSet]\n  · rw [hf.map_apply, Set.preimage_compl, hf.injective.preimage_image, hμν.measure_compl_nullSet]\n\n"}
{"name":"MeasureTheory.Measure.exists_null_set_measure_lt_of_disjoint","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : Disjoint μ ν\nε : NNReal\nhε : LT.lt 0 ε\n⊢ Exists fun s => And (Eq (μ s) 0) (LE.le (ν (HasCompl.compl s)) (HMul.hMul 2 ↑ε))","decl":"lemma exists_null_set_measure_lt_of_disjoint (h : Disjoint μ ν) {ε : ℝ≥0} (hε : 0 < ε) :\n    ∃ s, μ s = 0 ∧ ν sᶜ ≤ 2 * ε := by\n  have h₁ : (μ ⊓ ν) univ = 0 := le_bot_iff.1 (h (inf_le_left (b := ν)) inf_le_right) ▸ rfl\n  simp_rw [Measure.inf_apply MeasurableSet.univ, inter_univ] at h₁\n  have h₂ : ∀ n : ℕ, ∃ t, μ t + ν tᶜ < ε * (1 / 2) ^ n := by\n    intro n\n    obtain ⟨m, ⟨t, ht₁, rfl⟩, hm₂⟩ :\n        ∃ x ∈ {m | ∃ t, m = μ t + ν tᶜ}, x < ε * (1 / 2 : ℝ≥0∞) ^ n := by\n      refine exists_lt_of_csInf_lt ⟨ν univ, ∅, by simp⟩ <| h₁ ▸ ENNReal.mul_pos ?_ (by simp)\n      norm_cast\n      exact hε.ne.symm\n    exact ⟨t, hm₂⟩\n  choose t ht₂ using h₂\n  refine ⟨⋂ n, t n, ?_, ?_⟩\n  · refine eq_zero_of_le_mul_pow (by norm_num)\n      fun n ↦ ((measure_mono <| iInter_subset_of_subset n fun _ ht ↦ ht).trans\n      (le_add_right le_rfl)).trans (ht₂ n).le\n  · rw [compl_iInter, (by simp [ENNReal.tsum_mul_left, mul_comm] :\n      2 * (ε : ℝ≥0∞) = ∑' (n : ℕ), ε * (1 / 2 : ℝ≥0∞) ^ n)]\n    refine (measure_iUnion_le _).trans ?_\n    exact tsum_le_tsum (fun n ↦ (le_add_left le_rfl).trans (ht₂ n).le)\n      ENNReal.summable ENNReal.summable\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_of_disjoint","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : Disjoint μ ν\n⊢ μ.MutuallySingular ν","decl":"lemma mutuallySingular_of_disjoint (h : Disjoint μ ν) : μ ⟂ₘ ν := by\n  have h' (n : ℕ) : ∃ s, μ s = 0 ∧ ν sᶜ ≤ (1 / 2) ^ n := by\n    convert exists_null_set_measure_lt_of_disjoint h (ε := (1 / 2) ^ (n + 1))\n      <| pow_pos (by simp) (n + 1)\n    push_cast\n    rw [pow_succ, ← mul_assoc, mul_comm, ← mul_assoc]\n    norm_cast\n    rw [div_mul_cancel₀, one_mul]\n    · push_cast\n      simp\n    · simp\n  choose s hs₂ hs₃ using h'\n  refine Measure.MutuallySingular.mk (t := (⋃ n, s n)ᶜ) (measure_iUnion_null hs₂) ?_ ?_\n  · rw [compl_iUnion]\n    refine eq_zero_of_le_mul_pow (ε := 1) (by norm_num : (1 / 2 : ℝ≥0∞) < 1) <| fun n ↦ ?_\n    rw [ENNReal.coe_one, one_mul]\n    exact (measure_mono <| iInter_subset_of_subset n fun _ ht ↦ ht).trans (hs₃ n)\n  · rw [union_compl_self]\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.disjoint","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Disjoint μ ν","decl":"lemma MutuallySingular.disjoint (h : μ ⟂ₘ ν) : Disjoint μ ν := by\n  have h_bot_iff (ξ : Measure α) : ξ ≤ ⊥ ↔ ξ = 0 := by\n    rw [le_bot_iff]\n    rfl\n  intro ξ hξμ hξν\n  rw [h_bot_iff]\n  ext s hs\n  simp only [Measure.coe_zero, Pi.zero_apply]\n  rw [← inter_union_compl s h.nullSet, measure_union, add_eq_zero]\n  · exact ⟨measure_inter_null_of_null_right _ <| absolutelyContinuous_of_le hξμ h.measure_nullSet,\n      measure_inter_null_of_null_right _ <| absolutelyContinuous_of_le hξν h.measure_compl_nullSet⟩\n  · exact Disjoint.mono inter_subset_right inter_subset_right disjoint_compl_right\n  · exact hs.inter h.measurableSet_nullSet.compl\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.disjoint_ae","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\n⊢ Disjoint (MeasureTheory.ae μ) (MeasureTheory.ae ν)","decl":"lemma MutuallySingular.disjoint_ae (h : μ ⟂ₘ ν) : Disjoint (ae μ) (ae ν) := by\n  rw [disjoint_iff_inf_le]\n  intro s _\n  refine ⟨s ∪ h.nullSetᶜ, ?_, s ∪ h.nullSet, ?_, ?_⟩\n  · rw [mem_ae_iff, compl_union, compl_compl]\n    exact measure_inter_null_of_null_right _ h.measure_nullSet\n  · rw [mem_ae_iff, compl_union]\n    exact measure_inter_null_of_null_right _ h.measure_compl_nullSet\n  · rw [union_eq_compl_compl_inter_compl, union_eq_compl_compl_inter_compl,\n      ← compl_union, compl_compl, inter_union_compl, compl_compl]\n\n"}
{"name":"MeasureTheory.Measure.disjoint_of_disjoint_ae","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : Disjoint (MeasureTheory.ae μ) (MeasureTheory.ae ν)\n⊢ Disjoint μ ν","decl":"lemma disjoint_of_disjoint_ae (h : Disjoint (ae μ) (ae ν)) : Disjoint μ ν := by\n  rw [disjoint_iff_inf_le] at h ⊢\n  refine Measure.le_intro fun s hs _ ↦ ?_\n  rw [Measure.inf_apply hs]\n  have : (⊥ : Measure α) = 0 := rfl\n  simp only [this, Measure.coe_zero, Pi.zero_apply, nonpos_iff_eq_zero]\n  specialize h (mem_bot (s := sᶜ))\n  rw [mem_inf_iff] at h\n  obtain ⟨t₁, ht₁, t₂, ht₂, h_eq'⟩ := h\n  have h_eq : s = t₁ᶜ ∪ t₂ᶜ := by\n    rw [union_eq_compl_compl_inter_compl, compl_compl, compl_compl, ← h_eq', compl_compl]\n  rw [mem_ae_iff] at ht₁ ht₂\n  refine le_antisymm ?_ zero_le'\n  refine sInf_le_of_le (a := 0) (b := 0) ?_ le_rfl\n  rw [h_eq]\n  refine ⟨t₁ᶜ ∩ t₂, Eq.symm ?_⟩\n  rw [add_eq_zero]\n  constructor\n  · refine measure_inter_null_of_null_left _ ?_\n    exact measure_inter_null_of_null_left _ ht₁\n  · rw [compl_inter, compl_compl, union_eq_compl_compl_inter_compl,\n      union_eq_compl_compl_inter_compl, ← compl_union, compl_compl, compl_compl, inter_comm,\n      inter_comm t₁, union_comm, inter_union_compl]\n    exact ht₂\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_tfae","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ (List.cons (μ.MutuallySingular ν) (List.cons (Disjoint μ ν) (List.cons (Disjoint (MeasureTheory.ae μ) (MeasureTheory.ae ν)) List.nil))).TFAE","decl":"lemma mutuallySingular_tfae : List.TFAE\n    [ μ ⟂ₘ ν,\n      Disjoint μ ν,\n      Disjoint (ae μ) (ae ν) ] := by\n  tfae_have 1 → 2\n  | h => h.disjoint\n  tfae_have 2 → 1\n  | h => mutuallySingular_of_disjoint h\n  tfae_have 1 → 3\n  | h => h.disjoint_ae\n  tfae_have 3 → 2\n  | h => disjoint_of_disjoint_ae h\n  tfae_finish\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_iff_disjoint","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular ν) (Disjoint μ ν)","decl":"lemma mutuallySingular_iff_disjoint : μ ⟂ₘ ν ↔ Disjoint μ ν :=\n  mutuallySingular_tfae.out 0 1\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_iff_disjoint_ae","module":"Mathlib.MeasureTheory.Measure.MutuallySingular","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (μ.MutuallySingular ν) (Disjoint (MeasureTheory.ae μ) (MeasureTheory.ae ν))","decl":"lemma mutuallySingular_iff_disjoint_ae : μ ⟂ₘ ν ↔ Disjoint (ae μ) (ae ν) :=\n  mutuallySingular_tfae.out 0 2\n\n"}
