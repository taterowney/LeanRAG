{"name":"IsLeftRegular.isSMulRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\nc : R\nh : IsLeftRegular c\n⊢ IsSMulRegular R c","decl":"theorem IsLeftRegular.isSMulRegular [Mul R] {c : R} (h : IsLeftRegular c) : IsSMulRegular R c :=\n  h\n\n"}
{"name":"isLeftRegular_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\n⊢ Iff (IsLeftRegular a) (IsSMulRegular R a)","decl":"/-- Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself. -/\ntheorem isLeftRegular_iff [Mul R] {a : R} : IsLeftRegular a ↔ IsSMulRegular R a :=\n  Iff.rfl\n\n"}
{"name":"IsRightRegular.isSMulRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\nc : R\nh : IsRightRegular c\n⊢ IsSMulRegular R (MulOpposite.op c)","decl":"theorem IsRightRegular.isSMulRegular [Mul R] {c : R} (h : IsRightRegular c) :\n    IsSMulRegular R (MulOpposite.op c) :=\n  h\n\n"}
{"name":"isRightRegular_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\n⊢ Iff (IsRightRegular a) (IsSMulRegular R (MulOpposite.op a))","decl":"/-- Right-regular multiplication on `R` is equivalent to `Rᵐᵒᵖ`-regularity of `R` itself. -/\ntheorem isRightRegular_iff [Mul R] {a : R} :\n    IsRightRegular a ↔ IsSMulRegular R (MulOpposite.op a) :=\n  Iff.rfl\n\n"}
{"name":"IsSMulRegular.smul","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\na : R\ns : S\ninst✝³ : SMul R M\ninst✝² : SMul R S\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower R S M\nra : IsSMulRegular M a\nrs : IsSMulRegular M s\n⊢ IsSMulRegular M (HSMul.hSMul a s)","decl":"/-- The product of `M`-regular elements is `M`-regular. -/\ntheorem smul (ra : IsSMulRegular M a) (rs : IsSMulRegular M s) : IsSMulRegular M (a • s) :=\n  fun _ _ ab => rs (ra ((smul_assoc _ _ _).symm.trans (ab.trans (smul_assoc _ _ _))))\n\n"}
{"name":"IsSMulRegular.of_smul","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ns : S\ninst✝³ : SMul R M\ninst✝² : SMul R S\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower R S M\na : R\nab : IsSMulRegular M (HSMul.hSMul a s)\n⊢ IsSMulRegular M s","decl":"/-- If an element `b` becomes `M`-regular after multiplying it on the left by an `M`-regular\nelement, then `b` is `M`-regular. -/\ntheorem of_smul (a : R) (ab : IsSMulRegular M (a • s)) : IsSMulRegular M s :=\n  @Function.Injective.of_comp _ _ _ (fun m : M => a • m) _ fun c d cd => by\n  dsimp only [Function.comp_def] at cd\n  rw [← smul_assoc, ← smul_assoc] at cd\n  exact ab cd\n\n"}
{"name":"IsSMulRegular.smul_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\na : R\ninst✝³ : SMul R M\ninst✝² : SMul R S\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower R S M\nb : S\nha : IsSMulRegular M a\n⊢ Iff (IsSMulRegular M (HSMul.hSMul a b)) (IsSMulRegular M b)","decl":"/-- An element is `M`-regular if and only if multiplying it on the left by an `M`-regular element\nis `M`-regular. -/\n@[simp]\ntheorem smul_iff (b : S) (ha : IsSMulRegular M a) : IsSMulRegular M (a • b) ↔ IsSMulRegular M b :=\n  ⟨of_smul _, ha.smul⟩\n\n"}
{"name":"IsSMulRegular.isLeftRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nh : IsSMulRegular R a\n⊢ IsLeftRegular a","decl":"theorem isLeftRegular [Mul R] {a : R} (h : IsSMulRegular R a) : IsLeftRegular a :=\n  h\n\n"}
{"name":"IsSMulRegular.isRightRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nh : IsSMulRegular R (MulOpposite.op a)\n⊢ IsRightRegular a","decl":"theorem isRightRegular [Mul R] {a : R} (h : IsSMulRegular R (MulOpposite.op a)) :\n    IsRightRegular a :=\n  h\n\n"}
{"name":"IsSMulRegular.mul","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝² : SMul R M\ninst✝¹ : Mul R\ninst✝ : IsScalarTower R R M\nra : IsSMulRegular M a\nrb : IsSMulRegular M b\n⊢ IsSMulRegular M (HMul.hMul a b)","decl":"theorem mul [Mul R] [IsScalarTower R R M] (ra : IsSMulRegular M a) (rb : IsSMulRegular M b) :\n    IsSMulRegular M (a * b) :=\n  ra.smul rb\n\n"}
{"name":"IsSMulRegular.of_mul","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝² : SMul R M\ninst✝¹ : Mul R\ninst✝ : IsScalarTower R R M\nab : IsSMulRegular M (HMul.hMul a b)\n⊢ IsSMulRegular M b","decl":"theorem of_mul [Mul R] [IsScalarTower R R M] (ab : IsSMulRegular M (a * b)) :\n    IsSMulRegular M b := by\n  rw [← smul_eq_mul] at ab\n  exact ab.of_smul _\n\n"}
{"name":"IsSMulRegular.mul_iff_right","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝² : SMul R M\ninst✝¹ : Mul R\ninst✝ : IsScalarTower R R M\nha : IsSMulRegular M a\n⊢ Iff (IsSMulRegular M (HMul.hMul a b)) (IsSMulRegular M b)","decl":"@[simp]\ntheorem mul_iff_right [Mul R] [IsScalarTower R R M] (ha : IsSMulRegular M a) :\n    IsSMulRegular M (a * b) ↔ IsSMulRegular M b :=\n  ⟨of_mul, ha.mul⟩\n\n"}
{"name":"IsSMulRegular.mul_and_mul_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝² : SMul R M\ninst✝¹ : Mul R\ninst✝ : IsScalarTower R R M\n⊢ Iff (And (IsSMulRegular M (HMul.hMul a b)) (IsSMulRegular M (HMul.hMul b a))) (And (IsSMulRegular M a) (IsSMulRegular M b))","decl":"/-- Two elements `a` and `b` are `M`-regular if and only if both products `a * b` and `b * a`\nare `M`-regular. -/\ntheorem mul_and_mul_iff [Mul R] [IsScalarTower R R M] :\n    IsSMulRegular M (a * b) ∧ IsSMulRegular M (b * a) ↔ IsSMulRegular M a ∧ IsSMulRegular M b := by\n  refine ⟨?_, ?_⟩\n  · rintro ⟨ab, ba⟩\n    exact ⟨ba.of_mul, ab.of_mul⟩\n  · rintro ⟨ha, hb⟩\n    exact ⟨ha.mul hb, hb.mul ha⟩\n\n"}
{"name":"IsSMulRegular.of_injective","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : SMul R M\nN : Type u_4\nF : Type u_5\ninst✝² : SMul R N\ninst✝¹ : FunLike F M N\ninst✝ : MulActionHomClass F R M N\nf : F\nr : R\nh1 : Function.Injective ⇑f\nh2 : IsSMulRegular N r\n⊢ IsSMulRegular M r","decl":"lemma of_injective {N F} [SMul R N] [FunLike F M N] [MulActionHomClass F R M N]\n    (f : F) {r : R} (h1 : Function.Injective f) (h2 : IsSMulRegular N r) :\n    IsSMulRegular M r := fun x y h3 => h1 <| h2 <|\n  (map_smulₛₗ f r x).symm.trans ((congrArg f h3).trans (map_smulₛₗ f r y))\n\n"}
{"name":"IsSMulRegular.one","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\n⊢ IsSMulRegular M 1","decl":"/-- One is always `M`-regular. -/\n@[simp]\ntheorem one : IsSMulRegular M (1 : R) := fun a b ab => by\n  dsimp only [Function.comp_def] at ab\n  rw [one_smul, one_smul] at ab\n  assumption\n\n"}
{"name":"IsSMulRegular.of_mul_eq_one","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\nh : Eq (HMul.hMul a b) 1\n⊢ IsSMulRegular M b","decl":"/-- An element of `R` admitting a left inverse is `M`-regular. -/\ntheorem of_mul_eq_one (h : a * b = 1) : IsSMulRegular M b :=\n  of_mul (a := a) (by rw [h]; exact one M)\n\n"}
{"name":"IsSMulRegular.pow","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na : R\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\nn : Nat\nra : IsSMulRegular M a\n⊢ IsSMulRegular M (HPow.hPow a n)","decl":"/-- Any power of an `M`-regular element is `M`-regular. -/\ntheorem pow (n : ℕ) (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n) := by\n  induction n with\n  | zero => rw [pow_zero]; simp only [one]\n  | succ n hn =>\n    rw [pow_succ']\n    exact (ra.smul_iff (a ^ n)).mpr hn\n\n"}
{"name":"IsSMulRegular.pow_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na : R\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\nn : Nat\nn0 : LT.lt 0 n\n⊢ Iff (IsSMulRegular M (HPow.hPow a n)) (IsSMulRegular M a)","decl":"/-- An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular. -/\ntheorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by\n  refine ⟨?_, pow n⟩\n  rw [← Nat.succ_pred_eq_of_pos n0, pow_succ, ← smul_eq_mul]\n  exact of_smul _\n\n"}
{"name":"IsSMulRegular.of_smul_eq_one","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\na : R\ns : S\ninst✝⁴ : Monoid S\ninst✝³ : SMul R M\ninst✝² : SMul R S\ninst✝¹ : MulAction S M\ninst✝ : IsScalarTower R S M\nh : Eq (HSMul.hSMul a s) 1\n⊢ IsSMulRegular M s","decl":"/-- An element of `S` admitting a left inverse in `R` is `M`-regular. -/\ntheorem of_smul_eq_one (h : a • s = 1) : IsSMulRegular M s :=\n  of_smul a\n    (by\n      rw [h]\n      exact one M)\n\n"}
{"name":"IsSMulRegular.subsingleton","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : MonoidWithZero R\ninst✝¹ : Zero M\ninst✝ : MulActionWithZero R M\nh : IsSMulRegular M 0\n⊢ Subsingleton M","decl":"/-- The element `0` is `M`-regular if and only if `M` is trivial. -/\nprotected theorem subsingleton (h : IsSMulRegular M (0 : R)) : Subsingleton M :=\n  ⟨fun a b => h (by dsimp only [Function.comp_def]; repeat' rw [MulActionWithZero.zero_smul])⟩\n\n"}
{"name":"IsSMulRegular.zero_iff_subsingleton","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : MonoidWithZero R\ninst✝¹ : Zero M\ninst✝ : MulActionWithZero R M\n⊢ Iff (IsSMulRegular M 0) (Subsingleton M)","decl":"/-- The element `0` is `M`-regular if and only if `M` is trivial. -/\ntheorem zero_iff_subsingleton : IsSMulRegular M (0 : R) ↔ Subsingleton M :=\n  ⟨fun h => h.subsingleton, fun H a b _ => @Subsingleton.elim _ H a b⟩\n\n"}
{"name":"IsSMulRegular.not_zero_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : MonoidWithZero R\ninst✝¹ : Zero M\ninst✝ : MulActionWithZero R M\n⊢ Iff (Not (IsSMulRegular M 0)) (Nontrivial M)","decl":"/-- The `0` element is not `M`-regular, on a non-trivial module. -/\ntheorem not_zero_iff : ¬IsSMulRegular M (0 : R) ↔ Nontrivial M := by\n  rw [nontrivial_iff, not_iff_comm, zero_iff_subsingleton, subsingleton_iff]\n  push_neg\n  exact Iff.rfl\n\n"}
{"name":"IsSMulRegular.zero","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : MonoidWithZero R\ninst✝¹ : Zero M\ninst✝ : MulActionWithZero R M\nsM : Subsingleton M\n⊢ IsSMulRegular M 0","decl":"/-- The element `0` is `M`-regular when `M` is trivial. -/\ntheorem zero [sM : Subsingleton M] : IsSMulRegular M (0 : R) :=\n  zero_iff_subsingleton.mpr sM\n\n"}
{"name":"IsSMulRegular.not_zero","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : MonoidWithZero R\ninst✝¹ : Zero M\ninst✝ : MulActionWithZero R M\nnM : Nontrivial M\n⊢ Not (IsSMulRegular M 0)","decl":"/-- The `0` element is not `M`-regular, on a non-trivial module. -/\ntheorem not_zero [nM : Nontrivial M] : ¬IsSMulRegular M (0 : R) :=\n  not_zero_iff.mpr nM\n\n"}
{"name":"IsSMulRegular.mul_iff","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na b : R\ninst✝² : CommSemigroup R\ninst✝¹ : SMul R M\ninst✝ : IsScalarTower R R M\n⊢ Iff (IsSMulRegular M (HMul.hMul a b)) (And (IsSMulRegular M a) (IsSMulRegular M b))","decl":"/-- A product is `M`-regular if and only if the factors are. -/\ntheorem mul_iff : IsSMulRegular M (a * b) ↔ IsSMulRegular M a ∧ IsSMulRegular M b := by\n  rw [← mul_and_mul_iff]\n  exact ⟨fun ab => ⟨ab, by rwa [mul_comm]⟩, fun rab => rab.1⟩\n\n"}
{"name":"isSMulRegular_of_group","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nG : Type u_4\ninst✝¹ : Group G\ninst✝ : MulAction G R\ng : G\n⊢ IsSMulRegular R g","decl":"/-- An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. -/\ntheorem isSMulRegular_of_group [MulAction G R] (g : G) : IsSMulRegular R g := by\n  intro x y h\n  convert congr_arg (g⁻¹ • ·) h using 1 <;> simp [← smul_assoc]\n\n"}
{"name":"Units.isSMulRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\na : Units R\n⊢ IsSMulRegular M ↑a","decl":"/-- Any element in `Rˣ` is `M`-regular. -/\ntheorem Units.isSMulRegular (a : Rˣ) : IsSMulRegular M (a : R) :=\n  IsSMulRegular.of_mul_eq_one a.inv_val\n\n"}
{"name":"IsUnit.isSMulRegular","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\na : R\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\nua : IsUnit a\n⊢ IsSMulRegular M a","decl":"/-- A unit is `M`-regular. -/\ntheorem IsUnit.isSMulRegular (ua : IsUnit a) : IsSMulRegular M a := by\n  rcases ua with ⟨a, rfl⟩\n  exact a.isSMulRegular M\n\n"}
{"name":"IsSMulRegular.eq_zero_of_smul_eq_zero","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nr : R\nx : M\nh1 : IsSMulRegular M r\nh2 : Eq (HSMul.hSMul r x) 0\n⊢ Eq x 0","decl":"protected\nlemma IsSMulRegular.eq_zero_of_smul_eq_zero [Zero M] [SMulZeroClass R M]\n    {r : R} {x : M} (h1 : IsSMulRegular M r) (h2 : r • x = 0) : x = 0 :=\n  h1 (h2.trans (smul_zero r).symm)\n\n"}
{"name":"Equiv.isSMulRegular_congr","module":"Mathlib.Algebra.Regular.SMul","initialProofState":"R : Type u_4\nS : Type u_5\nM : Type u_6\nM' : Type u_7\ninst✝¹ : SMul R M\ninst✝ : SMul S M'\ne : Equiv M M'\nr : R\ns : S\nh : ∀ (x : M), Eq (e (HSMul.hSMul r x)) (HSMul.hSMul s (e x))\n⊢ Iff (IsSMulRegular M r) (IsSMulRegular M' s)","decl":"lemma Equiv.isSMulRegular_congr {R S M M'} [SMul R M] [SMul S M'] {e : M ≃ M'}\n    {r : R} {s : S} (h : ∀ x, e (r • x) = s • e x) :\n    IsSMulRegular M r ↔ IsSMulRegular M' s :=\n  (e.comp_injective _).symm.trans  <|\n    (iff_of_eq <| congrArg _ <| funext h).trans <| e.injective_comp _\n"}
