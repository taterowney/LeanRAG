{"name":"ContinuousMap.compactOpen_eq","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq ContinuousMap.compactOpen (TopologicalSpace.generateFrom (Set.image2 (fun K U => setOf fun f => Set.MapsTo (‚áëf) K U) (setOf fun K => IsCompact K) (setOf fun t => IsOpen t)))","decl":"/-- Definition of `ContinuousMap.compactOpen`. -/\ntheorem compactOpen_eq : @compactOpen X Y _ _ =\n    .generateFrom (image2 (fun K U ‚Ü¶ {f | MapsTo f K U}) {K | IsCompact K} {t | IsOpen t}) :=\n   rfl\n\n"}
{"name":"ContinuousMap.isOpen_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nK : Set X\nU : Set Y\nhK : IsCompact K\nhU : IsOpen U\n‚ä¢ IsOpen (setOf fun f => Set.MapsTo (‚áëf) K U)","decl":"theorem isOpen_setOf_mapsTo (hK : IsCompact K) (hU : IsOpen U) :\n    IsOpen {f : C(X, Y) | MapsTo f K U} :=\n  isOpen_generateFrom_of_mem <| mem_image2_of_mem hK hU\n\n"}
{"name":"ContinuousMap.eventually_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nK : Set X\nU : Set Y\nf : ContinuousMap X Y\nhK : IsCompact K\nhU : IsOpen U\nh : Set.MapsTo (‚áëf) K U\n‚ä¢ Filter.Eventually (fun g => Set.MapsTo (‚áëg) K U) (nhds f)","decl":"lemma eventually_mapsTo {f : C(X, Y)} (hK : IsCompact K) (hU : IsOpen U) (h : MapsTo f K U) :\n    ‚àÄ·∂† g : C(X, Y) in ùìù f, MapsTo g K U :=\n  (isOpen_setOf_mapsTo hK hU).mem_nhds h\n\n"}
{"name":"ContinuousMap.nhds_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\n‚ä¢ Eq (nhds f) (iInf fun K => iInf fun x => iInf fun U => iInf fun x => iInf fun x => Filter.principal (setOf fun g => Set.MapsTo (‚áëg) K U))","decl":"lemma nhds_compactOpen (f : C(X, Y)) :\n    ùìù f = ‚®Ö (K : Set X) (_ : IsCompact K) (U : Set Y) (_ : IsOpen U) (_ : MapsTo f K U),\n      ùìü {g : C(X, Y) | MapsTo g K U} := by\n  simp_rw [compactOpen_eq, nhds_generateFrom, mem_setOf_eq, @and_comm (f ‚àà _), iInf_and,\n    ‚Üê image_prod, iInf_image, biInf_prod, mem_setOf_eq]\n\n"}
{"name":"ContinuousMap.tendsto_nhds_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"Œ± : Type u_1\nY : Type u_3\nZ : Type u_4\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nl : Filter Œ±\nf : Œ± ‚Üí ContinuousMap Y Z\ng : ContinuousMap Y Z\n‚ä¢ Iff (Filter.Tendsto f l (nhds g)) (‚àÄ (K : Set Y), IsCompact K ‚Üí ‚àÄ (U : Set Z), IsOpen U ‚Üí Set.MapsTo (‚áëg) K U ‚Üí Filter.Eventually (fun a => Set.MapsTo (‚áë(f a)) K U) l)","decl":"lemma tendsto_nhds_compactOpen {l : Filter Œ±} {f : Œ± ‚Üí C(Y, Z)} {g : C(Y, Z)} :\n    Tendsto f l (ùìù g) ‚Üî\n      ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí ‚àÄ·∂† a in l, MapsTo (f a) K U := by\n  simp [nhds_compactOpen]\n\n"}
{"name":"ContinuousMap.continuous_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí ContinuousMap Y Z\n‚ä¢ Iff (Continuous f) (‚àÄ (K : Set Y), IsCompact K ‚Üí ‚àÄ (U : Set Z), IsOpen U ‚Üí IsOpen (setOf fun x => Set.MapsTo (‚áë(f x)) K U))","decl":"lemma continuous_compactOpen {f : X ‚Üí C(Y, Z)} :\n    Continuous f ‚Üî ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí IsOpen {x | MapsTo (f x) K U} :=\n  continuous_generateFrom_iff.trans forall_mem_image2\n\n"}
{"name":"ContinuousMap.continuous_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\n‚ä¢ Continuous g.comp","decl":"/-- `C(X, ¬∑)` is a functor. -/\ntheorem continuous_postcomp (g : C(Y, Z)) : Continuous (ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)) :=\n  continuous_compactOpen.2 fun _K hK _U hU ‚Ü¶ isOpen_setOf_mapsTo hK (hU.preimage g.2)\n\n"}
{"name":"ContinuousMap.continuous_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\n‚ä¢ Continuous g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias continuous_comp := continuous_postcomp\n\n"}
{"name":"ContinuousMap.isInducing_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ‚áëg\n‚ä¢ Topology.IsInducing g.comp","decl":"/-- If `g : C(Y, Z)` is a topology inducing map,\nthen the composition `ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)` is a topology inducing map too. -/\ntheorem isInducing_postcomp (g : C(Y, Z)) (hg : IsInducing g) :\n    IsInducing (g.comp : C(X, Y) ‚Üí C(X, Z)) where\n  eq_induced := by\n    simp only [compactOpen_eq, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,\n      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]\n\n"}
{"name":"ContinuousMap.inducing_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ‚áëg\n‚ä¢ Topology.IsInducing g.comp","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_postcomp := isInducing_postcomp\n\n"}
{"name":"ContinuousMap.inducing_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ‚áëg\n‚ä¢ Topology.IsInducing g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias inducing_comp := isInducing_postcomp\n\n"}
{"name":"ContinuousMap.isEmbedding_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding g.comp","decl":"/-- If `g : C(Y, Z)` is a topological embedding,\nthen the composition `ContinuousMap.comp g : C(X, Y) ‚Üí C(X, Z)` is an embedding too. -/\ntheorem isEmbedding_postcomp (g : C(Y, Z)) (hg : IsEmbedding g) :\n    IsEmbedding (g.comp : C(X, Y) ‚Üí C(X, Z)) :=\n  ‚ü®isInducing_postcomp g hg.1, fun _ _ ‚Ü¶ (cancel_left hg.2).1‚ü©\n\n"}
{"name":"ContinuousMap.embedding_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_postcomp := isEmbedding_postcomp\n\n"}
{"name":"ContinuousMap.embedding_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias embedding_comp := isEmbedding_postcomp\n\n"}
{"name":"ContinuousMap.continuous_precomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : ContinuousMap X Y\n‚ä¢ Continuous fun g => g.comp f","decl":"/-- `C(¬∑, Z)` is a functor. -/\n@[continuity, fun_prop]\ntheorem continuous_precomp (f : C(X, Y)) : Continuous (fun g => g.comp f : C(Y, Z) ‚Üí C(X, Z)) :=\n  continuous_compactOpen.2 fun K hK U hU ‚Ü¶ by\n    simpa only [mapsTo_image_iff] using isOpen_setOf_mapsTo (hK.image f.2) hU\n\n"}
{"name":"ContinuousMap.continuous_comp_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : ContinuousMap X Y\n‚ä¢ Continuous fun g => g.comp f","decl":"@[deprecated (since := \"2024-10-19\")] alias continuous_comp_left := continuous_precomp\n\n"}
{"name":"ContinuousMap.compRightContinuousMap_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : ContinuousMap X Y\ng : ContinuousMap Y Z\n‚ä¢ Eq ((ContinuousMap.compRightContinuousMap Z f) g) (g.comp f)","decl":"variable (Z) in\n/-- Precomposition by a continuous map is itself a continuous map between spaces of continuous maps.\n-/\n@[simps apply]\ndef compRightContinuousMap (f : C(X, Y)) :\n    C(C(Y, Z), C(X, Z)) where\n  toFun g := g.comp f\n\n"}
{"name":"ContinuousMap.continuous_comp'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactPair Y Z\n‚ä¢ Continuous fun x => x.2.comp x.1","decl":"/-- Composition is a continuous map from `C(X, Y) √ó C(Y, Z)` to `C(X, Z)`,\nprovided that `Y` is locally compact.\nThis is Prop. 9 of Chap. X, ¬ß3, ‚Ññ. 4 of Bourbaki's *Topologie G√©n√©rale*. -/\ntheorem continuous_comp' : Continuous fun x : C(X, Y) √ó C(Y, Z) => x.2.comp x.1 := by\n  simp_rw [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen]\n  intro ‚ü®f, g‚ü© K hK U hU (hKU : MapsTo (g ‚àò f) K U)\n  obtain ‚ü®L, hKL, hLc, hLU‚ü© : ‚àÉ L ‚àà ùìùÀ¢ (f '' K), IsCompact L ‚àß MapsTo g L U :=\n    exists_mem_nhdsSet_isCompact_mapsTo g.continuous (hK.image f.continuous) hU\n      (mapsTo_image_iff.2 hKU)\n  rw [‚Üê subset_interior_iff_mem_nhdsSet, ‚Üê mapsTo'] at hKL\n  exact ((eventually_mapsTo hK isOpen_interior hKL).prod_nhds\n    (eventually_mapsTo hLc hU hLU)).mono fun ‚ü®f', g'‚ü© ‚ü®hf', hg'‚ü© ‚Ü¶\n      hg'.comp <| hf'.mono_right interior_subset\n\n"}
{"name":"Filter.Tendsto.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactPair Y Z\nŒ± : Type u_6\nl : Filter Œ±\ng : Œ± ‚Üí ContinuousMap Y Z\ng‚ÇÄ : ContinuousMap Y Z\nf : Œ± ‚Üí ContinuousMap X Y\nf‚ÇÄ : ContinuousMap X Y\nhg : Filter.Tendsto g l (nhds g‚ÇÄ)\nhf : Filter.Tendsto f l (nhds f‚ÇÄ)\n‚ä¢ Filter.Tendsto (fun a => (g a).comp (f a)) l (nhds (g‚ÇÄ.comp f‚ÇÄ))","decl":"lemma _root_.Filter.Tendsto.compCM {Œ± : Type*} {l : Filter Œ±} {g : Œ± ‚Üí C(Y, Z)} {g‚ÇÄ : C(Y, Z)}\n    {f : Œ± ‚Üí C(X, Y)} {f‚ÇÄ : C(X, Y)} (hg : Tendsto g l (ùìù g‚ÇÄ)) (hf : Tendsto f l (ùìù f‚ÇÄ)) :\n    Tendsto (fun a ‚Ü¶ (g a).comp (f a)) l (ùìù (g‚ÇÄ.comp f‚ÇÄ)) :=\n  (continuous_comp'.tendsto (f‚ÇÄ, g‚ÇÄ)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"ContinuousAt.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : LocallyCompactPair Y Z\nX' : Type u_6\ninst‚úù : TopologicalSpace X'\na : X'\ng : X' ‚Üí ContinuousMap Y Z\nf : X' ‚Üí ContinuousMap X Y\nhg : ContinuousAt g a\nhf : ContinuousAt f a\n‚ä¢ ContinuousAt (fun x => (g x).comp (f x)) a","decl":"nonrec lemma _root_.ContinuousAt.compCM (hg : ContinuousAt g a) (hf : ContinuousAt f a) :\n    ContinuousAt (fun x ‚Ü¶ (g x).comp (f x)) a :=\n  hg.compCM hf\n\n"}
{"name":"ContinuousWithinAt.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : LocallyCompactPair Y Z\nX' : Type u_6\ninst‚úù : TopologicalSpace X'\na : X'\ng : X' ‚Üí ContinuousMap Y Z\nf : X' ‚Üí ContinuousMap X Y\ns : Set X'\nhg : ContinuousWithinAt g s a\nhf : ContinuousWithinAt f s a\n‚ä¢ ContinuousWithinAt (fun x => (g x).comp (f x)) s a","decl":"nonrec lemma _root_.ContinuousWithinAt.compCM (hg : ContinuousWithinAt g s a)\n    (hf : ContinuousWithinAt f s a) : ContinuousWithinAt (fun x ‚Ü¶ (g x).comp (f x)) s a :=\n  hg.compCM hf\n\n"}
{"name":"ContinuousOn.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : LocallyCompactPair Y Z\nX' : Type u_6\ninst‚úù : TopologicalSpace X'\ng : X' ‚Üí ContinuousMap Y Z\nf : X' ‚Üí ContinuousMap X Y\ns : Set X'\nhg : ContinuousOn g s\nhf : ContinuousOn f s\n‚ä¢ ContinuousOn (fun x => (g x).comp (f x)) s","decl":"lemma _root_.ContinuousOn.compCM (hg : ContinuousOn g s) (hf : ContinuousOn f s) :\n    ContinuousOn (fun x ‚Ü¶ (g x).comp (f x)) s := fun a ha ‚Ü¶\n  (hg a ha).compCM (hf a ha)\n\n"}
{"name":"Continuous.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : LocallyCompactPair Y Z\nX' : Type u_6\ninst‚úù : TopologicalSpace X'\ng : X' ‚Üí ContinuousMap Y Z\nf : X' ‚Üí ContinuousMap X Y\nhg : Continuous g\nhf : Continuous f\n‚ä¢ Continuous fun x => (g x).comp (f x)","decl":"lemma _root_.Continuous.compCM (hg : Continuous g) (hf : Continuous f) :\n    Continuous fun x => (g x).comp (f x) :=\n  continuous_comp'.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousMap.instContinuousEvalOfLocallyCompactPair","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactPair X Y\n‚ä¢ ContinuousEval (ContinuousMap X Y) X Y","decl":"/-- The evaluation map `C(X, Y) √ó X ‚Üí Y` is continuous\nif `X, Y` is a locally compact pair of spaces. -/\ninstance [LocallyCompactPair X Y] : ContinuousEval C(X, Y) X Y where\n  continuous_eval := by\n    simp_rw [continuous_iff_continuousAt, ContinuousAt, (nhds_basis_opens _).tendsto_right_iff]\n    rintro ‚ü®f, x‚ü© U ‚ü®hx : f x ‚àà U, hU : IsOpen U‚ü©\n    rcases exists_mem_nhds_isCompact_mapsTo f.continuous (hU.mem_nhds hx) with ‚ü®K, hxK, hK, hKU‚ü©\n    filter_upwards [prod_mem_nhds (eventually_mapsTo hK hU hKU) hxK] using fun _ h ‚Ü¶ h.1 h.2\n\n"}
{"name":"ContinuousMap.continuous_eval","module":"Mathlib.Topology.CompactOpen","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst‚úù¬≥ : FunLike F X Y\ninst‚úù¬≤ : TopologicalSpace F\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nself : ContinuousEval F X Y\n‚ä¢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-01\")] protected alias continuous_eval := continuous_eval\n\n"}
{"name":"ContinuousMap.instContinuousEvalConst","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ ContinuousEvalConst (ContinuousMap X Y) X Y","decl":"instance : ContinuousEvalConst C(X, Y) X Y where\n  continuous_eval_const x :=\n    continuous_def.2 fun U hU ‚Ü¶ by simpa using isOpen_setOf_mapsTo isCompact_singleton hU\n\n"}
{"name":"ContinuousMap.continuous_eval_const","module":"Mathlib.Topology.CompactOpen","initialProofState":"F : Type u_1\nŒ± : outParam (Type u_2)\nX : outParam (Type u_3)\ninst‚úù¬≤ : FunLike F Œ± X\ninst‚úù¬π : TopologicalSpace F\ninst‚úù : TopologicalSpace X\nself : ContinuousEvalConst F Œ± X\nx : Œ±\n‚ä¢ Continuous fun f => f x","decl":"@[deprecated (since := \"2024-10-01\")] protected alias continuous_eval_const := continuous_eval_const\n\n"}
{"name":"ContinuousMap.continuous_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Continuous DFunLike.coe","decl":"@[deprecated continuous_coeFun (since := \"2024-10-01\")]\ntheorem continuous_coe : Continuous ((‚áë) : C(X, Y) ‚Üí (X ‚Üí Y)) :=\n  continuous_coeFun\n\n"}
{"name":"ContinuousMap.isClosed_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nt : Set Y\nht : IsClosed t\ns : Set X\n‚ä¢ IsClosed (setOf fun f => Set.MapsTo (‚áëf) s t)","decl":"lemma isClosed_setOf_mapsTo {t : Set Y} (ht : IsClosed t) (s : Set X) :\n    IsClosed {f : C(X, Y) | MapsTo f s t} :=\n  ht.setOf_mapsTo fun _ _ ‚Ü¶ continuous_eval_const _\n\n"}
{"name":"ContinuousMap.isClopen_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nK : Set X\nU : Set Y\nhK : IsCompact K\nhU : IsClopen U\n‚ä¢ IsClopen (setOf fun f => Set.MapsTo (‚áëf) K U)","decl":"lemma isClopen_setOf_mapsTo (hK : IsCompact K) (hU : IsClopen U) :\n    IsClopen {f : C(X, Y) | MapsTo f K U} :=\n  ‚ü®isClosed_setOf_mapsTo hU.isClosed K, isOpen_setOf_mapsTo hK hU.isOpen‚ü©\n\n"}
{"name":"ContinuousMap.specializes_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf g : ContinuousMap X Y\n‚ä¢ Iff (Specializes ‚áëf ‚áëg) (Specializes f g)","decl":"@[norm_cast]\nlemma specializes_coe {f g : C(X, Y)} : ‚áëf ‚§≥ ‚áëg ‚Üî f ‚§≥ g := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ h.map continuous_coeFun‚ü©\n  suffices ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí MapsTo f K U by\n    simpa [specializes_iff_pure, nhds_compactOpen]\n  exact fun K _ U hU hg x hx ‚Ü¶ (h.map (continuous_apply x)).mem_open hU (hg hx)\n\n"}
{"name":"ContinuousMap.inseparable_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf g : ContinuousMap X Y\n‚ä¢ Iff (Inseparable ‚áëf ‚áëg) (Inseparable f g)","decl":"@[norm_cast]\nlemma inseparable_coe {f g : C(X, Y)} : Inseparable (f : X ‚Üí Y) g ‚Üî Inseparable f g := by\n  simp only [inseparable_iff_specializes_and, specializes_coe]\n\n"}
{"name":"ContinuousMap.instT0Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space Y\n‚ä¢ T0Space (ContinuousMap X Y)","decl":"instance [T0Space Y] : T0Space C(X, Y) :=\n  t0Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun\n\n"}
{"name":"ContinuousMap.instR0Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R0Space Y\n‚ä¢ R0Space (ContinuousMap X Y)","decl":"instance [R0Space Y] : R0Space C(X, Y) where\n  specializes_symmetric f g h := by\n    rw [‚Üê specializes_coe] at h ‚ä¢\n    exact h.symm\n\n"}
{"name":"ContinuousMap.instT1Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\n‚ä¢ T1Space (ContinuousMap X Y)","decl":"instance [T1Space Y] : T1Space C(X, Y) :=\n  t1Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun\n\n"}
{"name":"ContinuousMap.instR1Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R1Space Y\n‚ä¢ R1Space (ContinuousMap X Y)","decl":"instance [R1Space Y] : R1Space C(X, Y) :=\n  .of_continuous_specializes_imp continuous_coeFun fun _ _ ‚Ü¶ specializes_coe.1\n\n"}
{"name":"ContinuousMap.instT2Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T2Space Y\n‚ä¢ T2Space (ContinuousMap X Y)","decl":"instance [T2Space Y] : T2Space C(X, Y) := inferInstance\n\n"}
{"name":"ContinuousMap.instRegularSpace","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : RegularSpace Y\n‚ä¢ RegularSpace (ContinuousMap X Y)","decl":"instance [RegularSpace Y] : RegularSpace C(X, Y) :=\n  .of_lift'_closure_le fun f ‚Ü¶ by\n    rw [‚Üê tendsto_id', tendsto_nhds_compactOpen]\n    intro K hK U hU hf\n    rcases (hK.image f.continuous).exists_isOpen_closure_subset (hU.mem_nhdsSet.2 hf.image_subset)\n      with ‚ü®V, hVo, hKV, hVU‚ü©\n    filter_upwards [mem_lift' (eventually_mapsTo hK hVo (mapsTo'.2 hKV))] with g hg\n    refine ((isClosed_setOf_mapsTo isClosed_closure K).closure_subset ?_).mono_right hVU\n    exact closure_mono (fun _ h ‚Ü¶ h.mono_right subset_closure) hg\n\n"}
{"name":"ContinuousMap.instT3Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T3Space Y\n‚ä¢ T3Space (ContinuousMap X Y)","decl":"instance [T3Space Y] : T3Space C(X, Y) := inferInstance\n\n"}
{"name":"ContinuousMap.continuous_restrict","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\n‚ä¢ Continuous fun F => ContinuousMap.restrict s F","decl":"/-- For any subset `s` of `X`, the restriction of continuous functions to `s` is continuous\nas a function from `C(X, Y)` to `C(s, Y)` with their respective compact-open topologies. -/\ntheorem continuous_restrict (s : Set X) : Continuous fun F : C(X, Y) => F.restrict s :=\n  continuous_precomp <| restrict s <| .id X\n\n"}
{"name":"ContinuousMap.compactOpen_le_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\n‚ä¢ LE.le ContinuousMap.compactOpen (TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen)","decl":"theorem compactOpen_le_induced (s : Set X) :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) ‚â§\n      .induced (restrict s) ContinuousMap.compactOpen :=\n  (continuous_restrict s).le_induced\n\n"}
{"name":"ContinuousMap.compactOpen_eq_iInf_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq ContinuousMap.compactOpen (iInf fun K => iInf fun x => TopologicalSpace.induced (ContinuousMap.restrict K) ContinuousMap.compactOpen)","decl":"/-- The compact-open topology on `C(X, Y)`\nis equal to the infimum of the compact-open topologies on `C(s, Y)` for `s` a compact subset of `X`.\nThe key point of the proof is that for every compact set `K`,\nthe universal set `Set.univ : Set K` is a compact set as well. -/\ntheorem compactOpen_eq_iInf_induced :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      ‚®Ö (K : Set X) (_ : IsCompact K), .induced (.restrict K) ContinuousMap.compactOpen := by\n  refine le_antisymm (le_iInf‚ÇÇ fun s _ ‚Ü¶ compactOpen_le_induced s) ?_\n  refine le_generateFrom <| forall_mem_image2.2 fun K (hK : IsCompact K) U hU ‚Ü¶ ?_\n  refine TopologicalSpace.le_def.1 (iInf‚ÇÇ_le K hK) _ ?_\n  convert isOpen_induced (isOpen_setOf_mapsTo (isCompact_iff_isCompact_univ.1 hK) hU)\n  simp [mapsTo_univ_iff, Subtype.forall, MapsTo]\n\n"}
{"name":"ContinuousMap.nhds_compactOpen_eq_iInf_nhds_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\n‚ä¢ Eq (nhds f) (iInf fun s => iInf fun x => Filter.comap (ContinuousMap.restrict s) (nhds (ContinuousMap.restrict s f)))","decl":"theorem nhds_compactOpen_eq_iInf_nhds_induced (f : C(X, Y)) :\n    ùìù f = ‚®Ö (s) (_ : IsCompact s), (ùìù (f.restrict s)).comap (ContinuousMap.restrict s) := by\n  rw [compactOpen_eq_iInf_induced]\n  simp only [nhds_iInf, nhds_induced]\n\n"}
{"name":"ContinuousMap.tendsto_compactOpen_restrict","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nŒπ : Type u_6\nl : Filter Œπ\nF : Œπ ‚Üí ContinuousMap X Y\nf : ContinuousMap X Y\nhFf : Filter.Tendsto F l (nhds f)\ns : Set X\n‚ä¢ Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds (ContinuousMap.restrict s f))","decl":"theorem tendsto_compactOpen_restrict {Œπ : Type*} {l : Filter Œπ} {F : Œπ ‚Üí C(X, Y)} {f : C(X, Y)}\n    (hFf : Filter.Tendsto F l (ùìù f)) (s : Set X) :\n    Tendsto (fun i => (F i).restrict s) l (ùìù (f.restrict s)) :=\n  (continuous_restrict s).continuousAt.tendsto.comp hFf\n\n"}
{"name":"ContinuousMap.tendsto_compactOpen_iff_forall","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nŒπ : Type u_6\nl : Filter Œπ\nF : Œπ ‚Üí ContinuousMap X Y\nf : ContinuousMap X Y\n‚ä¢ Iff (Filter.Tendsto F l (nhds f)) (‚àÄ (K : Set X), IsCompact K ‚Üí Filter.Tendsto (fun i => ContinuousMap.restrict K (F i)) l (nhds (ContinuousMap.restrict K f)))","decl":"theorem tendsto_compactOpen_iff_forall {Œπ : Type*} {l : Filter Œπ} (F : Œπ ‚Üí C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (ùìù f) ‚Üî\n      ‚àÄ K, IsCompact K ‚Üí Tendsto (fun i => (F i).restrict K) l (ùìù (f.restrict K)) := by\n  rw [compactOpen_eq_iInf_induced]\n  simp [nhds_iInf, nhds_induced, Filter.tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"ContinuousMap.exists_tendsto_compactOpen_iff_forall","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : WeaklyLocallyCompactSpace X\ninst‚úù¬π : T2Space Y\nŒπ : Type u_6\nl : Filter Œπ\ninst‚úù : l.NeBot\nF : Œπ ‚Üí ContinuousMap X Y\n‚ä¢ Iff (Exists fun f => Filter.Tendsto F l (nhds f)) (‚àÄ (s : Set X), IsCompact s ‚Üí Exists fun f => Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f))","decl":"/-- A family `F` of functions in `C(X, Y)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `X`. -/\ntheorem exists_tendsto_compactOpen_iff_forall [WeaklyLocallyCompactSpace X] [T2Space Y]\n    {Œπ : Type*} {l : Filter Œπ} [Filter.NeBot l] (F : Œπ ‚Üí C(X, Y)) :\n    (‚àÉ f, Filter.Tendsto F l (ùìù f)) ‚Üî\n      ‚àÄ s : Set X, IsCompact s ‚Üí ‚àÉ f, Filter.Tendsto (fun i => (F i).restrict s) l (ùìù f) := by\n  constructor\n  ¬∑ rintro ‚ü®f, hf‚ü© s _\n    exact ‚ü®f.restrict s, tendsto_compactOpen_restrict hf s‚ü©\n  ¬∑ intro h\n    choose f hf using h\n    -- By uniqueness of limits in a `T2Space`, since `fun i ‚Ü¶ F i x` tends to both `f s‚ÇÅ hs‚ÇÅ x` and\n    -- `f s‚ÇÇ hs‚ÇÇ x`, we have `f s‚ÇÅ hs‚ÇÅ x = f s‚ÇÇ hs‚ÇÇ x`\n    have h :\n      ‚àÄ (s‚ÇÅ) (hs‚ÇÅ : IsCompact s‚ÇÅ) (s‚ÇÇ) (hs‚ÇÇ : IsCompact s‚ÇÇ) (x : X) (hxs‚ÇÅ : x ‚àà s‚ÇÅ) (hxs‚ÇÇ : x ‚àà s‚ÇÇ),\n        f s‚ÇÅ hs‚ÇÅ ‚ü®x, hxs‚ÇÅ‚ü© = f s‚ÇÇ hs‚ÇÇ ‚ü®x, hxs‚ÇÇ‚ü© := by\n      rintro s‚ÇÅ hs‚ÇÅ s‚ÇÇ hs‚ÇÇ x hxs‚ÇÅ hxs‚ÇÇ\n      haveI := isCompact_iff_compactSpace.mp hs‚ÇÅ\n      haveI := isCompact_iff_compactSpace.mp hs‚ÇÇ\n      have h‚ÇÅ := (continuous_eval_const (‚ü®x, hxs‚ÇÅ‚ü© : s‚ÇÅ)).continuousAt.tendsto.comp (hf s‚ÇÅ hs‚ÇÅ)\n      have h‚ÇÇ := (continuous_eval_const (‚ü®x, hxs‚ÇÇ‚ü© : s‚ÇÇ)).continuousAt.tendsto.comp (hf s‚ÇÇ hs‚ÇÇ)\n      exact tendsto_nhds_unique h‚ÇÅ h‚ÇÇ\n    -- So glue the `f s hs` together and prove that this glued function `f‚ÇÄ` is a limit on each\n    -- compact set `s`\n    refine ‚ü®liftCover' _ _ h exists_compact_mem_nhds, ?_‚ü©\n    rw [tendsto_compactOpen_iff_forall]\n    intro s hs\n    rw [liftCover_restrict']\n    exact hf s hs\n\n"}
{"name":"ContinuousMap.coev_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nb : Y\n‚ä¢ Eq (‚áë(ContinuousMap.coev X Y b)) (Prod.mk b)","decl":"/-- The coevaluation map `Y ‚Üí C(X, Y √ó X)` sending a point `x : Y` to the continuous function\non `X` sending `y` to `(x, y)`. -/\n@[simps (config := .asFn)]\ndef coev (b : Y) : C(X, Y √ó X) :=\n  { toFun := Prod.mk b }\n\n"}
{"name":"ContinuousMap.image_coev","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ny : Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áë(ContinuousMap.coev X Y y)) s) (SProd.sprod (Singleton.singleton y) s)","decl":"theorem image_coev {y : Y} (s : Set X) : coev X Y y '' s = {y} √óÀ¢ s := by simp\n\n"}
{"name":"ContinuousMap.continuous_coev","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Continuous (ContinuousMap.coev X Y)","decl":"/-- The coevaluation map `Y ‚Üí C(X, Y √ó X)` is continuous (always). -/\ntheorem continuous_coev : Continuous (coev X Y) := by\n  have : ‚àÄ {a K U}, MapsTo (coev X Y a) K U ‚Üî {a} √óÀ¢ K ‚äÜ U := by simp [mapsTo']\n  simp only [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen, this]\n  intro x K hK U hU hKU\n  rcases generalized_tube_lemma isCompact_singleton hK hU hKU with ‚ü®V, W, hV, -, hxV, hKW, hVWU‚ü©\n  filter_upwards [hV.mem_nhds (hxV rfl)] with a ha\n  exact (prod_mono (singleton_subset_iff.mpr ha) hKW).trans hVWU\n\n"}
{"name":"ContinuousMap.curry_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : ContinuousMap (Prod X Y) Z\na : X\nb : Y\n‚ä¢ Eq ((f.curry a) b) (f { fst := a, snd := b })","decl":"@[simp]\ntheorem curry_apply (f : C(X √ó Y, Z)) (a : X) (b : Y) : f.curry a b = f (a, b) :=\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_of_continuous_uncurry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí ContinuousMap Y Z\nh : Continuous (Function.uncurry fun x y => (f x) y)\n‚ä¢ Continuous f","decl":"/-- To show continuity of a map `Œ± ‚Üí C(Œ≤, Œ≥)`, it suffices to show that its uncurried form\n    `Œ± √ó Œ≤ ‚Üí Œ≥` is continuous. -/\ntheorem continuous_of_continuous_uncurry (f : X ‚Üí C(Y, Z))\n    (h : Continuous (Function.uncurry fun x y => f x y)) : Continuous f :=\n  (curry ‚ü®_, h‚ü©).2\n\n"}
{"name":"ContinuousMap.continuous_curry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace (Prod X Y)\n‚ä¢ Continuous ContinuousMap.curry","decl":"/-- The currying process is a continuous map between function spaces. -/\ntheorem continuous_curry [LocallyCompactSpace (X √ó Y)] :\n    Continuous (curry : C(X √ó Y, Z) ‚Üí C(X, C(Y, Z))) := by\n  apply continuous_of_continuous_uncurry\n  apply continuous_of_continuous_uncurry\n  rw [‚Üê (Homeomorph.prodAssoc _ _ _).symm.comp_continuous_iff']\n  exact continuous_eval\n\n"}
{"name":"ContinuousMap.continuous_uncurry_of_continuous","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : ContinuousMap X (ContinuousMap Y Z)\n‚ä¢ Continuous (Function.uncurry fun x y => (f x) y)","decl":"/-- The uncurried form of a continuous map `X ‚Üí C(Y, Z)` is a continuous map `X √ó Y ‚Üí Z`. -/\ntheorem continuous_uncurry_of_continuous [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) :\n    Continuous (Function.uncurry fun x y => f x y) :=\n  continuous_eval.comp <| f.continuous.prodMap continuous_id\n\n"}
{"name":"ContinuousMap.uncurry_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : ContinuousMap X (ContinuousMap Y Z)\na‚úù : Prod X Y\n‚ä¢ Eq (f.uncurry a‚úù) (Function.uncurry (fun x y => (f x) y) a‚úù)","decl":"/-- The uncurried form of a continuous map `X ‚Üí C(Y, Z)` as a continuous map `X √ó Y ‚Üí Z` (if `Y` is\n    locally compact). If `X` is also locally compact, then this is a homeomorphism between the two\n    function spaces, see `Homeomorph.curry`. -/\n@[simps]\ndef uncurry [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) : C(X √ó Y, Z) :=\n  ‚ü®_, continuous_uncurry_of_continuous f‚ü©\n\n"}
{"name":"ContinuousMap.continuous_uncurry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TopologicalSpace Z\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : LocallyCompactSpace Y\n‚ä¢ Continuous ContinuousMap.uncurry","decl":"/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem continuous_uncurry [LocallyCompactSpace X] [LocallyCompactSpace Y] :\n    Continuous (uncurry : C(X, C(Y, Z)) ‚Üí C(X √ó Y, Z)) := by\n  apply continuous_of_continuous_uncurry\n  rw [‚Üê (Homeomorph.prodAssoc _ _ _).comp_continuous_iff']\n  dsimp [Function.comp_def]\n  exact (continuous_fst.fst.eval continuous_fst.snd).eval continuous_snd\n\n"}
{"name":"ContinuousMap.coe_const'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq (‚áëContinuousMap.const') (ContinuousMap.const X)","decl":"@[simp]\ntheorem coe_const' : (const' : Y ‚Üí C(X, Y)) = const X :=\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_const'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Continuous (ContinuousMap.const X)","decl":"theorem continuous_const' : Continuous (const X : Y ‚Üí C(X, Y)) :=\n  const'.continuous\n\n"}
{"name":"Homeomorph.continuousMapOfUnique_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : Unique X\ny : Y\nx : X\n‚ä¢ Eq ((Homeomorph.continuousMapOfUnique y) x) y","decl":"@[simp]\ntheorem continuousMapOfUnique_apply [Unique X] (y : Y) (x : X) : continuousMapOfUnique y x = y :=\n  rfl\n\n"}
{"name":"Homeomorph.continuousMapOfUnique_symm_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : Unique X\nf : ContinuousMap X Y\n‚ä¢ Eq (Homeomorph.continuousMapOfUnique.symm f) (f Inhabited.default)","decl":"@[simp]\ntheorem continuousMapOfUnique_symm_apply [Unique X] (f : C(X, Y)) :\n    continuousMapOfUnique.symm f = f default :=\n  rfl\n\n"}
{"name":"Topology.IsQuotientMap.continuous_lift_prod_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X‚ÇÄ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÄ\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : X‚ÇÄ ‚Üí X\nhf : Topology.IsQuotientMap f\ng : Prod X Y ‚Üí Z\nhg : Continuous fun p => g { fst := f p.1, snd := p.2 }\n‚ä¢ Continuous g","decl":"theorem Topology.IsQuotientMap.continuous_lift_prod_left (hf : IsQuotientMap f) {g : X √ó Y ‚Üí Z}\n    (hg : Continuous fun p : X‚ÇÄ √ó Y => g (f p.1, p.2)) : Continuous g := by\n  let Gf : C(X‚ÇÄ, C(Y, Z)) := ContinuousMap.curry ‚ü®_, hg‚ü©\n  have h : ‚àÄ x : X, Continuous fun y => g (x, y) := by\n    intro x\n    obtain ‚ü®x‚ÇÄ, rfl‚ü© := hf.surjective x\n    exact (Gf x‚ÇÄ).continuous\n  let G : X ‚Üí C(Y, Z) := fun x => ‚ü®_, h x‚ü©\n  have : Continuous G := by\n    rw [hf.continuous_iff]\n    exact Gf.continuous\n  exact ContinuousMap.continuous_uncurry_of_continuous ‚ü®G, this‚ü©\n\n"}
{"name":"QuotientMap.continuous_lift_prod_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X‚ÇÄ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÄ\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : X‚ÇÄ ‚Üí X\nhf : Topology.IsQuotientMap f\ng : Prod X Y ‚Üí Z\nhg : Continuous fun p => g { fst := f p.1, snd := p.2 }\n‚ä¢ Continuous g","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.continuous_lift_prod_left := IsQuotientMap.continuous_lift_prod_left\n\n"}
{"name":"Topology.IsQuotientMap.continuous_lift_prod_right","module":"Mathlib.Topology.CompactOpen","initialProofState":"X‚ÇÄ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÄ\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : X‚ÇÄ ‚Üí X\nhf : Topology.IsQuotientMap f\ng : Prod Y X ‚Üí Z\nhg : Continuous fun p => g { fst := p.1, snd := f p.2 }\n‚ä¢ Continuous g","decl":"theorem Topology.IsQuotientMap.continuous_lift_prod_right (hf : IsQuotientMap f) {g : Y √ó X ‚Üí Z}\n    (hg : Continuous fun p : Y √ó X‚ÇÄ => g (p.1, f p.2)) : Continuous g := by\n  have : Continuous fun p : X‚ÇÄ √ó Y => g ((Prod.swap p).1, f (Prod.swap p).2) :=\n    hg.comp continuous_swap\n  have : Continuous fun p : X‚ÇÄ √ó Y => (g ‚àò Prod.swap) (f p.1, p.2) := this\n  exact (hf.continuous_lift_prod_left this).comp continuous_swap\n\n"}
{"name":"QuotientMap.continuous_lift_prod_right","module":"Mathlib.Topology.CompactOpen","initialProofState":"X‚ÇÄ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÄ\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : LocallyCompactSpace Y\nf : X‚ÇÄ ‚Üí X\nhf : Topology.IsQuotientMap f\ng : Prod Y X ‚Üí Z\nhg : Continuous fun p => g { fst := p.1, snd := f p.2 }\n‚ä¢ Continuous g","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.continuous_lift_prod_right := IsQuotientMap.continuous_lift_prod_right\n\n"}
