{"name":"ContinuousMap.compactOpen_eq","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Eq ContinuousMap.compactOpen (TopologicalSpace.generateFrom (Set.image2 (fun K U => setOf fun f => Set.MapsTo (⇑f) K U) (setOf fun K => IsCompact K) (setOf fun t => IsOpen t)))","decl":"/-- Definition of `ContinuousMap.compactOpen`. -/\ntheorem compactOpen_eq : @compactOpen X Y _ _ =\n    .generateFrom (image2 (fun K U ↦ {f | MapsTo f K U}) {K | IsCompact K} {t | IsOpen t}) :=\n   rfl\n\n"}
{"name":"ContinuousMap.isOpen_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nK : Set X\nU : Set Y\nhK : IsCompact K\nhU : IsOpen U\n⊢ IsOpen (setOf fun f => Set.MapsTo (⇑f) K U)","decl":"theorem isOpen_setOf_mapsTo (hK : IsCompact K) (hU : IsOpen U) :\n    IsOpen {f : C(X, Y) | MapsTo f K U} :=\n  isOpen_generateFrom_of_mem <| mem_image2_of_mem hK hU\n\n"}
{"name":"ContinuousMap.eventually_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nK : Set X\nU : Set Y\nf : ContinuousMap X Y\nhK : IsCompact K\nhU : IsOpen U\nh : Set.MapsTo (⇑f) K U\n⊢ Filter.Eventually (fun g => Set.MapsTo (⇑g) K U) (nhds f)","decl":"lemma eventually_mapsTo {f : C(X, Y)} (hK : IsCompact K) (hU : IsOpen U) (h : MapsTo f K U) :\n    ∀ᶠ g : C(X, Y) in 𝓝 f, MapsTo g K U :=\n  (isOpen_setOf_mapsTo hK hU).mem_nhds h\n\n"}
{"name":"ContinuousMap.nhds_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\n⊢ Eq (nhds f) (iInf fun K => iInf fun x => iInf fun U => iInf fun x => iInf fun x => Filter.principal (setOf fun g => Set.MapsTo (⇑g) K U))","decl":"lemma nhds_compactOpen (f : C(X, Y)) :\n    𝓝 f = ⨅ (K : Set X) (_ : IsCompact K) (U : Set Y) (_ : IsOpen U) (_ : MapsTo f K U),\n      𝓟 {g : C(X, Y) | MapsTo g K U} := by\n  simp_rw [compactOpen_eq, nhds_generateFrom, mem_setOf_eq, @and_comm (f ∈ _), iInf_and,\n    ← image_prod, iInf_image, biInf_prod, mem_setOf_eq]\n\n"}
{"name":"ContinuousMap.tendsto_nhds_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"α : Type u_1\nY : Type u_3\nZ : Type u_4\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nl : Filter α\nf : α → ContinuousMap Y Z\ng : ContinuousMap Y Z\n⊢ Iff (Filter.Tendsto f l (nhds g)) (∀ (K : Set Y), IsCompact K → ∀ (U : Set Z), IsOpen U → Set.MapsTo (⇑g) K U → Filter.Eventually (fun a => Set.MapsTo (⇑(f a)) K U) l)","decl":"lemma tendsto_nhds_compactOpen {l : Filter α} {f : α → C(Y, Z)} {g : C(Y, Z)} :\n    Tendsto f l (𝓝 g) ↔\n      ∀ K, IsCompact K → ∀ U, IsOpen U → MapsTo g K U → ∀ᶠ a in l, MapsTo (f a) K U := by\n  simp [nhds_compactOpen]\n\n"}
{"name":"ContinuousMap.continuous_compactOpen","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → ContinuousMap Y Z\n⊢ Iff (Continuous f) (∀ (K : Set Y), IsCompact K → ∀ (U : Set Z), IsOpen U → IsOpen (setOf fun x => Set.MapsTo (⇑(f x)) K U))","decl":"lemma continuous_compactOpen {f : X → C(Y, Z)} :\n    Continuous f ↔ ∀ K, IsCompact K → ∀ U, IsOpen U → IsOpen {x | MapsTo (f x) K U} :=\n  continuous_generateFrom_iff.trans forall_mem_image2\n\n"}
{"name":"ContinuousMap.continuous_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\n⊢ Continuous g.comp","decl":"/-- `C(X, ·)` is a functor. -/\ntheorem continuous_postcomp (g : C(Y, Z)) : Continuous (ContinuousMap.comp g : C(X, Y) → C(X, Z)) :=\n  continuous_compactOpen.2 fun _K hK _U hU ↦ isOpen_setOf_mapsTo hK (hU.preimage g.2)\n\n"}
{"name":"ContinuousMap.continuous_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\n⊢ Continuous g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias continuous_comp := continuous_postcomp\n\n"}
{"name":"ContinuousMap.isInducing_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ⇑g\n⊢ Topology.IsInducing g.comp","decl":"/-- If `g : C(Y, Z)` is a topology inducing map,\nthen the composition `ContinuousMap.comp g : C(X, Y) → C(X, Z)` is a topology inducing map too. -/\ntheorem isInducing_postcomp (g : C(Y, Z)) (hg : IsInducing g) :\n    IsInducing (g.comp : C(X, Y) → C(X, Z)) where\n  eq_induced := by\n    simp only [compactOpen_eq, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,\n      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]\n\n"}
{"name":"ContinuousMap.inducing_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ⇑g\n⊢ Topology.IsInducing g.comp","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_postcomp := isInducing_postcomp\n\n"}
{"name":"ContinuousMap.inducing_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsInducing ⇑g\n⊢ Topology.IsInducing g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias inducing_comp := isInducing_postcomp\n\n"}
{"name":"ContinuousMap.isEmbedding_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding g.comp","decl":"/-- If `g : C(Y, Z)` is a topological embedding,\nthen the composition `ContinuousMap.comp g : C(X, Y) → C(X, Z)` is an embedding too. -/\ntheorem isEmbedding_postcomp (g : C(Y, Z)) (hg : IsEmbedding g) :\n    IsEmbedding (g.comp : C(X, Y) → C(X, Z)) :=\n  ⟨isInducing_postcomp g hg.1, fun _ _ ↦ (cancel_left hg.2).1⟩\n\n"}
{"name":"ContinuousMap.embedding_postcomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_postcomp := isEmbedding_postcomp\n\n"}
{"name":"ContinuousMap.embedding_comp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nhg : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-19\")] alias embedding_comp := isEmbedding_postcomp\n\n"}
{"name":"ContinuousMap.continuous_precomp","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\n⊢ Continuous fun g => g.comp f","decl":"/-- `C(·, Z)` is a functor. -/\n@[continuity, fun_prop]\ntheorem continuous_precomp (f : C(X, Y)) : Continuous (fun g => g.comp f : C(Y, Z) → C(X, Z)) :=\n  continuous_compactOpen.2 fun K hK U hU ↦ by\n    simpa only [mapsTo_image_iff] using isOpen_setOf_mapsTo (hK.image f.2) hU\n\n"}
{"name":"ContinuousMap.continuous_comp_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\n⊢ Continuous fun g => g.comp f","decl":"@[deprecated (since := \"2024-10-19\")] alias continuous_comp_left := continuous_precomp\n\n"}
{"name":"ContinuousMap.compRightContinuousMap_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\ng : ContinuousMap Y Z\n⊢ Eq ((ContinuousMap.compRightContinuousMap Z f) g) (g.comp f)","decl":"variable (Z) in\n/-- Precomposition by a continuous map is itself a continuous map between spaces of continuous maps.\n-/\n@[simps apply]\ndef compRightContinuousMap (f : C(X, Y)) :\n    C(C(Y, Z), C(X, Z)) where\n  toFun g := g.comp f\n\n"}
{"name":"ContinuousMap.continuous_comp'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactPair Y Z\n⊢ Continuous fun x => x.2.comp x.1","decl":"/-- Composition is a continuous map from `C(X, Y) × C(Y, Z)` to `C(X, Z)`,\nprovided that `Y` is locally compact.\nThis is Prop. 9 of Chap. X, §3, №. 4 of Bourbaki's *Topologie Générale*. -/\ntheorem continuous_comp' : Continuous fun x : C(X, Y) × C(Y, Z) => x.2.comp x.1 := by\n  simp_rw [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen]\n  intro ⟨f, g⟩ K hK U hU (hKU : MapsTo (g ∘ f) K U)\n  obtain ⟨L, hKL, hLc, hLU⟩ : ∃ L ∈ 𝓝ˢ (f '' K), IsCompact L ∧ MapsTo g L U :=\n    exists_mem_nhdsSet_isCompact_mapsTo g.continuous (hK.image f.continuous) hU\n      (mapsTo_image_iff.2 hKU)\n  rw [← subset_interior_iff_mem_nhdsSet, ← mapsTo'] at hKL\n  exact ((eventually_mapsTo hK isOpen_interior hKL).prod_nhds\n    (eventually_mapsTo hLc hU hLU)).mono fun ⟨f', g'⟩ ⟨hf', hg'⟩ ↦\n      hg'.comp <| hf'.mono_right interior_subset\n\n"}
{"name":"Filter.Tendsto.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactPair Y Z\nα : Type u_6\nl : Filter α\ng : α → ContinuousMap Y Z\ng₀ : ContinuousMap Y Z\nf : α → ContinuousMap X Y\nf₀ : ContinuousMap X Y\nhg : Filter.Tendsto g l (nhds g₀)\nhf : Filter.Tendsto f l (nhds f₀)\n⊢ Filter.Tendsto (fun a => (g a).comp (f a)) l (nhds (g₀.comp f₀))","decl":"lemma _root_.Filter.Tendsto.compCM {α : Type*} {l : Filter α} {g : α → C(Y, Z)} {g₀ : C(Y, Z)}\n    {f : α → C(X, Y)} {f₀ : C(X, Y)} (hg : Tendsto g l (𝓝 g₀)) (hf : Tendsto f l (𝓝 f₀)) :\n    Tendsto (fun a ↦ (g a).comp (f a)) l (𝓝 (g₀.comp f₀)) :=\n  (continuous_comp'.tendsto (f₀, g₀)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"ContinuousAt.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : LocallyCompactPair Y Z\nX' : Type u_6\ninst✝ : TopologicalSpace X'\na : X'\ng : X' → ContinuousMap Y Z\nf : X' → ContinuousMap X Y\nhg : ContinuousAt g a\nhf : ContinuousAt f a\n⊢ ContinuousAt (fun x => (g x).comp (f x)) a","decl":"nonrec lemma _root_.ContinuousAt.compCM (hg : ContinuousAt g a) (hf : ContinuousAt f a) :\n    ContinuousAt (fun x ↦ (g x).comp (f x)) a :=\n  hg.compCM hf\n\n"}
{"name":"ContinuousWithinAt.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : LocallyCompactPair Y Z\nX' : Type u_6\ninst✝ : TopologicalSpace X'\na : X'\ng : X' → ContinuousMap Y Z\nf : X' → ContinuousMap X Y\ns : Set X'\nhg : ContinuousWithinAt g s a\nhf : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => (g x).comp (f x)) s a","decl":"nonrec lemma _root_.ContinuousWithinAt.compCM (hg : ContinuousWithinAt g s a)\n    (hf : ContinuousWithinAt f s a) : ContinuousWithinAt (fun x ↦ (g x).comp (f x)) s a :=\n  hg.compCM hf\n\n"}
{"name":"ContinuousOn.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : LocallyCompactPair Y Z\nX' : Type u_6\ninst✝ : TopologicalSpace X'\ng : X' → ContinuousMap Y Z\nf : X' → ContinuousMap X Y\ns : Set X'\nhg : ContinuousOn g s\nhf : ContinuousOn f s\n⊢ ContinuousOn (fun x => (g x).comp (f x)) s","decl":"lemma _root_.ContinuousOn.compCM (hg : ContinuousOn g s) (hf : ContinuousOn f s) :\n    ContinuousOn (fun x ↦ (g x).comp (f x)) s := fun a ha ↦\n  (hg a ha).compCM (hf a ha)\n\n"}
{"name":"Continuous.compCM","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : LocallyCompactPair Y Z\nX' : Type u_6\ninst✝ : TopologicalSpace X'\ng : X' → ContinuousMap Y Z\nf : X' → ContinuousMap X Y\nhg : Continuous g\nhf : Continuous f\n⊢ Continuous fun x => (g x).comp (f x)","decl":"lemma _root_.Continuous.compCM (hg : Continuous g) (hf : Continuous f) :\n    Continuous fun x => (g x).comp (f x) :=\n  continuous_comp'.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousMap.instContinuousEvalOfLocallyCompactPair","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : LocallyCompactPair X Y\n⊢ ContinuousEval (ContinuousMap X Y) X Y","decl":"/-- The evaluation map `C(X, Y) × X → Y` is continuous\nif `X, Y` is a locally compact pair of spaces. -/\ninstance [LocallyCompactPair X Y] : ContinuousEval C(X, Y) X Y where\n  continuous_eval := by\n    simp_rw [continuous_iff_continuousAt, ContinuousAt, (nhds_basis_opens _).tendsto_right_iff]\n    rintro ⟨f, x⟩ U ⟨hx : f x ∈ U, hU : IsOpen U⟩\n    rcases exists_mem_nhds_isCompact_mapsTo f.continuous (hU.mem_nhds hx) with ⟨K, hxK, hK, hKU⟩\n    filter_upwards [prod_mem_nhds (eventually_mapsTo hK hU hKU) hxK] using fun _ h ↦ h.1 h.2\n\n"}
{"name":"ContinuousMap.continuous_eval","module":"Mathlib.Topology.CompactOpen","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝³ : FunLike F X Y\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nself : ContinuousEval F X Y\n⊢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-01\")] protected alias continuous_eval := continuous_eval\n\n"}
{"name":"ContinuousMap.instContinuousEvalConst","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ ContinuousEvalConst (ContinuousMap X Y) X Y","decl":"instance : ContinuousEvalConst C(X, Y) X Y where\n  continuous_eval_const x :=\n    continuous_def.2 fun U hU ↦ by simpa using isOpen_setOf_mapsTo isCompact_singleton hU\n\n"}
{"name":"ContinuousMap.continuous_eval_const","module":"Mathlib.Topology.CompactOpen","initialProofState":"F : Type u_1\nα : outParam (Type u_2)\nX : outParam (Type u_3)\ninst✝² : FunLike F α X\ninst✝¹ : TopologicalSpace F\ninst✝ : TopologicalSpace X\nself : ContinuousEvalConst F α X\nx : α\n⊢ Continuous fun f => f x","decl":"@[deprecated (since := \"2024-10-01\")] protected alias continuous_eval_const := continuous_eval_const\n\n"}
{"name":"ContinuousMap.continuous_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous DFunLike.coe","decl":"@[deprecated continuous_coeFun (since := \"2024-10-01\")]\ntheorem continuous_coe : Continuous ((⇑) : C(X, Y) → (X → Y)) :=\n  continuous_coeFun\n\n"}
{"name":"ContinuousMap.isClosed_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nt : Set Y\nht : IsClosed t\ns : Set X\n⊢ IsClosed (setOf fun f => Set.MapsTo (⇑f) s t)","decl":"lemma isClosed_setOf_mapsTo {t : Set Y} (ht : IsClosed t) (s : Set X) :\n    IsClosed {f : C(X, Y) | MapsTo f s t} :=\n  ht.setOf_mapsTo fun _ _ ↦ continuous_eval_const _\n\n"}
{"name":"ContinuousMap.isClopen_setOf_mapsTo","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nK : Set X\nU : Set Y\nhK : IsCompact K\nhU : IsClopen U\n⊢ IsClopen (setOf fun f => Set.MapsTo (⇑f) K U)","decl":"lemma isClopen_setOf_mapsTo (hK : IsCompact K) (hU : IsClopen U) :\n    IsClopen {f : C(X, Y) | MapsTo f K U} :=\n  ⟨isClosed_setOf_mapsTo hU.isClosed K, isOpen_setOf_mapsTo hK hU.isOpen⟩\n\n"}
{"name":"ContinuousMap.specializes_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\n⊢ Iff (Specializes ⇑f ⇑g) (Specializes f g)","decl":"@[norm_cast]\nlemma specializes_coe {f g : C(X, Y)} : ⇑f ⤳ ⇑g ↔ f ⤳ g := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.map continuous_coeFun⟩\n  suffices ∀ K, IsCompact K → ∀ U, IsOpen U → MapsTo g K U → MapsTo f K U by\n    simpa [specializes_iff_pure, nhds_compactOpen]\n  exact fun K _ U hU hg x hx ↦ (h.map (continuous_apply x)).mem_open hU (hg hx)\n\n"}
{"name":"ContinuousMap.inseparable_coe","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : ContinuousMap X Y\n⊢ Iff (Inseparable ⇑f ⇑g) (Inseparable f g)","decl":"@[norm_cast]\nlemma inseparable_coe {f g : C(X, Y)} : Inseparable (f : X → Y) g ↔ Inseparable f g := by\n  simp only [inseparable_iff_specializes_and, specializes_coe]\n\n"}
{"name":"ContinuousMap.instT0Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T0Space Y\n⊢ T0Space (ContinuousMap X Y)","decl":"instance [T0Space Y] : T0Space C(X, Y) :=\n  t0Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun\n\n"}
{"name":"ContinuousMap.instR0Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : R0Space Y\n⊢ R0Space (ContinuousMap X Y)","decl":"instance [R0Space Y] : R0Space C(X, Y) where\n  specializes_symmetric f g h := by\n    rw [← specializes_coe] at h ⊢\n    exact h.symm\n\n"}
{"name":"ContinuousMap.instT1Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T1Space Y\n⊢ T1Space (ContinuousMap X Y)","decl":"instance [T1Space Y] : T1Space C(X, Y) :=\n  t1Space_of_injective_of_continuous DFunLike.coe_injective continuous_coeFun\n\n"}
{"name":"ContinuousMap.instR1Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : R1Space Y\n⊢ R1Space (ContinuousMap X Y)","decl":"instance [R1Space Y] : R1Space C(X, Y) :=\n  .of_continuous_specializes_imp continuous_coeFun fun _ _ ↦ specializes_coe.1\n\n"}
{"name":"ContinuousMap.instT2Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T2Space Y\n⊢ T2Space (ContinuousMap X Y)","decl":"instance [T2Space Y] : T2Space C(X, Y) := inferInstance\n\n"}
{"name":"ContinuousMap.instRegularSpace","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : RegularSpace Y\n⊢ RegularSpace (ContinuousMap X Y)","decl":"instance [RegularSpace Y] : RegularSpace C(X, Y) :=\n  .of_lift'_closure_le fun f ↦ by\n    rw [← tendsto_id', tendsto_nhds_compactOpen]\n    intro K hK U hU hf\n    rcases (hK.image f.continuous).exists_isOpen_closure_subset (hU.mem_nhdsSet.2 hf.image_subset)\n      with ⟨V, hVo, hKV, hVU⟩\n    filter_upwards [mem_lift' (eventually_mapsTo hK hVo (mapsTo'.2 hKV))] with g hg\n    refine ((isClosed_setOf_mapsTo isClosed_closure K).closure_subset ?_).mono_right hVU\n    exact closure_mono (fun _ h ↦ h.mono_right subset_closure) hg\n\n"}
{"name":"ContinuousMap.instT3Space","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : T3Space Y\n⊢ T3Space (ContinuousMap X Y)","decl":"instance [T3Space Y] : T3Space C(X, Y) := inferInstance\n\n"}
{"name":"ContinuousMap.continuous_restrict","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\n⊢ Continuous fun F => ContinuousMap.restrict s F","decl":"/-- For any subset `s` of `X`, the restriction of continuous functions to `s` is continuous\nas a function from `C(X, Y)` to `C(s, Y)` with their respective compact-open topologies. -/\ntheorem continuous_restrict (s : Set X) : Continuous fun F : C(X, Y) => F.restrict s :=\n  continuous_precomp <| restrict s <| .id X\n\n"}
{"name":"ContinuousMap.compactOpen_le_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\n⊢ LE.le ContinuousMap.compactOpen (TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen)","decl":"theorem compactOpen_le_induced (s : Set X) :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) ≤\n      .induced (restrict s) ContinuousMap.compactOpen :=\n  (continuous_restrict s).le_induced\n\n"}
{"name":"ContinuousMap.compactOpen_eq_iInf_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Eq ContinuousMap.compactOpen (iInf fun K => iInf fun x => TopologicalSpace.induced (ContinuousMap.restrict K) ContinuousMap.compactOpen)","decl":"/-- The compact-open topology on `C(X, Y)`\nis equal to the infimum of the compact-open topologies on `C(s, Y)` for `s` a compact subset of `X`.\nThe key point of the proof is that for every compact set `K`,\nthe universal set `Set.univ : Set K` is a compact set as well. -/\ntheorem compactOpen_eq_iInf_induced :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      ⨅ (K : Set X) (_ : IsCompact K), .induced (.restrict K) ContinuousMap.compactOpen := by\n  refine le_antisymm (le_iInf₂ fun s _ ↦ compactOpen_le_induced s) ?_\n  refine le_generateFrom <| forall_mem_image2.2 fun K (hK : IsCompact K) U hU ↦ ?_\n  refine TopologicalSpace.le_def.1 (iInf₂_le K hK) _ ?_\n  convert isOpen_induced (isOpen_setOf_mapsTo (isCompact_iff_isCompact_univ.1 hK) hU)\n  simp [mapsTo_univ_iff, Subtype.forall, MapsTo]\n\n"}
{"name":"ContinuousMap.nhds_compactOpen_eq_iInf_nhds_induced","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\n⊢ Eq (nhds f) (iInf fun s => iInf fun x => Filter.comap (ContinuousMap.restrict s) (nhds (ContinuousMap.restrict s f)))","decl":"theorem nhds_compactOpen_eq_iInf_nhds_induced (f : C(X, Y)) :\n    𝓝 f = ⨅ (s) (_ : IsCompact s), (𝓝 (f.restrict s)).comap (ContinuousMap.restrict s) := by\n  rw [compactOpen_eq_iInf_induced]\n  simp only [nhds_iInf, nhds_induced]\n\n"}
{"name":"ContinuousMap.tendsto_compactOpen_restrict","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nι : Type u_6\nl : Filter ι\nF : ι → ContinuousMap X Y\nf : ContinuousMap X Y\nhFf : Filter.Tendsto F l (nhds f)\ns : Set X\n⊢ Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds (ContinuousMap.restrict s f))","decl":"theorem tendsto_compactOpen_restrict {ι : Type*} {l : Filter ι} {F : ι → C(X, Y)} {f : C(X, Y)}\n    (hFf : Filter.Tendsto F l (𝓝 f)) (s : Set X) :\n    Tendsto (fun i => (F i).restrict s) l (𝓝 (f.restrict s)) :=\n  (continuous_restrict s).continuousAt.tendsto.comp hFf\n\n"}
{"name":"ContinuousMap.tendsto_compactOpen_iff_forall","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nι : Type u_6\nl : Filter ι\nF : ι → ContinuousMap X Y\nf : ContinuousMap X Y\n⊢ Iff (Filter.Tendsto F l (nhds f)) (∀ (K : Set X), IsCompact K → Filter.Tendsto (fun i => ContinuousMap.restrict K (F i)) l (nhds (ContinuousMap.restrict K f)))","decl":"theorem tendsto_compactOpen_iff_forall {ι : Type*} {l : Filter ι} (F : ι → C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (𝓝 f) ↔\n      ∀ K, IsCompact K → Tendsto (fun i => (F i).restrict K) l (𝓝 (f.restrict K)) := by\n  rw [compactOpen_eq_iInf_induced]\n  simp [nhds_iInf, nhds_induced, Filter.tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"ContinuousMap.exists_tendsto_compactOpen_iff_forall","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : WeaklyLocallyCompactSpace X\ninst✝¹ : T2Space Y\nι : Type u_6\nl : Filter ι\ninst✝ : l.NeBot\nF : ι → ContinuousMap X Y\n⊢ Iff (Exists fun f => Filter.Tendsto F l (nhds f)) (∀ (s : Set X), IsCompact s → Exists fun f => Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f))","decl":"/-- A family `F` of functions in `C(X, Y)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `X`. -/\ntheorem exists_tendsto_compactOpen_iff_forall [WeaklyLocallyCompactSpace X] [T2Space Y]\n    {ι : Type*} {l : Filter ι} [Filter.NeBot l] (F : ι → C(X, Y)) :\n    (∃ f, Filter.Tendsto F l (𝓝 f)) ↔\n      ∀ s : Set X, IsCompact s → ∃ f, Filter.Tendsto (fun i => (F i).restrict s) l (𝓝 f) := by\n  constructor\n  · rintro ⟨f, hf⟩ s _\n    exact ⟨f.restrict s, tendsto_compactOpen_restrict hf s⟩\n  · intro h\n    choose f hf using h\n    -- By uniqueness of limits in a `T2Space`, since `fun i ↦ F i x` tends to both `f s₁ hs₁ x` and\n    -- `f s₂ hs₂ x`, we have `f s₁ hs₁ x = f s₂ hs₂ x`\n    have h :\n      ∀ (s₁) (hs₁ : IsCompact s₁) (s₂) (hs₂ : IsCompact s₂) (x : X) (hxs₁ : x ∈ s₁) (hxs₂ : x ∈ s₂),\n        f s₁ hs₁ ⟨x, hxs₁⟩ = f s₂ hs₂ ⟨x, hxs₂⟩ := by\n      rintro s₁ hs₁ s₂ hs₂ x hxs₁ hxs₂\n      haveI := isCompact_iff_compactSpace.mp hs₁\n      haveI := isCompact_iff_compactSpace.mp hs₂\n      have h₁ := (continuous_eval_const (⟨x, hxs₁⟩ : s₁)).continuousAt.tendsto.comp (hf s₁ hs₁)\n      have h₂ := (continuous_eval_const (⟨x, hxs₂⟩ : s₂)).continuousAt.tendsto.comp (hf s₂ hs₂)\n      exact tendsto_nhds_unique h₁ h₂\n    -- So glue the `f s hs` together and prove that this glued function `f₀` is a limit on each\n    -- compact set `s`\n    refine ⟨liftCover' _ _ h exists_compact_mem_nhds, ?_⟩\n    rw [tendsto_compactOpen_iff_forall]\n    intro s hs\n    rw [liftCover_restrict']\n    exact hf s hs\n\n"}
{"name":"ContinuousMap.coev_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nb : Y\n⊢ Eq (⇑(ContinuousMap.coev X Y b)) (Prod.mk b)","decl":"/-- The coevaluation map `Y → C(X, Y × X)` sending a point `x : Y` to the continuous function\non `X` sending `y` to `(x, y)`. -/\n@[simps (config := .asFn)]\ndef coev (b : Y) : C(X, Y × X) :=\n  { toFun := Prod.mk b }\n\n"}
{"name":"ContinuousMap.image_coev","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ny : Y\ns : Set X\n⊢ Eq (Set.image (⇑(ContinuousMap.coev X Y y)) s) (SProd.sprod (Singleton.singleton y) s)","decl":"theorem image_coev {y : Y} (s : Set X) : coev X Y y '' s = {y} ×ˢ s := by simp\n\n"}
{"name":"ContinuousMap.continuous_coev","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous (ContinuousMap.coev X Y)","decl":"/-- The coevaluation map `Y → C(X, Y × X)` is continuous (always). -/\ntheorem continuous_coev : Continuous (coev X Y) := by\n  have : ∀ {a K U}, MapsTo (coev X Y a) K U ↔ {a} ×ˢ K ⊆ U := by simp [mapsTo']\n  simp only [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen, this]\n  intro x K hK U hU hKU\n  rcases generalized_tube_lemma isCompact_singleton hK hU hKU with ⟨V, W, hV, -, hxV, hKW, hVWU⟩\n  filter_upwards [hV.mem_nhds (hxV rfl)] with a ha\n  exact (prod_mono (singleton_subset_iff.mpr ha) hKW).trans hVWU\n\n"}
{"name":"ContinuousMap.curry_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap (Prod X Y) Z\na : X\nb : Y\n⊢ Eq ((f.curry a) b) (f { fst := a, snd := b })","decl":"@[simp]\ntheorem curry_apply (f : C(X × Y, Z)) (a : X) (b : Y) : f.curry a b = f (a, b) :=\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_of_continuous_uncurry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → ContinuousMap Y Z\nh : Continuous (Function.uncurry fun x y => (f x) y)\n⊢ Continuous f","decl":"/-- To show continuity of a map `α → C(β, γ)`, it suffices to show that its uncurried form\n    `α × β → γ` is continuous. -/\ntheorem continuous_of_continuous_uncurry (f : X → C(Y, Z))\n    (h : Continuous (Function.uncurry fun x y => f x y)) : Continuous f :=\n  (curry ⟨_, h⟩).2\n\n"}
{"name":"ContinuousMap.continuous_curry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace (Prod X Y)\n⊢ Continuous ContinuousMap.curry","decl":"/-- The currying process is a continuous map between function spaces. -/\ntheorem continuous_curry [LocallyCompactSpace (X × Y)] :\n    Continuous (curry : C(X × Y, Z) → C(X, C(Y, Z))) := by\n  apply continuous_of_continuous_uncurry\n  apply continuous_of_continuous_uncurry\n  rw [← (Homeomorph.prodAssoc _ _ _).symm.comp_continuous_iff']\n  exact continuous_eval\n\n"}
{"name":"ContinuousMap.continuous_uncurry_of_continuous","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : ContinuousMap X (ContinuousMap Y Z)\n⊢ Continuous (Function.uncurry fun x y => (f x) y)","decl":"/-- The uncurried form of a continuous map `X → C(Y, Z)` is a continuous map `X × Y → Z`. -/\ntheorem continuous_uncurry_of_continuous [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) :\n    Continuous (Function.uncurry fun x y => f x y) :=\n  continuous_eval.comp <| f.continuous.prodMap continuous_id\n\n"}
{"name":"ContinuousMap.uncurry_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : ContinuousMap X (ContinuousMap Y Z)\na✝ : Prod X Y\n⊢ Eq (f.uncurry a✝) (Function.uncurry (fun x y => (f x) y) a✝)","decl":"/-- The uncurried form of a continuous map `X → C(Y, Z)` as a continuous map `X × Y → Z` (if `Y` is\n    locally compact). If `X` is also locally compact, then this is a homeomorphism between the two\n    function spaces, see `Homeomorph.curry`. -/\n@[simps]\ndef uncurry [LocallyCompactSpace Y] (f : C(X, C(Y, Z))) : C(X × Y, Z) :=\n  ⟨_, continuous_uncurry_of_continuous f⟩\n\n"}
{"name":"ContinuousMap.continuous_uncurry","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : LocallyCompactSpace X\ninst✝ : LocallyCompactSpace Y\n⊢ Continuous ContinuousMap.uncurry","decl":"/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem continuous_uncurry [LocallyCompactSpace X] [LocallyCompactSpace Y] :\n    Continuous (uncurry : C(X, C(Y, Z)) → C(X × Y, Z)) := by\n  apply continuous_of_continuous_uncurry\n  rw [← (Homeomorph.prodAssoc _ _ _).comp_continuous_iff']\n  dsimp [Function.comp_def]\n  exact (continuous_fst.fst.eval continuous_fst.snd).eval continuous_snd\n\n"}
{"name":"ContinuousMap.coe_const'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Eq (⇑ContinuousMap.const') (ContinuousMap.const X)","decl":"@[simp]\ntheorem coe_const' : (const' : Y → C(X, Y)) = const X :=\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_const'","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous (ContinuousMap.const X)","decl":"theorem continuous_const' : Continuous (const X : Y → C(X, Y)) :=\n  const'.continuous\n\n"}
{"name":"Homeomorph.continuousMapOfUnique_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Unique X\ny : Y\nx : X\n⊢ Eq ((Homeomorph.continuousMapOfUnique y) x) y","decl":"@[simp]\ntheorem continuousMapOfUnique_apply [Unique X] (y : Y) (x : X) : continuousMapOfUnique y x = y :=\n  rfl\n\n"}
{"name":"Homeomorph.continuousMapOfUnique_symm_apply","module":"Mathlib.Topology.CompactOpen","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Unique X\nf : ContinuousMap X Y\n⊢ Eq (Homeomorph.continuousMapOfUnique.symm f) (f Inhabited.default)","decl":"@[simp]\ntheorem continuousMapOfUnique_symm_apply [Unique X] (f : C(X, Y)) :\n    continuousMapOfUnique.symm f = f default :=\n  rfl\n\n"}
{"name":"Topology.IsQuotientMap.continuous_lift_prod_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X₀ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X₀\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : X₀ → X\nhf : Topology.IsQuotientMap f\ng : Prod X Y → Z\nhg : Continuous fun p => g { fst := f p.1, snd := p.2 }\n⊢ Continuous g","decl":"theorem Topology.IsQuotientMap.continuous_lift_prod_left (hf : IsQuotientMap f) {g : X × Y → Z}\n    (hg : Continuous fun p : X₀ × Y => g (f p.1, p.2)) : Continuous g := by\n  let Gf : C(X₀, C(Y, Z)) := ContinuousMap.curry ⟨_, hg⟩\n  have h : ∀ x : X, Continuous fun y => g (x, y) := by\n    intro x\n    obtain ⟨x₀, rfl⟩ := hf.surjective x\n    exact (Gf x₀).continuous\n  let G : X → C(Y, Z) := fun x => ⟨_, h x⟩\n  have : Continuous G := by\n    rw [hf.continuous_iff]\n    exact Gf.continuous\n  exact ContinuousMap.continuous_uncurry_of_continuous ⟨G, this⟩\n\n"}
{"name":"QuotientMap.continuous_lift_prod_left","module":"Mathlib.Topology.CompactOpen","initialProofState":"X₀ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X₀\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : X₀ → X\nhf : Topology.IsQuotientMap f\ng : Prod X Y → Z\nhg : Continuous fun p => g { fst := f p.1, snd := p.2 }\n⊢ Continuous g","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.continuous_lift_prod_left := IsQuotientMap.continuous_lift_prod_left\n\n"}
{"name":"Topology.IsQuotientMap.continuous_lift_prod_right","module":"Mathlib.Topology.CompactOpen","initialProofState":"X₀ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X₀\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : X₀ → X\nhf : Topology.IsQuotientMap f\ng : Prod Y X → Z\nhg : Continuous fun p => g { fst := p.1, snd := f p.2 }\n⊢ Continuous g","decl":"theorem Topology.IsQuotientMap.continuous_lift_prod_right (hf : IsQuotientMap f) {g : Y × X → Z}\n    (hg : Continuous fun p : Y × X₀ => g (p.1, f p.2)) : Continuous g := by\n  have : Continuous fun p : X₀ × Y => g ((Prod.swap p).1, f (Prod.swap p).2) :=\n    hg.comp continuous_swap\n  have : Continuous fun p : X₀ × Y => (g ∘ Prod.swap) (f p.1, p.2) := this\n  exact (hf.continuous_lift_prod_left this).comp continuous_swap\n\n"}
{"name":"QuotientMap.continuous_lift_prod_right","module":"Mathlib.Topology.CompactOpen","initialProofState":"X₀ : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝⁴ : TopologicalSpace X₀\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : LocallyCompactSpace Y\nf : X₀ → X\nhf : Topology.IsQuotientMap f\ng : Prod Y X → Z\nhg : Continuous fun p => g { fst := p.1, snd := f p.2 }\n⊢ Continuous g","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.continuous_lift_prod_right := IsQuotientMap.continuous_lift_prod_right\n\n"}
