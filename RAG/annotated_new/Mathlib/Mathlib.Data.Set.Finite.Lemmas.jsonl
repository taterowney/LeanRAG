{"name":"Set.Finite.fin_embedding","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Exists fun n => Exists fun f => Eq (Set.range ⇑f) s","decl":"theorem Finite.fin_embedding {s : Set α} (h : s.Finite) :\n    ∃ (n : ℕ) (f : Fin n ↪ α), range f = s :=\n  ⟨_, (Fintype.equivFin (h.toFinset : Set α)).symm.asEmbedding, by\n    simp only [Finset.coe_sort_coe, Equiv.asEmbedding_range, Finite.coe_toFinset, setOf_mem_eq]⟩\n\n"}
{"name":"Set.Finite.fin_param","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Exists fun n => Exists fun f => And (Function.Injective f) (Eq (Set.range f) s)","decl":"theorem Finite.fin_param {s : Set α} (h : s.Finite) :\n    ∃ (n : ℕ) (f : Fin n → α), Injective f ∧ range f = s :=\n  let ⟨n, f, hf⟩ := h.fin_embedding\n  ⟨n, f, f.injective, hf⟩\n\n"}
{"name":"Set.Finite.induction_to","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\nC : Set α → Prop\nS : Set α\nh : S.Finite\nS0 : Set α\nhS0 : HasSubset.Subset S0 S\nH0 : C S0\nH1 : ∀ (s : Set α), HasSSubset.SSubset s S → C s → Exists fun a => And (Membership.mem (SDiff.sdiff S s) a) (C (Insert.insert a s))\n⊢ C S","decl":"/-- Induction up to a finite set `S`. -/\ntheorem Finite.induction_to {C : Set α → Prop} {S : Set α} (h : S.Finite)\n    (S0 : Set α) (hS0 : S0 ⊆ S) (H0 : C S0) (H1 : ∀ s ⊂ S, C s → ∃ a ∈ S \\ s, C (insert a s)) :\n    C S := by\n  have : Finite S := Finite.to_subtype h\n  have : Finite {T : Set α // T ⊆ S} := Finite.of_equiv (Set S) (Equiv.Set.powerset S).symm\n  rw [← Subtype.coe_mk (p := (· ⊆ S)) _ le_rfl]\n  rw [← Subtype.coe_mk (p := (· ⊆ S)) _ hS0] at H0\n  refine Finite.to_wellFoundedGT.wf.induction_bot' (fun s hs hs' ↦ ?_) H0\n  obtain ⟨a, ⟨ha1, ha2⟩, ha'⟩ := H1 s (ssubset_of_ne_of_subset hs s.2) hs'\n  exact ⟨⟨insert a s.1, insert_subset ha1 s.2⟩, Set.ssubset_insert ha2, ha'⟩\n\n"}
{"name":"Set.Finite.induction_to_univ","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\ninst✝ : Finite α\nC : Set α → Prop\nS0 : Set α\nH0 : C S0\nH1 : ∀ (S : Set α), Ne S Set.univ → C S → Exists fun a => And (Not (Membership.mem S a)) (C (Insert.insert a S))\n⊢ C Set.univ","decl":"/-- Induction up to `univ`. -/\ntheorem Finite.induction_to_univ [Finite α] {C : Set α → Prop} (S0 : Set α)\n    (H0 : C S0) (H1 : ∀ S ≠ univ, C S → ∃ a ∉ S, C (insert a S)) : C univ :=\n  finite_univ.induction_to S0 (subset_univ S0) H0 (by simpa [ssubset_univ_iff])\n\n"}
{"name":"Set.exists_min_image","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\ns : Set α\nf : α → β\nh1 : s.Finite\na✝ : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (b : α), Membership.mem s b → LE.le (f a) (f b))","decl":"theorem exists_min_image [LinearOrder β] (s : Set α) (f : α → β) (h1 : s.Finite) :\n    s.Nonempty → ∃ a ∈ s, ∀ b ∈ s, f a ≤ f b\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, Finite.mem_toFinset] using\n      h1.toFinset.exists_min_image f ⟨x, h1.mem_toFinset.2 hx⟩\n\n"}
{"name":"Set.exists_max_image","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\ns : Set α\nf : α → β\nh1 : s.Finite\na✝ : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (b : α), Membership.mem s b → LE.le (f b) (f a))","decl":"theorem exists_max_image [LinearOrder β] (s : Set α) (f : α → β) (h1 : s.Finite) :\n    s.Nonempty → ∃ a ∈ s, ∀ b ∈ s, f b ≤ f a\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, Finite.mem_toFinset] using\n      h1.toFinset.exists_max_image f ⟨x, h1.mem_toFinset.2 hx⟩\n\n"}
{"name":"Set.exists_lower_bound_image","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Nonempty α\ninst✝ : LinearOrder β\ns : Set α\nf : α → β\nh : s.Finite\n⊢ Exists fun a => ∀ (b : α), Membership.mem s b → LE.le (f a) (f b)","decl":"theorem exists_lower_bound_image [Nonempty α] [LinearOrder β] (s : Set α) (f : α → β)\n    (h : s.Finite) : ∃ a : α, ∀ b ∈ s, f a ≤ f b := by\n  rcases s.eq_empty_or_nonempty with rfl | hs\n  · exact ‹Nonempty α›.elim fun a => ⟨a, fun _ => False.elim⟩\n  · rcases Set.exists_min_image s f h hs with ⟨x₀, _, hx₀⟩\n    exact ⟨x₀, fun x hx => hx₀ x hx⟩\n\n"}
{"name":"Set.exists_upper_bound_image","module":"Mathlib.Data.Set.Finite.Lemmas","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Nonempty α\ninst✝ : LinearOrder β\ns : Set α\nf : α → β\nh : s.Finite\n⊢ Exists fun a => ∀ (b : α), Membership.mem s b → LE.le (f b) (f a)","decl":"theorem exists_upper_bound_image [Nonempty α] [LinearOrder β] (s : Set α) (f : α → β)\n    (h : s.Finite) : ∃ a : α, ∀ b ∈ s, f b ≤ f a :=\n  exists_lower_bound_image (β := βᵒᵈ) s f h\n\n"}
