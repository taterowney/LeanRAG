{"name":"DiffContOnCl.ball_subset_image_closedBall","module":"Mathlib.Analysis.Complex.OpenMapping","initialProofState":"f : Complex ‚Üí Complex\nz‚ÇÄ : Complex\nŒµ r : Real\nh : DiffContOnCl Complex f (Metric.ball z‚ÇÄ r)\nhr : LT.lt 0 r\nhf : ‚àÄ (z : Complex), Membership.mem (Metric.sphere z‚ÇÄ r) z ‚Üí LE.le Œµ (Norm.norm (HSub.hSub (f z) (f z‚ÇÄ)))\nhz‚ÇÄ : Filter.Frequently (fun z => Ne (f z) (f z‚ÇÄ)) (nhds z‚ÇÄ)\n‚ä¢ HasSubset.Subset (Metric.ball (f z‚ÇÄ) (HDiv.hDiv Œµ 2)) (Set.image f (Metric.closedBall z‚ÇÄ r))","decl":"/-- If the modulus of a holomorphic function `f` is bounded below by `Œµ` on a circle, then its range\ncontains a disk of radius `Œµ / 2`. -/\ntheorem DiffContOnCl.ball_subset_image_closedBall (h : DiffContOnCl ‚ÑÇ f (ball z‚ÇÄ r)) (hr : 0 < r)\n    (hf : ‚àÄ z ‚àà sphere z‚ÇÄ r, Œµ ‚â§ ‚Äñf z - f z‚ÇÄ‚Äñ) (hz‚ÇÄ : ‚àÉ·∂† z in ùìù z‚ÇÄ, f z ‚â† f z‚ÇÄ) :\n    ball (f z‚ÇÄ) (Œµ / 2) ‚äÜ f '' closedBall z‚ÇÄ r := by\n  /- This is a direct application of the maximum principle. Pick `v` close to `f z‚ÇÄ`, and look at\n    the function `fun z ‚Ü¶ ‚Äñf z - v‚Äñ`: it is bounded below on the circle, and takes a small value\n    at `z‚ÇÄ` so it is not constant on the disk, which implies that its infimum is equal to `0` and\n    hence that `v` is in the range of `f`. -/\n  rintro v hv\n  have h1 : DiffContOnCl ‚ÑÇ (fun z => f z - v) (ball z‚ÇÄ r) := h.sub_const v\n  have h2 : ContinuousOn (fun z => ‚Äñf z - v‚Äñ) (closedBall z‚ÇÄ r) :=\n    continuous_norm.comp_continuousOn (closure_ball z‚ÇÄ hr.ne.symm ‚ñ∏ h1.continuousOn)\n  have h3 : AnalyticOnNhd ‚ÑÇ f (ball z‚ÇÄ r) := h.differentiableOn.analyticOnNhd isOpen_ball\n  have h4 : ‚àÄ z ‚àà sphere z‚ÇÄ r, Œµ / 2 ‚â§ ‚Äñf z - v‚Äñ := fun z hz => by\n    linarith [hf z hz, show ‚Äñv - f z‚ÇÄ‚Äñ < Œµ / 2 from mem_ball.mp hv,\n      norm_sub_sub_norm_sub_le_norm_sub (f z) v (f z‚ÇÄ)]\n  have h5 : ‚Äñf z‚ÇÄ - v‚Äñ < Œµ / 2 := by simpa [‚Üê dist_eq_norm, dist_comm] using mem_ball.mp hv\n  obtain ‚ü®z, hz1, hz2‚ü© : ‚àÉ z ‚àà ball z‚ÇÄ r, IsLocalMin (fun z => ‚Äñf z - v‚Äñ) z :=\n    exists_isLocalMin_mem_ball h2 (mem_closedBall_self hr.le) fun z hz => h5.trans_le (h4 z hz)\n  refine ‚ü®z, ball_subset_closedBall hz1, sub_eq_zero.mp ?_‚ü©\n  have h6 := h1.differentiableOn.eventually_differentiableAt (isOpen_ball.mem_nhds hz1)\n  refine (eventually_eq_or_eq_zero_of_isLocalMin_norm h6 hz2).resolve_left fun key => ?_\n  have h7 : ‚àÄ·∂† w in ùìù z, f w = f z := by filter_upwards [key] with h; field_simp\n  replace h7 : ‚àÉ·∂† w in ùìù[‚â†] z, f w = f z := (h7.filter_mono nhdsWithin_le_nhds).frequently\n  have h8 : IsPreconnected (ball z‚ÇÄ r) := (convex_ball z‚ÇÄ r).isPreconnected\n  have h9 := h3.eqOn_of_preconnected_of_frequently_eq analyticOnNhd_const h8 hz1 h7\n  have h10 : f z = f z‚ÇÄ := (h9 (mem_ball_self hr)).symm\n  exact not_eventually.mpr hz‚ÇÄ (mem_of_superset (ball_mem_nhds z‚ÇÄ hr) (h10 ‚ñ∏ h9))\n\n"}
{"name":"AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux","module":"Mathlib.Analysis.Complex.OpenMapping","initialProofState":"f : Complex ‚Üí Complex\nz‚ÇÄ : Complex\nhf : AnalyticAt Complex f z‚ÇÄ\n‚ä¢ Or (Filter.Eventually (fun z => Eq (f z) (f z‚ÇÄ)) (nhds z‚ÇÄ)) (LE.le (nhds (f z‚ÇÄ)) (Filter.map f (nhds z‚ÇÄ)))","decl":"/-- A function `f : ‚ÑÇ ‚Üí ‚ÑÇ` which is analytic at a point `z‚ÇÄ` is either constant in a neighborhood\nof `z‚ÇÄ`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `z‚ÇÄ` is a neighborhood of `f z‚ÇÄ`, as in `isOpenMap_iff_nhds_le`). For a function `f : E ‚Üí ‚ÑÇ`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux (hf : AnalyticAt ‚ÑÇ f z‚ÇÄ) :\n    (‚àÄ·∂† z in ùìù z‚ÇÄ, f z = f z‚ÇÄ) ‚à® ùìù (f z‚ÇÄ) ‚â§ map f (ùìù z‚ÇÄ) := by\n  /- The function `f` is analytic in a neighborhood of `z‚ÇÄ`; by the isolated zeros principle, if `f`\n    is not constant in a neighborhood of `z‚ÇÄ`, then it is nonzero, and therefore bounded below, on\n    every small enough circle around `z‚ÇÄ` and then `DiffContOnCl.ball_subset_image_closedBall`\n    provides an explicit ball centered at `f z‚ÇÄ` contained in the range of `f`. -/\n  refine or_iff_not_imp_left.mpr fun h => ?_\n  refine (nhds_basis_ball.le_basis_iff (nhds_basis_closedBall.map f)).mpr fun R hR => ?_\n  have h1 := (hf.eventually_eq_or_eventually_ne analyticAt_const).resolve_left h\n  have h2 : ‚àÄ·∂† z in ùìù z‚ÇÄ, AnalyticAt ‚ÑÇ f z := (isOpen_analyticAt ‚ÑÇ f).eventually_mem hf\n  obtain ‚ü®œÅ, hœÅ, h3, h4‚ü© :\n    ‚àÉ œÅ > 0, AnalyticOnNhd ‚ÑÇ f (closedBall z‚ÇÄ œÅ) ‚àß ‚àÄ z ‚àà closedBall z‚ÇÄ œÅ, z ‚â† z‚ÇÄ ‚Üí f z ‚â† f z‚ÇÄ := by\n    simpa only [setOf_and, subset_inter_iff] using\n      nhds_basis_closedBall.mem_iff.mp (h2.and (eventually_nhdsWithin_iff.mp h1))\n  replace h3 : DiffContOnCl ‚ÑÇ f (ball z‚ÇÄ œÅ) :=\n    ‚ü®h3.differentiableOn.mono ball_subset_closedBall,\n      (closure_ball z‚ÇÄ hœÅ.lt.ne.symm).symm ‚ñ∏ h3.continuousOn‚ü©\n  let r := œÅ ‚äì R\n  have hr : 0 < r := lt_inf_iff.mpr ‚ü®hœÅ, hR‚ü©\n  have h5 : closedBall z‚ÇÄ r ‚äÜ closedBall z‚ÇÄ œÅ := closedBall_subset_closedBall inf_le_left\n  have h6 : DiffContOnCl ‚ÑÇ f (ball z‚ÇÄ r) := h3.mono (ball_subset_ball inf_le_left)\n  have h7 : ‚àÄ z ‚àà sphere z‚ÇÄ r, f z ‚â† f z‚ÇÄ := fun z hz =>\n    h4 z (h5 (sphere_subset_closedBall hz)) (ne_of_mem_sphere hz hr.ne.symm)\n  have h8 : (sphere z‚ÇÄ r).Nonempty := NormedSpace.sphere_nonempty.mpr hr.le\n  have h9 : ContinuousOn (fun x => ‚Äñf x - f z‚ÇÄ‚Äñ) (sphere z‚ÇÄ r) := continuous_norm.comp_continuousOn\n    ((h6.sub_const (f z‚ÇÄ)).continuousOn_ball.mono sphere_subset_closedBall)\n  obtain ‚ü®x, hx, hfx‚ü© := (isCompact_sphere z‚ÇÄ r).exists_isMinOn h8 h9\n  refine ‚ü®‚Äñf x - f z‚ÇÄ‚Äñ / 2, half_pos (norm_sub_pos_iff.mpr (h7 x hx)), ?_‚ü©\n  exact (h6.ball_subset_image_closedBall hr (fun z hz => hfx hz) (not_eventually.mp h)).trans\n    (image_subset f (closedBall_subset_closedBall inf_le_right))\n\n"}
{"name":"AnalyticAt.eventually_constant_or_nhds_le_map_nhds","module":"Mathlib.Analysis.Complex.OpenMapping","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\ng : E ‚Üí Complex\nz‚ÇÄ : E\nhg : AnalyticAt Complex g z‚ÇÄ\n‚ä¢ Or (Filter.Eventually (fun z => Eq (g z) (g z‚ÇÄ)) (nhds z‚ÇÄ)) (LE.le (nhds (g z‚ÇÄ)) (Filter.map g (nhds z‚ÇÄ)))","decl":"/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E ‚Üí ‚ÑÇ`\nis analytic at a point `z‚ÇÄ`, then either it is constant in a neighborhood of `z‚ÇÄ`, or it maps every\nneighborhood of `z‚ÇÄ` to a neighborhood of `z‚ÇÄ`. For the particular case of a holomorphic function on\n`‚ÑÇ`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem AnalyticAt.eventually_constant_or_nhds_le_map_nhds {z‚ÇÄ : E} (hg : AnalyticAt ‚ÑÇ g z‚ÇÄ) :\n    (‚àÄ·∂† z in ùìù z‚ÇÄ, g z = g z‚ÇÄ) ‚à® ùìù (g z‚ÇÄ) ‚â§ map g (ùìù z‚ÇÄ) := by\n  /- The idea of the proof is to use the one-dimensional version applied to the restriction of `g`\n    to lines going through `z‚ÇÄ` (indexed by `sphere (0 : E) 1`). If the restriction is eventually\n    constant along each of these lines, then the identity theorem implies that `g` is constant on\n    any ball centered at `z‚ÇÄ` on which it is analytic, and in particular `g` is eventually constant.\n    If on the other hand there is one line along which `g` is not eventually constant, then the\n    one-dimensional version of the open mapping theorem can be used to conclude. -/\n  let ray : E ‚Üí ‚ÑÇ ‚Üí E := fun z t => z‚ÇÄ + t ‚Ä¢ z\n  let gray : E ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun z => g ‚àò ray z\n  obtain ‚ü®r, hr, hgr‚ü© := isOpen_iff.mp (isOpen_analyticAt ‚ÑÇ g) z‚ÇÄ hg\n  have h1 : ‚àÄ z ‚àà sphere (0 : E) 1, AnalyticOnNhd ‚ÑÇ (gray z) (ball 0 r) := by\n    refine fun z hz t ht => AnalyticAt.comp ?_ ?_\n    ¬∑ exact hgr (by simpa [ray, norm_smul, mem_sphere_zero_iff_norm.mp hz] using ht)\n    ¬∑ exact analyticAt_const.add\n        ((ContinuousLinearMap.smulRight (ContinuousLinearMap.id ‚ÑÇ ‚ÑÇ) z).analyticAt t)\n  by_cases h : ‚àÄ z ‚àà sphere (0 : E) 1, ‚àÄ·∂† t in ùìù 0, gray z t = gray z 0\n  ¬∑ left\n    -- If g is eventually constant along every direction, then it is eventually constant\n    refine eventually_of_mem (ball_mem_nhds z‚ÇÄ hr) fun z hz => ?_\n    refine (eq_or_ne z z‚ÇÄ).casesOn (congr_arg g) fun h' => ?_\n    replace h' : ‚Äñz - z‚ÇÄ‚Äñ ‚â† 0 := by simpa only [Ne, norm_eq_zero, sub_eq_zero]\n    let w : E := ‚Äñz - z‚ÇÄ‚Äñ‚Åª¬π ‚Ä¢ (z - z‚ÇÄ)\n    have h3 : ‚àÄ t ‚àà ball (0 : ‚ÑÇ) r, gray w t = g z‚ÇÄ := by\n      have e1 : IsPreconnected (ball (0 : ‚ÑÇ) r) := (convex_ball 0 r).isPreconnected\n      have e2 : w ‚àà sphere (0 : E) 1 := by simp [w, norm_smul, inv_mul_cancel‚ÇÄ h']\n      specialize h1 w e2\n      apply h1.eqOn_of_preconnected_of_eventuallyEq analyticOnNhd_const e1 (mem_ball_self hr)\n      simpa [ray, gray] using h w e2\n    have h4 : ‚Äñz - z‚ÇÄ‚Äñ < r := by simpa [dist_eq_norm] using mem_ball.mp hz\n    replace h4 : ‚Üë‚Äñz - z‚ÇÄ‚Äñ ‚àà ball (0 : ‚ÑÇ) r := by\n      simpa only [mem_ball_zero_iff, norm_eq_abs, abs_ofReal, abs_norm]\n    simpa only [ray, gray, w, smul_smul, mul_inv_cancel‚ÇÄ h', one_smul, add_sub_cancel,\n      Function.comp_apply, coe_smul] using h3 (‚Üë‚Äñz - z‚ÇÄ‚Äñ) h4\n  ¬∑ right\n    -- Otherwise, it is open along at least one direction and that implies the result\n    push_neg at h\n    obtain ‚ü®z, hz, hrz‚ü© := h\n    specialize h1 z hz 0 (mem_ball_self hr)\n    have h7 := h1.eventually_constant_or_nhds_le_map_nhds_aux.resolve_left hrz\n    rw [show gray z 0 = g z‚ÇÄ by simp [gray, ray], ‚Üê map_compose] at h7\n    refine h7.trans (map_mono ?_)\n    have h10 : Continuous fun t : ‚ÑÇ => z‚ÇÄ + t ‚Ä¢ z :=\n      continuous_const.add (continuous_id'.smul continuous_const)\n    simpa using h10.tendsto 0\n\n"}
{"name":"AnalyticOnNhd.is_constant_or_isOpen","module":"Mathlib.Analysis.Complex.OpenMapping","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nU : Set E\ng : E ‚Üí Complex\nhg : AnalyticOnNhd Complex g U\nhU : IsPreconnected U\n‚ä¢ Or (Exists fun w => ‚àÄ (z : E), Membership.mem U z ‚Üí Eq (g z) w) (‚àÄ (s : Set E), HasSubset.Subset s U ‚Üí IsOpen s ‚Üí IsOpen (Set.image g s))","decl":"/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E ‚Üí ‚ÑÇ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `‚ÑÇ`). -/\ntheorem AnalyticOnNhd.is_constant_or_isOpen (hg : AnalyticOnNhd ‚ÑÇ g U) (hU : IsPreconnected U) :\n    (‚àÉ w, ‚àÄ z ‚àà U, g z = w) ‚à® ‚àÄ s ‚äÜ U, IsOpen s ‚Üí IsOpen (g '' s) := by\n  by_cases h : ‚àÉ z‚ÇÄ ‚àà U, ‚àÄ·∂† z in ùìù z‚ÇÄ, g z = g z‚ÇÄ\n  ¬∑ obtain ‚ü®z‚ÇÄ, hz‚ÇÄ, h‚ü© := h\n    exact Or.inl ‚ü®g z‚ÇÄ, hg.eqOn_of_preconnected_of_eventuallyEq analyticOnNhd_const hU hz‚ÇÄ h‚ü©\n  ¬∑ push_neg at h\n    refine Or.inr fun s hs1 hs2 => isOpen_iff_mem_nhds.mpr ?_\n    rintro z ‚ü®w, hw1, rfl‚ü©\n    exact (hg w (hs1 hw1)).eventually_constant_or_nhds_le_map_nhds.resolve_left (h w (hs1 hw1))\n        (image_mem_map (hs2.mem_nhds hw1))\n\n"}
{"name":"AnalyticOn.is_constant_or_isOpen","module":"Mathlib.Analysis.Complex.OpenMapping","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nU : Set E\ng : E ‚Üí Complex\nhg : AnalyticOnNhd Complex g U\nhU : IsPreconnected U\n‚ä¢ Or (Exists fun w => ‚àÄ (z : E), Membership.mem U z ‚Üí Eq (g z) w) (‚àÄ (s : Set E), HasSubset.Subset s U ‚Üí IsOpen s ‚Üí IsOpen (Set.image g s))","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.is_constant_or_isOpen := AnalyticOnNhd.is_constant_or_isOpen\n"}
