{"name":"Polynomial.algebraMap_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (Polynomial A)) r) (Polynomial.C ((algebraMap R A) r))","decl":"@[simp]\ntheorem algebraMap_apply (r : R) : algebraMap R A[X] r = C (algebraMap R A r) :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (Polynomial A)) r).toFinsupp ((algebraMap R (AddMonoidAlgebra A Nat)) r)","decl":"@[simp]\ntheorem toFinsupp_algebraMap (r : R) : (algebraMap R A[X] r).toFinsupp = algebraMap R _ r :=\n  show toFinsupp (C (algebraMap _ _ r)) = _ by\n    rw [toFinsupp_C]\n    rfl\n\n"}
{"name":"Polynomial.ofFinsupp_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq { toFinsupp := (algebraMap R (AddMonoidAlgebra A Nat)) r } ((algebraMap R (Polynomial A)) r)","decl":"theorem ofFinsupp_algebraMap (r : R) : (⟨algebraMap R _ r⟩ : A[X]) = algebraMap R A[X] r :=\n  toFinsupp_injective (toFinsupp_algebraMap _).symm\n\n"}
{"name":"Polynomial.C_eq_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (Polynomial.C r) ((algebraMap R (Polynomial R)) r)","decl":"/-- When we have `[CommSemiring R]`, the function `C` is the same as `algebraMap R R[X]`.\n\n(But note that `C` is defined when `R` is not necessarily commutative, in which case\n`algebraMap` is not available.)\n-/\ntheorem C_eq_algebraMap (r : R) : C r = algebraMap R R[X] r :=\n  rfl\n\n"}
{"name":"Polynomial.algebraMap_eq","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (algebraMap R (Polynomial R)) Polynomial.C","decl":"@[simp]\ntheorem algebraMap_eq : algebraMap R R[X] = C :=\n  rfl\n\n"}
{"name":"Polynomial.CAlgHom_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na✝ : A\n⊢ Eq (Polynomial.CAlgHom a✝) (Polynomial.C a✝)","decl":"/-- `Polynomial.C` as an `AlgHom`. -/\n@[simps! apply]\ndef CAlgHom : A →ₐ[R] A[X] where\n  toRingHom := C\n  commutes' _ := rfl\n\n"}
{"name":"Polynomial.algHom_ext'","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (Polynomial A) B\nhC : Eq (f.comp Polynomial.CAlgHom) (g.comp Polynomial.CAlgHom)\nhX : Eq (f Polynomial.X) (g Polynomial.X)\n⊢ Eq f g","decl":"/-- Extensionality lemma for algebra maps out of `A'[X]` over a smaller base ring than `A'`\n-/\n@[ext 1100]\ntheorem algHom_ext' {f g : A[X] →ₐ[R] B}\n    (hC : f.comp CAlgHom = g.comp CAlgHom)\n    (hX : f X = g X) : f = g :=\n  AlgHom.coe_ringHom_injective (ringHom_ext' (congr_arg AlgHom.toRingHom hC) hX)\n\n"}
{"name":"Polynomial.algHom_ext'_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (Polynomial A) B\n⊢ Iff (Eq f g) (And (Eq (f.comp Polynomial.CAlgHom) (g.comp Polynomial.CAlgHom)) (Eq (f Polynomial.X) (g Polynomial.X)))","decl":"/-- Extensionality lemma for algebra maps out of `A'[X]` over a smaller base ring than `A'`\n-/\n@[ext 1100]\ntheorem algHom_ext' {f g : A[X] →ₐ[R] B}\n    (hC : f.comp CAlgHom = g.comp CAlgHom)\n    (hX : f X = g X) : f = g :=\n  AlgHom.coe_ringHom_injective (ringHom_ext' (congr_arg AlgHom.toRingHom hC) hX)\n\n"}
{"name":"Polynomial.toFinsuppIsoAlg_symm_apply_toFinsupp","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ntoFinsupp : AddMonoidAlgebra R Nat\n⊢ Eq ((Polynomial.toFinsuppIsoAlg R).symm toFinsupp).toFinsupp toFinsupp","decl":"open AddMonoidAlgebra in\n/-- Algebra isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps!]\ndef toFinsuppIsoAlg : R[X] ≃ₐ[R] R[ℕ] :=\n  { toFinsuppIso R with\n    commutes' := fun r => by\n      dsimp }\n\n"}
{"name":"Polynomial.toFinsuppIsoAlg_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nself : Polynomial R\n⊢ Eq ((Polynomial.toFinsuppIsoAlg R) self) self.toFinsupp","decl":"open AddMonoidAlgebra in\n/-- Algebra isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps!]\ndef toFinsuppIsoAlg : R[X] ≃ₐ[R] R[ℕ] :=\n  { toFinsuppIso R with\n    commutes' := fun r => by\n      dsimp }\n\n"}
{"name":"Polynomial.subalgebraNontrivial","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial A\n⊢ Nontrivial (Subalgebra R (Polynomial A))","decl":"instance subalgebraNontrivial [Nontrivial A] : Nontrivial (Subalgebra R A[X]) :=\n  ⟨⟨⊥, ⊤, by\n      rw [Ne, SetLike.ext_iff, not_forall]\n      refine ⟨X, ?_⟩\n      simp only [Algebra.mem_bot, not_exists, Set.mem_range, iff_true, Algebra.mem_top,\n        algebraMap_apply, not_forall]\n      intro x\n      rw [ext_iff, not_forall]\n      refine ⟨1, ?_⟩\n      simp [coeff_C]⟩⟩\n\n"}
{"name":"Polynomial.algHom_eval₂_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\np : Polynomial R\nf : AlgHom R A B\na : A\n⊢ Eq (f (Polynomial.eval₂ (algebraMap R A) a p)) (Polynomial.eval₂ (algebraMap R B) (f a) p)","decl":"@[simp]\ntheorem algHom_eval₂_algebraMap {R A B : Type*} [CommSemiring R] [Semiring A] [Semiring B]\n    [Algebra R A] [Algebra R B] (p : R[X]) (f : A →ₐ[R] B) (a : A) :\n    f (eval₂ (algebraMap R A) a p) = eval₂ (algebraMap R B) (f a) p := by\n  simp only [eval₂_eq_sum, sum_def]\n  simp only [map_sum, map_mul, map_pow, eq_intCast, map_intCast, AlgHom.commutes]\n\n"}
{"name":"Polynomial.eval₂_algebraMap_X","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial R\nf : AlgHom R (Polynomial R) A\n⊢ Eq (Polynomial.eval₂ (algebraMap R A) (f Polynomial.X) p) (f p)","decl":"@[simp]\ntheorem eval₂_algebraMap_X {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] (p : R[X])\n    (f : R[X] →ₐ[R] A) : eval₂ (algebraMap R A) (f X) p = f p := by\n  conv_rhs => rw [← Polynomial.sum_C_mul_X_pow_eq p]\n  simp only [eval₂_eq_sum, sum_def]\n  simp only [map_sum, map_mul, map_pow, eq_intCast, map_intCast]\n  simp [Polynomial.C_eq_algebraMap]\n\n-- these used to be about `algebraMap ℤ R`, but now the simp-normal form is `Int.castRingHom R`.\n"}
{"name":"Polynomial.ringHom_eval₂_intCastRingHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝¹ : Ring R\ninst✝ : Ring S\np : Polynomial Int\nf : RingHom R S\nr : R\n⊢ Eq (f (Polynomial.eval₂ (Int.castRingHom R) r p)) (Polynomial.eval₂ (Int.castRingHom S) (f r) p)","decl":"@[simp]\ntheorem ringHom_eval₂_intCastRingHom {R S : Type*} [Ring R] [Ring S] (p : ℤ[X]) (f : R →+* S)\n    (r : R) : f (eval₂ (Int.castRingHom R) r p) = eval₂ (Int.castRingHom S) (f r) p :=\n  algHom_eval₂_algebraMap p f.toIntAlgHom r\n\n"}
{"name":"Polynomial.eval₂_intCastRingHom_X","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : Ring R\np : Polynomial Int\nf : RingHom (Polynomial Int) R\n⊢ Eq (Polynomial.eval₂ (Int.castRingHom R) (f Polynomial.X) p) (f p)","decl":"@[simp]\ntheorem eval₂_intCastRingHom_X {R : Type*} [Ring R] (p : ℤ[X]) (f : ℤ[X] →+* R) :\n    eval₂ (Int.castRingHom R) (f X) p = f p :=\n  eval₂_algebraMap_X p f.toIntAlgHom\n\n"}
{"name":"Polynomial.eval₂AlgHom'_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nb : B\nhf : ∀ (a : A), Commute (f a) b\np : Polynomial A\n⊢ Eq ((Polynomial.eval₂AlgHom' f b hf) p) (Polynomial.eval₂ (↑f) b p)","decl":"/-- `Polynomial.eval₂` as an `AlgHom` for noncommutative algebras.\n\nThis is `Polynomial.eval₂RingHom'` for `AlgHom`s. -/\n@[simps!]\ndef eval₂AlgHom' (f : A →ₐ[R] B) (b : B) (hf : ∀ a, Commute (f a) b) : A[X] →ₐ[R] B where\n  toRingHom := eval₂RingHom' f b hf\n  commutes' _ := (eval₂_C _ _).trans (f.commutes _)\n\n"}
{"name":"Polynomial.coe_mapAlgHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (⇑(Polynomial.mapAlgHom f)) (Polynomial.map ↑f)","decl":"@[simp]\ntheorem coe_mapAlgHom (f : A →ₐ[R] B) : ⇑(mapAlgHom f) = map f :=\n  rfl\n\n"}
{"name":"Polynomial.mapAlgHom_id","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Polynomial.mapAlgHom (AlgHom.id R A)) (AlgHom.id R (Polynomial A))","decl":"@[simp]\ntheorem mapAlgHom_id : mapAlgHom (AlgHom.id R A) = AlgHom.id R (Polynomial A) :=\n  AlgHom.ext fun _x => map_id\n\n"}
{"name":"Polynomial.mapAlgHom_coe_ringHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (↑(Polynomial.mapAlgHom f)) (Polynomial.mapRingHom ↑f)","decl":"@[simp]\ntheorem mapAlgHom_coe_ringHom (f : A →ₐ[R] B) :\n    ↑(mapAlgHom f : _ →ₐ[R] Polynomial B) = (mapRingHom ↑f : Polynomial A →+* Polynomial B) :=\n  rfl\n\n"}
{"name":"Polynomial.mapAlgHom_comp","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nC : Type z\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nf : AlgHom R B C\ng : AlgHom R A B\n⊢ Eq ((Polynomial.mapAlgHom f).comp (Polynomial.mapAlgHom g)) (Polynomial.mapAlgHom (f.comp g))","decl":"@[simp]\ntheorem mapAlgHom_comp (C : Type z) [Semiring C] [Algebra R C] (f : B →ₐ[R] C) (g : A →ₐ[R] B) :\n    (mapAlgHom f).comp (mapAlgHom g) = mapAlgHom (f.comp g) := by\n  apply AlgHom.ext\n  intro x\n  simp [AlgHom.comp_algebraMap, map_map]\n  congr\n\n"}
{"name":"Polynomial.mapAlgHom_eq_eval₂AlgHom'_CAlgHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (Polynomial.mapAlgHom f) (Polynomial.eval₂AlgHom' (Polynomial.CAlgHom.comp f) Polynomial.X ⋯)","decl":"theorem mapAlgHom_eq_eval₂AlgHom'_CAlgHom (f : A →ₐ[R] B) : mapAlgHom f = eval₂AlgHom'\n    (CAlgHom.comp f) X (fun a => (commute_X (C (f a))).symm) := by\n  apply AlgHom.ext\n  intro x\n  congr\n\n"}
{"name":"Polynomial.coe_mapAlgEquiv","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\n⊢ Eq (⇑(Polynomial.mapAlgEquiv f)) (Polynomial.map ↑f)","decl":"@[simp]\ntheorem coe_mapAlgEquiv (f : A ≃ₐ[R] B) : ⇑(mapAlgEquiv f) = map f :=\n  rfl\n\n"}
{"name":"Polynomial.mapAlgEquiv_id","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Polynomial.mapAlgEquiv AlgEquiv.refl) AlgEquiv.refl","decl":"@[simp]\ntheorem mapAlgEquiv_id : mapAlgEquiv (@AlgEquiv.refl R A _ _ _) = AlgEquiv.refl :=\n  AlgEquiv.ext fun _x => map_id\n\n"}
{"name":"Polynomial.mapAlgEquiv_coe_ringHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\n⊢ Eq (↑(Polynomial.mapAlgEquiv f)) (Polynomial.mapRingHom ↑f)","decl":"@[simp]\ntheorem mapAlgEquiv_coe_ringHom (f : A ≃ₐ[R] B) :\n    ↑(mapAlgEquiv f : _ ≃ₐ[R] Polynomial B) = (mapRingHom ↑f : Polynomial A →+* Polynomial B) :=\n  rfl\n\n"}
{"name":"Polynomial.mapAlgEquiv_comp","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nC : Type z\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nf : AlgEquiv R A B\ng : AlgEquiv R B C\n⊢ Eq ((Polynomial.mapAlgEquiv f).trans (Polynomial.mapAlgEquiv g)) (Polynomial.mapAlgEquiv (f.trans g))","decl":"@[simp]\ntheorem mapAlgEquiv_comp (C : Type z) [Semiring C] [Algebra R C] (f : A ≃ₐ[R] B) (g : B ≃ₐ[R] C) :\n    (mapAlgEquiv f).trans (mapAlgEquiv g) = mapAlgEquiv (f.trans g) := by\n  apply AlgEquiv.ext\n  intro x\n  simp [AlgEquiv.trans_apply, map_map]\n  congr\n\n"}
{"name":"Polynomial.algHom_ext","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nB : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nf g : AlgHom R (Polynomial R) B\nhX : Eq (f Polynomial.X) (g Polynomial.X)\n⊢ Eq f g","decl":"@[ext 1200]\ntheorem algHom_ext {f g : R[X] →ₐ[R] B} (hX : f X = g X) :\n    f = g :=\n  algHom_ext' (Subsingleton.elim _ _) hX\n\n"}
{"name":"Polynomial.algHom_ext_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nB : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nf g : AlgHom R (Polynomial R) B\n⊢ Iff (Eq f g) (Eq (f Polynomial.X) (g Polynomial.X))","decl":"@[ext 1200]\ntheorem algHom_ext {f g : R[X] →ₐ[R] B} (hX : f X = g X) :\n    f = g :=\n  algHom_ext' (Subsingleton.elim _ _) hX\n\n"}
{"name":"Polynomial.aeval_def","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\np : Polynomial R\n⊢ Eq ((Polynomial.aeval x) p) (Polynomial.eval₂ (algebraMap R A) x p)","decl":"theorem aeval_def (p : R[X]) : aeval x p = eval₂ (algebraMap R A) x p :=\n  rfl\n\n"}
{"name":"Polynomial.aeval_zero","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Eq ((Polynomial.aeval x) 0) 0","decl":"theorem aeval_zero : aeval x (0 : R[X]) = 0 :=\n  map_zero (aeval x)\n\n"}
{"name":"Polynomial.aeval_X","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Eq ((Polynomial.aeval x) Polynomial.X) x","decl":"@[simp]\ntheorem aeval_X : aeval x (X : R[X]) = x :=\n  eval₂_X _ x\n\n"}
{"name":"Polynomial.aeval_C","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\nr : R\n⊢ Eq ((Polynomial.aeval x) (Polynomial.C r)) ((algebraMap R A) r)","decl":"@[simp]\ntheorem aeval_C (r : R) : aeval x (C r) = algebraMap R A r :=\n  eval₂_C _ x\n\n"}
{"name":"Polynomial.aeval_monomial","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\nn : Nat\nr : R\n⊢ Eq ((Polynomial.aeval x) ((Polynomial.monomial n) r)) (HMul.hMul ((algebraMap R A) r) (HPow.hPow x n))","decl":"@[simp]\ntheorem aeval_monomial {n : ℕ} {r : R} : aeval x (monomial n r) = algebraMap _ _ r * x ^ n :=\n  eval₂_monomial _ _\n\n"}
{"name":"Polynomial.aeval_X_pow","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\nn : Nat\n⊢ Eq ((Polynomial.aeval x) (HPow.hPow Polynomial.X n)) (HPow.hPow x n)","decl":"theorem aeval_X_pow {n : ℕ} : aeval x ((X : R[X]) ^ n) = x ^ n :=\n  eval₂_X_pow _ _\n\n"}
{"name":"Polynomial.aeval_add","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np q : Polynomial R\nx : A\n⊢ Eq ((Polynomial.aeval x) (HAdd.hAdd p q)) (HAdd.hAdd ((Polynomial.aeval x) p) ((Polynomial.aeval x) q))","decl":"theorem aeval_add : aeval x (p + q) = aeval x p + aeval x q :=\n  map_add _ _ _\n\n"}
{"name":"Polynomial.aeval_one","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Eq ((Polynomial.aeval x) 1) 1","decl":"theorem aeval_one : aeval x (1 : R[X]) = 1 :=\n  map_one _\n\n"}
{"name":"Polynomial.aeval_natCast","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\nn : Nat\n⊢ Eq ((Polynomial.aeval x) ↑n) ↑n","decl":"theorem aeval_natCast (n : ℕ) : aeval x (n : R[X]) = n :=\n  map_natCast _ _\n\n"}
{"name":"Polynomial.aeval_mul","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np q : Polynomial R\nx : A\n⊢ Eq ((Polynomial.aeval x) (HMul.hMul p q)) (HMul.hMul ((Polynomial.aeval x) p) ((Polynomial.aeval x) q))","decl":"theorem aeval_mul : aeval x (p * q) = aeval x p * aeval x q :=\n  map_mul _ _ _\n\n"}
{"name":"Polynomial.comp_eq_aeval","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\n⊢ Eq (p.comp q) ((Polynomial.aeval q) p)","decl":"theorem comp_eq_aeval : p.comp q = aeval q p := rfl\n\n"}
{"name":"Polynomial.aeval_comp","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommSemiring R\np q : Polynomial R\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Eq ((Polynomial.aeval x) (p.comp q)) ((Polynomial.aeval ((Polynomial.aeval x) q)) p)","decl":"theorem aeval_comp {A : Type*} [Semiring A] [Algebra R A] (x : A) :\n    aeval x (p.comp q) = aeval (aeval x q) p :=\n  eval₂_comp' x p q\n\n"}
{"name":"Polynomial.algEquivOfCompEqX_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nhpq : Eq (p.comp q) Polynomial.X\nhqp : Eq (q.comp p) Polynomial.X\na : Polynomial R\n⊢ Eq ((p.algEquivOfCompEqX q hpq hqp) a) ((Polynomial.aeval p) a)","decl":"/-- Two polynomials `p` and `q` such that `p(q(X))=X` and `q(p(X))=X`\n  induces an automorphism of the polynomial algebra. -/\n@[simps!]\ndef algEquivOfCompEqX (p q : R[X]) (hpq : p.comp q = X) (hqp : q.comp p = X) : R[X] ≃ₐ[R] R[X] := by\n  refine AlgEquiv.ofAlgHom (aeval p) (aeval q) ?_ ?_ <;>\n    exact AlgHom.ext fun _ ↦ by simp [← comp_eq_aeval, comp_assoc, hpq, hqp]\n\n"}
{"name":"Polynomial.algEquivOfCompEqX_symm_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nhpq : Eq (p.comp q) Polynomial.X\nhqp : Eq (q.comp p) Polynomial.X\na : Polynomial R\n⊢ Eq ((p.algEquivOfCompEqX q hpq hqp).symm a) ((Polynomial.aeval q) a)","decl":"/-- Two polynomials `p` and `q` such that `p(q(X))=X` and `q(p(X))=X`\n  induces an automorphism of the polynomial algebra. -/\n@[simps!]\ndef algEquivOfCompEqX (p q : R[X]) (hpq : p.comp q = X) (hqp : q.comp p = X) : R[X] ≃ₐ[R] R[X] := by\n  refine AlgEquiv.ofAlgHom (aeval p) (aeval q) ?_ ?_ <;>\n    exact AlgHom.ext fun _ ↦ by simp [← comp_eq_aeval, comp_assoc, hpq, hqp]\n\n"}
{"name":"Polynomial.algEquivOfCompEqX_eq_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q p' q' : Polynomial R\nhpq : Eq (p.comp q) Polynomial.X\nhqp : Eq (q.comp p) Polynomial.X\nhpq' : Eq (p'.comp q') Polynomial.X\nhqp' : Eq (q'.comp p') Polynomial.X\n⊢ Iff (Eq (p.algEquivOfCompEqX q hpq hqp) (p'.algEquivOfCompEqX q' hpq' hqp')) (Eq p p')","decl":"@[simp]\ntheorem algEquivOfCompEqX_eq_iff (p q p' q' : R[X])\n    (hpq : p.comp q = X) (hqp : q.comp p = X) (hpq' : p'.comp q' = X) (hqp' : q'.comp p' = X) :\n    algEquivOfCompEqX p q hpq hqp = algEquivOfCompEqX p' q' hpq' hqp' ↔ p = p' :=\n  ⟨fun h ↦ by simpa using congr($h X), fun h ↦ by ext1; simp [h]⟩\n\n"}
{"name":"Polynomial.algEquivOfCompEqX_symm","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nhpq : Eq (p.comp q) Polynomial.X\nhqp : Eq (q.comp p) Polynomial.X\n⊢ Eq (p.algEquivOfCompEqX q hpq hqp).symm (q.algEquivOfCompEqX p hqp hpq)","decl":"@[simp]\ntheorem algEquivOfCompEqX_symm (p q : R[X]) (hpq : p.comp q = X) (hqp : q.comp p = X) :\n    (algEquivOfCompEqX p q hpq hqp).symm = algEquivOfCompEqX q p hqp hpq := rfl\n\n"}
{"name":"Polynomial.algEquivCMulXAddC_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\na✝ b : R\ninst✝ : Invertible a✝\na : Polynomial R\n⊢ Eq ((Polynomial.algEquivCMulXAddC a✝ b) a) ((Polynomial.aeval (HAdd.hAdd (HMul.hMul (Polynomial.C a✝) Polynomial.X) (Polynomial.C b))) a)","decl":"/-- The automorphism of the polynomial algebra given by `p(X) ↦ p(a * X + b)`,\n  with inverse `p(X) ↦ p(a⁻¹ * (X - b))`. -/\n@[simps!]\ndef algEquivCMulXAddC {R : Type*} [CommRing R] (a b : R) [Invertible a] : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (C a * X + C b) (C ⅟ a * (X - C b))\n    (by simp [← C_mul, ← mul_assoc]) (by simp [← C_mul, ← mul_assoc])\n\n"}
{"name":"Polynomial.algEquivCMulXAddC_symm_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\na✝ b : R\ninst✝ : Invertible a✝\na : Polynomial R\n⊢ Eq ((Polynomial.algEquivCMulXAddC a✝ b).symm a) ((Polynomial.aeval (HMul.hMul (Polynomial.C (Invertible.invOf a✝)) (HSub.hSub Polynomial.X (Polynomial.C b)))) a)","decl":"/-- The automorphism of the polynomial algebra given by `p(X) ↦ p(a * X + b)`,\n  with inverse `p(X) ↦ p(a⁻¹ * (X - b))`. -/\n@[simps!]\ndef algEquivCMulXAddC {R : Type*} [CommRing R] (a b : R) [Invertible a] : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (C a * X + C b) (C ⅟ a * (X - C b))\n    (by simp [← C_mul, ← mul_assoc]) (by simp [← C_mul, ← mul_assoc])\n\n"}
{"name":"Polynomial.algEquivCMulXAddC_symm_eq","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\na b : R\ninst✝ : Invertible a\n⊢ Eq (Polynomial.algEquivCMulXAddC a b).symm (Polynomial.algEquivCMulXAddC (Invertible.invOf a) (HMul.hMul (Neg.neg (Invertible.invOf a)) b))","decl":"theorem algEquivCMulXAddC_symm_eq {R : Type*} [CommRing R] (a b : R) [Invertible a] :\n    (algEquivCMulXAddC a b).symm =  algEquivCMulXAddC (⅟ a) (- ⅟ a * b) := by\n  ext p : 1\n  simp only [algEquivCMulXAddC_symm_apply, neg_mul, algEquivCMulXAddC_apply, map_neg, map_mul]\n  congr\n  simp [mul_add, sub_eq_add_neg]\n\n"}
{"name":"Polynomial.algEquivAevalXAddC_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nt : R\na : Polynomial R\n⊢ Eq ((Polynomial.algEquivAevalXAddC t) a) ((Polynomial.aeval (HAdd.hAdd Polynomial.X (Polynomial.C t))) a)","decl":"/-- The automorphism of the polynomial algebra given by `p(X) ↦ p(X+t)`,\n  with inverse `p(X) ↦ p(X-t)`. -/\n@[simps!]\ndef algEquivAevalXAddC {R : Type*} [CommRing R] (t : R) : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (X + C t) (X - C t) (by simp) (by simp)\n\n"}
{"name":"Polynomial.algEquivAevalXAddC_symm_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nt : R\na : Polynomial R\n⊢ Eq ((Polynomial.algEquivAevalXAddC t).symm a) ((Polynomial.aeval (HSub.hSub Polynomial.X (Polynomial.C t))) a)","decl":"/-- The automorphism of the polynomial algebra given by `p(X) ↦ p(X+t)`,\n  with inverse `p(X) ↦ p(X-t)`. -/\n@[simps!]\ndef algEquivAevalXAddC {R : Type*} [CommRing R] (t : R) : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (X + C t) (X - C t) (by simp) (by simp)\n\n"}
{"name":"Polynomial.algEquivAevalXAddC_eq_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nt t' : R\n⊢ Iff (Eq (Polynomial.algEquivAevalXAddC t) (Polynomial.algEquivAevalXAddC t')) (Eq t t')","decl":"@[simp]\ntheorem algEquivAevalXAddC_eq_iff {R : Type*} [CommRing R] (t t' : R) :\n    algEquivAevalXAddC t = algEquivAevalXAddC t' ↔ t = t' := by\n  simp [algEquivAevalXAddC]\n\n"}
{"name":"Polynomial.algEquivAevalXAddC_symm","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nt : R\n⊢ Eq (Polynomial.algEquivAevalXAddC t).symm (Polynomial.algEquivAevalXAddC (Neg.neg t))","decl":"@[simp]\ntheorem algEquivAevalXAddC_symm {R : Type*} [CommRing R] (t : R) :\n    (algEquivAevalXAddC t).symm = algEquivAevalXAddC (-t) := by\n  simp [algEquivAevalXAddC, sub_eq_add_neg]\n\n"}
{"name":"Polynomial.algEquivAevalNegX_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Polynomial R\n⊢ Eq (Polynomial.algEquivAevalNegX a) ((Polynomial.aeval (Neg.neg Polynomial.X)) a)","decl":"/-- The involutive automorphism of the polynomial algebra given by `p(X) ↦ p(-X)`. -/\n@[simps!]\ndef algEquivAevalNegX {R : Type*} [CommRing R] : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (-X) (-X) (by simp) (by simp)\n\n"}
{"name":"Polynomial.algEquivAevalNegX_symm_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Polynomial R\n⊢ Eq (Polynomial.algEquivAevalNegX.symm a) ((Polynomial.aeval (Neg.neg Polynomial.X)) a)","decl":"/-- The involutive automorphism of the polynomial algebra given by `p(X) ↦ p(-X)`. -/\n@[simps!]\ndef algEquivAevalNegX {R : Type*} [CommRing R] : R[X] ≃ₐ[R] R[X] :=\n  algEquivOfCompEqX (-X) (-X) (by simp) (by simp)\n\n"}
{"name":"Polynomial.comp_neg_X_comp_neg_X","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u_3\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq ((p.comp (Neg.neg Polynomial.X)).comp (Neg.neg Polynomial.X)) p","decl":"theorem comp_neg_X_comp_neg_X {R : Type*} [CommRing R] (p : R[X]) :\n    (p.comp (-X)).comp (-X) = p := by\n  rw [comp_assoc]\n  simp only [neg_comp, X_comp, neg_neg, comp_X]\n\n"}
{"name":"Polynomial.aeval_algHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nx : A\n⊢ Eq (Polynomial.aeval (f x)) (f.comp (Polynomial.aeval x))","decl":"theorem aeval_algHom (f : A →ₐ[R] B) (x : A) : aeval (f x) = f.comp (aeval x) :=\n  algHom_ext <| by simp only [aeval_X, AlgHom.comp_apply]\n\n"}
{"name":"Polynomial.aeval_X_left","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Polynomial.aeval Polynomial.X) (AlgHom.id R (Polynomial R))","decl":"@[simp]\ntheorem aeval_X_left : aeval (X : R[X]) = AlgHom.id R R[X] :=\n  algHom_ext <| aeval_X X\n\n"}
{"name":"Polynomial.aeval_X_left_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Eq ((Polynomial.aeval Polynomial.X) p) p","decl":"theorem aeval_X_left_apply (p : R[X]) : aeval X p = p :=\n  AlgHom.congr_fun (@aeval_X_left R _) p\n\n"}
{"name":"Polynomial.eval_unique","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nφ : AlgHom R (Polynomial R) A\np : Polynomial R\n⊢ Eq (φ p) (Polynomial.eval₂ (algebraMap R A) (φ Polynomial.X) p)","decl":"theorem eval_unique (φ : R[X] →ₐ[R] A) (p) : φ p = eval₂ (algebraMap R A) (φ X) p := by\n  rw [← aeval_def, aeval_algHom, aeval_X_left, AlgHom.comp_id]\n\n"}
{"name":"Polynomial.aeval_algHom_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nF : Type u_3\ninst✝¹ : FunLike F A B\ninst✝ : AlgHomClass F R A B\nf : F\nx : A\np : Polynomial R\n⊢ Eq ((Polynomial.aeval (f x)) p) (f ((Polynomial.aeval x) p))","decl":"theorem aeval_algHom_apply {F : Type*} [FunLike F A B] [AlgHomClass F R A B]\n    (f : F) (x : A) (p : R[X]) :\n    aeval (f x) p = f (aeval x p) := by\n  refine Polynomial.induction_on p (by simp [AlgHomClass.commutes]) (fun p q hp hq => ?_)\n    (by simp [AlgHomClass.commutes])\n  rw [map_add, hp, hq, ← map_add, ← map_add]\n\n"}
{"name":"Polynomial.coe_aeval_mk_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial R\nx : A\nS : Subalgebra R A\nh : Membership.mem S x\n⊢ Eq (↑((Polynomial.aeval ⟨x, h⟩) p)) ((Polynomial.aeval x) p)","decl":"@[simp]\nlemma coe_aeval_mk_apply {S : Subalgebra R A} (h : x ∈ S) :\n    (aeval (⟨x, h⟩ : S) p : A) = aeval x p :=\n  (aeval_algHom_apply S.val (⟨x, h⟩ : S) p).symm\n\n"}
{"name":"Polynomial.aeval_algEquiv","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\nx : A\n⊢ Eq (Polynomial.aeval (f x)) ((↑f).comp (Polynomial.aeval x))","decl":"theorem aeval_algEquiv (f : A ≃ₐ[R] B) (x : A) : aeval (f x) = (f : A →ₐ[R] B).comp (aeval x) :=\n  aeval_algHom (f : A →ₐ[R] B) x\n\n"}
{"name":"Polynomial.aeval_algebraMap_apply_eq_algebraMap_eval","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : R\np : Polynomial R\n⊢ Eq ((Polynomial.aeval ((algebraMap R A) x)) p) ((algebraMap R A) (Polynomial.eval x p))","decl":"theorem aeval_algebraMap_apply_eq_algebraMap_eval (x : R) (p : R[X]) :\n    aeval (algebraMap R A x) p = algebraMap R A (p.eval x) :=\n  aeval_algHom_apply (Algebra.ofId R A) x p\n\n"}
{"name":"Polynomial.aeval_prod","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx : Prod A B\n⊢ Eq (Polynomial.aeval x) ((Polynomial.aeval x.1).prod (Polynomial.aeval x.2))","decl":"/-- Polynomial evaluation on a pair is a product of the evaluations on the components. -/\ntheorem aeval_prod (x : A × B) : aeval (R := R) x = (aeval x.1).prod (aeval x.2) :=\n  aeval_algHom (.fst R A B) x ▸ aeval_algHom (.snd R A B) x ▸\n    (aeval x).prod_comp (.fst R A B) (.snd R A B)\n\n"}
{"name":"Polynomial.aeval_prod_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx : Prod A B\np : Polynomial R\n⊢ Eq ((Polynomial.aeval x) p) { fst := (Polynomial.aeval x.1) p, snd := (Polynomial.aeval x.2) p }","decl":"/-- Polynomial evaluation on a pair is a pair of evaluations. -/\ntheorem aeval_prod_apply (x : A × B) (p : Polynomial R) :\n    p.aeval x = (p.aeval x.1, p.aeval x.2) := by simp [aeval_prod]\n\n"}
{"name":"Polynomial.aeval_pi","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nI : Type u_3\nA : I → Type u_4\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\nx : (i : I) → A i\n⊢ Eq (Polynomial.aeval x) (Pi.algHom R A fun i => Polynomial.aeval (x i))","decl":"/-- Polynomial evaluation on an indexed tuple is the indexed product of the evaluations\non the components.\nGeneralizes `Polynomial.aeval_prod` to indexed products. -/\ntheorem aeval_pi (x : Π i, A i) : aeval (R := R) x = Pi.algHom R A (fun i ↦ aeval (x i)) :=\n  (funext fun i ↦ aeval_algHom (Pi.evalAlgHom R A i) x) ▸\n    (Pi.algHom_comp R A (Pi.evalAlgHom R A) (aeval x))\n\n"}
{"name":"Polynomial.aeval_pi_apply₂","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nI : Type u_3\nA : I → Type u_4\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\nx : (i : I) → A i\np : Polynomial R\nj : I\n⊢ Eq ((Polynomial.aeval x) p j) ((Polynomial.aeval (x j)) p)","decl":"theorem aeval_pi_apply₂ (j : I) : p.aeval x j = p.aeval (x j) :=\n  aeval_pi (R := R) x ▸ Pi.algHom_apply R A (fun i ↦ aeval (x i)) p j\n\n"}
{"name":"Polynomial.aeval_pi_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nI : Type u_3\nA : I → Type u_4\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\nx : (i : I) → A i\np : Polynomial R\n⊢ Eq ((Polynomial.aeval x) p) fun j => (Polynomial.aeval (x j)) p","decl":"/-- Polynomial evaluation on an indexed tuple is the indexed tuple of the evaluations\non the components.\nGeneralizes `Polynomial.aeval_prod_apply` to indexed products. -/\ntheorem aeval_pi_apply : p.aeval x = fun j ↦ p.aeval (x j) :=\n  funext fun j ↦ aeval_pi_apply₂ x p j\n\n"}
{"name":"Polynomial.coe_aeval_eq_eval","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (⇑(Polynomial.aeval r)) (Polynomial.eval r)","decl":"@[simp]\ntheorem coe_aeval_eq_eval (r : R) : (aeval r : R[X] → R) = eval r :=\n  rfl\n\n"}
{"name":"Polynomial.coe_aeval_eq_evalRingHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ Eq (↑(Polynomial.aeval x)) (Polynomial.evalRingHom x)","decl":"@[simp]\ntheorem coe_aeval_eq_evalRingHom (x : R) :\n    ((aeval x : R[X] →ₐ[R] R) : R[X] →+* R) = evalRingHom x :=\n  rfl\n\n"}
{"name":"Polynomial.aeval_fn_apply","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nX : Type u_3\ng : Polynomial R\nf : X → R\nx : X\n⊢ Eq ((Polynomial.aeval f) g x) ((Polynomial.aeval (f x)) g)","decl":"@[simp]\ntheorem aeval_fn_apply {X : Type*} (g : R[X]) (f : X → R) (x : X) :\n    ((aeval f) g) x = aeval (f x) g :=\n  (aeval_algHom_apply (Pi.evalAlgHom R (fun _ => R) x) f g).symm\n\n"}
{"name":"Polynomial.aeval_subalgebra_coe","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommSemiring R\ng : Polynomial R\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Subalgebra R A\nf : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((Polynomial.aeval f) g)) ((Polynomial.aeval ↑f) g)","decl":"@[norm_cast]\ntheorem aeval_subalgebra_coe (g : R[X]) {A : Type*} [Semiring A] [Algebra R A] (s : Subalgebra R A)\n    (f : s) : (aeval f g : A) = aeval (f : A) g :=\n  (aeval_algHom_apply s.val f g).symm\n\n"}
{"name":"Polynomial.coeff_zero_eq_aeval_zero","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Eq (p.coeff 0) ((Polynomial.aeval 0) p)","decl":"theorem coeff_zero_eq_aeval_zero (p : R[X]) : p.coeff 0 = aeval 0 p := by\n  simp [coeff_zero_eq_eval_zero]\n\n"}
{"name":"Polynomial.coeff_zero_eq_aeval_zero'","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial R\n⊢ Eq ((algebraMap R A) (p.coeff 0)) ((Polynomial.aeval 0) p)","decl":"theorem coeff_zero_eq_aeval_zero' (p : R[X]) : algebraMap R A (p.coeff 0) = aeval (0 : A) p := by\n  simp [aeval_def]\n\n"}
{"name":"Polynomial.map_aeval_eq_aeval_map","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Type u_3\nT : Type u_4\nU : Type u_5\ninst✝⁴ : Semiring S\ninst✝³ : CommSemiring T\ninst✝² : Semiring U\ninst✝¹ : Algebra R S\ninst✝ : Algebra T U\nφ : RingHom R T\nψ : RingHom S U\nh : Eq ((algebraMap T U).comp φ) (ψ.comp (algebraMap R S))\np : Polynomial R\na : S\n⊢ Eq (ψ ((Polynomial.aeval a) p)) ((Polynomial.aeval (ψ a)) (Polynomial.map φ p))","decl":"theorem map_aeval_eq_aeval_map {S T U : Type*} [Semiring S] [CommSemiring T] [Semiring U]\n    [Algebra R S] [Algebra T U] {φ : R →+* T} {ψ : S →+* U}\n    (h : (algebraMap T U).comp φ = ψ.comp (algebraMap R S)) (p : R[X]) (a : S) :\n    ψ (aeval a p) = aeval (ψ a) (p.map φ) := by\n  conv_rhs => rw [aeval_def, ← eval_map]\n  rw [map_map, h, ← map_map, eval_map, eval₂_at_apply, aeval_def, eval_map]\n\n"}
{"name":"Polynomial.aeval_eq_zero_of_dvd_aeval_eq_zero","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"S : Type v\nT : Type w\ninst✝² : CommSemiring S\ninst✝¹ : CommSemiring T\ninst✝ : Algebra S T\np q : Polynomial S\nh₁ : Dvd.dvd p q\na : T\nh₂ : Eq ((Polynomial.aeval a) p) 0\n⊢ Eq ((Polynomial.aeval a) q) 0","decl":"theorem aeval_eq_zero_of_dvd_aeval_eq_zero [CommSemiring S] [CommSemiring T] [Algebra S T]\n    {p q : S[X]} (h₁ : p ∣ q) {a : T} (h₂ : aeval a p = 0) : aeval a q = 0 := by\n  rw [aeval_def, ← eval_map] at h₂ ⊢\n  exact eval_eq_zero_of_dvd_of_eval_eq_zero (Polynomial.map_dvd (algebraMap S T) h₁) h₂\n\n"}
{"name":"Polynomial.aeval_eq_sum_range","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\nx : S\n⊢ Eq ((Polynomial.aeval x) p) ((Finset.range (HAdd.hAdd p.natDegree 1)).sum fun i => HSMul.hSMul (p.coeff i) (HPow.hPow x i))","decl":"theorem aeval_eq_sum_range [Algebra R S] {p : R[X]} (x : S) :\n    aeval x p = ∑ i ∈ Finset.range (p.natDegree + 1), p.coeff i • x ^ i := by\n  simp_rw [Algebra.smul_def]\n  exact eval₂_eq_sum_range (algebraMap R S) x\n\n"}
{"name":"Polynomial.aeval_eq_sum_range'","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\nn : Nat\nhn : LT.lt p.natDegree n\nx : S\n⊢ Eq ((Polynomial.aeval x) p) ((Finset.range n).sum fun i => HSMul.hSMul (p.coeff i) (HPow.hPow x i))","decl":"theorem aeval_eq_sum_range' [Algebra R S] {p : R[X]} {n : ℕ} (hn : p.natDegree < n) (x : S) :\n    aeval x p = ∑ i ∈ Finset.range n, p.coeff i • x ^ i := by\n  simp_rw [Algebra.smul_def]\n  exact eval₂_eq_sum_range' (algebraMap R S) hn x\n\n"}
{"name":"Polynomial.isRoot_of_eval₂_map_eq_zero","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\nr : R\na✝ : Eq (Polynomial.eval₂ f (f r) p) 0\n⊢ p.IsRoot r","decl":"theorem isRoot_of_eval₂_map_eq_zero (hf : Function.Injective f) {r : R} :\n    eval₂ f (f r) p = 0 → p.IsRoot r := by\n  intro h\n  apply hf\n  rw [← eval₂_hom, h, f.map_zero]\n\n"}
{"name":"Polynomial.isRoot_of_aeval_algebraMap_eq_zero","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\ninj : Function.Injective ⇑(algebraMap R S)\nr : R\nhr : Eq ((Polynomial.aeval ((algebraMap R S) r)) p) 0\n⊢ p.IsRoot r","decl":"theorem isRoot_of_aeval_algebraMap_eq_zero [Algebra R S] {p : R[X]}\n    (inj : Function.Injective (algebraMap R S)) {r : R} (hr : aeval (algebraMap R S r) p = 0) :\n    p.IsRoot r :=\n  isRoot_of_eval₂_map_eq_zero inj hr\n\n"}
{"name":"Polynomial.aevalTower_X","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\n⊢ Eq ((Polynomial.aevalTower g y) Polynomial.X) y","decl":"@[simp]\ntheorem aevalTower_X : aevalTower g y X = y :=\n  eval₂_X _ _\n\n"}
{"name":"Polynomial.aevalTower_C","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\nx : R\n⊢ Eq ((Polynomial.aevalTower g y) (Polynomial.C x)) (g x)","decl":"@[simp]\ntheorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.aevalTower_comp_C","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\n⊢ Eq ((↑(Polynomial.aevalTower g y)).comp Polynomial.C) ↑g","decl":"@[simp]\ntheorem aevalTower_comp_C : (aevalTower g y : R[X] →+* A').comp C = g :=\n  RingHom.ext <| aevalTower_C _ _\n\n"}
{"name":"Polynomial.aevalTower_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\nx : R\n⊢ Eq ((Polynomial.aevalTower g y) ((algebraMap R (Polynomial R)) x)) (g x)","decl":"theorem aevalTower_algebraMap (x : R) : aevalTower g y (algebraMap R R[X] x) = g x :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.aevalTower_comp_algebraMap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\n⊢ Eq ((↑(Polynomial.aevalTower g y)).comp (algebraMap R (Polynomial R))) ↑g","decl":"theorem aevalTower_comp_algebraMap : (aevalTower g y : R[X] →+* A').comp (algebraMap R R[X]) = g :=\n  aevalTower_comp_C _ _\n\n"}
{"name":"Polynomial.aevalTower_toAlgHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\nx : R\n⊢ Eq ((Polynomial.aevalTower g y) ((IsScalarTower.toAlgHom S R (Polynomial R)) x)) (g x)","decl":"theorem aevalTower_toAlgHom (x : R) : aevalTower g y (IsScalarTower.toAlgHom S R R[X] x) = g x :=\n  aevalTower_algebraMap _ _ _\n\n"}
{"name":"Polynomial.aevalTower_comp_toAlgHom","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nS : Type v\nA' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A'\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A'\ng : AlgHom S R A'\ny : A'\n⊢ Eq ((Polynomial.aevalTower g y).comp (IsScalarTower.toAlgHom S R (Polynomial R))) g","decl":"@[simp]\ntheorem aevalTower_comp_toAlgHom : (aevalTower g y).comp (IsScalarTower.toAlgHom S R R[X]) = g :=\n  AlgHom.coe_ringHom_injective <| aevalTower_comp_algebraMap _ _\n\n"}
{"name":"Polynomial.aevalTower_id","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"S : Type v\ninst✝ : CommSemiring S\n⊢ Eq (Polynomial.aevalTower (AlgHom.id S S)) Polynomial.aeval","decl":"@[simp]\ntheorem aevalTower_id : aevalTower (AlgHom.id S S) = aeval := by\n  ext s\n  simp only [eval_X, aevalTower_X, coe_aeval_eq_eval]\n\n"}
{"name":"Polynomial.aevalTower_ofId","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"S : Type v\nA' : Type u_1\ninst✝² : CommSemiring A'\ninst✝¹ : CommSemiring S\ninst✝ : Algebra S A'\n⊢ Eq (Polynomial.aevalTower (Algebra.ofId S A')) Polynomial.aeval","decl":"@[simp]\ntheorem aevalTower_ofId : aevalTower (Algebra.ofId S A') = aeval := by\n  ext\n  simp only [aeval_X, aevalTower_X]\n\n"}
{"name":"Polynomial.dvd_term_of_dvd_eval_of_dvd_terms","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"S : Type v\ninst✝ : CommRing S\nz p : S\nf : Polynomial S\ni : Nat\ndvd_eval : Dvd.dvd p (Polynomial.eval z f)\ndvd_terms : ∀ (j : Nat), Ne j i → Dvd.dvd p (HMul.hMul (f.coeff j) (HPow.hPow z j))\n⊢ Dvd.dvd p (HMul.hMul (f.coeff i) (HPow.hPow z i))","decl":"theorem dvd_term_of_dvd_eval_of_dvd_terms {z p : S} {f : S[X]} (i : ℕ) (dvd_eval : p ∣ f.eval z)\n    (dvd_terms : ∀ j ≠ i, p ∣ f.coeff j * z ^ j) : p ∣ f.coeff i * z ^ i := by\n  by_cases hi : i ∈ f.support\n  · rw [eval, eval₂_eq_sum, sum_def] at dvd_eval\n    rw [← Finset.insert_erase hi, Finset.sum_insert (Finset.not_mem_erase _ _)] at dvd_eval\n    refine (dvd_add_left ?_).mp dvd_eval\n    apply Finset.dvd_sum\n    intro j hj\n    exact dvd_terms j (Finset.ne_of_mem_erase hj)\n  · convert dvd_zero p\n    rw [not_mem_support_iff] at hi\n    simp [hi]\n\n"}
{"name":"Polynomial.dvd_term_of_isRoot_of_dvd_terms","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"S : Type v\ninst✝ : CommRing S\nr p : S\nf : Polynomial S\ni : Nat\nhr : f.IsRoot r\nh : ∀ (j : Nat), Ne j i → Dvd.dvd p (HMul.hMul (f.coeff j) (HPow.hPow r j))\n⊢ Dvd.dvd p (HMul.hMul (f.coeff i) (HPow.hPow r i))","decl":"theorem dvd_term_of_isRoot_of_dvd_terms {r p : S} {f : S[X]} (i : ℕ) (hr : f.IsRoot r)\n    (h : ∀ j ≠ i, p ∣ f.coeff j * r ^ j) : p ∣ f.coeff i * r ^ i :=\n  dvd_term_of_dvd_eval_of_dvd_terms i (Eq.symm hr ▸ dvd_zero p) h\n\n"}
{"name":"Polynomial.eval_mul_X_sub_C","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nr : R\n⊢ Eq (Polynomial.eval r (HMul.hMul p (HSub.hSub Polynomial.X (Polynomial.C r)))) 0","decl":"/-- The evaluation map is not generally multiplicative when the coefficient ring is noncommutative,\nbut nevertheless any polynomial of the form `p * (X - monomial 0 r)` is sent to zero\nwhen evaluated at `r`.\n\nThis is the key step in our proof of the Cayley-Hamilton theorem.\n-/\ntheorem eval_mul_X_sub_C {p : R[X]} (r : R) : (p * (X - C r)).eval r = 0 := by\n  simp only [eval, eval₂_eq_sum, RingHom.id_apply]\n  have bound :=\n    calc\n      (p * (X - C r)).natDegree ≤ p.natDegree + (X - C r).natDegree := natDegree_mul_le\n      _ ≤ p.natDegree + 1 := add_le_add_left (natDegree_X_sub_C_le _) _\n      _ < p.natDegree + 2 := lt_add_one _\n  rw [sum_over_range' _ _ (p.natDegree + 2) bound]\n  swap\n  · simp\n  rw [sum_range_succ']\n  conv_lhs =>\n    congr\n    arg 2\n    simp [coeff_mul_X_sub_C, sub_mul, mul_assoc, ← pow_succ']\n  rw [sum_range_sub']\n  simp [coeff_monomial]\n\n"}
{"name":"Polynomial.not_isUnit_X_sub_C","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\nr : R\n⊢ Not (IsUnit (HSub.hSub Polynomial.X (Polynomial.C r)))","decl":"theorem not_isUnit_X_sub_C [Nontrivial R] (r : R) : ¬IsUnit (X - C r) :=\n  fun ⟨⟨_, g, _hfg, hgf⟩, rfl⟩ => zero_ne_one' R <| by rw [← eval_mul_X_sub_C, hgf, eval_one]\n\n"}
{"name":"Polynomial.aeval_endomorphism","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nv : M\np : Polynomial R\n⊢ Eq (((Polynomial.aeval f) p) v) (p.sum fun n b => HSMul.hSMul b ((HPow.hPow f n) v))","decl":"theorem aeval_endomorphism {M : Type*} [AddCommGroup M] [Module R M] (f : M →ₗ[R] M)\n    (v : M) (p : R[X]) : aeval f p v = p.sum fun n b => b • (f ^ n) v := by\n  rw [aeval_def, eval₂_eq_sum]\n  exact map_sum (LinearMap.applyₗ v) _ _\n\n"}
{"name":"Polynomial.X_sub_C_pow_dvd_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C t)) n) p) (Dvd.dvd (HPow.hPow Polynomial.X n) (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))))","decl":"lemma X_sub_C_pow_dvd_iff {n : ℕ} : (X - C t) ^ n ∣ p ↔ X ^ n ∣ p.comp (X + C t) := by\n  convert (map_dvd_iff <| algEquivAevalXAddC t).symm using 2\n  simp [C_eq_algebraMap]\n\n"}
{"name":"Polynomial.comp_X_add_C_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Iff (Eq (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))) 0) (Eq p 0)","decl":"lemma comp_X_add_C_eq_zero_iff : p.comp (X + C t) = 0 ↔ p = 0 :=\n  EmbeddingLike.map_eq_zero_iff (f := algEquivAevalXAddC t)\n\n"}
{"name":"Polynomial.comp_X_add_C_ne_zero_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Iff (Ne (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))) 0) (Ne p 0)","decl":"lemma comp_X_add_C_ne_zero_iff : p.comp (X + C t) ≠ 0 ↔ p ≠ 0 := comp_X_add_C_eq_zero_iff.not\n\n"}
{"name":"Polynomial.dvd_comp_C_mul_X_add_C_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝¹ : CommRing R\np q : Polynomial R\na b : R\ninst✝ : Invertible a\n⊢ Iff (Dvd.dvd p (q.comp (HAdd.hAdd (HMul.hMul (Polynomial.C a) Polynomial.X) (Polynomial.C b)))) (Dvd.dvd (p.comp (HMul.hMul (Polynomial.C (Invertible.invOf a)) (HSub.hSub Polynomial.X (Polynomial.C b)))) q)","decl":"lemma dvd_comp_C_mul_X_add_C_iff (p q : R[X]) (a b : R) [Invertible a] :\n    p ∣ q.comp (C a * X + C b) ↔ p.comp (C ⅟ a * (X - C b)) ∣ q := by\n  convert map_dvd_iff <| algEquivCMulXAddC a b using 2\n  simp [← comp_eq_aeval, comp_assoc, ← mul_assoc, ← C_mul]\n\n"}
{"name":"Polynomial.dvd_comp_X_sub_C_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\na : R\n⊢ Iff (Dvd.dvd p (q.comp (HSub.hSub Polynomial.X (Polynomial.C a)))) (Dvd.dvd (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C a))) q)","decl":"lemma dvd_comp_X_sub_C_iff (p q : R[X]) (a : R) :\n    p ∣ q.comp (X - C a) ↔ p.comp (X + C a) ∣ q := by\n  let _ := invertibleOne (α := R)\n  simpa using dvd_comp_C_mul_X_add_C_iff p q 1 (-a)\n\n"}
{"name":"Polynomial.dvd_comp_X_add_C_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\na : R\n⊢ Iff (Dvd.dvd p (q.comp (HAdd.hAdd Polynomial.X (Polynomial.C a)))) (Dvd.dvd (p.comp (HSub.hSub Polynomial.X (Polynomial.C a))) q)","decl":"lemma dvd_comp_X_add_C_iff (p q : R[X]) (a : R) :\n    p ∣ q.comp (X + C a) ↔ p.comp (X - C a) ∣ q := by\n  simpa using dvd_comp_X_sub_C_iff p q (-a)\n\n"}
{"name":"Polynomial.dvd_comp_neg_X_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\n⊢ Iff (Dvd.dvd p (q.comp (Neg.neg Polynomial.X))) (Dvd.dvd (p.comp (Neg.neg Polynomial.X)) q)","decl":"lemma dvd_comp_neg_X_iff (p q : R[X]) : p ∣ q.comp (-X) ↔ p.comp (-X) ∣ q := by\n  let _ := invertibleOne (α := R)\n  let _ := invertibleNeg (α := R) 1\n  simpa using dvd_comp_C_mul_X_add_C_iff p q (-1) 0\n\n"}
{"name":"Polynomial.units_coeff_zero_smul","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nc : Units (Polynomial R)\np : Polynomial R\n⊢ Eq (HSMul.hSMul ((↑c).coeff 0) p) (HMul.hMul (↑c) p)","decl":"lemma units_coeff_zero_smul (c : R[X]ˣ) (p : R[X]) : (c : R[X]).coeff 0 • p = c * p := by\n  rw [← Polynomial.C_mul', ← Polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]\n\n"}
{"name":"Polynomial.aeval_apply_smul_mem_of_le_comap'","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nA : Type z\nM : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nq : Submodule R M\nm : M\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nhm : Membership.mem q m\np : Polynomial R\na : A\nhq : LE.le q (Submodule.comap ((Algebra.lsmul R R M) a) q)\n⊢ Membership.mem q (HSMul.hSMul ((Polynomial.aeval a) p) m)","decl":"lemma aeval_apply_smul_mem_of_le_comap'\n    [Semiring A] [Algebra R A] [Module A M] [IsScalarTower R A M] (hm : m ∈ q) (p : R[X]) (a : A)\n    (hq : q ≤ q.comap (Algebra.lsmul R R M a)) :\n    aeval a p • m ∈ q := by\n  refine p.induction_on (M := fun f ↦ aeval a f • m ∈ q) (by simpa) (fun f₁ f₂ h₁ h₂ ↦ ?_)\n    (fun n t hmq ↦ ?_)\n  · simp_rw [map_add, add_smul]\n    exact Submodule.add_mem q h₁ h₂\n  · dsimp only at hmq ⊢\n    rw [pow_succ', mul_left_comm, map_mul, aeval_X, mul_smul]\n    rw [← q.map_le_iff_le_comap] at hq\n    exact hq ⟨_, hmq, rfl⟩\n\n"}
{"name":"Polynomial.aeval_apply_smul_mem_of_le_comap","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\nM : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nq : Submodule R M\nm : M\nhm : Membership.mem q m\np : Polynomial R\nf : Module.End R M\nhq : LE.le q (Submodule.comap f q)\n⊢ Membership.mem q (((Polynomial.aeval f) p) m)","decl":"lemma aeval_apply_smul_mem_of_le_comap\n    (hm : m ∈ q) (p : R[X]) (f : Module.End R M) (hq : q ≤ q.comap f) :\n    aeval f p m ∈ q :=\n  aeval_apply_smul_mem_of_le_comap' hm p f hq\n\n"}
{"name":"Polynomial.eq_zero_of_mul_eq_zero_of_smul","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nP : Polynomial R\nh : ∀ (r : R), Eq (HSMul.hSMul r P) 0 → Eq r 0\nQ : Polynomial R\na✝ : Eq (HMul.hMul P Q) 0\n⊢ Eq Q 0","decl":"theorem eq_zero_of_mul_eq_zero_of_smul (P : R[X]) (h : ∀ r : R, r • P = 0 → r = 0) :\n    ∀ (Q : R[X]), P * Q = 0 → Q = 0 := by\n  intro Q hQ\n  suffices ∀ i, P.coeff i • Q = 0 by\n    rw [← leadingCoeff_eq_zero]\n    apply h\n    simpa [ext_iff, mul_comm Q.leadingCoeff] using fun i ↦ congr_arg (·.coeff Q.natDegree) (this i)\n  apply Nat.strong_decreasing_induction\n  · use P.natDegree\n    intro i hi\n    rw [coeff_eq_zero_of_natDegree_lt hi, zero_smul]\n  intro l IH\n  obtain _|hl := (natDegree_smul_le (P.coeff l) Q).lt_or_eq\n  · apply eq_zero_of_mul_eq_zero_of_smul _ h (P.coeff l • Q)\n    rw [smul_eq_C_mul, mul_left_comm, hQ, mul_zero]\n  suffices P.coeff l * Q.leadingCoeff = 0 by\n    rwa [← leadingCoeff_eq_zero, ← coeff_natDegree, coeff_smul, hl, coeff_natDegree, smul_eq_mul]\n  let m := Q.natDegree\n  suffices (P * Q).coeff (l + m) = P.coeff l * Q.leadingCoeff by rw [← this, hQ, coeff_zero]\n  rw [coeff_mul]\n  apply Finset.sum_eq_single (l, m) _ (by simp)\n  simp only [Finset.mem_antidiagonal, ne_eq, Prod.forall, Prod.mk.injEq, not_and]\n  intro i j hij H\n  obtain hi|rfl|hi := lt_trichotomy i l\n  · have hj : m < j := by omega\n    rw [coeff_eq_zero_of_natDegree_lt hj, mul_zero]\n  · omega\n  · rw [← coeff_C_mul, ← smul_eq_C_mul, IH _ hi, coeff_zero]\ntermination_by Q => Q.natDegree\n\n"}
{"name":"Polynomial.nmem_nonZeroDivisors_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nP : Polynomial R\n⊢ Iff (Not (Membership.mem (nonZeroDivisors (Polynomial R)) P)) (Exists fun a => And (Ne a 0) (Eq (HSMul.hSMul a P) 0))","decl":"open nonZeroDivisors in\n/-- *McCoy theorem*: a polynomial `P : R[X]` is a zerodivisor if and only if there is `a : R`\nsuch that `a ≠ 0` and `a • P = 0`. -/\ntheorem nmem_nonZeroDivisors_iff {P : R[X]} : P ∉ R[X]⁰ ↔ ∃ a : R, a ≠ 0 ∧ a • P = 0 := by\n  refine ⟨fun hP ↦ ?_, fun ⟨a, ha, h⟩ h1 ↦ ha <| C_eq_zero.1 <| (h1 _) <| smul_eq_C_mul a ▸ h⟩\n  by_contra! h\n  obtain ⟨Q, hQ⟩ := _root_.nmem_nonZeroDivisors_iff.1 hP\n  refine hQ.2 (eq_zero_of_mul_eq_zero_of_smul P (fun a ha ↦ ?_) Q (mul_comm P _ ▸ hQ.1))\n  contrapose! ha\n  exact h a ha\n\n"}
{"name":"Polynomial.mem_nonZeroDivisors_iff","module":"Mathlib.Algebra.Polynomial.AlgebraMap","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nP : Polynomial R\n⊢ Iff (Membership.mem (nonZeroDivisors (Polynomial R)) P) (∀ (a : R), Eq (HSMul.hSMul a P) 0 → Eq a 0)","decl":"open nonZeroDivisors in\nprotected lemma mem_nonZeroDivisors_iff {P : R[X]} : P ∈ R[X]⁰ ↔ ∀ a : R, a • P = 0 → a = 0 := by\n  simpa [not_imp_not] using (nmem_nonZeroDivisors_iff (P := P)).not\n\n"}
