{"name":"CategoryTheory.PrelaxFunctorStruct.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : Quiver B\ninst✝² : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝¹ : Quiver C\ninst✝ : (a b : C) → Quiver (Quiver.Hom a b)\ntoPrefunctor✝ : Prefunctor B C\nmap₂✝ : {a b : B} → {f g : Quiver.Hom a b} → Quiver.Hom f g → Quiver.Hom (toPrefunctor✝.map f) (toPrefunctor✝.map g)\ntoPrefunctor : Prefunctor B C\nmap₂ : {a b : B} → {f g : Quiver.Hom a b} → Quiver.Hom f g → Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\n⊢ Eq (Eq { toPrefunctor := toPrefunctor✝, map₂ := map₂✝ } { toPrefunctor := toPrefunctor, map₂ := map₂ }) (And (Eq toPrefunctor✝ toPrefunctor) (HEq map₂✝ map₂))","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map₂ {a b : B} {f g : a ⟶ b} : (f ⟶ g) → (map f ⟶ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝⁵ : Quiver B\ninst✝⁴ : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝³ : Quiver C\ninst✝² : (a b : C) → Quiver (Quiver.Hom a b)\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\ntoPrefunctor : Prefunctor B C\nmap₂ : {a b : B} → {f g : Quiver.Hom a b} → Quiver.Hom f g → Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\n⊢ Eq (SizeOf.sizeOf { toPrefunctor := toPrefunctor, map₂ := map₂ }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrefunctor))","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map₂ {a b : B} {f g : a ⟶ b} : (f ⟶ g) → (map f ⟶ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : Quiver B\ninst✝² : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝¹ : Quiver C\ninst✝ : (a b : C) → Quiver (Quiver.Hom a b)\ntoPrefunctor✝ : Prefunctor B C\nmap₂✝ : {a b : B} → {f g : Quiver.Hom a b} → Quiver.Hom f g → Quiver.Hom (toPrefunctor✝.map f) (toPrefunctor✝.map g)\ntoPrefunctor : Prefunctor B C\nmap₂ : {a b : B} → {f g : Quiver.Hom a b} → Quiver.Hom f g → Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\nx✝ : Eq { toPrefunctor := toPrefunctor✝, map₂ := map₂✝ } { toPrefunctor := toPrefunctor, map₂ := map₂ }\n⊢ And (Eq toPrefunctor✝ toPrefunctor) (HEq map₂✝ map₂)","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map₂ {a b : B} {f g : a ⟶ b} : (f ⟶ g) → (map f ⟶ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_map₂","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : Quiver B\ninst✝² : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝¹ : Quiver C\ninst✝ : (a b : C) → Quiver (Quiver.Hom a b)\nF : B → C\nF' : (a b : B) → Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\nf✝ g✝ : Quiver.Hom a b\na✝ : Quiver.Hom f✝ g✝\n⊢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').map₂ a✝) ((F' a b).map a✝)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B → C) (F' : (a : B) → (b : B) → Prefunctor (a ⟶ b) (F a ⟶ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map₂ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_toPrefunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : Quiver B\ninst✝² : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝¹ : Quiver C\ninst✝ : (a b : C) → Quiver (Quiver.Hom a b)\nF : B → C\nF' : (a b : B) → Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\na✝ : Quiver.Hom a b\n⊢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').map a✝) ((F' a b).obj a✝)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B → C) (F' : (a : B) → (b : B) → Prefunctor (a ⟶ b) (F a ⟶ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map₂ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_toPrefunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : Quiver B\ninst✝² : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝¹ : Quiver C\ninst✝ : (a b : C) → Quiver (Quiver.Hom a b)\nF : B → C\nF' : (a b : B) → Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na✝ : B\n⊢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').obj a✝) (F a✝)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B → C) (F' : (a : B) → (b : B) → Prefunctor (a ⟶ b) (F a ⟶ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map₂ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.id_map₂","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\ninst✝ : (a b : B) → Quiver (Quiver.Hom a b)\na✝ b✝ : B\nf✝ g✝ : Quiver.Hom a✝ b✝\nη : Quiver.Hom f✝ g✝\n⊢ Eq ((CategoryTheory.PrelaxFunctorStruct.id B).map₂ η) η","decl":"/-- The identity lax prefunctor. -/\n@[simps]\ndef id (B : Type u₁) [Quiver.{v₁ + 1} B] [∀ a b : B, Quiver.{w₁ + 1} (a ⟶ b)] :\n    PrelaxFunctorStruct B B :=\n  { Prefunctor.id B with map₂ := fun η => η }\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.id_toPrefunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\ninst✝ : (a b : B) → Quiver (Quiver.Hom a b)\n⊢ Eq (CategoryTheory.PrelaxFunctorStruct.id B).toPrefunctor (Prefunctor.id B)","decl":"/-- The identity lax prefunctor. -/\n@[simps]\ndef id (B : Type u₁) [Quiver.{v₁ + 1} B] [∀ a b : B, Quiver.{w₁ + 1} (a ⟶ b)] :\n    PrelaxFunctorStruct B B :=\n  { Prefunctor.id B with map₂ := fun η => η }\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.comp_map₂","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝⁵ : Quiver B\ninst✝⁴ : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝³ : Quiver C\ninst✝² : (a b : C) → Quiver (Quiver.Hom a b)\nD : Type u₃\ninst✝¹ : Quiver D\ninst✝ : (a b : D) → Quiver (Quiver.Hom a b)\nF : CategoryTheory.PrelaxFunctorStruct B C\nG : CategoryTheory.PrelaxFunctorStruct C D\na✝ b✝ : B\nf✝ g✝ : Quiver.Hom a✝ b✝\nη : Quiver.Hom f✝ g✝\n⊢ Eq ((F.comp G).map₂ η) (G.map₂ (F.map₂ η))","decl":"/-- Composition of lax prefunctors. -/\n@[simps]\ndef comp (F : PrelaxFunctorStruct B C) (G : PrelaxFunctorStruct C D) : PrelaxFunctorStruct B D where\n  toPrefunctor := F.toPrefunctor.comp G.toPrefunctor\n  map₂ := fun η => G.map₂ (F.map₂ η)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.comp_toPrefunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝⁵ : Quiver B\ninst✝⁴ : (a b : B) → Quiver (Quiver.Hom a b)\nC : Type u₂\ninst✝³ : Quiver C\ninst✝² : (a b : C) → Quiver (Quiver.Hom a b)\nD : Type u₃\ninst✝¹ : Quiver D\ninst✝ : (a b : D) → Quiver (Quiver.Hom a b)\nF : CategoryTheory.PrelaxFunctorStruct B C\nG : CategoryTheory.PrelaxFunctorStruct C D\n⊢ Eq (F.comp G).toPrefunctor (F.comp G.toPrefunctor)","decl":"/-- Composition of lax prefunctors. -/\n@[simps]\ndef comp (F : PrelaxFunctorStruct B C) (G : PrelaxFunctorStruct C D) : PrelaxFunctorStruct B D where\n  toPrefunctor := F.toPrefunctor.comp G.toPrefunctor\n  map₂ := fun η => G.map₂ (F.map₂ η)\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\ntoPrelaxFunctorStruct✝ : CategoryTheory.PrelaxFunctorStruct B C\nmap₂_id✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct✝.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct✝.map f))) _auto✝\nmap₂_comp✝ : autoParam (∀ {a b : B} {f g h : Quiver.Hom a b} (η : Quiver.Hom f g) (θ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct✝.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct✝.map₂ η) (toPrelaxFunctorStruct✝.map₂ θ))) _auto✝\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap₂_id : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto✝\nmap₂_comp : autoParam (∀ {a b : B} {f g h : Quiver.Hom a b} (η : Quiver.Hom f g) (θ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map₂ η) (toPrelaxFunctorStruct.map₂ θ))) _auto✝\n⊢ Eq (Eq { toPrelaxFunctorStruct := toPrelaxFunctorStruct✝, map₂_id := map₂_id✝, map₂_comp := map₂_comp✝ } { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map₂_id := map₂_id, map₂_comp := map₂_comp }) (Eq toPrelaxFunctorStruct✝ toPrelaxFunctorStruct)","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map₂` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map₂_comp : ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h),\n      map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\ntoPrelaxFunctorStruct✝ : CategoryTheory.PrelaxFunctorStruct B C\nmap₂_id✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct✝.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct✝.map f))) _auto✝\nmap₂_comp✝ : autoParam (∀ {a b : B} {f g h : Quiver.Hom a b} (η : Quiver.Hom f g) (θ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct✝.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct✝.map₂ η) (toPrelaxFunctorStruct✝.map₂ θ))) _auto✝\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap₂_id : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto✝\nmap₂_comp : autoParam (∀ {a b : B} {f g h : Quiver.Hom a b} (η : Quiver.Hom f g) (θ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map₂ η) (toPrelaxFunctorStruct.map₂ θ))) _auto✝\nx✝ : Eq { toPrelaxFunctorStruct := toPrelaxFunctorStruct✝, map₂_id := map₂_id✝, map₂_comp := map₂_comp✝ } { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map₂_id := map₂_id, map₂_comp := map₂_comp }\n⊢ Eq toPrelaxFunctorStruct✝ toPrelaxFunctorStruct","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map₂` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map₂_comp : ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h),\n      map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_id","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq (self.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (self.map f))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map₂` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map₂_comp : ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h),\n      map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap₂_id : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto✝\nmap₂_comp : autoParam (∀ {a b : B} {f g h : Quiver.Hom a b} (η : Quiver.Hom f g) (θ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map₂ η) (toPrelaxFunctorStruct.map₂ θ))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map₂_id := map₂_id, map₂_comp := map₂_comp }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctorStruct))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map₂` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map₂_comp : ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h),\n      map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_comp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf g h : Quiver.Hom a b\nη : Quiver.Hom f g\nθ : Quiver.Hom g h\n⊢ Eq (self.map₂ (CategoryTheory.CategoryStruct.comp η θ)) (CategoryTheory.CategoryStruct.comp (self.map₂ η) (self.map₂ θ))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map₂` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map₂_id : ∀ {a b : B} (f : a ⟶ b), map₂ (𝟙 f) = 𝟙 (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map₂_comp : ∀ {a b : B} {f g h : a ⟶ b} (η : f ⟶ g) (θ : g ⟶ h),\n      map₂ (η ≫ θ) = map₂ η ≫ map₂ θ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf g h✝ : Quiver.Hom a b\nη : Quiver.Hom f g\nθ : Quiver.Hom g h✝\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map h✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.CategoryStruct.comp η θ)) h) (CategoryTheory.CategoryStruct.comp (self.map₂ η) (CategoryTheory.CategoryStruct.comp (self.map₂ θ) h))","decl":"attribute [reassoc] map₂_comp\n"}
{"name":"CategoryTheory.PrelaxFunctor.mkOfHomFunctors_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : B → C\nF' : (a b : B) → CategoryTheory.Functor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\n⊢ Eq (CategoryTheory.PrelaxFunctor.mkOfHomFunctors F F').toPrelaxFunctorStruct (CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F fun a b => (F' a b).toPrefunctor)","decl":"/-- Construct a prelax functor from a map on objects, and functors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomFunctors (F : B → C) (F' : (a : B) → (b : B) → (a ⟶ b) ⥤ (F a ⟶ F b)) :\n    PrelaxFunctor B C where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.mkOfHomPrefunctors F fun a b => (F' a b).toPrefunctor\n  map₂_id {a b} := (F' a b).map_id\n  map₂_comp {a b} := (F' a b).map_comp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.id_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝ : CategoryTheory.Bicategory B\n⊢ Eq (CategoryTheory.PrelaxFunctor.id B).toPrelaxFunctorStruct (CategoryTheory.PrelaxFunctorStruct.id B)","decl":"/-- The identity prelax functor. -/\n@[simps]\ndef id (B : Type u₁) [Bicategory.{w₁, v₁} B] : PrelaxFunctor B B where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.id B\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.comp_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nD : Type u₃\ninst✝ : CategoryTheory.Bicategory D\nF : CategoryTheory.PrelaxFunctor B C\nG : CategoryTheory.PrelaxFunctor C D\n⊢ Eq (F.comp G).toPrelaxFunctorStruct (F.comp G.toPrelaxFunctorStruct)","decl":"/-- Composition of prelax functors. -/\n@[simps]\ndef comp (G : PrelaxFunctor C D) : PrelaxFunctor B D where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.comp F.toPrelaxFunctorStruct G.toPrelaxFunctorStruct\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mapFunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq ((F.mapFunctor a b).obj f) (F.map f)","decl":"/-- Function between 1-morphisms as a functor. -/\n@[simps]\ndef mapFunctor (a b : B) : (a ⟶ b) ⥤ (F.obj a ⟶ F.obj b) where\n  obj f := F.map f\n  map η := F.map₂ η\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mapFunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nX✝ Y✝ : Quiver.Hom a b\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((F.mapFunctor a b).map η) (F.map₂ η)","decl":"/-- Function between 1-morphisms as a functor. -/\n@[simps]\ndef mapFunctor (a b : B) : (a ⟶ b) ⥤ (F.obj a ⟶ F.obj b) where\n  obj f := F.map f\n  map η := F.map₂ η\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mkOfHomFunctors_mapFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : B → C\nF' : (a b : B) → CategoryTheory.Functor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\n⊢ Eq ((CategoryTheory.PrelaxFunctor.mkOfHomFunctors F F').mapFunctor a b) (F' a b)","decl":"@[simp]\nlemma mkOfHomFunctors_mapFunctor (F : B → C) (F' : (a : B) → (b : B) → (a ⟶ b) ⥤ (F a ⟶ F b))\n    (a b : B) : (mkOfHomFunctors F F').mapFunctor a b = F' a b :=\n  rfl\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂Iso_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\n⊢ Eq (F.map₂Iso η).hom (F.map₂ η.hom)","decl":"/-- A prelaxfunctor `F` sends 2-isomorphisms `η : f ≅ f` to 2-isomorphisms `F.map f ≅ F.map g`. -/\n@[simps!]\nabbrev map₂Iso {f g : a ⟶ b} (η : f ≅ g) : F.map f ≅ F.map g :=\n  (F.mapFunctor a b).mapIso η\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂Iso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\n⊢ Eq (F.map₂Iso η).inv (F.map₂ η.inv)","decl":"/-- A prelaxfunctor `F` sends 2-isomorphisms `η : f ≅ f` to 2-isomorphisms `F.map f ≅ F.map g`. -/\n@[simps!]\nabbrev map₂Iso {f g : a ⟶ b} (η : f ≅ g) : F.map f ≅ F.map g :=\n  (F.mapFunctor a b).mapIso η\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\n⊢ CategoryTheory.IsIso (F.map₂ η)","decl":"instance map₂_isIso {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] : IsIso (F.map₂ η) :=\n  (F.map₂Iso (asIso η)).isIso_hom\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (F.map₂ (CategoryTheory.inv η)) (CategoryTheory.inv (F.map₂ η))","decl":"@[simp]\nlemma map₂_inv {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] : F.map₂ (inv η) = inv (F.map₂ η) := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  simp [← F.map₂_comp η (inv η)]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_hom_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η.hom) (CategoryTheory.CategoryStruct.comp (F.map₂ η.inv) h)) h","decl":"@[reassoc, simp]\nlemma map₂_hom_inv {f g : a ⟶ b} (η : f ≅ g) :\n    F.map₂ η.hom ≫ F.map₂ η.inv = 𝟙 (F.map f) := by\n  rw [← F.map₂_comp, Iso.hom_inv_id, F.map₂_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_hom_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η.hom) (F.map₂ η.inv)) (CategoryTheory.CategoryStruct.id (F.map f))","decl":"@[reassoc, simp]\nlemma map₂_hom_inv {f g : a ⟶ b} (η : f ≅ g) :\n    F.map₂ η.hom ≫ F.map₂ η.inv = 𝟙 (F.map f) := by\n  rw [← F.map₂_comp, Iso.hom_inv_id, F.map₂_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_hom_inv_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η) (F.map₂ (CategoryTheory.inv η))) (CategoryTheory.CategoryStruct.id (F.map f))","decl":"@[reassoc]\nlemma map₂_hom_inv_isIso {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] :\n    F.map₂ η ≫ F.map₂ (inv η) = 𝟙 (F.map f) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_hom_inv_isIso_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η) (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.inv η)) h)) h","decl":"@[reassoc]\nlemma map₂_hom_inv_isIso {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] :\n    F.map₂ η ≫ F.map₂ (inv η) = 𝟙 (F.map f) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_inv_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η.inv) (F.map₂ η.hom)) (CategoryTheory.CategoryStruct.id (F.map g))","decl":"@[reassoc, simp]\nlemma map₂_inv_hom {f g : a ⟶ b} (η : f ≅ g) :\n    F.map₂ η.inv ≫ F.map₂ η.hom = 𝟙 (F.map g) := by\n  rw [← F.map₂_comp, Iso.inv_hom_id, F.map₂_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_inv_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : CategoryTheory.Iso f g\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ η.inv) (CategoryTheory.CategoryStruct.comp (F.map₂ η.hom) h)) h","decl":"@[reassoc, simp]\nlemma map₂_inv_hom {f g : a ⟶ b} (η : f ≅ g) :\n    F.map₂ η.inv ≫ F.map₂ η.hom = 𝟙 (F.map g) := by\n  rw [← F.map₂_comp, Iso.inv_hom_id, F.map₂_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_inv_hom_isIso_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.inv η)) (CategoryTheory.CategoryStruct.comp (F.map₂ η) h)) h","decl":"@[reassoc]\nlemma map₂_inv_hom_isIso {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] :\n    F.map₂ (inv η) ≫ F.map₂ η = 𝟙 (F.map g) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map₂_inv_hom_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.inv η)) (F.map₂ η)) (CategoryTheory.CategoryStruct.id (F.map g))","decl":"@[reassoc]\nlemma map₂_inv_hom_isIso {f g : a ⟶ b} (η : f ⟶ g) [IsIso η] :\n    F.map₂ (inv η) ≫ F.map₂ η = 𝟙 (F.map g) := by\n  simp\n\n"}
