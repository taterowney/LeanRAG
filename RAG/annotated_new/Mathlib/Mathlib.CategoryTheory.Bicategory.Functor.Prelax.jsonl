{"name":"CategoryTheory.PrelaxFunctorStruct.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : Quiver B\ninst‚úù¬≤ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬π : Quiver C\ninst‚úù : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\ntoPrefunctor‚úù : Prefunctor B C\nmap‚ÇÇ‚úù : {a b : B} ‚Üí {f g : Quiver.Hom a b} ‚Üí Quiver.Hom f g ‚Üí Quiver.Hom (toPrefunctor‚úù.map f) (toPrefunctor‚úù.map g)\ntoPrefunctor : Prefunctor B C\nmap‚ÇÇ : {a b : B} ‚Üí {f g : Quiver.Hom a b} ‚Üí Quiver.Hom f g ‚Üí Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\n‚ä¢ Eq (Eq { toPrefunctor := toPrefunctor‚úù, map‚ÇÇ := map‚ÇÇ‚úù } { toPrefunctor := toPrefunctor, map‚ÇÇ := map‚ÇÇ }) (And (Eq toPrefunctor‚úù toPrefunctor) (HEq map‚ÇÇ‚úù map‚ÇÇ))","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map‚ÇÇ {a b : B} {f g : a ‚ü∂ b} : (f ‚ü∂ g) ‚Üí (map f ‚ü∂ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù‚Åµ : Quiver B\ninst‚úù‚Å¥ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬≥ : Quiver C\ninst‚úù¬≤ : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\ntoPrefunctor : Prefunctor B C\nmap‚ÇÇ : {a b : B} ‚Üí {f g : Quiver.Hom a b} ‚Üí Quiver.Hom f g ‚Üí Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\n‚ä¢ Eq (SizeOf.sizeOf { toPrefunctor := toPrefunctor, map‚ÇÇ := map‚ÇÇ }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrefunctor))","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map‚ÇÇ {a b : B} {f g : a ‚ü∂ b} : (f ‚ü∂ g) ‚Üí (map f ‚ü∂ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : Quiver B\ninst‚úù¬≤ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬π : Quiver C\ninst‚úù : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\ntoPrefunctor‚úù : Prefunctor B C\nmap‚ÇÇ‚úù : {a b : B} ‚Üí {f g : Quiver.Hom a b} ‚Üí Quiver.Hom f g ‚Üí Quiver.Hom (toPrefunctor‚úù.map f) (toPrefunctor‚úù.map g)\ntoPrefunctor : Prefunctor B C\nmap‚ÇÇ : {a b : B} ‚Üí {f g : Quiver.Hom a b} ‚Üí Quiver.Hom f g ‚Üí Quiver.Hom (toPrefunctor.map f) (toPrefunctor.map g)\nx‚úù : Eq { toPrefunctor := toPrefunctor‚úù, map‚ÇÇ := map‚ÇÇ‚úù } { toPrefunctor := toPrefunctor, map‚ÇÇ := map‚ÇÇ }\n‚ä¢ And (Eq toPrefunctor‚úù toPrefunctor) (HEq map‚ÇÇ‚úù map‚ÇÇ)","decl":"/-- A `PrelaxFunctorStruct` between bicategories consists of functions between objects,\n1-morphisms, and 2-morphisms. This structure will be extended to define `PrelaxFunctor`.\n-/\nstructure PrelaxFunctorStruct extends Prefunctor B C where\n  /-- The action of a lax prefunctor on 2-morphisms. -/\n  map‚ÇÇ {a b : B} {f g : a ‚ü∂ b} : (f ‚ü∂ g) ‚Üí (map f ‚ü∂ map g)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_map‚ÇÇ","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : Quiver B\ninst‚úù¬≤ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬π : Quiver C\ninst‚úù : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\nF : B ‚Üí C\nF' : (a b : B) ‚Üí Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\nf‚úù g‚úù : Quiver.Hom a b\na‚úù : Quiver.Hom f‚úù g‚úù\n‚ä¢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').map‚ÇÇ a‚úù) ((F' a b).map a‚úù)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B ‚Üí C) (F' : (a : B) ‚Üí (b : B) ‚Üí Prefunctor (a ‚ü∂ b) (F a ‚ü∂ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map‚ÇÇ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_toPrefunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : Quiver B\ninst‚úù¬≤ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬π : Quiver C\ninst‚úù : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\nF : B ‚Üí C\nF' : (a b : B) ‚Üí Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\na‚úù : Quiver.Hom a b\n‚ä¢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').map a‚úù) ((F' a b).obj a‚úù)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B ‚Üí C) (F' : (a : B) ‚Üí (b : B) ‚Üí Prefunctor (a ‚ü∂ b) (F a ‚ü∂ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map‚ÇÇ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors_toPrefunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : Quiver B\ninst‚úù¬≤ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬π : Quiver C\ninst‚úù : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\nF : B ‚Üí C\nF' : (a b : B) ‚Üí Prefunctor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na‚úù : B\n‚ä¢ Eq ((CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F F').obj a‚úù) (F a‚úù)","decl":"/-- Construct a lax prefunctor from a map on objects, and prefunctors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomPrefunctors (F : B ‚Üí C) (F' : (a : B) ‚Üí (b : B) ‚Üí Prefunctor (a ‚ü∂ b) (F a ‚ü∂ F b)) :\n    PrelaxFunctorStruct B C where\n  obj := F\n  map {a b} := (F' a b).obj\n  map‚ÇÇ {a b} := (F' a b).map\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.id_map‚ÇÇ","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\ninst‚úù : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\na‚úù b‚úù : B\nf‚úù g‚úù : Quiver.Hom a‚úù b‚úù\nŒ∑ : Quiver.Hom f‚úù g‚úù\n‚ä¢ Eq ((CategoryTheory.PrelaxFunctorStruct.id B).map‚ÇÇ Œ∑) Œ∑","decl":"/-- The identity lax prefunctor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Quiver.{v‚ÇÅ + 1} B] [‚àÄ a b : B, Quiver.{w‚ÇÅ + 1} (a ‚ü∂ b)] :\n    PrelaxFunctorStruct B B :=\n  { Prefunctor.id B with map‚ÇÇ := fun Œ∑ => Œ∑ }\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.id_toPrefunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\ninst‚úù : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\n‚ä¢ Eq (CategoryTheory.PrelaxFunctorStruct.id B).toPrefunctor (Prefunctor.id B)","decl":"/-- The identity lax prefunctor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Quiver.{v‚ÇÅ + 1} B] [‚àÄ a b : B, Quiver.{w‚ÇÅ + 1} (a ‚ü∂ b)] :\n    PrelaxFunctorStruct B B :=\n  { Prefunctor.id B with map‚ÇÇ := fun Œ∑ => Œ∑ }\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.comp_map‚ÇÇ","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù‚Åµ : Quiver B\ninst‚úù‚Å¥ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬≥ : Quiver C\ninst‚úù¬≤ : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\nD : Type u‚ÇÉ\ninst‚úù¬π : Quiver D\ninst‚úù : (a b : D) ‚Üí Quiver (Quiver.Hom a b)\nF : CategoryTheory.PrelaxFunctorStruct B C\nG : CategoryTheory.PrelaxFunctorStruct C D\na‚úù b‚úù : B\nf‚úù g‚úù : Quiver.Hom a‚úù b‚úù\nŒ∑ : Quiver.Hom f‚úù g‚úù\n‚ä¢ Eq ((F.comp G).map‚ÇÇ Œ∑) (G.map‚ÇÇ (F.map‚ÇÇ Œ∑))","decl":"/-- Composition of lax prefunctors. -/\n@[simps]\ndef comp (F : PrelaxFunctorStruct B C) (G : PrelaxFunctorStruct C D) : PrelaxFunctorStruct B D where\n  toPrefunctor := F.toPrefunctor.comp G.toPrefunctor\n  map‚ÇÇ := fun Œ∑ => G.map‚ÇÇ (F.map‚ÇÇ Œ∑)\n\n"}
{"name":"CategoryTheory.PrelaxFunctorStruct.comp_toPrefunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù‚Åµ : Quiver B\ninst‚úù‚Å¥ : (a b : B) ‚Üí Quiver (Quiver.Hom a b)\nC : Type u‚ÇÇ\ninst‚úù¬≥ : Quiver C\ninst‚úù¬≤ : (a b : C) ‚Üí Quiver (Quiver.Hom a b)\nD : Type u‚ÇÉ\ninst‚úù¬π : Quiver D\ninst‚úù : (a b : D) ‚Üí Quiver (Quiver.Hom a b)\nF : CategoryTheory.PrelaxFunctorStruct B C\nG : CategoryTheory.PrelaxFunctorStruct C D\n‚ä¢ Eq (F.comp G).toPrefunctor (F.comp G.toPrefunctor)","decl":"/-- Composition of lax prefunctors. -/\n@[simps]\ndef comp (F : PrelaxFunctorStruct B C) (G : PrelaxFunctorStruct C D) : PrelaxFunctorStruct B D where\n  toPrefunctor := F.toPrefunctor.comp G.toPrefunctor\n  map‚ÇÇ := fun Œ∑ => G.map‚ÇÇ (F.map‚ÇÇ Œ∑)\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctorStruct‚úù : CategoryTheory.PrelaxFunctorStruct B C\nmap‚ÇÇ_id‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct‚úù.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct‚úù.map f))) _auto‚úù\nmap‚ÇÇ_comp‚úù : autoParam (‚àÄ {a b : B} {f g h : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (Œ∏ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct‚úù.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctorStruct‚úù.map‚ÇÇ Œ∏))) _auto‚úù\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap‚ÇÇ_id : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto‚úù\nmap‚ÇÇ_comp : autoParam (‚àÄ {a b : B} {f g h : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (Œ∏ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map‚ÇÇ Œ∑) (toPrelaxFunctorStruct.map‚ÇÇ Œ∏))) _auto‚úù\n‚ä¢ Eq (Eq { toPrelaxFunctorStruct := toPrelaxFunctorStruct‚úù, map‚ÇÇ_id := map‚ÇÇ_id‚úù, map‚ÇÇ_comp := map‚ÇÇ_comp‚úù } { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map‚ÇÇ_id := map‚ÇÇ_id, map‚ÇÇ_comp := map‚ÇÇ_comp }) (Eq toPrelaxFunctorStruct‚úù toPrelaxFunctorStruct)","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map‚ÇÇ` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map‚ÇÇ_id : ‚àÄ {a b : B} (f : a ‚ü∂ b), map‚ÇÇ (ùüô f) = ùüô (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map‚ÇÇ_comp : ‚àÄ {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h),\n      map‚ÇÇ (Œ∑ ‚â´ Œ∏) = map‚ÇÇ Œ∑ ‚â´ map‚ÇÇ Œ∏ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctorStruct‚úù : CategoryTheory.PrelaxFunctorStruct B C\nmap‚ÇÇ_id‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct‚úù.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct‚úù.map f))) _auto‚úù\nmap‚ÇÇ_comp‚úù : autoParam (‚àÄ {a b : B} {f g h : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (Œ∏ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct‚úù.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctorStruct‚úù.map‚ÇÇ Œ∏))) _auto‚úù\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap‚ÇÇ_id : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto‚úù\nmap‚ÇÇ_comp : autoParam (‚àÄ {a b : B} {f g h : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (Œ∏ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map‚ÇÇ Œ∑) (toPrelaxFunctorStruct.map‚ÇÇ Œ∏))) _auto‚úù\nx‚úù : Eq { toPrelaxFunctorStruct := toPrelaxFunctorStruct‚úù, map‚ÇÇ_id := map‚ÇÇ_id‚úù, map‚ÇÇ_comp := map‚ÇÇ_comp‚úù } { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map‚ÇÇ_id := map‚ÇÇ_id, map‚ÇÇ_comp := map‚ÇÇ_comp }\n‚ä¢ Eq toPrelaxFunctorStruct‚úù toPrelaxFunctorStruct","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map‚ÇÇ` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map‚ÇÇ_id : ‚àÄ {a b : B} (f : a ‚ü∂ b), map‚ÇÇ (ùüô f) = ùüô (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map‚ÇÇ_comp : ‚àÄ {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h),\n      map‚ÇÇ (Œ∑ ‚â´ Œ∏) = map‚ÇÇ Œ∑ ‚â´ map‚ÇÇ Œ∏ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_id","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (self.map f))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map‚ÇÇ` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map‚ÇÇ_id : ‚àÄ {a b : B} (f : a ‚ü∂ b), map‚ÇÇ (ùüô f) = ùüô (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map‚ÇÇ_comp : ‚àÄ {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h),\n      map‚ÇÇ (Œ∑ ‚â´ Œ∏) = map‚ÇÇ Œ∑ ‚â´ map‚ÇÇ Œ∏ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\ntoPrelaxFunctorStruct : CategoryTheory.PrelaxFunctorStruct B C\nmap‚ÇÇ_id : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctorStruct.map f))) _auto‚úù\nmap‚ÇÇ_comp : autoParam (‚àÄ {a b : B} {f g h : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (Œ∏ : Quiver.Hom g h), Eq (toPrelaxFunctorStruct.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctorStruct.map‚ÇÇ Œ∑) (toPrelaxFunctorStruct.map‚ÇÇ Œ∏))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrelaxFunctorStruct := toPrelaxFunctorStruct, map‚ÇÇ_id := map‚ÇÇ_id, map‚ÇÇ_comp := map‚ÇÇ_comp }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctorStruct))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map‚ÇÇ` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map‚ÇÇ_id : ‚àÄ {a b : B} (f : a ‚ü∂ b), map‚ÇÇ (ùüô f) = ùüô (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map‚ÇÇ_comp : ‚àÄ {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h),\n      map‚ÇÇ (Œ∑ ‚â´ Œ∏) = map‚ÇÇ Œ∑ ‚â´ map‚ÇÇ Œ∏ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_comp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf g h : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\nŒ∏ : Quiver.Hom g h\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ Œ∑) (self.map‚ÇÇ Œ∏))","decl":"/-- A prelax functor between bicategories is a lax prefunctor such that `map‚ÇÇ` is a functor.\nThis structure will be extended to define `LaxFunctor` and `OplaxFunctor`.\n-/\nstructure PrelaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctorStruct B C where\n  /-- Prelax functors preserves identity 2-morphisms. -/\n  map‚ÇÇ_id : ‚àÄ {a b : B} (f : a ‚ü∂ b), map‚ÇÇ (ùüô f) = ùüô (map f) := by aesop -- TODO: why not aesop_cat?\n  /-- Prelax functors preserves compositions of 2-morphisms. -/\n  map‚ÇÇ_comp : ‚àÄ {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h),\n      map‚ÇÇ (Œ∑ ‚â´ Œ∏) = map‚ÇÇ Œ∑ ‚â´ map‚ÇÇ Œ∏ := by aesop_cat\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.PrelaxFunctor B C\na b : B\nf g h‚úù : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\nŒ∏ : Quiver.Hom g h‚úù\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map h‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.CategoryStruct.comp Œ∑ Œ∏)) h) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ Œ∑) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ Œ∏) h))","decl":"attribute [reassoc] map‚ÇÇ_comp\n"}
{"name":"CategoryTheory.PrelaxFunctor.mkOfHomFunctors_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : B ‚Üí C\nF' : (a b : B) ‚Üí CategoryTheory.Functor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\n‚ä¢ Eq (CategoryTheory.PrelaxFunctor.mkOfHomFunctors F F').toPrelaxFunctorStruct (CategoryTheory.PrelaxFunctorStruct.mkOfHomPrefunctors F fun a b => (F' a b).toPrefunctor)","decl":"/-- Construct a prelax functor from a map on objects, and functors between the corresponding\nhom types. -/\n@[simps]\ndef mkOfHomFunctors (F : B ‚Üí C) (F' : (a : B) ‚Üí (b : B) ‚Üí (a ‚ü∂ b) ‚•§ (F a ‚ü∂ F b)) :\n    PrelaxFunctor B C where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.mkOfHomPrefunctors F fun a b => (F' a b).toPrefunctor\n  map‚ÇÇ_id {a b} := (F' a b).map_id\n  map‚ÇÇ_comp {a b} := (F' a b).map_comp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.id_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\n‚ä¢ Eq (CategoryTheory.PrelaxFunctor.id B).toPrelaxFunctorStruct (CategoryTheory.PrelaxFunctorStruct.id B)","decl":"/-- The identity prelax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : PrelaxFunctor B B where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.id B\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.comp_toPrelaxFunctorStruct","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.PrelaxFunctor B C\nG : CategoryTheory.PrelaxFunctor C D\n‚ä¢ Eq (F.comp G).toPrelaxFunctorStruct (F.comp G.toPrelaxFunctorStruct)","decl":"/-- Composition of prelax functors. -/\n@[simps]\ndef comp (G : PrelaxFunctor C D) : PrelaxFunctor B D where\n  toPrelaxFunctorStruct := PrelaxFunctorStruct.comp F.toPrelaxFunctorStruct G.toPrelaxFunctorStruct\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mapFunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq ((F.mapFunctor a b).obj f) (F.map f)","decl":"/-- Function between 1-morphisms as a functor. -/\n@[simps]\ndef mapFunctor (a b : B) : (a ‚ü∂ b) ‚•§ (F.obj a ‚ü∂ F.obj b) where\n  obj f := F.map f\n  map Œ∑ := F.map‚ÇÇ Œ∑\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mapFunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nX‚úù Y‚úù : Quiver.Hom a b\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.mapFunctor a b).map Œ∑) (F.map‚ÇÇ Œ∑)","decl":"/-- Function between 1-morphisms as a functor. -/\n@[simps]\ndef mapFunctor (a b : B) : (a ‚ü∂ b) ‚•§ (F.obj a ‚ü∂ F.obj b) where\n  obj f := F.map f\n  map Œ∑ := F.map‚ÇÇ Œ∑\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.mkOfHomFunctors_mapFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : B ‚Üí C\nF' : (a b : B) ‚Üí CategoryTheory.Functor (Quiver.Hom a b) (Quiver.Hom (F a) (F b))\na b : B\n‚ä¢ Eq ((CategoryTheory.PrelaxFunctor.mkOfHomFunctors F F').mapFunctor a b) (F' a b)","decl":"@[simp]\nlemma mkOfHomFunctors_mapFunctor (F : B ‚Üí C) (F' : (a : B) ‚Üí (b : B) ‚Üí (a ‚ü∂ b) ‚•§ (F a ‚ü∂ F b))\n    (a b : B) : (mkOfHomFunctors F F').mapFunctor a b = F' a b :=\n  rfl\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\n‚ä¢ Eq (F.map‚ÇÇIso Œ∑).hom (F.map‚ÇÇ Œ∑.hom)","decl":"/-- A prelaxfunctor `F` sends 2-isomorphisms `Œ∑ : f ‚âÖ f` to 2-isomorphisms `F.map f ‚âÖ F.map g`. -/\n@[simps!]\nabbrev map‚ÇÇIso {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : F.map f ‚âÖ F.map g :=\n  (F.mapFunctor a b).mapIso Œ∑\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\n‚ä¢ Eq (F.map‚ÇÇIso Œ∑).inv (F.map‚ÇÇ Œ∑.inv)","decl":"/-- A prelaxfunctor `F` sends 2-isomorphisms `Œ∑ : f ‚âÖ f` to 2-isomorphisms `F.map f ‚âÖ F.map g`. -/\n@[simps!]\nabbrev map‚ÇÇIso {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : F.map f ‚âÖ F.map g :=\n  (F.mapFunctor a b).mapIso Œ∑\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ CategoryTheory.IsIso (F.map‚ÇÇ Œ∑)","decl":"instance map‚ÇÇ_isIso {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] : IsIso (F.map‚ÇÇ Œ∑) :=\n  (F.map‚ÇÇIso (asIso Œ∑)).isIso_hom\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (F.map‚ÇÇ (CategoryTheory.inv Œ∑)) (CategoryTheory.inv (F.map‚ÇÇ Œ∑))","decl":"@[simp]\nlemma map‚ÇÇ_inv {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] : F.map‚ÇÇ (inv Œ∑) = inv (F.map‚ÇÇ Œ∑) := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  simp [‚Üê F.map‚ÇÇ_comp Œ∑ (inv Œ∑)]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_hom_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.hom) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.inv) h)) h","decl":"@[reassoc, simp]\nlemma map‚ÇÇ_hom_inv {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) :\n    F.map‚ÇÇ Œ∑.hom ‚â´ F.map‚ÇÇ Œ∑.inv = ùüô (F.map f) := by\n  rw [‚Üê F.map‚ÇÇ_comp, Iso.hom_inv_id, F.map‚ÇÇ_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_hom_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.hom) (F.map‚ÇÇ Œ∑.inv)) (CategoryTheory.CategoryStruct.id (F.map f))","decl":"@[reassoc, simp]\nlemma map‚ÇÇ_hom_inv {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) :\n    F.map‚ÇÇ Œ∑.hom ‚â´ F.map‚ÇÇ Œ∑.inv = ùüô (F.map f) := by\n  rw [‚Üê F.map‚ÇÇ_comp, Iso.hom_inv_id, F.map‚ÇÇ_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_hom_inv_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑) (F.map‚ÇÇ (CategoryTheory.inv Œ∑))) (CategoryTheory.CategoryStruct.id (F.map f))","decl":"@[reassoc]\nlemma map‚ÇÇ_hom_inv_isIso {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] :\n    F.map‚ÇÇ Œ∑ ‚â´ F.map‚ÇÇ (inv Œ∑) = ùüô (F.map f) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_hom_inv_isIso_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.inv Œ∑)) h)) h","decl":"@[reassoc]\nlemma map‚ÇÇ_hom_inv_isIso {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] :\n    F.map‚ÇÇ Œ∑ ‚â´ F.map‚ÇÇ (inv Œ∑) = ùüô (F.map f) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_inv_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.inv) (F.map‚ÇÇ Œ∑.hom)) (CategoryTheory.CategoryStruct.id (F.map g))","decl":"@[reassoc, simp]\nlemma map‚ÇÇ_inv_hom {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) :\n    F.map‚ÇÇ Œ∑.inv ‚â´ F.map‚ÇÇ Œ∑.hom = ùüô (F.map g) := by\n  rw [‚Üê F.map‚ÇÇ_comp, Iso.inv_hom_id, F.map‚ÇÇ_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_inv_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.Iso f g\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.inv) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑.hom) h)) h","decl":"@[reassoc, simp]\nlemma map‚ÇÇ_inv_hom {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) :\n    F.map‚ÇÇ Œ∑.inv ‚â´ F.map‚ÇÇ Œ∑.hom = ùüô (F.map g) := by\n  rw [‚Üê F.map‚ÇÇ_comp, Iso.inv_hom_id, F.map‚ÇÇ_id]\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_inv_hom_isIso_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.inv Œ∑)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ Œ∑) h)) h","decl":"@[reassoc]\nlemma map‚ÇÇ_inv_hom_isIso {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] :\n    F.map‚ÇÇ (inv Œ∑) ‚â´ F.map‚ÇÇ Œ∑ = ùüô (F.map g) := by\n  simp\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_inv_hom_isIso","module":"Mathlib.CategoryTheory.Bicategory.Functor.Prelax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.inv Œ∑)) (F.map‚ÇÇ Œ∑)) (CategoryTheory.CategoryStruct.id (F.map g))","decl":"@[reassoc]\nlemma map‚ÇÇ_inv_hom_isIso {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) [IsIso Œ∑] :\n    F.map‚ÇÇ (inv Œ∑) ‚â´ F.map‚ÇÇ Œ∑ = ùüô (F.map g) := by\n  simp\n\n"}
