{"name":"DiscreteQuotient.ext_iff","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\nx y : DiscreteQuotient X\n⊢ Iff (Eq x y) (Eq ⇑x.toSetoid ⇑y.toSetoid)","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.isOpen_setOf_rel","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\nself : DiscreteQuotient X\nx : X\n⊢ IsOpen (setOf (self.toSetoid x))","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.mk.inj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ntoSetoid✝ : Setoid X\nisOpen_setOf_rel✝ : ∀ (x : X), IsOpen (setOf (toSetoid✝ x))\ntoSetoid : Setoid X\nisOpen_setOf_rel : ∀ (x : X), IsOpen (setOf (toSetoid x))\nx✝ : Eq { toSetoid := toSetoid✝, isOpen_setOf_rel := isOpen_setOf_rel✝ } { toSetoid := toSetoid, isOpen_setOf_rel := isOpen_setOf_rel }\n⊢ Eq toSetoid✝ toSetoid","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.ext","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\nx y : DiscreteQuotient X\nr : Eq ⇑x.toSetoid ⇑y.toSetoid\n⊢ Eq x y","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.mk.injEq","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ntoSetoid✝ : Setoid X\nisOpen_setOf_rel✝ : ∀ (x : X), IsOpen (setOf (toSetoid✝ x))\ntoSetoid : Setoid X\nisOpen_setOf_rel : ∀ (x : X), IsOpen (setOf (toSetoid x))\n⊢ Eq (Eq { toSetoid := toSetoid✝, isOpen_setOf_rel := isOpen_setOf_rel✝ } { toSetoid := toSetoid, isOpen_setOf_rel := isOpen_setOf_rel }) (Eq toSetoid✝ toSetoid)","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.mk.sizeOf_spec","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : SizeOf X\ntoSetoid : Setoid X\nisOpen_setOf_rel : ∀ (x : X), IsOpen (setOf (toSetoid x))\n⊢ Eq (SizeOf.sizeOf { toSetoid := toSetoid, isOpen_setOf_rel := isOpen_setOf_rel }) (HAdd.hAdd 1 (SizeOf.sizeOf toSetoid))","decl":"/-- The type of discrete quotients of a topological space. -/\n@[ext] -- Porting note: in Lean 4, uses projection to `r` instead of `Setoid`.\nstructure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  /-- For every point `x`, the set `{ y | Rel x y }` is an open set. -/\n  protected isOpen_setOf_rel : ∀ x, IsOpen (setOf (toSetoid x))\n\n"}
{"name":"DiscreteQuotient.toSetoid_injective","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Function.Injective DiscreteQuotient.toSetoid","decl":"lemma toSetoid_injective : Function.Injective (@toSetoid X _)\n  | ⟨_, _⟩, ⟨_, _⟩, _ => by congr\n\n"}
{"name":"DiscreteQuotient.refl","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nx : X\n⊢ S.toSetoid x x","decl":"theorem refl : ∀ x, S.toSetoid x x := S.refl'\n\n"}
{"name":"DiscreteQuotient.symm","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nx y : X\na✝ : S.toSetoid x y\n⊢ S.toSetoid y x","decl":"theorem symm (x y : X) : S.toSetoid x y → S.toSetoid y x := S.symm'\n\n"}
{"name":"DiscreteQuotient.trans","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nx y z : X\na✝¹ : S.toSetoid x y\na✝ : S.toSetoid y z\n⊢ S.toSetoid x z","decl":"theorem trans (x y z : X) : S.toSetoid x y → S.toSetoid y z → S.toSetoid x z := S.trans'\n\n"}
{"name":"DiscreteQuotient.fiber_eq","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nx : X\n⊢ Eq (Set.preimage S.proj (Singleton.singleton (S.proj x))) (setOf (S.toSetoid x))","decl":"theorem fiber_eq (x : X) : S.proj ⁻¹' {S.proj x} = setOf (S.toSetoid x) :=\n  Set.ext fun _ => eq_comm.trans Quotient.eq''\n\n"}
{"name":"DiscreteQuotient.proj_surjective","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ Function.Surjective S.proj","decl":"theorem proj_surjective : Function.Surjective S.proj :=\n  Quotient.mk''_surjective\n\n"}
{"name":"DiscreteQuotient.proj_isQuotientMap","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ Topology.IsQuotientMap S.proj","decl":"theorem proj_isQuotientMap : IsQuotientMap S.proj :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"DiscreteQuotient.proj_quotientMap","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ Topology.IsQuotientMap S.proj","decl":"@[deprecated (since := \"2024-10-22\")]\nalias proj_quotientMap := proj_isQuotientMap\n\n"}
{"name":"DiscreteQuotient.proj_continuous","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ Continuous S.proj","decl":"theorem proj_continuous : Continuous S.proj :=\n  S.proj_isQuotientMap.continuous\n\n"}
{"name":"DiscreteQuotient.instDiscreteTopologyQuotient","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ DiscreteTopology (Quotient S.toSetoid)","decl":"instance : DiscreteTopology S :=\n  singletons_open_iff_discrete.1 <| S.proj_surjective.forall.2 fun x => by\n    rw [← S.proj_isQuotientMap.isOpen_preimage, fiber_eq]\n    exact S.isOpen_setOf_rel _\n\n"}
{"name":"DiscreteQuotient.proj_isLocallyConstant","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ IsLocallyConstant S.proj","decl":"theorem proj_isLocallyConstant : IsLocallyConstant S.proj :=\n  (IsLocallyConstant.iff_continuous S.proj).2 S.proj_continuous\n\n"}
{"name":"DiscreteQuotient.isClopen_preimage","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nA : Set (Quotient S.toSetoid)\n⊢ IsClopen (Set.preimage S.proj A)","decl":"theorem isClopen_preimage (A : Set S) : IsClopen (S.proj ⁻¹' A) :=\n  (isClopen_discrete A).preimage S.proj_continuous\n\n"}
{"name":"DiscreteQuotient.isOpen_preimage","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nA : Set (Quotient S.toSetoid)\n⊢ IsOpen (Set.preimage S.proj A)","decl":"theorem isOpen_preimage (A : Set S) : IsOpen (S.proj ⁻¹' A) :=\n  (S.isClopen_preimage A).2\n\n"}
{"name":"DiscreteQuotient.isClosed_preimage","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nA : Set (Quotient S.toSetoid)\n⊢ IsClosed (Set.preimage S.proj A)","decl":"theorem isClosed_preimage (A : Set S) : IsClosed (S.proj ⁻¹' A) :=\n  (S.isClopen_preimage A).1\n\n"}
{"name":"DiscreteQuotient.isClopen_setOf_rel","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\nx : X\n⊢ IsClopen (setOf (S.toSetoid x))","decl":"theorem isClopen_setOf_rel (x : X) : IsClopen (setOf (S.toSetoid x)) := by\n  rw [← fiber_eq]\n  apply isClopen_preimage\n\n"}
{"name":"DiscreteQuotient.instNonemptyQuotient","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\nS : DiscreteQuotient X\ninst✝ : Nonempty X\n⊢ Nonempty (Quotient S.toSetoid)","decl":"instance [Nonempty X] : Nonempty S := Nonempty.map S.proj ‹_›\n\n"}
{"name":"DiscreteQuotient.instSubsingletonQuotientTop","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Subsingleton (Quotient Top.top.toSetoid)","decl":"/-- The quotient by `⊤ : DiscreteQuotient X` is a `Subsingleton`. -/\ninstance : Subsingleton (⊤ : DiscreteQuotient X) where\n  allEq := by rintro ⟨_⟩ ⟨_⟩; exact Quotient.sound trivial\n\n"}
{"name":"DiscreteQuotient.comap_id","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : DiscreteQuotient X\n⊢ Eq (DiscreteQuotient.comap (ContinuousMap.id X) S) S","decl":"@[simp]\ntheorem comap_id : S.comap (ContinuousMap.id X) = S := rfl\n\n"}
{"name":"DiscreteQuotient.comap_comp","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : ContinuousMap Y Z\nf : ContinuousMap X Y\nS : DiscreteQuotient Z\n⊢ Eq (DiscreteQuotient.comap (g.comp f) S) (DiscreteQuotient.comap f (DiscreteQuotient.comap g S))","decl":"@[simp]\ntheorem comap_comp (S : DiscreteQuotient Z) : S.comap (g.comp f) = (S.comap g).comap f :=\n  rfl\n\n"}
{"name":"DiscreteQuotient.comap_mono","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA B : DiscreteQuotient Y\nh : LE.le A B\n⊢ LE.le (DiscreteQuotient.comap f A) (DiscreteQuotient.comap f B)","decl":"@[mono]\ntheorem comap_mono {A B : DiscreteQuotient Y} (h : A ≤ B) : A.comap f ≤ B.comap f := by tauto\n\n"}
{"name":"DiscreteQuotient.ofLE_refl","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA : DiscreteQuotient X\n⊢ Eq (DiscreteQuotient.ofLE ⋯) id","decl":"@[simp]\ntheorem ofLE_refl : ofLE (le_refl A) = id := by\n  ext ⟨⟩\n  rfl\n\n"}
{"name":"DiscreteQuotient.ofLE_refl_apply","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA : DiscreteQuotient X\na : Quotient A.toSetoid\n⊢ Eq (DiscreteQuotient.ofLE ⋯ a) a","decl":"theorem ofLE_refl_apply (a : A) : ofLE (le_refl A) a = a := by simp\n\n"}
{"name":"DiscreteQuotient.ofLE_ofLE","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B C : DiscreteQuotient X\nh₁ : LE.le A B\nh₂ : LE.le B C\nx : Quotient A.toSetoid\n⊢ Eq (DiscreteQuotient.ofLE h₂ (DiscreteQuotient.ofLE h₁ x)) (DiscreteQuotient.ofLE ⋯ x)","decl":"@[simp]\ntheorem ofLE_ofLE (h₁ : A ≤ B) (h₂ : B ≤ C) (x : A) :\n    ofLE h₂ (ofLE h₁ x) = ofLE (h₁.trans h₂) x := by\n  rcases x with ⟨⟩\n  rfl\n\n"}
{"name":"DiscreteQuotient.ofLE_comp_ofLE","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B C : DiscreteQuotient X\nh₁ : LE.le A B\nh₂ : LE.le B C\n⊢ Eq (Function.comp (DiscreteQuotient.ofLE h₂) (DiscreteQuotient.ofLE h₁)) (DiscreteQuotient.ofLE ⋯)","decl":"@[simp]\ntheorem ofLE_comp_ofLE (h₁ : A ≤ B) (h₂ : B ≤ C) : ofLE h₂ ∘ ofLE h₁ = ofLE (le_trans h₁ h₂) :=\n  funext <| ofLE_ofLE _ _\n\n"}
{"name":"DiscreteQuotient.ofLE_continuous","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B : DiscreteQuotient X\nh : LE.le A B\n⊢ Continuous (DiscreteQuotient.ofLE h)","decl":"theorem ofLE_continuous (h : A ≤ B) : Continuous (ofLE h) :=\n  continuous_of_discreteTopology\n\n"}
{"name":"DiscreteQuotient.ofLE_proj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B : DiscreteQuotient X\nh : LE.le A B\nx : X\n⊢ Eq (DiscreteQuotient.ofLE h (A.proj x)) (B.proj x)","decl":"@[simp]\ntheorem ofLE_proj (h : A ≤ B) (x : X) : ofLE h (A.proj x) = B.proj x :=\n  Quotient.sound' (B.refl _)\n\n"}
{"name":"DiscreteQuotient.ofLE_comp_proj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B : DiscreteQuotient X\nh : LE.le A B\n⊢ Eq (Function.comp (DiscreteQuotient.ofLE h) A.proj) B.proj","decl":"@[simp]\ntheorem ofLE_comp_proj (h : A ≤ B) : ofLE h ∘ A.proj = B.proj :=\n  funext <| ofLE_proj _\n\n"}
{"name":"DiscreteQuotient.proj_bot_eq","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : LocallyConnectedSpace X\nx y : X\n⊢ Iff (Eq (Bot.bot.proj x) (Bot.bot.proj y)) (Eq (connectedComponent x) (connectedComponent y))","decl":"@[simp]\ntheorem proj_bot_eq [LocallyConnectedSpace X] {x y : X} :\n    proj ⊥ x = proj ⊥ y ↔ connectedComponent x = connectedComponent y :=\n  Quotient.eq''\n\n"}
{"name":"DiscreteQuotient.proj_bot_inj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\nx y : X\n⊢ Iff (Eq (Bot.bot.proj x) (Bot.bot.proj y)) (Eq x y)","decl":"theorem proj_bot_inj [DiscreteTopology X] {x y : X} : proj ⊥ x = proj ⊥ y ↔ x = y := by simp\n\n"}
{"name":"DiscreteQuotient.proj_bot_injective","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ Function.Injective Bot.bot.proj","decl":"theorem proj_bot_injective [DiscreteTopology X] : Injective (⊥ : DiscreteQuotient X).proj :=\n  fun _ _ => proj_bot_inj.1\n\n"}
{"name":"DiscreteQuotient.proj_bot_bijective","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ Function.Bijective Bot.bot.proj","decl":"theorem proj_bot_bijective [DiscreteTopology X] : Bijective (⊥ : DiscreteQuotient X).proj :=\n  ⟨proj_bot_injective, proj_surjective _⟩\n\n"}
{"name":"DiscreteQuotient.leComap_id","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA : DiscreteQuotient X\n⊢ DiscreteQuotient.LEComap (ContinuousMap.id X) A A","decl":"theorem leComap_id : LEComap (.id X) A A := le_rfl\n\n"}
{"name":"DiscreteQuotient.leComap_id_iff","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA A' : DiscreteQuotient X\n⊢ Iff (DiscreteQuotient.LEComap (ContinuousMap.id X) A A') (LE.le A A')","decl":"@[simp]\ntheorem leComap_id_iff : LEComap (ContinuousMap.id X) A A' ↔ A ≤ A' :=\n  Iff.rfl\n\n"}
{"name":"DiscreteQuotient.LEComap.comp","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ng : ContinuousMap Y Z\nC : DiscreteQuotient Z\na✝¹ : DiscreteQuotient.LEComap g B C\na✝ : DiscreteQuotient.LEComap f A B\n⊢ DiscreteQuotient.LEComap (g.comp f) A C","decl":"theorem LEComap.comp : LEComap g B C → LEComap f A B → LEComap (g.comp f) A C := by tauto\n\n"}
{"name":"DiscreteQuotient.LEComap.mono","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA A' : DiscreteQuotient X\nB B' : DiscreteQuotient Y\nh : DiscreteQuotient.LEComap f A B\nhA : LE.le A' A\nhB : LE.le B B'\n⊢ DiscreteQuotient.LEComap f A' B'","decl":"@[mono]\ntheorem LEComap.mono (h : LEComap f A B) (hA : A' ≤ A) (hB : B ≤ B') : LEComap f A' B' :=\n  hA.trans <| h.trans <| comap_mono _ hB\n\n"}
{"name":"DiscreteQuotient.map_continuous","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\n⊢ Continuous (DiscreteQuotient.map f cond)","decl":"theorem map_continuous (cond : LEComap f A B) : Continuous (map f cond) :=\n  continuous_of_discreteTopology\n\n"}
{"name":"DiscreteQuotient.map_comp_proj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\n⊢ Eq (Function.comp (DiscreteQuotient.map f cond) A.proj) (Function.comp B.proj ⇑f)","decl":"@[simp]\ntheorem map_comp_proj (cond : LEComap f A B) : map f cond ∘ A.proj = B.proj ∘ f :=\n  rfl\n\n"}
{"name":"DiscreteQuotient.map_proj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\nx : X\n⊢ Eq (DiscreteQuotient.map f cond (A.proj x)) (B.proj (f x))","decl":"@[simp]\ntheorem map_proj (cond : LEComap f A B) (x : X) : map f cond (A.proj x) = B.proj (f x) :=\n  rfl\n\n"}
{"name":"DiscreteQuotient.map_id","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA : DiscreteQuotient X\n⊢ Eq (DiscreteQuotient.map (ContinuousMap.id X) ⋯) id","decl":"@[simp]\ntheorem map_id : map _ (leComap_id A) = id := by ext ⟨⟩; rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: figure out why `simpNF` says this is a bad `@[simp]` lemma\n-- See https://github.com/leanprover-community/batteries/issues/365\n"}
{"name":"DiscreteQuotient.map_comp","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\nZ : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB : DiscreteQuotient Y\ng : ContinuousMap Y Z\nC : DiscreteQuotient Z\nh1 : DiscreteQuotient.LEComap g B C\nh2 : DiscreteQuotient.LEComap f A B\n⊢ Eq (DiscreteQuotient.map (g.comp f) ⋯) (Function.comp (DiscreteQuotient.map g h1) (DiscreteQuotient.map f h2))","decl":"theorem map_comp (h1 : LEComap g B C) (h2 : LEComap f A B) :\n    map (g.comp f) (h1.comp h2) = map g h1 ∘ map f h2 := by\n  ext ⟨⟩\n  rfl\n\n"}
{"name":"DiscreteQuotient.ofLE_map","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB B' : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\nh : LE.le B B'\na : Quotient A.toSetoid\n⊢ Eq (DiscreteQuotient.ofLE h (DiscreteQuotient.map f cond a)) (DiscreteQuotient.map f ⋯ a)","decl":"@[simp]\ntheorem ofLE_map (cond : LEComap f A B) (h : B ≤ B') (a : A) :\n    ofLE h (map f cond a) = map f (cond.mono le_rfl h) a := by\n  rcases a with ⟨⟩\n  rfl\n\n"}
{"name":"DiscreteQuotient.ofLE_comp_map","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA : DiscreteQuotient X\nB B' : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\nh : LE.le B B'\n⊢ Eq (Function.comp (DiscreteQuotient.ofLE h) (DiscreteQuotient.map f cond)) (DiscreteQuotient.map f ⋯)","decl":"@[simp]\ntheorem ofLE_comp_map (cond : LEComap f A B) (h : B ≤ B') :\n    ofLE h ∘ map f cond = map f (cond.mono le_rfl h) :=\n  funext <| ofLE_map cond h\n\n"}
{"name":"DiscreteQuotient.map_ofLE","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA A' : DiscreteQuotient X\nB : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\nh : LE.le A' A\nc : Quotient A'.toSetoid\n⊢ Eq (DiscreteQuotient.map f cond (DiscreteQuotient.ofLE h c)) (DiscreteQuotient.map f ⋯ c)","decl":"@[simp]\ntheorem map_ofLE (cond : LEComap f A B) (h : A' ≤ A) (c : A') :\n    map f cond (ofLE h c) = map f (cond.mono h le_rfl) c := by\n  rcases c with ⟨⟩\n  rfl\n\n"}
{"name":"DiscreteQuotient.map_comp_ofLE","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nA A' : DiscreteQuotient X\nB : DiscreteQuotient Y\ncond : DiscreteQuotient.LEComap f A B\nh : LE.le A' A\n⊢ Eq (Function.comp (DiscreteQuotient.map f cond) (DiscreteQuotient.ofLE h)) (DiscreteQuotient.map f ⋯)","decl":"@[simp]\ntheorem map_comp_ofLE (cond : LEComap f A B) (h : A' ≤ A) :\n    map f cond ∘ ofLE h = map f (cond.mono h le_rfl) :=\n  funext <| map_ofLE cond h\n\n"}
{"name":"DiscreteQuotient.eq_of_forall_proj_eq","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : CompactSpace X\ndisc : TotallyDisconnectedSpace X\nx y : X\nh : ∀ (Q : DiscreteQuotient X), Eq (Q.proj x) (Q.proj y)\n⊢ Eq x y","decl":"theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n    {x y : X} (h : ∀ Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y := by\n  rw [← mem_singleton_iff, ← connectedComponent_eq_singleton, connectedComponent_eq_iInter_isClopen,\n    mem_iInter]\n  rintro ⟨U, hU1, hU2⟩\n  exact (Quotient.exact' (h (ofIsClopen hU1))).mpr hU2\n\n"}
{"name":"DiscreteQuotient.fiber_subset_ofLE","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nA B : DiscreteQuotient X\nh : LE.le A B\na : Quotient A.toSetoid\n⊢ HasSubset.Subset (Set.preimage A.proj (Singleton.singleton a)) (Set.preimage B.proj (Singleton.singleton (DiscreteQuotient.ofLE h a)))","decl":"theorem fiber_subset_ofLE {A B : DiscreteQuotient X} (h : A ≤ B) (a : A) :\n    A.proj ⁻¹' {a} ⊆ B.proj ⁻¹' {ofLE h a} := by\n  rcases A.proj_surjective a with ⟨a, rfl⟩\n  rw [fiber_eq, ofLE_proj, fiber_eq]\n  exact fun _ h' => h h'\n\n"}
{"name":"DiscreteQuotient.exists_of_compat","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nQs : (Q : DiscreteQuotient X) → Quotient Q.toSetoid\ncompat : ∀ (A B : DiscreteQuotient X) (h : LE.le A B), Eq (DiscreteQuotient.ofLE h (Qs A)) (Qs B)\n⊢ Exists fun x => ∀ (Q : DiscreteQuotient X), Eq (Q.proj x) (Qs Q)","decl":"theorem exists_of_compat [CompactSpace X] (Qs : (Q : DiscreteQuotient X) → Q)\n    (compat : ∀ (A B : DiscreteQuotient X) (h : A ≤ B), ofLE h (Qs _) = Qs _) :\n    ∃ x : X, ∀ Q : DiscreteQuotient X, Q.proj x = Qs _ := by\n  have H₁ : ∀ Q₁ Q₂, Q₁ ≤ Q₂ → proj Q₁ ⁻¹' {Qs Q₁} ⊆ proj Q₂ ⁻¹' {Qs Q₂} := fun _ _ h => by\n    rw [← compat _ _ h]\n    exact fiber_subset_ofLE _ _\n  obtain ⟨x, hx⟩ : Set.Nonempty (⋂ Q, proj Q ⁻¹' {Qs Q}) :=\n    IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n      (fun Q : DiscreteQuotient X => Q.proj ⁻¹' {Qs _}) (directed_of_isDirected_ge H₁)\n      (fun Q => (singleton_nonempty _).preimage Q.proj_surjective)\n      (fun Q => (Q.isClosed_preimage {Qs _}).isCompact) fun Q => Q.isClosed_preimage _\n  exact ⟨x, mem_iInter.1 hx⟩\n\n"}
{"name":"DiscreteQuotient.instFiniteQuotientOfCompactSpace","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\nS : DiscreteQuotient X\ninst✝ : CompactSpace X\n⊢ Finite (Quotient S.toSetoid)","decl":"/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ninstance [CompactSpace X] : Finite S := by\n  have : CompactSpace S := Quotient.compactSpace\n  rwa [← isCompact_univ_iff, isCompact_iff_finite, finite_univ_iff] at this\n\n"}
{"name":"DiscreteQuotient.comp_finsetClopens","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ Eq (Function.comp (Function.comp (Set.image fun t => t.carrier) Finset.toSet) (DiscreteQuotient.finsetClopens X)) fun x => DiscreteQuotient.comp_finsetClopens.match_1 X (fun x => Set (Set X)) x fun f isOpen_setOf_rel => f.classes","decl":"/-- A helper lemma to prove that `finsetClopens X` is injective, see `finsetClopens_inj`. -/\nlemma comp_finsetClopens [CompactSpace X] :\n    (Set.image (fun (t : Clopens X) ↦ t.carrier) ∘ Finset.toSet) ∘\n      finsetClopens X = fun ⟨f, _⟩ ↦ f.classes := by\n  ext d\n  simp only [Setoid.classes, Set.mem_setOf_eq, Function.comp_apply,\n    finsetClopens, Set.coe_toFinset, Set.mem_image, Set.mem_range,\n    exists_exists_eq_and]\n  constructor\n  · refine fun ⟨y, h⟩ ↦ ⟨Quotient.out (s := d.toSetoid) y, ?_⟩\n    ext\n    simpa [← h] using Quotient.mk_eq_iff_out (s := d.toSetoid)\n  · exact fun ⟨y, h⟩ ↦ ⟨d.proj y, by ext; simp [h, proj]⟩\n\n"}
{"name":"DiscreteQuotient.finsetClopens_inj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ Function.Injective (DiscreteQuotient.finsetClopens X)","decl":"/-- `finsetClopens X` is injective. -/\ntheorem finsetClopens_inj [CompactSpace X] :\n    (finsetClopens X).Injective := by\n  apply Function.Injective.of_comp (f := Set.image (fun (t : Clopens X) ↦ t.carrier) ∘ Finset.toSet)\n  rw [comp_finsetClopens]\n  intro ⟨_, _⟩ ⟨_, _⟩ h\n  congr\n  rw [Setoid.classes_inj]\n  exact h\n\n"}
{"name":"LocallyConstant.lift_comp_proj","module":"Mathlib.Topology.DiscreteQuotient","initialProofState":"α : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nf : LocallyConstant X α\n⊢ Eq (Function.comp (⇑f.lift) f.discreteQuotient.proj) ⇑f","decl":"@[simp]\ntheorem lift_comp_proj : f.lift ∘ f.discreteQuotient.proj = f := rfl\n\n"}
