{"name":"mem_innerDualCone","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ny : H\ns : Set H\n⊢ Iff (Membership.mem s.innerDualCone y) (∀ (x : H), Membership.mem s x → LE.le 0 (Inner.inner x y))","decl":"@[simp]\ntheorem mem_innerDualCone (y : H) (s : Set H) : y ∈ s.innerDualCone ↔ ∀ x ∈ s, 0 ≤ ⟪x, y⟫ :=\n  Iff.rfl\n\n"}
{"name":"innerDualCone_empty","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\n⊢ Eq EmptyCollection.emptyCollection.innerDualCone Top.top","decl":"@[simp]\ntheorem innerDualCone_empty : (∅ : Set H).innerDualCone = ⊤ :=\n  eq_top_iff.mpr fun _ _ _ => False.elim\n\n"}
{"name":"innerDualCone_zero","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\n⊢ Eq (Set.innerDualCone 0) Top.top","decl":"/-- Dual cone of the convex cone {0} is the total space. -/\n@[simp]\ntheorem innerDualCone_zero : (0 : Set H).innerDualCone = ⊤ :=\n  eq_top_iff.mpr fun _ _ y (hy : y = 0) => hy.symm ▸ (inner_zero_left _).ge\n\n"}
{"name":"innerDualCone_univ","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\n⊢ Eq Set.univ.innerDualCone 0","decl":"/-- Dual cone of the total space is the convex cone {0}. -/\n@[simp]\ntheorem innerDualCone_univ : (univ : Set H).innerDualCone = 0 := by\n  suffices ∀ x : H, x ∈ (univ : Set H).innerDualCone → x = 0 by\n    apply SetLike.coe_injective\n    exact eq_singleton_iff_unique_mem.mpr ⟨fun x _ => (inner_zero_right _).ge, this⟩\n  exact fun x hx => by simpa [← real_inner_self_nonpos] using hx (-x) (mem_univ _)\n\n"}
{"name":"innerDualCone_le_innerDualCone","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ns t : Set H\nh : HasSubset.Subset t s\n⊢ LE.le s.innerDualCone t.innerDualCone","decl":"theorem innerDualCone_le_innerDualCone (h : t ⊆ s) : s.innerDualCone ≤ t.innerDualCone :=\n  fun _ hy x hx => hy x (h hx)\n\n"}
{"name":"pointed_innerDualCone","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ns : Set H\n⊢ s.innerDualCone.Pointed","decl":"theorem pointed_innerDualCone : s.innerDualCone.Pointed := fun x _ => by rw [inner_zero_right]\n\n"}
{"name":"innerDualCone_singleton","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\nx : H\n⊢ Eq (Singleton.singleton x).innerDualCone (ConvexCone.comap ((innerₛₗ Real) x) (ConvexCone.positive Real Real))","decl":"/-- The inner dual cone of a singleton is given by the preimage of the positive cone under the\nlinear map `fun y ↦ ⟪x, y⟫`. -/\ntheorem innerDualCone_singleton (x : H) :\n    ({x} : Set H).innerDualCone = (ConvexCone.positive ℝ ℝ).comap (innerₛₗ ℝ x) :=\n  ConvexCone.ext fun _ => forall_eq\n\n"}
{"name":"innerDualCone_union","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ns t : Set H\n⊢ Eq (Union.union s t).innerDualCone (Min.min s.innerDualCone t.innerDualCone)","decl":"theorem innerDualCone_union (s t : Set H) :\n    (s ∪ t).innerDualCone = s.innerDualCone ⊓ t.innerDualCone :=\n  le_antisymm (le_inf (fun _ hx _ hy => hx _ <| Or.inl hy) fun _ hx _ hy => hx _ <| Or.inr hy)\n    fun _ hx _ => Or.rec (hx.1 _) (hx.2 _)\n\n"}
{"name":"innerDualCone_insert","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\nx : H\ns : Set H\n⊢ Eq (Insert.insert x s).innerDualCone (Min.min (Singleton.singleton x).innerDualCone s.innerDualCone)","decl":"theorem innerDualCone_insert (x : H) (s : Set H) :\n    (insert x s).innerDualCone = Set.innerDualCone {x} ⊓ s.innerDualCone := by\n  rw [insert_eq, innerDualCone_union]\n\n"}
{"name":"innerDualCone_iUnion","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\nι : Sort u_2\nf : ι → Set H\n⊢ Eq (Set.iUnion fun i => f i).innerDualCone (iInf fun i => (f i).innerDualCone)","decl":"theorem innerDualCone_iUnion {ι : Sort*} (f : ι → Set H) :\n    (⋃ i, f i).innerDualCone = ⨅ i, (f i).innerDualCone := by\n  refine le_antisymm (le_iInf fun i x hx y hy => hx _ <| mem_iUnion_of_mem _ hy) ?_\n  intro x hx y hy\n  rw [ConvexCone.mem_iInf] at hx\n  obtain ⟨j, hj⟩ := mem_iUnion.mp hy\n  exact hx _ _ hj\n\n"}
{"name":"innerDualCone_sUnion","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\nS : Set (Set H)\n⊢ Eq S.sUnion.innerDualCone (InfSet.sInf (Set.image Set.innerDualCone S))","decl":"theorem innerDualCone_sUnion (S : Set (Set H)) :\n    (⋃₀ S).innerDualCone = sInf (Set.innerDualCone '' S) := by\n  simp_rw [sInf_image, sUnion_eq_biUnion, innerDualCone_iUnion]\n\n"}
{"name":"innerDualCone_eq_iInter_innerDualCone_singleton","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ns : Set H\n⊢ Eq (↑s.innerDualCone) (Set.iInter fun i => ↑(Singleton.singleton ↑i).innerDualCone)","decl":"/-- The dual cone of `s` equals the intersection of dual cones of the points in `s`. -/\ntheorem innerDualCone_eq_iInter_innerDualCone_singleton :\n    (s.innerDualCone : Set H) = ⋂ i : s, (({↑i} : Set H).innerDualCone : Set H) := by\n  rw [← ConvexCone.coe_iInf, ← innerDualCone_iUnion, iUnion_of_singleton_coe]\n\n"}
{"name":"isClosed_innerDualCone","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\ns : Set H\n⊢ IsClosed ↑s.innerDualCone","decl":"theorem isClosed_innerDualCone : IsClosed (s.innerDualCone : Set H) := by\n  -- reduce the problem to showing that dual cone of a singleton `{x}` is closed\n  rw [innerDualCone_eq_iInter_innerDualCone_singleton]\n  apply isClosed_iInter\n  intro x\n  -- the dual cone of a singleton `{x}` is the preimage of `[0, ∞)` under `inner x`\n  have h : ({↑x} : Set H).innerDualCone = (inner x : H → ℝ) ⁻¹' Set.Ici 0 := by\n    rw [innerDualCone_singleton, ConvexCone.coe_comap, ConvexCone.coe_positive, innerₛₗ_apply_coe]\n  -- the preimage is closed as `inner x` is continuous and `[0, ∞)` is closed\n  rw [h]\n  exact isClosed_Ici.preimage (continuous_const.inner continuous_id')\n\n"}
{"name":"ConvexCone.pointed_of_nonempty_of_isClosed","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace Real H\nK : ConvexCone Real H\nne : (↑K).Nonempty\nhc : IsClosed ↑K\n⊢ K.Pointed","decl":"theorem ConvexCone.pointed_of_nonempty_of_isClosed (K : ConvexCone ℝ H) (ne : (K : Set H).Nonempty)\n    (hc : IsClosed (K : Set H)) : K.Pointed := by\n  obtain ⟨x, hx⟩ := ne\n  let f : ℝ → H := (· • x)\n  -- f (0, ∞) is a subset of K\n  have fI : f '' Set.Ioi 0 ⊆ (K : Set H) := by\n    rintro _ ⟨_, h, rfl⟩\n    exact K.smul_mem (Set.mem_Ioi.1 h) hx\n  -- closure of f (0, ∞) is a subset of K\n  have clf : closure (f '' Set.Ioi 0) ⊆ (K : Set H) := hc.closure_subset_iff.2 fI\n  -- f is continuous at 0 from the right\n  have fc : ContinuousWithinAt f (Set.Ioi (0 : ℝ)) 0 :=\n    (continuous_id.smul continuous_const).continuousWithinAt\n  -- 0 belongs to the closure of the f (0, ∞)\n  have mem₀ := fc.mem_closure_image (by rw [closure_Ioi (0 : ℝ), mem_Ici])\n  -- as 0 ∈ closure f (0, ∞) and closure f (0, ∞) ⊆ K, 0 ∈ K.\n  have f₀ : f 0 = 0 := zero_smul ℝ x\n  simpa only [f₀, ConvexCone.Pointed, ← SetLike.mem_coe] using mem_of_subset_of_mem clf mem₀\n\n"}
{"name":"ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace Real H\ninst✝ : CompleteSpace H\nK : ConvexCone Real H\nne : (↑K).Nonempty\nhc : IsClosed ↑K\nb : H\ndisj : Not (Membership.mem K b)\n⊢ Exists fun y => And (∀ (x : H), Membership.mem K x → LE.le 0 (Inner.inner x y)) (LT.lt (Inner.inner y b) 0)","decl":"open scoped InnerProductSpace in\n/-- This is a stronger version of the Hahn-Banach separation theorem for closed convex cones. This\nis also the geometric interpretation of Farkas' lemma. -/\ntheorem ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem (K : ConvexCone ℝ H)\n    (ne : (K : Set H).Nonempty) (hc : IsClosed (K : Set H)) {b : H} (disj : b ∉ K) :\n    ∃ y : H, (∀ x : H, x ∈ K → 0 ≤ ⟪x, y⟫_ℝ) ∧ ⟪y, b⟫_ℝ < 0 := by\n  -- let `z` be the point in `K` closest to `b`\n  obtain ⟨z, hzK, infi⟩ := exists_norm_eq_iInf_of_complete_convex ne hc.isComplete K.convex b\n  -- for any `w` in `K`, we have `⟪b - z, w - z⟫_ℝ ≤ 0`\n  have hinner := (norm_eq_iInf_iff_real_inner_le_zero K.convex hzK).1 infi\n  -- set `y := z - b`\n  use z - b\n  constructor\n  · -- the rest of the proof is a straightforward calculation\n    rintro x hxK\n    specialize hinner _ (K.add_mem hxK hzK)\n    rwa [add_sub_cancel_right, real_inner_comm, ← neg_nonneg, neg_eq_neg_one_mul,\n      ← real_inner_smul_right, neg_smul, one_smul, neg_sub] at hinner\n  · -- as `K` is closed and non-empty, it is pointed\n    have hinner₀ := hinner 0 (K.pointed_of_nonempty_of_isClosed ne hc)\n    -- the rest of the proof is a straightforward calculation\n    rw [zero_sub, inner_neg_right, Right.neg_nonpos_iff] at hinner₀\n    have hbz : b - z ≠ 0 := by\n      rw [sub_ne_zero]\n      contrapose! hzK\n      rwa [← hzK]\n    rw [← neg_zero, lt_neg, ← neg_one_mul, ← real_inner_smul_left, smul_sub, neg_smul, one_smul,\n      neg_smul, neg_sub_neg, one_smul]\n    calc\n      0 < ⟪b - z, b - z⟫_ℝ := lt_of_not_le ((Iff.not real_inner_self_nonpos).2 hbz)\n      _ = ⟪b - z, b - z⟫_ℝ + 0 := (add_zero _).symm\n      _ ≤ ⟪b - z, b - z⟫_ℝ + ⟪b - z, z⟫_ℝ := add_le_add rfl.ge hinner₀\n      _ = ⟪b - z, b - z + z⟫_ℝ := (inner_add_right _ _ _).symm\n      _ = ⟪b - z, b⟫_ℝ := by rw [sub_add_cancel]\n\n"}
{"name":"ConvexCone.innerDualCone_of_innerDualCone_eq_self","module":"Mathlib.Analysis.Convex.Cone.InnerDual","initialProofState":"H : Type u_1\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace Real H\ninst✝ : CompleteSpace H\nK : ConvexCone Real H\nne : (↑K).Nonempty\nhc : IsClosed ↑K\n⊢ Eq (↑(↑K).innerDualCone).innerDualCone K","decl":"/-- The inner dual of inner dual of a non-empty, closed convex cone is itself. -/\ntheorem ConvexCone.innerDualCone_of_innerDualCone_eq_self (K : ConvexCone ℝ H)\n    (ne : (K : Set H).Nonempty) (hc : IsClosed (K : Set H)) :\n    ((K : Set H).innerDualCone : Set H).innerDualCone = K := by\n  ext x\n  constructor\n  · rw [mem_innerDualCone, ← SetLike.mem_coe]\n    contrapose!\n    exact K.hyperplane_separation_of_nonempty_of_isClosed_of_nmem ne hc\n  · rintro hxK y h\n    specialize h x hxK\n    rwa [real_inner_comm]\n\n"}
