{"name":"CategoryTheory.FintypeCat.instMonoActionFintypeCatOfImageComplementIncl","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\nX Y : Action FintypeCat (MonCat.of G)\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Mono (CategoryTheory.FintypeCat.Action.imageComplementIncl G f)","decl":"instance {X Y : Action FintypeCat (MonCat.of G)} (f : X ⟶ Y) :\n    Mono (Action.imageComplementIncl G f) := by\n  apply Functor.mono_of_mono_map (forget _)\n  apply ConcreteCategory.mono_of_injective\n  exact Subtype.val_injective\n\n"}
{"name":"CategoryTheory.FintypeCat.instHasColimitsOfShapeSingleObjFintypeCatOfFinite","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.SingleObj G) FintypeCat","decl":"/-- The category of finite sets has quotients by finite groups in arbitrary universes. -/\ninstance [Finite G] : HasColimitsOfShape (SingleObj G) FintypeCat.{w} := by\n  obtain ⟨G', hg, hf, ⟨e⟩⟩ := Finite.exists_type_univ_nonempty_mulEquiv G\n  exact Limits.hasColimitsOfShape_of_equivalence e.toSingleObjEquiv.symm\n\n"}
{"name":"CategoryTheory.FintypeCat.instPreservesFiniteLimitsActionFintypeCatOfForget","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget (Action FintypeCat (MonCat.of G)))","decl":"noncomputable instance : PreservesFiniteLimits (forget (Action FintypeCat (MonCat.of G))) := by\n  show PreservesFiniteLimits (Action.forget FintypeCat _ ⋙ FintypeCat.incl)\n  apply comp_preservesFiniteLimits\n\n"}
{"name":"CategoryTheory.FintypeCat.instPreGaloisCategoryActionFintypeCatOf","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ CategoryTheory.PreGaloisCategory (Action FintypeCat (MonCat.of G))","decl":"/-- The category of finite `G`-sets is a `PreGaloisCategory`. -/\ninstance : PreGaloisCategory (Action FintypeCat (MonCat.of G)) where\n  hasQuotientsByFiniteGroups _ _ _ := inferInstance\n  monoInducesIsoOnDirectSummand {_ _} i _ :=\n    ⟨Action.imageComplement G i, Action.imageComplementIncl G i,\n     ⟨isColimitOfReflects (Action.forget _ _ ⋙ FintypeCat.incl) <|\n      (isColimitMapCoconeBinaryCofanEquiv (forget _) i _).symm\n      (Types.isCoprodOfMono ((forget _).map i))⟩⟩\n\n"}
{"name":"CategoryTheory.FintypeCat.instFiberFunctorActionFintypeCatOfForget","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ CategoryTheory.PreGaloisCategory.FiberFunctor (Action.forget FintypeCat (MonCat.of G))","decl":"/-- The forgetful functor from finite `G`-sets to sets is a `FiberFunctor`. -/\nnoncomputable instance : FiberFunctor (Action.forget FintypeCat (MonCat.of G)) where\n  preservesFiniteCoproducts := ⟨fun _ _ ↦ inferInstance⟩\n  preservesQuotientsByFiniteGroups _ _ _ := inferInstance\n  reflectsIsos := ⟨fun f (_ : IsIso f.hom) => inferInstance⟩\n\n"}
{"name":"CategoryTheory.FintypeCat.instFiberFunctorActionFintypeCatOfForget₂","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ CategoryTheory.PreGaloisCategory.FiberFunctor (CategoryTheory.forget₂ (Action FintypeCat (MonCat.of G)) FintypeCat)","decl":"/-- The forgetful functor from finite `G`-sets to sets is a `FiberFunctor`. -/\nnoncomputable instance : FiberFunctor (forget₂ (Action FintypeCat (MonCat.of G)) FintypeCat) :=\n  inferInstanceAs <| FiberFunctor (Action.forget FintypeCat (MonCat.of G))\n\n"}
{"name":"CategoryTheory.FintypeCat.instGaloisCategoryActionFintypeCatOf","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ CategoryTheory.GaloisCategory (Action FintypeCat (MonCat.of G))","decl":"/-- The category of finite `G`-sets is a `GaloisCategory`. -/\ninstance : GaloisCategory (Action FintypeCat (MonCat.of G)) where\n  hasFiberFunctor := ⟨Action.forget FintypeCat (MonCat.of G), ⟨inferInstance⟩⟩\n\n"}
{"name":"CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝¹ : Group G\nX : Action FintypeCat (MonCat.of G)\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ MulAction.IsPretransitive G ↑X.V","decl":"/-- The `G`-action on a connected finite `G`-set is transitive. -/\ntheorem Action.pretransitive_of_isConnected (X : Action FintypeCat (MonCat.of G))\n    [IsConnected X] : MulAction.IsPretransitive G X.V where\n  exists_smul_eq x y := by\n    /- We show that the `G`-orbit of `x` is a non-initial subobject of `X` and hence by\n    connectedness, the orbit equals `X.V`. -/\n    let T : Set X.V := MulAction.orbit G x\n    have : Fintype T := Fintype.ofFinite T\n    letI : MulAction G (FintypeCat.of T) := inferInstanceAs <| MulAction G ↑(MulAction.orbit G x)\n    let T' : Action FintypeCat (MonCat.of G) := Action.FintypeCat.ofMulAction G (FintypeCat.of T)\n    let i : T' ⟶ X := ⟨Subtype.val, fun _ ↦ rfl⟩\n    have : Mono i := ConcreteCategory.mono_of_injective _ (Subtype.val_injective)\n    have : IsIso i := by\n      apply IsConnected.noTrivialComponent T' i\n      apply (not_initial_iff_fiber_nonempty (Action.forget _ _) T').mpr\n      exact Set.Nonempty.coe_sort (MulAction.orbit_nonempty x)\n    have hb : Function.Bijective i.hom := by\n      apply (ConcreteCategory.isIso_iff_bijective i.hom).mp\n      exact map_isIso (forget₂ _ FintypeCat) i\n    obtain ⟨⟨y', ⟨g, (hg : g • x = y')⟩⟩, (hy' : y' = y)⟩ := hb.surjective y\n    use g\n    exact hg.trans hy'\n\n"}
{"name":"CategoryTheory.FintypeCat.Action.isConnected_of_transitive","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝² : Group G\nX : FintypeCat\ninst✝¹ : MulAction G ↑X\ninst✝ : MulAction.IsPretransitive G ↑X\nh : Nonempty ↑X\n⊢ CategoryTheory.PreGaloisCategory.IsConnected (Action.FintypeCat.ofMulAction G X)","decl":"/-- A nonempty `G`-set with transitive `G`-action is connected. -/\ntheorem Action.isConnected_of_transitive (X : FintypeCat) [MulAction G X]\n    [MulAction.IsPretransitive G X] [h : Nonempty X] :\n    IsConnected (Action.FintypeCat.ofMulAction G X) where\n  notInitial := not_initial_of_inhabited (Action.forget _ _) h.some\n  noTrivialComponent Y i hm hni := by\n    /- We show that the induced inclusion `i.hom` of finite sets is surjective, using the\n    transitivity of the `G`-action. -/\n    obtain ⟨(y : Y.V)⟩ := (not_initial_iff_fiber_nonempty (Action.forget _ _) Y).mp hni\n    have : IsIso i.hom := by\n      refine (ConcreteCategory.isIso_iff_bijective i.hom).mpr ⟨?_, fun x' ↦ ?_⟩\n      · haveI : Mono i.hom := map_mono (forget₂ _ _) i\n        exact ConcreteCategory.injective_of_mono_of_preservesPullback i.hom\n      · letI x : X := i.hom y\n        obtain ⟨σ, hσ⟩ := MulAction.exists_smul_eq G x x'\n        use σ • y\n        show (Y.ρ σ ≫ i.hom) y = x'\n        rw [i.comm, FintypeCat.comp_apply]\n        exact hσ\n    apply isIso_of_reflects_iso i (Action.forget _ _)\n\n"}
{"name":"CategoryTheory.FintypeCat.Action.isConnected_iff_transitive","module":"Mathlib.CategoryTheory.Galois.Examples","initialProofState":"G : Type u\ninst✝¹ : Group G\nX : Action FintypeCat (MonCat.of G)\ninst✝ : Nonempty ↑X.V\n⊢ Iff (CategoryTheory.PreGaloisCategory.IsConnected X) (MulAction.IsPretransitive G ↑X.V)","decl":"/-- A nonempty finite `G`-set is connected if and only if the `G`-action is transitive. -/\ntheorem Action.isConnected_iff_transitive (X : Action FintypeCat (MonCat.of G)) [Nonempty X.V] :\n    IsConnected X ↔ MulAction.IsPretransitive G X.V :=\n  ⟨fun _ ↦ pretransitive_of_isConnected G X, fun _ ↦ isConnected_of_transitive G X.V⟩\n\n"}
