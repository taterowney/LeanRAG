{"name":"Nat.bodd_zero","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bodd 0) Bool.false","decl":"@[simp] lemma bodd_zero : bodd 0 = false := rfl\n\n"}
{"name":"Nat.bodd_one","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bodd 1) Bool.true","decl":"@[simp] lemma bodd_one : bodd 1 = true := rfl\n\n"}
{"name":"Nat.bodd_two","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bodd 2) Bool.false","decl":"lemma bodd_two : bodd 2 = false := rfl\n\n"}
{"name":"Nat.bodd_succ","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.succ.bodd n.bodd.not","decl":"@[simp]\nlemma bodd_succ (n : ℕ) : bodd (succ n) = not (bodd n) := by\n  simp only [bodd, boddDiv2]\n  let ⟨b,m⟩ := boddDiv2 n\n  cases b <;> rfl\n\n"}
{"name":"Nat.bodd_add","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\n⊢ Eq (HAdd.hAdd m n).bodd (m.bodd.xor n.bodd)","decl":"@[simp]\nlemma bodd_add (m n : ℕ) : bodd (m + n) = bxor (bodd m) (bodd n) := by\n  induction n\n  case zero => simp\n  case succ n ih => simp [← Nat.add_assoc, Bool.xor_not, ih]\n\n"}
{"name":"Nat.bodd_mul","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\n⊢ Eq (HMul.hMul m n).bodd (m.bodd.and n.bodd)","decl":"@[simp]\nlemma bodd_mul (m n : ℕ) : bodd (m * n) = (bodd m && bodd n) := by\n  induction n with\n  | zero => simp\n  | succ n IH =>\n    simp only [mul_succ, bodd_add, IH, bodd_succ]\n    cases bodd m <;> cases bodd n <;> rfl\n\n"}
{"name":"Nat.mod_two_of_bodd","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HMod.hMod n 2) n.bodd.toNat","decl":"lemma mod_two_of_bodd (n : ℕ) : n % 2 = (bodd n).toNat := by\n  have := congr_arg bodd (mod_add_div n 2)\n  simp? [not] at this says\n    simp only [bodd_add, bodd_mul, bodd_succ, not, bodd_zero, Bool.false_and, Bool.bne_false]\n      at this\n  have _ : ∀ b, and false b = false := by\n    intro b\n    cases b <;> rfl\n  have _ : ∀ b, bxor b false = b := by\n    intro b\n    cases b <;> rfl\n  rw [← this]\n  rcases mod_two_eq_zero_or_one n with h | h <;> rw [h] <;> rfl\n\n"}
{"name":"Nat.div2_zero","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.div2 0) 0","decl":"@[simp] lemma div2_zero : div2 0 = 0 := rfl\n\n"}
{"name":"Nat.div2_one","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.div2 1) 0","decl":"@[simp] lemma div2_one : div2 1 = 0 := rfl\n\n"}
{"name":"Nat.div2_two","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.div2 2) 1","decl":"lemma div2_two : div2 2 = 1 := rfl\n\n"}
{"name":"Nat.div2_succ","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 1).div2 (cond n.bodd n.div2.succ n.div2)","decl":"@[simp]\nlemma div2_succ (n : ℕ) : div2 (n + 1) = cond (bodd n) (succ (div2 n)) (div2 n) := by\n  simp only [bodd, boddDiv2, div2]\n  rcases boddDiv2 n with ⟨_|_, _⟩ <;> simp\n\n"}
{"name":"Nat.bodd_add_div2","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n.bodd.toNat (HMul.hMul 2 n.div2)) n","decl":"lemma bodd_add_div2 : ∀ n, (bodd n).toNat + 2 * div2 n = n\n  | 0 => rfl\n  | succ n => by\n    simp only [bodd_succ, Bool.cond_not, div2_succ, Nat.mul_comm]\n    refine Eq.trans ?_ (congr_arg succ (bodd_add_div2 n))\n    cases bodd n\n    · simp\n    · simp; omega\n\n"}
{"name":"Nat.div2_val","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.div2 (HDiv.hDiv n 2)","decl":"lemma div2_val (n) : div2 n = n / 2 := by\n  refine Nat.eq_of_mul_eq_mul_left (by decide)\n    (Nat.add_left_cancel (Eq.trans ?_ (Nat.mod_add_div n 2).symm))\n  rw [mod_two_of_bodd, bodd_add_div2]\n\n"}
{"name":"Nat.bit_decomp","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (Nat.bit n.bodd n.div2) n","decl":"lemma bit_decomp (n : Nat) : bit (bodd n) (div2 n) = n :=\n  (bit_val _ _).trans <| (Nat.add_comm _ _).trans <| bodd_add_div2 _\n\n"}
{"name":"Nat.bit_zero","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bit Bool.false 0) 0","decl":"lemma bit_zero : bit false 0 = 0 :=\n  rfl\n\n"}
{"name":"Nat.shiftLeft'_false","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\n⊢ Eq (Nat.shiftLeft' Bool.false m n) (HShiftLeft.hShiftLeft m n)","decl":"@[simp]\nlemma shiftLeft'_false : ∀ n, shiftLeft' false m n = m <<< n\n  | 0 => rfl\n  | n + 1 => by\n    have : 2 * (m * 2^n) = 2^(n+1)*m := by\n      rw [Nat.mul_comm, Nat.mul_assoc, ← Nat.pow_succ]; simp\n    simp [shiftLeft_eq, shiftLeft', bit_val, shiftLeft'_false, this]\n\n"}
{"name":"Nat.shiftLeft_eq'","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\n⊢ Eq (m.shiftLeft n) (HShiftLeft.hShiftLeft m n)","decl":"/-- Lean takes the unprimed name for `Nat.shiftLeft_eq m n : m <<< n = m * 2 ^ n`. -/\n@[simp] lemma shiftLeft_eq' (m n : Nat) : shiftLeft m n = m <<< n := rfl\n"}
{"name":"Nat.shiftRight_eq","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\n⊢ Eq (m.shiftRight n) (HShiftRight.hShiftRight m n)","decl":"@[simp] lemma shiftRight_eq (m n : Nat) : shiftRight m n = m >>> n := rfl\n\n"}
{"name":"Nat.binaryRec_decreasing","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\nh : Ne n 0\n⊢ LT.lt n.div2 n","decl":"lemma binaryRec_decreasing (h : n ≠ 0) : div2 n < n := by\n  rw [div2_val]\n  apply (div_lt_iff_lt_mul <| succ_pos 1).2\n  have := Nat.mul_lt_mul_of_pos_left (lt_succ_self 1)\n    (lt_of_le_of_ne n.zero_le h.symm)\n  rwa [Nat.mul_one] at this\n\n"}
{"name":"Nat.bodd_bit","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Nat.bit b n).bodd b","decl":"lemma bodd_bit (b n) : bodd (bit b n) = b := by\n  rw [bit_val]\n  simp only [Nat.mul_comm, Nat.add_comm, bodd_add, bodd_mul, bodd_succ, bodd_zero, Bool.not_false,\n    Bool.not_true, Bool.and_false, Bool.xor_false]\n  cases b <;> cases bodd n <;> rfl\n\n"}
{"name":"Nat.div2_bit","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Nat.bit b n).div2 n","decl":"lemma div2_bit (b n) : div2 (bit b n) = n := by\n  rw [bit_val, div2_val, Nat.add_comm, add_mul_div_left, div_eq_of_lt, Nat.zero_add]\n  <;> cases b\n  <;> decide\n\n"}
{"name":"Nat.shiftLeft'_add","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nm n k : Nat\n⊢ Eq (Nat.shiftLeft' b m (HAdd.hAdd n k)) (Nat.shiftLeft' b (Nat.shiftLeft' b m n) k)","decl":"lemma shiftLeft'_add (b m n) : ∀ k, shiftLeft' b m (n + k) = shiftLeft' b (shiftLeft' b m n) k\n  | 0 => rfl\n  | k + 1 => congr_arg (bit b) (shiftLeft'_add b m n k)\n\n"}
{"name":"Nat.shiftLeft'_sub","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nm n k : Nat\na✝ : LE.le k n\n⊢ Eq (Nat.shiftLeft' b m (HSub.hSub n k)) (HShiftRight.hShiftRight (Nat.shiftLeft' b m n) k)","decl":"lemma shiftLeft'_sub (b m) : ∀ {n k}, k ≤ n → shiftLeft' b m (n - k) = (shiftLeft' b m n) >>> k\n  | _, 0, _ => rfl\n  | n + 1, k + 1, h => by\n    rw [succ_sub_succ_eq_sub, shiftLeft', Nat.add_comm, shiftRight_add]\n    simp only [shiftLeft'_sub, Nat.le_of_succ_le_succ h, shiftRight_succ, shiftRight_zero]\n    simp [← div2_val, div2_bit]\n\n"}
{"name":"Nat.shiftLeft_sub","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n k : Nat\na✝ : LE.le k n\n⊢ Eq (HShiftLeft.hShiftLeft m (HSub.hSub n k)) (HShiftRight.hShiftRight (HShiftLeft.hShiftLeft m n) k)","decl":"lemma shiftLeft_sub : ∀ (m : Nat) {n k}, k ≤ n → m <<< (n - k) = (m <<< n) >>> k :=\n  fun _ _ _ hk => by simp only [← shiftLeft'_false, shiftLeft'_sub false _ hk]\n\n"}
{"name":"Nat.bodd_eq_one_and_ne_zero","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.bodd (bne (HAnd.hAnd 1 n) 0)","decl":"lemma bodd_eq_one_and_ne_zero : ∀ n, bodd n = (1 &&& n != 0)\n  | 0 => rfl\n  | 1 => rfl\n  | n + 2 => by simpa using bodd_eq_one_and_ne_zero n\n\n"}
{"name":"Nat.testBit_bit_succ","module":"Mathlib.Data.Nat.Bits","initialProofState":"m : Nat\nb : Bool\nn : Nat\n⊢ Eq ((Nat.bit b n).testBit m.succ) (n.testBit m)","decl":"lemma testBit_bit_succ (m b n) : testBit (bit b n) (succ m) = testBit n m := by\n  have : bodd (((bit b n) >>> 1) >>> m) = bodd (n >>> m) := by\n    simp only [shiftRight_eq_div_pow]\n    simp [← div2_val, div2_bit]\n  rw [← shiftRight_add, Nat.add_comm] at this\n  simp only [bodd_eq_one_and_ne_zero] at this\n  exact this\n\n"}
{"name":"Nat.boddDiv2_eq","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.boddDiv2 { fst := n.bodd, snd := n.div2 }","decl":"@[simp]\ntheorem boddDiv2_eq (n : ℕ) : boddDiv2 n = (bodd n, div2 n) := rfl\n\n"}
{"name":"Nat.div2_bit0","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul 2 n).div2 n","decl":"@[simp]\ntheorem div2_bit0 (n) : div2 (2 * n) = n :=\n  div2_bit false n\n\n-- simp can prove this\n"}
{"name":"Nat.div2_bit1","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (HMul.hMul 2 n) 1).div2 n","decl":"theorem div2_bit1 (n) : div2 (2 * n + 1) = n :=\n  div2_bit true n\n\n"}
{"name":"Nat.bit_add","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nn m : Nat\n⊢ Eq (Nat.bit b (HAdd.hAdd n m)) (HAdd.hAdd (Nat.bit Bool.false n) (Nat.bit b m))","decl":"theorem bit_add : ∀ (b : Bool) (n m : ℕ), bit b (n + m) = bit false n + bit b m\n  | true,  _, _ => by dsimp [bit]; omega\n  | false, _, _ => by dsimp [bit]; omega\n\n"}
{"name":"Nat.bit_add'","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nn m : Nat\n⊢ Eq (Nat.bit b (HAdd.hAdd n m)) (HAdd.hAdd (Nat.bit b n) (Nat.bit Bool.false m))","decl":"theorem bit_add' : ∀ (b : Bool) (n m : ℕ), bit b (n + m) = bit b n + bit false m\n  | true,  _, _ => by dsimp [bit]; omega\n  | false, _, _ => by dsimp [bit]; omega\n\n"}
{"name":"Nat.bit_ne_zero","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nn : Nat\nh : Ne n 0\n⊢ Ne (Nat.bit b n) 0","decl":"theorem bit_ne_zero (b) {n} (h : n ≠ 0) : bit b n ≠ 0 := by\n  cases b <;> dsimp [bit] <;> omega\n\n"}
{"name":"Nat.bitCasesOn_bit0","module":"Mathlib.Data.Nat.Bits","initialProofState":"motive : Nat → Sort u\nH : (b : Bool) → (n : Nat) → motive (Nat.bit b n)\nn : Nat\n⊢ Eq (Nat.bitCasesOn (HMul.hMul 2 n) H) (H Bool.false n)","decl":"@[simp]\ntheorem bitCasesOn_bit0 {motive : ℕ → Sort u} (H : ∀ b n, motive (bit b n)) (n : ℕ) :\n    bitCasesOn (2 * n) H = H false n :=\n  bitCasesOn_bit H false n\n\n"}
{"name":"Nat.bitCasesOn_bit1","module":"Mathlib.Data.Nat.Bits","initialProofState":"motive : Nat → Sort u\nH : (b : Bool) → (n : Nat) → motive (Nat.bit b n)\nn : Nat\n⊢ Eq (Nat.bitCasesOn (HAdd.hAdd (HMul.hMul 2 n) 1) H) (H Bool.true n)","decl":"@[simp]\ntheorem bitCasesOn_bit1 {motive : ℕ → Sort u} (H : ∀ b n, motive (bit b n)) (n : ℕ) :\n    bitCasesOn (2 * n + 1) H = H true n :=\n  bitCasesOn_bit H true n\n\n"}
{"name":"Nat.bit_cases_on_injective","module":"Mathlib.Data.Nat.Bits","initialProofState":"motive : Nat → Sort u\n⊢ Function.Injective fun H n => Nat.bitCasesOn n H","decl":"theorem bit_cases_on_injective {motive : ℕ → Sort u} :\n    Function.Injective fun H : ∀ b n, motive (bit b n) => fun n => bitCasesOn n H := by\n  intro H₁ H₂ h\n  ext b n\n  simpa only [bitCasesOn_bit] using congr_fun h (bit b n)\n\n"}
{"name":"Nat.bit_cases_on_inj","module":"Mathlib.Data.Nat.Bits","initialProofState":"motive : Nat → Sort u\nH₁ H₂ : (b : Bool) → (n : Nat) → motive (Nat.bit b n)\n⊢ Iff (Eq (fun n => Nat.bitCasesOn n H₁) fun n => Nat.bitCasesOn n H₂) (Eq H₁ H₂)","decl":"@[simp]\ntheorem bit_cases_on_inj {motive : ℕ → Sort u} (H₁ H₂ : ∀ b n, motive (bit b n)) :\n    ((fun n => bitCasesOn n H₁) = fun n => bitCasesOn n H₂) ↔ H₁ = H₂ :=\n  bit_cases_on_injective.eq_iff\n\n"}
{"name":"Nat.bit_le","module":"Mathlib.Data.Nat.Bits","initialProofState":"b : Bool\nm n : Nat\na✝ : LE.le m n\n⊢ LE.le (Nat.bit b m) (Nat.bit b n)","decl":"lemma bit_le : ∀ (b : Bool) {m n : ℕ}, m ≤ n → bit b m ≤ bit b n\n  | true, _, _, h => by dsimp [bit]; omega\n  | false, _, _, h => by dsimp [bit]; omega\n\n"}
{"name":"Nat.bit_lt_bit","module":"Mathlib.Data.Nat.Bits","initialProofState":"m n : Nat\na b : Bool\nh : LT.lt m n\n⊢ LT.lt (Nat.bit a m) (Nat.bit b n)","decl":"lemma bit_lt_bit (a b) (h : m < n) : bit a m < bit b n := calc\n  bit a m < 2 * n   := by cases a <;> dsimp [bit] <;> omega\n        _ ≤ bit b n := by cases b <;> dsimp [bit] <;> omega\n\n"}
{"name":"Nat.zero_bits","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bits 0) List.nil","decl":"@[simp]\ntheorem zero_bits : bits 0 = [] := by simp [Nat.bits]\n\n"}
{"name":"Nat.bits_append_bit","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\nb : Bool\nhn : Eq n 0 → Eq b Bool.true\n⊢ Eq (Nat.bit b n).bits (List.cons b n.bits)","decl":"@[simp]\ntheorem bits_append_bit (n : ℕ) (b : Bool) (hn : n = 0 → b = true) :\n    (bit b n).bits = b :: n.bits := by\n  rw [Nat.bits, Nat.bits, binaryRec_eq]\n  simpa\n\n"}
{"name":"Nat.bit0_bits","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (HMul.hMul 2 n).bits (List.cons Bool.false n.bits)","decl":"@[simp]\ntheorem bit0_bits (n : ℕ) (hn : n ≠ 0) : (2 * n).bits = false :: n.bits :=\n  bits_append_bit n false fun hn' => absurd hn' hn\n\n"}
{"name":"Nat.bit1_bits","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (HMul.hMul 2 n) 1).bits (List.cons Bool.true n.bits)","decl":"@[simp]\ntheorem bit1_bits (n : ℕ) : (2 * n + 1).bits = true :: n.bits :=\n  bits_append_bit n true fun _ => rfl\n\n"}
{"name":"Nat.one_bits","module":"Mathlib.Data.Nat.Bits","initialProofState":"⊢ Eq (Nat.bits 1) (List.cons Bool.true List.nil)","decl":"@[simp]\ntheorem one_bits : Nat.bits 1 = [true] := by\n  convert bit1_bits 0\n  simp\n\n-- TODO Find somewhere this can live.\n-- example : bits 3423 = [true, true, true, true, true, false, true, false, true, false, true, true]\n-- := by norm_num\n\n"}
{"name":"Nat.bodd_eq_bits_head","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.bodd n.bits.headI","decl":"theorem bodd_eq_bits_head (n : ℕ) : n.bodd = n.bits.headI := by\n  induction n using Nat.binaryRec' with\n  | z => simp\n  | f _ _ h _ => simp [bodd_bit, bits_append_bit _ _ h]\n\n"}
{"name":"Nat.div2_bits_eq_tail","module":"Mathlib.Data.Nat.Bits","initialProofState":"n : Nat\n⊢ Eq n.div2.bits n.bits.tail","decl":"theorem div2_bits_eq_tail (n : ℕ) : n.div2.bits = n.bits.tail := by\n  induction n using Nat.binaryRec' with\n  | z => simp\n  | f _ _ h _ => simp [div2_bit, bits_append_bit _ _ h]\n\n"}
