{"name":"CategoryTheory.MonoOver.factors_congr","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nf g : CategoryTheory.MonoOver X\nY : C\nh : Quiver.Hom Y X\ne : CategoryTheory.Iso f g\n‚ä¢ Iff (f.Factors h) (g.Factors h)","decl":"theorem factors_congr {X : C} {f g : MonoOver X} {Y : C} (h : Y ‚ü∂ X) (e : f ‚âÖ g) :\n    f.Factors h ‚Üî g.Factors h :=\n  ‚ü®fun ‚ü®u, hu‚ü© => ‚ü®u ‚â´ ((MonoOver.forget _).map e.hom).left, by simp [hu]‚ü©, fun ‚ü®u, hu‚ü© =>\n    ‚ü®u ‚â´ ((MonoOver.forget _).map e.inv).left, by simp [hu]‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.mk_factors_iff","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.Mono f\ng : Quiver.Hom Z X\n‚ä¢ Iff ((CategoryTheory.Subobject.mk f).Factors g) ((CategoryTheory.MonoOver.mk' f).Factors g)","decl":"@[simp]\ntheorem mk_factors_iff {X Y Z : C} (f : Y ‚ü∂ X) [Mono f] (g : Z ‚ü∂ X) :\n    (Subobject.mk f).Factors g ‚Üî (MonoOver.mk' f).Factors g :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Subobject.mk_factors_self","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ (CategoryTheory.Subobject.mk f).Factors f","decl":"theorem mk_factors_self (f : X ‚ü∂ Y) [Mono f] : (mk f).Factors f :=\n  ‚ü®ùüô _, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factors_iff","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X Y\n‚ä¢ Iff (P.Factors f) ((CategoryTheory.Subobject.representative.obj P).Factors f)","decl":"theorem factors_iff {X Y : C} (P : Subobject Y) (f : X ‚ü∂ Y) :\n    P.Factors f ‚Üî (representative.obj P).Factors f :=\n  Quot.inductionOn P fun _ => MonoOver.factors_congr _ (representativeIso _).symm\n\n"}
{"name":"CategoryTheory.Subobject.factors_self","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nP : CategoryTheory.Subobject X\n‚ä¢ P.Factors P.arrow","decl":"theorem factors_self {X : C} (P : Subobject X) : P.Factors P.arrow :=\n  (factors_iff _ _).mpr ‚ü®ùüô (P : C), by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factors_comp_arrow","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\n‚ä¢ P.Factors (CategoryTheory.CategoryStruct.comp f P.arrow)","decl":"theorem factors_comp_arrow {X Y : C} {P : Subobject Y} (f : X ‚ü∂ P) : P.Factors (f ‚â´ P.arrow) :=\n  (factors_iff _ _).mpr ‚ü®f, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factors_of_factors_right","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nP : CategoryTheory.Subobject Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : P.Factors g\n‚ä¢ P.Factors (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem factors_of_factors_right {X Y Z : C} {P : Subobject Z} (f : X ‚ü∂ Y) {g : Y ‚ü∂ Z}\n    (h : P.Factors g) : P.Factors (f ‚â´ g) := by\n  induction' P using Quotient.ind' with P\n  obtain ‚ü®g, rfl‚ü© := h\n  exact ‚ü®f ‚â´ g, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factors_zero","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nP : CategoryTheory.Subobject Y\n‚ä¢ P.Factors 0","decl":"theorem factors_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y} : P.Factors (0 : X ‚ü∂ Y) :=\n  (factors_iff _ _).mpr ‚ü®0, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factors_of_le","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nY Z : C\nP Q : CategoryTheory.Subobject Y\nf : Quiver.Hom Z Y\nh : LE.le P Q\na‚úù : P.Factors f\n‚ä¢ Q.Factors f","decl":"theorem factors_of_le {Y Z : C} {P Q : Subobject Y} (f : Z ‚ü∂ Y) (h : P ‚â§ Q) :\n    P.Factors f ‚Üí Q.Factors f := by\n  simp only [factors_iff]\n  exact fun ‚ü®u, hu‚ü© => ‚ü®u ‚â´ ofLE _ _ h, by simp [‚Üê hu]‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_arrow","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X Y\nh : P.Factors f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.factorThru f h) P.arrow) f","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_arrow {X Y : C} (P : Subobject Y) (f : X ‚ü∂ Y) (h : Factors P f) :\n    P.factorThru f h ‚â´ P.arrow = f :=\n  Classical.choose_spec ((factors_iff _ _).mp h)\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X Y\nh‚úù : P.Factors f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.factorThru f h‚úù) (CategoryTheory.CategoryStruct.comp P.arrow h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_arrow {X Y : C} (P : Subobject Y) (f : X ‚ü∂ Y) (h : Factors P f) :\n    P.factorThru f h ‚â´ P.arrow = f :=\n  Classical.choose_spec ((factors_iff _ _).mp h)\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_self","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nP : CategoryTheory.Subobject X\nh : P.Factors P.arrow\n‚ä¢ Eq (P.factorThru P.arrow h) (CategoryTheory.CategoryStruct.id (CategoryTheory.Subobject.underlying.obj P))","decl":"@[simp]\ntheorem factorThru_self {X : C} (P : Subobject X) (h) : P.factorThru P.arrow h = ùüô (P : C) := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_mk_self","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq ((CategoryTheory.Subobject.mk f).factorThru f ‚ãØ) (CategoryTheory.Subobject.underlyingIso f).inv","decl":"@[simp]\ntheorem factorThru_mk_self (f : X ‚ü∂ Y) [Mono f] :\n    (mk f).factorThru f (mk_factors_self f) = (underlyingIso f).inv := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_comp_arrow","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\nh : P.Factors (CategoryTheory.CategoryStruct.comp f P.arrow)\n‚ä¢ Eq (P.factorThru (CategoryTheory.CategoryStruct.comp f P.arrow) h) f","decl":"@[simp]\ntheorem factorThru_comp_arrow {X Y : C} {P : Subobject Y} (f : X ‚ü∂ P) (h) :\n    P.factorThru (f ‚â´ P.arrow) h = f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_eq_zero","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nP : CategoryTheory.Subobject Y\nf : Quiver.Hom X Y\nh : P.Factors f\n‚ä¢ Iff (Eq (P.factorThru f h) 0) (Eq f 0)","decl":"@[simp]\ntheorem factorThru_eq_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y} {f : X ‚ü∂ Y}\n    {h : Factors P f} : P.factorThru f h = 0 ‚Üî f = 0 := by\n  fconstructor\n  ¬∑ intro w\n    replace w := w =‚â´ P.arrow\n    simpa using w\n  ¬∑ rintro rfl\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_right","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nP : CategoryTheory.Subobject Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : P.Factors g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (P.factorThru g h)) (P.factorThru (CategoryTheory.CategoryStruct.comp f g) ‚ãØ)","decl":"theorem factorThru_right {X Y Z : C} {P : Subobject Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : P.Factors g) :\n    f ‚â´ P.factorThru g h = P.factorThru (f ‚â´ g) (factors_of_factors_right f h) := by\n  apply (cancel_mono P.arrow).mp\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_zero","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nP : CategoryTheory.Subobject Y\nh : P.Factors 0\n‚ä¢ Eq (P.factorThru 0 h) 0","decl":"@[simp]\ntheorem factorThru_zero [HasZeroMorphisms C] {X Y : C} {P : Subobject Y}\n    (h : P.Factors (0 : X ‚ü∂ Y)) : P.factorThru 0 h = 0 := by simp\n\n-- `h` is an explicit argument here so we can use\n-- `rw factorThru_ofLE h`, obtaining a subgoal `P.Factors f`.\n-- (While the reverse direction looks plausible as a simp lemma, it seems to be unproductive.)\n"}
{"name":"CategoryTheory.Subobject.factorThru_ofLE","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nY Z : C\nP Q : CategoryTheory.Subobject Y\nf : Quiver.Hom Z Y\nh : LE.le P Q\nw : P.Factors f\n‚ä¢ Eq (Q.factorThru f ‚ãØ) (CategoryTheory.CategoryStruct.comp (P.factorThru f w) (P.ofLE Q h))","decl":"theorem factorThru_ofLE {Y Z : C} {P Q : Subobject Y} {f : Z ‚ü∂ Y} (h : P ‚â§ Q) (w : P.Factors f) :\n    Q.factorThru f (factors_of_le f h w) = P.factorThru f w ‚â´ ofLE P Q h := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factors_add","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nwf : P.Factors f\nwg : P.Factors g\n‚ä¢ P.Factors (HAdd.hAdd f g)","decl":"theorem factors_add {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y) (wf : P.Factors f)\n    (wg : P.Factors g) : P.Factors (f + g) :=\n  (factors_iff _ _).mpr ‚ü®P.factorThru f wf + P.factorThru g wg, by simp‚ü©\n\n-- This can't be a `simp` lemma as `wf` and `wg` may not exist.\n-- However you can `rw` by it to assert that `f` and `g` factor through `P` separately.\n"}
{"name":"CategoryTheory.Subobject.factorThru_add","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nw : P.Factors (HAdd.hAdd f g)\nwf : P.Factors f\nwg : P.Factors g\n‚ä¢ Eq (P.factorThru (HAdd.hAdd f g) w) (HAdd.hAdd (P.factorThru f wf) (P.factorThru g wg))","decl":"theorem factorThru_add {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y) (w : P.Factors (f + g))\n    (wf : P.Factors f) (wg : P.Factors g) :\n    P.factorThru (f + g) w = P.factorThru f wf + P.factorThru g wg := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factors_left_of_factors_add","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nw : P.Factors (HAdd.hAdd f g)\nwg : P.Factors g\n‚ä¢ P.Factors f","decl":"theorem factors_left_of_factors_add {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y)\n    (w : P.Factors (f + g)) (wg : P.Factors g) : P.Factors f :=\n  (factors_iff _ _).mpr ‚ü®P.factorThru (f + g) w - P.factorThru g wg, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_add_sub_factorThru_right","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nw : P.Factors (HAdd.hAdd f g)\nwg : P.Factors g\n‚ä¢ Eq (HSub.hSub (P.factorThru (HAdd.hAdd f g) w) (P.factorThru g wg)) (P.factorThru f ‚ãØ)","decl":"@[simp]\ntheorem factorThru_add_sub_factorThru_right {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y)\n    (w : P.Factors (f + g)) (wg : P.Factors g) :\n    P.factorThru (f + g) w - P.factorThru g wg =\n      P.factorThru f (factors_left_of_factors_add f g w wg) := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.factors_right_of_factors_add","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nw : P.Factors (HAdd.hAdd f g)\nwf : P.Factors f\n‚ä¢ P.Factors g","decl":"theorem factors_right_of_factors_add {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y)\n    (w : P.Factors (f + g)) (wf : P.Factors f) : P.Factors g :=\n  (factors_iff _ _).mpr ‚ü®P.factorThru (f + g) w - P.factorThru f wf, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.factorThru_add_sub_factorThru_left","module":"Mathlib.CategoryTheory.Subobject.FactorThru","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X Y\nw : P.Factors (HAdd.hAdd f g)\nwf : P.Factors f\n‚ä¢ Eq (HSub.hSub (P.factorThru (HAdd.hAdd f g) w) (P.factorThru f wf)) (P.factorThru g ‚ãØ)","decl":"@[simp]\ntheorem factorThru_add_sub_factorThru_left {X Y : C} {P : Subobject Y} (f g : X ‚ü∂ Y)\n    (w : P.Factors (f + g)) (wf : P.Factors f) :\n    P.factorThru (f + g) w - P.factorThru f wf =\n      P.factorThru g (factors_right_of_factors_add f g w wf) := by\n  ext\n  simp\n\n"}
