{"name":"PiTensorProduct.toDualContinuousMultilinearMap_apply_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : PiTensorProduct ğ•œ fun i => E i\naâœ : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ Eq (((PiTensorProduct.toDualContinuousMultilinearMap F) x) aâœ) ((PiTensorProduct.lift aâœ.toMultilinearMap) x)","decl":"variable (F) in\n/-- The linear map from `â¨‚[ğ•œ] i, Eáµ¢` to `ContinuousMultilinearMap ğ•œ E F â†’L[ğ•œ] F` sending\n`x` in `â¨‚[ğ•œ] i, Eáµ¢` to the map `f â†¦ f.lift x`.\n-/\n@[simps!]\nnoncomputable def toDualContinuousMultilinearMap : (â¨‚[ğ•œ] i, E i) â†’â‚—[ğ•œ]\n    ContinuousMultilinearMap ğ•œ E F â†’L[ğ•œ] F where\n  toFun x := LinearMap.mkContinuous\n    ((LinearMap.flip (lift (R := ğ•œ) (s := E) (E := F)).toLinearMap x) âˆ˜â‚—\n    ContinuousMultilinearMap.toMultilinearMapLinear)\n    (projectiveSeminorm x)\n    (fun _ â†¦ by simp only [LinearMap.coe_comp, Function.comp_apply,\n                  ContinuousMultilinearMap.toMultilinearMapLinear_apply, LinearMap.flip_apply,\n                  LinearEquiv.coe_coe]\n                exact norm_eval_le_projectiveSeminorm _ _ _)\n  map_add' x y := by\n    ext _\n    simp only [map_add, LinearMap.mkContinuous_apply, LinearMap.coe_comp, Function.comp_apply,\n      ContinuousMultilinearMap.toMultilinearMapLinear_apply, LinearMap.add_apply,\n      LinearMap.flip_apply, LinearEquiv.coe_coe, ContinuousLinearMap.add_apply]\n  map_smul' a x := by\n    ext _\n    simp only [map_smul, LinearMap.mkContinuous_apply, LinearMap.coe_comp, Function.comp_apply,\n      ContinuousMultilinearMap.toMultilinearMapLinear_apply, LinearMap.smul_apply,\n      LinearMap.flip_apply, LinearEquiv.coe_coe, RingHom.id_apply, ContinuousLinearMap.coe_smul',\n      Pi.smul_apply]\n\n"}
{"name":"PiTensorProduct.toDualContinuousMultilinearMap_le_projectiveSeminorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ LE.le (Norm.norm ((PiTensorProduct.toDualContinuousMultilinearMap F) x)) (PiTensorProduct.projectiveSeminorm x)","decl":"theorem toDualContinuousMultilinearMap_le_projectiveSeminorm (x : â¨‚[ğ•œ] i, E i) :\n    â€–toDualContinuousMultilinearMap F xâ€– â‰¤ projectiveSeminorm x := by\n  simp only [toDualContinuousMultilinearMap, LinearMap.coe_mk, AddHom.coe_mk]\n  apply LinearMap.mkContinuous_norm_le _ (apply_nonneg _ _)\n\n"}
{"name":"PiTensorProduct.injectiveSeminorm_def","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type u_1\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type u_3\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ Eq PiTensorProduct.injectiveSeminorm (SupSet.sSup (setOf fun p => Exists fun G => Exists fun x => Exists fun x_1 => Eq p ((normSeminorm ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) (ContinuousMultilinearMap ğ•œ E G) G)).comp (PiTensorProduct.toDualContinuousMultilinearMap G))))","decl":"/-- The injective seminorm on `â¨‚[ğ•œ] i, Eáµ¢`. Morally, it sends `x` in `â¨‚[ğ•œ] i, Eáµ¢` to the\n`sup` of the operator norms of the `PiTensorProduct.toDualContinuousMultilinearMap F x`, for all\nnormed vector spaces `F`. In fact, we only take in the same universe as `â¨‚[ğ•œ] i, Eáµ¢`, and then\nprove in `PiTensorProduct.norm_eval_le_injectiveSeminorm` that this gives the same result.\n-/\nnoncomputable irreducible_def injectiveSeminorm : Seminorm ğ•œ (â¨‚[ğ•œ] i, E i) :=\n  sSup {p | âˆƒ (G : Type (max uÎ¹ uğ•œ uE)) (_ : SeminormedAddCommGroup G)\n  (_ : NormedSpace ğ•œ G), p = Seminorm.comp (normSeminorm ğ•œ (ContinuousMultilinearMap ğ•œ E G â†’L[ğ•œ] G))\n  (toDualContinuousMultilinearMap G (ğ•œ := ğ•œ) (E := E))}\n\n"}
{"name":"PiTensorProduct.dualSeminorms_bounded","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ BddAbove (setOf fun p => Exists fun G => Exists fun x => Exists fun x_1 => Eq p ((normSeminorm ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) (ContinuousMultilinearMap ğ•œ E G) G)).comp (PiTensorProduct.toDualContinuousMultilinearMap G)))","decl":"lemma dualSeminorms_bounded : BddAbove {p | âˆƒ (G : Type (max uÎ¹ uğ•œ uE))\n    (_ : SeminormedAddCommGroup G) (_ : NormedSpace ğ•œ G),\n    p = Seminorm.comp (normSeminorm ğ•œ (ContinuousMultilinearMap ğ•œ E G â†’L[ğ•œ] G))\n    (toDualContinuousMultilinearMap G (ğ•œ := ğ•œ) (E := E))} := by\n  existsi projectiveSeminorm\n  rw [mem_upperBounds]\n  simp only [Set.mem_setOf_eq, forall_exists_index]\n  intro p G _ _ hp\n  rw [hp]\n  intro x\n  simp only [Seminorm.comp_apply, coe_normSeminorm]\n  exact toDualContinuousMultilinearMap_le_projectiveSeminorm _\n\n"}
{"name":"PiTensorProduct.injectiveSeminorm_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nx : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ Eq (PiTensorProduct.injectiveSeminorm x) (iSup fun p => â†‘p x)","decl":"theorem injectiveSeminorm_apply (x : â¨‚[ğ•œ] i, E i) :\n    injectiveSeminorm x = â¨† p : {p | âˆƒ (G : Type (max uÎ¹ uğ•œ uE))\n    (_ : SeminormedAddCommGroup G) (_ : NormedSpace ğ•œ G), p = Seminorm.comp (normSeminorm ğ•œ\n    (ContinuousMultilinearMap ğ•œ E G â†’L[ğ•œ] G))\n    (toDualContinuousMultilinearMap G (ğ•œ := ğ•œ) (E := E))}, p.1 x := by\n  simpa only [injectiveSeminorm, Set.coe_setOf, Set.mem_setOf_eq]\n    using Seminorm.sSup_apply dualSeminorms_bounded\n\n"}
{"name":"PiTensorProduct.norm_eval_le_injectiveSeminorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ContinuousMultilinearMap ğ•œ E F\nx : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ LE.le (Norm.norm ((PiTensorProduct.lift f.toMultilinearMap) x)) (HMul.hMul (Norm.norm f) (PiTensorProduct.injectiveSeminorm x))","decl":"theorem norm_eval_le_injectiveSeminorm (f : ContinuousMultilinearMap ğ•œ E F) (x : â¨‚[ğ•œ] i, E i) :\n    â€–lift f.toMultilinearMap xâ€– â‰¤ â€–fâ€– * injectiveSeminorm x := by\n    /- If `F` were in `Type (max uÎ¹ uğ•œ uE)` (which is the type of `â¨‚[ğ•œ] i, E i`), then the\n    property that we want to prove would hold by definition of `injectiveSeminorm`. This is\n    not necessarily true, but we will show that there exists a normed vector space `G` in\n    `Type (max uÎ¹ uğ•œ uE)` and an injective isometry from `G` to `F` such that `f` factors\n    through a continuous multilinear map `f'` from `E = Î  i, E i` to `G`, to which we can apply\n    the definition of `injectiveSeminorm`. The desired inequality for `f` then follows\n    immediately.\n    The idea is very simple: the multilinear map `f` corresponds by `PiTensorProduct.lift`\n    to a linear map from `â¨‚[ğ•œ] i, E i` to `F`, say `l`. We want to take `G` to be the image of\n    `l`, with the norm induced from that of `F`; to make sure that we are in the correct universe,\n    it is actually more convenient to take `G` equal to the coimage of `l` (i.e. the quotient\n    of `â¨‚[ğ•œ] i, E i` by the kernel of `l`), which is canonically isomorphic to its image by\n    `LinearMap.quotKerEquivRange`. -/\n  set G := (â¨‚[ğ•œ] i, E i) â§¸ LinearMap.ker (lift f.toMultilinearMap)\n  set G' := LinearMap.range (lift f.toMultilinearMap)\n  set e := LinearMap.quotKerEquivRange (lift f.toMultilinearMap)\n  letI := SeminormedAddCommGroup.induced G G' e\n  letI := NormedSpace.induced ğ•œ G G' e\n  set f'â‚€ := lift.symm (e.symm.toLinearMap âˆ˜â‚— LinearMap.rangeRestrict (lift f.toMultilinearMap))\n  have hf'â‚€ : âˆ€ (x : Î  (i : Î¹), E i), â€–f'â‚€ xâ€– â‰¤ â€–fâ€– * âˆ i, â€–x iâ€– := fun x â†¦ by\n    change â€–e (f'â‚€ x)â€– â‰¤ _\n    simp only [lift_symm, LinearMap.compMultilinearMap_apply, LinearMap.coe_comp,\n        LinearEquiv.coe_coe, Function.comp_apply, LinearEquiv.apply_symm_apply, Submodule.coe_norm,\n        LinearMap.codRestrict_apply, lift.tprod, ContinuousMultilinearMap.coe_coe, e, f'â‚€]\n    exact f.le_opNorm x\n  set f' := MultilinearMap.mkContinuous f'â‚€ â€–fâ€– hf'â‚€\n  have hnorm : â€–f'â€– â‰¤ â€–fâ€– := (f'.opNorm_le_iff (norm_nonneg f)).mpr hf'â‚€\n  have heq : e (lift f'.toMultilinearMap x) = lift f.toMultilinearMap x := by\n    induction x using PiTensorProduct.induction_on with\n    | smul_tprod =>\n      simp only [lift_symm, map_smul, lift.tprod, ContinuousMultilinearMap.coe_coe,\n      MultilinearMap.coe_mkContinuous, LinearMap.compMultilinearMap_apply, LinearMap.coe_comp,\n      LinearEquiv.coe_coe, Function.comp_apply, LinearEquiv.apply_symm_apply, SetLike.val_smul,\n      LinearMap.codRestrict_apply, f', f'â‚€]\n    | add _ _ hx hy => simp only [map_add, Submodule.coe_add, hx, hy]\n  suffices h : â€–lift f'.toMultilinearMap xâ€– â‰¤ â€–f'â€– * injectiveSeminorm x by\n    change â€–(e (lift f'.toMultilinearMap x)).1â€– â‰¤ _ at h\n    rw [heq] at h\n    exact le_trans h (mul_le_mul_of_nonneg_right hnorm (apply_nonneg _ _))\n  have hle : Seminorm.comp (normSeminorm ğ•œ (ContinuousMultilinearMap ğ•œ E G â†’L[ğ•œ] G))\n      (toDualContinuousMultilinearMap G (ğ•œ := ğ•œ) (E := E)) â‰¤ injectiveSeminorm := by\n    simp only [injectiveSeminorm]\n    refine le_csSup dualSeminorms_bounded ?_\n    rw [Set.mem_setOf]\n    existsi G, inferInstance, inferInstance\n    rfl\n  refine le_trans ?_ (mul_le_mul_of_nonneg_left (hle x) (norm_nonneg f'))\n  simp only [Seminorm.comp_apply, coe_normSeminorm, â† toDualContinuousMultilinearMap_apply_apply]\n  rw [mul_comm]\n  exact ContinuousLinearMap.le_opNorm _ _\n\n"}
{"name":"PiTensorProduct.injectiveSeminorm_le_projectiveSeminorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ LE.le PiTensorProduct.injectiveSeminorm PiTensorProduct.projectiveSeminorm","decl":"theorem injectiveSeminorm_le_projectiveSeminorm :\n    injectiveSeminorm (ğ•œ := ğ•œ) (E := E) â‰¤ projectiveSeminorm := by\n  rw [injectiveSeminorm]\n  refine csSup_le ?_ ?_\n  Â· existsi 0\n    simp only [Set.mem_setOf_eq]\n    existsi PUnit, inferInstance, inferInstance\n    ext x\n    simp only [Seminorm.zero_apply, Seminorm.comp_apply, coe_normSeminorm]\n    rw [Subsingleton.elim (toDualContinuousMultilinearMap PUnit x) 0, norm_zero]\n  Â· intro p hp\n    simp only [Set.mem_setOf_eq] at hp\n    obtain âŸ¨G, _, _, hâŸ© := hp\n    rw [h]; intro x; simp only [Seminorm.comp_apply, coe_normSeminorm]\n    exact toDualContinuousMultilinearMap_le_projectiveSeminorm _\n\n"}
{"name":"PiTensorProduct.injectiveSeminorm_tprod_le","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (PiTensorProduct.injectiveSeminorm ((PiTensorProduct.tprod ğ•œ) fun i => m i)) (Finset.univ.prod fun i => Norm.norm (m i))","decl":"theorem injectiveSeminorm_tprod_le (m : Î  (i : Î¹), E i) :\n    injectiveSeminorm (â¨‚â‚œ[ğ•œ] i, m i) â‰¤ âˆ i, â€–m iâ€– :=\n  le_trans (injectiveSeminorm_le_projectiveSeminorm _) (projectiveSeminorm_tprod_le m)\n\n"}
{"name":"PiTensorProduct.liftEquiv_symm_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nl : ContinuousLinearMap (RingHom.id ğ•œ) (PiTensorProduct ğ•œ fun i => E i) F\nâŠ¢ Eq ((PiTensorProduct.liftEquiv ğ•œ E F).symm l) ((PiTensorProduct.lift.symm â†‘l).mkContinuous (Norm.norm l) â‹¯)","decl":"/-- The linear equivalence between `ContinuousMultilinearMap ğ•œ E F` and `(â¨‚[ğ•œ] i, Eáµ¢) â†’L[ğ•œ] F`\ninduced by `PiTensorProduct.lift`, for every normed space `F`.\n-/\n@[simps]\nnoncomputable def liftEquiv : ContinuousMultilinearMap ğ•œ E F â‰ƒâ‚—[ğ•œ] (â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] F where\n  toFun f := LinearMap.mkContinuous (lift f.toMultilinearMap) â€–fâ€–\n    (fun x â†¦ norm_eval_le_injectiveSeminorm f x)\n  map_add' f g := by ext _; simp only [ContinuousMultilinearMap.toMultilinearMap_add, map_add,\n    LinearMap.mkContinuous_apply, LinearMap.add_apply, ContinuousLinearMap.add_apply]\n  map_smul' a f := by ext _; simp only [ContinuousMultilinearMap.toMultilinearMap_smul, map_smul,\n    LinearMap.mkContinuous_apply, LinearMap.smul_apply, RingHom.id_apply,\n    ContinuousLinearMap.coe_smul', Pi.smul_apply]\n  invFun l := MultilinearMap.mkContinuous (lift.symm l.toLinearMap) â€–lâ€– (fun x â†¦ by\n    simp only [lift_symm, LinearMap.compMultilinearMap_apply, ContinuousLinearMap.coe_coe]\n    refine le_trans (ContinuousLinearMap.le_opNorm _ _) (mul_le_mul_of_nonneg_left ?_\n      (norm_nonneg l))\n    exact injectiveSeminorm_tprod_le x)\n  left_inv f := by ext x; simp only [LinearMap.mkContinuous_coe, LinearEquiv.symm_apply_apply,\n      MultilinearMap.coe_mkContinuous, ContinuousMultilinearMap.coe_coe]\n  right_inv l := by\n    rw [â† ContinuousLinearMap.coe_inj]\n    apply PiTensorProduct.ext; ext m\n    simp only [lift_symm, LinearMap.mkContinuous_coe, LinearMap.compMultilinearMap_apply,\n      lift.tprod, ContinuousMultilinearMap.coe_coe, MultilinearMap.coe_mkContinuous,\n      ContinuousLinearMap.coe_coe]\n\n"}
{"name":"PiTensorProduct.liftEquiv_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ Eq ((PiTensorProduct.liftEquiv ğ•œ E F) f) ((PiTensorProduct.lift f.toMultilinearMap).mkContinuous (Norm.norm f) â‹¯)","decl":"/-- The linear equivalence between `ContinuousMultilinearMap ğ•œ E F` and `(â¨‚[ğ•œ] i, Eáµ¢) â†’L[ğ•œ] F`\ninduced by `PiTensorProduct.lift`, for every normed space `F`.\n-/\n@[simps]\nnoncomputable def liftEquiv : ContinuousMultilinearMap ğ•œ E F â‰ƒâ‚—[ğ•œ] (â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] F where\n  toFun f := LinearMap.mkContinuous (lift f.toMultilinearMap) â€–fâ€–\n    (fun x â†¦ norm_eval_le_injectiveSeminorm f x)\n  map_add' f g := by ext _; simp only [ContinuousMultilinearMap.toMultilinearMap_add, map_add,\n    LinearMap.mkContinuous_apply, LinearMap.add_apply, ContinuousLinearMap.add_apply]\n  map_smul' a f := by ext _; simp only [ContinuousMultilinearMap.toMultilinearMap_smul, map_smul,\n    LinearMap.mkContinuous_apply, LinearMap.smul_apply, RingHom.id_apply,\n    ContinuousLinearMap.coe_smul', Pi.smul_apply]\n  invFun l := MultilinearMap.mkContinuous (lift.symm l.toLinearMap) â€–lâ€– (fun x â†¦ by\n    simp only [lift_symm, LinearMap.compMultilinearMap_apply, ContinuousLinearMap.coe_coe]\n    refine le_trans (ContinuousLinearMap.le_opNorm _ _) (mul_le_mul_of_nonneg_left ?_\n      (norm_nonneg l))\n    exact injectiveSeminorm_tprod_le x)\n  left_inv f := by ext x; simp only [LinearMap.mkContinuous_coe, LinearEquiv.symm_apply_apply,\n      MultilinearMap.coe_mkContinuous, ContinuousMultilinearMap.coe_coe]\n  right_inv l := by\n    rw [â† ContinuousLinearMap.coe_inj]\n    apply PiTensorProduct.ext; ext m\n    simp only [lift_symm, LinearMap.mkContinuous_coe, LinearMap.compMultilinearMap_apply,\n      lift.tprod, ContinuousMultilinearMap.coe_coe, MultilinearMap.coe_mkContinuous,\n      ContinuousLinearMap.coe_coe]\n\n"}
{"name":"PiTensorProduct.liftIsometry_apply_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ContinuousMultilinearMap ğ•œ E F\nx : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ Eq (((PiTensorProduct.liftIsometry ğ•œ E F) f) x) ((PiTensorProduct.lift f.toMultilinearMap) x)","decl":"@[simp]\ntheorem liftIsometry_apply_apply (f : ContinuousMultilinearMap ğ•œ E F) (x : â¨‚[ğ•œ] i, E i) :\n    liftIsometry ğ•œ E F f x = lift f.toMultilinearMap x := by\n  simp only [liftIsometry, LinearIsometryEquiv.coe_mk, liftEquiv_apply,\n    LinearMap.mkContinuous_apply]\n\n"}
{"name":"PiTensorProduct.tprodL_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\naâœ : (i : Î¹) â†’ E i\nâŠ¢ Eq ((PiTensorProduct.tprodL ğ•œ) aâœ) ((PiTensorProduct.tprod ğ•œ) aâœ)","decl":"/-- The canonical continuous multilinear map from `E = Î áµ¢ Eáµ¢` to `â¨‚[ğ•œ] i, Eáµ¢`.\n-/\n@[simps!]\nnoncomputable def tprodL : ContinuousMultilinearMap ğ•œ E (â¨‚[ğ•œ] i, E i) :=\n  (liftIsometry ğ•œ E _).symm (ContinuousLinearMap.id ğ•œ _)\n\n"}
{"name":"PiTensorProduct.tprodL_toFun","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\naâœ : (i : Î¹) â†’ E i\nâŠ¢ Eq ((PiTensorProduct.tprodL ğ•œ) aâœ) ((PiTensorProduct.tprod ğ•œ) aâœ)","decl":"/-- The canonical continuous multilinear map from `E = Î áµ¢ Eáµ¢` to `â¨‚[ğ•œ] i, Eáµ¢`.\n-/\n@[simps!]\nnoncomputable def tprodL : ContinuousMultilinearMap ğ•œ E (â¨‚[ğ•œ] i, E i) :=\n  (liftIsometry ğ•œ E _).symm (ContinuousLinearMap.id ğ•œ _)\n\n"}
{"name":"PiTensorProduct.tprodL_coe","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ Eq (PiTensorProduct.tprodL ğ•œ).toMultilinearMap (PiTensorProduct.tprod ğ•œ)","decl":"@[simp]\ntheorem tprodL_coe : (tprodL ğ•œ).toMultilinearMap = tprod ğ•œ (s := E) := by\n  ext m\n  simp only [ContinuousMultilinearMap.coe_coe, tprodL_toFun]\n\n"}
{"name":"PiTensorProduct.liftIsometry_symm_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nl : ContinuousLinearMap (RingHom.id ğ•œ) (PiTensorProduct ğ•œ fun i => E i) F\nâŠ¢ Eq ((PiTensorProduct.liftIsometry ğ•œ E F).symm l) (l.compContinuousMultilinearMap (PiTensorProduct.tprodL ğ•œ))","decl":"@[simp]\ntheorem liftIsometry_symm_apply (l : (â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] F) :\n    (liftIsometry ğ•œ E F).symm l = l.compContinuousMultilinearMap (tprodL ğ•œ) := by\n  ext m\n  change (liftEquiv ğ•œ E F).symm l m = _\n  simp only [liftEquiv_symm_apply, lift_symm, MultilinearMap.coe_mkContinuous,\n    LinearMap.compMultilinearMap_apply, ContinuousLinearMap.coe_coe,\n    ContinuousLinearMap.compContinuousMultilinearMap_coe, Function.comp_apply, tprodL_toFun]\n\n"}
{"name":"PiTensorProduct.liftIsometry_tprodL","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ Eq ((PiTensorProduct.liftIsometry ğ•œ E (PiTensorProduct ğ•œ fun i => E i)) (PiTensorProduct.tprodL ğ•œ)) (ContinuousLinearMap.id ğ•œ (PiTensorProduct ğ•œ fun i => E i))","decl":"@[simp]\ntheorem liftIsometry_tprodL :\n    liftIsometry ğ•œ E _ (tprodL ğ•œ) = ContinuousLinearMap.id ğ•œ (â¨‚[ğ•œ] i, E i) := by\n  ext _\n  simp only [liftIsometry_apply_apply, tprodL_coe, lift_tprod, LinearMap.id_coe, id_eq,\n    ContinuousLinearMap.coe_id']\n\n"}
{"name":"PiTensorProduct.mapL_coe","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nâŠ¢ Eq (â†‘(PiTensorProduct.mapL f)) (PiTensorProduct.map fun i => â†‘(f i))","decl":"@[simp]\ntheorem mapL_coe : (mapL f).toLinearMap = map (fun i â†¦ (f i).toLinearMap) := by\n  ext\n  simp only [mapL, LinearMap.compMultilinearMap_apply, ContinuousLinearMap.coe_coe,\n    liftIsometry_apply_apply, lift.tprod, ContinuousMultilinearMap.coe_coe,\n    ContinuousMultilinearMap.compContinuousLinearMap_apply, tprodL_toFun, map_tprod]\n\n"}
{"name":"PiTensorProduct.mapL_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nx : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ Eq ((PiTensorProduct.mapL f) x) ((PiTensorProduct.map fun i => â†‘(f i)) x)","decl":"@[simp]\ntheorem mapL_apply (x : â¨‚[ğ•œ] i, E i) : mapL f x = map (fun i â†¦ (f i).toLinearMap) x := by\n  induction x using PiTensorProduct.induction_on with\n  | smul_tprod =>\n    simp only [mapL, map_smul, liftIsometry_apply_apply, lift.tprod,\n    ContinuousMultilinearMap.coe_coe, ContinuousMultilinearMap.compContinuousLinearMap_apply,\n    tprodL_toFun, map_tprod, ContinuousLinearMap.coe_coe]\n  | add _ _ hx hy => simp only [map_add, hx, hy]\n\n"}
{"name":"PiTensorProduct.mapL_comp","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâ· : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\nE'' : Î¹ â†’ Type u_2\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E'' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E'' i)\ng : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E' i) (E'' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nâŠ¢ Eq (PiTensorProduct.mapL fun i => (g i).comp (f i)) ((PiTensorProduct.mapL g).comp (PiTensorProduct.mapL f))","decl":"theorem mapL_comp : mapL (fun (i : Î¹) â†¦ g i âˆ˜L f i) = mapL g âˆ˜L mapL f := by\n  apply ContinuousLinearMap.coe_injective\n  ext\n  simp only [mapL_coe, ContinuousLinearMap.coe_comp, LinearMap.compMultilinearMap_apply, map_tprod,\n    LinearMap.coe_comp, ContinuousLinearMap.coe_coe, Function.comp_apply]\n\n"}
{"name":"PiTensorProduct.liftIsometry_comp_mapL","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâ· : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nh : ContinuousMultilinearMap ğ•œ E' F\nâŠ¢ Eq (((PiTensorProduct.liftIsometry ğ•œ E' F) h).comp (PiTensorProduct.mapL f)) ((PiTensorProduct.liftIsometry ğ•œ E F) (h.compContinuousLinearMap f))","decl":"theorem liftIsometry_comp_mapL (h : ContinuousMultilinearMap ğ•œ E' F) :\n    liftIsometry ğ•œ E' F h âˆ˜L mapL f = liftIsometry ğ•œ E F (h.compContinuousLinearMap f) := by\n  apply ContinuousLinearMap.coe_injective\n  ext\n  simp only [ContinuousLinearMap.coe_comp, mapL_coe, LinearMap.compMultilinearMap_apply,\n    LinearMap.coe_comp, ContinuousLinearMap.coe_coe, Function.comp_apply, map_tprod,\n    liftIsometry_apply_apply, lift.tprod, ContinuousMultilinearMap.coe_coe,\n    ContinuousMultilinearMap.compContinuousLinearMap_apply]\n\n"}
{"name":"PiTensorProduct.mapL_id","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ Eq (PiTensorProduct.mapL fun i => ContinuousLinearMap.id ğ•œ (E i)) (ContinuousLinearMap.id ğ•œ (PiTensorProduct ğ•œ fun i => E i))","decl":"@[simp]\ntheorem mapL_id : mapL (fun i â†¦ ContinuousLinearMap.id ğ•œ (E i)) = ContinuousLinearMap.id _ _ := by\n  apply ContinuousLinearMap.coe_injective\n  ext\n  simp only [mapL_coe, ContinuousLinearMap.coe_id, map_id, LinearMap.compMultilinearMap_apply,\n    LinearMap.id_coe, id_eq]\n\n"}
{"name":"PiTensorProduct.mapL_one","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ Eq (PiTensorProduct.mapL fun i => 1) 1","decl":"@[simp]\ntheorem mapL_one : mapL (fun (i : Î¹) â†¦ (1 : E i â†’L[ğ•œ] E i)) = 1 :=\n  mapL_id\n\n"}
{"name":"PiTensorProduct.mapL_mul","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nfâ‚ fâ‚‚ : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E i)\nâŠ¢ Eq (PiTensorProduct.mapL fun i => HMul.hMul (fâ‚ i) (fâ‚‚ i)) (HMul.hMul (PiTensorProduct.mapL fâ‚) (PiTensorProduct.mapL fâ‚‚))","decl":"theorem mapL_mul (fâ‚ fâ‚‚ : Î  i, E i â†’L[ğ•œ] E i) :\n    mapL (fun i â†¦ fâ‚ i * fâ‚‚ i) = mapL fâ‚ * mapL fâ‚‚ :=\n  mapL_comp fâ‚ fâ‚‚\n\n"}
{"name":"PiTensorProduct.mapLMonoidHom_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E i)\nâŠ¢ Eq (PiTensorProduct.mapLMonoidHom f) (PiTensorProduct.mapL f)","decl":"/-- Upgrading `PiTensorProduct.mapL` to a `MonoidHom` when `E = E'`. -/\n@[simps]\nnoncomputable def mapLMonoidHom : (Î  i, E i â†’L[ğ•œ] E i) â†’* ((â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] â¨‚[ğ•œ] i, E i) where\n  toFun := mapL\n  map_one' := mapL_one\n  map_mul' := mapL_mul\n\n"}
{"name":"PiTensorProduct.mapL_pow","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœÂ³ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E i)\nn : Nat\nâŠ¢ Eq (PiTensorProduct.mapL (HPow.hPow f n)) (HPow.hPow (PiTensorProduct.mapL f) n)","decl":"@[simp]\nprotected theorem mapL_pow (f : Î  i, E i â†’L[ğ•œ] E i) (n : â„•) :\n    mapL (f ^ n) = mapL f ^ n := MonoidHom.map_pow mapLMonoidHom _ _\n\n-- We redeclare `Î¹` here, and later dependent arguments,\n-- to avoid the `[Fintype Î¹]` assumption present throughout the rest of the file.\n"}
{"name":"PiTensorProduct.mapL_add","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâ¶ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ² : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nu v : ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nâŠ¢ Eq (PiTensorProduct.mapL (Function.update f i (HAdd.hAdd u v))) (HAdd.hAdd (PiTensorProduct.mapL (Function.update f i u)) (PiTensorProduct.mapL (Function.update f i v)))","decl":"open Function in\nprotected theorem mapL_add [DecidableEq Î¹] (i : Î¹) (u v : E i â†’L[ğ•œ] E' i) :\n    mapL (update f i (u + v)) = mapL (update f i u) + mapL (update f i v) := by\n  ext x\n  simp only [mapL_apply, mapL_add_smul_aux, ContinuousLinearMap.coe_add,\n    PiTensorProduct.map_update_add, LinearMap.add_apply, ContinuousLinearMap.add_apply]\n\n"}
{"name":"PiTensorProduct.mapL_smul","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâ¶ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ² : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nc : ğ•œ\nu : ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nâŠ¢ Eq (PiTensorProduct.mapL (Function.update f i (HSMul.hSMul c u))) (HSMul.hSMul c (PiTensorProduct.mapL (Function.update f i u)))","decl":"open Function in\nprotected theorem mapL_smul [DecidableEq Î¹] (i : Î¹) (c : ğ•œ) (u : E i â†’L[ğ•œ] E' i) :\n    mapL (update f i (c â€¢ u)) = c â€¢ mapL (update f i u) := by\n  ext x\n  simp only [mapL_apply, mapL_add_smul_aux, ContinuousLinearMap.coe_smul,\n    PiTensorProduct.map_update_smul, LinearMap.smul_apply, ContinuousLinearMap.coe_smul',\n    Pi.smul_apply]\n\n"}
{"name":"PiTensorProduct.mapL_opNorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\nâŠ¢ LE.le (Norm.norm (PiTensorProduct.mapL f)) (Finset.univ.prod fun i => Norm.norm (f i))","decl":"theorem mapL_opNorm : â€–mapL fâ€– â‰¤ âˆ i, â€–f iâ€– := by\n  rw [ContinuousLinearMap.opNorm_le_iff (by positivity)]\n  intro x\n  rw [mapL, liftIsometry]\n  simp only [LinearIsometryEquiv.coe_mk, liftEquiv_apply, LinearMap.mkContinuous_apply]\n  refine le_trans (norm_eval_le_injectiveSeminorm _ _)\n    (mul_le_mul_of_nonneg_right ?_ (norm_nonneg x))\n  rw [ContinuousMultilinearMap.opNorm_le_iff (Finset.prod_nonneg (fun _ _ â†¦ norm_nonneg _))]\n  intro m\n  simp only [ContinuousMultilinearMap.compContinuousLinearMap_apply]\n  refine le_trans (injectiveSeminorm_tprod_le (fun i â†¦ (f i) (m i))) ?_\n  rw [â† Finset.prod_mul_distrib]\n  exact Finset.prod_le_prod (fun _ _ â†¦ norm_nonneg _) (fun _ _ â†¦ ContinuousLinearMap.le_opNorm _ _ )\n\n"}
{"name":"PiTensorProduct.mapLMultilinear_apply_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\naâœ : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ Eq (((PiTensorProduct.mapLMultilinear ğ•œ E E') f) aâœ) ((PiTensorProduct.liftAux ((PiTensorProduct.tprodL ğ•œ).compContinuousLinearMap f).toMultilinearMap) aâœ)","decl":"/-- The tensor of a family of linear maps from `Eáµ¢` to `E'áµ¢`, as a continuous multilinear map of\nthe family.\n-/\n@[simps!]\nnoncomputable def mapLMultilinear : ContinuousMultilinearMap ğ•œ (fun (i : Î¹) â†¦ E i â†’L[ğ•œ] E' i)\n    ((â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] â¨‚[ğ•œ] i, E' i) :=\n  MultilinearMap.mkContinuous\n  { toFun := mapL\n    map_update_smul' := fun _ _ _ _ â†¦ PiTensorProduct.mapL_smul _ _ _ _\n    map_update_add' := fun _ _ _ _ â†¦ PiTensorProduct.mapL_add _ _ _ _ }\n  1 (fun f â†¦ by rw [one_mul]; exact mapL_opNorm f)\n\n"}
{"name":"PiTensorProduct.mapLMultilinear_toFun_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (E' i)\naâœ : PiTensorProduct ğ•œ fun i => E i\nâŠ¢ Eq (((PiTensorProduct.mapLMultilinear ğ•œ E E') f) aâœ) ((PiTensorProduct.liftAux ((PiTensorProduct.tprodL ğ•œ).compContinuousLinearMap f).toMultilinearMap) aâœ)","decl":"/-- The tensor of a family of linear maps from `Eáµ¢` to `E'áµ¢`, as a continuous multilinear map of\nthe family.\n-/\n@[simps!]\nnoncomputable def mapLMultilinear : ContinuousMultilinearMap ğ•œ (fun (i : Î¹) â†¦ E i â†’L[ğ•œ] E' i)\n    ((â¨‚[ğ•œ] i, E i) â†’L[ğ•œ] â¨‚[ğ•œ] i, E' i) :=\n  MultilinearMap.mkContinuous\n  { toFun := mapL\n    map_update_smul' := fun _ _ _ _ â†¦ PiTensorProduct.mapL_smul _ _ _ _\n    map_update_add' := fun _ _ _ _ â†¦ PiTensorProduct.mapL_add _ _ _ _ }\n  1 (fun f â†¦ by rw [one_mul]; exact mapL_opNorm f)\n\n"}
{"name":"PiTensorProduct.mapLMultilinear_opNorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm","initialProofState":"Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nE' : Î¹ â†’ Type u_1\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E' i)\nâŠ¢ LE.le (Norm.norm (PiTensorProduct.mapLMultilinear ğ•œ E E')) 1","decl":"theorem mapLMultilinear_opNorm : â€–mapLMultilinear ğ•œ E E'â€– â‰¤ 1 :=\n  MultilinearMap.mkContinuous_norm_le _ zero_le_one _\n\n"}
