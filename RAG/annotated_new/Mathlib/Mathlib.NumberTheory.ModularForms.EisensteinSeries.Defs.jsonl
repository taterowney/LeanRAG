{"name":"EisensteinSeries.pairwise_disjoint_gammaSet","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"N : Nat\n⊢ Pairwise (Function.onFun Disjoint (EisensteinSeries.gammaSet N))","decl":"open scoped Function in -- required for scoped `on` notation\nlemma pairwise_disjoint_gammaSet : Pairwise (Disjoint on gammaSet N) := by\n  refine fun u v huv ↦ ?_\n  contrapose! huv\n  obtain ⟨f, hf⟩ := Set.not_disjoint_iff.mp huv\n  exact hf.1.1.symm.trans hf.2.1\n\n"}
{"name":"EisensteinSeries.gammaSet_one_eq","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"a a' : Fin 2 → ZMod 1\n⊢ Eq (EisensteinSeries.gammaSet 1 a) (EisensteinSeries.gammaSet 1 a')","decl":"/-- For level `N = 1`, the gamma sets are all equal. -/\nlemma gammaSet_one_eq (a a' : Fin 2 → ZMod 1) : gammaSet 1 a = gammaSet 1 a' :=\n  congr_arg _ (Subsingleton.elim _ _)\n\n"}
{"name":"EisensteinSeries.vecMul_SL2_mem_gammaSet","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"N : Nat\na : Fin 2 → ZMod N\nv : Fin 2 → Int\nhv : Membership.mem (EisensteinSeries.gammaSet N a) v\nγ : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Membership.mem (EisensteinSeries.gammaSet N (Matrix.vecMul a ↑((Matrix.SpecialLinearGroup.map (Int.castRingHom (ZMod N))) γ))) (Matrix.vecMul v ↑γ)","decl":"/-- Right-multiplying by `γ ∈ SL(2, ℤ)` sends `gammaSet N a` to `gammaSet N (a ᵥ* γ)`. -/\nlemma vecMul_SL2_mem_gammaSet {v : Fin 2 → ℤ} (hv : v ∈ gammaSet N a) (γ : SL(2, ℤ)) :\n    v ᵥ* γ ∈ gammaSet N (a ᵥ* γ) := by\n  refine ⟨?_, hv.2.vecMulSL γ⟩\n  have := RingHom.map_vecMul (m := Fin 2) (n := Fin 2) (Int.castRingHom (ZMod N)) γ v\n  simp only [eq_intCast, Int.coe_castRingHom] at this\n  simp_rw [Function.comp_def, this, hv.1]\n  simp\n\n"}
{"name":"EisensteinSeries.eisSummand_SL2_apply","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"k : Int\ni : Fin 2 → Int\nA : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Eq (EisensteinSeries.eisSummand k i (HSMul.hSMul A z)) (HMul.hMul (HPow.hPow (UpperHalfPlane.denom (↑A) z) k) (EisensteinSeries.eisSummand k (Matrix.vecMul i ↑A) z))","decl":"/-- How the `eisSummand` function changes under the Moebius action. -/\ntheorem eisSummand_SL2_apply (k : ℤ) (i : (Fin 2 → ℤ)) (A : SL(2, ℤ)) (z : ℍ) :\n    eisSummand k i (A • z) = (z.denom A) ^ k * eisSummand k (i ᵥ* A) z := by\n  simp only [eisSummand, vecMul, vec2_dotProduct]\n  push_cast\n  have h (a b c d u v : ℂ) (hc : c * z + d ≠ 0) : (u * ((a * z + b) / (c * z + d)) + v) ^ (-k) =\n      (c * z + d) ^ k * ((u * a + v * c) * z + (u * b + v * d)) ^ (-k) := by\n    field_simp [hc]\n    ring_nf\n  apply h (hc := z.denom_ne_zero A)\n\n"}
{"name":"EisensteinSeries.eisensteinSeries_slash_apply","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"N : Nat\na : Fin 2 → ZMod N\nk : Int\nγ : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (SlashAction.map Complex k γ (eisensteinSeries a k)) (eisensteinSeries (Matrix.vecMul a ↑((Matrix.SpecialLinearGroup.map (Int.castRingHom (ZMod N))) γ)) k)","decl":"lemma eisensteinSeries_slash_apply (k : ℤ) (γ : SL(2, ℤ)) :\n    eisensteinSeries a k ∣[k] γ = eisensteinSeries (a ᵥ* γ) k := by\n  ext1 z\n  simp_rw [SL_slash, slash_def, slash, ModularGroup.det_coe, ofReal_one, one_zpow, mul_one,\n    zpow_neg, mul_inv_eq_iff_eq_mul₀ (zpow_ne_zero _ <| z.denom_ne_zero _), mul_comm,\n    eisensteinSeries, ← ModularGroup.sl_moeb, eisSummand_SL2_apply, tsum_mul_left]\n  exact congr_arg (_ * ·) <| (gammaSetEquiv a γ).tsum_eq (eisSummand k · z)\n\n"}
{"name":"EisensteinSeries.eisensteinSeries_SIF_apply","module":"Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs","initialProofState":"N : Nat\na : Fin 2 → ZMod N\nk : Int\nz : UpperHalfPlane\n⊢ Eq ((EisensteinSeries.eisensteinSeries_SIF a k) z) (eisensteinSeries a k z)","decl":"lemma eisensteinSeries_SIF_apply (k : ℤ) (z : ℍ) :\n    eisensteinSeries_SIF a k z = eisensteinSeries a k z := rfl\n\n"}
