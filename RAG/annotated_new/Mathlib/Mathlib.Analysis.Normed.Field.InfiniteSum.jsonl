{"name":"Summable.mul_of_nonneg","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"Î¹ : Type u_2\nÎ¹' : Type u_3\nf : Î¹ â†’ Real\ng : Î¹' â†’ Real\nhf : Summable f\nhg : Summable g\nhf' : LE.le 0 f\nhg' : LE.le 0 g\nâŠ¢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem Summable.mul_of_nonneg {f : Î¹ â†’ â„} {g : Î¹' â†’ â„} (hf : Summable f) (hg : Summable g)\n    (hf' : 0 â‰¤ f) (hg' : 0 â‰¤ g) : Summable fun x : Î¹ Ã— Î¹' => f x.1 * g x.2 :=\n  (summable_prod_of_nonneg fun _ â†¦ mul_nonneg (hf' _) (hg' _)).2 âŸ¨fun x â†¦ hg.mul_left (f x),\n    by simpa only [hg.tsum_mul_left _] using hf.mul_right (âˆ‘' x, g x)âŸ©\n\n"}
{"name":"Summable.mul_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœ : NormedRing R\nf : Î¹ â†’ R\ng : Î¹' â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Summable fun x => Norm.norm (HMul.hMul (f x.1) (g x.2))","decl":"theorem Summable.mul_norm {f : Î¹ â†’ R} {g : Î¹' â†’ R} (hf : Summable fun x => â€–f xâ€–)\n    (hg : Summable fun x => â€–g xâ€–) : Summable fun x : Î¹ Ã— Î¹' => â€–f x.1 * g x.2â€– :=\n  .of_nonneg_of_le (fun _ â†¦ norm_nonneg _)\n    (fun x => norm_mul_le (f x.1) (g x.2))\n    (hf.mul_of_nonneg hg (fun x => norm_nonneg <| f x) fun x => norm_nonneg <| g x :)\n\n"}
{"name":"summable_mul_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf : Î¹ â†’ R\ng : Î¹' â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem summable_mul_of_summable_norm [CompleteSpace R] {f : Î¹ â†’ R} {g : Î¹' â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    Summable fun x : Î¹ Ã— Î¹' => f x.1 * g x.2 :=\n  (hf.mul_norm hg).of_norm\n\n"}
{"name":"summable_mul_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœ : NormedRing R\nf : Î¹ â†’ R\ng : Î¹' â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem summable_mul_of_summable_norm' {f : Î¹ â†’ R} {g : Î¹' â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    Summable fun x : Î¹ Ã— Î¹' => f x.1 * g x.2 := by\n  classical\n  suffices HasSum (fun x : Î¹ Ã— Î¹' => f x.1 * g x.2) ((âˆ‘' i, f i) * (âˆ‘' j, g j)) from this.summable\n  let s : Finset Î¹ Ã— Finset Î¹' â†’ Finset (Î¹ Ã— Î¹') := fun p â†¦ p.1 Ã—Ë¢ p.2\n  apply hasSum_of_subseq_of_summable (hf.mul_norm hg) tendsto_finset_prod_atTop\n  rw [â† prod_atTop_atTop_eq]\n  have := Tendsto.prod_map h'f.hasSum h'g.hasSum\n  rw [â† nhds_prod_eq] at this\n  convert ((continuous_mul (M := R)).continuousAt\n      (x := (âˆ‘' (i : Î¹), f i, âˆ‘' (j : Î¹'), g j))).tendsto.comp this with p\n  simp [s, sum_product, â† mul_sum, â† sum_mul]\n\n"}
{"name":"tsum_mul_tsum_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf : Î¹ â†’ R\ng : Î¹' â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Eq (HMul.hMul (tsum fun x => f x) (tsum fun y => g y)) (tsum fun z => HMul.hMul (f z.1) (g z.2))","decl":"/-- Product of two infinite sums indexed by arbitrary types.\n    See also `tsum_mul_tsum` if `f` and `g` are *not* absolutely summable, and\n    `tsum_mul_tsum_of_summable_norm'` when the space is not complete. -/\ntheorem tsum_mul_tsum_of_summable_norm [CompleteSpace R] {f : Î¹ â†’ R} {g : Î¹' â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    ((âˆ‘' x, f x) * âˆ‘' y, g y) = âˆ‘' z : Î¹ Ã— Î¹', f z.1 * g z.2 :=\n  tsum_mul_tsum hf.of_norm hg.of_norm (summable_mul_of_summable_norm hf hg)\n\n"}
{"name":"tsum_mul_tsum_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœ : NormedRing R\nf : Î¹ â†’ R\ng : Î¹' â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Eq (HMul.hMul (tsum fun x => f x) (tsum fun y => g y)) (tsum fun z => HMul.hMul (f z.1) (g z.2))","decl":"theorem tsum_mul_tsum_of_summable_norm' {f : Î¹ â†’ R} {g : Î¹' â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    ((âˆ‘' x, f x) * âˆ‘' y, g y) = âˆ‘' z : Î¹ Ã— Î¹', f z.1 * g z.2 :=\n  tsum_mul_tsum h'f h'g (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"summable_norm_sum_mul_antidiagonal_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Summable fun n => Norm.norm ((Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"theorem summable_norm_sum_mul_antidiagonal_of_summable_norm {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    Summable fun n => â€–âˆ‘ kl âˆˆ antidiagonal n, f kl.1 * g kl.2â€– := by\n  have :=\n    summable_sum_mul_antidiagonal_of_summable_mul\n      (Summable.mul_of_nonneg hf hg (fun _ => norm_nonneg _) fun _ => norm_nonneg _)\n  refine this.of_nonneg_of_le (fun _ => norm_nonneg _) (fun n â†¦ ?_)\n  calc\n    â€–âˆ‘ kl âˆˆ antidiagonal n, f kl.1 * g kl.2â€– â‰¤ âˆ‘ kl âˆˆ antidiagonal n, â€–f kl.1 * g kl.2â€– :=\n      norm_sum_le _ _\n    _ â‰¤ âˆ‘ kl âˆˆ antidiagonal n, â€–f kl.1â€– * â€–g kl.2â€– := by gcongr; apply norm_mul_le\n\n"}
{"name":"summable_sum_mul_antidiagonal_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Summable fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2)","decl":"theorem summable_sum_mul_antidiagonal_of_summable_norm' {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    Summable fun n => âˆ‘ kl âˆˆ antidiagonal n, f kl.1 * g kl.2 :=\n  summable_sum_mul_antidiagonal_of_summable_mul (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"/-- The Cauchy product formula for the product of two infinite sums indexed by `â„•`,\n    expressed by summing on `Finset.antidiagonal`.\n    See also `tsum_mul_tsum_eq_tsum_sum_antidiagonal` if `f` and `g` are\n    *not* absolutely summable, and `tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm'`\n    when the space is not complete. -/\ntheorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm [CompleteSpace R] {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    ((âˆ‘' n, f n) * âˆ‘' n, g n) = âˆ‘' n, âˆ‘ kl âˆˆ antidiagonal n, f kl.1 * g kl.2 :=\n  tsum_mul_tsum_eq_tsum_sum_antidiagonal hf.of_norm hg.of_norm (summable_mul_of_summable_norm hf hg)\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm' {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    ((âˆ‘' n, f n) * âˆ‘' n, g n) = âˆ‘' n, âˆ‘ kl âˆˆ antidiagonal n, f kl.1 * g kl.2 :=\n  tsum_mul_tsum_eq_tsum_sum_antidiagonal h'f h'g (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"summable_norm_sum_mul_range_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Summable fun n => Norm.norm ((Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"theorem summable_norm_sum_mul_range_of_summable_norm {f g : â„• â†’ R} (hf : Summable fun x => â€–f xâ€–)\n    (hg : Summable fun x => â€–g xâ€–) : Summable fun n => â€–âˆ‘ k âˆˆ range (n + 1), f k * g (n - k)â€– := by\n  simp_rw [â† sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact summable_norm_sum_mul_antidiagonal_of_summable_norm hf hg\n\n"}
{"name":"summable_sum_mul_range_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Summable fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))","decl":"theorem summable_sum_mul_range_of_summable_norm' {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    Summable fun n => âˆ‘ k âˆˆ range (n + 1), f k * g (n - k) := by\n  simp_rw [â† sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact summable_sum_mul_antidiagonal_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"/-- The Cauchy product formula for the product of two infinite sums indexed by `â„•`,\n    expressed by summing on `Finset.range`.\n    See also `tsum_mul_tsum_eq_tsum_sum_range` if `f` and `g` are\n    *not* absolutely summable, and `tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm'` when the\n    space is not complete. -/\ntheorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm [CompleteSpace R] {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    ((âˆ‘' n, f n) * âˆ‘' n, g n) = âˆ‘' n, âˆ‘ k âˆˆ range (n + 1), f k * g (n - k) := by\n  simp_rw [â† sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm hf hg\n\n"}
{"name":"hasSum_sum_range_mul_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\nâŠ¢ HasSum (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))) (HMul.hMul (tsum fun n => f n) (tsum fun n => g n))","decl":"theorem hasSum_sum_range_mul_of_summable_norm [CompleteSpace R] {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (hg : Summable fun x => â€–g xâ€–) :\n    HasSum (fun n â†¦ âˆ‘ k âˆˆ range (n + 1), f k * g (n - k)) ((âˆ‘' n, f n) * âˆ‘' n, g n) := by\n  convert (summable_norm_sum_mul_range_of_summable_norm hf hg).of_norm.hasSum\n  exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm hf hg\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"theorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    ((âˆ‘' n, f n) * âˆ‘' n, g n) = âˆ‘' n, âˆ‘ k âˆˆ range (n + 1), f k * g (n - k) := by\n  simp_rw [â† sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"hasSum_sum_range_mul_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninstâœ : NormedRing R\nf g : Nat â†’ R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\nâŠ¢ HasSum (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))) (HMul.hMul (tsum fun n => f n) (tsum fun n => g n))","decl":"theorem hasSum_sum_range_mul_of_summable_norm' {f g : â„• â†’ R}\n    (hf : Summable fun x => â€–f xâ€–) (h'f : Summable f)\n    (hg : Summable fun x => â€–g xâ€–) (h'g : Summable g) :\n    HasSum (fun n â†¦ âˆ‘ k âˆˆ range (n + 1), f k * g (n - k)) ((âˆ‘' n, f n) * âˆ‘' n, g n) := by\n  convert (summable_sum_mul_range_of_summable_norm' hf h'f hg h'g).hasSum\n  exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"summable_of_absolute_convergence_real","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"f : Nat â†’ Real\naâœ : Exists fun r => Filter.Tendsto (fun n => (Finset.range n).sum fun i => abs (f i)) Filter.atTop (nhds r)\nâŠ¢ Summable f","decl":"lemma summable_of_absolute_convergence_real {f : â„• â†’ â„} :\n    (âˆƒ r, Tendsto (fun n â†¦ âˆ‘ i âˆˆ range n, |f i|) atTop (ð“ r)) â†’ Summable f\n  | âŸ¨r, hrâŸ© => by\n    refine .of_norm âŸ¨r, (hasSum_iff_tendsto_nat_of_nonneg ?_ _).2 ?_âŸ©\n    Â· exact fun i â†¦ norm_nonneg _\n    Â· simpa only using hr\n"}
