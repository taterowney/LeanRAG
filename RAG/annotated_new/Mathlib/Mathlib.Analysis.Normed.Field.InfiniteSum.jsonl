{"name":"Summable.mul_of_nonneg","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"ι : Type u_2\nι' : Type u_3\nf : ι → Real\ng : ι' → Real\nhf : Summable f\nhg : Summable g\nhf' : LE.le 0 f\nhg' : LE.le 0 g\n⊢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem Summable.mul_of_nonneg {f : ι → ℝ} {g : ι' → ℝ} (hf : Summable f) (hg : Summable g)\n    (hf' : 0 ≤ f) (hg' : 0 ≤ g) : Summable fun x : ι × ι' => f x.1 * g x.2 :=\n  (summable_prod_of_nonneg fun _ ↦ mul_nonneg (hf' _) (hg' _)).2 ⟨fun x ↦ hg.mul_left (f x),\n    by simpa only [hg.tsum_mul_left _] using hf.mul_right (∑' x, g x)⟩\n\n"}
{"name":"Summable.mul_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : NormedRing R\nf : ι → R\ng : ι' → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Summable fun x => Norm.norm (HMul.hMul (f x.1) (g x.2))","decl":"theorem Summable.mul_norm {f : ι → R} {g : ι' → R} (hf : Summable fun x => ‖f x‖)\n    (hg : Summable fun x => ‖g x‖) : Summable fun x : ι × ι' => ‖f x.1 * g x.2‖ :=\n  .of_nonneg_of_le (fun _ ↦ norm_nonneg _)\n    (fun x => norm_mul_le (f x.1) (g x.2))\n    (hf.mul_of_nonneg hg (fun x => norm_nonneg <| f x) fun x => norm_nonneg <| g x :)\n\n"}
{"name":"summable_mul_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf : ι → R\ng : ι' → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem summable_mul_of_summable_norm [CompleteSpace R] {f : ι → R} {g : ι' → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    Summable fun x : ι × ι' => f x.1 * g x.2 :=\n  (hf.mul_norm hg).of_norm\n\n"}
{"name":"summable_mul_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : NormedRing R\nf : ι → R\ng : ι' → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Summable fun x => HMul.hMul (f x.1) (g x.2)","decl":"theorem summable_mul_of_summable_norm' {f : ι → R} {g : ι' → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    Summable fun x : ι × ι' => f x.1 * g x.2 := by\n  classical\n  suffices HasSum (fun x : ι × ι' => f x.1 * g x.2) ((∑' i, f i) * (∑' j, g j)) from this.summable\n  let s : Finset ι × Finset ι' → Finset (ι × ι') := fun p ↦ p.1 ×ˢ p.2\n  apply hasSum_of_subseq_of_summable (hf.mul_norm hg) tendsto_finset_prod_atTop\n  rw [← prod_atTop_atTop_eq]\n  have := Tendsto.prod_map h'f.hasSum h'g.hasSum\n  rw [← nhds_prod_eq] at this\n  convert ((continuous_mul (M := R)).continuousAt\n      (x := (∑' (i : ι), f i, ∑' (j : ι'), g j))).tendsto.comp this with p\n  simp [s, sum_product, ← mul_sum, ← sum_mul]\n\n"}
{"name":"tsum_mul_tsum_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf : ι → R\ng : ι' → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Eq (HMul.hMul (tsum fun x => f x) (tsum fun y => g y)) (tsum fun z => HMul.hMul (f z.1) (g z.2))","decl":"/-- Product of two infinite sums indexed by arbitrary types.\n    See also `tsum_mul_tsum` if `f` and `g` are *not* absolutely summable, and\n    `tsum_mul_tsum_of_summable_norm'` when the space is not complete. -/\ntheorem tsum_mul_tsum_of_summable_norm [CompleteSpace R] {f : ι → R} {g : ι' → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    ((∑' x, f x) * ∑' y, g y) = ∑' z : ι × ι', f z.1 * g z.2 :=\n  tsum_mul_tsum hf.of_norm hg.of_norm (summable_mul_of_summable_norm hf hg)\n\n"}
{"name":"tsum_mul_tsum_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : NormedRing R\nf : ι → R\ng : ι' → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Eq (HMul.hMul (tsum fun x => f x) (tsum fun y => g y)) (tsum fun z => HMul.hMul (f z.1) (g z.2))","decl":"theorem tsum_mul_tsum_of_summable_norm' {f : ι → R} {g : ι' → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    ((∑' x, f x) * ∑' y, g y) = ∑' z : ι × ι', f z.1 * g z.2 :=\n  tsum_mul_tsum h'f h'g (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"summable_norm_sum_mul_antidiagonal_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Summable fun n => Norm.norm ((Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"theorem summable_norm_sum_mul_antidiagonal_of_summable_norm {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    Summable fun n => ‖∑ kl ∈ antidiagonal n, f kl.1 * g kl.2‖ := by\n  have :=\n    summable_sum_mul_antidiagonal_of_summable_mul\n      (Summable.mul_of_nonneg hf hg (fun _ => norm_nonneg _) fun _ => norm_nonneg _)\n  refine this.of_nonneg_of_le (fun _ => norm_nonneg _) (fun n ↦ ?_)\n  calc\n    ‖∑ kl ∈ antidiagonal n, f kl.1 * g kl.2‖ ≤ ∑ kl ∈ antidiagonal n, ‖f kl.1 * g kl.2‖ :=\n      norm_sum_le _ _\n    _ ≤ ∑ kl ∈ antidiagonal n, ‖f kl.1‖ * ‖g kl.2‖ := by gcongr; apply norm_mul_le\n\n"}
{"name":"summable_sum_mul_antidiagonal_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Summable fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2)","decl":"theorem summable_sum_mul_antidiagonal_of_summable_norm' {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    Summable fun n => ∑ kl ∈ antidiagonal n, f kl.1 * g kl.2 :=\n  summable_sum_mul_antidiagonal_of_summable_mul (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"/-- The Cauchy product formula for the product of two infinite sums indexed by `ℕ`,\n    expressed by summing on `Finset.antidiagonal`.\n    See also `tsum_mul_tsum_eq_tsum_sum_antidiagonal` if `f` and `g` are\n    *not* absolutely summable, and `tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm'`\n    when the space is not complete. -/\ntheorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm [CompleteSpace R] {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    ((∑' n, f n) * ∑' n, g n) = ∑' n, ∑ kl ∈ antidiagonal n, f kl.1 * g kl.2 :=\n  tsum_mul_tsum_eq_tsum_sum_antidiagonal hf.of_norm hg.of_norm (summable_mul_of_summable_norm hf hg)\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.HasAntidiagonal.antidiagonal n).sum fun kl => HMul.hMul (f kl.1) (g kl.2))","decl":"theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm' {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    ((∑' n, f n) * ∑' n, g n) = ∑' n, ∑ kl ∈ antidiagonal n, f kl.1 * g kl.2 :=\n  tsum_mul_tsum_eq_tsum_sum_antidiagonal h'f h'g (summable_mul_of_summable_norm' hf h'f hg h'g)\n\n"}
{"name":"summable_norm_sum_mul_range_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Summable fun n => Norm.norm ((Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"theorem summable_norm_sum_mul_range_of_summable_norm {f g : ℕ → R} (hf : Summable fun x => ‖f x‖)\n    (hg : Summable fun x => ‖g x‖) : Summable fun n => ‖∑ k ∈ range (n + 1), f k * g (n - k)‖ := by\n  simp_rw [← sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact summable_norm_sum_mul_antidiagonal_of_summable_norm hf hg\n\n"}
{"name":"summable_sum_mul_range_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Summable fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))","decl":"theorem summable_sum_mul_range_of_summable_norm' {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    Summable fun n => ∑ k ∈ range (n + 1), f k * g (n - k) := by\n  simp_rw [← sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact summable_sum_mul_antidiagonal_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"/-- The Cauchy product formula for the product of two infinite sums indexed by `ℕ`,\n    expressed by summing on `Finset.range`.\n    See also `tsum_mul_tsum_eq_tsum_sum_range` if `f` and `g` are\n    *not* absolutely summable, and `tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm'` when the\n    space is not complete. -/\ntheorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm [CompleteSpace R] {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    ((∑' n, f n) * ∑' n, g n) = ∑' n, ∑ k ∈ range (n + 1), f k * g (n - k) := by\n  simp_rw [← sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm hf hg\n\n"}
{"name":"hasSum_sum_range_mul_of_summable_norm","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nhg : Summable fun x => Norm.norm (g x)\n⊢ HasSum (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))) (HMul.hMul (tsum fun n => f n) (tsum fun n => g n))","decl":"theorem hasSum_sum_range_mul_of_summable_norm [CompleteSpace R] {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :\n    HasSum (fun n ↦ ∑ k ∈ range (n + 1), f k * g (n - k)) ((∑' n, f n) * ∑' n, g n) := by\n  convert (summable_norm_sum_mul_range_of_summable_norm hf hg).of_norm.hasSum\n  exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm hf hg\n\n"}
{"name":"tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ Eq (HMul.hMul (tsum fun n => f n) (tsum fun n => g n)) (tsum fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k)))","decl":"theorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    ((∑' n, f n) * ∑' n, g n) = ∑' n, ∑ k ∈ range (n + 1), f k * g (n - k) := by\n  simp_rw [← sum_antidiagonal_eq_sum_range_succ fun k l => f k * g l]\n  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"hasSum_sum_range_mul_of_summable_norm'","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"R : Type u_1\ninst✝ : NormedRing R\nf g : Nat → R\nhf : Summable fun x => Norm.norm (f x)\nh'f : Summable f\nhg : Summable fun x => Norm.norm (g x)\nh'g : Summable g\n⊢ HasSum (fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (f k) (g (HSub.hSub n k))) (HMul.hMul (tsum fun n => f n) (tsum fun n => g n))","decl":"theorem hasSum_sum_range_mul_of_summable_norm' {f g : ℕ → R}\n    (hf : Summable fun x => ‖f x‖) (h'f : Summable f)\n    (hg : Summable fun x => ‖g x‖) (h'g : Summable g) :\n    HasSum (fun n ↦ ∑ k ∈ range (n + 1), f k * g (n - k)) ((∑' n, f n) * ∑' n, g n) := by\n  convert (summable_sum_mul_range_of_summable_norm' hf h'f hg h'g).hasSum\n  exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' hf h'f hg h'g\n\n"}
{"name":"summable_of_absolute_convergence_real","module":"Mathlib.Analysis.Normed.Field.InfiniteSum","initialProofState":"f : Nat → Real\na✝ : Exists fun r => Filter.Tendsto (fun n => (Finset.range n).sum fun i => abs (f i)) Filter.atTop (nhds r)\n⊢ Summable f","decl":"lemma summable_of_absolute_convergence_real {f : ℕ → ℝ} :\n    (∃ r, Tendsto (fun n ↦ ∑ i ∈ range n, |f i|) atTop (𝓝 r)) → Summable f\n  | ⟨r, hr⟩ => by\n    refine .of_norm ⟨r, (hasSum_iff_tendsto_nat_of_nonneg ?_ _).2 ?_⟩\n    · exact fun i ↦ norm_nonneg _\n    · simpa only using hr\n"}
