{"name":"CategoryTheory.Functor.WellOrderInductionData.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝¹ : LinearOrder J\ninst✝ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nsucc✝ : (j : J) → Not (IsMax j) → F.obj { unop := j } → F.obj { unop := Order.succ j }\nmap_succ✝ : ∀ (j : J) (hj : Not (IsMax j)) (x : F.obj { unop := j }), Eq (F.map (CategoryTheory.homOfLE ⋯).op (succ✝ j hj x)) x\nlift✝ : (j : J) → Order.IsSuccLimit j → ↑(⋯.functor.op.comp F).sections → F.obj { unop := j }\nmap_lift✝ : ∀ (j : J) (hj : Order.IsSuccLimit j) (x : ↑(⋯.functor.op.comp F).sections) (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op (lift✝ j hj x)) (↑x { unop := ⟨i, hi⟩ })\nsucc : (j : J) → Not (IsMax j) → F.obj { unop := j } → F.obj { unop := Order.succ j }\nmap_succ : ∀ (j : J) (hj : Not (IsMax j)) (x : F.obj { unop := j }), Eq (F.map (CategoryTheory.homOfLE ⋯).op (succ j hj x)) x\nlift : (j : J) → Order.IsSuccLimit j → ↑(⋯.functor.op.comp F).sections → F.obj { unop := j }\nmap_lift : ∀ (j : J) (hj : Order.IsSuccLimit j) (x : ↑(⋯.functor.op.comp F).sections) (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op (lift j hj x)) (↑x { unop := ⟨i, hi⟩ })\n⊢ Eq (Eq { succ := succ✝, map_succ := map_succ✝, lift := lift✝, map_lift := map_lift✝ } { succ := succ, map_succ := map_succ, lift := lift, map_lift := map_lift }) (And (Eq succ✝ succ) (Eq lift✝ lift))","decl":"/-- Given a functor `F : Jᵒᵖ ⥤ Type v` where `J` is a well-ordered type, this data\nallows to construct a section of `F` from an element in `F.obj (op ⊥)`,\nsee `WellOrderInductionData.sectionsMk`. -/\nstructure WellOrderInductionData where\n  /-- A section `F.obj (op j) → F.obj (op (Order.succ j))` to the restriction\n  `F.obj (op (Order.succ j)) → F.obj (op j)` when `j` is not maximal. -/\n  succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) : F.obj (op (Order.succ j))\n  map_succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) :\n      F.map (homOfLE (Order.le_succ j)).op (succ j hj x) = x\n  /-- When `j` is a limit element, and `x` is a compatible family of elements\n  in `F.obj (op i)` for all `i < j`, this is a lifting to `F.obj (op j)`. -/\n  lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections) :\n      F.obj (op j)\n  map_lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections)\n    (i : J) (hi : i < j) :\n        F.map (homOfLE hi.le).op (lift j hj x) = x.val (op ⟨i, hi⟩)\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.map_lift","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝¹ : LinearOrder J\ninst✝ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nself : F.WellOrderInductionData\nj : J\nhj : Order.IsSuccLimit j\nx : ↑(⋯.functor.op.comp F).sections\ni : J\nhi : LT.lt i j\n⊢ Eq (F.map (CategoryTheory.homOfLE ⋯).op (self.lift j hj x)) (↑x { unop := ⟨i, hi⟩ })","decl":"/-- Given a functor `F : Jᵒᵖ ⥤ Type v` where `J` is a well-ordered type, this data\nallows to construct a section of `F` from an element in `F.obj (op ⊥)`,\nsee `WellOrderInductionData.sectionsMk`. -/\nstructure WellOrderInductionData where\n  /-- A section `F.obj (op j) → F.obj (op (Order.succ j))` to the restriction\n  `F.obj (op (Order.succ j)) → F.obj (op j)` when `j` is not maximal. -/\n  succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) : F.obj (op (Order.succ j))\n  map_succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) :\n      F.map (homOfLE (Order.le_succ j)).op (succ j hj x) = x\n  /-- When `j` is a limit element, and `x` is a compatible family of elements\n  in `F.obj (op i)` for all `i < j`, this is a lifting to `F.obj (op j)`. -/\n  lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections) :\n      F.obj (op j)\n  map_lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections)\n    (i : J) (hi : i < j) :\n        F.map (homOfLE hi.le).op (lift j hj x) = x.val (op ⟨i, hi⟩)\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.map_succ","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝¹ : LinearOrder J\ninst✝ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nself : F.WellOrderInductionData\nj : J\nhj : Not (IsMax j)\nx : F.obj { unop := j }\n⊢ Eq (F.map (CategoryTheory.homOfLE ⋯).op (self.succ j hj x)) x","decl":"/-- Given a functor `F : Jᵒᵖ ⥤ Type v` where `J` is a well-ordered type, this data\nallows to construct a section of `F` from an element in `F.obj (op ⊥)`,\nsee `WellOrderInductionData.sectionsMk`. -/\nstructure WellOrderInductionData where\n  /-- A section `F.obj (op j) → F.obj (op (Order.succ j))` to the restriction\n  `F.obj (op (Order.succ j)) → F.obj (op j)` when `j` is not maximal. -/\n  succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) : F.obj (op (Order.succ j))\n  map_succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) :\n      F.map (homOfLE (Order.le_succ j)).op (succ j hj x) = x\n  /-- When `j` is a limit element, and `x` is a compatible family of elements\n  in `F.obj (op i)` for all `i < j`, this is a lifting to `F.obj (op j)`. -/\n  lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections) :\n      F.obj (op j)\n  map_lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections)\n    (i : J) (hi : i < j) :\n        F.map (homOfLE hi.le).op (lift j hj x) = x.val (op ⟨i, hi⟩)\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\ninst✝ : SizeOf J\nsucc : (j : J) → Not (IsMax j) → F.obj { unop := j } → F.obj { unop := Order.succ j }\nmap_succ : ∀ (j : J) (hj : Not (IsMax j)) (x : F.obj { unop := j }), Eq (F.map (CategoryTheory.homOfLE ⋯).op (succ j hj x)) x\nlift : (j : J) → Order.IsSuccLimit j → ↑(⋯.functor.op.comp F).sections → F.obj { unop := j }\nmap_lift : ∀ (j : J) (hj : Order.IsSuccLimit j) (x : ↑(⋯.functor.op.comp F).sections) (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op (lift j hj x)) (↑x { unop := ⟨i, hi⟩ })\n⊢ Eq (SizeOf.sizeOf { succ := succ, map_succ := map_succ, lift := lift, map_lift := map_lift }) 1","decl":"/-- Given a functor `F : Jᵒᵖ ⥤ Type v` where `J` is a well-ordered type, this data\nallows to construct a section of `F` from an element in `F.obj (op ⊥)`,\nsee `WellOrderInductionData.sectionsMk`. -/\nstructure WellOrderInductionData where\n  /-- A section `F.obj (op j) → F.obj (op (Order.succ j))` to the restriction\n  `F.obj (op (Order.succ j)) → F.obj (op j)` when `j` is not maximal. -/\n  succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) : F.obj (op (Order.succ j))\n  map_succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) :\n      F.map (homOfLE (Order.le_succ j)).op (succ j hj x) = x\n  /-- When `j` is a limit element, and `x` is a compatible family of elements\n  in `F.obj (op i)` for all `i < j`, this is a lifting to `F.obj (op j)`. -/\n  lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections) :\n      F.obj (op j)\n  map_lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections)\n    (i : J) (hi : i < j) :\n        F.map (homOfLE hi.le).op (lift j hj x) = x.val (op ⟨i, hi⟩)\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝¹ : LinearOrder J\ninst✝ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nsucc✝ : (j : J) → Not (IsMax j) → F.obj { unop := j } → F.obj { unop := Order.succ j }\nmap_succ✝ : ∀ (j : J) (hj : Not (IsMax j)) (x : F.obj { unop := j }), Eq (F.map (CategoryTheory.homOfLE ⋯).op (succ✝ j hj x)) x\nlift✝ : (j : J) → Order.IsSuccLimit j → ↑(⋯.functor.op.comp F).sections → F.obj { unop := j }\nmap_lift✝ : ∀ (j : J) (hj : Order.IsSuccLimit j) (x : ↑(⋯.functor.op.comp F).sections) (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op (lift✝ j hj x)) (↑x { unop := ⟨i, hi⟩ })\nsucc : (j : J) → Not (IsMax j) → F.obj { unop := j } → F.obj { unop := Order.succ j }\nmap_succ : ∀ (j : J) (hj : Not (IsMax j)) (x : F.obj { unop := j }), Eq (F.map (CategoryTheory.homOfLE ⋯).op (succ j hj x)) x\nlift : (j : J) → Order.IsSuccLimit j → ↑(⋯.functor.op.comp F).sections → F.obj { unop := j }\nmap_lift : ∀ (j : J) (hj : Order.IsSuccLimit j) (x : ↑(⋯.functor.op.comp F).sections) (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op (lift j hj x)) (↑x { unop := ⟨i, hi⟩ })\nx✝ : Eq { succ := succ✝, map_succ := map_succ✝, lift := lift✝, map_lift := map_lift✝ } { succ := succ, map_succ := map_succ, lift := lift, map_lift := map_lift }\n⊢ And (Eq succ✝ succ) (Eq lift✝ lift)","decl":"/-- Given a functor `F : Jᵒᵖ ⥤ Type v` where `J` is a well-ordered type, this data\nallows to construct a section of `F` from an element in `F.obj (op ⊥)`,\nsee `WellOrderInductionData.sectionsMk`. -/\nstructure WellOrderInductionData where\n  /-- A section `F.obj (op j) → F.obj (op (Order.succ j))` to the restriction\n  `F.obj (op (Order.succ j)) → F.obj (op j)` when `j` is not maximal. -/\n  succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) : F.obj (op (Order.succ j))\n  map_succ (j : J) (hj : ¬IsMax j) (x : F.obj (op j)) :\n      F.map (homOfLE (Order.le_succ j)).op (succ j hj x) = x\n  /-- When `j` is a limit element, and `x` is a compatible family of elements\n  in `F.obj (op i)` for all `i < j`, this is a lifting to `F.obj (op j)`. -/\n  lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections) :\n      F.obj (op j)\n  map_lift (j : J) (hj : Order.IsSuccLimit j)\n    (x : ((OrderHom.Subtype.val (· ∈ Set.Iio j)).monotone.functor.op ⋙ F).sections)\n    (i : J) (hi : i < j) :\n        F.map (homOfLE hi.le).op (lift j hj x) = x.val (op ⟨i, hi⟩)\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\nval✝ : F.obj { unop := j }\nmap_zero✝ : Eq (F.map (CategoryTheory.homOfLE ⋯).op val✝) val₀\nmap_succ✝ : ∀ (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op val✝) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op val✝))\nmap_limit✝ : ∀ (i : J) (hi : Order.IsSuccLimit i) (hij : LE.le i j), Eq (F.map (CategoryTheory.homOfLE hij).op val✝) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op val✝, ⋯⟩)\nval : F.obj { unop := j }\nmap_zero : Eq (F.map (CategoryTheory.homOfLE ⋯).op val) val₀\nmap_succ : ∀ (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op val) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op val))\nmap_limit : ∀ (i : J) (hi : Order.IsSuccLimit i) (hij : LE.le i j), Eq (F.map (CategoryTheory.homOfLE hij).op val) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op val, ⋯⟩)\nx✝ : Eq { val := val✝, map_zero := map_zero✝, map_succ := map_succ✝, map_limit := map_limit✝ } { val := val, map_zero := map_zero, map_succ := map_succ, map_limit := map_limit }\n⊢ Eq val✝ val","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝¹ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\ninst✝ : SizeOf J\nval : F.obj { unop := j }\nmap_zero : Eq (F.map (CategoryTheory.homOfLE ⋯).op val) val₀\nmap_succ : ∀ (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op val) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op val))\nmap_limit : ∀ (i : J) (hi : Order.IsSuccLimit i) (hij : LE.le i j), Eq (F.map (CategoryTheory.homOfLE hij).op val) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op val, ⋯⟩)\n⊢ Eq (SizeOf.sizeOf { val := val, map_zero := map_zero, map_succ := map_succ, map_limit := map_limit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf map_zero))","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\nval✝ : F.obj { unop := j }\nmap_zero✝ : Eq (F.map (CategoryTheory.homOfLE ⋯).op val✝) val₀\nmap_succ✝ : ∀ (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op val✝) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op val✝))\nmap_limit✝ : ∀ (i : J) (hi : Order.IsSuccLimit i) (hij : LE.le i j), Eq (F.map (CategoryTheory.homOfLE hij).op val✝) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op val✝, ⋯⟩)\nval : F.obj { unop := j }\nmap_zero : Eq (F.map (CategoryTheory.homOfLE ⋯).op val) val₀\nmap_succ : ∀ (i : J) (hi : LT.lt i j), Eq (F.map (CategoryTheory.homOfLE ⋯).op val) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op val))\nmap_limit : ∀ (i : J) (hi : Order.IsSuccLimit i) (hij : LE.le i j), Eq (F.map (CategoryTheory.homOfLE hij).op val) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op val, ⋯⟩)\n⊢ Eq (Eq { val := val✝, map_zero := map_zero✝, map_succ := map_succ✝, map_limit := map_limit✝ } { val := val, map_zero := map_zero, map_succ := map_succ, map_limit := map_limit }) (Eq val✝ val)","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.map_limit","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\nself : d.Extension val₀ j\ni : J\nhi : Order.IsSuccLimit i\nhij : LE.le i j\n⊢ Eq (F.map (CategoryTheory.homOfLE hij).op self.val) (d.lift i hi ⟨fun x => CategoryTheory.Functor.WellOrderInductionData.Extension.match_1 i (fun x => (⋯.functor.op.comp F).obj x) x fun k hk => F.map (CategoryTheory.homOfLE ⋯).op self.val, ⋯⟩)","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.map_succ","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\nself : d.Extension val₀ j\ni : J\nhi : LT.lt i j\n⊢ Eq (F.map (CategoryTheory.homOfLE ⋯).op self.val) (d.succ i ⋯ (F.map (CategoryTheory.homOfLE ⋯).op self.val))","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.map_zero","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\nself : d.Extension val₀ j\n⊢ Eq (F.map (CategoryTheory.homOfLE ⋯).op self.val) val₀","decl":"/-- Given `d : F.WellOrderInductionData`, `val₀ : F.obj (op ⊥)` and `j : J`,\nthis is the data of an element `val : F.obj (op j)` such that the induced\ncompatible family of elements in all `F.obj (op i)` for `i ≤ j`\nis determined by `val₀` and the choice of \"liftings\" given by `d`. -/\nstructure Extension (val₀ : F.obj (op ⊥)) (j : J) where\n  /-- An element in `F.obj (op j)`, which, by restriction, induces elements\n  in `F.obj (op i)` for all `i ≤ j`. -/\n  val : F.obj (op j)\n  map_zero : F.map (homOfLE bot_le).op val = val₀\n  map_succ (i : J) (hi : i < j) :\n    F.map (homOfLE (Order.succ_le_of_lt hi)).op val =\n      d.succ i (not_isMax_iff.2 ⟨_, hi⟩) (F.map (homOfLE hi.le).op val)\n  map_limit (i : J) (hi : Order.IsSuccLimit i) (hij : i ≤ j) :\n    F.map (homOfLE hij).op val = d.lift i hi\n      { val := fun ⟨⟨k, hk⟩⟩ ↦ F.map (homOfLE (hk.le.trans hij)).op val\n        property := fun f ↦ by\n          dsimp\n          rw [← FunctorToTypes.map_comp_apply]\n          rfl }\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.ofLE_val","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\ne : d.Extension val₀ j\ni : J\nhij : LE.le i j\n⊢ Eq (e.ofLE hij).val (F.map (CategoryTheory.homOfLE hij).op e.val)","decl":"/-- An element in `d.Extension val₀ j` induces an element in `d.Extension val₀ i` when `i ≤ j`. -/\n@[simps]\ndef ofLE {j : J} (e : d.Extension val₀ j) {i : J} (hij : i ≤ j) : d.Extension val₀ i where\n  val := F.map (homOfLE hij).op e.val\n  map_zero := by\n    rw [← FunctorToTypes.map_comp_apply]\n    exact e.map_zero\n  map_succ k hk := by\n    rw [← FunctorToTypes.map_comp_apply, ← FunctorToTypes.map_comp_apply, ← op_comp, ← op_comp,\n      homOfLE_comp, homOfLE_comp, e.map_succ k (lt_of_lt_of_le hk hij)]\n  map_limit k hk hki := by\n    rw [← FunctorToTypes.map_comp_apply, ← op_comp, homOfLE_comp,\n      e.map_limit k hk (hki.trans hij)]\n    congr\n    ext ⟨l, hl⟩\n    dsimp\n    rw [← FunctorToTypes.map_comp_apply]\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.val_injective","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\ne e' : d.Extension val₀ j\nh : Eq e.val e'.val\n⊢ Eq e e'","decl":"lemma val_injective {j : J} {e e' : d.Extension val₀ j} (h : e.val = e'.val) : e = e' := by\n  cases e\n  cases e'\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.instSubsingletonOfWellFoundedLT","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝¹ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\ninst✝ : WellFoundedLT J\nj : J\n⊢ Subsingleton (d.Extension val₀ j)","decl":"instance [WellFoundedLT J] (j : J) : Subsingleton (d.Extension val₀ j) := by\n  induction j using SuccOrder.limitRecOn with\n  | hm i hi =>\n      obtain rfl : i = ⊥ := by simpa using hi\n      refine Subsingleton.intro (fun e₁ e₂ ↦ val_injective ?_)\n      have h₁ := e₁.map_zero\n      have h₂ := e₂.map_zero\n      simp only [homOfLE_refl, op_id, FunctorToTypes.map_id_apply] at h₁ h₂\n      rw [h₁, h₂]\n  | hs i hi hi' =>\n      refine Subsingleton.intro (fun e₁ e₂ ↦ val_injective ?_)\n      have h₁ := e₁.map_succ i (Order.lt_succ_of_not_isMax hi)\n      have h₂ := e₂.map_succ i (Order.lt_succ_of_not_isMax hi)\n      simp only [homOfLE_refl, op_id, FunctorToTypes.map_id_apply, homOfLE_leOfHom] at h₁ h₂\n      rw [h₁, h₂]\n      congr\n      exact congr_arg val\n        (Subsingleton.elim (e₁.ofLE (Order.le_succ i)) (e₂.ofLE (Order.le_succ i)))\n  | hl i hi hi' =>\n      refine Subsingleton.intro (fun e₁ e₂ ↦ val_injective ?_)\n      have h₁ := e₁.map_limit i hi (by rfl)\n      have h₂ := e₂.map_limit i hi (by rfl)\n      simp only [homOfLE_refl, op_id, FunctorToTypes.map_id_apply, OrderHom.Subtype.val_coe,\n        comp_obj, op_obj, Monotone.functor_obj, homOfLE_leOfHom] at h₁ h₂\n      rw [h₁, h₂]\n      congr\n      ext ⟨⟨l, hl⟩⟩\n      have := hi' l hl\n      exact congr_arg val (Subsingleton.elim (e₁.ofLE hl.le) (e₂.ofLE hl.le))\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.compatibility","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝¹ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\ninst✝ : WellFoundedLT J\nj : J\ne : d.Extension val₀ j\ni : J\ne' : d.Extension val₀ i\nh : LE.le i j\n⊢ Eq (F.map (CategoryTheory.homOfLE h).op e.val) e'.val","decl":"lemma compatibility [WellFoundedLT J]\n    {j : J} (e : d.Extension val₀ j) {i : J} (e' : d.Extension val₀ i) (h : i ≤ j) :\n    F.map (homOfLE h).op e.val = e'.val := by\n  obtain rfl : e' = e.ofLE h := Subsingleton.elim _ _\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.zero_val","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\n⊢ Eq (CategoryTheory.Functor.WellOrderInductionData.Extension.zero d val₀).val val₀","decl":"variable (d val₀) in\n/-- The obvious element in `d.Extension val₀ ⊥`. -/\n@[simps]\ndef zero : d.Extension val₀ ⊥ where\n  val := val₀\n  map_zero := by simp\n  map_succ i hi := by simp at hi\n  map_limit i hi hij := by\n    obtain rfl : i = ⊥ := by simpa using hij\n    simpa using hi.not_isMin\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.Extension.instNonempty","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝² : LinearOrder J\ninst✝¹ : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝ : OrderBot J\nval₀ : F.obj { unop := Bot.bot }\nj : J\n⊢ Nonempty (d.Extension val₀ j)","decl":"instance (j : J) : Nonempty (d.Extension val₀ j) := by\n  induction j using SuccOrder.limitRecOn with\n  | hm i hi =>\n      obtain rfl : i = ⊥ := by simpa using hi\n      exact ⟨zero d val₀⟩\n  | hs i hi hi' => exact ⟨hi'.some.succ hi⟩\n  | hl i hi hi' => exact ⟨limit i hi (fun l hl ↦ (hi' l hl).some)⟩\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.sectionsMk_val_op_bot","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝¹ : OrderBot J\ninst✝ : WellFoundedLT J\nval₀ : F.obj { unop := Bot.bot }\n⊢ Eq (↑(d.sectionsMk val₀) { unop := Bot.bot }) val₀","decl":"lemma sectionsMk_val_op_bot (val₀ : F.obj (op ⊥)) :\n    (d.sectionsMk val₀).val (op ⊥) = val₀ := by\n  simpa using (default : d.Extension val₀ ⊥).map_zero\n\n"}
{"name":"CategoryTheory.Functor.WellOrderInductionData.surjective","module":"Mathlib.CategoryTheory.SmallObject.WellOrderInductionData","initialProofState":"J : Type u\ninst✝³ : LinearOrder J\ninst✝² : SuccOrder J\nF : CategoryTheory.Functor (Opposite J) (Type v)\nd : F.WellOrderInductionData\ninst✝¹ : OrderBot J\ninst✝ : WellFoundedLT J\n⊢ Function.Surjective (Function.comp (fun s => s { unop := Bot.bot }) Subtype.val)","decl":"include d in\nlemma surjective :\n    Function.Surjective ((fun s ↦ s (op ⊥)) ∘ Subtype.val : F.sections → F.obj (op ⊥)) :=\n  fun val₀ ↦ ⟨d.sectionsMk val₀, d.sectionsMk_val_op_bot val₀⟩\n\n"}
