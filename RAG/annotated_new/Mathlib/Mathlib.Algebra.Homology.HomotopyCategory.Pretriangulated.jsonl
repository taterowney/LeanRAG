{"name":"CochainComplex.mappingCone.triangle_mor‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÅ œÜ","decl":"/-- The standard triangle `K ‚ü∂ L ‚ü∂ mappingCone œÜ ‚ü∂ K‚ü¶(1 : ‚Ñ§)‚üß` in `CochainComplex C ‚Ñ§`\nattached to a morphism `œÜ : K ‚ü∂ L`. It involves `œÜ`, `inr œÜ : L ‚ü∂ mappingCone œÜ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst œÜ`. -/\n@[simps! obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ mor‚ÇÅ mor‚ÇÇ]\nnoncomputable def triangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk œÜ (inr œÜ) (Cocycle.homOf ((-fst œÜ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÉ (CochainComplex.mappingCone œÜ)","decl":"/-- The standard triangle `K ‚ü∂ L ‚ü∂ mappingCone œÜ ‚ü∂ K‚ü¶(1 : ‚Ñ§)‚üß` in `CochainComplex C ‚Ñ§`\nattached to a morphism `œÜ : K ‚ü∂ L`. It involves `œÜ`, `inr œÜ : L ‚ü∂ mappingCone œÜ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst œÜ`. -/\n@[simps! obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ mor‚ÇÅ mor‚ÇÇ]\nnoncomputable def triangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk œÜ (inr œÜ) (Cocycle.homOf ((-fst œÜ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_mor‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÇ (CochainComplex.mappingCone.inr œÜ)","decl":"/-- The standard triangle `K ‚ü∂ L ‚ü∂ mappingCone œÜ ‚ü∂ K‚ü¶(1 : ‚Ñ§)‚üß` in `CochainComplex C ‚Ñ§`\nattached to a morphism `œÜ : K ‚ü∂ L`. It involves `œÜ`, `inr œÜ : L ‚ü∂ mappingCone œÜ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst œÜ`. -/\n@[simps! obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ mor‚ÇÅ mor‚ÇÇ]\nnoncomputable def triangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk œÜ (inr œÜ) (Cocycle.homOf ((-fst œÜ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÇ L","decl":"/-- The standard triangle `K ‚ü∂ L ‚ü∂ mappingCone œÜ ‚ü∂ K‚ü¶(1 : ‚Ñ§)‚üß` in `CochainComplex C ‚Ñ§`\nattached to a morphism `œÜ : K ‚ü∂ L`. It involves `œÜ`, `inr œÜ : L ‚ü∂ mappingCone œÜ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst œÜ`. -/\n@[simps! obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ mor‚ÇÅ mor‚ÇÇ]\nnoncomputable def triangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk œÜ (inr œÜ) (Cocycle.homOf ((-fst œÜ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÅ K","decl":"/-- The standard triangle `K ‚ü∂ L ‚ü∂ mappingCone œÜ ‚ü∂ K‚ü¶(1 : ‚Ñ§)‚üß` in `CochainComplex C ‚Ñ§`\nattached to a morphism `œÜ : K ‚ü∂ L`. It involves `œÜ`, `inr œÜ : L ‚ü∂ mappingCone œÜ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst œÜ`. -/\n@[simps! obj‚ÇÅ obj‚ÇÇ obj‚ÇÉ mor‚ÇÅ mor‚ÇÇ]\nnoncomputable def triangle : Triangle (CochainComplex C ‚Ñ§) :=\n  Triangle.mk œÜ (inr œÜ) (Cocycle.homOf ((-fst œÜ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_triangle_mor‚ÇÉ_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÅ).X q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl œÜ).v p q hpq) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ.f q) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (K.shiftFunctorObjXIso 1 q p ‚ãØ).inv) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_triangle_mor‚ÇÉ_f (p q : ‚Ñ§) (hpq : p + (-1) = q) :\n    (inl œÜ).v p q hpq ‚â´ (triangle œÜ).mor‚ÇÉ.f q =\n      -(K.shiftFunctorObjXIso 1 q p (by rw [‚Üê hpq, neg_add_cancel_right])).inv := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega)]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega), shiftFunctor_obj_X,\n    shiftFunctorObjXIso, Preadditive.comp_neg, inl_v_fst_v_assoc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_triangle_mor‚ÇÉ_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl œÜ).v p q hpq) ((CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ.f q)) (Neg.neg (K.shiftFunctorObjXIso 1 q p ‚ãØ).inv)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_triangle_mor‚ÇÉ_f (p q : ‚Ñ§) (hpq : p + (-1) = q) :\n    (inl œÜ).v p q hpq ‚â´ (triangle œÜ).mor‚ÇÉ.f q =\n      -(K.shiftFunctorObjXIso 1 q p (by rw [‚Üê hpq, neg_add_cancel_right])).inv := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega)]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega), shiftFunctor_obj_X,\n    shiftFunctorObjXIso, Preadditive.comp_neg, inl_v_fst_v_assoc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_triangle_mor‚ÇÉ_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\np : Int\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr œÜ).f p) ((CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ.f p)) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_f_triangle_mor‚ÇÉ_f (p : ‚Ñ§) : (inr œÜ).f p ‚â´ (triangle œÜ).mor‚ÇÉ.f p = 0 := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p+1) rfl]\n  simp only [Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p + 1) rfl, shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id,\n    Preadditive.comp_neg, inr_f_fst_v, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_triangle_mor‚ÇÉ_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\np : Int\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÅ).X p) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr œÜ).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ.f p) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_triangle_mor‚ÇÉ_f (p : ‚Ñ§) : (inr œÜ).f p ‚â´ (triangle œÜ).mor‚ÇÉ.f p = 0 := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p+1) rfl]\n  simp only [Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p + 1) rfl, shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id,\n    Preadditive.comp_neg, inr_f_fst_v, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.inr_triangleŒ¥_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\nZ : CochainComplex C Int\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle œÜ).obj‚ÇÅ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr œÜ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_triangleŒ¥ : inr œÜ ‚â´ (triangle œÜ).mor‚ÇÉ = 0 := by ext; dsimp; simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_triangleŒ¥","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr œÜ) (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_triangleŒ¥ : inr œÜ ‚â´ (triangle œÜ).mor‚ÇÉ = 0 := by ext; dsimp; simp\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm‚ÇÇ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\nZ : CochainComplex C Int\nh : Quiver.Hom (CochainComplex.mappingCone œÜ‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr œÜ‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) h)) (CategoryTheory.CategoryStruct.comp b (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr œÜ‚ÇÇ) h))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm‚ÇÇ :\n    inr œÜ‚ÇÅ ‚â´ mapOfHomotopy H = b ‚â´ inr œÜ‚ÇÇ := by\n  simp [mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr œÜ‚ÇÅ) (CochainComplex.mappingCone.mapOfHomotopy H)) (CategoryTheory.CategoryStruct.comp b (CochainComplex.mappingCone.inr œÜ‚ÇÇ))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm‚ÇÇ :\n    inr œÜ‚ÇÅ ‚â´ mapOfHomotopy H = b ‚â´ inr œÜ‚ÇÇ := by\n  simp [mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) (CochainComplex.mappingCone.triangle œÜ‚ÇÇ).mor‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle œÜ‚ÇÅ).mor‚ÇÉ ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map a))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm‚ÇÉ :\n    mapOfHomotopy H ‚â´ (triangle œÜ‚ÇÇ).mor‚ÇÉ = (triangle œÜ‚ÇÅ).mor‚ÇÉ ‚â´ a‚ü¶1‚üß' := by\n  ext p\n  dsimp [mapOfHomotopy, triangle]\n  -- the following list of lemmas as been obtained by doing\n  -- simp? [ext_from_iff _ _ _ rfl, Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl, shiftFunctor_obj_X, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Preadditive.comp_neg,\n    Preadditive.neg_comp, ext_from_iff _ _ _ rfl, inl_v_desc_f_assoc, Cochain.add_v,\n    Cochain.zero_cochain_comp_v, Cochain.ofHom_v, Cochain.comp_zero_cochain_v, Preadditive.add_comp,\n    assoc, inl_v_fst_v, inr_f_fst_v, comp_zero, add_zero, inl_v_fst_v_assoc, inr_f_desc_f_assoc,\n    HomologicalComplex.comp_f, neg_zero, inr_f_fst_v_assoc, zero_comp, and_self]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm‚ÇÉ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle œÜ‚ÇÇ).obj‚ÇÅ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle œÜ‚ÇÇ).mor‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle œÜ‚ÇÅ).mor‚ÇÉ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map a) h))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm‚ÇÉ :\n    mapOfHomotopy H ‚â´ (triangle œÜ‚ÇÇ).mor‚ÇÉ = (triangle œÜ‚ÇÅ).mor‚ÇÉ ‚â´ a‚ü¶1‚üß' := by\n  ext p\n  dsimp [mapOfHomotopy, triangle]\n  -- the following list of lemmas as been obtained by doing\n  -- simp? [ext_from_iff _ _ _ rfl, Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl, shiftFunctor_obj_X, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Preadditive.comp_neg,\n    Preadditive.neg_comp, ext_from_iff _ _ _ rfl, inl_v_desc_f_assoc, Cochain.add_v,\n    Cochain.zero_cochain_comp_v, Cochain.ofHom_v, Cochain.comp_zero_cochain_v, Preadditive.add_comp,\n    assoc, inl_v_fst_v, inr_f_fst_v, comp_zero, add_zero, inl_v_fst_v_assoc, inr_f_desc_f_assoc,\n    HomologicalComplex.comp_f, neg_zero, inr_f_fst_v_assoc, zero_comp, and_self]\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom‚ÇÅ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map a)","decl":"/-- The morphism `triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ where\n  hom‚ÇÅ := (HomotopyCategory.quotient _ _).map a\n  hom‚ÇÇ := (HomotopyCategory.quotient _ _).map b\n  hom‚ÇÉ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm‚ÇÅ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm‚ÇÇ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [‚Üê Functor.map_comp_assoc, triangleMapOfHomotopy_comm‚ÇÉ, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom‚ÇÇ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map b)","decl":"/-- The morphism `triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ where\n  hom‚ÇÅ := (HomotopyCategory.quotient _ _).map a\n  hom‚ÇÇ := (HomotopyCategory.quotient _ _).map b\n  hom‚ÇÉ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm‚ÇÅ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm‚ÇÇ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [‚Üê Functor.map_comp_assoc, triangleMapOfHomotopy_comm‚ÇÉ, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\nH : Homotopy (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom‚ÇÉ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.mapOfHomotopy H))","decl":"/-- The morphism `triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh œÜ‚ÇÅ ‚ü∂ triangleh œÜ‚ÇÇ where\n  hom‚ÇÅ := (HomotopyCategory.quotient _ _).map a\n  hom‚ÇÇ := (HomotopyCategory.quotient _ _).map b\n  hom‚ÇÉ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm‚ÇÅ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm‚ÇÇ := by\n    dsimp\n    simp only [‚Üê Functor.map_comp, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [‚Üê Functor.map_comp_assoc, triangleMapOfHomotopy_comm‚ÇÉ, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.map_eq_mapOfHomotopy","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÇ a b comm) (CochainComplex.mappingCone.mapOfHomotopy (Homotopy.ofEq comm))","decl":"lemma map_eq_mapOfHomotopy : map œÜ‚ÇÅ œÜ‚ÇÇ a b comm = mapOfHomotopy (Homotopy.ofEq comm) := by\n  simp [map, mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.map_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CochainComplex.mappingCone.map œÜ œÜ (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id L) ‚ãØ) (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone œÜ))","decl":"lemma map_id : map œÜ œÜ (ùüô _) (ùüô _) (by rw [id_comp, comp_id]) = ùüô _ := by\n  ext n\n  simp [ext_from_iff _ (n + 1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.map_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ K‚ÇÉ L‚ÇÉ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\nœÜ‚ÇÉ : Quiver.Hom K‚ÇÉ L‚ÇÉ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\na' : Quiver.Hom K‚ÇÇ K‚ÇÉ\nb' : Quiver.Hom L‚ÇÇ L‚ÇÉ\ncomm' : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÇ b') (CategoryTheory.CategoryStruct.comp a' œÜ‚ÇÉ)\n‚ä¢ Eq (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÉ (CategoryTheory.CategoryStruct.comp a a') (CategoryTheory.CategoryStruct.comp b b') ‚ãØ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÇ a b comm) (CochainComplex.mappingCone.map œÜ‚ÇÇ œÜ‚ÇÉ a' b' comm'))","decl":"@[reassoc]\nlemma map_comp (comm' : œÜ‚ÇÇ ‚â´ b' = a' ‚â´ œÜ‚ÇÉ) :\n    map œÜ‚ÇÅ œÜ‚ÇÉ (a ‚â´ a') (b ‚â´ b') (by rw [reassoc_of% comm, comm', assoc]) =\n      map œÜ‚ÇÅ œÜ‚ÇÇ a b comm ‚â´ map œÜ‚ÇÇ œÜ‚ÇÉ a' b' comm' := by\n  ext n\n  simp [ext_from_iff _ (n+1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.map_comp_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ K‚ÇÉ L‚ÇÉ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\nœÜ‚ÇÉ : Quiver.Hom K‚ÇÉ L‚ÇÉ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\na' : Quiver.Hom K‚ÇÇ K‚ÇÉ\nb' : Quiver.Hom L‚ÇÇ L‚ÇÉ\ncomm' : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÇ b') (CategoryTheory.CategoryStruct.comp a' œÜ‚ÇÉ)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom (CochainComplex.mappingCone œÜ‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÉ (CategoryTheory.CategoryStruct.comp a a') (CategoryTheory.CategoryStruct.comp b b') ‚ãØ) h) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÇ a b comm) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map œÜ‚ÇÇ œÜ‚ÇÉ a' b' comm') h))","decl":"@[reassoc]\nlemma map_comp (comm' : œÜ‚ÇÇ ‚â´ b' = a' ‚â´ œÜ‚ÇÉ) :\n    map œÜ‚ÇÅ œÜ‚ÇÉ (a ‚â´ a') (b ‚â´ b') (by rw [reassoc_of% comm, comm', assoc]) =\n      map œÜ‚ÇÅ œÜ‚ÇÇ a b comm ‚â´ map œÜ‚ÇÇ œÜ‚ÇÉ a' b' comm' := by\n  ext n\n  simp [ext_from_iff _ (n+1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom‚ÇÅ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.triangleMap œÜ‚ÇÅ œÜ‚ÇÇ a b comm).hom‚ÇÅ a","decl":"/-- The morphism `triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ where\n  hom‚ÇÅ := a\n  hom‚ÇÇ := b\n  hom‚ÇÉ := map œÜ‚ÇÅ œÜ‚ÇÇ a b comm\n  comm‚ÇÅ := comm\n  comm‚ÇÇ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÉ]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.triangleMap œÜ‚ÇÅ œÜ‚ÇÇ a b comm).hom‚ÇÇ b","decl":"/-- The morphism `triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ where\n  hom‚ÇÅ := a\n  hom‚ÇÇ := b\n  hom‚ÇÉ := map œÜ‚ÇÅ œÜ‚ÇÇ a b comm\n  comm‚ÇÅ := comm\n  comm‚ÇÇ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÉ]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : CochainComplex C Int\nœÜ‚ÇÅ : Quiver.Hom K‚ÇÅ L‚ÇÅ\nœÜ‚ÇÇ : Quiver.Hom K‚ÇÇ L‚ÇÇ\na : Quiver.Hom K‚ÇÅ K‚ÇÇ\nb : Quiver.Hom L‚ÇÅ L‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a œÜ‚ÇÇ)\n‚ä¢ Eq (CochainComplex.mappingCone.triangleMap œÜ‚ÇÅ œÜ‚ÇÇ a b comm).hom‚ÇÉ (CochainComplex.mappingCone.map œÜ‚ÇÅ œÜ‚ÇÇ a b comm)","decl":"/-- The morphism `triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle œÜ‚ÇÅ ‚ü∂ triangle œÜ‚ÇÇ where\n  hom‚ÇÅ := a\n  hom‚ÇÇ := b\n  hom‚ÇÉ := map œÜ‚ÇÅ œÜ‚ÇÇ a b comm\n  comm‚ÇÅ := comm\n  comm‚ÇÇ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÇ]\n  comm‚ÇÉ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm‚ÇÉ]\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm‚ÇÇ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\nZ : HomotopyCategory C (ComplexShape.up Int)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.up Int)).obj (CochainComplex.mappingCone (CochainComplex.mappingCone.inr œÜ))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.rotateHomotopyEquiv œÜ).hom) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.inr œÜ))) h)","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm‚ÇÇ :\n    (HomotopyCategory.quotient _ _ ).map (triangle œÜ).mor‚ÇÉ ‚â´\n      (HomotopyCategory.quotient _ _ ).map (rotateHomotopyEquiv œÜ).hom =\n      (HomotopyCategory.quotient _ _ ).map (inr (inr œÜ)) := by\n  simpa only [Functor.map_comp]\n    using HomotopyCategory.eq_of_homotopy _ _  (rotateHomotopyEquivComm‚ÇÇHomotopy œÜ)\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm‚ÇÇ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ) ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.rotateHomotopyEquiv œÜ).hom)) ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.inr œÜ)))","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm‚ÇÇ :\n    (HomotopyCategory.quotient _ _ ).map (triangle œÜ).mor‚ÇÉ ‚â´\n      (HomotopyCategory.quotient _ _ ).map (rotateHomotopyEquiv œÜ).hom =\n      (HomotopyCategory.quotient _ _ ).map (inr (inr œÜ)) := by\n  simpa only [Functor.map_comp]\n    using HomotopyCategory.eq_of_homotopy _ _  (rotateHomotopyEquivComm‚ÇÇHomotopy œÜ)\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm‚ÇÉ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr œÜ)).obj‚ÇÅ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.rotateHomotopyEquiv œÜ).hom (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr œÜ)).mor‚ÇÉ h)) (CategoryTheory.CategoryStruct.comp (Neg.neg ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map œÜ)) h)","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm‚ÇÉ :\n    (rotateHomotopyEquiv œÜ).hom ‚â´ (triangle (inr œÜ)).mor‚ÇÉ = -œÜ‚ü¶1‚üß' := by\n  ext p\n  dsimp [rotateHomotopyEquiv]\n  -- the following list of lemmas has been obtained by doing\n  -- simp? [lift_f _ _ _ _ _ (p + 1) rfl,\n  --   (Cochain.ofHom œÜ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega)]\n  simp only [Int.reduceNeg, lift_f _ _ _ _ _ (p + 1) rfl, shiftFunctor_obj_X', Cocycle.coe_neg,\n    Cocycle.leftShift_coe, Cocycle.ofHom_coe, Cochain.neg_v,\n    (Cochain.ofHom œÜ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega),\n    shiftFunctor_obj_X, mul_one, sub_self, mul_zero, Int.zero_ediv, add_zero, Int.negOnePow_one,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_hom, Cochain.ofHom_v, id_comp,\n    Units.neg_smul, one_smul, neg_neg, Preadditive.neg_comp, Preadditive.add_comp, assoc,\n    inl_v_triangle_mor‚ÇÉ_f, Iso.refl_inv, Preadditive.comp_neg, comp_id, inr_f_triangle_mor‚ÇÉ_f,\n    comp_zero, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm‚ÇÉ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.rotateHomotopyEquiv œÜ).hom (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr œÜ)).mor‚ÇÉ) (Neg.neg ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map œÜ))","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm‚ÇÉ :\n    (rotateHomotopyEquiv œÜ).hom ‚â´ (triangle (inr œÜ)).mor‚ÇÉ = -œÜ‚ü¶1‚üß' := by\n  ext p\n  dsimp [rotateHomotopyEquiv]\n  -- the following list of lemmas has been obtained by doing\n  -- simp? [lift_f _ _ _ _ _ (p + 1) rfl,\n  --   (Cochain.ofHom œÜ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega)]\n  simp only [Int.reduceNeg, lift_f _ _ _ _ _ (p + 1) rfl, shiftFunctor_obj_X', Cocycle.coe_neg,\n    Cocycle.leftShift_coe, Cocycle.ofHom_coe, Cochain.neg_v,\n    (Cochain.ofHom œÜ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega),\n    shiftFunctor_obj_X, mul_one, sub_self, mul_zero, Int.zero_ediv, add_zero, Int.negOnePow_one,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_hom, Cochain.ofHom_v, id_comp,\n    Units.neg_smul, one_smul, neg_neg, Preadditive.neg_comp, Preadditive.add_comp, assoc,\n    inl_v_triangle_mor‚ÇÉ_f, Iso.refl_inv, Preadditive.comp_neg, comp_id, inr_f_triangle_mor‚ÇÉ_f,\n    comp_zero, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.map_Œ¥","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts D\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\nG : CategoryTheory.Functor C D\ninst‚úù : G.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((G.mapHomologicalComplex (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle œÜ).mor‚ÇÉ) (((G.mapHomologicalComplex (ComplexShape.up Int)).commShiftIso 1).hom.app K)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapHomologicalComplexIso œÜ G).hom (CochainComplex.mappingCone.triangle ((G.mapHomologicalComplex (ComplexShape.up Int)).map œÜ)).mor‚ÇÉ)","decl":"lemma map_Œ¥ :\n    (G.mapHomologicalComplex (ComplexShape.up ‚Ñ§)).map (triangle œÜ).mor‚ÇÉ ‚â´\n      NatTrans.app ((Functor.mapHomologicalComplex G (ComplexShape.up ‚Ñ§)).commShiftIso  1).hom K =\n    (mapHomologicalComplexIso œÜ G).hom ‚â´\n      (triangle ((G.mapHomologicalComplex (ComplexShape.up ‚Ñ§)).map œÜ)).mor‚ÇÉ := by\n  ext n\n  dsimp [mapHomologicalComplexIso]\n  rw [mapHomologicalComplexXIso_eq œÜ G n (n+1) rfl, mapHomologicalComplexXIso'_hom]\n  simp only [Functor.mapHomologicalComplex_obj_X, add_comp, assoc, inl_v_triangle_mor‚ÇÉ_f,\n    shiftFunctor_obj_X, shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv,\n    comp_neg, comp_id, inr_f_triangle_mor‚ÇÉ_f, comp_zero, add_zero]\n  dsimp [triangle]\n  rw [Cochain.rightShift_v _ 1 0 (by omega) n n (by omega) (n + 1) (by omega)]\n  simp only [shiftFunctor_obj_X, Cochain.neg_v, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Functor.map_neg]\n\n"}
{"name":"HomotopyCategory.Pretriangulated.isomorphic_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT‚ÇÅ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT‚ÇÅ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T‚ÇÅ\nT‚ÇÇ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\ne : CategoryTheory.Iso T‚ÇÇ T‚ÇÅ\n‚ä¢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T‚ÇÇ","decl":"lemma isomorphic_distinguished (T‚ÇÅ : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles C) (T‚ÇÇ : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (e : T‚ÇÇ ‚âÖ T‚ÇÅ) : T‚ÇÇ ‚àà distinguishedTriangles C := by\n  obtain ‚ü®X, Y, f, ‚ü®e'‚ü©‚ü© := hT‚ÇÅ\n  exact ‚ü®X, Y, f, ‚ü®e ‚â™‚â´ e'‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.Pretriangulated.contractible_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : HomotopyCategory C (ComplexShape.up Int)\n‚ä¢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"variable [HasZeroObject C] in\nlemma contractible_distinguished (X : HomotopyCategory C (ComplexShape.up ‚Ñ§)) :\n    Pretriangulated.contractibleTriangle X ‚àà distinguishedTriangles C := by\n  obtain ‚ü®X‚ü© := X\n  refine ‚ü®_, _, ùüô X, ‚ü®?_‚ü©‚ü©\n  have h := (isZero_quotient_obj_iff _).2 ‚ü®CochainComplex.mappingCone.homotopyToZeroOfId X‚ü©\n  exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) h.isoZero.symm\n    (by simp) (h.eq_of_tgt _ _) (by dsimp; ext)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.distinguished_cocone_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : HomotopyCategory C (ComplexShape.up Int)\nf : Quiver.Hom X Y\n‚ä¢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"lemma distinguished_cocone_triangle {X Y : HomotopyCategory C (ComplexShape.up ‚Ñ§)} (f : X ‚ü∂ Y) :\n    ‚àÉ (Z : HomotopyCategory C (ComplexShape.up ‚Ñ§)) (g : Y ‚ü∂ Z) (h : Z ‚ü∂ X‚ü¶1‚üß),\n      Triangle.mk f g h ‚àà distinguishedTriangles C := by\n  obtain ‚ü®X‚ü© := X\n  obtain ‚ü®Y‚ü© := Y\n  obtain ‚ü®f, rfl‚ü© := (quotient _ _).map_surjective f\n  exact ‚ü®_, _, _, ‚ü®_, _, f, ‚ü®Iso.refl _‚ü©‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.Pretriangulated.rotate_distinguished_triangle'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\n‚ä¢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.rotate","decl":"lemma rotate_distinguished_triangle' (T : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (hT : T ‚àà distinguishedTriangles C) : T.rotate ‚àà distinguishedTriangles C := by\n  obtain ‚ü®K, L, œÜ, ‚ü®e‚ü©‚ü© := hT\n  exact ‚ü®_, _, _, ‚ü®(rotate _).mapIso e ‚â™‚â´ CochainComplex.mappingCone.rotateTrianglehIso œÜ‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.Pretriangulated.shift_distinguished_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\nn : Int\n‚ä¢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) ((CategoryTheory.Pretriangulated.Triangle.shiftFunctor (HomotopyCategory C (ComplexShape.up Int)) n).obj T)","decl":"lemma shift_distinguished_triangle (T : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (hT : T ‚àà distinguishedTriangles C) (n : ‚Ñ§) :\n      (Triangle.shiftFunctor _ n).obj T ‚àà distinguishedTriangles C := by\n  obtain ‚ü®K, L, œÜ, ‚ü®e‚ü©‚ü© := hT\n  exact ‚ü®_, _, _, ‚ü®Functor.mapIso _ e ‚â™‚â´ CochainComplex.mappingCone.shiftTrianglehIso œÜ n‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.Pretriangulated.invRotate_distinguished_triangle'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\n‚ä¢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.invRotate","decl":"lemma invRotate_distinguished_triangle' (T : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (hT : T ‚àà distinguishedTriangles C) : T.invRotate ‚àà distinguishedTriangles C :=\n  isomorphic_distinguished _\n    (shift_distinguished_triangle _ (rotate_distinguished_triangle' _\n      (rotate_distinguished_triangle' _ hT)) _) _\n    ((invRotateIsoRotateRotateShiftFunctorNegOne _).app T)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.rotate_distinguished_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\n‚ä¢ Iff (Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T) (Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.rotate)","decl":"lemma rotate_distinguished_triangle (T : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§))) :\n    T ‚àà distinguishedTriangles C ‚Üî T.rotate ‚àà distinguishedTriangles C := by\n  constructor\n  ¬∑ exact rotate_distinguished_triangle' T\n  ¬∑ intro hT\n    exact isomorphic_distinguished _ (invRotate_distinguished_triangle' T.rotate hT) _\n      ((triangleRotation _).unitIso.app T)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.complete_distinguished_triangle_morphism","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT‚ÇÅ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T‚ÇÅ\nhT‚ÇÇ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T‚ÇÇ\na : Quiver.Hom T‚ÇÅ.obj‚ÇÅ T‚ÇÇ.obj‚ÇÅ\nb : Quiver.Hom T‚ÇÅ.obj‚ÇÇ T‚ÇÇ.obj‚ÇÇ\nfac : Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a T‚ÇÇ.mor‚ÇÅ)\n‚ä¢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÇ c) (CategoryTheory.CategoryStruct.comp b T‚ÇÇ.mor‚ÇÇ)) (Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÉ ((CategoryTheory.shiftFunctor (HomotopyCategory C (ComplexShape.up Int)) 1).map a)) (CategoryTheory.CategoryStruct.comp c T‚ÇÇ.mor‚ÇÉ))","decl":"open CochainComplex.mappingCone in\nlemma complete_distinguished_triangle_morphism\n    (T‚ÇÅ T‚ÇÇ : Triangle (HomotopyCategory C (ComplexShape.up ‚Ñ§)))\n    (hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles C) (hT‚ÇÇ : T‚ÇÇ ‚àà distinguishedTriangles C)\n    (a : T‚ÇÅ.obj‚ÇÅ ‚ü∂ T‚ÇÇ.obj‚ÇÅ) (b : T‚ÇÅ.obj‚ÇÇ ‚ü∂ T‚ÇÇ.obj‚ÇÇ) (fac : T‚ÇÅ.mor‚ÇÅ ‚â´ b = a ‚â´ T‚ÇÇ.mor‚ÇÅ) :\n    ‚àÉ (c : T‚ÇÅ.obj‚ÇÉ ‚ü∂ T‚ÇÇ.obj‚ÇÉ), T‚ÇÅ.mor‚ÇÇ ‚â´ c = b ‚â´ T‚ÇÇ.mor‚ÇÇ ‚àß\n      T‚ÇÅ.mor‚ÇÉ ‚â´ a‚ü¶(1 : ‚Ñ§)‚üß' = c ‚â´ T‚ÇÇ.mor‚ÇÉ := by\n  obtain ‚ü®K‚ÇÅ, L‚ÇÅ, œÜ‚ÇÅ, ‚ü®e‚ÇÅ‚ü©‚ü© := hT‚ÇÅ\n  obtain ‚ü®K‚ÇÇ, L‚ÇÇ, œÜ‚ÇÇ, ‚ü®e‚ÇÇ‚ü©‚ü© := hT‚ÇÇ\n  obtain ‚ü®a', ha'‚ü© : ‚àÉ (a' : (quotient _ _).obj K‚ÇÅ ‚ü∂ (quotient _ _).obj K‚ÇÇ),\n    a' = e‚ÇÅ.inv.hom‚ÇÅ ‚â´ a ‚â´ e‚ÇÇ.hom.hom‚ÇÅ := ‚ü®_, rfl‚ü©\n  obtain ‚ü®b', hb'‚ü© : ‚àÉ (b' : (quotient _ _).obj L‚ÇÅ ‚ü∂ (quotient _ _).obj L‚ÇÇ),\n    b' = e‚ÇÅ.inv.hom‚ÇÇ ‚â´ b ‚â´ e‚ÇÇ.hom.hom‚ÇÇ := ‚ü®_, rfl‚ü©\n  obtain ‚ü®a'', rfl‚ü© := (quotient _ _).map_surjective a'\n  obtain ‚ü®b'', rfl‚ü© := (quotient _ _).map_surjective b'\n  have H : Homotopy (œÜ‚ÇÅ ‚â´ b'') (a'' ‚â´ œÜ‚ÇÇ) := homotopyOfEq _ _ (by\n    have comm‚ÇÅ‚ÇÅ := e‚ÇÅ.inv.comm‚ÇÅ\n    have comm‚ÇÅ‚ÇÇ := e‚ÇÇ.hom.comm‚ÇÅ\n    dsimp at comm‚ÇÅ‚ÇÅ comm‚ÇÅ‚ÇÇ\n    simp only [Functor.map_comp, ha', hb', reassoc_of% comm‚ÇÅ‚ÇÅ,\n      reassoc_of% fac, comm‚ÇÅ‚ÇÇ, assoc])\n  let Œ≥ := e‚ÇÅ.hom ‚â´ trianglehMapOfHomotopy H ‚â´ e‚ÇÇ.inv\n  have comm‚ÇÇ := Œ≥.comm‚ÇÇ\n  have comm‚ÇÉ := Œ≥.comm‚ÇÉ\n  dsimp [Œ≥] at comm‚ÇÇ comm‚ÇÉ\n  simp only [ha', hb'] at comm‚ÇÇ comm‚ÇÉ\n  refine ‚ü®Œ≥.hom‚ÇÉ, ?_, ?_‚ü©\n  -- the following list of lemmas was obtained by doing simpa? [Œ≥] using comm‚ÇÇ\n  ¬∑ simpa only [triangleCategory_comp, Functor.mapTriangle_obj, triangle_obj‚ÇÅ, triangle_obj‚ÇÇ,\n      triangle_obj‚ÇÉ, triangle_mor‚ÇÅ, triangle_mor‚ÇÇ, TriangleMorphism.comp_hom‚ÇÉ, Triangle.mk_obj‚ÇÉ,\n      trianglehMapOfHomotopy_hom‚ÇÉ, TriangleMorphism.comm‚ÇÇ_assoc, Triangle.mk_obj‚ÇÇ,\n      Triangle.mk_mor‚ÇÇ, assoc, Iso.hom_inv_id_triangle_hom‚ÇÇ, comp_id,\n      Iso.hom_inv_id_triangle_hom‚ÇÇ_assoc, Œ≥] using comm‚ÇÇ\n  -- the following list of lemmas was obtained by doing simpa? [Œ≥] using comm‚ÇÉ\n  ¬∑ simpa only [triangleCategory_comp, Functor.mapTriangle_obj, triangle_obj‚ÇÅ, triangle_obj‚ÇÇ,\n      triangle_obj‚ÇÉ, triangle_mor‚ÇÅ, triangle_mor‚ÇÇ, TriangleMorphism.comp_hom‚ÇÉ, Triangle.mk_obj‚ÇÉ,\n      trianglehMapOfHomotopy_hom‚ÇÉ, assoc, Triangle.mk_obj‚ÇÅ, Iso.hom_inv_id_triangle_hom‚ÇÅ, comp_id,\n      Iso.hom_inv_id_triangle_hom‚ÇÅ_assoc, Œ≥] using comm‚ÇÉ\n\n"}
{"name":"HomotopyCategory.mappingCone_triangleh_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : CochainComplex C Int\nf : Quiver.Hom X Y\n‚ä¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CochainComplex.mappingCone.triangleh f)","decl":"lemma mappingCone_triangleh_distinguished {X Y : CochainComplex C ‚Ñ§} (f : X ‚ü∂ Y) :\n    CochainComplex.mappingCone.triangleh f ‚àà distTriang (HomotopyCategory _ _) :=\n  ‚ü®_, _, f, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.instIsTriangulatedIntUpMapHomotopyCategory","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù‚Å∂ : CategoryTheory.Preadditive C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive D\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryBiproducts D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\nG : CategoryTheory.Functor C D\ninst‚úù : G.Additive\n‚ä¢ (G.mapHomotopyCategory (ComplexShape.up Int)).IsTriangulated","decl":"instance (G : C ‚•§ D) [G.Additive] :\n    (G.mapHomotopyCategory (ComplexShape.up ‚Ñ§)).IsTriangulated where\n  map_distinguished := by\n    rintro T ‚ü®K, L, f, ‚ü®e‚ü©‚ü©\n    exact ‚ü®_, _, _, ‚ü®(G.mapHomotopyCategory (ComplexShape.up ‚Ñ§)).mapTriangle.mapIso e ‚â™‚â´\n      CochainComplex.mappingCone.mapTrianglehIso f G‚ü©‚ü©\n\n"}
