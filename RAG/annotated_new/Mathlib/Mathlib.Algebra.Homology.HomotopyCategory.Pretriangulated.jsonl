{"name":"CochainComplex.mappingCone.triangle_mor₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.triangle φ).mor₁ φ","decl":"/-- The standard triangle `K ⟶ L ⟶ mappingCone φ ⟶ K⟦(1 : ℤ)⟧` in `CochainComplex C ℤ`\nattached to a morphism `φ : K ⟶ L`. It involves `φ`, `inr φ : L ⟶ mappingCone φ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst φ`. -/\n@[simps! obj₁ obj₂ obj₃ mor₁ mor₂]\nnoncomputable def triangle : Triangle (CochainComplex C ℤ) :=\n  Triangle.mk φ (inr φ) (Cocycle.homOf ((-fst φ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.triangle φ).obj₃ (CochainComplex.mappingCone φ)","decl":"/-- The standard triangle `K ⟶ L ⟶ mappingCone φ ⟶ K⟦(1 : ℤ)⟧` in `CochainComplex C ℤ`\nattached to a morphism `φ : K ⟶ L`. It involves `φ`, `inr φ : L ⟶ mappingCone φ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst φ`. -/\n@[simps! obj₁ obj₂ obj₃ mor₁ mor₂]\nnoncomputable def triangle : Triangle (CochainComplex C ℤ) :=\n  Triangle.mk φ (inr φ) (Cocycle.homOf ((-fst φ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_mor₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.triangle φ).mor₂ (CochainComplex.mappingCone.inr φ)","decl":"/-- The standard triangle `K ⟶ L ⟶ mappingCone φ ⟶ K⟦(1 : ℤ)⟧` in `CochainComplex C ℤ`\nattached to a morphism `φ : K ⟶ L`. It involves `φ`, `inr φ : L ⟶ mappingCone φ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst φ`. -/\n@[simps! obj₁ obj₂ obj₃ mor₁ mor₂]\nnoncomputable def triangle : Triangle (CochainComplex C ℤ) :=\n  Triangle.mk φ (inr φ) (Cocycle.homOf ((-fst φ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.triangle φ).obj₂ L","decl":"/-- The standard triangle `K ⟶ L ⟶ mappingCone φ ⟶ K⟦(1 : ℤ)⟧` in `CochainComplex C ℤ`\nattached to a morphism `φ : K ⟶ L`. It involves `φ`, `inr φ : L ⟶ mappingCone φ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst φ`. -/\n@[simps! obj₁ obj₂ obj₃ mor₁ mor₂]\nnoncomputable def triangle : Triangle (CochainComplex C ℤ) :=\n  Triangle.mk φ (inr φ) (Cocycle.homOf ((-fst φ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.triangle_obj₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.triangle φ).obj₁ K","decl":"/-- The standard triangle `K ⟶ L ⟶ mappingCone φ ⟶ K⟦(1 : ℤ)⟧` in `CochainComplex C ℤ`\nattached to a morphism `φ : K ⟶ L`. It involves `φ`, `inr φ : L ⟶ mappingCone φ` and\nthe morphism induced by the `1`-cocycle `-mappingCone.fst φ`. -/\n@[simps! obj₁ obj₂ obj₃ mor₁ mor₂]\nnoncomputable def triangle : Triangle (CochainComplex C ℤ) :=\n  Triangle.mk φ (inr φ) (Cocycle.homOf ((-fst φ).rightShift 1 0 (zero_add 1)))\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_triangle_mor₃_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle φ).obj₁).X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q hpq) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.triangle φ).mor₃.f q) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (K.shiftFunctorObjXIso 1 q p ⋯).inv) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_triangle_mor₃_f (p q : ℤ) (hpq : p + (-1) = q) :\n    (inl φ).v p q hpq ≫ (triangle φ).mor₃.f q =\n      -(K.shiftFunctorObjXIso 1 q p (by rw [← hpq, neg_add_cancel_right])).inv := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega)]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega), shiftFunctor_obj_X,\n    shiftFunctorObjXIso, Preadditive.comp_neg, inl_v_fst_v_assoc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_triangle_mor₃_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q hpq) ((CochainComplex.mappingCone.triangle φ).mor₃.f q)) (Neg.neg (K.shiftFunctorObjXIso 1 q p ⋯).inv)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_triangle_mor₃_f (p q : ℤ) (hpq : p + (-1) = q) :\n    (inl φ).v p q hpq ≫ (triangle φ).mor₃.f q =\n      -(K.shiftFunctorObjXIso 1 q p (by rw [← hpq, neg_add_cancel_right])).inv := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega)]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 (zero_add 1) q q (add_zero q) p (by omega), shiftFunctor_obj_X,\n    shiftFunctorObjXIso, Preadditive.comp_neg, inl_v_fst_v_assoc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_triangle_mor₃_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\np : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) ((CochainComplex.mappingCone.triangle φ).mor₃.f p)) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_f_triangle_mor₃_f (p : ℤ) : (inr φ).f p ≫ (triangle φ).mor₃.f p = 0 := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p+1) rfl]\n  simp only [Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p + 1) rfl, shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id,\n    Preadditive.comp_neg, inr_f_fst_v, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_triangle_mor₃_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\np : Int\nZ : C\nh : Quiver.Hom (((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle φ).obj₁).X p) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.triangle φ).mor₃.f p) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_triangle_mor₃_f (p : ℤ) : (inr φ).f p ≫ (triangle φ).mor₃.f p = 0 := by\n  dsimp [triangle]\n  -- the following list of lemmas was obtained by doing\n  -- simp? [Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p+1) rfl]\n  simp only [Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p (add_zero p) (p + 1) rfl, shiftFunctor_obj_X,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id,\n    Preadditive.comp_neg, inr_f_fst_v, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.inr_triangleδ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nZ : CochainComplex C Int\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle φ).obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle φ).mor₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_triangleδ : inr φ ≫ (triangle φ).mor₃ = 0 := by ext; dsimp; simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_triangleδ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ) (CochainComplex.mappingCone.triangle φ).mor₃) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_triangleδ : inr φ ≫ (triangle φ).mor₃ = 0 := by ext; dsimp; simp\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm₂_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\nZ : CochainComplex C Int\nh : Quiver.Hom (CochainComplex.mappingCone φ₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ₁) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) h)) (CategoryTheory.CategoryStruct.comp b (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ₂) h))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm₂ :\n    inr φ₁ ≫ mapOfHomotopy H = b ≫ inr φ₂ := by\n  simp [mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ₁) (CochainComplex.mappingCone.mapOfHomotopy H)) (CategoryTheory.CategoryStruct.comp b (CochainComplex.mappingCone.inr φ₂))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm₂ :\n    inr φ₁ ≫ mapOfHomotopy H = b ≫ inr φ₂ := by\n  simp [mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) (CochainComplex.mappingCone.triangle φ₂).mor₃) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle φ₁).mor₃ ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map a))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm₃ :\n    mapOfHomotopy H ≫ (triangle φ₂).mor₃ = (triangle φ₁).mor₃ ≫ a⟦1⟧' := by\n  ext p\n  dsimp [mapOfHomotopy, triangle]\n  -- the following list of lemmas as been obtained by doing\n  -- simp? [ext_from_iff _ _ _ rfl, Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl, shiftFunctor_obj_X, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Preadditive.comp_neg,\n    Preadditive.neg_comp, ext_from_iff _ _ _ rfl, inl_v_desc_f_assoc, Cochain.add_v,\n    Cochain.zero_cochain_comp_v, Cochain.ofHom_v, Cochain.comp_zero_cochain_v, Preadditive.add_comp,\n    assoc, inl_v_fst_v, inr_f_fst_v, comp_zero, add_zero, inl_v_fst_v_assoc, inr_f_desc_f_assoc,\n    HomologicalComplex.comp_f, neg_zero, inr_f_fst_v_assoc, zero_comp, and_self]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMapOfHomotopy_comm₃_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle φ₂).obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapOfHomotopy H) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle φ₂).mor₃ h)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle φ₁).mor₃ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map a) h))","decl":"@[reassoc]\nlemma triangleMapOfHomotopy_comm₃ :\n    mapOfHomotopy H ≫ (triangle φ₂).mor₃ = (triangle φ₁).mor₃ ≫ a⟦1⟧' := by\n  ext p\n  dsimp [mapOfHomotopy, triangle]\n  -- the following list of lemmas as been obtained by doing\n  -- simp? [ext_from_iff _ _ _ rfl, Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl]\n  simp only [Int.reduceNeg, Cochain.rightShift_neg, Cochain.neg_v, shiftFunctor_obj_X',\n    Cochain.rightShift_v _ 1 0 _ p p _ (p + 1) rfl, shiftFunctor_obj_X, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Preadditive.comp_neg,\n    Preadditive.neg_comp, ext_from_iff _ _ _ rfl, inl_v_desc_f_assoc, Cochain.add_v,\n    Cochain.zero_cochain_comp_v, Cochain.ofHom_v, Cochain.comp_zero_cochain_v, Preadditive.add_comp,\n    assoc, inl_v_fst_v, inr_f_fst_v, comp_zero, add_zero, inl_v_fst_v_assoc, inr_f_desc_f_assoc,\n    HomologicalComplex.comp_f, neg_zero, inr_f_fst_v_assoc, zero_comp, and_self]\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom₁ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map a)","decl":"/-- The morphism `triangleh φ₁ ⟶ triangleh φ₂` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh φ₁ ⟶ triangleh φ₂ where\n  hom₁ := (HomotopyCategory.quotient _ _).map a\n  hom₂ := (HomotopyCategory.quotient _ _).map b\n  hom₃ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm₁ := by\n    dsimp\n    simp only [← Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm₂ := by\n    dsimp\n    simp only [← Functor.map_comp, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [← Functor.map_comp_assoc, triangleMapOfHomotopy_comm₃, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom₂ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map b)","decl":"/-- The morphism `triangleh φ₁ ⟶ triangleh φ₂` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh φ₁ ⟶ triangleh φ₂ where\n  hom₁ := (HomotopyCategory.quotient _ _).map a\n  hom₂ := (HomotopyCategory.quotient _ _).map b\n  hom₃ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm₁ := by\n    dsimp\n    simp only [← Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm₂ := by\n    dsimp\n    simp only [← Functor.map_comp, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [← Functor.map_comp_assoc, triangleMapOfHomotopy_comm₃, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.trianglehMapOfHomotopy_hom₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\nH : Homotopy (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.trianglehMapOfHomotopy H).hom₃ ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.mapOfHomotopy H))","decl":"/-- The morphism `triangleh φ₁ ⟶ triangleh φ₂` that is induced by a square that\nis commutative up to homotopy. -/\n@[simps]\nnoncomputable def trianglehMapOfHomotopy :\n    triangleh φ₁ ⟶ triangleh φ₂ where\n  hom₁ := (HomotopyCategory.quotient _ _).map a\n  hom₂ := (HomotopyCategory.quotient _ _).map b\n  hom₃ := (HomotopyCategory.quotient _ _).map (mapOfHomotopy H)\n  comm₁ := by\n    dsimp\n    simp only [← Functor.map_comp]\n    exact HomotopyCategory.eq_of_homotopy _ _ H\n  comm₂ := by\n    dsimp\n    simp only [← Functor.map_comp, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [← Functor.map_comp_assoc, triangleMapOfHomotopy_comm₃, Functor.map_comp, assoc, assoc]\n    simp\n\n"}
{"name":"CochainComplex.mappingCone.map_eq_mapOfHomotopy","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.map φ₁ φ₂ a b comm) (CochainComplex.mappingCone.mapOfHomotopy (Homotopy.ofEq comm))","decl":"lemma map_eq_mapOfHomotopy : map φ₁ φ₂ a b comm = mapOfHomotopy (Homotopy.ofEq comm) := by\n  simp [map, mapOfHomotopy]\n\n"}
{"name":"CochainComplex.mappingCone.map_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CochainComplex.mappingCone.map φ φ (CategoryTheory.CategoryStruct.id K) (CategoryTheory.CategoryStruct.id L) ⋯) (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone φ))","decl":"lemma map_id : map φ φ (𝟙 _) (𝟙 _) (by rw [id_comp, comp_id]) = 𝟙 _ := by\n  ext n\n  simp [ext_from_iff _ (n + 1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.map_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ K₃ L₃ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\nφ₃ : Quiver.Hom K₃ L₃\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\na' : Quiver.Hom K₂ K₃\nb' : Quiver.Hom L₂ L₃\ncomm' : Eq (CategoryTheory.CategoryStruct.comp φ₂ b') (CategoryTheory.CategoryStruct.comp a' φ₃)\n⊢ Eq (CochainComplex.mappingCone.map φ₁ φ₃ (CategoryTheory.CategoryStruct.comp a a') (CategoryTheory.CategoryStruct.comp b b') ⋯) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map φ₁ φ₂ a b comm) (CochainComplex.mappingCone.map φ₂ φ₃ a' b' comm'))","decl":"@[reassoc]\nlemma map_comp (comm' : φ₂ ≫ b' = a' ≫ φ₃) :\n    map φ₁ φ₃ (a ≫ a') (b ≫ b') (by rw [reassoc_of% comm, comm', assoc]) =\n      map φ₁ φ₂ a b comm ≫ map φ₂ φ₃ a' b' comm' := by\n  ext n\n  simp [ext_from_iff _ (n+1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.map_comp_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ K₃ L₃ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\nφ₃ : Quiver.Hom K₃ L₃\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\na' : Quiver.Hom K₂ K₃\nb' : Quiver.Hom L₂ L₃\ncomm' : Eq (CategoryTheory.CategoryStruct.comp φ₂ b') (CategoryTheory.CategoryStruct.comp a' φ₃)\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom (CochainComplex.mappingCone φ₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map φ₁ φ₃ (CategoryTheory.CategoryStruct.comp a a') (CategoryTheory.CategoryStruct.comp b b') ⋯) h) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map φ₁ φ₂ a b comm) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.map φ₂ φ₃ a' b' comm') h))","decl":"@[reassoc]\nlemma map_comp (comm' : φ₂ ≫ b' = a' ≫ φ₃) :\n    map φ₁ φ₃ (a ≫ a') (b ≫ b') (by rw [reassoc_of% comm, comm', assoc]) =\n      map φ₁ φ₂ a b comm ≫ map φ₂ φ₃ a' b' comm' := by\n  ext n\n  simp [ext_from_iff _ (n+1) n rfl, map]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.triangleMap φ₁ φ₂ a b comm).hom₁ a","decl":"/-- The morphism `triangle φ₁ ⟶ triangle φ₂` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle φ₁ ⟶ triangle φ₂ where\n  hom₁ := a\n  hom₂ := b\n  hom₃ := map φ₁ φ₂ a b comm\n  comm₁ := comm\n  comm₂ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₃]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.triangleMap φ₁ φ₂ a b comm).hom₂ b","decl":"/-- The morphism `triangle φ₁ ⟶ triangle φ₂` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle φ₁ ⟶ triangle φ₂ where\n  hom₁ := a\n  hom₂ := b\n  hom₃ := map φ₁ φ₂ a b comm\n  comm₁ := comm\n  comm₂ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₃]\n\n"}
{"name":"CochainComplex.mappingCone.triangleMap_hom₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK₁ L₁ K₂ L₂ : CochainComplex C Int\nφ₁ : Quiver.Hom K₁ L₁\nφ₂ : Quiver.Hom K₂ L₂\na : Quiver.Hom K₁ K₂\nb : Quiver.Hom L₁ L₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ₁ b) (CategoryTheory.CategoryStruct.comp a φ₂)\n⊢ Eq (CochainComplex.mappingCone.triangleMap φ₁ φ₂ a b comm).hom₃ (CochainComplex.mappingCone.map φ₁ φ₂ a b comm)","decl":"/-- The morphism `triangle φ₁ ⟶ triangle φ₂` that is induced by a commutative square. -/\n@[simps]\nnoncomputable def triangleMap :\n    triangle φ₁ ⟶ triangle φ₂ where\n  hom₁ := a\n  hom₂ := b\n  hom₃ := map φ₁ φ₂ a b comm\n  comm₁ := comm\n  comm₂ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₂]\n  comm₃ := by\n    dsimp\n    rw [map_eq_mapOfHomotopy, triangleMapOfHomotopy_comm₃]\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm₂_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nZ : HomotopyCategory C (ComplexShape.up Int)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.up Int)).obj (CochainComplex.mappingCone (CochainComplex.mappingCone.inr φ))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle φ).mor₃) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.rotateHomotopyEquiv φ).hom) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.inr φ))) h)","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm₂ :\n    (HomotopyCategory.quotient _ _ ).map (triangle φ).mor₃ ≫\n      (HomotopyCategory.quotient _ _ ).map (rotateHomotopyEquiv φ).hom =\n      (HomotopyCategory.quotient _ _ ).map (inr (inr φ)) := by\n  simpa only [Functor.map_comp]\n    using HomotopyCategory.eq_of_homotopy _ _  (rotateHomotopyEquivComm₂Homotopy φ)\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle φ).mor₃) ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.rotateHomotopyEquiv φ).hom)) ((HomotopyCategory.quotient C (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr (CochainComplex.mappingCone.inr φ)))","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm₂ :\n    (HomotopyCategory.quotient _ _ ).map (triangle φ).mor₃ ≫\n      (HomotopyCategory.quotient _ _ ).map (rotateHomotopyEquiv φ).hom =\n      (HomotopyCategory.quotient _ _ ).map (inr (inr φ)) := by\n  simpa only [Functor.map_comp]\n    using HomotopyCategory.eq_of_homotopy _ _  (rotateHomotopyEquivComm₂Homotopy φ)\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm₃_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nZ : HomologicalComplex C (ComplexShape.up Int)\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).obj (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr φ)).obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.rotateHomotopyEquiv φ).hom (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr φ)).mor₃ h)) (CategoryTheory.CategoryStruct.comp (Neg.neg ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map φ)) h)","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm₃ :\n    (rotateHomotopyEquiv φ).hom ≫ (triangle (inr φ)).mor₃ = -φ⟦1⟧' := by\n  ext p\n  dsimp [rotateHomotopyEquiv]\n  -- the following list of lemmas has been obtained by doing\n  -- simp? [lift_f _ _ _ _ _ (p + 1) rfl,\n  --   (Cochain.ofHom φ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega)]\n  simp only [Int.reduceNeg, lift_f _ _ _ _ _ (p + 1) rfl, shiftFunctor_obj_X', Cocycle.coe_neg,\n    Cocycle.leftShift_coe, Cocycle.ofHom_coe, Cochain.neg_v,\n    (Cochain.ofHom φ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega),\n    shiftFunctor_obj_X, mul_one, sub_self, mul_zero, Int.zero_ediv, add_zero, Int.negOnePow_one,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_hom, Cochain.ofHom_v, id_comp,\n    Units.neg_smul, one_smul, neg_neg, Preadditive.neg_comp, Preadditive.add_comp, assoc,\n    inl_v_triangle_mor₃_f, Iso.refl_inv, Preadditive.comp_neg, comp_id, inr_f_triangle_mor₃_f,\n    comp_zero, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.rotateHomotopyEquiv_comm₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.rotateHomotopyEquiv φ).hom (CochainComplex.mappingCone.triangle (CochainComplex.mappingCone.inr φ)).mor₃) (Neg.neg ((CategoryTheory.shiftFunctor (CochainComplex C Int) 1).map φ))","decl":"@[reassoc (attr := simp)]\nlemma rotateHomotopyEquiv_comm₃ :\n    (rotateHomotopyEquiv φ).hom ≫ (triangle (inr φ)).mor₃ = -φ⟦1⟧' := by\n  ext p\n  dsimp [rotateHomotopyEquiv]\n  -- the following list of lemmas has been obtained by doing\n  -- simp? [lift_f _ _ _ _ _ (p + 1) rfl,\n  --   (Cochain.ofHom φ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega)]\n  simp only [Int.reduceNeg, lift_f _ _ _ _ _ (p + 1) rfl, shiftFunctor_obj_X', Cocycle.coe_neg,\n    Cocycle.leftShift_coe, Cocycle.ofHom_coe, Cochain.neg_v,\n    (Cochain.ofHom φ).leftShift_v 1 1 (zero_add 1) p (p + 1) rfl (p + 1) (by omega),\n    shiftFunctor_obj_X, mul_one, sub_self, mul_zero, Int.zero_ediv, add_zero, Int.negOnePow_one,\n    shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_hom, Cochain.ofHom_v, id_comp,\n    Units.neg_smul, one_smul, neg_neg, Preadditive.neg_comp, Preadditive.add_comp, assoc,\n    inl_v_triangle_mor₃_f, Iso.refl_inv, Preadditive.comp_neg, comp_id, inr_f_triangle_mor₃_f,\n    comp_zero, neg_zero]\n\n"}
{"name":"CochainComplex.mappingCone.map_δ","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts D\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nG : CategoryTheory.Functor C D\ninst✝ : G.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((G.mapHomologicalComplex (ComplexShape.up Int)).map (CochainComplex.mappingCone.triangle φ).mor₃) (((G.mapHomologicalComplex (ComplexShape.up Int)).commShiftIso 1).hom.app K)) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.mapHomologicalComplexIso φ G).hom (CochainComplex.mappingCone.triangle ((G.mapHomologicalComplex (ComplexShape.up Int)).map φ)).mor₃)","decl":"lemma map_δ :\n    (G.mapHomologicalComplex (ComplexShape.up ℤ)).map (triangle φ).mor₃ ≫\n      NatTrans.app ((Functor.mapHomologicalComplex G (ComplexShape.up ℤ)).commShiftIso  1).hom K =\n    (mapHomologicalComplexIso φ G).hom ≫\n      (triangle ((G.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).mor₃ := by\n  ext n\n  dsimp [mapHomologicalComplexIso]\n  rw [mapHomologicalComplexXIso_eq φ G n (n+1) rfl, mapHomologicalComplexXIso'_hom]\n  simp only [Functor.mapHomologicalComplex_obj_X, add_comp, assoc, inl_v_triangle_mor₃_f,\n    shiftFunctor_obj_X, shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv,\n    comp_neg, comp_id, inr_f_triangle_mor₃_f, comp_zero, add_zero]\n  dsimp [triangle]\n  rw [Cochain.rightShift_v _ 1 0 (by omega) n n (by omega) (n + 1) (by omega)]\n  simp only [shiftFunctor_obj_X, Cochain.neg_v, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_inv, comp_id, Functor.map_neg]\n\n"}
{"name":"HomotopyCategory.Pretriangulated.isomorphic_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT₁ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT₁ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T₁\nT₂ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\ne : CategoryTheory.Iso T₂ T₁\n⊢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T₂","decl":"lemma isomorphic_distinguished (T₁ : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (hT₁ : T₁ ∈ distinguishedTriangles C) (T₂ : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (e : T₂ ≅ T₁) : T₂ ∈ distinguishedTriangles C := by\n  obtain ⟨X, Y, f, ⟨e'⟩⟩ := hT₁\n  exact ⟨X, Y, f, ⟨e ≪≫ e'⟩⟩\n\n"}
{"name":"HomotopyCategory.Pretriangulated.contractible_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX : HomotopyCategory C (ComplexShape.up Int)\n⊢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"variable [HasZeroObject C] in\nlemma contractible_distinguished (X : HomotopyCategory C (ComplexShape.up ℤ)) :\n    Pretriangulated.contractibleTriangle X ∈ distinguishedTriangles C := by\n  obtain ⟨X⟩ := X\n  refine ⟨_, _, 𝟙 X, ⟨?_⟩⟩\n  have h := (isZero_quotient_obj_iff _).2 ⟨CochainComplex.mappingCone.homotopyToZeroOfId X⟩\n  exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) h.isoZero.symm\n    (by simp) (h.eq_of_tgt _ _) (by dsimp; ext)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.distinguished_cocone_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : HomotopyCategory C (ComplexShape.up Int)\nf : Quiver.Hom X Y\n⊢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"lemma distinguished_cocone_triangle {X Y : HomotopyCategory C (ComplexShape.up ℤ)} (f : X ⟶ Y) :\n    ∃ (Z : HomotopyCategory C (ComplexShape.up ℤ)) (g : Y ⟶ Z) (h : Z ⟶ X⟦1⟧),\n      Triangle.mk f g h ∈ distinguishedTriangles C := by\n  obtain ⟨X⟩ := X\n  obtain ⟨Y⟩ := Y\n  obtain ⟨f, rfl⟩ := (quotient _ _).map_surjective f\n  exact ⟨_, _, _, ⟨_, _, f, ⟨Iso.refl _⟩⟩⟩\n\n"}
{"name":"HomotopyCategory.Pretriangulated.rotate_distinguished_triangle'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\n⊢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.rotate","decl":"lemma rotate_distinguished_triangle' (T : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (hT : T ∈ distinguishedTriangles C) : T.rotate ∈ distinguishedTriangles C := by\n  obtain ⟨K, L, φ, ⟨e⟩⟩ := hT\n  exact ⟨_, _, _, ⟨(rotate _).mapIso e ≪≫ CochainComplex.mappingCone.rotateTrianglehIso φ⟩⟩\n\n"}
{"name":"HomotopyCategory.Pretriangulated.shift_distinguished_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\nn : Int\n⊢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) ((CategoryTheory.Pretriangulated.Triangle.shiftFunctor (HomotopyCategory C (ComplexShape.up Int)) n).obj T)","decl":"lemma shift_distinguished_triangle (T : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (hT : T ∈ distinguishedTriangles C) (n : ℤ) :\n      (Triangle.shiftFunctor _ n).obj T ∈ distinguishedTriangles C := by\n  obtain ⟨K, L, φ, ⟨e⟩⟩ := hT\n  exact ⟨_, _, _, ⟨Functor.mapIso _ e ≪≫ CochainComplex.mappingCone.shiftTrianglehIso φ n⟩⟩\n\n"}
{"name":"HomotopyCategory.Pretriangulated.invRotate_distinguished_triangle'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T\n⊢ Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.invRotate","decl":"lemma invRotate_distinguished_triangle' (T : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (hT : T ∈ distinguishedTriangles C) : T.invRotate ∈ distinguishedTriangles C :=\n  isomorphic_distinguished _\n    (shift_distinguished_triangle _ (rotate_distinguished_triangle' _\n      (rotate_distinguished_triangle' _ hT)) _) _\n    ((invRotateIsoRotateRotateShiftFunctorNegOne _).app T)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.rotate_distinguished_triangle","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\n⊢ Iff (Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T) (Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T.rotate)","decl":"lemma rotate_distinguished_triangle (T : Triangle (HomotopyCategory C (ComplexShape.up ℤ))) :\n    T ∈ distinguishedTriangles C ↔ T.rotate ∈ distinguishedTriangles C := by\n  constructor\n  · exact rotate_distinguished_triangle' T\n  · intro hT\n    exact isomorphic_distinguished _ (invRotate_distinguished_triangle' T.rotate hT) _\n      ((triangleRotation _).unitIso.app T)\n\n"}
{"name":"HomotopyCategory.Pretriangulated.complete_distinguished_triangle_morphism","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle (HomotopyCategory C (ComplexShape.up Int))\nhT₁ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T₁\nhT₂ : Membership.mem (HomotopyCategory.Pretriangulated.distinguishedTriangles C) T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nfac : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor (HomotopyCategory C (ComplexShape.up Int)) 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"open CochainComplex.mappingCone in\nlemma complete_distinguished_triangle_morphism\n    (T₁ T₂ : Triangle (HomotopyCategory C (ComplexShape.up ℤ)))\n    (hT₁ : T₁ ∈ distinguishedTriangles C) (hT₂ : T₂ ∈ distinguishedTriangles C)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (fac : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n    ∃ (c : T₁.obj₃ ⟶ T₂.obj₃), T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧\n      T₁.mor₃ ≫ a⟦(1 : ℤ)⟧' = c ≫ T₂.mor₃ := by\n  obtain ⟨K₁, L₁, φ₁, ⟨e₁⟩⟩ := hT₁\n  obtain ⟨K₂, L₂, φ₂, ⟨e₂⟩⟩ := hT₂\n  obtain ⟨a', ha'⟩ : ∃ (a' : (quotient _ _).obj K₁ ⟶ (quotient _ _).obj K₂),\n    a' = e₁.inv.hom₁ ≫ a ≫ e₂.hom.hom₁ := ⟨_, rfl⟩\n  obtain ⟨b', hb'⟩ : ∃ (b' : (quotient _ _).obj L₁ ⟶ (quotient _ _).obj L₂),\n    b' = e₁.inv.hom₂ ≫ b ≫ e₂.hom.hom₂ := ⟨_, rfl⟩\n  obtain ⟨a'', rfl⟩ := (quotient _ _).map_surjective a'\n  obtain ⟨b'', rfl⟩ := (quotient _ _).map_surjective b'\n  have H : Homotopy (φ₁ ≫ b'') (a'' ≫ φ₂) := homotopyOfEq _ _ (by\n    have comm₁₁ := e₁.inv.comm₁\n    have comm₁₂ := e₂.hom.comm₁\n    dsimp at comm₁₁ comm₁₂\n    simp only [Functor.map_comp, ha', hb', reassoc_of% comm₁₁,\n      reassoc_of% fac, comm₁₂, assoc])\n  let γ := e₁.hom ≫ trianglehMapOfHomotopy H ≫ e₂.inv\n  have comm₂ := γ.comm₂\n  have comm₃ := γ.comm₃\n  dsimp [γ] at comm₂ comm₃\n  simp only [ha', hb'] at comm₂ comm₃\n  refine ⟨γ.hom₃, ?_, ?_⟩\n  -- the following list of lemmas was obtained by doing simpa? [γ] using comm₂\n  · simpa only [triangleCategory_comp, Functor.mapTriangle_obj, triangle_obj₁, triangle_obj₂,\n      triangle_obj₃, triangle_mor₁, triangle_mor₂, TriangleMorphism.comp_hom₃, Triangle.mk_obj₃,\n      trianglehMapOfHomotopy_hom₃, TriangleMorphism.comm₂_assoc, Triangle.mk_obj₂,\n      Triangle.mk_mor₂, assoc, Iso.hom_inv_id_triangle_hom₂, comp_id,\n      Iso.hom_inv_id_triangle_hom₂_assoc, γ] using comm₂\n  -- the following list of lemmas was obtained by doing simpa? [γ] using comm₃\n  · simpa only [triangleCategory_comp, Functor.mapTriangle_obj, triangle_obj₁, triangle_obj₂,\n      triangle_obj₃, triangle_mor₁, triangle_mor₂, TriangleMorphism.comp_hom₃, Triangle.mk_obj₃,\n      trianglehMapOfHomotopy_hom₃, assoc, Triangle.mk_obj₁, Iso.hom_inv_id_triangle_hom₁, comp_id,\n      Iso.hom_inv_id_triangle_hom₁_assoc, γ] using comm₃\n\n"}
{"name":"HomotopyCategory.mappingCone_triangleh_distinguished","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : CochainComplex C Int\nf : Quiver.Hom X Y\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CochainComplex.mappingCone.triangleh f)","decl":"lemma mappingCone_triangleh_distinguished {X Y : CochainComplex C ℤ} (f : X ⟶ Y) :\n    CochainComplex.mappingCone.triangleh f ∈ distTriang (HomotopyCategory _ _) :=\n  ⟨_, _, f, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"HomotopyCategory.instIsTriangulatedIntUpMapHomotopyCategory","module":"Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝⁴ : CategoryTheory.Preadditive D\ninst✝³ : CategoryTheory.Limits.HasBinaryBiproducts D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\nG : CategoryTheory.Functor C D\ninst✝ : G.Additive\n⊢ (G.mapHomotopyCategory (ComplexShape.up Int)).IsTriangulated","decl":"instance (G : C ⥤ D) [G.Additive] :\n    (G.mapHomotopyCategory (ComplexShape.up ℤ)).IsTriangulated where\n  map_distinguished := by\n    rintro T ⟨K, L, f, ⟨e⟩⟩\n    exact ⟨_, _, _, ⟨(G.mapHomotopyCategory (ComplexShape.up ℤ)).mapTriangle.mapIso e ≪≫\n      CochainComplex.mappingCone.mapTrianglehIso f G⟩⟩\n\n"}
