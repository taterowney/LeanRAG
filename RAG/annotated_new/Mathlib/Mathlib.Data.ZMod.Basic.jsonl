{"name":"ZMod.charZero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"⊢ CharZero (ZMod 0)","decl":"instance charZero : CharZero (ZMod 0) := inferInstanceAs (CharZero ℤ)\n\n"}
{"name":"ZMod.val_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ LT.lt a.val n","decl":"theorem val_lt {n : ℕ} [NeZero n] (a : ZMod n) : a.val < n := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  exact Fin.is_lt a\n\n"}
{"name":"ZMod.val_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ LE.le a.val n","decl":"theorem val_le {n : ℕ} [NeZero n] (a : ZMod n) : a.val ≤ n :=\n  a.val_lt.le\n\n"}
{"name":"ZMod.val_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (ZMod.val 0) 0","decl":"@[simp]\ntheorem val_zero : ∀ {n}, (0 : ZMod n).val = 0\n  | 0 => rfl\n  | _ + 1 => rfl\n\n"}
{"name":"ZMod.val_one'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"⊢ Eq (ZMod.val 1) 1","decl":"@[simp]\ntheorem val_one' : (1 : ZMod 0).val = 1 :=\n  rfl\n\n"}
{"name":"ZMod.val_neg'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : ZMod 0\n⊢ Eq (Neg.neg n).val n.val","decl":"@[simp]\ntheorem val_neg' {n : ZMod 0} : (-n).val = n.val :=\n  Int.natAbs_neg n\n\n"}
{"name":"ZMod.val_mul'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : ZMod 0\n⊢ Eq (HMul.hMul m n).val (HMul.hMul m.val n.val)","decl":"@[simp]\ntheorem val_mul' {m n : ZMod 0} : (m * n).val = m.val * n.val :=\n  Int.natAbs_mul m n\n\n"}
{"name":"ZMod.val_natCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n a : Nat\n⊢ Eq (↑a).val (HMod.hMod a n)","decl":"@[simp]\ntheorem val_natCast {n : ℕ} (a : ℕ) : (a : ZMod n).val = a % n := by\n  cases n\n  · rw [Nat.mod_zero]\n    exact Int.natAbs_ofNat a\n  · apply Fin.val_natCast\n\n"}
{"name":"ZMod.val_unit'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : ZMod 0\n⊢ Iff (IsUnit n) (Eq n.val 1)","decl":"theorem val_unit' {n : ZMod 0} : IsUnit n ↔ n.val = 1 := by\n  simp only [val]\n  rw [Int.isUnit_iff, Int.natAbs_eq_iff, Nat.cast_one]\n\n"}
{"name":"ZMod.eq_one_of_isUnit_natCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nh : IsUnit ↑n\n⊢ Eq n 1","decl":"lemma eq_one_of_isUnit_natCast {n : ℕ} (h : IsUnit (n : ZMod 0)) : n = 1 := by\n  rw [← Nat.mod_zero n, ← val_natCast, val_unit'.mp h]\n\n"}
{"name":"ZMod.val_natCast_of_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n a : Nat\nh : LT.lt a n\n⊢ Eq (↑a).val a","decl":"theorem val_natCast_of_lt {n a : ℕ} (h : a < n) : (a : ZMod n).val = a := by\n  rwa [val_natCast, Nat.mod_eq_of_lt]\n\n"}
{"name":"ZMod.charP","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ CharP (ZMod n) n","decl":"instance charP (n : ℕ) : CharP (ZMod n) n where\n  cast_eq_zero_iff' := by\n    intro k\n    cases' n with n\n    · simp [zero_dvd_iff, Int.natCast_eq_zero]\n    · exact Fin.natCast_eq_zero\n\n"}
{"name":"ZMod.addOrderOf_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (addOrderOf 1) n","decl":"@[simp]\ntheorem addOrderOf_one (n : ℕ) : addOrderOf (1 : ZMod n) = n :=\n  CharP.eq _ (CharP.addOrderOf_one _) (ZMod.charP n)\n\n"}
{"name":"ZMod.addOrderOf_coe","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a n : Nat\nn0 : Ne n 0\n⊢ Eq (addOrderOf ↑a) (HDiv.hDiv n (n.gcd a))","decl":"/-- This lemma works in the case in which `ZMod n` is not infinite, i.e. `n ≠ 0`.  The version\nwhere `a ≠ 0` is `addOrderOf_coe'`. -/\n@[simp]\ntheorem addOrderOf_coe (a : ℕ) {n : ℕ} (n0 : n ≠ 0) : addOrderOf (a : ZMod n) = n / n.gcd a := by\n  cases' a with a\n  · simp only [Nat.cast_zero, addOrderOf_zero, Nat.gcd_zero_right,\n      Nat.pos_of_ne_zero n0, Nat.div_self]\n  rw [← Nat.smul_one_eq_cast, addOrderOf_nsmul' _ a.succ_ne_zero, ZMod.addOrderOf_one]\n\n"}
{"name":"ZMod.addOrderOf_coe'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a n : Nat\na0 : Ne a 0\n⊢ Eq (addOrderOf ↑a) (HDiv.hDiv n (n.gcd a))","decl":"/-- This lemma works in the case in which `a ≠ 0`.  The version where\n `ZMod n` is not infinite, i.e. `n ≠ 0`, is `addOrderOf_coe`. -/\n@[simp]\ntheorem addOrderOf_coe' {a : ℕ} (n : ℕ) (a0 : a ≠ 0) : addOrderOf (a : ZMod n) = n / n.gcd a := by\n  rw [← Nat.smul_one_eq_cast, addOrderOf_nsmul' _ a0, ZMod.addOrderOf_one]\n\n"}
{"name":"ZMod.ringChar_zmod_n","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (ringChar (ZMod n)) n","decl":"/-- We have that `ringChar (ZMod n) = n`. -/\ntheorem ringChar_zmod_n (n : ℕ) : ringChar (ZMod n) = n := by\n  rw [ringChar.eq_iff]\n  exact ZMod.charP n\n\n"}
{"name":"ZMod.natCast_self","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n) 0","decl":"theorem natCast_self (n : ℕ) : (n : ZMod n) = 0 :=\n  CharP.cast_eq_zero (ZMod n) n\n\n"}
{"name":"ZMod.natCast_self'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) 1) 0","decl":"@[simp]\ntheorem natCast_self' (n : ℕ) : (n + 1 : ZMod (n + 1)) = 0 := by\n  rw [← Nat.cast_add_one, natCast_self (n + 1)]\n\n"}
{"name":"ZMod.cast_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : AddGroupWithOne R\n⊢ Eq (ZMod.cast 0) 0","decl":"@[simp]\ntheorem cast_zero : (cast (0 : ZMod n) : R) = 0 := by\n  delta ZMod.cast\n  cases n\n  · exact Int.cast_zero\n  · simp\n\n"}
{"name":"ZMod.cast_eq_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : AddGroupWithOne R\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq a.cast ↑a.val","decl":"theorem cast_eq_val [NeZero n] (a : ZMod n) : (cast a : R) = a.val := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  rfl\n\n"}
{"name":"Prod.fst_zmod_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : AddGroupWithOne R\nS : Type u_2\ninst✝ : AddGroupWithOne S\na : ZMod n\n⊢ Eq a.cast.1 a.cast","decl":"@[simp]\ntheorem _root_.Prod.fst_zmod_cast (a : ZMod n) : (cast a : R × S).fst = cast a := by\n  cases n\n  · rfl\n  · simp [ZMod.cast]\n\n"}
{"name":"Prod.snd_zmod_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : AddGroupWithOne R\nS : Type u_2\ninst✝ : AddGroupWithOne S\na : ZMod n\n⊢ Eq a.cast.2 a.cast","decl":"@[simp]\ntheorem _root_.Prod.snd_zmod_cast (a : ZMod n) : (cast a : R × S).snd = cast a := by\n  cases n\n  · rfl\n  · simp [ZMod.cast]\n\n"}
{"name":"ZMod.natCast_zmod_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq (↑a.val) a","decl":"/-- So-named because the coercion is `Nat.cast` into `ZMod`. For `Nat.cast` into an arbitrary ring,\nsee `ZMod.natCast_val`. -/\ntheorem natCast_zmod_val {n : ℕ} [NeZero n] (a : ZMod n) : (a.val : ZMod n) = a := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  · apply Fin.cast_val_eq_self\n\n"}
{"name":"ZMod.natCast_rightInverse","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Function.RightInverse ZMod.val Nat.cast","decl":"theorem natCast_rightInverse [NeZero n] : Function.RightInverse val ((↑) : ℕ → ZMod n) :=\n  natCast_zmod_val\n\n"}
{"name":"ZMod.natCast_zmod_surjective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Function.Surjective Nat.cast","decl":"theorem natCast_zmod_surjective [NeZero n] : Function.Surjective ((↑) : ℕ → ZMod n) :=\n  natCast_rightInverse.surjective\n\n"}
{"name":"ZMod.intCast_zmod_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Eq (↑a.cast) a","decl":"/-- So-named because the outer coercion is `Int.cast` into `ZMod`. For `Int.cast` into an arbitrary\nring, see `ZMod.intCast_cast`. -/\n@[norm_cast]\ntheorem intCast_zmod_cast (a : ZMod n) : ((cast a : ℤ) : ZMod n) = a := by\n  cases n\n  · simp [ZMod.cast, ZMod]\n  · dsimp [ZMod.cast, ZMod]\n    erw [Int.cast_natCast, Fin.cast_val_eq_self]\n\n"}
{"name":"ZMod.intCast_rightInverse","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Function.RightInverse ZMod.cast Int.cast","decl":"theorem intCast_rightInverse : Function.RightInverse (cast : ZMod n → ℤ) ((↑) : ℤ → ZMod n) :=\n  intCast_zmod_cast\n\n"}
{"name":"ZMod.intCast_surjective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Function.Surjective Int.cast","decl":"theorem intCast_surjective : Function.Surjective ((↑) : ℤ → ZMod n) :=\n  intCast_rightInverse.surjective\n\n"}
{"name":"ZMod.forall","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nP : ZMod n → Prop\n⊢ Iff (∀ (x : ZMod n), P x) (∀ (x : Int), P ↑x)","decl":"lemma «forall» {P : ZMod n → Prop} : (∀ x, P x) ↔ ∀ x : ℤ, P x := intCast_surjective.forall\n"}
{"name":"ZMod.exists","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nP : ZMod n → Prop\n⊢ Iff (Exists fun x => P x) (Exists fun x => P ↑x)","decl":"lemma «exists» {P : ZMod n → Prop} : (∃ x, P x) ↔ ∃ x : ℤ, P x := intCast_surjective.exists\n\n"}
{"name":"ZMod.cast_id","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ni : ZMod n\n⊢ Eq i.cast i","decl":"theorem cast_id : ∀ (n) (i : ZMod n), (ZMod.cast i : ZMod n) = i\n  | 0, _ => Int.cast_id\n  | _ + 1, i => natCast_zmod_val i\n\n"}
{"name":"ZMod.cast_id'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq ZMod.cast id","decl":"@[simp]\ntheorem cast_id' : (ZMod.cast : ZMod n → ZMod n) = id :=\n  funext (cast_id n)\n\n"}
{"name":"ZMod.natCast_comp_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : NeZero n\n⊢ Eq (Function.comp Nat.cast ZMod.val) ZMod.cast","decl":"/-- The coercions are respectively `Nat.cast` and `ZMod.cast`. -/\n@[simp]\ntheorem natCast_comp_val [NeZero n] : ((↑) : ℕ → R) ∘ (val : ZMod n → ℕ) = cast := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  rfl\n\n"}
{"name":"ZMod.intCast_comp_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\n⊢ Eq (Function.comp Int.cast ZMod.cast) ZMod.cast","decl":"/-- The coercions are respectively `Int.cast`, `ZMod.cast`, and `ZMod.cast`. -/\n@[simp]\ntheorem intCast_comp_cast : ((↑) : ℤ → R) ∘ (cast : ZMod n → ℤ) = cast := by\n  cases n\n  · exact congr_arg (Int.cast ∘ ·) ZMod.cast_id'\n  · ext\n    simp [ZMod, ZMod.cast]\n\n"}
{"name":"ZMod.natCast_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : NeZero n\ni : ZMod n\n⊢ Eq (↑i.val) i.cast","decl":"@[simp]\ntheorem natCast_val [NeZero n] (i : ZMod n) : (i.val : R) = cast i :=\n  congr_fun (natCast_comp_val R) i\n\n"}
{"name":"ZMod.intCast_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\ni : ZMod n\n⊢ Eq (↑i.cast) i.cast","decl":"@[simp]\ntheorem intCast_cast (i : ZMod n) : ((cast i : ℤ) : R) = cast i :=\n  congr_fun (intCast_comp_cast R) i\n\n"}
{"name":"ZMod.cast_add_eq_ite","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\n⊢ Eq (HAdd.hAdd a b).cast (ite (LE.le (↑n) (HAdd.hAdd a.cast b.cast)) (HSub.hSub (HAdd.hAdd a.cast b.cast) ↑n) (HAdd.hAdd a.cast b.cast))","decl":"theorem cast_add_eq_ite {n : ℕ} (a b : ZMod n) :\n    (cast (a + b) : ℤ) =\n      if (n : ℤ) ≤ cast a + cast b then (cast a + cast b - n : ℤ) else cast a + cast b := by\n  cases' n with n\n  · simp; rfl\n  change Fin (n + 1) at a b\n  change ((((a + b) : Fin (n + 1)) : ℕ) : ℤ) = if ((n + 1 : ℕ) : ℤ) ≤ (a : ℕ) + b then _ else _\n  simp only [Fin.val_add_eq_ite, Int.ofNat_succ, Int.ofNat_le]\n  norm_cast\n  split_ifs with h\n  · rw [Nat.cast_sub h]\n    congr\n  · rfl\n\n"}
{"name":"ZMod.cast_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\n⊢ Eq (ZMod.cast 1) 1","decl":"@[simp]\ntheorem cast_one (h : m ∣ n) : (cast (1 : ZMod n) : R) = 1 := by\n  cases' n with n\n  · exact Int.cast_one\n  show ((1 % (n + 1) : ℕ) : R) = 1\n  cases n\n  · rw [Nat.dvd_one] at h\n    subst m\n    subsingleton [CharP.CharOne.subsingleton]\n  rw [Nat.mod_eq_of_lt]\n  · exact Nat.cast_one\n  exact Nat.lt_of_sub_eq_succ rfl\n\n"}
{"name":"ZMod.cast_add","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\na b : ZMod n\n⊢ Eq (HAdd.hAdd a b).cast (HAdd.hAdd a.cast b.cast)","decl":"theorem cast_add (h : m ∣ n) (a b : ZMod n) : (cast (a + b : ZMod n) : R) = cast a + cast b := by\n  cases n\n  · apply Int.cast_add\n  symm\n  dsimp [ZMod, ZMod.cast]\n  erw [← Nat.cast_add, ← sub_eq_zero, ← Nat.cast_sub (Nat.mod_le _ _),\n    @CharP.cast_eq_zero_iff R _ m]\n  exact h.trans (Nat.dvd_sub_mod _)\n\n"}
{"name":"ZMod.cast_mul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\na b : ZMod n\n⊢ Eq (HMul.hMul a b).cast (HMul.hMul a.cast b.cast)","decl":"theorem cast_mul (h : m ∣ n) (a b : ZMod n) : (cast (a * b : ZMod n) : R) = cast a * cast b := by\n  cases n\n  · apply Int.cast_mul\n  symm\n  dsimp [ZMod, ZMod.cast]\n  erw [← Nat.cast_mul, ← sub_eq_zero, ← Nat.cast_sub (Nat.mod_le _ _),\n    @CharP.cast_eq_zero_iff R _ m]\n  exact h.trans (Nat.dvd_sub_mod _)\n\n"}
{"name":"ZMod.castHom_apply","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\ni : ZMod n\n⊢ Eq ((ZMod.castHom h R) i) i.cast","decl":"@[simp]\ntheorem castHom_apply {h : m ∣ n} (i : ZMod n) : castHom h R i = cast i :=\n  rfl\n\n"}
{"name":"ZMod.cast_sub","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\na b : ZMod n\n⊢ Eq (HSub.hSub a b).cast (HSub.hSub a.cast b.cast)","decl":"@[simp]\ntheorem cast_sub (h : m ∣ n) (a b : ZMod n) : (cast (a - b : ZMod n) : R) = cast a - cast b :=\n  (castHom h R).map_sub a b\n\n"}
{"name":"ZMod.cast_neg","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\na : ZMod n\n⊢ Eq (Neg.neg a).cast (Neg.neg a.cast)","decl":"@[simp]\ntheorem cast_neg (h : m ∣ n) (a : ZMod n) : (cast (-a : ZMod n) : R) = -(cast a) :=\n  (castHom h R).map_neg a\n\n"}
{"name":"ZMod.cast_pow","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\na : ZMod n\nk : Nat\n⊢ Eq (HPow.hPow a k).cast (HPow.hPow a.cast k)","decl":"@[simp]\ntheorem cast_pow (h : m ∣ n) (a : ZMod n) (k : ℕ) : (cast (a ^ k : ZMod n) : R) = (cast a) ^ k :=\n  (castHom h R).map_pow a k\n\n"}
{"name":"ZMod.cast_natCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\nk : Nat\n⊢ Eq (↑k).cast ↑k","decl":"@[simp, norm_cast]\ntheorem cast_natCast (h : m ∣ n) (k : ℕ) : (cast (k : ZMod n) : R) = k :=\n  map_natCast (castHom h R) k\n\n"}
{"name":"ZMod.cast_intCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\nm : Nat\ninst✝ : CharP R m\nh : Dvd.dvd m n\nk : Int\n⊢ Eq (↑k).cast ↑k","decl":"@[simp, norm_cast]\ntheorem cast_intCast (h : m ∣ n) (k : ℤ) : (cast (k : ZMod n) : R) = k :=\n  map_intCast (castHom h R) k\n\n"}
{"name":"ZMod.cast_one'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\n⊢ Eq (ZMod.cast 1) 1","decl":"@[simp]\ntheorem cast_one' : (cast (1 : ZMod n) : R) = 1 :=\n  cast_one dvd_rfl\n\n"}
{"name":"ZMod.cast_add'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\na b : ZMod n\n⊢ Eq (HAdd.hAdd a b).cast (HAdd.hAdd a.cast b.cast)","decl":"@[simp]\ntheorem cast_add' (a b : ZMod n) : (cast (a + b : ZMod n) : R) = cast a + cast b :=\n  cast_add dvd_rfl a b\n\n"}
{"name":"ZMod.cast_mul'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\na b : ZMod n\n⊢ Eq (HMul.hMul a b).cast (HMul.hMul a.cast b.cast)","decl":"@[simp]\ntheorem cast_mul' (a b : ZMod n) : (cast (a * b : ZMod n) : R) = cast a * cast b :=\n  cast_mul dvd_rfl a b\n\n"}
{"name":"ZMod.cast_sub'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\na b : ZMod n\n⊢ Eq (HSub.hSub a b).cast (HSub.hSub a.cast b.cast)","decl":"@[simp]\ntheorem cast_sub' (a b : ZMod n) : (cast (a - b : ZMod n) : R) = cast a - cast b :=\n  cast_sub dvd_rfl a b\n\n"}
{"name":"ZMod.cast_pow'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\na : ZMod n\nk : Nat\n⊢ Eq (HPow.hPow a k).cast (HPow.hPow a.cast k)","decl":"@[simp]\ntheorem cast_pow' (a : ZMod n) (k : ℕ) : (cast (a ^ k : ZMod n) : R) = (cast a : R) ^ k :=\n  cast_pow dvd_rfl a k\n\n"}
{"name":"ZMod.cast_natCast'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\nk : Nat\n⊢ Eq (↑k).cast ↑k","decl":"@[simp, norm_cast]\ntheorem cast_natCast' (k : ℕ) : (cast (k : ZMod n) : R) = k :=\n  cast_natCast dvd_rfl k\n\n"}
{"name":"ZMod.cast_intCast'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\nk : Int\n⊢ Eq (↑k).cast ↑k","decl":"@[simp, norm_cast]\ntheorem cast_intCast' (k : ℤ) : (cast (k : ZMod n) : R) = k :=\n  cast_intCast dvd_rfl k\n\n"}
{"name":"ZMod.castHom_injective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R n\n⊢ Function.Injective ⇑(ZMod.castHom ⋯ R)","decl":"theorem castHom_injective : Function.Injective (ZMod.castHom (dvd_refl n) R) := by\n  rw [injective_iff_map_eq_zero]\n  intro x\n  obtain ⟨k, rfl⟩ := ZMod.intCast_surjective x\n  rw [map_intCast, CharP.intCast_eq_zero_iff R n, CharP.intCast_eq_zero_iff (ZMod n) n]\n  exact id\n\n"}
{"name":"ZMod.castHom_bijective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝² : Ring R\ninst✝¹ : CharP R n\ninst✝ : Fintype R\nh : Eq (Fintype.card R) n\n⊢ Function.Bijective ⇑(ZMod.castHom ⋯ R)","decl":"theorem castHom_bijective [Fintype R] (h : Fintype.card R = n) :\n    Function.Bijective (ZMod.castHom (dvd_refl n) R) := by\n  haveI : NeZero n :=\n    ⟨by\n      intro hn\n      rw [hn] at h\n      exact (Fintype.card_eq_zero_iff.mp h).elim' 0⟩\n  rw [Fintype.bijective_iff_injective_and_card, ZMod.card, h, eq_self_iff_true, and_true]\n  apply ZMod.castHom_injective\n\n"}
{"name":"ZMod.ringEquivOfPrime_eq_ringEquiv","module":"Mathlib.Data.ZMod.Basic","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : Fintype R\np : Nat\ninst✝ : CharP R p\nhp : Nat.Prime p\nhR : Eq (Fintype.card R) p\n⊢ Eq (ZMod.ringEquivOfPrime R hp hR) (ZMod.ringEquiv R hR)","decl":"@[simp]\nlemma ringEquivOfPrime_eq_ringEquiv [Fintype R] {p : ℕ} [CharP R p] (hp : p.Prime)\n    (hR : Fintype.card R = p) : ringEquivOfPrime R hp hR = ringEquiv R hR := rfl\n\n"}
{"name":"ZMod.ringEquivCongr_refl","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : Nat\n⊢ Eq (ZMod.ringEquivCongr ⋯) (RingEquiv.refl (ZMod a))","decl":"@[simp] lemma ringEquivCongr_refl (a : ℕ) : ringEquivCongr (rfl : a = a) = .refl _ := by\n  cases a <;> rfl\n\n"}
{"name":"ZMod.ringEquivCongr_refl_apply","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : Nat\nx : ZMod a\n⊢ Eq ((ZMod.ringEquivCongr ⋯) x) x","decl":"lemma ringEquivCongr_refl_apply {a : ℕ} (x : ZMod a) : ringEquivCongr rfl x = x := by\n  rw [ringEquivCongr_refl]\n  rfl\n\n"}
{"name":"ZMod.ringEquivCongr_symm","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Nat\nhab : Eq a b\n⊢ Eq (ZMod.ringEquivCongr hab).symm (ZMod.ringEquivCongr ⋯)","decl":"lemma ringEquivCongr_symm {a b : ℕ} (hab : a = b) :\n    (ringEquivCongr hab).symm = ringEquivCongr hab.symm := by\n  subst hab\n  cases a <;> rfl\n\n"}
{"name":"ZMod.ringEquivCongr_trans","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b c : Nat\nhab : Eq a b\nhbc : Eq b c\n⊢ Eq ((ZMod.ringEquivCongr hab).trans (ZMod.ringEquivCongr hbc)) (ZMod.ringEquivCongr ⋯)","decl":"lemma ringEquivCongr_trans {a b c : ℕ} (hab : a = b) (hbc : b = c) :\n    (ringEquivCongr hab).trans (ringEquivCongr hbc) = ringEquivCongr (hab.trans hbc) := by\n  subst hab hbc\n  cases a <;> rfl\n\n"}
{"name":"ZMod.ringEquivCongr_ringEquivCongr_apply","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b c : Nat\nhab : Eq a b\nhbc : Eq b c\nx : ZMod a\n⊢ Eq ((ZMod.ringEquivCongr hbc) ((ZMod.ringEquivCongr hab) x)) ((ZMod.ringEquivCongr ⋯) x)","decl":"lemma ringEquivCongr_ringEquivCongr_apply {a b c : ℕ} (hab : a = b) (hbc : b = c) (x : ZMod a) :\n    ringEquivCongr hbc (ringEquivCongr hab x) = ringEquivCongr (hab.trans hbc) x := by\n  rw [← ringEquivCongr_trans hab hbc]\n  rfl\n\n"}
{"name":"ZMod.ringEquivCongr_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Nat\nh : Eq a b\nx : ZMod a\n⊢ Eq ((ZMod.ringEquivCongr h) x).val x.val","decl":"lemma ringEquivCongr_val {a b : ℕ} (h : a = b) (x : ZMod a) :\n    ZMod.val ((ZMod.ringEquivCongr h) x) = ZMod.val x := by\n  subst h\n  cases a <;> rfl\n\n"}
{"name":"ZMod.ringEquivCongr_intCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Nat\nh : Eq a b\nz : Int\n⊢ Eq ((ZMod.ringEquivCongr h) ↑z) ↑z","decl":"lemma ringEquivCongr_intCast {a b : ℕ} (h : a = b) (z : ℤ) :\n    ZMod.ringEquivCongr h z = z := by\n  subst h\n  cases a <;> rfl\n\n"}
{"name":"ZMod.val_eq_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Iff (Eq a.val 0) (Eq a 0)","decl":"@[simp]\ntheorem val_eq_zero : ∀ {n : ℕ} (a : ZMod n), a.val = 0 ↔ a = 0\n  | 0, _ => Int.natAbs_eq_zero\n  | n + 1, a => by\n    rw [Fin.ext_iff]\n    exact Iff.rfl\n\n"}
{"name":"ZMod.intCast_eq_intCast_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Int\nc : Nat\n⊢ Iff (Eq ↑a ↑b) ((↑c).ModEq a b)","decl":"theorem intCast_eq_intCast_iff (a b : ℤ) (c : ℕ) : (a : ZMod c) = (b : ZMod c) ↔ a ≡ b [ZMOD c] :=\n  CharP.intCast_eq_intCast (ZMod c) c\n\n"}
{"name":"ZMod.intCast_eq_intCast_iff'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Int\nc : Nat\n⊢ Iff (Eq ↑a ↑b) (Eq (HMod.hMod a ↑c) (HMod.hMod b ↑c))","decl":"theorem intCast_eq_intCast_iff' (a b : ℤ) (c : ℕ) : (a : ZMod c) = (b : ZMod c) ↔ a % c = b % c :=\n  ZMod.intCast_eq_intCast_iff a b c\n\n"}
{"name":"ZMod.val_intCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : Int\ninst✝ : NeZero n\n⊢ Eq (↑(↑a).val) (HMod.hMod a ↑n)","decl":"theorem val_intCast {n : ℕ} (a : ℤ) [NeZero n] : ↑(a : ZMod n).val = a % n := by\n  have hle : (0 : ℤ) ≤ ↑(a : ZMod n).val := Int.natCast_nonneg _\n  have hlt : ↑(a : ZMod n).val < (n : ℤ) := Int.ofNat_lt.mpr (ZMod.val_lt a)\n  refine (Int.emod_eq_of_lt hle hlt).symm.trans ?_\n  rw [← ZMod.intCast_eq_intCast_iff', Int.cast_natCast, ZMod.natCast_val, ZMod.cast_id]\n\n"}
{"name":"ZMod.natCast_eq_natCast_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b c : Nat\n⊢ Iff (Eq ↑a ↑b) (c.ModEq a b)","decl":"theorem natCast_eq_natCast_iff (a b c : ℕ) : (a : ZMod c) = (b : ZMod c) ↔ a ≡ b [MOD c] := by\n  simpa [Int.natCast_modEq_iff] using ZMod.intCast_eq_intCast_iff a b c\n\n"}
{"name":"ZMod.natCast_eq_natCast_iff'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b c : Nat\n⊢ Iff (Eq ↑a ↑b) (Eq (HMod.hMod a c) (HMod.hMod b c))","decl":"theorem natCast_eq_natCast_iff' (a b c : ℕ) : (a : ZMod c) = (b : ZMod c) ↔ a % c = b % c :=\n  ZMod.natCast_eq_natCast_iff a b c\n\n"}
{"name":"ZMod.intCast_zmod_eq_zero_iff_dvd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : Int\nb : Nat\n⊢ Iff (Eq (↑a) 0) (Dvd.dvd (↑b) a)","decl":"theorem intCast_zmod_eq_zero_iff_dvd (a : ℤ) (b : ℕ) : (a : ZMod b) = 0 ↔ (b : ℤ) ∣ a := by\n  rw [← Int.cast_zero, ZMod.intCast_eq_intCast_iff, Int.modEq_zero_iff_dvd]\n\n"}
{"name":"ZMod.intCast_eq_intCast_iff_dvd_sub","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Int\nc : Nat\n⊢ Iff (Eq ↑a ↑b) (Dvd.dvd (↑c) (HSub.hSub b a))","decl":"theorem intCast_eq_intCast_iff_dvd_sub (a b : ℤ) (c : ℕ) : (a : ZMod c) = ↑b ↔ ↑c ∣ b - a := by\n  rw [ZMod.intCast_eq_intCast_iff, Int.modEq_iff_dvd]\n\n"}
{"name":"ZMod.natCast_zmod_eq_zero_iff_dvd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a b : Nat\n⊢ Iff (Eq (↑a) 0) (Dvd.dvd b a)","decl":"theorem natCast_zmod_eq_zero_iff_dvd (a b : ℕ) : (a : ZMod b) = 0 ↔ b ∣ a := by\n  rw [← Nat.cast_zero, ZMod.natCast_eq_natCast_iff, Nat.modEq_zero_iff_dvd]\n\n"}
{"name":"ZMod.coe_intCast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : Int\n⊢ Eq (↑a).cast (HMod.hMod a ↑n)","decl":"theorem coe_intCast (a : ℤ) : cast (a : ZMod n) = a % n := by\n  cases n\n  · rw [Int.ofNat_zero, Int.emod_zero, Int.cast_id]; rfl\n  · rw [← val_intCast, val]; rfl\n\n"}
{"name":"ZMod.intCast_cast_add","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx y : ZMod n\n⊢ Eq (HAdd.hAdd x y).cast (HMod.hMod (HAdd.hAdd x.cast y.cast) ↑n)","decl":"lemma intCast_cast_add (x y : ZMod n) : (cast (x + y) : ℤ) = (cast x + cast y) % n := by\n  rw [← ZMod.coe_intCast, Int.cast_add, ZMod.intCast_zmod_cast, ZMod.intCast_zmod_cast]\n\n"}
{"name":"ZMod.intCast_cast_mul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx y : ZMod n\n⊢ Eq (HMul.hMul x y).cast (HMod.hMod (HMul.hMul x.cast y.cast) ↑n)","decl":"lemma intCast_cast_mul (x y : ZMod n) : (cast (x * y) : ℤ) = cast x * cast y % n := by\n  rw [← ZMod.coe_intCast, Int.cast_mul, ZMod.intCast_zmod_cast, ZMod.intCast_zmod_cast]\n\n"}
{"name":"ZMod.intCast_cast_sub","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx y : ZMod n\n⊢ Eq (HSub.hSub x y).cast (HMod.hMod (HSub.hSub x.cast y.cast) ↑n)","decl":"lemma intCast_cast_sub (x y : ZMod n) : (cast (x - y) : ℤ) = (cast x - cast y) % n := by\n  rw [← ZMod.coe_intCast, Int.cast_sub, ZMod.intCast_zmod_cast, ZMod.intCast_zmod_cast]\n\n"}
{"name":"ZMod.intCast_cast_neg","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx : ZMod n\n⊢ Eq (Neg.neg x).cast (HMod.hMod (Neg.neg x.cast) ↑n)","decl":"lemma intCast_cast_neg (x : ZMod n) : (cast (-x) : ℤ) = -cast x % n := by\n  rw [← ZMod.coe_intCast, Int.cast_neg, ZMod.intCast_zmod_cast]\n\n"}
{"name":"ZMod.val_neg_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (-1).val n","decl":"@[simp]\ntheorem val_neg_one (n : ℕ) : (-1 : ZMod n.succ).val = n := by\n  dsimp [val, Fin.coe_neg]\n  cases n\n  · simp [Nat.mod_one]\n  · dsimp [ZMod, ZMod.cast]\n    rw [Fin.coe_neg_one]\n\n"}
{"name":"ZMod.cast_neg_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\n⊢ Eq (-1).cast (HSub.hSub (↑n) 1)","decl":"/-- `-1 : ZMod n` lifts to `n - 1 : R`. This avoids the characteristic assumption in `cast_neg`. -/\ntheorem cast_neg_one {R : Type*} [Ring R] (n : ℕ) : cast (-1 : ZMod n) = (n - 1 : R) := by\n  cases' n with n\n  · dsimp [ZMod, ZMod.cast]; simp\n  · rw [← natCast_val, val_neg_one, Nat.cast_succ, add_sub_cancel_right]\n\n"}
{"name":"ZMod.cast_sub_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\nk : ZMod n\n⊢ Eq (HSub.hSub k 1).cast (HSub.hSub (ite (Eq k 0) (↑n) k.cast) 1)","decl":"theorem cast_sub_one {R : Type*} [Ring R] {n : ℕ} (k : ZMod n) :\n    (cast (k - 1 : ZMod n) : R) = (if k = 0 then (n : R) else cast k) - 1 := by\n  split_ifs with hk\n  · rw [hk, zero_sub, ZMod.cast_neg_one]\n  · cases n\n    · dsimp [ZMod, ZMod.cast]\n      rw [Int.cast_sub, Int.cast_one]\n    · dsimp [ZMod, ZMod.cast, ZMod.val]\n      rw [Fin.coe_sub_one, if_neg]\n      · rw [Nat.cast_sub, Nat.cast_one]\n        rwa [Fin.ext_iff, Fin.val_zero, ← Ne, ← Nat.one_le_iff_ne_zero] at hk\n      · exact hk\n\n"}
{"name":"ZMod.natCast_eq_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"p n : Nat\nz : ZMod p\ninst✝ : NeZero p\n⊢ Iff (Eq (↑n) z) (Exists fun k => Eq n (HAdd.hAdd z.val (HMul.hMul p k)))","decl":"theorem natCast_eq_iff (p : ℕ) (n : ℕ) (z : ZMod p) [NeZero p] :\n    ↑n = z ↔ ∃ k, n = z.val + p * k := by\n  constructor\n  · rintro rfl\n    refine ⟨n / p, ?_⟩\n    rw [val_natCast, Nat.mod_add_div]\n  · rintro ⟨k, rfl⟩\n    rw [Nat.cast_add, natCast_zmod_val, Nat.cast_mul, natCast_self, zero_mul,\n      add_zero]\n\n"}
{"name":"ZMod.intCast_eq_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"p : Nat\nn : Int\nz : ZMod p\ninst✝ : NeZero p\n⊢ Iff (Eq (↑n) z) (Exists fun k => Eq n (HAdd.hAdd (↑z.val) (HMul.hMul (↑p) k)))","decl":"theorem intCast_eq_iff (p : ℕ) (n : ℤ) (z : ZMod p) [NeZero p] :\n    ↑n = z ↔ ∃ k, n = z.val + p * k := by\n  constructor\n  · rintro rfl\n    refine ⟨n / p, ?_⟩\n    rw [val_intCast, Int.emod_add_ediv]\n  · rintro ⟨k, rfl⟩\n    rw [Int.cast_add, Int.cast_mul, Int.cast_natCast, Int.cast_natCast, natCast_val,\n      ZMod.natCast_self, zero_mul, add_zero, cast_id]\n\n"}
{"name":"ZMod.intCast_mod","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : Int\nb : Nat\n⊢ Eq ↑(HMod.hMod a ↑b) ↑a","decl":"@[push_cast, simp]\ntheorem intCast_mod (a : ℤ) (b : ℕ) : ((a % b : ℤ) : ZMod b) = (a : ZMod b) := by\n  rw [ZMod.intCast_eq_intCast_iff]\n  apply Int.mod_modEq\n\n"}
{"name":"ZMod.ker_intCastAddHom","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (Int.castAddHom (ZMod n)).ker (AddSubgroup.zmultiples ↑n)","decl":"theorem ker_intCastAddHom (n : ℕ) :\n    (Int.castAddHom (ZMod n)).ker = AddSubgroup.zmultiples (n : ℤ) := by\n  ext\n  rw [Int.mem_zmultiples_iff, AddMonoidHom.mem_ker, Int.coe_castAddHom,\n    intCast_zmod_eq_zero_iff_dvd]\n\n"}
{"name":"ZMod.cast_injective_of_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\nnzm : NeZero m\nh : LE.le m n\n⊢ Function.Injective ZMod.cast","decl":"theorem cast_injective_of_le {m n : ℕ} [nzm : NeZero m] (h : m ≤ n) :\n    Function.Injective (@cast (ZMod n) _ m) := by\n  cases m with\n  | zero => cases nzm; simp_all\n  | succ m =>\n    rintro ⟨x, hx⟩ ⟨y, hy⟩ f\n    simp only [cast, val, natCast_eq_natCast_iff',\n      Nat.mod_eq_of_lt (hx.trans_le h), Nat.mod_eq_of_lt (hy.trans_le h)] at f\n    apply Fin.ext\n    exact f\n\n"}
{"name":"ZMod.cast_zmod_eq_zero_iff_of_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\ninst✝ : NeZero m\nh : LE.le m n\na : ZMod m\n⊢ Iff (Eq a.cast 0) (Eq a 0)","decl":"theorem cast_zmod_eq_zero_iff_of_le {m n : ℕ} [NeZero m] (h : m ≤ n) (a : ZMod m) :\n    (cast a : ZMod n) = 0 ↔ a = 0 := by\n  rw [← ZMod.cast_zero (n := m)]\n  exact Injective.eq_iff' (cast_injective_of_le h) rfl\n\n-- Porting note: commented\n-- unseal Int.NonNeg\n\n"}
{"name":"ZMod.natCast_toNat","module":"Mathlib.Data.ZMod.Basic","initialProofState":"p : Nat\nz : Int\n_h : LE.le 0 z\n⊢ Eq ↑z.toNat ↑z","decl":"@[simp]\ntheorem natCast_toNat (p : ℕ) : ∀ {z : ℤ} (_h : 0 ≤ z), (z.toNat : ZMod p) = z\n  | (n : ℕ), _h => by simp only [Int.cast_natCast, Int.toNat_natCast]\n  | Int.negSucc n, h => by simp at h\n\n"}
{"name":"ZMod.val_injective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Function.Injective ZMod.val","decl":"theorem val_injective (n : ℕ) [NeZero n] : Function.Injective (val : ZMod n → ℕ) := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  intro a b h\n  dsimp [ZMod]\n  ext\n  exact h\n\n"}
{"name":"ZMod.val_one_eq_one_mod","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (ZMod.val 1) (HMod.hMod 1 n)","decl":"theorem val_one_eq_one_mod (n : ℕ) : (1 : ZMod n).val = 1 % n := by\n  rw [← Nat.cast_one, val_natCast]\n\n"}
{"name":"ZMod.val_two_eq_two_mod","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (ZMod.val 2) (HMod.hMod 2 n)","decl":"theorem val_two_eq_two_mod (n : ℕ) : (2 : ZMod n).val = 2 % n := by\n  rw [← Nat.cast_two, val_natCast]\n\n"}
{"name":"ZMod.val_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : Fact (LT.lt 1 n)\n⊢ Eq (ZMod.val 1) 1","decl":"theorem val_one (n : ℕ) [Fact (1 < n)] : (1 : ZMod n).val = 1 := by\n  rw [val_one_eq_one_mod]\n  exact Nat.mod_eq_of_lt Fact.out\n\n"}
{"name":"ZMod.val_one''","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na✝ : Ne n 1\n⊢ Eq (ZMod.val 1) 1","decl":"lemma val_one'' : ∀ {n}, n ≠ 1 → (1 : ZMod n).val = 1\n  | 0, _ => rfl\n  | 1, hn => by cases hn rfl\n  | n + 2, _ =>\n    haveI : Fact (1 < n + 2) := ⟨by simp⟩\n    ZMod.val_one _\n\n"}
{"name":"ZMod.val_add","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na b : ZMod n\n⊢ Eq (HAdd.hAdd a b).val (HMod.hMod (HAdd.hAdd a.val b.val) n)","decl":"theorem val_add {n : ℕ} [NeZero n] (a b : ZMod n) : (a + b).val = (a.val + b.val) % n := by\n  cases n\n  · cases NeZero.ne 0 rfl\n  · apply Fin.val_add\n\n"}
{"name":"ZMod.val_add_of_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\nh : LT.lt (HAdd.hAdd a.val b.val) n\n⊢ Eq (HAdd.hAdd a b).val (HAdd.hAdd a.val b.val)","decl":"theorem val_add_of_lt {n : ℕ} {a b : ZMod n} (h : a.val + b.val < n) :\n    (a + b).val = a.val + b.val := by\n  have : NeZero n := by constructor; rintro rfl; simp at h\n  rw [ZMod.val_add, Nat.mod_eq_of_lt h]\n\n"}
{"name":"ZMod.val_add_val_of_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na b : ZMod n\nh : LE.le n (HAdd.hAdd a.val b.val)\n⊢ Eq (HAdd.hAdd a.val b.val) (HAdd.hAdd (HAdd.hAdd a b).val n)","decl":"theorem val_add_val_of_le {n : ℕ} [NeZero n] {a b : ZMod n} (h : n ≤ a.val + b.val) :\n    a.val + b.val = (a + b).val + n := by\n  rw [val_add, Nat.add_mod_add_of_le_add_mod, Nat.mod_eq_of_lt (val_lt _),\n    Nat.mod_eq_of_lt (val_lt _)]\n  rwa [Nat.mod_eq_of_lt (val_lt _), Nat.mod_eq_of_lt (val_lt _)]\n\n"}
{"name":"ZMod.val_add_of_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na b : ZMod n\nh : LE.le n (HAdd.hAdd a.val b.val)\n⊢ Eq (HAdd.hAdd a b).val (HSub.hSub (HAdd.hAdd a.val b.val) n)","decl":"theorem val_add_of_le {n : ℕ} [NeZero n] {a b : ZMod n} (h : n ≤ a.val + b.val) :\n    (a + b).val = a.val + b.val - n := by\n  rw [val_add_val_of_le h]\n  exact eq_tsub_of_add_eq rfl\n\n"}
{"name":"ZMod.val_add_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\n⊢ LE.le (HAdd.hAdd a b).val (HAdd.hAdd a.val b.val)","decl":"theorem val_add_le {n : ℕ} (a b : ZMod n) : (a + b).val ≤ a.val + b.val := by\n  cases n\n  · simpa [ZMod.val] using Int.natAbs_add_le _ _\n  · simpa [ZMod.val_add] using Nat.mod_le _ _\n\n"}
{"name":"ZMod.val_mul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\n⊢ Eq (HMul.hMul a b).val (HMod.hMod (HMul.hMul a.val b.val) n)","decl":"theorem val_mul {n : ℕ} (a b : ZMod n) : (a * b).val = a.val * b.val % n := by\n  cases n\n  · rw [Nat.mod_zero]\n    apply Int.natAbs_mul\n  · apply Fin.val_mul\n\n"}
{"name":"ZMod.val_mul_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\n⊢ LE.le (HMul.hMul a b).val (HMul.hMul a.val b.val)","decl":"theorem val_mul_le {n : ℕ} (a b : ZMod n) : (a * b).val ≤ a.val * b.val := by\n  rw [val_mul]\n  apply Nat.mod_le\n\n"}
{"name":"ZMod.val_mul_of_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\nh : LT.lt (HMul.hMul a.val b.val) n\n⊢ Eq (HMul.hMul a b).val (HMul.hMul a.val b.val)","decl":"theorem val_mul_of_lt {n : ℕ} {a b : ZMod n} (h : a.val * b.val < n) :\n    (a * b).val = a.val * b.val := by\n  rw [val_mul]\n  apply Nat.mod_eq_of_lt h\n\n"}
{"name":"ZMod.val_mul_iff_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na b : ZMod n\n⊢ Iff (Eq (HMul.hMul a b).val (HMul.hMul a.val b.val)) (LT.lt (HMul.hMul a.val b.val) n)","decl":"theorem val_mul_iff_lt {n : ℕ} [NeZero n] (a b : ZMod n) :\n    (a * b).val = a.val * b.val ↔ a.val * b.val < n := by\n  constructor <;> intro h\n  · rw [← h]; apply ZMod.val_lt\n  · apply ZMod.val_mul_of_lt h\n\n"}
{"name":"ZMod.nontrivial","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : Fact (LT.lt 1 n)\n⊢ Nontrivial (ZMod n)","decl":"instance nontrivial (n : ℕ) [Fact (1 < n)] : Nontrivial (ZMod n) :=\n  ⟨⟨0, 1, fun h =>\n      zero_ne_one <|\n        calc\n          0 = (0 : ZMod n).val := by rw [val_zero]\n          _ = (1 : ZMod n).val := congr_arg ZMod.val h\n          _ = 1 := val_one n\n          ⟩⟩\n\n"}
{"name":"ZMod.nontrivial'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"⊢ Nontrivial (ZMod 0)","decl":"instance nontrivial' : Nontrivial (ZMod 0) := by\n  delta ZMod; infer_instance\n\n"}
{"name":"ZMod.inv_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (Inv.inv 0) 0","decl":"theorem inv_zero : ∀ n : ℕ, (0 : ZMod n)⁻¹ = 0\n  | 0 => Int.sign_zero\n  | n + 1 =>\n    show (Nat.gcdA _ (n + 1) : ZMod (n + 1)) = 0 by\n      rw [val_zero]\n      unfold Nat.gcdA Nat.xgcd Nat.xgcdAux\n      rfl\n\n"}
{"name":"ZMod.mul_inv_eq_gcd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Eq (HMul.hMul a (Inv.inv a)) ↑(a.val.gcd n)","decl":"theorem mul_inv_eq_gcd {n : ℕ} (a : ZMod n) : a * a⁻¹ = Nat.gcd a.val n := by\n  cases' n with n\n  · dsimp [ZMod] at a ⊢\n    calc\n      _ = a * Int.sign a := rfl\n      _ = a.natAbs := by rw [Int.mul_sign]\n      _ = a.natAbs.gcd 0 := by rw [Nat.gcd_zero_right]\n  · calc\n      a * a⁻¹ = a * a⁻¹ + n.succ * Nat.gcdB (val a) n.succ := by\n        rw [natCast_self, zero_mul, add_zero]\n      _ = ↑(↑a.val * Nat.gcdA (val a) n.succ + n.succ * Nat.gcdB (val a) n.succ) := by\n        push_cast\n        rw [natCast_zmod_val]\n        rfl\n      _ = Nat.gcd a.val n.succ := by rw [← Nat.gcd_eq_gcd_ab a.val n.succ]; rfl\n\n"}
{"name":"ZMod.inv_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (Inv.inv 1) 1","decl":"@[simp] protected lemma inv_one (n : ℕ) : (1⁻¹ : ZMod n) = 1 := by\n  obtain rfl | hn := eq_or_ne n 1\n  · exact Subsingleton.elim _ _\n  · simpa [ZMod.val_one'' hn] using mul_inv_eq_gcd (1 : ZMod n)\n\n"}
{"name":"ZMod.natCast_mod","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a n : Nat\n⊢ Eq ↑(HMod.hMod a n) ↑a","decl":"@[simp]\ntheorem natCast_mod (a : ℕ) (n : ℕ) : ((a % n : ℕ) : ZMod n) = a := by\n  conv =>\n      rhs\n      rw [← Nat.mod_add_div a n]\n  simp\n\n"}
{"name":"ZMod.eq_iff_modEq_nat","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n a b : Nat\n⊢ Iff (Eq ↑a ↑b) (n.ModEq a b)","decl":"theorem eq_iff_modEq_nat (n : ℕ) {a b : ℕ} : (a : ZMod n) = b ↔ a ≡ b [MOD n] := by\n  cases n\n  · simp [Nat.ModEq, Int.natCast_inj, Nat.mod_zero]\n  · rw [Fin.ext_iff, Nat.ModEq, ← val_natCast, ← val_natCast]\n    exact Iff.rfl\n\n"}
{"name":"ZMod.eq_zero_iff_even","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 0) (Even n)","decl":"theorem eq_zero_iff_even {n : ℕ} : (n : ZMod 2) = 0 ↔ Even n :=\n  (CharP.cast_eq_zero_iff (ZMod 2) 2 n).trans even_iff_two_dvd.symm\n\n"}
{"name":"ZMod.eq_one_iff_odd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 1) (Odd n)","decl":"theorem eq_one_iff_odd {n : ℕ} : (n : ZMod 2) = 1 ↔ Odd n := by\n  rw [← @Nat.cast_one (ZMod 2), ZMod.eq_iff_modEq_nat, Nat.odd_iff, Nat.ModEq]\n\n"}
{"name":"ZMod.ne_zero_iff_odd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Iff (Ne (↑n) 0) (Odd n)","decl":"theorem ne_zero_iff_odd {n : ℕ} : (n : ZMod 2) ≠ 0 ↔ Odd n := by\n  constructor <;>\n    · contrapose\n      simp [eq_zero_iff_even]\n\n"}
{"name":"ZMod.coe_mul_inv_eq_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n x : Nat\nh : x.Coprime n\n⊢ Eq (HMul.hMul (↑x) (Inv.inv ↑x)) 1","decl":"theorem coe_mul_inv_eq_one {n : ℕ} (x : ℕ) (h : Nat.Coprime x n) :\n    ((x : ZMod n) * (x : ZMod n)⁻¹) = 1 := by\n  rw [Nat.Coprime, Nat.gcd_comm, Nat.gcd_rec] at h\n  rw [mul_inv_eq_gcd, val_natCast, h, Nat.cast_one]\n\n"}
{"name":"ZMod.mul_val_inv","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\nhmn : m.Coprime n\n⊢ Eq (HMul.hMul ↑m ↑(Inv.inv ↑m).val) 1","decl":"lemma mul_val_inv (hmn : m.Coprime n) : (m * (m⁻¹ : ZMod n).val : ZMod n) = 1 := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp [m.coprime_zero_right.1 hmn]\n  haveI : NeZero n := ⟨hn⟩\n  rw [ZMod.natCast_zmod_val, ZMod.coe_mul_inv_eq_one _ hmn]\n\n"}
{"name":"ZMod.val_inv_mul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\nhmn : m.Coprime n\n⊢ Eq (HMul.hMul ↑(Inv.inv ↑m).val ↑m) 1","decl":"lemma val_inv_mul (hmn : m.Coprime n) : ((m⁻¹ : ZMod n).val * m : ZMod n) = 1 := by\n  rw [mul_comm, mul_val_inv hmn]\n\n"}
{"name":"ZMod.coe_unitOfCoprime","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n x : Nat\nh : x.Coprime n\n⊢ Eq ↑(ZMod.unitOfCoprime x h) ↑x","decl":"@[simp]\ntheorem coe_unitOfCoprime {n : ℕ} (x : ℕ) (h : Nat.Coprime x n) :\n    (unitOfCoprime x h : ZMod n) = x :=\n  rfl\n\n"}
{"name":"ZMod.val_coe_unit_coprime","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nu : Units (ZMod n)\n⊢ (↑u).val.Coprime n","decl":"theorem val_coe_unit_coprime {n : ℕ} (u : (ZMod n)ˣ) : Nat.Coprime (u : ZMod n).val n := by\n  cases' n with n\n  · rcases Int.units_eq_one_or u with (rfl | rfl) <;> simp\n  apply Nat.coprime_of_mul_modEq_one ((u⁻¹ : Units (ZMod (n + 1))) : ZMod (n + 1)).val\n  have := Units.ext_iff.1 (mul_inv_cancel u)\n  rw [Units.val_one] at this\n  rw [← eq_iff_modEq_nat, Nat.cast_one, ← this]; clear this\n  rw [← natCast_zmod_val ((u * u⁻¹ : Units (ZMod (n + 1))) : ZMod (n + 1))]\n  rw [Units.val_mul, val_mul, natCast_mod]\n\n"}
{"name":"ZMod.isUnit_iff_coprime","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\n⊢ Iff (IsUnit ↑m) (m.Coprime n)","decl":"lemma isUnit_iff_coprime (m n : ℕ) : IsUnit (m : ZMod n) ↔ m.Coprime n := by\n  refine ⟨fun H ↦ ?_, fun H ↦ (unitOfCoprime m H).isUnit⟩\n  have H' := val_coe_unit_coprime H.unit\n  rw [IsUnit.unit_spec, val_natCast m, Nat.coprime_iff_gcd_eq_one] at H'\n  rw [Nat.coprime_iff_gcd_eq_one, Nat.gcd_comm, ← H']\n  exact Nat.gcd_rec n m\n\n"}
{"name":"ZMod.isUnit_prime_iff_not_dvd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\n⊢ Iff (IsUnit ↑p) (Not (Dvd.dvd p n))","decl":"lemma isUnit_prime_iff_not_dvd {n p : ℕ} (hp : p.Prime) : IsUnit (p : ZMod n) ↔ ¬p ∣ n := by\n  rw [isUnit_iff_coprime, Nat.Prime.coprime_iff_not_dvd hp]\n\n"}
{"name":"ZMod.isUnit_prime_of_not_dvd","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n p : Nat\nhp : Nat.Prime p\nh : Not (Dvd.dvd p n)\n⊢ IsUnit ↑p","decl":"lemma isUnit_prime_of_not_dvd {n p : ℕ} (hp : p.Prime) (h : ¬ p ∣ n) : IsUnit (p : ZMod n) :=\n  (isUnit_prime_iff_not_dvd hp).mpr h\n\n"}
{"name":"ZMod.inv_coe_unit","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nu : Units (ZMod n)\n⊢ Eq (Inv.inv ↑u) ↑(Inv.inv u)","decl":"@[simp]\ntheorem inv_coe_unit {n : ℕ} (u : (ZMod n)ˣ) : (u : ZMod n)⁻¹ = (u⁻¹ : (ZMod n)ˣ) := by\n  have := congr_arg ((↑) : ℕ → ZMod n) (val_coe_unit_coprime u)\n  rw [← mul_inv_eq_gcd, Nat.cast_one] at this\n  let u' : (ZMod n)ˣ := ⟨u, (u : ZMod n)⁻¹, this, by rwa [mul_comm]⟩\n  have h : u = u' := by\n    apply Units.ext\n    rfl\n  rw [h]\n  rfl\n\n"}
{"name":"ZMod.mul_inv_of_unit","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\nh : IsUnit a\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"theorem mul_inv_of_unit {n : ℕ} (a : ZMod n) (h : IsUnit a) : a * a⁻¹ = 1 := by\n  rcases h with ⟨u, rfl⟩\n  rw [inv_coe_unit, u.mul_inv]\n\n"}
{"name":"ZMod.inv_mul_of_unit","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\nh : IsUnit a\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"theorem inv_mul_of_unit {n : ℕ} (a : ZMod n) (h : IsUnit a) : a⁻¹ * a = 1 := by\n  rw [mul_comm, mul_inv_of_unit a h]\n\n-- TODO: If we changed `⁻¹` so that `ZMod n` is always a `DivisionMonoid`,\n-- then we could use the general lemma `inv_eq_of_mul_eq_one`\n"}
{"name":"ZMod.inv_eq_of_mul_eq_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na b : ZMod n\nh : Eq (HMul.hMul a b) 1\n⊢ Eq (Inv.inv a) b","decl":"protected theorem inv_eq_of_mul_eq_one (n : ℕ) (a b : ZMod n) (h : a * b = 1) : a⁻¹ = b :=\n  left_inv_eq_right_inv (inv_mul_of_unit a ⟨⟨a, b, h, mul_comm a b ▸ h⟩, rfl⟩) h\n\n"}
{"name":"ZMod.inv_mul_eq_one_of_isUnit","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\nha : IsUnit a\nb : ZMod n\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) 1) (Eq a b)","decl":"lemma inv_mul_eq_one_of_isUnit {n : ℕ} {a : ZMod n} (ha : IsUnit a) (b : ZMod n) :\n    a⁻¹ * b = 1 ↔ a = b := by\n  -- ideally, this would be `ha.inv_mul_eq_one`, but `ZMod n` is not a `DivisionMonoid`...\n  -- (see the \"TODO\" above)\n  refine ⟨fun H ↦ ?_, fun H ↦ H ▸ a.inv_mul_of_unit ha⟩\n  apply_fun (a * ·) at H\n  rwa [← mul_assoc, a.mul_inv_of_unit ha, one_mul, mul_one, eq_comm] at H\n\n-- TODO: this equivalence is true for `ZMod 0 = ℤ`, but needs to use different functions.\n"}
{"name":"ZMod.subsingleton_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Iff (Subsingleton (ZMod n)) (Eq n 1)","decl":"lemma subsingleton_iff {n : ℕ} : Subsingleton (ZMod n) ↔ n = 1 := by\n  constructor\n  · obtain (_ | _ | n) := n\n    · simpa [ZMod] using not_subsingleton _\n    · simp [ZMod]\n    · simpa [ZMod] using not_subsingleton _\n  · rintro rfl\n    infer_instance\n\n"}
{"name":"ZMod.nontrivial_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Iff (Nontrivial (ZMod n)) (Ne n 1)","decl":"lemma nontrivial_iff {n : ℕ} : Nontrivial (ZMod n) ↔ n ≠ 1 := by\n  rw [← not_subsingleton_iff_nontrivial, subsingleton_iff]\n\n-- todo: this can be made a `Unique` instance.\n"}
{"name":"ZMod.subsingleton_units","module":"Mathlib.Data.ZMod.Basic","initialProofState":"⊢ Subsingleton (Units (ZMod 2))","decl":"instance subsingleton_units : Subsingleton (ZMod 2)ˣ :=\n  ⟨by decide⟩\n\n"}
{"name":"ZMod.add_self_eq_zero_iff_eq_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nhn : Odd n\na : ZMod n\n⊢ Iff (Eq (HAdd.hAdd a a) 0) (Eq a 0)","decl":"@[simp]\ntheorem add_self_eq_zero_iff_eq_zero {n : ℕ} (hn : Odd n) {a : ZMod n} :\n    a + a = 0 ↔ a = 0 := by\n  rw [Nat.odd_iff, ← Nat.two_dvd_ne_zero, ← Nat.prime_two.coprime_iff_not_dvd] at hn\n  rw [← mul_two, ← @Nat.cast_two (ZMod n), ← ZMod.coe_unitOfCoprime 2 hn, Units.mul_left_eq_zero]\n\n"}
{"name":"ZMod.ne_neg_self","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nhn : Odd n\na : ZMod n\nha : Ne a 0\n⊢ Ne a (Neg.neg a)","decl":"theorem ne_neg_self {n : ℕ} (hn : Odd n) {a : ZMod n} (ha : a ≠ 0) : a ≠ -a := by\n  rwa [Ne, eq_neg_iff_add_eq_zero, add_self_eq_zero_iff_eq_zero hn]\n\n"}
{"name":"ZMod.neg_one_ne_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : Fact (LT.lt 2 n)\n⊢ Ne (-1) 1","decl":"theorem neg_one_ne_one {n : ℕ} [Fact (2 < n)] : (-1 : ZMod n) ≠ 1 :=\n  CharP.neg_one_ne_one (ZMod n) n\n\n"}
{"name":"ZMod.neg_eq_self_mod_two","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : ZMod 2\n⊢ Eq (Neg.neg a) a","decl":"theorem neg_eq_self_mod_two (a : ZMod 2) : -a = a := by\n  fin_cases a <;> apply Fin.ext <;> simp [Fin.coe_neg, Int.natMod]; rfl\n\n"}
{"name":"ZMod.natAbs_mod_two","module":"Mathlib.Data.ZMod.Basic","initialProofState":"a : Int\n⊢ Eq ↑a.natAbs ↑a","decl":"@[simp]\ntheorem natAbs_mod_two (a : ℤ) : (a.natAbs : ZMod 2) = a := by\n  cases a\n  · simp only [Int.natAbs_ofNat, Int.cast_natCast, Int.ofNat_eq_coe]\n  · simp only [neg_eq_self_mod_two, Nat.cast_succ, Int.natAbs, Int.cast_negSucc]\n\n"}
{"name":"ZMod.val_ne_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Iff (Ne a.val 0) (Ne a 0)","decl":"theorem val_ne_zero {n : ℕ} (a : ZMod n) : a.val ≠ 0 ↔ a ≠ 0 :=\n  (val_eq_zero a).not\n\n"}
{"name":"ZMod.val_pos","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Iff (LT.lt 0 a.val) (Ne a 0)","decl":"theorem val_pos {n : ℕ} {a : ZMod n} : 0 < a.val ↔ a ≠ 0 := by\n  simp [pos_iff_ne_zero]\n\n"}
{"name":"ZMod.val_eq_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx✝ : LT.lt 1 n\na : ZMod n\n⊢ Iff (Eq a.val 1) (Eq a 1)","decl":"theorem val_eq_one : ∀ {n : ℕ} (_ : 1 < n) (a : ZMod n), a.val = 1 ↔ a = 1\n  | 0, hn, _\n  | 1, hn, _ => by simp at hn\n  | n + 2, _, _ => by simp only [val, ZMod, Fin.ext_iff, Fin.val_one]\n\n"}
{"name":"ZMod.neg_eq_self_iff","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\na : ZMod n\n⊢ Iff (Eq (Neg.neg a) a) (Or (Eq a 0) (Eq (HMul.hMul 2 a.val) n))","decl":"theorem neg_eq_self_iff {n : ℕ} (a : ZMod n) : -a = a ↔ a = 0 ∨ 2 * a.val = n := by\n  rw [neg_eq_iff_add_eq_zero, ← two_mul]\n  cases n\n  · rw [@mul_eq_zero ℤ, @mul_eq_zero ℕ, val_eq_zero]\n    exact\n      ⟨fun h => h.elim (by simp) Or.inl, fun h =>\n        Or.inr (h.elim id fun h => h.elim (by simp) id)⟩\n  conv_lhs =>\n    rw [← a.natCast_zmod_val, ← Nat.cast_two, ← Nat.cast_mul, natCast_zmod_eq_zero_iff_dvd]\n  constructor\n  · rintro ⟨m, he⟩\n    cases' m with m\n    · rw [mul_zero, mul_eq_zero] at he\n      rcases he with (⟨⟨⟩⟩ | he)\n      exact Or.inl (a.val_eq_zero.1 he)\n    cases m\n    · right\n      rwa [show 0 + 1 = 1 from rfl, mul_one] at he\n    refine (a.val_lt.not_le <| Nat.le_of_mul_le_mul_left ?_ zero_lt_two).elim\n    rw [he, mul_comm]\n    apply Nat.mul_le_mul_left\n    simp\n  · rintro (rfl | h)\n    · rw [val_zero, mul_zero]\n      apply dvd_zero\n    · rw [h]\n\n"}
{"name":"ZMod.val_cast_of_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n a : Nat\nh : LT.lt a n\n⊢ Eq (↑a).val a","decl":"theorem val_cast_of_lt {n : ℕ} {a : ℕ} (h : a < n) : (a : ZMod n).val = a := by\n  rw [val_natCast, Nat.mod_eq_of_lt h]\n\n"}
{"name":"ZMod.val_cast_zmod_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m : Nat\ninst✝¹ : NeZero m\nn : Nat\ninst✝ : NeZero n\na : ZMod m\n⊢ LT.lt a.cast.val m","decl":"theorem val_cast_zmod_lt {m : ℕ} [NeZero m] (n : ℕ) [NeZero n] (a : ZMod m) :\n    (a.cast : ZMod n).val < m := by\n  rcases m with (⟨⟩|⟨m⟩); · cases NeZero.ne 0 rfl\n  by_cases h : m < n\n  · rcases n with (⟨⟩|⟨n⟩); · simp at h\n    rw [← natCast_val, val_cast_of_lt]\n    · apply a.val_lt\n    apply lt_of_le_of_lt (Nat.le_of_lt_succ (ZMod.val_lt a)) h\n  · rw [not_lt] at h\n    apply lt_of_lt_of_le (ZMod.val_lt _) (le_trans h (Nat.le_succ m))\n\n"}
{"name":"ZMod.neg_val'","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq (Neg.neg a).val (HMod.hMod (HSub.hSub n a.val) n)","decl":"theorem neg_val' {n : ℕ} [NeZero n] (a : ZMod n) : (-a).val = (n - a.val) % n :=\n  calc\n    (-a).val = val (-a) % n := by rw [Nat.mod_eq_of_lt (-a).val_lt]\n    _ = (n - val a) % n :=\n      Nat.ModEq.add_right_cancel' (val a)\n        (by\n          rw [Nat.ModEq, ← val_add, neg_add_cancel, tsub_add_cancel_of_le a.val_le, Nat.mod_self,\n            val_zero])\n\n"}
{"name":"ZMod.neg_val","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq (Neg.neg a).val (ite (Eq a 0) 0 (HSub.hSub n a.val))","decl":"theorem neg_val {n : ℕ} [NeZero n] (a : ZMod n) : (-a).val = if a = 0 then 0 else n - a.val := by\n  rw [neg_val']\n  by_cases h : a = 0; · rw [if_pos h, h, val_zero, tsub_zero, Nat.mod_self]\n  rw [if_neg h]\n  apply Nat.mod_eq_of_lt\n  apply Nat.sub_lt (NeZero.pos n)\n  contrapose! h\n  rwa [Nat.le_zero, val_eq_zero] at h\n\n"}
{"name":"ZMod.val_neg_of_ne_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nnz : NeZero n\na : ZMod n\nna : NeZero a\n⊢ Eq (Neg.neg a).val (HSub.hSub n a.val)","decl":"theorem val_neg_of_ne_zero {n : ℕ} [nz : NeZero n] (a : ZMod n) [na : NeZero a] :\n    (- a).val = n - a.val := by simp_all [neg_val a, na.out]\n\n"}
{"name":"ZMod.val_sub","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na b : ZMod n\nh : LE.le b.val a.val\n⊢ Eq (HSub.hSub a b).val (HSub.hSub a.val b.val)","decl":"theorem val_sub {n : ℕ} [NeZero n] {a b : ZMod n} (h : b.val ≤ a.val) :\n    (a - b).val = a.val - b.val := by\n  by_cases hb : b = 0\n  · cases hb; simp\n  · have : NeZero b := ⟨hb⟩\n    rw [sub_eq_add_neg, val_add, val_neg_of_ne_zero, ← Nat.add_sub_assoc (le_of_lt (val_lt _)),\n      add_comm, Nat.add_sub_assoc h, Nat.add_mod_left]\n    apply Nat.mod_eq_of_lt (tsub_lt_of_lt (val_lt _))\n\n"}
{"name":"ZMod.val_cast_eq_val_of_lt","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\nnzm : NeZero m\na : ZMod m\nh : LT.lt a.val n\n⊢ Eq a.cast.val a.val","decl":"theorem val_cast_eq_val_of_lt {m n : ℕ} [nzm : NeZero m] {a : ZMod m}\n    (h : a.val < n) : (a.cast : ZMod n).val = a.val := by\n  have nzn : NeZero n := by constructor; rintro rfl; simp at h\n  cases m with\n  | zero => cases nzm; simp_all\n  | succ m =>\n    cases n with\n    | zero => cases nzn; simp_all\n    | succ n => exact Fin.val_cast_of_lt h\n\n"}
{"name":"ZMod.cast_cast_zmod_of_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\nhm : NeZero m\nh : LE.le m n\na : ZMod m\n⊢ Eq a.cast.cast a","decl":"theorem cast_cast_zmod_of_le {m n : ℕ} [hm : NeZero m] (h : m ≤ n) (a : ZMod m) :\n    (cast (cast a : ZMod n) : ZMod m) = a := by\n  have : NeZero n := ⟨((Nat.zero_lt_of_ne_zero hm.out).trans_le h).ne'⟩\n  rw [cast_eq_val, val_cast_eq_val_of_lt (a.val_lt.trans_le h), natCast_zmod_val]\n\n"}
{"name":"ZMod.val_pow","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\na : ZMod n\nilt : Fact (LT.lt 1 n)\nh : LT.lt (HPow.hPow a.val m) n\n⊢ Eq (HPow.hPow a m).val (HPow.hPow a.val m)","decl":"theorem val_pow {m n : ℕ} {a : ZMod n} [ilt : Fact (1 < n)] (h : a.val ^ m < n) :\n    (a ^ m).val = a.val ^ m := by\n  induction m with\n  | zero => simp [ZMod.val_one]\n  | succ m ih =>\n    have : a.val ^ m < n := by\n      obtain rfl | ha := eq_or_ne a 0\n      · by_cases hm : m = 0\n        · cases hm; simp [ilt.out]\n        · simp only [val_zero, ne_eq, hm, not_false_eq_true, zero_pow, Nat.zero_lt_of_lt h]\n      · exact lt_of_le_of_lt\n         (Nat.pow_le_pow_of_le_right (by rwa [gt_iff_lt, ZMod.val_pos]) (Nat.le_succ m)) h\n    rw [pow_succ, ZMod.val_mul, ih this, ← pow_succ, Nat.mod_eq_of_lt h]\n\n"}
{"name":"ZMod.val_pow_le","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m n : Nat\ninst✝ : Fact (LT.lt 1 n)\na : ZMod n\n⊢ LE.le (HPow.hPow a m).val (HPow.hPow a.val m)","decl":"theorem val_pow_le {m n : ℕ} [Fact (1 < n)] {a : ZMod n} : (a ^ m).val ≤ a.val ^ m := by\n  induction m with\n  | zero => simp [ZMod.val_one]\n  | succ m ih =>\n    rw [pow_succ, pow_succ]\n    apply le_trans (ZMod.val_mul_le _ _)\n    apply Nat.mul_le_mul_right _ ih\n\n"}
{"name":"ZMod.natAbs_min_of_le_div_two","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nx y : Int\nhe : Eq ↑x ↑y\nhl : LE.le x.natAbs (HDiv.hDiv n 2)\n⊢ LE.le x.natAbs y.natAbs","decl":"theorem natAbs_min_of_le_div_two (n : ℕ) (x y : ℤ) (he : (x : ZMod n) = y) (hl : x.natAbs ≤ n / 2) :\n    x.natAbs ≤ y.natAbs := by\n  rw [intCast_eq_intCast_iff_dvd_sub] at he\n  obtain ⟨m, he⟩ := he\n  rw [sub_eq_iff_eq_add] at he\n  subst he\n  obtain rfl | hm := eq_or_ne m 0\n  · rw [mul_zero, zero_add]\n  apply hl.trans\n  rw [← add_le_add_iff_right x.natAbs]\n  refine le_trans (le_trans ((add_le_add_iff_left _).2 hl) ?_) (Int.natAbs_sub_le _ _)\n  rw [add_sub_cancel_right, Int.natAbs_mul, Int.natAbs_ofNat]\n  refine le_trans ?_ (Nat.le_mul_of_pos_right _ <| Int.natAbs_pos.2 hm)\n  rw [← mul_two]; apply Nat.div_mul_le_self\n\n"}
{"name":"ZMod.instIsDomain","module":"Mathlib.Data.ZMod.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsDomain (ZMod p)","decl":"/-- `ZMod p` is an integral domain when `p` is prime. -/\ninstance (p : ℕ) [hp : Fact p.Prime] : IsDomain (ZMod p) := by\n  -- We need `cases p` here in order to resolve which `CommRing` instance is being used.\n  cases p\n  · exact (Nat.not_prime_zero hp.out).elim\n  exact @Field.isDomain (ZMod _) (inferInstanceAs (Field (ZMod _)))\n\n"}
{"name":"RingHom.ext_zmod","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Semiring R\nf g : RingHom (ZMod n) R\n⊢ Eq f g","decl":"theorem RingHom.ext_zmod {n : ℕ} {R : Type*} [Semiring R] (f g : ZMod n →+* R) : f = g := by\n  ext a\n  obtain ⟨k, rfl⟩ := ZMod.intCast_surjective a\n  let φ : ℤ →+* R := f.comp (Int.castRingHom (ZMod n))\n  let ψ : ℤ →+* R := g.comp (Int.castRingHom (ZMod n))\n  show φ k = ψ k\n  rw [φ.ext_int ψ]\n\n"}
{"name":"ZMod.subsingleton_ringHom","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Semiring R\n⊢ Subsingleton (RingHom (ZMod n) R)","decl":"instance subsingleton_ringHom [Semiring R] : Subsingleton (ZMod n →+* R) :=\n  ⟨RingHom.ext_zmod⟩\n\n"}
{"name":"ZMod.subsingleton_ringEquiv","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Semiring R\n⊢ Subsingleton (RingEquiv (ZMod n) R)","decl":"instance subsingleton_ringEquiv [Semiring R] : Subsingleton (ZMod n ≃+* R) :=\n  ⟨fun f g => by\n    rw [RingEquiv.coe_ringHom_inj_iff]\n    apply RingHom.ext_zmod _ _⟩\n\n"}
{"name":"ZMod.ringHom_map_cast","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\nf : RingHom R (ZMod n)\nk : ZMod n\n⊢ Eq (f k.cast) k","decl":"@[simp]\ntheorem ringHom_map_cast [Ring R] (f : R →+* ZMod n) (k : ZMod n) : f (cast k) = k := by\n  cases n\n  · dsimp [ZMod, ZMod.cast] at f k ⊢; simp\n  · dsimp [ZMod, ZMod.cast] at f k ⊢\n    erw [map_natCast, Fin.cast_val_eq_self]\n\n"}
{"name":"ZMod.ringHom_rightInverse","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\nf : RingHom R (ZMod n)\n⊢ Function.RightInverse ZMod.cast ⇑f","decl":"/-- Any ring homomorphism into `ZMod n` has a right inverse. -/\ntheorem ringHom_rightInverse [Ring R] (f : R →+* ZMod n) :\n    Function.RightInverse (cast : ZMod n → R) f :=\n  ringHom_map_cast f\n\n"}
{"name":"ZMod.ringHom_surjective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nR : Type u_1\ninst✝ : Ring R\nf : RingHom R (ZMod n)\n⊢ Function.Surjective ⇑f","decl":"/-- Any ring homomorphism into `ZMod n` is surjective. -/\ntheorem ringHom_surjective [Ring R] (f : R →+* ZMod n) : Function.Surjective f :=\n  (ringHom_rightInverse f).surjective\n\n"}
{"name":"ZMod.castHom_self","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\n⊢ Eq (ZMod.castHom ⋯ (ZMod n)) (RingHom.id (ZMod n))","decl":"@[simp]\nlemma castHom_self : ZMod.castHom dvd_rfl (ZMod n) = RingHom.id (ZMod n) :=\n  Subsingleton.elim _ _\n\n"}
{"name":"ZMod.castHom_comp","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n m d : Nat\nhm : Dvd.dvd n m\nhd : Dvd.dvd m d\n⊢ Eq ((ZMod.castHom hm (ZMod n)).comp (ZMod.castHom hd (ZMod m))) (ZMod.castHom ⋯ (ZMod n))","decl":"@[simp]\nlemma castHom_comp {m d : ℕ} (hm : n ∣ m) (hd : m ∣ d) :\n    (castHom hm (ZMod n)).comp (castHom hd (ZMod m)) = castHom (dvd_trans hm hd) (ZMod n) :=\n  RingHom.ext_zmod _ _\n\n"}
{"name":"ZMod.lift_coe","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nA : Type u_2\ninst✝ : AddGroup A\nf : Subtype fun f => Eq (f ↑n) 0\nx : Int\n⊢ Eq (((ZMod.lift n) f) ↑x) (↑f x)","decl":"@[simp]\ntheorem lift_coe (x : ℤ) : lift n f (x : ZMod n) = f.val x :=\n  AddMonoidHom.liftOfRightInverse_comp_apply _ _ (fun _ => intCast_zmod_cast _) _ _\n\n"}
{"name":"ZMod.lift_castAddHom","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nA : Type u_2\ninst✝ : AddGroup A\nf : Subtype fun f => Eq (f ↑n) 0\nx : Int\n⊢ Eq (((ZMod.lift n) f) ((Int.castAddHom (ZMod n)) x)) (↑f x)","decl":"theorem lift_castAddHom (x : ℤ) : lift n f (Int.castAddHom (ZMod n) x) = f.1 x :=\n  AddMonoidHom.liftOfRightInverse_comp_apply _ _ (fun _ => intCast_zmod_cast _) _ _\n\n"}
{"name":"ZMod.lift_comp_coe","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nA : Type u_2\ninst✝ : AddGroup A\nf : Subtype fun f => Eq (f ↑n) 0\n⊢ Eq (Function.comp (⇑((ZMod.lift n) f)) Int.cast) ⇑↑f","decl":"@[simp]\ntheorem lift_comp_coe : ZMod.lift n f ∘ ((↑) : ℤ → _) = f :=\n  funext <| lift_coe _ _\n\n"}
{"name":"ZMod.lift_comp_castAddHom","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nA : Type u_2\ninst✝ : AddGroup A\nf : Subtype fun f => Eq (f ↑n) 0\n⊢ Eq (((ZMod.lift n) f).comp (Int.castAddHom (ZMod n))) ↑f","decl":"@[simp]\ntheorem lift_comp_castAddHom : (ZMod.lift n f).comp (Int.castAddHom (ZMod n)) = f :=\n  AddMonoidHom.ext <| lift_castAddHom _ _\n\n"}
{"name":"ZMod.lift_injective","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nA : Type u_2\ninst✝ : AddGroup A\nf : Subtype fun f => Eq (f ↑n) 0\n⊢ Iff (Function.Injective ⇑((ZMod.lift n) f)) (∀ (m : Int), Eq (↑f m) 0 → Eq (↑m) 0)","decl":"lemma lift_injective {f : {f : ℤ →+ A // f n = 0}} :\n    Injective (lift n f) ↔ ∀ m, f.1 m = 0 → (m : ZMod n) = 0 := by\n  simp only [← AddMonoidHom.ker_eq_bot_iff, eq_bot_iff, SetLike.le_def,\n    ZMod.intCast_surjective.forall, ZMod.lift_coe, AddMonoidHom.mem_ker, AddSubgroup.mem_bot]\n\n"}
{"name":"zmod_smul_mem","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nS : Type u_1\nG : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : SetLike S G\ninst✝¹ : AddSubgroupClass S G\nK : S\ninst✝ : Module (ZMod n) G\nx : G\nhx : Membership.mem K x\na : ZMod n\n⊢ Membership.mem K (HSMul.hSMul a x)","decl":"lemma zmod_smul_mem (hx : x ∈ K) : ∀ a : ZMod n, a • x ∈ K := by\n  simpa [ZMod.forall, Int.cast_smul_eq_zsmul] using zsmul_mem hx\n\n"}
{"name":"smulMemClass","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nS : Type u_1\nG : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : SetLike S G\ninst✝¹ : AddSubgroupClass S G\ninst✝ : Module (ZMod n) G\n⊢ SMulMemClass S (ZMod n) G","decl":"/-- This cannot be made an instance because of the `[Module (ZMod n) G]` argument and the fact that\n`n` only appears in the second argument of `SMulMemClass`, which is an `OutParam`. -/\nlemma smulMemClass : SMulMemClass S (ZMod n) G where smul_mem _ _ {_x} hx := zmod_smul_mem hx _\n\n"}
{"name":"AddSubgroupClass.coe_zmod_smul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nS : Type u_1\nG : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : SetLike S G\ninst✝¹ : AddSubgroupClass S G\nK : S\ninst✝ : Module (ZMod n) G\na : ZMod n\nx : Subtype fun x => Membership.mem K x\n⊢ Eq (↑(HSMul.hSMul a x)) (HSMul.hSMul a ↑x)","decl":"@[simp, norm_cast] lemma coe_zmod_smul (a : ZMod n) (x : K) : ↑(a • x) = (a • x : G) := rfl\n\n"}
{"name":"ZModModule.char_nsmul_eq_zero","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nG : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod n) G\nx : G\n⊢ Eq (HSMul.hSMul n x) 0","decl":"lemma ZModModule.char_nsmul_eq_zero (x : G) : n • x = 0 := by\n  simp [← Nat.cast_smul_eq_nsmul (ZMod n)]\n\n"}
{"name":"ZModModule.char_ne_one","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nG : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : Module (ZMod n) G\ninst✝ : Nontrivial G\n⊢ Ne n 1","decl":"variable (G) in\nlemma ZModModule.char_ne_one [Nontrivial G] : n ≠ 1 := by\n  rintro rfl\n  obtain ⟨x, hx⟩ := exists_ne (0 : G)\n  exact hx <| by simpa using char_nsmul_eq_zero 1 x\n\n"}
{"name":"ZModModule.two_le_char","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nG : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : Module (ZMod n) G\ninst✝¹ : NeZero n\ninst✝ : Nontrivial G\n⊢ LE.le 2 n","decl":"variable (G) in\nlemma ZModModule.two_le_char [NeZero n] [Nontrivial G] : 2 ≤ n := by\n  have := NeZero.ne n\n  have := char_ne_one n G\n  omega\n\n"}
{"name":"ZModModule.periodicPts_add_left","module":"Mathlib.Data.ZMod.Basic","initialProofState":"n : Nat\nG : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : Module (ZMod n) G\ninst✝ : NeZero n\nx : G\n⊢ Eq (Function.periodicPts fun x_1 => HAdd.hAdd x x_1) Set.univ","decl":"lemma ZModModule.periodicPts_add_left [NeZero n] (x : G) : periodicPts (x + ·) = .univ :=\n  Set.eq_univ_of_forall fun y ↦ ⟨n, NeZero.pos n, by\n    simpa [char_nsmul_eq_zero, IsPeriodicPt] using isFixedPt_id _⟩\n\n"}
{"name":"ZModModule.add_self","module":"Mathlib.Data.ZMod.Basic","initialProofState":"G : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod 2) G\nx : G\n⊢ Eq (HAdd.hAdd x x) 0","decl":"lemma ZModModule.add_self (x : G) : x + x = 0 := by\n  simpa [two_nsmul] using char_nsmul_eq_zero 2 x\n\n"}
{"name":"ZModModule.neg_eq_self","module":"Mathlib.Data.ZMod.Basic","initialProofState":"G : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod 2) G\nx : G\n⊢ Eq (Neg.neg x) x","decl":"lemma ZModModule.neg_eq_self (x : G) : -x = x := by simp [add_self, eq_comm, ← sub_eq_zero]\n\n"}
{"name":"ZModModule.sub_eq_add","module":"Mathlib.Data.ZMod.Basic","initialProofState":"G : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod 2) G\nx y : G\n⊢ Eq (HSub.hSub x y) (HAdd.hAdd x y)","decl":"lemma ZModModule.sub_eq_add (x y : G) : x - y = x + y := by simp [neg_eq_self, sub_eq_add_neg]\n\n"}
{"name":"ZModModule.add_add_add_cancel","module":"Mathlib.Data.ZMod.Basic","initialProofState":"G : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod 2) G\nx y z : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd x y) (HAdd.hAdd y z)) (HAdd.hAdd x z)","decl":"lemma ZModModule.add_add_add_cancel (x y z : G) : (x + y) + (y + z) = x + z := by\n  simpa [sub_eq_add] using sub_add_sub_cancel x y z\n\n"}
{"name":"nsmul_zmod_val_inv_nsmul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nn : Nat\nhn : (Nat.card α).Coprime n\na : α\n⊢ Eq (HSMul.hSMul n (HSMul.hSMul (Inv.inv ↑n).val a)) a","decl":"@[simp]\nlemma nsmul_zmod_val_inv_nsmul (hn : (Nat.card α).Coprime n) (a : α) :\n    n • (n⁻¹ : ZMod (Nat.card α)).val • a = a := by\n  rw [← mul_nsmul', ← mod_natCard_nsmul, ← ZMod.val_natCast, Nat.cast_mul,\n    ZMod.mul_val_inv hn.symm, ZMod.val_one_eq_one_mod, mod_natCard_nsmul, one_nsmul]\n\n"}
{"name":"zmod_val_inv_nsmul_nsmul","module":"Mathlib.Data.ZMod.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nn : Nat\nhn : (Nat.card α).Coprime n\na : α\n⊢ Eq (HSMul.hSMul (Inv.inv ↑n).val (HSMul.hSMul n a)) a","decl":"@[simp]\nlemma zmod_val_inv_nsmul_nsmul (hn : (Nat.card α).Coprime n) (a : α) :\n    (n⁻¹ : ZMod (Nat.card α)).val • n • a = a := by\n  rw [nsmul_left_comm, nsmul_zmod_val_inv_nsmul hn]\n\n"}
{"name":"pow_zmod_val_inv_pow","module":"Mathlib.Data.ZMod.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nn : Nat\nhn : (Nat.card α).Coprime n\na : α\n⊢ Eq (HPow.hPow (HPow.hPow a (Inv.inv ↑n).val) n) a","decl":"@[to_additive (attr := simp) existing nsmul_zmod_val_inv_nsmul]\nlemma pow_zmod_val_inv_pow (hn : (Nat.card α).Coprime n) (a : α) :\n    (a ^ (n⁻¹ : ZMod (Nat.card α)).val) ^ n = a := by\n  rw [← pow_mul', ← pow_mod_natCard, ← ZMod.val_natCast, Nat.cast_mul, ZMod.mul_val_inv hn.symm,\n    ZMod.val_one_eq_one_mod, pow_mod_natCard, pow_one]\n\n"}
{"name":"pow_pow_zmod_val_inv","module":"Mathlib.Data.ZMod.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nn : Nat\nhn : (Nat.card α).Coprime n\na : α\n⊢ Eq (HPow.hPow (HPow.hPow a n) (Inv.inv ↑n).val) a","decl":"@[to_additive (attr := simp) existing zmod_val_inv_nsmul_nsmul]\nlemma pow_pow_zmod_val_inv (hn : (Nat.card α).Coprime n) (a : α) :\n    (a ^ n) ^ (n⁻¹ : ZMod (Nat.card α)).val = a := by rw [pow_right_comm, pow_zmod_val_inv_pow hn]\n\n"}
{"name":"Nat.range_mul_add","module":"Mathlib.Data.ZMod.Basic","initialProofState":"m k : Nat\n⊢ Eq (Set.range fun n => HAdd.hAdd (HMul.hMul m n) k) (setOf fun n => And (Eq ↑n ↑k) (LE.le k n))","decl":"/-- The range of `(m * · + k)` on natural numbers is the set of elements `≥ k` in the\nresidue class of `k` mod `m`. -/\nlemma Nat.range_mul_add (m k : ℕ) :\n    Set.range (fun n : ℕ ↦ m * n + k) = {n : ℕ | (n : ZMod m) = k ∧ k ≤ n} := by\n  ext n\n  simp only [Set.mem_range, Set.mem_setOf_eq]\n  conv => enter [1, 1, y]; rw [add_comm, eq_comm]\n  refine ⟨fun ⟨a, ha⟩ ↦ ⟨?_, le_iff_exists_add.mpr ⟨_, ha⟩⟩, fun ⟨H₁, H₂⟩ ↦ ?_⟩\n  · simpa using congr_arg ((↑) : ℕ → ZMod m) ha\n  · obtain ⟨a, ha⟩ := le_iff_exists_add.mp H₂\n    simp only [ha, Nat.cast_add, add_right_eq_self, ZMod.natCast_zmod_eq_zero_iff_dvd] at H₁\n    obtain ⟨b, rfl⟩ := H₁\n    exact ⟨b, ha⟩\n\n"}
