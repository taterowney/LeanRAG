{"name":"CategoryTheory.Sheaf.tensorProd_isSheaf","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (CategoryTheory.MonoidalCategoryStruct.tensorObj X.val Y.val)","decl":"lemma tensorProd_isSheaf : Presheaf.IsSheaf J (X.val ‚äó Y.val) := by\n  apply isSheaf_of_isLimit (E := (Cones.postcompose (pairComp X Y (sheafToPresheaf J A)).inv).obj\n    (ChosenFiniteProducts.product X.val Y.val).cone)\n  exact (IsLimit.postcomposeInvEquiv _ _).invFun (ChosenFiniteProducts.product X.val Y.val).isLimit\n\n"}
{"name":"CategoryTheory.Sheaf.tensorUnit_isSheaf","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"lemma tensorUnit_isSheaf : Presheaf.IsSheaf J (ùüô_ (C·µí·µñ ‚•§ A)) := by\n  apply isSheaf_of_isLimit (E := (Cones.postcompose (Functor.uniqueFromEmpty _).inv).obj\n    ChosenFiniteProducts.terminal.cone)\n  ¬∑ exact (IsLimit.postcomposeInvEquiv _ _).invFun ChosenFiniteProducts.terminal.isLimit\n  ¬∑ exact Functor.empty _\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_product_cone_pt_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.product X Y).cone.pt.val (CategoryTheory.MonoidalCategoryStruct.tensorObj X.val Y.val)","decl":"/-- Any `ChosenFiniteProducts` on `A` induce a `ChosenFiniteProducts` structures on `A`-valued\nsheaves. -/\n@[simps! product_cone_pt_val terminal_cone_pt_val_obj terminal_cone_pt_val_map]\nnoncomputable instance chosenFiniteProducts : ChosenFiniteProducts (Sheaf J A) where\n  product X Y :=\n    { cone := BinaryFan.mk\n          (P := { val := X.val ‚äó Y.val\n                  cond := tensorProd_isSheaf J X Y})\n          ‚ü®(ChosenFiniteProducts.fst _ _)‚ü© ‚ü®(ChosenFiniteProducts.snd _ _)‚ü©\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.lift (BinaryFan.fst f).val (BinaryFan.snd f).val‚ü©\n          fac := by rintro s ‚ü®‚ü®j‚ü©‚ü© <;> apply Sheaf.hom_ext <;> simp\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            apply ChosenFiniteProducts.hom_ext\n            ¬∑ specialize h ‚ü®WalkingPair.left‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h\n            ¬∑ specialize h ‚ü®WalkingPair.right‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h } }\n  terminal :=\n    { cone := asEmptyCone { val := ùüô_ (C·µí·µñ ‚•§ A)\n                            cond := tensorUnit_isSheaf _}\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.toUnit f.pt.val‚ü©\n          fac := by intro s ‚ü®e‚ü©; cases e\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            exact ChosenFiniteProducts.toUnit_unique f.val _} }\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_terminal_cone_pt_val_map","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX‚úù Y‚úù : Opposite C\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.terminal.cone.pt.val.map x‚úù) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- Any `ChosenFiniteProducts` on `A` induce a `ChosenFiniteProducts` structures on `A`-valued\nsheaves. -/\n@[simps! product_cone_pt_val terminal_cone_pt_val_obj terminal_cone_pt_val_map]\nnoncomputable instance chosenFiniteProducts : ChosenFiniteProducts (Sheaf J A) where\n  product X Y :=\n    { cone := BinaryFan.mk\n          (P := { val := X.val ‚äó Y.val\n                  cond := tensorProd_isSheaf J X Y})\n          ‚ü®(ChosenFiniteProducts.fst _ _)‚ü© ‚ü®(ChosenFiniteProducts.snd _ _)‚ü©\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.lift (BinaryFan.fst f).val (BinaryFan.snd f).val‚ü©\n          fac := by rintro s ‚ü®‚ü®j‚ü©‚ü© <;> apply Sheaf.hom_ext <;> simp\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            apply ChosenFiniteProducts.hom_ext\n            ¬∑ specialize h ‚ü®WalkingPair.left‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h\n            ¬∑ specialize h ‚ü®WalkingPair.right‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h } }\n  terminal :=\n    { cone := asEmptyCone { val := ùüô_ (C·µí·µñ ‚•§ A)\n                            cond := tensorUnit_isSheaf _}\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.toUnit f.pt.val‚ü©\n          fac := by intro s ‚ü®e‚ü©; cases e\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            exact ChosenFiniteProducts.toUnit_unique f.val _} }\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_terminal_cone_pt_val_obj","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nx‚úù : Opposite C\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.terminal.cone.pt.val.obj x‚úù) CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- Any `ChosenFiniteProducts` on `A` induce a `ChosenFiniteProducts` structures on `A`-valued\nsheaves. -/\n@[simps! product_cone_pt_val terminal_cone_pt_val_obj terminal_cone_pt_val_map]\nnoncomputable instance chosenFiniteProducts : ChosenFiniteProducts (Sheaf J A) where\n  product X Y :=\n    { cone := BinaryFan.mk\n          (P := { val := X.val ‚äó Y.val\n                  cond := tensorProd_isSheaf J X Y})\n          ‚ü®(ChosenFiniteProducts.fst _ _)‚ü© ‚ü®(ChosenFiniteProducts.snd _ _)‚ü©\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.lift (BinaryFan.fst f).val (BinaryFan.snd f).val‚ü©\n          fac := by rintro s ‚ü®‚ü®j‚ü©‚ü© <;> apply Sheaf.hom_ext <;> simp\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            apply ChosenFiniteProducts.hom_ext\n            ¬∑ specialize h ‚ü®WalkingPair.left‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h\n            ¬∑ specialize h ‚ü®WalkingPair.right‚ü©\n              rw [Sheaf.hom_ext_iff] at h\n              simpa using h } }\n  terminal :=\n    { cone := asEmptyCone { val := ùüô_ (C·µí·µñ ‚•§ A)\n                            cond := tensorUnit_isSheaf _}\n      isLimit :=\n        { lift := fun f ‚Ü¶ ‚ü®ChosenFiniteProducts.toUnit f.pt.val‚ü©\n          fac := by intro s ‚ü®e‚ü©; cases e\n          uniq := by\n            intro x f h\n            apply Sheaf.hom_ext\n            exact ChosenFiniteProducts.toUnit_unique f.val _} }\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_fst_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.fst X Y).val (CategoryTheory.ChosenFiniteProducts.fst X.val Y.val)","decl":"@[simp]\nlemma chosenFiniteProducts_fst_val : (ChosenFiniteProducts.fst X Y).val =\n    ChosenFiniteProducts.fst X.val Y.val := rfl\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_snd_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.snd X Y).val (CategoryTheory.ChosenFiniteProducts.snd X.val Y.val)","decl":"@[simp]\nlemma chosenFiniteProducts_snd_val : (ChosenFiniteProducts.snd X Y).val =\n    ChosenFiniteProducts.snd X.val Y.val := rfl\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_lift_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y W : CategoryTheory.Sheaf J A\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.ChosenFiniteProducts.lift f g).val (CategoryTheory.ChosenFiniteProducts.lift f.val g.val)","decl":"@[simp]\nlemma chosenFiniteProducts_lift_val : (ChosenFiniteProducts.lift f g).val =\n    ChosenFiniteProducts.lift f.val g.val := rfl\n\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_whiskerLeft_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX W : CategoryTheory.Sheaf J A\nf : Quiver.Hom W X\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).val (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.val f.val)","decl":"@[simp]\nlemma chosenFiniteProducts_whiskerLeft_val : (X ‚óÅ f).val = (X.val ‚óÅ f.val) := rfl\n"}
{"name":"CategoryTheory.Sheaf.chosenFiniteProducts_whiskerRight_val","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX W : CategoryTheory.Sheaf J A\nf : Quiver.Hom W X\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X).val (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.val X.val)","decl":"@[simp]\nlemma chosenFiniteProducts_whiskerRight_val : (f ‚ñ∑ X).val = (f.val ‚ñ∑ X.val) := rfl\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_Œµ","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (CategoryTheory.sheafToPresheaf J A)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\nlemma sheafToPresheaf_Œµ : Œµ (sheafToPresheaf J A) = ùüô _ := rfl\n"}
{"name":"CategoryTheory.sheafToPresheaf_Œ∑","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ (CategoryTheory.sheafToPresheaf J A)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.sheafToPresheaf J A).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp]\nlemma sheafToPresheaf_Œ∑ : Œ∑ (sheafToPresheaf J A) = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_Œº","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (CategoryTheory.sheafToPresheaf J A) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.sheafToPresheaf J A).obj X) ((CategoryTheory.sheafToPresheaf J A).obj Y)))","decl":"@[simp]\nlemma sheafToPresheaf_Œº (X Y : Sheaf J A) : Œº (sheafToPresheaf J A) X Y = ùüô _ := rfl\n"}
{"name":"CategoryTheory.sheafToPresheaf_Œ¥","module":"Mathlib.CategoryTheory.Sites.ChosenFiniteProducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù : CategoryTheory.ChosenFiniteProducts A\nX Y : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ (CategoryTheory.sheafToPresheaf J A) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.sheafToPresheaf J A).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp]\nlemma sheafToPresheaf_Œ¥ (X Y : Sheaf J A) : Œ¥ (sheafToPresheaf J A) X Y = ùüô _ := rfl\n\n"}
