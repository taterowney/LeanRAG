{"name":"CategoryTheory.FreeBicategory.preinclusion_obj","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na : B\n⊢ Eq ((CategoryTheory.FreeBicategory.preinclusion B).obj { as := a }) a","decl":"@[simp]\ntheorem preinclusion_obj (a : B) : (preinclusion B).obj ⟨a⟩ = a :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.preinclusion_map₂","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : B\nf g : CategoryTheory.Discrete (Quiver.Path a b)\nη : Quiver.Hom f g\n⊢ Eq ((CategoryTheory.FreeBicategory.preinclusion B).map₂ η) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem preinclusion_map₂ {a b : B} (f g : Discrete (Path.{v + 1} a b)) (η : f ⟶ g) :\n    (preinclusion B).map₂ η = eqToHom (congr_arg _ (Discrete.ext (Discrete.eq_of_hom η))) := by\n  rcases η with ⟨⟨⟩⟩\n  cases Discrete.ext (by assumption)\n  convert (inclusionPath a b).map_id _\n\n"}
{"name":"CategoryTheory.FreeBicategory.normalizeAux_congr","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : B\np : Quiver.Path a b\nf g : CategoryTheory.FreeBicategory.Hom b c\nη : Quiver.Hom f g\n⊢ Eq (CategoryTheory.FreeBicategory.normalizeAux p f) (CategoryTheory.FreeBicategory.normalizeAux p g)","decl":"/-- Given a 2-morphism between `f` and `g` in the free bicategory, we have the equality\n`normalizeAux p f = normalizeAux p g`.\n-/\ntheorem normalizeAux_congr {a b c : B} (p : Path a b) {f g : Hom b c} (η : f ⟶ g) :\n    normalizeAux p f = normalizeAux p g := by\n  rcases η with ⟨η'⟩\n  apply @congr_fun _ _ fun p => normalizeAux p f\n  clear p η\n  induction η' with\n  | vcomp _ _ _ _ => apply Eq.trans <;> assumption\n  | whisker_left _ _ ih => funext; apply congr_fun ih\n  | whisker_right _ _ ih => funext; apply congr_arg₂ _ (congr_fun ih _) rfl\n  | _ => funext; rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.normalize_naturality","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : B\np : Quiver.Path a b\nf g : CategoryTheory.FreeBicategory.Hom b c\nη : Quiver.Hom f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft ((CategoryTheory.FreeBicategory.preinclusion B).map { as := p }) η) (CategoryTheory.FreeBicategory.normalizeIso p g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.FreeBicategory.normalizeIso p f).hom ((CategoryTheory.FreeBicategory.preinclusion B).map₂ (CategoryTheory.eqToHom ⋯)))","decl":"/-- The 2-isomorphism `normalizeIso p f` is natural in `f`. -/\ntheorem normalize_naturality {a b c : B} (p : Path a b) {f g : Hom b c} (η : f ⟶ g) :\n    (preinclusion B).map ⟨p⟩ ◁ η ≫ (normalizeIso p g).hom =\n      (normalizeIso p f).hom ≫\n        (preinclusion B).map₂ (eqToHom (Discrete.ext (normalizeAux_congr p η))) := by\n  rcases η with ⟨η'⟩; clear η\n  induction η' with\n  | id => simp\n  | vcomp η θ ihf ihg =>\n    simp only [mk_vcomp, Bicategory.whiskerLeft_comp]\n    slice_lhs 2 3 => rw [ihg]\n    slice_lhs 1 2 => rw [ihf]\n    simp\n  -- p ≠ nil required! See the docstring of `normalizeAux`.\n  | whisker_left _ _ ih =>\n    dsimp\n    rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc, ih]\n    simp\n  | whisker_right h η' ih =>\n    dsimp\n    rw [associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc, ih, comp_whiskerRight]\n    have := dcongr_arg (fun x => (normalizeIso x h).hom) (normalizeAux_congr p (Quot.mk _ η'))\n    dsimp at this; simp [this]\n  | _ => simp\n\n-- Porting note: the left-hand side is not in simp-normal form.\n-- @[simp]\n"}
{"name":"CategoryTheory.FreeBicategory.normalizeAux_nil_comp","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\n⊢ Eq (CategoryTheory.FreeBicategory.normalizeAux Quiver.Path.nil (f.comp g)) ((CategoryTheory.FreeBicategory.normalizeAux Quiver.Path.nil f).comp (CategoryTheory.FreeBicategory.normalizeAux Quiver.Path.nil g))","decl":"theorem normalizeAux_nil_comp {a b c : B} (f : Hom a b) (g : Hom b c) :\n    normalizeAux nil (f.comp g) = (normalizeAux nil f).comp (normalizeAux nil g) := by\n  induction g generalizing a with\n  | id => rfl\n  | of => rfl\n  | comp g _ ihf ihg => erw [ihg (f.comp g), ihf f, ihg g, comp_assoc]\n\n"}
{"name":"CategoryTheory.FreeBicategory.locally_thin","module":"Mathlib.CategoryTheory.Bicategory.Coherence","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\n⊢ Quiver.IsThin (Quiver.Hom a b)","decl":"/-- The coherence theorem for bicategories. -/\ninstance locally_thin {a b : FreeBicategory B} : Quiver.IsThin (a ⟶ b) := fun _ _ =>\n  ⟨fun _ _ =>\n    (@normalizeEquiv B _ a b).functor.map_injective (Subsingleton.elim _ _)⟩\n\n"}
