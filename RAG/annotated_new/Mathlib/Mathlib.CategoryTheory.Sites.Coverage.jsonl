{"name":"CategoryTheory.Presieve.factorsThruAlong_id","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX : C\nS T : CategoryTheory.Presieve X\n‚ä¢ Iff (S.FactorsThruAlong T (CategoryTheory.CategoryStruct.id X)) (S.FactorsThru T)","decl":"@[simp]\nlemma factorsThruAlong_id {X : C} (S T : Presieve X) :\n    S.FactorsThruAlong T (ùüô X) ‚Üî S.FactorsThru T := by\n  simp [FactorsThruAlong, FactorsThru]\n\n"}
{"name":"CategoryTheory.Presieve.factorsThru_of_le","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX : C\nS T : CategoryTheory.Presieve X\nh : LE.le S T\n‚ä¢ S.FactorsThru T","decl":"lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S ‚â§ T) :\n    S.FactorsThru T :=\n  fun Y g hg => ‚ü®Y, ùüô _, g, h _ hg, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.le_of_factorsThru_sieve","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX : C\nS : CategoryTheory.Presieve X\nT : CategoryTheory.Sieve X\nh : S.FactorsThru T.arrows\n‚ä¢ LE.le S T.arrows","decl":"lemma le_of_factorsThru_sieve {X : C} (S : Presieve X) (T : Sieve X) (h : S.FactorsThru T) :\n    S ‚â§ T := by\n  rintro Y f hf\n  obtain ‚ü®W, i, e, h1, rfl‚ü© := h hf\n  exact T.downward_closed h1 _\n\n"}
{"name":"CategoryTheory.Presieve.factorsThru_top","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX : C\nS : CategoryTheory.Presieve X\n‚ä¢ S.FactorsThru Top.top","decl":"lemma factorsThru_top {X : C} (S : Presieve X) : S.FactorsThru ‚ä§ :=\n  factorsThru_of_le _ _ le_top\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_of_factorsThru","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_3\ninst‚úù : CategoryTheory.Category.{u_2, u_3} C\nX : C\nS T : CategoryTheory.Presieve X\nP : CategoryTheory.Functor (Opposite C) (Type u_1)\nH : S.FactorsThru T\nhS : CategoryTheory.Presieve.IsSheafFor P S\nh : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, T f ‚Üí Exists fun R => And (CategoryTheory.Presieve.IsSeparatedFor P R) (R.FactorsThruAlong S f)\n‚ä¢ CategoryTheory.Presieve.IsSheafFor P T","decl":"lemma isSheafFor_of_factorsThru\n    {X : C} {S T : Presieve X}\n    (P : C·µí·µñ ‚•§ Type*)\n    (H : S.FactorsThru T) (hS : S.IsSheafFor P)\n    (h : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, T f ‚Üí ‚àÉ (R : Presieve Y),\n      R.IsSeparatedFor P ‚àß R.FactorsThruAlong S f) :\n    T.IsSheafFor P := by\n  simp only [‚Üê Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *\n  choose W i e h1 h2 using H\n  refine ‚ü®?_, fun x hx => ?_‚ü©\n  ¬∑ intro x y‚ÇÅ y‚ÇÇ h‚ÇÅ h‚ÇÇ\n    refine hS.1.ext (fun Y g hg => ?_)\n    simp only [‚Üê h2 hg, op_comp, P.map_comp, types_comp_apply, h‚ÇÅ _ (h1 _ ), h‚ÇÇ _ (h1 _)]\n  let y : S.FamilyOfElements P := fun Y g hg => P.map (i _).op (x (e hg) (h1 _))\n  have hy : y.Compatible := by\n    intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h\n    rw [‚Üê types_comp_apply (P.map (i h‚ÇÅ).op) (P.map g‚ÇÅ.op),\n      ‚Üê types_comp_apply (P.map (i h‚ÇÇ).op) (P.map g‚ÇÇ.op),\n      ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê P.map_comp, ‚Üê op_comp]\n    apply hx\n    simp only [h2, h, Category.assoc]\n  let ‚ü®_, h2'‚ü© := hS\n  obtain ‚ü®z, hz‚ü© := h2' y hy\n  refine ‚ü®z, fun Y g hg => ?_‚ü©\n  obtain ‚ü®R, hR1, hR2‚ü© := h hg\n  choose WW ii ee hh1 hh2 using hR2\n  refine hR1.ext (fun Q t ht => ?_)\n  rw [‚Üê types_comp_apply (P.map g.op) (P.map t.op), ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê hh2 ht,\n    op_comp, P.map_comp, types_comp_apply, hz _ (hh1 _),\n    ‚Üê types_comp_apply _ (P.map (ii ht).op), ‚Üê P.map_comp, ‚Üê op_comp]\n  apply hx\n  simp only [Category.assoc, h2, hh2]\n\n\n"}
{"name":"CategoryTheory.Coverage.ext","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nx y : CategoryTheory.Coverage C\ncovering : Eq x.covering y.covering\n‚ä¢ Eq x y","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\ncovering‚úù : (X : C) ‚Üí Set (CategoryTheory.Presieve X)\npullback‚úù : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom Y X) (S : CategoryTheory.Presieve X), Membership.mem (covering‚úù X) S ‚Üí Exists fun T => And (Membership.mem (covering‚úù Y) T) (T.FactorsThruAlong S f)\ncovering : (X : C) ‚Üí Set (CategoryTheory.Presieve X)\npullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom Y X) (S : CategoryTheory.Presieve X), Membership.mem (covering X) S ‚Üí Exists fun T => And (Membership.mem (covering Y) T) (T.FactorsThruAlong S f)\n‚ä¢ Eq (Eq { covering := covering‚úù, pullback := pullback‚úù } { covering := covering, pullback := pullback }) (Eq covering‚úù covering)","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : SizeOf C\ncovering : (X : C) ‚Üí Set (CategoryTheory.Presieve X)\npullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom Y X) (S : CategoryTheory.Presieve X), Membership.mem (covering X) S ‚Üí Exists fun T => And (Membership.mem (covering Y) T) (T.FactorsThruAlong S f)\n‚ä¢ Eq (SizeOf.sizeOf { covering := covering, pullback := pullback }) 1","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.pullback","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Coverage C\nX Y : C\nf : Quiver.Hom Y X\nS : CategoryTheory.Presieve X\nx‚úù : Membership.mem (self.covering X) S\n‚ä¢ Exists fun T => And (Membership.mem (self.covering Y) T) (T.FactorsThruAlong S f)","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.ext_iff","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nx y : CategoryTheory.Coverage C\n‚ä¢ Iff (Eq x y) (Eq x.covering y.covering)","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.mk.inj","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\ncovering‚úù : (X : C) ‚Üí Set (CategoryTheory.Presieve X)\npullback‚úù : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom Y X) (S : CategoryTheory.Presieve X), Membership.mem (covering‚úù X) S ‚Üí Exists fun T => And (Membership.mem (covering‚úù Y) T) (T.FactorsThruAlong S f)\ncovering : (X : C) ‚Üí Set (CategoryTheory.Presieve X)\npullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom Y X) (S : CategoryTheory.Presieve X), Membership.mem (covering X) S ‚Üí Exists fun T => And (Membership.mem (covering Y) T) (T.FactorsThruAlong S f)\nx‚úù : Eq { covering := covering‚úù, pullback := pullback‚úù } { covering := covering, pullback := pullback }\n‚ä¢ Eq covering‚úù covering","decl":"variable (C) in\n/--\nThe type `Coverage C` of coverages on `C`.\nA coverage is a collection of *covering* presieves on every object `X : C`,\nwhich satisfies a *pullback compatibility* condition.\nExplicitly, this condition says that whenever `S` is a covering presieve for `X` and\n`f : Y ‚ü∂ X` is a morphism, then there exists some covering presieve `T` for `Y`\nsuch that `T` factors through `S` along `f`.\n-/\n@[ext]\nstructure Coverage where\n  /-- The collection of covering presieves for an object `X`. -/\n  covering : ‚àÄ (X : C), Set (Presieve X)\n  /-- Given any covering sieve `S` on `X` and a morphism `f : Y ‚ü∂ X`, there exists\n    some covering sieve `T` on `Y` such that `T` factors through `S` along `f`. -/\n  pullback : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Y ‚ü∂ X) (S : Presieve X) (_ : S ‚àà covering X),\n    ‚àÉ (T : Presieve Y), T ‚àà covering Y ‚àß T.FactorsThruAlong S f\n\n"}
{"name":"CategoryTheory.Coverage.ofGrothendieck_iff","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX : C\nS : CategoryTheory.Presieve X\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Coverage.ofGrothendieck C J).covering X) S) (Membership.mem (J X) (CategoryTheory.Sieve.generate S))","decl":"lemma ofGrothendieck_iff {X : C} {S : Presieve X} (J : GrothendieckTopology C) :\n    S ‚àà ofGrothendieck _ J X ‚Üî Sieve.generate S ‚àà J X := Iff.rfl\n\n"}
{"name":"CategoryTheory.Coverage.Saturate.brecOn","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nK : CategoryTheory.Coverage C\nmotive‚úù : (X : C) ‚Üí (a : CategoryTheory.Sieve X) ‚Üí K.Saturate X a ‚Üí Prop\nX : C\na‚úù : CategoryTheory.Sieve X\nx‚úù : K.Saturate X a‚úù\nih‚úù : ‚àÄ (X : C) (a : CategoryTheory.Sieve X) (x : K.Saturate X a), x.below ‚Üí motive‚úù X a x\n‚ä¢ motive‚úù X a‚úù x‚úù","decl":"/--\nAn auxiliary definition used to define the Grothendieck topology associated to a\ncoverage. See `Coverage.toGrothendieck`.\n-/\ninductive Saturate (K : Coverage C) : (X : C) ‚Üí Sieve X ‚Üí Prop where\n  | of (X : C) (S : Presieve X) (hS : S ‚àà K X) : Saturate K X (Sieve.generate S)\n  | top (X : C) : Saturate K X ‚ä§\n  | transitive (X : C) (R S : Sieve X) :\n    Saturate K X R ‚Üí\n    (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí Saturate K Y (S.pullback f)) ‚Üí\n    Saturate K X S\n\n"}
{"name":"CategoryTheory.Coverage.eq_top_pullback","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nX Y : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\nf : Quiver.Hom Y X\nhf : S.arrows f\n‚ä¢ Eq (CategoryTheory.Sieve.pullback f T) Top.top","decl":"lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ‚â§ T) (f : Y ‚ü∂ X) (hf : S f) :\n    T.pullback f = ‚ä§ := by\n  ext Z g\n  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]\n  apply h\n  apply S.downward_closed\n  exact hf\n\n"}
{"name":"CategoryTheory.Coverage.saturate_of_superset","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nK : CategoryTheory.Coverage C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\nhS : K.Saturate X S\n‚ä¢ K.Saturate X T","decl":"lemma saturate_of_superset (K : Coverage C) {X : C} {S T : Sieve X} (h : S ‚â§ T)\n    (hS : Saturate K X S) : Saturate K X T := by\n  apply Saturate.transitive _ _ _ hS\n  intro Y g hg\n  rw [eq_top_pullback (h := h)]\n  ¬∑ apply Saturate.top\n  ¬∑ assumption\n\n"}
{"name":"CategoryTheory.Coverage.toGrothendieck_eq_sInf","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nK : CategoryTheory.Coverage C\n‚ä¢ Eq (CategoryTheory.Coverage.toGrothendieck C K) (InfSet.sInf (setOf fun J => LE.le K (CategoryTheory.Coverage.ofGrothendieck C J)))","decl":"/--\nAn alternative characterization of the Grothendieck topology associated to a coverage `K`:\nit is the infimum of all Grothendieck topologies whose associated coverage contains `K`.\n-/\ntheorem toGrothendieck_eq_sInf (K : Coverage C) : toGrothendieck _ K =\n    sInf {J | K ‚â§ ofGrothendieck _ J } := by\n  apply le_antisymm\n  ¬∑ apply le_sInf; intro J hJ\n    intro X S hS\n    induction hS with\n    | of X S hS => apply hJ; assumption\n    | top => apply J.top_mem\n    | transitive X R S _ _ H1 H2 => exact J.transitive H1 _ H2\n  ¬∑ apply sInf_le\n    intro X S hS\n    apply Saturate.of _ _ hS\n\n"}
{"name":"CategoryTheory.Coverage.sup_covering","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nx y : CategoryTheory.Coverage C\nB : C\n‚ä¢ Eq ((Max.max x y).covering B) (Union.union (x.covering B) (y.covering B))","decl":"@[simp]\nlemma sup_covering (x y : Coverage C) (B : C) :\n    (x ‚äî y).covering B = x.covering B ‚à™ y.covering B :=\n  rfl\n\n"}
{"name":"CategoryTheory.Coverage.mem_toGrothendieck_sieves_of_superset","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nK : CategoryTheory.Coverage C\nX : C\nS : CategoryTheory.Sieve X\nR : CategoryTheory.Presieve X\nh : LE.le R S.arrows\nhR : Membership.mem (K.covering X) R\n‚ä¢ Membership.mem ((CategoryTheory.Coverage.toGrothendieck C K) X) S","decl":"/--\nAny sieve that contains a covering presieve for a coverage is a covering sieve for the associated\nGrothendieck topology.\n-/\ntheorem mem_toGrothendieck_sieves_of_superset (K : Coverage C) {X : C} {S : Sieve X}\n    {R : Presieve X} (h : R ‚â§ S) (hR : R ‚àà K.covering X) : S ‚àà (K.toGrothendieck C) X :=\n  K.saturate_of_superset ((Sieve.generate_le_iff _ _).mpr h) (Coverage.Saturate.of X _ hR)\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_coverage","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nK : CategoryTheory.Coverage C\nP : CategoryTheory.Functor (Opposite C) (Type u_1)\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) (‚àÄ {X : C} (R : CategoryTheory.Presieve X), Membership.mem (K.covering X) R ‚Üí CategoryTheory.Presieve.IsSheafFor P R)","decl":"/--\nThe main theorem of this file: Given a coverage `K` on `C`,\na `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf for\nthe associated Grothendieck topology.\n-/\ntheorem isSheaf_coverage (K : Coverage C) (P : C·µí·µñ ‚•§ Type*) :\n    Presieve.IsSheaf (toGrothendieck _ K) P ‚Üî\n    (‚àÄ {X : C} (R : Presieve X), R ‚àà K X ‚Üí Presieve.IsSheafFor P R) := by\n  constructor\n  ¬∑ intro H X R hR\n    rw [Presieve.isSheafFor_iff_generate]\n    apply H _ <| Saturate.of _ _ hR\n  ¬∑ intro H X S hS\n    -- This is the key point of the proof:\n    -- We must generalize the induction in the correct way.\n    suffices ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), Presieve.IsSheafFor P (S.pullback f).arrows by\n      simpa using this (f := ùüô _)\n    induction hS with\n    | of X S hS =>\n      intro Y f\n      obtain ‚ü®T, hT1, hT2‚ü© := K.pullback f S hS\n      apply Presieve.isSheafFor_of_factorsThru (S := T)\n      ¬∑ intro Z g hg\n        obtain ‚ü®W, i, e, h1, h2‚ü© := hT2 hg\n        exact ‚ü®Z, ùüô _, g, ‚ü®W, i, e, h1, h2‚ü©, by simp‚ü©\n      ¬∑ apply H; assumption\n      ¬∑ intro Z g _\n        obtain ‚ü®R, hR1, hR2‚ü© := K.pullback g _ hT1\n        exact ‚ü®R, (H _ hR1).isSeparatedFor, hR2‚ü©\n    | top => intros; simpa using Presieve.isSheafFor_top_sieve _\n    | transitive X R S _ _ H1 H2 =>\n      intro Y f\n      simp only [‚Üê Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *\n      choose H1 H1' using H1\n      choose H2 H2' using H2\n      refine ‚ü®?_, fun x hx => ?_‚ü©\n      ¬∑ intro x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ\n        refine (H1 f).ext (fun Z g hg => ?_)\n        refine (H2 hg (ùüô _)).ext (fun ZZ gg hgg => ?_)\n        simp only [Sieve.pullback_id, Sieve.pullback_apply] at hgg\n        simp only [‚Üê types_comp_apply]\n        rw [‚Üê P.map_comp, ‚Üê op_comp, h‚ÇÅ, h‚ÇÇ]\n        simpa only [Sieve.pullback_apply, Category.assoc] using hgg\n      let y : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y),\n        ((S.pullback (g ‚â´ f)).pullback (ùüô _)).arrows.FamilyOfElements P :=\n        fun Z g ZZ gg hgg => x (gg ‚â´ g) (by simpa using hgg)\n      have hy : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ Y), (y g).Compatible := by\n        intro Z g Y‚ÇÅ Y‚ÇÇ ZZ g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h\n        rw [hx]\n        rw [reassoc_of% h]\n      choose z hz using fun ‚¶ÉZ : C‚¶Ñ ‚¶Ég : Z ‚ü∂ Y‚¶Ñ (hg : R.pullback f g) =>\n        H2' hg (ùüô _) (y g) (hy g)\n      let q : (R.pullback f).arrows.FamilyOfElements P := fun Z g hg => z hg\n      have hq : q.Compatible := by\n        intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ h\n        apply (H2 h‚ÇÅ g‚ÇÅ).ext\n        intro ZZ gg hgg\n        simp only [‚Üê types_comp_apply]\n        rw [‚Üê P.map_comp, ‚Üê P.map_comp, ‚Üê op_comp, ‚Üê op_comp, hz, hz]\n        ¬∑ dsimp [y]; congr 1; simp only [Category.assoc, h]\n        ¬∑ simpa [reassoc_of% h] using hgg\n        ¬∑ simpa using hgg\n      obtain ‚ü®t, ht‚ü© := H1' f q hq\n      refine ‚ü®t, fun Z g hg => ?_‚ü©\n      refine (H1 (g ‚â´ f)).ext (fun ZZ gg hgg => ?_)\n      rw [‚Üê types_comp_apply _ (P.map gg.op), ‚Üê P.map_comp, ‚Üê op_comp, ht]\n      on_goal 2 => simpa using hgg\n      refine (H2 hgg (ùüô _)).ext (fun ZZZ ggg hggg => ?_)\n      rw [‚Üê types_comp_apply _ (P.map ggg.op), ‚Üê P.map_comp, ‚Üê op_comp, hz]\n      on_goal 2 => simpa using hggg\n      refine (H2 hgg ggg).ext (fun ZZZZ gggg _ => ?_)\n      rw [‚Üê types_comp_apply _ (P.map gggg.op), ‚Üê P.map_comp, ‚Üê op_comp]\n      apply hx\n      simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_sup","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nK L : CategoryTheory.Coverage C\nP : CategoryTheory.Functor (Opposite C) (Type u_1)\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (Max.max K L)) P) (And (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P))","decl":"/--\nA presheaf is a sheaf for the Grothendieck topology generated by a union of coverages iff it is a\nsheaf for the Grothendieck topology generated by each coverage separately.\n-/\ntheorem isSheaf_sup (K L : Coverage C) (P : C·µí·µñ ‚•§ Type*) :\n    (Presieve.IsSheaf ((K ‚äî L).toGrothendieck C)) P ‚Üî\n    (Presieve.IsSheaf (K.toGrothendieck C)) P ‚àß (Presieve.IsSheaf (L.toGrothendieck C)) P := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_left) h,\n      Presieve.isSheaf_of_le _ ((gi C).gc.monotone_l le_sup_right) h‚ü©, fun h ‚Ü¶ ?_‚ü©\n  rw [isSheaf_coverage, isSheaf_coverage] at h\n  rw [isSheaf_coverage]\n  intro X R hR\n  cases' hR with hR hR\n  ¬∑ exact h.1 R hR\n  ¬∑ exact h.2 R hR\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit_coverage","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\nD : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Category.{u_3, u_4} D\nK : CategoryTheory.Coverage C\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) (‚àÄ ‚¶ÉX : C‚¶Ñ (R : CategoryTheory.Presieve X), Membership.mem (K.covering X) R ‚Üí Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.generate R).arrows.cocone.op)))","decl":"theorem isSheaf_iff_isLimit_coverage (K : Coverage C) (P : C·µí·µñ ‚•§ D) :\n    Presheaf.IsSheaf (toGrothendieck _ K) P ‚Üî ‚àÄ ‚¶ÉX : C‚¶Ñ (R : Presieve X),\n      R ‚àà K.covering X ‚Üí\n        Nonempty (IsLimit (P.mapCone (Sieve.generate R).arrows.cocone.op)) := by\n  simp only [Presheaf.IsSheaf, Presieve.isSheaf_coverage, isLimit_iff_isSheafFor,\n    ‚Üê Presieve.isSheafFor_iff_generate]\n  aesop\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_sup","module":"Mathlib.CategoryTheory.Sites.Coverage","initialProofState":"C : Type u_1\nD : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Category.{u_3, u_4} D\nK L : CategoryTheory.Coverage C\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (Max.max K L)) P) (And (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P))","decl":"theorem isSheaf_sup (K L : Coverage C) (P : C·µí·µñ ‚•§ D) :\n    (IsSheaf ((K ‚äî L).toGrothendieck C)) P ‚Üî\n    (IsSheaf (K.toGrothendieck C)) P ‚àß (IsSheaf (L.toGrothendieck C)) P :=\n  ‚ü®fun h ‚Ü¶ ‚ü®fun E ‚Ü¶ ((Presieve.isSheaf_sup K L _).mp (h E)).1, fun E ‚Ü¶\n    ((Presieve.isSheaf_sup K L _).mp (h E)).2‚ü©,\n      fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© E ‚Ü¶ (Presieve.isSheaf_sup K L _).mpr ‚ü®h‚ÇÅ E, h‚ÇÇ E‚ü©‚ü©\n\n"}
