{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn ğ•œ f s\nk : Nat\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ HasFPowerSeriesWithinOnBall (iteratedFDerivWithin ğ•œ k f s) (p.iteratedFDerivSeries k) s x r","decl":"/-- If a function has a power series on a ball, then so do its iterated derivatives. -/\nprotected theorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn ğ•œ f s)\n    (k : â„•) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    HasFPowerSeriesWithinOnBall (iteratedFDerivWithin ğ•œ k f s)\n      (p.iteratedFDerivSeries k) s x r := by\n  induction k with\n  | zero =>\n    exact (continuousMultilinearCurryFin0 ğ•œ E F).symm\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall h\n  | succ k ih =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left]\n    apply (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (k + 1) â†¦ E) F).symm\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall\n        (ih.fderivWithin_of_mem_of_analyticOn (h'.iteratedFDerivWithin hs _) hs hx)\n\n"}
{"name":"FormalMultilinearSeries.iteratedFDerivSeries_eq_zero","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nk n : Nat\nh : Eq (p (HAdd.hAdd n k)) 0\nâŠ¢ Eq (p.iteratedFDerivSeries k n) 0","decl":"lemma FormalMultilinearSeries.iteratedFDerivSeries_eq_zero {k n : â„•}\n    (h : p (n + k) = 0) : p.iteratedFDerivSeries k n = 0 := by\n  induction k generalizing n with\n  | zero =>\n    ext\n    have : p n = 0 := p.congr_zero rfl h\n    simp [FormalMultilinearSeries.iteratedFDerivSeries, this]\n  | succ k ih =>\n    ext\n    simp only [iteratedFDerivSeries, Nat.succ_eq_add_one,\n      ContinuousLinearMap.compFormalMultilinearSeries_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe,\n      LinearIsometryEquiv.coe_toContinuousLinearEquiv, Function.comp_apply,\n      continuousMultilinearCurryLeftEquiv_symm_apply, ContinuousMultilinearMap.zero_apply,\n      ContinuousLinearMap.zero_apply,\n      derivSeries_eq_zero _ (ih (p.congr_zero (Nat.succ_add_eq_add_succ _ _).symm h))]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_zero","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn ğ•œ f s\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nn : Nat\nhn : Eq (p n) 0\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s x) 0","decl":"/-- If the `n`-th term in a power series is zero, then the `n`-th derivative of the corresponding\nfunction vanishes. -/\nlemma HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_zero\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn ğ•œ f s)\n    (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {n : â„•} (hn : p n = 0) :\n    iteratedFDerivWithin ğ•œ n f s x = 0 := by\n  have : iteratedFDerivWithin ğ•œ n f s x = p.iteratedFDerivSeries n 0 (fun _ â†¦ 0) :=\n    ((h.iteratedFDerivWithin h' n hu hx).coeff_zero _).symm\n  rw [this, p.iteratedFDerivSeries_eq_zero (p.congr_zero (Nat.zero_add n).symm hn),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDeriv_comp_diagonal","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ContinuousMultilinearMap ğ•œ (fun i => E) F\nx : E\nv : Fin n â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n (fun x => f fun x_1 => x) x) v) (Finset.univ.sum fun Ïƒ => f fun i => v (Ïƒ i))","decl":"lemma ContinuousMultilinearMap.iteratedFDeriv_comp_diagonal\n    {n : â„•} (f : E [Ã—n]â†’L[ğ•œ] F) (x : E) (v : Fin n â†’ E) :\n    iteratedFDeriv ğ•œ n (fun x â†¦ f (fun _ â†¦ x)) x v = âˆ‘ Ïƒ : Perm (Fin n), f (fun i â†¦ v (Ïƒ i)) := by\n  rw [â† sum_comp (Equiv.inv (Perm (Fin n)))]\n  let g : E â†’L[ğ•œ] (Fin n â†’ E) := ContinuousLinearMap.pi (fun i â†¦ ContinuousLinearMap.id ğ•œ E)\n  change iteratedFDeriv ğ•œ n (f âˆ˜ g) x v = _\n  rw [ContinuousLinearMap.iteratedFDeriv_comp_right _ f.contDiff _ le_rfl, f.iteratedFDeriv_eq]\n  simp only [ContinuousMultilinearMap.iteratedFDeriv,\n    ContinuousMultilinearMap.compContinuousLinearMap_apply, ContinuousMultilinearMap.sum_apply,\n    ContinuousMultilinearMap.iteratedFDerivComponent_apply, Set.mem_range, Pi.compRightL_apply]\n  rw [â† sum_comp (Equiv.embeddingEquivOfFinite (Fin n))]\n  congr with Ïƒ\n  congr with i\n  have A : âˆƒ y, Ïƒ y = i := by\n    have : Function.Bijective Ïƒ := (Fintype.bijective_iff_injective_and_card _).2 âŸ¨Ïƒ.injective, rflâŸ©\n    exact this.surjective i\n  rcases A with âŸ¨y, rflâŸ©\n  simp only [EmbeddingLike.apply_eq_iff_eq, exists_eq, â†“reduceDIte,\n    Function.Embedding.toEquivRange_symm_apply_self, ContinuousLinearMap.coe_pi',\n    ContinuousLinearMap.coe_id', id_eq, g]\n  congr 1\n  symm\n  simp [coe_fn_mk, inv_apply, Perm.inv_def,\n    ofBijective_symm_apply_apply, Function.Embedding.equivOfFiniteSelfEmbedding]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nn : Nat\nv : Fin n â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ n f s x) v) (Finset.univ.sum fun Ïƒ => (p n) fun i => v (Ïƒ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(vâ‚, ..., vâ‚™) â†¦ âˆ‘ pâ‚™ (v_{Ïƒ (1)}, ..., v_{Ïƒ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn ğ•œ f s)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {n : â„•} (v : Fin n â†’ E) :\n    iteratedFDerivWithin ğ•œ n f s x v = âˆ‘ Ïƒ : Perm (Fin n), p n (fun i â†¦ v (Ïƒ i)) := by\n  have : iteratedFDerivWithin ğ•œ n f s x\n      = iteratedFDerivWithin ğ•œ n f (s âˆ© EMetric.ball x r) x :=\n    (iteratedFDerivWithin_inter_open EMetric.isOpen_ball (EMetric.mem_ball_self h.r_pos)).symm\n  rw [this]\n  apply HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_subset\n  Â· exact h.mono inter_subset_left\n  Â· exact h'.mono inter_subset_left\n  Â· exact hs.inter EMetric.isOpen_ball\n  Â· exact âŸ¨hx, EMetric.mem_ball_self h.r_posâŸ©\n  Â· exact inter_subset_right\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\nh' : AnalyticOn ğ•œ f Set.univ\nn : Nat\nv : Fin n â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n f x) v) (Finset.univ.sum fun Ïƒ => (p n) fun i => v (Ïƒ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(vâ‚, ..., vâ‚™) â†¦ âˆ‘ pâ‚™ (v_{Ïƒ (1)}, ..., v_{Ïƒ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum\n    (h : HasFPowerSeriesOnBall f p x r) (h' : AnalyticOn ğ•œ f univ) {n : â„•} (v : Fin n â†’ E) :\n    iteratedFDeriv ğ•œ n f x v = âˆ‘ Ïƒ : Perm (Fin n), p n (fun i â†¦ v (Ïƒ i)) := by\n  simp only [â† iteratedFDerivWithin_univ, â† hasFPowerSeriesWithinOnBall_univ] at h âŠ¢\n  exact h.iteratedFDerivWithin_eq_sum h' uniqueDiffOn_univ (mem_univ x) v\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_completeSpace","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nn : Nat\nv : Fin n â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ n f s x) v) (Finset.univ.sum fun Ïƒ => (p n) fun i => v (Ïƒ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(vâ‚, ..., vâ‚™) â†¦ âˆ‘ pâ‚™ (v_{Ïƒ (1)}, ..., v_{Ïƒ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_completeSpace [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {n : â„•} (v : Fin n â†’ E) :\n    iteratedFDerivWithin ğ•œ n f s x v = âˆ‘ Ïƒ : Perm (Fin n), p n (fun i â†¦ v (Ïƒ i)) := by\n  have : iteratedFDerivWithin ğ•œ n f s x\n      = iteratedFDerivWithin ğ•œ n f (s âˆ© EMetric.ball x r) x :=\n    (iteratedFDerivWithin_inter_open EMetric.isOpen_ball (EMetric.mem_ball_self h.r_pos)).symm\n  rw [this]\n  apply HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_subset\n  Â· exact h.mono inter_subset_left\n  Â· apply h.analyticOn.mono\n    rw [insert_eq_of_mem hx]\n  Â· exact hs.inter EMetric.isOpen_ball\n  Â· exact âŸ¨hx, EMetric.mem_ball_self h.r_posâŸ©\n  Â· exact inter_subset_right\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum_of_completeSpace","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\nn : Nat\nv : Fin n â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n f x) v) (Finset.univ.sum fun Ïƒ => (p n) fun i => v (Ïƒ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(vâ‚, ..., vâ‚™) â†¦ âˆ‘ pâ‚™ (v_{Ïƒ (1)}, ..., v_{Ïƒ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum_of_completeSpace [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) {n : â„•} (v : Fin n â†’ E) :\n    iteratedFDeriv ğ•œ n f x v = âˆ‘ Ïƒ : Perm (Fin n), p n (fun i â†¦ v (Ïƒ i)) := by\n  simp only [â† iteratedFDerivWithin_univ, â† hasFPowerSeriesWithinOnBall_univ] at h âŠ¢\n  exact h.iteratedFDerivWithin_eq_sum_of_completeSpace uniqueDiffOn_univ (mem_univ _) v\n\n"}
{"name":"AnalyticOn.iteratedFDerivWithin_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nh : AnalyticOn ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nn : Nat\nv : Fin n â†’ E\nÏƒ : Equiv.Perm (Fin n)\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ n f s x) (Function.comp v â‡‘Ïƒ)) ((iteratedFDerivWithin ğ•œ n f s x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function on a set is symmetric. -/\ntheorem AnalyticOn.iteratedFDerivWithin_comp_perm\n    (h : AnalyticOn ğ•œ f s) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {n : â„•} (v : Fin n â†’ E)\n    (Ïƒ : Perm (Fin n)) :\n    iteratedFDerivWithin ğ•œ n f s x (v âˆ˜ Ïƒ) = iteratedFDerivWithin ğ•œ n f s x v := by\n  rcases h x hx with âŸ¨p, r, hpâŸ©\n  rw [hp.iteratedFDerivWithin_eq_sum h hs hx, hp.iteratedFDerivWithin_eq_sum h hs hx]\n  conv_rhs => rw [â† Equiv.sum_comp (Equiv.mulLeft Ïƒ)]\n  simp only [coe_mulLeft, Perm.coe_mul, Function.comp_apply]\n\n"}
{"name":"ContDiffWithinAt.iteratedFDerivWithin_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nh : ContDiffWithinAt ğ•œ Top.top f s x\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nn : Nat\nv : Fin n â†’ E\nÏƒ : Equiv.Perm (Fin n)\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ n f s x) (Function.comp v â‡‘Ïƒ)) ((iteratedFDerivWithin ğ•œ n f s x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function on a set is symmetric. -/\ntheorem ContDiffWithinAt.iteratedFDerivWithin_comp_perm\n    (h : ContDiffWithinAt ğ•œ Ï‰ f s x) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {n : â„•} (v : Fin n â†’ E)\n    (Ïƒ : Perm (Fin n)) :\n    iteratedFDerivWithin ğ•œ n f s x (v âˆ˜ Ïƒ) = iteratedFDerivWithin ğ•œ n f s x v := by\n  rcases h.contDiffOn' le_rfl (by simp) with âŸ¨u, u_open, xu, huâŸ©\n  rw [insert_eq_of_mem hx] at hu\n  have : iteratedFDerivWithin ğ•œ n f (s âˆ© u) x = iteratedFDerivWithin ğ•œ n f s x :=\n    iteratedFDerivWithin_inter_open u_open xu\n  rw [â† this]\n  exact AnalyticOn.iteratedFDerivWithin_comp_perm hu.analyticOn (hs.inter u_open) âŸ¨hx, xuâŸ© _ _\n\n"}
{"name":"AnalyticOn.iteratedFDeriv_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : AnalyticOn ğ•œ f Set.univ\nn : Nat\nv : Fin n â†’ E\nÏƒ : Equiv.Perm (Fin n)\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n f x) (Function.comp v â‡‘Ïƒ)) ((iteratedFDeriv ğ•œ n f x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function is symmetric. -/\ntheorem AnalyticOn.iteratedFDeriv_comp_perm\n    (h : AnalyticOn ğ•œ f univ) {n : â„•} (v : Fin n â†’ E) (Ïƒ : Perm (Fin n)) :\n    iteratedFDeriv ğ•œ n f x (v âˆ˜ Ïƒ) = iteratedFDeriv ğ•œ n f x v := by\n  rw [â† iteratedFDerivWithin_univ]\n  exact h.iteratedFDerivWithin_comp_perm uniqueDiffOn_univ (mem_univ x) _ _\n\n"}
{"name":"ContDiffAt.iteratedFDeriv_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : ContDiffAt ğ•œ Top.top f x\nn : Nat\nv : Fin n â†’ E\nÏƒ : Equiv.Perm (Fin n)\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n f x) (Function.comp v â‡‘Ïƒ)) ((iteratedFDeriv ğ•œ n f x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function is symmetric. -/\ntheorem ContDiffAt.iteratedFDeriv_comp_perm\n    (h : ContDiffAt ğ•œ Ï‰ f x) {n : â„•} (v : Fin n â†’ E) (Ïƒ : Perm (Fin n)) :\n    iteratedFDeriv ğ•œ n f x (v âˆ˜ Ïƒ) = iteratedFDeriv ğ•œ n f x v := by\n  rw [â† iteratedFDerivWithin_univ]\n  exact h.iteratedFDerivWithin_comp_perm uniqueDiffOn_univ (mem_univ x) _ _\n"}
