{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn 𝕜 f s\nk : Nat\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ HasFPowerSeriesWithinOnBall (iteratedFDerivWithin 𝕜 k f s) (p.iteratedFDerivSeries k) s x r","decl":"/-- If a function has a power series on a ball, then so do its iterated derivatives. -/\nprotected theorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn 𝕜 f s)\n    (k : ℕ) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    HasFPowerSeriesWithinOnBall (iteratedFDerivWithin 𝕜 k f s)\n      (p.iteratedFDerivSeries k) s x r := by\n  induction k with\n  | zero =>\n    exact (continuousMultilinearCurryFin0 𝕜 E F).symm\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall h\n  | succ k ih =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left]\n    apply (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (k + 1) ↦ E) F).symm\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall\n        (ih.fderivWithin_of_mem_of_analyticOn (h'.iteratedFDerivWithin hs _) hs hx)\n\n"}
{"name":"FormalMultilinearSeries.iteratedFDerivSeries_eq_zero","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nk n : Nat\nh : Eq (p (HAdd.hAdd n k)) 0\n⊢ Eq (p.iteratedFDerivSeries k n) 0","decl":"lemma FormalMultilinearSeries.iteratedFDerivSeries_eq_zero {k n : ℕ}\n    (h : p (n + k) = 0) : p.iteratedFDerivSeries k n = 0 := by\n  induction k generalizing n with\n  | zero =>\n    ext\n    have : p n = 0 := p.congr_zero rfl h\n    simp [FormalMultilinearSeries.iteratedFDerivSeries, this]\n  | succ k ih =>\n    ext\n    simp only [iteratedFDerivSeries, Nat.succ_eq_add_one,\n      ContinuousLinearMap.compFormalMultilinearSeries_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe,\n      LinearIsometryEquiv.coe_toContinuousLinearEquiv, Function.comp_apply,\n      continuousMultilinearCurryLeftEquiv_symm_apply, ContinuousMultilinearMap.zero_apply,\n      ContinuousLinearMap.zero_apply,\n      derivSeries_eq_zero _ (ih (p.congr_zero (Nat.succ_add_eq_add_succ _ _).symm h))]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_zero","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn 𝕜 f s\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nhn : Eq (p n) 0\n⊢ Eq (iteratedFDerivWithin 𝕜 n f s x) 0","decl":"/-- If the `n`-th term in a power series is zero, then the `n`-th derivative of the corresponding\nfunction vanishes. -/\nlemma HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_zero\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn 𝕜 f s)\n    (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (hn : p n = 0) :\n    iteratedFDerivWithin 𝕜 n f s x = 0 := by\n  have : iteratedFDerivWithin 𝕜 n f s x = p.iteratedFDerivSeries n 0 (fun _ ↦ 0) :=\n    ((h.iteratedFDerivWithin h' n hu hx).coeff_zero _).symm\n  rw [this, p.iteratedFDerivSeries_eq_zero (p.congr_zero (Nat.zero_add n).symm hn),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDeriv_comp_diagonal","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : ContinuousMultilinearMap 𝕜 (fun i => E) F\nx : E\nv : Fin n → E\n⊢ Eq ((iteratedFDeriv 𝕜 n (fun x => f fun x_1 => x) x) v) (Finset.univ.sum fun σ => f fun i => v (σ i))","decl":"lemma ContinuousMultilinearMap.iteratedFDeriv_comp_diagonal\n    {n : ℕ} (f : E [×n]→L[𝕜] F) (x : E) (v : Fin n → E) :\n    iteratedFDeriv 𝕜 n (fun x ↦ f (fun _ ↦ x)) x v = ∑ σ : Perm (Fin n), f (fun i ↦ v (σ i)) := by\n  rw [← sum_comp (Equiv.inv (Perm (Fin n)))]\n  let g : E →L[𝕜] (Fin n → E) := ContinuousLinearMap.pi (fun i ↦ ContinuousLinearMap.id 𝕜 E)\n  change iteratedFDeriv 𝕜 n (f ∘ g) x v = _\n  rw [ContinuousLinearMap.iteratedFDeriv_comp_right _ f.contDiff _ le_rfl, f.iteratedFDeriv_eq]\n  simp only [ContinuousMultilinearMap.iteratedFDeriv,\n    ContinuousMultilinearMap.compContinuousLinearMap_apply, ContinuousMultilinearMap.sum_apply,\n    ContinuousMultilinearMap.iteratedFDerivComponent_apply, Set.mem_range, Pi.compRightL_apply]\n  rw [← sum_comp (Equiv.embeddingEquivOfFinite (Fin n))]\n  congr with σ\n  congr with i\n  have A : ∃ y, σ y = i := by\n    have : Function.Bijective σ := (Fintype.bijective_iff_injective_and_card _).2 ⟨σ.injective, rfl⟩\n    exact this.surjective i\n  rcases A with ⟨y, rfl⟩\n  simp only [EmbeddingLike.apply_eq_iff_eq, exists_eq, ↓reduceDIte,\n    Function.Embedding.toEquivRange_symm_apply_self, ContinuousLinearMap.coe_pi',\n    ContinuousLinearMap.coe_id', id_eq, g]\n  congr 1\n  symm\n  simp [coe_fn_mk, inv_apply, Perm.inv_def,\n    ofBijective_symm_apply_apply, Function.Embedding.equivOfFiniteSelfEmbedding]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : AnalyticOn 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nv : Fin n → E\n⊢ Eq ((iteratedFDerivWithin 𝕜 n f s x) v) (Finset.univ.sum fun σ => (p n) fun i => v (σ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(v₁, ..., vₙ) ↦ ∑ pₙ (v_{σ (1)}, ..., v_{σ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (h' : AnalyticOn 𝕜 f s)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (v : Fin n → E) :\n    iteratedFDerivWithin 𝕜 n f s x v = ∑ σ : Perm (Fin n), p n (fun i ↦ v (σ i)) := by\n  have : iteratedFDerivWithin 𝕜 n f s x\n      = iteratedFDerivWithin 𝕜 n f (s ∩ EMetric.ball x r) x :=\n    (iteratedFDerivWithin_inter_open EMetric.isOpen_ball (EMetric.mem_ball_self h.r_pos)).symm\n  rw [this]\n  apply HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_subset\n  · exact h.mono inter_subset_left\n  · exact h'.mono inter_subset_left\n  · exact hs.inter EMetric.isOpen_ball\n  · exact ⟨hx, EMetric.mem_ball_self h.r_pos⟩\n  · exact inter_subset_right\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\nh' : AnalyticOn 𝕜 f Set.univ\nn : Nat\nv : Fin n → E\n⊢ Eq ((iteratedFDeriv 𝕜 n f x) v) (Finset.univ.sum fun σ => (p n) fun i => v (σ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(v₁, ..., vₙ) ↦ ∑ pₙ (v_{σ (1)}, ..., v_{σ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum\n    (h : HasFPowerSeriesOnBall f p x r) (h' : AnalyticOn 𝕜 f univ) {n : ℕ} (v : Fin n → E) :\n    iteratedFDeriv 𝕜 n f x v = ∑ σ : Perm (Fin n), p n (fun i ↦ v (σ i)) := by\n  simp only [← iteratedFDerivWithin_univ, ← hasFPowerSeriesWithinOnBall_univ] at h ⊢\n  exact h.iteratedFDerivWithin_eq_sum h' uniqueDiffOn_univ (mem_univ x) v\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_completeSpace","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nv : Fin n → E\n⊢ Eq ((iteratedFDerivWithin 𝕜 n f s x) v) (Finset.univ.sum fun σ => (p n) fun i => v (σ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(v₁, ..., vₙ) ↦ ∑ pₙ (v_{σ (1)}, ..., v_{σ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_completeSpace [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (v : Fin n → E) :\n    iteratedFDerivWithin 𝕜 n f s x v = ∑ σ : Perm (Fin n), p n (fun i ↦ v (σ i)) := by\n  have : iteratedFDerivWithin 𝕜 n f s x\n      = iteratedFDerivWithin 𝕜 n f (s ∩ EMetric.ball x r) x :=\n    (iteratedFDerivWithin_inter_open EMetric.isOpen_ball (EMetric.mem_ball_self h.r_pos)).symm\n  rw [this]\n  apply HasFPowerSeriesWithinOnBall.iteratedFDerivWithin_eq_sum_of_subset\n  · exact h.mono inter_subset_left\n  · apply h.analyticOn.mono\n    rw [insert_eq_of_mem hx]\n  · exact hs.inter EMetric.isOpen_ball\n  · exact ⟨hx, EMetric.mem_ball_self h.r_pos⟩\n  · exact inter_subset_right\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum_of_completeSpace","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\nn : Nat\nv : Fin n → E\n⊢ Eq ((iteratedFDeriv 𝕜 n f x) v) (Finset.univ.sum fun σ => (p n) fun i => v (σ i))","decl":"/-- If a function has a power series in a ball, then its `n`-th iterated derivative is given by\n`(v₁, ..., vₙ) ↦ ∑ pₙ (v_{σ (1)}, ..., v_{σ (n)})` where the sum is over all\npermutations of `{1, ..., n}`.-/\ntheorem HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum_of_completeSpace [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) {n : ℕ} (v : Fin n → E) :\n    iteratedFDeriv 𝕜 n f x v = ∑ σ : Perm (Fin n), p n (fun i ↦ v (σ i)) := by\n  simp only [← iteratedFDerivWithin_univ, ← hasFPowerSeriesWithinOnBall_univ] at h ⊢\n  exact h.iteratedFDerivWithin_eq_sum_of_completeSpace uniqueDiffOn_univ (mem_univ _) v\n\n"}
{"name":"AnalyticOn.iteratedFDerivWithin_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nh : AnalyticOn 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nv : Fin n → E\nσ : Equiv.Perm (Fin n)\n⊢ Eq ((iteratedFDerivWithin 𝕜 n f s x) (Function.comp v ⇑σ)) ((iteratedFDerivWithin 𝕜 n f s x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function on a set is symmetric. -/\ntheorem AnalyticOn.iteratedFDerivWithin_comp_perm\n    (h : AnalyticOn 𝕜 f s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (v : Fin n → E)\n    (σ : Perm (Fin n)) :\n    iteratedFDerivWithin 𝕜 n f s x (v ∘ σ) = iteratedFDerivWithin 𝕜 n f s x v := by\n  rcases h x hx with ⟨p, r, hp⟩\n  rw [hp.iteratedFDerivWithin_eq_sum h hs hx, hp.iteratedFDerivWithin_eq_sum h hs hx]\n  conv_rhs => rw [← Equiv.sum_comp (Equiv.mulLeft σ)]\n  simp only [coe_mulLeft, Perm.coe_mul, Function.comp_apply]\n\n"}
{"name":"ContDiffWithinAt.iteratedFDerivWithin_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nh : ContDiffWithinAt 𝕜 Top.top f s x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nv : Fin n → E\nσ : Equiv.Perm (Fin n)\n⊢ Eq ((iteratedFDerivWithin 𝕜 n f s x) (Function.comp v ⇑σ)) ((iteratedFDerivWithin 𝕜 n f s x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function on a set is symmetric. -/\ntheorem ContDiffWithinAt.iteratedFDerivWithin_comp_perm\n    (h : ContDiffWithinAt 𝕜 ω f s x) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (v : Fin n → E)\n    (σ : Perm (Fin n)) :\n    iteratedFDerivWithin 𝕜 n f s x (v ∘ σ) = iteratedFDerivWithin 𝕜 n f s x v := by\n  rcases h.contDiffOn' le_rfl (by simp) with ⟨u, u_open, xu, hu⟩\n  rw [insert_eq_of_mem hx] at hu\n  have : iteratedFDerivWithin 𝕜 n f (s ∩ u) x = iteratedFDerivWithin 𝕜 n f s x :=\n    iteratedFDerivWithin_inter_open u_open xu\n  rw [← this]\n  exact AnalyticOn.iteratedFDerivWithin_comp_perm hu.analyticOn (hs.inter u_open) ⟨hx, xu⟩ _ _\n\n"}
{"name":"AnalyticOn.iteratedFDeriv_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : AnalyticOn 𝕜 f Set.univ\nn : Nat\nv : Fin n → E\nσ : Equiv.Perm (Fin n)\n⊢ Eq ((iteratedFDeriv 𝕜 n f x) (Function.comp v ⇑σ)) ((iteratedFDeriv 𝕜 n f x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function is symmetric. -/\ntheorem AnalyticOn.iteratedFDeriv_comp_perm\n    (h : AnalyticOn 𝕜 f univ) {n : ℕ} (v : Fin n → E) (σ : Perm (Fin n)) :\n    iteratedFDeriv 𝕜 n f x (v ∘ σ) = iteratedFDeriv 𝕜 n f x v := by\n  rw [← iteratedFDerivWithin_univ]\n  exact h.iteratedFDerivWithin_comp_perm uniqueDiffOn_univ (mem_univ x) _ _\n\n"}
{"name":"ContDiffAt.iteratedFDeriv_comp_perm","module":"Mathlib.Analysis.Analytic.IteratedFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : ContDiffAt 𝕜 Top.top f x\nn : Nat\nv : Fin n → E\nσ : Equiv.Perm (Fin n)\n⊢ Eq ((iteratedFDeriv 𝕜 n f x) (Function.comp v ⇑σ)) ((iteratedFDeriv 𝕜 n f x) v)","decl":"/-- The `n`-th iterated derivative of an analytic function is symmetric. -/\ntheorem ContDiffAt.iteratedFDeriv_comp_perm\n    (h : ContDiffAt 𝕜 ω f x) {n : ℕ} (v : Fin n → E) (σ : Perm (Fin n)) :\n    iteratedFDeriv 𝕜 n f x (v ∘ σ) = iteratedFDeriv 𝕜 n f x v := by\n  rw [← iteratedFDerivWithin_univ]\n  exact h.iteratedFDerivWithin_comp_perm uniqueDiffOn_univ (mem_univ x) _ _\n"}
