{"name":"mem_idRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\na b : Œ±\n‚ä¢ Iff (Membership.mem idRel { fst := a, snd := b }) (Eq a b)","decl":"@[simp]\ntheorem mem_idRel {a b : Œ±} : (a, b) ‚àà @idRel Œ± ‚Üî a = b :=\n  Iff.rfl\n\n"}
{"name":"idRel_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns : Set (Prod Œ± Œ±)\n‚ä¢ Iff (HasSubset.Subset idRel s) (‚àÄ (a : Œ±), Membership.mem s { fst := a, snd := a })","decl":"@[simp]\ntheorem idRel_subset {s : Set (Œ± √ó Œ±)} : idRel ‚äÜ s ‚Üî ‚àÄ a, (a, a) ‚àà s := by\n  simp [subset_def]\n\n"}
{"name":"eq_singleton_left_of_prod_subset_idRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : HasSubset.Subset (SProd.sprod S T) idRel\n‚ä¢ Exists fun x => Eq S (Singleton.singleton x)","decl":"theorem eq_singleton_left_of_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S √óÀ¢ T ‚äÜ idRel) : ‚àÉ x, S = {x} := by\n  rcases hS, hT with ‚ü®‚ü®s, hs‚ü©, ‚ü®t, ht‚ü©‚ü©\n  refine ‚ü®s, eq_singleton_iff_nonempty_unique_mem.mpr ‚ü®‚ü®s, hs‚ü©, fun x hx ‚Ü¶ ?_‚ü©‚ü©\n  rw [prod_subset_iff] at h_diag\n  replace hs := h_diag s hs t ht\n  replace hx := h_diag x hx t ht\n  simp only [idRel, mem_setOf_eq] at hx hs\n  rwa [‚Üê hs] at hx\n\n"}
{"name":"eq_singleton_right_prod_subset_idRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : HasSubset.Subset (SProd.sprod S T) idRel\n‚ä¢ Exists fun x => Eq T (Singleton.singleton x)","decl":"theorem eq_singleton_right_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S √óÀ¢ T ‚äÜ idRel) : ‚àÉ x, T = {x} := by\n  rw [Set.prod_subset_iff] at h_diag\n  replace h_diag := fun x hx y hy => (h_diag y hy x hx).symm\n  exact eq_singleton_left_of_prod_subset_idRel hT hS (prod_subset_iff.mpr h_diag)\n\n"}
{"name":"eq_singleton_prod_subset_idRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"X : Type u_2\nS T : Set X\nhS : S.Nonempty\nhT : T.Nonempty\nh_diag : HasSubset.Subset (SProd.sprod S T) idRel\n‚ä¢ Exists fun x => And (Eq S (Singleton.singleton x)) (Eq T (Singleton.singleton x))","decl":"theorem eq_singleton_prod_subset_idRel {X : Type*} {S T : Set X} (hS : S.Nonempty)\n    (hT : T.Nonempty) (h_diag : S √óÀ¢ T ‚äÜ idRel) : ‚àÉ x, S = {x} ‚àß T = {x} := by\n  obtain ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü© := eq_singleton_left_of_prod_subset_idRel hS hT h_diag,\n    eq_singleton_right_prod_subset_idRel hS hT h_diag\n  refine ‚ü®x, ‚ü®hx, ?_‚ü©‚ü©\n  rw [hy, Set.singleton_eq_singleton_iff]\n  exact (Set.prod_subset_iff.mp h_diag x (by simp only [hx, Set.mem_singleton]) y\n    (by simp only [hy, Set.mem_singleton])).symm\n\n"}
{"name":"mem_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nr‚ÇÅ r‚ÇÇ : Set (Prod Œ± Œ±)\nx y : Œ±\n‚ä¢ Iff (Membership.mem (compRel r‚ÇÅ r‚ÇÇ) { fst := x, snd := y }) (Exists fun z => And (Membership.mem r‚ÇÅ { fst := x, snd := z }) (Membership.mem r‚ÇÇ { fst := z, snd := y }))","decl":"@[simp]\ntheorem mem_compRel {Œ± : Type u} {r‚ÇÅ r‚ÇÇ : Set (Œ± √ó Œ±)} {x y : Œ±} :\n    (x, y) ‚àà r‚ÇÅ ‚óã r‚ÇÇ ‚Üî ‚àÉ z, (x, z) ‚àà r‚ÇÅ ‚àß (z, y) ‚àà r‚ÇÇ :=\n  Iff.rfl\n\n"}
{"name":"swap_idRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\n‚ä¢ Eq (Set.image Prod.swap idRel) idRel","decl":"@[simp]\ntheorem swap_idRel : Prod.swap '' idRel = @idRel Œ± :=\n  Set.ext fun ‚ü®a, b‚ü© => by simpa [image_swap_eq_preimage_swap] using eq_comm\n\n"}
{"name":"Monotone.compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : Preorder Œ≤\nf g : Œ≤ ‚Üí Set (Prod Œ± Œ±)\nhf : Monotone f\nhg : Monotone g\n‚ä¢ Monotone fun x => compRel (f x) (g x)","decl":"theorem Monotone.compRel [Preorder Œ≤] {f g : Œ≤ ‚Üí Set (Œ± √ó Œ±)} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x ‚óã g x := fun _ _ h _ ‚ü®z, h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®z, hf h h‚ÇÅ, hg h h‚ÇÇ‚ü©\n\n"}
{"name":"compRel_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nf g h k : Set (Prod Œ± Œ±)\nh‚ÇÅ : HasSubset.Subset f h\nh‚ÇÇ : HasSubset.Subset g k\n‚ä¢ HasSubset.Subset (compRel f g) (compRel h k)","decl":"@[mono, gcongr]\ntheorem compRel_mono {f g h k : Set (Œ± √ó Œ±)} (h‚ÇÅ : f ‚äÜ h) (h‚ÇÇ : g ‚äÜ k) : f ‚óã g ‚äÜ h ‚óã k :=\n  fun _ ‚ü®z, h, h'‚ü© => ‚ü®z, h‚ÇÅ h, h‚ÇÇ h'‚ü©\n\n"}
{"name":"prod_mk_mem_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\na b c : Œ±\ns t : Set (Prod Œ± Œ±)\nh‚ÇÅ : Membership.mem s { fst := a, snd := c }\nh‚ÇÇ : Membership.mem t { fst := c, snd := b }\n‚ä¢ Membership.mem (compRel s t) { fst := a, snd := b }","decl":"theorem prod_mk_mem_compRel {a b c : Œ±} {s t : Set (Œ± √ó Œ±)} (h‚ÇÅ : (a, c) ‚àà s) (h‚ÇÇ : (c, b) ‚àà t) :\n    (a, b) ‚àà s ‚óã t :=\n  ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü©\n\n"}
{"name":"id_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nr : Set (Prod Œ± Œ±)\n‚ä¢ Eq (compRel idRel r) r","decl":"@[simp]\ntheorem id_compRel {r : Set (Œ± √ó Œ±)} : idRel ‚óã r = r :=\n  Set.ext fun ‚ü®a, b‚ü© => by simp\n\n"}
{"name":"compRel_assoc","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nr s t : Set (Prod Œ± Œ±)\n‚ä¢ Eq (compRel (compRel r s) t) (compRel r (compRel s t))","decl":"theorem compRel_assoc {r s t : Set (Œ± √ó Œ±)} : r ‚óã s ‚óã t = r ‚óã (s ‚óã t) := by\n  ext ‚ü®a, b‚ü©; simp only [mem_compRel]; tauto\n\n"}
{"name":"left_subset_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns t : Set (Prod Œ± Œ±)\nh : HasSubset.Subset idRel t\n‚ä¢ HasSubset.Subset s (compRel s t)","decl":"theorem left_subset_compRel {s t : Set (Œ± √ó Œ±)} (h : idRel ‚äÜ t) : s ‚äÜ s ‚óã t := fun ‚ü®_x, y‚ü© xy_in =>\n  ‚ü®y, xy_in, h <| rfl‚ü©\n\n"}
{"name":"right_subset_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns t : Set (Prod Œ± Œ±)\nh : HasSubset.Subset idRel s\n‚ä¢ HasSubset.Subset t (compRel s t)","decl":"theorem right_subset_compRel {s t : Set (Œ± √ó Œ±)} (h : idRel ‚äÜ s) : t ‚äÜ s ‚óã t := fun ‚ü®x, _y‚ü© xy_in =>\n  ‚ü®x, h <| rfl, xy_in‚ü©\n\n"}
{"name":"subset_comp_self","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns : Set (Prod Œ± Œ±)\nh : HasSubset.Subset idRel s\n‚ä¢ HasSubset.Subset s (compRel s s)","decl":"theorem subset_comp_self {s : Set (Œ± √ó Œ±)} (h : idRel ‚äÜ s) : s ‚äÜ s ‚óã s :=\n  left_subset_compRel h\n\n"}
{"name":"subset_iterate_compRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns t : Set (Prod Œ± Œ±)\nh : HasSubset.Subset idRel s\nn : Nat\n‚ä¢ HasSubset.Subset t (Nat.iterate (fun x => compRel s x) n t)","decl":"theorem subset_iterate_compRel {s t : Set (Œ± √ó Œ±)} (h : idRel ‚äÜ s) (n : ‚Ñï) :\n    t ‚äÜ (s ‚óã ¬∑)^[n] t := by\n  induction' n with n ihn generalizing t\n  exacts [Subset.rfl, (right_subset_compRel h).trans ihn]\n\n"}
{"name":"symmetric_symmetrizeRel","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nV : Set (Prod Œ± Œ±)\n‚ä¢ SymmetricRel (symmetrizeRel V)","decl":"theorem symmetric_symmetrizeRel (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) := by\n  simp [SymmetricRel, symmetrizeRel, preimage_inter, inter_comm, ‚Üê preimage_comp]\n\n"}
{"name":"symmetrizeRel_subset_self","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nV : Set (Prod Œ± Œ±)\n‚ä¢ HasSubset.Subset (symmetrizeRel V) V","decl":"theorem symmetrizeRel_subset_self (V : Set (Œ± √ó Œ±)) : symmetrizeRel V ‚äÜ V :=\n  sep_subset _ _\n\n"}
{"name":"symmetrize_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nV W : Set (Prod Œ± Œ±)\nh : HasSubset.Subset V W\n‚ä¢ HasSubset.Subset (symmetrizeRel V) (symmetrizeRel W)","decl":"@[mono]\ntheorem symmetrize_mono {V W : Set (Œ± √ó Œ±)} (h : V ‚äÜ W) : symmetrizeRel V ‚äÜ symmetrizeRel W :=\n  inter_subset_inter h <| preimage_mono h\n\n"}
{"name":"SymmetricRel.mk_mem_comm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nV : Set (Prod Œ± Œ±)\nhV : SymmetricRel V\nx y : Œ±\n‚ä¢ Iff (Membership.mem V { fst := x, snd := y }) (Membership.mem V { fst := y, snd := x })","decl":"theorem SymmetricRel.mk_mem_comm {V : Set (Œ± √ó Œ±)} (hV : SymmetricRel V) {x y : Œ±} :\n    (x, y) ‚àà V ‚Üî (y, x) ‚àà V :=\n  Set.ext_iff.1 hV (y, x)\n\n"}
{"name":"SymmetricRel.eq","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nU : Set (Prod Œ± Œ±)\nhU : SymmetricRel U\n‚ä¢ Eq (Set.preimage Prod.swap U) U","decl":"theorem SymmetricRel.eq {U : Set (Œ± √ó Œ±)} (hU : SymmetricRel U) : Prod.swap ‚Åª¬π' U = U :=\n  hU\n\n"}
{"name":"SymmetricRel.inter","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nU V : Set (Prod Œ± Œ±)\nhU : SymmetricRel U\nhV : SymmetricRel V\n‚ä¢ SymmetricRel (Inter.inter U V)","decl":"theorem SymmetricRel.inter {U V : Set (Œ± √ó Œ±)} (hU : SymmetricRel U) (hV : SymmetricRel V) :\n    SymmetricRel (U ‚à© V) := by rw [SymmetricRel, preimage_inter, hU.eq, hV.eq]\n\n"}
{"name":"UniformSpace.Core.symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace.Core Œ±\n‚ä¢ Filter.Tendsto Prod.swap self.uniformity self.uniformity","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.mk.injEq","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nuniformity‚úù : Filter (Prod Œ± Œ±)\nrefl‚úù : LE.le (Filter.principal idRel) uniformity‚úù\nsymm‚úù : Filter.Tendsto Prod.swap uniformity‚úù uniformity‚úù\ncomp‚úù : LE.le (uniformity‚úù.lift' fun s => compRel s s) uniformity‚úù\nuniformity : Filter (Prod Œ± Œ±)\nrefl : LE.le (Filter.principal idRel) uniformity\nsymm : Filter.Tendsto Prod.swap uniformity uniformity\ncomp : LE.le (uniformity.lift' fun s => compRel s s) uniformity\n‚ä¢ Eq (Eq { uniformity := uniformity‚úù, refl := refl‚úù, symm := symm‚úù, comp := comp‚úù } { uniformity := uniformity, refl := refl, symm := symm, comp := comp }) (Eq uniformity‚úù uniformity)","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.mk.inj","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nuniformity‚úù : Filter (Prod Œ± Œ±)\nrefl‚úù : LE.le (Filter.principal idRel) uniformity‚úù\nsymm‚úù : Filter.Tendsto Prod.swap uniformity‚úù uniformity‚úù\ncomp‚úù : LE.le (uniformity‚úù.lift' fun s => compRel s s) uniformity‚úù\nuniformity : Filter (Prod Œ± Œ±)\nrefl : LE.le (Filter.principal idRel) uniformity\nsymm : Filter.Tendsto Prod.swap uniformity uniformity\ncomp : LE.le (uniformity.lift' fun s => compRel s s) uniformity\nx‚úù : Eq { uniformity := uniformity‚úù, refl := refl‚úù, symm := symm‚úù, comp := comp‚úù } { uniformity := uniformity, refl := refl, symm := symm, comp := comp }\n‚ä¢ Eq uniformity‚úù uniformity","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.mk.sizeOf_spec","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\ninst‚úù : SizeOf Œ±\nuniformity : Filter (Prod Œ± Œ±)\nrefl : LE.le (Filter.principal idRel) uniformity\nsymm : Filter.Tendsto Prod.swap uniformity uniformity\ncomp : LE.le (uniformity.lift' fun s => compRel s s) uniformity\n‚ä¢ Eq (SizeOf.sizeOf { uniformity := uniformity, refl := refl, symm := symm, comp := comp }) (HAdd.hAdd 1 (SizeOf.sizeOf uniformity))","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.refl","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace.Core Œ±\n‚ä¢ LE.le (Filter.principal idRel) self.uniformity","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace.Core Œ±\n‚ä¢ LE.le (self.uniformity.lift' fun s => compRel s s) self.uniformity","decl":"/-- This core description of a uniform space is outside of the type class hierarchy. It is useful\n  for constructions of uniform spaces, when the topology is derived from the uniform space. -/\nstructure UniformSpace.Core (Œ± : Type u) where\n  /-- The uniformity filter. Once `UniformSpace` is defined, `ùì§ Œ±` (`_root_.uniformity`) becomes the\n  normal form. -/\n  uniformity : Filter (Œ± √ó Œ±)\n  /-- Every set in the uniformity filter includes the diagonal. -/\n  refl : ùìü idRel ‚â§ uniformity\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n\n"}
{"name":"UniformSpace.Core.comp_mem_uniformity_sets","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nc : UniformSpace.Core Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem c.uniformity s\n‚ä¢ Exists fun t => And (Membership.mem c.uniformity t) (HasSubset.Subset (compRel t t) s)","decl":"protected theorem UniformSpace.Core.comp_mem_uniformity_sets {c : Core Œ±} {s : Set (Œ± √ó Œ±)}\n    (hs : s ‚àà c.uniformity) : ‚àÉ t ‚àà c.uniformity, t ‚óã t ‚äÜ s :=\n  (mem_lift'_sets <| monotone_id.compRel monotone_id).mp <| c.comp hs\n\n"}
{"name":"UniformSpace.Core.ext","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace.Core Œ±\na‚úù : Eq u‚ÇÅ.uniformity u‚ÇÇ.uniformity\n‚ä¢ Eq u‚ÇÅ u‚ÇÇ","decl":"theorem UniformSpace.Core.ext :\n    ‚àÄ {u‚ÇÅ u‚ÇÇ : UniformSpace.Core Œ±}, u‚ÇÅ.uniformity = u‚ÇÇ.uniformity ‚Üí u‚ÇÅ = u‚ÇÇ\n  | ‚ü®_, _, _, _‚ü©, ‚ü®_, _, _, _‚ü©, rfl => rfl\n\n"}
{"name":"UniformSpace.Core.nhds_toTopologicalSpace","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nu : UniformSpace.Core Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) (Filter.comap (Prod.mk x) u.uniformity)","decl":"theorem UniformSpace.Core.nhds_toTopologicalSpace {Œ± : Type u} (u : Core Œ±) (x : Œ±) :\n    @nhds Œ± u.toTopologicalSpace x = comap (Prod.mk x) u.uniformity := by\n  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis (fun _ ‚Ü¶ (basis_sets _).comap _)\n  ¬∑ exact fun a U hU ‚Ü¶ u.refl hU rfl\n  ¬∑ intro a U hU\n    rcases u.comp_mem_uniformity_sets hU with ‚ü®V, hV, hVU‚ü©\n    filter_upwards [preimage_mem_comap hV] with b hb\n    filter_upwards [preimage_mem_comap hV] with c hc\n    exact hVU ‚ü®b, hb, hc‚ü©\n\n-- the topological structure is embedded in the uniform structure\n-- to avoid instance diamond issues. See Note [forgetful inheritance].\n"}
{"name":"UniformSpace.nhds_eq_comap_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) (Filter.comap (Prod.mk x) UniformSpace.uniformity)","decl":"/-- A uniform space is a generalization of the \"uniform\" topological aspects of a\n  metric space. It consists of a filter on `Œ± √ó Œ±` called the \"uniformity\", which\n  satisfies properties analogous to the reflexivity, symmetry, and triangle properties\n  of a metric.\n\n  A metric space has a natural uniformity, and a uniform space has a natural topology.\n  A topological group also has a natural uniformity, even when it is not metrizable. -/\nclass UniformSpace (Œ± : Type u) extends TopologicalSpace Œ± where\n  /-- The uniformity filter. -/\n  protected uniformity : Filter (Œ± √ó Œ±)\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  protected symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  protected comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n  /-- The uniformity agrees with the topology: the neighborhoods filter of each point `x`\n  is equal to `Filter.comap (Prod.mk x) (ùì§ Œ±)`. -/\n  protected nhds_eq_comap_uniformity (x : Œ±) : ùìù x = comap (Prod.mk x) uniformity\n\n"}
{"name":"UniformSpace.symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace Œ±\n‚ä¢ Filter.Tendsto Prod.swap UniformSpace.uniformity UniformSpace.uniformity","decl":"/-- A uniform space is a generalization of the \"uniform\" topological aspects of a\n  metric space. It consists of a filter on `Œ± √ó Œ±` called the \"uniformity\", which\n  satisfies properties analogous to the reflexivity, symmetry, and triangle properties\n  of a metric.\n\n  A metric space has a natural uniformity, and a uniform space has a natural topology.\n  A topological group also has a natural uniformity, even when it is not metrizable. -/\nclass UniformSpace (Œ± : Type u) extends TopologicalSpace Œ± where\n  /-- The uniformity filter. -/\n  protected uniformity : Filter (Œ± √ó Œ±)\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  protected symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  protected comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n  /-- The uniformity agrees with the topology: the neighborhoods filter of each point `x`\n  is equal to `Filter.comap (Prod.mk x) (ùì§ Œ±)`. -/\n  protected nhds_eq_comap_uniformity (x : Œ±) : ùìù x = comap (Prod.mk x) uniformity\n\n"}
{"name":"UniformSpace.comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u\nself : UniformSpace Œ±\n‚ä¢ LE.le (UniformSpace.uniformity.lift' fun s => compRel s s) UniformSpace.uniformity","decl":"/-- A uniform space is a generalization of the \"uniform\" topological aspects of a\n  metric space. It consists of a filter on `Œ± √ó Œ±` called the \"uniformity\", which\n  satisfies properties analogous to the reflexivity, symmetry, and triangle properties\n  of a metric.\n\n  A metric space has a natural uniformity, and a uniform space has a natural topology.\n  A topological group also has a natural uniformity, even when it is not metrizable. -/\nclass UniformSpace (Œ± : Type u) extends TopologicalSpace Œ± where\n  /-- The uniformity filter. -/\n  protected uniformity : Filter (Œ± √ó Œ±)\n  /-- If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. -/\n  protected symm : Tendsto Prod.swap uniformity uniformity\n  /-- For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. -/\n  protected comp : (uniformity.lift' fun s => s ‚óã s) ‚â§ uniformity\n  /-- The uniformity agrees with the topology: the neighborhoods filter of each point `x`\n  is equal to `Filter.comap (Prod.mk x) (ùì§ Œ±)`. -/\n  protected nhds_eq_comap_uniformity (x : Œ±) : ùìù x = comap (Prod.mk x) uniformity\n\n"}
{"name":"UniformSpace.toCore_toTopologicalSpace","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu : UniformSpace Œ±\n‚ä¢ Eq u.toCore.toTopologicalSpace UniformSpace.toTopologicalSpace","decl":"theorem UniformSpace.toCore_toTopologicalSpace (u : UniformSpace Œ±) :\n    u.toCore.toTopologicalSpace = u.toTopologicalSpace :=\n  TopologicalSpace.ext_nhds fun a ‚Ü¶ by\n    rw [u.nhds_eq_comap_uniformity, u.toCore.nhds_toTopologicalSpace]\n\n"}
{"name":"UniformSpace.ext","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\nh : Eq (uniformity Œ±) (uniformity Œ±)\n‚ä¢ Eq u‚ÇÅ u‚ÇÇ","decl":"@[ext (iff := false)]\nprotected theorem UniformSpace.ext {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} (h : ùì§[u‚ÇÅ] = ùì§[u‚ÇÇ]) : u‚ÇÅ = u‚ÇÇ := by\n  have : u‚ÇÅ.toTopologicalSpace = u‚ÇÇ.toTopologicalSpace := TopologicalSpace.ext_nhds fun x ‚Ü¶ by\n    rw [u‚ÇÅ.nhds_eq_comap_uniformity, u‚ÇÇ.nhds_eq_comap_uniformity]\n    exact congr_arg (comap _) h\n  cases u‚ÇÅ; cases u‚ÇÇ; congr\n\n"}
{"name":"UniformSpace.ext_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\n‚ä¢ Iff (Eq u‚ÇÅ u‚ÇÇ) (‚àÄ (s : Set (Prod Œ± Œ±)), Iff (Membership.mem (uniformity Œ±) s) (Membership.mem (uniformity Œ±) s))","decl":"protected theorem UniformSpace.ext_iff {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} :\n    u‚ÇÅ = u‚ÇÇ ‚Üî ‚àÄ s, s ‚àà ùì§[u‚ÇÅ] ‚Üî s ‚àà ùì§[u‚ÇÇ] :=\n  ‚ü®fun h _ => h ‚ñ∏ Iff.rfl, fun h => by ext; exact h _‚ü©\n\n"}
{"name":"UniformSpace.ofCoreEq_toCore","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu : UniformSpace Œ±\nt : TopologicalSpace Œ±\nh : Eq t u.toCore.toTopologicalSpace\n‚ä¢ Eq (UniformSpace.ofCoreEq u.toCore t h) u","decl":"theorem UniformSpace.ofCoreEq_toCore (u : UniformSpace Œ±) (t : TopologicalSpace Œ±)\n    (h : t = u.toCore.toTopologicalSpace) : .ofCoreEq u.toCore t h = u :=\n  UniformSpace.ext rfl\n\n"}
{"name":"UniformSpace.replaceTopology_eq","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\ni : TopologicalSpace Œ±\nu : UniformSpace Œ±\nh : Eq i UniformSpace.toTopologicalSpace\n‚ä¢ Eq (u.replaceTopology h) u","decl":"theorem UniformSpace.replaceTopology_eq {Œ± : Type*} [i : TopologicalSpace Œ±] (u : UniformSpace Œ±)\n    (h : i = u.toTopologicalSpace) : u.replaceTopology h = u :=\n  UniformSpace.ext rfl\n\n"}
{"name":"nhds_eq_comap_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) (Filter.comap (Prod.mk x) (uniformity Œ±))","decl":"theorem nhds_eq_comap_uniformity {x : Œ±} : ùìù x = (ùì§ Œ±).comap (Prod.mk x) :=\n  UniformSpace.nhds_eq_comap_uniformity x\n\n"}
{"name":"isOpen_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Membership.mem (uniformity Œ±) (setOf fun p => Eq p.1 x ‚Üí Membership.mem s p.2))","decl":"theorem isOpen_uniformity {s : Set Œ±} :\n    IsOpen s ‚Üî ‚àÄ x ‚àà s, { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà ùì§ Œ± := by\n  simp only [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity, mem_comap_prod_mk]\n\n"}
{"name":"refl_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le (Filter.principal idRel) (uniformity Œ±)","decl":"theorem refl_le_uniformity : ùìü idRel ‚â§ ùì§ Œ± :=\n  (@UniformSpace.toCore Œ± _).refl\n\n"}
{"name":"uniformity.neBot","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ (uniformity Œ±).NeBot","decl":"instance uniformity.neBot [Nonempty Œ±] : NeBot (ùì§ Œ±) :=\n  diagonal_nonempty.principal_neBot.mono refl_le_uniformity\n\n"}
{"name":"refl_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\n‚ä¢ Membership.mem s { fst := x, snd := x }","decl":"theorem refl_mem_uniformity {x : Œ±} {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) : (x, x) ‚àà s :=\n  refl_le_uniformity h rfl\n\n"}
{"name":"mem_uniformity_of_eq","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx y : Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\nhx : Eq x y\n‚ä¢ Membership.mem s { fst := x, snd := y }","decl":"theorem mem_uniformity_of_eq {x y : Œ±} {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) (hx : x = y) : (x, y) ‚àà s :=\n  refl_le_uniformity h hx\n\n"}
{"name":"symm_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le (Filter.map Prod.swap (uniformity Œ±)) (uniformity Œ±)","decl":"theorem symm_le_uniformity : map (@Prod.swap Œ± Œ±) (ùì§ _) ‚â§ ùì§ _ :=\n  UniformSpace.symm\n\n"}
{"name":"comp_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le ((uniformity Œ±).lift' fun s => compRel s s) (uniformity Œ±)","decl":"theorem comp_le_uniformity : ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => s ‚óã s) ‚â§ ùì§ Œ± :=\n  UniformSpace.comp\n\n"}
{"name":"lift'_comp_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq ((uniformity Œ±).lift' fun s => compRel s s) (uniformity Œ±)","decl":"theorem lift'_comp_uniformity : ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => s ‚óã s) = ùì§ Œ± :=\n  comp_le_uniformity.antisymm <| le_lift'.2 fun _s hs ‚Ü¶ mem_of_superset hs <|\n    subset_comp_self <| idRel_subset.2 fun _ ‚Ü¶ refl_mem_uniformity hs\n\n"}
{"name":"tendsto_swap_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Filter.Tendsto Prod.swap (uniformity Œ±) (uniformity Œ±)","decl":"theorem tendsto_swap_uniformity : Tendsto (@Prod.swap Œ± Œ±) (ùì§ Œ±) (ùì§ Œ±) :=\n  symm_le_uniformity\n\n"}
{"name":"comp_mem_uniformity_sets","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (HasSubset.Subset (compRel t t) s)","decl":"theorem comp_mem_uniformity_sets {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) : ‚àÉ t ‚àà ùì§ Œ±, t ‚óã t ‚äÜ s :=\n  (mem_lift'_sets <| monotone_id.compRel monotone_id).mp <| comp_le_uniformity hs\n\n"}
{"name":"eventually_uniformity_iterate_comp_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\nn : Nat\n‚ä¢ Filter.Eventually (fun t => HasSubset.Subset (Nat.iterate (fun x => compRel t x) n t) s) (uniformity Œ±).smallSets","decl":"/-- If `s ‚àà ùì§ Œ±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ùì§ Œ±`,\nwe have `t ‚óã t ‚óã ... ‚óã t ‚äÜ s` (`n` compositions). -/\ntheorem eventually_uniformity_iterate_comp_subset {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) (n : ‚Ñï) :\n    ‚àÄ·∂† t in (ùì§ Œ±).smallSets, (t ‚óã ¬∑)^[n] t ‚äÜ s := by\n  suffices ‚àÄ·∂† t in (ùì§ Œ±).smallSets, t ‚äÜ s ‚àß (t ‚óã ¬∑)^[n] t ‚äÜ s from (eventually_and.1 this).2\n  induction' n with n ihn generalizing s\n  ¬∑ simpa\n  rcases comp_mem_uniformity_sets hs with ‚ü®t, htU, hts‚ü©\n  refine (ihn htU).mono fun U hU => ?_\n  rw [Function.iterate_succ_apply']\n  exact\n    ‚ü®hU.1.trans <| (subset_comp_self <| refl_le_uniformity htU).trans hts,\n      (compRel_mono hU.1 hU.2).trans hts‚ü©\n\n"}
{"name":"eventually_uniformity_comp_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Filter.Eventually (fun t => HasSubset.Subset (compRel t t) s) (uniformity Œ±).smallSets","decl":"/-- If `s ‚àà ùì§ Œ±`, then for a subset `t` of a sufficiently small set in `ùì§ Œ±`,\nwe have `t ‚óã t ‚äÜ s`. -/\ntheorem eventually_uniformity_comp_subset {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÄ·∂† t in (ùì§ Œ±).smallSets, t ‚óã t ‚äÜ s :=\n  eventually_uniformity_iterate_comp_subset hs 1\n\n"}
{"name":"Filter.Tendsto.uniformity_trans","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nl : Filter Œ≤\nf‚ÇÅ f‚ÇÇ f‚ÇÉ : Œ≤ ‚Üí Œ±\nh‚ÇÅ‚ÇÇ : Filter.Tendsto (fun x => { fst := f‚ÇÅ x, snd := f‚ÇÇ x }) l (uniformity Œ±)\nh‚ÇÇ‚ÇÉ : Filter.Tendsto (fun x => { fst := f‚ÇÇ x, snd := f‚ÇÉ x }) l (uniformity Œ±)\n‚ä¢ Filter.Tendsto (fun x => { fst := f‚ÇÅ x, snd := f‚ÇÉ x }) l (uniformity Œ±)","decl":"/-- Relation `fun f g ‚Ü¶ Tendsto (fun x ‚Ü¶ (f x, g x)) l (ùì§ Œ±)` is transitive. -/\ntheorem Filter.Tendsto.uniformity_trans {l : Filter Œ≤} {f‚ÇÅ f‚ÇÇ f‚ÇÉ : Œ≤ ‚Üí Œ±}\n    (h‚ÇÅ‚ÇÇ : Tendsto (fun x => (f‚ÇÅ x, f‚ÇÇ x)) l (ùì§ Œ±))\n    (h‚ÇÇ‚ÇÉ : Tendsto (fun x => (f‚ÇÇ x, f‚ÇÉ x)) l (ùì§ Œ±)) : Tendsto (fun x => (f‚ÇÅ x, f‚ÇÉ x)) l (ùì§ Œ±) := by\n  refine le_trans (le_lift'.2 fun s hs => mem_map.2 ?_) comp_le_uniformity\n  filter_upwards [mem_map.1 (h‚ÇÅ‚ÇÇ hs), mem_map.1 (h‚ÇÇ‚ÇÉ hs)] with x hx‚ÇÅ‚ÇÇ hx‚ÇÇ‚ÇÉ using ‚ü®_, hx‚ÇÅ‚ÇÇ, hx‚ÇÇ‚ÇÉ‚ü©\n\n"}
{"name":"Filter.Tendsto.uniformity_symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nl : Filter Œ≤\nf : Œ≤ ‚Üí Prod Œ± Œ±\nh : Filter.Tendsto f l (uniformity Œ±)\n‚ä¢ Filter.Tendsto (fun x => { fst := (f x).2, snd := (f x).1 }) l (uniformity Œ±)","decl":"/-- Relation `fun f g ‚Ü¶ Tendsto (fun x ‚Ü¶ (f x, g x)) l (ùì§ Œ±)` is symmetric. -/\ntheorem Filter.Tendsto.uniformity_symm {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ± √ó Œ±} (h : Tendsto f l (ùì§ Œ±)) :\n    Tendsto (fun x => ((f x).2, (f x).1)) l (ùì§ Œ±) :=\n  tendsto_swap_uniformity.comp h\n\n"}
{"name":"tendsto_diag_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nf : Œ≤ ‚Üí Œ±\nl : Filter Œ≤\n‚ä¢ Filter.Tendsto (fun x => { fst := f x, snd := f x }) l (uniformity Œ±)","decl":"/-- Relation `fun f g ‚Ü¶ Tendsto (fun x ‚Ü¶ (f x, g x)) l (ùì§ Œ±)` is reflexive. -/\ntheorem tendsto_diag_uniformity (f : Œ≤ ‚Üí Œ±) (l : Filter Œ≤) :\n    Tendsto (fun x => (f x, f x)) l (ùì§ Œ±) := fun _s hs =>\n  mem_map.2 <| univ_mem' fun _ => refl_mem_uniformity hs\n\n"}
{"name":"tendsto_const_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\na : Œ±\nf : Filter Œ≤\n‚ä¢ Filter.Tendsto (fun x => { fst := a, snd := a }) f (uniformity Œ±)","decl":"theorem tendsto_const_uniformity {a : Œ±} {f : Filter Œ≤} : Tendsto (fun _ => (a, a)) f (ùì§ Œ±) :=\n  tendsto_diag_uniformity (fun _ => a) f\n\n"}
{"name":"symm_of_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (‚àÄ (a b : Œ±), Membership.mem t { fst := a, snd := b } ‚Üí Membership.mem t { fst := b, snd := a }) (HasSubset.Subset t s))","decl":"theorem symm_of_uniformity {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ t ‚àà ùì§ Œ±, (‚àÄ a b, (a, b) ‚àà t ‚Üí (b, a) ‚àà t) ‚àß t ‚äÜ s :=\n  have : preimage Prod.swap s ‚àà ùì§ Œ± := symm_le_uniformity hs\n  ‚ü®s ‚à© preimage Prod.swap s, inter_mem hs this, fun _ _ ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©, inter_subset_left‚ü©\n\n"}
{"name":"comp_symm_of_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (‚àÄ {a b : Œ±}, Membership.mem t { fst := a, snd := b } ‚Üí Membership.mem t { fst := b, snd := a }) (HasSubset.Subset (compRel t t) s))","decl":"theorem comp_symm_of_uniformity {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ t ‚àà ùì§ Œ±, (‚àÄ {a b}, (a, b) ‚àà t ‚Üí (b, a) ‚àà t) ‚àß t ‚óã t ‚äÜ s :=\n  let ‚ü®_t, ht‚ÇÅ, ht‚ÇÇ‚ü© := comp_mem_uniformity_sets hs\n  let ‚ü®t', ht', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := symm_of_uniformity ht‚ÇÅ\n  ‚ü®t', ht', ht'‚ÇÅ _ _, Subset.trans (monotone_id.compRel monotone_id ht'‚ÇÇ) ht‚ÇÇ‚ü©\n\n"}
{"name":"uniformity_le_symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le (uniformity Œ±) (Functor.map Prod.swap (uniformity Œ±))","decl":"theorem uniformity_le_symm : ùì§ Œ± ‚â§ @Prod.swap Œ± Œ± <$> ùì§ Œ± := by\n  rw [map_swap_eq_comap_swap]; exact tendsto_swap_uniformity.le_comap\n\n"}
{"name":"uniformity_eq_symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (Functor.map Prod.swap (uniformity Œ±))","decl":"theorem uniformity_eq_symm : ùì§ Œ± = @Prod.swap Œ± Œ± <$> ùì§ Œ± :=\n  le_antisymm uniformity_le_symm symm_le_uniformity\n\n"}
{"name":"comap_swap_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.comap Prod.swap (uniformity Œ±)) (uniformity Œ±)","decl":"@[simp]\ntheorem comap_swap_uniformity : comap (@Prod.swap Œ± Œ±) (ùì§ Œ±) = ùì§ Œ± :=\n  (congr_arg _ uniformity_eq_symm).trans <| comap_map Prod.swap_injective\n\n"}
{"name":"symmetrize_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nV : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) V\n‚ä¢ Membership.mem (uniformity Œ±) (symmetrizeRel V)","decl":"theorem symmetrize_mem_uniformity {V : Set (Œ± √ó Œ±)} (h : V ‚àà ùì§ Œ±) : symmetrizeRel V ‚àà ùì§ Œ± := by\n  apply (ùì§ Œ±).inter_sets h\n  rw [‚Üê image_swap_eq_preimage_swap, uniformity_eq_symm]\n  exact image_mem_map h\n\n"}
{"name":"UniformSpace.hasBasis_symmetric","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun s => And (Membership.mem (uniformity Œ±) s) (SymmetricRel s)) id","decl":"/-- Symmetric entourages form a basis of `ùì§ Œ±` -/\ntheorem UniformSpace.hasBasis_symmetric :\n    (ùì§ Œ±).HasBasis (fun s : Set (Œ± √ó Œ±) => s ‚àà ùì§ Œ± ‚àß SymmetricRel s) id :=\n  hasBasis_self.2 fun t t_in =>\n    ‚ü®symmetrizeRel t, symmetrize_mem_uniformity t_in, symmetric_symmetrizeRel t,\n      symmetrizeRel_subset_self t‚ü©\n\n"}
{"name":"uniformity_lift_le_swap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\ng : Set (Prod Œ± Œ±) ‚Üí Filter Œ≤\nf : Filter Œ≤\nhg : Monotone g\nh : LE.le ((uniformity Œ±).lift fun s => g (Set.preimage Prod.swap s)) f\n‚ä¢ LE.le ((uniformity Œ±).lift g) f","decl":"theorem uniformity_lift_le_swap {g : Set (Œ± √ó Œ±) ‚Üí Filter Œ≤} {f : Filter Œ≤} (hg : Monotone g)\n    (h : ((ùì§ Œ±).lift fun s => g (preimage Prod.swap s)) ‚â§ f) : (ùì§ Œ±).lift g ‚â§ f :=\n  calc\n    (ùì§ Œ±).lift g ‚â§ (Filter.map (@Prod.swap Œ± Œ±) <| ùì§ Œ±).lift g :=\n      lift_mono uniformity_le_symm le_rfl\n    _ ‚â§ _ := by rw [map_lift_eq2 hg, image_swap_eq_preimage_swap]; exact h\n\n"}
{"name":"uniformity_lift_le_comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nf : Set (Prod Œ± Œ±) ‚Üí Filter Œ≤\nh : Monotone f\n‚ä¢ LE.le ((uniformity Œ±).lift fun s => f (compRel s s)) ((uniformity Œ±).lift f)","decl":"theorem uniformity_lift_le_comp {f : Set (Œ± √ó Œ±) ‚Üí Filter Œ≤} (h : Monotone f) :\n    ((ùì§ Œ±).lift fun s => f (s ‚óã s)) ‚â§ (ùì§ Œ±).lift f :=\n  calc\n    ((ùì§ Œ±).lift fun s => f (s ‚óã s)) = ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => s ‚óã s).lift f := by\n      rw [lift_lift'_assoc]\n      ¬∑ exact monotone_id.compRel monotone_id\n      ¬∑ exact h\n    _ ‚â§ (ùì§ Œ±).lift f := lift_mono comp_le_uniformity le_rfl\n\n"}
{"name":"comp3_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (HasSubset.Subset (compRel t (compRel t t)) s)","decl":"theorem comp3_mem_uniformity {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) : ‚àÉ t ‚àà ùì§ Œ±, t ‚óã (t ‚óã t) ‚äÜ s :=\n  let ‚ü®_t', ht', ht's‚ü© := comp_mem_uniformity_sets hs\n  let ‚ü®t, ht, htt'‚ü© := comp_mem_uniformity_sets ht'\n  ‚ü®t, ht, (compRel_mono ((subset_comp_self (refl_le_uniformity ht)).trans htt') htt').trans ht's‚ü©\n\n"}
{"name":"comp_le_uniformity3","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le ((uniformity Œ±).lift' fun s => compRel s (compRel s s)) (uniformity Œ±)","decl":"/-- See also `comp3_mem_uniformity`. -/\ntheorem comp_le_uniformity3 : ((ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => s ‚óã (s ‚óã s)) ‚â§ ùì§ Œ± := fun _ h =>\n  let ‚ü®_t, htU, ht‚ü© := comp3_mem_uniformity h\n  mem_of_superset (mem_lift' htU) ht\n\n"}
{"name":"comp_symm_mem_uniformity_sets","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (SymmetricRel t) (HasSubset.Subset (compRel t t) s))","decl":"/-- See also `comp_open_symm_mem_uniformity_sets`. -/\ntheorem comp_symm_mem_uniformity_sets {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ t ‚àà ùì§ Œ±, SymmetricRel t ‚àß t ‚óã t ‚äÜ s := by\n  obtain ‚ü®w, w_in, w_sub‚ü© : ‚àÉ w ‚àà ùì§ Œ±, w ‚óã w ‚äÜ s := comp_mem_uniformity_sets hs\n  use symmetrizeRel w, symmetrize_mem_uniformity w_in, symmetric_symmetrizeRel w\n  have : symmetrizeRel w ‚äÜ w := symmetrizeRel_subset_self w\n  calc symmetrizeRel w ‚óã symmetrizeRel w\n    _ ‚äÜ w ‚óã w := by gcongr\n    _ ‚äÜ s     := w_sub\n\n"}
{"name":"subset_comp_self_of_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\n‚ä¢ HasSubset.Subset s (compRel s s)","decl":"theorem subset_comp_self_of_mem_uniformity {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) : s ‚äÜ s ‚óã s :=\n  subset_comp_self (refl_le_uniformity h)\n\n"}
{"name":"comp_comp_symm_mem_uniformity_sets","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (SymmetricRel t) (HasSubset.Subset (compRel (compRel t t) t) s))","decl":"theorem comp_comp_symm_mem_uniformity_sets {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ t ‚àà ùì§ Œ±, SymmetricRel t ‚àß t ‚óã t ‚óã t ‚äÜ s := by\n  rcases comp_symm_mem_uniformity_sets hs with ‚ü®w, w_in, _, w_sub‚ü©\n  rcases comp_symm_mem_uniformity_sets w_in with ‚ü®t, t_in, t_symm, t_sub‚ü©\n  use t, t_in, t_symm\n  have : t ‚äÜ t ‚óã t := subset_comp_self_of_mem_uniformity t_in\n  -- Porting note: Needed the following `have`s to make `mono` work\n  have ht := Subset.refl t\n  have hw := Subset.refl w\n  calc\n    t ‚óã t ‚óã t ‚äÜ w ‚óã t := by mono\n    _ ‚äÜ w ‚óã (t ‚óã t) := by mono\n    _ ‚äÜ w ‚óã w := by mono\n    _ ‚äÜ s := w_sub\n\n"}
{"name":"UniformSpace.mem_ball_self","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nV : Set (Prod Œ± Œ±)\na‚úù : Membership.mem (uniformity Œ±) V\n‚ä¢ Membership.mem (UniformSpace.ball x V) x","decl":"lemma mem_ball_self (x : Œ±) {V : Set (Œ± √ó Œ±)} : V ‚àà ùì§ Œ± ‚Üí x ‚àà ball x V := refl_mem_uniformity\n\n"}
{"name":"UniformSpace.mem_ball_comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV W : Set (Prod Œ≤ Œ≤)\nx y z : Œ≤\nh : Membership.mem (UniformSpace.ball x V) y\nh' : Membership.mem (UniformSpace.ball y W) z\n‚ä¢ Membership.mem (UniformSpace.ball x (compRel V W)) z","decl":"/-- The triangle inequality for `UniformSpace.ball` -/\ntheorem mem_ball_comp {V W : Set (Œ≤ √ó Œ≤)} {x y z} (h : y ‚àà ball x V) (h' : z ‚àà ball y W) :\n    z ‚àà ball x (V ‚óã W) :=\n  prod_mk_mem_compRel h h'\n\n"}
{"name":"UniformSpace.ball_subset_of_comp_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV W : Set (Prod Œ≤ Œ≤)\nx y : Œ≤\nh : Membership.mem (UniformSpace.ball y W) x\nh' : HasSubset.Subset (compRel W W) V\n‚ä¢ HasSubset.Subset (UniformSpace.ball x W) (UniformSpace.ball y V)","decl":"theorem ball_subset_of_comp_subset {V W : Set (Œ≤ √ó Œ≤)} {x y} (h : x ‚àà ball y W) (h' : W ‚óã W ‚äÜ V) :\n    ball x W ‚äÜ ball y V := fun _z z_in => h' (mem_ball_comp h z_in)\n\n"}
{"name":"UniformSpace.ball_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV W : Set (Prod Œ≤ Œ≤)\nh : HasSubset.Subset V W\nx : Œ≤\n‚ä¢ HasSubset.Subset (UniformSpace.ball x V) (UniformSpace.ball x W)","decl":"theorem ball_mono {V W : Set (Œ≤ √ó Œ≤)} (h : V ‚äÜ W) (x : Œ≤) : ball x V ‚äÜ ball x W :=\n  preimage_mono h\n\n"}
{"name":"UniformSpace.ball_inter","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nx : Œ≤\nV W : Set (Prod Œ≤ Œ≤)\n‚ä¢ Eq (UniformSpace.ball x (Inter.inter V W)) (Inter.inter (UniformSpace.ball x V) (UniformSpace.ball x W))","decl":"theorem ball_inter (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) = ball x V ‚à© ball x W :=\n  preimage_inter\n\n"}
{"name":"UniformSpace.ball_inter_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nx : Œ≤\nV W : Set (Prod Œ≤ Œ≤)\n‚ä¢ HasSubset.Subset (UniformSpace.ball x (Inter.inter V W)) (UniformSpace.ball x V)","decl":"theorem ball_inter_left (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x V :=\n  ball_mono inter_subset_left x\n\n"}
{"name":"UniformSpace.ball_inter_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nx : Œ≤\nV W : Set (Prod Œ≤ Œ≤)\n‚ä¢ HasSubset.Subset (UniformSpace.ball x (Inter.inter V W)) (UniformSpace.ball x W)","decl":"theorem ball_inter_right (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=\n  ball_mono inter_subset_right x\n\n"}
{"name":"UniformSpace.mem_ball_symmetry","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV : Set (Prod Œ≤ Œ≤)\nhV : SymmetricRel V\nx y : Œ≤\n‚ä¢ Iff (Membership.mem (UniformSpace.ball y V) x) (Membership.mem (UniformSpace.ball x V) y)","decl":"theorem mem_ball_symmetry {V : Set (Œ≤ √ó Œ≤)} (hV : SymmetricRel V) {x y} :\n    x ‚àà ball y V ‚Üî y ‚àà ball x V :=\n  show (x, y) ‚àà Prod.swap ‚Åª¬π' V ‚Üî (x, y) ‚àà V by\n    unfold SymmetricRel at hV\n    rw [hV]\n\n"}
{"name":"UniformSpace.ball_eq_of_symmetry","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV : Set (Prod Œ≤ Œ≤)\nhV : SymmetricRel V\nx : Œ≤\n‚ä¢ Eq (UniformSpace.ball x V) (setOf fun y => Membership.mem V { fst := y, snd := x })","decl":"theorem ball_eq_of_symmetry {V : Set (Œ≤ √ó Œ≤)} (hV : SymmetricRel V) {x} :\n    ball x V = { y | (y, x) ‚àà V } := by\n  ext y\n  rw [mem_ball_symmetry hV]\n  exact Iff.rfl\n\n"}
{"name":"UniformSpace.mem_comp_of_mem_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV W : Set (Prod Œ≤ Œ≤)\nx y z : Œ≤\nhV : SymmetricRel V\nhx : Membership.mem (UniformSpace.ball z V) x\nhy : Membership.mem (UniformSpace.ball z W) y\n‚ä¢ Membership.mem (compRel V W) { fst := x, snd := y }","decl":"theorem mem_comp_of_mem_ball {V W : Set (Œ≤ √ó Œ≤)} {x y z : Œ≤} (hV : SymmetricRel V)\n    (hx : x ‚àà ball z V) (hy : y ‚àà ball z W) : (x, y) ‚àà V ‚óã W := by\n  rw [mem_ball_symmetry hV] at hx\n  exact ‚ü®z, hx, hy‚ü©\n\n"}
{"name":"UniformSpace.isOpen_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nV : Set (Prod Œ± Œ±)\nhV : IsOpen V\n‚ä¢ IsOpen (UniformSpace.ball x V)","decl":"lemma isOpen_ball (x : Œ±) {V : Set (Œ± √ó Œ±)} (hV : IsOpen V) : IsOpen (ball x V) :=\n  hV.preimage <| continuous_const.prod_mk continuous_id\n\n"}
{"name":"UniformSpace.isClosed_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nV : Set (Prod Œ± Œ±)\nhV : IsClosed V\n‚ä¢ IsClosed (UniformSpace.ball x V)","decl":"lemma isClosed_ball (x : Œ±) {V : Set (Œ± √ó Œ±)} (hV : IsClosed V) : IsClosed (ball x V) :=\n  hV.preimage <| continuous_const.prod_mk continuous_id\n\n"}
{"name":"UniformSpace.mem_comp_comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\nV W M : Set (Prod Œ≤ Œ≤)\nhW' : SymmetricRel W\np : Prod Œ≤ Œ≤\n‚ä¢ Iff (Membership.mem (compRel (compRel V M) W) p) (Inter.inter (SProd.sprod (UniformSpace.ball p.1 V) (UniformSpace.ball p.2 W)) M).Nonempty","decl":"theorem mem_comp_comp {V W M : Set (Œ≤ √ó Œ≤)} (hW' : SymmetricRel W) {p : Œ≤ √ó Œ≤} :\n    p ‚àà V ‚óã M ‚óã W ‚Üî (ball p.1 V √óÀ¢ ball p.2 W ‚à© M).Nonempty := by\n  cases' p with x y\n  constructor\n  ¬∑ rintro ‚ü®z, ‚ü®w, hpw, hwz‚ü©, hzy‚ü©\n    exact ‚ü®(w, z), ‚ü®hpw, by rwa [mem_ball_symmetry hW']‚ü©, hwz‚ü©\n  ¬∑ rintro ‚ü®‚ü®w, z‚ü©, ‚ü®w_in, z_in‚ü©, hwz‚ü©\n    rw [mem_ball_symmetry hW'] at z_in\n    exact ‚ü®z, ‚ü®w, w_in, hwz‚ü©, z_in‚ü©\n\n"}
{"name":"mem_nhds_uniformity_iff_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Membership.mem (uniformity Œ±) (setOf fun p => Eq p.1 x ‚Üí Membership.mem s p.2))","decl":"theorem mem_nhds_uniformity_iff_right {x : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù x ‚Üî { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà ùì§ Œ± := by\n  simp only [nhds_eq_comap_uniformity, mem_comap_prod_mk]\n\n"}
{"name":"mem_nhds_uniformity_iff_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Membership.mem (uniformity Œ±) (setOf fun p => Eq p.2 x ‚Üí Membership.mem s p.1))","decl":"theorem mem_nhds_uniformity_iff_left {x : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù x ‚Üî { p : Œ± √ó Œ± | p.2 = x ‚Üí p.1 ‚àà s } ‚àà ùì§ Œ± := by\n  rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]\n  simp only [map_def, mem_map, preimage_setOf_eq, Prod.snd_swap, Prod.fst_swap]\n\n"}
{"name":"nhdsWithin_eq_comap_uniformity_of_mem","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nT : Set Œ±\nhx : Membership.mem T x\nS : Set Œ±\n‚ä¢ Eq (nhdsWithin x S) (Filter.comap (Prod.mk x) (Min.min (uniformity Œ±) (Filter.principal (SProd.sprod T S))))","decl":"theorem nhdsWithin_eq_comap_uniformity_of_mem {x : Œ±} {T : Set Œ±} (hx : x ‚àà T) (S : Set Œ±) :\n    ùìù[S] x = (ùì§ Œ± ‚äì ùìü (T √óÀ¢ S)).comap (Prod.mk x) := by\n  simp [nhdsWithin, nhds_eq_comap_uniformity, hx]\n\n"}
{"name":"nhdsWithin_eq_comap_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nS : Set Œ±\n‚ä¢ Eq (nhdsWithin x S) (Filter.comap (Prod.mk x) (Min.min (uniformity Œ±) (Filter.principal (SProd.sprod Set.univ S))))","decl":"theorem nhdsWithin_eq_comap_uniformity {x : Œ±} (S : Set Œ±) :\n    ùìù[S] x = (ùì§ Œ± ‚äì ùìü (univ √óÀ¢ S)).comap (Prod.mk x) :=\n  nhdsWithin_eq_comap_uniformity_of_mem (mem_univ _) S\n\n"}
{"name":"isOpen_iff_ball_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun V => And (Membership.mem (uniformity Œ±) V) (HasSubset.Subset (UniformSpace.ball x V) s))","decl":"/-- See also `isOpen_iff_isOpen_ball_subset`. -/\ntheorem isOpen_iff_ball_subset {s : Set Œ±} : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ V ‚àà ùì§ Œ±, ball x V ‚äÜ s := by\n  simp_rw [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity, mem_comap, ball]\n\n"}
{"name":"nhds_basis_uniformity'","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p s\nx : Œ±\n‚ä¢ (nhds x).HasBasis p fun i => UniformSpace.ball x (s i)","decl":"theorem nhds_basis_uniformity' {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (h : (ùì§ Œ±).HasBasis p s)\n    {x : Œ±} : (ùìù x).HasBasis p fun i => ball x (s i) := by\n  rw [nhds_eq_comap_uniformity]\n  exact h.comap (Prod.mk x)\n\n"}
{"name":"nhds_basis_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p s\nx : Œ±\n‚ä¢ (nhds x).HasBasis p fun i => setOf fun y => Membership.mem (s i) { fst := y, snd := x }","decl":"theorem nhds_basis_uniformity {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (h : (ùì§ Œ±).HasBasis p s)\n    {x : Œ±} : (ùìù x).HasBasis p fun i => { y | (y, x) ‚àà s i } := by\n  replace h := h.comap Prod.swap\n  rw [comap_swap_uniformity] at h\n  exact nhds_basis_uniformity' h\n\n"}
{"name":"nhds_eq_comap_uniformity'","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) (Filter.comap (fun y => { fst := y, snd := x }) (uniformity Œ±))","decl":"theorem nhds_eq_comap_uniformity' {x : Œ±} : ùìù x = (ùì§ Œ±).comap fun y => (y, x) :=\n  (nhds_basis_uniformity (ùì§ Œ±).basis_sets).eq_of_same_basis <| (ùì§ Œ±).basis_sets.comap _\n\n"}
{"name":"UniformSpace.mem_nhds_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Exists fun V => And (Membership.mem (uniformity Œ±) V) (HasSubset.Subset (UniformSpace.ball x V) s))","decl":"theorem UniformSpace.mem_nhds_iff {x : Œ±} {s : Set Œ±} : s ‚àà ùìù x ‚Üî ‚àÉ V ‚àà ùì§ Œ±, ball x V ‚äÜ s := by\n  rw [nhds_eq_comap_uniformity, mem_comap]\n  simp_rw [ball]\n\n"}
{"name":"UniformSpace.ball_mem_nhds","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nV : Set (Prod Œ± Œ±)\nV_in : Membership.mem (uniformity Œ±) V\n‚ä¢ Membership.mem (nhds x) (UniformSpace.ball x V)","decl":"theorem UniformSpace.ball_mem_nhds (x : Œ±) ‚¶ÉV : Set (Œ± √ó Œ±)‚¶Ñ (V_in : V ‚àà ùì§ Œ±) : ball x V ‚àà ùìù x := by\n  rw [UniformSpace.mem_nhds_iff]\n  exact ‚ü®V, V_in, Subset.rfl‚ü©\n\n"}
{"name":"UniformSpace.ball_mem_nhdsWithin","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\nS : Set Œ±\nV : Set (Prod Œ± Œ±)\nx_in : Membership.mem S x\nV_in : Membership.mem (Min.min (uniformity Œ±) (Filter.principal (SProd.sprod S S))) V\n‚ä¢ Membership.mem (nhdsWithin x S) (UniformSpace.ball x V)","decl":"theorem UniformSpace.ball_mem_nhdsWithin {x : Œ±} {S : Set Œ±} ‚¶ÉV : Set (Œ± √ó Œ±)‚¶Ñ (x_in : x ‚àà S)\n    (V_in : V ‚àà ùì§ Œ± ‚äì ùìü (S √óÀ¢ S)) : ball x V ‚àà ùìù[S] x := by\n  rw [nhdsWithin_eq_comap_uniformity_of_mem x_in, mem_comap]\n  exact ‚ü®V, V_in, Subset.rfl‚ü©\n\n"}
{"name":"UniformSpace.mem_nhds_iff_symm","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Exists fun V => And (Membership.mem (uniformity Œ±) V) (And (SymmetricRel V) (HasSubset.Subset (UniformSpace.ball x V) s)))","decl":"theorem UniformSpace.mem_nhds_iff_symm {x : Œ±} {s : Set Œ±} :\n    s ‚àà ùìù x ‚Üî ‚àÉ V ‚àà ùì§ Œ±, SymmetricRel V ‚àß ball x V ‚äÜ s := by\n  rw [UniformSpace.mem_nhds_iff]\n  constructor\n  ¬∑ rintro ‚ü®V, V_in, V_sub‚ü©\n    use symmetrizeRel V, symmetrize_mem_uniformity V_in, symmetric_symmetrizeRel V\n    exact Subset.trans (ball_mono (symmetrizeRel_subset_self V) x) V_sub\n  ¬∑ rintro ‚ü®V, V_in, _, V_sub‚ü©\n    exact ‚ü®V, V_in, V_sub‚ü©\n\n"}
{"name":"UniformSpace.hasBasis_nhds","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem (uniformity Œ±) s) (SymmetricRel s)) fun s => UniformSpace.ball x s","decl":"theorem UniformSpace.hasBasis_nhds (x : Œ±) :\n    HasBasis (ùìù x) (fun s : Set (Œ± √ó Œ±) => s ‚àà ùì§ Œ± ‚àß SymmetricRel s) fun s => ball x s :=\n  ‚ü®fun t => by simp [UniformSpace.mem_nhds_iff_symm, and_assoc]‚ü©\n\n"}
{"name":"UniformSpace.mem_closure_iff_symm_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Iff (Membership.mem (closure s) x) (‚àÄ {V : Set (Prod Œ± Œ±)}, Membership.mem (uniformity Œ±) V ‚Üí SymmetricRel V ‚Üí (Inter.inter s (UniformSpace.ball x V)).Nonempty)","decl":"theorem UniformSpace.mem_closure_iff_symm_ball {s : Set Œ±} {x} :\n    x ‚àà closure s ‚Üî ‚àÄ {V}, V ‚àà ùì§ Œ± ‚Üí SymmetricRel V ‚Üí (s ‚à© ball x V).Nonempty := by\n  simp [mem_closure_iff_nhds_basis (hasBasis_nhds x), Set.Nonempty]\n\n"}
{"name":"UniformSpace.mem_closure_iff_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Iff (Membership.mem (closure s) x) (‚àÄ {V : Set (Prod Œ± Œ±)}, Membership.mem (uniformity Œ±) V ‚Üí (Inter.inter (UniformSpace.ball x V) s).Nonempty)","decl":"theorem UniformSpace.mem_closure_iff_ball {s : Set Œ±} {x} :\n    x ‚àà closure s ‚Üî ‚àÄ {V}, V ‚àà ùì§ Œ± ‚Üí (ball x V ‚à© s).Nonempty := by\n  simp [mem_closure_iff_nhds_basis' (nhds_basis_uniformity' (ùì§ Œ±).basis_sets)]\n\n"}
{"name":"UniformSpace.hasBasis_nhds_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx y : Œ±\n‚ä¢ (nhds { fst := x, snd := y }).HasBasis (fun s => And (Membership.mem (uniformity Œ±) s) (SymmetricRel s)) fun s => SProd.sprod (UniformSpace.ball x s) (UniformSpace.ball y s)","decl":"theorem UniformSpace.hasBasis_nhds_prod (x y : Œ±) :\n    HasBasis (ùìù (x, y)) (fun s => s ‚àà ùì§ Œ± ‚àß SymmetricRel s) fun s => ball x s √óÀ¢ ball y s := by\n  rw [nhds_prod_eq]\n  apply (hasBasis_nhds x).prod_same_index (hasBasis_nhds y)\n  rintro U V ‚ü®U_in, U_symm‚ü© ‚ü®V_in, V_symm‚ü©\n  exact\n    ‚ü®U ‚à© V, ‚ü®(ùì§ Œ±).inter_sets U_in V_in, U_symm.inter V_symm‚ü©, ball_inter_left x U V,\n      ball_inter_right y U V‚ü©\n\n"}
{"name":"nhds_eq_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) ((uniformity Œ±).lift' (UniformSpace.ball x))","decl":"theorem nhds_eq_uniformity {x : Œ±} : ùìù x = (ùì§ Œ±).lift' (ball x) :=\n  (nhds_basis_uniformity' (ùì§ Œ±).basis_sets).eq_biInf\n\n"}
{"name":"nhds_eq_uniformity'","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ Eq (nhds x) ((uniformity Œ±).lift' fun s => setOf fun y => Membership.mem s { fst := y, snd := x })","decl":"theorem nhds_eq_uniformity' {x : Œ±} : ùìù x = (ùì§ Œ±).lift' fun s => { y | (y, x) ‚àà s } :=\n  (nhds_basis_uniformity (ùì§ Œ±).basis_sets).eq_biInf\n\n"}
{"name":"mem_nhds_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\n‚ä¢ Membership.mem (nhds x) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"theorem mem_nhds_left (x : Œ±) {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) : { y : Œ± | (x, y) ‚àà s } ‚àà ùìù x :=\n  ball_mem_nhds x h\n\n"}
{"name":"mem_nhds_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ny : Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\n‚ä¢ Membership.mem (nhds y) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"theorem mem_nhds_right (y : Œ±) {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) : { x : Œ± | (x, y) ‚àà s } ‚àà ùìù y :=\n  mem_nhds_left _ (symm_le_uniformity h)\n\n"}
{"name":"exists_mem_nhds_ball_subset_of_mem_nhds","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\na : Œ±\nU : Set Œ±\nh : Membership.mem (nhds a) U\n‚ä¢ Exists fun V => And (Membership.mem (nhds a) V) (Exists fun t => And (Membership.mem (uniformity Œ±) t) (‚àÄ (a' : Œ±), Membership.mem V a' ‚Üí HasSubset.Subset (UniformSpace.ball a' t) U))","decl":"theorem exists_mem_nhds_ball_subset_of_mem_nhds {a : Œ±} {U : Set Œ±} (h : U ‚àà ùìù a) :\n    ‚àÉ V ‚àà ùìù a, ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ a' ‚àà V, UniformSpace.ball a' t ‚äÜ U :=\n  let ‚ü®t, ht, htU‚ü© := comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 h)\n  ‚ü®_, mem_nhds_left a ht, t, ht, fun a‚ÇÅ h‚ÇÅ a‚ÇÇ h‚ÇÇ => @htU (a, a‚ÇÇ) ‚ü®a‚ÇÅ, h‚ÇÅ, h‚ÇÇ‚ü© rfl‚ü©\n\n"}
{"name":"tendsto_right_nhds_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\na : Œ±\n‚ä¢ Filter.Tendsto (fun a' => { fst := a', snd := a }) (nhds a) (uniformity Œ±)","decl":"theorem tendsto_right_nhds_uniformity {a : Œ±} : Tendsto (fun a' => (a', a)) (ùìù a) (ùì§ Œ±) := fun _ =>\n  mem_nhds_right a\n\n"}
{"name":"tendsto_left_nhds_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\na : Œ±\n‚ä¢ Filter.Tendsto (fun a' => { fst := a, snd := a' }) (nhds a) (uniformity Œ±)","decl":"theorem tendsto_left_nhds_uniformity {a : Œ±} : Tendsto (fun a' => (a, a')) (ùìù a) (ùì§ Œ±) := fun _ =>\n  mem_nhds_left a\n\n"}
{"name":"lift_nhds_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nx : Œ±\ng : Set Œ± ‚Üí Filter Œ≤\nhg : Monotone g\n‚ä¢ Eq ((nhds x).lift g) ((uniformity Œ±).lift fun s => g (UniformSpace.ball x s))","decl":"theorem lift_nhds_left {x : Œ±} {g : Set Œ± ‚Üí Filter Œ≤} (hg : Monotone g) :\n    (ùìù x).lift g = (ùì§ Œ±).lift fun s : Set (Œ± √ó Œ±) => g (ball x s) := by\n  rw [nhds_eq_comap_uniformity, comap_lift_eq2 hg]\n  simp_rw [ball, Function.comp_def]\n\n"}
{"name":"lift_nhds_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nx : Œ±\ng : Set Œ± ‚Üí Filter Œ≤\nhg : Monotone g\n‚ä¢ Eq ((nhds x).lift g) ((uniformity Œ±).lift fun s => g (setOf fun y => Membership.mem s { fst := y, snd := x }))","decl":"theorem lift_nhds_right {x : Œ±} {g : Set Œ± ‚Üí Filter Œ≤} (hg : Monotone g) :\n    (ùìù x).lift g = (ùì§ Œ±).lift fun s : Set (Œ± √ó Œ±) => g { y | (y, x) ‚àà s } := by\n  rw [nhds_eq_comap_uniformity', comap_lift_eq2 hg]\n  simp_rw [Function.comp_def, preimage]\n\n"}
{"name":"nhds_nhds_eq_uniformity_uniformity_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\na b : Œ±\n‚ä¢ Eq (SProd.sprod (nhds a) (nhds b)) ((uniformity Œ±).lift fun s => (uniformity Œ±).lift' fun t => SProd.sprod (setOf fun y => Membership.mem s { fst := y, snd := a }) (setOf fun y => Membership.mem t { fst := b, snd := y }))","decl":"theorem nhds_nhds_eq_uniformity_uniformity_prod {a b : Œ±} :\n    ùìù a √óÀ¢ ùìù b = (ùì§ Œ±).lift fun s : Set (Œ± √ó Œ±) =>\n      (ùì§ Œ±).lift' fun t => { y : Œ± | (y, a) ‚àà s } √óÀ¢ { y : Œ± | (b, y) ‚àà t } := by\n  rw [nhds_eq_uniformity', nhds_eq_uniformity, prod_lift'_lift']\n  exacts [rfl, monotone_preimage, monotone_preimage]\n\n"}
{"name":"nhds_eq_uniformity_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\na b : Œ±\n‚ä¢ Eq (nhds { fst := a, snd := b }) ((uniformity Œ±).lift' fun s => SProd.sprod (setOf fun y => Membership.mem s { fst := y, snd := a }) (setOf fun y => Membership.mem s { fst := b, snd := y }))","decl":"theorem nhds_eq_uniformity_prod {a b : Œ±} :\n    ùìù (a, b) =\n      (ùì§ Œ±).lift' fun s : Set (Œ± √ó Œ±) => { y : Œ± | (y, a) ‚àà s } √óÀ¢ { y : Œ± | (b, y) ‚àà s } := by\n  rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']\n  ¬∑ exact fun s => monotone_const.set_prod monotone_preimage\n  ¬∑ refine fun t => Monotone.set_prod ?_ monotone_const\n    exact monotone_preimage (f := fun y => (y, a))\n\n"}
{"name":"nhdset_of_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nd s : Set (Prod Œ± Œ±)\nhd : Membership.mem (uniformity Œ±) d\n‚ä¢ Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (HasSubset.Subset t (setOf fun p => Exists fun x => Exists fun y => And (Membership.mem d { fst := p.1, snd := x }) (And (Membership.mem s { fst := x, snd := y }) (Membership.mem d { fst := y, snd := p.2 })))))","decl":"theorem nhdset_of_mem_uniformity {d : Set (Œ± √ó Œ±)} (s : Set (Œ± √ó Œ±)) (hd : d ‚àà ùì§ Œ±) :\n    ‚àÉ t : Set (Œ± √ó Œ±), IsOpen t ‚àß s ‚äÜ t ‚àß\n      t ‚äÜ { p | ‚àÉ x y, (p.1, x) ‚àà d ‚àß (x, y) ‚àà s ‚àß (y, p.2) ‚àà d } := by\n  let cl_d := { p : Œ± √ó Œ± | ‚àÉ x y, (p.1, x) ‚àà d ‚àß (x, y) ‚àà s ‚àß (y, p.2) ‚àà d }\n  have : ‚àÄ p ‚àà s, ‚àÉ t, t ‚äÜ cl_d ‚àß IsOpen t ‚àß p ‚àà t := fun ‚ü®x, y‚ü© hp =>\n    mem_nhds_iff.mp <|\n      show cl_d ‚àà ùìù (x, y) by\n        rw [nhds_eq_uniformity_prod, mem_lift'_sets]\n        ¬∑ exact ‚ü®d, hd, fun ‚ü®a, b‚ü© ‚ü®ha, hb‚ü© => ‚ü®x, y, ha, hp, hb‚ü©‚ü©\n        ¬∑ exact fun _ _ h _ h' => ‚ü®h h'.1, h h'.2‚ü©\n  choose t ht using this\n  exact ‚ü®(‚ãÉ p : Œ± √ó Œ±, ‚ãÉ h : p ‚àà s, t p h : Set (Œ± √ó Œ±)),\n    isOpen_iUnion fun p : Œ± √ó Œ± => isOpen_iUnion fun hp => (ht p hp).right.left,\n    fun ‚ü®a, b‚ü© hp => by\n      simp only [mem_iUnion, Prod.exists]; exact ‚ü®a, b, hp, (ht (a, b) hp).right.right‚ü©,\n    iUnion_subset fun p => iUnion_subset fun hp => (ht p hp).left‚ü©\n\n"}
{"name":"nhds_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nx : Œ±\n‚ä¢ LE.le (nhds { fst := x, snd := x }) (uniformity Œ±)","decl":"/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhds_le_uniformity (x : Œ±) : ùìù (x, x) ‚â§ ùì§ Œ± := by\n  intro V V_in\n  rcases comp_symm_mem_uniformity_sets V_in with ‚ü®w, w_in, w_symm, w_sub‚ü©\n  have : ball x w √óÀ¢ ball x w ‚àà ùìù (x, x) := by\n    rw [nhds_prod_eq]\n    exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)\n  apply mem_of_superset this\n  rintro ‚ü®u, v‚ü© ‚ü®u_in, v_in‚ü©\n  exact w_sub (mem_comp_of_mem_ball w_symm u_in v_in)\n\n"}
{"name":"iSup_nhds_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le (iSup fun x => nhds { fst := x, snd := x }) (uniformity Œ±)","decl":"/-- Entourages are neighborhoods of the diagonal. -/\ntheorem iSup_nhds_le_uniformity : ‚®Ü x : Œ±, ùìù (x, x) ‚â§ ùì§ Œ± :=\n  iSup_le nhds_le_uniformity\n\n"}
{"name":"nhdsSet_diagonal_le_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ LE.le (nhdsSet (Set.diagonal Œ±)) (uniformity Œ±)","decl":"/-- Entourages are neighborhoods of the diagonal. -/\ntheorem nhdsSet_diagonal_le_uniformity : ùìùÀ¢ (diagonal Œ±) ‚â§ ùì§ Œ± :=\n  (nhdsSet_diagonal Œ±).trans_le iSup_nhds_le_uniformity\n\n"}
{"name":"closure_eq_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\n‚ä¢ Eq (closure s) (Set.iInter fun V => Set.iInter fun h => compRel (compRel V s) V)","decl":"theorem closure_eq_uniformity (s : Set <| Œ± √ó Œ±) :\n    closure s = ‚ãÇ V ‚àà { V | V ‚àà ùì§ Œ± ‚àß SymmetricRel V }, V ‚óã s ‚óã V := by\n  ext ‚ü®x, y‚ü©\n  simp +contextual only\n    [mem_closure_iff_nhds_basis (UniformSpace.hasBasis_nhds_prod x y), mem_iInter, mem_setOf_eq,\n      and_imp, mem_comp_comp, exists_prop, ‚Üê mem_inter_iff, inter_comm, Set.Nonempty]\n\n"}
{"name":"uniformity_hasBasis_closed","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun V => And (Membership.mem (uniformity Œ±) V) (IsClosed V)) id","decl":"theorem uniformity_hasBasis_closed :\n    HasBasis (ùì§ Œ±) (fun V : Set (Œ± √ó Œ±) => V ‚àà ùì§ Œ± ‚àß IsClosed V) id := by\n  refine Filter.hasBasis_self.2 fun t h => ?_\n  rcases comp_comp_symm_mem_uniformity_sets h with ‚ü®w, w_in, w_symm, r‚ü©\n  refine ‚ü®closure w, mem_of_superset w_in subset_closure, isClosed_closure, ?_‚ü©\n  refine Subset.trans ?_ r\n  rw [closure_eq_uniformity]\n  apply iInter_subset_of_subset\n  apply iInter_subset\n  exact ‚ü®w_in, w_symm‚ü©\n\n"}
{"name":"uniformity_eq_uniformity_closure","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity Œ±) ((uniformity Œ±).lift' closure)","decl":"theorem uniformity_eq_uniformity_closure : ùì§ Œ± = (ùì§ Œ±).lift' closure :=\n  Eq.symm <| uniformity_hasBasis_closed.lift'_closure_eq_self fun _ => And.right\n\n"}
{"name":"Filter.HasBasis.uniformity_closure","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => closure (U i)","decl":"theorem Filter.HasBasis.uniformity_closure {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (h : (ùì§ Œ±).HasBasis p U) : (ùì§ Œ±).HasBasis p fun i => closure (U i) :=\n  (@uniformity_eq_uniformity_closure Œ± _).symm ‚ñ∏ h.lift'_closure\n\n"}
{"name":"uniformity_hasBasis_closure","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun V => Membership.mem (uniformity Œ±) V) closure","decl":"/-- Closed entourages form a basis of the uniformity filter. -/\ntheorem uniformity_hasBasis_closure : HasBasis (ùì§ Œ±) (fun V : Set (Œ± √ó Œ±) => V ‚àà ùì§ Œ±) closure :=\n  (ùì§ Œ±).basis_sets.uniformity_closure\n\n"}
{"name":"closure_eq_inter_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nt : Set (Prod Œ± Œ±)\n‚ä¢ Eq (closure t) (Set.iInter fun d => Set.iInter fun h => compRel d (compRel t d))","decl":"theorem closure_eq_inter_uniformity {t : Set (Œ± √ó Œ±)} : closure t = ‚ãÇ d ‚àà ùì§ Œ±, d ‚óã (t ‚óã d) :=\n  calc\n    closure t = ‚ãÇ (V) (_ : V ‚àà ùì§ Œ± ‚àß SymmetricRel V), V ‚óã t ‚óã V := closure_eq_uniformity t\n    _ = ‚ãÇ V ‚àà ùì§ Œ±, V ‚óã t ‚óã V :=\n      Eq.symm <|\n        UniformSpace.hasBasis_symmetric.biInter_mem fun _ _ hV =>\n          compRel_mono (compRel_mono hV Subset.rfl) hV\n    _ = ‚ãÇ V ‚àà ùì§ Œ±, V ‚óã (t ‚óã V) := by simp only [compRel_assoc]\n\n"}
{"name":"uniformity_eq_uniformity_interior","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity Œ±) ((uniformity Œ±).lift' interior)","decl":"theorem uniformity_eq_uniformity_interior : ùì§ Œ± = (ùì§ Œ±).lift' interior :=\n  le_antisymm\n    (le_iInf‚ÇÇ fun d hd => by\n      let ‚ü®s, hs, hs_comp‚ü© := comp3_mem_uniformity hd\n      let ‚ü®t, ht, hst, ht_comp‚ü© := nhdset_of_mem_uniformity s hs\n      have : s ‚äÜ interior d :=\n        calc\n          s ‚äÜ t := hst\n          _ ‚äÜ interior d :=\n            ht.subset_interior_iff.mpr fun x (hx : x ‚àà t) =>\n              let ‚ü®x, y, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := ht_comp hx\n              hs_comp ‚ü®x, h‚ÇÅ, y, h‚ÇÇ, h‚ÇÉ‚ü©\n      have : interior d ‚àà ùì§ Œ± := by filter_upwards [hs] using this\n      simp [this])\n    fun _ hs => ((ùì§ Œ±).lift' interior).sets_of_superset (mem_lift' hs) interior_subset\n\n"}
{"name":"interior_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Membership.mem (uniformity Œ±) (interior s)","decl":"theorem interior_mem_uniformity {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) : interior s ‚àà ùì§ Œ± := by\n  rw [uniformity_eq_uniformity_interior]; exact mem_lift' hs\n\n"}
{"name":"mem_uniformity_isClosed","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nh : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (IsClosed t) (HasSubset.Subset t s))","decl":"theorem mem_uniformity_isClosed {s : Set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) : ‚àÉ t ‚àà ùì§ Œ±, IsClosed t ‚àß t ‚äÜ s :=\n  let ‚ü®t, ‚ü®ht_mem, htc‚ü©, hts‚ü© := uniformity_hasBasis_closed.mem_iff.1 h\n  ‚ü®t, ht_mem, htc, hts‚ü©\n\n"}
{"name":"isOpen_iff_isOpen_ball_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun V => And (Membership.mem (uniformity Œ±) V) (And (IsOpen V) (HasSubset.Subset (UniformSpace.ball x V) s)))","decl":"theorem isOpen_iff_isOpen_ball_subset {s : Set Œ±} :\n    IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ V ‚àà ùì§ Œ±, IsOpen V ‚àß ball x V ‚äÜ s := by\n  rw [isOpen_iff_ball_subset]\n  constructor <;> intro h x hx\n  ¬∑ obtain ‚ü®V, hV, hV'‚ü© := h x hx\n    exact\n      ‚ü®interior V, interior_mem_uniformity hV, isOpen_interior,\n        (ball_mono interior_subset x).trans hV'‚ü©\n  ¬∑ obtain ‚ü®V, hV, -, hV'‚ü© := h x hx\n    exact ‚ü®V, hV, hV'‚ü©\n\n"}
{"name":"isOpen_iff_open_ball_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun V => And (Membership.mem (uniformity Œ±) V) (And (IsOpen V) (HasSubset.Subset (UniformSpace.ball x V) s)))","decl":"@[deprecated (since := \"2024-11-18\")] alias\nisOpen_iff_open_ball_subset := isOpen_iff_isOpen_ball_subset\n\n"}
{"name":"Dense.biUnion_uniformity_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\nU : Set (Prod Œ± Œ±)\nhs : Dense s\nhU : Membership.mem (uniformity Œ±) U\n‚ä¢ Eq (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x U) Set.univ","decl":"/-- The uniform neighborhoods of all points of a dense set cover the whole space. -/\ntheorem Dense.biUnion_uniformity_ball {s : Set Œ±} {U : Set (Œ± √ó Œ±)} (hs : Dense s) (hU : U ‚àà ùì§ Œ±) :\n    ‚ãÉ x ‚àà s, ball x U = univ := by\n  refine iUnion‚ÇÇ_eq_univ_iff.2 fun y => ?_\n  rcases hs.inter_nhds_nonempty (mem_nhds_right y hU) with ‚ü®x, hxs, hxy : (x, y) ‚àà U‚ü©\n  exact ‚ü®x, hxs, hxy‚ü©\n\n"}
{"name":"DenseRange.iUnion_uniformity_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nŒπ : Type u_2\nxs : Œπ ‚Üí Œ±\nxs_dense : DenseRange xs\nU : Set (Prod Œ± Œ±)\nhU : Membership.mem (uniformity Œ±) U\n‚ä¢ Eq (Set.iUnion fun i => UniformSpace.ball (xs i) U) Set.univ","decl":"/-- The uniform neighborhoods of all points of a dense indexed collection cover the whole space. -/\nlemma DenseRange.iUnion_uniformity_ball {Œπ : Type*} {xs : Œπ ‚Üí Œ±}\n    (xs_dense : DenseRange xs) {U : Set (Œ± √ó Œ±)} (hU : U ‚àà uniformity Œ±) :\n    ‚ãÉ i, UniformSpace.ball (xs i) U = univ := by\n  rw [‚Üê biUnion_range (f := xs) (g := fun x ‚Ü¶ UniformSpace.ball x U)]\n  exact Dense.biUnion_uniformity_ball xs_dense hU\n\n"}
{"name":"uniformity_hasBasis_open","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun V => And (Membership.mem (uniformity Œ±) V) (IsOpen V)) id","decl":"/-- Open elements of `ùì§ Œ±` form a basis of `ùì§ Œ±`. -/\ntheorem uniformity_hasBasis_open : HasBasis (ùì§ Œ±) (fun V : Set (Œ± √ó Œ±) => V ‚àà ùì§ Œ± ‚àß IsOpen V) id :=\n  hasBasis_self.2 fun s hs =>\n    ‚ü®interior s, interior_mem_uniformity hs, isOpen_interior, interior_subset‚ü©\n\n"}
{"name":"Filter.HasBasis.mem_uniformity_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\np : Œ≤ ‚Üí Prop\ns : Œ≤ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p s\nt : Set (Prod Œ± Œ±)\n‚ä¢ Iff (Membership.mem (uniformity Œ±) t) (Exists fun i => And (p i) (‚àÄ (a b : Œ±), Membership.mem (s i) { fst := a, snd := b } ‚Üí Membership.mem t { fst := a, snd := b }))","decl":"theorem Filter.HasBasis.mem_uniformity_iff {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí Set (Œ± √ó Œ±)}\n    (h : (ùì§ Œ±).HasBasis p s) {t : Set (Œ± √ó Œ±)} :\n    t ‚àà ùì§ Œ± ‚Üî ‚àÉ i, p i ‚àß ‚àÄ a b, (a, b) ‚àà s i ‚Üí (a, b) ‚àà t :=\n  h.mem_iff.trans <| by simp only [Prod.forall, subset_def]\n\n"}
{"name":"uniformity_hasBasis_open_symmetric","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun V => And (Membership.mem (uniformity Œ±) V) (And (IsOpen V) (SymmetricRel V))) id","decl":"/-- Open elements `s : Set (Œ± √ó Œ±)` of `ùì§ Œ±` such that `(x, y) ‚àà s ‚Üî (y, x) ‚àà s` form a basis\nof `ùì§ Œ±`. -/\ntheorem uniformity_hasBasis_open_symmetric :\n    HasBasis (ùì§ Œ±) (fun V : Set (Œ± √ó Œ±) => V ‚àà ùì§ Œ± ‚àß IsOpen V ‚àß SymmetricRel V) id := by\n  simp only [‚Üê and_assoc]\n  refine uniformity_hasBasis_open.restrict fun s hs => ‚ü®symmetrizeRel s, ?_‚ü©\n  exact\n    ‚ü®‚ü®symmetrize_mem_uniformity hs.1, IsOpen.inter hs.2 (hs.2.preimage continuous_swap)‚ü©,\n      symmetric_symmetrizeRel s, symmetrizeRel_subset_self s‚ü©\n\n"}
{"name":"comp_open_symm_mem_uniformity_sets","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\ns : Set (Prod Œ± Œ±)\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun t => And (Membership.mem (uniformity Œ±) t) (And (IsOpen t) (And (SymmetricRel t) (HasSubset.Subset (compRel t t) s)))","decl":"theorem comp_open_symm_mem_uniformity_sets {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ t ‚àà ùì§ Œ±, IsOpen t ‚àß SymmetricRel t ‚àß t ‚óã t ‚äÜ s := by\n  obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := comp_mem_uniformity_sets hs\n  obtain ‚ü®u, ‚ü®hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ‚ü©, hu‚ÇÑ : u ‚äÜ t‚ü© := uniformity_hasBasis_open_symmetric.mem_iff.mp ht‚ÇÅ\n  exact ‚ü®u, hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ, (compRel_mono hu‚ÇÑ hu‚ÇÑ).trans ht‚ÇÇ‚ü©\n\n"}
{"name":"UniformSpace.has_seq_basis","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : (uniformity Œ±).IsCountablyGenerated\n‚ä¢ Exists fun V => And ((uniformity Œ±).HasAntitoneBasis V) (‚àÄ (n : Nat), SymmetricRel (V n))","decl":"theorem UniformSpace.has_seq_basis [IsCountablyGenerated <| ùì§ Œ±] :\n    ‚àÉ V : ‚Ñï ‚Üí Set (Œ± √ó Œ±), HasAntitoneBasis (ùì§ Œ±) V ‚àß ‚àÄ n, SymmetricRel (V n) :=\n  let ‚ü®U, hsym, hbasis‚ü© := (@UniformSpace.hasBasis_symmetric Œ± _).exists_antitone_subbasis\n  ‚ü®U, hbasis, fun n => (hsym n).2‚ü©\n\n"}
{"name":"Filter.HasBasis.biInter_biUnion_ball","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set (Prod Œ± Œ±)\nh : (uniformity Œ±).HasBasis p U\ns : Set Œ±\n‚ä¢ Eq (Set.iInter fun i => Set.iInter fun x => Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (U i)) (closure s)","decl":"theorem Filter.HasBasis.biInter_biUnion_ball {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (h : HasBasis (ùì§ Œ±) p U) (s : Set Œ±) :\n    (‚ãÇ (i) (_ : p i), ‚ãÉ x ‚àà s, ball x (U i)) = closure s := by\n  ext x\n  simp [mem_closure_iff_nhds_basis (nhds_basis_uniformity h), ball]\n\n"}
{"name":"uniformContinuous_def","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (r : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) r ‚Üí Membership.mem (uniformity Œ±) (setOf fun x => Membership.mem r { fst := f x.1, snd := f x.2 }))","decl":"theorem uniformContinuous_def [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî ‚àÄ r ‚àà ùì§ Œ≤, { x : Œ± √ó Œ± | (f x.1, f x.2) ‚àà r } ‚àà ùì§ Œ± :=\n  Iff.rfl\n\n"}
{"name":"uniformContinuous_iff_eventually","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (r : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) r ‚Üí Filter.Eventually (fun x => Membership.mem r { fst := f x.1, snd := f x.2 }) (uniformity Œ±))","decl":"theorem uniformContinuous_iff_eventually [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî ‚àÄ r ‚àà ùì§ Œ≤, ‚àÄ·∂† x : Œ± √ó Œ± in ùì§ Œ±, (f x.1, f x.2) ‚àà r :=\n  Iff.rfl\n\n"}
{"name":"uniformContinuousOn_univ","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuousOn f Set.univ) (UniformContinuous f)","decl":"theorem uniformContinuousOn_univ [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    UniformContinuousOn f univ ‚Üî UniformContinuous f := by\n  rw [UniformContinuousOn, UniformContinuous, univ_prod_univ, principal_univ, inf_top_eq]\n\n"}
{"name":"uniformContinuous_of_const","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nc : Œ± ‚Üí Œ≤\nh : ‚àÄ (a b : Œ±), Eq (c a) (c b)\n‚ä¢ UniformContinuous c","decl":"theorem uniformContinuous_of_const [UniformSpace Œ≤] {c : Œ± ‚Üí Œ≤} (h : ‚àÄ a b, c a = c b) :\n    UniformContinuous c :=\n  have : (fun x : Œ± √ó Œ± => (c x.fst, c x.snd)) ‚Åª¬π' idRel = univ :=\n    eq_univ_iff_forall.2 fun ‚ü®a, b‚ü© => h a b\n  le_trans (map_le_iff_le_comap.2 <| by simp [comap_principal, this, univ_mem]) refl_le_uniformity\n\n"}
{"name":"uniformContinuous_id","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous id","decl":"theorem uniformContinuous_id : UniformContinuous (@id Œ±) := tendsto_id\n\n"}
{"name":"uniformContinuous_const","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nb : Œ≤\n‚ä¢ UniformContinuous fun x => b","decl":"theorem uniformContinuous_const [UniformSpace Œ≤] {b : Œ≤} : UniformContinuous fun _ : Œ± => b :=\n  uniformContinuous_of_const fun _ _ => rfl\n\n"}
{"name":"UniformContinuous.comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nhg : UniformContinuous g\nhf : UniformContinuous f\n‚ä¢ UniformContinuous (Function.comp g f)","decl":"nonrec theorem UniformContinuous.comp [UniformSpace Œ≤] [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}\n    (hg : UniformContinuous g) (hf : UniformContinuous f) : UniformContinuous (g ‚àò f) :=\n  hg.comp hf\n\n"}
{"name":"UniformContinuous.iterate","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ≤ : Type ub\ninst‚úù : UniformSpace Œ≤\nT : Œ≤ ‚Üí Œ≤\nn : Nat\nh : UniformContinuous T\n‚ä¢ UniformContinuous (Nat.iterate T n)","decl":"/--If a function `T` is uniformly continuous in a uniform space `Œ≤`,\nthen its `n`-th iterate `T^[n]` is also uniformly continuous.-/\ntheorem UniformContinuous.iterate [UniformSpace Œ≤] (T : Œ≤ ‚Üí Œ≤) (n : ‚Ñï) (h : UniformContinuous T) :\n    UniformContinuous T^[n] := by\n  induction n with\n  | zero => exact uniformContinuous_id\n  | succ n hn => exact Function.iterate_succ _ _ ‚ñ∏ UniformContinuous.comp hn h\n\n"}
{"name":"Filter.HasBasis.uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒπ : Sort u_1\ninst‚úù¬π : UniformSpace Œ±\nŒπ' : Sort u_2\ninst‚úù : UniformSpace Œ≤\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nha : (uniformity Œ±).HasBasis p s\nq : Œπ' ‚Üí Prop\nt : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nhb : (uniformity Œ≤).HasBasis q t\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (i : Œπ'), q i ‚Üí Exists fun j => And (p j) (‚àÄ (x y : Œ±), Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (t i) { fst := f x, snd := f y }))","decl":"theorem Filter.HasBasis.uniformContinuous_iff {Œπ'} [UniformSpace Œ≤] {p : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (ha : (ùì§ Œ±).HasBasis p s) {q : Œπ' ‚Üí Prop} {t : Œπ' ‚Üí Set (Œ≤ √ó Œ≤)}\n    (hb : (ùì§ Œ≤).HasBasis q t) {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî ‚àÄ i, q i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà t i :=\n  (ha.tendsto_iff hb).trans <| by simp only [Prod.forall]\n\n"}
{"name":"Filter.HasBasis.uniformContinuousOn_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒπ : Sort u_1\ninst‚úù¬π : UniformSpace Œ±\nŒπ' : Sort u_2\ninst‚úù : UniformSpace Œ≤\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nha : (uniformity Œ±).HasBasis p s\nq : Œπ' ‚Üí Prop\nt : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nhb : (uniformity Œ≤).HasBasis q t\nf : Œ± ‚Üí Œ≤\nS : Set Œ±\n‚ä¢ Iff (UniformContinuousOn f S) (‚àÄ (i : Œπ'), q i ‚Üí Exists fun j => And (p j) (‚àÄ (x : Œ±), Membership.mem S x ‚Üí ‚àÄ (y : Œ±), Membership.mem S y ‚Üí Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (t i) { fst := f x, snd := f y }))","decl":"theorem Filter.HasBasis.uniformContinuousOn_iff {Œπ'} [UniformSpace Œ≤] {p : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set (Œ± √ó Œ±)} (ha : (ùì§ Œ±).HasBasis p s) {q : Œπ' ‚Üí Prop} {t : Œπ' ‚Üí Set (Œ≤ √ó Œ≤)}\n    (hb : (ùì§ Œ≤).HasBasis q t) {f : Œ± ‚Üí Œ≤} {S : Set Œ±} :\n    UniformContinuousOn f S ‚Üî\n      ‚àÄ i, q i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x, x ‚àà S ‚Üí ‚àÄ y, y ‚àà S ‚Üí (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà t i :=\n  ((ha.inf_principal (S √óÀ¢ S)).tendsto_iff hb).trans <| by\n    simp_rw [Prod.forall, Set.inter_comm (s _), forall_mem_comm, mem_inter_iff, mem_prod, and_imp]\n\n"}
{"name":"UniformSpace.le_def","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\n‚ä¢ Iff (LE.le u‚ÇÅ u‚ÇÇ) (LE.le (uniformity Œ±) (uniformity Œ±))","decl":"protected theorem UniformSpace.le_def {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} : u‚ÇÅ ‚â§ u‚ÇÇ ‚Üî ùì§[u‚ÇÅ] ‚â§ ùì§[u‚ÇÇ] := Iff.rfl\n\n"}
{"name":"UniformSpace.sInf_le","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ntt : Set (UniformSpace Œ±)\nt : UniformSpace Œ±\nh : Membership.mem tt t\n‚ä¢ LE.le (InfSet.sInf tt) t","decl":"protected theorem UniformSpace.sInf_le {tt : Set (UniformSpace Œ±)} {t : UniformSpace Œ±}\n    (h : t ‚àà tt) : sInf tt ‚â§ t :=\n  show ‚®Ö u ‚àà tt, ùì§[u] ‚â§ ùì§[t] from iInf‚ÇÇ_le t h\n\n"}
{"name":"UniformSpace.le_sInf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ntt : Set (UniformSpace Œ±)\nt : UniformSpace Œ±\nh : ‚àÄ (t' : UniformSpace Œ±), Membership.mem tt t' ‚Üí LE.le t t'\n‚ä¢ LE.le t (InfSet.sInf tt)","decl":"protected theorem UniformSpace.le_sInf {tt : Set (UniformSpace Œ±)} {t : UniformSpace Œ±}\n    (h : ‚àÄ t' ‚àà tt, t ‚â§ t') : t ‚â§ sInf tt :=\n  show ùì§[t] ‚â§ ‚®Ö u ‚àà tt, ùì§[u] from le_iInf‚ÇÇ h\n\n"}
{"name":"iInf_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_2\nu : Œπ ‚Üí UniformSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iInf fun i => uniformity Œ±)","decl":"theorem iInf_uniformity {Œπ : Sort*} {u : Œπ ‚Üí UniformSpace Œ±} : ùì§[iInf u] = ‚®Ö i, ùì§[u i] :=\n  iInf_range\n\n"}
{"name":"inf_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu v : UniformSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (Min.min (uniformity Œ±) (uniformity Œ±))","decl":"theorem inf_uniformity {u v : UniformSpace Œ±} : ùì§[u ‚äì v] = ùì§[u] ‚äì ùì§[v] := rfl\n\n"}
{"name":"bot_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\n‚ä¢ Eq (uniformity Œ±) (Filter.principal idRel)","decl":"lemma bot_uniformity : ùì§[(‚ä• : UniformSpace Œ±)] = ùìü idRel := rfl\n\n"}
{"name":"top_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\n‚ä¢ Eq (uniformity Œ±) Top.top","decl":"lemma top_uniformity : ùì§[(‚ä§ : UniformSpace Œ±)] = ‚ä§ := rfl\n\n"}
{"name":"uniformity_comap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nx‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (Prod.map f f) (uniformity Œ≤))","decl":"theorem uniformity_comap {_ : UniformSpace Œ≤} (f : Œ± ‚Üí Œ≤) :\n    ùì§[UniformSpace.comap f ‚Äπ_‚Ä∫] = comap (Prod.map f f) (ùì§ Œ≤) :=\n  rfl\n\n"}
{"name":"ball_preimage","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nU : Set (Prod Œ≤ Œ≤)\nx : Œ±\n‚ä¢ Eq (UniformSpace.ball x (Set.preimage (Prod.map f f) U)) (Set.preimage f (UniformSpace.ball (f x) U))","decl":"lemma ball_preimage {f : Œ± ‚Üí Œ≤} {U : Set (Œ≤ √ó Œ≤)} {x : Œ±} :\n    UniformSpace.ball x (Prod.map f f ‚Åª¬π' U) = f ‚Åª¬π' UniformSpace.ball (f x) U := by\n  ext : 1\n  simp only [UniformSpace.ball, mem_preimage, Prod.map_apply]\n\n"}
{"name":"uniformSpace_comap_id","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\n‚ä¢ Eq (UniformSpace.comap id) id","decl":"@[simp]\ntheorem uniformSpace_comap_id {Œ± : Type*} : UniformSpace.comap (id : Œ± ‚Üí Œ±) = id := by\n  ext : 2\n  rw [uniformity_comap, Prod.map_id, comap_id]\n\n"}
{"name":"UniformSpace.comap_comap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\nuŒ≥ : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\n‚ä¢ Eq (UniformSpace.comap (Function.comp g f) uŒ≥) (UniformSpace.comap f (UniformSpace.comap g uŒ≥))","decl":"theorem UniformSpace.comap_comap {Œ± Œ≤ Œ≥} {uŒ≥ : UniformSpace Œ≥} {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} :\n    UniformSpace.comap (g ‚àò f) uŒ≥ = UniformSpace.comap f (UniformSpace.comap g uŒ≥) := by\n  ext1\n  simp only [uniformity_comap, Filter.comap_comap, Prod.map_comp_map]\n\n"}
{"name":"UniformSpace.comap_inf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_3\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≥\n‚ä¢ Eq (UniformSpace.comap f (Min.min u‚ÇÅ u‚ÇÇ)) (Min.min (UniformSpace.comap f u‚ÇÅ) (UniformSpace.comap f u‚ÇÇ))","decl":"theorem UniformSpace.comap_inf {Œ± Œ≥} {u‚ÇÅ u‚ÇÇ : UniformSpace Œ≥} {f : Œ± ‚Üí Œ≥} :\n    (u‚ÇÅ ‚äì u‚ÇÇ).comap f = u‚ÇÅ.comap f ‚äì u‚ÇÇ.comap f :=\n  UniformSpace.ext Filter.comap_inf\n\n"}
{"name":"UniformSpace.comap_iInf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œπ : Sort u_2\nŒ± : Type u_3\nŒ≥ : Type u_4\nu : Œπ ‚Üí UniformSpace Œ≥\nf : Œ± ‚Üí Œ≥\n‚ä¢ Eq (UniformSpace.comap f (iInf fun i => u i)) (iInf fun i => UniformSpace.comap f (u i))","decl":"theorem UniformSpace.comap_iInf {Œπ Œ± Œ≥} {u : Œπ ‚Üí UniformSpace Œ≥} {f : Œ± ‚Üí Œ≥} :\n    (‚®Ö i, u i).comap f = ‚®Ö i, (u i).comap f := by\n  ext : 1\n  simp [uniformity_comap, iInf_uniformity]\n\n"}
{"name":"UniformSpace.comap_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_3\nf : Œ± ‚Üí Œ≥\n‚ä¢ Monotone fun u => UniformSpace.comap f u","decl":"theorem UniformSpace.comap_mono {Œ± Œ≥} {f : Œ± ‚Üí Œ≥} :\n    Monotone fun u : UniformSpace Œ≥ => u.comap f := fun _ _ hu =>\n  Filter.comap_mono hu\n\n"}
{"name":"uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nuŒ± : UniformSpace Œ±\nuŒ≤ : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (LE.le uŒ± (UniformSpace.comap f uŒ≤))","decl":"theorem uniformContinuous_iff {Œ± Œ≤} {uŒ± : UniformSpace Œ±} {uŒ≤ : UniformSpace Œ≤} {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî uŒ± ‚â§ uŒ≤.comap f :=\n  Filter.map_le_iff_le_comap\n\n"}
{"name":"le_iff_uniformContinuous_id","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu v : UniformSpace Œ±\n‚ä¢ Iff (LE.le u v) (UniformContinuous id)","decl":"theorem le_iff_uniformContinuous_id {u v : UniformSpace Œ±} :\n    u ‚â§ v ‚Üî @UniformContinuous _ _ u v id := by\n  rw [uniformContinuous_iff, uniformSpace_comap_id, id]\n\n"}
{"name":"uniformContinuous_comap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu : UniformSpace Œ≤\n‚ä¢ UniformContinuous f","decl":"theorem uniformContinuous_comap {f : Œ± ‚Üí Œ≤} [u : UniformSpace Œ≤] :\n    @UniformContinuous Œ± Œ≤ (UniformSpace.comap f u) u f :=\n  tendsto_comap\n\n"}
{"name":"uniformContinuous_comap'","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\nf : Œ≥ ‚Üí Œ≤\ng : Œ± ‚Üí Œ≥\nv : UniformSpace Œ≤\nu : UniformSpace Œ±\nh : UniformContinuous (Function.comp f g)\n‚ä¢ UniformContinuous g","decl":"theorem uniformContinuous_comap' {f : Œ≥ ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} [v : UniformSpace Œ≤] [u : UniformSpace Œ±]\n    (h : UniformContinuous (f ‚àò g)) : @UniformContinuous Œ± Œ≥ u (UniformSpace.comap f v) g :=\n  tendsto_comap_iff.2 h\n\n"}
{"name":"UniformSpace.to_nhds_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\nh : LE.le u‚ÇÅ u‚ÇÇ\na : Œ±\n‚ä¢ LE.le (nhds a) (nhds a)","decl":"theorem to_nhds_mono {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} (h : u‚ÇÅ ‚â§ u‚ÇÇ) (a : Œ±) :\n    @nhds _ (@UniformSpace.toTopologicalSpace _ u‚ÇÅ) a ‚â§\n      @nhds _ (@UniformSpace.toTopologicalSpace _ u‚ÇÇ) a := by\n  rw [@nhds_eq_uniformity Œ± u‚ÇÅ a, @nhds_eq_uniformity Œ± u‚ÇÇ a]; exact lift'_mono h le_rfl\n\n"}
{"name":"UniformSpace.toTopologicalSpace_mono","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\nh : LE.le u‚ÇÅ u‚ÇÇ\n‚ä¢ LE.le UniformSpace.toTopologicalSpace UniformSpace.toTopologicalSpace","decl":"theorem toTopologicalSpace_mono {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} (h : u‚ÇÅ ‚â§ u‚ÇÇ) :\n    @UniformSpace.toTopologicalSpace _ u‚ÇÅ ‚â§ @UniformSpace.toTopologicalSpace _ u‚ÇÇ :=\n  le_of_nhds_le_nhds <| to_nhds_mono h\n\n"}
{"name":"UniformSpace.toTopologicalSpace_comap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu : UniformSpace Œ≤\n‚ä¢ Eq UniformSpace.toTopologicalSpace (TopologicalSpace.induced f UniformSpace.toTopologicalSpace)","decl":"theorem toTopologicalSpace_comap {f : Œ± ‚Üí Œ≤} {u : UniformSpace Œ≤} :\n    @UniformSpace.toTopologicalSpace _ (UniformSpace.comap f u) =\n      TopologicalSpace.induced f (@UniformSpace.toTopologicalSpace Œ≤ u) :=\n  rfl\n\n"}
{"name":"UniformSpace.uniformSpace_eq_bot","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu : UniformSpace Œ±\n‚ä¢ Iff (Eq u Bot.bot) (Membership.mem (uniformity Œ±) idRel)","decl":"lemma uniformSpace_eq_bot {u : UniformSpace Œ±} : u = ‚ä• ‚Üî idRel ‚àà ùì§[u] :=\n  le_bot_iff.symm.trans le_principal_iff\n\n"}
{"name":"Filter.HasBasis.uniformSpace_eq_bot","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nu : UniformSpace Œ±\nh : (uniformity Œ±).HasBasis p s\n‚ä¢ Iff (Eq u Bot.bot) (Exists fun i => And (p i) (Pairwise fun x y => Not (Membership.mem (s i) { fst := x, snd := y })))","decl":"protected lemma _root_.Filter.HasBasis.uniformSpace_eq_bot {Œπ p} {s : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    {u : UniformSpace Œ±} (h : ùì§[u].HasBasis p s) :\n    u = ‚ä• ‚Üî ‚àÉ i, p i ‚àß Pairwise fun x y : Œ± ‚Ü¶ (x, y) ‚àâ s i := by\n  simp [uniformSpace_eq_bot, h.mem_iff, subset_def, Pairwise, not_imp_not]\n\n"}
{"name":"UniformSpace.toTopologicalSpace_bot","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\n‚ä¢ Eq UniformSpace.toTopologicalSpace Bot.bot","decl":"theorem toTopologicalSpace_bot : @UniformSpace.toTopologicalSpace Œ± ‚ä• = ‚ä• := rfl\n\n"}
{"name":"UniformSpace.toTopologicalSpace_top","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\n‚ä¢ Eq UniformSpace.toTopologicalSpace Top.top","decl":"theorem toTopologicalSpace_top : @UniformSpace.toTopologicalSpace Œ± ‚ä§ = ‚ä§ := rfl\n\n"}
{"name":"UniformSpace.toTopologicalSpace_iInf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒπ : Sort u_2\nu : Œπ ‚Üí UniformSpace Œ±\n‚ä¢ Eq UniformSpace.toTopologicalSpace (iInf fun i => UniformSpace.toTopologicalSpace)","decl":"theorem toTopologicalSpace_iInf {Œπ : Sort*} {u : Œπ ‚Üí UniformSpace Œ±} :\n    (iInf u).toTopologicalSpace = ‚®Ö i, (u i).toTopologicalSpace :=\n  TopologicalSpace.ext_nhds fun a ‚Ü¶ by simp only [@nhds_eq_comap_uniformity _ (iInf u), nhds_iInf,\n    iInf_uniformity, @nhds_eq_comap_uniformity _ (u _), Filter.comap_iInf]\n\n"}
{"name":"UniformSpace.toTopologicalSpace_sInf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns : Set (UniformSpace Œ±)\n‚ä¢ Eq UniformSpace.toTopologicalSpace (iInf fun i => iInf fun h => UniformSpace.toTopologicalSpace)","decl":"theorem toTopologicalSpace_sInf {s : Set (UniformSpace Œ±)} :\n    (sInf s).toTopologicalSpace = ‚®Ö i ‚àà s, @UniformSpace.toTopologicalSpace Œ± i := by\n  rw [sInf_eq_iInf]\n  simp only [‚Üê toTopologicalSpace_iInf]\n\n"}
{"name":"UniformSpace.toTopologicalSpace_inf","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu v : UniformSpace Œ±\n‚ä¢ Eq UniformSpace.toTopologicalSpace (Min.min UniformSpace.toTopologicalSpace UniformSpace.toTopologicalSpace)","decl":"theorem toTopologicalSpace_inf {u v : UniformSpace Œ±} :\n    (u ‚äì v).toTopologicalSpace = u.toTopologicalSpace ‚äì v.toTopologicalSpace :=\n  rfl\n\n"}
{"name":"UniformContinuous.continuous","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : UniformContinuous f\n‚ä¢ Continuous f","decl":"theorem UniformContinuous.continuous [UniformSpace Œ±] [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : UniformContinuous f) : Continuous f :=\n  continuous_iff_le_induced.mpr <| UniformSpace.toTopologicalSpace_mono <|\n    uniformContinuous_iff.1 hf\n\n"}
{"name":"UniformContinuous.inf_rng","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ : UniformSpace Œ±\nu‚ÇÇ u‚ÇÉ : UniformSpace Œ≤\nh‚ÇÅ : UniformContinuous f\nh‚ÇÇ : UniformContinuous f\n‚ä¢ UniformContinuous f","decl":"theorem UniformContinuous.inf_rng {f : Œ± ‚Üí Œ≤} {u‚ÇÅ : UniformSpace Œ±} {u‚ÇÇ u‚ÇÉ : UniformSpace Œ≤}\n    (h‚ÇÅ : UniformContinuous[u‚ÇÅ, u‚ÇÇ] f) (h‚ÇÇ : UniformContinuous[u‚ÇÅ, u‚ÇÉ] f) :\n    UniformContinuous[u‚ÇÅ, u‚ÇÇ ‚äì u‚ÇÉ] f :=\n  tendsto_inf.mpr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n\n-- Porting note: renamed for dot notation\n"}
{"name":"UniformContinuous.inf_dom_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\nu‚ÇÉ : UniformSpace Œ≤\nhf : UniformContinuous f\n‚ä¢ UniformContinuous f","decl":"theorem UniformContinuous.inf_dom_left {f : Œ± ‚Üí Œ≤} {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} {u‚ÇÉ : UniformSpace Œ≤}\n    (hf : UniformContinuous[u‚ÇÅ, u‚ÇÉ] f) : UniformContinuous[u‚ÇÅ ‚äì u‚ÇÇ, u‚ÇÉ] f :=\n  tendsto_inf_left hf\n\n-- Porting note: renamed for dot notation\n"}
{"name":"UniformContinuous.inf_dom_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ±\nu‚ÇÉ : UniformSpace Œ≤\nhf : UniformContinuous f\n‚ä¢ UniformContinuous f","decl":"theorem UniformContinuous.inf_dom_right {f : Œ± ‚Üí Œ≤} {u‚ÇÅ u‚ÇÇ : UniformSpace Œ±} {u‚ÇÉ : UniformSpace Œ≤}\n    (hf : UniformContinuous[u‚ÇÇ, u‚ÇÉ] f) : UniformContinuous[u‚ÇÅ ‚äì u‚ÇÇ, u‚ÇÉ] f :=\n  tendsto_inf_right hf\n\n"}
{"name":"uniformContinuous_sInf_dom","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ : Set (UniformSpace Œ±)\nu‚ÇÇ : UniformSpace Œ≤\nu : UniformSpace Œ±\nh‚ÇÅ : Membership.mem u‚ÇÅ u\nhf : UniformContinuous f\n‚ä¢ UniformContinuous f","decl":"theorem uniformContinuous_sInf_dom {f : Œ± ‚Üí Œ≤} {u‚ÇÅ : Set (UniformSpace Œ±)} {u‚ÇÇ : UniformSpace Œ≤}\n    {u : UniformSpace Œ±} (h‚ÇÅ : u ‚àà u‚ÇÅ) (hf : UniformContinuous[u, u‚ÇÇ] f) :\n    UniformContinuous[sInf u‚ÇÅ, u‚ÇÇ] f := by\n  delta UniformContinuous\n  rw [sInf_eq_iInf', iInf_uniformity]\n  exact tendsto_iInf' ‚ü®u, h‚ÇÅ‚ü© hf\n\n"}
{"name":"uniformContinuous_sInf_rng","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ : UniformSpace Œ±\nu‚ÇÇ : Set (UniformSpace Œ≤)\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (u : UniformSpace Œ≤), Membership.mem u‚ÇÇ u ‚Üí UniformContinuous f)","decl":"theorem uniformContinuous_sInf_rng {f : Œ± ‚Üí Œ≤} {u‚ÇÅ : UniformSpace Œ±} {u‚ÇÇ : Set (UniformSpace Œ≤)} :\n    UniformContinuous[u‚ÇÅ, sInf u‚ÇÇ] f ‚Üî ‚àÄ u ‚àà u‚ÇÇ, UniformContinuous[u‚ÇÅ, u] f := by\n  delta UniformContinuous\n  rw [sInf_eq_iInf', iInf_uniformity, tendsto_iInf, SetCoe.forall]\n\n"}
{"name":"uniformContinuous_iInf_dom","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒπ : Sort u_1\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ : Œπ ‚Üí UniformSpace Œ±\nu‚ÇÇ : UniformSpace Œ≤\ni : Œπ\nhf : UniformContinuous f\n‚ä¢ UniformContinuous f","decl":"theorem uniformContinuous_iInf_dom {f : Œ± ‚Üí Œ≤} {u‚ÇÅ : Œπ ‚Üí UniformSpace Œ±} {u‚ÇÇ : UniformSpace Œ≤}\n    {i : Œπ} (hf : UniformContinuous[u‚ÇÅ i, u‚ÇÇ] f) : UniformContinuous[iInf u‚ÇÅ, u‚ÇÇ] f := by\n  delta UniformContinuous\n  rw [iInf_uniformity]\n  exact tendsto_iInf' i hf\n\n"}
{"name":"uniformContinuous_iInf_rng","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒπ : Sort u_1\nf : Œ± ‚Üí Œ≤\nu‚ÇÅ : UniformSpace Œ±\nu‚ÇÇ : Œπ ‚Üí UniformSpace Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (i : Œπ), UniformContinuous f)","decl":"theorem uniformContinuous_iInf_rng {f : Œ± ‚Üí Œ≤} {u‚ÇÅ : UniformSpace Œ±} {u‚ÇÇ : Œπ ‚Üí UniformSpace Œ≤} :\n    UniformContinuous[u‚ÇÅ, iInf u‚ÇÇ] f ‚Üî ‚àÄ i, UniformContinuous[u‚ÇÅ, u‚ÇÇ i] f := by\n  delta UniformContinuous\n  rw [iInf_uniformity, tendsto_iInf]\n\n"}
{"name":"discreteTopology_of_discrete_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nhŒ± : UniformSpace Œ±\nh : Eq (uniformity Œ±) (Filter.principal idRel)\n‚ä¢ DiscreteTopology Œ±","decl":"/-- A uniform space with the discrete uniformity has the discrete topology. -/\ntheorem discreteTopology_of_discrete_uniformity [hŒ± : UniformSpace Œ±] (h : uniformity Œ± = ùìü idRel) :\n    DiscreteTopology Œ± :=\n  ‚ü®(UniformSpace.ext h.symm : ‚ä• = hŒ±) ‚ñ∏ rfl‚ü©\n\n"}
{"name":"uniformContinuous_ofMul","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous ‚áëAdditive.ofMul","decl":"theorem uniformContinuous_ofMul : UniformContinuous (ofMul : Œ± ‚Üí Additive Œ±) :=\n  uniformContinuous_id\n\n"}
{"name":"uniformContinuous_toMul","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous ‚áëAdditive.toMul","decl":"theorem uniformContinuous_toMul : UniformContinuous (toMul : Additive Œ± ‚Üí Œ±) :=\n  uniformContinuous_id\n\n"}
{"name":"uniformContinuous_ofAdd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous ‚áëMultiplicative.ofAdd","decl":"theorem uniformContinuous_ofAdd : UniformContinuous (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=\n  uniformContinuous_id\n\n"}
{"name":"uniformContinuous_toAdd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous ‚áëMultiplicative.toAdd","decl":"theorem uniformContinuous_toAdd : UniformContinuous (toAdd : Multiplicative Œ± ‚Üí Œ±) :=\n  uniformContinuous_id\n\n"}
{"name":"uniformity_additive","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (Additive Œ±)) (Filter.map (Prod.map ‚áëAdditive.ofMul ‚áëAdditive.ofMul) (uniformity Œ±))","decl":"theorem uniformity_additive : ùì§ (Additive Œ±) = (ùì§ Œ±).map (Prod.map ofMul ofMul) := rfl\n\n"}
{"name":"uniformity_multiplicative","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (Multiplicative Œ±)) (Filter.map (Prod.map ‚áëMultiplicative.ofAdd ‚áëMultiplicative.ofAdd) (uniformity Œ±))","decl":"theorem uniformity_multiplicative : ùì§ (Multiplicative Œ±) = (ùì§ Œ±).map (Prod.map ofAdd ofAdd) := rfl\n\n"}
{"name":"uniformity_subtype","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\np : Œ± ‚Üí Prop\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (Subtype p)) (Filter.comap (fun q => { fst := ‚Üëq.1, snd := ‚Üëq.2 }) (uniformity Œ±))","decl":"theorem uniformity_subtype {p : Œ± ‚Üí Prop} [UniformSpace Œ±] :\n    ùì§ (Subtype p) = comap (fun q : Subtype p √ó Subtype p => (q.1.1, q.2.1)) (ùì§ Œ±) :=\n  rfl\n\n"}
{"name":"uniformity_setCoe","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns : Set Œ±\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity ‚Üës) (Filter.comap (Prod.map Subtype.val Subtype.val) (uniformity Œ±))","decl":"theorem uniformity_setCoe {s : Set Œ±} [UniformSpace Œ±] :\n    ùì§ s = comap (Prod.map ((‚Üë) : s ‚Üí Œ±) ((‚Üë) : s ‚Üí Œ±)) (ùì§ Œ±) :=\n  rfl\n\n"}
{"name":"map_uniformity_set_coe","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ns : Set Œ±\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.map (Prod.map Subtype.val Subtype.val) (uniformity ‚Üës)) (Min.min (uniformity Œ±) (Filter.principal (SProd.sprod s s)))","decl":"theorem map_uniformity_set_coe {s : Set Œ±} [UniformSpace Œ±] :\n    map (Prod.map (‚Üë) (‚Üë)) (ùì§ s) = ùì§ Œ± ‚äì ùìü (s √óÀ¢ s) := by\n  rw [uniformity_setCoe, map_comap, range_prod_map, Subtype.range_val]\n\n"}
{"name":"uniformContinuous_subtype_val","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\np : Œ± ‚Üí Prop\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous Subtype.val","decl":"theorem uniformContinuous_subtype_val {p : Œ± ‚Üí Prop} [UniformSpace Œ±] :\n    UniformContinuous (Subtype.val : { a : Œ± // p a } ‚Üí Œ±) :=\n  uniformContinuous_comap\n\n"}
{"name":"UniformContinuous.subtype_mk","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\np : Œ± ‚Üí Prop\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nh : ‚àÄ (x : Œ≤), p (f x)\n‚ä¢ UniformContinuous fun x => ‚ü®f x, ‚ãØ‚ü©","decl":"theorem UniformContinuous.subtype_mk {p : Œ± ‚Üí Prop} [UniformSpace Œ±] [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±}\n    (hf : UniformContinuous f) (h : ‚àÄ x, p (f x)) :\n    UniformContinuous (fun x => ‚ü®f x, h x‚ü© : Œ≤ ‚Üí Subtype p) :=\n  uniformContinuous_comap' hf\n\n"}
{"name":"uniformContinuousOn_iff_restrict","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (UniformContinuousOn f s) (UniformContinuous (s.restrict f))","decl":"theorem uniformContinuousOn_iff_restrict [UniformSpace Œ±] [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    UniformContinuousOn f s ‚Üî UniformContinuous (s.restrict f) := by\n  delta UniformContinuousOn UniformContinuous\n  rw [‚Üê map_uniformity_set_coe, tendsto_map'_iff]; rfl\n\n"}
{"name":"tendsto_of_uniformContinuous_subtype","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\na : Œ±\nhf : UniformContinuous fun x => f ‚Üëx\nha : Membership.mem (nhds a) s\n‚ä¢ Filter.Tendsto f (nhds a) (nhds (f a))","decl":"theorem tendsto_of_uniformContinuous_subtype [UniformSpace Œ±] [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n    {s : Set Œ±} {a : Œ±} (hf : UniformContinuous fun x : s => f x.val) (ha : s ‚àà ùìù a) :\n    Tendsto f (ùìù a) (ùìù (f a)) := by\n  rw [(@map_nhds_subtype_coe_eq_nhds Œ± _ s a (mem_of_mem_nhds ha) ha).symm]\n  exact tendsto_map' hf.continuous.continuousAt\n\n"}
{"name":"UniformContinuousOn.continuousOn","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nh : UniformContinuousOn f s\n‚ä¢ ContinuousOn f s","decl":"theorem UniformContinuousOn.continuousOn [UniformSpace Œ±] [UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (h : UniformContinuousOn f s) : ContinuousOn f s := by\n  rw [uniformContinuousOn_iff_restrict] at h\n  rw [continuousOn_iff_continuous_restrict]\n  exact h.continuous\n\n"}
{"name":"uniformity_mulOpposite","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (MulOpposite Œ±)) (Filter.comap (fun q => { fst := MulOpposite.unop q.1, snd := MulOpposite.unop q.2 }) (uniformity Œ±))","decl":"@[to_additive]\ntheorem uniformity_mulOpposite [UniformSpace Œ±] :\n    ùì§ Œ±·µê·µí·µñ = comap (fun q : Œ±·µê·µí·µñ √ó Œ±·µê·µí·µñ => (q.1.unop, q.2.unop)) (ùì§ Œ±) :=\n  rfl\n\n"}
{"name":"uniformity_addOpposite","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (uniformity (AddOpposite Œ±)) (Filter.comap (fun q => { fst := AddOpposite.unop q.1, snd := AddOpposite.unop q.2 }) (uniformity Œ±))","decl":"@[to_additive]\ntheorem uniformity_mulOpposite [UniformSpace Œ±] :\n    ùì§ Œ±·µê·µí·µñ = comap (fun q : Œ±·µê·µí·µñ √ó Œ±·µê·µí·µñ => (q.1.unop, q.2.unop)) (ùì§ Œ±) :=\n  rfl\n\n"}
{"name":"comap_uniformity_addOpposite","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.comap (fun p => { fst := AddOpposite.op p.1, snd := AddOpposite.op p.2 }) (uniformity (AddOpposite Œ±))) (uniformity Œ±)","decl":"@[to_additive (attr := simp)]\ntheorem comap_uniformity_mulOpposite [UniformSpace Œ±] :\n    comap (fun p : Œ± √ó Œ± => (MulOpposite.op p.1, MulOpposite.op p.2)) (ùì§ Œ±·µê·µí·µñ) = ùì§ Œ± := by\n  simpa [uniformity_mulOpposite, comap_comap, (¬∑ ‚àò ¬∑)] using comap_id\n\n"}
{"name":"comap_uniformity_mulOpposite","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ Eq (Filter.comap (fun p => { fst := MulOpposite.op p.1, snd := MulOpposite.op p.2 }) (uniformity (MulOpposite Œ±))) (uniformity Œ±)","decl":"@[to_additive (attr := simp)]\ntheorem comap_uniformity_mulOpposite [UniformSpace Œ±] :\n    comap (fun p : Œ± √ó Œ± => (MulOpposite.op p.1, MulOpposite.op p.2)) (ùì§ Œ±·µê·µí·µñ) = ùì§ Œ± := by\n  simpa [uniformity_mulOpposite, comap_comap, (¬∑ ‚àò ¬∑)] using comap_id\n\n"}
{"name":"MulOpposite.uniformContinuous_unop","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous MulOpposite.unop","decl":"@[to_additive]\ntheorem uniformContinuous_unop [UniformSpace Œ±] : UniformContinuous (unop : Œ±·µê·µí·µñ ‚Üí Œ±) :=\n  uniformContinuous_comap\n\n"}
{"name":"AddOpposite.uniformContinuous_unop","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous AddOpposite.unop","decl":"@[to_additive]\ntheorem uniformContinuous_unop [UniformSpace Œ±] : UniformContinuous (unop : Œ±·µê·µí·µñ ‚Üí Œ±) :=\n  uniformContinuous_comap\n\n"}
{"name":"MulOpposite.uniformContinuous_op","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous MulOpposite.op","decl":"@[to_additive]\ntheorem uniformContinuous_op [UniformSpace Œ±] : UniformContinuous (op : Œ± ‚Üí Œ±·µê·µí·µñ) :=\n  uniformContinuous_comap' uniformContinuous_id\n\n"}
{"name":"AddOpposite.uniformContinuous_op","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\n‚ä¢ UniformContinuous AddOpposite.op","decl":"@[to_additive]\ntheorem uniformContinuous_op [UniformSpace Œ±] : UniformContinuous (op : Œ± ‚Üí Œ±·µê·µí·µñ) :=\n  uniformContinuous_comap' uniformContinuous_id\n\n"}
{"name":"uniformity_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Eq (uniformity (Prod Œ± Œ≤)) (Min.min (Filter.comap (fun p => { fst := p.1.1, snd := p.2.1 }) (uniformity Œ±)) (Filter.comap (fun p => { fst := p.1.2, snd := p.2.2 }) (uniformity Œ≤)))","decl":"theorem uniformity_prod [UniformSpace Œ±] [UniformSpace Œ≤] :\n    ùì§ (Œ± √ó Œ≤) =\n      ((ùì§ Œ±).comap fun p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤ => (p.1.1, p.2.1)) ‚äì\n        (ùì§ Œ≤).comap fun p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤ => (p.1.2, p.2.2) :=\n  rfl\n\n"}
{"name":"instIsCountablyGeneratedProdUniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : (uniformity Œ±).IsCountablyGenerated\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : (uniformity Œ≤).IsCountablyGenerated\n‚ä¢ (uniformity (Prod Œ± Œ≤)).IsCountablyGenerated","decl":"instance [UniformSpace Œ±] [IsCountablyGenerated (ùì§ Œ±)]\n    [UniformSpace Œ≤] [IsCountablyGenerated (ùì§ Œ≤)] : IsCountablyGenerated (ùì§ (Œ± √ó Œ≤)) := by\n  rw [uniformity_prod]\n  infer_instance\n\n"}
{"name":"uniformity_prod_eq_comap_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Eq (uniformity (Prod Œ± Œ≤)) (Filter.comap (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (uniformity Œ±) (uniformity Œ≤)))","decl":"theorem uniformity_prod_eq_comap_prod [UniformSpace Œ±] [UniformSpace Œ≤] :\n    ùì§ (Œ± √ó Œ≤) =\n      comap (fun p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (ùì§ Œ± √óÀ¢ ùì§ Œ≤) := by\n  simp_rw [uniformity_prod, prod_eq_inf, Filter.comap_inf, Filter.comap_comap, Function.comp_def]\n\n"}
{"name":"uniformity_prod_eq_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Eq (uniformity (Prod Œ± Œ≤)) (Filter.map (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (uniformity Œ±) (uniformity Œ≤)))","decl":"theorem uniformity_prod_eq_prod [UniformSpace Œ±] [UniformSpace Œ≤] :\n    ùì§ (Œ± √ó Œ≤) = map (fun p : (Œ± √ó Œ±) √ó Œ≤ √ó Œ≤ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (ùì§ Œ± √óÀ¢ ùì§ Œ≤) := by\n  rw [map_swap4_eq_comap, uniformity_prod_eq_comap_prod]\n\n"}
{"name":"mem_uniformity_of_uniformContinuous_invariant","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\ns : Set (Prod Œ≤ Œ≤)\nf : Œ± ‚Üí Œ± ‚Üí Œ≤\nhf : UniformContinuous fun p => f p.1 p.2\nhs : Membership.mem (uniformity Œ≤) s\n‚ä¢ Exists fun u => And (Membership.mem (uniformity Œ±) u) (‚àÄ (a b c : Œ±), Membership.mem u { fst := a, snd := b } ‚Üí Membership.mem s { fst := f a c, snd := f b c })","decl":"theorem mem_uniformity_of_uniformContinuous_invariant [UniformSpace Œ±] [UniformSpace Œ≤]\n    {s : Set (Œ≤ √ó Œ≤)} {f : Œ± ‚Üí Œ± ‚Üí Œ≤} (hf : UniformContinuous fun p : Œ± √ó Œ± => f p.1 p.2)\n    (hs : s ‚àà ùì§ Œ≤) : ‚àÉ u ‚àà ùì§ Œ±, ‚àÄ a b c, (a, b) ‚àà u ‚Üí (f a c, f b c) ‚àà s := by\n  rw [UniformContinuous, uniformity_prod_eq_prod, tendsto_map'_iff] at hf\n  rcases mem_prod_iff.1 (mem_map.1 <| hf hs) with ‚ü®u, hu, v, hv, huvt‚ü©\n  exact ‚ü®u, hu, fun a b c hab => @huvt ((_, _), (_, _)) ‚ü®hab, refl_mem_uniformity hv‚ü©‚ü©\n\n"}
{"name":"mem_entourageProd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nu : Set (Prod Œ± Œ±)\nv : Set (Prod Œ≤ Œ≤)\np : Prod (Prod Œ± Œ≤) (Prod Œ± Œ≤)\n‚ä¢ Iff (Membership.mem (entourageProd u v) p) (And (Membership.mem u { fst := p.1.1, snd := p.2.1 }) (Membership.mem v { fst := p.1.2, snd := p.2.2 }))","decl":"theorem mem_entourageProd {u : Set (Œ± √ó Œ±)} {v : Set (Œ≤ √ó Œ≤)} {p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤} :\n    p ‚àà entourageProd u v ‚Üî (p.1.1, p.2.1) ‚àà u ‚àß (p.1.2, p.2.2) ‚àà v := Iff.rfl\n\n"}
{"name":"entourageProd_mem_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nt‚ÇÅ : UniformSpace Œ±\nt‚ÇÇ : UniformSpace Œ≤\nu : Set (Prod Œ± Œ±)\nv : Set (Prod Œ≤ Œ≤)\nhu : Membership.mem (uniformity Œ±) u\nhv : Membership.mem (uniformity Œ≤) v\n‚ä¢ Membership.mem (uniformity (Prod Œ± Œ≤)) (entourageProd u v)","decl":"theorem entourageProd_mem_uniformity [t‚ÇÅ : UniformSpace Œ±] [t‚ÇÇ : UniformSpace Œ≤] {u : Set (Œ± √ó Œ±)}\n    {v : Set (Œ≤ √ó Œ≤)} (hu : u ‚àà ùì§ Œ±) (hv : v ‚àà ùì§ Œ≤) :\n    entourageProd u v ‚àà ùì§ (Œ± √ó Œ≤) := by\n  rw [uniformity_prod]; exact inter_mem_inf (preimage_mem_comap hu) (preimage_mem_comap hv)\n\n"}
{"name":"ball_entourageProd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nu : Set (Prod Œ± Œ±)\nv : Set (Prod Œ≤ Œ≤)\nx : Prod Œ± Œ≤\n‚ä¢ Eq (UniformSpace.ball x (entourageProd u v)) (SProd.sprod (UniformSpace.ball x.1 u) (UniformSpace.ball x.2 v))","decl":"theorem ball_entourageProd (u : Set (Œ± √ó Œ±)) (v : Set (Œ≤ √ó Œ≤)) (x : Œ± √ó Œ≤) :\n    ball x (entourageProd u v) = ball x.1 u √óÀ¢ ball x.2 v := by\n  ext p; simp only [ball, entourageProd, Set.mem_setOf_eq, Set.mem_prod, Set.mem_preimage]\n\n"}
{"name":"Filter.HasBasis.uniformity_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒπa : Type u_2\nŒπb : Type u_3\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\npa : Œπa ‚Üí Prop\npb : Œπb ‚Üí Prop\nsa : Œπa ‚Üí Set (Prod Œ± Œ±)\nsb : Œπb ‚Üí Set (Prod Œ≤ Œ≤)\nha : (uniformity Œ±).HasBasis pa sa\nhb : (uniformity Œ≤).HasBasis pb sb\n‚ä¢ (uniformity (Prod Œ± Œ≤)).HasBasis (fun i => And (pa i.1) (pb i.2)) fun i => entourageProd (sa i.1) (sb i.2)","decl":"theorem Filter.HasBasis.uniformity_prod {Œπa Œπb : Type*} [UniformSpace Œ±] [UniformSpace Œ≤]\n    {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop} {sa : Œπa ‚Üí Set (Œ± √ó Œ±)} {sb : Œπb ‚Üí Set (Œ≤ √ó Œ≤)}\n    (ha : (ùì§ Œ±).HasBasis pa sa) (hb : (ùì§ Œ≤).HasBasis pb sb) :\n    (ùì§ (Œ± √ó Œ≤)).HasBasis (fun i : Œπa √ó Œπb ‚Ü¶ pa i.1 ‚àß pb i.2)\n    (fun i ‚Ü¶ entourageProd (sa i.1) (sb i.2)) :=\n  (ha.comap _).inf (hb.comap _)\n\n"}
{"name":"entourageProd_subset","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\ns : Set (Prod (Prod Œ± Œ≤) (Prod Œ± Œ≤))\nh : Membership.mem (uniformity (Prod Œ± Œ≤)) s\n‚ä¢ Exists fun u => And (Membership.mem (uniformity Œ±) u) (Exists fun v => And (Membership.mem (uniformity Œ≤) v) (HasSubset.Subset (entourageProd u v) s))","decl":"theorem entourageProd_subset [UniformSpace Œ±] [UniformSpace Œ≤]\n    {s : Set ((Œ± √ó Œ≤) √ó Œ± √ó Œ≤)} (h : s ‚àà ùì§ (Œ± √ó Œ≤)) :\n    ‚àÉ u ‚àà ùì§ Œ±, ‚àÉ v ‚àà ùì§ Œ≤, entourageProd u v ‚äÜ s := by\n  rcases (((ùì§ Œ±).basis_sets.uniformity_prod (ùì§ Œ≤).basis_sets).mem_iff' s).1 h with ‚ü®w, hw‚ü©\n  use w.1, hw.1.1, w.2, hw.1.2, hw.2\n\n"}
{"name":"tendsto_prod_uniformity_fst","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Filter.Tendsto (fun p => { fst := p.1.1, snd := p.2.1 }) (uniformity (Prod Œ± Œ≤)) (uniformity Œ±)","decl":"theorem tendsto_prod_uniformity_fst [UniformSpace Œ±] [UniformSpace Œ≤] :\n    Tendsto (fun p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤ => (p.1.1, p.2.1)) (ùì§ (Œ± √ó Œ≤)) (ùì§ Œ±) :=\n  le_trans (map_mono inf_le_left) map_comap_le\n\n"}
{"name":"tendsto_prod_uniformity_snd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Filter.Tendsto (fun p => { fst := p.1.2, snd := p.2.2 }) (uniformity (Prod Œ± Œ≤)) (uniformity Œ≤)","decl":"theorem tendsto_prod_uniformity_snd [UniformSpace Œ±] [UniformSpace Œ≤] :\n    Tendsto (fun p : (Œ± √ó Œ≤) √ó Œ± √ó Œ≤ => (p.1.2, p.2.2)) (ùì§ (Œ± √ó Œ≤)) (ùì§ Œ≤) :=\n  le_trans (map_mono inf_le_right) map_comap_le\n\n"}
{"name":"uniformContinuous_fst","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ UniformContinuous fun p => p.1","decl":"theorem uniformContinuous_fst [UniformSpace Œ±] [UniformSpace Œ≤] :\n    UniformContinuous fun p : Œ± √ó Œ≤ => p.1 :=\n  tendsto_prod_uniformity_fst\n\n"}
{"name":"uniformContinuous_snd","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ UniformContinuous fun p => p.2","decl":"theorem uniformContinuous_snd [UniformSpace Œ±] [UniformSpace Œ≤] :\n    UniformContinuous fun p : Œ± √ó Œ≤ => p.2 :=\n  tendsto_prod_uniformity_snd\n\n"}
{"name":"UniformContinuous.prod_mk","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf‚ÇÅ : Œ± ‚Üí Œ≤\nf‚ÇÇ : Œ± ‚Üí Œ≥\nh‚ÇÅ : UniformContinuous f‚ÇÅ\nh‚ÇÇ : UniformContinuous f‚ÇÇ\n‚ä¢ UniformContinuous fun a => { fst := f‚ÇÅ a, snd := f‚ÇÇ a }","decl":"theorem UniformContinuous.prod_mk {f‚ÇÅ : Œ± ‚Üí Œ≤} {f‚ÇÇ : Œ± ‚Üí Œ≥} (h‚ÇÅ : UniformContinuous f‚ÇÅ)\n    (h‚ÇÇ : UniformContinuous f‚ÇÇ) : UniformContinuous fun a => (f‚ÇÅ a, f‚ÇÇ a) := by\n  rw [UniformContinuous, uniformity_prod]\n  exact tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©\n\n"}
{"name":"UniformContinuous.prod_mk_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\nh : UniformContinuous f\nb : Œ≤\n‚ä¢ UniformContinuous fun a => f { fst := a, snd := b }","decl":"theorem UniformContinuous.prod_mk_left {f : Œ± √ó Œ≤ ‚Üí Œ≥} (h : UniformContinuous f) (b) :\n    UniformContinuous fun a => f (a, b) :=\n  h.comp (uniformContinuous_id.prod_mk uniformContinuous_const)\n\n"}
{"name":"UniformContinuous.prod_mk_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\nh : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun b => f { fst := a, snd := b }","decl":"theorem UniformContinuous.prod_mk_right {f : Œ± √ó Œ≤ ‚Üí Œ≥} (h : UniformContinuous f) (a) :\n    UniformContinuous fun b => f (a, b) :=\n  h.comp (uniformContinuous_const.prod_mk uniformContinuous_id)\n\n"}
{"name":"UniformContinuous.prodMap","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\nŒ¥ : Type ud\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ninst‚úù : UniformSpace Œ¥\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ¥\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous (Prod.map f g)","decl":"theorem UniformContinuous.prodMap [UniformSpace Œ¥] {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥}\n    (hf : UniformContinuous f) (hg : UniformContinuous g) : UniformContinuous (Prod.map f g) :=\n  (hf.comp uniformContinuous_fst).prod_mk (hg.comp uniformContinuous_snd)\n\n"}
{"name":"UniformContinuous.prod_map","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\nŒ¥ : Type ud\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ninst‚úù : UniformSpace Œ¥\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ¥\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-06\")] alias UniformContinuous.prod_map := UniformContinuous.prodMap\n\n"}
{"name":"toTopologicalSpace_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nu : UniformSpace Œ±\nv : UniformSpace Œ≤\n‚ä¢ Eq UniformSpace.toTopologicalSpace instTopologicalSpaceProd","decl":"theorem toTopologicalSpace_prod {Œ±} {Œ≤} [u : UniformSpace Œ±] [v : UniformSpace Œ≤] :\n    @UniformSpace.toTopologicalSpace (Œ± √ó Œ≤) instUniformSpaceProd =\n      @instTopologicalSpaceProd Œ± Œ≤ u.toTopologicalSpace v.toTopologicalSpace :=\n  rfl\n\n"}
{"name":"uniformContinuous_inf_dom_left‚ÇÇ","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nua1 ua2 : UniformSpace Œ±\nub1 ub2 : UniformSpace Œ≤\nuc1 : UniformSpace Œ≥\nh : UniformContinuous fun p => f p.1 p.2\n‚ä¢ UniformContinuous fun p => f p.1 p.2","decl":"/-- A version of `UniformContinuous.inf_dom_left` for binary functions -/\ntheorem uniformContinuous_inf_dom_left‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ua1 ua2 : UniformSpace Œ±}\n    {ub1 ub2 : UniformSpace Œ≤} {uc1 : UniformSpace Œ≥}\n    (h : by haveI := ua1; haveI := ub1; exact UniformContinuous fun p : Œ± √ó Œ≤ => f p.1 p.2) : by\n      haveI := ua1 ‚äì ua2; haveI := ub1 ‚äì ub2\n      exact UniformContinuous fun p : Œ± √ó Œ≤ => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_inf_dom_left‚ÇÇ`\n  have ha := @UniformContinuous.inf_dom_left _ _ id ua1 ua2 ua1 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_left _ _ id ub1 ub2 ub1 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 ‚äì ua2) (ub1 ‚äì ub2) ua1 ub1 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n\n"}
{"name":"uniformContinuous_inf_dom_right‚ÇÇ","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nua1 ua2 : UniformSpace Œ±\nub1 ub2 : UniformSpace Œ≤\nuc1 : UniformSpace Œ≥\nh : UniformContinuous fun p => f p.1 p.2\n‚ä¢ UniformContinuous fun p => f p.1 p.2","decl":"/-- A version of `UniformContinuous.inf_dom_right` for binary functions -/\ntheorem uniformContinuous_inf_dom_right‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ua1 ua2 : UniformSpace Œ±}\n    {ub1 ub2 : UniformSpace Œ≤} {uc1 : UniformSpace Œ≥}\n    (h : by haveI := ua2; haveI := ub2; exact UniformContinuous fun p : Œ± √ó Œ≤ => f p.1 p.2) : by\n      haveI := ua1 ‚äì ua2; haveI := ub1 ‚äì ub2\n      exact UniformContinuous fun p : Œ± √ó Œ≤ => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_inf_dom_right‚ÇÇ`\n  have ha := @UniformContinuous.inf_dom_right _ _ id ua1 ua2 ua2 (@uniformContinuous_id _ (id _))\n  have hb := @UniformContinuous.inf_dom_right _ _ id ub1 ub2 ub2 (@uniformContinuous_id _ (id _))\n  have h_unif_cont_id :=\n    @UniformContinuous.prodMap _ _ _ _ (ua1 ‚äì ua2) (ub1 ‚äì ub2) ua2 ub2 _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ h h_unif_cont_id\n\n"}
{"name":"uniformContinuous_sInf_dom‚ÇÇ","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nuas : Set (UniformSpace Œ±)\nubs : Set (UniformSpace Œ≤)\nua : UniformSpace Œ±\nub : UniformSpace Œ≤\nuc : UniformSpace Œ≥\nha : Membership.mem uas ua\nhb : Membership.mem ubs ub\nhf : UniformContinuous fun p => f p.1 p.2\n‚ä¢ UniformContinuous fun p => f p.1 p.2","decl":"/-- A version of `uniformContinuous_sInf_dom` for binary functions -/\ntheorem uniformContinuous_sInf_dom‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {uas : Set (UniformSpace Œ±)}\n    {ubs : Set (UniformSpace Œ≤)} {ua : UniformSpace Œ±} {ub : UniformSpace Œ≤} {uc : UniformSpace Œ≥}\n    (ha : ua ‚àà uas) (hb : ub ‚àà ubs) (hf : UniformContinuous fun p : Œ± √ó Œ≤ => f p.1 p.2) : by\n      haveI := sInf uas; haveI := sInf ubs\n      exact @UniformContinuous _ _ _ uc fun p : Œ± √ó Œ≤ => f p.1 p.2 := by\n  -- proof essentially copied from `continuous_sInf_dom`\n  let _ : UniformSpace (Œ± √ó Œ≤) := instUniformSpaceProd\n  have ha := uniformContinuous_sInf_dom ha uniformContinuous_id\n  have hb := uniformContinuous_sInf_dom hb uniformContinuous_id\n  have h_unif_cont_id := @UniformContinuous.prodMap _ _ _ _ (sInf uas) (sInf ubs) ua ub _ _ ha hb\n  exact @UniformContinuous.comp _ _ _ (id _) (id _) _ _ _ hf h_unif_cont_id\n\n"}
{"name":"uniformContinuous‚ÇÇ_def","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\n‚ä¢ Iff (UniformContinuous‚ÇÇ f) (UniformContinuous (Function.uncurry f))","decl":"theorem uniformContinuous‚ÇÇ_def (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) :\n    UniformContinuous‚ÇÇ f ‚Üî UniformContinuous (uncurry f) :=\n  Iff.rfl\n\n"}
{"name":"UniformContinuous‚ÇÇ.uniformContinuous","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nh : UniformContinuous‚ÇÇ f\n‚ä¢ UniformContinuous (Function.uncurry f)","decl":"theorem UniformContinuous‚ÇÇ.uniformContinuous {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : UniformContinuous‚ÇÇ f) :\n    UniformContinuous (uncurry f) :=\n  h\n\n"}
{"name":"uniformContinuous‚ÇÇ_curry","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\n‚ä¢ Iff (UniformContinuous‚ÇÇ (Function.curry f)) (UniformContinuous f)","decl":"theorem uniformContinuous‚ÇÇ_curry (f : Œ± √ó Œ≤ ‚Üí Œ≥) :\n    UniformContinuous‚ÇÇ (Function.curry f) ‚Üî UniformContinuous f := by\n  rw [UniformContinuous‚ÇÇ, uncurry_curry]\n\n"}
{"name":"UniformContinuous‚ÇÇ.comp","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\nŒ¥ : Type ud\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ninst‚úù : UniformSpace Œ¥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\ng : Œ≥ ‚Üí Œ¥\nhg : UniformContinuous g\nhf : UniformContinuous‚ÇÇ f\n‚ä¢ UniformContinuous‚ÇÇ (Function.bicompr g f)","decl":"theorem UniformContinuous‚ÇÇ.comp {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ≥ ‚Üí Œ¥} (hg : UniformContinuous g)\n    (hf : UniformContinuous‚ÇÇ f) : UniformContinuous‚ÇÇ (g ‚àò‚ÇÇ f) :=\n  hg.comp hf\n\n"}
{"name":"UniformContinuous‚ÇÇ.bicompl","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\nŒ≥ : Type uc\nŒ¥ : Type ud\nŒ¥' : Type u_2\ninst‚úù‚Å¥ : UniformSpace Œ±\ninst‚úù¬≥ : UniformSpace Œ≤\ninst‚úù¬≤ : UniformSpace Œ≥\ninst‚úù¬π : UniformSpace Œ¥\ninst‚úù : UniformSpace Œ¥'\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nga : Œ¥ ‚Üí Œ±\ngb : Œ¥' ‚Üí Œ≤\nhf : UniformContinuous‚ÇÇ f\nhga : UniformContinuous ga\nhgb : UniformContinuous gb\n‚ä¢ UniformContinuous‚ÇÇ (Function.bicompl f ga gb)","decl":"theorem UniformContinuous‚ÇÇ.bicompl {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ga : Œ¥ ‚Üí Œ±} {gb : Œ¥' ‚Üí Œ≤}\n    (hf : UniformContinuous‚ÇÇ f) (hga : UniformContinuous ga) (hgb : UniformContinuous gb) :\n    UniformContinuous‚ÇÇ (bicompl f ga gb) :=\n  hf.uniformContinuous.comp (hga.prodMap hgb)\n\n"}
{"name":"toTopologicalSpace_subtype","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nu : UniformSpace Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Eq UniformSpace.toTopologicalSpace instTopologicalSpaceSubtype","decl":"theorem toTopologicalSpace_subtype [u : UniformSpace Œ±] {p : Œ± ‚Üí Prop} :\n    @UniformSpace.toTopologicalSpace (Subtype p) instUniformSpaceSubtype =\n      @instTopologicalSpaceSubtype Œ± p u.toTopologicalSpace :=\n  rfl\n\n"}
{"name":"union_mem_uniformity_sum","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\na : Set (Prod Œ± Œ±)\nha : Membership.mem (uniformity Œ±) a\nb : Set (Prod Œ≤ Œ≤)\nhb : Membership.mem (uniformity Œ≤) b\n‚ä¢ Membership.mem (uniformity (Sum Œ± Œ≤)) (Union.union (Set.image (Prod.map Sum.inl Sum.inl) a) (Set.image (Prod.map Sum.inr Sum.inr) b))","decl":"/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. -/\ntheorem union_mem_uniformity_sum {a : Set (Œ± √ó Œ±)} (ha : a ‚àà ùì§ Œ±) {b : Set (Œ≤ √ó Œ≤)} (hb : b ‚àà ùì§ Œ≤) :\n    Prod.map inl inl '' a ‚à™ Prod.map inr inr '' b ‚àà ùì§ (Œ± ‚äï Œ≤) :=\n  union_mem_sup (image_mem_map ha) (image_mem_map hb)\n\n"}
{"name":"Sum.uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Eq (uniformity (Sum Œ± Œ≤)) (Max.max (Filter.map (Prod.map Sum.inl Sum.inl) (uniformity Œ±)) (Filter.map (Prod.map Sum.inr Sum.inr) (uniformity Œ≤)))","decl":"theorem Sum.uniformity : ùì§ (Œ± ‚äï Œ≤) = map (Prod.map inl inl) (ùì§ Œ±) ‚äî map (Prod.map inr inr) (ùì§ Œ≤) :=\n  rfl\n\n"}
{"name":"uniformContinuous_inl","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ UniformContinuous Sum.inl","decl":"lemma uniformContinuous_inl : UniformContinuous (Sum.inl : Œ± ‚Üí Œ± ‚äï Œ≤) := le_sup_left\n"}
{"name":"uniformContinuous_inr","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ UniformContinuous Sum.inr","decl":"lemma uniformContinuous_inr : UniformContinuous (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) := le_sup_right\n\n"}
{"name":"instIsCountablyGeneratedProdSumUniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : (uniformity Œ±).IsCountablyGenerated\ninst‚úù : (uniformity Œ≤).IsCountablyGenerated\n‚ä¢ (uniformity (Sum Œ± Œ≤)).IsCountablyGenerated","decl":"instance [IsCountablyGenerated (ùì§ Œ±)] [IsCountablyGenerated (ùì§ Œ≤)] :\n    IsCountablyGenerated (ùì§ (Œ± ‚äï Œ≤)) := by\n  rw [Sum.uniformity]\n  infer_instance\n\n"}
{"name":"Uniform.tendsto_nhds_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u f (nhds a)) (Filter.Tendsto (fun x => { fst := a, snd := u x }) f (uniformity Œ±))","decl":"theorem tendsto_nhds_right {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u f (ùìù a) ‚Üî Tendsto (fun x => (a, u x)) f (ùì§ Œ±) := by\n  rw [nhds_eq_comap_uniformity, tendsto_comap_iff]; rfl\n\n"}
{"name":"Uniform.tendsto_nhds_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù : UniformSpace Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u f (nhds a)) (Filter.Tendsto (fun x => { fst := u x, snd := a }) f (uniformity Œ±))","decl":"theorem tendsto_nhds_left {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u f (ùìù a) ‚Üî Tendsto (fun x => (u x, a)) f (ùì§ Œ±) := by\n  rw [nhds_eq_comap_uniformity', tendsto_comap_iff]; rfl\n\n"}
{"name":"Uniform.continuousAt_iff'_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\n‚ä¢ Iff (ContinuousAt f b) (Filter.Tendsto (fun x => { fst := f b, snd := f x }) (nhds b) (uniformity Œ±))","decl":"theorem continuousAt_iff'_right [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} :\n    ContinuousAt f b ‚Üî Tendsto (fun x => (f b, f x)) (ùìù b) (ùì§ Œ±) := by\n  rw [ContinuousAt, tendsto_nhds_right]\n\n"}
{"name":"Uniform.continuousAt_iff'_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\n‚ä¢ Iff (ContinuousAt f b) (Filter.Tendsto (fun x => { fst := f x, snd := f b }) (nhds b) (uniformity Œ±))","decl":"theorem continuousAt_iff'_left [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} :\n    ContinuousAt f b ‚Üî Tendsto (fun x => (f x, f b)) (ùìù b) (ùì§ Œ±) := by\n  rw [ContinuousAt, tendsto_nhds_left]\n\n"}
{"name":"Uniform.continuousAt_iff_prod","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\n‚ä¢ Iff (ContinuousAt f b) (Filter.Tendsto (fun x => { fst := f x.1, snd := f x.2 }) (nhds { fst := b, snd := b }) (uniformity Œ±))","decl":"theorem continuousAt_iff_prod [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} :\n    ContinuousAt f b ‚Üî Tendsto (fun x : Œ≤ √ó Œ≤ => (f x.1, f x.2)) (ùìù (b, b)) (ùì§ Œ±) :=\n  ‚ü®fun H => le_trans (H.prodMap' H) (nhds_le_uniformity _), fun H =>\n    continuousAt_iff'_left.2 <| H.comp <| tendsto_id.prod_mk_nhds tendsto_const_nhds‚ü©\n\n"}
{"name":"Uniform.continuousWithinAt_iff'_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\ns : Set Œ≤\n‚ä¢ Iff (ContinuousWithinAt f s b) (Filter.Tendsto (fun x => { fst := f b, snd := f x }) (nhdsWithin b s) (uniformity Œ±))","decl":"theorem continuousWithinAt_iff'_right [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : Set Œ≤} :\n    ContinuousWithinAt f s b ‚Üî Tendsto (fun x => (f b, f x)) (ùìù[s] b) (ùì§ Œ±) := by\n  rw [ContinuousWithinAt, tendsto_nhds_right]\n\n"}
{"name":"Uniform.continuousWithinAt_iff'_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\ns : Set Œ≤\n‚ä¢ Iff (ContinuousWithinAt f s b) (Filter.Tendsto (fun x => { fst := f x, snd := f b }) (nhdsWithin b s) (uniformity Œ±))","decl":"theorem continuousWithinAt_iff'_left [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : Set Œ≤} :\n    ContinuousWithinAt f s b ‚Üî Tendsto (fun x => (f x, f b)) (ùìù[s] b) (ùì§ Œ±) := by\n  rw [ContinuousWithinAt, tendsto_nhds_left]\n\n"}
{"name":"Uniform.continuousOn_iff'_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\ns : Set Œ≤\n‚ä¢ Iff (ContinuousOn f s) (‚àÄ (b : Œ≤), Membership.mem s b ‚Üí Filter.Tendsto (fun x => { fst := f b, snd := f x }) (nhdsWithin b s) (uniformity Œ±))","decl":"theorem continuousOn_iff'_right [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ≤} :\n    ContinuousOn f s ‚Üî ‚àÄ b ‚àà s, Tendsto (fun x => (f b, f x)) (ùìù[s] b) (ùì§ Œ±) := by\n  simp [ContinuousOn, continuousWithinAt_iff'_right]\n\n"}
{"name":"Uniform.continuousOn_iff'_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\ns : Set Œ≤\n‚ä¢ Iff (ContinuousOn f s) (‚àÄ (b : Œ≤), Membership.mem s b ‚Üí Filter.Tendsto (fun x => { fst := f x, snd := f b }) (nhdsWithin b s) (uniformity Œ±))","decl":"theorem continuousOn_iff'_left [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ≤} :\n    ContinuousOn f s ‚Üî ‚àÄ b ‚àà s, Tendsto (fun x => (f x, f b)) (ùìù[s] b) (ùì§ Œ±) := by\n  simp [ContinuousOn, continuousWithinAt_iff'_left]\n\n"}
{"name":"Uniform.continuous_iff'_right","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Continuous f) (‚àÄ (b : Œ≤), Filter.Tendsto (fun x => { fst := f b, snd := f x }) (nhds b) (uniformity Œ±))","decl":"theorem continuous_iff'_right [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :\n    Continuous f ‚Üî ‚àÄ b, Tendsto (fun x => (f b, f x)) (ùìù b) (ùì§ Œ±) :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds_right\n\n"}
{"name":"Uniform.continuous_iff'_left","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Continuous f) (‚àÄ (b : Œ≤), Filter.Tendsto (fun x => { fst := f x, snd := f b }) (nhds b) (uniformity Œ±))","decl":"theorem continuous_iff'_left [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :\n    Continuous f ‚Üî ‚àÄ b, Tendsto (fun x => (f x, f b)) (ùìù b) (ùì§ Œ±) :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds_left\n\n"}
{"name":"Uniform.exists_is_open_mem_uniformity_of_forall_mem_eq","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type ua\nŒ≤ : Type ub\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nr : Set (Prod Œ± Œ±)\ns : Set Œ≤\nf g : Œ≤ ‚Üí Œ±\nhf : ‚àÄ (x : Œ≤), Membership.mem s x ‚Üí ContinuousAt f x\nhg : ‚àÄ (x : Œ≤), Membership.mem s x ‚Üí ContinuousAt g x\nhfg : Set.EqOn f g s\nhr : Membership.mem (uniformity Œ±) r\n‚ä¢ Exists fun t => And (IsOpen t) (And (HasSubset.Subset s t) (‚àÄ (x : Œ≤), Membership.mem t x ‚Üí Membership.mem r { fst := f x, snd := g x }))","decl":"/-- Consider two functions `f` and `g` which coincide on a set `s` and are continuous there.\nThen there is an open neighborhood of `s` on which `f` and `g` are uniformly close. -/\nlemma exists_is_open_mem_uniformity_of_forall_mem_eq\n    [TopologicalSpace Œ≤] {r : Set (Œ± √ó Œ±)} {s : Set Œ≤}\n    {f g : Œ≤ ‚Üí Œ±} (hf : ‚àÄ x ‚àà s, ContinuousAt f x) (hg : ‚àÄ x ‚àà s, ContinuousAt g x)\n    (hfg : s.EqOn f g) (hr : r ‚àà ùì§ Œ±) :\n    ‚àÉ t, IsOpen t ‚àß s ‚äÜ t ‚àß ‚àÄ x ‚àà t, (f x, g x) ‚àà r := by\n  have A : ‚àÄ x ‚àà s, ‚àÉ t, IsOpen t ‚àß x ‚àà t ‚àß ‚àÄ z ‚àà t, (f z, g z) ‚àà r := by\n    intro x hx\n    obtain ‚ü®t, ht, htsymm, htr‚ü© := comp_symm_mem_uniformity_sets hr\n    have A : {z | (f x, f z) ‚àà t} ‚àà ùìù x := (hf x hx).preimage_mem_nhds (mem_nhds_left (f x) ht)\n    have B : {z | (g x, g z) ‚àà t} ‚àà ùìù x := (hg x hx).preimage_mem_nhds (mem_nhds_left (g x) ht)\n    rcases _root_.mem_nhds_iff.1 (inter_mem A B) with ‚ü®u, hu, u_open, xu‚ü©\n    refine ‚ü®u, u_open, xu, fun y hy ‚Ü¶ ?_‚ü©\n    have I1 : (f y, f x) ‚àà t := (htsymm.mk_mem_comm).2 (hu hy).1\n    have I2 : (g x, g y) ‚àà t := (hu hy).2\n    rw [hfg hx] at I1\n    exact htr (prod_mk_mem_compRel I1 I2)\n  choose! t t_open xt ht using A\n  refine ‚ü®‚ãÉ x ‚àà s, t x, isOpen_biUnion t_open, fun x hx ‚Ü¶ mem_biUnion hx (xt x hx), ?_‚ü©\n  rintro x hx\n  simp only [mem_iUnion, exists_prop] at hx\n  rcases hx with ‚ü®y, ys, hy‚ü©\n  exact ht y ys x hy\n\n"}
{"name":"Filter.Tendsto.congr_uniformity","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù : UniformSpace Œ≤\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nb : Œ≤\nhf : Filter.Tendsto f l (nhds b)\nhg : Filter.Tendsto (fun x => { fst := f x, snd := g x }) l (uniformity Œ≤)\n‚ä¢ Filter.Tendsto g l (nhds b)","decl":"theorem Filter.Tendsto.congr_uniformity {Œ± Œ≤} [UniformSpace Œ≤] {f g : Œ± ‚Üí Œ≤} {l : Filter Œ±} {b : Œ≤}\n    (hf : Tendsto f l (ùìù b)) (hg : Tendsto (fun x => (f x, g x)) l (ùì§ Œ≤)) : Tendsto g l (ùìù b) :=\n  Uniform.tendsto_nhds_right.2 <| (Uniform.tendsto_nhds_right.1 hf).uniformity_trans hg\n\n"}
{"name":"Uniform.tendsto_congr","module":"Mathlib.Topology.UniformSpace.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù : UniformSpace Œ≤\nf g : Œ± ‚Üí Œ≤\nl : Filter Œ±\nb : Œ≤\nhfg : Filter.Tendsto (fun x => { fst := f x, snd := g x }) l (uniformity Œ≤)\n‚ä¢ Iff (Filter.Tendsto f l (nhds b)) (Filter.Tendsto g l (nhds b))","decl":"theorem Uniform.tendsto_congr {Œ± Œ≤} [UniformSpace Œ≤] {f g : Œ± ‚Üí Œ≤} {l : Filter Œ±} {b : Œ≤}\n    (hfg : Tendsto (fun x => (f x, g x)) l (ùì§ Œ≤)) : Tendsto f l (ùìù b) ‚Üî Tendsto g l (ùìù b) :=\n  ‚ü®fun h => h.congr_uniformity hfg, fun h => h.congr_uniformity hfg.uniformity_symm‚ü©\n\n"}
