{"name":"Polynomial.roots_def","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : DecidableEq R\np : Polynomial R\ninst✝ : Decidable (Eq p 0)\n⊢ Eq p.roots (dite (Eq p 0) (fun h => EmptyCollection.emptyCollection) fun h => Classical.choose ⋯)","decl":"theorem roots_def [DecidableEq R] (p : R[X]) [Decidable (p = 0)] :\n    p.roots = if h : p = 0 then ∅ else Classical.choose (exists_multiset_roots h) := by\n  -- porting noteL `‹_›` doesn't work for instance arguments\n  rename_i iR ip0\n  obtain rfl := Subsingleton.elim iR (Classical.decEq R)\n  obtain rfl := Subsingleton.elim ip0 (Classical.dec (p = 0))\n  rfl\n\n"}
{"name":"Polynomial.roots_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.roots 0) 0","decl":"@[simp]\ntheorem roots_zero : (0 : R[X]).roots = 0 :=\n  dif_pos rfl\n\n"}
{"name":"Polynomial.card_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp0 : Ne p 0\n⊢ LE.le (↑p.roots.card) p.degree","decl":"theorem card_roots (hp0 : p ≠ 0) : (Multiset.card (roots p) : WithBot ℕ) ≤ degree p := by\n  classical\n  unfold roots\n  rw [dif_neg hp0]\n  exact (Classical.choose_spec (exists_multiset_roots hp0)).1\n\n"}
{"name":"Polynomial.card_roots'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ LE.le p.roots.card p.natDegree","decl":"theorem card_roots' (p : R[X]) : Multiset.card p.roots ≤ natDegree p := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  exact WithBot.coe_le_coe.1 (le_trans (card_roots hp0) (le_of_eq <| degree_eq_natDegree hp0))\n\n"}
{"name":"Polynomial.card_roots_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\na : R\nhp0 : LT.lt 0 p.degree\n⊢ LE.le (↑(HSub.hSub p (Polynomial.C a)).roots.card) p.degree","decl":"theorem card_roots_sub_C {p : R[X]} {a : R} (hp0 : 0 < degree p) :\n    (Multiset.card (p - C a).roots : WithBot ℕ) ≤ degree p :=\n  calc\n    (Multiset.card (p - C a).roots : WithBot ℕ) ≤ degree (p - C a) :=\n      card_roots <| mt sub_eq_zero.1 fun h => not_le_of_gt hp0 <| h.symm ▸ degree_C_le\n    _ = degree p := by rw [sub_eq_add_neg, ← C_neg]; exact degree_add_C hp0\n\n"}
{"name":"Polynomial.card_roots_sub_C'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\na : R\nhp0 : LT.lt 0 p.degree\n⊢ LE.le (HSub.hSub p (Polynomial.C a)).roots.card p.natDegree","decl":"theorem card_roots_sub_C' {p : R[X]} {a : R} (hp0 : 0 < degree p) :\n    Multiset.card (p - C a).roots ≤ natDegree p :=\n  WithBot.coe_le_coe.1\n    (le_trans (card_roots_sub_C hp0)\n      (le_of_eq <| degree_eq_natDegree fun h => by simp_all [lt_irrefl]))\n\n"}
{"name":"Polynomial.count_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\np : Polynomial R\n⊢ Eq (Multiset.count a p.roots) (Polynomial.rootMultiplicity a p)","decl":"@[simp]\ntheorem count_roots [DecidableEq R] (p : R[X]) : p.roots.count a = rootMultiplicity a p := by\n  classical\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [roots_def, dif_neg hp]\n  exact (Classical.choose_spec (exists_multiset_roots hp)).2 a\n\n"}
{"name":"Polynomial.mem_roots'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ Iff (Membership.mem p.roots a) (And (Ne p 0) (p.IsRoot a))","decl":"@[simp]\ntheorem mem_roots' : a ∈ p.roots ↔ p ≠ 0 ∧ IsRoot p a := by\n  classical\n  rw [← count_pos, count_roots p, rootMultiplicity_pos']\n\n"}
{"name":"Polynomial.mem_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp : Ne p 0\n⊢ Iff (Membership.mem p.roots a) (p.IsRoot a)","decl":"theorem mem_roots (hp : p ≠ 0) : a ∈ p.roots ↔ IsRoot p a :=\n  mem_roots'.trans <| and_iff_right hp\n\n"}
{"name":"Polynomial.ne_zero_of_mem_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nh : Membership.mem p.roots a\n⊢ Ne p 0","decl":"theorem ne_zero_of_mem_roots (h : a ∈ p.roots) : p ≠ 0 :=\n  (mem_roots'.1 h).1\n\n"}
{"name":"Polynomial.isRoot_of_mem_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nh : Membership.mem p.roots a\n⊢ p.IsRoot a","decl":"theorem isRoot_of_mem_roots (h : a ∈ p.roots) : IsRoot p a :=\n  (mem_roots'.1 h).2\n\n"}
{"name":"Polynomial.mem_roots_map_of_injective","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Semiring S\np : Polynomial S\nf : RingHom S R\nhf : Function.Injective ⇑f\nx : R\nhp : Ne p 0\n⊢ Iff (Membership.mem (Polynomial.map f p).roots x) (Eq (Polynomial.eval₂ f x p) 0)","decl":"theorem mem_roots_map_of_injective [Semiring S] {p : S[X]} {f : S →+* R}\n    (hf : Function.Injective f) {x : R} (hp : p ≠ 0) : x ∈ (p.map f).roots ↔ p.eval₂ f x = 0 := by\n  rw [mem_roots ((Polynomial.map_ne_zero_iff hf).mpr hp), IsRoot, eval_map]\n\n"}
{"name":"Polynomial.mem_roots_iff_aeval_eq_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nx : R\nw : Ne p 0\n⊢ Iff (Membership.mem p.roots x) (Eq ((Polynomial.aeval x) p) 0)","decl":"lemma mem_roots_iff_aeval_eq_zero {x : R} (w : p ≠ 0) : x ∈ roots p ↔ aeval x p = 0 := by\n  rw [aeval_def, ← mem_roots_map_of_injective (NoZeroSMulDivisors.algebraMap_injective _ _) w,\n    Algebra.id.map_eq_id, map_id]\n\n"}
{"name":"Polynomial.card_le_degree_of_subset_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nZ : Finset R\nh : HasSubset.Subset Z.val p.roots\n⊢ LE.le Z.card p.natDegree","decl":"theorem card_le_degree_of_subset_roots {p : R[X]} {Z : Finset R} (h : Z.val ⊆ p.roots) :\n    #Z ≤ p.natDegree :=\n  (Multiset.card_le_card (Finset.val_le_iff_val_subset.2 h)).trans (Polynomial.card_roots' p)\n\n"}
{"name":"Polynomial.finite_setOf_isRoot","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp : Ne p 0\n⊢ (setOf fun x => p.IsRoot x).Finite","decl":"theorem finite_setOf_isRoot {p : R[X]} (hp : p ≠ 0) : Set.Finite { x | IsRoot p x } := by\n  classical\n  simpa only [← Finset.setOf_mem, Multiset.mem_toFinset, mem_roots hp]\n    using p.roots.toFinset.finite_toSet\n\n"}
{"name":"Polynomial.eq_zero_of_infinite_isRoot","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nh : (setOf fun x => p.IsRoot x).Infinite\n⊢ Eq p 0","decl":"theorem eq_zero_of_infinite_isRoot (p : R[X]) (h : Set.Infinite { x | IsRoot p x }) : p = 0 :=\n  not_imp_comm.mp finite_setOf_isRoot h\n\n"}
{"name":"Polynomial.exists_max_root","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : LinearOrder R\np : Polynomial R\nhp : Ne p 0\n⊢ Exists fun x₀ => ∀ (x : R), p.IsRoot x → LE.le x x₀","decl":"theorem exists_max_root [LinearOrder R] (p : R[X]) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.IsRoot x → x ≤ x₀ :=\n  Set.exists_upper_bound_image _ _ <| finite_setOf_isRoot hp\n\n"}
{"name":"Polynomial.exists_min_root","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : LinearOrder R\np : Polynomial R\nhp : Ne p 0\n⊢ Exists fun x₀ => ∀ (x : R), p.IsRoot x → LE.le x₀ x","decl":"theorem exists_min_root [LinearOrder R] (p : R[X]) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.IsRoot x → x₀ ≤ x :=\n  Set.exists_lower_bound_image _ _ <| finite_setOf_isRoot hp\n\n"}
{"name":"Polynomial.eq_of_infinite_eval_eq","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nh : (setOf fun x => Eq (Polynomial.eval x p) (Polynomial.eval x q)).Infinite\n⊢ Eq p q","decl":"theorem eq_of_infinite_eval_eq (p q : R[X]) (h : Set.Infinite { x | eval x p = eval x q }) :\n    p = q := by\n  rw [← sub_eq_zero]\n  apply eq_zero_of_infinite_isRoot\n  simpa only [IsRoot, eval_sub, sub_eq_zero]\n\n"}
{"name":"Polynomial.roots_mul","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nhpq : Ne (HMul.hMul p q) 0\n⊢ Eq (HMul.hMul p q).roots (HAdd.hAdd p.roots q.roots)","decl":"theorem roots_mul {p q : R[X]} (hpq : p * q ≠ 0) : (p * q).roots = p.roots + q.roots := by\n  classical\n  exact Multiset.ext.mpr fun r => by\n    rw [count_add, count_roots, count_roots, count_roots, rootMultiplicity_mul hpq]\n\n"}
{"name":"Polynomial.roots.le_of_dvd","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nh : Ne q 0\na✝ : Dvd.dvd p q\n⊢ LE.le p.roots q.roots","decl":"theorem roots.le_of_dvd (h : q ≠ 0) : p ∣ q → roots p ≤ roots q := by\n  rintro ⟨k, rfl⟩\n  exact Multiset.le_iff_exists_add.mpr ⟨k.roots, roots_mul h⟩\n\n"}
{"name":"Polynomial.mem_roots_sub_C'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\na x : R\n⊢ Iff (Membership.mem (HSub.hSub p (Polynomial.C a)).roots x) (And (Ne p (Polynomial.C a)) (Eq (Polynomial.eval x p) a))","decl":"theorem mem_roots_sub_C' {p : R[X]} {a x : R} : x ∈ (p - C a).roots ↔ p ≠ C a ∧ p.eval x = a := by\n  rw [mem_roots', IsRoot.def, sub_ne_zero, eval_sub, sub_eq_zero, eval_C]\n\n"}
{"name":"Polynomial.mem_roots_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\na x : R\nhp0 : LT.lt 0 p.degree\n⊢ Iff (Membership.mem (HSub.hSub p (Polynomial.C a)).roots x) (Eq (Polynomial.eval x p) a)","decl":"theorem mem_roots_sub_C {p : R[X]} {a x : R} (hp0 : 0 < degree p) :\n    x ∈ (p - C a).roots ↔ p.eval x = a :=\n  mem_roots_sub_C'.trans <| and_iff_right fun hp => hp0.not_le <| hp.symm ▸ degree_C_le\n\n"}
{"name":"Polynomial.roots_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Eq (HSub.hSub Polynomial.X (Polynomial.C r)).roots (Singleton.singleton r)","decl":"@[simp]\ntheorem roots_X_sub_C (r : R) : roots (X - C r) = {r} := by\n  classical\n  ext s\n  rw [count_roots, rootMultiplicity_X_sub_C, count_singleton]\n\n"}
{"name":"Polynomial.roots_X_add_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Eq (HAdd.hAdd Polynomial.X (Polynomial.C r)).roots (Singleton.singleton (Neg.neg r))","decl":"@[simp]\ntheorem roots_X_add_C (r : R) : roots (X + C r) = {-r} := by simpa using roots_X_sub_C (-r)\n\n"}
{"name":"Polynomial.roots_X","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq Polynomial.X.roots (Singleton.singleton 0)","decl":"@[simp]\ntheorem roots_X : roots (X : R[X]) = {0} := by rw [← roots_X_sub_C, C_0, sub_zero]\n\n"}
{"name":"Polynomial.roots_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : R\n⊢ Eq (Polynomial.C x).roots 0","decl":"@[simp]\ntheorem roots_C (x : R) : (C x).roots = 0 := by\n  classical exact\n  if H : x = 0 then by rw [H, C_0, roots_zero]\n  else\n    Multiset.ext.mpr fun r => (by\n      rw [count_roots, count_zero, rootMultiplicity_eq_zero (not_isRoot_C _ _ H)])\n\n"}
{"name":"Polynomial.roots_one","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.roots 1) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem roots_one : (1 : R[X]).roots = ∅ :=\n  roots_C 1\n\n"}
{"name":"Polynomial.roots_C_mul","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nha : Ne a 0\n⊢ Eq (HMul.hMul (Polynomial.C a) p).roots p.roots","decl":"@[simp]\ntheorem roots_C_mul (p : R[X]) (ha : a ≠ 0) : (C a * p).roots = p.roots := by\n  by_cases hp : p = 0 <;>\n    simp only [roots_mul, *, Ne, mul_eq_zero, C_eq_zero, or_self_iff, not_false_iff, roots_C,\n      zero_add, mul_zero]\n\n"}
{"name":"Polynomial.roots_smul_nonzero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nha : Ne a 0\n⊢ Eq (HSMul.hSMul a p).roots p.roots","decl":"@[simp]\ntheorem roots_smul_nonzero (p : R[X]) (ha : a ≠ 0) : (a • p).roots = p.roots := by\n  rw [smul_eq_C_mul, roots_C_mul _ ha]\n\n"}
{"name":"Polynomial.roots_neg","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ Eq (Neg.neg p).roots p.roots","decl":"@[simp]\nlemma roots_neg (p : R[X]) : (-p).roots = p.roots := by\n  rw [← neg_one_smul R p, roots_smul_nonzero p (neg_ne_zero.mpr one_ne_zero)]\n\n"}
{"name":"Polynomial.roots_C_mul_X_sub_C_of_IsUnit","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nb : R\na : Units R\n⊢ Eq (HSub.hSub (HMul.hMul (Polynomial.C ↑a) Polynomial.X) (Polynomial.C b)).roots (Singleton.singleton (HMul.hMul (↑(Inv.inv a)) b))","decl":"@[simp]\ntheorem roots_C_mul_X_sub_C_of_IsUnit (b : R) (a : Rˣ) : (C (a : R) * X - C b).roots =\n    {a⁻¹ * b} := by\n  rw [← roots_C_mul _ (Units.ne_zero a⁻¹), mul_sub, ← mul_assoc, ← C_mul, ← C_mul,\n    Units.inv_mul, C_1, one_mul]\n  exact roots_X_sub_C (a⁻¹ * b)\n\n"}
{"name":"Polynomial.roots_C_mul_X_add_C_of_IsUnit","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nb : R\na : Units R\n⊢ Eq (HAdd.hAdd (HMul.hMul (Polynomial.C ↑a) Polynomial.X) (Polynomial.C b)).roots (Singleton.singleton (Neg.neg (HMul.hMul (↑(Inv.inv a)) b)))","decl":"@[simp]\ntheorem roots_C_mul_X_add_C_of_IsUnit (b : R) (a : Rˣ) : (C (a : R) * X + C b).roots =\n    {-(a⁻¹ * b)} := by\n  rw [← sub_neg_eq_add, ← C_neg, roots_C_mul_X_sub_C_of_IsUnit, mul_neg]\n\n"}
{"name":"Polynomial.roots_list_prod","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nL : List (Polynomial R)\na✝ : Not (Membership.mem L 0)\n⊢ Eq L.prod.roots ((↑L).bind Polynomial.roots)","decl":"theorem roots_list_prod (L : List R[X]) :\n    (0 : R[X]) ∉ L → L.prod.roots = (L : Multiset R[X]).bind roots :=\n  List.recOn L (fun _ => roots_one) fun hd tl ih H => by\n    rw [List.mem_cons, not_or] at H\n    rw [List.prod_cons, roots_mul (mul_ne_zero (Ne.symm H.1) <| List.prod_ne_zero H.2), ←\n      Multiset.cons_coe, Multiset.cons_bind, ih H.2]\n\n"}
{"name":"Polynomial.roots_multiset_prod","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nm : Multiset (Polynomial R)\na✝ : Not (Membership.mem m 0)\n⊢ Eq m.prod.roots (m.bind Polynomial.roots)","decl":"theorem roots_multiset_prod (m : Multiset R[X]) : (0 : R[X]) ∉ m → m.prod.roots = m.bind roots := by\n  rcases m with ⟨L⟩\n  simpa only [Multiset.prod_coe, quot_mk_to_coe''] using roots_list_prod L\n\n"}
{"name":"Polynomial.roots_prod","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nι : Type u_1\nf : ι → Polynomial R\ns : Finset ι\na✝ : Ne (s.prod f) 0\n⊢ Eq (s.prod f).roots (s.val.bind fun i => (f i).roots)","decl":"theorem roots_prod {ι : Type*} (f : ι → R[X]) (s : Finset ι) :\n    s.prod f ≠ 0 → (s.prod f).roots = s.val.bind fun i => roots (f i) := by\n  rcases s with ⟨m, hm⟩\n  simpa [Multiset.prod_eq_zero_iff, Multiset.bind_map] using roots_multiset_prod (m.map f)\n\n"}
{"name":"Polynomial.roots_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nn : Nat\n⊢ Eq (HPow.hPow p n).roots (HSMul.hSMul n p.roots)","decl":"@[simp]\ntheorem roots_pow (p : R[X]) (n : ℕ) : (p ^ n).roots = n • p.roots := by\n  induction n with\n  | zero => rw [pow_zero, roots_one, zero_smul, empty_eq_zero]\n  | succ n ihn =>\n    rcases eq_or_ne p 0 with (rfl | hp)\n    · rw [zero_pow n.succ_ne_zero, roots_zero, smul_zero]\n    · rw [pow_succ, roots_mul (mul_ne_zero (pow_ne_zero _ hp) hp), ihn, add_smul, one_smul]\n\n"}
{"name":"Polynomial.roots_X_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n).roots (HSMul.hSMul n (Singleton.singleton 0))","decl":"theorem roots_X_pow (n : ℕ) : (X ^ n : R[X]).roots = n • ({0} : Multiset R) := by\n  rw [roots_pow, roots_X]\n\n"}
{"name":"Polynomial.roots_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nha : Ne a 0\nn : Nat\n⊢ Eq (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)).roots (HSMul.hSMul n (Singleton.singleton 0))","decl":"theorem roots_C_mul_X_pow (ha : a ≠ 0) (n : ℕ) :\n    Polynomial.roots (C a * X ^ n) = n • ({0} : Multiset R) := by\n  rw [roots_C_mul _ ha, roots_X_pow]\n\n"}
{"name":"Polynomial.roots_monomial","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\na : R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nha : Ne a 0\nn : Nat\n⊢ Eq ((Polynomial.monomial n) a).roots (HSMul.hSMul n (Singleton.singleton 0))","decl":"@[simp]\ntheorem roots_monomial (ha : a ≠ 0) (n : ℕ) : (monomial n a).roots = n • ({0} : Multiset R) := by\n  rw [← C_mul_X_pow_eq_monomial, roots_C_mul_X_pow ha]\n\n"}
{"name":"Polynomial.roots_prod_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\ns : Finset R\n⊢ Eq (s.prod fun a => HSub.hSub Polynomial.X (Polynomial.C a)).roots s.val","decl":"theorem roots_prod_X_sub_C (s : Finset R) : (s.prod fun a => X - C a).roots = s.val := by\n  apply (roots_prod (fun a => X - C a) s ?_).trans\n  · simp_rw [roots_X_sub_C]\n    rw [Multiset.bind_singleton, Multiset.map_id']\n  · refine prod_ne_zero_iff.mpr (fun a _ => X_sub_C_ne_zero a)\n\n"}
{"name":"Polynomial.roots_multiset_prod_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\ns : Multiset R\n⊢ Eq (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) s).prod.roots s","decl":"@[simp]\ntheorem roots_multiset_prod_X_sub_C (s : Multiset R) : (s.map fun a => X - C a).prod.roots = s := by\n  rw [roots_multiset_prod, Multiset.bind_map]\n  · simp_rw [roots_X_sub_C]\n    rw [Multiset.bind_singleton, Multiset.map_id']\n  · rw [Multiset.mem_map]\n    rintro ⟨a, -, h⟩\n    exact X_sub_C_ne_zero a h\n\n"}
{"name":"Polynomial.card_roots_X_pow_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nhn : LT.lt 0 n\na : R\n⊢ LE.le (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a)).roots.card n","decl":"theorem card_roots_X_pow_sub_C {n : ℕ} (hn : 0 < n) (a : R) :\n    Multiset.card (roots ((X : R[X]) ^ n - C a)) ≤ n :=\n  WithBot.coe_le_coe.1 <|\n    calc\n      (Multiset.card (roots ((X : R[X]) ^ n - C a)) : WithBot ℕ) ≤ degree ((X : R[X]) ^ n - C a) :=\n        card_roots (X_pow_sub_C_ne_zero hn a)\n      _ = n := degree_X_pow_sub_C hn a\n\n"}
{"name":"Polynomial.mem_nthRoots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nhn : LT.lt 0 n\na x : R\n⊢ Iff (Membership.mem (Polynomial.nthRoots n a) x) (Eq (HPow.hPow x n) a)","decl":"@[simp]\ntheorem mem_nthRoots {n : ℕ} (hn : 0 < n) {a x : R} : x ∈ nthRoots n a ↔ x ^ n = a := by\n  rw [nthRoots, mem_roots (X_pow_sub_C_ne_zero hn a), IsRoot.def, eval_sub, eval_C, eval_pow,\n    eval_X, sub_eq_zero]\n\n"}
{"name":"Polynomial.nthRoots_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Eq (Polynomial.nthRoots 0 r) 0","decl":"@[simp]\ntheorem nthRoots_zero (r : R) : nthRoots 0 r = 0 := by\n  simp only [empty_eq_zero, pow_zero, nthRoots, ← C_1, ← C_sub, roots_C]\n\n"}
{"name":"Polynomial.nthRoots_zero_right","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\n⊢ Eq (Polynomial.nthRoots n 0) (Multiset.replicate n 0)","decl":"@[simp]\ntheorem nthRoots_zero_right {R} [CommRing R] [IsDomain R] (n : ℕ) :\n    nthRoots n (0 : R) = Multiset.replicate n 0 := by\n  rw [nthRoots, C.map_zero, sub_zero, roots_pow, roots_X, Multiset.nsmul_singleton]\n\n"}
{"name":"Polynomial.card_nthRoots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\na : R\n⊢ LE.le (Polynomial.nthRoots n a).card n","decl":"theorem card_nthRoots (n : ℕ) (a : R) : Multiset.card (nthRoots n a) ≤ n := by\n  classical exact\n  (if hn : n = 0 then\n    if h : (X : R[X]) ^ n - C a = 0 then by\n      simp [Nat.zero_le, nthRoots, roots, h, dif_pos rfl, empty_eq_zero, Multiset.card_zero]\n    else\n      WithBot.coe_le_coe.1\n        (le_trans (card_roots h)\n          (by\n            rw [hn, pow_zero, ← C_1, ← RingHom.map_sub]\n            exact degree_C_le))\n  else by\n    rw [← Nat.cast_le (α := WithBot ℕ)]\n    rw [← degree_X_pow_sub_C (Nat.pos_of_ne_zero hn) a]\n    exact card_roots (X_pow_sub_C_ne_zero (Nat.pos_of_ne_zero hn) a))\n\n"}
{"name":"Polynomial.nthRoots_two_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Iff (Eq (Polynomial.nthRoots 2 r) 0) (Not (IsSquare r))","decl":"@[simp]\ntheorem nthRoots_two_eq_zero_iff {r : R} : nthRoots 2 r = 0 ↔ ¬IsSquare r := by\n  simp_rw [isSquare_iff_exists_sq, eq_zero_iff_forall_not_mem, mem_nthRoots (by norm_num : 0 < 2),\n    ← not_exists, eq_comm]\n\n"}
{"name":"Polynomial.nthRootsFinset_def","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"n : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\n⊢ Eq (Polynomial.nthRootsFinset n R) (Polynomial.nthRoots n 1).toFinset","decl":"lemma nthRootsFinset_def (n : ℕ) (R : Type*) [CommRing R] [IsDomain R] [DecidableEq R] :\n    nthRootsFinset n R = Multiset.toFinset (nthRoots n (1 : R)) := by\n  unfold nthRootsFinset\n  convert rfl\n\n"}
{"name":"Polynomial.mem_nthRootsFinset","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nh : LT.lt 0 n\nx : R\n⊢ Iff (Membership.mem (Polynomial.nthRootsFinset n R) x) (Eq (HPow.hPow x n) 1)","decl":"@[simp]\ntheorem mem_nthRootsFinset {n : ℕ} (h : 0 < n) {x : R} :\n    x ∈ nthRootsFinset n R ↔ x ^ (n : ℕ) = 1 := by\n  classical\n  rw [nthRootsFinset_def, mem_toFinset, mem_nthRoots h]\n\n"}
{"name":"Polynomial.nthRootsFinset_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (Polynomial.nthRootsFinset 0 R) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem nthRootsFinset_zero : nthRootsFinset 0 R = ∅ := by classical simp [nthRootsFinset_def]\n\n"}
{"name":"Polynomial.map_mem_nthRootsFinset","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nn : Nat\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\nS : Type u_1\nF : Type u_2\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nx : R\nhx : Membership.mem (Polynomial.nthRootsFinset n R) x\nf : F\n⊢ Membership.mem (Polynomial.nthRootsFinset n S) (f x)","decl":"theorem map_mem_nthRootsFinset {S F : Type*} [CommRing S] [IsDomain S] [FunLike F R S]\n    [RingHomClass F R S] {x : R} (hx : x ∈ nthRootsFinset n R) (f : F) :\n    f x ∈ nthRootsFinset n S := by\n  by_cases hn : n = 0\n  · simp [hn] at hx\n  · rw [mem_nthRootsFinset <| Nat.pos_of_ne_zero hn, ← map_pow, (mem_nthRootsFinset <|\n      Nat.pos_of_ne_zero hn).1 hx, map_one]\n\n"}
{"name":"Polynomial.mul_mem_nthRootsFinset","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nn : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nη₁ η₂ : R\nhη₁ : Membership.mem (Polynomial.nthRootsFinset n R) η₁\nhη₂ : Membership.mem (Polynomial.nthRootsFinset n R) η₂\n⊢ Membership.mem (Polynomial.nthRootsFinset n R) (HMul.hMul η₁ η₂)","decl":"theorem mul_mem_nthRootsFinset\n    {η₁ η₂ : R} (hη₁ : η₁ ∈ nthRootsFinset n R) (hη₂ : η₂ ∈ nthRootsFinset n R) :\n    η₁ * η₂ ∈ nthRootsFinset n R := by\n  cases n with\n  | zero =>\n    simp only [nthRootsFinset_zero, not_mem_empty] at hη₁\n  | succ n =>\n    rw [mem_nthRootsFinset n.succ_pos] at hη₁ hη₂ ⊢\n    rw [mul_pow, hη₁, hη₂, one_mul]\n\n"}
{"name":"Polynomial.ne_zero_of_mem_nthRootsFinset","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nn : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nη : R\nhη : Membership.mem (Polynomial.nthRootsFinset n R) η\n⊢ Ne η 0","decl":"theorem ne_zero_of_mem_nthRootsFinset {η : R} (hη : η ∈ nthRootsFinset n R) : η ≠ 0 := by\n  nontriviality R\n  rintro rfl\n  cases n with\n  | zero =>\n    simp only [nthRootsFinset_zero, not_mem_empty] at hη\n  | succ n =>\n    rw [mem_nthRootsFinset n.succ_pos, zero_pow n.succ_ne_zero] at hη\n    exact zero_ne_one hη\n\n"}
{"name":"Polynomial.one_mem_nthRootsFinset","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nn : Nat\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nhn : LT.lt 0 n\n⊢ Membership.mem (Polynomial.nthRootsFinset n R) 1","decl":"theorem one_mem_nthRootsFinset (hn : 0 < n) : 1 ∈ nthRootsFinset n R := by\n  rw [mem_nthRootsFinset hn, one_pow]\n\n"}
{"name":"Polynomial.zero_of_eval_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Infinite R\np : Polynomial R\nh : ∀ (x : R), Eq (Polynomial.eval x p) 0\n⊢ Eq p 0","decl":"theorem zero_of_eval_zero [Infinite R] (p : R[X]) (h : ∀ x, p.eval x = 0) : p = 0 := by\n  classical\n  by_contra hp\n  refine @Fintype.false R _ ?_\n  exact ⟨p.roots.toFinset, fun x => Multiset.mem_toFinset.mpr ((mem_roots hp).mpr (h _))⟩\n\n"}
{"name":"Polynomial.funext","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Infinite R\np q : Polynomial R\next : ∀ (r : R), Eq (Polynomial.eval r p) (Polynomial.eval r q)\n⊢ Eq p q","decl":"theorem funext [Infinite R] {p q : R[X]} (ext : ∀ r : R, p.eval r = q.eval r) : p = q := by\n  rw [← sub_eq_zero]\n  apply zero_of_eval_zero\n  intro x\n  rw [eval_sub, sub_eq_zero, ext]\n\n"}
{"name":"Polynomial.aroots_def","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (p.aroots S) (Polynomial.map (algebraMap T S) p).roots","decl":"theorem aroots_def (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] :\n    p.aroots S = (p.map (algebraMap T S)).roots :=\n  rfl\n\n"}
{"name":"Polynomial.mem_aroots'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\np : Polynomial T\na : S\n⊢ Iff (Membership.mem (p.aroots S) a) (And (Ne (Polynomial.map (algebraMap T S) p) 0) (Eq ((Polynomial.aeval a) p) 0))","decl":"theorem mem_aroots' [CommRing S] [IsDomain S] [Algebra T S] {p : T[X]} {a : S} :\n    a ∈ p.aroots S ↔ p.map (algebraMap T S) ≠ 0 ∧ aeval a p = 0 := by\n  rw [mem_roots', IsRoot.def, ← eval₂_eq_eval_map, aeval_def]\n\n"}
{"name":"Polynomial.mem_aroots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\np : Polynomial T\na : S\n⊢ Iff (Membership.mem (p.aroots S) a) (And (Ne p 0) (Eq ((Polynomial.aeval a) p) 0))","decl":"theorem mem_aroots [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {p : T[X]} {a : S} : a ∈ p.aroots S ↔ p ≠ 0 ∧ aeval a p = 0 := by\n  rw [mem_aroots', Polynomial.map_ne_zero_iff]\n  exact NoZeroSMulDivisors.algebraMap_injective T S\n\n"}
{"name":"Polynomial.aroots_mul","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\np q : Polynomial T\nhpq : Ne (HMul.hMul p q) 0\n⊢ Eq ((HMul.hMul p q).aroots S) (HAdd.hAdd (p.aroots S) (q.aroots S))","decl":"theorem aroots_mul [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {p q : T[X]} (hpq : p * q ≠ 0) :\n    (p * q).aroots S = p.aroots S + q.aroots S := by\n  suffices map (algebraMap T S) p * map (algebraMap T S) q ≠ 0 by\n    rw [aroots_def, Polynomial.map_mul, roots_mul this]\n  rwa [← Polynomial.map_mul, Polynomial.map_ne_zero_iff\n    (NoZeroSMulDivisors.algebraMap_injective T S)]\n\n"}
{"name":"Polynomial.aroots_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\nr : T\n⊢ Eq ((HSub.hSub Polynomial.X (Polynomial.C r)).aroots S) (Singleton.singleton ((algebraMap T S) r))","decl":"@[simp]\ntheorem aroots_X_sub_C [CommRing S] [IsDomain S] [Algebra T S]\n    (r : T) : aroots (X - C r) S = {algebraMap T S r} := by\n  rw [aroots_def, Polynomial.map_sub, map_X, map_C, roots_X_sub_C]\n\n"}
{"name":"Polynomial.aroots_X","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (Polynomial.X.aroots S) (Singleton.singleton 0)","decl":"@[simp]\ntheorem aroots_X [CommRing S] [IsDomain S] [Algebra T S] :\n    aroots (X : T[X]) S = {0} := by\n  rw [aroots_def, map_X, roots_X]\n\n"}
{"name":"Polynomial.aroots_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\na : T\n⊢ Eq ((Polynomial.C a).aroots S) 0","decl":"@[simp]\ntheorem aroots_C [CommRing S] [IsDomain S] [Algebra T S] (a : T) : (C a).aroots S = 0 := by\n  rw [aroots_def, map_C, roots_C]\n\n"}
{"name":"Polynomial.aroots_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (Polynomial.aroots 0 S) 0","decl":"@[simp]\ntheorem aroots_zero (S) [CommRing S] [IsDomain S] [Algebra T S] : (0 : T[X]).aroots S = 0 := by\n  rw [← C_0, aroots_C]\n\n"}
{"name":"Polynomial.aroots_one","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (Polynomial.aroots 1 S) 0","decl":"@[simp]\ntheorem aroots_one [CommRing S] [IsDomain S] [Algebra T S] :\n    (1 : T[X]).aroots S = 0 :=\n  aroots_C 1\n\n"}
{"name":"Polynomial.aroots_neg","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\np : Polynomial T\n⊢ Eq ((Neg.neg p).aroots S) (p.aroots S)","decl":"@[simp]\ntheorem aroots_neg [CommRing S] [IsDomain S] [Algebra T S] (p : T[X]) :\n    (-p).aroots S = p.aroots S := by\n  rw [aroots, Polynomial.map_neg, roots_neg]\n\n"}
{"name":"Polynomial.aroots_C_mul","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\na : T\np : Polynomial T\nha : Ne a 0\n⊢ Eq ((HMul.hMul (Polynomial.C a) p).aroots S) (p.aroots S)","decl":"@[simp]\ntheorem aroots_C_mul [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (p : T[X]) (ha : a ≠ 0) :\n    (C a * p).aroots S = p.aroots S := by\n  rw [aroots_def, Polynomial.map_mul, map_C, roots_C_mul]\n  rwa [map_ne_zero_iff]\n  exact NoZeroSMulDivisors.algebraMap_injective T S\n\n"}
{"name":"Polynomial.aroots_smul_nonzero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\na : T\np : Polynomial T\nha : Ne a 0\n⊢ Eq ((HSMul.hSMul a p).aroots S) (p.aroots S)","decl":"@[simp]\ntheorem aroots_smul_nonzero [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (p : T[X]) (ha : a ≠ 0) :\n    (a • p).aroots S = p.aroots S := by\n  rw [smul_eq_C_mul, aroots_C_mul _ ha]\n\n"}
{"name":"Polynomial.aroots_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\np : Polynomial T\nn : Nat\n⊢ Eq ((HPow.hPow p n).aroots S) (HSMul.hSMul n (p.aroots S))","decl":"@[simp]\ntheorem aroots_pow [CommRing S] [IsDomain S] [Algebra T S] (p : T[X]) (n : ℕ) :\n    (p ^ n).aroots S = n • p.aroots S := by\n  rw [aroots_def, Polynomial.map_pow, roots_pow]\n\n"}
{"name":"Polynomial.aroots_X_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\nn : Nat\n⊢ Eq ((HPow.hPow Polynomial.X n).aroots S) (HSMul.hSMul n (Singleton.singleton 0))","decl":"theorem aroots_X_pow [CommRing S] [IsDomain S] [Algebra T S] (n : ℕ) :\n    (X ^ n : T[X]).aroots S = n • ({0} : Multiset S) := by\n  rw [aroots_pow, aroots_X]\n\n"}
{"name":"Polynomial.aroots_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\na : T\nha : Ne a 0\nn : Nat\n⊢ Eq ((HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)).aroots S) (HSMul.hSMul n (Singleton.singleton 0))","decl":"theorem aroots_C_mul_X_pow [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (ha : a ≠ 0) (n : ℕ) :\n    (C a * X ^ n : T[X]).aroots S = n • ({0} : Multiset S) := by\n  rw [aroots_C_mul _ ha, aroots_X_pow]\n\n"}
{"name":"Polynomial.aroots_monomial","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝⁴ : CommRing T\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\na : T\nha : Ne a 0\nn : Nat\n⊢ Eq (((Polynomial.monomial n) a).aroots S) (HSMul.hSMul n (Singleton.singleton 0))","decl":"@[simp]\ntheorem aroots_monomial [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (ha : a ≠ 0) (n : ℕ) :\n    (monomial n a).aroots S = n • ({0} : Multiset S) := by\n  rw [← C_mul_X_pow_eq_monomial, aroots_C_mul_X_pow ha]\n\n"}
{"name":"Polynomial.aroots_map","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : IsDomain R\ninst✝⁵ : CommRing T\np : Polynomial T\ninst✝⁴ : CommRing S\ninst✝³ : Algebra T S\ninst✝² : Algebra S R\ninst✝¹ : Algebra T R\ninst✝ : IsScalarTower T S R\n⊢ Eq ((Polynomial.map (algebraMap T S) p).aroots R) (p.aroots R)","decl":"variable (R S) in\n@[simp]\ntheorem aroots_map (p : T[X]) [CommRing S] [Algebra T S] [Algebra S R] [Algebra T R]\n    [IsScalarTower T S R] :\n    (p.map (algebraMap T S)).aroots R = p.aroots R := by\n  rw [aroots_def, aroots_def, map_map, IsScalarTower.algebraMap_eq T S R]\n\n"}
{"name":"Polynomial.rootSet_def","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝⁴ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : DecidableEq S\n⊢ Eq (p.rootSet S) ↑(p.aroots S).toFinset","decl":"theorem rootSet_def (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] [DecidableEq S] :\n    p.rootSet S = (p.aroots S).toFinset := by\n  rw [rootSet]\n  convert rfl\n\n"}
{"name":"Polynomial.rootSet_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\na : T\n⊢ Eq ((Polynomial.C a).rootSet S) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem rootSet_C [CommRing S] [IsDomain S] [Algebra T S] (a : T) : (C a).rootSet S = ∅ := by\n  classical\n  rw [rootSet_def, aroots_C, Multiset.toFinset_zero, Finset.coe_empty]\n\n"}
{"name":"Polynomial.rootSet_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (Polynomial.rootSet 0 S) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem rootSet_zero (S) [CommRing S] [IsDomain S] [Algebra T S] : (0 : T[X]).rootSet S = ∅ := by\n  rw [← C_0, rootSet_C]\n\n"}
{"name":"Polynomial.rootSet_one","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq (Polynomial.rootSet 1 S) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem rootSet_one (S) [CommRing S] [IsDomain S] [Algebra T S] : (1 : T[X]).rootSet S = ∅ := by\n  rw [← C_1, rootSet_C]\n\n"}
{"name":"Polynomial.rootSet_neg","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ Eq ((Neg.neg p).rootSet S) (p.rootSet S)","decl":"@[simp]\ntheorem rootSet_neg (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] :\n    (-p).rootSet S = p.rootSet S := by\n  rw [rootSet, aroots_neg, rootSet]\n\n"}
{"name":"Polynomial.rootSet_finite","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\n⊢ (p.rootSet S).Finite","decl":"theorem rootSet_finite (p : T[X]) (S : Type*) [CommRing S] [IsDomain S] [Algebra T S] :\n    (p.rootSet S).Finite :=\n  Set.toFinite _\n\n"}
{"name":"Polynomial.bUnion_roots_finite","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : DecidableEq S\nm : RingHom R S\nd : Nat\nU : Set R\nh : U.Finite\n⊢ (Set.iUnion fun f => Set.iUnion fun x => ↑(Polynomial.map m f).roots.toFinset).Finite","decl":"/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. -/\ntheorem bUnion_roots_finite {R S : Type*} [Semiring R] [CommRing S] [IsDomain S] [DecidableEq S]\n    (m : R →+* S) (d : ℕ) {U : Set R} (h : U.Finite) :\n    (⋃ (f : R[X]) (_ : f.natDegree ≤ d ∧ ∀ i, f.coeff i ∈ U),\n        ((f.map m).roots.toFinset.toSet : Set S)).Finite :=\n  Set.Finite.biUnion\n    (by\n      -- We prove that the set of polynomials under consideration is finite because its\n      -- image by the injective map `π` is finite\n      let π : R[X] → Fin (d + 1) → R := fun f i => f.coeff i\n      refine ((Set.Finite.pi fun _ => h).subset <| ?_).of_finite_image (?_ : Set.InjOn π _)\n      · exact Set.image_subset_iff.2 fun f hf i _ => hf.2 i\n      · refine fun x hx y hy hxy => (ext_iff_natDegree_le hx.1 hy.1).2 fun i hi => ?_\n        exact id congr_fun hxy ⟨i, Nat.lt_succ_of_le hi⟩)\n    fun _ _ => Finset.finite_toSet _\n\n"}
{"name":"Polynomial.mem_rootSet'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝³ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\na : S\n⊢ Iff (Membership.mem (p.rootSet S) a) (And (Ne (Polynomial.map (algebraMap T S) p) 0) (Eq ((Polynomial.aeval a) p) 0))","decl":"theorem mem_rootSet' {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S] {a : S} :\n    a ∈ p.rootSet S ↔ p.map (algebraMap T S) ≠ 0 ∧ aeval a p = 0 := by\n  classical\n  rw [rootSet_def, Finset.mem_coe, mem_toFinset, mem_aroots']\n\n"}
{"name":"Polynomial.mem_rootSet","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝⁴ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\na : S\n⊢ Iff (Membership.mem (p.rootSet S) a) (And (Ne p 0) (Eq ((Polynomial.aeval a) p) 0))","decl":"theorem mem_rootSet {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : S} : a ∈ p.rootSet S ↔ p ≠ 0 ∧ aeval a p = 0 := by\n  rw [mem_rootSet', Polynomial.map_ne_zero_iff (NoZeroSMulDivisors.algebraMap_injective T S)]\n\n"}
{"name":"Polynomial.mem_rootSet_of_ne","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝⁴ : CommRing T\np : Polynomial T\nS : Type u_1\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra T S\ninst✝ : NoZeroSMulDivisors T S\nhp : Ne p 0\na : S\n⊢ Iff (Membership.mem (p.rootSet S) a) (Eq ((Polynomial.aeval a) p) 0)","decl":"theorem mem_rootSet_of_ne {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] (hp : p ≠ 0) {a : S} : a ∈ p.rootSet S ↔ aeval a p = 0 :=\n  mem_rootSet.trans <| and_iff_right hp\n\n"}
{"name":"Polynomial.rootSet_maps_to'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝⁶ : CommRing T\np : Polynomial T\nS : Type u_1\nS' : Type u_2\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain S\ninst✝³ : Algebra T S\ninst✝² : CommRing S'\ninst✝¹ : IsDomain S'\ninst✝ : Algebra T S'\nhp : Eq (Polynomial.map (algebraMap T S') p) 0 → Eq (Polynomial.map (algebraMap T S) p) 0\nf : AlgHom T S S'\n⊢ Set.MapsTo (⇑f) (p.rootSet S) (p.rootSet S')","decl":"theorem rootSet_maps_to' {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']\n    [IsDomain S'] [Algebra T S'] (hp : p.map (algebraMap T S') = 0 → p.map (algebraMap T S) = 0)\n    (f : S →ₐ[T] S') : (p.rootSet S).MapsTo f (p.rootSet S') := fun x hx => by\n  rw [mem_rootSet'] at hx ⊢\n  rw [aeval_algHom, AlgHom.comp_apply, hx.2, _root_.map_zero]\n  exact ⟨mt hp hx.1, rfl⟩\n\n"}
{"name":"Polynomial.ne_zero_of_mem_rootSet","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\np : Polynomial T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\na : S\nh : Membership.mem (p.rootSet S) a\n⊢ Ne p 0","decl":"theorem ne_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}\n    (h : a ∈ p.rootSet S) : p ≠ 0 := fun hf => by rwa [hf, rootSet_zero] at h\n\n"}
{"name":"Polynomial.aeval_eq_zero_of_mem_rootSet","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"S : Type v\nT : Type w\ninst✝³ : CommRing T\np : Polynomial T\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra T S\na : S\nhx : Membership.mem (p.rootSet S) a\n⊢ Eq ((Polynomial.aeval a) p) 0","decl":"theorem aeval_eq_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}\n    (hx : a ∈ p.rootSet S) : aeval a p = 0 :=\n  (mem_rootSet'.1 hx).2\n\n"}
{"name":"Polynomial.rootSet_mapsTo","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"T : Type w\ninst✝⁷ : CommRing T\np : Polynomial T\nS : Type u_1\nS' : Type u_2\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra T S\ninst✝³ : CommRing S'\ninst✝² : IsDomain S'\ninst✝¹ : Algebra T S'\ninst✝ : NoZeroSMulDivisors T S'\nf : AlgHom T S S'\n⊢ Set.MapsTo (⇑f) (p.rootSet S) (p.rootSet S')","decl":"theorem rootSet_mapsTo {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']\n    [IsDomain S'] [Algebra T S'] [NoZeroSMulDivisors T S'] (f : S →ₐ[T] S') :\n    (p.rootSet S).MapsTo f (p.rootSet S') := by\n  refine rootSet_maps_to' (fun h₀ => ?_) f\n  obtain rfl : p = 0 :=\n    map_injective _ (NoZeroSMulDivisors.algebraMap_injective T S') (by rwa [Polynomial.map_zero])\n  exact Polynomial.map_zero _\n\n"}
{"name":"Polynomial.mem_rootSet_of_injective","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : CommRing S\np : Polynomial S\ninst✝ : Algebra S R\nh : Function.Injective ⇑(algebraMap S R)\nx : R\nhp : Ne p 0\n⊢ Iff (Membership.mem (p.rootSet R) x) (Eq ((Polynomial.aeval x) p) 0)","decl":"theorem mem_rootSet_of_injective [CommRing S] {p : S[X]} [Algebra S R]\n    (h : Function.Injective (algebraMap S R)) {x : R} (hp : p ≠ 0) :\n    x ∈ p.rootSet R ↔ aeval x p = 0 := by\n  classical\n  exact Multiset.mem_toFinset.trans (mem_roots_map_of_injective h hp)\n\n"}
{"name":"Polynomial.eq_zero_of_natDegree_lt_card_of_eval_eq_zero","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Polynomial R\nι : Type u_2\ninst✝ : Fintype ι\nf : ι → R\nhf : Function.Injective f\nheval : ∀ (i : ι), Eq (Polynomial.eval (f i) p) 0\nhcard : LT.lt p.natDegree (Fintype.card ι)\n⊢ Eq p 0","decl":"lemma eq_zero_of_natDegree_lt_card_of_eval_eq_zero {R} [CommRing R] [IsDomain R]\n    (p : R[X]) {ι} [Fintype ι] {f : ι → R} (hf : Function.Injective f)\n    (heval : ∀ i, p.eval (f i) = 0) (hcard : natDegree p < Fintype.card ι) : p = 0 := by\n  classical\n  by_contra hp\n  refine lt_irrefl #p.roots.toFinset ?_\n  calc\n    #p.roots.toFinset ≤ Multiset.card p.roots := Multiset.toFinset_card_le _\n    _ ≤ natDegree p := Polynomial.card_roots' p\n    _ < Fintype.card ι := hcard\n    _ = Fintype.card (Set.range f) := (Set.card_range_of_injective hf).symm\n    _ = #(Finset.univ.image f) := by rw [← Set.toFinset_card, Set.toFinset_range]\n    _ ≤ #p.roots.toFinset := Finset.card_mono ?_\n  intro _\n  simp only [Finset.mem_image, Finset.mem_univ, true_and, Multiset.mem_toFinset, mem_roots', ne_eq,\n    IsRoot.def, forall_exists_index, hp, not_false_eq_true]\n  rintro x rfl\n  exact heval _\n\n"}
{"name":"Polynomial.eq_zero_of_natDegree_lt_card_of_eval_eq_zero'","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\ns : Finset R\nheval : ∀ (i : R), Membership.mem s i → Eq (Polynomial.eval i p) 0\nhcard : LT.lt p.natDegree s.card\n⊢ Eq p 0","decl":"lemma eq_zero_of_natDegree_lt_card_of_eval_eq_zero' {R} [CommRing R] [IsDomain R]\n    (p : R[X]) (s : Finset R) (heval : ∀ i ∈ s, p.eval i = 0) (hcard : natDegree p < #s) :\n    p = 0 :=\n  eq_zero_of_natDegree_lt_card_of_eval_eq_zero p Subtype.val_injective\n    (fun i : s ↦ heval i i.prop) (hcard.trans_eq (Fintype.card_coe s).symm)\n\n"}
{"name":"Polynomial.eq_zero_of_forall_eval_zero_of_natDegree_lt_card","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf : Polynomial R\nhf : ∀ (r : R), Eq (Polynomial.eval r f) 0\nhfR : LT.lt (↑f.natDegree) (Cardinal.mk R)\n⊢ Eq f 0","decl":"open Cardinal in\nlemma eq_zero_of_forall_eval_zero_of_natDegree_lt_card\n    (f : R[X]) (hf : ∀ r, f.eval r = 0) (hfR : f.natDegree < #R) : f = 0 := by\n  obtain hR|hR := finite_or_infinite R\n  · have := Fintype.ofFinite R\n    apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero f Function.injective_id hf\n    simpa only [mk_fintype, Nat.cast_lt] using hfR\n  · exact zero_of_eval_zero _ hf\n\n"}
{"name":"Polynomial.exists_eval_ne_zero_of_natDegree_lt_card","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf : Polynomial R\nhf : Ne f 0\nhfR : LT.lt (↑f.natDegree) (Cardinal.mk R)\n⊢ Exists fun r => Ne (Polynomial.eval r f) 0","decl":"open Cardinal in\nlemma exists_eval_ne_zero_of_natDegree_lt_card (f : R[X]) (hf : f ≠ 0) (hfR : f.natDegree < #R) :\n    ∃ r, f.eval r ≠ 0 := by\n  contrapose! hf\n  exact eq_zero_of_forall_eval_zero_of_natDegree_lt_card f hf hfR\n\n"}
{"name":"Polynomial.monic_prod_multiset_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod.Monic","decl":"theorem monic_prod_multiset_X_sub_C : Monic (p.roots.map fun a => X - C a).prod :=\n  monic_multiset_prod_of_monic _ _ fun a _ => monic_X_sub_C a\n\n"}
{"name":"Polynomial.prod_multiset_root_eq_finset_root","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Polynomial R\ninst✝ : DecidableEq R\n⊢ Eq (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod (p.roots.toFinset.prod fun a => HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p))","decl":"theorem prod_multiset_root_eq_finset_root [DecidableEq R] :\n    (p.roots.map fun a => X - C a).prod =\n      p.roots.toFinset.prod fun a => (X - C a) ^ rootMultiplicity a p := by\n  simp only [count_roots, Finset.prod_multiset_map_count]\n\n"}
{"name":"Polynomial.prod_multiset_X_sub_C_dvd","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ Dvd.dvd (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod p","decl":"/-- The product `∏ (X - a)` for `a` inside the multiset `p.roots` divides `p`. -/\ntheorem prod_multiset_X_sub_C_dvd (p : R[X]) : (p.roots.map fun a => X - C a).prod ∣ p := by\n  classical\n  rw [← map_dvd_map _ (IsFractionRing.injective R <| FractionRing R) monic_prod_multiset_X_sub_C]\n  rw [prod_multiset_root_eq_finset_root, Polynomial.map_prod]\n  refine Finset.prod_dvd_of_coprime (fun a _ b _ h => ?_) fun a _ => ?_\n  · simp_rw [Polynomial.map_pow, Polynomial.map_sub, map_C, map_X]\n    exact (pairwise_coprime_X_sub_C (IsFractionRing.injective R <| FractionRing R) h).pow\n  · exact Polynomial.map_dvd _ (pow_rootMultiplicity_dvd p a)\n\n"}
{"name":"Multiset.prod_X_sub_C_dvd_iff_le_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp : Ne p 0\ns : Multiset R\n⊢ Iff (Dvd.dvd (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) s).prod p) (LE.le s p.roots)","decl":"/-- A Galois connection. -/\ntheorem _root_.Multiset.prod_X_sub_C_dvd_iff_le_roots {p : R[X]} (hp : p ≠ 0) (s : Multiset R) :\n    (s.map fun a => X - C a).prod ∣ p ↔ s ≤ p.roots := by\n  classical exact\n  ⟨fun h =>\n    Multiset.le_iff_count.2 fun r => by\n      rw [count_roots, le_rootMultiplicity_iff hp, ← Multiset.prod_replicate, ←\n        Multiset.map_replicate fun a => X - C a, ← Multiset.filter_eq]\n      exact (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| s.filter_le _).trans h,\n    fun h =>\n    (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map h).trans p.prod_multiset_X_sub_C_dvd⟩\n\n"}
{"name":"Polynomial.exists_prod_multiset_X_sub_C_mul","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\n⊢ Exists fun q => And (Eq (HMul.hMul (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod q) p) (And (Eq (HAdd.hAdd p.roots.card q.natDegree) p.natDegree) (Eq q.roots 0))","decl":"theorem exists_prod_multiset_X_sub_C_mul (p : R[X]) :\n    ∃ q,\n      (p.roots.map fun a => X - C a).prod * q = p ∧\n        Multiset.card p.roots + q.natDegree = p.natDegree ∧ q.roots = 0 := by\n  obtain ⟨q, he⟩ := p.prod_multiset_X_sub_C_dvd\n  use q, he.symm\n  obtain rfl | hq := eq_or_ne q 0\n  · rw [mul_zero] at he\n    subst he\n    simp\n  constructor\n  · conv_rhs => rw [he]\n    rw [monic_prod_multiset_X_sub_C.natDegree_mul' hq, natDegree_multiset_prod_X_sub_C_eq_card]\n  · replace he := congr_arg roots he.symm\n    rw [roots_mul, roots_multiset_prod_X_sub_C] at he\n    exacts [add_right_eq_self.1 he, mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq]\n\n"}
{"name":"Polynomial.C_leadingCoeff_mul_prod_multiset_X_sub_C","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhroots : Eq p.roots.card p.natDegree\n⊢ Eq (HMul.hMul (Polynomial.C p.leadingCoeff) (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod) p","decl":"/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem C_leadingCoeff_mul_prod_multiset_X_sub_C (hroots : Multiset.card p.roots = p.natDegree) :\n    C p.leadingCoeff * (p.roots.map fun a => X - C a).prod = p :=\n  (eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le monic_prod_multiset_X_sub_C\n      p.prod_multiset_X_sub_C_dvd\n      ((natDegree_multiset_prod_X_sub_C_eq_card _).trans hroots).ge).symm\n\n"}
{"name":"Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp : p.Monic\nhroots : Eq p.roots.card p.natDegree\n⊢ Eq (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) p.roots).prod p","decl":"/-- A monic polynomial `p` that has as many roots as its degree\ncan be written `p = ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem prod_multiset_X_sub_C_of_monic_of_roots_card_eq (hp : p.Monic)\n    (hroots : Multiset.card p.roots = p.natDegree) : (p.roots.map fun a => X - C a).prod = p := by\n  convert C_leadingCoeff_mul_prod_multiset_X_sub_C hroots\n  rw [hp.leadingCoeff, C_1, one_mul]\n\n"}
{"name":"Polynomial.Monic.isUnit_leadingCoeff_of_dvd","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\na p : Polynomial R\nhp : p.Monic\nhap : Dvd.dvd a p\n⊢ IsUnit a.leadingCoeff","decl":"theorem Monic.isUnit_leadingCoeff_of_dvd {a p : R[X]} (hp : Monic p) (hap : a ∣ p) :\n    IsUnit a.leadingCoeff :=\n  isUnit_of_dvd_one (by simpa only [hp.leadingCoeff] using leadingCoeff_dvd_leadingCoeff hap)\n\n"}
{"name":"Polynomial.Monic.irreducible_iff_degree_lt","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\np_monic : p.Monic\np_1 : Ne p 1\n⊢ Iff (Irreducible p) (∀ (q : Polynomial R), LE.le q.degree ↑(HDiv.hDiv p.natDegree 2) → Dvd.dvd q p → IsUnit q)","decl":"/-- To check a monic polynomial is irreducible, it suffices to check only for\ndivisors that have smaller degree.\n\nSee also: `Polynomial.Monic.irreducible_iff_natDegree`.\n-/\ntheorem Monic.irreducible_iff_degree_lt {p : R[X]} (p_monic : Monic p) (p_1 : p ≠ 1) :\n    Irreducible p ↔ ∀ q, degree q ≤ ↑(p.natDegree / 2) → q ∣ p → IsUnit q := by\n  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,\n    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]\n  constructor\n  · rintro h q deg_le dvd\n    by_contra q_unit\n    have := degree_pos_of_not_isUnit_of_dvd_monic p_monic q_unit dvd\n    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd\n    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim\n    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]\n    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]\n    · rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]\n  · rintro h q _ deg_pos deg_le dvd\n    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)\n\n"}
{"name":"Polynomial.le_rootMultiplicity_map","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\np : Polynomial A\nf : RingHom A B\nhmap : Ne (Polynomial.map f p) 0\na : A\n⊢ LE.le (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity (f a) (Polynomial.map f p))","decl":"theorem le_rootMultiplicity_map {p : A[X]} {f : A →+* B} (hmap : map f p ≠ 0) (a : A) :\n    rootMultiplicity a p ≤ rootMultiplicity (f a) (p.map f) := by\n  rw [le_rootMultiplicity_iff hmap]\n  refine _root_.trans ?_ ((mapRingHom f).map_dvd (pow_rootMultiplicity_dvd p a))\n  rw [map_pow, map_sub, coe_mapRingHom, map_X, map_C]\n\n"}
{"name":"Polynomial.eq_rootMultiplicity_map","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\np : Polynomial A\nf : RingHom A B\nhf : Function.Injective ⇑f\na : A\n⊢ Eq (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity (f a) (Polynomial.map f p))","decl":"theorem eq_rootMultiplicity_map {p : A[X]} {f : A →+* B} (hf : Function.Injective f) (a : A) :\n    rootMultiplicity a p = rootMultiplicity (f a) (p.map f) := by\n  by_cases hp0 : p = 0; · simp only [hp0, rootMultiplicity_zero, Polynomial.map_zero]\n  apply le_antisymm (le_rootMultiplicity_map ((Polynomial.map_ne_zero_iff hf).mpr hp0) a)\n  rw [le_rootMultiplicity_iff hp0, ← map_dvd_map f hf ((monic_X_sub_C a).pow _),\n    Polynomial.map_pow, Polynomial.map_sub, map_X, map_C]\n  apply pow_rootMultiplicity_dvd\n\n"}
{"name":"Polynomial.count_map_roots","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : DecidableEq B\np : Polynomial A\nf : RingHom A B\nhmap : Ne (Polynomial.map f p) 0\nb : B\n⊢ LE.le (Multiset.count b (Multiset.map (⇑f) p.roots)) (Polynomial.rootMultiplicity b (Polynomial.map f p))","decl":"theorem count_map_roots [IsDomain A] [DecidableEq B] {p : A[X]} {f : A →+* B} (hmap : map f p ≠ 0)\n    (b : B) :\n    (p.roots.map f).count b ≤ rootMultiplicity b (p.map f) := by\n  rw [le_rootMultiplicity_iff hmap, ← Multiset.prod_replicate, ←\n    Multiset.map_replicate fun a => X - C a]\n  rw [← Multiset.filter_eq]\n  refine\n    (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| Multiset.filter_le (Eq b) _).trans ?_\n  convert Polynomial.map_dvd f p.prod_multiset_X_sub_C_dvd\n  simp only [Polynomial.map_multiset_prod, Multiset.map_map]\n  congr; ext1\n  simp only [Function.comp_apply, Polynomial.map_sub, map_X, map_C]\n\n"}
{"name":"Polynomial.count_map_roots_of_injective","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : DecidableEq B\np : Polynomial A\nf : RingHom A B\nhf : Function.Injective ⇑f\nb : B\n⊢ LE.le (Multiset.count b (Multiset.map (⇑f) p.roots)) (Polynomial.rootMultiplicity b (Polynomial.map f p))","decl":"theorem count_map_roots_of_injective [IsDomain A] [DecidableEq B] (p : A[X]) {f : A →+* B}\n    (hf : Function.Injective f) (b : B) :\n    (p.roots.map f).count b ≤ rootMultiplicity b (p.map f) := by\n  by_cases hp0 : p = 0\n  · simp only [hp0, roots_zero, Multiset.map_zero, Multiset.count_zero, Polynomial.map_zero,\n      rootMultiplicity_zero, le_refl]\n  · exact count_map_roots ((Polynomial.map_ne_zero_iff hf).mpr hp0) b\n\n"}
{"name":"Polynomial.map_roots_le","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nh : Ne (Polynomial.map f p) 0\n⊢ LE.le (Multiset.map (⇑f) p.roots) (Polynomial.map f p).roots","decl":"theorem map_roots_le [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B} (h : p.map f ≠ 0) :\n    p.roots.map f ≤ (p.map f).roots := by\n  classical\n  exact Multiset.le_iff_count.2 fun b => by\n    rw [count_roots]\n    apply count_map_roots h\n\n"}
{"name":"Polynomial.map_roots_le_of_injective","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nhf : Function.Injective ⇑f\n⊢ LE.le (Multiset.map (⇑f) p.roots) (Polynomial.map f p).roots","decl":"theorem map_roots_le_of_injective [IsDomain A] [IsDomain B] (p : A[X]) {f : A →+* B}\n    (hf : Function.Injective f) : p.roots.map f ≤ (p.map f).roots := by\n  by_cases hp0 : p = 0\n  · simp only [hp0, roots_zero, Multiset.map_zero, Polynomial.map_zero, le_rfl]\n  exact map_roots_le ((Polynomial.map_ne_zero_iff hf).mpr hp0)\n\n"}
{"name":"Polynomial.card_roots_le_map","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nh : Ne (Polynomial.map f p) 0\n⊢ LE.le p.roots.card (Polynomial.map f p).roots.card","decl":"theorem card_roots_le_map [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B} (h : p.map f ≠ 0) :\n    Multiset.card p.roots ≤ Multiset.card (p.map f).roots := by\n  rw [← p.roots.card_map f]\n  exact Multiset.card_le_card (map_roots_le h)\n\n"}
{"name":"Polynomial.card_roots_le_map_of_injective","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nhf : Function.Injective ⇑f\n⊢ LE.le p.roots.card (Polynomial.map f p).roots.card","decl":"theorem card_roots_le_map_of_injective [IsDomain A] [IsDomain B] {p : A[X]} {f : A →+* B}\n    (hf : Function.Injective f) : Multiset.card p.roots ≤ Multiset.card (p.map f).roots := by\n  by_cases hp0 : p = 0\n  · simp only [hp0, roots_zero, Polynomial.map_zero, Multiset.card_zero, le_rfl]\n  exact card_roots_le_map ((Polynomial.map_ne_zero_iff hf).mpr hp0)\n\n"}
{"name":"Polynomial.roots_map_of_injective_of_card_eq_natDegree","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nhf : Function.Injective ⇑f\nhroots : Eq p.roots.card p.natDegree\n⊢ Eq (Multiset.map (⇑f) p.roots) (Polynomial.map f p).roots","decl":"theorem roots_map_of_injective_of_card_eq_natDegree [IsDomain A] [IsDomain B] {p : A[X]}\n    {f : A →+* B} (hf : Function.Injective f) (hroots : Multiset.card p.roots = p.natDegree) :\n    p.roots.map f = (p.map f).roots := by\n  apply Multiset.eq_of_le_of_card_le (map_roots_le_of_injective p hf)\n  simpa only [Multiset.card_map, hroots] using (card_roots' _).trans natDegree_map_le\n\n"}
{"name":"Polynomial.roots_map_of_map_ne_zero_of_card_eq_natDegree","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nf : RingHom A B\nh : Ne (Polynomial.map f p) 0\nhroots : Eq p.roots.card p.natDegree\n⊢ Eq (Multiset.map (⇑f) p.roots) (Polynomial.map f p).roots","decl":"theorem roots_map_of_map_ne_zero_of_card_eq_natDegree [IsDomain A] [IsDomain B] {p : A[X]}\n    (f : A →+* B) (h : p.map f ≠ 0) (hroots : p.roots.card = p.natDegree) :\n    p.roots.map f = (p.map f).roots :=\n  eq_of_le_of_card_le (map_roots_le h) <| by\n    simpa only [Multiset.card_map, hroots] using (p.map f).card_roots'.trans natDegree_map_le\n\n"}
{"name":"Polynomial.Monic.roots_map_of_card_eq_natDegree","module":"Mathlib.Algebra.Polynomial.Roots","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\np : Polynomial A\nhm : p.Monic\nf : RingHom A B\nhroots : Eq p.roots.card p.natDegree\n⊢ Eq (Multiset.map (⇑f) p.roots) (Polynomial.map f p).roots","decl":"theorem Monic.roots_map_of_card_eq_natDegree [IsDomain A] [IsDomain B] {p : A[X]} (hm : p.Monic)\n    (f : A →+* B) (hroots : p.roots.card = p.natDegree) : p.roots.map f  = (p.map f).roots :=\n  roots_map_of_map_ne_zero_of_card_eq_natDegree f (map_monic_ne_zero hm) hroots\n\n"}
