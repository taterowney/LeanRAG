{"name":"Finset.Colex.toColex.sizeOf_spec","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_3\ninst‚úù : SizeOf Œ±\nofColex : Finset Œ±\n‚ä¢ Eq (SizeOf.sizeOf { ofColex := ofColex }) (HAdd.hAdd 1 (SizeOf.sizeOf ofColex))","decl":"/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (Œ±) where\n  /-- `toColex` is the \"identity\" function between `Finset Œ±` and `Finset.Colex Œ±`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex Œ±` and `Finset Œ±`. -/\n  (ofColex : Finset Œ±)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.toColex.injEq","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_3\nofColex‚úù ofColex : Finset Œ±\n‚ä¢ Eq (Eq { ofColex := ofColex‚úù } { ofColex := ofColex }) (Eq ofColex‚úù ofColex)","decl":"/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (Œ±) where\n  /-- `toColex` is the \"identity\" function between `Finset Œ±` and `Finset.Colex Œ±`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex Œ±` and `Finset Œ±`. -/\n  (ofColex : Finset Œ±)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.toColex.inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_3\nofColex‚úù ofColex : Finset Œ±\nx‚úù : Eq { ofColex := ofColex‚úù } { ofColex := ofColex }\n‚ä¢ Eq ofColex‚úù ofColex","decl":"/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (Œ±) where\n  /-- `toColex` is the \"identity\" function between `Finset Œ±` and `Finset.Colex Œ±`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex Œ±` and `Finset Œ±`. -/\n  (ofColex : Finset Œ±)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.ext","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_3\nx y : Finset.Colex Œ±\nofColex : Eq x.ofColex y.ofColex\n‚ä¢ Eq x y","decl":"/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (Œ±) where\n  /-- `toColex` is the \"identity\" function between `Finset Œ±` and `Finset.Colex Œ±`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex Œ±` and `Finset Œ±`. -/\n  (ofColex : Finset Œ±)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.ext_iff","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_3\nx y : Finset.Colex Œ±\n‚ä¢ Iff (Eq x y) (Eq x.ofColex y.ofColex)","decl":"/-- Type synonym of `Finset Œ±` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (Œ±) where\n  /-- `toColex` is the \"identity\" function between `Finset Œ±` and `Finset.Colex Œ±`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex Œ±` and `Finset Œ±`. -/\n  (ofColex : Finset Œ±)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.toColex_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns : Finset.Colex Œ±\n‚ä¢ Eq { ofColex := s.ofColex } s","decl":"@[simp] lemma toColex_ofColex (s : Colex Œ±) : toColex (ofColex s) = s := rfl\n"}
{"name":"Finset.ofColex_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns : Finset Œ±\n‚ä¢ Eq { ofColex := s }.ofColex s","decl":"lemma ofColex_toColex (s : Finset Œ±) : ofColex (toColex s) = s := rfl\n"}
{"name":"Finset.toColex_inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns t : Finset Œ±\n‚ä¢ Iff (Eq { ofColex := s } { ofColex := t }) (Eq s t)","decl":"lemma toColex_inj {s t : Finset Œ±} : toColex s = toColex t ‚Üî s = t := by simp\n"}
{"name":"Finset.ofColex_inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns t : Finset.Colex Œ±\n‚ä¢ Iff (Eq s.ofColex t.ofColex) (Eq s t)","decl":"@[simp]\nlemma ofColex_inj {s t : Colex Œ±} : ofColex s = ofColex t ‚Üî s = t := by cases s; cases t; simp\n"}
{"name":"Finset.toColex_ne_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns t : Finset Œ±\n‚ä¢ Iff (Ne { ofColex := s } { ofColex := t }) (Ne s t)","decl":"lemma toColex_ne_toColex {s t : Finset Œ±} : toColex s ‚â† toColex t ‚Üî s ‚â† t := by simp\n"}
{"name":"Finset.ofColex_ne_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ns t : Finset.Colex Œ±\n‚ä¢ Iff (Ne s.ofColex t.ofColex) (Ne s t)","decl":"lemma ofColex_ne_ofColex {s t : Colex Œ±} : ofColex s ‚â† ofColex t ‚Üî s ‚â† t := by simp\n\n"}
{"name":"Finset.toColex_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\n‚ä¢ Function.Injective Finset.Colex.toColex","decl":"lemma toColex_injective : Injective (toColex : Finset Œ± ‚Üí Colex Œ±) := fun _ _ ‚Ü¶ toColex_inj.1\n"}
{"name":"Finset.ofColex_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\n‚ä¢ Function.Injective Finset.Colex.ofColex","decl":"lemma ofColex_injective : Injective (ofColex : Colex Œ± ‚Üí Finset Œ±) := fun _ _ ‚Ü¶ ofColex_inj.1\n\n"}
{"name":"Finset.Colex.le_def","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset.Colex Œ±\n‚ä¢ Iff (LE.le s t) (‚àÄ ‚¶Éa : Œ±‚¶Ñ, Membership.mem s.ofColex a ‚Üí Not (Membership.mem t.ofColex a) ‚Üí Exists fun b => And (Membership.mem t.ofColex b) (And (Not (Membership.mem s.ofColex b)) (LE.le a b)))","decl":"lemma le_def {s t : Colex Œ±} :\n    s ‚â§ t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà ofColex s ‚Üí a ‚àâ ofColex t ‚Üí ‚àÉ b, b ‚àà ofColex t ‚àß b ‚àâ ofColex s ‚àß a ‚â§ b :=\n  Iff.rfl\n\n"}
{"name":"Finset.Colex.toColex_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LE.le { ofColex := s } { ofColex := t }) (‚àÄ ‚¶Éa : Œ±‚¶Ñ, Membership.mem s a ‚Üí Not (Membership.mem t a) ‚Üí Exists fun b => And (Membership.mem t b) (And (Not (Membership.mem s b)) (LE.le a b)))","decl":"lemma toColex_le_toColex :\n    toColex s ‚â§ toColex t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí a ‚àâ t ‚Üí ‚àÉ b, b ‚àà t ‚àß b ‚àâ s ‚àß a ‚â§ b := Iff.rfl\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LT.lt { ofColex := s } { ofColex := t }) (And (Ne s t) (‚àÄ ‚¶Éa : Œ±‚¶Ñ, Membership.mem s a ‚Üí Not (Membership.mem t a) ‚Üí Exists fun b => And (Membership.mem t b) (And (Not (Membership.mem s b)) (LE.le a b))))","decl":"lemma toColex_lt_toColex :\n    toColex s < toColex t ‚Üî s ‚â† t ‚àß ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí a ‚àâ t ‚Üí ‚àÉ b, b ‚àà t ‚àß b ‚àâ s ‚àß a ‚â§ b := by\n  simp [lt_iff_le_and_ne, toColex_le_toColex, and_comm]\n\n"}
{"name":"Finset.Colex.toColex_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\n‚ä¢ Monotone Finset.Colex.toColex","decl":"/-- If `s ‚äÜ t`, then `s ‚â§ t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_mono : Monotone (toColex : Finset Œ± ‚Üí Colex Œ±) :=\n  fun _s _t hst _a has hat ‚Ü¶ (hat <| hst has).elim\n\n"}
{"name":"Finset.Colex.toColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\n‚ä¢ StrictMono Finset.Colex.toColex","decl":"/-- If `s ‚äÇ t`, then `s < t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_strictMono : StrictMono (toColex : Finset Œ± ‚Üí Colex Œ±) :=\n  toColex_mono.strictMono_of_injective toColex_injective\n\n"}
{"name":"Finset.Colex.toColex_le_toColex_of_subset","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\nh : HasSubset.Subset s t\n‚ä¢ LE.le { ofColex := s } { ofColex := t }","decl":"/-- If `s ‚äÜ t`, then `s ‚â§ t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_le_toColex_of_subset (h : s ‚äÜ t) : toColex s ‚â§ toColex t := toColex_mono h\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_of_ssubset","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\nh : HasSSubset.SSubset s t\n‚ä¢ LT.lt { ofColex := s } { ofColex := t }","decl":"/-- If `s ‚äÇ t`, then `s < t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_lt_toColex_of_ssubset (h : s ‚äÇ t) : toColex s < toColex t := toColex_strictMono h\n\n"}
{"name":"Finset.Colex.toColex_empty","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\n‚ä¢ Eq { ofColex := EmptyCollection.emptyCollection } Bot.bot","decl":"@[simp] lemma toColex_empty : toColex (‚àÖ : Finset Œ±) = ‚ä• := rfl\n"}
{"name":"Finset.Colex.ofColex_bot","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\n‚ä¢ Eq Bot.bot.ofColex EmptyCollection.emptyCollection","decl":"@[simp] lemma ofColex_bot : ofColex (‚ä• : Colex Œ±) = ‚àÖ := rfl\n\n"}
{"name":"Finset.Colex.forall_le_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\na : Œ±\nhst : LE.le { ofColex := s } { ofColex := t }\nht : ‚àÄ (b : Œ±), Membership.mem t b ‚Üí LE.le b a\nb : Œ±\na‚úù : Membership.mem s b\n‚ä¢ LE.le b a","decl":"/-- If `s ‚â§ t` in colex, and all elements in `t` are small, then all elements in `s` are small. -/\nlemma forall_le_mono (hst : toColex s ‚â§ toColex t) (ht : ‚àÄ b ‚àà t, b ‚â§ a) : ‚àÄ b ‚àà s, b ‚â§ a := by\n  rintro b hb\n  by_cases b ‚àà t\n  ¬∑ exact ht _ ‚Äπ_‚Ä∫\n  ¬∑ obtain ‚ü®c, hct, -, hbc‚ü© := hst hb ‚Äπ_‚Ä∫\n    exact hbc.trans <| ht _ hct\n\n"}
{"name":"Finset.Colex.forall_lt_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset Œ±\na : Œ±\nhst : LE.le { ofColex := s } { ofColex := t }\nht : ‚àÄ (b : Œ±), Membership.mem t b ‚Üí LT.lt b a\nb : Œ±\na‚úù : Membership.mem s b\n‚ä¢ LT.lt b a","decl":"/-- If `s ‚â§ t` in colex, and all elements in `t` are small, then all elements in `s` are small. -/\nlemma forall_lt_mono (hst : toColex s ‚â§ toColex t) (ht : ‚àÄ b ‚àà t, b < a) : ‚àÄ b ‚àà s, b < a := by\n  rintro b hb\n  by_cases b ‚àà t\n  ¬∑ exact ht _ ‚Äπ_‚Ä∫\n  ¬∑ obtain ‚ü®c, hct, -, hbc‚ü© := hst hb ‚Äπ_‚Ä∫\n    exact hbc.trans_lt <| ht _ hct\n\n"}
{"name":"Finset.Colex.toColex_le_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns : Finset Œ±\na : Œ±\n‚ä¢ Iff (LE.le { ofColex := s } { ofColex := Singleton.singleton a }) (‚àÄ (b : Œ±), Membership.mem s b ‚Üí And (LE.le b a) (Membership.mem s a ‚Üí Eq b a))","decl":"/-- `s ‚â§ {a}` in colex iff all elements of `s` are strictly less than `a`, except possibly `a` in\nwhich case `s = {a}`. -/\nlemma toColex_le_singleton : toColex s ‚â§ toColex {a} ‚Üî ‚àÄ b ‚àà s, b ‚â§ a ‚àß (a ‚àà s ‚Üí b = a) := by\n  simp only [toColex_le_toColex, mem_singleton, and_assoc, exists_eq_left]\n  refine forall‚ÇÇ_congr fun b _ ‚Ü¶ ?_; obtain rfl | hba := eq_or_ne b a <;> aesop\n\n"}
{"name":"Finset.Colex.toColex_lt_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns : Finset Œ±\na : Œ±\n‚ä¢ Iff (LT.lt { ofColex := s } { ofColex := Singleton.singleton a }) (‚àÄ (b : Œ±), Membership.mem s b ‚Üí LT.lt b a)","decl":"/-- `s < {a}` in colex iff all elements of `s` are strictly less than `a`. -/\nlemma toColex_lt_singleton : toColex s < toColex {a} ‚Üî ‚àÄ b ‚àà s, b < a := by\n  rw [lt_iff_le_and_ne, toColex_le_singleton, toColex_ne_toColex]\n  refine ‚ü®fun h b hb ‚Ü¶ (h.1 _ hb).1.lt_of_ne ?_,\n    fun h ‚Ü¶ ‚ü®fun b hb ‚Ü¶ ‚ü®(h _ hb).le, fun ha ‚Ü¶ (lt_irrefl _ <| h _ ha).elim‚ü©, ?_‚ü©‚ü© <;> rintro rfl\n  ¬∑ refine h.2 <| eq_singleton_iff_unique_mem.2 ‚ü®hb, fun c hc ‚Ü¶ (h.1 _ hc).2 hb‚ü©\n  ¬∑ simp at h\n\n"}
{"name":"Finset.Colex.singleton_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns : Finset Œ±\na : Œ±\n‚ä¢ Iff (LE.le { ofColex := Singleton.singleton a } { ofColex := s }) (Exists fun x => And (Membership.mem s x) (LE.le a x))","decl":"/-- `{a} ‚â§ s` in colex iff `s` contains an element greater than or equal to `a`. -/\nlemma singleton_le_toColex : (toColex {a} : Colex Œ±) ‚â§ toColex s ‚Üî ‚àÉ x ‚àà s, a ‚â§ x := by\n  simp [toColex_le_toColex]; by_cases a ‚àà s <;> aesop\n\n"}
{"name":"Finset.Colex.singleton_le_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Iff (LE.le { ofColex := Singleton.singleton a } { ofColex := Singleton.singleton b }) (LE.le a b)","decl":"/-- Colex is an extension of the base order. -/\nlemma singleton_le_singleton : (toColex {a} : Colex Œ±) ‚â§ toColex {b} ‚Üî a ‚â§ b := by\n  simp [toColex_le_singleton, eq_comm]\n\n"}
{"name":"Finset.Colex.singleton_lt_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\na b : Œ±\n‚ä¢ Iff (LT.lt { ofColex := Singleton.singleton a } { ofColex := Singleton.singleton b }) (LT.lt a b)","decl":"/-- Colex is an extension of the base order. -/\nlemma singleton_lt_singleton : (toColex {a} : Colex Œ±) < toColex {b} ‚Üî a < b := by\n  simp [toColex_lt_singleton]\n\n"}
{"name":"Finset.Colex.le_iff_sdiff_subset_lowerClosure","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns t : Finset.Colex Œ±\n‚ä¢ Iff (LE.le s t) (HasSubset.Subset (SDiff.sdiff ‚Üës.ofColex ‚Üët.ofColex) ‚Üë(lowerClosure (SDiff.sdiff ‚Üët.ofColex ‚Üës.ofColex)))","decl":"lemma le_iff_sdiff_subset_lowerClosure {s t : Colex Œ±} :\n    s ‚â§ t ‚Üî (ofColex s : Set Œ±) \\ ofColex t ‚äÜ lowerClosure (ofColex t \\ ofColex s : Set Œ±) := by\n  simp [le_def, Set.subset_def, and_assoc]\n\n"}
{"name":"Finset.Colex.toColex_sdiff_le_toColex_sdiff","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns t u : Finset Œ±\ninst‚úù : DecidableEq Œ±\nhus : HasSubset.Subset u s\nhut : HasSubset.Subset u t\n‚ä¢ Iff (LE.le { ofColex := SDiff.sdiff s u } { ofColex := SDiff.sdiff t u }) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- The colexigraphic order is insensitive to removing the same elements from both sets. -/\nlemma toColex_sdiff_le_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :\n    toColex (s \\ u) ‚â§ toColex (t \\ u) ‚Üî toColex s ‚â§ toColex t := by\n  simp_rw [toColex_le_toColex, ‚Üê and_imp, ‚Üê and_assoc, ‚Üê mem_sdiff,\n    sdiff_sdiff_sdiff_cancel_right (show u ‚â§ s from hus),\n    sdiff_sdiff_sdiff_cancel_right (show u ‚â§ t from hut)]\n\n"}
{"name":"Finset.Colex.toColex_sdiff_lt_toColex_sdiff","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns t u : Finset Œ±\ninst‚úù : DecidableEq Œ±\nhus : HasSubset.Subset u s\nhut : HasSubset.Subset u t\n‚ä¢ Iff (LT.lt { ofColex := SDiff.sdiff s u } { ofColex := SDiff.sdiff t u }) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- The colexigraphic order is insensitive to removing the same elements from both sets. -/\nlemma toColex_sdiff_lt_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :\n    toColex (s \\ u) < toColex (t \\ u) ‚Üî toColex s < toColex t :=\n  lt_iff_lt_of_le_iff_le' (toColex_sdiff_le_toColex_sdiff hut hus) <|\n    toColex_sdiff_le_toColex_sdiff hus hut\n\n"}
{"name":"Finset.Colex.toColex_sdiff_le_toColex_sdiff'","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns t : Finset Œ±\ninst‚úù : DecidableEq Œ±\n‚ä¢ Iff (LE.le { ofColex := SDiff.sdiff s t } { ofColex := SDiff.sdiff t s }) (LE.le { ofColex := s } { ofColex := t })","decl":"@[simp] lemma toColex_sdiff_le_toColex_sdiff' :\n    toColex (s \\ t) ‚â§ toColex (t \\ s) ‚Üî toColex s ‚â§ toColex t := by\n  simpa using toColex_sdiff_le_toColex_sdiff (inter_subset_left (s‚ÇÅ := s)) inter_subset_right\n\n"}
{"name":"Finset.Colex.toColex_sdiff_lt_toColex_sdiff'","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns t : Finset Œ±\ninst‚úù : DecidableEq Œ±\n‚ä¢ Iff (LT.lt { ofColex := SDiff.sdiff s t } { ofColex := SDiff.sdiff t s }) (LT.lt { ofColex := s } { ofColex := t })","decl":"@[simp] lemma toColex_sdiff_lt_toColex_sdiff' :\n toColex (s \\ t) < toColex (t \\ s) ‚Üî toColex s < toColex t := by\n  simpa using toColex_sdiff_lt_toColex_sdiff (inter_subset_left (s‚ÇÅ := s)) inter_subset_right\n\n"}
{"name":"Finset.Colex.cons_le_cons","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n‚ä¢ Iff (LE.le { ofColex := Finset.cons a s ha } { ofColex := Finset.cons b s hb }) (LE.le a b)","decl":"@[simp] lemma cons_le_cons (ha hb) : toColex (s.cons a ha) ‚â§ toColex (s.cons b hb) ‚Üî a ‚â§ b := by\n  obtain rfl | hab := eq_or_ne a b\n  ¬∑ simp\n  classical\n  rw [‚Üê toColex_sdiff_le_toColex_sdiff', cons_sdiff_cons hab, cons_sdiff_cons hab.symm,\n    singleton_le_singleton]\n\n"}
{"name":"Finset.Colex.cons_lt_cons","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n‚ä¢ Iff (LT.lt { ofColex := Finset.cons a s ha } { ofColex := Finset.cons b s hb }) (LT.lt a b)","decl":"@[simp] lemma cons_lt_cons (ha hb) : toColex (s.cons a ha) < toColex (s.cons b hb) ‚Üî a < b :=\n  lt_iff_lt_of_le_iff_le' (cons_le_cons _ _) (cons_le_cons _ _)\n\n"}
{"name":"Finset.Colex.insert_le_insert","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\ninst‚úù : DecidableEq Œ±\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n‚ä¢ Iff (LE.le { ofColex := Insert.insert a s } { ofColex := Insert.insert b s }) (LE.le a b)","decl":"lemma insert_le_insert (ha : a ‚àâ s) (hb : b ‚àâ s) :\n    toColex (insert a s) ‚â§ toColex (insert b s) ‚Üî a ‚â§ b := by\n  rw [‚Üê cons_eq_insert _ _ ha, ‚Üê cons_eq_insert _ _ hb, cons_le_cons]\n\n"}
{"name":"Finset.Colex.insert_lt_insert","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\ninst‚úù : DecidableEq Œ±\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n‚ä¢ Iff (LT.lt { ofColex := Insert.insert a s } { ofColex := Insert.insert b s }) (LT.lt a b)","decl":"lemma insert_lt_insert (ha : a ‚àâ s) (hb : b ‚àâ s) :\n    toColex (insert a s) < toColex (insert b s) ‚Üî a < b := by\n  rw [‚Üê cons_eq_insert _ _ ha, ‚Üê cons_eq_insert _ _ hb, cons_lt_cons]\n\n"}
{"name":"Finset.Colex.erase_le_erase","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\ninst‚úù : DecidableEq Œ±\nha : Membership.mem s a\nhb : Membership.mem s b\n‚ä¢ Iff (LE.le { ofColex := s.erase a } { ofColex := s.erase b }) (LE.le b a)","decl":"lemma erase_le_erase (ha : a ‚àà s) (hb : b ‚àà s) :\n    toColex (s.erase a) ‚â§ toColex (s.erase b) ‚Üî b ‚â§ a := by\n  obtain rfl | hab := eq_or_ne a b\n  ¬∑ simp\n  classical\n  rw [‚Üê toColex_sdiff_le_toColex_sdiff', erase_sdiff_erase hab hb, erase_sdiff_erase hab.symm ha,\n    singleton_le_singleton]\n\n"}
{"name":"Finset.Colex.erase_lt_erase","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ns : Finset Œ±\na b : Œ±\ninst‚úù : DecidableEq Œ±\nha : Membership.mem s a\nhb : Membership.mem s b\n‚ä¢ Iff (LT.lt { ofColex := s.erase a } { ofColex := s.erase b }) (LT.lt b a)","decl":"lemma erase_lt_erase (ha : a ‚àà s) (hb : b ‚àà s) :\n    toColex (s.erase a) < toColex (s.erase b) ‚Üî b < a :=\n  lt_iff_lt_of_le_iff_le' (erase_le_erase hb ha) (erase_le_erase ha hb)\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_iff_exists_forall_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun a => And (Membership.mem t a) (And (Not (Membership.mem s a)) (‚àÄ (b : Œ±), Membership.mem s b ‚Üí Not (Membership.mem t b) ‚Üí LT.lt b a)))","decl":"lemma toColex_lt_toColex_iff_exists_forall_lt :\n    toColex s < toColex t ‚Üî ‚àÉ a ‚àà t, a ‚àâ s ‚àß ‚àÄ b ‚àà s, b ‚àâ t ‚Üí b < a := by\n  rw [‚Üê not_le, toColex_le_toColex, not_forall]\n  simp only [not_forall, not_exists, not_and, not_le, exists_prop, exists_and_left]\n\n"}
{"name":"Finset.Colex.lt_iff_exists_forall_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset.Colex Œ±\n‚ä¢ Iff (LT.lt s t) (Exists fun a => And (Membership.mem t.ofColex a) (And (Not (Membership.mem s.ofColex a)) (‚àÄ (b : Œ±), Membership.mem s.ofColex b ‚Üí Not (Membership.mem t.ofColex b) ‚Üí LT.lt b a)))","decl":"lemma lt_iff_exists_forall_lt {s t : Colex Œ±} :\n    s < t ‚Üî ‚àÉ a ‚àà ofColex t, a ‚àâ ofColex s ‚àß ‚àÄ b ‚àà ofColex s, b ‚àâ ofColex t ‚Üí b < a :=\n  toColex_lt_toColex_iff_exists_forall_lt\n\n"}
{"name":"Finset.Colex.toColex_le_toColex_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LE.le { ofColex := s } { ofColex := t }) (‚àÄ (hst : Ne s t), Membership.mem t ((symmDiff s t).max' ‚ãØ))","decl":"lemma toColex_le_toColex_iff_max'_mem :\n    toColex s ‚â§ toColex t ‚Üî ‚àÄ hst : s ‚â† t, (s ‚àÜ t).max' (symmDiff_nonempty.2 hst) ‚àà t := by\n  refine ‚ü®fun h hst ‚Ü¶ ?_, fun h a has hat ‚Ü¶ ?_‚ü©\n  ¬∑ set m := (s ‚àÜ t).max' (symmDiff_nonempty.2 hst)\n    by_contra hmt\n    have hms : m ‚àà s := by\n      simpa [m, mem_symmDiff, hmt] using max'_mem _ <| symmDiff_nonempty.2 hst\n    have ‚ü®b, hbt, hbs, hmb‚ü© := h hms hmt\n    exact lt_irrefl _ <| (max'_lt_iff _ _).1 (hmb.lt_of_ne <| ne_of_mem_of_not_mem hms hbs) _ <|\n      mem_symmDiff.2 <| Or.inr ‚ü®hbt, hbs‚ü©\n  ¬∑ have hst : s ‚â† t := ne_of_mem_of_not_mem' has hat\n    refine ‚ü®_, h hst, ?_, le_max' _ _ <| mem_symmDiff.2 <| Or.inl ‚ü®has, hat‚ü©‚ü©\n    simpa [mem_symmDiff, h hst] using max'_mem _ <| symmDiff_nonempty.2 hst\n\n"}
{"name":"Finset.Colex.le_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset.Colex Œ±\n‚ä¢ Iff (LE.le s t) (‚àÄ (h : Ne s t), Membership.mem t.ofColex ((symmDiff s.ofColex t.ofColex).max' ‚ãØ))","decl":"lemma le_iff_max'_mem {s t : Colex Œ±} :\n    s ‚â§ t ‚Üî ‚àÄ h : s ‚â† t, (ofColex s ‚àÜ ofColex t).max' (max_mem_aux h) ‚àà ofColex t :=\n  toColex_le_toColex_iff_max'_mem.trans\n    ‚ü®fun h hst ‚Ü¶ h <| ofColex_ne_ofColex.2 hst, fun h hst ‚Ü¶ h <| ofColex_ne_ofColex.1 hst‚ü©\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun hst => Membership.mem t ((symmDiff s t).max' ‚ãØ))","decl":"lemma toColex_lt_toColex_iff_max'_mem :\n    toColex s < toColex t ‚Üî ‚àÉ hst : s ‚â† t, (s ‚àÜ t).max' (symmDiff_nonempty.2 hst) ‚àà t := by\n  rw [lt_iff_le_and_ne, toColex_le_toColex_iff_max'_mem]; aesop\n\n"}
{"name":"Finset.Colex.lt_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset.Colex Œ±\n‚ä¢ Iff (LT.lt s t) (Exists fun h => Membership.mem t.ofColex ((symmDiff s.ofColex t.ofColex).max' ‚ãØ))","decl":"lemma lt_iff_max'_mem {s t : Colex Œ±} :\n    s < t ‚Üî ‚àÉ h : s ‚â† t, (ofColex s ‚àÜ ofColex t).max' (max_mem_aux h) ‚àà ofColex t := by\n  rw [lt_iff_le_and_ne, le_iff_max'_mem]; aesop\n\n"}
{"name":"Finset.Colex.lt_iff_exists_filter_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset Œ±\n‚ä¢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun w => And (Membership.mem (SDiff.sdiff t s) w) (Eq (Finset.filter (fun a => LT.lt w a) s) (Finset.filter (fun a => LT.lt w a) t)))","decl":"lemma lt_iff_exists_filter_lt :\n    toColex s < toColex t ‚Üî ‚àÉ w ‚àà t \\ s, {a ‚àà s | w < a} = {a ‚àà t | w < a} := by\n  simp only [lt_iff_exists_forall_lt, mem_sdiff, filter_inj, and_assoc]\n  refine ‚ü®fun h ‚Ü¶ ?_, ?_‚ü©\n  ¬∑ let u := {w ‚àà t \\ s | ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < w}\n    have mem_u {w : Œ±} : w ‚àà u ‚Üî w ‚àà t ‚àß w ‚àâ s ‚àß ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < w := by simp [u, and_assoc]\n    have hu : u.Nonempty := h.imp fun _ ‚Ü¶ mem_u.2\n    let m := max' _ hu\n    have ‚ü®hmt, hms, hm‚ü© : m ‚àà t ‚àß m ‚àâ s ‚àß ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < m := mem_u.1 <| max'_mem _ _\n    refine ‚ü®m, hmt, hms, fun a hma ‚Ü¶ ‚ü®fun has ‚Ü¶ not_imp_comm.1 (hm _ has) hma.asymm, fun hat ‚Ü¶ ?_‚ü©‚ü©\n    by_contra has\n    have hau : a ‚àà u := mem_u.2 ‚ü®hat, has, fun b hbs hbt ‚Ü¶ (hm _ hbs hbt).trans hma‚ü©\n    exact hma.not_le <| le_max' _ _ hau\n  ¬∑ rintro ‚ü®w, hwt, hws, hw‚ü©\n    refine ‚ü®w, hwt, hws, fun a has hat ‚Ü¶ ?_‚ü©\n    by_contra! hwa\n    exact hat <| (hw <| hwa.lt_of_ne <| ne_of_mem_of_not_mem hwt hat).1 has\n\n"}
{"name":"Finset.Colex.erase_le_erase_min'","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\ns t : Finset Œ±\na : Œ±\nhst : LE.le { ofColex := s } { ofColex := t }\nhcard : LE.le s.card t.card\nha : Membership.mem s a\n‚ä¢ LE.le { ofColex := s.erase a } { ofColex := t.erase (t.min' ‚ãØ) }","decl":"/-- If `s ‚â§ t` in colex and `#s ‚â§ #t`, then `s \\ {a} ‚â§ t \\ {min t}` for any `a ‚àà s`. -/\nlemma erase_le_erase_min' (hst : toColex s ‚â§ toColex t) (hcard : #s ‚â§ #t) (ha : a ‚àà s) :\n    toColex (s.erase a) ‚â§\n      toColex (t.erase <| min' t <| card_pos.1 <| (card_pos.2 ‚ü®a, ha‚ü©).trans_le hcard) := by\n  generalize_proofs ht\n  set m := min' t ht\n  -- Case on whether `s = t`\n  obtain rfl | h' := eq_or_ne s t\n  -- If `s = t`, then `s \\ {a} ‚â§ s \\ {m}` because `m ‚â§ a`\n  ¬∑ exact (erase_le_erase ha <| min'_mem _ _).2 <| min'_le _ _ <| ha\n  -- If `s ‚â† t`, call `w` the colex witness. Case on whether `w < a` or `a < w`\n  replace hst := hst.lt_of_ne <| toColex_inj.not.2 h'\n  simp only [lt_iff_exists_filter_lt, mem_sdiff, filter_inj, and_assoc] at hst\n  obtain ‚ü®w, hwt, hws, hw‚ü© := hst\n  obtain hwa | haw := (ne_of_mem_of_not_mem ha hws).symm.lt_or_lt\n  -- If `w < a`, then `a` is the colex witness for `s \\ {a} < t \\ {m}`\n  ¬∑ have hma : m < a := (min'_le _ _ hwt).trans_lt hwa\n    refine (lt_iff_exists_forall_lt.2 ‚ü®a, mem_erase.2 ‚ü®hma.ne', (hw hwa).1 ha‚ü©,\n      not_mem_erase _ _, fun b hbs hbt ‚Ü¶ ?_‚ü©).le\n    change b ‚àâ t.erase m at hbt\n    rw [mem_erase, not_and_or, not_ne_iff] at hbt\n    obtain rfl | hbt := hbt\n    ¬∑ assumption\n    ¬∑ by_contra! hab\n      exact hbt <| (hw <| hwa.trans_le hab).1 <| mem_of_mem_erase hbs\n  -- If `a < w`, case on whether `m < w` or `m = w`\n  obtain rfl | hmw : m = w ‚à® m < w := (min'_le _ _ hwt).eq_or_lt\n  -- If `m = w`, then `s \\ {a} = t \\ {m}`\n  ¬∑ have : erase t m ‚äÜ erase s a := by\n      rintro b hb\n      rw [mem_erase] at hb ‚ä¢\n      exact ‚ü®(haw.trans_le <| min'_le _ _ hb.2).ne',\n        (hw <| hb.1.lt_of_le' <| min'_le _ _ hb.2).2 hb.2‚ü©\n    rw [eq_of_subset_of_card_le this]\n    rw [card_erase_of_mem ha, card_erase_of_mem (min'_mem _ _)]\n    exact tsub_le_tsub_right hcard _\n  -- If `m < w`, then `w` works as the colex witness for  `s \\ {a} < t \\ {m}`\n  ¬∑ refine (lt_iff_exists_forall_lt.2 ‚ü®w, mem_erase.2 ‚ü®hmw.ne', hwt‚ü©, mt mem_of_mem_erase hws,\n      fun b hbs hbt ‚Ü¶ ?_‚ü©).le\n    change b ‚àâ t.erase m at hbt\n    rw [mem_erase, not_and_or, not_ne_iff] at hbt\n    obtain rfl | hbt := hbt\n    ¬∑ assumption\n    ¬∑ by_contra! hwb\n      exact hbt <| (hw <| hwb.lt_of_ne <| ne_of_mem_of_not_mem hwt hbt).1 <| mem_of_mem_erase hbs\n\n"}
{"name":"Finset.Colex.toColex_image_le_toColex_image","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : LinearOrder Œ≤\nf : Œ± ‚Üí Œ≤\ns t : Finset Œ±\nhf : StrictMono f\n‚ä¢ Iff (LE.le { ofColex := Finset.image f s } { ofColex := Finset.image f t }) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- Strictly monotone functions preserve the colex ordering. -/\nlemma toColex_image_le_toColex_image (hf : StrictMono f) :\n    toColex (s.image f) ‚â§ toColex (t.image f) ‚Üî toColex s ‚â§ toColex t := by\n  simp [toColex_le_toColex, hf.le_iff_le, hf.injective.eq_iff]\n\n"}
{"name":"Finset.Colex.toColex_image_lt_toColex_image","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : LinearOrder Œ≤\nf : Œ± ‚Üí Œ≤\ns t : Finset Œ±\nhf : StrictMono f\n‚ä¢ Iff (LT.lt { ofColex := Finset.image f s } { ofColex := Finset.image f t }) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- Strictly monotone functions preserve the colex ordering. -/\nlemma toColex_image_lt_toColex_image (hf : StrictMono f) :\n    toColex (s.image f) < toColex (t.image f) ‚Üî toColex s < toColex t :=\n  lt_iff_lt_of_le_iff_le <| toColex_image_le_toColex_image hf\n\n"}
{"name":"Finset.Colex.toColex_image_ofColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : LinearOrder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : StrictMono f\n‚ä¢ StrictMono fun s => { ofColex := Finset.image f s.ofColex }","decl":"lemma toColex_image_ofColex_strictMono (hf : StrictMono f) :\n    StrictMono fun s ‚Ü¶ toColex <| image f <| ofColex s :=\n  fun _s _t ‚Ü¶ (toColex_image_lt_toColex_image hf).2\n\n"}
{"name":"Finset.Colex.toColex_univ","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ Eq { ofColex := Finset.univ } Top.top","decl":"@[simp] lemma toColex_univ : toColex (univ : Finset Œ±) = ‚ä§ := rfl\n"}
{"name":"Finset.Colex.ofColex_top","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ Eq Top.top.ofColex Finset.univ","decl":"@[simp] lemma ofColex_top : ofColex (‚ä§ : Colex Œ±) = univ := rfl\n\n"}
{"name":"Finset.Colex.isInitSeg_empty","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\nr : Nat\n‚ä¢ Finset.Colex.IsInitSeg EmptyCollection.emptyCollection r","decl":"@[simp] lemma isInitSeg_empty : IsInitSeg (‚àÖ : Finset (Finset Œ±)) r := by simp [IsInitSeg]\n\n"}
{"name":"Finset.Colex.IsInitSeg.total","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrder Œ±\nùíú‚ÇÅ ùíú‚ÇÇ : Finset (Finset Œ±)\nr : Nat\nh‚ÇÅ : Finset.Colex.IsInitSeg ùíú‚ÇÅ r\nh‚ÇÇ : Finset.Colex.IsInitSeg ùíú‚ÇÇ r\n‚ä¢ Or (HasSubset.Subset ùíú‚ÇÅ ùíú‚ÇÇ) (HasSubset.Subset ùíú‚ÇÇ ùíú‚ÇÅ)","decl":"/-- Initial segments are nested in some way. In particular, if they're the same size they're equal.\n-/\nlemma IsInitSeg.total (h‚ÇÅ : IsInitSeg ùíú‚ÇÅ r) (h‚ÇÇ : IsInitSeg ùíú‚ÇÇ r) : ùíú‚ÇÅ ‚äÜ ùíú‚ÇÇ ‚à® ùíú‚ÇÇ ‚äÜ ùíú‚ÇÅ := by\n  classical\n  simp_rw [‚Üê sdiff_eq_empty_iff_subset, ‚Üê not_nonempty_iff_eq_empty]\n  by_contra! h\n  have ‚ü®‚ü®s, hs‚ü©, t, ht‚ü© := h\n  rw [mem_sdiff] at hs ht\n  obtain hst | hst | hts := trichotomous_of (Œ± := Colex Œ±) (¬∑ < ¬∑) (toColex s) (toColex t)\n  ¬∑ exact hs.2 <| h‚ÇÇ.2 ht.1 ‚ü®hst, h‚ÇÅ.1 hs.1‚ü©\n  ¬∑ simp only [toColex.injEq] at hst\n    exact ht.2 <| hst ‚ñ∏ hs.1\n  ¬∑ exact ht.2 <| h‚ÇÅ.2 hs.1 ‚ü®hts, h‚ÇÇ.1 ht.1‚ü©\n\n"}
{"name":"Finset.Colex.mem_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ns t : Finset Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ Iff (Membership.mem (Finset.Colex.initSeg s) t) (And (Eq s.card t.card) (LE.le { ofColex := t } { ofColex := s }))","decl":"@[simp]\nlemma mem_initSeg : t ‚àà initSeg s ‚Üî #s = #t ‚àß toColex t ‚â§ toColex s := by simp [initSeg]\n\n"}
{"name":"Finset.Colex.mem_initSeg_self","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ns : Finset Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ Membership.mem (Finset.Colex.initSeg s) s","decl":"lemma mem_initSeg_self : s ‚àà initSeg s := by simp\n"}
{"name":"Finset.Colex.initSeg_nonempty","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ns : Finset Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ (Finset.Colex.initSeg s).Nonempty","decl":"@[simp] lemma initSeg_nonempty : (initSeg s).Nonempty := ‚ü®s, mem_initSeg_self‚ü©\n\n"}
{"name":"Finset.Colex.isInitSeg_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\ns : Finset Œ±\ninst‚úù : Fintype Œ±\n‚ä¢ Finset.Colex.IsInitSeg (Finset.Colex.initSeg s) s.card","decl":"lemma isInitSeg_initSeg : IsInitSeg (initSeg s) #s := by\n  refine ‚ü®fun t ht => (mem_initSeg.1 ht).1.symm, fun t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ ‚Ü¶ mem_initSeg.2 ‚ü®ht‚ÇÇ.2.symm, ?_‚ü©‚ü©\n  rw [mem_initSeg] at ht‚ÇÅ\n  exact ht‚ÇÇ.1.le.trans ht‚ÇÅ.2\n\n"}
{"name":"Finset.Colex.IsInitSeg.exists_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\nùíú : Finset (Finset Œ±)\nr : Nat\ninst‚úù : Fintype Œ±\nhùíú : Finset.Colex.IsInitSeg ùíú r\nhùíú‚ÇÄ : ùíú.Nonempty\n‚ä¢ Exists fun s => And (Eq s.card r) (Eq ùíú (Finset.Colex.initSeg s))","decl":"lemma IsInitSeg.exists_initSeg (hùíú : IsInitSeg ùíú r) (hùíú‚ÇÄ : ùíú.Nonempty) :\n    ‚àÉ s : Finset Œ±, #s = r ‚àß ùíú = initSeg s := by\n  have hs := sup'_mem (ofColex ‚Åª¬π' ùíú) (LinearOrder.supClosed _) ùíú hùíú‚ÇÄ toColex\n    (fun a ha ‚Ü¶ by simpa using ha)\n  refine ‚ü®_, hùíú.1 hs, ?_‚ü©\n  ext t\n  rw [mem_initSeg]\n  refine ‚ü®fun p ‚Ü¶ ?_, ?_‚ü©\n  ¬∑ rw [hùíú.1 p, hùíú.1 hs]\n    exact ‚ü®rfl, le_sup' _ p‚ü©\n  rintro ‚ü®cards, le‚ü©\n  obtain p | p := le.eq_or_lt\n  ¬∑ rwa [toColex_inj.1 p]\n  ¬∑ exact hùíú.2 hs ‚ü®p, cards ‚ñ∏ hùíú.1 hs‚ü©\n\n"}
{"name":"Finset.Colex.isInitSeg_iff_exists_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrder Œ±\nùíú : Finset (Finset Œ±)\nr : Nat\ninst‚úù : Fintype Œ±\n‚ä¢ Iff (And (Finset.Colex.IsInitSeg ùíú r) ùíú.Nonempty) (Exists fun s => And (Eq s.card r) (Eq ùíú (Finset.Colex.initSeg s)))","decl":"/-- Being a nonempty initial segment of colex is equivalent to being an `initSeg`. -/\nlemma isInitSeg_iff_exists_initSeg :\n    IsInitSeg ùíú r ‚àß ùíú.Nonempty ‚Üî ‚àÉ s : Finset Œ±, #s = r ‚àß ùíú = initSeg s := by\n  refine ‚ü®fun hùíú ‚Ü¶ hùíú.1.exists_initSeg hùíú.2, ?_‚ü©\n  rintro ‚ü®s, rfl, rfl‚ü©\n  exact ‚ü®isInitSeg_initSeg, initSeg_nonempty‚ü©\n\n"}
{"name":"Finset.geomSum_ofColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\nhn : LE.le 2 n\n‚ä¢ StrictMono fun s => s.ofColex.sum fun k => HPow.hPow n k","decl":"lemma geomSum_ofColex_strictMono (hn : 2 ‚â§ n) : StrictMono fun s ‚Ü¶ ‚àë k ‚àà ofColex s, n ^ k := by\n  rintro ‚ü®s‚ü© ‚ü®t‚ü© hst\n  rw [toColex_lt_toColex_iff_exists_forall_lt] at hst\n  obtain ‚ü®a, hat, has, ha‚ü© := hst\n  rw [‚Üê sum_sdiff_lt_sum_sdiff]\n  exact (Nat.geomSum_lt hn <| by simpa).trans_le <| single_le_sum (fun _ _ ‚Ü¶ by positivity) <|\n    mem_sdiff.2 ‚ü®hat, has‚ü©\n\n"}
{"name":"Finset.geomSum_le_geomSum_iff_toColex_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"s t : Finset Nat\nn : Nat\nhn : LE.le 2 n\n‚ä¢ Iff (LE.le (s.sum fun k => HPow.hPow n k) (t.sum fun k => HPow.hPow n k)) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- For finsets of naturals, the colexicographic order is equivalent to the order induced by the\n`n`-ary expansion. -/\nlemma geomSum_le_geomSum_iff_toColex_le_toColex (hn : 2 ‚â§ n) :\n    ‚àë k ‚àà s, n ^ k ‚â§ ‚àë k ‚àà t, n ^ k ‚Üî toColex s ‚â§ toColex t :=\n  (geomSum_ofColex_strictMono hn).le_iff_le\n\n"}
{"name":"Finset.geomSum_lt_geomSum_iff_toColex_lt_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"s t : Finset Nat\nn : Nat\nhn : LE.le 2 n\n‚ä¢ Iff (LT.lt (s.sum fun i => HPow.hPow n i) (t.sum fun i => HPow.hPow n i)) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- For finsets of naturals, the colexicographic order is equivalent to the order induced by the\n`n`-ary expansion. -/\nlemma geomSum_lt_geomSum_iff_toColex_lt_toColex (hn : 2 ‚â§ n) :\n    ‚àë i ‚àà s, n ^ i < ‚àë i ‚àà t, n ^ i ‚Üî toColex s < toColex t :=\n  (geomSum_ofColex_strictMono hn).lt_iff_lt\n\n"}
{"name":"Finset.geomSum_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\nhn : LE.le 2 n\n‚ä¢ Function.Injective fun s => s.sum fun i => HPow.hPow n i","decl":"theorem geomSum_injective {n : ‚Ñï} (hn : 2 ‚â§ n) :\n    Function.Injective (fun s : Finset ‚Ñï ‚Ü¶ ‚àë i ‚àà s, n ^ i) := by\n  intro _ _ h\n  rwa [le_antisymm_iff, geomSum_le_geomSum_iff_toColex_le_toColex hn,\n    geomSum_le_geomSum_iff_toColex_le_toColex hn, ‚Üê le_antisymm_iff, Colex.toColex.injEq] at h\n\n"}
{"name":"Finset.lt_geomSum_of_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\nn a : Nat\nhn : LE.le 2 n\nhi : Membership.mem s a\n‚ä¢ LT.lt a (s.sum fun i => HPow.hPow n i)","decl":"theorem lt_geomSum_of_mem {a : ‚Ñï} (hn : 2 ‚â§ n) (hi : a ‚àà s) : a < ‚àë i ‚àà s, n ^ i :=\n  (a.lt_pow_self hn).trans_le <| single_le_sum (by simp) hi\n\n"}
{"name":"Finset.toFinset_bitIndices_twoPowSum","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\n‚ä¢ Eq (s.sum fun i => HPow.hPow 2 i).bitIndices.toFinset s","decl":"@[simp] theorem toFinset_bitIndices_twoPowSum (s : Finset ‚Ñï) :\n    (‚àë i ‚àà s, 2 ^ i).bitIndices.toFinset = s := by\n  simp [‚Üê (geomSum_injective rfl.le).eq_iff, List.sum_toFinset _ Nat.bitIndices_sorted.nodup]\n\n"}
{"name":"Finset.twoPowSum_toFinset_bitIndices","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n‚ä¢ Eq (n.bitIndices.toFinset.sum fun i => HPow.hPow 2 i) n","decl":"@[simp] theorem twoPowSum_toFinset_bitIndices (n : ‚Ñï) :\n    ‚àë i ‚àà n.bitIndices.toFinset, 2 ^ i = n := by\n  simp [List.sum_toFinset _ Nat.bitIndices_sorted.nodup]\n\n"}
{"name":"Finset.equivBitIndices_symm_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\n‚ä¢ Eq (Finset.equivBitIndices.symm s) (s.sum fun i => HPow.hPow 2 i)","decl":"/-- The equivalence between `‚Ñï` and `Finset ‚Ñï` that maps `‚àë i ‚àà s, 2^i` to `s`. -/\n@[simps] def equivBitIndices : ‚Ñï ‚âÉ Finset ‚Ñï where\n  toFun n := n.bitIndices.toFinset\n  invFun s := ‚àë i ‚àà s, 2^i\n  left_inv := twoPowSum_toFinset_bitIndices\n  right_inv := toFinset_bitIndices_twoPowSum\n\n"}
{"name":"Finset.equivBitIndices_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n‚ä¢ Eq (Finset.equivBitIndices n) n.bitIndices.toFinset","decl":"/-- The equivalence between `‚Ñï` and `Finset ‚Ñï` that maps `‚àë i ‚àà s, 2^i` to `s`. -/\n@[simps] def equivBitIndices : ‚Ñï ‚âÉ Finset ‚Ñï where\n  toFun n := n.bitIndices.toFinset\n  invFun s := ‚àë i ‚àà s, 2^i\n  left_inv := twoPowSum_toFinset_bitIndices\n  right_inv := toFinset_bitIndices_twoPowSum\n\n"}
{"name":"Finset.orderIsoColex_apply_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n‚ä¢ Eq (Finset.orderIsoColex n).ofColex (Finset.equivBitIndices n)","decl":"/-- The equivalence `Nat.equivBitIndices` enumerates `Finset ‚Ñï` in colexicographic order. -/\n@[simps] def orderIsoColex : ‚Ñï ‚âÉo Colex ‚Ñï where\n  toFun n := Colex.toColex (equivBitIndices n)\n  invFun s := equivBitIndices.symm s.ofColex\n  left_inv n := equivBitIndices.symm_apply_apply n\n  right_inv s :=  Finset.toColex_inj.2 (equivBitIndices.apply_symm_apply s.ofColex)\n  map_rel_iff' := by simp [‚Üê (Finset.geomSum_le_geomSum_iff_toColex_le_toColex rfl.le),\n    toFinset_bitIndices_twoPowSum]\n\n"}
{"name":"Finset.orderIsoColex_symm_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset.Colex Nat\n‚ä¢ Eq ((RelIso.symm Finset.orderIsoColex) s) (Finset.equivBitIndices.symm s.ofColex)","decl":"/-- The equivalence `Nat.equivBitIndices` enumerates `Finset ‚Ñï` in colexicographic order. -/\n@[simps] def orderIsoColex : ‚Ñï ‚âÉo Colex ‚Ñï where\n  toFun n := Colex.toColex (equivBitIndices n)\n  invFun s := equivBitIndices.symm s.ofColex\n  left_inv n := equivBitIndices.symm_apply_apply n\n  right_inv s :=  Finset.toColex_inj.2 (equivBitIndices.apply_symm_apply s.ofColex)\n  map_rel_iff' := by simp [‚Üê (Finset.geomSum_le_geomSum_iff_toColex_le_toColex rfl.le),\n    toFinset_bitIndices_twoPowSum]\n\n"}
