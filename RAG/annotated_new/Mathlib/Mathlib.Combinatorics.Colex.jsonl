{"name":"Finset.Colex.toColex.sizeOf_spec","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_3\ninst✝ : SizeOf α\nofColex : Finset α\n⊢ Eq (SizeOf.sizeOf { ofColex := ofColex }) (HAdd.hAdd 1 (SizeOf.sizeOf ofColex))","decl":"/-- Type synonym of `Finset α` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (α) where\n  /-- `toColex` is the \"identity\" function between `Finset α` and `Finset.Colex α`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex α` and `Finset α`. -/\n  (ofColex : Finset α)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.toColex.injEq","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_3\nofColex✝ ofColex : Finset α\n⊢ Eq (Eq { ofColex := ofColex✝ } { ofColex := ofColex }) (Eq ofColex✝ ofColex)","decl":"/-- Type synonym of `Finset α` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (α) where\n  /-- `toColex` is the \"identity\" function between `Finset α` and `Finset.Colex α`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex α` and `Finset α`. -/\n  (ofColex : Finset α)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.toColex.inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_3\nofColex✝ ofColex : Finset α\nx✝ : Eq { ofColex := ofColex✝ } { ofColex := ofColex }\n⊢ Eq ofColex✝ ofColex","decl":"/-- Type synonym of `Finset α` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (α) where\n  /-- `toColex` is the \"identity\" function between `Finset α` and `Finset.Colex α`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex α` and `Finset α`. -/\n  (ofColex : Finset α)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.ext","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_3\nx y : Finset.Colex α\nofColex : Eq x.ofColex y.ofColex\n⊢ Eq x y","decl":"/-- Type synonym of `Finset α` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (α) where\n  /-- `toColex` is the \"identity\" function between `Finset α` and `Finset.Colex α`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex α` and `Finset α`. -/\n  (ofColex : Finset α)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.Colex.ext_iff","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_3\nx y : Finset.Colex α\n⊢ Iff (Eq x y) (Eq x.ofColex y.ofColex)","decl":"/-- Type synonym of `Finset α` equipped with the colexicographic order rather than the inclusion\norder. -/\n@[ext]\nstructure Colex (α) where\n  /-- `toColex` is the \"identity\" function between `Finset α` and `Finset.Colex α`. -/\n  toColex ::\n  /-- `ofColex` is the \"identity\" function between `Finset.Colex α` and `Finset α`. -/\n  (ofColex : Finset α)\n\n-- TODO: Why can't we export?\n--export Colex (toColex)\n\n"}
{"name":"Finset.toColex_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns : Finset.Colex α\n⊢ Eq { ofColex := s.ofColex } s","decl":"@[simp] lemma toColex_ofColex (s : Colex α) : toColex (ofColex s) = s := rfl\n"}
{"name":"Finset.ofColex_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq { ofColex := s }.ofColex s","decl":"lemma ofColex_toColex (s : Finset α) : ofColex (toColex s) = s := rfl\n"}
{"name":"Finset.toColex_inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Eq { ofColex := s } { ofColex := t }) (Eq s t)","decl":"lemma toColex_inj {s t : Finset α} : toColex s = toColex t ↔ s = t := by simp\n"}
{"name":"Finset.ofColex_inj","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns t : Finset.Colex α\n⊢ Iff (Eq s.ofColex t.ofColex) (Eq s t)","decl":"@[simp]\nlemma ofColex_inj {s t : Colex α} : ofColex s = ofColex t ↔ s = t := by cases s; cases t; simp\n"}
{"name":"Finset.toColex_ne_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (Ne { ofColex := s } { ofColex := t }) (Ne s t)","decl":"lemma toColex_ne_toColex {s t : Finset α} : toColex s ≠ toColex t ↔ s ≠ t := by simp\n"}
{"name":"Finset.ofColex_ne_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ns t : Finset.Colex α\n⊢ Iff (Ne s.ofColex t.ofColex) (Ne s t)","decl":"lemma ofColex_ne_ofColex {s t : Colex α} : ofColex s ≠ ofColex t ↔ s ≠ t := by simp\n\n"}
{"name":"Finset.toColex_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\n⊢ Function.Injective Finset.Colex.toColex","decl":"lemma toColex_injective : Injective (toColex : Finset α → Colex α) := fun _ _ ↦ toColex_inj.1\n"}
{"name":"Finset.ofColex_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\n⊢ Function.Injective Finset.Colex.ofColex","decl":"lemma ofColex_injective : Injective (ofColex : Colex α → Finset α) := fun _ _ ↦ ofColex_inj.1\n\n"}
{"name":"Finset.Colex.le_def","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset.Colex α\n⊢ Iff (LE.le s t) (∀ ⦃a : α⦄, Membership.mem s.ofColex a → Not (Membership.mem t.ofColex a) → Exists fun b => And (Membership.mem t.ofColex b) (And (Not (Membership.mem s.ofColex b)) (LE.le a b)))","decl":"lemma le_def {s t : Colex α} :\n    s ≤ t ↔ ∀ ⦃a⦄, a ∈ ofColex s → a ∉ ofColex t → ∃ b, b ∈ ofColex t ∧ b ∉ ofColex s ∧ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"Finset.Colex.toColex_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\n⊢ Iff (LE.le { ofColex := s } { ofColex := t }) (∀ ⦃a : α⦄, Membership.mem s a → Not (Membership.mem t a) → Exists fun b => And (Membership.mem t b) (And (Not (Membership.mem s b)) (LE.le a b)))","decl":"lemma toColex_le_toColex :\n    toColex s ≤ toColex t ↔ ∀ ⦃a⦄, a ∈ s → a ∉ t → ∃ b, b ∈ t ∧ b ∉ s ∧ a ≤ b := Iff.rfl\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\n⊢ Iff (LT.lt { ofColex := s } { ofColex := t }) (And (Ne s t) (∀ ⦃a : α⦄, Membership.mem s a → Not (Membership.mem t a) → Exists fun b => And (Membership.mem t b) (And (Not (Membership.mem s b)) (LE.le a b))))","decl":"lemma toColex_lt_toColex :\n    toColex s < toColex t ↔ s ≠ t ∧ ∀ ⦃a⦄, a ∈ s → a ∉ t → ∃ b, b ∈ t ∧ b ∉ s ∧ a ≤ b := by\n  simp [lt_iff_le_and_ne, toColex_le_toColex, and_comm]\n\n"}
{"name":"Finset.Colex.toColex_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Monotone Finset.Colex.toColex","decl":"/-- If `s ⊆ t`, then `s ≤ t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_mono : Monotone (toColex : Finset α → Colex α) :=\n  fun _s _t hst _a has hat ↦ (hat <| hst has).elim\n\n"}
{"name":"Finset.Colex.toColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ StrictMono Finset.Colex.toColex","decl":"/-- If `s ⊂ t`, then `s < t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_strictMono : StrictMono (toColex : Finset α → Colex α) :=\n  toColex_mono.strictMono_of_injective toColex_injective\n\n"}
{"name":"Finset.Colex.toColex_le_toColex_of_subset","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ LE.le { ofColex := s } { ofColex := t }","decl":"/-- If `s ⊆ t`, then `s ≤ t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_le_toColex_of_subset (h : s ⊆ t) : toColex s ≤ toColex t := toColex_mono h\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_of_ssubset","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\nh : HasSSubset.SSubset s t\n⊢ LT.lt { ofColex := s } { ofColex := t }","decl":"/-- If `s ⊂ t`, then `s < t` in the colex order. Note the converse does not hold, as inclusion does\nnot form a linear order. -/\nlemma toColex_lt_toColex_of_ssubset (h : s ⊂ t) : toColex s < toColex t := toColex_strictMono h\n\n"}
{"name":"Finset.Colex.toColex_empty","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq { ofColex := EmptyCollection.emptyCollection } Bot.bot","decl":"@[simp] lemma toColex_empty : toColex (∅ : Finset α) = ⊥ := rfl\n"}
{"name":"Finset.Colex.ofColex_bot","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq Bot.bot.ofColex EmptyCollection.emptyCollection","decl":"@[simp] lemma ofColex_bot : ofColex (⊥ : Colex α) = ∅ := rfl\n\n"}
{"name":"Finset.Colex.forall_le_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\na : α\nhst : LE.le { ofColex := s } { ofColex := t }\nht : ∀ (b : α), Membership.mem t b → LE.le b a\nb : α\na✝ : Membership.mem s b\n⊢ LE.le b a","decl":"/-- If `s ≤ t` in colex, and all elements in `t` are small, then all elements in `s` are small. -/\nlemma forall_le_mono (hst : toColex s ≤ toColex t) (ht : ∀ b ∈ t, b ≤ a) : ∀ b ∈ s, b ≤ a := by\n  rintro b hb\n  by_cases b ∈ t\n  · exact ht _ ‹_›\n  · obtain ⟨c, hct, -, hbc⟩ := hst hb ‹_›\n    exact hbc.trans <| ht _ hct\n\n"}
{"name":"Finset.Colex.forall_lt_mono","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset α\na : α\nhst : LE.le { ofColex := s } { ofColex := t }\nht : ∀ (b : α), Membership.mem t b → LT.lt b a\nb : α\na✝ : Membership.mem s b\n⊢ LT.lt b a","decl":"/-- If `s ≤ t` in colex, and all elements in `t` are small, then all elements in `s` are small. -/\nlemma forall_lt_mono (hst : toColex s ≤ toColex t) (ht : ∀ b ∈ t, b < a) : ∀ b ∈ s, b < a := by\n  rintro b hb\n  by_cases b ∈ t\n  · exact ht _ ‹_›\n  · obtain ⟨c, hct, -, hbc⟩ := hst hb ‹_›\n    exact hbc.trans_lt <| ht _ hct\n\n"}
{"name":"Finset.Colex.toColex_le_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Finset α\na : α\n⊢ Iff (LE.le { ofColex := s } { ofColex := Singleton.singleton a }) (∀ (b : α), Membership.mem s b → And (LE.le b a) (Membership.mem s a → Eq b a))","decl":"/-- `s ≤ {a}` in colex iff all elements of `s` are strictly less than `a`, except possibly `a` in\nwhich case `s = {a}`. -/\nlemma toColex_le_singleton : toColex s ≤ toColex {a} ↔ ∀ b ∈ s, b ≤ a ∧ (a ∈ s → b = a) := by\n  simp only [toColex_le_toColex, mem_singleton, and_assoc, exists_eq_left]\n  refine forall₂_congr fun b _ ↦ ?_; obtain rfl | hba := eq_or_ne b a <;> aesop\n\n"}
{"name":"Finset.Colex.toColex_lt_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Finset α\na : α\n⊢ Iff (LT.lt { ofColex := s } { ofColex := Singleton.singleton a }) (∀ (b : α), Membership.mem s b → LT.lt b a)","decl":"/-- `s < {a}` in colex iff all elements of `s` are strictly less than `a`. -/\nlemma toColex_lt_singleton : toColex s < toColex {a} ↔ ∀ b ∈ s, b < a := by\n  rw [lt_iff_le_and_ne, toColex_le_singleton, toColex_ne_toColex]\n  refine ⟨fun h b hb ↦ (h.1 _ hb).1.lt_of_ne ?_,\n    fun h ↦ ⟨fun b hb ↦ ⟨(h _ hb).le, fun ha ↦ (lt_irrefl _ <| h _ ha).elim⟩, ?_⟩⟩ <;> rintro rfl\n  · refine h.2 <| eq_singleton_iff_unique_mem.2 ⟨hb, fun c hc ↦ (h.1 _ hc).2 hb⟩\n  · simp at h\n\n"}
{"name":"Finset.Colex.singleton_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Finset α\na : α\n⊢ Iff (LE.le { ofColex := Singleton.singleton a } { ofColex := s }) (Exists fun x => And (Membership.mem s x) (LE.le a x))","decl":"/-- `{a} ≤ s` in colex iff `s` contains an element greater than or equal to `a`. -/\nlemma singleton_le_toColex : (toColex {a} : Colex α) ≤ toColex s ↔ ∃ x ∈ s, a ≤ x := by\n  simp [toColex_le_toColex]; by_cases a ∈ s <;> aesop\n\n"}
{"name":"Finset.Colex.singleton_le_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (LE.le { ofColex := Singleton.singleton a } { ofColex := Singleton.singleton b }) (LE.le a b)","decl":"/-- Colex is an extension of the base order. -/\nlemma singleton_le_singleton : (toColex {a} : Colex α) ≤ toColex {b} ↔ a ≤ b := by\n  simp [toColex_le_singleton, eq_comm]\n\n"}
{"name":"Finset.Colex.singleton_lt_singleton","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (LT.lt { ofColex := Singleton.singleton a } { ofColex := Singleton.singleton b }) (LT.lt a b)","decl":"/-- Colex is an extension of the base order. -/\nlemma singleton_lt_singleton : (toColex {a} : Colex α) < toColex {b} ↔ a < b := by\n  simp [toColex_lt_singleton]\n\n"}
{"name":"Finset.Colex.le_iff_sdiff_subset_lowerClosure","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Finset.Colex α\n⊢ Iff (LE.le s t) (HasSubset.Subset (SDiff.sdiff ↑s.ofColex ↑t.ofColex) ↑(lowerClosure (SDiff.sdiff ↑t.ofColex ↑s.ofColex)))","decl":"lemma le_iff_sdiff_subset_lowerClosure {s t : Colex α} :\n    s ≤ t ↔ (ofColex s : Set α) \\ ofColex t ⊆ lowerClosure (ofColex t \\ ofColex s : Set α) := by\n  simp [le_def, Set.subset_def, and_assoc]\n\n"}
{"name":"Finset.Colex.toColex_sdiff_le_toColex_sdiff","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns t u : Finset α\ninst✝ : DecidableEq α\nhus : HasSubset.Subset u s\nhut : HasSubset.Subset u t\n⊢ Iff (LE.le { ofColex := SDiff.sdiff s u } { ofColex := SDiff.sdiff t u }) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- The colexigraphic order is insensitive to removing the same elements from both sets. -/\nlemma toColex_sdiff_le_toColex_sdiff (hus : u ⊆ s) (hut : u ⊆ t) :\n    toColex (s \\ u) ≤ toColex (t \\ u) ↔ toColex s ≤ toColex t := by\n  simp_rw [toColex_le_toColex, ← and_imp, ← and_assoc, ← mem_sdiff,\n    sdiff_sdiff_sdiff_cancel_right (show u ≤ s from hus),\n    sdiff_sdiff_sdiff_cancel_right (show u ≤ t from hut)]\n\n"}
{"name":"Finset.Colex.toColex_sdiff_lt_toColex_sdiff","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns t u : Finset α\ninst✝ : DecidableEq α\nhus : HasSubset.Subset u s\nhut : HasSubset.Subset u t\n⊢ Iff (LT.lt { ofColex := SDiff.sdiff s u } { ofColex := SDiff.sdiff t u }) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- The colexigraphic order is insensitive to removing the same elements from both sets. -/\nlemma toColex_sdiff_lt_toColex_sdiff (hus : u ⊆ s) (hut : u ⊆ t) :\n    toColex (s \\ u) < toColex (t \\ u) ↔ toColex s < toColex t :=\n  lt_iff_lt_of_le_iff_le' (toColex_sdiff_le_toColex_sdiff hut hus) <|\n    toColex_sdiff_le_toColex_sdiff hus hut\n\n"}
{"name":"Finset.Colex.toColex_sdiff_le_toColex_sdiff'","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (LE.le { ofColex := SDiff.sdiff s t } { ofColex := SDiff.sdiff t s }) (LE.le { ofColex := s } { ofColex := t })","decl":"@[simp] lemma toColex_sdiff_le_toColex_sdiff' :\n    toColex (s \\ t) ≤ toColex (t \\ s) ↔ toColex s ≤ toColex t := by\n  simpa using toColex_sdiff_le_toColex_sdiff (inter_subset_left (s₁ := s)) inter_subset_right\n\n"}
{"name":"Finset.Colex.toColex_sdiff_lt_toColex_sdiff'","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (LT.lt { ofColex := SDiff.sdiff s t } { ofColex := SDiff.sdiff t s }) (LT.lt { ofColex := s } { ofColex := t })","decl":"@[simp] lemma toColex_sdiff_lt_toColex_sdiff' :\n toColex (s \\ t) < toColex (t \\ s) ↔ toColex s < toColex t := by\n  simpa using toColex_sdiff_lt_toColex_sdiff (inter_subset_left (s₁ := s)) inter_subset_right\n\n"}
{"name":"Finset.Colex.cons_le_cons","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Finset α\na b : α\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n⊢ Iff (LE.le { ofColex := Finset.cons a s ha } { ofColex := Finset.cons b s hb }) (LE.le a b)","decl":"@[simp] lemma cons_le_cons (ha hb) : toColex (s.cons a ha) ≤ toColex (s.cons b hb) ↔ a ≤ b := by\n  obtain rfl | hab := eq_or_ne a b\n  · simp\n  classical\n  rw [← toColex_sdiff_le_toColex_sdiff', cons_sdiff_cons hab, cons_sdiff_cons hab.symm,\n    singleton_le_singleton]\n\n"}
{"name":"Finset.Colex.cons_lt_cons","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Finset α\na b : α\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n⊢ Iff (LT.lt { ofColex := Finset.cons a s ha } { ofColex := Finset.cons b s hb }) (LT.lt a b)","decl":"@[simp] lemma cons_lt_cons (ha hb) : toColex (s.cons a ha) < toColex (s.cons b hb) ↔ a < b :=\n  lt_iff_lt_of_le_iff_le' (cons_le_cons _ _) (cons_le_cons _ _)\n\n"}
{"name":"Finset.Colex.insert_le_insert","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns : Finset α\na b : α\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n⊢ Iff (LE.le { ofColex := Insert.insert a s } { ofColex := Insert.insert b s }) (LE.le a b)","decl":"lemma insert_le_insert (ha : a ∉ s) (hb : b ∉ s) :\n    toColex (insert a s) ≤ toColex (insert b s) ↔ a ≤ b := by\n  rw [← cons_eq_insert _ _ ha, ← cons_eq_insert _ _ hb, cons_le_cons]\n\n"}
{"name":"Finset.Colex.insert_lt_insert","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns : Finset α\na b : α\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nhb : Not (Membership.mem s b)\n⊢ Iff (LT.lt { ofColex := Insert.insert a s } { ofColex := Insert.insert b s }) (LT.lt a b)","decl":"lemma insert_lt_insert (ha : a ∉ s) (hb : b ∉ s) :\n    toColex (insert a s) < toColex (insert b s) ↔ a < b := by\n  rw [← cons_eq_insert _ _ ha, ← cons_eq_insert _ _ hb, cons_lt_cons]\n\n"}
{"name":"Finset.Colex.erase_le_erase","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns : Finset α\na b : α\ninst✝ : DecidableEq α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LE.le { ofColex := s.erase a } { ofColex := s.erase b }) (LE.le b a)","decl":"lemma erase_le_erase (ha : a ∈ s) (hb : b ∈ s) :\n    toColex (s.erase a) ≤ toColex (s.erase b) ↔ b ≤ a := by\n  obtain rfl | hab := eq_or_ne a b\n  · simp\n  classical\n  rw [← toColex_sdiff_le_toColex_sdiff', erase_sdiff_erase hab hb, erase_sdiff_erase hab.symm ha,\n    singleton_le_singleton]\n\n"}
{"name":"Finset.Colex.erase_lt_erase","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ns : Finset α\na b : α\ninst✝ : DecidableEq α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (LT.lt { ofColex := s.erase a } { ofColex := s.erase b }) (LT.lt b a)","decl":"lemma erase_lt_erase (ha : a ∈ s) (hb : b ∈ s) :\n    toColex (s.erase a) < toColex (s.erase b) ↔ b < a :=\n  lt_iff_lt_of_le_iff_le' (erase_le_erase hb ha) (erase_le_erase ha hb)\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_iff_exists_forall_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun a => And (Membership.mem t a) (And (Not (Membership.mem s a)) (∀ (b : α), Membership.mem s b → Not (Membership.mem t b) → LT.lt b a)))","decl":"lemma toColex_lt_toColex_iff_exists_forall_lt :\n    toColex s < toColex t ↔ ∃ a ∈ t, a ∉ s ∧ ∀ b ∈ s, b ∉ t → b < a := by\n  rw [← not_le, toColex_le_toColex, not_forall]\n  simp only [not_forall, not_exists, not_and, not_le, exists_prop, exists_and_left]\n\n"}
{"name":"Finset.Colex.lt_iff_exists_forall_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset.Colex α\n⊢ Iff (LT.lt s t) (Exists fun a => And (Membership.mem t.ofColex a) (And (Not (Membership.mem s.ofColex a)) (∀ (b : α), Membership.mem s.ofColex b → Not (Membership.mem t.ofColex b) → LT.lt b a)))","decl":"lemma lt_iff_exists_forall_lt {s t : Colex α} :\n    s < t ↔ ∃ a ∈ ofColex t, a ∉ ofColex s ∧ ∀ b ∈ ofColex s, b ∉ ofColex t → b < a :=\n  toColex_lt_toColex_iff_exists_forall_lt\n\n"}
{"name":"Finset.Colex.toColex_le_toColex_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Iff (LE.le { ofColex := s } { ofColex := t }) (∀ (hst : Ne s t), Membership.mem t ((symmDiff s t).max' ⋯))","decl":"lemma toColex_le_toColex_iff_max'_mem :\n    toColex s ≤ toColex t ↔ ∀ hst : s ≠ t, (s ∆ t).max' (symmDiff_nonempty.2 hst) ∈ t := by\n  refine ⟨fun h hst ↦ ?_, fun h a has hat ↦ ?_⟩\n  · set m := (s ∆ t).max' (symmDiff_nonempty.2 hst)\n    by_contra hmt\n    have hms : m ∈ s := by\n      simpa [m, mem_symmDiff, hmt] using max'_mem _ <| symmDiff_nonempty.2 hst\n    have ⟨b, hbt, hbs, hmb⟩ := h hms hmt\n    exact lt_irrefl _ <| (max'_lt_iff _ _).1 (hmb.lt_of_ne <| ne_of_mem_of_not_mem hms hbs) _ <|\n      mem_symmDiff.2 <| Or.inr ⟨hbt, hbs⟩\n  · have hst : s ≠ t := ne_of_mem_of_not_mem' has hat\n    refine ⟨_, h hst, ?_, le_max' _ _ <| mem_symmDiff.2 <| Or.inl ⟨has, hat⟩⟩\n    simpa [mem_symmDiff, h hst] using max'_mem _ <| symmDiff_nonempty.2 hst\n\n"}
{"name":"Finset.Colex.le_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset.Colex α\n⊢ Iff (LE.le s t) (∀ (h : Ne s t), Membership.mem t.ofColex ((symmDiff s.ofColex t.ofColex).max' ⋯))","decl":"lemma le_iff_max'_mem {s t : Colex α} :\n    s ≤ t ↔ ∀ h : s ≠ t, (ofColex s ∆ ofColex t).max' (max_mem_aux h) ∈ ofColex t :=\n  toColex_le_toColex_iff_max'_mem.trans\n    ⟨fun h hst ↦ h <| ofColex_ne_ofColex.2 hst, fun h hst ↦ h <| ofColex_ne_ofColex.1 hst⟩\n\n"}
{"name":"Finset.Colex.toColex_lt_toColex_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun hst => Membership.mem t ((symmDiff s t).max' ⋯))","decl":"lemma toColex_lt_toColex_iff_max'_mem :\n    toColex s < toColex t ↔ ∃ hst : s ≠ t, (s ∆ t).max' (symmDiff_nonempty.2 hst) ∈ t := by\n  rw [lt_iff_le_and_ne, toColex_le_toColex_iff_max'_mem]; aesop\n\n"}
{"name":"Finset.Colex.lt_iff_max'_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset.Colex α\n⊢ Iff (LT.lt s t) (Exists fun h => Membership.mem t.ofColex ((symmDiff s.ofColex t.ofColex).max' ⋯))","decl":"lemma lt_iff_max'_mem {s t : Colex α} :\n    s < t ↔ ∃ h : s ≠ t, (ofColex s ∆ ofColex t).max' (max_mem_aux h) ∈ ofColex t := by\n  rw [lt_iff_le_and_ne, le_iff_max'_mem]; aesop\n\n"}
{"name":"Finset.Colex.lt_iff_exists_filter_lt","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Iff (LT.lt { ofColex := s } { ofColex := t }) (Exists fun w => And (Membership.mem (SDiff.sdiff t s) w) (Eq (Finset.filter (fun a => LT.lt w a) s) (Finset.filter (fun a => LT.lt w a) t)))","decl":"lemma lt_iff_exists_filter_lt :\n    toColex s < toColex t ↔ ∃ w ∈ t \\ s, {a ∈ s | w < a} = {a ∈ t | w < a} := by\n  simp only [lt_iff_exists_forall_lt, mem_sdiff, filter_inj, and_assoc]\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · let u := {w ∈ t \\ s | ∀ a ∈ s, a ∉ t → a < w}\n    have mem_u {w : α} : w ∈ u ↔ w ∈ t ∧ w ∉ s ∧ ∀ a ∈ s, a ∉ t → a < w := by simp [u, and_assoc]\n    have hu : u.Nonempty := h.imp fun _ ↦ mem_u.2\n    let m := max' _ hu\n    have ⟨hmt, hms, hm⟩ : m ∈ t ∧ m ∉ s ∧ ∀ a ∈ s, a ∉ t → a < m := mem_u.1 <| max'_mem _ _\n    refine ⟨m, hmt, hms, fun a hma ↦ ⟨fun has ↦ not_imp_comm.1 (hm _ has) hma.asymm, fun hat ↦ ?_⟩⟩\n    by_contra has\n    have hau : a ∈ u := mem_u.2 ⟨hat, has, fun b hbs hbt ↦ (hm _ hbs hbt).trans hma⟩\n    exact hma.not_le <| le_max' _ _ hau\n  · rintro ⟨w, hwt, hws, hw⟩\n    refine ⟨w, hwt, hws, fun a has hat ↦ ?_⟩\n    by_contra! hwa\n    exact hat <| (hw <| hwa.lt_of_ne <| ne_of_mem_of_not_mem hwt hat).1 has\n\n"}
{"name":"Finset.Colex.erase_le_erase_min'","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Finset α\na : α\nhst : LE.le { ofColex := s } { ofColex := t }\nhcard : LE.le s.card t.card\nha : Membership.mem s a\n⊢ LE.le { ofColex := s.erase a } { ofColex := t.erase (t.min' ⋯) }","decl":"/-- If `s ≤ t` in colex and `#s ≤ #t`, then `s \\ {a} ≤ t \\ {min t}` for any `a ∈ s`. -/\nlemma erase_le_erase_min' (hst : toColex s ≤ toColex t) (hcard : #s ≤ #t) (ha : a ∈ s) :\n    toColex (s.erase a) ≤\n      toColex (t.erase <| min' t <| card_pos.1 <| (card_pos.2 ⟨a, ha⟩).trans_le hcard) := by\n  generalize_proofs ht\n  set m := min' t ht\n  -- Case on whether `s = t`\n  obtain rfl | h' := eq_or_ne s t\n  -- If `s = t`, then `s \\ {a} ≤ s \\ {m}` because `m ≤ a`\n  · exact (erase_le_erase ha <| min'_mem _ _).2 <| min'_le _ _ <| ha\n  -- If `s ≠ t`, call `w` the colex witness. Case on whether `w < a` or `a < w`\n  replace hst := hst.lt_of_ne <| toColex_inj.not.2 h'\n  simp only [lt_iff_exists_filter_lt, mem_sdiff, filter_inj, and_assoc] at hst\n  obtain ⟨w, hwt, hws, hw⟩ := hst\n  obtain hwa | haw := (ne_of_mem_of_not_mem ha hws).symm.lt_or_lt\n  -- If `w < a`, then `a` is the colex witness for `s \\ {a} < t \\ {m}`\n  · have hma : m < a := (min'_le _ _ hwt).trans_lt hwa\n    refine (lt_iff_exists_forall_lt.2 ⟨a, mem_erase.2 ⟨hma.ne', (hw hwa).1 ha⟩,\n      not_mem_erase _ _, fun b hbs hbt ↦ ?_⟩).le\n    change b ∉ t.erase m at hbt\n    rw [mem_erase, not_and_or, not_ne_iff] at hbt\n    obtain rfl | hbt := hbt\n    · assumption\n    · by_contra! hab\n      exact hbt <| (hw <| hwa.trans_le hab).1 <| mem_of_mem_erase hbs\n  -- If `a < w`, case on whether `m < w` or `m = w`\n  obtain rfl | hmw : m = w ∨ m < w := (min'_le _ _ hwt).eq_or_lt\n  -- If `m = w`, then `s \\ {a} = t \\ {m}`\n  · have : erase t m ⊆ erase s a := by\n      rintro b hb\n      rw [mem_erase] at hb ⊢\n      exact ⟨(haw.trans_le <| min'_le _ _ hb.2).ne',\n        (hw <| hb.1.lt_of_le' <| min'_le _ _ hb.2).2 hb.2⟩\n    rw [eq_of_subset_of_card_le this]\n    rw [card_erase_of_mem ha, card_erase_of_mem (min'_mem _ _)]\n    exact tsub_le_tsub_right hcard _\n  -- If `m < w`, then `w` works as the colex witness for  `s \\ {a} < t \\ {m}`\n  · refine (lt_iff_exists_forall_lt.2 ⟨w, mem_erase.2 ⟨hmw.ne', hwt⟩, mt mem_of_mem_erase hws,\n      fun b hbs hbt ↦ ?_⟩).le\n    change b ∉ t.erase m at hbt\n    rw [mem_erase, not_and_or, not_ne_iff] at hbt\n    obtain rfl | hbt := hbt\n    · assumption\n    · by_contra! hwb\n      exact hbt <| (hw <| hwb.lt_of_ne <| ne_of_mem_of_not_mem hwt hbt).1 <| mem_of_mem_erase hbs\n\n"}
{"name":"Finset.Colex.toColex_image_le_toColex_image","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\ns t : Finset α\nhf : StrictMono f\n⊢ Iff (LE.le { ofColex := Finset.image f s } { ofColex := Finset.image f t }) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- Strictly monotone functions preserve the colex ordering. -/\nlemma toColex_image_le_toColex_image (hf : StrictMono f) :\n    toColex (s.image f) ≤ toColex (t.image f) ↔ toColex s ≤ toColex t := by\n  simp [toColex_le_toColex, hf.le_iff_le, hf.injective.eq_iff]\n\n"}
{"name":"Finset.Colex.toColex_image_lt_toColex_image","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\ns t : Finset α\nhf : StrictMono f\n⊢ Iff (LT.lt { ofColex := Finset.image f s } { ofColex := Finset.image f t }) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- Strictly monotone functions preserve the colex ordering. -/\nlemma toColex_image_lt_toColex_image (hf : StrictMono f) :\n    toColex (s.image f) < toColex (t.image f) ↔ toColex s < toColex t :=\n  lt_iff_lt_of_le_iff_le <| toColex_image_le_toColex_image hf\n\n"}
{"name":"Finset.Colex.toColex_image_ofColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : StrictMono f\n⊢ StrictMono fun s => { ofColex := Finset.image f s.ofColex }","decl":"lemma toColex_image_ofColex_strictMono (hf : StrictMono f) :\n    StrictMono fun s ↦ toColex <| image f <| ofColex s :=\n  fun _s _t ↦ (toColex_image_lt_toColex_image hf).2\n\n"}
{"name":"Finset.Colex.toColex_univ","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : Fintype α\n⊢ Eq { ofColex := Finset.univ } Top.top","decl":"@[simp] lemma toColex_univ : toColex (univ : Finset α) = ⊤ := rfl\n"}
{"name":"Finset.Colex.ofColex_top","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : Fintype α\n⊢ Eq Top.top.ofColex Finset.univ","decl":"@[simp] lemma ofColex_top : ofColex (⊤ : Colex α) = univ := rfl\n\n"}
{"name":"Finset.Colex.isInitSeg_empty","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nr : Nat\n⊢ Finset.Colex.IsInitSeg EmptyCollection.emptyCollection r","decl":"@[simp] lemma isInitSeg_empty : IsInitSeg (∅ : Finset (Finset α)) r := by simp [IsInitSeg]\n\n"}
{"name":"Finset.Colex.IsInitSeg.total","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n𝒜₁ 𝒜₂ : Finset (Finset α)\nr : Nat\nh₁ : Finset.Colex.IsInitSeg 𝒜₁ r\nh₂ : Finset.Colex.IsInitSeg 𝒜₂ r\n⊢ Or (HasSubset.Subset 𝒜₁ 𝒜₂) (HasSubset.Subset 𝒜₂ 𝒜₁)","decl":"/-- Initial segments are nested in some way. In particular, if they're the same size they're equal.\n-/\nlemma IsInitSeg.total (h₁ : IsInitSeg 𝒜₁ r) (h₂ : IsInitSeg 𝒜₂ r) : 𝒜₁ ⊆ 𝒜₂ ∨ 𝒜₂ ⊆ 𝒜₁ := by\n  classical\n  simp_rw [← sdiff_eq_empty_iff_subset, ← not_nonempty_iff_eq_empty]\n  by_contra! h\n  have ⟨⟨s, hs⟩, t, ht⟩ := h\n  rw [mem_sdiff] at hs ht\n  obtain hst | hst | hts := trichotomous_of (α := Colex α) (· < ·) (toColex s) (toColex t)\n  · exact hs.2 <| h₂.2 ht.1 ⟨hst, h₁.1 hs.1⟩\n  · simp only [toColex.injEq] at hst\n    exact ht.2 <| hst ▸ hs.1\n  · exact ht.2 <| h₁.2 hs.1 ⟨hts, h₂.1 ht.1⟩\n\n"}
{"name":"Finset.Colex.mem_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ns t : Finset α\ninst✝ : Fintype α\n⊢ Iff (Membership.mem (Finset.Colex.initSeg s) t) (And (Eq s.card t.card) (LE.le { ofColex := t } { ofColex := s }))","decl":"@[simp]\nlemma mem_initSeg : t ∈ initSeg s ↔ #s = #t ∧ toColex t ≤ toColex s := by simp [initSeg]\n\n"}
{"name":"Finset.Colex.mem_initSeg_self","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ns : Finset α\ninst✝ : Fintype α\n⊢ Membership.mem (Finset.Colex.initSeg s) s","decl":"lemma mem_initSeg_self : s ∈ initSeg s := by simp\n"}
{"name":"Finset.Colex.initSeg_nonempty","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ns : Finset α\ninst✝ : Fintype α\n⊢ (Finset.Colex.initSeg s).Nonempty","decl":"@[simp] lemma initSeg_nonempty : (initSeg s).Nonempty := ⟨s, mem_initSeg_self⟩\n\n"}
{"name":"Finset.Colex.isInitSeg_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ns : Finset α\ninst✝ : Fintype α\n⊢ Finset.Colex.IsInitSeg (Finset.Colex.initSeg s) s.card","decl":"lemma isInitSeg_initSeg : IsInitSeg (initSeg s) #s := by\n  refine ⟨fun t ht => (mem_initSeg.1 ht).1.symm, fun t₁ t₂ ht₁ ht₂ ↦ mem_initSeg.2 ⟨ht₂.2.symm, ?_⟩⟩\n  rw [mem_initSeg] at ht₁\n  exact ht₂.1.le.trans ht₁.2\n\n"}
{"name":"Finset.Colex.IsInitSeg.exists_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\n𝒜 : Finset (Finset α)\nr : Nat\ninst✝ : Fintype α\nh𝒜 : Finset.Colex.IsInitSeg 𝒜 r\nh𝒜₀ : 𝒜.Nonempty\n⊢ Exists fun s => And (Eq s.card r) (Eq 𝒜 (Finset.Colex.initSeg s))","decl":"lemma IsInitSeg.exists_initSeg (h𝒜 : IsInitSeg 𝒜 r) (h𝒜₀ : 𝒜.Nonempty) :\n    ∃ s : Finset α, #s = r ∧ 𝒜 = initSeg s := by\n  have hs := sup'_mem (ofColex ⁻¹' 𝒜) (LinearOrder.supClosed _) 𝒜 h𝒜₀ toColex\n    (fun a ha ↦ by simpa using ha)\n  refine ⟨_, h𝒜.1 hs, ?_⟩\n  ext t\n  rw [mem_initSeg]\n  refine ⟨fun p ↦ ?_, ?_⟩\n  · rw [h𝒜.1 p, h𝒜.1 hs]\n    exact ⟨rfl, le_sup' _ p⟩\n  rintro ⟨cards, le⟩\n  obtain p | p := le.eq_or_lt\n  · rwa [toColex_inj.1 p]\n  · exact h𝒜.2 hs ⟨p, cards ▸ h𝒜.1 hs⟩\n\n"}
{"name":"Finset.Colex.isInitSeg_iff_exists_initSeg","module":"Mathlib.Combinatorics.Colex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\n𝒜 : Finset (Finset α)\nr : Nat\ninst✝ : Fintype α\n⊢ Iff (And (Finset.Colex.IsInitSeg 𝒜 r) 𝒜.Nonempty) (Exists fun s => And (Eq s.card r) (Eq 𝒜 (Finset.Colex.initSeg s)))","decl":"/-- Being a nonempty initial segment of colex is equivalent to being an `initSeg`. -/\nlemma isInitSeg_iff_exists_initSeg :\n    IsInitSeg 𝒜 r ∧ 𝒜.Nonempty ↔ ∃ s : Finset α, #s = r ∧ 𝒜 = initSeg s := by\n  refine ⟨fun h𝒜 ↦ h𝒜.1.exists_initSeg h𝒜.2, ?_⟩\n  rintro ⟨s, rfl, rfl⟩\n  exact ⟨isInitSeg_initSeg, initSeg_nonempty⟩\n\n"}
{"name":"Finset.geomSum_ofColex_strictMono","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\nhn : LE.le 2 n\n⊢ StrictMono fun s => s.ofColex.sum fun k => HPow.hPow n k","decl":"lemma geomSum_ofColex_strictMono (hn : 2 ≤ n) : StrictMono fun s ↦ ∑ k ∈ ofColex s, n ^ k := by\n  rintro ⟨s⟩ ⟨t⟩ hst\n  rw [toColex_lt_toColex_iff_exists_forall_lt] at hst\n  obtain ⟨a, hat, has, ha⟩ := hst\n  rw [← sum_sdiff_lt_sum_sdiff]\n  exact (Nat.geomSum_lt hn <| by simpa).trans_le <| single_le_sum (fun _ _ ↦ by positivity) <|\n    mem_sdiff.2 ⟨hat, has⟩\n\n"}
{"name":"Finset.geomSum_le_geomSum_iff_toColex_le_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"s t : Finset Nat\nn : Nat\nhn : LE.le 2 n\n⊢ Iff (LE.le (s.sum fun k => HPow.hPow n k) (t.sum fun k => HPow.hPow n k)) (LE.le { ofColex := s } { ofColex := t })","decl":"/-- For finsets of naturals, the colexicographic order is equivalent to the order induced by the\n`n`-ary expansion. -/\nlemma geomSum_le_geomSum_iff_toColex_le_toColex (hn : 2 ≤ n) :\n    ∑ k ∈ s, n ^ k ≤ ∑ k ∈ t, n ^ k ↔ toColex s ≤ toColex t :=\n  (geomSum_ofColex_strictMono hn).le_iff_le\n\n"}
{"name":"Finset.geomSum_lt_geomSum_iff_toColex_lt_toColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"s t : Finset Nat\nn : Nat\nhn : LE.le 2 n\n⊢ Iff (LT.lt (s.sum fun i => HPow.hPow n i) (t.sum fun i => HPow.hPow n i)) (LT.lt { ofColex := s } { ofColex := t })","decl":"/-- For finsets of naturals, the colexicographic order is equivalent to the order induced by the\n`n`-ary expansion. -/\nlemma geomSum_lt_geomSum_iff_toColex_lt_toColex (hn : 2 ≤ n) :\n    ∑ i ∈ s, n ^ i < ∑ i ∈ t, n ^ i ↔ toColex s < toColex t :=\n  (geomSum_ofColex_strictMono hn).lt_iff_lt\n\n"}
{"name":"Finset.geomSum_injective","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\nhn : LE.le 2 n\n⊢ Function.Injective fun s => s.sum fun i => HPow.hPow n i","decl":"theorem geomSum_injective {n : ℕ} (hn : 2 ≤ n) :\n    Function.Injective (fun s : Finset ℕ ↦ ∑ i ∈ s, n ^ i) := by\n  intro _ _ h\n  rwa [le_antisymm_iff, geomSum_le_geomSum_iff_toColex_le_toColex hn,\n    geomSum_le_geomSum_iff_toColex_le_toColex hn, ← le_antisymm_iff, Colex.toColex.injEq] at h\n\n"}
{"name":"Finset.lt_geomSum_of_mem","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\nn a : Nat\nhn : LE.le 2 n\nhi : Membership.mem s a\n⊢ LT.lt a (s.sum fun i => HPow.hPow n i)","decl":"theorem lt_geomSum_of_mem {a : ℕ} (hn : 2 ≤ n) (hi : a ∈ s) : a < ∑ i ∈ s, n ^ i :=\n  (a.lt_pow_self hn).trans_le <| single_le_sum (by simp) hi\n\n"}
{"name":"Finset.toFinset_bitIndices_twoPowSum","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\n⊢ Eq (s.sum fun i => HPow.hPow 2 i).bitIndices.toFinset s","decl":"@[simp] theorem toFinset_bitIndices_twoPowSum (s : Finset ℕ) :\n    (∑ i ∈ s, 2 ^ i).bitIndices.toFinset = s := by\n  simp [← (geomSum_injective rfl.le).eq_iff, List.sum_toFinset _ Nat.bitIndices_sorted.nodup]\n\n"}
{"name":"Finset.twoPowSum_toFinset_bitIndices","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n⊢ Eq (n.bitIndices.toFinset.sum fun i => HPow.hPow 2 i) n","decl":"@[simp] theorem twoPowSum_toFinset_bitIndices (n : ℕ) :\n    ∑ i ∈ n.bitIndices.toFinset, 2 ^ i = n := by\n  simp [List.sum_toFinset _ Nat.bitIndices_sorted.nodup]\n\n"}
{"name":"Finset.equivBitIndices_symm_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset Nat\n⊢ Eq (Finset.equivBitIndices.symm s) (s.sum fun i => HPow.hPow 2 i)","decl":"/-- The equivalence between `ℕ` and `Finset ℕ` that maps `∑ i ∈ s, 2^i` to `s`. -/\n@[simps] def equivBitIndices : ℕ ≃ Finset ℕ where\n  toFun n := n.bitIndices.toFinset\n  invFun s := ∑ i ∈ s, 2^i\n  left_inv := twoPowSum_toFinset_bitIndices\n  right_inv := toFinset_bitIndices_twoPowSum\n\n"}
{"name":"Finset.equivBitIndices_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n⊢ Eq (Finset.equivBitIndices n) n.bitIndices.toFinset","decl":"/-- The equivalence between `ℕ` and `Finset ℕ` that maps `∑ i ∈ s, 2^i` to `s`. -/\n@[simps] def equivBitIndices : ℕ ≃ Finset ℕ where\n  toFun n := n.bitIndices.toFinset\n  invFun s := ∑ i ∈ s, 2^i\n  left_inv := twoPowSum_toFinset_bitIndices\n  right_inv := toFinset_bitIndices_twoPowSum\n\n"}
{"name":"Finset.orderIsoColex_apply_ofColex","module":"Mathlib.Combinatorics.Colex","initialProofState":"n : Nat\n⊢ Eq (Finset.orderIsoColex n).ofColex (Finset.equivBitIndices n)","decl":"/-- The equivalence `Nat.equivBitIndices` enumerates `Finset ℕ` in colexicographic order. -/\n@[simps] def orderIsoColex : ℕ ≃o Colex ℕ where\n  toFun n := Colex.toColex (equivBitIndices n)\n  invFun s := equivBitIndices.symm s.ofColex\n  left_inv n := equivBitIndices.symm_apply_apply n\n  right_inv s :=  Finset.toColex_inj.2 (equivBitIndices.apply_symm_apply s.ofColex)\n  map_rel_iff' := by simp [← (Finset.geomSum_le_geomSum_iff_toColex_le_toColex rfl.le),\n    toFinset_bitIndices_twoPowSum]\n\n"}
{"name":"Finset.orderIsoColex_symm_apply","module":"Mathlib.Combinatorics.Colex","initialProofState":"s : Finset.Colex Nat\n⊢ Eq ((RelIso.symm Finset.orderIsoColex) s) (Finset.equivBitIndices.symm s.ofColex)","decl":"/-- The equivalence `Nat.equivBitIndices` enumerates `Finset ℕ` in colexicographic order. -/\n@[simps] def orderIsoColex : ℕ ≃o Colex ℕ where\n  toFun n := Colex.toColex (equivBitIndices n)\n  invFun s := equivBitIndices.symm s.ofColex\n  left_inv n := equivBitIndices.symm_apply_apply n\n  right_inv s :=  Finset.toColex_inj.2 (equivBitIndices.apply_symm_apply s.ofColex)\n  map_rel_iff' := by simp [← (Finset.geomSum_le_geomSum_iff_toColex_le_toColex rfl.le),\n    toFinset_bitIndices_twoPowSum]\n\n"}
