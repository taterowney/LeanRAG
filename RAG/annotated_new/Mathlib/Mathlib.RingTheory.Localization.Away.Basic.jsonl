{"name":"IsLocalization.Away.mul_invSelf","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\n⊢ Eq (HMul.hMul ((algebraMap R S) x) (IsLocalization.Away.invSelf x)) 1","decl":"@[simp]\ntheorem mul_invSelf : algebraMap R S x * invSelf x = 1 := by\n  convert IsLocalization.mk'_mul_mk'_eq_one (M := Submonoid.powers x) (S := S) _ 1\n  symm\n  apply IsLocalization.mk'_one\n\n"}
{"name":"IsLocalization.Away.sec_spec","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\ns : S\n⊢ Eq (HMul.hMul s ((algebraMap R S) (HPow.hPow x (IsLocalization.Away.sec x s).2))) ((algebraMap R S) (IsLocalization.Away.sec x s).1)","decl":"lemma sec_spec (s : S) : s * (algebraMap R S) (x ^ (IsLocalization.Away.sec x s).2) =\n    algebraMap R S (IsLocalization.Away.sec x s).1 := by\n  simp only [IsLocalization.Away.sec, ← IsLocalization.sec_spec]\n  congr\n  exact (IsLocalization.sec (Submonoid.powers x) s).2.property.choose_spec\n\n"}
{"name":"IsLocalization.Away.algebraMap_pow_isUnit","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\nn : Nat\n⊢ IsUnit (HPow.hPow ((algebraMap R S) x) n)","decl":"lemma algebraMap_pow_isUnit (n : ℕ) : IsUnit (algebraMap R S x ^ n) :=\n  IsUnit.pow _ <| IsLocalization.map_units _ (⟨x, 1, by simp⟩ : Submonoid.powers x)\n\n"}
{"name":"IsLocalization.Away.algebraMap_isUnit","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\n⊢ IsUnit ((algebraMap R S) x)","decl":"lemma algebraMap_isUnit : IsUnit (algebraMap R S x) :=\n  IsLocalization.map_units _ (⟨x, 1, by simp⟩ : Submonoid.powers x)\n\n"}
{"name":"IsLocalization.Away.surj","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\nz : S\n⊢ Exists fun n => Exists fun a => Eq (HMul.hMul z (HPow.hPow ((algebraMap R S) x) n)) ((algebraMap R S) a)","decl":"lemma surj (z : S) : ∃ (n : ℕ) (a : R), z * algebraMap R S x ^ n = algebraMap R S a := by\n  obtain ⟨⟨a, ⟨-, n, rfl⟩⟩, h⟩ := IsLocalization.surj (Submonoid.powers x) z\n  use n, a\n  simpa using h\n\n"}
{"name":"IsLocalization.Away.exists_of_eq","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\na b : R\nh : Eq ((algebraMap R S) a) ((algebraMap R S) b)\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow x n) a) (HMul.hMul (HPow.hPow x n) b)","decl":"lemma exists_of_eq {a b : R} (h : algebraMap R S a = algebraMap R S b) :\n    ∃ (n : ℕ), x ^ n * a = x ^ n * b := by\n  obtain ⟨⟨-, n, rfl⟩, hx⟩ := IsLocalization.exists_of_eq (M := Submonoid.powers x) h\n  use n\n\n"}
{"name":"IsLocalization.Away.mk","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nr : R\nmap_unit : IsUnit ((algebraMap R S) r)\nsurj : ∀ (s : S), Exists fun n => Exists fun a => Eq (HMul.hMul s (HPow.hPow ((algebraMap R S) r) n)) ((algebraMap R S) a)\nexists_of_eq : ∀ (a b : R), Eq ((algebraMap R S) a) ((algebraMap R S) b) → Exists fun n => Eq (HMul.hMul (HPow.hPow r n) a) (HMul.hMul (HPow.hPow r n) b)\n⊢ IsLocalization.Away r S","decl":"/-- Specialized constructor for `IsLocalization.Away`. -/\nlemma mk (r : R) (map_unit : IsUnit (algebraMap R S r))\n    (surj : ∀ s, ∃ (n : ℕ) (a : R), s * algebraMap R S r ^ n = algebraMap R S a)\n    (exists_of_eq : ∀ a b, algebraMap R S a = algebraMap R S b → ∃ (n : ℕ), r ^ n * a = r ^ n * b) :\n    IsLocalization.Away r S where\n  map_units' := by\n    rintro ⟨-, n, rfl⟩\n    simp only [map_pow]\n    exact IsUnit.pow _ map_unit\n  surj' z := by\n    obtain ⟨n, a, hn⟩ := surj z\n    use ⟨a, ⟨r ^ n, n, rfl⟩⟩\n    simpa using hn\n  exists_of_eq {x y} h := by\n    obtain ⟨n, hn⟩ := exists_of_eq x y h\n    use ⟨r ^ n, n, rfl⟩\n\n"}
{"name":"IsLocalization.Away.of_associated","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nr r' : R\nh : Associated r r'\ninst✝ : IsLocalization.Away r S\n⊢ IsLocalization.Away r' S","decl":"lemma of_associated {r r' : R} (h : Associated r r') [IsLocalization.Away r S] :\n    IsLocalization.Away r' S := by\n  obtain ⟨u, rfl⟩ := h\n  refine mk _ ?_ (fun s ↦ ?_) (fun a b hab ↦ ?_)\n  · simp [algebraMap_isUnit r, IsUnit.map _ u.isUnit]\n  · obtain ⟨n, a, hn⟩ := surj r s\n    use n, a * u ^ n\n    simp [mul_pow, ← mul_assoc, hn]\n  · obtain ⟨n, hn⟩ := exists_of_eq r hab\n    use n\n    rw [mul_pow, mul_comm (r ^ n), mul_assoc, mul_assoc, hn]\n\n"}
{"name":"IsLocalization.Away.iff_of_associated","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nr r' : R\nh : Associated r r'\n⊢ Iff (IsLocalization.Away r S) (IsLocalization.Away r' S)","decl":"/-- If `r` and `r'` are associated elements of `R`, an `R`-algebra `S`\nis the localization of `R` away from `r` if and only of it is the localization of `R` away from\n`r'`. -/\nlemma iff_of_associated {r r' : R} (h : Associated r r') :\n    IsLocalization.Away r S ↔ IsLocalization.Away r' S :=\n  ⟨fun _ ↦ IsLocalization.Away.of_associated h, fun _ ↦ IsLocalization.Away.of_associated h.symm⟩\n\n"}
{"name":"IsLocalization.Away.isUnit_of_dvd","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx : R\ninst✝ : IsLocalization.Away x S\nr : R\nh : Dvd.dvd r x\n⊢ IsUnit ((algebraMap R S) r)","decl":"lemma isUnit_of_dvd {r : R} (h : r ∣ x) : IsUnit (algebraMap R S r) :=\n  isUnit_of_dvd_unit (map_dvd _ h) (algebraMap_isUnit x)\n\n"}
{"name":"IsLocalization.Away.lift_eq","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\nx : R\ninst✝ : IsLocalization.Away x S\ng : RingHom R P\nhg : IsUnit (g x)\na : R\n⊢ Eq ((IsLocalization.Away.lift x hg) ((algebraMap R S) a)) (g a)","decl":"@[simp]\ntheorem lift_eq (hg : IsUnit (g x)) (a : R) : lift x hg (algebraMap R S a) = g a :=\n  IsLocalization.lift_eq _ _\n\n"}
{"name":"IsLocalization.Away.lift_comp","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\nx : R\ninst✝ : IsLocalization.Away x S\ng : RingHom R P\nhg : IsUnit (g x)\n⊢ Eq ((IsLocalization.Away.lift x hg).comp (algebraMap R S)) g","decl":"@[simp]\ntheorem lift_comp (hg : IsUnit (g x)) : (lift x hg).comp (algebraMap R S) = g :=\n  IsLocalization.lift_comp _\n\n"}
{"name":"IsLocalization.Away.AwayMap.lift_eq","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\nx : R\ninst✝ : IsLocalization.Away x S\ng : RingHom R P\nhg : IsUnit (g x)\na : R\n⊢ Eq ((IsLocalization.Away.lift x hg) ((algebraMap R S) a)) (g a)","decl":"@[deprecated (since := \"2024-11-25\")] alias AwayMap.lift_eq := lift_eq\n"}
{"name":"IsLocalization.Away.AwayMap.lift_comp","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\nx : R\ninst✝ : IsLocalization.Away x S\ng : RingHom R P\nhg : IsUnit (g x)\n⊢ Eq ((IsLocalization.Away.lift x hg).comp (algebraMap R S)) g","decl":"@[deprecated (since := \"2024-11-25\")] alias AwayMap.lift_comp := lift_comp\n\n"}
{"name":"IsLocalization.Away.awayToAwayLeft_eq","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nP : Type u_3\ninst✝³ : CommSemiring P\nx : R\ninst✝² : IsLocalization.Away x S\ny : R\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization.Away (HMul.hMul y x) P\na : R\n⊢ Eq ((IsLocalization.Away.awayToAwayLeft x y) ((algebraMap R S) a)) ((algebraMap R P) a)","decl":"theorem awayToAwayLeft_eq (y : R) [Algebra R P] [IsLocalization.Away (y * x) P] (a : R) :\n    awayToAwayLeft x y (algebraMap R S a) = algebraMap R P a :=\n  lift_eq _ _ _\n\n"}
{"name":"IsLocalization.Away.awayToAwayRight_eq","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nP : Type u_3\ninst✝³ : CommSemiring P\nx : R\ninst✝² : IsLocalization.Away x S\ny : R\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization.Away (HMul.hMul x y) P\na : R\n⊢ Eq ((IsLocalization.Away.awayToAwayRight x y) ((algebraMap R S) a)) ((algebraMap R P) a)","decl":"theorem awayToAwayRight_eq (y : R) [Algebra R P] [IsLocalization.Away (x * y) P] (a : R) :\n    awayToAwayRight x y (algebraMap R S a) = algebraMap R P a :=\n  lift_eq _ _ _\n\n"}
{"name":"IsLocalization.Away.instMapRingHomPowersOfCoe","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"A : Type u_5\ninst✝⁴ : CommSemiring A\nB : Type u_6\ninst✝³ : CommSemiring B\nBₚ : Type u_8\ninst✝² : CommSemiring Bₚ\ninst✝¹ : Algebra B Bₚ\nf : RingHom A B\na : A\ninst✝ : IsLocalization.Away (f a) Bₚ\n⊢ IsLocalization (Submonoid.map f (Submonoid.powers a)) Bₚ","decl":"instance {f : A →+* B} (a : A) [Away (f a) Bₚ] : IsLocalization (.map f (.powers a)) Bₚ := by\n  simpa\n\n"}
{"name":"IsLocalization.Away.mapₐ_apply","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommSemiring R\nA : Type u_5\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\nB : Type u_6\ninst✝¹¹ : CommSemiring B\ninst✝¹⁰ : Algebra R B\nAₚ : Type u_7\ninst✝⁹ : CommSemiring Aₚ\ninst✝⁸ : Algebra A Aₚ\ninst✝⁷ : Algebra R Aₚ\ninst✝⁶ : IsScalarTower R A Aₚ\nBₚ : Type u_8\ninst✝⁵ : CommSemiring Bₚ\ninst✝⁴ : Algebra B Bₚ\ninst✝³ : Algebra R Bₚ\ninst✝² : IsScalarTower R B Bₚ\nf : AlgHom R A B\na : A\ninst✝¹ : IsLocalization.Away a Aₚ\ninst✝ : IsLocalization.Away (f a) Bₚ\nx : Aₚ\n⊢ Eq ((IsLocalization.Away.mapₐ Aₚ Bₚ f a) x) ((IsLocalization.Away.map Aₚ Bₚ f.toRingHom a) x)","decl":"@[simp]\nlemma mapₐ_apply (f : A →ₐ[R] B) (a : A) [Away a Aₚ] [Away (f a) Bₚ] (x : Aₚ) :\n    mapₐ Aₚ Bₚ f a x = map Aₚ Bₚ f.toRingHom a x :=\n  rfl\n\n"}
{"name":"IsLocalization.Away.mapₐ_injective_of_injective","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommSemiring R\nA : Type u_5\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\nB : Type u_6\ninst✝¹¹ : CommSemiring B\ninst✝¹⁰ : Algebra R B\nAₚ : Type u_7\ninst✝⁹ : CommSemiring Aₚ\ninst✝⁸ : Algebra A Aₚ\ninst✝⁷ : Algebra R Aₚ\ninst✝⁶ : IsScalarTower R A Aₚ\nBₚ : Type u_8\ninst✝⁵ : CommSemiring Bₚ\ninst✝⁴ : Algebra B Bₚ\ninst✝³ : Algebra R Bₚ\ninst✝² : IsScalarTower R B Bₚ\nf : AlgHom R A B\na : A\ninst✝¹ : IsLocalization.Away a Aₚ\ninst✝ : IsLocalization.Away (f a) Bₚ\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(IsLocalization.Away.mapₐ Aₚ Bₚ f a)","decl":"lemma mapₐ_injective_of_injective {f : A →ₐ[R] B} (a : A) [Away a Aₚ] [Away (f a) Bₚ]\n    (hf : Function.Injective f) : Function.Injective (mapₐ Aₚ Bₚ f a) :=\n  IsLocalization.map_injective_of_injective _ _ _ hf\n\n"}
{"name":"IsLocalization.Away.mapₐ_surjective_of_surjective","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommSemiring R\nA : Type u_5\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\nB : Type u_6\ninst✝¹¹ : CommSemiring B\ninst✝¹⁰ : Algebra R B\nAₚ : Type u_7\ninst✝⁹ : CommSemiring Aₚ\ninst✝⁸ : Algebra A Aₚ\ninst✝⁷ : Algebra R Aₚ\ninst✝⁶ : IsScalarTower R A Aₚ\nBₚ : Type u_8\ninst✝⁵ : CommSemiring Bₚ\ninst✝⁴ : Algebra B Bₚ\ninst✝³ : Algebra R Bₚ\ninst✝² : IsScalarTower R B Bₚ\nf : AlgHom R A B\na : A\ninst✝¹ : IsLocalization.Away a Aₚ\ninst✝ : IsLocalization.Away (f a) Bₚ\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(IsLocalization.Away.mapₐ Aₚ Bₚ f a)","decl":"lemma mapₐ_surjective_of_surjective {f : A →ₐ[R] B} (a : A) [Away a Aₚ] [Away (f a) Bₚ]\n    (hf : Function.Surjective f) : Function.Surjective (mapₐ Aₚ Bₚ f a) :=\n  have : IsLocalization (Submonoid.map f.toRingHom (Submonoid.powers a)) Bₚ := by\n    simp only [AlgHom.toRingHom_eq_coe, Submonoid.map_powers, RingHom.coe_coe]\n    infer_instance\n  IsLocalization.map_surjective_of_surjective _ _ _ hf\n\n"}
{"name":"IsLocalization.Away.mul","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nT : Type u_5\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra S T\ninst✝³ : Algebra R T\ninst✝² : IsScalarTower R S T\nx y : R\ninst✝¹ : IsLocalization.Away x S\ninst✝ : IsLocalization.Away ((algebraMap R S) y) T\n⊢ IsLocalization.Away (HMul.hMul y x) T","decl":"/-- Localizing the localization of `R` at `x` at the image of `y` is the same as localizing\n`R` at `y * x`. See `IsLocalization.Away.mul'` for the `x * y` version. -/\nlemma mul (T : Type*) [CommSemiring T] [Algebra S T]\n    [Algebra R T] [IsScalarTower R S T] (x y : R)\n    [IsLocalization.Away x S] [IsLocalization.Away (algebraMap R S y) T] :\n    IsLocalization.Away (y * x) T := by\n  refine mk _ ?_ (fun z ↦ ?_) (fun a b h ↦ ?_)\n  · simp only [map_mul, IsUnit.mul_iff, IsScalarTower.algebraMap_apply R S T]\n    exact ⟨algebraMap_isUnit _, IsUnit.map _ (algebraMap_isUnit x)⟩\n  · obtain ⟨m, p, hpq⟩ := surj (algebraMap R S y) z\n    obtain ⟨n, a, hab⟩ := surj x p\n    use m + n, a * x ^ m * y ^ n\n    simp only [mul_pow, pow_add, map_pow, map_mul, ← mul_assoc, hpq,\n      IsScalarTower.algebraMap_apply R S T, ← hab]\n    ring\n  · repeat rw [IsScalarTower.algebraMap_apply R S T] at h\n    obtain ⟨n, hn⟩ := exists_of_eq (algebraMap R S y) h\n    simp only [← map_pow, ← map_mul, ← map_mul] at hn\n    obtain ⟨m, hm⟩ := exists_of_eq x hn\n    use n + m\n    convert_to y ^ m * x ^ n * (x ^ m * (y ^ n * a)) = y ^ m * x ^ n * (x ^ m * (y ^ n * b))\n    · ring\n    · ring\n    · rw [hm]\n\n"}
{"name":"IsLocalization.Away.mul'","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nT : Type u_5\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra S T\ninst✝³ : Algebra R T\ninst✝² : IsScalarTower R S T\nx y : R\ninst✝¹ : IsLocalization.Away x S\ninst✝ : IsLocalization.Away ((algebraMap R S) y) T\n⊢ IsLocalization.Away (HMul.hMul x y) T","decl":"/-- Localizing the localization of `R` at `x` at the image of `y` is the same as localizing\n`R` at `x * y`. See `IsLocalization.Away.mul` for the `y * x` version. -/\nlemma mul' (T : Type*) [CommSemiring T] [Algebra S T] [Algebra R T] [IsScalarTower R S T] (x y : R)\n    [IsLocalization.Away x S] [IsLocalization.Away (algebraMap R S y) T] :\n    IsLocalization.Away (x * y) T :=\n  mul_comm x y ▸ mul S T x y\n\n"}
{"name":"IsLocalization.Away.instHMulAwayCoeRingHomAlgebraMap","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx y : R\ninst✝ : IsLocalization.Away x S\n⊢ IsLocalization.Away (HMul.hMul y x) (Localization.Away ((algebraMap R S) y))","decl":"/-- Localizing the localization of `R` at `x` at the image of `y` is the same as localizing\n`R` at `y * x`. -/\ninstance (x y : R) [IsLocalization.Away x S] :\n    IsLocalization.Away (y * x) (Localization.Away (algebraMap R S y)) :=\n  IsLocalization.Away.mul S (Localization.Away (algebraMap R S y)) _ _\n\n"}
{"name":"IsLocalization.Away.instHMulAwayCoeRingHomAlgebraMap_1","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nx y : R\ninst✝ : IsLocalization.Away x S\n⊢ IsLocalization.Away (HMul.hMul x y) (Localization.Away ((algebraMap R S) y))","decl":"/-- Localizing the localization of `R` at `x` at the image of `y` is the same as localizing\n`R` at `x * y`. -/\ninstance (x y : R) [IsLocalization.Away x S] :\n    IsLocalization.Away (x * y) (Localization.Away (algebraMap R S y)) :=\n  IsLocalization.Away.mul' S (Localization.Away (algebraMap R S y)) _ _\n\n"}
{"name":"IsLocalization.Away.commutes","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_5\ninst✝¹³ : CommSemiring R\nS₁ : Type u_6\nS₂ : Type u_7\nT : Type u_8\ninst✝¹² : CommSemiring S₁\ninst✝¹¹ : CommSemiring S₂\ninst✝¹⁰ : CommSemiring T\ninst✝⁹ : Algebra R S₁\ninst✝⁸ : Algebra R S₂\ninst✝⁷ : Algebra R T\ninst✝⁶ : Algebra S₁ T\ninst✝⁵ : Algebra S₂ T\ninst✝⁴ : IsScalarTower R S₁ T\ninst✝³ : IsScalarTower R S₂ T\nx y : R\ninst✝² : IsLocalization.Away x S₁\ninst✝¹ : IsLocalization.Away y S₂\ninst✝ : IsLocalization.Away ((algebraMap R S₂) x) T\n⊢ IsLocalization.Away ((algebraMap R S₁) y) T","decl":"/-- If `S₁` is the localization of `R` away from `f` and `S₂` is the localization away from `g`,\nthen any localization `T` of `S₂` away from `f` is also a localization of `S₁` away from `g`. -/\nlemma commutes {R : Type*} [CommSemiring R] (S₁ S₂ T : Type*) [CommSemiring S₁]\n    [CommSemiring S₂] [CommSemiring T] [Algebra R S₁] [Algebra R S₂] [Algebra R T] [Algebra S₁ T]\n    [Algebra S₂ T] [IsScalarTower R S₁ T] [IsScalarTower R S₂ T] (x y : R)\n    [IsLocalization.Away x S₁] [IsLocalization.Away y S₂]\n    [IsLocalization.Away (algebraMap R S₂ x) T] :\n    IsLocalization.Away (algebraMap R S₁ y) T := by\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid S₂ (Submonoid.powers x)) T := by\n    simp only [Algebra.algebraMapSubmonoid, Submonoid.map_powers]\n    infer_instance\n  convert IsLocalization.commutes S₁ S₂ T (Submonoid.powers x) (Submonoid.powers y)\n  ext x\n  simp [Algebra.algebraMapSubmonoid]\n\n"}
{"name":"IsLocalization.away_of_isUnit_of_bijective","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nr : R\nhr : IsUnit r\nH : Function.Bijective ⇑(algebraMap R S)\n⊢ IsLocalization.Away r S","decl":"theorem away_of_isUnit_of_bijective {R : Type*} (S : Type*) [CommSemiring R] [CommSemiring S]\n    [Algebra R S] {r : R} (hr : IsUnit r) (H : Function.Bijective (algebraMap R S)) :\n    IsLocalization.Away r S :=\n  { map_units' := by\n      rintro ⟨_, n, rfl⟩\n      exact (algebraMap R S).isUnit_map (hr.pow _)\n    surj' := fun z => by\n      obtain ⟨z', rfl⟩ := H.2 z\n      exact ⟨⟨z', 1⟩, by simp⟩\n    exists_of_eq := fun {x y} => by\n      rw [H.1.eq_iff]\n      rintro rfl\n      exact ⟨1, rfl⟩ }\n\n"}
{"name":"IsLocalization.away_of_isIdempotentElem_of_mul","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\ne : R\nhe : IsIdempotentElem e\nH : ∀ (x y : R), Iff (Eq ((algebraMap R S) x) ((algebraMap R S) y)) (Eq (HMul.hMul e x) (HMul.hMul e y))\nH' : Function.Surjective ⇑(algebraMap R S)\n⊢ IsLocalization.Away e S","decl":"lemma away_of_isIdempotentElem_of_mul {R S} [CommSemiring R] [CommSemiring S] [Algebra R S]\n    {e : R} (he : IsIdempotentElem e)\n    (H : ∀ x y, algebraMap R S x = algebraMap R S y ↔ e * x = e * y)\n    (H' : Function.Surjective (algebraMap R S)) :\n    IsLocalization.Away e S where\n  map_units' r := by\n    obtain ⟨r, n, rfl⟩ := r\n    simp [show algebraMap R S e = 1 by rw [← (algebraMap R S).map_one, H, mul_one, he]]\n  surj' z := by\n    obtain ⟨z, rfl⟩ := H' z\n    exact ⟨⟨z, 1⟩, by simp⟩\n  exists_of_eq {x y} h := ⟨⟨e, Submonoid.mem_powers e⟩, (H x y).mp h⟩\n\n"}
{"name":"IsLocalization.away_of_isIdempotentElem","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ne : R\nhe : IsIdempotentElem e\nH : Eq (RingHom.ker (algebraMap R S)) (Ideal.span (Singleton.singleton (HSub.hSub 1 e)))\nH' : Function.Surjective ⇑(algebraMap R S)\n⊢ IsLocalization.Away e S","decl":"lemma away_of_isIdempotentElem {R S} [CommRing R] [CommRing S] [Algebra R S]\n    {e : R} (he : IsIdempotentElem e)\n    (H : RingHom.ker (algebraMap R S) = Ideal.span {1 - e})\n    (H' : Function.Surjective (algebraMap R S)) :\n    IsLocalization.Away e S :=\n  away_of_isIdempotentElem_of_mul he (fun x y ↦ by\n    rw [← sub_eq_zero, ← map_sub, ← RingHom.mem_ker, H, ← he.ker_toSpanSingleton_eq_span,\n      LinearMap.mem_ker, LinearMap.toSpanSingleton_apply, sub_smul, sub_eq_zero]\n    simp_rw [mul_comm e, smul_eq_mul]) H'\n\n"}
{"name":"IsLocalization.away_fst","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\n⊢ IsLocalization.Away { fst := 1, snd := 0 } R","decl":"instance away_fst {R S} [CommSemiring R] [CommSemiring S] :\n    letI := (RingHom.fst R S).toAlgebra\n    IsLocalization.Away (R := R × S) (1, 0) R :=\n  letI := (RingHom.fst R S).toAlgebra\n  away_of_isIdempotentElem_of_mul (by ext <;> simp)\n    (fun ⟨xR, xS⟩ ⟨yR, yS⟩ ↦ show xR = yR ↔ _ by simp) Prod.fst_surjective\n\n"}
{"name":"IsLocalization.away_snd","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\n⊢ IsLocalization.Away { fst := 0, snd := 1 } S","decl":"instance away_snd {R S} [CommSemiring R] [CommSemiring S] :\n    letI := (RingHom.snd R S).toAlgebra\n    IsLocalization.Away (R := R × S) (0, 1) S :=\n  letI := (RingHom.snd R S).toAlgebra\n  away_of_isIdempotentElem_of_mul (by ext <;> simp)\n    (fun ⟨xR, xS⟩ ⟨yR, yS⟩ ↦ show xS = yS ↔ _ by simp) Prod.snd_surjective\n\n"}
{"name":"Localization.awayLift_mk","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nA : Type u_4\ninst✝ : CommRing A\nf : RingHom R A\nr a : R\nv : A\nhv : Eq (HMul.hMul (f r) v) 1\nj : Nat\n⊢ Eq ((Localization.awayLift f r ⋯) (Localization.mk a ⟨HPow.hPow r j, ⋯⟩)) (HMul.hMul (f a) (HPow.hPow v j))","decl":"lemma awayLift_mk {A : Type*} [CommRing A] (f : R →+* A) (r : R)\n    (a : R) (v : A) (hv : f r * v = 1) (j : ℕ) :\n    Localization.awayLift f r (isUnit_iff_exists_inv.mpr ⟨v, hv⟩)\n      (Localization.mk a ⟨r ^ j, j, rfl⟩) = f a * v ^ j := by\n  rw [Localization.mk_eq_mk']\n  erw [IsLocalization.lift_mk']\n  rw [Units.mul_inv_eq_iff_eq_mul]\n  simp [IsUnit.liftRight, mul_assoc, ← mul_pow, (mul_comm _ _).trans hv]\n\n"}
{"name":"Localization.algebraMap_injective_of_span_eq_top","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\n⊢ Function.Injective ⇑(algebraMap R ((a : ↑s) → Localization.Away ↑a))","decl":"theorem algebraMap_injective_of_span_eq_top (s : Set R) (span_eq : Ideal.span s = ⊤) :\n    Function.Injective (algebraMap R <| Π a : s, Away a.1) := fun x y eq ↦ by\n  suffices Module.eqIdeal R x y = ⊤ by simpa [Module.eqIdeal] using (Ideal.eq_top_iff_one _).mp this\n  by_contra ne\n  have ⟨r, hrs, disj⟩ := Ideal.exists_disjoint_powers_of_span_eq_top s span_eq _ ne\n  let r : s := ⟨r, hrs⟩\n  have ⟨⟨_, n, rfl⟩, eq⟩ := (IsLocalization.eq_iff_exists (.powers r.1) _).mp (congr_fun eq r)\n  exact Set.disjoint_left.mp disj eq ⟨n, rfl⟩\n\n"}
{"name":"Localization.existsUnique_algebraMap_eq_of_span_eq_top","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nf : (a : ↑s) → Localization.Away ↑a\nh : ∀ (a b : ↑s), Eq ((IsLocalization.Away.awayToAwayRight ↑a ↑b) (f a)) ((IsLocalization.Away.awayToAwayLeft ↑b ↑a) (f b))\n⊢ ExistsUnique fun r => ∀ (a : ↑s), Eq ((algebraMap R (Localization.Away ↑a)) r) (f a)","decl":"/-- The sheaf condition for the structure sheaf on `Spec R`\nfor a covering of the whole prime spectrum by basic opens. -/\ntheorem existsUnique_algebraMap_eq_of_span_eq_top (s : Set R) (span_eq : Ideal.span s = ⊤)\n    (f : Π a : s, Away a.1) (h : ∀ a b : s,\n      Away.awayToAwayRight (P := Away (a * b : R)) a.1 b (f a) = Away.awayToAwayLeft b.1 a (f b)) :\n    ∃! r : R, ∀ a : s, algebraMap R _ r = f a := by\n  have mem := (Ideal.eq_top_iff_one _).mp span_eq; clear span_eq\n  wlog finset_eq : ∃ t : Finset R, t = s generalizing s\n  · have ⟨t, hts, mem⟩ := Submodule.mem_span_finite_of_mem_span mem\n    have ⟨r, eq, uniq⟩ := this t (fun a ↦ f ⟨a, hts a.2⟩)\n      (fun a b ↦ h ⟨a, hts a.2⟩ ⟨b, hts b.2⟩) mem ⟨_, rfl⟩\n    refine ⟨r, fun a ↦ ?_, fun _ eq ↦ uniq _ fun a ↦ eq ⟨a, hts a.2⟩⟩\n    replace hts := Set.insert_subset a.2 hts\n    classical\n    have ⟨r', eq, _⟩ := this ({a.1} ∪ t) (fun a ↦ f ⟨a, hts a.2⟩) (fun a b ↦\n      h ⟨a, hts a.2⟩ ⟨b, hts b.2⟩) (Ideal.span_mono (fun _ ↦ .inr) mem) ⟨{a.1} ∪ t, by simp⟩\n    exact (congr_arg _ (uniq _ fun b ↦ eq ⟨b, .inr b.2⟩).symm).trans (eq ⟨a, .inl rfl⟩)\n  have span_eq := (Ideal.eq_top_iff_one _).mpr mem\n  refine existsUnique_of_exists_of_unique ?_ fun x y hx hy ↦\n    algebraMap_injective_of_span_eq_top s span_eq (funext fun a ↦ (hx a).trans (hy a).symm)\n  obtain ⟨s, rfl⟩ := finset_eq\n  choose n r eq using fun a ↦ Away.surj a.1 (f a)\n  let N := s.attach.sup n\n  let r a := a ^ (N - n a) * r a\n  have eq a : f a * algebraMap R _ (a ^ N) = algebraMap R _ (r a) := by\n    rw [map_mul, ← eq, mul_left_comm, ← map_pow, ← map_mul, ← pow_add,\n      Nat.sub_add_cancel (Finset.le_sup <| s.mem_attach a)]\n  have eq2 a b : ∃ N', (a * b) ^ N' * (r a * b ^ N) = (a * b) ^ N' * (r b * a ^ N) :=\n    Away.exists_of_eq (S := Away (a * b : R)) _ <| by\n      simp_rw [map_mul, ← Away.awayToAwayRight_eq (S := Away a.1) a.1 b (r a),\n        ← Away.awayToAwayLeft_eq (S := Away b.1) b.1 a (r b), ← eq, map_mul,\n        Away.awayToAwayRight_eq, Away.awayToAwayLeft_eq, h, mul_assoc, ← map_mul, mul_comm]\n  choose N' hN' using eq2\n  let N' := (s ×ˢ s).attach.sup fun a ↦ N'\n    ⟨_, (Finset.mem_product.mp a.2).1⟩ ⟨_, (Finset.mem_product.mp a.2).2⟩\n  have eq2 a b : (a * b) ^ N' * (r a * b ^ N) = (a * b) ^ N' * (r b * a ^ N) := by\n    dsimp only [N']; rw [← Nat.sub_add_cancel (Finset.le_sup <| (Finset.mem_attach _ ⟨⟨a, b⟩,\n      Finset.mk_mem_product a.2 b.2⟩)), pow_add, mul_assoc, hN', ← mul_assoc]\n  let N := N' + N\n  let r a := a ^ N' * r a\n  have eq a : f a * algebraMap R _ (a ^ N) = algebraMap R _ (r a) := by\n    rw [map_mul, ← eq, mul_left_comm, ← map_mul, ← pow_add]\n  have eq2 a b : r a * b ^ N = r b * a ^ N := by\n    rw [pow_add, mul_mul_mul_comm, ← mul_pow, eq2,\n      mul_comm a.1, mul_pow, mul_mul_mul_comm, ← pow_add]\n  have ⟨c, eq1⟩ := (mem_span_range_iff_exists_fun _).mp <|\n    (Ideal.eq_top_iff_one _).mp <| (Set.image_eq_range _ _ ▸ Ideal.span_pow_eq_top _ span_eq N)\n  refine ⟨∑ b, c b * r b, fun a ↦ ((Away.algebraMap_isUnit a.1).pow N).mul_left_inj.mp ?_⟩\n  simp_rw [← map_pow, eq, ← map_mul, Finset.sum_mul, mul_assoc, eq2 _ a, mul_left_comm (c _),\n    ← Finset.mul_sum, ← smul_eq_mul (a := c _), eq1, mul_one]\n\n"}
{"name":"selfZPow_of_nonneg","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nn : Int\nhn : LE.le 0 n\n⊢ Eq (selfZPow x B n) (HPow.hPow ((algebraMap R B) x) n.natAbs)","decl":"theorem selfZPow_of_nonneg {n : ℤ} (hn : 0 ≤ n) : selfZPow x B n = algebraMap R B x ^ n.natAbs :=\n  dif_pos hn\n\n"}
{"name":"selfZPow_natCast","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nd : Nat\n⊢ Eq (selfZPow x B ↑d) (HPow.hPow ((algebraMap R B) x) d)","decl":"@[simp]\ntheorem selfZPow_natCast (d : ℕ) : selfZPow x B d = algebraMap R B x ^ d :=\n  selfZPow_of_nonneg _ _ (Int.natCast_nonneg d)\n\n"}
{"name":"selfZPow_zero","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\n⊢ Eq (selfZPow x B 0) 1","decl":"@[simp]\ntheorem selfZPow_zero : selfZPow x B 0 = 1 := by\n  simp [selfZPow_of_nonneg _ _ le_rfl]\n\n"}
{"name":"selfZPow_of_neg","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nn : Int\nhn : LT.lt n 0\n⊢ Eq (selfZPow x B n) (IsLocalization.mk' B 1 (Submonoid.pow x n.natAbs))","decl":"theorem selfZPow_of_neg {n : ℤ} (hn : n < 0) :\n    selfZPow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) :=\n  dif_neg hn.not_le\n\n"}
{"name":"selfZPow_of_nonpos","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nn : Int\nhn : LE.le n 0\n⊢ Eq (selfZPow x B n) (IsLocalization.mk' B 1 (Submonoid.pow x n.natAbs))","decl":"theorem selfZPow_of_nonpos {n : ℤ} (hn : n ≤ 0) :\n    selfZPow x B n = mk' _ (1 : R) (Submonoid.pow x n.natAbs) := by\n  by_cases hn0 : n = 0\n  · simp [hn0, selfZPow_zero, Submonoid.pow_apply]\n  · simp [selfZPow_of_neg _ _ (lt_of_le_of_ne hn hn0)]\n\n"}
{"name":"selfZPow_neg_natCast","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nd : Nat\n⊢ Eq (selfZPow x B (Neg.neg ↑d)) (IsLocalization.mk' B 1 (Submonoid.pow x d))","decl":"@[simp]\ntheorem selfZPow_neg_natCast (d : ℕ) : selfZPow x B (-d) = mk' _ (1 : R) (Submonoid.pow x d) := by\n  simp [selfZPow_of_nonpos _ _ (neg_nonpos.mpr (Int.natCast_nonneg d))]\n\n"}
{"name":"selfZPow_sub_natCast","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nn m : Nat\n⊢ Eq (selfZPow x B (HSub.hSub ↑n ↑m)) (IsLocalization.mk' B (HPow.hPow x n) (Submonoid.pow x m))","decl":"@[simp]\ntheorem selfZPow_sub_natCast {n m : ℕ} :\n    selfZPow x B (n - m) = mk' _ (x ^ n) (Submonoid.pow x m) := by\n  by_cases h : m ≤ n\n  · rw [IsLocalization.eq_mk'_iff_mul_eq, Submonoid.pow_apply, Subtype.coe_mk, ← Int.ofNat_sub h,\n      selfZPow_natCast, ← map_pow, ← map_mul, ← pow_add, Nat.sub_add_cancel h]\n  · rw [← neg_sub, ← Int.ofNat_sub (le_of_not_le h), selfZPow_neg_natCast,\n      IsLocalization.mk'_eq_iff_eq]\n    simp [Submonoid.pow_apply, ← pow_add, Nat.sub_add_cancel (le_of_not_le h)]\n\n"}
{"name":"selfZPow_add","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nn m : Int\n⊢ Eq (selfZPow x B (HAdd.hAdd n m)) (HMul.hMul (selfZPow x B n) (selfZPow x B m))","decl":"@[simp]\ntheorem selfZPow_add {n m : ℤ} : selfZPow x B (n + m) = selfZPow x B n * selfZPow x B m := by\n  rcases le_or_lt 0 n with hn | hn <;> rcases le_or_lt 0 m with hm | hm\n  · rw [selfZPow_of_nonneg _ _ hn, selfZPow_of_nonneg _ _ hm,\n      selfZPow_of_nonneg _ _ (add_nonneg hn hm), Int.natAbs_add_of_nonneg hn hm, pow_add]\n  · have : n + m = n.natAbs - m.natAbs := by\n      rw [Int.natAbs_of_nonneg hn, Int.ofNat_natAbs_of_nonpos hm.le, sub_neg_eq_add]\n    rw [selfZPow_of_nonneg _ _ hn, selfZPow_of_neg _ _ hm, this, selfZPow_sub_natCast,\n      IsLocalization.mk'_eq_mul_mk'_one, map_pow]\n  · have : n + m = m.natAbs - n.natAbs := by\n      rw [Int.natAbs_of_nonneg hm, Int.ofNat_natAbs_of_nonpos hn.le, sub_neg_eq_add, add_comm]\n    rw [selfZPow_of_nonneg _ _ hm, selfZPow_of_neg _ _ hn, this, selfZPow_sub_natCast,\n      IsLocalization.mk'_eq_mul_mk'_one, map_pow, mul_comm]\n  · rw [selfZPow_of_neg _ _ hn, selfZPow_of_neg _ _ hm, selfZPow_of_neg _ _ (add_neg hn hm),\n      Int.natAbs_add_of_nonpos hn.le hm.le, ← mk'_mul, one_mul]\n    congr\n    ext\n    simp [pow_add]\n\n"}
{"name":"selfZPow_mul_neg","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nd : Int\n⊢ Eq (HMul.hMul (selfZPow x B d) (selfZPow x B (Neg.neg d))) 1","decl":"theorem selfZPow_mul_neg (d : ℤ) : selfZPow x B d * selfZPow x B (-d) = 1 := by\n  by_cases hd : d ≤ 0\n  · erw [selfZPow_of_nonpos x B hd, selfZPow_of_nonneg, ← map_pow, Int.natAbs_neg,\n      IsLocalization.mk'_spec, map_one]\n    apply nonneg_of_neg_nonpos\n    rwa [neg_neg]\n  · erw [selfZPow_of_nonneg x B (le_of_not_le hd), selfZPow_of_nonpos, ← map_pow, Int.natAbs_neg,\n      @IsLocalization.mk'_spec' R _ (Submonoid.powers x) B _ _ _ 1 (Submonoid.pow x d.natAbs),\n      map_one]\n    refine nonpos_of_neg_nonneg (le_of_lt ?_)\n    rwa [neg_neg, ← not_le]\n\n"}
{"name":"selfZPow_neg_mul","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\nd : Int\n⊢ Eq (HMul.hMul (selfZPow x B (Neg.neg d)) (selfZPow x B d)) 1","decl":"theorem selfZPow_neg_mul (d : ℤ) : selfZPow x B (-d) * selfZPow x B d = 1 := by\n  rw [mul_comm, selfZPow_mul_neg x B d]\n\n"}
{"name":"selfZPow_pow_sub","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nx : R\nB : Type u_2\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : IsLocalization.Away x B\na : R\nb : B\nm d : Int\n⊢ Iff (Eq (HMul.hMul (selfZPow x B (HSub.hSub m d)) (IsLocalization.mk' B a 1)) b) (Eq (HMul.hMul (selfZPow x B m) (IsLocalization.mk' B a 1)) (HMul.hMul (selfZPow x B d) b))","decl":"theorem selfZPow_pow_sub (a : R) (b : B) (m d : ℤ) :\n    selfZPow x B (m - d) * mk' B a (1 : Submonoid.powers x) = b ↔\n      selfZPow x B m * mk' B a (1 : Submonoid.powers x) = selfZPow x B d * b := by\n  rw [sub_eq_add_neg, selfZPow_add, mul_assoc, mul_comm _ (mk' B a 1), ← mul_assoc]\n  constructor\n  · intro h\n    have := congr_arg (fun s : B => s * selfZPow x B d) h\n    simp only at this\n    rwa [mul_assoc, mul_assoc, selfZPow_neg_mul, mul_one, mul_comm b _] at this\n  · intro h\n    have := congr_arg (fun s : B => s * selfZPow x B (-d)) h\n    simp only at this\n    rwa [mul_comm _ b, mul_assoc b _ _, selfZPow_mul_neg, mul_one] at this\n\n"}
{"name":"exists_reduced_fraction'","module":"Mathlib.RingTheory.Localization.Away.Basic","initialProofState":"R : Type u_3\ninst✝⁵ : CommRing R\nx : R\nB : Type u_4\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\ninst✝² : IsLocalization.Away x B\ninst✝¹ : IsDomain R\ninst✝ : WfDvdMonoid R\nb : B\nhb : Ne b 0\nhx : Irreducible x\n⊢ Exists fun a => Exists fun n => And (Not (Dvd.dvd x a)) (Eq (HMul.hMul (selfZPow x B n) ((algebraMap R B) a)) b)","decl":"theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :\n    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b := by\n  obtain ⟨⟨a₀, y⟩, H⟩ := surj (Submonoid.powers x) b\n  obtain ⟨d, hy⟩ := (Submonoid.mem_powers_iff y.1 x).mp y.2\n  have ha₀ : a₀ ≠ 0 := by\n    haveI :=\n      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _\n        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n    simp only [map_zero, ← hy, map_pow] at H\n    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a₀).mpr.mt\n    · rw [← H]\n      apply mul_ne_zero hb (pow_ne_zero _ _)\n      exact\n        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B\n          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)\n    · exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)\n  simp only [← hy] at H\n  obtain ⟨m, a, hyp1, hyp2⟩ := WfDvdMonoid.max_power_factor ha₀ hx\n  refine ⟨a, m - d, ?_⟩\n  rw [← mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,\n    ← map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]\n  exact ⟨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)⟩\n\n"}
