{"name":"DirectSum.GAlgebra.commutes","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nself : DirectSum.GAlgebra R A\nr : R\nx : GradedMonoid A\n⊢ Eq (HMul.hMul (GradedMonoid.mk 0 (DirectSum.GAlgebra.toFun r)) x) (HMul.hMul x (GradedMonoid.mk 0 (DirectSum.GAlgebra.toFun r)))","decl":"/-- A graded version of `Algebra`. An instance of `DirectSum.GAlgebra R A` endows `(⨁ i, A i)`\nwith an `R`-algebra structure. -/\nclass GAlgebra where\n  toFun : R →+ A 0\n  map_one : toFun 1 = GradedMonoid.GOne.one\n  map_mul :\n    ∀ r s, GradedMonoid.mk _ (toFun (r * s)) = .mk _ (GradedMonoid.GMul.mul (toFun r) (toFun s))\n  commutes : ∀ (r) (x : GradedMonoid A), .mk _ (toFun r) * x = x * .mk _ (toFun r)\n  smul_def : ∀ (r) (x : GradedMonoid A), r • x = .mk _ (toFun r) * x\n\n"}
{"name":"DirectSum.GAlgebra.smul_def","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nself : DirectSum.GAlgebra R A\nr : R\nx : GradedMonoid A\n⊢ Eq (HSMul.hSMul r x) (HMul.hMul (GradedMonoid.mk 0 (DirectSum.GAlgebra.toFun r)) x)","decl":"/-- A graded version of `Algebra`. An instance of `DirectSum.GAlgebra R A` endows `(⨁ i, A i)`\nwith an `R`-algebra structure. -/\nclass GAlgebra where\n  toFun : R →+ A 0\n  map_one : toFun 1 = GradedMonoid.GOne.one\n  map_mul :\n    ∀ r s, GradedMonoid.mk _ (toFun (r * s)) = .mk _ (GradedMonoid.GMul.mul (toFun r) (toFun s))\n  commutes : ∀ (r) (x : GradedMonoid A), .mk _ (toFun r) * x = x * .mk _ (toFun r)\n  smul_def : ∀ (r) (x : GradedMonoid A), r • x = .mk _ (toFun r) * x\n\n"}
{"name":"DirectSum.GAlgebra.map_mul","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nself : DirectSum.GAlgebra R A\nr s : R\n⊢ Eq (GradedMonoid.mk 0 (DirectSum.GAlgebra.toFun (HMul.hMul r s))) (GradedMonoid.mk (HAdd.hAdd 0 0) (GradedMonoid.GMul.mul (DirectSum.GAlgebra.toFun r) (DirectSum.GAlgebra.toFun s)))","decl":"/-- A graded version of `Algebra`. An instance of `DirectSum.GAlgebra R A` endows `(⨁ i, A i)`\nwith an `R`-algebra structure. -/\nclass GAlgebra where\n  toFun : R →+ A 0\n  map_one : toFun 1 = GradedMonoid.GOne.one\n  map_mul :\n    ∀ r s, GradedMonoid.mk _ (toFun (r * s)) = .mk _ (GradedMonoid.GMul.mul (toFun r) (toFun s))\n  commutes : ∀ (r) (x : GradedMonoid A), .mk _ (toFun r) * x = x * .mk _ (toFun r)\n  smul_def : ∀ (r) (x : GradedMonoid A), r • x = .mk _ (toFun r) * x\n\n"}
{"name":"DirectSum.GAlgebra.map_one","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nself : DirectSum.GAlgebra R A\n⊢ Eq (DirectSum.GAlgebra.toFun 1) GradedMonoid.GOne.one","decl":"/-- A graded version of `Algebra`. An instance of `DirectSum.GAlgebra R A` endows `(⨁ i, A i)`\nwith an `R`-algebra structure. -/\nclass GAlgebra where\n  toFun : R →+ A 0\n  map_one : toFun 1 = GradedMonoid.GOne.one\n  map_mul :\n    ∀ r s, GradedMonoid.mk _ (toFun (r * s)) = .mk _ (GradedMonoid.GMul.mul (toFun r) (toFun s))\n  commutes : ∀ (r) (x : GradedMonoid A), .mk _ (toFun r) * x = x * .mk _ (toFun r)\n  smul_def : ∀ (r) (x : GradedMonoid A), r • x = .mk _ (toFun r) * x\n\n"}
{"name":"GradedMonoid.smulCommClass_right","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\n⊢ SMulCommClass R (GradedMonoid A) (GradedMonoid A)","decl":"instance _root_.GradedMonoid.smulCommClass_right :\n    SMulCommClass R (GradedMonoid A) (GradedMonoid A) where\n  smul_comm s x y := by\n    dsimp\n    rw [GAlgebra.smul_def, GAlgebra.smul_def, ← mul_assoc, GAlgebra.commutes, mul_assoc]\n\n"}
{"name":"GradedMonoid.isScalarTower_right","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\n⊢ IsScalarTower R (GradedMonoid A) (GradedMonoid A)","decl":"instance _root_.GradedMonoid.isScalarTower_right :\n    IsScalarTower R (GradedMonoid A) (GradedMonoid A) where\n  smul_assoc s x y := by\n    dsimp\n    rw [GAlgebra.smul_def, GAlgebra.smul_def, ← mul_assoc]\n\n"}
{"name":"DirectSum.algebraMap_apply","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (A i)\ninst✝⁴ : (i : ι) → Module R (A i)\ninst✝³ : AddMonoid ι\ninst✝² : DirectSum.GSemiring A\ninst✝¹ : DirectSum.GAlgebra R A\ninst✝ : DecidableEq ι\nr : R\n⊢ Eq ((algebraMap R (DirectSum ι fun i => A i)) r) ((DirectSum.of A 0) (DirectSum.GAlgebra.toFun r))","decl":"theorem algebraMap_apply (r : R) :\n    algebraMap R (⨁ i, A i) r = DirectSum.of A 0 (GAlgebra.toFun r) :=\n  rfl\n\n"}
{"name":"DirectSum.algebraMap_toAddMonoid_hom","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (A i)\ninst✝⁴ : (i : ι) → Module R (A i)\ninst✝³ : AddMonoid ι\ninst✝² : DirectSum.GSemiring A\ninst✝¹ : DirectSum.GAlgebra R A\ninst✝ : DecidableEq ι\n⊢ Eq (↑(algebraMap R (DirectSum ι fun i => A i))) ((DirectSum.of A 0).comp DirectSum.GAlgebra.toFun)","decl":"theorem algebraMap_toAddMonoid_hom :\n    ↑(algebraMap R (⨁ i, A i)) = (DirectSum.of A 0).comp (GAlgebra.toFun : R →+ A 0) :=\n  rfl\n\n"}
{"name":"DirectSum.toAlgebra_apply","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (A i)\ninst✝⁶ : (i : ι) → Module R (A i)\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : DirectSum.GSemiring A\ninst✝³ : Semiring B\ninst✝² : DirectSum.GAlgebra R A\ninst✝¹ : Algebra R B\ninst✝ : DecidableEq ι\nf : (i : ι) → LinearMap (RingHom.id R) (A i) B\nhone : Eq ((f 0) GradedMonoid.GOne.one) 1\nhmul : ∀ {i j : ι} (ai : A i) (aj : A j), Eq ((f (HAdd.hAdd i j)) (GradedMonoid.GMul.mul ai aj)) (HMul.hMul ((f i) ai) ((f j) aj))\na : DirectSum ι fun i => A i\n⊢ Eq ((DirectSum.toAlgebra R A f hone hmul) a) ((DirectSum.toSemiring (fun i => (f i).toAddMonoidHom) hone hmul) a)","decl":"/-- A family of `LinearMap`s preserving `DirectSum.GOne.one` and `DirectSum.GMul.mul`\ndescribes an `AlgHom` on `⨁ i, A i`. This is a stronger version of `DirectSum.toSemiring`.\n\nOf particular interest is the case when `A i` are bundled subojects, `f` is the family of\ncoercions such as `Submodule.subtype (A i)`, and the `[GMonoid A]` structure originates from\n`DirectSum.GMonoid.ofAddSubmodules`, in which case the proofs about `GOne` and `GMul`\ncan be discharged by `rfl`. -/\n@[simps]\ndef toAlgebra (f : ∀ i, A i →ₗ[R] B) (hone : f _ GradedMonoid.GOne.one = 1)\n    (hmul : ∀ {i j} (ai : A i) (aj : A j), f _ (GradedMonoid.GMul.mul ai aj) = f _ ai * f _ aj) :\n    (⨁ i, A i) →ₐ[R] B :=\n  { toSemiring (fun i => (f i).toAddMonoidHom) hone @hmul with\n    toFun := toSemiring (fun i => (f i).toAddMonoidHom) hone @hmul\n    commutes' := fun r => by\n      show toModule R _ _ f (algebraMap R _ r) = _\n      rw [Algebra.algebraMap_eq_smul_one, Algebra.algebraMap_eq_smul_one, map_smul, one_def,\n        ← lof_eq_of R, toModule_lof, hone] }\n\n"}
{"name":"DirectSum.algHom_ext'_iff","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (A i)\ninst✝⁶ : (i : ι) → Module R (A i)\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : DirectSum.GSemiring A\ninst✝³ : Semiring B\ninst✝² : DirectSum.GAlgebra R A\ninst✝¹ : Algebra R B\ninst✝ : DecidableEq ι\nf g : AlgHom R (DirectSum ι fun i => A i) B\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.toLinearMap.comp (DirectSum.lof R ι A i)) (g.toLinearMap.comp (DirectSum.lof R ι A i)))","decl":"/-- Two `AlgHom`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem algHom_ext' ⦃f g : (⨁ i, A i) →ₐ[R] B⦄\n    (h : ∀ i, f.toLinearMap.comp (lof _ _ A i) = g.toLinearMap.comp (lof _ _ A i)) : f = g :=\n  AlgHom.toLinearMap_injective <| DirectSum.linearMap_ext _ h\n\n"}
{"name":"DirectSum.algHom_ext'","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (A i)\ninst✝⁶ : (i : ι) → Module R (A i)\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : DirectSum.GSemiring A\ninst✝³ : Semiring B\ninst✝² : DirectSum.GAlgebra R A\ninst✝¹ : Algebra R B\ninst✝ : DecidableEq ι\nf g : AlgHom R (DirectSum ι fun i => A i) B\nh : ∀ (i : ι), Eq (f.toLinearMap.comp (DirectSum.lof R ι A i)) (g.toLinearMap.comp (DirectSum.lof R ι A i))\n⊢ Eq f g","decl":"/-- Two `AlgHom`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem algHom_ext' ⦃f g : (⨁ i, A i) →ₐ[R] B⦄\n    (h : ∀ i, f.toLinearMap.comp (lof _ _ A i) = g.toLinearMap.comp (lof _ _ A i)) : f = g :=\n  AlgHom.toLinearMap_injective <| DirectSum.linearMap_ext _ h\n\n"}
{"name":"DirectSum.algHom_ext","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (A i)\ninst✝⁶ : (i : ι) → Module R (A i)\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : DirectSum.GSemiring A\ninst✝³ : Semiring B\ninst✝² : DirectSum.GAlgebra R A\ninst✝¹ : Algebra R B\ninst✝ : DecidableEq ι\nf g : AlgHom R (DirectSum ι fun i => A i) B\nh : ∀ (i : ι) (x : A i), Eq (f ((DirectSum.of A i) x)) (g ((DirectSum.of A i) x))\n⊢ Eq f g","decl":"theorem algHom_ext ⦃f g : (⨁ i, A i) →ₐ[R] B⦄ (h : ∀ i x, f (of A i x) = g (of A i x)) : f = g :=\n  algHom_ext' R A fun i => LinearMap.ext <| h i\n\n"}
{"name":"DirectSum.gMulLHom_apply_apply","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type uR\nA : ι → Type uA\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\ni j : ι\na : A i\nb : A j\n⊢ Eq (((DirectSum.gMulLHom R A) a) b) (GradedMonoid.GMul.mul a b)","decl":"/-- The piecewise multiplication from the `Mul` instance, as a bundled linear map.\n\nThis is the graded version of `LinearMap.mul`, and the linear version of `DirectSum.gMulHom` -/\n@[simps]\ndef gMulLHom {i j} : A i →ₗ[R] A j →ₗ[R] A (i + j) where\n  toFun a :=\n    { toFun := fun b => GradedMonoid.GMul.mul a b\n      map_smul' := fun r x => by\n        injection (smul_comm r (GradedMonoid.mk _ a) (GradedMonoid.mk _ x)).symm\n      map_add' := GNonUnitalNonAssocSemiring.mul_add _ }\n  map_smul' r x := LinearMap.ext fun y => by\n    injection smul_assoc r (GradedMonoid.mk _ x) (GradedMonoid.mk _ y)\n  map_add' _ _ := LinearMap.ext fun _ => GNonUnitalNonAssocSemiring.add_mul _ _ _\n\n"}
{"name":"Algebra.directSumGAlgebra_toFun_apply","module":"Mathlib.Algebra.DirectSum.Algebra","initialProofState":"ι : Type uι\nR : Type u_1\nA : Type u_2\ninst✝³ : AddMonoid ι\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na✝ : R\n⊢ Eq (DirectSum.GAlgebra.toFun a✝) ((↑↑(algebraMap R A)).toFun a✝)","decl":"/-- A direct sum of copies of an `Algebra` inherits the algebra structure.\n\n-/\n@[simps]\ninstance Algebra.directSumGAlgebra {R A : Type*} [AddMonoid ι] [CommSemiring R]\n    [Semiring A] [Algebra R A] : DirectSum.GAlgebra R fun _ : ι => A where\n  toFun := (algebraMap R A).toAddMonoidHom\n  map_one := (algebraMap R A).map_one\n  map_mul a b := Sigma.ext (zero_add _).symm (heq_of_eq <| (algebraMap R A).map_mul a b)\n  commutes := fun _ ⟨_, _⟩ =>\n    Sigma.ext ((zero_add _).trans (add_zero _).symm) (heq_of_eq <| Algebra.commutes _ _)\n  smul_def := fun _ ⟨_, _⟩ => Sigma.ext (zero_add _).symm (heq_of_eq <| Algebra.smul_def _ _)\n"}
