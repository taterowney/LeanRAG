{"name":"RootPairing.equiv_of_mapsTo_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nroot : Function.Embedding ι M\ncoroot : Function.Embedding ι N\ni : ι\nh : ∀ (i : ι), Set.MapsTo (⇑(Module.preReflection (root i) (p.toLin.flip (coroot i)))) (Set.range ⇑root) (Set.range ⇑root)\nhp : ∀ (i : ι), Eq ((p.toLin (root i)) (coroot i)) 2\nj : ι\n⊢ Eq ((RootPairing.equiv_of_mapsTo p root coroot i h hp).symm j) ⋯.choose","decl":"/-- The bijection on the indexing set induced by reflection. -/\n@[simps]\nprotected def equiv_of_mapsTo :\n    ι ≃ ι where\n  toFun j := (exist_eq_reflection_of_mapsTo p root coroot i j h).choose\n  invFun j := (exist_eq_reflection_of_mapsTo p root coroot i j h).choose\n  left_inv j := choose_choose_eq_of_mapsTo p root coroot i j h hp\n  right_inv j := choose_choose_eq_of_mapsTo p root coroot i j h hp\n\n"}
{"name":"RootPairing.equiv_of_mapsTo_apply","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nroot : Function.Embedding ι M\ncoroot : Function.Embedding ι N\ni : ι\nh : ∀ (i : ι), Set.MapsTo (⇑(Module.preReflection (root i) (p.toLin.flip (coroot i)))) (Set.range ⇑root) (Set.range ⇑root)\nhp : ∀ (i : ι), Eq ((p.toLin (root i)) (coroot i)) 2\nj : ι\n⊢ Eq ((RootPairing.equiv_of_mapsTo p root coroot i h hp) j) ⋯.choose","decl":"/-- The bijection on the indexing set induced by reflection. -/\n@[simps]\nprotected def equiv_of_mapsTo :\n    ι ≃ ι where\n  toFun j := (exist_eq_reflection_of_mapsTo p root coroot i j h).choose\n  invFun j := (exist_eq_reflection_of_mapsTo p root coroot i j h).choose\n  left_inv j := choose_choose_eq_of_mapsTo p root coroot i j h hp\n  right_inv j := choose_choose_eq_of_mapsTo p root coroot i j h hp\n\n"}
{"name":"RootPairing.infinite_of_linearIndependent_coxeterWeight_four","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors Int M\nP : RootPairing ι R M N\ni j : ι\nhl : LinearIndependent R (Matrix.vecCons (P.root i) (Matrix.vecCons (P.root j) Matrix.vecEmpty))\nhc : Eq (P.coxeterWeight i j) 4\n⊢ Infinite ι","decl":"lemma infinite_of_linearIndependent_coxeterWeight_four [CharZero R] [NoZeroSMulDivisors ℤ M]\n    (P : RootPairing ι R M N) (i j : ι) (hl : LinearIndependent R ![P.root i, P.root j])\n    (hc : P.coxeterWeight i j = 4) : Infinite ι := by\n  refine (infinite_range_iff (Embedding.injective P.root)).mp (Infinite.mono ?_\n    ((infinite_range_reflection_reflection_iterate_iff (P.coroot_root_two i)\n    (P.coroot_root_two j) ?_).mpr ?_))\n  · rw [range_subset_iff]\n    intro n\n    rw [← IsFixedPt.image_iterate ((bijOn_reflection_of_mapsTo (P.coroot_root_two i)\n      (P.mapsTo_reflection_root i)).comp (bijOn_reflection_of_mapsTo (P.coroot_root_two j)\n      (P.mapsTo_reflection_root j))).image_eq n]\n    exact mem_image_of_mem _ (mem_range_self j)\n  · rw [coroot_root_eq_pairing, coroot_root_eq_pairing, ← hc, mul_comm, coxeterWeight]\n  · rw [LinearIndependent.pair_iff] at hl\n    specialize hl (P.pairing j i) (-2)\n    simp only [neg_smul, neg_eq_zero, OfNat.ofNat_ne_zero, and_false, imp_false] at hl\n    rw [ne_eq, coroot_root_eq_pairing, ← sub_eq_zero, sub_eq_add_neg]\n    exact hl\n\n"}
{"name":"RootPairing.coxeterWeight_ne_four_of_linearIndependent","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Finite ι\nP : RootPairing ι R M N\ni j : ι\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors Int M\nhl : LinearIndependent R (Matrix.vecCons (P.root i) (Matrix.vecCons (P.root j) Matrix.vecEmpty))\n⊢ Ne (P.coxeterWeight i j) 4","decl":"lemma coxeterWeight_ne_four_of_linearIndependent [CharZero R] [NoZeroSMulDivisors ℤ M]\n    (hl : LinearIndependent R ![P.root i, P.root j]) :\n    P.coxeterWeight i j ≠ 4 := by\n  intro contra\n  have := P.infinite_of_linearIndependent_coxeterWeight_four i j hl contra\n  exact not_finite ι\n\n"}
{"name":"RootPairing.injOn_dualMap_subtype_span_root_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Finite ι\nP : RootPairing ι R M N\ninst✝ : NoZeroSMulDivisors Int M\n⊢ Set.InjOn (⇑((Submodule.span R (Set.range ⇑P.root)).subtype.dualMap.comp P.toLin.flip)) (Set.range ⇑P.coroot)","decl":"/-- Even though the roots may not span, coroots are distinguished by their pairing with the\nroots. The proof depends crucially on the fact that there are finitely-many roots.\n\nModulo trivial generalisations, this statement is exactly Lemma 1.1.4 on page 87 of SGA 3 XXI. -/\nlemma injOn_dualMap_subtype_span_root_coroot [NoZeroSMulDivisors ℤ M] :\n    InjOn ((span R (range P.root)).subtype.dualMap ∘ₗ P.toLin.flip) (range P.coroot) := by\n  have := injOn_dualMap_subtype_span_range_range (finite_range P.root)\n    (c := P.toLin.flip ∘ P.coroot) P.root_coroot_two P.mapsTo_reflection_root\n  rintro - ⟨i, rfl⟩ - ⟨j, rfl⟩ hij\n  exact P.bijectiveRight.injective <| this (mem_range_self i) (mem_range_self j) hij\n\n"}
{"name":"RootPairing.ext_iff","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nP₁ P₂ : RootPairing ι R M N\n⊢ Iff (Eq P₁ P₂) (And (Eq P₁.toPerfectPairing P₂.toPerfectPairing) (And (Eq P₁.root P₂.root) (Eq (Set.range ⇑P₁.coroot) (Set.range ⇑P₂.coroot))))","decl":"/-- In characteristic zero if there is no torsion, the correspondence between roots and coroots is\nunique.\n\nFormally, the point is that the hypothesis `hc` depends only on the range of the coroot mappings. -/\n@[ext]\nprotected lemma ext [CharZero R] [NoZeroSMulDivisors R M]\n    {P₁ P₂ : RootPairing ι R M N}\n    (he : P₁.toPerfectPairing = P₂.toPerfectPairing)\n    (hr : P₁.root = P₂.root)\n    (hc : range P₁.coroot = range P₂.coroot) :\n    P₁ = P₂ := by\n  have hp (hc' : P₁.coroot = P₂.coroot) : P₁.reflection_perm = P₂.reflection_perm := by\n    ext i j\n    refine P₁.root.injective ?_\n    conv_rhs => rw [hr]\n    simp only [root_reflection_perm, reflection_apply, coroot']\n    simp only [hr, he, hc']\n  suffices P₁.coroot = P₂.coroot by\n    cases' P₁ with p₁; cases' P₂ with p₂; cases p₁; cases p₂; congr; exact hp this\n  have := NoZeroSMulDivisors.int_of_charZero R M\n  ext i\n  apply P₁.injOn_dualMap_subtype_span_root_coroot (mem_range_self i) (hc ▸ mem_range_self i)\n  simp only [LinearMap.coe_comp, LinearEquiv.coe_coe, comp_apply]\n  apply Dual.eq_of_preReflection_mapsTo' (finite_range P₁.root)\n  · exact Submodule.subset_span (mem_range_self i)\n  · exact P₁.coroot_root_two i\n  · exact P₁.mapsTo_reflection_root i\n  · exact hr ▸ he ▸ P₂.coroot_root_two i\n  · exact hr ▸ he ▸ P₂.mapsTo_reflection_root i\n\n"}
{"name":"RootPairing.ext","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nP₁ P₂ : RootPairing ι R M N\nhe : Eq P₁.toPerfectPairing P₂.toPerfectPairing\nhr : Eq P₁.root P₂.root\nhc : Eq (Set.range ⇑P₁.coroot) (Set.range ⇑P₂.coroot)\n⊢ Eq P₁ P₂","decl":"/-- In characteristic zero if there is no torsion, the correspondence between roots and coroots is\nunique.\n\nFormally, the point is that the hypothesis `hc` depends only on the range of the coroot mappings. -/\n@[ext]\nprotected lemma ext [CharZero R] [NoZeroSMulDivisors R M]\n    {P₁ P₂ : RootPairing ι R M N}\n    (he : P₁.toPerfectPairing = P₂.toPerfectPairing)\n    (hr : P₁.root = P₂.root)\n    (hc : range P₁.coroot = range P₂.coroot) :\n    P₁ = P₂ := by\n  have hp (hc' : P₁.coroot = P₂.coroot) : P₁.reflection_perm = P₂.reflection_perm := by\n    ext i j\n    refine P₁.root.injective ?_\n    conv_rhs => rw [hr]\n    simp only [root_reflection_perm, reflection_apply, coroot']\n    simp only [hr, he, hc']\n  suffices P₁.coroot = P₂.coroot by\n    cases' P₁ with p₁; cases' P₂ with p₂; cases p₁; cases p₂; congr; exact hp this\n  have := NoZeroSMulDivisors.int_of_charZero R M\n  ext i\n  apply P₁.injOn_dualMap_subtype_span_root_coroot (mem_range_self i) (hc ▸ mem_range_self i)\n  simp only [LinearMap.coe_comp, LinearEquiv.coe_coe, comp_apply]\n  apply Dual.eq_of_preReflection_mapsTo' (finite_range P₁.root)\n  · exact Submodule.subset_span (mem_range_self i)\n  · exact P₁.coroot_root_two i\n  · exact P₁.mapsTo_reflection_root i\n  · exact hr ▸ he ▸ P₂.coroot_root_two i\n  · exact hr ▸ he ▸ P₂.mapsTo_reflection_root i\n\n"}
{"name":"RootSystem.ext","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nP₁ P₂ : RootSystem ι R M N\nhe : Eq P₁.toPerfectPairing P₂.toPerfectPairing\nhr : Eq P₁.root P₂.root\n⊢ Eq P₁ P₂","decl":"/-- In characteristic zero if there is no torsion, a finite root system is determined entirely by\nits roots. -/\n@[ext]\nprotected lemma ext [CharZero R] [NoZeroSMulDivisors R M]\n    {P₁ P₂ : RootSystem ι R M N}\n    (he : P₁.toPerfectPairing = P₂.toPerfectPairing)\n    (hr : P₁.root = P₂.root) :\n    P₁ = P₂ := by\n  suffices ∀ P₁ P₂ : RootSystem ι R M N, P₁.toPerfectPairing = P₂.toPerfectPairing →\n      P₁.root = P₂.root → range P₁.coroot ⊆ range P₂.coroot by\n    have h₁ := this P₁ P₂ he hr\n    have h₂ := this P₂ P₁ he.symm hr.symm\n    cases' P₁ with P₁\n    cases' P₂ with P₂\n    congr\n    exact RootPairing.ext he hr (le_antisymm h₁ h₂)\n  clear! P₁ P₂\n  rintro P₁ P₂ he hr - ⟨i, rfl⟩\n  use i\n  apply P₁.bijectiveRight.injective\n  apply Dual.eq_of_preReflection_mapsTo (finite_range P₁.root) P₁.span_root_eq_top\n  · exact hr ▸ he ▸ P₂.coroot_root_two i\n  · exact hr ▸ he ▸ P₂.mapsTo_reflection_root i\n  · exact P₁.coroot_root_two i\n  · exact P₁.mapsTo_reflection_root i\n\n"}
{"name":"RootSystem.ext_iff","module":"Mathlib.LinearAlgebra.RootSystem.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nP₁ P₂ : RootSystem ι R M N\n⊢ Iff (Eq P₁ P₂) (And (Eq P₁.toPerfectPairing P₂.toPerfectPairing) (Eq P₁.root P₂.root))","decl":"/-- In characteristic zero if there is no torsion, a finite root system is determined entirely by\nits roots. -/\n@[ext]\nprotected lemma ext [CharZero R] [NoZeroSMulDivisors R M]\n    {P₁ P₂ : RootSystem ι R M N}\n    (he : P₁.toPerfectPairing = P₂.toPerfectPairing)\n    (hr : P₁.root = P₂.root) :\n    P₁ = P₂ := by\n  suffices ∀ P₁ P₂ : RootSystem ι R M N, P₁.toPerfectPairing = P₂.toPerfectPairing →\n      P₁.root = P₂.root → range P₁.coroot ⊆ range P₂.coroot by\n    have h₁ := this P₁ P₂ he hr\n    have h₂ := this P₂ P₁ he.symm hr.symm\n    cases' P₁ with P₁\n    cases' P₂ with P₂\n    congr\n    exact RootPairing.ext he hr (le_antisymm h₁ h₂)\n  clear! P₁ P₂\n  rintro P₁ P₂ he hr - ⟨i, rfl⟩\n  use i\n  apply P₁.bijectiveRight.injective\n  apply Dual.eq_of_preReflection_mapsTo (finite_range P₁.root) P₁.span_root_eq_top\n  · exact hr ▸ he ▸ P₂.coroot_root_two i\n  · exact hr ▸ he ▸ P₂.mapsTo_reflection_root i\n  · exact P₁.coroot_root_two i\n  · exact P₁.mapsTo_reflection_root i\n\n"}
