{"name":"CategoryTheory.Over.hasColimit_of_hasColimit_comp_forget","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"J : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nF : CategoryTheory.Functor J (CategoryTheory.Over X)\ni : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.Over.forget X))\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit_of_hasColimit_comp_forget (F : J ⥤ Over X) [i : HasColimit (F ⋙ forget X)] :\n    HasColimit F :=\n  CostructuredArrow.hasColimit (i₁ := i)\n\n"}
{"name":"CategoryTheory.Over.instHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.Over X)","decl":"instance [HasColimitsOfShape J C] : HasColimitsOfShape J (Over X) where\n\n"}
{"name":"CategoryTheory.Over.instHasColimits","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.Over X)","decl":"instance [HasColimits C] : HasColimits (Over X) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.Over.epi_left_of_epi","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nf g : CategoryTheory.Over X\nh : Quiver.Hom f g\ninst✝ : CategoryTheory.Epi h\n⊢ CategoryTheory.Epi h.left","decl":"theorem epi_left_of_epi [HasPushouts C] {f g : Over X} (h : f ⟶ g) [Epi h] : Epi h.left :=\n  CostructuredArrow.epi_left_of_epi _\n\n"}
{"name":"CategoryTheory.Over.epi_iff_epi_left","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nf g : CategoryTheory.Over X\nh : Quiver.Hom f g\n⊢ Iff (CategoryTheory.Epi h) (CategoryTheory.Epi h.left)","decl":"theorem epi_iff_epi_left [HasPushouts C] {f g : Over X} (h : f ⟶ g) : Epi h ↔ Epi h.left :=\n  CostructuredArrow.epi_iff_epi_left _\n\n"}
{"name":"CategoryTheory.Over.preservesColimitsOfSize_map","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v, u} C\nY : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v, v, max u v, max u v} (CategoryTheory.Over.map f)","decl":"instance preservesColimitsOfSize_map [HasColimitsOfSize.{w, w'} C] {Y : C} (f : X ⟶ Y) :\n    PreservesColimitsOfSize.{w, w'} (map f) :=\n  preservesColimits_of_reflects_of_preserves (map f) (forget Y)\n\n"}
{"name":"CategoryTheory.Under.hasLimit_of_hasLimit_comp_forget","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"J : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nF : CategoryTheory.Functor J (CategoryTheory.Under X)\ni : CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.Under.forget X))\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit_of_hasLimit_comp_forget (F : J ⥤ Under X) [i : HasLimit (F ⋙ forget X)] :\n    HasLimit F :=\n  StructuredArrow.hasLimit (i₁ := i)\n\n"}
{"name":"CategoryTheory.Under.instHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Under X)","decl":"instance [HasLimitsOfShape J C] : HasLimitsOfShape J (Under X) where\n\n"}
{"name":"CategoryTheory.Under.instHasLimits","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.Under X)","decl":"instance [HasLimits C] : HasLimits (Under X) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.Under.mono_right_of_mono","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nf g : CategoryTheory.Under X\nh : Quiver.Hom f g\ninst✝ : CategoryTheory.Mono h\n⊢ CategoryTheory.Mono h.right","decl":"theorem mono_right_of_mono [HasPullbacks C] {f g : Under X} (h : f ⟶ g) [Mono h] : Mono h.right :=\n  StructuredArrow.mono_right_of_mono _\n\n"}
{"name":"CategoryTheory.Under.mono_iff_mono_right","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nf g : CategoryTheory.Under X\nh : Quiver.Hom f g\n⊢ Iff (CategoryTheory.Mono h) (CategoryTheory.Mono h.right)","decl":"theorem mono_iff_mono_right [HasPullbacks C] {f g : Under X} (h : f ⟶ g) : Mono h ↔ Mono h.right :=\n  StructuredArrow.mono_iff_mono_right _\n\n"}
{"name":"CategoryTheory.Under.preservesLimitsOfSize_map","module":"Mathlib.CategoryTheory.Limits.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v, u} C\nY : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v, v, max u v, max u v} (CategoryTheory.Under.map f)","decl":"instance preservesLimitsOfSize_map [HasLimitsOfSize.{w, w'} C] {Y : C} (f : X ⟶ Y) :\n    PreservesLimitsOfSize.{w, w'} (map f) :=\n  preservesLimits_of_reflects_of_preserves (map f) (forget X)\n\n"}
