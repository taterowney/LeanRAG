{"name":"Finset.disjUnion_eq_union","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (s.disjUnion t h) (Union.union s t)","decl":"@[simp]\ntheorem disjUnion_eq_union (s t h) : @disjUnion α s t h = s ∪ t :=\n  ext fun a => by simp\n\n"}
{"name":"Finset.disjoint_union_left","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (Disjoint (Union.union s t) u) (And (Disjoint s u) (Disjoint t u))","decl":"@[simp]\ntheorem disjoint_union_left : Disjoint (s ∪ t) u ↔ Disjoint s u ∧ Disjoint t u := by\n  simp only [disjoint_left, mem_union, or_imp, forall_and]\n\n"}
{"name":"Finset.disjoint_union_right","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (Disjoint s (Union.union t u)) (And (Disjoint s t) (Disjoint s u))","decl":"@[simp]\ntheorem disjoint_union_right : Disjoint s (t ∪ u) ↔ Disjoint s t ∧ Disjoint s u := by\n  simp only [disjoint_right, mem_union, or_imp, forall_and]\n\n"}
{"name":"Finset.not_disjoint_iff_nonempty_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Not (Disjoint s t)) (Inter.inter s t).Nonempty","decl":"theorem not_disjoint_iff_nonempty_inter : ¬Disjoint s t ↔ (s ∩ t).Nonempty :=\n  not_disjoint_iff.trans <| by simp [Finset.Nonempty]\n\n"}
{"name":"Finset.Nonempty.not_disjoint","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na✝ : (Inter.inter s t).Nonempty\n⊢ Not (Disjoint s t)","decl":"alias ⟨_, Nonempty.not_disjoint⟩ := not_disjoint_iff_nonempty_inter\n\n"}
{"name":"Finset.disjoint_or_nonempty_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Or (Disjoint s t) (Inter.inter s t).Nonempty","decl":"theorem disjoint_or_nonempty_inter (s t : Finset α) : Disjoint s t ∨ (s ∩ t).Nonempty := by\n  rw [← not_disjoint_iff_nonempty_inter]\n  exact em _\n\n"}
{"name":"Finset.disjoint_of_subset_iff_left_eq_empty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Iff (Disjoint s t) (Eq s EmptyCollection.emptyCollection)","decl":"omit [DecidableEq α] in\ntheorem disjoint_of_subset_iff_left_eq_empty (h : s ⊆ t) :\n    Disjoint s t ↔ s = ∅ :=\n  disjoint_of_le_iff_left_eq_bot h\n\n"}
{"name":"Finset.pairwiseDisjoint_iff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nι : Type u_4\ns : Set ι\nf : ι → Finset α\n⊢ Iff (s.PairwiseDisjoint f) (∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃j : ι⦄, Membership.mem s j → (Inter.inter (f i) (f j)).Nonempty → Eq i j)","decl":"lemma pairwiseDisjoint_iff {ι : Type*} {s : Set ι} {f : ι → Finset α} :\n    s.PairwiseDisjoint f ↔ ∀ ⦃i⦄, i ∈ s → ∀ ⦃j⦄, j ∈ s → (f i ∩ f j).Nonempty → i = j := by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]\n\n"}
{"name":"Finset.isDirected_le","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\n⊢ IsDirected (Finset α) fun x1 x2 => LE.le x1 x2","decl":"instance isDirected_le : IsDirected (Finset α) (· ≤ ·) := by classical infer_instance\n"}
{"name":"Finset.isDirected_subset","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\n⊢ IsDirected (Finset α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance isDirected_subset : IsDirected (Finset α) (· ⊆ ·) := isDirected_le\n\n"}
{"name":"Finset.erase_empty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (EmptyCollection.emptyCollection.erase a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem erase_empty (a : α) : erase ∅ a = ∅ :=\n  rfl\n\n"}
{"name":"Finset.Nontrivial.erase_nonempty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nhs : s.Nontrivial\n⊢ (s.erase a).Nonempty","decl":"protected lemma Nontrivial.erase_nonempty (hs : s.Nontrivial) : (s.erase a).Nonempty :=\n  (hs.exists_ne a).imp <| by aesop\n\n"}
{"name":"Finset.erase_nonempty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Iff (s.erase a).Nonempty s.Nontrivial","decl":"@[simp] lemma erase_nonempty (ha : a ∈ s) : (s.erase a).Nonempty ↔ s.Nontrivial := by\n  simp only [Finset.Nonempty, mem_erase, and_comm (b := _ ∈ _)]\n  refine ⟨?_, fun hs ↦ hs.exists_ne a⟩\n  rintro ⟨b, hb, hba⟩\n  exact ⟨_, hb, _, ha, hba⟩\n\n"}
{"name":"Finset.erase_singleton","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Singleton.singleton a).erase a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem erase_singleton (a : α) : ({a} : Finset α).erase a = ∅ := by\n  ext x\n  simp\n\n"}
{"name":"Finset.erase_insert_eq_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq ((Insert.insert a s).erase a) (s.erase a)","decl":"@[simp]\ntheorem erase_insert_eq_erase (s : Finset α) (a : α) : (insert a s).erase a = s.erase a :=\n  ext fun x => by\n    simp +contextual only [mem_erase, mem_insert, and_congr_right_iff,\n      false_or, iff_self, imp_true_iff]\n\n"}
{"name":"Finset.erase_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).erase a) s","decl":"theorem erase_insert {a : α} {s : Finset α} (h : a ∉ s) : erase (insert a s) a = s := by\n  rw [erase_insert_eq_erase, erase_eq_of_not_mem h]\n\n"}
{"name":"Finset.erase_insert_of_ne","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\nh : Ne a b\n⊢ Eq ((Insert.insert a s).erase b) (Insert.insert a (s.erase b))","decl":"theorem erase_insert_of_ne {a b : α} {s : Finset α} (h : a ≠ b) :\n    erase (insert a s) b = insert a (erase s b) :=\n  ext fun x => by\n    have : x ≠ b ∧ x = a ↔ x = a := and_iff_right_of_imp fun hx => hx.symm ▸ h\n    simp only [mem_erase, mem_insert, and_or_left, this]\n\n"}
{"name":"Finset.erase_cons_of_ne","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\nha : Not (Membership.mem s a)\nhb : Ne a b\n⊢ Eq ((Finset.cons a s ha).erase b) (Finset.cons a (s.erase b) ⋯)","decl":"theorem erase_cons_of_ne {a b : α} {s : Finset α} (ha : a ∉ s) (hb : a ≠ b) :\n    erase (cons a s ha) b = cons a (erase s b) fun h => ha <| erase_subset _ _ h := by\n  simp only [cons_eq_insert, erase_insert_of_ne hb]\n\n"}
{"name":"Finset.insert_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Membership.mem s a\n⊢ Eq (Insert.insert a (s.erase a)) s","decl":"@[simp] theorem insert_erase (h : a ∈ s) : insert a (erase s a) = s :=\n  ext fun x => by\n    simp only [mem_insert, mem_erase, or_and_left, dec_em, true_and]\n    apply or_iff_right_of_imp\n    rintro rfl\n    exact h\n\n"}
{"name":"Finset.erase_eq_iff_eq_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nhs : Membership.mem s a\nht : Not (Membership.mem t a)\n⊢ Iff (Eq (s.erase a) t) (Eq s (Insert.insert a t))","decl":"lemma erase_eq_iff_eq_insert (hs : a ∈ s) (ht : a ∉ t) : erase s a = t ↔ s = insert a t := by\n  aesop\n\n"}
{"name":"Finset.insert_erase_invOn","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Set.InvOn (Insert.insert a) (fun s => s.erase a) (setOf fun s => Membership.mem s a) (setOf fun s => Not (Membership.mem s a))","decl":"lemma insert_erase_invOn :\n    Set.InvOn (insert a) (fun s ↦ erase s a) {s : Finset α | a ∈ s} {s : Finset α | a ∉ s} :=\n  ⟨fun _s ↦ insert_erase, fun _s ↦ erase_insert⟩\n\n"}
{"name":"Finset.erase_ssubset","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Membership.mem s a\n⊢ HasSSubset.SSubset (s.erase a) s","decl":"theorem erase_ssubset {a : α} {s : Finset α} (h : a ∈ s) : s.erase a ⊂ s :=\n  calc\n    s.erase a ⊂ insert a (s.erase a) := ssubset_insert <| not_mem_erase _ _\n    _ = _ := insert_erase h\n\n"}
{"name":"Finset.ssubset_iff_exists_subset_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun a => And (Membership.mem t a) (HasSubset.Subset s (t.erase a)))","decl":"theorem ssubset_iff_exists_subset_erase {s t : Finset α} : s ⊂ t ↔ ∃ a ∈ t, s ⊆ t.erase a := by\n  refine ⟨fun h => ?_, fun ⟨a, ha, h⟩ => ssubset_of_subset_of_ssubset h <| erase_ssubset ha⟩\n  obtain ⟨a, ht, hs⟩ := not_subset.1 h.2\n  exact ⟨a, ht, subset_erase.2 ⟨h.1, hs⟩⟩\n\n"}
{"name":"Finset.erase_ssubset_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ HasSSubset.SSubset (s.erase a) (Insert.insert a s)","decl":"theorem erase_ssubset_insert (s : Finset α) (a : α) : s.erase a ⊂ insert a s :=\n  ssubset_iff_exists_subset_erase.2\n    ⟨a, mem_insert_self _ _, erase_subset_erase _ <| subset_insert _ _⟩\n\n"}
{"name":"Finset.erase_cons","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Eq ((Finset.cons a s h).erase a) s","decl":"theorem erase_cons {s : Finset α} {a : α} (h : a ∉ s) : (s.cons a h).erase a = s := by\n  rw [cons_eq_insert, erase_insert_eq_erase, erase_eq_of_not_mem h]\n\n"}
{"name":"Finset.subset_insert_iff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Iff (HasSubset.Subset s (Insert.insert a t)) (HasSubset.Subset (s.erase a) t)","decl":"theorem subset_insert_iff {a : α} {s t : Finset α} : s ⊆ insert a t ↔ erase s a ⊆ t := by\n  simp only [subset_iff, or_iff_not_imp_left, mem_erase, mem_insert, and_imp]\n  exact forall_congr' fun x => forall_swap\n\n"}
{"name":"Finset.erase_insert_subset","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ HasSubset.Subset ((Insert.insert a s).erase a) s","decl":"theorem erase_insert_subset (a : α) (s : Finset α) : erase (insert a s) a ⊆ s :=\n  subset_insert_iff.1 <| Subset.rfl\n\n"}
{"name":"Finset.insert_erase_subset","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ HasSubset.Subset s (Insert.insert a (s.erase a))","decl":"theorem insert_erase_subset (a : α) (s : Finset α) : s ⊆ insert a (erase s a) :=\n  subset_insert_iff.2 <| Subset.rfl\n\n"}
{"name":"Finset.subset_insert_iff_of_not_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Iff (HasSubset.Subset s (Insert.insert a t)) (HasSubset.Subset s t)","decl":"theorem subset_insert_iff_of_not_mem (h : a ∉ s) : s ⊆ insert a t ↔ s ⊆ t := by\n  rw [subset_insert_iff, erase_eq_of_not_mem h]\n\n"}
{"name":"Finset.erase_subset_iff_of_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nh : Membership.mem t a\n⊢ Iff (HasSubset.Subset (s.erase a) t) (HasSubset.Subset s t)","decl":"theorem erase_subset_iff_of_mem (h : a ∈ t) : s.erase a ⊆ t ↔ s ⊆ t := by\n  rw [← subset_insert_iff, insert_eq_of_mem h]\n\n"}
{"name":"Finset.erase_injOn'","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Set.InjOn (fun s => s.erase a) (setOf fun s => Membership.mem s a)","decl":"theorem erase_injOn' (a : α) : { s : Finset α | a ∈ s }.InjOn fun s => erase s a :=\n  fun s hs t ht (h : s.erase a = _) => by rw [← insert_erase hs, ← insert_erase ht, h]\n\n"}
{"name":"Finset.Nontrivial.exists_cons_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nontrivial\n⊢ Exists fun t => Exists fun a => Exists fun ha => Exists fun b => Exists fun hb => Exists fun hab => Eq (Finset.cons a (Finset.cons b t hb) ⋯) s","decl":"lemma Nontrivial.exists_cons_eq {s : Finset α} (hs : s.Nontrivial) :\n    ∃ t a ha b hb hab, (cons b t hb).cons a (mem_cons.not.2 <| not_or_intro hab ha) = s := by\n  classical\n  obtain ⟨a, ha, b, hb, hab⟩ := hs\n  have : b ∈ s.erase a := mem_erase.2 ⟨hab.symm, hb⟩\n  refine ⟨(s.erase a).erase b, a, ?_, b, ?_, ?_, ?_⟩ <;>\n    simp [insert_erase this, insert_erase ha, *]\n\n"}
{"name":"Finset.erase_sdiff_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nhab : Ne a b\nhb : Membership.mem s b\n⊢ Eq (SDiff.sdiff (s.erase a) (s.erase b)) (Singleton.singleton b)","decl":"lemma erase_sdiff_erase (hab : a ≠ b) (hb : b ∈ s) : s.erase a \\ s.erase b = {b} := by\n  ext; aesop\n\n-- TODO: Do we want to delete this lemma and `Finset.disjUnion_singleton`,\n-- or instead add `Finset.union_singleton`/`Finset.singleton_union`?\n"}
{"name":"Finset.sdiff_singleton_eq_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (SDiff.sdiff s (Singleton.singleton a)) (s.erase a)","decl":"theorem sdiff_singleton_eq_erase (a : α) (s : Finset α) : s \\ {a} = erase s a := by\n  ext\n  rw [mem_erase, mem_sdiff, mem_singleton, and_comm]\n\n-- This lemma matches `Finset.insert_eq` in functionality.\n"}
{"name":"Finset.erase_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (s.erase a) (SDiff.sdiff s (Singleton.singleton a))","decl":"theorem erase_eq (s : Finset α) (a : α) : s.erase a = s \\ {a} :=\n  (sdiff_singleton_eq_erase _ _).symm\n\n"}
{"name":"Finset.disjoint_erase_comm","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Iff (Disjoint (s.erase a) t) (Disjoint s (t.erase a))","decl":"theorem disjoint_erase_comm : Disjoint (s.erase a) t ↔ Disjoint s (t.erase a) := by\n  simp_rw [erase_eq, disjoint_sdiff_comm]\n\n"}
{"name":"Finset.disjoint_insert_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Not (Membership.mem t a)\n⊢ Iff (Disjoint (s.erase a) (Insert.insert a t)) (Disjoint s t)","decl":"lemma disjoint_insert_erase (ha : a ∉ t) : Disjoint (s.erase a) (insert a t) ↔ Disjoint s t := by\n  rw [disjoint_erase_comm, erase_insert ha]\n\n"}
{"name":"Finset.disjoint_erase_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Not (Membership.mem s a)\n⊢ Iff (Disjoint (Insert.insert a s) (t.erase a)) (Disjoint s t)","decl":"lemma disjoint_erase_insert (ha : a ∉ s) : Disjoint (insert a s) (t.erase a) ↔ Disjoint s t := by\n  rw [← disjoint_erase_comm, erase_insert ha]\n\n"}
{"name":"Finset.disjoint_of_erase_left","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Not (Membership.mem t a)\nhst : Disjoint (s.erase a) t\n⊢ Disjoint s t","decl":"theorem disjoint_of_erase_left (ha : a ∉ t) (hst : Disjoint (s.erase a) t) : Disjoint s t := by\n  rw [← erase_insert ha, ← disjoint_erase_comm, disjoint_insert_right]\n  exact ⟨not_mem_erase _ _, hst⟩\n\n"}
{"name":"Finset.disjoint_of_erase_right","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Not (Membership.mem s a)\nhst : Disjoint s (t.erase a)\n⊢ Disjoint s t","decl":"theorem disjoint_of_erase_right (ha : a ∉ s) (hst : Disjoint s (t.erase a)) : Disjoint s t := by\n  rw [← erase_insert ha, disjoint_erase_comm, disjoint_insert_left]\n  exact ⟨not_mem_erase _ _, hst⟩\n\n"}
{"name":"Finset.inter_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (Inter.inter s (t.erase a)) ((Inter.inter s t).erase a)","decl":"theorem inter_erase (a : α) (s t : Finset α) : s ∩ t.erase a = (s ∩ t).erase a := by\n  simp only [erase_eq, inter_sdiff_assoc]\n\n"}
{"name":"Finset.erase_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (Inter.inter (s.erase a) t) ((Inter.inter s t).erase a)","decl":"@[simp]\ntheorem erase_inter (a : α) (s t : Finset α) : s.erase a ∩ t = (s ∩ t).erase a := by\n  simpa only [inter_comm t] using inter_erase a t s\n\n"}
{"name":"Finset.erase_sdiff_comm","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (SDiff.sdiff (s.erase a) t) ((SDiff.sdiff s t).erase a)","decl":"theorem erase_sdiff_comm (s t : Finset α) (a : α) : s.erase a \\ t = (s \\ t).erase a := by\n  simp_rw [erase_eq, sdiff_right_comm]\n\n"}
{"name":"Finset.erase_inter_comm","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (Inter.inter (s.erase a) t) (Inter.inter s (t.erase a))","decl":"theorem erase_inter_comm (s t : Finset α) (a : α) : s.erase a ∩ t = s ∩ t.erase a := by\n  rw [erase_inter, inter_erase]\n\n"}
{"name":"Finset.erase_union_distrib","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq ((Union.union s t).erase a) (Union.union (s.erase a) (t.erase a))","decl":"theorem erase_union_distrib (s t : Finset α) (a : α) : (s ∪ t).erase a = s.erase a ∪ t.erase a := by\n  simp_rw [erase_eq, union_sdiff_distrib]\n\n"}
{"name":"Finset.insert_inter_distrib","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (Insert.insert a (Inter.inter s t)) (Inter.inter (Insert.insert a s) (Insert.insert a t))","decl":"theorem insert_inter_distrib (s t : Finset α) (a : α) :\n    insert a (s ∩ t) = insert a s ∩ insert a t := by simp_rw [insert_eq, union_inter_distrib_left]\n\n"}
{"name":"Finset.erase_sdiff_distrib","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq ((SDiff.sdiff s t).erase a) (SDiff.sdiff (s.erase a) (t.erase a))","decl":"theorem erase_sdiff_distrib (s t : Finset α) (a : α) : (s \\ t).erase a = s.erase a \\ t.erase a := by\n  simp_rw [erase_eq, sdiff_sdiff, sup_sdiff_eq_sup le_rfl, sup_comm]\n\n"}
{"name":"Finset.erase_union_of_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Finset α\na : α\nha : Membership.mem t a\ns : Finset α\n⊢ Eq (Union.union (s.erase a) t) (Union.union s t)","decl":"theorem erase_union_of_mem (ha : a ∈ t) (s : Finset α) : s.erase a ∪ t = s ∪ t := by\n  rw [← insert_erase (mem_union_right s ha), erase_union_distrib, ← union_insert, insert_erase ha]\n\n"}
{"name":"Finset.union_erase_of_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nha : Membership.mem s a\nt : Finset α\n⊢ Eq (Union.union s (t.erase a)) (Union.union s t)","decl":"theorem union_erase_of_mem (ha : a ∈ s) (t : Finset α) : s ∪ t.erase a = s ∪ t := by\n  rw [← insert_erase (mem_union_left t ha), erase_union_distrib, ← insert_union, insert_erase ha]\n\n"}
{"name":"Finset.sdiff_singleton_eq_self","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nha : Not (Membership.mem s a)\n⊢ Eq (SDiff.sdiff s (Singleton.singleton a)) s","decl":"@[simp, deprecated erase_eq_of_not_mem (since := \"2024-10-01\")]\ntheorem sdiff_singleton_eq_self (ha : a ∉ s) : s \\ {a} = s := by\n  rw [← erase_eq, erase_eq_of_not_mem ha]\n\n"}
{"name":"Finset.sdiff_union_erase_cancel","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nhts : HasSubset.Subset t s\nha : Membership.mem t a\n⊢ Eq (Union.union (SDiff.sdiff s t) (t.erase a)) (s.erase a)","decl":"theorem sdiff_union_erase_cancel (hts : t ⊆ s) (ha : a ∈ t) : s \\ t ∪ t.erase a = s.erase a := by\n  simp_rw [erase_eq, sdiff_union_sdiff_cancel hts (singleton_subset_iff.2 ha)]\n\n"}
{"name":"Finset.sdiff_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nx : α\n⊢ Eq (SDiff.sdiff s (Insert.insert x t)) ((SDiff.sdiff s t).erase x)","decl":"theorem sdiff_insert (s t : Finset α) (x : α) : s \\ insert x t = (s \\ t).erase x := by\n  simp_rw [← sdiff_singleton_eq_erase, insert_eq, sdiff_sdiff_left', sdiff_union_distrib,\n    inter_comm]\n\n"}
{"name":"Finset.sdiff_insert_insert_of_mem_of_not_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nx : α\nhxs : Membership.mem s x\nhxt : Not (Membership.mem t x)\n⊢ Eq (Insert.insert x (SDiff.sdiff s (Insert.insert x t))) (SDiff.sdiff s t)","decl":"theorem sdiff_insert_insert_of_mem_of_not_mem {s t : Finset α} {x : α} (hxs : x ∈ s) (hxt : x ∉ t) :\n    insert x (s \\ insert x t) = s \\ t := by\n  rw [sdiff_insert, insert_erase (mem_sdiff.mpr ⟨hxs, hxt⟩)]\n\n"}
{"name":"Finset.sdiff_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nh : Membership.mem s a\n⊢ Eq (SDiff.sdiff s (t.erase a)) (Insert.insert a (SDiff.sdiff s t))","decl":"theorem sdiff_erase (h : a ∈ s) : s \\ t.erase a = insert a (s \\ t) := by\n  rw [← sdiff_singleton_eq_erase, sdiff_sdiff_eq_sdiff_union (singleton_subset_iff.2 h), insert_eq,\n    union_comm]\n\n"}
{"name":"Finset.sdiff_erase_self","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Eq (SDiff.sdiff s (s.erase a)) (Singleton.singleton a)","decl":"theorem sdiff_erase_self (ha : a ∈ s) : s \\ s.erase a = {a} := by\n  rw [sdiff_erase ha, Finset.sdiff_self, insert_emptyc_eq]\n\n"}
{"name":"Finset.erase_eq_empty_iff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Iff (Eq (s.erase a) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq s (Singleton.singleton a)))","decl":"theorem erase_eq_empty_iff (s : Finset α) (a : α) : s.erase a = ∅ ↔ s = ∅ ∨ s = {a} := by\n  rw [← sdiff_singleton_eq_erase, sdiff_eq_empty_iff_subset, subset_singleton_iff]\n\n--TODO@Yaël: Kill lemmas duplicate with `BooleanAlgebra`\n"}
{"name":"Finset.sdiff_disjoint","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Disjoint (SDiff.sdiff t s) s","decl":"theorem sdiff_disjoint : Disjoint (t \\ s) s :=\n  disjoint_left.2 fun _a ha => (mem_sdiff.1 ha).2\n\n"}
{"name":"Finset.disjoint_sdiff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Disjoint s (SDiff.sdiff t s)","decl":"theorem disjoint_sdiff : Disjoint s (t \\ s) :=\n  sdiff_disjoint.symm\n\n"}
{"name":"Finset.disjoint_sdiff_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Disjoint (SDiff.sdiff s t) (Inter.inter s t)","decl":"theorem disjoint_sdiff_inter (s t : Finset α) : Disjoint (s \\ t) (s ∩ t) :=\n  disjoint_of_subset_right inter_subset_right sdiff_disjoint\n\n"}
{"name":"Finset.attach_empty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.attach EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem attach_empty : attach (∅ : Finset α) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.attach_nonempty_iff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff s.attach.Nonempty s.Nonempty","decl":"@[simp]\ntheorem attach_nonempty_iff {s : Finset α} : s.attach.Nonempty ↔ s.Nonempty := by\n  simp [Finset.Nonempty]\n\n"}
{"name":"Finset.Nonempty.attach","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ s.attach.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected alias ⟨_, Nonempty.attach⟩ := attach_nonempty_iff\n\n"}
{"name":"Finset.attach_eq_empty_iff","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.attach EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem attach_eq_empty_iff {s : Finset α} : s.attach = ∅ ↔ s = ∅ := by\n  simp [eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Finset.filter_singleton","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\n⊢ Eq (Finset.filter p (Singleton.singleton a)) (ite (p a) (Singleton.singleton a) EmptyCollection.emptyCollection)","decl":"theorem filter_singleton (a : α) : filter p {a} = if p a then {a} else ∅ := by\n  classical\n    ext x\n    simp only [mem_singleton, forall_eq, mem_filter]\n    split_ifs with h <;> by_cases h' : x = a <;> simp [h, h']\n\n"}
{"name":"Finset.filter_cons_of_pos","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Finset α\nha : Not (Membership.mem s a)\nhp : p a\n⊢ Eq (Finset.filter p (Finset.cons a s ha)) (Finset.cons a (Finset.filter p s) ⋯)","decl":"theorem filter_cons_of_pos (a : α) (s : Finset α) (ha : a ∉ s) (hp : p a) :\n    filter p (cons a s ha) = cons a (filter p s) ((mem_of_mem_filter _).mt ha) :=\n  eq_of_veq <| Multiset.filter_cons_of_pos s.val hp\n\n"}
{"name":"Finset.filter_cons_of_neg","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Finset α\nha : Not (Membership.mem s a)\nhp : Not (p a)\n⊢ Eq (Finset.filter p (Finset.cons a s ha)) (Finset.filter p s)","decl":"theorem filter_cons_of_neg (a : α) (s : Finset α) (ha : a ∉ s) (hp : ¬p a) :\n    filter p (cons a s ha) = filter p s :=\n  eq_of_veq <| Multiset.filter_cons_of_neg s.val hp\n\n"}
{"name":"Finset.disjoint_filter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Iff (Disjoint (Finset.filter p s) (Finset.filter q s)) (∀ (x : α), Membership.mem s x → p x → Not (q x))","decl":"theorem disjoint_filter {s : Finset α} {p q : α → Prop} [DecidablePred p] [DecidablePred q] :\n    Disjoint (s.filter p) (s.filter q) ↔ ∀ x ∈ s, p x → ¬q x := by\n  constructor <;> simp +contextual [disjoint_left]\n\n"}
{"name":"Finset.disjoint_filter_filter'","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns t : Finset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nh : Disjoint p q\n⊢ Disjoint (Finset.filter p s) (Finset.filter q t)","decl":"theorem disjoint_filter_filter' (s t : Finset α)\n    {p q : α → Prop} [DecidablePred p] [DecidablePred q] (h : Disjoint p q) :\n    Disjoint (s.filter p) (t.filter q) := by\n  simp_rw [disjoint_left, mem_filter]\n  rintro a ⟨_, hp⟩ ⟨_, hq⟩\n  rw [Pi.disjoint_iff] at h\n  simpa [hp, hq] using h a\n\n"}
{"name":"Finset.disjoint_filter_filter_neg","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns t : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\n⊢ Disjoint (Finset.filter p s) (Finset.filter (fun a => Not (p a)) t)","decl":"theorem disjoint_filter_filter_neg (s t : Finset α) (p : α → Prop)\n    [DecidablePred p] [∀ x, Decidable (¬p x)] :\n    Disjoint (s.filter p) (t.filter fun a => ¬p a) :=\n  disjoint_filter_filter' s t disjoint_compl_right\n\n"}
{"name":"Finset.filter_inter_filter_neg_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns t : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\n⊢ Disjoint (Finset.filter p s) (Finset.filter (fun a => Not (p a)) t)","decl":"@[deprecated (since := \"2024-10-01\")] alias filter_inter_filter_neg_eq := disjoint_filter_filter_neg\n\n"}
{"name":"Finset.filter_disj_union","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (Finset.filter p (s.disjUnion t h)) ((Finset.filter p s).disjUnion (Finset.filter p t) ⋯)","decl":"theorem filter_disj_union (s : Finset α) (t : Finset α) (h : Disjoint s t) :\n    filter p (disjUnion s t h) = (filter p s).disjUnion (filter p t) (disjoint_filter_filter h) :=\n  eq_of_veq <| Multiset.filter_add _ _ _\n\n"}
{"name":"Finset.filter_cons","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Finset α\nha : Not (Membership.mem s a)\n⊢ Eq (Finset.filter p (Finset.cons a s ha)) (ite (p a) (Finset.cons a (Finset.filter p s) ⋯) (Finset.filter p s))","decl":"theorem filter_cons {a : α} (s : Finset α) (ha : a ∉ s) :\n    filter p (cons a s ha) =\n      if p a then cons a (filter p s) ((mem_of_mem_filter _).mt ha) else filter p s := by\n  split_ifs with h\n  · rw [filter_cons_of_pos _ _ _ ha h]\n  · rw [filter_cons_of_neg _ _ _ ha h]\n\n"}
{"name":"Finset.filter_union","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\n⊢ Eq (Finset.filter p (Union.union s₁ s₂)) (Union.union (Finset.filter p s₁) (Finset.filter p s₂))","decl":"theorem filter_union (s₁ s₂ : Finset α) : (s₁ ∪ s₂).filter p = s₁.filter p ∪ s₂.filter p :=\n  ext fun _ => by simp only [mem_filter, mem_union, or_and_right]\n\n"}
{"name":"Finset.filter_union_right","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝² : DecidablePred p\ninst✝¹ : DecidablePred q\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Union.union (Finset.filter p s) (Finset.filter q s)) (Finset.filter (fun x => Or (p x) (q x)) s)","decl":"theorem filter_union_right (s : Finset α) : s.filter p ∪ s.filter q = s.filter fun x => p x ∨ q x :=\n  ext fun x => by simp [mem_filter, mem_union, ← and_or_left]\n\n"}
{"name":"Finset.filter_mem_eq_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns t : Finset α\ninst✝ : (i : α) → Decidable (Membership.mem t i)\n⊢ Eq (Finset.filter (fun i => Membership.mem t i) s) (Inter.inter s t)","decl":"theorem filter_mem_eq_inter {s t : Finset α} [∀ i, Decidable (i ∈ t)] :\n    (s.filter fun i => i ∈ t) = s ∩ t :=\n  ext fun i => by simp [mem_filter, mem_inter]\n\n"}
{"name":"Finset.filter_inter_distrib","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Finset.filter p (Inter.inter s t)) (Inter.inter (Finset.filter p s) (Finset.filter p t))","decl":"theorem filter_inter_distrib (s t : Finset α) : (s ∩ t).filter p = s.filter p ∩ t.filter p := by\n  ext\n  simp [mem_filter, mem_inter, and_assoc]\n\n"}
{"name":"Finset.filter_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Inter.inter (Finset.filter p s) t) (Finset.filter p (Inter.inter s t))","decl":"theorem filter_inter (s t : Finset α) : filter p s ∩ t = filter p (s ∩ t) := by\n  ext\n  simp only [mem_inter, mem_filter, and_right_comm]\n\n"}
{"name":"Finset.inter_filter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Inter.inter s (Finset.filter p t)) (Finset.filter p (Inter.inter s t))","decl":"theorem inter_filter (s t : Finset α) : s ∩ filter p t = filter p (s ∩ t) := by\n  rw [inter_comm, filter_inter, inter_comm]\n\n"}
{"name":"Finset.filter_insert","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Finset.filter p (Insert.insert a s)) (ite (p a) (Insert.insert a (Finset.filter p s)) (Finset.filter p s))","decl":"theorem filter_insert (a : α) (s : Finset α) :\n    filter p (insert a s) = if p a then insert a (filter p s) else filter p s := by\n  ext x\n  split_ifs with h <;> by_cases h' : x = a <;> simp [h, h']\n\n"}
{"name":"Finset.filter_erase","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Finset.filter p (s.erase a)) ((Finset.filter p s).erase a)","decl":"theorem filter_erase (a : α) (s : Finset α) : filter p (erase s a) = erase (filter p s) a := by\n  ext x\n  simp only [and_assoc, mem_filter, iff_self, mem_erase]\n\n"}
{"name":"Finset.filter_or","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝² : DecidablePred p\ninst✝¹ : DecidablePred q\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun a => Or (p a) (q a)) s) (Union.union (Finset.filter p s) (Finset.filter q s))","decl":"theorem filter_or (s : Finset α) : (s.filter fun a => p a ∨ q a) = s.filter p ∪ s.filter q :=\n  ext fun _ => by simp [mem_filter, mem_union, and_or_left]\n\n"}
{"name":"Finset.filter_and","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝² : DecidablePred p\ninst✝¹ : DecidablePred q\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun a => And (p a) (q a)) s) (Inter.inter (Finset.filter p s) (Finset.filter q s))","decl":"theorem filter_and (s : Finset α) : (s.filter fun a => p a ∧ q a) = s.filter p ∩ s.filter q :=\n  ext fun _ => by simp [mem_filter, mem_inter, and_comm, and_left_comm, and_self_iff, and_assoc]\n\n"}
{"name":"Finset.filter_not","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun a => Not (p a)) s) (SDiff.sdiff s (Finset.filter p s))","decl":"theorem filter_not (s : Finset α) : (s.filter fun a => ¬p a) = s \\ s.filter p :=\n  ext fun a => by\n    simp only [Bool.decide_coe, Bool.not_eq_true', mem_filter, and_comm, mem_sdiff, not_and_or,\n      Bool.not_eq_true, and_or_left, and_not_self, or_false]\n\n"}
{"name":"Finset.filter_and_not","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ns : Finset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq (Finset.filter (fun a => And (p a) (Not (q a))) s) (SDiff.sdiff (Finset.filter p s) (Finset.filter q s))","decl":"lemma filter_and_not (s : Finset α) (p q : α → Prop) [DecidablePred p] [DecidablePred q] :\n    s.filter (fun a ↦ p a ∧ ¬ q a) = s.filter p \\ s.filter q := by\n  rw [filter_and, filter_not, ← inter_sdiff_assoc, inter_eq_left.2 (filter_subset _ _)]\n\n"}
{"name":"Finset.sdiff_eq_filter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\n⊢ Eq (SDiff.sdiff s₁ s₂) (Finset.filter (fun x => Not (Membership.mem s₂ x)) s₁)","decl":"theorem sdiff_eq_filter (s₁ s₂ : Finset α) : s₁ \\ s₂ = filter (· ∉ s₂) s₁ :=\n  ext fun _ => by simp [mem_sdiff, mem_filter]\n\n"}
{"name":"Finset.subset_union_elim","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nt₁ t₂ : Set α\nh : HasSubset.Subset (↑s) (Union.union t₁ t₂)\n⊢ Exists fun s₁ => Exists fun s₂ => And (Eq (Union.union s₁ s₂) s) (And (HasSubset.Subset (↑s₁) t₁) (HasSubset.Subset (↑s₂) (SDiff.sdiff t₂ t₁)))","decl":"theorem subset_union_elim {s : Finset α} {t₁ t₂ : Set α} (h : ↑s ⊆ t₁ ∪ t₂) :\n    ∃ s₁ s₂ : Finset α, s₁ ∪ s₂ = s ∧ ↑s₁ ⊆ t₁ ∧ ↑s₂ ⊆ t₂ \\ t₁ := by\n  classical\n    refine ⟨s.filter (· ∈ t₁), s.filter (· ∉ t₁), ?_, ?_, ?_⟩\n    · simp [filter_union_right, em]\n    · intro x\n      simp\n    · intro x\n      simp only [not_not, coe_filter, Set.mem_setOf_eq, Set.mem_diff, and_imp]\n      intro hx hx₂\n      exact ⟨Or.resolve_left (h hx) hx₂, hx₂⟩\n\n"}
{"name":"Finset.filter_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"β : Type u_2\ninst✝ : DecidableEq β\ns : Finset β\nb : β\n⊢ Eq (Finset.filter (Eq b) s) (ite (Membership.mem s b) (Singleton.singleton b) EmptyCollection.emptyCollection)","decl":"/-- After filtering out everything that does not equal a given value, at most that value remains.\n\n  This is equivalent to `filter_eq'` with the equality the other way.\n-/\ntheorem filter_eq [DecidableEq β] (s : Finset β) (b : β) :\n    s.filter (Eq b) = ite (b ∈ s) {b} ∅ := by\n  split_ifs with h\n  · ext\n    simp only [mem_filter, mem_singleton, decide_eq_true_eq]\n    refine ⟨fun h => h.2.symm, ?_⟩\n    rintro rfl\n    exact ⟨h, rfl⟩\n  · ext\n    simp only [mem_filter, not_and, iff_false, not_mem_empty, decide_eq_true_eq]\n    rintro m rfl\n    exact h m\n\n"}
{"name":"Finset.filter_eq'","module":"Mathlib.Data.Finset.Basic","initialProofState":"β : Type u_2\ninst✝ : DecidableEq β\ns : Finset β\nb : β\n⊢ Eq (Finset.filter (fun a => Eq a b) s) (ite (Membership.mem s b) (Singleton.singleton b) EmptyCollection.emptyCollection)","decl":"/-- After filtering out everything that does not equal a given value, at most that value remains.\n\n  This is equivalent to `filter_eq` with the equality the other way.\n-/\ntheorem filter_eq' [DecidableEq β] (s : Finset β) (b : β) :\n    (s.filter fun a => a = b) = ite (b ∈ s) {b} ∅ :=\n  _root_.trans (filter_congr fun _ _ => by simp_rw [@eq_comm _ b]) (filter_eq s b)\n\n"}
{"name":"Finset.filter_ne","module":"Mathlib.Data.Finset.Basic","initialProofState":"β : Type u_2\ninst✝ : DecidableEq β\ns : Finset β\nb : β\n⊢ Eq (Finset.filter (fun a => Ne b a) s) (s.erase b)","decl":"theorem filter_ne [DecidableEq β] (s : Finset β) (b : β) :\n    (s.filter fun a => b ≠ a) = s.erase b := by\n  ext\n  simp only [mem_filter, mem_erase, Ne, decide_not, Bool.not_eq_true', decide_eq_false_iff_not]\n  tauto\n\n"}
{"name":"Finset.filter_ne'","module":"Mathlib.Data.Finset.Basic","initialProofState":"β : Type u_2\ninst✝ : DecidableEq β\ns : Finset β\nb : β\n⊢ Eq (Finset.filter (fun a => Ne a b) s) (s.erase b)","decl":"theorem filter_ne' [DecidableEq β] (s : Finset β) (b : β) : (s.filter fun a => a ≠ b) = s.erase b :=\n  _root_.trans (filter_congr fun _ _ => by simp_rw [@ne_comm _ b]) (filter_ne s b)\n\n"}
{"name":"Finset.filter_union_filter_of_codisjoint","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝² : DecidablePred p\ninst✝¹ : DecidablePred q\ninst✝ : DecidableEq α\ns : Finset α\nh : Codisjoint p q\n⊢ Eq (Union.union (Finset.filter p s) (Finset.filter q s)) s","decl":"theorem filter_union_filter_of_codisjoint (s : Finset α) (h : Codisjoint p q) :\n    s.filter p ∪ s.filter q = s :=\n  (filter_or _ _ _).symm.trans <| filter_true_of_mem fun x _ => h.top_le x trivial\n\n"}
{"name":"Finset.filter_union_filter_neg_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝² : DecidablePred p\ninst✝¹ : DecidableEq α\ninst✝ : (x : α) → Decidable (Not (p x))\ns : Finset α\n⊢ Eq (Union.union (Finset.filter p s) (Finset.filter (fun a => Not (p a)) s)) s","decl":"theorem filter_union_filter_neg_eq [∀ x, Decidable (¬p x)] (s : Finset α) :\n    (s.filter p ∪ s.filter fun a => ¬p a) = s :=\n  filter_union_filter_of_codisjoint _ _ _ <| @codisjoint_hnot_right _ _ p\n\n"}
{"name":"Finset.range_filter_eq","module":"Mathlib.Data.Finset.Basic","initialProofState":"n m : Nat\n⊢ Eq (Finset.filter (fun x => Eq x m) (Finset.range n)) (ite (LT.lt m n) (Singleton.singleton m) EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem range_filter_eq {n m : ℕ} : (range n).filter (· = m) = if m < n then {m} else ∅ := by\n  convert filter_eq (range n) m using 2\n  · ext\n    rw [eq_comm]\n  · simp\n\n"}
{"name":"Multiset.toFinset_add","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t).toFinset (Union.union s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_add (s t : Multiset α) : toFinset (s + t) = toFinset s ∪ toFinset t :=\n  Finset.ext <| by simp\n\n"}
{"name":"Multiset.toFinset_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Inter.inter s t).toFinset (Inter.inter s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_inter (s t : Multiset α) : toFinset (s ∩ t) = toFinset s ∩ toFinset t :=\n  Finset.ext <| by simp\n\n"}
{"name":"Multiset.toFinset_union","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Union.union s t).toFinset (Union.union s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_union (s t : Multiset α) : (s ∪ t).toFinset = s.toFinset ∪ t.toFinset := by\n  ext; simp\n\n"}
{"name":"Multiset.toFinset_eq_empty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Iff (Eq m.toFinset EmptyCollection.emptyCollection) (Eq m 0)","decl":"@[simp]\ntheorem toFinset_eq_empty {m : Multiset α} : m.toFinset = ∅ ↔ m = 0 :=\n  Finset.val_inj.symm.trans Multiset.dedup_eq_zero\n\n"}
{"name":"Multiset.toFinset_nonempty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff s.toFinset.Nonempty (Ne s 0)","decl":"@[simp]\ntheorem toFinset_nonempty : s.toFinset.Nonempty ↔ s ≠ 0 := by\n  simp only [toFinset_eq_empty, Ne, Finset.nonempty_iff_ne_empty]\n\n"}
{"name":"Multiset.Aesop.toFinset_nonempty_of_ne","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na✝ : Ne s 0\n⊢ s.toFinset.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected alias ⟨_, Aesop.toFinset_nonempty_of_ne⟩ := toFinset_nonempty\n\n"}
{"name":"Multiset.toFinset_filter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns : Multiset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filter p s).toFinset (Finset.filter p s.toFinset)","decl":"@[simp]\ntheorem toFinset_filter (s : Multiset α) (p : α → Prop) [DecidablePred p] :\n    Multiset.toFinset (s.filter p) = s.toFinset.filter p := by\n  ext; simp\n\n"}
{"name":"List.toFinset_union","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ Eq (Union.union l l').toFinset (Union.union l.toFinset l'.toFinset)","decl":"@[simp]\ntheorem toFinset_union (l l' : List α) : (l ∪ l').toFinset = l.toFinset ∪ l'.toFinset := by\n  ext\n  simp\n\n"}
{"name":"List.toFinset_inter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ Eq (Inter.inter l l').toFinset (Inter.inter l.toFinset l'.toFinset)","decl":"@[simp]\ntheorem toFinset_inter (l l' : List α) : (l ∩ l').toFinset = l.toFinset ∩ l'.toFinset := by\n  ext\n  simp\n\n"}
{"name":"List.Aesop.toFinset_nonempty_of_ne","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na✝ : Ne l List.nil\n⊢ l.toFinset.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.toFinset_nonempty_of_ne⟩ := toFinset_nonempty_iff\n\n"}
{"name":"List.toFinset_filter","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : List α\np : α → Bool\n⊢ Eq (List.filter p s).toFinset (Finset.filter (fun x => Eq (p x) Bool.true) s.toFinset)","decl":"@[simp]\ntheorem toFinset_filter (s : List α) (p : α → Bool) :\n    (s.filter p).toFinset = s.toFinset.filter (p ·) := by\n  ext; simp [List.mem_filter]\n\n"}
{"name":"Finset.toList_eq_nil","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.toList List.nil) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem toList_eq_nil {s : Finset α} : s.toList = [] ↔ s = ∅ :=\n  Multiset.toList_eq_nil.trans val_eq_zero\n\n"}
{"name":"Finset.empty_toList","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.toList.isEmpty Bool.true) (Eq s EmptyCollection.emptyCollection)","decl":"theorem empty_toList {s : Finset α} : s.toList.isEmpty ↔ s = ∅ := by simp\n\n"}
{"name":"Finset.toList_empty","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.toList List.nil","decl":"@[simp]\ntheorem toList_empty : (∅ : Finset α).toList = [] :=\n  toList_eq_nil.mpr rfl\n\n"}
{"name":"Finset.Nonempty.toList_ne_nil","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\n⊢ Ne s.toList List.nil","decl":"theorem Nonempty.toList_ne_nil {s : Finset α} (hs : s.Nonempty) : s.toList ≠ [] :=\n  mt toList_eq_nil.mp hs.ne_empty\n\n"}
{"name":"Finset.Nonempty.not_empty_toList","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\n⊢ Not (Eq s.toList.isEmpty Bool.true)","decl":"theorem Nonempty.not_empty_toList {s : Finset α} (hs : s.Nonempty) : ¬s.toList.isEmpty :=\n  mt empty_toList.mp hs.ne_empty\n\n"}
{"name":"Finset.choose_spec","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Finset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ And (Membership.mem l (Finset.choose p l hp)) (p (Finset.choose p l hp))","decl":"theorem choose_spec (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n\n"}
{"name":"Finset.choose_mem","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Finset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ Membership.mem l (Finset.choose p l hp)","decl":"theorem choose_mem (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n\n"}
{"name":"Finset.choose_property","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Finset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ p (Finset.choose p l hp)","decl":"theorem choose_property (hp : ∃! a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n\n"}
{"name":"Equiv.Finset.union_symm_inl","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\nx : Subtype fun x => Membership.mem s x\n⊢ Eq ((Equiv.Finset.union s t h) (Sum.inl x)) ⟨↑x, ⋯⟩","decl":"@[simp]\ntheorem Finset.union_symm_inl (h : Disjoint s t) (x : s) :\n    Equiv.Finset.union s t h (Sum.inl x) = ⟨x, Finset.mem_union.mpr <| Or.inl x.2⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Finset.union_symm_inr","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\ny : Subtype fun x => Membership.mem t x\n⊢ Eq ((Equiv.Finset.union s t h) (Sum.inr y)) ⟨↑y, ⋯⟩","decl":"@[simp]\ntheorem Finset.union_symm_inr (h : Disjoint s t) (y : t) :\n    Equiv.Finset.union s t h (Sum.inr y) = ⟨y, Finset.mem_union.mpr <| Or.inr y.2⟩ :=\n  rfl\n\n"}
{"name":"Multiset.toFinset_replicate","module":"Mathlib.Data.Finset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\na : α\n⊢ Eq (Multiset.replicate n a).toFinset (ite (Eq n 0) EmptyCollection.emptyCollection (Singleton.singleton a))","decl":"@[simp]\nlemma toFinset_replicate (n : ℕ) (a : α) :\n    (replicate n a).toFinset = if n = 0 then ∅ else {a} := by\n  ext x\n  simp only [mem_toFinset, Finset.mem_singleton, mem_replicate]\n  split_ifs with hn <;> simp [hn]\n\n"}
