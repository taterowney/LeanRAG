{"name":"AlternatingMap.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : Semiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\nι : Type u_7\ninst✝³ : SizeOf R\ninst✝² : SizeOf M\ninst✝¹ : SizeOf N\ninst✝ : SizeOf ι\ntoMultilinearMap : MultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toMultilinearMap.toFun v) 0\n⊢ Eq (SizeOf.sizeOf { toMultilinearMap := toMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMultilinearMap))","decl":"/-- An alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→ₗ[R] N`,\nis a multilinear map that vanishes when two of its arguments are equal. -/\nstructure AlternatingMap extends MultilinearMap R (fun _ : ι => M) N where\n  /-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\n  map_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), v i = v j → i ≠ j → toFun v = 0\n\n"}
{"name":"AlternatingMap.map_eq_zero_of_eq'","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nself : AlternatingMap R M N ι\nv : ι → M\ni j : ι\na✝¹ : Eq (v i) (v j)\na✝ : Ne i j\n⊢ Eq (self.toFun v) 0","decl":"/-- An alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→ₗ[R] N`,\nis a multilinear map that vanishes when two of its arguments are equal. -/\nstructure AlternatingMap extends MultilinearMap R (fun _ : ι => M) N where\n  /-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\n  map_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), v i = v j → i ≠ j → toFun v = 0\n\n"}
{"name":"AlternatingMap.mk.inj","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\ntoMultilinearMap✝ : MultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq'✝ : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toMultilinearMap✝.toFun v) 0\ntoMultilinearMap : MultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toMultilinearMap.toFun v) 0\nx✝ : Eq { toMultilinearMap := toMultilinearMap✝, map_eq_zero_of_eq' := map_eq_zero_of_eq'✝ } { toMultilinearMap := toMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }\n⊢ Eq toMultilinearMap✝ toMultilinearMap","decl":"/-- An alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→ₗ[R] N`,\nis a multilinear map that vanishes when two of its arguments are equal. -/\nstructure AlternatingMap extends MultilinearMap R (fun _ : ι => M) N where\n  /-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\n  map_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), v i = v j → i ≠ j → toFun v = 0\n\n"}
{"name":"AlternatingMap.mk.injEq","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\ntoMultilinearMap✝ : MultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq'✝ : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toMultilinearMap✝.toFun v) 0\ntoMultilinearMap : MultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toMultilinearMap.toFun v) 0\n⊢ Eq (Eq { toMultilinearMap := toMultilinearMap✝, map_eq_zero_of_eq' := map_eq_zero_of_eq'✝ } { toMultilinearMap := toMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }) (Eq toMultilinearMap✝ toMultilinearMap)","decl":"/-- An alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→ₗ[R] N`,\nis a multilinear map that vanishes when two of its arguments are equal. -/\nstructure AlternatingMap extends MultilinearMap R (fun _ : ι => M) N where\n  /-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\n  map_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), v i = v j → i ≠ j → toFun v = 0\n\n"}
{"name":"AlternatingMap.toFun_eq_coe","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe : f.toFun = f :=\n  rfl\n\n-- Porting note: changed statement to reflect new `mk` signature\n"}
{"name":"AlternatingMap.coe_mk","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : MultilinearMap R (fun x => M) N\nh : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (f.toFun v) 0\n⊢ Eq ⇑{ toMultilinearMap := f, map_eq_zero_of_eq' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : MultilinearMap R (fun _ : ι => M) N) (h) :\n    ⇑(⟨f, h⟩ : M [⋀^ι]→ₗ[R] N) = f :=\n  rfl\n\n"}
{"name":"AlternatingMap.congr_fun","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf g : AlternatingMap R M N ι\nh : Eq f g\nx : ι → M\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : M [⋀^ι]→ₗ[R] N} (h : f = g) (x : ι → M) : f x = g x :=\n  congr_arg (fun h : M [⋀^ι]→ₗ[R] N => h x) h\n\n"}
{"name":"AlternatingMap.congr_arg","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nx y : ι → M\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : M [⋀^ι]→ₗ[R] N) {x y : ι → M} (h : x = y) : f x = f y :=\n  congr_arg (fun x : ι → M => f x) h\n\n"}
{"name":"AlternatingMap.coe_injective","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : Injective ((↑) : M [⋀^ι]→ₗ[R] N → (ι → M) → N) :=\n  DFunLike.coe_injective\n\n"}
{"name":"AlternatingMap.coe_inj","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf g : AlternatingMap R M N ι\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"@[norm_cast]\ntheorem coe_inj {f g : M [⋀^ι]→ₗ[R] N} : (f : (ι → M) → N) = g ↔ f = g :=\n  coe_injective.eq_iff\n\n"}
{"name":"AlternatingMap.ext","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf f' : AlternatingMap R M N ι\nH : ∀ (x : ι → M), Eq (f x) (f' x)\n⊢ Eq f f'","decl":"@[ext]\ntheorem ext {f f' : M [⋀^ι]→ₗ[R] N} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"AlternatingMap.ext_iff","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf f' : AlternatingMap R M N ι\n⊢ Iff (Eq f f') (∀ (x : ι → M), Eq (f x) (f' x))","decl":"@[ext]\ntheorem ext {f f' : M [⋀^ι]→ₗ[R] N} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"AlternatingMap.coe_multilinearMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_multilinearMap : ⇑(f : MultilinearMap R (fun _ : ι => M) N) = f :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_multilinearMap_injective","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\n⊢ Function.Injective AlternatingMap.toMultilinearMap","decl":"theorem coe_multilinearMap_injective :\n    Function.Injective ((↑) : M [⋀^ι]→ₗ[R] N → MultilinearMap R (fun _ : ι => M) N) :=\n  fun _ _ h => ext <| MultilinearMap.congr_fun h\n\n-- Porting note: changed statement to reflect new `mk` signature.\n-- Porting note: removed `simp`\n-- @[simp]\n"}
{"name":"AlternatingMap.coe_multilinearMap_mk","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : (ι → M) → N\nh₁ : ∀ [inst : DecidableEq ι] (m : ι → M) (i : ι) (x y : M), Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))\nh₂ : ∀ [inst : DecidableEq ι] (m : ι → M) (i : ι) (c : R) (x : M), Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))\nh₃ : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq ({ toFun := f, map_update_add' := ⋯, map_update_smul' := ⋯ }.toFun v) 0\n⊢ Eq ↑{ toFun := f, map_update_add' := ⋯, map_update_smul' := ⋯, map_eq_zero_of_eq' := h₃ } { toFun := f, map_update_add' := h₁, map_update_smul' := h₂ }","decl":"theorem coe_multilinearMap_mk (f : (ι → M) → N) (h₁ h₂ h₃) :\n    ((⟨⟨f, h₁, h₂⟩, h₃⟩ : M [⋀^ι]→ₗ[R] N) : MultilinearMap R (fun _ : ι => M) N) =\n      ⟨f, @h₁, @h₂⟩ := by\n  simp\n\n"}
{"name":"AlternatingMap.map_update_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni : ι\nx y : M\n⊢ Eq (f (Function.update v i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update v i x)) (f (Function.update v i y)))","decl":"@[simp]\ntheorem map_update_add [DecidableEq ι] (i : ι) (x y : M) :\n    f (update v i (x + y)) = f (update v i x) + f (update v i y) :=\n  f.map_update_add' v i x y\n\n"}
{"name":"AlternatingMap.map_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni : ι\nx y : M\n⊢ Eq (f (Function.update v i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update v i x)) (f (Function.update v i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_add := map_update_add\n\n"}
{"name":"AlternatingMap.map_update_sub","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM' : Type u_5\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R M'\nN' : Type u_6\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nι : Type u_7\ng' : AlternatingMap R M' N' ι\nv' : ι → M'\ninst✝ : DecidableEq ι\ni : ι\nx y : M'\n⊢ Eq (g' (Function.update v' i (HSub.hSub x y))) (HSub.hSub (g' (Function.update v' i x)) (g' (Function.update v' i y)))","decl":"@[simp]\ntheorem map_update_sub [DecidableEq ι] (i : ι) (x y : M') :\n    g' (update v' i (x - y)) = g' (update v' i x) - g' (update v' i y) :=\n  g'.toMultilinearMap.map_update_sub v' i x y\n\n"}
{"name":"AlternatingMap.map_sub","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM' : Type u_5\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R M'\nN' : Type u_6\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nι : Type u_7\ng' : AlternatingMap R M' N' ι\nv' : ι → M'\ninst✝ : DecidableEq ι\ni : ι\nx y : M'\n⊢ Eq (g' (Function.update v' i (HSub.hSub x y))) (HSub.hSub (g' (Function.update v' i x)) (g' (Function.update v' i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_sub := map_update_sub\n\n"}
{"name":"AlternatingMap.map_update_neg","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM' : Type u_5\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R M'\nN' : Type u_6\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nι : Type u_7\ng' : AlternatingMap R M' N' ι\nv' : ι → M'\ninst✝ : DecidableEq ι\ni : ι\nx : M'\n⊢ Eq (g' (Function.update v' i (Neg.neg x))) (Neg.neg (g' (Function.update v' i x)))","decl":"@[simp]\ntheorem map_update_neg [DecidableEq ι] (i : ι) (x : M') :\n    g' (update v' i (-x)) = -g' (update v' i x) :=\n  g'.toMultilinearMap.map_update_neg v' i x\n\n"}
{"name":"AlternatingMap.map_neg","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM' : Type u_5\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R M'\nN' : Type u_6\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nι : Type u_7\ng' : AlternatingMap R M' N' ι\nv' : ι → M'\ninst✝ : DecidableEq ι\ni : ι\nx : M'\n⊢ Eq (g' (Function.update v' i (Neg.neg x))) (Neg.neg (g' (Function.update v' i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_neg := map_update_neg\n\n"}
{"name":"AlternatingMap.map_update_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni : ι\nr : R\nx : M\n⊢ Eq (f (Function.update v i (HSMul.hSMul r x))) (HSMul.hSMul r (f (Function.update v i x)))","decl":"@[simp]\ntheorem map_update_smul [DecidableEq ι] (i : ι) (r : R) (x : M) :\n    f (update v i (r • x)) = r • f (update v i x) :=\n  f.map_update_smul' v i r x\n\n"}
{"name":"AlternatingMap.map_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni : ι\nr : R\nx : M\n⊢ Eq (f (Function.update v i (HSMul.hSMul r x))) (HSMul.hSMul r (f (Function.update v i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_smul := map_update_smul\n\n"}
{"name":"AlternatingMap.map_eq_zero_of_eq","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ni j : ι\nh : Eq (v i) (v j)\nhij : Ne i j\n⊢ Eq (f v) 0","decl":"@[simp]\ntheorem map_eq_zero_of_eq (v : ι → M) {i j : ι} (h : v i = v j) (hij : i ≠ j) : f v = 0 :=\n  f.map_eq_zero_of_eq' v i j h hij\n\n"}
{"name":"AlternatingMap.map_coord_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nm : ι → M\ni : ι\nh : Eq (m i) 0\n⊢ Eq (f m) 0","decl":"theorem map_coord_zero {m : ι → M} (i : ι) (h : m i = 0) : f m = 0 :=\n  f.toMultilinearMap.map_coord_zero i h\n\n"}
{"name":"AlternatingMap.map_update_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\n⊢ Eq (f (Function.update m i 0)) 0","decl":"@[simp]\ntheorem map_update_zero [DecidableEq ι] (m : ι → M) (i : ι) : f (update m i 0) = 0 :=\n  f.toMultilinearMap.map_update_zero m i\n\n"}
{"name":"AlternatingMap.map_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\ninst✝ : Nonempty ι\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  f.toMultilinearMap.map_zero\n\n"}
{"name":"AlternatingMap.map_eq_zero_of_not_injective","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\nhv : Not (Function.Injective v)\n⊢ Eq (f v) 0","decl":"theorem map_eq_zero_of_not_injective (v : ι → M) (hv : ¬Function.Injective v) : f v = 0 := by\n  rw [Function.Injective] at hv\n  push_neg at hv\n  rcases hv with ⟨i₁, i₂, heq, hne⟩\n  exact f.map_eq_zero_of_eq v heq hne\n\n"}
{"name":"AlternatingMap.smul_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nS : Type u_10\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass R S N\nc : S\nm : ι → M\n⊢ Eq ((HSMul.hSMul c f) m) (HSMul.hSMul c (f m))","decl":"@[simp]\ntheorem smul_apply (c : S) (m : ι → M) : (c • f) m = c • f m :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nS : Type u_10\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass R S N\nc : S\n⊢ Eq (↑(HSMul.hSMul c f)) (HSMul.hSMul c ↑f)","decl":"@[norm_cast]\ntheorem coe_smul (c : S) : ↑(c • f) = c • (f : MultilinearMap R (fun _ : ι => M) N) :=\n  rfl\n\n"}
{"name":"AlternatingMap.coeFn_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nS : Type u_10\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass R S N\nc : S\nf : AlternatingMap R M N ι\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"theorem coeFn_smul (c : S) (f : M [⋀^ι]→ₗ[R] N) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"AlternatingMap.isCentralScalar","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_3\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nι : Type u_7\nS : Type u_10\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S N\ninst✝² : SMulCommClass R S N\ninst✝¹ : DistribMulAction (MulOpposite S) N\ninst✝ : IsCentralScalar S N\n⊢ IsCentralScalar S (AlternatingMap R M N ι)","decl":"instance isCentralScalar [DistribMulAction Sᵐᵒᵖ N] [IsCentralScalar S N] :\n    IsCentralScalar S (M [⋀^ι]→ₗ[R] N) :=\n  ⟨fun _ _ => ext fun _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"AlternatingMap.prod_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nι : Type u_7\nf : AlternatingMap R M N ι\ng : AlternatingMap R M P ι\nm : (i : ι) → (fun x => M) i\n⊢ Eq ((f.prod g) m) { fst := f m, snd := g m }","decl":"/-- The cartesian product of two alternating maps, as an alternating map. -/\n@[simps!]\ndef prod (f : M [⋀^ι]→ₗ[R] N) (g : M [⋀^ι]→ₗ[R] P) : M [⋀^ι]→ₗ[R] (N × P) :=\n  { f.toMultilinearMap.prod g.toMultilinearMap with\n    map_eq_zero_of_eq' := fun _ _ _ h hne =>\n      Prod.ext (f.map_eq_zero_of_eq _ h hne) (g.map_eq_zero_of_eq _ h hne) }\n\n"}
{"name":"AlternatingMap.coe_prod","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nι : Type u_7\nf : AlternatingMap R M N ι\ng : AlternatingMap R M P ι\n⊢ Eq (↑(f.prod g)) ((↑f).prod ↑g)","decl":"@[simp]\ntheorem coe_prod (f : M [⋀^ι]→ₗ[R] N) (g : M [⋀^ι]→ₗ[R] P) :\n    (f.prod g : MultilinearMap R (fun _ : ι => M) (N × P)) = MultilinearMap.prod f g :=\n  rfl\n\n"}
{"name":"AlternatingMap.pi_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nι : Type u_7\nι' : Type u_10\nN : ι' → Type u_11\ninst✝¹ : (i : ι') → AddCommMonoid (N i)\ninst✝ : (i : ι') → Module R (N i)\nf : (i : ι') → AlternatingMap R M (N i) ι\nm : (i : ι) → (fun x => M) i\ni : ι'\n⊢ Eq ((AlternatingMap.pi f) m i) ((f i) m)","decl":"/-- Combine a family of alternating maps with the same domain and codomains `N i` into an\nalternating map taking values in the space of functions `Π i, N i`. -/\n@[simps!]\ndef pi {ι' : Type*} {N : ι' → Type*} [∀ i, AddCommMonoid (N i)] [∀ i, Module R (N i)]\n    (f : ∀ i, M [⋀^ι]→ₗ[R] N i) : M [⋀^ι]→ₗ[R] (∀ i, N i) :=\n  { MultilinearMap.pi fun a => (f a).toMultilinearMap with\n    map_eq_zero_of_eq' := fun _ _ _ h hne => funext fun a => (f a).map_eq_zero_of_eq _ h hne }\n\n"}
{"name":"AlternatingMap.coe_pi","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nι : Type u_7\nι' : Type u_10\nN : ι' → Type u_11\ninst✝¹ : (i : ι') → AddCommMonoid (N i)\ninst✝ : (i : ι') → Module R (N i)\nf : (i : ι') → AlternatingMap R M (N i) ι\n⊢ Eq (↑(AlternatingMap.pi f)) (MultilinearMap.pi fun a => ↑(f a))","decl":"@[simp]\ntheorem coe_pi {ι' : Type*} {N : ι' → Type*} [∀ i, AddCommMonoid (N i)] [∀ i, Module R (N i)]\n    (f : ∀ i, M [⋀^ι]→ₗ[R] N i) :\n    (pi f : MultilinearMap R (fun _ : ι => M) (∀ i, N i)) = MultilinearMap.pi fun a => f a :=\n  rfl\n\n"}
{"name":"AlternatingMap.smulRight_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_10\nM₁ : Type u_11\nM₂ : Type u_12\nι : Type u_13\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nf : AlternatingMap R M₁ R ι\nz : M₂\na✝ : (i : ι) → (fun x => M₁) i\n⊢ Eq ((f.smulRight z) a✝) (HSMul.hSMul (f a✝) z)","decl":"/-- Given an alternating `R`-multilinear map `f` taking values in `R`, `f.smul_right z` is the map\nsending `m` to `f m • z`. -/\n@[simps!]\ndef smulRight {R M₁ M₂ ι : Type*} [CommSemiring R] [AddCommMonoid M₁] [AddCommMonoid M₂]\n    [Module R M₁] [Module R M₂] (f : M₁ [⋀^ι]→ₗ[R] R) (z : M₂) : M₁ [⋀^ι]→ₗ[R] M₂ :=\n  { f.toMultilinearMap.smulRight z with\n    map_eq_zero_of_eq' := fun v i j h hne => by simp [f.map_eq_zero_of_eq v h hne] }\n\n"}
{"name":"AlternatingMap.coe_smulRight","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_10\nM₁ : Type u_11\nM₂ : Type u_12\nι : Type u_13\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nf : AlternatingMap R M₁ R ι\nz : M₂\n⊢ Eq (↑(f.smulRight z)) ((↑f).smulRight z)","decl":"@[simp]\ntheorem coe_smulRight {R M₁ M₂ ι : Type*} [CommSemiring R] [AddCommMonoid M₁] [AddCommMonoid M₂]\n    [Module R M₁] [Module R M₂] (f : M₁ [⋀^ι]→ₗ[R] R) (z : M₂) :\n    (f.smulRight z : MultilinearMap R (fun _ : ι => M₁) M₂) = MultilinearMap.smulRight f z :=\n  rfl\n\n"}
{"name":"AlternatingMap.add_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf f' : AlternatingMap R M N ι\nv : ι → M\n⊢ Eq ((HAdd.hAdd f f') v) (HAdd.hAdd (f v) (f' v))","decl":"@[simp]\ntheorem add_apply : (f + f') v = f v + f' v :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf f' : AlternatingMap R M N ι\n⊢ Eq (↑(HAdd.hAdd f f')) (HAdd.hAdd ↑f ↑f')","decl":"@[norm_cast]\ntheorem coe_add : (↑(f + f') : MultilinearMap R (fun _ : ι => M) N) = f + f' :=\n  rfl\n\n"}
{"name":"AlternatingMap.zero_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nv : ι → M\n⊢ Eq (0 v) 0","decl":"@[simp]\ntheorem zero_apply : (0 : M [⋀^ι]→ₗ[R] N) v = 0 :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\n⊢ Eq (↑0) 0","decl":"@[norm_cast]\ntheorem coe_zero : ((0 : M [⋀^ι]→ₗ[R] N) : MultilinearMap R (fun _ : ι => M) N) = 0 :=\n  rfl\n\n"}
{"name":"AlternatingMap.mk_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\n⊢ Eq { toMultilinearMap := 0, map_eq_zero_of_eq' := ⋯ } 0","decl":"@[simp]\ntheorem mk_zero :\n    mk (0 : MultilinearMap R (fun _ : ι ↦ M) N) (0 : M [⋀^ι]→ₗ[R] N).2 = 0 :=\n  rfl\n\n"}
{"name":"AlternatingMap.neg_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN' : Type u_6\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\nm : ι → M\n⊢ Eq ((Neg.neg g) m) (Neg.neg (g m))","decl":"@[simp]\ntheorem neg_apply (m : ι → M) : (-g) m = -g m :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_neg","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN' : Type u_6\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\n⊢ Eq (↑(Neg.neg g)) (Neg.neg ↑g)","decl":"@[norm_cast]\ntheorem coe_neg : ((-g : M [⋀^ι]→ₗ[R] N') : MultilinearMap R (fun _ : ι => M) N') = -g :=\n  rfl\n\n"}
{"name":"AlternatingMap.sub_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN' : Type u_6\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nι : Type u_7\ng g₂ : AlternatingMap R M N' ι\nm : ι → M\n⊢ Eq ((HSub.hSub g g₂) m) (HSub.hSub (g m) (g₂ m))","decl":"@[simp]\ntheorem sub_apply (m : ι → M) : (g - g₂) m = g m - g₂ m :=\n  rfl\n\n"}
{"name":"AlternatingMap.coe_sub","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN' : Type u_6\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nι : Type u_7\ng g₂ : AlternatingMap R M N' ι\n⊢ Eq (↑(HSub.hSub g g₂)) (HSub.hSub ↑g ↑g₂)","decl":"@[norm_cast]\ntheorem coe_sub : (↑(g - g₂) : MultilinearMap R (fun _ : ι => M) N') = g - g₂ :=\n  rfl\n\n"}
{"name":"AlternatingMap.noZeroSMulDivisors","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : Semiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\nι : Type u_7\nS : Type u_10\ninst✝³ : Semiring S\ninst✝² : Module S N\ninst✝¹ : SMulCommClass R S N\ninst✝ : NoZeroSMulDivisors S N\n⊢ NoZeroSMulDivisors S (AlternatingMap R M N ι)","decl":"instance noZeroSMulDivisors [NoZeroSMulDivisors S N] :\n    NoZeroSMulDivisors S (M [⋀^ι]→ₗ[R] N) :=\n  coe_injective.noZeroSMulDivisors _ rfl coeFn_smul\n\n"}
{"name":"AlternatingMap.ofSubsingleton_symm_apply_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\ninst✝ : Subsingleton ι\ni : ι\nf : AlternatingMap R M N ι\nx : M\n⊢ Eq (((AlternatingMap.ofSubsingleton R M N i).symm f) x) (f fun x_1 => x)","decl":"/-- The natural equivalence between linear maps from `M` to `N`\nand `1`-multilinear alternating maps from `M` to `N`. -/\n@[simps!]\ndef ofSubsingleton [Subsingleton ι] (i : ι) : (M →ₗ[R] N) ≃ (M [⋀^ι]→ₗ[R] N) where\n  toFun f := ⟨MultilinearMap.ofSubsingleton R M N i f, fun _ _ _ _ ↦ absurd (Subsingleton.elim _ _)⟩\n  invFun f := (MultilinearMap.ofSubsingleton R M N i).symm f\n  left_inv _ := rfl\n  right_inv _ := coe_multilinearMap_injective <|\n    (MultilinearMap.ofSubsingleton R M N i).apply_symm_apply _\n\n"}
{"name":"AlternatingMap.ofSubsingleton_apply_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\ninst✝ : Subsingleton ι\ni : ι\nf : LinearMap (RingHom.id R) M N\nx : ι → M\n⊢ Eq (((AlternatingMap.ofSubsingleton R M N i) f) x) (f (x i))","decl":"/-- The natural equivalence between linear maps from `M` to `N`\nand `1`-multilinear alternating maps from `M` to `N`. -/\n@[simps!]\ndef ofSubsingleton [Subsingleton ι] (i : ι) : (M →ₗ[R] N) ≃ (M [⋀^ι]→ₗ[R] N) where\n  toFun f := ⟨MultilinearMap.ofSubsingleton R M N i f, fun _ _ _ _ ↦ absurd (Subsingleton.elim _ _)⟩\n  invFun f := (MultilinearMap.ofSubsingleton R M N i).symm f\n  left_inv _ := rfl\n  right_inv _ := coe_multilinearMap_injective <|\n    (MultilinearMap.ofSubsingleton R M N i).apply_symm_apply _\n\n"}
{"name":"AlternatingMap.constOfIsEmpty_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\ninst✝ : IsEmpty ι\nm : N\n⊢ Eq (⇑(AlternatingMap.constOfIsEmpty R M ι m)) (Function.const (ι → M) m)","decl":"/-- The constant map is alternating when `ι` is empty. -/\n@[simps (config := .asFn)]\ndef constOfIsEmpty [IsEmpty ι] (m : N) : M [⋀^ι]→ₗ[R] N :=\n  { MultilinearMap.constOfIsEmpty R _ m with\n    toFun := Function.const _ m\n    map_eq_zero_of_eq' := fun _ => isEmptyElim }\n\n"}
{"name":"AlternatingMap.codRestrict_apply_coe","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\np : Submodule R N\nh : ∀ (v : ι → M), Membership.mem p (f v)\nv : ι → M\n⊢ Eq (↑((f.codRestrict p h) v)) (f v)","decl":"/-- Restrict the codomain of an alternating map to a submodule. -/\n@[simps]\ndef codRestrict (f : M [⋀^ι]→ₗ[R] N) (p : Submodule R N) (h : ∀ v, f v ∈ p) :\n    M [⋀^ι]→ₗ[R] p :=\n  { f.toMultilinearMap.codRestrict p h with\n    toFun := fun v => ⟨f v, h v⟩\n    map_eq_zero_of_eq' := fun _ _ _ hv hij => Subtype.ext <| map_eq_zero_of_eq _ _ hv hij }\n\n"}
{"name":"LinearMap.coe_compAlternatingMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng : LinearMap (RingHom.id R) N N₂\nf : AlternatingMap R M N ι\n⊢ Eq (⇑(g.compAlternatingMap f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_compAlternatingMap (g : N →ₗ[R] N₂) (f : M [⋀^ι]→ₗ[R] N) :\n    ⇑(g.compAlternatingMap f) = g ∘ f :=\n  rfl\n\n"}
{"name":"LinearMap.compAlternatingMap_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng : LinearMap (RingHom.id R) N N₂\nf : AlternatingMap R M N ι\nm : ι → M\n⊢ Eq ((g.compAlternatingMap f) m) (g (f m))","decl":"@[simp]\ntheorem compAlternatingMap_apply (g : N →ₗ[R] N₂) (f : M [⋀^ι]→ₗ[R] N) (m : ι → M) :\n    g.compAlternatingMap f m = g (f m) :=\n  rfl\n\n"}
{"name":"LinearMap.compAlternatingMap_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng : LinearMap (RingHom.id R) N N₂\n⊢ Eq (g.compAlternatingMap 0) 0","decl":"@[simp]\ntheorem compAlternatingMap_zero (g : N →ₗ[R] N₂) :\n    g.compAlternatingMap (0 : M [⋀^ι]→ₗ[R] N) = 0 :=\n  AlternatingMap.ext fun _ => map_zero g\n\n"}
{"name":"LinearMap.zero_compAlternatingMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\nf : AlternatingMap R M N ι\n⊢ Eq (LinearMap.compAlternatingMap 0 f) 0","decl":"@[simp]\ntheorem zero_compAlternatingMap (f: M [⋀^ι]→ₗ[R] N) :\n    (0 : N →ₗ[R] N₂).compAlternatingMap f = 0 := rfl\n\n"}
{"name":"LinearMap.compAlternatingMap_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng : LinearMap (RingHom.id R) N N₂\nf₁ f₂ : AlternatingMap R M N ι\n⊢ Eq (g.compAlternatingMap (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (g.compAlternatingMap f₁) (g.compAlternatingMap f₂))","decl":"@[simp]\ntheorem compAlternatingMap_add (g : N →ₗ[R] N₂) (f₁ f₂ : M [⋀^ι]→ₗ[R] N) :\n    g.compAlternatingMap (f₁ + f₂) = g.compAlternatingMap f₁ + g.compAlternatingMap f₂ :=\n  AlternatingMap.ext fun _ => map_add g _ _\n\n"}
{"name":"LinearMap.add_compAlternatingMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng₁ g₂ : LinearMap (RingHom.id R) N N₂\nf : AlternatingMap R M N ι\n⊢ Eq ((HAdd.hAdd g₁ g₂).compAlternatingMap f) (HAdd.hAdd (g₁.compAlternatingMap f) (g₂.compAlternatingMap f))","decl":"@[simp]\ntheorem add_compAlternatingMap (g₁ g₂ : N →ₗ[R] N₂) (f: M [⋀^ι]→ₗ[R] N) :\n    (g₁ + g₂).compAlternatingMap f = g₁.compAlternatingMap f + g₂.compAlternatingMap f := rfl\n\n"}
{"name":"LinearMap.compAlternatingMap_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝¹² : Semiring R\nM : Type u_2\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\nN : Type u_3\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\nι : Type u_7\nS : Type u_10\nN₂ : Type u_11\ninst✝⁷ : AddCommMonoid N₂\ninst✝⁶ : Module R N₂\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S N\ninst✝³ : DistribMulAction S N₂\ninst✝² : SMulCommClass R S N\ninst✝¹ : SMulCommClass R S N₂\ninst✝ : LinearMap.CompatibleSMul N N₂ S R\ng : LinearMap (RingHom.id R) N N₂\ns : S\nf : AlternatingMap R M N ι\n⊢ Eq (g.compAlternatingMap (HSMul.hSMul s f)) (HSMul.hSMul s (g.compAlternatingMap f))","decl":"@[simp]\ntheorem compAlternatingMap_smul [Monoid S] [DistribMulAction S N] [DistribMulAction S N₂]\n    [SMulCommClass R S N] [SMulCommClass R S N₂] [CompatibleSMul N N₂ S R]\n    (g : N →ₗ[R] N₂) (s : S) (f : M [⋀^ι]→ₗ[R] N) :\n    g.compAlternatingMap (s • f) = s • g.compAlternatingMap f :=\n  AlternatingMap.ext fun _ => g.map_smul_of_tower _ _\n\n"}
{"name":"LinearMap.smul_compAlternatingMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_3\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nι : Type u_7\nS : Type u_10\nN₂ : Type u_11\ninst✝⁴ : AddCommMonoid N₂\ninst✝³ : Module R N₂\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N₂\ninst✝ : SMulCommClass R S N₂\ng : LinearMap (RingHom.id R) N N₂\ns : S\nf : AlternatingMap R M N ι\n⊢ Eq ((HSMul.hSMul s g).compAlternatingMap f) (HSMul.hSMul s (g.compAlternatingMap f))","decl":"@[simp]\ntheorem smul_compAlternatingMap [Monoid S] [DistribMulAction S N₂] [SMulCommClass R S N₂]\n    (g : N →ₗ[R] N₂) (s : S) (f : M [⋀^ι]→ₗ[R] N) :\n    (s • g).compAlternatingMap f = s • g.compAlternatingMap f := rfl\n\n"}
{"name":"LinearMap.compAlternatingMapₗ_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝¹² : Semiring R\nM : Type u_2\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\nN : Type u_3\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\nι : Type u_7\nS : Type u_10\nN₂ : Type u_11\ninst✝⁷ : AddCommMonoid N₂\ninst✝⁶ : Module R N₂\ninst✝⁵ : Semiring S\ninst✝⁴ : Module S N\ninst✝³ : Module S N₂\ninst✝² : SMulCommClass R S N\ninst✝¹ : SMulCommClass R S N₂\ninst✝ : LinearMap.CompatibleSMul N N₂ S R\ng : LinearMap (RingHom.id R) N N₂\nf : AlternatingMap R M N ι\n⊢ Eq ((LinearMap.compAlternatingMapₗ S g) f) (g.compAlternatingMap f)","decl":"variable (S) in\n/-- `LinearMap.compAlternatingMap` as an `S`-linear map. -/\n@[simps]\ndef compAlternatingMapₗ [Semiring S] [Module S N] [Module S N₂]\n    [SMulCommClass R S N] [SMulCommClass R S N₂] [LinearMap.CompatibleSMul N N₂ S R]\n    (g : N →ₗ[R] N₂) :\n    (M [⋀^ι]→ₗ[R] N) →ₗ[S] (M [⋀^ι]→ₗ[R] N₂) where\n  toFun := g.compAlternatingMap\n  map_add' := g.compAlternatingMap_add\n  map_smul' := g.compAlternatingMap_smul\n\n"}
{"name":"LinearMap.smulRight_eq_comp","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_12\nM₁ : Type u_13\nM₂ : Type u_14\nι : Type u_15\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nf : AlternatingMap R M₁ R ι\nz : M₂\n⊢ Eq (f.smulRight z) ((LinearMap.id.smulRight z).compAlternatingMap f)","decl":"theorem smulRight_eq_comp {R M₁ M₂ ι : Type*} [CommSemiring R] [AddCommMonoid M₁]\n    [AddCommMonoid M₂] [Module R M₁] [Module R M₂] (f : M₁ [⋀^ι]→ₗ[R] R) (z : M₂) :\n    f.smulRight z = (LinearMap.id.smulRight z).compAlternatingMap f :=\n  rfl\n\n"}
{"name":"LinearMap.subtype_compAlternatingMap_codRestrict","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\np : Submodule R N\nh : ∀ (v : ι → M), Membership.mem p (f v)\n⊢ Eq (p.subtype.compAlternatingMap (f.codRestrict p h)) f","decl":"@[simp]\ntheorem subtype_compAlternatingMap_codRestrict (f : M [⋀^ι]→ₗ[R] N) (p : Submodule R N)\n    (h) : p.subtype.compAlternatingMap (f.codRestrict p h) = f :=\n  AlternatingMap.ext fun _ => rfl\n\n"}
{"name":"LinearMap.compAlternatingMap_codRestrict","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nN₂ : Type u_11\ninst✝¹ : AddCommMonoid N₂\ninst✝ : Module R N₂\ng : LinearMap (RingHom.id R) N N₂\nf : AlternatingMap R M N ι\np : Submodule R N₂\nh : ∀ (c : N), Membership.mem p (g c)\n⊢ Eq ((LinearMap.codRestrict p g h).compAlternatingMap f) ((g.compAlternatingMap f).codRestrict p ⋯)","decl":"@[simp]\ntheorem compAlternatingMap_codRestrict (g : N →ₗ[R] N₂) (f : M [⋀^ι]→ₗ[R] N)\n    (p : Submodule R N₂) (h) :\n    (g.codRestrict p h).compAlternatingMap f =\n      (g.compAlternatingMap f).codRestrict p fun v => h (f v) :=\n  AlternatingMap.ext fun _ => rfl\n\n"}
{"name":"AlternatingMap.coe_compLinearMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : AlternatingMap R M N ι\ng : LinearMap (RingHom.id R) M₂ M\n⊢ Eq (⇑(f.compLinearMap g)) (Function.comp ⇑f fun x => Function.comp (⇑g) x)","decl":"theorem coe_compLinearMap (f : M [⋀^ι]→ₗ[R] N) (g : M₂ →ₗ[R] M) :\n    ⇑(f.compLinearMap g) = f ∘ (g ∘ ·) :=\n  rfl\n\n"}
{"name":"AlternatingMap.compLinearMap_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : AlternatingMap R M N ι\ng : LinearMap (RingHom.id R) M₂ M\nv : ι → M₂\n⊢ Eq ((f.compLinearMap g) v) (f fun i => g (v i))","decl":"@[simp]\ntheorem compLinearMap_apply (f : M [⋀^ι]→ₗ[R] N) (g : M₂ →ₗ[R] M) (v : ι → M₂) :\n    f.compLinearMap g v = f fun i => g (v i) :=\n  rfl\n\n"}
{"name":"AlternatingMap.compLinearMap_assoc","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : Semiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN : Type u_3\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nM₃ : Type u_11\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : AlternatingMap R M N ι\ng₁ : LinearMap (RingHom.id R) M₂ M\ng₂ : LinearMap (RingHom.id R) M₃ M₂\n⊢ Eq ((f.compLinearMap g₁).compLinearMap g₂) (f.compLinearMap (g₁.comp g₂))","decl":"/-- Composing an alternating map twice with the same linear map in each argument is\nthe same as composing with their composition. -/\ntheorem compLinearMap_assoc (f : M [⋀^ι]→ₗ[R] N) (g₁ : M₂ →ₗ[R] M) (g₂ : M₃ →ₗ[R] M₂) :\n    (f.compLinearMap g₁).compLinearMap g₂ = f.compLinearMap (g₁ ∘ₗ g₂) :=\n  rfl\n\n"}
{"name":"AlternatingMap.zero_compLinearMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\ng : LinearMap (RingHom.id R) M₂ M\n⊢ Eq (AlternatingMap.compLinearMap 0 g) 0","decl":"@[simp]\ntheorem zero_compLinearMap (g : M₂ →ₗ[R] M) : (0 : M [⋀^ι]→ₗ[R] N).compLinearMap g = 0 := by\n  ext\n  simp only [compLinearMap_apply, zero_apply]\n\n"}
{"name":"AlternatingMap.add_compLinearMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ f₂ : AlternatingMap R M N ι\ng : LinearMap (RingHom.id R) M₂ M\n⊢ Eq ((HAdd.hAdd f₁ f₂).compLinearMap g) (HAdd.hAdd (f₁.compLinearMap g) (f₂.compLinearMap g))","decl":"@[simp]\ntheorem add_compLinearMap (f₁ f₂ : M [⋀^ι]→ₗ[R] N) (g : M₂ →ₗ[R] M) :\n    (f₁ + f₂).compLinearMap g = f₁.compLinearMap g + f₂.compLinearMap g := by\n  ext\n  simp only [compLinearMap_apply, add_apply]\n\n"}
{"name":"AlternatingMap.compLinearMap_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Nonempty ι\nf : AlternatingMap R M N ι\n⊢ Eq (f.compLinearMap 0) 0","decl":"@[simp]\ntheorem compLinearMap_zero [Nonempty ι] (f : M [⋀^ι]→ₗ[R] N) :\n    f.compLinearMap (0 : M₂ →ₗ[R] M) = 0 := by\n  ext\n  simp_rw [compLinearMap_apply, LinearMap.zero_apply, ← Pi.zero_def, map_zero, zero_apply]\n\n"}
{"name":"AlternatingMap.compLinearMap_id","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\n⊢ Eq (f.compLinearMap LinearMap.id) f","decl":"/-- Composing an alternating map with the identity linear map in each argument. -/\n@[simp]\ntheorem compLinearMap_id (f : M [⋀^ι]→ₗ[R] N) : f.compLinearMap LinearMap.id = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AlternatingMap.compLinearMap_injective","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₂ M\nhf : Function.Surjective ⇑f\n⊢ Function.Injective fun g => g.compLinearMap f","decl":"/-- Composing with a surjective linear map is injective. -/\ntheorem compLinearMap_injective (f : M₂ →ₗ[R] M) (hf : Function.Surjective f) :\n    Function.Injective fun g : M [⋀^ι]→ₗ[R] N => g.compLinearMap f := fun g₁ g₂ h =>\n  ext fun x => by\n    simpa [Function.surjInv_eq hf] using AlternatingMap.ext_iff.mp h (Function.surjInv hf ∘ x)\n\n"}
{"name":"AlternatingMap.compLinearMap_inj","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₂ M\nhf : Function.Surjective ⇑f\ng₁ g₂ : AlternatingMap R M N ι\n⊢ Iff (Eq (g₁.compLinearMap f) (g₂.compLinearMap f)) (Eq g₁ g₂)","decl":"theorem compLinearMap_inj (f : M₂ →ₗ[R] M) (hf : Function.Surjective f)\n    (g₁ g₂ : M [⋀^ι]→ₗ[R] N) : g₁.compLinearMap f = g₂.compLinearMap f ↔ g₁ = g₂ :=\n  (compLinearMap_injective _ hf).eq_iff\n\n"}
{"name":"AlternatingMap.domLCongr_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_3\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\ne : LinearEquiv (RingHom.id R) M M₂\nf : AlternatingMap R M N ι\n⊢ Eq ((AlternatingMap.domLCongr R N ι S e) f) (f.compLinearMap ↑e.symm)","decl":"/-- Construct a linear equivalence between maps from a linear equivalence between domains. -/\n@[simps apply]\ndef domLCongr (e : M ≃ₗ[R] M₂) : M [⋀^ι]→ₗ[R] N ≃ₗ[S] (M₂ [⋀^ι]→ₗ[R] N) where\n  toFun f := f.compLinearMap e.symm\n  invFun g := g.compLinearMap e\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv f := AlternatingMap.ext fun _ => f.congr_arg <| funext fun _ => e.symm_apply_apply _\n  right_inv f := AlternatingMap.ext fun _ => f.congr_arg <| funext fun _ => e.apply_symm_apply _\n\n"}
{"name":"AlternatingMap.domLCongr_refl","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\n⊢ Eq (AlternatingMap.domLCongr R N ι S (LinearEquiv.refl R M)) (LinearEquiv.refl S (AlternatingMap R M N ι))","decl":"@[simp]\ntheorem domLCongr_refl : domLCongr R N ι S (LinearEquiv.refl R M) = LinearEquiv.refl S _ :=\n  LinearEquiv.ext fun _ => AlternatingMap.ext fun _ => rfl\n\n"}
{"name":"AlternatingMap.domLCongr_symm","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nN : Type u_3\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\ne : LinearEquiv (RingHom.id R) M M₂\n⊢ Eq (AlternatingMap.domLCongr R N ι S e).symm (AlternatingMap.domLCongr R N ι S e.symm)","decl":"@[simp]\ntheorem domLCongr_symm (e : M ≃ₗ[R] M₂) : (domLCongr R N ι S e).symm = domLCongr R N ι S e.symm :=\n  rfl\n\n"}
{"name":"AlternatingMap.domLCongr_trans","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : Semiring R\nM : Type u_2\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\nN : Type u_3\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M₂\nM₃ : Type u_11\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₃\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\ne : LinearEquiv (RingHom.id R) M M₂\nf : LinearEquiv (RingHom.id R) M₂ M₃\n⊢ Eq ((AlternatingMap.domLCongr R N ι S e).trans (AlternatingMap.domLCongr R N ι S f)) (AlternatingMap.domLCongr R N ι S (e.trans f))","decl":"theorem domLCongr_trans (e : M ≃ₗ[R] M₂) (f : M₂ ≃ₗ[R] M₃) :\n    (domLCongr R N ι S e).trans (domLCongr R N ι S f) = domLCongr R N ι S (e.trans f) :=\n  rfl\n\n"}
{"name":"AlternatingMap.compLinearEquiv_eq_zero_iff","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nι : Type u_7\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : AlternatingMap R M N ι\ng : LinearEquiv (RingHom.id R) M₂ M\n⊢ Iff (Eq (f.compLinearMap ↑g) 0) (Eq f 0)","decl":"/-- Composing an alternating map with the same linear equiv on each argument gives the zero map\nif and only if the alternating map is the zero map. -/\n@[simp]\ntheorem compLinearEquiv_eq_zero_iff (f : M [⋀^ι]→ₗ[R] N) (g : M₂ ≃ₗ[R] M) :\n    f.compLinearMap (g : M₂ →ₗ[R] M) = 0 ↔ f = 0 :=\n  (domLCongr R N ι ℕ g.symm).map_eq_zero_iff\n\n"}
{"name":"AlternatingMap.map_update_sum","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nα : Type u_12\ninst✝ : DecidableEq ι\nt : Finset α\ni : ι\ng : α → M\nm : ι → M\n⊢ Eq (f (Function.update m i (t.sum fun a => g a))) (t.sum fun a => f (Function.update m i (g a)))","decl":"theorem map_update_sum {α : Type*} [DecidableEq ι] (t : Finset α) (i : ι) (g : α → M) (m : ι → M) :\n    f (update m i (∑ a ∈ t, g a)) = ∑ a ∈ t, f (update m i (g a)) :=\n  f.toMultilinearMap.map_update_sum t i g m\n\n"}
{"name":"AlternatingMap.map_update_self","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\n⊢ Eq (f (Function.update v i (v j))) 0","decl":"theorem map_update_self [DecidableEq ι] {i j : ι} (hij : i ≠ j) :\n    f (Function.update v i (v j)) = 0 :=\n  f.map_eq_zero_of_eq _ (by rw [Function.update_self, Function.update_of_ne hij.symm]) hij\n\n"}
{"name":"AlternatingMap.map_update_update","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\nm : M\n⊢ Eq (f (Function.update (Function.update v i m) j m)) 0","decl":"theorem map_update_update [DecidableEq ι] {i j : ι} (hij : i ≠ j) (m : M) :\n    f (Function.update (Function.update v i m) j m) = 0 :=\n  f.map_eq_zero_of_eq _\n    (by rw [Function.update_self, Function.update_of_ne hij, Function.update_self]) hij\n\n"}
{"name":"AlternatingMap.map_swap_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\n⊢ Eq (HAdd.hAdd (f (Function.comp v ⇑(Equiv.swap i j))) (f v)) 0","decl":"theorem map_swap_add [DecidableEq ι] {i j : ι} (hij : i ≠ j) :\n    f (v ∘ Equiv.swap i j) + f v = 0 := by\n  rw [Equiv.comp_swap_eq_update]\n  convert f.map_update_update v hij (v i + v j)\n  simp [f.map_update_self _ hij, f.map_update_self _ hij.symm,\n    Function.update_comm hij (v i + v j) (v _) v, Function.update_comm hij.symm (v i) (v i) v]\n\n"}
{"name":"AlternatingMap.map_add_swap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\nv : ι → M\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\n⊢ Eq (HAdd.hAdd (f v) (f (Function.comp v ⇑(Equiv.swap i j)))) 0","decl":"theorem map_add_swap [DecidableEq ι] {i j : ι} (hij : i ≠ j) :\n    f v + f (v ∘ Equiv.swap i j) = 0 := by\n  rw [add_comm]\n  exact f.map_swap_add v hij\n\n"}
{"name":"AlternatingMap.map_swap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN' : Type u_6\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\nv : ι → M\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\n⊢ Eq (g (Function.comp v ⇑(Equiv.swap i j))) (Neg.neg (g v))","decl":"theorem map_swap [DecidableEq ι] {i j : ι} (hij : i ≠ j) : g (v ∘ Equiv.swap i j) = -g v :=\n  eq_neg_of_add_eq_zero_left <| g.map_swap_add v hij\n\n"}
{"name":"AlternatingMap.map_perm","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nv : ι → M\nσ : Equiv.Perm ι\n⊢ Eq (g (Function.comp v ⇑σ)) (HSMul.hSMul (Equiv.Perm.sign σ) (g v))","decl":"theorem map_perm [DecidableEq ι] [Fintype ι] (v : ι → M) (σ : Equiv.Perm ι) :\n    g (v ∘ σ) = Equiv.Perm.sign σ • g v := by\n  -- Porting note: `apply` → `induction'`\n  induction' σ using Equiv.Perm.swap_induction_on' with s x y hxy hI\n  · simp\n  · -- Porting note: `← Function.comp_assoc` & `-Equiv.Perm.sign_swap'` are required.\n    simpa [← Function.comp_assoc, g.map_swap (v ∘ s) hxy,\n      Equiv.Perm.sign_swap hxy, -Equiv.Perm.sign_swap'] using hI\n\n"}
{"name":"AlternatingMap.map_congr_perm","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\nv : ι → M\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nσ : Equiv.Perm ι\n⊢ Eq (g v) (HSMul.hSMul (Equiv.Perm.sign σ) (g (Function.comp v ⇑σ)))","decl":"theorem map_congr_perm [DecidableEq ι] [Fintype ι] (σ : Equiv.Perm ι) :\n    g v = Equiv.Perm.sign σ • g (v ∘ σ) := by\n  rw [g.map_perm, smul_smul]\n  simp\n\n"}
{"name":"AlternatingMap.domDomCongr_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι\nv : ι' → M\n⊢ Eq ((AlternatingMap.domDomCongr σ f) v) (f (Function.comp v ⇑σ))","decl":"/-- Transfer the arguments to a map along an equivalence between argument indices.\n\nThis is the alternating version of `MultilinearMap.domDomCongr`. -/\n@[simps]\ndef domDomCongr (σ : ι ≃ ι') (f : M [⋀^ι]→ₗ[R] N) : M [⋀^ι']→ₗ[R] N :=\n  { f.toMultilinearMap.domDomCongr σ with\n    toFun := fun v => f (v ∘ σ)\n    map_eq_zero_of_eq' := fun v i j hv hij =>\n      f.map_eq_zero_of_eq (v ∘ σ) (i := σ.symm i) (j := σ.symm j)\n        (by simpa using hv) (σ.symm.injective.ne hij) }\n\n"}
{"name":"AlternatingMap.domDomCongr_refl","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nf : AlternatingMap R M N ι\n⊢ Eq (AlternatingMap.domDomCongr (Equiv.refl ι) f) f","decl":"@[simp]\ntheorem domDomCongr_refl (f : M [⋀^ι]→ₗ[R] N) : f.domDomCongr (Equiv.refl ι) = f := rfl\n\n"}
{"name":"AlternatingMap.domDomCongr_trans","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nι'' : Type u_9\nσ₁ : Equiv ι ι'\nσ₂ : Equiv ι' ι''\nf : AlternatingMap R M N ι\n⊢ Eq (AlternatingMap.domDomCongr (σ₁.trans σ₂) f) (AlternatingMap.domDomCongr σ₂ (AlternatingMap.domDomCongr σ₁ f))","decl":"theorem domDomCongr_trans (σ₁ : ι ≃ ι') (σ₂ : ι' ≃ ι'') (f : M [⋀^ι]→ₗ[R] N) :\n    f.domDomCongr (σ₁.trans σ₂) = (f.domDomCongr σ₁).domDomCongr σ₂ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongr_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\n⊢ Eq (AlternatingMap.domDomCongr σ 0) 0","decl":"@[simp]\ntheorem domDomCongr_zero (σ : ι ≃ ι') : (0 : M [⋀^ι]→ₗ[R] N).domDomCongr σ = 0 :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongr_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf g : AlternatingMap R M N ι\n⊢ Eq (AlternatingMap.domDomCongr σ (HAdd.hAdd f g)) (HAdd.hAdd (AlternatingMap.domDomCongr σ f) (AlternatingMap.domDomCongr σ g))","decl":"@[simp]\ntheorem domDomCongr_add (σ : ι ≃ ι') (f g : M [⋀^ι]→ₗ[R] N) :\n    (f + g).domDomCongr σ = f.domDomCongr σ + g.domDomCongr σ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongr_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nι' : Type u_8\nS : Type u_12\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass R S N\nσ : Equiv ι ι'\nc : S\nf : AlternatingMap R M N ι\n⊢ Eq (AlternatingMap.domDomCongr σ (HSMul.hSMul c f)) (HSMul.hSMul c (AlternatingMap.domDomCongr σ f))","decl":"@[simp]\ntheorem domDomCongr_smul {S : Type*} [Monoid S] [DistribMulAction S N] [SMulCommClass R S N]\n    (σ : ι ≃ ι') (c : S) (f : M [⋀^ι]→ₗ[R] N) :\n    (c • f).domDomCongr σ = c • f.domDomCongr σ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongrEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι'\n⊢ Eq ((AlternatingMap.domDomCongrEquiv σ).symm f) (AlternatingMap.domDomCongr σ.symm f)","decl":"/-- `AlternatingMap.domDomCongr` as an equivalence.\n\nThis is declared separately because it does not work with dot notation. -/\n@[simps apply symm_apply]\ndef domDomCongrEquiv (σ : ι ≃ ι') : M [⋀^ι]→ₗ[R] N ≃+ M [⋀^ι']→ₗ[R] N where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv f := by\n    ext\n    simp [Function.comp_def]\n  right_inv m := by\n    ext\n    simp [Function.comp_def]\n  map_add' := domDomCongr_add σ\n\n"}
{"name":"AlternatingMap.domDomCongrEquiv_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι\n⊢ Eq ((AlternatingMap.domDomCongrEquiv σ) f) (AlternatingMap.domDomCongr σ f)","decl":"/-- `AlternatingMap.domDomCongr` as an equivalence.\n\nThis is declared separately because it does not work with dot notation. -/\n@[simps apply symm_apply]\ndef domDomCongrEquiv (σ : ι ≃ ι') : M [⋀^ι]→ₗ[R] N ≃+ M [⋀^ι']→ₗ[R] N where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv f := by\n    ext\n    simp [Function.comp_def]\n  right_inv m := by\n    ext\n    simp [Function.comp_def]\n  map_add' := domDomCongr_add σ\n\n"}
{"name":"AlternatingMap.domDomCongrₗ_symm_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nι' : Type u_8\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι'\n⊢ Eq ((AlternatingMap.domDomCongrₗ S σ).symm f) (AlternatingMap.domDomCongr σ.symm f)","decl":"/-- `AlternatingMap.domDomCongr` as a linear equivalence. -/\n@[simps apply symm_apply]\ndef domDomCongrₗ (σ : ι ≃ ι') : M [⋀^ι]→ₗ[R] N ≃ₗ[S] M [⋀^ι']→ₗ[R] N where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv f := by ext; simp [Function.comp_def]\n  right_inv m := by ext; simp [Function.comp_def]\n  map_add' := domDomCongr_add σ\n  map_smul' := domDomCongr_smul σ\n\n"}
{"name":"AlternatingMap.domDomCongrₗ_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nι' : Type u_8\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι\n⊢ Eq ((AlternatingMap.domDomCongrₗ S σ) f) (AlternatingMap.domDomCongr σ f)","decl":"/-- `AlternatingMap.domDomCongr` as a linear equivalence. -/\n@[simps apply symm_apply]\ndef domDomCongrₗ (σ : ι ≃ ι') : M [⋀^ι]→ₗ[R] N ≃ₗ[S] M [⋀^ι']→ₗ[R] N where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv f := by ext; simp [Function.comp_def]\n  right_inv m := by ext; simp [Function.comp_def]\n  map_add' := domDomCongr_add σ\n  map_smul' := domDomCongr_smul σ\n\n"}
{"name":"AlternatingMap.domDomCongrₗ_refl","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\n⊢ Eq (AlternatingMap.domDomCongrₗ S (Equiv.refl ι)) (LinearEquiv.refl S (AlternatingMap R M N ι))","decl":"@[simp]\ntheorem domDomCongrₗ_refl :\n    (domDomCongrₗ S (Equiv.refl ι) : M [⋀^ι]→ₗ[R] N ≃ₗ[S] M [⋀^ι]→ₗ[R] N) =\n      LinearEquiv.refl _ _ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongrₗ_toAddEquiv","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nN : Type u_3\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_7\nι' : Type u_8\nS : Type u_12\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nσ : Equiv ι ι'\n⊢ Eq (↑(AlternatingMap.domDomCongrₗ S σ)) (AlternatingMap.domDomCongrEquiv σ)","decl":"@[simp]\ntheorem domDomCongrₗ_toAddEquiv (σ : ι ≃ ι') :\n    (↑(domDomCongrₗ S σ : M [⋀^ι]→ₗ[R] N ≃ₗ[S] _) : M [⋀^ι]→ₗ[R] N ≃+ _) =\n      domDomCongrEquiv σ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domDomCongr_eq_iff","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf g : AlternatingMap R M N ι\n⊢ Iff (Eq (AlternatingMap.domDomCongr σ f) (AlternatingMap.domDomCongr σ g)) (Eq f g)","decl":"/-- The results of applying `domDomCongr` to two maps are equal if and only if those maps are. -/\n@[simp]\ntheorem domDomCongr_eq_iff (σ : ι ≃ ι') (f g : M [⋀^ι]→ₗ[R] N) :\n    f.domDomCongr σ = g.domDomCongr σ ↔ f = g :=\n  (domDomCongrEquiv σ : _ ≃+ M [⋀^ι']→ₗ[R] N).apply_eq_iff_eq\n\n"}
{"name":"AlternatingMap.domDomCongr_eq_zero_iff","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nσ : Equiv ι ι'\nf : AlternatingMap R M N ι\n⊢ Iff (Eq (AlternatingMap.domDomCongr σ f) 0) (Eq f 0)","decl":"@[simp]\ntheorem domDomCongr_eq_zero_iff (σ : ι ≃ ι') (f : M [⋀^ι]→ₗ[R] N) :\n    f.domDomCongr σ = 0 ↔ f = 0 :=\n  (domDomCongrEquiv σ : M [⋀^ι]→ₗ[R] N ≃+ M [⋀^ι']→ₗ[R] N).map_eq_zero_iff\n\n"}
{"name":"AlternatingMap.domDomCongr_perm","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ng : AlternatingMap R M N' ι\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nσ : Equiv.Perm ι\n⊢ Eq (AlternatingMap.domDomCongr σ g) (HSMul.hSMul (Equiv.Perm.sign σ) g)","decl":"theorem domDomCongr_perm [Fintype ι] [DecidableEq ι] (σ : Equiv.Perm ι) :\n    g.domDomCongr σ = Equiv.Perm.sign σ • g :=\n  AlternatingMap.ext fun v => g.map_perm v σ\n\n"}
{"name":"AlternatingMap.coe_domDomCongr","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nι' : Type u_8\nf : AlternatingMap R M N ι\nσ : Equiv ι ι'\n⊢ Eq (↑(AlternatingMap.domDomCongr σ f)) (MultilinearMap.domDomCongr σ ↑f)","decl":"@[norm_cast]\ntheorem coe_domDomCongr (σ : ι ≃ ι') :\n    ↑(f.domDomCongr σ) = (f : MultilinearMap R (fun _ : ι => M) N).domDomCongr σ :=\n  MultilinearMap.ext fun _ => rfl\n\n"}
{"name":"AlternatingMap.map_linearDependent","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"ι : Type u_7\nK : Type u_12\ninst✝⁵ : Ring K\nM : Type u_13\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module K M\nN : Type u_14\ninst✝² : AddCommGroup N\ninst✝¹ : Module K N\ninst✝ : NoZeroSMulDivisors K N\nf : AlternatingMap K M N ι\nv : ι → M\nh : Not (LinearIndependent K v)\n⊢ Eq (f v) 0","decl":"/-- If the arguments are linearly dependent then the result is `0`. -/\ntheorem map_linearDependent {K : Type*} [Ring K] {M : Type*} [AddCommGroup M] [Module K M]\n    {N : Type*} [AddCommGroup N] [Module K N] [NoZeroSMulDivisors K N] (f : M [⋀^ι]→ₗ[K] N)\n    (v : ι → M) (h : ¬LinearIndependent K v) : f v = 0 := by\n  obtain ⟨s, g, h, i, hi, hz⟩ := not_linearIndependent_iff.mp h\n  letI := Classical.decEq ι\n  suffices f (update v i (g i • v i)) = 0 by\n    rw [f.map_update_smul, Function.update_eq_self, smul_eq_zero] at this\n    exact Or.resolve_left this hz\n  -- Porting note: Was `conv at h in .. => ..`.\n  rw [← (funext fun x => ite_self (c := i = x) (d := Classical.decEq ι i x) (g x • v x))] at h\n  rw [Finset.sum_ite, Finset.filter_eq, Finset.filter_ne, if_pos hi, Finset.sum_singleton,\n    add_eq_zero_iff_eq_neg] at h\n  rw [h, f.map_update_neg, f.map_update_sum, neg_eq_zero]; apply Finset.sum_eq_zero\n  intro j hj\n  obtain ⟨hij, _⟩ := Finset.mem_erase.mp hj\n  rw [f.map_update_smul, f.map_update_self _ hij.symm, smul_zero]\n\n"}
{"name":"AlternatingMap.map_vecCons_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nn : Nat\nf : AlternatingMap R M N (Fin n.succ)\nm : Fin n → M\nx y : M\n⊢ Eq (f (Matrix.vecCons (HAdd.hAdd x y) m)) (HAdd.hAdd (f (Matrix.vecCons x m)) (f (Matrix.vecCons y m)))","decl":"/-- A version of `MultilinearMap.cons_add` for `AlternatingMap`. -/\ntheorem map_vecCons_add {n : ℕ} (f : M [⋀^Fin n.succ]→ₗ[R] N) (m : Fin n → M) (x y : M) :\n    f (Matrix.vecCons (x + y) m) = f (Matrix.vecCons x m) + f (Matrix.vecCons y m) :=\n  f.toMultilinearMap.cons_add _ _ _\n\n"}
{"name":"AlternatingMap.map_vecCons_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nn : Nat\nf : AlternatingMap R M N (Fin n.succ)\nm : Fin n → M\nc : R\nx : M\n⊢ Eq (f (Matrix.vecCons (HSMul.hSMul c x) m)) (HSMul.hSMul c (f (Matrix.vecCons x m)))","decl":"/-- A version of `MultilinearMap.cons_smul` for `AlternatingMap`. -/\ntheorem map_vecCons_smul {n : ℕ} (f : M [⋀^Fin n.succ]→ₗ[R] N) (m : Fin n → M) (c : R)\n    (x : M) : f (Matrix.vecCons (c • x) m) = c • f (Matrix.vecCons x m) :=\n  f.toMultilinearMap.cons_smul _ _ _\n\n"}
{"name":"MultilinearMap.alternatization_def","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nm : MultilinearMap R (fun x => M) N'\n⊢ Eq ⇑(MultilinearMap.alternatization m) ⇑(Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) (MultilinearMap.domDomCongr σ m))","decl":"theorem alternatization_def (m : MultilinearMap R (fun _ : ι => M) N') :\n    ⇑(alternatization m) = (∑ σ : Perm ι, Equiv.Perm.sign σ • m.domDomCongr σ :) :=\n  rfl\n\n"}
{"name":"MultilinearMap.alternatization_coe","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nm : MultilinearMap R (fun x => M) N'\n⊢ Eq (↑(MultilinearMap.alternatization m)) (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) (MultilinearMap.domDomCongr σ m))","decl":"theorem alternatization_coe (m : MultilinearMap R (fun _ : ι => M) N') :\n    ↑(alternatization m) = (∑ σ : Perm ι, Equiv.Perm.sign σ • m.domDomCongr σ :) :=\n  coe_injective rfl\n\n"}
{"name":"MultilinearMap.alternatization_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nm : MultilinearMap R (fun x => M) N'\nv : ι → M\n⊢ Eq ((MultilinearMap.alternatization m) v) (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) ((MultilinearMap.domDomCongr σ m) v))","decl":"theorem alternatization_apply (m : MultilinearMap R (fun _ : ι => M) N') (v : ι → M) :\n    alternatization m v = ∑ σ : Perm ι, Equiv.Perm.sign σ • m.domDomCongr σ v := by\n  simp only [alternatization_def, smul_apply, sum_apply]\n\n"}
{"name":"AlternatingMap.coe_alternatization","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN' : Type u_6\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\nι : Type u_7\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\na : AlternatingMap R M N' ι\n⊢ Eq (MultilinearMap.alternatization ↑a) (HSMul.hSMul (Fintype.card ι).factorial a)","decl":"/-- Alternatizing a multilinear map that is already alternating results in a scale factor of `n!`,\nwhere `n` is the number of inputs. -/\ntheorem coe_alternatization [DecidableEq ι] [Fintype ι] (a : M [⋀^ι]→ₗ[R] N') :\n    MultilinearMap.alternatization (a : MultilinearMap R (fun _ => M) N')\n    = Nat.factorial (Fintype.card ι) • a := by\n  apply AlternatingMap.coe_injective\n  simp_rw [MultilinearMap.alternatization_def, ← coe_domDomCongr, domDomCongr_perm, coe_smul,\n    smul_smul, Int.units_mul_self, one_smul, Finset.sum_const, Finset.card_univ, Fintype.card_perm,\n    ← coe_multilinearMap, coe_smul]\n\n"}
{"name":"LinearMap.compMultilinearMap_alternatization","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : Semiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nN' : Type u_6\ninst✝⁵ : AddCommGroup N'\ninst✝⁴ : Module R N'\nι : Type u_7\nN'₂ : Type u_10\ninst✝³ : AddCommGroup N'₂\ninst✝² : Module R N'₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ng : LinearMap (RingHom.id R) N' N'₂\nf : MultilinearMap R (fun x => M) N'\n⊢ Eq (MultilinearMap.alternatization (g.compMultilinearMap f)) (g.compAlternatingMap (MultilinearMap.alternatization f))","decl":"/-- Composition with a linear map before and after alternatization are equivalent. -/\ntheorem compMultilinearMap_alternatization (g : N' →ₗ[R] N'₂)\n    (f : MultilinearMap R (fun _ : ι => M) N') :\n    MultilinearMap.alternatization (g.compMultilinearMap f)\n      = g.compAlternatingMap (MultilinearMap.alternatization f) := by\n  ext\n  simp [MultilinearMap.alternatization_def]\n\n"}
{"name":"Basis.ext_alternating","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"ι : Type u_7\nι₁ : Type u_10\ninst✝⁵ : Finite ι\nR' : Type u_11\nN₁ : Type u_12\nN₂ : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid N₁\ninst✝² : AddCommMonoid N₂\ninst✝¹ : Module R' N₁\ninst✝ : Module R' N₂\nf g : AlternatingMap R' N₁ N₂ ι\ne : Basis ι₁ R' N₁\nh : ∀ (v : ι → ι₁), Function.Injective v → Eq (f fun i => e (v i)) (g fun i => e (v i))\n⊢ Eq f g","decl":"/-- Two alternating maps indexed by a `Fintype` are equal if they are equal when all arguments\nare distinct basis vectors. -/\ntheorem Basis.ext_alternating {f g : N₁ [⋀^ι]→ₗ[R'] N₂} (e : Basis ι₁ R' N₁)\n    (h : ∀ v : ι → ι₁, Function.Injective v → (f fun i => e (v i)) = g fun i => e (v i)) :\n    f = g := by\n  classical\n    refine AlternatingMap.coe_multilinearMap_injective (Basis.ext_multilinear e fun v => ?_)\n    by_cases hi : Function.Injective v\n    · exact h v hi\n    · have : ¬Function.Injective fun i => e (v i) := hi.imp Function.Injective.of_comp\n      rw [coe_multilinearMap, coe_multilinearMap, f.map_eq_zero_of_not_injective _ this,\n        g.map_eq_zero_of_not_injective _ this]\n\n"}
{"name":"AlternatingMap.curryLeft_apply_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\nf : AlternatingMap R' M'' N'' (Fin n.succ)\nm : M''\nv : Fin n → M''\n⊢ Eq ((f.curryLeft m) v) (f (Matrix.vecCons m v))","decl":"/-- Given an alternating map `f` in `n+1` variables, split the first variable to obtain\na linear map into alternating maps in `n` variables, given by `x ↦ (m ↦ f (Matrix.vecCons x m))`.\nIt can be thought of as a map $Hom(\\bigwedge^{n+1} M, N) \\to Hom(M, Hom(\\bigwedge^n M, N))$.\n\nThis is `MultilinearMap.curryLeft` for `AlternatingMap`. See also\n`AlternatingMap.curryLeftLinearMap`. -/\n@[simps]\ndef curryLeft {n : ℕ} (f : M'' [⋀^Fin n.succ]→ₗ[R'] N'') :\n    M'' →ₗ[R'] M'' [⋀^Fin n]→ₗ[R'] N'' where\n  toFun m :=\n    { f.toMultilinearMap.curryLeft m with\n      toFun := fun v => f (Matrix.vecCons m v)\n      map_eq_zero_of_eq' := fun v i j hv hij =>\n        f.map_eq_zero_of_eq _ (by\n          rwa [Matrix.cons_val_succ, Matrix.cons_val_succ]) ((Fin.succ_injective _).ne hij) }\n  map_add' _ _ := ext fun _ => f.map_vecCons_add _ _ _\n  map_smul' _ _ := ext fun _ => f.map_vecCons_smul _ _ _\n\n"}
{"name":"AlternatingMap.curryLeft_zero","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\n⊢ Eq (AlternatingMap.curryLeft 0) 0","decl":"@[simp]\ntheorem curryLeft_zero {n : ℕ} : curryLeft (0 : M'' [⋀^Fin n.succ]→ₗ[R'] N'') = 0 :=\n  rfl\n\n"}
{"name":"AlternatingMap.curryLeft_add","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\nf g : AlternatingMap R' M'' N'' (Fin n.succ)\n⊢ Eq (HAdd.hAdd f g).curryLeft (HAdd.hAdd f.curryLeft g.curryLeft)","decl":"@[simp]\ntheorem curryLeft_add {n : ℕ} (f g : M'' [⋀^Fin n.succ]→ₗ[R'] N'') :\n    curryLeft (f + g) = curryLeft f + curryLeft g :=\n  rfl\n\n"}
{"name":"AlternatingMap.curryLeft_smul","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\nr : R'\nf : AlternatingMap R' M'' N'' (Fin n.succ)\n⊢ Eq (HSMul.hSMul r f).curryLeft (HSMul.hSMul r f.curryLeft)","decl":"@[simp]\ntheorem curryLeft_smul {n : ℕ} (r : R') (f : M'' [⋀^Fin n.succ]→ₗ[R'] N'') :\n    curryLeft (r • f) = r • curryLeft f :=\n  rfl\n\n"}
{"name":"AlternatingMap.curryLeftLinearMap_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\nf : AlternatingMap R' M'' N'' (Fin n.succ)\n⊢ Eq (AlternatingMap.curryLeftLinearMap f) f.curryLeft","decl":"/-- `AlternatingMap.curryLeft` as a `LinearMap`. This is a separate definition as dot notation\ndoes not work for this version. -/\n@[simps]\ndef curryLeftLinearMap {n : ℕ} :\n    (M'' [⋀^Fin n.succ]→ₗ[R'] N'') →ₗ[R'] M'' →ₗ[R'] M'' [⋀^Fin n]→ₗ[R'] N'' where\n  toFun f := f.curryLeft\n  map_add' := curryLeft_add\n  map_smul' := curryLeft_smul\n\n"}
{"name":"AlternatingMap.curryLeft_same","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁴ : CommSemiring R'\ninst✝³ : AddCommMonoid M''\ninst✝² : AddCommMonoid N''\ninst✝¹ : Module R' M''\ninst✝ : Module R' N''\nn : Nat\nf : AlternatingMap R' M'' N'' (Fin n.succ.succ)\nm : M''\n⊢ Eq ((f.curryLeft m).curryLeft m) 0","decl":"/-- Currying with the same element twice gives the zero map. -/\n@[simp]\ntheorem curryLeft_same {n : ℕ} (f : M'' [⋀^Fin n.succ.succ]→ₗ[R'] N'') (m : M'') :\n    (f.curryLeft m).curryLeft m = 0 :=\n  ext fun _ => f.map_eq_zero_of_eq _ (by simp) Fin.zero_ne_one\n\n"}
{"name":"AlternatingMap.curryLeft_compAlternatingMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\nN₂'' : Type u_14\ninst✝⁶ : CommSemiring R'\ninst✝⁵ : AddCommMonoid M''\ninst✝⁴ : AddCommMonoid N''\ninst✝³ : AddCommMonoid N₂''\ninst✝² : Module R' M''\ninst✝¹ : Module R' N''\ninst✝ : Module R' N₂''\nn : Nat\ng : LinearMap (RingHom.id R') N'' N₂''\nf : AlternatingMap R' M'' N'' (Fin n.succ)\nm : M''\n⊢ Eq ((g.compAlternatingMap f).curryLeft m) (g.compAlternatingMap (f.curryLeft m))","decl":"@[simp]\ntheorem curryLeft_compAlternatingMap {n : ℕ} (g : N'' →ₗ[R'] N₂'')\n    (f : M'' [⋀^Fin n.succ]→ₗ[R'] N'') (m : M'') :\n    (g.compAlternatingMap f).curryLeft m = g.compAlternatingMap (f.curryLeft m) :=\n  rfl\n\n"}
{"name":"AlternatingMap.curryLeft_compLinearMap","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"R' : Type u_10\nM'' : Type u_11\nM₂'' : Type u_12\nN'' : Type u_13\ninst✝⁶ : CommSemiring R'\ninst✝⁵ : AddCommMonoid M''\ninst✝⁴ : AddCommMonoid M₂''\ninst✝³ : AddCommMonoid N''\ninst✝² : Module R' M''\ninst✝¹ : Module R' M₂''\ninst✝ : Module R' N''\nn : Nat\ng : LinearMap (RingHom.id R') M₂'' M''\nf : AlternatingMap R' M'' N'' (Fin n.succ)\nm : M₂''\n⊢ Eq ((f.compLinearMap g).curryLeft m) ((f.curryLeft (g m)).compLinearMap g)","decl":"@[simp]\ntheorem curryLeft_compLinearMap {n : ℕ} (g : M₂'' →ₗ[R'] M'')\n    (f : M'' [⋀^Fin n.succ]→ₗ[R'] N'') (m : M₂'') :\n    (f.compLinearMap g).curryLeft m = (f.curryLeft (g m)).compLinearMap g :=\n  ext fun v => congr_arg f <| funext <| by\n    refine Fin.cases ?_ ?_\n    · rfl\n    · simp\n\n"}
{"name":"AlternatingMap.constLinearEquivOfIsEmpty_symm_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"ι : Type u_7\nR' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁵ : CommSemiring R'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : AddCommMonoid N''\ninst✝² : Module R' M''\ninst✝¹ : Module R' N''\ninst✝ : IsEmpty ι\nf : AlternatingMap R' M'' N'' ι\n⊢ Eq (AlternatingMap.constLinearEquivOfIsEmpty.symm f) (f 0)","decl":"/-- The space of constant maps is equivalent to the space of maps that are alternating with respect\nto an empty family. -/\n@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty ι] : N'' ≃ₗ[R'] (M'' [⋀^ι]→ₗ[R'] N'') where\n  toFun := AlternatingMap.constOfIsEmpty R' M'' ι\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => AlternatingMap.congr_arg f <| Subsingleton.elim _ _\n\n"}
{"name":"AlternatingMap.constLinearEquivOfIsEmpty_apply","module":"Mathlib.LinearAlgebra.Alternating.Basic","initialProofState":"ι : Type u_7\nR' : Type u_10\nM'' : Type u_11\nN'' : Type u_13\ninst✝⁵ : CommSemiring R'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : AddCommMonoid N''\ninst✝² : Module R' M''\ninst✝¹ : Module R' N''\ninst✝ : IsEmpty ι\nm : N''\n⊢ Eq (AlternatingMap.constLinearEquivOfIsEmpty m) (AlternatingMap.constOfIsEmpty R' M'' ι m)","decl":"/-- The space of constant maps is equivalent to the space of maps that are alternating with respect\nto an empty family. -/\n@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty ι] : N'' ≃ₗ[R'] (M'' [⋀^ι]→ₗ[R'] N'') where\n  toFun := AlternatingMap.constOfIsEmpty R' M'' ι\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => AlternatingMap.congr_arg f <| Subsingleton.elim _ _\n\n"}
