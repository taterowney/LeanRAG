{"name":"ZMod.valMinAbs_def_zero","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"x : ZMod 0\n⊢ Eq x.valMinAbs x","decl":"@[simp] lemma valMinAbs_def_zero (x : ZMod 0) : valMinAbs x = x := rfl\n\n"}
{"name":"ZMod.valMinAbs_def_pos","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\n⊢ Eq x.valMinAbs (ite (LE.le x.val (HDiv.hDiv n 2)) (↑x.val) (HSub.hSub ↑x.val ↑n))","decl":"lemma valMinAbs_def_pos : ∀ {n : ℕ} [NeZero n] (x : ZMod n),\n    valMinAbs x = if x.val ≤ n / 2 then (x.val : ℤ) else x.val - n\n  | 0, _, x => by cases NeZero.ne 0 rfl\n  | n + 1, _, x => rfl\n\n"}
{"name":"ZMod.coe_valMinAbs","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\nx : ZMod n\n⊢ Eq (↑x.valMinAbs) x","decl":"@[simp, norm_cast]\nlemma coe_valMinAbs : ∀ {n : ℕ} (x : ZMod n), (x.valMinAbs : ZMod n) = x\n  | 0, _ => Int.cast_id\n  | k@(n + 1), x => by\n    rw [valMinAbs_def_pos]\n    split_ifs\n    · rw [Int.cast_natCast, natCast_zmod_val]\n    · rw [Int.cast_sub, Int.cast_natCast, natCast_zmod_val, Int.cast_natCast, natCast_self,\n        sub_zero]\n\n"}
{"name":"ZMod.injective_valMinAbs","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\n⊢ Function.Injective ZMod.valMinAbs","decl":"lemma injective_valMinAbs : (valMinAbs : ZMod n → ℤ).Injective :=\n  Function.injective_iff_hasLeftInverse.2 ⟨_, coe_valMinAbs⟩\n\n"}
{"name":"ZMod.valMinAbs_nonneg_iff","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\n⊢ Iff (LE.le 0 x.valMinAbs) (LE.le x.val (HDiv.hDiv n 2))","decl":"lemma valMinAbs_nonneg_iff [NeZero n] (x : ZMod n) : 0 ≤ x.valMinAbs ↔ x.val ≤ n / 2 := by\n  rw [valMinAbs_def_pos]; split_ifs with h\n  · exact iff_of_true (Nat.cast_nonneg _) h\n  · exact iff_of_false (sub_lt_zero.2 <| Int.ofNat_lt.2 x.val_lt).not_le h\n\n"}
{"name":"ZMod.valMinAbs_mul_two_eq_iff","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\na : ZMod n\n⊢ Iff (Eq (HMul.hMul a.valMinAbs 2) ↑n) (Eq (HMul.hMul 2 a.val) n)","decl":"lemma valMinAbs_mul_two_eq_iff (a : ZMod n) : a.valMinAbs * 2 = n ↔ 2 * a.val = n := by\n  cases' n with n\n  · simp\n  by_cases h : a.val ≤ n.succ / 2\n  · dsimp [valMinAbs]\n    rw [if_pos h, ← Int.natCast_inj, Nat.cast_mul, Nat.cast_two, mul_comm]\n  apply iff_of_false _ (mt _ h)\n  · intro he\n    rw [← a.valMinAbs_nonneg_iff, ← mul_nonneg_iff_left_nonneg_of_pos, he] at h\n    exacts [h (Nat.cast_nonneg _), zero_lt_two]\n  · rw [mul_comm]\n    exact fun h => (Nat.le_div_iff_mul_le zero_lt_two).2 h.le\n\n"}
{"name":"ZMod.valMinAbs_mem_Ioc","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\n⊢ Membership.mem (Set.Ioc (Neg.neg ↑n) ↑n) (HMul.hMul x.valMinAbs 2)","decl":"lemma valMinAbs_mem_Ioc [NeZero n] (x : ZMod n) : x.valMinAbs * 2 ∈ Set.Ioc (-n : ℤ) n := by\n  simp_rw [valMinAbs_def_pos, Nat.le_div_two_iff_mul_two_le]; split_ifs with h\n  · refine ⟨(neg_lt_zero.2 <| mod_cast NeZero.pos n).trans_le (mul_nonneg ?_ ?_), h⟩\n    exacts [Nat.cast_nonneg _, zero_le_two]\n  · refine ⟨?_, le_trans (mul_nonpos_of_nonpos_of_nonneg ?_ zero_le_two) <| Nat.cast_nonneg _⟩\n    · linarith only [h]\n    · rw [sub_nonpos, Int.ofNat_le]\n      exact x.val_lt.le\n\n"}
{"name":"ZMod.valMinAbs_spec","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\ny : Int\n⊢ Iff (Eq x.valMinAbs y) (And (Eq x ↑y) (Membership.mem (Set.Ioc (Neg.neg ↑n) ↑n) (HMul.hMul y 2)))","decl":"lemma valMinAbs_spec [NeZero n] (x : ZMod n) (y : ℤ) :\n    x.valMinAbs = y ↔ x = y ∧ y * 2 ∈ Set.Ioc (-n : ℤ) n where\n  mp := by rintro rfl; exact ⟨x.coe_valMinAbs.symm, x.valMinAbs_mem_Ioc⟩\n  mpr h := by\n    rw [← sub_eq_zero]\n    apply @Int.eq_zero_of_abs_lt_dvd n\n    · rw [← intCast_zmod_eq_zero_iff_dvd, Int.cast_sub, coe_valMinAbs, h.1, sub_self]\n    rw [← mul_lt_mul_right (@zero_lt_two ℤ _ _ _ _ _)]\n    nth_rw 1 [← abs_eq_self.2 (@zero_le_two ℤ _ _ _ _)]\n    rw [← abs_mul, sub_mul, abs_lt]\n    constructor <;> linarith only [x.valMinAbs_mem_Ioc.1, x.valMinAbs_mem_Ioc.2, h.2.1, h.2.2]\n\n"}
{"name":"ZMod.natAbs_valMinAbs_le","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\n⊢ LE.le x.valMinAbs.natAbs (HDiv.hDiv n 2)","decl":"lemma natAbs_valMinAbs_le [NeZero n] (x : ZMod n) : x.valMinAbs.natAbs ≤ n / 2 := by\n  rw [Nat.le_div_two_iff_mul_two_le]\n  cases' x.valMinAbs.natAbs_eq with h h\n  · rw [← h]\n    exact x.valMinAbs_mem_Ioc.2\n  · rw [← neg_le_neg_iff, ← neg_mul, ← h]\n    exact x.valMinAbs_mem_Ioc.1.le\n\n"}
{"name":"ZMod.valMinAbs_zero","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\n⊢ Eq (ZMod.valMinAbs 0) 0","decl":"@[simp]\nlemma valMinAbs_zero : ∀ n, (0 : ZMod n).valMinAbs = 0\n  | 0 => by simp only [valMinAbs_def_zero]\n  | n + 1 => by simp only [valMinAbs_def_pos, if_true, Int.ofNat_zero, zero_le, val_zero]\n\n"}
{"name":"ZMod.valMinAbs_eq_zero","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\nx : ZMod n\n⊢ Iff (Eq x.valMinAbs 0) (Eq x 0)","decl":"@[simp]\nlemma valMinAbs_eq_zero (x : ZMod n) : x.valMinAbs = 0 ↔ x = 0 := by\n  cases' n with n\n  · simp\n  rw [← valMinAbs_zero n.succ]\n  apply injective_valMinAbs.eq_iff\n\n"}
{"name":"ZMod.natCast_natAbs_valMinAbs","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq (↑a.valMinAbs.natAbs) (ite (LE.le a.val (HDiv.hDiv n 2)) a (Neg.neg a))","decl":"lemma natCast_natAbs_valMinAbs [NeZero n] (a : ZMod n) :\n    (a.valMinAbs.natAbs : ZMod n) = if a.val ≤ (n : ℕ) / 2 then a else -a := by\n  have : (a.val : ℤ) - n ≤ 0 := by\n    rw [sub_nonpos, Int.ofNat_le]\n    exact a.val_le\n  rw [valMinAbs_def_pos]\n  split_ifs\n  · rw [Int.natAbs_ofNat, natCast_zmod_val]\n  · rw [← Int.cast_natCast, Int.ofNat_natAbs_of_nonpos this, Int.cast_neg, Int.cast_sub,\n      Int.cast_natCast, Int.cast_natCast, natCast_self, sub_zero, natCast_zmod_val]\n\n"}
{"name":"ZMod.valMinAbs_neg_of_ne_half","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\na : ZMod n\nha : Ne (HMul.hMul 2 a.val) n\n⊢ Eq (Neg.neg a).valMinAbs (Neg.neg a.valMinAbs)","decl":"lemma valMinAbs_neg_of_ne_half (ha : 2 * a.val ≠ n) : (-a).valMinAbs = -a.valMinAbs := by\n  cases' eq_zero_or_neZero n with h h\n  · subst h\n    rfl\n  refine (valMinAbs_spec _ _).2 ⟨?_, ?_, ?_⟩\n  · rw [Int.cast_neg, coe_valMinAbs]\n  · rw [neg_mul, neg_lt_neg_iff]\n    exact a.valMinAbs_mem_Ioc.2.lt_of_ne (mt a.valMinAbs_mul_two_eq_iff.1 ha)\n  · linarith only [a.valMinAbs_mem_Ioc.1]\n\n"}
{"name":"ZMod.natAbs_valMinAbs_neg","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\na : ZMod n\n⊢ Eq (Neg.neg a).valMinAbs.natAbs a.valMinAbs.natAbs","decl":"@[simp]\nlemma natAbs_valMinAbs_neg (a : ZMod n) : (-a).valMinAbs.natAbs = a.valMinAbs.natAbs := by\n  by_cases h2a : 2 * a.val = n\n  · rw [a.neg_eq_self_iff.2 (Or.inr h2a)]\n  · rw [valMinAbs_neg_of_ne_half h2a, Int.natAbs_neg]\n\n"}
{"name":"ZMod.val_eq_ite_valMinAbs","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\ninst✝ : NeZero n\na : ZMod n\n⊢ Eq (↑a.val) (HAdd.hAdd a.valMinAbs ↑(ite (LE.le a.val (HDiv.hDiv n 2)) 0 n))","decl":"lemma val_eq_ite_valMinAbs [NeZero n] (a : ZMod n) :\n    (a.val : ℤ) = a.valMinAbs + if a.val ≤ n / 2 then 0 else n := by\n  rw [valMinAbs_def_pos]\n  split_ifs <;> simp [add_zero, sub_add_cancel]\n\n"}
{"name":"ZMod.prime_ne_zero","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nhpq : Ne p q\n⊢ Ne (↑q) 0","decl":"lemma prime_ne_zero (p q : ℕ) [hp : Fact p.Prime] [hq : Fact q.Prime] (hpq : p ≠ q) :\n    (q : ZMod p) ≠ 0 := by\n  rwa [← Nat.cast_zero, Ne, eq_iff_modEq_nat, Nat.modEq_zero_iff_dvd, ←\n    hp.1.coprime_iff_not_dvd, Nat.coprime_primes hp.1 hq.1]\n\n"}
{"name":"ZMod.valMinAbs_natAbs_eq_min","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\nhpos : NeZero n\na : ZMod n\n⊢ Eq a.valMinAbs.natAbs (Min.min a.val (HSub.hSub n a.val))","decl":"lemma valMinAbs_natAbs_eq_min [hpos : NeZero n] (a : ZMod n) :\n    a.valMinAbs.natAbs = min a.val (n - a.val) := by\n  rw [valMinAbs_def_pos]\n  have := a.val_lt\n  omega\n\n"}
{"name":"ZMod.valMinAbs_natCast_of_le_half","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n a : Nat\nha : LE.le a (HDiv.hDiv n 2)\n⊢ Eq (↑a).valMinAbs ↑a","decl":"lemma valMinAbs_natCast_of_le_half (ha : a ≤ n / 2) : (a : ZMod n).valMinAbs = a := by\n  cases n\n  · simp\n  · simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt (ha.trans_lt <| Nat.div_lt_self' _ 0),\n      ha]\n\n"}
{"name":"ZMod.valMinAbs_natCast_of_half_lt","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n a : Nat\nha : LT.lt (HDiv.hDiv n 2) a\nha' : LT.lt a n\n⊢ Eq (↑a).valMinAbs (HSub.hSub ↑a ↑n)","decl":"lemma valMinAbs_natCast_of_half_lt (ha : n / 2 < a) (ha' : a < n) :\n    (a : ZMod n).valMinAbs = a - n := by\n  cases n\n  · cases not_lt_bot ha'\n  · simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt ha', ha.not_le]\n\n"}
{"name":"ZMod.valMinAbs_natCast_eq_self","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n a : Nat\ninst✝ : NeZero n\n⊢ Iff (Eq (↑a).valMinAbs ↑a) (LE.le a (HDiv.hDiv n 2))","decl":"@[simp]\nlemma valMinAbs_natCast_eq_self [NeZero n] : (a : ZMod n).valMinAbs = a ↔ a ≤ n / 2 := by\n  refine ⟨fun ha => ?_, valMinAbs_natCast_of_le_half⟩\n  rw [← Int.natAbs_ofNat a, ← ha]\n  exact natAbs_valMinAbs_le (n := n) a\n\n"}
{"name":"ZMod.natAbs_valMinAbs_add_le","module":"Mathlib.Data.ZMod.ValMinAbs","initialProofState":"n : Nat\na b : ZMod n\n⊢ LE.le (HAdd.hAdd a b).valMinAbs.natAbs (HAdd.hAdd a.valMinAbs b.valMinAbs).natAbs","decl":"lemma natAbs_valMinAbs_add_le (a b : ZMod n) :\n    (a + b).valMinAbs.natAbs ≤ (a.valMinAbs + b.valMinAbs).natAbs := by\n  cases' n with n\n  · rfl\n  apply natAbs_min_of_le_div_two n.succ\n  · simp_rw [Int.cast_add, coe_valMinAbs]\n  · apply natAbs_valMinAbs_le\n\n"}
