{"name":"TopCat.Presheaf.isSheaf_iff_isSheaf_comp'","module":"Mathlib.Topology.Sheaves.Forget","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝² : G.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{v, v, v₁, u₁} C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, v₁, v₂, u₁, u₂} G\nX : TopCat\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf (TopCat.Presheaf.IsSheaf (CategoryTheory.Functor.comp F G))","decl":"/-- If `G : C ⥤ D` is a functor which reflects isomorphisms and preserves limits\n(we assume all limits exist in `C`),\nthen checking the sheaf condition for a presheaf `F : Presheaf C X`\nis equivalent to checking the sheaf condition for `F ⋙ G`.\n\nThe important special case is when\n`C` is a concrete category with a forgetful functor\nthat preserves limits and reflects isomorphisms.\nThen to check the sheaf condition it suffices to check it on the underlying sheaf of types.\n\nAnother useful example is the forgetful functor `TopCommRingCat ⥤ TopCat`. -/\n@[stacks 0073 \"In fact we prove a stronger version with arbitrary target category.\"]\ntheorem isSheaf_iff_isSheaf_comp' {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₂} D]\n    (G : C ⥤ D) [G.ReflectsIsomorphisms] [HasLimitsOfSize.{v, v} C] [PreservesLimitsOfSize.{v, v} G]\n    {X : TopCat.{v}} (F : Presheaf C X) : Presheaf.IsSheaf F ↔ Presheaf.IsSheaf (F ⋙ G) :=\n  Presheaf.isSheaf_iff_isSheaf_comp _ F G\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheaf_comp","module":"Mathlib.Topology.Sheaves.Forget","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nG : CategoryTheory.Functor C D\ninst✝² : G.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasLimits C\ninst✝ : CategoryTheory.Limits.PreservesLimits G\nX : TopCat\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf (TopCat.Presheaf.IsSheaf (CategoryTheory.Functor.comp F G))","decl":"theorem isSheaf_iff_isSheaf_comp {C : Type u₁} [Category.{v} C] {D : Type u₂} [Category.{v} D]\n    (G : C ⥤ D) [G.ReflectsIsomorphisms] [HasLimits C] [PreservesLimits G]\n    {X : TopCat.{v}} (F : Presheaf C X) : Presheaf.IsSheaf F ↔ Presheaf.IsSheaf (F ⋙ G) :=\n  isSheaf_iff_isSheaf_comp' G F\n\n"}
