{"name":"CategoryTheory.Iso.inv_hom_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.inv self.hom) (CategoryTheory.CategoryStruct.id Y)","decl":"/-- An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. -/\n@[stacks 0017]\nstructure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  /-- The forward direction of an isomorphism. -/\n  hom : X ‚ü∂ Y\n  /-- The backwards direction of an isomorphism. -/\n  inv : Y ‚ü∂ X\n  /-- Composition of the two directions of an isomorphism is the identity on the source. -/\n  hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat\n  /-- Composition of the two directions of an isomorphism in reverse order\n  is the identity on the target. -/\n  inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom self.inv) (CategoryTheory.CategoryStruct.id X)","decl":"/-- An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. -/\n@[stacks 0017]\nstructure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  /-- The forward direction of an isomorphism. -/\n  hom : X ‚ü∂ Y\n  /-- The backwards direction of an isomorphism. -/\n  inv : Y ‚ü∂ X\n  /-- Composition of the two directions of an isomorphism is the identity on the source. -/\n  hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat\n  /-- Composition of the two directions of an isomorphism in reverse order\n  is the identity on the target. -/\n  inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.mk.inj","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhom‚úù : Quiver.Hom X Y\ninv‚úù : Quiver.Hom Y X\nhom_inv_id‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù inv‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ninv_hom_id‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp inv‚úù hom‚úù) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nhom : Quiver.Hom X Y\ninv : Quiver.Hom Y X\nhom_inv_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ninv_hom_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, inv := inv‚úù, hom_inv_id := hom_inv_id‚úù, inv_hom_id := inv_hom_id‚úù } { hom := hom, inv := inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id }\n‚ä¢ And (Eq hom‚úù hom) (Eq inv‚úù inv)","decl":"/-- An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. -/\n@[stacks 0017]\nstructure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  /-- The forward direction of an isomorphism. -/\n  hom : X ‚ü∂ Y\n  /-- The backwards direction of an isomorphism. -/\n  inv : Y ‚ü∂ X\n  /-- Composition of the two directions of an isomorphism is the identity on the source. -/\n  hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat\n  /-- Composition of the two directions of an isomorphism in reverse order\n  is the identity on the target. -/\n  inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : SizeOf C\nhom : Quiver.Hom X Y\ninv : Quiver.Hom Y X\nhom_inv_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ninv_hom_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, inv := inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf hom_inv_id)) (SizeOf.sizeOf inv_hom_id))","decl":"/-- An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. -/\n@[stacks 0017]\nstructure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  /-- The forward direction of an isomorphism. -/\n  hom : X ‚ü∂ Y\n  /-- The backwards direction of an isomorphism. -/\n  inv : Y ‚ü∂ X\n  /-- Composition of the two directions of an isomorphism is the identity on the source. -/\n  hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat\n  /-- Composition of the two directions of an isomorphism in reverse order\n  is the identity on the target. -/\n  inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.mk.injEq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhom‚úù : Quiver.Hom X Y\ninv‚úù : Quiver.Hom Y X\nhom_inv_id‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù inv‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ninv_hom_id‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp inv‚úù hom‚úù) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nhom : Quiver.Hom X Y\ninv : Quiver.Hom Y X\nhom_inv_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ninv_hom_id : autoParam (Eq (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, inv := inv‚úù, hom_inv_id := hom_inv_id‚úù, inv_hom_id := inv_hom_id‚úù } { hom := hom, inv := inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id }) (And (Eq hom‚úù hom) (Eq inv‚úù inv))","decl":"/-- An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `CategoryTheory.Core` for the category with the same objects and isomorphisms playing\nthe role of morphisms. -/\n@[stacks 0017]\nstructure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  /-- The forward direction of an isomorphism. -/\n  hom : X ‚ü∂ Y\n  /-- The backwards direction of an isomorphism. -/\n  inv : Y ‚ü∂ X\n  /-- Composition of the two directions of an isomorphism is the identity on the source. -/\n  hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat\n  /-- Composition of the two directions of an isomorphism in reverse order\n  is the identity on the target. -/\n  inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Iso X Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.inv (CategoryTheory.CategoryStruct.comp self.hom h)) h","decl":"attribute [reassoc (attr := simp)] Iso.hom_inv_id Iso.inv_hom_id\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nself : CategoryTheory.Iso X Y\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp self.inv h)) h","decl":"attribute [reassoc (attr := simp)] Iso.hom_inv_id Iso.inv_hom_id\n\n"}
{"name":"CategoryTheory.Iso.ext","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± Œ≤ : CategoryTheory.Iso X Y\nw : Eq Œ±.hom Œ≤.hom\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext]\ntheorem ext ‚¶ÉŒ± Œ≤ : X ‚âÖ Y‚¶Ñ (w : Œ±.hom = Œ≤.hom) : Œ± = Œ≤ :=\n  suffices Œ±.inv = Œ≤.inv by\n    cases Œ±\n    cases Œ≤\n    cases w\n    cases this\n    rfl\n  calc\n    Œ±.inv = Œ±.inv ‚â´ Œ≤.hom ‚â´ Œ≤.inv   := by rw [Iso.hom_inv_id, Category.comp_id]\n    _     = (Œ±.inv ‚â´ Œ±.hom) ‚â´ Œ≤.inv := by rw [Category.assoc, ‚Üê w]\n    _     = Œ≤.inv                    := by rw [Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Iso.ext_iff","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± Œ≤ : CategoryTheory.Iso X Y\n‚ä¢ Iff (Eq Œ± Œ≤) (Eq Œ±.hom Œ≤.hom)","decl":"@[ext]\ntheorem ext ‚¶ÉŒ± Œ≤ : X ‚âÖ Y‚¶Ñ (w : Œ±.hom = Œ≤.hom) : Œ± = Œ≤ :=\n  suffices Œ±.inv = Œ≤.inv by\n    cases Œ±\n    cases Œ≤\n    cases w\n    cases this\n    rfl\n  calc\n    Œ±.inv = Œ±.inv ‚â´ Œ≤.hom ‚â´ Œ≤.inv   := by rw [Iso.hom_inv_id, Category.comp_id]\n    _     = (Œ±.inv ‚â´ Œ±.hom) ‚â´ Œ≤.inv := by rw [Category.assoc, ‚Üê w]\n    _     = Œ≤.inv                    := by rw [Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Iso.symm_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq Œ±.symm.hom Œ±.inv","decl":"@[simp]\ntheorem symm_hom (Œ± : X ‚âÖ Y) : Œ±.symm.hom = Œ±.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.symm_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq Œ±.symm.inv Œ±.hom","decl":"@[simp]\ntheorem symm_inv (Œ± : X ‚âÖ Y) : Œ±.symm.inv = Œ±.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.symm_mk","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhom : Quiver.Hom X Y\ninv : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id X)\ninv_hom_id : Eq (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id Y)\n‚ä¢ Eq { hom := hom, inv := inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id }.symm { hom := inv, inv := hom, hom_inv_id := inv_hom_id, inv_hom_id := hom_inv_id }","decl":"@[simp]\ntheorem symm_mk {X Y : C} (hom : X ‚ü∂ Y) (inv : Y ‚ü∂ X) (hom_inv_id) (inv_hom_id) :\n    Iso.symm { hom, inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id } =\n      { hom := inv, inv := hom, hom_inv_id := inv_hom_id, inv_hom_id := hom_inv_id } :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.symm_symm_eq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq Œ±.symm.symm Œ±","decl":"@[simp]\ntheorem symm_symm_eq {X Y : C} (Œ± : X ‚âÖ Y) : Œ±.symm.symm = Œ± := rfl\n\n"}
{"name":"CategoryTheory.Iso.symm_eq_iff","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± Œ≤ : CategoryTheory.Iso X Y\n‚ä¢ Iff (Eq Œ±.symm Œ≤.symm) (Eq Œ± Œ≤)","decl":"@[simp]\ntheorem symm_eq_iff {X Y : C} {Œ± Œ≤ : X ‚âÖ Y} : Œ±.symm = Œ≤.symm ‚Üî Œ± = Œ≤ :=\n  ‚ü®fun h => symm_symm_eq Œ± ‚ñ∏ symm_symm_eq Œ≤ ‚ñ∏ congr_arg symm h, congr_arg symm‚ü©\n\n"}
{"name":"CategoryTheory.Iso.nonempty_iso_symm","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\n‚ä¢ Iff (Nonempty (CategoryTheory.Iso X Y)) (Nonempty (CategoryTheory.Iso Y X))","decl":"theorem nonempty_iso_symm (X Y : C) : Nonempty (X ‚âÖ Y) ‚Üî Nonempty (Y ‚âÖ X) :=\n  ‚ü®fun h => ‚ü®h.some.symm‚ü©, fun h => ‚ü®h.some.symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Iso.refl_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Iso.refl X).inv (CategoryTheory.CategoryStruct.id X)","decl":"/-- Identity isomorphism. -/\n@[refl, simps]\ndef refl (X : C) : X ‚âÖ X where\n  hom := ùüô X\n  inv := ùüô X\n\n"}
{"name":"CategoryTheory.Iso.refl_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Iso.refl X).hom (CategoryTheory.CategoryStruct.id X)","decl":"/-- Identity isomorphism. -/\n@[refl, simps]\ndef refl (X : C) : X ‚âÖ X where\n  hom := ùüô X\n  inv := ùüô X\n\n"}
{"name":"CategoryTheory.Iso.nonempty_iso_refl","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Nonempty (CategoryTheory.Iso X X)","decl":"theorem nonempty_iso_refl (X : C) : Nonempty (X ‚âÖ X) := ‚ü®default‚ü©\n\n"}
{"name":"CategoryTheory.Iso.refl_symm","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Iso.refl X).symm (CategoryTheory.Iso.refl X)","decl":"@[simp]\ntheorem refl_symm (X : C) : (Iso.refl X).symm = Iso.refl X := rfl\n\n-- Porting note: It seems that the trans `trans` attribute isn't working properly\n-- in this case, so we have to manually add a `Trans` instance (with a `simps` tag).\n"}
{"name":"CategoryTheory.Iso.trans_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y Z\n‚ä¢ Eq (Œ±.trans Œ≤).inv (CategoryTheory.CategoryStruct.comp Œ≤.inv Œ±.inv)","decl":"/-- Composition of two isomorphisms -/\n@[trans, simps]\ndef trans (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : X ‚âÖ Z where\n  hom := Œ±.hom ‚â´ Œ≤.hom\n  inv := Œ≤.inv ‚â´ Œ±.inv\n\n"}
{"name":"CategoryTheory.Iso.trans_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y Z\n‚ä¢ Eq (Œ±.trans Œ≤).hom (CategoryTheory.CategoryStruct.comp Œ±.hom Œ≤.hom)","decl":"/-- Composition of two isomorphisms -/\n@[trans, simps]\ndef trans (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : X ‚âÖ Z where\n  hom := Œ±.hom ‚â´ Œ≤.hom\n  inv := Œ≤.inv ‚â´ Œ±.inv\n\n"}
{"name":"CategoryTheory.Iso.instTransIso_trans","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\na‚úù b‚úù c‚úù : C\nŒ± : CategoryTheory.Iso a‚úù b‚úù\nŒ≤ : CategoryTheory.Iso b‚úù c‚úù\n‚ä¢ Eq (Trans.trans Œ± Œ≤) (Œ±.trans Œ≤)","decl":"@[simps]\ninstance instTransIso : Trans (Œ± := C) (¬∑ ‚âÖ ¬∑) (¬∑ ‚âÖ ¬∑) (¬∑ ‚âÖ ¬∑) where\n  trans := trans\n\n"}
{"name":"CategoryTheory.Iso.trans_mk","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nhom : Quiver.Hom X Y\ninv : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id X)\ninv_hom_id : Eq (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id Y)\nhom' : Quiver.Hom Y Z\ninv' : Quiver.Hom Z Y\nhom_inv_id' : Eq (CategoryTheory.CategoryStruct.comp hom' inv') (CategoryTheory.CategoryStruct.id Y)\ninv_hom_id' : Eq (CategoryTheory.CategoryStruct.comp inv' hom') (CategoryTheory.CategoryStruct.id Z)\nhom_inv_id'' : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp hom hom') (CategoryTheory.CategoryStruct.comp inv' inv)) (CategoryTheory.CategoryStruct.id X)\ninv_hom_id'' : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp inv' inv) (CategoryTheory.CategoryStruct.comp hom hom')) (CategoryTheory.CategoryStruct.id Z)\n‚ä¢ Eq ({ hom := hom, inv := inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id }.trans { hom := hom', inv := inv', hom_inv_id := hom_inv_id', inv_hom_id := inv_hom_id' }) { hom := CategoryTheory.CategoryStruct.comp hom hom', inv := CategoryTheory.CategoryStruct.comp inv' inv, hom_inv_id := hom_inv_id'', inv_hom_id := inv_hom_id'' }","decl":"@[simp]\ntheorem trans_mk {X Y Z : C} (hom : X ‚ü∂ Y) (inv : Y ‚ü∂ X) (hom_inv_id) (inv_hom_id)\n    (hom' : Y ‚ü∂ Z) (inv' : Z ‚ü∂ Y) (hom_inv_id') (inv_hom_id') (hom_inv_id'') (inv_hom_id'') :\n    Iso.trans ‚ü®hom, inv, hom_inv_id, inv_hom_id‚ü© ‚ü®hom', inv', hom_inv_id', inv_hom_id'‚ü© =\n     ‚ü®hom ‚â´ hom', inv' ‚â´ inv, hom_inv_id'', inv_hom_id''‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.trans_symm","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y Z\n‚ä¢ Eq (Œ±.trans Œ≤).symm (Œ≤.symm.trans Œ±.symm)","decl":"@[simp]\ntheorem trans_symm (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : (Œ± ‚â™‚â´ Œ≤).symm = Œ≤.symm ‚â™‚â´ Œ±.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.trans_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z Z' : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y Z\nŒ≥ : CategoryTheory.Iso Z Z'\n‚ä¢ Eq ((Œ±.trans Œ≤).trans Œ≥) (Œ±.trans (Œ≤.trans Œ≥))","decl":"@[simp]\ntheorem trans_assoc {Z' : C} (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) (Œ≥ : Z ‚âÖ Z') :\n    (Œ± ‚â™‚â´ Œ≤) ‚â™‚â´ Œ≥ = Œ± ‚â™‚â´ Œ≤ ‚â™‚â´ Œ≥ := by\n  ext; simp only [trans_hom, Category.assoc]\n\n"}
{"name":"CategoryTheory.Iso.refl_trans","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq ((CategoryTheory.Iso.refl X).trans Œ±) Œ±","decl":"@[simp]\ntheorem refl_trans (Œ± : X ‚âÖ Y) : Iso.refl X ‚â™‚â´ Œ± = Œ± := by ext; apply Category.id_comp\n\n"}
{"name":"CategoryTheory.Iso.trans_refl","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq (Œ±.trans (CategoryTheory.Iso.refl Y)) Œ±","decl":"@[simp]\ntheorem trans_refl (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Iso.refl Y = Œ± := by ext; apply Category.comp_id\n\n"}
{"name":"CategoryTheory.Iso.symm_self_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq (Œ±.symm.trans Œ±) (CategoryTheory.Iso.refl Y)","decl":"@[simp]\ntheorem symm_self_id (Œ± : X ‚âÖ Y) : Œ±.symm ‚â™‚â´ Œ± = Iso.refl Y :=\n  ext Œ±.inv_hom_id\n\n"}
{"name":"CategoryTheory.Iso.self_symm_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq (Œ±.trans Œ±.symm) (CategoryTheory.Iso.refl X)","decl":"@[simp]\ntheorem self_symm_id (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=\n  ext Œ±.hom_inv_id\n\n"}
{"name":"CategoryTheory.Iso.symm_self_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y Z\n‚ä¢ Eq (Œ±.symm.trans (Œ±.trans Œ≤)) Œ≤","decl":"@[simp]\ntheorem symm_self_id_assoc (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : Œ±.symm ‚â™‚â´ Œ± ‚â™‚â´ Œ≤ = Œ≤ := by\n  rw [‚Üê trans_assoc, symm_self_id, refl_trans]\n\n"}
{"name":"CategoryTheory.Iso.self_symm_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso X Z\n‚ä¢ Eq (Œ±.trans (Œ±.symm.trans Œ≤)) Œ≤","decl":"@[simp]\ntheorem self_symm_id_assoc (Œ± : X ‚âÖ Y) (Œ≤ : X ‚âÖ Z) : Œ± ‚â™‚â´ Œ±.symm ‚â™‚â´ Œ≤ = Œ≤ := by\n  rw [‚Üê trans_assoc, self_symm_id, refl_trans]\n\n"}
{"name":"CategoryTheory.Iso.inv_comp_eq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp Œ±.inv f) g) (Eq f (CategoryTheory.CategoryStruct.comp Œ±.hom g))","decl":"theorem inv_comp_eq (Œ± : X ‚âÖ Y) {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} : Œ±.inv ‚â´ f = g ‚Üî f = Œ±.hom ‚â´ g :=\n  ‚ü®fun H => by simp [H.symm], fun H => by simp [H]‚ü©\n\n"}
{"name":"CategoryTheory.Iso.eq_inv_comp","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Iff (Eq g (CategoryTheory.CategoryStruct.comp Œ±.inv f)) (Eq (CategoryTheory.CategoryStruct.comp Œ±.hom g) f)","decl":"theorem eq_inv_comp (Œ± : X ‚âÖ Y) {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} : g = Œ±.inv ‚â´ f ‚Üî Œ±.hom ‚â´ g = f :=\n  (inv_comp_eq Œ±.symm).symm\n\n"}
{"name":"CategoryTheory.Iso.comp_inv_eq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom Z Y\ng : Quiver.Hom Z X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f Œ±.inv) g) (Eq f (CategoryTheory.CategoryStruct.comp g Œ±.hom))","decl":"theorem comp_inv_eq (Œ± : X ‚âÖ Y) {f : Z ‚ü∂ Y} {g : Z ‚ü∂ X} : f ‚â´ Œ±.inv = g ‚Üî f = g ‚â´ Œ±.hom :=\n  ‚ü®fun H => by simp [H.symm], fun H => by simp [H]‚ü©\n\n"}
{"name":"CategoryTheory.Iso.eq_comp_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom Z Y\ng : Quiver.Hom Z X\n‚ä¢ Iff (Eq g (CategoryTheory.CategoryStruct.comp f Œ±.inv)) (Eq (CategoryTheory.CategoryStruct.comp g Œ±.hom) f)","decl":"theorem eq_comp_inv (Œ± : X ‚âÖ Y) {f : Z ‚ü∂ Y} {g : Z ‚ü∂ X} : g = f ‚â´ Œ±.inv ‚Üî g ‚â´ Œ±.hom = f :=\n  (comp_inv_eq Œ±.symm).symm\n\n"}
{"name":"CategoryTheory.Iso.inv_eq_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : CategoryTheory.Iso X Y\n‚ä¢ Iff (Eq f.inv g.inv) (Eq f.hom g.hom)","decl":"theorem inv_eq_inv (f g : X ‚âÖ Y) : f.inv = g.inv ‚Üî f.hom = g.hom :=\n  have : ‚àÄ {X Y : C} (f g : X ‚âÖ Y), f.hom = g.hom ‚Üí f.inv = g.inv := fun f g h => by rw [ext h]\n  ‚ü®this f.symm g.symm, this f g‚ü©\n\n"}
{"name":"CategoryTheory.Iso.hom_comp_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom Y X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp Œ±.hom f) (CategoryTheory.CategoryStruct.id X)) (Eq f Œ±.inv)","decl":"theorem hom_comp_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : Œ±.hom ‚â´ f = ùüô X ‚Üî f = Œ±.inv := by\n  rw [‚Üê eq_inv_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Iso.comp_hom_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom Y X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f Œ±.hom) (CategoryTheory.CategoryStruct.id Y)) (Eq f Œ±.inv)","decl":"theorem comp_hom_eq_id (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv := by\n  rw [‚Üê eq_comp_inv, id_comp]\n\n"}
{"name":"CategoryTheory.Iso.inv_comp_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp Œ±.inv f) (CategoryTheory.CategoryStruct.id Y)) (Eq f Œ±.hom)","decl":"theorem inv_comp_eq_id (Œ± : X ‚âÖ Y) {f : X ‚ü∂ Y} : Œ±.inv ‚â´ f = ùüô Y ‚Üî f = Œ±.hom :=\n  hom_comp_eq_id Œ±.symm\n\n"}
{"name":"CategoryTheory.Iso.comp_inv_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nf : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f Œ±.inv) (CategoryTheory.CategoryStruct.id X)) (Eq f Œ±.hom)","decl":"theorem comp_inv_eq_id (Œ± : X ‚âÖ Y) {f : X ‚ü∂ Y} : f ‚â´ Œ±.inv = ùüô X ‚Üî f = Œ±.hom :=\n  comp_hom_eq_id Œ±.symm\n\n"}
{"name":"CategoryTheory.Iso.hom_eq_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nŒ≤ : CategoryTheory.Iso Y X\n‚ä¢ Iff (Eq Œ±.hom Œ≤.inv) (Eq Œ≤.hom Œ±.inv)","decl":"theorem hom_eq_inv (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ X) : Œ±.hom = Œ≤.inv ‚Üî Œ≤.hom = Œ±.inv := by\n  erw [inv_eq_inv Œ±.symm Œ≤, eq_comm]\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.homToEquiv_apply","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\nf : Quiver.Hom Z X\n‚ä¢ Eq (Œ±.homToEquiv f) (CategoryTheory.CategoryStruct.comp f Œ±.hom)","decl":"/-- The bijection `(Z ‚ü∂ X) ‚âÉ (Z ‚ü∂ Y)` induced by `Œ± : X ‚âÖ Y`. -/\n@[simps]\ndef homToEquiv (Œ± : X ‚âÖ Y) {Z : C} : (Z ‚ü∂ X) ‚âÉ (Z ‚ü∂ Y) where\n  toFun f := f ‚â´ Œ±.hom\n  invFun g := g ‚â´ Œ±.inv\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.homToEquiv_symm_apply","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\ng : Quiver.Hom Z Y\n‚ä¢ Eq (Œ±.homToEquiv.symm g) (CategoryTheory.CategoryStruct.comp g Œ±.inv)","decl":"/-- The bijection `(Z ‚ü∂ X) ‚âÉ (Z ‚ü∂ Y)` induced by `Œ± : X ‚âÖ Y`. -/\n@[simps]\ndef homToEquiv (Œ± : X ‚âÖ Y) {Z : C} : (Z ‚ü∂ X) ‚âÉ (Z ‚ü∂ Y) where\n  toFun f := f ‚â´ Œ±.hom\n  invFun g := g ‚â´ Œ±.inv\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.homFromEquiv_apply","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\nf : Quiver.Hom X Z\n‚ä¢ Eq (Œ±.homFromEquiv f) (CategoryTheory.CategoryStruct.comp Œ±.inv f)","decl":"/-- The bijection `(X ‚ü∂ Z) ‚âÉ (Y ‚ü∂ Z)` induced by `Œ± : X ‚âÖ Y`. -/\n@[simps]\ndef homFromEquiv (Œ± : X ‚âÖ Y) {Z : C} : (X ‚ü∂ Z) ‚âÉ (Y ‚ü∂ Z) where\n  toFun f := Œ±.inv ‚â´ f\n  invFun g := Œ±.hom ‚â´ g\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.homFromEquiv_symm_apply","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\nZ : C\ng : Quiver.Hom Y Z\n‚ä¢ Eq (Œ±.homFromEquiv.symm g) (CategoryTheory.CategoryStruct.comp Œ±.hom g)","decl":"/-- The bijection `(X ‚ü∂ Z) ‚âÉ (Y ‚ü∂ Z)` induced by `Œ± : X ‚âÖ Y`. -/\n@[simps]\ndef homFromEquiv (Œ± : X ‚âÖ Y) {Z : C} : (X ‚ü∂ Z) ‚âÉ (Y ‚ü∂ Z) where\n  toFun f := Œ±.inv ‚â´ f\n  invFun g := Œ±.hom ‚â´ g\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsIso.out","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.IsIso f\n‚ä¢ Exists fun inv => And (Eq (CategoryTheory.CategoryStruct.comp f inv) (CategoryTheory.CategoryStruct.id X)) (Eq (CategoryTheory.CategoryStruct.comp inv f) (CategoryTheory.CategoryStruct.id Y))","decl":"/-- `IsIso` typeclass expressing that a morphism is invertible. -/\nclass IsIso (f : X ‚ü∂ Y) : Prop where\n  /-- The existence of an inverse morphism. -/\n  out : ‚àÉ inv : Y ‚ü∂ X, f ‚â´ inv = ùüô X ‚àß inv ‚â´ f = ùüô Y\n\n"}
{"name":"CategoryTheory.IsIso.hom_inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv f)) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem hom_inv_id (f : X ‚ü∂ Y) [I : IsIso f] : f ‚â´ inv f = ùüô X :=\n  (Classical.choose_spec I.1).left\n\n"}
{"name":"CategoryTheory.IsIso.inv_hom_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) f) (CategoryTheory.CategoryStruct.id Y)","decl":"@[simp]\ntheorem inv_hom_id (f : X ‚ü∂ Y) [I : IsIso f] : inv f ‚â´ f = ùüô Y :=\n  (Classical.choose_spec I.1).right\n\n-- FIXME putting @[reassoc] on the `hom_inv_id` above somehow unfolds `inv`\n-- This happens even if we make `inv` irreducible!\n-- I don't understand how this is happening: it is likely a bug.\n\n-- attribute [reassoc] hom_inv_id inv_hom_id\n-- #print hom_inv_id_assoc\n--   theorem CategoryTheory.IsIso.hom_inv_id_assoc {X Y : C} (f : X ‚ü∂ Y) [I : IsIso f]\n--     {Z : C} (h : X ‚ü∂ Z),\n--     f ‚â´ Classical.choose (_ : Exists fun inv ‚Ü¶ f ‚â´ inv = ùüô X ‚àß inv ‚â´ f = ùüô Y) ‚â´ h = h := ...\n\n"}
{"name":"CategoryTheory.IsIso.hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.IsIso f\nZ : C\ng : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) g)) g","decl":"@[simp]\ntheorem hom_inv_id_assoc (f : X ‚ü∂ Y) [I : IsIso f] {Z} (g : X ‚ü∂ Z) : f ‚â´ inv f ‚â´ g = g := by\n  simp [‚Üê Category.assoc]\n\n"}
{"name":"CategoryTheory.IsIso.inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.IsIso f\nZ : C\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) (CategoryTheory.CategoryStruct.comp f g)) g","decl":"@[simp]\ntheorem inv_hom_id_assoc (f : X ‚ü∂ Y) [I : IsIso f] {Z} (g : Y ‚ü∂ Z) : inv f ‚â´ f ‚â´ g = g := by\n  simp [‚Üê Category.assoc]\n\n"}
{"name":"CategoryTheory.Iso.isIso_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ CategoryTheory.IsIso e.hom","decl":"lemma Iso.isIso_hom (e : X ‚âÖ Y) : IsIso e.hom :=\n  ‚ü®e.inv, by simp, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Iso.isIso_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ CategoryTheory.IsIso e.inv","decl":"lemma Iso.isIso_inv (e : X ‚âÖ Y) : IsIso e.inv := e.symm.isIso_hom\n\n"}
{"name":"CategoryTheory.asIso_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nx‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.asIso f).hom f","decl":"@[simp]\ntheorem asIso_hom (f : X ‚ü∂ Y) {_ : IsIso f} : (asIso f).hom = f :=\n  rfl\n\n-- Porting note: the `IsIso f` argument had been instance implicit,\n-- but we've changed it to implicit as a `rw` in `Mathlib.CategoryTheory.Closed.Functor`\n-- was failing to generate it by typeclass search.\n"}
{"name":"CategoryTheory.asIso_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nx‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.asIso f).inv (CategoryTheory.inv f)","decl":"@[simp]\ntheorem asIso_inv (f : X ‚ü∂ Y) {_ : IsIso f} : (asIso f).inv = inv f :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsIso.epi_of_iso","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.Epi f","decl":"instance (priority := 100) epi_of_iso (f : X ‚ü∂ Y) [IsIso f] : Epi f where\n  left_cancellation g h w := by\n    rw [‚Üê IsIso.inv_hom_id_assoc f g, w, IsIso.inv_hom_id_assoc f h]\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.IsIso.mono_of_iso","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.Mono f","decl":"instance (priority := 100) mono_of_iso (f : X ‚ü∂ Y) [IsIso f] : Mono f where\n  right_cancellation g h w := by\n    rw [‚Üê Category.comp_id g, ‚Üê Category.comp_id h, ‚Üê IsIso.hom_inv_id f,\n      ‚Üê Category.assoc, w, ‚Üê Category.assoc]\n\n"}
{"name":"CategoryTheory.IsIso.inv_eq_of_hom_inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\ng : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id X)\n‚ä¢ Eq (CategoryTheory.inv f) g","decl":"@[aesop apply safe (rule_sets := [CategoryTheory])]\ntheorem inv_eq_of_hom_inv_id {f : X ‚ü∂ Y} [IsIso f] {g : Y ‚ü∂ X} (hom_inv_id : f ‚â´ g = ùüô X) :\n    inv f = g := by\n  apply (cancel_epi f).mp\n  simp [hom_inv_id]\n\n"}
{"name":"CategoryTheory.IsIso.inv_eq_of_inv_hom_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\ng : Quiver.Hom Y X\ninv_hom_id : Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id Y)\n‚ä¢ Eq (CategoryTheory.inv f) g","decl":"theorem inv_eq_of_inv_hom_id {f : X ‚ü∂ Y} [IsIso f] {g : Y ‚ü∂ X} (inv_hom_id : g ‚â´ f = ùüô Y) :\n    inv f = g := by\n  apply (cancel_mono f).mp\n  simp [inv_hom_id]\n\n"}
{"name":"CategoryTheory.IsIso.eq_inv_of_hom_inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\ng : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id X)\n‚ä¢ Eq g (CategoryTheory.inv f)","decl":"@[aesop apply safe (rule_sets := [CategoryTheory])]\ntheorem eq_inv_of_hom_inv_id {f : X ‚ü∂ Y} [IsIso f] {g : Y ‚ü∂ X} (hom_inv_id : f ‚â´ g = ùüô X) :\n    g = inv f :=\n  (inv_eq_of_hom_inv_id hom_inv_id).symm\n\n"}
{"name":"CategoryTheory.IsIso.eq_inv_of_inv_hom_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\ng : Quiver.Hom Y X\ninv_hom_id : Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id Y)\n‚ä¢ Eq g (CategoryTheory.inv f)","decl":"theorem eq_inv_of_inv_hom_id {f : X ‚ü∂ Y} [IsIso f] {g : Y ‚ü∂ X} (inv_hom_id : g ‚â´ f = ùüô Y) :\n    g = inv f :=\n  (inv_eq_of_inv_hom_id inv_hom_id).symm\n\n"}
{"name":"CategoryTheory.IsIso.id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.CategoryStruct.id X)","decl":"instance id (X : C) : IsIso (ùüô X) := ‚ü®‚ü®ùüô X, by simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsIso.inv_isIso","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.inv f)","decl":"instance inv_isIso [IsIso f] : IsIso (inv f) :=\n  (asIso f).isIso_inv\n\n/- The following instance has lower priority for the following reason:\nSuppose we are given `f : X ‚âÖ Y` with `X Y : Type u`.\nWithout the lower priority, typeclass inference cannot deduce `IsIso f.hom`\nbecause `f.hom` is defeq to `(fun x ‚Ü¶ x) ‚â´ f.hom`, triggering a loop. -/\n"}
{"name":"CategoryTheory.IsIso.comp_isIso","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\nh : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso h\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.CategoryStruct.comp f h)","decl":"instance (priority := 900) comp_isIso [IsIso f] [IsIso h] : IsIso (f ‚â´ h) :=\n  (asIso f ‚â™‚â´ asIso h).isIso_hom\n\n"}
{"name":"CategoryTheory.IsIso.comp_isIso'","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nx‚úù¬π : CategoryTheory.IsIso f\nx‚úù : CategoryTheory.IsIso h\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.CategoryStruct.comp f h)","decl":"/--\nThe composition of isomorphisms is an isomorphism. Here the arguments of type `IsIso` are\nexplicit, to make this easier to use with the `refine` tactic, for instance.\n-/\nlemma comp_isIso' (_ : IsIso f) (_ : IsIso h) : IsIso (f ‚â´ h) := inferInstance\n\n"}
{"name":"CategoryTheory.IsIso.inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.inv (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem inv_id : inv (ùüô X) = ùüô X := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.inv_comp_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\nh‚úù : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso h‚úù\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.CategoryStruct.comp f h‚úù)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) h))","decl":"@[simp, reassoc]\ntheorem inv_comp [IsIso f] [IsIso h] : inv (f ‚â´ h) = inv h ‚â´ inv f := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.inv_comp","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\nh : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso h\n‚ä¢ Eq (CategoryTheory.inv (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv h) (CategoryTheory.inv f))","decl":"@[simp, reassoc]\ntheorem inv_comp [IsIso f] [IsIso h] : inv (f ‚â´ h) = inv h ‚â´ inv f := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.inv_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.inv (CategoryTheory.inv f)) f","decl":"@[simp]\ntheorem inv_inv [IsIso f] : inv (inv f) = f := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.Iso.inv_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.inv f.inv) f.hom","decl":"@[simp]\ntheorem Iso.inv_inv (f : X ‚âÖ Y) : inv f.inv = f.hom := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.Iso.inv_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.inv f.hom) f.inv","decl":"@[simp]\ntheorem Iso.inv_hom (f : X ‚âÖ Y) : inv f.hom = f.inv := by\n  apply inv_eq_of_hom_inv_id\n  simp\n\n"}
{"name":"CategoryTheory.IsIso.inv_comp_eq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso Œ±\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv Œ±) f) g) (Eq f (CategoryTheory.CategoryStruct.comp Œ± g))","decl":"@[simp]\ntheorem inv_comp_eq (Œ± : X ‚ü∂ Y) [IsIso Œ±] {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} : inv Œ± ‚â´ f = g ‚Üî f = Œ± ‚â´ g :=\n  (asIso Œ±).inv_comp_eq\n\n"}
{"name":"CategoryTheory.IsIso.eq_inv_comp","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso Œ±\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Iff (Eq g (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv Œ±) f)) (Eq (CategoryTheory.CategoryStruct.comp Œ± g) f)","decl":"@[simp]\ntheorem eq_inv_comp (Œ± : X ‚ü∂ Y) [IsIso Œ±] {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} : g = inv Œ± ‚â´ f ‚Üî Œ± ‚â´ g = f :=\n  (asIso Œ±).eq_inv_comp\n\n"}
{"name":"CategoryTheory.IsIso.comp_inv_eq","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso Œ±\nf : Quiver.Hom Z Y\ng : Quiver.Hom Z X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv Œ±)) g) (Eq f (CategoryTheory.CategoryStruct.comp g Œ±))","decl":"@[simp]\ntheorem comp_inv_eq (Œ± : X ‚ü∂ Y) [IsIso Œ±] {f : Z ‚ü∂ Y} {g : Z ‚ü∂ X} : f ‚â´ inv Œ± = g ‚Üî f = g ‚â´ Œ± :=\n  (asIso Œ±).comp_inv_eq\n\n"}
{"name":"CategoryTheory.IsIso.eq_comp_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nŒ± : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso Œ±\nf : Quiver.Hom Z Y\ng : Quiver.Hom Z X\n‚ä¢ Iff (Eq g (CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv Œ±))) (Eq (CategoryTheory.CategoryStruct.comp g Œ±) f)","decl":"@[simp]\ntheorem eq_comp_inv (Œ± : X ‚ü∂ Y) [IsIso Œ±] {f : Z ‚ü∂ Y} {g : Z ‚ü∂ X} : g = f ‚â´ inv Œ± ‚Üî g ‚â´ Œ± = f :=\n  (asIso Œ±).eq_comp_inv\n\n"}
{"name":"CategoryTheory.IsIso.of_isIso_comp_left","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ CategoryTheory.IsIso g","decl":"theorem of_isIso_comp_left {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [IsIso (f ‚â´ g)] :\n    IsIso g := by\n  rw [‚Üê id_comp g, ‚Üê inv_hom_id f, assoc]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsIso.of_isIso_comp_right","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso g\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem of_isIso_comp_right {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso g] [IsIso (f ‚â´ g)] :\n    IsIso f := by\n  rw [‚Üê comp_id f, ‚Üê hom_inv_id g, ‚Üê assoc]\n  infer_instance\n\n"}
{"name":"CategoryTheory.IsIso.of_isIso_fac_left","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninst‚úù : CategoryTheory.IsIso f\nhh : CategoryTheory.IsIso h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\n‚ä¢ CategoryTheory.IsIso g","decl":"theorem of_isIso_fac_left {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} {h : X ‚ü∂ Z} [IsIso f]\n    [hh : IsIso h] (w : f ‚â´ g = h) : IsIso g := by\n  rw [‚Üê w] at hh\n  haveI := hh\n  exact of_isIso_comp_left f g\n\n"}
{"name":"CategoryTheory.IsIso.of_isIso_fac_right","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninst‚úù : CategoryTheory.IsIso g\nhh : CategoryTheory.IsIso h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem of_isIso_fac_right {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} {h : X ‚ü∂ Z} [IsIso g]\n    [hh : IsIso h] (w : f ‚â´ g = h) : IsIso f := by\n  rw [‚Üê w] at hh\n  haveI := hh\n  exact of_isIso_comp_right f g\n\n"}
{"name":"CategoryTheory.eq_of_inv_eq_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso g\np : Eq (CategoryTheory.inv f) (CategoryTheory.inv g)\n‚ä¢ Eq f g","decl":"theorem eq_of_inv_eq_inv {f g : X ‚ü∂ Y} [IsIso f] [IsIso g] (p : inv f = inv g) : f = g := by\n  apply (cancel_epi (inv f)).1\n  rw [inv_hom_id, p, inv_hom_id]\n\n"}
{"name":"CategoryTheory.IsIso.inv_eq_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Iff (Eq (CategoryTheory.inv f) (CategoryTheory.inv g)) (Eq f g)","decl":"theorem IsIso.inv_eq_inv {f g : X ‚ü∂ Y} [IsIso f] [IsIso g] : inv f = inv g ‚Üî f = g :=\n  Iso.inv_eq_inv (asIso f) (asIso g)\n\n"}
{"name":"CategoryTheory.hom_comp_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom Y X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id X)) (Eq f (CategoryTheory.inv g))","decl":"theorem hom_comp_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : Y ‚ü∂ X} : g ‚â´ f = ùüô X ‚Üî f = inv g :=\n  (asIso g).hom_comp_eq_id\n\n"}
{"name":"CategoryTheory.comp_hom_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom Y X\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id Y)) (Eq f (CategoryTheory.inv g))","decl":"theorem comp_hom_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : Y ‚ü∂ X} : f ‚â´ g = ùüô Y ‚Üî f = inv g :=\n  (asIso g).comp_hom_eq_id\n\n"}
{"name":"CategoryTheory.inv_comp_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) f) (CategoryTheory.CategoryStruct.id Y)) (Eq f g)","decl":"theorem inv_comp_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : X ‚ü∂ Y} : inv g ‚â´ f = ùüô Y ‚Üî f = g :=\n  (asIso g).inv_comp_eq_id\n\n"}
{"name":"CategoryTheory.comp_inv_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv g)) (CategoryTheory.CategoryStruct.id X)) (Eq f g)","decl":"theorem comp_inv_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : X ‚ü∂ Y} : f ‚â´ inv g = ùüô X ‚Üî f = g :=\n  (asIso g).comp_inv_eq_id\n\n"}
{"name":"CategoryTheory.isIso_of_hom_comp_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom Y X\nh : Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.id X)\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem isIso_of_hom_comp_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : Y ‚ü∂ X} (h : g ‚â´ f = ùüô X) : IsIso f := by\n  rw [(hom_comp_eq_id _).mp h]\n  infer_instance\n\n"}
{"name":"CategoryTheory.isIso_of_comp_hom_eq_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso g\nf : Quiver.Hom Y X\nh : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id Y)\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem isIso_of_comp_hom_eq_id (g : X ‚ü∂ Y) [IsIso g] {f : Y ‚ü∂ X} (h : f ‚â´ g = ùüô Y) : IsIso f := by\n  rw [(comp_hom_eq_id _).mp h]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Iso.inv_ext","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : CategoryTheory.Iso X Y\ng : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp f.hom g) (CategoryTheory.CategoryStruct.id X)\n‚ä¢ Eq f.inv g","decl":"@[aesop apply safe (rule_sets := [CategoryTheory])]\ntheorem inv_ext {f : X ‚âÖ Y} {g : Y ‚ü∂ X} (hom_inv_id : f.hom ‚â´ g = ùüô X) : f.inv = g :=\n  ((hom_comp_eq_id f).1 hom_inv_id).symm\n\n"}
{"name":"CategoryTheory.Iso.inv_ext'","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : CategoryTheory.Iso X Y\ng : Quiver.Hom Y X\nhom_inv_id : Eq (CategoryTheory.CategoryStruct.comp f.hom g) (CategoryTheory.CategoryStruct.id X)\n‚ä¢ Eq g f.inv","decl":"@[aesop apply safe (rule_sets := [CategoryTheory])]\ntheorem inv_ext' {f : X ‚âÖ Y} {g : Y ‚ü∂ X} (hom_inv_id : f.hom ‚â´ g = ùüô X) : g = f.inv :=\n  (hom_comp_eq_id f).1 hom_inv_id\n\n"}
{"name":"CategoryTheory.Iso.cancel_iso_hom_left","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : CategoryTheory.Iso X Y\ng g' : Quiver.Hom Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f.hom g) (CategoryTheory.CategoryStruct.comp f.hom g')) (Eq g g')","decl":"@[simp]\ntheorem cancel_iso_hom_left {X Y Z : C} (f : X ‚âÖ Y) (g g' : Y ‚ü∂ Z) :\n    f.hom ‚â´ g = f.hom ‚â´ g' ‚Üî g = g' := by\n  simp only [cancel_epi]\n\n"}
{"name":"CategoryTheory.Iso.cancel_iso_inv_left","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : CategoryTheory.Iso Y X\ng g' : Quiver.Hom Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f.inv g) (CategoryTheory.CategoryStruct.comp f.inv g')) (Eq g g')","decl":"@[simp]\ntheorem cancel_iso_inv_left {X Y Z : C} (f : Y ‚âÖ X) (g g' : Y ‚ü∂ Z) :\n    f.inv ‚â´ g = f.inv ‚â´ g' ‚Üî g = g' := by\n  simp only [cancel_epi]\n\n"}
{"name":"CategoryTheory.Iso.cancel_iso_hom_right","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf f' : Quiver.Hom X Y\ng : CategoryTheory.Iso Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g.hom) (CategoryTheory.CategoryStruct.comp f' g.hom)) (Eq f f')","decl":"@[simp]\ntheorem cancel_iso_hom_right {X Y Z : C} (f f' : X ‚ü∂ Y) (g : Y ‚âÖ Z) :\n    f ‚â´ g.hom = f' ‚â´ g.hom ‚Üî f = f' := by\n  simp only [cancel_mono]\n\n"}
{"name":"CategoryTheory.Iso.cancel_iso_inv_right","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf f' : Quiver.Hom X Y\ng : CategoryTheory.Iso Z Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g.inv) (CategoryTheory.CategoryStruct.comp f' g.inv)) (Eq f f')","decl":"@[simp]\ntheorem cancel_iso_inv_right {X Y Z : C} (f f' : X ‚ü∂ Y) (g : Z ‚âÖ Y) :\n    f ‚â´ g.inv = f' ‚â´ g.inv ‚Üî f = f' := by\n  simp only [cancel_mono]\n\n/-\nUnfortunately cancelling an isomorphism from the right of a chain of compositions is awkward.\nWe would need separate lemmas for each chain length (worse: for each pair of chain lengths).\n\nWe provide two more lemmas, for case of three morphisms, because this actually comes up in practice,\nbut then stop.\n-/\n"}
{"name":"CategoryTheory.Iso.cancel_iso_hom_right_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X X' Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y\nh : CategoryTheory.Iso Y Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h.hom)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' h.hom))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_iso_hom_right_assoc {W X X' Y Z : C} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (f' : W ‚ü∂ X')\n    (g' : X' ‚ü∂ Y) (h : Y ‚âÖ Z) : f ‚â´ g ‚â´ h.hom = f' ‚â´ g' ‚â´ h.hom ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Iso.cancel_iso_inv_right_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X X' Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y\nh : CategoryTheory.Iso Z Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h.inv)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' h.inv))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_iso_inv_right_assoc {W X X' Y Z : C} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (f' : W ‚ü∂ X')\n    (g' : X' ‚ü∂ Y) (h : Z ‚âÖ Y) : f ‚â´ g ‚â´ h.inv = f' ‚â´ g' ‚â´ h.inv ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map e.hom) (F.map e.inv)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id (F : C ‚•§ D) :\n    F.map e.hom ‚â´ F.map e.inv = ùüô _ := by\n  rw [‚Üê F.map_comp, e.hom_inv_id, F.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map e.hom) (CategoryTheory.CategoryStruct.comp (F.map e.inv) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id (F : C ‚•§ D) :\n    F.map e.hom ‚â´ F.map e.inv = ùüô _ := by\n  rw [‚Üê F.map_comp, e.hom_inv_id, F.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map e.inv) (F.map e.hom)) (CategoryTheory.CategoryStruct.id (F.obj Y))","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id (F : C ‚•§ D) :\n    F.map e.inv ‚â´ F.map e.hom = ùüô _ := by\n  rw [‚Üê F.map_comp, e.inv_hom_id, F.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map e.inv) (CategoryTheory.CategoryStruct.comp (F.map e.hom) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id (F : C ‚•§ D) :\n    F.map e.inv ‚â´ F.map e.hom = ùüô _ := by\n  rw [‚Üê F.map_comp, e.inv_hom_id, F.map_id]\n\n"}
{"name":"CategoryTheory.Functor.mapIso_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (F.mapIso i).inv (F.map i.inv)","decl":"/-- A functor `F : C ‚•§ D` sends isomorphisms `i : X ‚âÖ Y` to isomorphisms `F.obj X ‚âÖ F.obj Y` -/\n@[simps]\ndef mapIso (F : C ‚•§ D) {X Y : C} (i : X ‚âÖ Y) : F.obj X ‚âÖ F.obj Y where\n  hom := F.map i.hom\n  inv := F.map i.inv\n\n"}
{"name":"CategoryTheory.Functor.mapIso_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (F.mapIso i).hom (F.map i.hom)","decl":"/-- A functor `F : C ‚•§ D` sends isomorphisms `i : X ‚âÖ Y` to isomorphisms `F.obj X ‚âÖ F.obj Y` -/\n@[simps]\ndef mapIso (F : C ‚•§ D) {X Y : C} (i : X ‚âÖ Y) : F.obj X ‚âÖ F.obj Y where\n  hom := F.map i.hom\n  inv := F.map i.inv\n\n"}
{"name":"CategoryTheory.Functor.mapIso_symm","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (F.mapIso i.symm) (F.mapIso i).symm","decl":"@[simp]\ntheorem mapIso_symm (F : C ‚•§ D) {X Y : C} (i : X ‚âÖ Y) : F.mapIso i.symm = (F.mapIso i).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapIso_trans","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\ni : CategoryTheory.Iso X Y\nj : CategoryTheory.Iso Y Z\n‚ä¢ Eq (F.mapIso (i.trans j)) ((F.mapIso i).trans (F.mapIso j))","decl":"@[simp]\ntheorem mapIso_trans (F : C ‚•§ D) {X Y Z : C} (i : X ‚âÖ Y) (j : Y ‚âÖ Z) :\n    F.mapIso (i ‚â™‚â´ j) = F.mapIso i ‚â™‚â´ F.mapIso j := by\n  ext; apply Functor.map_comp\n\n"}
{"name":"CategoryTheory.Functor.mapIso_refl","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.mapIso (CategoryTheory.Iso.refl X)) (CategoryTheory.Iso.refl (F.obj X))","decl":"@[simp]\ntheorem mapIso_refl (F : C ‚•§ D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X) :=\n  Iso.ext <| F.map_id X\n\n"}
{"name":"CategoryTheory.Functor.map_isIso","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso (F.map f)","decl":"instance map_isIso (F : C ‚•§ D) (f : X ‚ü∂ Y) [IsIso f] : IsIso (F.map f) :=\n  (F.mapIso (asIso f)).isIso_hom\n\n"}
{"name":"CategoryTheory.Functor.map_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (F.map (CategoryTheory.inv f)) (CategoryTheory.inv (F.map f))","decl":"@[simp]\ntheorem map_inv (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : F.map (inv f) = inv (F.map f) := by\n  apply eq_inv_of_hom_inv_id\n  simp [‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_hom_inv_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.inv f)) h)) h","decl":"@[reassoc]\ntheorem map_hom_inv (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [IsIso f] :\n    F.map f ‚â´ F.map (inv f) = ùüô (F.obj X) := by simp\n\n"}
{"name":"CategoryTheory.Functor.map_hom_inv","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (F.map (CategoryTheory.inv f))) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc]\ntheorem map_hom_inv (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [IsIso f] :\n    F.map f ‚â´ F.map (inv f) = ùüô (F.obj X) := by simp\n\n"}
{"name":"CategoryTheory.Functor.map_inv_hom","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.inv f)) (F.map f)) (CategoryTheory.CategoryStruct.id (F.obj Y))","decl":"@[reassoc]\ntheorem map_inv_hom (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [IsIso f] :\n    F.map (inv f) ‚â´ F.map f = ùüô (F.obj Y) := by simp\n\n"}
{"name":"CategoryTheory.Functor.map_inv_hom_assoc","module":"Mathlib.CategoryTheory.Iso","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.inv f)) (CategoryTheory.CategoryStruct.comp (F.map f) h)) h","decl":"@[reassoc]\ntheorem map_inv_hom (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) [IsIso f] :\n    F.map (inv f) ‚â´ F.map f = ùüô (F.obj Y) := by simp\n\n"}
