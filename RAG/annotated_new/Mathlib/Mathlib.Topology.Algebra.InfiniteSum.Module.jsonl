{"name":"HasSum.const_smul","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : Monoid γ\ninst✝³ : TopologicalSpace α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction γ α\ninst✝ : ContinuousConstSMul γ α\nf : β → α\na : α\nb : γ\nhf : HasSum f a\n⊢ HasSum (fun i => HSMul.hSMul b (f i)) (HSMul.hSMul b a)","decl":"theorem HasSum.const_smul {a : α} (b : γ) (hf : HasSum f a) : HasSum (fun i ↦ b • f i) (b • a) :=\n  hf.map (DistribMulAction.toAddMonoidHom α _) <| continuous_const_smul _\n\n"}
{"name":"Summable.const_smul","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : Monoid γ\ninst✝³ : TopologicalSpace α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction γ α\ninst✝ : ContinuousConstSMul γ α\nf : β → α\nb : γ\nhf : Summable f\n⊢ Summable fun i => HSMul.hSMul b (f i)","decl":"theorem Summable.const_smul (b : γ) (hf : Summable f) : Summable fun i ↦ b • f i :=\n  (hf.hasSum.const_smul _).summable\n\n"}
{"name":"tsum_const_smul","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : Monoid γ\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddCommMonoid α\ninst✝² : DistribMulAction γ α\ninst✝¹ : ContinuousConstSMul γ α\nf : β → α\ninst✝ : T2Space α\nb : γ\nhf : Summable f\n⊢ Eq (tsum fun i => HSMul.hSMul b (f i)) (HSMul.hSMul b (tsum fun i => f i))","decl":"/-- Infinite sums commute with scalar multiplication. Version for scalars living in a `Monoid`, but\n  requiring a summability hypothesis. -/\ntheorem tsum_const_smul [T2Space α] (b : γ) (hf : Summable f) : ∑' i, b • f i = b • ∑' i, f i :=\n  (hf.hasSum.const_smul _).tsum_eq\n\n"}
{"name":"tsum_const_smul'","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : AddCommMonoid α\nf : β → α\nγ : Type u_5\ninst✝³ : Group γ\ninst✝² : DistribMulAction γ α\ninst✝¹ : ContinuousConstSMul γ α\ninst✝ : T2Space α\ng : γ\n⊢ Eq (tsum fun i => HSMul.hSMul g (f i)) (HSMul.hSMul g (tsum fun i => f i))","decl":"/-- Infinite sums commute with scalar multiplication. Version for scalars living in a `Group`, but\n  not requiring any summability hypothesis. -/\nlemma tsum_const_smul' {γ : Type*} [Group γ] [DistribMulAction γ α] [ContinuousConstSMul γ α]\n    [T2Space α] (g : γ) : ∑' (i : β), g • f i = g • ∑' (i : β), f i := by\n  by_cases hf : Summable f\n  · exact tsum_const_smul g hf\n  rw [tsum_eq_zero_of_not_summable hf]\n  simp only [smul_zero]\n  let mul_g : α ≃+ α := DistribMulAction.toAddEquiv α g\n  apply tsum_eq_zero_of_not_summable\n  change ¬ Summable (mul_g ∘ f)\n  rwa [Summable.map_iff_of_equiv mul_g]\n  · apply continuous_const_smul\n  · apply continuous_const_smul\n\n"}
{"name":"tsum_const_smul''","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : AddCommMonoid α\nf : β → α\nγ : Type u_5\ninst✝³ : DivisionRing γ\ninst✝² : Module γ α\ninst✝¹ : ContinuousConstSMul γ α\ninst✝ : T2Space α\ng : γ\n⊢ Eq (tsum fun i => HSMul.hSMul g (f i)) (HSMul.hSMul g (tsum fun i => f i))","decl":"/-- Infinite sums commute with scalar multiplication. Version for scalars living in a\n  `DivisionRing`; no summability hypothesis. This could be made to work for a\n  `[GroupWithZero γ]` if there was such a thing as `DistribMulActionWithZero`. -/\nlemma tsum_const_smul'' {γ : Type*} [DivisionRing γ] [Module γ α] [ContinuousConstSMul γ α]\n    [T2Space α] (g : γ) : ∑' (i : β), g • f i = g • ∑' (i : β), f i := by\n  rcases eq_or_ne g 0 with rfl | hg\n  · simp\n  · exact tsum_const_smul' (Units.mk0 g hg)\n\n"}
{"name":"HasSum.smul_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nM : Type u_9\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousSMul R M\nf : ι → R\nr : R\nhf : HasSum f r\na : M\n⊢ HasSum (fun z => HSMul.hSMul (f z) a) (HSMul.hSMul r a)","decl":"theorem HasSum.smul_const {r : R} (hf : HasSum f r) (a : M) : HasSum (fun z ↦ f z • a) (r • a) :=\n  hf.map ((smulAddHom R M).flip a) (continuous_id.smul continuous_const)\n\n"}
{"name":"Summable.smul_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nM : Type u_9\ninst✝⁵ : Semiring R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : ContinuousSMul R M\nf : ι → R\nhf : Summable f\na : M\n⊢ Summable fun z => HSMul.hSMul (f z) a","decl":"theorem Summable.smul_const (hf : Summable f) (a : M) : Summable fun z ↦ f z • a :=\n  (hf.hasSum.smul_const _).summable\n\n"}
{"name":"tsum_smul_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nM : Type u_9\ninst✝⁶ : Semiring R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : ContinuousSMul R M\nf : ι → R\ninst✝ : T2Space M\nhf : Summable f\na : M\n⊢ Eq (tsum fun z => HSMul.hSMul (f z) a) (HSMul.hSMul (tsum fun z => f z) a)","decl":"theorem tsum_smul_const [T2Space M] (hf : Summable f) (a : M) : ∑' z, f z • a = (∑' z, f z) • a :=\n  (hf.hasSum.smul_const _).tsum_eq\n\n"}
{"name":"HasSum.smul_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nκ : Type u_6\nR : Type u_7\nM : Type u_9\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace M\ninst✝² : T3Space M\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousSMul R M\nf : ι → R\ng : κ → M\ns : R\nt u : M\nhf : HasSum f s\nhg : HasSum g t\nhfg : HasSum (fun x => HSMul.hSMul (f x.1) (g x.2)) u\n⊢ Eq (HSMul.hSMul s t) u","decl":"theorem HasSum.smul_eq (hf : HasSum f s) (hg : HasSum g t)\n    (hfg : HasSum (fun x : ι × κ ↦ f x.1 • g x.2) u) : s • t = u :=\n  have key₁ : HasSum (fun i ↦ f i • t) (s • t) := hf.smul_const t\n  have this : ∀ i : ι, HasSum (fun c : κ ↦ f i • g c) (f i • t) := fun i ↦ hg.const_smul (f i)\n  have key₂ : HasSum (fun i ↦ f i • t) u := HasSum.prod_fiberwise hfg this\n  key₁.unique key₂\n\n"}
{"name":"HasSum.smul","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nκ : Type u_6\nR : Type u_7\nM : Type u_9\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace M\ninst✝² : T3Space M\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousSMul R M\nf : ι → R\ng : κ → M\ns : R\nt : M\nhf : HasSum f s\nhg : HasSum g t\nhfg : Summable fun x => HSMul.hSMul (f x.1) (g x.2)\n⊢ HasSum (fun x => HSMul.hSMul (f x.1) (g x.2)) (HSMul.hSMul s t)","decl":"theorem HasSum.smul (hf : HasSum f s) (hg : HasSum g t)\n    (hfg : Summable fun x : ι × κ ↦ f x.1 • g x.2) :\n    HasSum (fun x : ι × κ ↦ f x.1 • g x.2) (s • t) :=\n  let ⟨_u, hu⟩ := hfg\n  (hf.smul_eq hg hu).symm ▸ hu\n\n"}
{"name":"tsum_smul_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nκ : Type u_6\nR : Type u_7\nM : Type u_9\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace M\ninst✝² : T3Space M\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousSMul R M\nf : ι → R\ng : κ → M\nhf : Summable f\nhg : Summable g\nhfg : Summable fun x => HSMul.hSMul (f x.1) (g x.2)\n⊢ Eq (HSMul.hSMul (tsum fun x => f x) (tsum fun y => g y)) (tsum fun z => HSMul.hSMul (f z.1) (g z.2))","decl":"/-- Scalar product of two infinites sums indexed by arbitrary types. -/\ntheorem tsum_smul_tsum (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : ι × κ ↦ f x.1 • g x.2) :\n    ((∑' x, f x) • ∑' y, g y) = ∑' z : ι × κ, f z.1 • g z.2 :=\n  hf.hasSum.smul_eq hg.hasSum hfg.hasSum\n\n"}
{"name":"ContinuousLinearMap.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace M₂\nσ : RingHom R R₂\nf : ι → M\nφ : ContinuousLinearMap σ M M₂\nx : M\nhf : HasSum f x\n⊢ HasSum (fun b => φ (f b)) (φ x)","decl":"/-- Applying a continuous linear map commutes with taking an (infinite) sum. -/\nprotected theorem ContinuousLinearMap.hasSum {f : ι → M} (φ : M →SL[σ] M₂) {x : M}\n    (hf : HasSum f x) : HasSum (fun b : ι ↦ φ (f b)) (φ x) := by\n  simpa only using hf.map φ.toLinearMap.toAddMonoidHom φ.continuous\n\n"}
{"name":"HasSum.mapL","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace M₂\nσ : RingHom R R₂\nf : ι → M\nφ : ContinuousLinearMap σ M M₂\nx : M\nhf : HasSum f x\n⊢ HasSum (fun b => φ (f b)) (φ x)","decl":"alias HasSum.mapL := ContinuousLinearMap.hasSum\n\n"}
{"name":"ContinuousLinearMap.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace M₂\nσ : RingHom R R₂\nf : ι → M\nφ : ContinuousLinearMap σ M M₂\nhf : Summable f\n⊢ Summable fun b => φ (f b)","decl":"protected theorem ContinuousLinearMap.summable {f : ι → M} (φ : M →SL[σ] M₂) (hf : Summable f) :\n    Summable fun b : ι ↦ φ (f b) :=\n  (hf.hasSum.mapL φ).summable\n\n"}
{"name":"Summable.mapL","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace M₂\nσ : RingHom R R₂\nf : ι → M\nφ : ContinuousLinearMap σ M M₂\nhf : Summable f\n⊢ Summable fun b => φ (f b)","decl":"alias Summable.mapL := ContinuousLinearMap.summable\n\n"}
{"name":"ContinuousLinearMap.map_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R₂ M₂\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace M₂\nσ : RingHom R R₂\ninst✝ : T2Space M₂\nf : ι → M\nφ : ContinuousLinearMap σ M M₂\nhf : Summable f\n⊢ Eq (φ (tsum fun z => f z)) (tsum fun z => φ (f z))","decl":"protected theorem ContinuousLinearMap.map_tsum [T2Space M₂] {f : ι → M} (φ : M →SL[σ] M₂)\n    (hf : Summable f) : φ (∑' z, f z) = ∑' z, φ (f z) :=\n  (hf.hasSum.mapL φ).tsum_eq.symm\n\n"}
{"name":"ContinuousLinearEquiv.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R₂ M₂\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M₂\nσ : RingHom R R₂\nσ' : RingHom R₂ R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\nf : ι → M\ne : ContinuousLinearEquiv σ M M₂\ny : M₂\n⊢ Iff (HasSum (fun b => e (f b)) y) (HasSum f (e.symm y))","decl":"/-- Applying a continuous linear map commutes with taking an (infinite) sum. -/\nprotected theorem ContinuousLinearEquiv.hasSum {f : ι → M} (e : M ≃SL[σ] M₂) {y : M₂} :\n    HasSum (fun b : ι ↦ e (f b)) y ↔ HasSum f (e.symm y) :=\n  ⟨fun h ↦ by simpa only [e.symm.coe_coe, e.symm_apply_apply] using h.mapL (e.symm : M₂ →SL[σ'] M),\n    fun h ↦ by simpa only [e.coe_coe, e.apply_symm_apply] using (e : M →SL[σ] M₂).hasSum h⟩\n\n"}
{"name":"ContinuousLinearEquiv.hasSum'","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R₂ M₂\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M₂\nσ : RingHom R R₂\nσ' : RingHom R₂ R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\nf : ι → M\ne : ContinuousLinearEquiv σ M M₂\nx : M\n⊢ Iff (HasSum (fun b => e (f b)) (e x)) (HasSum f x)","decl":"/-- Applying a continuous linear map commutes with taking an (infinite) sum. -/\nprotected theorem ContinuousLinearEquiv.hasSum' {f : ι → M} (e : M ≃SL[σ] M₂) {x : M} :\n    HasSum (fun b : ι ↦ e (f b)) (e x) ↔ HasSum f x := by\n  rw [e.hasSum, ContinuousLinearEquiv.symm_apply_apply]\n\n"}
{"name":"ContinuousLinearEquiv.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R₂ M₂\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace M₂\nσ : RingHom R R₂\nσ' : RingHom R₂ R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\nf : ι → M\ne : ContinuousLinearEquiv σ M M₂\n⊢ Iff (Summable fun b => e (f b)) (Summable f)","decl":"protected theorem ContinuousLinearEquiv.summable {f : ι → M} (e : M ≃SL[σ] M₂) :\n    (Summable fun b : ι ↦ e (f b)) ↔ Summable f :=\n  ⟨fun hf ↦ (e.hasSum.1 hf.hasSum).summable, (e : M →SL[σ] M₂).summable⟩\n\n"}
{"name":"ContinuousLinearEquiv.tsum_eq_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring R₂\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R₂ M₂\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace M₂\nσ : RingHom R R₂\nσ' : RingHom R₂ R\ninst✝³ : RingHomInvPair σ σ'\ninst✝² : RingHomInvPair σ' σ\ninst✝¹ : T2Space M\ninst✝ : T2Space M₂\nf : ι → M\ne : ContinuousLinearEquiv σ M M₂\ny : M₂\n⊢ Iff (Eq (tsum fun z => e (f z)) y) (Eq (tsum fun z => f z) (e.symm y))","decl":"theorem ContinuousLinearEquiv.tsum_eq_iff [T2Space M] [T2Space M₂] {f : ι → M} (e : M ≃SL[σ] M₂)\n    {y : M₂} : (∑' z, e (f z)) = y ↔ ∑' z, f z = e.symm y := by\n  by_cases hf : Summable f\n  · exact\n      ⟨fun h ↦ (e.hasSum.mp ((e.summable.mpr hf).hasSum_iff.mpr h)).tsum_eq, fun h ↦\n        (e.hasSum.mpr (hf.hasSum_iff.mpr h)).tsum_eq⟩\n  · have hf' : ¬Summable fun z ↦ e (f z) := fun h ↦ hf (e.summable.mp h)\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf']\n    refine ⟨?_, fun H ↦ ?_⟩\n    · rintro rfl\n      simp\n    · simpa using congr_arg (fun z ↦ e z) H\n\n"}
{"name":"ContinuousLinearEquiv.map_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"ι : Type u_5\nR : Type u_7\nR₂ : Type u_8\nM : Type u_9\nM₂ : Type u_10\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring R₂\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R₂ M₂\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace M₂\nσ : RingHom R R₂\nσ' : RingHom R₂ R\ninst✝³ : RingHomInvPair σ σ'\ninst✝² : RingHomInvPair σ' σ\ninst✝¹ : T2Space M\ninst✝ : T2Space M₂\nf : ι → M\ne : ContinuousLinearEquiv σ M M₂\n⊢ Eq (e (tsum fun z => f z)) (tsum fun z => e (f z))","decl":"protected theorem ContinuousLinearEquiv.map_tsum [T2Space M] [T2Space M₂] {f : ι → M}\n    (e : M ≃SL[σ] M₂) : e (∑' z, f z) = ∑' z, e (f z) := by\n  refine symm (e.tsum_eq_iff.mpr ?_)\n  rw [e.symm_apply_apply _]\n\n"}
{"name":"MulAction.automorphize_smul_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_11\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : T2Space M\nR : Type u_12\ninst✝⁴ : DivisionRing R\ninst✝³ : Module R M\ninst✝² : ContinuousConstSMul R M\ninst✝¹ : Group α\ninst✝ : MulAction α β\nf : β → M\ng : Quotient (MulAction.orbitRel α β) → R\n⊢ Eq (MulAction.automorphize (HSMul.hSMul (Function.comp g Quotient.mk') f)) (HSMul.hSMul g (MulAction.automorphize f))","decl":"/-- Automorphization of a function into an `R`-`Module` distributes, that is, commutes with the\n`R`-scalar multiplication. -/\nlemma MulAction.automorphize_smul_left [Group α] [MulAction α β] (f : β → M)\n    (g : Quotient (MulAction.orbitRel α β) → R) :\n    MulAction.automorphize ((g ∘ (@Quotient.mk' _ (_))) • f)\n      = g • (MulAction.automorphize f : Quotient (MulAction.orbitRel α β) → M) := by\n  ext x\n  apply @Quotient.inductionOn' β (MulAction.orbitRel α β) _ x _\n  intro b\n  simp only [automorphize, Pi.smul_apply', comp_apply]\n  set π : β → Quotient (MulAction.orbitRel α β) := Quotient.mk (MulAction.orbitRel α β)\n  have H₁ : ∀ a : α, π (a • b) = π b := by\n    intro a\n    apply (@Quotient.eq _ (MulAction.orbitRel α β) (a • b) b).mpr\n    use a\n  change ∑' a : α, g (π (a • b)) • f (a • b) = g (π b) • ∑' a : α, f (a • b)\n  simp_rw [H₁]\n  exact tsum_const_smul'' _\n\n"}
{"name":"AddAction.automorphize_smul_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_11\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : T2Space M\nR : Type u_12\ninst✝⁴ : DivisionRing R\ninst✝³ : Module R M\ninst✝² : ContinuousConstSMul R M\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nf : β → M\ng : Quotient (AddAction.orbitRel α β) → R\n⊢ Eq (AddAction.automorphize (HSMul.hSMul (Function.comp g Quotient.mk') f)) (HSMul.hSMul g (AddAction.automorphize f))","decl":"/-- Automorphization of a function into an `R`-`Module` distributes, that is, commutes with the\n`R`-scalar multiplication. -/\nlemma AddAction.automorphize_smul_left [AddGroup α] [AddAction α β]  (f : β → M)\n    (g : Quotient (AddAction.orbitRel α β) → R) :\n    AddAction.automorphize ((g ∘ (@Quotient.mk' _ (_))) • f)\n      = g • (AddAction.automorphize f : Quotient (AddAction.orbitRel α β) → M) := by\n  ext x\n  apply @Quotient.inductionOn' β (AddAction.orbitRel α β) _ x _\n  intro b\n  simp only [automorphize, Pi.smul_apply', comp_apply]\n  set π : β → Quotient (AddAction.orbitRel α β) := Quotient.mk (AddAction.orbitRel α β)\n  have H₁ : ∀ a : α, π (a +ᵥ b) = π b := by\n    intro a\n    apply (@Quotient.eq _ (AddAction.orbitRel α β) (a +ᵥ b) b).mpr\n    use a\n  change ∑' a : α, g (π (a +ᵥ b)) • f (a +ᵥ b) = g (π b) • ∑' a : α, f (a +ᵥ b)\n  simp_rw [H₁]\n  exact tsum_const_smul'' _\n\n"}
{"name":"QuotientGroup.automorphize_smul_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"M : Type u_11\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : T2Space M\nR : Type u_12\ninst✝³ : DivisionRing R\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\nG : Type u_13\ninst✝ : Group G\nΓ : Subgroup G\nf : G → M\ng : HasQuotient.Quotient G Γ → R\n⊢ Eq (QuotientGroup.automorphize (HSMul.hSMul (Function.comp g Quotient.mk') f)) (HSMul.hSMul g (QuotientGroup.automorphize f))","decl":"/-- Automorphization of a function into an `R`-`Module` distributes, that is, commutes with the\n`R`-scalar multiplication. -/\nlemma QuotientGroup.automorphize_smul_left (f : G → M) (g : G ⧸ Γ → R) :\n    (QuotientGroup.automorphize ((g ∘ (@Quotient.mk' _ (_)) : G → R) • f) : G ⧸ Γ → M)\n      = g • (QuotientGroup.automorphize f : G ⧸ Γ → M) :=\n  MulAction.automorphize_smul_left f g\n\n"}
{"name":"QuotientAddGroup.automorphize_smul_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Module","initialProofState":"M : Type u_11\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : T2Space M\nR : Type u_12\ninst✝³ : DivisionRing R\ninst✝² : Module R M\ninst✝¹ : ContinuousConstSMul R M\nG : Type u_13\ninst✝ : AddGroup G\nΓ : AddSubgroup G\nf : G → M\ng : HasQuotient.Quotient G Γ → R\n⊢ Eq (QuotientAddGroup.automorphize (HSMul.hSMul (Function.comp g Quotient.mk') f)) (HSMul.hSMul g (QuotientAddGroup.automorphize f))","decl":"/-- Automorphization of a function into an `R`-`Module` distributes, that is, commutes with the\n`R`-scalar multiplication. -/\nlemma QuotientAddGroup.automorphize_smul_left (f : G → M) (g : G ⧸ Γ → R) :\n    QuotientAddGroup.automorphize ((g ∘ (@Quotient.mk' _ (_))) • f)\n      = g • (QuotientAddGroup.automorphize f : G ⧸ Γ → M) :=\n  AddAction.automorphize_smul_left f g\n\n"}
