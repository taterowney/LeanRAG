{"name":"IsSymmSndFDerivWithinAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : IsSymmSndFDerivWithinAt ğ•œ f s x\nv w : E\nâŠ¢ Eq (((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) v) w) (((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) w) v)","decl":"protected lemma IsSymmSndFDerivWithinAt.eq (h : IsSymmSndFDerivWithinAt ğ•œ f s x) (v w : E) :\n    fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x v w = fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x w v :=\n  h v w\n\n"}
{"name":"IsSymmSndFDerivAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : IsSymmSndFDerivAt ğ•œ f x\nv w : E\nâŠ¢ Eq (((fderiv ğ•œ (fderiv ğ•œ f) x) v) w) (((fderiv ğ•œ (fderiv ğ•œ f) x) w) v)","decl":"protected lemma IsSymmSndFDerivAt.eq\n    (h : IsSymmSndFDerivAt ğ•œ f x) (v w : E) :\n    fderiv ğ•œ (fderiv ğ•œ f) x v w = fderiv ğ•œ (fderiv ğ•œ f) x w v :=\n  h v w\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : Membership.mem (nhdsWithin x s) t\nhf : ContDiffWithinAt ğ•œ 2 f t x\nhs : UniqueDiffOn ğ•œ s\nht : UniqueDiffOn ğ•œ t\nhx : Membership.mem s x\nâŠ¢ Eq (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) (fderivWithin ğ•œ (fderivWithin ğ•œ f t) t x)","decl":"lemma fderivWithin_fderivWithin_eq_of_mem_nhdsWithin (h : t âˆˆ ğ“[s] x)\n    (hf : ContDiffWithinAt ğ•œ 2 f t x) (hs : UniqueDiffOn ğ•œ s) (ht : UniqueDiffOn ğ•œ t) (hx : x âˆˆ s) :\n    fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x = fderivWithin ğ•œ (fderivWithin ğ•œ f t) t x := by\n  have A : âˆ€á¶  y in ğ“[s] x, fderivWithin ğ•œ f s y = fderivWithin ğ•œ f t y := by\n    have : âˆ€á¶  y in ğ“[s] x, ContDiffWithinAt ğ•œ 2 f t y :=\n      nhdsWithin_le_iff.2 h (nhdsWithin_mono _ (subset_insert x t) (hf.eventually (by simp)))\n    filter_upwards [self_mem_nhdsWithin, this, eventually_eventually_nhdsWithin.2 h]\n      with y hy h'y h''y\n    exact fderivWithin_of_mem_nhdsWithin h''y (hs y hy) (h'y.differentiableWithinAt one_le_two)\n  have : fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x = fderivWithin ğ•œ (fderivWithin ğ•œ f t) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq A\n    exact fderivWithin_of_mem_nhdsWithin h (hs x hx) (hf.differentiableWithinAt one_le_two)\n  rw [this]\n  apply fderivWithin_of_mem_nhdsWithin h (hs x hx)\n  exact (hf.fderivWithin_right (m := 1) ht le_rfl\n    (mem_of_mem_nhdsWithin hx h)).differentiableWithinAt le_rfl\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : (nhds x).EventuallyEq s t\nâŠ¢ Eq (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) (fderivWithin ğ•œ (fderivWithin ğ•œ f t) t x)","decl":"lemma fderivWithin_fderivWithin_eq_of_eventuallyEq (h : s =á¶ [ğ“ x] t) :\n    fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x = fderivWithin ğ•œ (fderivWithin ğ•œ f t) t x := calc\n  fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x\n    = fderivWithin ğ•œ (fderivWithin ğ•œ f t) s x :=\n      (fderivWithin_eventually_congr_set h).fderivWithin_eq_nhds\n  _ = fderivWithin ğ•œ (fderivWithin ğ•œ f t) t x := fderivWithin_congr_set h\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\nâŠ¢ Eq (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) (fderiv ğ•œ (fderiv ğ•œ f) x)","decl":"lemma fderivWithin_fderivWithin_eq_of_mem_nhds {f : E â†’ F} {x : E} {s : Set E}\n    (h : s âˆˆ ğ“ x) :\n    fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x = fderiv ğ•œ (fderiv ğ•œ f) x := by\n  simp only [â† fderivWithin_univ]\n  apply fderivWithin_fderivWithin_eq_of_eventuallyEq\n  simp [h]\n\n"}
{"name":"isSymmSndFDerivWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (IsSymmSndFDerivWithinAt ğ•œ f Set.univ x) (IsSymmSndFDerivAt ğ•œ f x)","decl":"@[simp] lemma isSymmSndFDerivWithinAt_univ :\n    IsSymmSndFDerivWithinAt ğ•œ f univ x â†” IsSymmSndFDerivAt ğ•œ f x := by\n  simp [IsSymmSndFDerivWithinAt, IsSymmSndFDerivAt]\n\n"}
{"name":"IsSymmSndFDerivWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : IsSymmSndFDerivWithinAt ğ•œ f t x\nhst : Membership.mem (nhdsWithin x s) t\nhf : ContDiffWithinAt ğ•œ 2 f t x\nhs : UniqueDiffOn ğ•œ s\nht : UniqueDiffOn ğ•œ t\nhx : Membership.mem s x\nâŠ¢ IsSymmSndFDerivWithinAt ğ•œ f s x","decl":"theorem IsSymmSndFDerivWithinAt.mono_of_mem_nhdsWithin (h : IsSymmSndFDerivWithinAt ğ•œ f t x)\n    (hst : t âˆˆ ğ“[s] x) (hf : ContDiffWithinAt ğ•œ 2 f t x)\n    (hs : UniqueDiffOn ğ•œ s) (ht : UniqueDiffOn ğ•œ t) (hx : x âˆˆ s) :\n    IsSymmSndFDerivWithinAt ğ•œ f s x := by\n  intro v w\n  rw [fderivWithin_fderivWithin_eq_of_mem_nhdsWithin hst hf hs ht hx]\n  exact h v w\n\n"}
{"name":"IsSymmSndFDerivWithinAt.congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : IsSymmSndFDerivWithinAt ğ•œ f s x\nhst : (nhds x).EventuallyEq s t\nâŠ¢ IsSymmSndFDerivWithinAt ğ•œ f t x","decl":"theorem IsSymmSndFDerivWithinAt.congr_set (h : IsSymmSndFDerivWithinAt ğ•œ f s x)\n    (hst : s =á¶ [ğ“ x] t) : IsSymmSndFDerivWithinAt ğ•œ f t x := by\n  intro v w\n  rw [fderivWithin_fderivWithin_eq_of_eventuallyEq hst.symm]\n  exact h v w\n\n"}
{"name":"isSymmSndFDerivWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nhst : (nhds x).EventuallyEq s t\nâŠ¢ Iff (IsSymmSndFDerivWithinAt ğ•œ f s x) (IsSymmSndFDerivWithinAt ğ•œ f t x)","decl":"theorem isSymmSndFDerivWithinAt_congr_set (hst : s =á¶ [ğ“ x] t) :\n    IsSymmSndFDerivWithinAt ğ•œ f s x â†” IsSymmSndFDerivWithinAt ğ•œ f t x :=\n  âŸ¨fun h â†¦ h.congr_set hst, fun h â†¦ h.congr_set hst.symmâŸ©\n\n"}
{"name":"IsSymmSndFDerivAt.isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : IsSymmSndFDerivAt ğ•œ f x\nhf : ContDiffAt ğ•œ 2 f x\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ IsSymmSndFDerivWithinAt ğ•œ f s x","decl":"theorem IsSymmSndFDerivAt.isSymmSndFDerivWithinAt (h : IsSymmSndFDerivAt ğ•œ f x)\n    (hf : ContDiffAt ğ•œ 2 f x) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    IsSymmSndFDerivWithinAt ğ•œ f s x := by\n  simp only [â† isSymmSndFDerivWithinAt_univ, â† contDiffWithinAt_univ] at h hf\n  exact h.mono_of_mem_nhdsWithin univ_mem hf hs uniqueDiffOn_univ hx\n\n"}
{"name":"ContDiffWithinAt.isSymmSndFDerivWithinAt_of_omega","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nhf : ContDiffWithinAt ğ•œ Top.top f s x\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ IsSymmSndFDerivWithinAt ğ•œ f s x","decl":"/-- If a function is analytic within a set at a point, then its second derivative is symmetric. -/\ntheorem ContDiffWithinAt.isSymmSndFDerivWithinAt_of_omega (hf : ContDiffWithinAt ğ•œ Ï‰ f s x)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    IsSymmSndFDerivWithinAt ğ•œ f s x := by\n  intro v w\n  rw [â† iteratedFDerivWithin_two_apply' f hs hx, â† iteratedFDerivWithin_two_apply' f hs hx,\n    â† hf.iteratedFDerivWithin_comp_perm hs hx _ (Equiv.swap 0 1)]\n  congr\n  ext i\n  fin_cases i <;> rfl\n\n"}
{"name":"ContDiffAt.isSymmSndFDerivAt_of_omega","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : ContDiffAt ğ•œ Top.top f x\nâŠ¢ IsSymmSndFDerivAt ğ•œ f x","decl":"/-- If a function is analytic at a point, then its second derivative is symmetric. -/\ntheorem ContDiffAt.isSymmSndFDerivAt_of_omega (hf : ContDiffAt ğ•œ Ï‰ f x) :\n    IsSymmSndFDerivAt ğ•œ f x := by\n  simp only [â† isSymmSndFDerivWithinAt_univ, â† contDiffWithinAt_univ] at hf âŠ¢\n  exact hf.isSymmSndFDerivWithinAt_of_omega uniqueDiffOn_univ (mem_univ _)\n\n"}
{"name":"Convex.taylor_approx_two_segment","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : âˆ€ (x : E), Membership.mem (interior s) x â†’ HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nhv : Membership.mem (interior s) (HAdd.hAdd x v)\nhw : Membership.mem (interior s) (HAdd.hAdd (HAdd.hAdd x v) w)\nâŠ¢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) (fun h => HSub.hSub (HSub.hSub (HSub.hSub (HSub.hSub (f (HAdd.hAdd (HAdd.hAdd x (HSMul.hSMul h v)) (HSMul.hSMul h w))) (f (HAdd.hAdd x (HSMul.hSMul h v)))) (HSMul.hSMul h ((f' x) w))) (HSMul.hSMul (HPow.hPow h 2) ((f'' v) w))) (HSMul.hSMul (HDiv.hDiv (HPow.hPow h 2) 2) ((f'' w) w))) fun h => HPow.hPow h 2","decl":"/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is\ndifferentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one can\nTaylor-expand to order two the function `f` on the segment `[x + h v, x + h (v + w)]`, giving a\nbilinear estimate for `f (x + hv + hw) - f (x + hv)` in terms of `f' w` and of `f'' â¬ w`, up to\n`o(h^2)`.\n\nThis is a technical statement used to show that the second derivative is symmetric. -/\ntheorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v âˆˆ interior s)\n    (hw : x + v + w âˆˆ interior s) :\n    (fun h : â„ => f (x + h â€¢ v + h â€¢ w)\n        - f (x + h â€¢ v) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (h ^ 2 / 2) â€¢ f'' w w) =o[ğ“[>] 0]\n      fun h => h ^ 2 := by\n  -- it suffices to check that the expression is bounded by `Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h^2` for\n  -- small enough `h`, for any positive `Îµ`.\n  refine IsLittleO.trans_isBigO\n    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)\n  -- consider a ball of radius `Î´` around `x` in which the Taylor approximation for `f''` is\n  -- good up to `Î´`.\n  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx\n  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©\n  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by\n    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=\n      (continuous_id.mul continuous_const).continuousWithinAt\n    apply (tendsto_order.1 this).2 Î´\n    simpa only [zero_mul] using Î´pos\n  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=\n    mem_nhdsWithin_of_mem_nhds <| Iio_mem_nhds zero_lt_one\n  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos\n  -- we consider `h` small enough that all points under consideration belong to this ball,\n  -- and also with `0 < h < 1`.\n  replace hpos : 0 < h := hpos\n  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by\n    intro t ht\n    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©\n    rw [â† smul_smul]\n    apply s_conv.interior.add_smul_mem this _ ht\n    rw [add_assoc] at hw\n    convert s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ© using 1\n    module\n  -- define a function `g` on `[0,1]` (identified with `[v, v + w]`) such that `g 1 - g 0` is the\n  -- quantity to be estimated. We will check that its derivative is given by an explicit\n  -- expression `g'`, that we can bound. Then the desired bound for `g 1 - g 0` follows from the\n  -- mean value inequality.\n  let g t :=\n    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -\n      ((t * h) ^ 2 / 2) â€¢ f'' w w\n  set g' := fun t =>\n    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w\n    with hg'\n  -- check that `g'` is the derivative of `g`, by a straightforward computation\n  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by\n    intro t ht\n    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]\n    Â· refine (hf _ ?_).comp_hasDerivWithinAt _ ?_\n      Â· exact xt_mem t ht\n      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,\n        hasDerivAt_mul_const]\n    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]\n    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]\n    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)\n          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by\n        convert H using 2\n        ring\n      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',\n        HasDerivAt.pow, HasDerivAt.mul_const]\n  -- check that `g'` is uniformly bounded, with a suitable bound `Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h^2`.\n  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by\n    intro t ht\n    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=\n      calc\n        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _\n        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by\n          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,\n            mul_assoc]\n        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le\n        _ = h * (â€–vâ€– + â€–wâ€–) := by ring\n    calc\n      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by\n        rw [hg']\n        congrm â€–?_â€–\n        simp only [ContinuousLinearMap.sub_apply, ContinuousLinearMap.add_apply,\n          ContinuousLinearMap.smul_apply, map_add, map_smul]\n        module\n      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=\n        (ContinuousLinearMap.le_opNorm _ _)\n      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by\n        gcongr\n        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by\n          refine âŸ¨?_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©\n          rw [add_assoc, add_mem_ball_iff_norm]\n          exact I.trans_lt hÎ´\n        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sÎ´ H\n      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by\n        gcongr\n        apply (norm_add_le _ _).trans\n        gcongr\n        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]\n        exact mul_le_of_le_one_left (by positivity) ht.2.le\n      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by\n        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring\n  -- conclude using the mean value inequality\n  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by\n    simpa only [mul_one, sub_zero] using\n      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)\n  convert I using 1\n  Â· congr 1\n    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,\n      zero_smul, Ne, not_false_iff, zero_pow, reduceCtorEq]\n    abel\n  Â· simp (discharger := positivity) only [Real.norm_eq_abs, abs_mul, abs_of_nonneg, abs_pow]\n    ring\n\n"}
{"name":"Convex.isLittleO_alternate_sum_square","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : âˆ€ (x : E), Membership.mem (interior s) x â†’ HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 v))\nh4w : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 w))\nâŠ¢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) (fun h => HSub.hSub (HSub.hSub (HSub.hSub (HAdd.hAdd (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd (HSMul.hSMul 2 v) (HSMul.hSMul 2 w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd v w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd (HSMul.hSMul 2 v) w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd v (HSMul.hSMul 2 w)))))) (HSMul.hSMul (HPow.hPow h 2) ((f'' v) w))) fun h => HPow.hPow h 2","decl":"/-- One can get `f'' v w` as the limit of `h ^ (-2)` times the alternate sum of the values of `f`\nalong the vertices of a quadrilateral with sides `h v` and `h w` based at `x`.\nIn a setting where `f` is not guaranteed to be continuous at `f`, we can still\nget this if we use a quadrilateral based at `h v + h w`. -/\ntheorem Convex.isLittleO_alternate_sum_square {v w : E} (h4v : x + (4 : â„) â€¢ v âˆˆ interior s)\n    (h4w : x + (4 : â„) â€¢ w âˆˆ interior s) :\n    (fun h : â„ => f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w))\n        - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h ^ 2 â€¢ f'' v w) =o[ğ“[>] 0]\n      fun h => h ^ 2 := by\n  have A : (1 : â„) / 2 âˆˆ Ioc (0 : â„) 1 := âŸ¨by norm_num, by norm_numâŸ©\n  have B : (1 : â„) / 2 âˆˆ Icc (0 : â„) 1 := âŸ¨by norm_num, by norm_numâŸ©\n  have h2v2w : x + (2 : â„) â€¢ v + (2 : â„) â€¢ w âˆˆ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h4v h4w B using 1\n    module\n  have h2vww : x + (2 â€¢ v + w) + w âˆˆ interior s := by\n    convert h2v2w using 1\n    module\n  have h2v : x + (2 : â„) â€¢ v âˆˆ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h4v A using 1\n    module\n  have h2w : x + (2 : â„) â€¢ w âˆˆ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h4w A using 1\n    module\n  have hvw : x + (v + w) âˆˆ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h2v2w A using 1\n    module\n  have h2vw : x + (2 â€¢ v + w) âˆˆ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h2v h2v2w B using 1\n    module\n  have hvww : x + (v + w) + w âˆˆ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h2w h2v2w B using 1\n    module\n  have TA1 := s_conv.taylor_approx_two_segment hf xs hx h2vw h2vww\n  have TA2 := s_conv.taylor_approx_two_segment hf xs hx hvw hvww\n  convert TA1.sub TA2 using 1\n  ext h\n  simp only [two_smul, smul_add, â† add_assoc, ContinuousLinearMap.map_add,\n    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul',\n    ContinuousLinearMap.map_smul]\n  abel\n\n"}
{"name":"Convex.second_derivative_within_at_symmetric_of_mem_interior","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : âˆ€ (x : E), Membership.mem (interior s) x â†’ HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 v))\nh4w : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 w))\nâŠ¢ Eq ((f'' w) v) ((f'' v) w)","decl":"/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is\ndifferentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one\nhas `f'' v w = f'' w v`. Superseded by `Convex.second_derivative_within_at_symmetric`, which\nremoves the assumption that `v` and `w` point inside `s`. -/\ntheorem Convex.second_derivative_within_at_symmetric_of_mem_interior {v w : E}\n    (h4v : x + (4 : â„) â€¢ v âˆˆ interior s) (h4w : x + (4 : â„) â€¢ w âˆˆ interior s) :\n    f'' w v = f'' v w := by\n  have A : (fun h : â„ => h ^ 2 â€¢ (f'' w v - f'' v w)) =o[ğ“[>] 0] fun h => h ^ 2 := by\n    convert (s_conv.isLittleO_alternate_sum_square hf xs hx h4v h4w).sub\n      (s_conv.isLittleO_alternate_sum_square hf xs hx h4w h4v) using 1\n    ext h\n    simp only [add_comm, smul_add, smul_sub]\n    abel\n  have B : (fun _ : â„ => f'' w v - f'' v w) =o[ğ“[>] 0] fun _ => (1 : â„) := by\n    have : (fun h : â„ => 1 / h ^ 2) =O[ğ“[>] 0] fun h => 1 / h ^ 2 := isBigO_refl _ _\n    have C := this.smul_isLittleO A\n    apply C.congr' _ _\n    Â· filter_upwards [self_mem_nhdsWithin]\n      intro h (hpos : 0 < h)\n      match_scalars <;> field_simp\n    Â· filter_upwards [self_mem_nhdsWithin] with h (hpos : 0 < h)\n      field_simp\n  simpa only [sub_eq_zero] using isLittleO_const_const_iff.1 B\n\n"}
{"name":"Convex.second_derivative_within_at_symmetric","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nhne : (interior s).Nonempty\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : âˆ€ (x : E), Membership.mem (interior s) x â†’ HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nâŠ¢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable inside a convex set with nonempty interior, and has a second\nderivative at a point of this convex set, then this second derivative is symmetric. -/\ntheorem Convex.second_derivative_within_at_symmetric {s : Set E} (s_conv : Convex â„ s)\n    (hne : (interior s).Nonempty) {f : E â†’ F} {f' : E â†’ E â†’L[â„] F} {f'' : E â†’L[â„] E â†’L[â„] F}\n    (hf : âˆ€ x âˆˆ interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x âˆˆ s)\n    (hx : HasFDerivWithinAt f' f'' (interior s) x) (v w : E) : f'' v w = f'' w v := by\n  /- we work around a point `x + 4 z` in the interior of `s`. For any vector `m`,\n    then `x + 4 (z + t m)` also belongs to the interior of `s` for small enough `t`. This means that\n    we will be able to apply `second_derivative_within_at_symmetric_of_mem_interior` to show\n    that `f''` is symmetric, after cancelling all the contributions due to `z`. -/\n  rcases hne with âŸ¨y, hyâŸ©\n  obtain âŸ¨z, hzâŸ© : âˆƒ z, z = ((1 : â„) / 4) â€¢ (y - x) := âŸ¨((1 : â„) / 4) â€¢ (y - x), rflâŸ©\n  have A : âˆ€ m : E, Filter.Tendsto (fun t : â„ => x + (4 : â„) â€¢ (z + t â€¢ m)) (ğ“ 0) (ğ“ y) := by\n    intro m\n    have : x + (4 : â„) â€¢ (z + (0 : â„) â€¢ m) = y := by simp [hz]\n    rw [â† this]\n    refine tendsto_const_nhds.add <| tendsto_const_nhds.smul <| tendsto_const_nhds.add ?_\n    exact continuousAt_id.smul continuousAt_const\n  have B : âˆ€ m : E, âˆ€á¶  t in ğ“[>] (0 : â„), x + (4 : â„) â€¢ (z + t â€¢ m) âˆˆ interior s := by\n    intro m\n    apply nhdsWithin_le_nhds\n    apply A m\n    rw [mem_interior_iff_mem_nhds] at hy\n    exact interior_mem_nhds.2 hy\n  -- we choose `t m > 0` such that `x + 4 (z + (t m) m)` belongs to the interior of `s`, for any\n  -- vector `m`.\n  choose t ts tpos using fun m => ((B m).and self_mem_nhdsWithin).exists\n  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z`\n  -- and `z + (t m) m`, we deduce that `f'' m z = f'' z m` for all `m`.\n  have C : âˆ€ m : E, f'' m z = f'' z m := by\n    intro m\n    have : f'' (z + t m â€¢ m) (z + t 0 â€¢ (0 : E)) = f'' (z + t 0 â€¢ (0 : E)) (z + t m â€¢ m) :=\n      s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts 0) (ts m)\n    simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, add_right_inj,\n      ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', add_zero,\n      ContinuousLinearMap.zero_apply, smul_zero, ContinuousLinearMap.map_zero] at this\n    exact smul_right_injective F (tpos m).ne' this\n  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z + (t v) v`\n  -- and `z + (t w) w`, we deduce that `f'' v w = f'' w v`. Cross terms involving `z` can be\n  -- eliminated thanks to the fact proved above that `f'' m z = f'' z m`.\n  have : f'' (z + t v â€¢ v) (z + t w â€¢ w) = f'' (z + t w â€¢ w) (z + t v â€¢ v) :=\n    s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts w) (ts v)\n  simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, smul_add, smul_smul,\n    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', C] at this\n  have : (t v * t w) â€¢ (f'' v) w = (t v * t w) â€¢ (f'' w) v := by\n    linear_combination (norm := module) this\n  apply smul_right_injective F _ this\n  simp [(tpos v).ne', (tpos w).ne']\n\n"}
{"name":"second_derivative_symmetric_of_eventually_of_real","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nx : E\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : Filter.Eventually (fun y => HasFDerivAt f (f' y) y) (nhds x)\nhx : HasFDerivAt f' f'' x\nv w : E\nâŠ¢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable around `x`, and has two derivatives at `x`, then the second\nderivative is symmetric. Version over `â„`. See `second_derivative_symmetric_of_eventually` for a\nversion over `â„` or `â„‚`. -/\ntheorem second_derivative_symmetric_of_eventually_of_real {f : E â†’ F} {f' : E â†’ E â†’L[â„] F}\n    {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€á¶  y in ğ“ x, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x)\n    (v w : E) : f'' v w = f'' w v := by\n  rcases Metric.mem_nhds_iff.1 hf with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  have A : (interior (Metric.ball x Îµ)).Nonempty := by\n    rwa [Metric.isOpen_ball.interior_eq, Metric.nonempty_ball]\n  exact\n    Convex.second_derivative_within_at_symmetric (convex_ball x Îµ) A\n      (fun y hy => hÎµ (interior_subset hy)) (Metric.mem_ball_self Îµpos) hx.hasFDerivWithinAt v w\n\n"}
{"name":"second_derivative_symmetric_of_eventually","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : IsRCLikeNormedField ğ•œ\nf' : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nf'' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nhf : Filter.Eventually (fun y => HasFDerivAt f (f' y) y) (nhds x)\nhx : HasFDerivAt f' f'' x\nv w : E\nâŠ¢ Eq ((f'' v) w) ((f'' w) v)","decl":"theorem second_derivative_symmetric_of_eventually [IsRCLikeNormedField ğ•œ]\n    {f' : E â†’ E â†’L[ğ•œ] F} {x : E}\n    {f'' : E â†’L[ğ•œ] E â†’L[ğ•œ] F} (hf : âˆ€á¶  y in ğ“ x, HasFDerivAt f (f' y) y)\n    (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v := by\n  let _ := IsRCLikeNormedField.rclike ğ•œ\n  let _ : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ E\n  let _ : NormedSpace â„ F := NormedSpace.restrictScalars â„ ğ•œ F\n  let _ : LinearMap.CompatibleSMul E F â„ ğ•œ := LinearMap.IsScalarTower.compatibleSMul\n  let _ : LinearMap.CompatibleSMul E (E â†’L[ğ•œ] F) â„ ğ•œ := LinearMap.IsScalarTower.compatibleSMul\n  let f'R : E â†’ E â†’L[â„] F := fun x â†¦ (f' x).restrictScalars â„\n  have hfR : âˆ€á¶  y in ğ“ x, HasFDerivAt f (f'R y) y := by\n    filter_upwards [hf] with y hy using HasFDerivAt.restrictScalars â„ hy\n  let f''Rl : E â†’â‚—[â„] E â†’â‚—[â„] F :=\n  { toFun := fun x â†¦\n      { toFun := fun y â†¦ f'' x y\n        map_add' := by simp\n        map_smul' := by simp }\n    map_add' := by intros; ext; simp\n    map_smul' := by intros; ext; simp }\n  let f''R : E â†’L[â„] E â†’L[â„] F := by\n    refine LinearMap.mkContinuousâ‚‚ f''Rl (â€–f''â€–) (fun x y â†¦ ?_)\n    simp only [LinearMap.coe_mk, AddHom.coe_mk, f''Rl]\n    exact ContinuousLinearMap.le_opNormâ‚‚ f'' x y\n  have : HasFDerivAt f'R f''R x := by\n    simp only [hasFDerivAt_iff_tendsto] at hx âŠ¢\n    exact hx\n  change f''R v w = f''R w v\n  exact second_derivative_symmetric_of_eventually_of_real hfR this v w\n\n"}
{"name":"second_derivative_symmetric","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœ : IsRCLikeNormedField ğ•œ\nf' : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nf'' : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nx : E\nhf : âˆ€ (y : E), HasFDerivAt f (f' y) y\nhx : HasFDerivAt f' f'' x\nv w : E\nâŠ¢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable, and has two derivatives at `x`, then the second\nderivative is symmetric. -/\ntheorem second_derivative_symmetric [IsRCLikeNormedField ğ•œ]\n    {f' : E â†’ E â†’L[ğ•œ] F} {f'' : E â†’L[ğ•œ] E â†’L[ğ•œ] F} {x : E}\n    (hf : âˆ€ y, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v :=\n  second_derivative_symmetric_of_eventually (Filter.Eventually.of_forall hf) hx v w\n\n"}
{"name":"minSmoothness_def","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_4\ninstâœ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nâŠ¢ Eq (minSmoothness ğ•œ n) (ite (IsRCLikeNormedField ğ•œ) n Top.top)","decl":"open scoped Classical in\nvariable (ğ•œ) in\n/-- `minSmoothness ğ•œ n` is the minimal smoothness exponent larger than or equal to `n` for which\none can do serious calculus in `ğ•œ`. If `ğ•œ` is `â„` or `â„‚`, this is just `n`. Otherwise,\nthis is `Ï‰` as only analytic functions are well behaved on `â„šâ‚š`, say. -/\nnoncomputable irreducible_def minSmoothness (n : WithTop â„•âˆ) :=\n  if IsRCLikeNormedField ğ•œ then n else Ï‰\n\n"}
{"name":"minSmoothness_of_isRCLikeNormedField","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nh : IsRCLikeNormedField ğ•œ\nn : WithTop ENat\nâŠ¢ Eq (minSmoothness ğ•œ n) n","decl":"@[simp] lemma minSmoothness_of_isRCLikeNormedField [h : IsRCLikeNormedField ğ•œ] {n : WithTop â„•âˆ} :\n    minSmoothness ğ•œ n = n := by\n  simp [minSmoothness, h]\n\n"}
{"name":"le_minSmoothness","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nâŠ¢ LE.le n (minSmoothness ğ•œ n)","decl":"lemma le_minSmoothness {n : WithTop â„•âˆ} : n â‰¤ minSmoothness ğ•œ n := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n\n"}
{"name":"minSmoothness_add","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nn m : WithTop ENat\nâŠ¢ Eq (minSmoothness ğ•œ (HAdd.hAdd n m)) (HAdd.hAdd (minSmoothness ğ•œ n) m)","decl":"lemma minSmoothness_add {n m : WithTop â„•âˆ} : minSmoothness ğ•œ (n + m) = minSmoothness ğ•œ n + m := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n\n"}
{"name":"minSmoothness_monotone","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ Monotone (minSmoothness ğ•œ)","decl":"lemma minSmoothness_monotone : Monotone (minSmoothness ğ•œ) := by\n  intro m n hmn\n  simp only [minSmoothness]\n  split_ifs <;> simp [hmn]\n\n"}
{"name":"minSmoothness_eq_infty","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nâŠ¢ Iff (Eq (minSmoothness ğ•œ n) â†‘Top.top) (And (Eq n â†‘Top.top) (IsRCLikeNormedField ğ•œ))","decl":"@[simp] lemma minSmoothness_eq_infty {n : WithTop â„•âˆ} :\n    minSmoothness ğ•œ n = âˆ â†” (n = âˆ âˆ§ IsRCLikeNormedField ğ•œ) := by\n  simp only [minSmoothness]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"exist_minSmoothness_le_ne_infty","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nm : Nat\nhm : LE.le (minSmoothness ğ•œ â†‘m) n\nâŠ¢ Exists fun n' => And (LE.le (minSmoothness ğ•œ â†‘m) n') (And (LE.le n' n) (Ne n' â†‘Top.top))","decl":"/-- If `minSmoothness ğ•œ m â‰¤ n` for some (finite) integer `m`, then one can\nfind `n' âˆˆ [minSmoothness ğ•œ m, n]` which is not `âˆ`: over `â„` or `â„‚`, just take `m`, and otherwise\njust take `Ï‰`. The interest of this technical lemma is that, if a function is `C^{n'}` at a point\nfor `n' â‰  âˆ`, then it is `C^{n'}` on a neighborhood of the point (this property fails only\nin `C^âˆ` smoothness, see `ContDiffWithinAt.contDiffOn`). -/\nlemma exist_minSmoothness_le_ne_infty {n : WithTop â„•âˆ} {m : â„•} (hm : minSmoothness ğ•œ m â‰¤ n) :\n    âˆƒ n', minSmoothness ğ•œ m â‰¤ n' âˆ§ n' â‰¤ n âˆ§ n' â‰  âˆ := by\n  simp only [minSmoothness] at hm âŠ¢\n  split_ifs with h\n  Â· simp only [h, â†“reduceIte] at hm\n    exact âŸ¨m, le_rfl, hm, by simpâŸ©\n  Â· simp only [h, â†“reduceIte, top_le_iff] at hm\n    refine âŸ¨Ï‰, le_rfl, by simp [hm], by simpâŸ©\n\n"}
{"name":"ContDiffAt.isSymmSndFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nhf : ContDiffAt ğ•œ n f x\nhn : LE.le (minSmoothness ğ•œ 2) n\nâŠ¢ IsSymmSndFDerivAt ğ•œ f x","decl":"/-- If a function is `C^2` at a point, then its second derivative there is symmetric. Over a field\ndifferent from `â„` or `â„‚`, we should require that the function is analytic. -/\ntheorem ContDiffAt.isSymmSndFDerivAt {n : WithTop â„•âˆ}\n    (hf : ContDiffAt ğ•œ n f x) (hn : minSmoothness ğ•œ 2 â‰¤ n) : IsSymmSndFDerivAt ğ•œ f x := by\n  by_cases h : IsRCLikeNormedField ğ•œ\n  -- First deal with the `â„` or `â„‚` case, where `C^2` is enough.\n  Â· intro v w\n    apply second_derivative_symmetric_of_eventually (f := f) (f' := fderiv ğ•œ f) (x := x)\n    Â· obtain âŸ¨u, hu, h'uâŸ© : âˆƒ u âˆˆ ğ“ x, ContDiffOn ğ•œ 2 f u :=\n        (hf.of_le hn).contDiffOn (m := 2) le_minSmoothness (by simp)\n      rcases mem_nhds_iff.1 hu with âŸ¨v, vu, v_open, xvâŸ©\n      filter_upwards [v_open.mem_nhds xv] with y hy\n      have : DifferentiableAt ğ•œ f y := by\n        have := (h'u.mono vu y hy).contDiffAt (v_open.mem_nhds hy)\n        exact this.differentiableAt one_le_two\n      exact DifferentiableAt.hasFDerivAt this\n    Â· have : DifferentiableAt ğ•œ (fderiv ğ•œ f) x := by\n        apply ContDiffAt.differentiableAt _ le_rfl\n        exact hf.fderiv_right (le_minSmoothness.trans hn)\n      exact DifferentiableAt.hasFDerivAt this\n  -- then deal with the case of an arbitrary field, with analytic functions.\n  Â· simp only [minSmoothness, h, â†“reduceIte, top_le_iff] at hn\n    apply ContDiffAt.isSymmSndFDerivAt_of_omega\n    simpa [hn] using hf\n\n"}
{"name":"ContDiffWithinAt.isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nhf : ContDiffWithinAt ğ•œ n f s x\nhn : LE.le (minSmoothness ğ•œ 2) n\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem (closure (interior s)) x\nh'x : Membership.mem s x\nâŠ¢ IsSymmSndFDerivWithinAt ğ•œ f s x","decl":"/-- If a function is `C^2` within a set at a point, and accumulated by points in the interior\nof the set, then its second derivative there is symmetric. Over a field\ndifferent from `â„` or `â„‚`, we should require that the function is analytic. -/\ntheorem ContDiffWithinAt.isSymmSndFDerivWithinAt {n : WithTop â„•âˆ}\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hn : minSmoothness ğ•œ 2 â‰¤ n)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ closure (interior s)) (h'x : x âˆˆ s) :\n    IsSymmSndFDerivWithinAt ğ•œ f s x := by\n  /- We argue that, at interior points, the second derivative is symmetric, and moreover by\n  continuity it converges to the second derivative at `x`. Therefore, the latter is also\n  symmetric. -/\n  obtain âŸ¨m, hm, hmn, m_neâŸ© := exist_minSmoothness_le_ne_infty hn\n  rcases (hf.of_le hmn).contDiffOn' le_rfl (by simp [m_ne]) with âŸ¨u, u_open, xu, huâŸ©\n  simp only [insert_eq_of_mem h'x] at hu\n  have h'u : UniqueDiffOn ğ•œ (s âˆ© u) := hs.inter u_open\n  obtain âŸ¨y, hy, y_limâŸ© : âˆƒ y, (âˆ€ (n : â„•), y n âˆˆ interior s) âˆ§ Tendsto y atTop (ğ“ x) :=\n    mem_closure_iff_seq_limit.1 hx\n  have L : âˆ€á¶  k in atTop, y k âˆˆ u := y_lim (u_open.mem_nhds xu)\n  have I : âˆ€á¶  k in atTop, IsSymmSndFDerivWithinAt ğ•œ f s (y k) := by\n    filter_upwards [L] with k hk\n    have s_mem : s âˆˆ ğ“ (y k) := by\n      apply mem_of_superset (isOpen_interior.mem_nhds (hy k))\n      exact interior_subset\n    have : IsSymmSndFDerivAt ğ•œ f (y k) := by\n      apply ContDiffAt.isSymmSndFDerivAt _ (n := m) hm\n      apply (hu (y k) âŸ¨(interior_subset (hy k)), hkâŸ©).contDiffAt\n      exact inter_mem s_mem (u_open.mem_nhds hk)\n    intro v w\n    rw [fderivWithin_fderivWithin_eq_of_mem_nhds s_mem]\n    exact this v w\n  have A : ContinuousOn (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s) (s âˆ© u) := by\n    have : ContinuousOn (fderivWithin ğ•œ (fderivWithin ğ•œ f (s âˆ© u)) (s âˆ© u)) (s âˆ© u) :=\n      ((hu.fderivWithin h'u (m := 1) (le_minSmoothness.trans hm)).fderivWithin h'u\n      (m := 0) le_rfl).continuousOn\n    apply this.congr\n    intro y hy\n    apply fderivWithin_fderivWithin_eq_of_eventuallyEq\n    filter_upwards [u_open.mem_nhds hy.2] with z hz\n    change (z âˆˆ s) = (z âˆˆ s âˆ© u)\n    aesop\n  have B : Tendsto (fun k â†¦ fderivWithin ğ•œ (fderivWithin ğ•œ f s) s (y k)) atTop\n      (ğ“ (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x)) := by\n    have : Tendsto y atTop (ğ“[s âˆ© u] x) := by\n      apply tendsto_nhdsWithin_iff.2 âŸ¨y_lim, ?_âŸ©\n      filter_upwards [L] with k hk using âŸ¨interior_subset (hy k), hkâŸ©\n    exact (A x âŸ¨h'x, xuâŸ© ).tendsto.comp this\n  have C (v w : E) : Tendsto (fun k â†¦ fderivWithin ğ•œ (fderivWithin ğ•œ f s) s (y k) v w) atTop\n      (ğ“ (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x v w)) := by\n    have : Continuous (fun (A : E â†’L[ğ•œ] E â†’L[ğ•œ] F) â†¦ A v w) := by fun_prop\n    exact (this.tendsto _).comp B\n  have C' (v w : E) : Tendsto (fun k â†¦ fderivWithin ğ•œ (fderivWithin ğ•œ f s) s (y k) w v) atTop\n      (ğ“ (fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x v w)) := by\n    apply (C v w).congr'\n    filter_upwards [I] with k hk using hk v w\n  intro v w\n  exact tendsto_nhds_unique (C v w) (C' w v)\n\n"}
