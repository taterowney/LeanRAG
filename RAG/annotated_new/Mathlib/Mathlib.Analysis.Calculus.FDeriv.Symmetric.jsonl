{"name":"IsSymmSndFDerivWithinAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nh : IsSymmSndFDerivWithinAt 𝕜 f s x\nv w : E\n⊢ Eq (((fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) v) w) (((fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) w) v)","decl":"protected lemma IsSymmSndFDerivWithinAt.eq (h : IsSymmSndFDerivWithinAt 𝕜 f s x) (v w : E) :\n    fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x v w = fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x w v :=\n  h v w\n\n"}
{"name":"IsSymmSndFDerivAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : IsSymmSndFDerivAt 𝕜 f x\nv w : E\n⊢ Eq (((fderiv 𝕜 (fderiv 𝕜 f) x) v) w) (((fderiv 𝕜 (fderiv 𝕜 f) x) w) v)","decl":"protected lemma IsSymmSndFDerivAt.eq\n    (h : IsSymmSndFDerivAt 𝕜 f x) (v w : E) :\n    fderiv 𝕜 (fderiv 𝕜 f) x v w = fderiv 𝕜 (fderiv 𝕜 f) x w v :=\n  h v w\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nh : Membership.mem (nhdsWithin x s) t\nhf : ContDiffWithinAt 𝕜 2 f t x\nhs : UniqueDiffOn 𝕜 s\nht : UniqueDiffOn 𝕜 t\nhx : Membership.mem s x\n⊢ Eq (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) (fderivWithin 𝕜 (fderivWithin 𝕜 f t) t x)","decl":"lemma fderivWithin_fderivWithin_eq_of_mem_nhdsWithin (h : t ∈ 𝓝[s] x)\n    (hf : ContDiffWithinAt 𝕜 2 f t x) (hs : UniqueDiffOn 𝕜 s) (ht : UniqueDiffOn 𝕜 t) (hx : x ∈ s) :\n    fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x = fderivWithin 𝕜 (fderivWithin 𝕜 f t) t x := by\n  have A : ∀ᶠ y in 𝓝[s] x, fderivWithin 𝕜 f s y = fderivWithin 𝕜 f t y := by\n    have : ∀ᶠ y in 𝓝[s] x, ContDiffWithinAt 𝕜 2 f t y :=\n      nhdsWithin_le_iff.2 h (nhdsWithin_mono _ (subset_insert x t) (hf.eventually (by simp)))\n    filter_upwards [self_mem_nhdsWithin, this, eventually_eventually_nhdsWithin.2 h]\n      with y hy h'y h''y\n    exact fderivWithin_of_mem_nhdsWithin h''y (hs y hy) (h'y.differentiableWithinAt one_le_two)\n  have : fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x = fderivWithin 𝕜 (fderivWithin 𝕜 f t) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq A\n    exact fderivWithin_of_mem_nhdsWithin h (hs x hx) (hf.differentiableWithinAt one_le_two)\n  rw [this]\n  apply fderivWithin_of_mem_nhdsWithin h (hs x hx)\n  exact (hf.fderivWithin_right (m := 1) ht le_rfl\n    (mem_of_mem_nhdsWithin hx h)).differentiableWithinAt le_rfl\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nh : (nhds x).EventuallyEq s t\n⊢ Eq (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) (fderivWithin 𝕜 (fderivWithin 𝕜 f t) t x)","decl":"lemma fderivWithin_fderivWithin_eq_of_eventuallyEq (h : s =ᶠ[𝓝 x] t) :\n    fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x = fderivWithin 𝕜 (fderivWithin 𝕜 f t) t x := calc\n  fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x\n    = fderivWithin 𝕜 (fderivWithin 𝕜 f t) s x :=\n      (fderivWithin_eventually_congr_set h).fderivWithin_eq_nhds\n  _ = fderivWithin 𝕜 (fderivWithin 𝕜 f t) t x := fderivWithin_congr_set h\n\n"}
{"name":"fderivWithin_fderivWithin_eq_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\n⊢ Eq (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) (fderiv 𝕜 (fderiv 𝕜 f) x)","decl":"lemma fderivWithin_fderivWithin_eq_of_mem_nhds {f : E → F} {x : E} {s : Set E}\n    (h : s ∈ 𝓝 x) :\n    fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x = fderiv 𝕜 (fderiv 𝕜 f) x := by\n  simp only [← fderivWithin_univ]\n  apply fderivWithin_fderivWithin_eq_of_eventuallyEq\n  simp [h]\n\n"}
{"name":"isSymmSndFDerivWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (IsSymmSndFDerivWithinAt 𝕜 f Set.univ x) (IsSymmSndFDerivAt 𝕜 f x)","decl":"@[simp] lemma isSymmSndFDerivWithinAt_univ :\n    IsSymmSndFDerivWithinAt 𝕜 f univ x ↔ IsSymmSndFDerivAt 𝕜 f x := by\n  simp [IsSymmSndFDerivWithinAt, IsSymmSndFDerivAt]\n\n"}
{"name":"IsSymmSndFDerivWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nh : IsSymmSndFDerivWithinAt 𝕜 f t x\nhst : Membership.mem (nhdsWithin x s) t\nhf : ContDiffWithinAt 𝕜 2 f t x\nhs : UniqueDiffOn 𝕜 s\nht : UniqueDiffOn 𝕜 t\nhx : Membership.mem s x\n⊢ IsSymmSndFDerivWithinAt 𝕜 f s x","decl":"theorem IsSymmSndFDerivWithinAt.mono_of_mem_nhdsWithin (h : IsSymmSndFDerivWithinAt 𝕜 f t x)\n    (hst : t ∈ 𝓝[s] x) (hf : ContDiffWithinAt 𝕜 2 f t x)\n    (hs : UniqueDiffOn 𝕜 s) (ht : UniqueDiffOn 𝕜 t) (hx : x ∈ s) :\n    IsSymmSndFDerivWithinAt 𝕜 f s x := by\n  intro v w\n  rw [fderivWithin_fderivWithin_eq_of_mem_nhdsWithin hst hf hs ht hx]\n  exact h v w\n\n"}
{"name":"IsSymmSndFDerivWithinAt.congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nh : IsSymmSndFDerivWithinAt 𝕜 f s x\nhst : (nhds x).EventuallyEq s t\n⊢ IsSymmSndFDerivWithinAt 𝕜 f t x","decl":"theorem IsSymmSndFDerivWithinAt.congr_set (h : IsSymmSndFDerivWithinAt 𝕜 f s x)\n    (hst : s =ᶠ[𝓝 x] t) : IsSymmSndFDerivWithinAt 𝕜 f t x := by\n  intro v w\n  rw [fderivWithin_fderivWithin_eq_of_eventuallyEq hst.symm]\n  exact h v w\n\n"}
{"name":"isSymmSndFDerivWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nhst : (nhds x).EventuallyEq s t\n⊢ Iff (IsSymmSndFDerivWithinAt 𝕜 f s x) (IsSymmSndFDerivWithinAt 𝕜 f t x)","decl":"theorem isSymmSndFDerivWithinAt_congr_set (hst : s =ᶠ[𝓝 x] t) :\n    IsSymmSndFDerivWithinAt 𝕜 f s x ↔ IsSymmSndFDerivWithinAt 𝕜 f t x :=\n  ⟨fun h ↦ h.congr_set hst, fun h ↦ h.congr_set hst.symm⟩\n\n"}
{"name":"IsSymmSndFDerivAt.isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nh : IsSymmSndFDerivAt 𝕜 f x\nhf : ContDiffAt 𝕜 2 f x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ IsSymmSndFDerivWithinAt 𝕜 f s x","decl":"theorem IsSymmSndFDerivAt.isSymmSndFDerivWithinAt (h : IsSymmSndFDerivAt 𝕜 f x)\n    (hf : ContDiffAt 𝕜 2 f x) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    IsSymmSndFDerivWithinAt 𝕜 f s x := by\n  simp only [← isSymmSndFDerivWithinAt_univ, ← contDiffWithinAt_univ] at h hf\n  exact h.mono_of_mem_nhdsWithin univ_mem hf hs uniqueDiffOn_univ hx\n\n"}
{"name":"ContDiffWithinAt.isSymmSndFDerivWithinAt_of_omega","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nhf : ContDiffWithinAt 𝕜 Top.top f s x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ IsSymmSndFDerivWithinAt 𝕜 f s x","decl":"/-- If a function is analytic within a set at a point, then its second derivative is symmetric. -/\ntheorem ContDiffWithinAt.isSymmSndFDerivWithinAt_of_omega (hf : ContDiffWithinAt 𝕜 ω f s x)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    IsSymmSndFDerivWithinAt 𝕜 f s x := by\n  intro v w\n  rw [← iteratedFDerivWithin_two_apply' f hs hx, ← iteratedFDerivWithin_two_apply' f hs hx,\n    ← hf.iteratedFDerivWithin_comp_perm hs hx _ (Equiv.swap 0 1)]\n  congr\n  ext i\n  fin_cases i <;> rfl\n\n"}
{"name":"ContDiffAt.isSymmSndFDerivAt_of_omega","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : ContDiffAt 𝕜 Top.top f x\n⊢ IsSymmSndFDerivAt 𝕜 f x","decl":"/-- If a function is analytic at a point, then its second derivative is symmetric. -/\ntheorem ContDiffAt.isSymmSndFDerivAt_of_omega (hf : ContDiffAt 𝕜 ω f x) :\n    IsSymmSndFDerivAt 𝕜 f x := by\n  simp only [← isSymmSndFDerivWithinAt_univ, ← contDiffWithinAt_univ] at hf ⊢\n  exact hf.isSymmSndFDerivWithinAt_of_omega uniqueDiffOn_univ (mem_univ _)\n\n"}
{"name":"Convex.taylor_approx_two_segment","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : ∀ (x : E), Membership.mem (interior s) x → HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nhv : Membership.mem (interior s) (HAdd.hAdd x v)\nhw : Membership.mem (interior s) (HAdd.hAdd (HAdd.hAdd x v) w)\n⊢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) (fun h => HSub.hSub (HSub.hSub (HSub.hSub (HSub.hSub (f (HAdd.hAdd (HAdd.hAdd x (HSMul.hSMul h v)) (HSMul.hSMul h w))) (f (HAdd.hAdd x (HSMul.hSMul h v)))) (HSMul.hSMul h ((f' x) w))) (HSMul.hSMul (HPow.hPow h 2) ((f'' v) w))) (HSMul.hSMul (HDiv.hDiv (HPow.hPow h 2) 2) ((f'' w) w))) fun h => HPow.hPow h 2","decl":"/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is\ndifferentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one can\nTaylor-expand to order two the function `f` on the segment `[x + h v, x + h (v + w)]`, giving a\nbilinear estimate for `f (x + hv + hw) - f (x + hv)` in terms of `f' w` and of `f'' ⬝ w`, up to\n`o(h^2)`.\n\nThis is a technical statement used to show that the second derivative is symmetric. -/\ntheorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)\n    (hw : x + v + w ∈ interior s) :\n    (fun h : ℝ => f (x + h • v + h • w)\n        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]\n      fun h => h ^ 2 := by\n  -- it suffices to check that the expression is bounded by `ε * ((‖v‖ + ‖w‖) * ‖w‖) * h^2` for\n  -- small enough `h`, for any positive `ε`.\n  refine IsLittleO.trans_isBigO\n    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)\n  -- consider a ball of radius `δ` around `x` in which the Taylor approximation for `f''` is\n  -- good up to `δ`.\n  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx\n  rcases Metric.mem_nhdsWithin_iff.1 (hx εpos) with ⟨δ, δpos, sδ⟩\n  have E1 : ∀ᶠ h in 𝓝[>] (0 : ℝ), h * (‖v‖ + ‖w‖) < δ := by\n    have : Filter.Tendsto (fun h => h * (‖v‖ + ‖w‖)) (𝓝[>] (0 : ℝ)) (𝓝 (0 * (‖v‖ + ‖w‖))) :=\n      (continuous_id.mul continuous_const).continuousWithinAt\n    apply (tendsto_order.1 this).2 δ\n    simpa only [zero_mul] using δpos\n  have E2 : ∀ᶠ h in 𝓝[>] (0 : ℝ), (h : ℝ) < 1 :=\n    mem_nhdsWithin_of_mem_nhds <| Iio_mem_nhds zero_lt_one\n  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hδ h_lt_1 hpos\n  -- we consider `h` small enough that all points under consideration belong to this ball,\n  -- and also with `0 < h < 1`.\n  replace hpos : 0 < h := hpos\n  have xt_mem : ∀ t ∈ Icc (0 : ℝ) 1, x + h • v + (t * h) • w ∈ interior s := by\n    intro t ht\n    have : x + h • v ∈ interior s := s_conv.add_smul_mem_interior xs hv ⟨hpos, h_lt_1.le⟩\n    rw [← smul_smul]\n    apply s_conv.interior.add_smul_mem this _ ht\n    rw [add_assoc] at hw\n    convert s_conv.add_smul_mem_interior xs hw ⟨hpos, h_lt_1.le⟩ using 1\n    module\n  -- define a function `g` on `[0,1]` (identified with `[v, v + w]`) such that `g 1 - g 0` is the\n  -- quantity to be estimated. We will check that its derivative is given by an explicit\n  -- expression `g'`, that we can bound. Then the desired bound for `g 1 - g 0` follows from the\n  -- mean value inequality.\n  let g t :=\n    f (x + h • v + (t * h) • w) - (t * h) • f' x w - (t * h ^ 2) • f'' v w -\n      ((t * h) ^ 2 / 2) • f'' w w\n  set g' := fun t =>\n    f' (x + h • v + (t * h) • w) (h • w) - h • f' x w - h ^ 2 • f'' v w - (t * h ^ 2) • f'' w w\n    with hg'\n  -- check that `g'` is the derivative of `g`, by a straightforward computation\n  have g_deriv : ∀ t ∈ Icc (0 : ℝ) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by\n    intro t ht\n    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]\n    · refine (hf _ ?_).comp_hasDerivWithinAt _ ?_\n      · exact xt_mem t ht\n      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,\n        hasDerivAt_mul_const]\n    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]\n    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]\n    · suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) • f'' w w)\n          ((((2 : ℕ) : ℝ) * (t * h) ^ (2 - 1) * (1 * h) / 2) • f'' w w) (Icc 0 1) t by\n        convert H using 2\n        ring\n      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',\n        HasDerivAt.pow, HasDerivAt.mul_const]\n  -- check that `g'` is uniformly bounded, with a suitable bound `ε * ((‖v‖ + ‖w‖) * ‖w‖) * h^2`.\n  have g'_bound : ∀ t ∈ Ico (0 : ℝ) 1, ‖g' t‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by\n    intro t ht\n    have I : ‖h • v + (t * h) • w‖ ≤ h * (‖v‖ + ‖w‖) :=\n      calc\n        ‖h • v + (t * h) • w‖ ≤ ‖h • v‖ + ‖(t * h) • w‖ := norm_add_le _ _\n        _ = h * ‖v‖ + t * (h * ‖w‖) := by\n          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,\n            mul_assoc]\n        _ ≤ h * ‖v‖ + 1 * (h * ‖w‖) := by gcongr; exact ht.2.le\n        _ = h * (‖v‖ + ‖w‖) := by ring\n    calc\n      ‖g' t‖ = ‖(f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)) (h • w)‖ := by\n        rw [hg']\n        congrm ‖?_‖\n        simp only [ContinuousLinearMap.sub_apply, ContinuousLinearMap.add_apply,\n          ContinuousLinearMap.smul_apply, map_add, map_smul]\n        module\n      _ ≤ ‖f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)‖ * ‖h • w‖ :=\n        (ContinuousLinearMap.le_opNorm _ _)\n      _ ≤ ε * ‖h • v + (t * h) • w‖ * ‖h • w‖ := by\n        gcongr\n        have H : x + h • v + (t * h) • w ∈ Metric.ball x δ ∩ interior s := by\n          refine ⟨?_, xt_mem t ⟨ht.1, ht.2.le⟩⟩\n          rw [add_assoc, add_mem_ball_iff_norm]\n          exact I.trans_lt hδ\n        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sδ H\n      _ ≤ ε * (‖h • v‖ + ‖h • w‖) * ‖h • w‖ := by\n        gcongr\n        apply (norm_add_le _ _).trans\n        gcongr\n        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]\n        exact mul_le_of_le_one_left (by positivity) ht.2.le\n      _ = ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by\n        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring\n  -- conclude using the mean value inequality\n  have I : ‖g 1 - g 0‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by\n    simpa only [mul_one, sub_zero] using\n      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)\n  convert I using 1\n  · congr 1\n    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,\n      zero_smul, Ne, not_false_iff, zero_pow, reduceCtorEq]\n    abel\n  · simp (discharger := positivity) only [Real.norm_eq_abs, abs_mul, abs_of_nonneg, abs_pow]\n    ring\n\n"}
{"name":"Convex.isLittleO_alternate_sum_square","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : ∀ (x : E), Membership.mem (interior s) x → HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 v))\nh4w : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 w))\n⊢ Asymptotics.IsLittleO (nhdsWithin 0 (Set.Ioi 0)) (fun h => HSub.hSub (HSub.hSub (HSub.hSub (HAdd.hAdd (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd (HSMul.hSMul 2 v) (HSMul.hSMul 2 w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd v w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd (HSMul.hSMul 2 v) w))))) (f (HAdd.hAdd x (HSMul.hSMul h (HAdd.hAdd v (HSMul.hSMul 2 w)))))) (HSMul.hSMul (HPow.hPow h 2) ((f'' v) w))) fun h => HPow.hPow h 2","decl":"/-- One can get `f'' v w` as the limit of `h ^ (-2)` times the alternate sum of the values of `f`\nalong the vertices of a quadrilateral with sides `h v` and `h w` based at `x`.\nIn a setting where `f` is not guaranteed to be continuous at `f`, we can still\nget this if we use a quadrilateral based at `h v + h w`. -/\ntheorem Convex.isLittleO_alternate_sum_square {v w : E} (h4v : x + (4 : ℝ) • v ∈ interior s)\n    (h4w : x + (4 : ℝ) • w ∈ interior s) :\n    (fun h : ℝ => f (x + h • (2 • v + 2 • w)) + f (x + h • (v + w))\n        - f (x + h • (2 • v + w)) - f (x + h • (v + 2 • w)) - h ^ 2 • f'' v w) =o[𝓝[>] 0]\n      fun h => h ^ 2 := by\n  have A : (1 : ℝ) / 2 ∈ Ioc (0 : ℝ) 1 := ⟨by norm_num, by norm_num⟩\n  have B : (1 : ℝ) / 2 ∈ Icc (0 : ℝ) 1 := ⟨by norm_num, by norm_num⟩\n  have h2v2w : x + (2 : ℝ) • v + (2 : ℝ) • w ∈ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h4v h4w B using 1\n    module\n  have h2vww : x + (2 • v + w) + w ∈ interior s := by\n    convert h2v2w using 1\n    module\n  have h2v : x + (2 : ℝ) • v ∈ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h4v A using 1\n    module\n  have h2w : x + (2 : ℝ) • w ∈ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h4w A using 1\n    module\n  have hvw : x + (v + w) ∈ interior s := by\n    convert s_conv.add_smul_sub_mem_interior xs h2v2w A using 1\n    module\n  have h2vw : x + (2 • v + w) ∈ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h2v h2v2w B using 1\n    module\n  have hvww : x + (v + w) + w ∈ interior s := by\n    convert s_conv.interior.add_smul_sub_mem h2w h2v2w B using 1\n    module\n  have TA1 := s_conv.taylor_approx_two_segment hf xs hx h2vw h2vww\n  have TA2 := s_conv.taylor_approx_two_segment hf xs hx hvw hvww\n  convert TA1.sub TA2 using 1\n  ext h\n  simp only [two_smul, smul_add, ← add_assoc, ContinuousLinearMap.map_add,\n    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul',\n    ContinuousLinearMap.map_smul]\n  abel\n\n"}
{"name":"Convex.second_derivative_within_at_symmetric_of_mem_interior","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : ∀ (x : E), Membership.mem (interior s) x → HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\nh4v : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 v))\nh4w : Membership.mem (interior s) (HAdd.hAdd x (HSMul.hSMul 4 w))\n⊢ Eq ((f'' w) v) ((f'' v) w)","decl":"/-- Assume that `f` is differentiable inside a convex set `s`, and that its derivative `f'` is\ndifferentiable at a point `x`. Then, given two vectors `v` and `w` pointing inside `s`, one\nhas `f'' v w = f'' w v`. Superseded by `Convex.second_derivative_within_at_symmetric`, which\nremoves the assumption that `v` and `w` point inside `s`. -/\ntheorem Convex.second_derivative_within_at_symmetric_of_mem_interior {v w : E}\n    (h4v : x + (4 : ℝ) • v ∈ interior s) (h4w : x + (4 : ℝ) • w ∈ interior s) :\n    f'' w v = f'' v w := by\n  have A : (fun h : ℝ => h ^ 2 • (f'' w v - f'' v w)) =o[𝓝[>] 0] fun h => h ^ 2 := by\n    convert (s_conv.isLittleO_alternate_sum_square hf xs hx h4v h4w).sub\n      (s_conv.isLittleO_alternate_sum_square hf xs hx h4w h4v) using 1\n    ext h\n    simp only [add_comm, smul_add, smul_sub]\n    abel\n  have B : (fun _ : ℝ => f'' w v - f'' v w) =o[𝓝[>] 0] fun _ => (1 : ℝ) := by\n    have : (fun h : ℝ => 1 / h ^ 2) =O[𝓝[>] 0] fun h => 1 / h ^ 2 := isBigO_refl _ _\n    have C := this.smul_isLittleO A\n    apply C.congr' _ _\n    · filter_upwards [self_mem_nhdsWithin]\n      intro h (hpos : 0 < h)\n      match_scalars <;> field_simp\n    · filter_upwards [self_mem_nhdsWithin] with h (hpos : 0 < h)\n      field_simp\n  simpa only [sub_eq_zero] using isLittleO_const_const_iff.1 B\n\n"}
{"name":"Convex.second_derivative_within_at_symmetric","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ns : Set E\ns_conv : Convex Real s\nhne : (interior s).Nonempty\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : ∀ (x : E), Membership.mem (interior s) x → HasFDerivAt f (f' x) x\nx : E\nxs : Membership.mem s x\nhx : HasFDerivWithinAt f' f'' (interior s) x\nv w : E\n⊢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable inside a convex set with nonempty interior, and has a second\nderivative at a point of this convex set, then this second derivative is symmetric. -/\ntheorem Convex.second_derivative_within_at_symmetric {s : Set E} (s_conv : Convex ℝ s)\n    (hne : (interior s).Nonempty) {f : E → F} {f' : E → E →L[ℝ] F} {f'' : E →L[ℝ] E →L[ℝ] F}\n    (hf : ∀ x ∈ interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x ∈ s)\n    (hx : HasFDerivWithinAt f' f'' (interior s) x) (v w : E) : f'' v w = f'' w v := by\n  /- we work around a point `x + 4 z` in the interior of `s`. For any vector `m`,\n    then `x + 4 (z + t m)` also belongs to the interior of `s` for small enough `t`. This means that\n    we will be able to apply `second_derivative_within_at_symmetric_of_mem_interior` to show\n    that `f''` is symmetric, after cancelling all the contributions due to `z`. -/\n  rcases hne with ⟨y, hy⟩\n  obtain ⟨z, hz⟩ : ∃ z, z = ((1 : ℝ) / 4) • (y - x) := ⟨((1 : ℝ) / 4) • (y - x), rfl⟩\n  have A : ∀ m : E, Filter.Tendsto (fun t : ℝ => x + (4 : ℝ) • (z + t • m)) (𝓝 0) (𝓝 y) := by\n    intro m\n    have : x + (4 : ℝ) • (z + (0 : ℝ) • m) = y := by simp [hz]\n    rw [← this]\n    refine tendsto_const_nhds.add <| tendsto_const_nhds.smul <| tendsto_const_nhds.add ?_\n    exact continuousAt_id.smul continuousAt_const\n  have B : ∀ m : E, ∀ᶠ t in 𝓝[>] (0 : ℝ), x + (4 : ℝ) • (z + t • m) ∈ interior s := by\n    intro m\n    apply nhdsWithin_le_nhds\n    apply A m\n    rw [mem_interior_iff_mem_nhds] at hy\n    exact interior_mem_nhds.2 hy\n  -- we choose `t m > 0` such that `x + 4 (z + (t m) m)` belongs to the interior of `s`, for any\n  -- vector `m`.\n  choose t ts tpos using fun m => ((B m).and self_mem_nhdsWithin).exists\n  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z`\n  -- and `z + (t m) m`, we deduce that `f'' m z = f'' z m` for all `m`.\n  have C : ∀ m : E, f'' m z = f'' z m := by\n    intro m\n    have : f'' (z + t m • m) (z + t 0 • (0 : E)) = f'' (z + t 0 • (0 : E)) (z + t m • m) :=\n      s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts 0) (ts m)\n    simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, add_right_inj,\n      ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', add_zero,\n      ContinuousLinearMap.zero_apply, smul_zero, ContinuousLinearMap.map_zero] at this\n    exact smul_right_injective F (tpos m).ne' this\n  -- applying `second_derivative_within_at_symmetric_of_mem_interior` to the vectors `z + (t v) v`\n  -- and `z + (t w) w`, we deduce that `f'' v w = f'' w v`. Cross terms involving `z` can be\n  -- eliminated thanks to the fact proved above that `f'' m z = f'' z m`.\n  have : f'' (z + t v • v) (z + t w • w) = f'' (z + t w • w) (z + t v • v) :=\n    s_conv.second_derivative_within_at_symmetric_of_mem_interior hf xs hx (ts w) (ts v)\n  simp only [ContinuousLinearMap.map_add, ContinuousLinearMap.map_smul, smul_add, smul_smul,\n    ContinuousLinearMap.add_apply, Pi.smul_apply, ContinuousLinearMap.coe_smul', C] at this\n  have : (t v * t w) • (f'' v) w = (t v * t w) • (f'' w) v := by\n    linear_combination (norm := module) this\n  apply smul_right_injective F _ this\n  simp [(tpos v).ne', (tpos w).ne']\n\n"}
{"name":"second_derivative_symmetric_of_eventually_of_real","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nx : E\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\nf'' : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E F)\nhf : Filter.Eventually (fun y => HasFDerivAt f (f' y) y) (nhds x)\nhx : HasFDerivAt f' f'' x\nv w : E\n⊢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable around `x`, and has two derivatives at `x`, then the second\nderivative is symmetric. Version over `ℝ`. See `second_derivative_symmetric_of_eventually` for a\nversion over `ℝ` or `ℂ`. -/\ntheorem second_derivative_symmetric_of_eventually_of_real {f : E → F} {f' : E → E →L[ℝ] F}\n    {f'' : E →L[ℝ] E →L[ℝ] F} (hf : ∀ᶠ y in 𝓝 x, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x)\n    (v w : E) : f'' v w = f'' w v := by\n  rcases Metric.mem_nhds_iff.1 hf with ⟨ε, εpos, hε⟩\n  have A : (interior (Metric.ball x ε)).Nonempty := by\n    rwa [Metric.isOpen_ball.interior_eq, Metric.nonempty_ball]\n  exact\n    Convex.second_derivative_within_at_symmetric (convex_ball x ε) A\n      (fun y hy => hε (interior_subset hy)) (Metric.mem_ball_self εpos) hx.hasFDerivWithinAt v w\n\n"}
{"name":"second_derivative_symmetric_of_eventually","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : IsRCLikeNormedField 𝕜\nf' : E → ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nf'' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E F)\nhf : Filter.Eventually (fun y => HasFDerivAt f (f' y) y) (nhds x)\nhx : HasFDerivAt f' f'' x\nv w : E\n⊢ Eq ((f'' v) w) ((f'' w) v)","decl":"theorem second_derivative_symmetric_of_eventually [IsRCLikeNormedField 𝕜]\n    {f' : E → E →L[𝕜] F} {x : E}\n    {f'' : E →L[𝕜] E →L[𝕜] F} (hf : ∀ᶠ y in 𝓝 x, HasFDerivAt f (f' y) y)\n    (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v := by\n  let _ := IsRCLikeNormedField.rclike 𝕜\n  let _ : NormedSpace ℝ E := NormedSpace.restrictScalars ℝ 𝕜 E\n  let _ : NormedSpace ℝ F := NormedSpace.restrictScalars ℝ 𝕜 F\n  let _ : LinearMap.CompatibleSMul E F ℝ 𝕜 := LinearMap.IsScalarTower.compatibleSMul\n  let _ : LinearMap.CompatibleSMul E (E →L[𝕜] F) ℝ 𝕜 := LinearMap.IsScalarTower.compatibleSMul\n  let f'R : E → E →L[ℝ] F := fun x ↦ (f' x).restrictScalars ℝ\n  have hfR : ∀ᶠ y in 𝓝 x, HasFDerivAt f (f'R y) y := by\n    filter_upwards [hf] with y hy using HasFDerivAt.restrictScalars ℝ hy\n  let f''Rl : E →ₗ[ℝ] E →ₗ[ℝ] F :=\n  { toFun := fun x ↦\n      { toFun := fun y ↦ f'' x y\n        map_add' := by simp\n        map_smul' := by simp }\n    map_add' := by intros; ext; simp\n    map_smul' := by intros; ext; simp }\n  let f''R : E →L[ℝ] E →L[ℝ] F := by\n    refine LinearMap.mkContinuous₂ f''Rl (‖f''‖) (fun x y ↦ ?_)\n    simp only [LinearMap.coe_mk, AddHom.coe_mk, f''Rl]\n    exact ContinuousLinearMap.le_opNorm₂ f'' x y\n  have : HasFDerivAt f'R f''R x := by\n    simp only [hasFDerivAt_iff_tendsto] at hx ⊢\n    exact hx\n  change f''R v w = f''R w v\n  exact second_derivative_symmetric_of_eventually_of_real hfR this v w\n\n"}
{"name":"second_derivative_symmetric","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ninst✝ : IsRCLikeNormedField 𝕜\nf' : E → ContinuousLinearMap (RingHom.id 𝕜) E F\nf'' : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E F)\nx : E\nhf : ∀ (y : E), HasFDerivAt f (f' y) y\nhx : HasFDerivAt f' f'' x\nv w : E\n⊢ Eq ((f'' v) w) ((f'' w) v)","decl":"/-- If a function is differentiable, and has two derivatives at `x`, then the second\nderivative is symmetric. -/\ntheorem second_derivative_symmetric [IsRCLikeNormedField 𝕜]\n    {f' : E → E →L[𝕜] F} {f'' : E →L[𝕜] E →L[𝕜] F} {x : E}\n    (hf : ∀ y, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v :=\n  second_derivative_symmetric_of_eventually (Filter.Eventually.of_forall hf) hx v w\n\n"}
{"name":"minSmoothness_def","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_4\ninst✝ : NontriviallyNormedField 𝕜\nn : WithTop ENat\n⊢ Eq (minSmoothness 𝕜 n) (ite (IsRCLikeNormedField 𝕜) n Top.top)","decl":"open scoped Classical in\nvariable (𝕜) in\n/-- `minSmoothness 𝕜 n` is the minimal smoothness exponent larger than or equal to `n` for which\none can do serious calculus in `𝕜`. If `𝕜` is `ℝ` or `ℂ`, this is just `n`. Otherwise,\nthis is `ω` as only analytic functions are well behaved on `ℚₚ`, say. -/\nnoncomputable irreducible_def minSmoothness (n : WithTop ℕ∞) :=\n  if IsRCLikeNormedField 𝕜 then n else ω\n\n"}
{"name":"minSmoothness_of_isRCLikeNormedField","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nh : IsRCLikeNormedField 𝕜\nn : WithTop ENat\n⊢ Eq (minSmoothness 𝕜 n) n","decl":"@[simp] lemma minSmoothness_of_isRCLikeNormedField [h : IsRCLikeNormedField 𝕜] {n : WithTop ℕ∞} :\n    minSmoothness 𝕜 n = n := by\n  simp [minSmoothness, h]\n\n"}
{"name":"le_minSmoothness","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nn : WithTop ENat\n⊢ LE.le n (minSmoothness 𝕜 n)","decl":"lemma le_minSmoothness {n : WithTop ℕ∞} : n ≤ minSmoothness 𝕜 n := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n\n"}
{"name":"minSmoothness_add","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nn m : WithTop ENat\n⊢ Eq (minSmoothness 𝕜 (HAdd.hAdd n m)) (HAdd.hAdd (minSmoothness 𝕜 n) m)","decl":"lemma minSmoothness_add {n m : WithTop ℕ∞} : minSmoothness 𝕜 (n + m) = minSmoothness 𝕜 n + m := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n\n"}
{"name":"minSmoothness_monotone","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Monotone (minSmoothness 𝕜)","decl":"lemma minSmoothness_monotone : Monotone (minSmoothness 𝕜) := by\n  intro m n hmn\n  simp only [minSmoothness]\n  split_ifs <;> simp [hmn]\n\n"}
{"name":"minSmoothness_eq_infty","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nn : WithTop ENat\n⊢ Iff (Eq (minSmoothness 𝕜 n) ↑Top.top) (And (Eq n ↑Top.top) (IsRCLikeNormedField 𝕜))","decl":"@[simp] lemma minSmoothness_eq_infty {n : WithTop ℕ∞} :\n    minSmoothness 𝕜 n = ∞ ↔ (n = ∞ ∧ IsRCLikeNormedField 𝕜) := by\n  simp only [minSmoothness]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"exist_minSmoothness_le_ne_infty","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nm : Nat\nhm : LE.le (minSmoothness 𝕜 ↑m) n\n⊢ Exists fun n' => And (LE.le (minSmoothness 𝕜 ↑m) n') (And (LE.le n' n) (Ne n' ↑Top.top))","decl":"/-- If `minSmoothness 𝕜 m ≤ n` for some (finite) integer `m`, then one can\nfind `n' ∈ [minSmoothness 𝕜 m, n]` which is not `∞`: over `ℝ` or `ℂ`, just take `m`, and otherwise\njust take `ω`. The interest of this technical lemma is that, if a function is `C^{n'}` at a point\nfor `n' ≠ ∞`, then it is `C^{n'}` on a neighborhood of the point (this property fails only\nin `C^∞` smoothness, see `ContDiffWithinAt.contDiffOn`). -/\nlemma exist_minSmoothness_le_ne_infty {n : WithTop ℕ∞} {m : ℕ} (hm : minSmoothness 𝕜 m ≤ n) :\n    ∃ n', minSmoothness 𝕜 m ≤ n' ∧ n' ≤ n ∧ n' ≠ ∞ := by\n  simp only [minSmoothness] at hm ⊢\n  split_ifs with h\n  · simp only [h, ↓reduceIte] at hm\n    exact ⟨m, le_rfl, hm, by simp⟩\n  · simp only [h, ↓reduceIte, top_le_iff] at hm\n    refine ⟨ω, le_rfl, by simp [hm], by simp⟩\n\n"}
{"name":"ContDiffAt.isSymmSndFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\nhf : ContDiffAt 𝕜 n f x\nhn : LE.le (minSmoothness 𝕜 2) n\n⊢ IsSymmSndFDerivAt 𝕜 f x","decl":"/-- If a function is `C^2` at a point, then its second derivative there is symmetric. Over a field\ndifferent from `ℝ` or `ℂ`, we should require that the function is analytic. -/\ntheorem ContDiffAt.isSymmSndFDerivAt {n : WithTop ℕ∞}\n    (hf : ContDiffAt 𝕜 n f x) (hn : minSmoothness 𝕜 2 ≤ n) : IsSymmSndFDerivAt 𝕜 f x := by\n  by_cases h : IsRCLikeNormedField 𝕜\n  -- First deal with the `ℝ` or `ℂ` case, where `C^2` is enough.\n  · intro v w\n    apply second_derivative_symmetric_of_eventually (f := f) (f' := fderiv 𝕜 f) (x := x)\n    · obtain ⟨u, hu, h'u⟩ : ∃ u ∈ 𝓝 x, ContDiffOn 𝕜 2 f u :=\n        (hf.of_le hn).contDiffOn (m := 2) le_minSmoothness (by simp)\n      rcases mem_nhds_iff.1 hu with ⟨v, vu, v_open, xv⟩\n      filter_upwards [v_open.mem_nhds xv] with y hy\n      have : DifferentiableAt 𝕜 f y := by\n        have := (h'u.mono vu y hy).contDiffAt (v_open.mem_nhds hy)\n        exact this.differentiableAt one_le_two\n      exact DifferentiableAt.hasFDerivAt this\n    · have : DifferentiableAt 𝕜 (fderiv 𝕜 f) x := by\n        apply ContDiffAt.differentiableAt _ le_rfl\n        exact hf.fderiv_right (le_minSmoothness.trans hn)\n      exact DifferentiableAt.hasFDerivAt this\n  -- then deal with the case of an arbitrary field, with analytic functions.\n  · simp only [minSmoothness, h, ↓reduceIte, top_le_iff] at hn\n    apply ContDiffAt.isSymmSndFDerivAt_of_omega\n    simpa [hn] using hf\n\n"}
{"name":"ContDiffWithinAt.isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Symmetric","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nhf : ContDiffWithinAt 𝕜 n f s x\nhn : LE.le (minSmoothness 𝕜 2) n\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem (closure (interior s)) x\nh'x : Membership.mem s x\n⊢ IsSymmSndFDerivWithinAt 𝕜 f s x","decl":"/-- If a function is `C^2` within a set at a point, and accumulated by points in the interior\nof the set, then its second derivative there is symmetric. Over a field\ndifferent from `ℝ` or `ℂ`, we should require that the function is analytic. -/\ntheorem ContDiffWithinAt.isSymmSndFDerivWithinAt {n : WithTop ℕ∞}\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hn : minSmoothness 𝕜 2 ≤ n)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ closure (interior s)) (h'x : x ∈ s) :\n    IsSymmSndFDerivWithinAt 𝕜 f s x := by\n  /- We argue that, at interior points, the second derivative is symmetric, and moreover by\n  continuity it converges to the second derivative at `x`. Therefore, the latter is also\n  symmetric. -/\n  obtain ⟨m, hm, hmn, m_ne⟩ := exist_minSmoothness_le_ne_infty hn\n  rcases (hf.of_le hmn).contDiffOn' le_rfl (by simp [m_ne]) with ⟨u, u_open, xu, hu⟩\n  simp only [insert_eq_of_mem h'x] at hu\n  have h'u : UniqueDiffOn 𝕜 (s ∩ u) := hs.inter u_open\n  obtain ⟨y, hy, y_lim⟩ : ∃ y, (∀ (n : ℕ), y n ∈ interior s) ∧ Tendsto y atTop (𝓝 x) :=\n    mem_closure_iff_seq_limit.1 hx\n  have L : ∀ᶠ k in atTop, y k ∈ u := y_lim (u_open.mem_nhds xu)\n  have I : ∀ᶠ k in atTop, IsSymmSndFDerivWithinAt 𝕜 f s (y k) := by\n    filter_upwards [L] with k hk\n    have s_mem : s ∈ 𝓝 (y k) := by\n      apply mem_of_superset (isOpen_interior.mem_nhds (hy k))\n      exact interior_subset\n    have : IsSymmSndFDerivAt 𝕜 f (y k) := by\n      apply ContDiffAt.isSymmSndFDerivAt _ (n := m) hm\n      apply (hu (y k) ⟨(interior_subset (hy k)), hk⟩).contDiffAt\n      exact inter_mem s_mem (u_open.mem_nhds hk)\n    intro v w\n    rw [fderivWithin_fderivWithin_eq_of_mem_nhds s_mem]\n    exact this v w\n  have A : ContinuousOn (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s) (s ∩ u) := by\n    have : ContinuousOn (fderivWithin 𝕜 (fderivWithin 𝕜 f (s ∩ u)) (s ∩ u)) (s ∩ u) :=\n      ((hu.fderivWithin h'u (m := 1) (le_minSmoothness.trans hm)).fderivWithin h'u\n      (m := 0) le_rfl).continuousOn\n    apply this.congr\n    intro y hy\n    apply fderivWithin_fderivWithin_eq_of_eventuallyEq\n    filter_upwards [u_open.mem_nhds hy.2] with z hz\n    change (z ∈ s) = (z ∈ s ∩ u)\n    aesop\n  have B : Tendsto (fun k ↦ fderivWithin 𝕜 (fderivWithin 𝕜 f s) s (y k)) atTop\n      (𝓝 (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x)) := by\n    have : Tendsto y atTop (𝓝[s ∩ u] x) := by\n      apply tendsto_nhdsWithin_iff.2 ⟨y_lim, ?_⟩\n      filter_upwards [L] with k hk using ⟨interior_subset (hy k), hk⟩\n    exact (A x ⟨h'x, xu⟩ ).tendsto.comp this\n  have C (v w : E) : Tendsto (fun k ↦ fderivWithin 𝕜 (fderivWithin 𝕜 f s) s (y k) v w) atTop\n      (𝓝 (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x v w)) := by\n    have : Continuous (fun (A : E →L[𝕜] E →L[𝕜] F) ↦ A v w) := by fun_prop\n    exact (this.tendsto _).comp B\n  have C' (v w : E) : Tendsto (fun k ↦ fderivWithin 𝕜 (fderivWithin 𝕜 f s) s (y k) w v) atTop\n      (𝓝 (fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x v w)) := by\n    apply (C v w).congr'\n    filter_upwards [I] with k hk using hk v w\n  intro v w\n  exact tendsto_nhds_unique (C v w) (C' w v)\n\n"}
