{"name":"CategoryTheory.LocalizerMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\ninst‚úù¬≥ : SizeOf C‚ÇÅ\ninst‚úù¬≤ : SizeOf C‚ÇÇ\ninst‚úù¬π : ‚¶ÉX Y : C‚ÇÅ‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÅ x)\ninst‚úù : ‚¶ÉX Y : C‚ÇÇ‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÇ x)\nfunctor : CategoryTheory.Functor C‚ÇÅ C‚ÇÇ\nmap : LE.le W‚ÇÅ (W‚ÇÇ.inverseImage functor)\n‚ä¢ Eq (SizeOf.sizeOf { functor := functor, map := map }) (HAdd.hAdd 1 (SizeOf.sizeOf functor))","decl":"/-- If `W‚ÇÅ : MorphismProperty C‚ÇÅ` and `W‚ÇÇ : MorphismProperty C‚ÇÇ`, a `LocalizerMorphism W‚ÇÅ W‚ÇÇ`\nis the datum of a functor `C‚ÇÅ ‚•§ C‚ÇÇ` which sends morphisms in `W‚ÇÅ` to morphisms in `W‚ÇÇ` -/\nstructure LocalizerMorphism where\n  /-- a functor between the two categories -/\n  functor : C‚ÇÅ ‚•§ C‚ÇÇ\n  /-- the functor is compatible with the `MorphismProperty` -/\n  map : W‚ÇÅ ‚â§ W‚ÇÇ.inverseImage functor\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.map","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nself : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\n‚ä¢ LE.le W‚ÇÅ (W‚ÇÇ.inverseImage self.functor)","decl":"/-- If `W‚ÇÅ : MorphismProperty C‚ÇÅ` and `W‚ÇÇ : MorphismProperty C‚ÇÇ`, a `LocalizerMorphism W‚ÇÅ W‚ÇÇ`\nis the datum of a functor `C‚ÇÅ ‚•§ C‚ÇÇ` which sends morphisms in `W‚ÇÅ` to morphisms in `W‚ÇÇ` -/\nstructure LocalizerMorphism where\n  /-- a functor between the two categories -/\n  functor : C‚ÇÅ ‚•§ C‚ÇÇ\n  /-- the functor is compatible with the `MorphismProperty` -/\n  map : W‚ÇÅ ‚â§ W‚ÇÇ.inverseImage functor\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.mk.inj","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nfunctor‚úù : CategoryTheory.Functor C‚ÇÅ C‚ÇÇ\nmap‚úù : LE.le W‚ÇÅ (W‚ÇÇ.inverseImage functor‚úù)\nfunctor : CategoryTheory.Functor C‚ÇÅ C‚ÇÇ\nmap : LE.le W‚ÇÅ (W‚ÇÇ.inverseImage functor)\nx‚úù : Eq { functor := functor‚úù, map := map‚úù } { functor := functor, map := map }\n‚ä¢ Eq functor‚úù functor","decl":"/-- If `W‚ÇÅ : MorphismProperty C‚ÇÅ` and `W‚ÇÇ : MorphismProperty C‚ÇÇ`, a `LocalizerMorphism W‚ÇÅ W‚ÇÇ`\nis the datum of a functor `C‚ÇÅ ‚•§ C‚ÇÇ` which sends morphisms in `W‚ÇÅ` to morphisms in `W‚ÇÇ` -/\nstructure LocalizerMorphism where\n  /-- a functor between the two categories -/\n  functor : C‚ÇÅ ‚•§ C‚ÇÇ\n  /-- the functor is compatible with the `MorphismProperty` -/\n  map : W‚ÇÅ ‚â§ W‚ÇÇ.inverseImage functor\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nfunctor‚úù : CategoryTheory.Functor C‚ÇÅ C‚ÇÇ\nmap‚úù : LE.le W‚ÇÅ (W‚ÇÇ.inverseImage functor‚úù)\nfunctor : CategoryTheory.Functor C‚ÇÅ C‚ÇÇ\nmap : LE.le W‚ÇÅ (W‚ÇÇ.inverseImage functor)\n‚ä¢ Eq (Eq { functor := functor‚úù, map := map‚úù } { functor := functor, map := map }) (Eq functor‚úù functor)","decl":"/-- If `W‚ÇÅ : MorphismProperty C‚ÇÅ` and `W‚ÇÇ : MorphismProperty C‚ÇÇ`, a `LocalizerMorphism W‚ÇÅ W‚ÇÇ`\nis the datum of a functor `C‚ÇÅ ‚•§ C‚ÇÇ` which sends morphisms in `W‚ÇÅ` to morphisms in `W‚ÇÇ` -/\nstructure LocalizerMorphism where\n  /-- a functor between the two categories -/\n  functor : C‚ÇÅ ‚•§ C‚ÇÇ\n  /-- the functor is compatible with the `MorphismProperty` -/\n  map : W‚ÇÅ ‚â§ W‚ÇÇ.inverseImage functor\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.id_functor","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\n‚ä¢ Eq (CategoryTheory.LocalizerMorphism.id W‚ÇÅ).functor (CategoryTheory.Functor.id C‚ÇÅ)","decl":"/-- The identity functor as a morphism of localizers. -/\n@[simps]\ndef id : LocalizerMorphism W‚ÇÅ W‚ÇÅ where\n  functor := ùü≠ C‚ÇÅ\n  map _ _ _ hf := hf\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.comp_functor","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nC‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C‚ÇÉ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nW‚ÇÉ : CategoryTheory.MorphismProperty C‚ÇÉ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nŒ® : CategoryTheory.LocalizerMorphism W‚ÇÇ W‚ÇÉ\n‚ä¢ Eq (Œ¶.comp Œ®).functor (Œ¶.functor.comp Œ®.functor)","decl":"/-- The composition of two localizers morphisms. -/\n@[simps]\ndef comp (Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ) (Œ® : LocalizerMorphism W‚ÇÇ W‚ÇÉ) :\n    LocalizerMorphism W‚ÇÅ W‚ÇÉ where\n  functor := Œ¶.functor ‚ãô Œ®.functor\n  map _ _ _ hf := Œ®.map _ (Œ¶.map _ hf)\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.op_functor","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\n‚ä¢ Eq Œ¶.op.functor Œ¶.functor.op","decl":"/-- The opposite localizer morphism `LocalizerMorphism W‚ÇÅ.op W‚ÇÇ.op` deduced\nfrom `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`. -/\n@[simps]\ndef op : LocalizerMorphism W‚ÇÅ.op W‚ÇÇ.op where\n  functor := Œ¶.functor.op\n  map _ _ _ hf := Œ¶.map _ hf\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.inverts","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù : L‚ÇÇ.IsLocalization W‚ÇÇ\n‚ä¢ W‚ÇÅ.IsInvertedBy (Œ¶.functor.comp L‚ÇÇ)","decl":"lemma inverts : W‚ÇÅ.IsInvertedBy (Œ¶.functor ‚ãô L‚ÇÇ) :=\n  fun _ _ _ hf => Localization.inverts L‚ÇÇ W‚ÇÇ _ (Œ¶.map _ hf)\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.isEquivalence_imp","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÅ : Type u‚ÇÑ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù¬π¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬π¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù¬π‚Å∞ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D‚ÇÅ\ninst‚úù‚Åπ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\ninst‚úù‚Å∏ : L‚ÇÅ.IsLocalization W‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù‚Å∑ : L‚ÇÇ.IsLocalization W‚ÇÇ\nG : CategoryTheory.Functor D‚ÇÅ D‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G\nD‚ÇÅ' : Type u‚ÇÑ'\nD‚ÇÇ' : Type u‚ÇÖ'\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ', u‚ÇÑ'} D‚ÇÅ'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ', u‚ÇÖ'} D‚ÇÇ'\nL‚ÇÅ' : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ'\nL‚ÇÇ' : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ'\ninst‚úù¬≥ : L‚ÇÅ'.IsLocalization W‚ÇÅ\ninst‚úù¬≤ : L‚ÇÇ'.IsLocalization W‚ÇÇ\nG' : CategoryTheory.Functor D‚ÇÅ' D‚ÇÇ'\ninst‚úù¬π : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ' L‚ÇÇ' G'\ninst‚úù : G.IsEquivalence\n‚ä¢ G'.IsEquivalence","decl":"/-- If a localizer morphism induces an equivalence on some choice of localized categories,\nit will be so for any choice of localized categoriees. -/\nlemma isEquivalence_imp [G.IsEquivalence] : G'.IsEquivalence :=\n  let E‚ÇÅ := Localization.uniq L‚ÇÅ L‚ÇÅ' W‚ÇÅ\n  let E‚ÇÇ := Localization.uniq L‚ÇÇ L‚ÇÇ' W‚ÇÇ\n  let e : L‚ÇÅ ‚ãô G ‚ãô E‚ÇÇ.functor ‚âÖ L‚ÇÅ ‚ãô E‚ÇÅ.functor ‚ãô G' :=\n    calc\n      L‚ÇÅ ‚ãô G ‚ãô E‚ÇÇ.functor ‚âÖ Œ¶.functor ‚ãô L‚ÇÇ ‚ãô E‚ÇÇ.functor :=\n          (Functor.associator _ _ _).symm ‚â™‚â´\n            isoWhiskerRight (CatCommSq.iso Œ¶.functor L‚ÇÅ L‚ÇÇ G).symm E‚ÇÇ.functor ‚â™‚â´\n            Functor.associator _ _ _\n      _ ‚âÖ Œ¶.functor ‚ãô L‚ÇÇ' := isoWhiskerLeft Œ¶.functor (compUniqFunctor L‚ÇÇ L‚ÇÇ' W‚ÇÇ)\n      _ ‚âÖ L‚ÇÅ' ‚ãô G' := CatCommSq.iso Œ¶.functor L‚ÇÅ' L‚ÇÇ' G'\n      _ ‚âÖ L‚ÇÅ ‚ãô E‚ÇÅ.functor ‚ãô G' :=\n            isoWhiskerRight (compUniqFunctor L‚ÇÅ L‚ÇÅ' W‚ÇÅ).symm G' ‚â™‚â´ Functor.associator _ _ _\n  have := Functor.isEquivalence_of_iso\n    (liftNatIso L‚ÇÅ W‚ÇÅ _ _ (G ‚ãô E‚ÇÇ.functor) (E‚ÇÅ.functor ‚ãô G') e)\n  Functor.isEquivalence_of_comp_left E‚ÇÅ.functor G'\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.isEquivalence_iff","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÅ : Type u‚ÇÑ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù¬π¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬π‚Å∞ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù‚Åπ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D‚ÇÅ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\ninst‚úù‚Å∑ : L‚ÇÅ.IsLocalization W‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù‚Å∂ : L‚ÇÇ.IsLocalization W‚ÇÇ\nG : CategoryTheory.Functor D‚ÇÅ D‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G\nD‚ÇÅ' : Type u‚ÇÑ'\nD‚ÇÇ' : Type u‚ÇÖ'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ', u‚ÇÑ'} D‚ÇÅ'\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÖ', u‚ÇÖ'} D‚ÇÇ'\nL‚ÇÅ' : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ'\nL‚ÇÇ' : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ'\ninst‚úù¬≤ : L‚ÇÅ'.IsLocalization W‚ÇÅ\ninst‚úù¬π : L‚ÇÇ'.IsLocalization W‚ÇÇ\nG' : CategoryTheory.Functor D‚ÇÅ' D‚ÇÇ'\ninst‚úù : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ' L‚ÇÇ' G'\n‚ä¢ Iff G.IsEquivalence G'.IsEquivalence","decl":"lemma isEquivalence_iff : G.IsEquivalence ‚Üî G'.IsEquivalence :=\n  ‚ü®fun _ => Œ¶.isEquivalence_imp L‚ÇÅ L‚ÇÇ G L‚ÇÅ' L‚ÇÇ' G',\n    fun _ => Œ¶.isEquivalence_imp L‚ÇÅ' L‚ÇÇ' G' L‚ÇÅ L‚ÇÇ G‚ü©\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.isEquivalence","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nself : Œ¶.IsLocalizedEquivalence\n‚ä¢ (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q).IsEquivalence","decl":"/-- Condition that a `LocalizerMorphism` induces an equivalence on the localized categories -/\nclass IsLocalizedEquivalence : Prop where\n  /-- the induced functor on the constructed localized categories is an equivalence -/\n  isEquivalence : (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q).IsEquivalence\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.mk'","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÅ : Type u‚ÇÑ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\ninst‚úù¬≥ : L‚ÇÅ.IsLocalization W‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù¬≤ : L‚ÇÇ.IsLocalization W‚ÇÇ\nG : CategoryTheory.Functor D‚ÇÅ D‚ÇÇ\ninst‚úù¬π : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G\ninst‚úù : G.IsEquivalence\n‚ä¢ Œ¶.IsLocalizedEquivalence","decl":"lemma IsLocalizedEquivalence.mk' [CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G] [G.IsEquivalence] :\n    Œ¶.IsLocalizedEquivalence where\n  isEquivalence := by\n    rw [Œ¶.isEquivalence_iff W‚ÇÅ.Q W‚ÇÇ.Q (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q) L‚ÇÅ L‚ÇÇ G]\n    exact inferInstance\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.isEquivalence","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÅ : Type u‚ÇÑ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\ninst‚úù¬≤ : L‚ÇÅ.IsLocalization W‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù¬π : L‚ÇÇ.IsLocalization W‚ÇÇ\nG : CategoryTheory.Functor D‚ÇÅ D‚ÇÇ\nh : Œ¶.IsLocalizedEquivalence\ninst‚úù : CategoryTheory.CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G\n‚ä¢ G.IsEquivalence","decl":"/-- If a `LocalizerMorphism` is a localized equivalence, then any compatible functor\nbetween the localized categories is an equivalence. -/\nlemma isEquivalence [h : Œ¶.IsLocalizedEquivalence] [CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G] :\n    G.IsEquivalence := (by\n  rw [Œ¶.isEquivalence_iff L‚ÇÅ L‚ÇÇ G W‚ÇÅ.Q W‚ÇÇ.Q (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q)]\n  exact h.isEquivalence)\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.localizedFunctor_isEquivalence","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÅ : Type u‚ÇÑ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\ninst‚úù¬≤ : L‚ÇÅ.IsLocalization W‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù¬π : L‚ÇÇ.IsLocalization W‚ÇÇ\ninst‚úù : Œ¶.IsLocalizedEquivalence\n‚ä¢ (Œ¶.localizedFunctor L‚ÇÅ L‚ÇÇ).IsEquivalence","decl":"/-- If a `LocalizerMorphism` is a localized equivalence, then the induced functor on\nthe localized categories is an equivalence -/\ninstance localizedFunctor_isEquivalence [Œ¶.IsLocalizedEquivalence] :\n    (Œ¶.localizedFunctor L‚ÇÅ L‚ÇÇ).IsEquivalence :=\n  Œ¶.isEquivalence L‚ÇÅ L‚ÇÇ _\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.of_isLocalization_of_isLocalization","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù¬π : L‚ÇÇ.IsLocalization W‚ÇÇ\ninst‚úù : (Œ¶.functor.comp L‚ÇÇ).IsLocalization W‚ÇÅ\n‚ä¢ Œ¶.IsLocalizedEquivalence","decl":"/-- When `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`, if the composition `Œ¶.functor ‚ãô L‚ÇÇ` is a\nlocalization functor for `W‚ÇÅ`, then `Œ¶` is a localized equivalence. -/\nlemma IsLocalizedEquivalence.of_isLocalization_of_isLocalization\n    [(Œ¶.functor ‚ãô L‚ÇÇ).IsLocalization W‚ÇÅ] :\n    IsLocalizedEquivalence Œ¶ := by\n  have : CatCommSq Œ¶.functor (Œ¶.functor ‚ãô L‚ÇÇ) L‚ÇÇ (ùü≠ D‚ÇÇ) :=\n    CatCommSq.mk (Functor.rightUnitor _).symm\n  exact IsLocalizedEquivalence.mk' Œ¶ (Œ¶.functor ‚ãô L‚ÇÇ) L‚ÇÇ (ùü≠ D‚ÇÇ)\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.of_equivalence","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\ninst‚úù : Œ¶.functor.IsEquivalence\nh : LE.le W‚ÇÇ (W‚ÇÅ.map Œ¶.functor)\n‚ä¢ Œ¶.IsLocalizedEquivalence","decl":"/-- When the underlying functor `Œ¶.functor` of `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ` is\nan equivalence of categories and that `W‚ÇÅ` and `W‚ÇÇ` essentially correspond to each\nother via this equivalence, then `Œ¶` is a localized equivalence. -/\nlemma IsLocalizedEquivalence.of_equivalence [Œ¶.functor.IsEquivalence]\n    (h : W‚ÇÇ ‚â§ W‚ÇÅ.map Œ¶.functor) : IsLocalizedEquivalence Œ¶ := by\n  haveI : Functor.IsLocalization (Œ¶.functor ‚ãô MorphismProperty.Q W‚ÇÇ) W‚ÇÅ := by\n    refine Functor.IsLocalization.of_equivalence_source W‚ÇÇ.Q W‚ÇÇ (Œ¶.functor ‚ãô W‚ÇÇ.Q) W‚ÇÅ\n      (Functor.asEquivalence Œ¶.functor).symm ?_ (Œ¶.inverts W‚ÇÇ.Q)\n      ((Functor.associator _ _ _).symm ‚â™‚â´ isoWhiskerRight ((Equivalence.unitIso _).symm) _ ‚â™‚â´\n        Functor.leftUnitor _)\n    erw [W‚ÇÅ.isoClosure.inverseImage_equivalence_functor_eq_map_inverse]\n    rw [MorphismProperty.map_isoClosure]\n    exact h\n  exact IsLocalizedEquivalence.of_isLocalization_of_isLocalization Œ¶ W‚ÇÇ.Q\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.isLocalization","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\nD‚ÇÇ : Type u‚ÇÖ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\nL‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\ninst‚úù¬π : L‚ÇÇ.IsLocalization W‚ÇÇ\ninst‚úù : Œ¶.IsLocalizedEquivalence\n‚ä¢ (Œ¶.functor.comp L‚ÇÇ).IsLocalization W‚ÇÅ","decl":"instance IsLocalizedEquivalence.isLocalization [Œ¶.IsLocalizedEquivalence] :\n    (Œ¶.functor ‚ãô L‚ÇÇ).IsLocalization W‚ÇÅ :=\n  Functor.IsLocalization.of_iso _ ((Œ¶.catCommSq W‚ÇÅ.Q L‚ÇÇ).iso).symm\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.arrow_functor","module":"Mathlib.CategoryTheory.Localization.LocalizerMorphism","initialProofState":"C‚ÇÅ : Type u‚ÇÅ\nC‚ÇÇ : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\n‚ä¢ Eq Œ¶.arrow.functor Œ¶.functor.mapArrow","decl":"/-- The localizer morphism from `W‚ÇÅ.arrow` to `W‚ÇÇ.arrow` that is induced by\n`Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`. -/\n@[simps]\ndef arrow : LocalizerMorphism W‚ÇÅ.arrow W‚ÇÇ.arrow where\n  functor := Œ¶.functor.mapArrow\n  map _ _ _ hf := ‚ü®Œ¶.map _ hf.1, Œ¶.map _ hf.2‚ü©\n\n"}
