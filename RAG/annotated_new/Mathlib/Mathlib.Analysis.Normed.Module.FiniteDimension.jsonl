{"name":"LinearIsometry.coe_toLinearIsometryEquiv","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"F : Type u_1\nEâ‚ : Type u_2\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NormedAddCommGroup Eâ‚\nRâ‚ : Type u_3\ninstâœâ´ : Field Râ‚\ninstâœÂ³ : Module Râ‚ Eâ‚\ninstâœÂ² : Module Râ‚ F\ninstâœÂ¹ : FiniteDimensional Râ‚ Eâ‚\ninstâœ : FiniteDimensional Râ‚ F\nli : LinearIsometry (RingHom.id Râ‚) Eâ‚ F\nh : Eq (Module.finrank Râ‚ Eâ‚) (Module.finrank Râ‚ F)\nâŠ¢ Eq â‡‘(li.toLinearIsometryEquiv h) â‡‘li","decl":"@[simp]\ntheorem coe_toLinearIsometryEquiv (li : Eâ‚ â†’â‚—áµ¢[Râ‚] F) (h : finrank Râ‚ Eâ‚ = finrank Râ‚ F) :\n    (li.toLinearIsometryEquiv h : Eâ‚ â†’ F) = li :=\n  rfl\n\n"}
{"name":"LinearIsometry.toLinearIsometryEquiv_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"F : Type u_1\nEâ‚ : Type u_2\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NormedAddCommGroup Eâ‚\nRâ‚ : Type u_3\ninstâœâ´ : Field Râ‚\ninstâœÂ³ : Module Râ‚ Eâ‚\ninstâœÂ² : Module Râ‚ F\ninstâœÂ¹ : FiniteDimensional Râ‚ Eâ‚\ninstâœ : FiniteDimensional Râ‚ F\nli : LinearIsometry (RingHom.id Râ‚) Eâ‚ F\nh : Eq (Module.finrank Râ‚ Eâ‚) (Module.finrank Râ‚ F)\nx : Eâ‚\nâŠ¢ Eq ((li.toLinearIsometryEquiv h) x) (li x)","decl":"@[simp]\ntheorem toLinearIsometryEquiv_apply (li : Eâ‚ â†’â‚—áµ¢[Râ‚] F) (h : finrank Râ‚ Eâ‚ = finrank Râ‚ F)\n    (x : Eâ‚) : (li.toLinearIsometryEquiv h) x = li x :=\n  rfl\n\n"}
{"name":"AffineIsometry.coe_toAffineIsometryEquiv","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nVâ‚ : Type u_2\nVâ‚‚ : Type u_3\nPâ‚ : Type u_4\nPâ‚‚ : Type u_5\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : NormedAddCommGroup Vâ‚\ninstâœâ¹ : SeminormedAddCommGroup Vâ‚‚\ninstâœâ¸ : NormedSpace ğ•œ Vâ‚\ninstâœâ· : NormedSpace ğ•œ Vâ‚‚\ninstâœâ¶ : MetricSpace Pâ‚\ninstâœâµ : PseudoMetricSpace Pâ‚‚\ninstâœâ´ : NormedAddTorsor Vâ‚ Pâ‚\ninstâœÂ³ : NormedAddTorsor Vâ‚‚ Pâ‚‚\ninstâœÂ² : FiniteDimensional ğ•œ Vâ‚\ninstâœÂ¹ : FiniteDimensional ğ•œ Vâ‚‚\ninstâœ : Inhabited Pâ‚\nli : AffineIsometry ğ•œ Pâ‚ Pâ‚‚\nh : Eq (Module.finrank ğ•œ Vâ‚) (Module.finrank ğ•œ Vâ‚‚)\nâŠ¢ Eq â‡‘(li.toAffineIsometryEquiv h) â‡‘li","decl":"@[simp]\ntheorem coe_toAffineIsometryEquiv [Inhabited Pâ‚] (li : Pâ‚ â†’áµƒâ±[ğ•œ] Pâ‚‚)\n    (h : finrank ğ•œ Vâ‚ = finrank ğ•œ Vâ‚‚) : (li.toAffineIsometryEquiv h : Pâ‚ â†’ Pâ‚‚) = li :=\n  rfl\n\n"}
{"name":"AffineIsometry.toAffineIsometryEquiv_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nVâ‚ : Type u_2\nVâ‚‚ : Type u_3\nPâ‚ : Type u_4\nPâ‚‚ : Type u_5\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : NormedAddCommGroup Vâ‚\ninstâœâ¹ : SeminormedAddCommGroup Vâ‚‚\ninstâœâ¸ : NormedSpace ğ•œ Vâ‚\ninstâœâ· : NormedSpace ğ•œ Vâ‚‚\ninstâœâ¶ : MetricSpace Pâ‚\ninstâœâµ : PseudoMetricSpace Pâ‚‚\ninstâœâ´ : NormedAddTorsor Vâ‚ Pâ‚\ninstâœÂ³ : NormedAddTorsor Vâ‚‚ Pâ‚‚\ninstâœÂ² : FiniteDimensional ğ•œ Vâ‚\ninstâœÂ¹ : FiniteDimensional ğ•œ Vâ‚‚\ninstâœ : Inhabited Pâ‚\nli : AffineIsometry ğ•œ Pâ‚ Pâ‚‚\nh : Eq (Module.finrank ğ•œ Vâ‚) (Module.finrank ğ•œ Vâ‚‚)\nx : Pâ‚\nâŠ¢ Eq ((li.toAffineIsometryEquiv h) x) (li x)","decl":"@[simp]\ntheorem toAffineIsometryEquiv_apply [Inhabited Pâ‚] (li : Pâ‚ â†’áµƒâ±[ğ•œ] Pâ‚‚)\n    (h : finrank ğ•œ Vâ‚ = finrank ğ•œ Vâ‚‚) (x : Pâ‚) : (li.toAffineIsometryEquiv h) x = li x :=\n  rfl\n\n"}
{"name":"AffineMap.continuous_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : CompleteSpace ğ•œ\nPE : Type u_1\nPF : Type u_2\ninstâœâ´ : MetricSpace PE\ninstâœÂ³ : NormedAddTorsor E PE\ninstâœÂ² : MetricSpace PF\ninstâœÂ¹ : NormedAddTorsor F PF\ninstâœ : FiniteDimensional ğ•œ E\nf : AffineMap ğ•œ PE PF\nâŠ¢ Continuous â‡‘f","decl":"theorem AffineMap.continuous_of_finiteDimensional (f : PE â†’áµƒ[ğ•œ] PF) : Continuous f :=\n  AffineMap.continuous_linear_iff.1 f.linear.continuous_of_finiteDimensional\n\n"}
{"name":"AffineEquiv.continuous_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : CompleteSpace ğ•œ\nPE : Type u_1\nPF : Type u_2\ninstâœâ´ : MetricSpace PE\ninstâœÂ³ : NormedAddTorsor E PE\ninstâœÂ² : MetricSpace PF\ninstâœÂ¹ : NormedAddTorsor F PF\ninstâœ : FiniteDimensional ğ•œ E\nf : AffineEquiv ğ•œ PE PF\nâŠ¢ Continuous â‡‘f","decl":"theorem AffineEquiv.continuous_of_finiteDimensional (f : PE â‰ƒáµƒ[ğ•œ] PF) : Continuous f :=\n  f.toAffineMap.continuous_of_finiteDimensional\n\n"}
{"name":"AffineEquiv.coe_toHomeomorphOfFiniteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : CompleteSpace ğ•œ\nPE : Type u_1\nPF : Type u_2\ninstâœâ´ : MetricSpace PE\ninstâœÂ³ : NormedAddTorsor E PE\ninstâœÂ² : MetricSpace PF\ninstâœÂ¹ : NormedAddTorsor F PF\ninstâœ : FiniteDimensional ğ•œ E\nf : AffineEquiv ğ•œ PE PF\nâŠ¢ Eq â‡‘f.toHomeomorphOfFiniteDimensional â‡‘f","decl":"@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional (f : PE â‰ƒáµƒ[ğ•œ] PF) :\n    â‡‘f.toHomeomorphOfFiniteDimensional = f :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : CompleteSpace ğ•œ\nPE : Type u_1\nPF : Type u_2\ninstâœâ´ : MetricSpace PE\ninstâœÂ³ : NormedAddTorsor E PE\ninstâœÂ² : MetricSpace PF\ninstâœÂ¹ : NormedAddTorsor F PF\ninstâœ : FiniteDimensional ğ•œ E\nf : AffineEquiv ğ•œ PE PF\nâŠ¢ Eq â‡‘f.toHomeomorphOfFiniteDimensional.symm â‡‘f.symm","decl":"@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm (f : PE â‰ƒáµƒ[ğ•œ] PF) :\n    â‡‘f.toHomeomorphOfFiniteDimensional.symm = f.symm :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.continuous_det","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nâŠ¢ Continuous fun f => f.det","decl":"theorem ContinuousLinearMap.continuous_det : Continuous fun f : E â†’L[ğ•œ] E => f.det := by\n  change Continuous fun f : E â†’L[ğ•œ] E => LinearMap.det (f : E â†’â‚—[ğ•œ] E)\n  -- Porting note: this could be easier with `det_cases`\n  by_cases h : âˆƒ s : Finset E, Nonempty (Basis (â†¥s) ğ•œ E)\n  Â· rcases h with âŸ¨s, âŸ¨bâŸ©âŸ©\n    haveI : FiniteDimensional ğ•œ E := FiniteDimensional.of_fintype_basis b\n    classical\n    simp_rw [LinearMap.det_eq_det_toMatrix_of_finset b]\n    refine Continuous.matrix_det ?_\n    exact\n      ((LinearMap.toMatrix b b).toLinearMap.comp\n          (ContinuousLinearMap.coeLM ğ•œ)).continuous_of_finiteDimensional\n  Â· -- Porting note: was `unfold LinearMap.det`\n    rw [LinearMap.det_def]\n    simpa only [h, MonoidHom.one_apply, dif_neg, not_false_iff] using continuous_const\n\n"}
{"name":"lipschitzExtensionConstant_def","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E' : Type u_1\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace Real E'\ninstâœ : FiniteDimensional Real E'\nâŠ¢ Eq (lipschitzExtensionConstant E')\n    (let A := (Basis.ofVectorSpace Real E').equivFun.toContinuousLinearEquiv;\n    Max.max (HMul.hMul (NNNorm.nnnorm â†‘A.symm) (NNNorm.nnnorm â†‘A)) 1)","decl":"/-- Any `K`-Lipschitz map from a subset `s` of a metric space `Î±` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `Î±`, with a slightly worse\nconstant `C * K` where `C` only depends on `E'`. We record a working value for this constant `C`\nas `lipschitzExtensionConstant E'`. -/\nirreducible_def lipschitzExtensionConstant (E' : Type*) [NormedAddCommGroup E'] [NormedSpace â„ E']\n  [FiniteDimensional â„ E'] : â„â‰¥0 :=\n  let A := (Basis.ofVectorSpace â„ E').equivFun.toContinuousLinearEquiv\n  max (â€–A.symm.toContinuousLinearMapâ€–â‚Š * â€–A.toContinuousLinearMapâ€–â‚Š) 1\n\n"}
{"name":"lipschitzExtensionConstant_pos","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E' : Type u_1\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace Real E'\ninstâœ : FiniteDimensional Real E'\nâŠ¢ LT.lt 0 (lipschitzExtensionConstant E')","decl":"theorem lipschitzExtensionConstant_pos (E' : Type*) [NormedAddCommGroup E'] [NormedSpace â„ E']\n    [FiniteDimensional â„ E'] : 0 < lipschitzExtensionConstant E' := by\n  rw [lipschitzExtensionConstant]\n  exact zero_lt_one.trans_le (le_max_right _ _)\n\n"}
{"name":"LipschitzOnWith.extend_finite_dimension","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nE' : Type u_2\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace Real E'\ninstâœ : FiniteDimensional Real E'\ns : Set Î±\nf : Î± â†’ E'\nK : NNReal\nhf : LipschitzOnWith K f s\nâŠ¢ Exists fun g => And (LipschitzWith (HMul.hMul (lipschitzExtensionConstant E') K) g) (Set.EqOn f g s)","decl":"/-- Any `K`-Lipschitz map from a subset `s` of a metric space `Î±` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `Î±`, with a slightly worse\nconstant `lipschitzExtensionConstant E' * K`. -/\ntheorem LipschitzOnWith.extend_finite_dimension {Î± : Type*} [PseudoMetricSpace Î±] {E' : Type*}\n    [NormedAddCommGroup E'] [NormedSpace â„ E'] [FiniteDimensional â„ E'] {s : Set Î±} {f : Î± â†’ E'}\n    {K : â„â‰¥0} (hf : LipschitzOnWith K f s) :\n    âˆƒ g : Î± â†’ E', LipschitzWith (lipschitzExtensionConstant E' * K) g âˆ§ EqOn f g s := by\n  /- This result is already known for spaces `Î¹ â†’ â„`. We use a continuous linear equiv between\n    `E'` and such a space to transfer the result to `E'`. -/\n  let Î¹ : Type _ := Basis.ofVectorSpaceIndex â„ E'\n  let A := (Basis.ofVectorSpace â„ E').equivFun.toContinuousLinearEquiv\n  have LA : LipschitzWith â€–A.toContinuousLinearMapâ€–â‚Š A := by apply A.lipschitz\n  have L : LipschitzOnWith (â€–A.toContinuousLinearMapâ€–â‚Š * K) (A âˆ˜ f) s :=\n    LA.comp_lipschitzOnWith hf\n  obtain âŸ¨g, hg, gsâŸ© :\n    âˆƒ g : Î± â†’ Î¹ â†’ â„, LipschitzWith (â€–A.toContinuousLinearMapâ€–â‚Š * K) g âˆ§ EqOn (A âˆ˜ f) g s :=\n    L.extend_pi\n  refine âŸ¨A.symm âˆ˜ g, ?_, ?_âŸ©\n  Â· have LAsymm : LipschitzWith â€–A.symm.toContinuousLinearMapâ€–â‚Š A.symm := by\n      apply A.symm.lipschitz\n    apply (LAsymm.comp hg).weaken\n    rw [lipschitzExtensionConstant, â† mul_assoc]\n    exact mul_le_mul' (le_max_left _ _) le_rfl\n  Â· intro x hx\n    have : A (f x) = g x := gs hx\n    simp only [(Â· âˆ˜ Â·), â† this, A.symm_apply_apply]\n\n"}
{"name":"LinearMap.exists_antilipschitzWith","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nhf : Eq (LinearMap.ker f) Bot.bot\nâŠ¢ Exists fun K => And (GT.gt K 0) (AntilipschitzWith K â‡‘f)","decl":"theorem LinearMap.exists_antilipschitzWith [FiniteDimensional ğ•œ E] (f : E â†’â‚—[ğ•œ] F)\n    (hf : LinearMap.ker f = âŠ¥) : âˆƒ K > 0, AntilipschitzWith K f := by\n  cases subsingleton_or_nontrivial E\n  Â· exact âŸ¨1, zero_lt_one, AntilipschitzWith.of_subsingletonâŸ©\n  Â· rw [LinearMap.ker_eq_bot] at hf\n    let e : E â‰ƒL[ğ•œ] LinearMap.range f := (LinearEquiv.ofInjective f hf).toContinuousLinearEquiv\n    exact âŸ¨_, e.nnnorm_symm_pos, e.antilipschitzâŸ©\n\n"}
{"name":"LinearMap.injective_iff_antilipschitz","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Iff (Function.Injective â‡‘f) (Exists fun K => And (GT.gt K 0) (AntilipschitzWith K â‡‘f))","decl":"open Function in\n/-- A `LinearMap` on a finite-dimensional space over a complete field\n  is injective iff it is anti-Lipschitz. -/\ntheorem LinearMap.injective_iff_antilipschitz [FiniteDimensional ğ•œ E] (f : E â†’â‚—[ğ•œ] F) :\n    Injective f â†” âˆƒ K > 0, AntilipschitzWith K f := by\n  constructor\n  Â· rw [â† LinearMap.ker_eq_bot]\n    exact f.exists_antilipschitzWith\n  Â· rintro âŸ¨K, -, HâŸ©\n    exact H.injective\n\n"}
{"name":"ContinuousLinearMap.isOpen_injective","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ IsOpen (setOf fun L => Function.Injective â‡‘L)","decl":"open Function in\n/-- The set of injective continuous linear maps `E â†’ F` is open,\n  if `E` is finite-dimensional over a complete field. -/\ntheorem ContinuousLinearMap.isOpen_injective [FiniteDimensional ğ•œ E] :\n    IsOpen { L : E â†’L[ğ•œ] F | Injective L } := by\n  rw [isOpen_iff_eventually]\n  rintro Ï†â‚€ hÏ†â‚€\n  rcases Ï†â‚€.injective_iff_antilipschitz.mp hÏ†â‚€ with âŸ¨K, K_pos, HâŸ©\n  have : âˆ€á¶  Ï† in ğ“ Ï†â‚€, â€–Ï† - Ï†â‚€â€–â‚Š < Kâ»Â¹ := eventually_nnnorm_sub_lt _ <| inv_pos_of_pos K_pos\n  filter_upwards [this] with Ï† hÏ†\n  apply Ï†.injective_iff_antilipschitz.mpr\n  exact âŸ¨(Kâ»Â¹ - â€–Ï† - Ï†â‚€â€–â‚Š)â»Â¹, inv_pos_of_pos (tsub_pos_of_lt hÏ†),\n    H.add_sub_lipschitzWith (Ï† - Ï†â‚€).lipschitz hÏ†âŸ©\n\n"}
{"name":"LinearIndependent.eventually","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Finite Î¹\nf : Î¹ â†’ E\nhf : LinearIndependent ğ•œ f\nâŠ¢ Filter.Eventually (fun g => LinearIndependent ğ•œ g) (nhds f)","decl":"protected theorem LinearIndependent.eventually {Î¹} [Finite Î¹] {f : Î¹ â†’ E}\n    (hf : LinearIndependent ğ•œ f) : âˆ€á¶  g in ğ“ f, LinearIndependent ğ•œ g := by\n  cases nonempty_fintype Î¹\n  classical\n  simp only [Fintype.linearIndependent_iff'] at hf âŠ¢\n  rcases LinearMap.exists_antilipschitzWith _ hf with âŸ¨K, K0, hKâŸ©\n  have : Tendsto (fun g : Î¹ â†’ E => âˆ‘ i, â€–g i - f iâ€–) (ğ“ f) (ğ“ <| âˆ‘ i, â€–f i - f iâ€–) :=\n    tendsto_finset_sum _ fun i _ =>\n      Tendsto.norm <| ((continuous_apply i).tendsto _).sub tendsto_const_nhds\n  simp only [sub_self, norm_zero, Finset.sum_const_zero] at this\n  refine (this.eventually (gt_mem_nhds <| inv_pos.2 K0)).mono fun g hg => ?_\n  replace hg : âˆ‘ i, â€–g i - f iâ€–â‚Š < Kâ»Â¹ := by\n    rw [â† NNReal.coe_lt_coe]\n    push_cast\n    exact hg\n  rw [LinearMap.ker_eq_bot]\n  refine (hK.add_sub_lipschitzWith (LipschitzWith.of_dist_le_mul fun v u => ?_) hg).injective\n  simp only [dist_eq_norm, LinearMap.lsum_apply, Pi.sub_apply, LinearMap.sum_apply,\n    LinearMap.comp_apply, LinearMap.proj_apply, LinearMap.smulRight_apply, LinearMap.id_apply, â†\n    Finset.sum_sub_distrib, â† smul_sub, â† sub_smul, NNReal.coe_sum, coe_nnnorm, Finset.sum_mul]\n  refine norm_sum_le_of_le _ fun i _ => ?_\n  rw [norm_smul, mul_comm]\n  gcongr\n  exact norm_le_pi_norm (v - u) i\n\n"}
{"name":"isOpen_setOf_linearIndependent","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Finite Î¹\nâŠ¢ IsOpen (setOf fun f => LinearIndependent ğ•œ f)","decl":"theorem isOpen_setOf_linearIndependent {Î¹ : Type*} [Finite Î¹] :\n    IsOpen { f : Î¹ â†’ E | LinearIndependent ğ•œ f } :=\n  isOpen_iff_mem_nhds.2 fun _ => LinearIndependent.eventually\n\n"}
{"name":"isOpen_setOf_nat_le_rank","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace ğ•œ\nn : Nat\nâŠ¢ IsOpen (setOf fun f => LE.le (â†‘n) (â†‘f).rank)","decl":"theorem isOpen_setOf_nat_le_rank (n : â„•) :\n    IsOpen { f : E â†’L[ğ•œ] F | â†‘n â‰¤ (f : E â†’â‚—[ğ•œ] F).rank } := by\n  simp only [LinearMap.le_rank_iff_exists_linearIndependent_finset, setOf_exists, â† exists_prop]\n  refine isOpen_biUnion fun t _ => ?_\n  have : Continuous fun f : E â†’L[ğ•œ] F => fun x : (t : Set E) => f x :=\n    continuous_pi fun x => (ContinuousLinearMap.apply ğ•œ F (x : E)).continuous\n  exact isOpen_setOf_linearIndependent.preimage this\n\n"}
{"name":"Basis.opNNNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nu : ContinuousLinearMap (RingHom.id ğ•œ) E F\nM : NNReal\nhu : âˆ€ (i : Î¹), LE.le (NNNorm.nnnorm (u (v i))) M\nâŠ¢ LE.le (NNNorm.nnnorm u) (HMul.hMul (HSMul.hSMul (Fintype.card Î¹) (NNNorm.nnnorm â†‘v.equivFunL)) M)","decl":"theorem Basis.opNNNorm_le {Î¹ : Type*} [Fintype Î¹] (v : Basis Î¹ ğ•œ E) {u : E â†’L[ğ•œ] F} (M : â„â‰¥0)\n    (hu : âˆ€ i, â€–u (v i)â€–â‚Š â‰¤ M) : â€–uâ€–â‚Š â‰¤ Fintype.card Î¹ â€¢ â€–v.equivFunL.toContinuousLinearMapâ€–â‚Š * M :=\n  u.opNNNorm_le_bound _ fun e => by\n    set Ï† := v.equivFunL.toContinuousLinearMap\n    calc\n      â€–u eâ€–â‚Š = â€–u (âˆ‘ i, v.equivFun e i â€¢ v i)â€–â‚Š := by rw [v.sum_equivFun]\n      _ = â€–âˆ‘ i, v.equivFun e i â€¢ (u <| v i)â€–â‚Š := by simp [map_sum, LinearMap.map_smul]\n      _ â‰¤ âˆ‘ i, â€–v.equivFun e i â€¢ (u <| v i)â€–â‚Š := nnnorm_sum_le _ _\n      _ = âˆ‘ i, â€–v.equivFun e iâ€–â‚Š * â€–u (v i)â€–â‚Š := by simp only [nnnorm_smul]\n      _ â‰¤ âˆ‘ i, â€–v.equivFun e iâ€–â‚Š * M := by gcongr; apply hu\n      _ = (âˆ‘ i, â€–v.equivFun e iâ€–â‚Š) * M := by rw [Finset.sum_mul]\n      _ â‰¤ Fintype.card Î¹ â€¢ (â€–Ï†â€–â‚Š * â€–eâ€–â‚Š) * M := by\n        gcongr\n        calc\n          âˆ‘ i, â€–v.equivFun e iâ€–â‚Š â‰¤ Fintype.card Î¹ â€¢ â€–Ï† eâ€–â‚Š := Pi.sum_nnnorm_apply_le_nnnorm _\n          _ â‰¤ Fintype.card Î¹ â€¢ (â€–Ï†â€–â‚Š * â€–eâ€–â‚Š) := nsmul_le_nsmul_right (Ï†.le_opNNNorm e) _\n      _ = Fintype.card Î¹ â€¢ â€–Ï†â€–â‚Š * M * â€–eâ€–â‚Š := by simp only [smul_mul_assoc, mul_right_comm]\n\n"}
{"name":"Basis.opNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nu : ContinuousLinearMap (RingHom.id ğ•œ) E F\nM : Real\nhM : LE.le 0 M\nhu : âˆ€ (i : Î¹), LE.le (Norm.norm (u (v i))) M\nâŠ¢ LE.le (Norm.norm u) (HMul.hMul (HSMul.hSMul (Fintype.card Î¹) (Norm.norm â†‘v.equivFunL)) M)","decl":"theorem Basis.opNorm_le {Î¹ : Type*} [Fintype Î¹] (v : Basis Î¹ ğ•œ E) {u : E â†’L[ğ•œ] F} {M : â„}\n    (hM : 0 â‰¤ M) (hu : âˆ€ i, â€–u (v i)â€– â‰¤ M) :\n    â€–uâ€– â‰¤ Fintype.card Î¹ â€¢ â€–v.equivFunL.toContinuousLinearMapâ€– * M := by\n  simpa using NNReal.coe_le_coe.mpr (v.opNNNorm_le âŸ¨M, hMâŸ© hu)\n\n"}
{"name":"Basis.exists_opNNNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Finite Î¹\nv : Basis Î¹ ğ•œ E\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ {u : ContinuousLinearMap (RingHom.id ğ•œ) E F} (M : NNReal), (âˆ€ (i : Î¹), LE.le (NNNorm.nnnorm (u (v i))) M) â†’ LE.le (NNNorm.nnnorm u) (HMul.hMul C M))","decl":"/-- A weaker version of `Basis.opNNNorm_le` that abstracts away the value of `C`. -/\ntheorem Basis.exists_opNNNorm_le {Î¹ : Type*} [Finite Î¹] (v : Basis Î¹ ğ•œ E) :\n    âˆƒ C > (0 : â„â‰¥0), âˆ€ {u : E â†’L[ğ•œ] F} (M : â„â‰¥0), (âˆ€ i, â€–u (v i)â€–â‚Š â‰¤ M) â†’ â€–uâ€–â‚Š â‰¤ C * M := by\n  cases nonempty_fintype Î¹\n  exact\n    âŸ¨max (Fintype.card Î¹ â€¢ â€–v.equivFunL.toContinuousLinearMapâ€–â‚Š) 1,\n      zero_lt_one.trans_le (le_max_right _ _), fun {u} M hu =>\n      (v.opNNNorm_le M hu).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (zero_le M)âŸ©\n\n"}
{"name":"Basis.exists_opNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœ : Finite Î¹\nv : Basis Î¹ ğ•œ E\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ {u : ContinuousLinearMap (RingHom.id ğ•œ) E F} {M : Real}, LE.le 0 M â†’ (âˆ€ (i : Î¹), LE.le (Norm.norm (u (v i))) M) â†’ LE.le (Norm.norm u) (HMul.hMul C M))","decl":"/-- A weaker version of `Basis.opNorm_le` that abstracts away the value of `C`. -/\ntheorem Basis.exists_opNorm_le {Î¹ : Type*} [Finite Î¹] (v : Basis Î¹ ğ•œ E) :\n    âˆƒ C > (0 : â„), âˆ€ {u : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ i, â€–u (v i)â€– â‰¤ M) â†’ â€–uâ€– â‰¤ C * M := by\n  obtain âŸ¨C, hC, hâŸ© := v.exists_opNNNorm_le (F := F)\n  -- Porting note: used `Subtype.forall'` below\n  refine âŸ¨C, hC, ?_âŸ©\n  intro u M hM H\n  simpa using h âŸ¨M, hMâŸ© H\n\n"}
{"name":"instSecondCountableTopologyContinuousLinearMapIdOfFiniteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type w\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : SecondCountableTopology F\nâŠ¢ SecondCountableTopology (ContinuousLinearMap (RingHom.id ğ•œ) E F)","decl":"instance [FiniteDimensional ğ•œ E] [SecondCountableTopology F] :\n    SecondCountableTopology (E â†’L[ğ•œ] F) := by\n  set d := Module.finrank ğ•œ E\n  suffices\n    âˆ€ Îµ > (0 : â„), âˆƒ n : (E â†’L[ğ•œ] F) â†’ Fin d â†’ â„•, âˆ€ f g : E â†’L[ğ•œ] F, n f = n g â†’ dist f g â‰¤ Îµ from\n    Metric.secondCountable_of_countable_discretization fun Îµ Îµ_pos =>\n      âŸ¨Fin d â†’ â„•, by infer_instance, this Îµ Îµ_posâŸ©\n  intro Îµ Îµ_pos\n  obtain âŸ¨u : â„• â†’ F, hu : DenseRange uâŸ© := exists_dense_seq F\n  let v := Module.finBasis ğ•œ E\n  obtain\n    âŸ¨C : â„, C_pos : 0 < C, hC :\n      âˆ€ {Ï† : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ i, â€–Ï† (v i)â€– â‰¤ M) â†’ â€–Ï†â€– â‰¤ C * MâŸ© :=\n    v.exists_opNorm_le (E := E) (F := F)\n  have h_2C : 0 < 2 * C := mul_pos zero_lt_two C_pos\n  have hÎµ2C : 0 < Îµ / (2 * C) := div_pos Îµ_pos h_2C\n  have : âˆ€ Ï† : E â†’L[ğ•œ] F, âˆƒ n : Fin d â†’ â„•, â€–Ï† - (v.constrL <| u âˆ˜ n)â€– â‰¤ Îµ / 2 := by\n    intro Ï†\n    have : âˆ€ i, âˆƒ n, â€–Ï† (v i) - u nâ€– â‰¤ Îµ / (2 * C) := by\n      simp only [norm_sub_rev]\n      intro i\n      have : Ï† (v i) âˆˆ closure (range u) := hu _\n      obtain âŸ¨n, hnâŸ© : âˆƒ n, â€–u n - Ï† (v i)â€– < Îµ / (2 * C) := by\n        rw [mem_closure_iff_nhds_basis Metric.nhds_basis_ball] at this\n        specialize this (Îµ / (2 * C)) hÎµ2C\n        simpa [dist_eq_norm]\n      exact âŸ¨n, le_of_lt hnâŸ©\n    choose n hn using this\n    use n\n    replace hn : âˆ€ i : Fin d, â€–(Ï† - (v.constrL <| u âˆ˜ n)) (v i)â€– â‰¤ Îµ / (2 * C) := by simp [hn]\n    have : C * (Îµ / (2 * C)) = Îµ / 2 := by\n      rw [eq_div_iff (two_ne_zero : (2 : â„) â‰  0), mul_comm, â† mul_assoc,\n        mul_div_cancelâ‚€ _ (ne_of_gt h_2C)]\n    specialize hC (le_of_lt hÎµ2C) hn\n    rwa [this] at hC\n  choose n hn using this\n  set Î¦ := fun Ï† : E â†’L[ğ•œ] F => v.constrL <| u âˆ˜ n Ï†\n  change âˆ€ z, dist z (Î¦ z) â‰¤ Îµ / 2 at hn\n  use n\n  intro x y hxy\n  calc\n    dist x y â‰¤ dist x (Î¦ x) + dist (Î¦ x) y := dist_triangle _ _ _\n    _ = dist x (Î¦ x) + dist y (Î¦ y) := by simp [Î¦, hxy, dist_comm]\n    _ â‰¤ Îµ := by linarith [hn x, hn y]\n\n"}
{"name":"AffineSubspace.closed_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace ğ•œ\nP : Type u_1\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ns : AffineSubspace ğ•œ P\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem s.direction x)\nâŠ¢ IsClosed â†‘s","decl":"theorem AffineSubspace.closed_of_finiteDimensional {P : Type*} [MetricSpace P]\n    [NormedAddTorsor E P] (s : AffineSubspace ğ•œ P) [FiniteDimensional ğ•œ s.direction] :\n    IsClosed (s : Set P) :=\n  s.isClosed_direction_iff.mp s.direction.closed_of_finiteDimensional\n\n"}
{"name":"exists_norm_le_le_norm_sub_of_finset","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nR : Real\nhR : LT.lt (Norm.norm c) R\nh : Not (FiniteDimensional ğ•œ E)\ns : Finset E\nâŠ¢ Exists fun x => And (LE.le (Norm.norm x) R) (âˆ€ (y : E), Membership.mem s y â†’ LE.le 1 (Norm.norm (HSub.hSub y x)))","decl":"/-- In an infinite dimensional space, given a finite number of points, one may find a point\nwith norm at most `R` which is at distance at least `1` of all these points. -/\ntheorem exists_norm_le_le_norm_sub_of_finset {c : ğ•œ} (hc : 1 < â€–câ€–) {R : â„} (hR : â€–câ€– < R)\n    (h : Â¬FiniteDimensional ğ•œ E) (s : Finset E) : âˆƒ x : E, â€–xâ€– â‰¤ R âˆ§ âˆ€ y âˆˆ s, 1 â‰¤ â€–y - xâ€– := by\n  let F := Submodule.span ğ•œ (s : Set E)\n  haveI : FiniteDimensional ğ•œ F :=\n    Module.finite_def.2\n      ((Submodule.fg_top _).2 (Submodule.fg_def.2 âŸ¨s, Finset.finite_toSet _, rflâŸ©))\n  have Fclosed : IsClosed (F : Set E) := Submodule.closed_of_finiteDimensional _\n  have : âˆƒ x, x âˆ‰ F := by\n    contrapose! h\n    have : (âŠ¤ : Submodule ğ•œ E) = F := by\n      ext x\n      simp [h]\n    have : FiniteDimensional ğ•œ (âŠ¤ : Submodule ğ•œ E) := by rwa [this]\n    exact Module.finite_def.2 ((Submodule.fg_top _).1 (Module.finite_def.1 this))\n  obtain âŸ¨x, xR, hxâŸ© : âˆƒ x : E, â€–xâ€– â‰¤ R âˆ§ âˆ€ y : E, y âˆˆ F â†’ 1 â‰¤ â€–x - yâ€– :=\n    riesz_lemma_of_norm_lt hc hR Fclosed this\n  have hx' : âˆ€ y : E, y âˆˆ F â†’ 1 â‰¤ â€–y - xâ€– := by\n    intro y hy\n    rw [â† norm_neg]\n    simpa using hx y hy\n  exact âŸ¨x, xR, fun y hy => hx' _ (Submodule.subset_span hy)âŸ©\n\n"}
{"name":"exists_seq_norm_le_one_le_norm_sub'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nR : Real\nhR : LT.lt (Norm.norm c) R\nh : Not (FiniteDimensional ğ•œ E)\nâŠ¢ Exists fun f => And (âˆ€ (n : Nat), LE.le (Norm.norm (f n)) R) (Pairwise fun m n => LE.le 1 (Norm.norm (HSub.hSub (f m) (f n))))","decl":"/-- In an infinite-dimensional normed space, there exists a sequence of points which are all\nbounded by `R` and at distance at least `1`. For a version not assuming `c` and `R`, see\n`exists_seq_norm_le_one_le_norm_sub`. -/\ntheorem exists_seq_norm_le_one_le_norm_sub' {c : ğ•œ} (hc : 1 < â€–câ€–) {R : â„} (hR : â€–câ€– < R)\n    (h : Â¬FiniteDimensional ğ•œ E) :\n    âˆƒ f : â„• â†’ E, (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ Pairwise fun m n => 1 â‰¤ â€–f m - f nâ€– := by\n  have : IsSymm E fun x y : E => 1 â‰¤ â€–x - yâ€– := by\n    constructor\n    intro x y hxy\n    rw [â† norm_neg]\n    simpa\n  apply\n    exists_seq_of_forall_finset_exists' (fun x : E => â€–xâ€– â‰¤ R) fun (x : E) (y : E) => 1 â‰¤ â€–x - yâ€–\n  rintro s -\n  exact exists_norm_le_le_norm_sub_of_finset hc hR h s\n\n"}
{"name":"exists_seq_norm_le_one_le_norm_sub","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nh : Not (FiniteDimensional ğ•œ E)\nâŠ¢ Exists fun R => Exists fun f => And (LT.lt 1 R) (And (âˆ€ (n : Nat), LE.le (Norm.norm (f n)) R) (Pairwise fun m n => LE.le 1 (Norm.norm (HSub.hSub (f m) (f n)))))","decl":"theorem exists_seq_norm_le_one_le_norm_sub (h : Â¬FiniteDimensional ğ•œ E) :\n    âˆƒ (R : â„) (f : â„• â†’ E), 1 < R âˆ§ (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ Pairwise fun m n => 1 â‰¤ â€–f m - f nâ€– := by\n  obtain âŸ¨c, hcâŸ© : âˆƒ c : ğ•œ, 1 < â€–câ€– := NormedField.exists_one_lt_norm ğ•œ\n  have A : â€–câ€– < â€–câ€– + 1 := by linarith\n  rcases exists_seq_norm_le_one_le_norm_sub' hc A h with âŸ¨f, hfâŸ©\n  exact âŸ¨â€–câ€– + 1, f, hc.trans A, hf.1, hf.2âŸ©\n\n"}
{"name":"FiniteDimensional.of_isCompact_closedBallâ‚€","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nr : Real\nrpos : LT.lt 0 r\nh : IsCompact (Metric.closedBall 0 r)\nâŠ¢ FiniteDimensional ğ•œ E","decl":"/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. -/\ntheorem FiniteDimensional.of_isCompact_closedBallâ‚€ {r : â„} (rpos : 0 < r)\n    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional ğ•œ E := by\n  by_contra hfin\n  obtain âŸ¨R, f, Rgt, fle, lefâŸ© :\n    âˆƒ (R : â„) (f : â„• â†’ E), 1 < R âˆ§ (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ Pairwise fun m n => 1 â‰¤ â€–f m - f nâ€– :=\n    exists_seq_norm_le_one_le_norm_sub hfin\n  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)\n  obtain âŸ¨c, hcâŸ© : âˆƒ c : ğ•œ, 0 < â€–câ€– âˆ§ â€–câ€– < r / R := NormedField.exists_norm_lt _ rRpos\n  let g := fun n : â„• => c â€¢ f n\n  have A : âˆ€ n, g n âˆˆ Metric.closedBall (0 : E) r := by\n    intro n\n    simp only [g, norm_smul, dist_zero_right, Metric.mem_closedBall]\n    calc\n      â€–câ€– * â€–f nâ€– â‰¤ r / R * R := by\n        gcongr\n        Â· exact hc.2.le\n        Â· apply fle\n      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']\n  -- Porting note: moved type ascriptions because of exists_prop changes\n  obtain âŸ¨x : E, _ : x âˆˆ Metric.closedBall (0 : E) r, Ï† : â„• â†’ â„•, Ï†mono : StrictMono Ï†,\n    Ï†lim : Tendsto (g âˆ˜ Ï†) atTop (ğ“ x)âŸ© := h.tendsto_subseq A\n  have B : CauchySeq (g âˆ˜ Ï†) := Ï†lim.cauchySeq\n  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ n : â„•, N â‰¤ n â†’ dist ((g âˆ˜ Ï†) n) ((g âˆ˜ Ï†) N) < â€–câ€– :=\n    Metric.cauchySeq_iff'.1 B â€–câ€– hc.1\n  apply lt_irrefl â€–câ€–\n  calc\n    â€–câ€– â‰¤ dist (g (Ï† (N + 1))) (g (Ï† N)) := by\n      conv_lhs => rw [â† mul_one â€–câ€–]\n      simp only [g, dist_eq_norm, â† smul_sub, norm_smul]\n      gcongr\n      apply lef (ne_of_gt _)\n      exact Ï†mono (Nat.lt_succ_self N)\n    _ < â€–câ€– := hN (N + 1) (Nat.le_succ N)\n\n"}
{"name":"FiniteDimensional.of_isCompact_closedBall","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace ğ•œ\nr : Real\nrpos : LT.lt 0 r\nc : E\nh : IsCompact (Metric.closedBall c r)\nâŠ¢ FiniteDimensional ğ•œ E","decl":"/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\nspace is finite-dimensional. -/\ntheorem FiniteDimensional.of_isCompact_closedBall {r : â„} (rpos : 0 < r) {c : E}\n    (h : IsCompact (Metric.closedBall c r)) : FiniteDimensional ğ•œ E :=\n  .of_isCompact_closedBallâ‚€ ğ•œ rpos <| by simpa using h.vadd (-c)\n\n"}
{"name":"FiniteDimensional.of_locallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : LocallyCompactSpace E\nâŠ¢ FiniteDimensional ğ•œ E","decl":"/-- **Riesz's theorem**: a locally compact normed vector space is finite-dimensional. -/\ntheorem FiniteDimensional.of_locallyCompactSpace [LocallyCompactSpace E] :\n    FiniteDimensional ğ•œ E :=\n  let âŸ¨_r, rpos, hrâŸ© := exists_isCompact_closedBall (0 : E)\n  .of_isCompact_closedBallâ‚€ ğ•œ rpos hr\n\n"}
{"name":"HasCompactSupport.eq_zero_or_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace ğ•œ\nX : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Zero X\ninstâœ : T1Space X\nf : E â†’ X\nhf : HasCompactSupport f\nh'f : Continuous f\nâŠ¢ Or (Eq f 0) (FiniteDimensional ğ•œ E)","decl":"/-- If a function has compact support, then either the function is trivial\nor the space is finite-dimensional. -/\ntheorem HasCompactSupport.eq_zero_or_finiteDimensional {X : Type*} [TopologicalSpace X] [Zero X]\n    [T1Space X] {f : E â†’ X} (hf : HasCompactSupport f) (h'f : Continuous f) :\n    f = 0 âˆ¨ FiniteDimensional ğ•œ E :=\n  (HasCompactSupport.eq_zero_or_locallyCompactSpace_of_addGroup hf h'f).imp_right fun h â†¦\n    -- TODO: Lean doesn't find the instance without this `have`\n    have : LocallyCompactSpace E := h; .of_locallyCompactSpace ğ•œ\n\n"}
{"name":"HasCompactMulSupport.eq_one_or_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace ğ•œ\nX : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : One X\ninstâœ : T1Space X\nf : E â†’ X\nhf : HasCompactMulSupport f\nh'f : Continuous f\nâŠ¢ Or (Eq f 1) (FiniteDimensional ğ•œ E)","decl":"/-- If a function has compact multiplicative support, then either the function is trivial\nor the space is finite-dimensional. -/\n@[to_additive existing]\ntheorem HasCompactMulSupport.eq_one_or_finiteDimensional {X : Type*} [TopologicalSpace X] [One X]\n    [T1Space X] {f : E â†’ X} (hf : HasCompactMulSupport f) (h'f : Continuous f) :\n    f = 1 âˆ¨ FiniteDimensional ğ•œ E :=\n  have : T1Space (Additive X) := â€¹_â€º\n  HasCompactSupport.eq_zero_or_finiteDimensional (X := Additive X) ğ•œ hf h'f\n\n"}
{"name":"ProperSpace.of_locallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : LocallyCompactSpace E\nâŠ¢ ProperSpace E","decl":"/-- A locally compact normed vector space is proper. -/\nlemma ProperSpace.of_locallyCompactSpace (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]\n    {E : Type*} [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] [LocallyCompactSpace E] :\n    ProperSpace E := by\n  rcases exists_isCompact_closedBall (0 : E) with âŸ¨r, rpos, hrâŸ©\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  have hC : âˆ€ n, IsCompact (closedBall (0 : E) (â€–câ€–^n * r)) := fun n â†¦ by\n    have : c ^ n â‰  0 := pow_ne_zero _ <| fun h â†¦ by simp [h, zero_le_one.not_lt] at hc\n    simpa [_root_.smul_closedBall' this] using hr.smul (c ^ n)\n  have hTop : Tendsto (fun n â†¦ â€–câ€–^n * r) atTop atTop :=\n    Tendsto.atTop_mul_const rpos (tendsto_pow_atTop_atTop_of_one_lt hc)\n  exact .of_seq_closedBall hTop (Eventually.of_forall hC)\n\n"}
{"name":"ProperSpace.of_locallyCompact_module","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : Nontrivial E\ninstâœ : LocallyCompactSpace E\nâŠ¢ ProperSpace ğ•œ","decl":"lemma ProperSpace.of_locallyCompact_module [Nontrivial E] [LocallyCompactSpace E] :\n    ProperSpace ğ•œ :=\n  have : LocallyCompactSpace ğ•œ := by\n    obtain âŸ¨v, hvâŸ© : âˆƒ v : E, v â‰  0 := exists_ne 0\n    let L : ğ•œ â†’ E := fun t â†¦ t â€¢ v\n    have : IsClosedEmbedding L := isClosedEmbedding_smul_left hv\n    apply IsClosedEmbedding.locallyCompactSpace this\n  .of_locallyCompactSpace ğ•œ\n\n"}
{"name":"continuousOn_clm_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\nX : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FiniteDimensional ğ•œ E\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set X\nâŠ¢ Iff (ContinuousOn f s) (âˆ€ (y : E), ContinuousOn (fun x => (f x) y) s)","decl":"/-- A family of continuous linear maps is continuous on `s` if all its applications are. -/\ntheorem continuousOn_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional ğ•œ E]\n    {f : X â†’ E â†’L[ğ•œ] F} {s : Set X} : ContinuousOn f s â†” âˆ€ y, ContinuousOn (fun x => f x y) s := by\n  refine âŸ¨fun h y => (ContinuousLinearMap.apply ğ•œ F y).continuous.comp_continuousOn h, fun h => ?_âŸ©\n  let d := finrank ğ•œ E\n  have hd : d = finrank ğ•œ (Fin d â†’ ğ•œ) := (finrank_fin_fun ğ•œ).symm\n  let eâ‚ : E â‰ƒL[ğ•œ] Fin d â†’ ğ•œ := ContinuousLinearEquiv.ofFinrankEq hd\n  let eâ‚‚ : (E â†’L[ğ•œ] F) â‰ƒL[ğ•œ] Fin d â†’ F :=\n    (eâ‚.arrowCongr (1 : F â‰ƒL[ğ•œ] F)).trans (ContinuousLinearEquiv.piRing (Fin d))\n  rw [â† f.id_comp, â† eâ‚‚.symm_comp_self]\n  exact eâ‚‚.symm.continuous.comp_continuousOn (continuousOn_pi.mpr fun i => h _)\n\n"}
{"name":"continuous_clm_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type w\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\nX : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FiniteDimensional ğ•œ E\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Iff (Continuous f) (âˆ€ (y : E), Continuous fun x => (f x) y)","decl":"theorem continuous_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional ğ•œ E]\n    {f : X â†’ E â†’L[ğ•œ] F} : Continuous f â†” âˆ€ y, Continuous (f Â· y) := by\n  simp_rw [continuous_iff_continuousOn_univ, continuousOn_clm_apply]\n\n"}
{"name":"FiniteDimensional.proper","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : LocallyCompactSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ ProperSpace E","decl":"/-- Any finite-dimensional vector space over a locally compact field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `ğ•œ`, and the search for `ğ•œ` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem FiniteDimensional.proper [FiniteDimensional ğ•œ E] : ProperSpace E := by\n  have : ProperSpace ğ•œ := .of_locallyCompactSpace ğ•œ\n  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ğ•œ _ _ (finrank ğ•œ E)).symm\n  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective\n\n"}
{"name":"FiniteDimensional.proper_real","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nâŠ¢ ProperSpace E","decl":"instance (priority := 900) FiniteDimensional.proper_real (E : Type u) [NormedAddCommGroup E]\n    [NormedSpace â„ E] [FiniteDimensional â„ E] : ProperSpace E :=\n  FiniteDimensional.proper â„ E\n\n"}
{"name":"instProperSpaceSubtypeMemSubmoduleOfCompleteSpaceOfLocallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : LocallyCompactSpace E\nS : Submodule ğ•œ E\nâŠ¢ ProperSpace (Subtype fun x => Membership.mem S x)","decl":"/-- A submodule of a locally compact space over a complete field is also locally compact (and even\nproper). -/\ninstance {ğ•œ E : Type*} [NontriviallyNormedField ğ•œ] [CompleteSpace ğ•œ]\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [LocallyCompactSpace E] (S : Submodule ğ•œ E) :\n    ProperSpace S := by\n  nontriviality E\n  have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E\n  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ\n  exact FiniteDimensional.proper ğ•œ S\n\n"}
{"name":"exists_mem_frontier_infDist_compl_eq_dist","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nx : E\ns : Set E\nhx : Membership.mem s x\nhs : Ne s Set.univ\nâŠ¢ Exists fun y => And (Membership.mem (frontier s) y) (Eq (Metric.infDist x (HasCompl.compl s)) (Dist.dist x y))","decl":"/-- If `E` is a finite dimensional normed real vector space, `x : E`, and `s` is a neighborhood of\n`x` that is not equal to the whole space, then there exists a point `y âˆˆ frontier s` at distance\n`Metric.infDist x sá¶œ` from `x`. See also\n`IsCompact.exists_mem_frontier_infDist_compl_eq_dist`. -/\ntheorem exists_mem_frontier_infDist_compl_eq_dist {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [FiniteDimensional â„ E] {x : E} {s : Set E} (hx : x âˆˆ s) (hs : s â‰  univ) :\n    âˆƒ y âˆˆ frontier s, Metric.infDist x sá¶œ = dist x y := by\n  rcases Metric.exists_mem_closure_infDist_eq_dist (nonempty_compl.2 hs) x with âŸ¨y, hys, hydâŸ©\n  rw [closure_compl] at hys\n  refine âŸ¨y, âŸ¨Metric.closedBall_infDist_compl_subset_closure hx <|\n    Metric.mem_closedBall.2 <| ge_of_eq ?_, hysâŸ©, hydâŸ©\n  rwa [dist_comm]\n\n"}
{"name":"IsCompact.exists_mem_frontier_infDist_compl_eq_dist","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : Nontrivial E\nx : E\nK : Set E\nhK : IsCompact K\nhx : Membership.mem K x\nâŠ¢ Exists fun y => And (Membership.mem (frontier K) y) (Eq (Metric.infDist x (HasCompl.compl K)) (Dist.dist x y))","decl":"/-- If `K` is a compact set in a nontrivial real normed space and `x âˆˆ K`, then there exists a point\n`y` of the boundary of `K` at distance `Metric.infDist x Ká¶œ` from `x`. See also\n`exists_mem_frontier_infDist_compl_eq_dist`. -/\nnonrec theorem IsCompact.exists_mem_frontier_infDist_compl_eq_dist {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace â„ E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K)\n    (hx : x âˆˆ K) :\n    âˆƒ y âˆˆ frontier K, Metric.infDist x Ká¶œ = dist x y := by\n  obtain hx' | hx' : x âˆˆ interior K âˆª frontier K := by\n    rw [â† closure_eq_interior_union_frontier]\n    exact subset_closure hx\n  Â· rw [mem_interior_iff_mem_nhds, Metric.nhds_basis_closedBall.mem_iff] at hx'\n    rcases hx' with âŸ¨r, hrâ‚€, hrKâŸ©\n    have : FiniteDimensional â„ E :=\n      .of_isCompact_closedBall â„ hrâ‚€\n        (hK.of_isClosed_subset Metric.isClosed_ball hrK)\n    exact exists_mem_frontier_infDist_compl_eq_dist hx hK.ne_univ\n  Â· refine âŸ¨x, hx', ?_âŸ©\n    rw [frontier_eq_closure_inter_closure] at hx'\n    rw [Metric.infDist_zero_of_mem_closure hx'.2, dist_self]\n\n"}
{"name":"summable_norm_iff","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf : Î± â†’ E\nâŠ¢ Iff (Summable fun x => Norm.norm (f x)) (Summable f)","decl":"/-- In a finite dimensional vector space over `â„`, the series `âˆ‘ x, â€–f xâ€–` is unconditionally\nsummable if and only if the series `âˆ‘ x, f x` is unconditionally summable. One implication holds in\nany complete normed space, while the other holds only in finite dimensional spaces. -/\ntheorem summable_norm_iff {Î± E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {f : Î± â†’ E} : (Summable fun x => â€–f xâ€–) â†” Summable f := by\n  refine âŸ¨Summable.of_norm, fun hf â†¦ ?_âŸ©\n  -- First we use a finite basis to reduce the problem to the case `E = Fin N â†’ â„`\n  suffices âˆ€ {N : â„•} {g : Î± â†’ Fin N â†’ â„}, Summable g â†’ Summable fun x => â€–g xâ€– by\n    obtain v := Module.finBasis â„ E\n    set e := v.equivFunL\n    have H : Summable fun x => â€–e (f x)â€– := this (e.summable.2 hf)\n    refine .of_norm_bounded _ (H.mul_left â†‘â€–(e.symm : (Fin (finrank â„ E) â†’ â„) â†’L[â„] E)â€–â‚Š) fun i â†¦ ?_\n    simpa using (e.symm : (Fin (finrank â„ E) â†’ â„) â†’L[â„] E).le_opNorm (e <| f i)\n  clear! E\n  -- Now we deal with `g : Î± â†’ Fin N â†’ â„`\n  intro N g hg\n  have : âˆ€ i, Summable fun x => â€–g x iâ€– := fun i => (Pi.summable.1 hg i).abs\n  refine .of_norm_bounded _ (summable_sum fun i (_ : i âˆˆ Finset.univ) => this i) fun x => ?_\n  rw [norm_norm, pi_norm_le_iff_of_nonneg]\n  Â· refine fun i => Finset.single_le_sum (f := fun i => â€–g x iâ€–) (fun i _ => ?_) (Finset.mem_univ i)\n    exact norm_nonneg (g x i)\n  Â· exact Finset.sum_nonneg fun _ _ => norm_nonneg _\n\n"}
{"name":"Summable.norm","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf : Î± â†’ E\naâœ : Summable f\nâŠ¢ Summable fun x => Norm.norm (f x)","decl":"alias âŸ¨_, Summable.normâŸ© := summable_norm_iff\n\n"}
{"name":"summable_of_sum_range_norm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nc : Real\nf : Nat â†’ E\nh : âˆ€ (n : Nat), LE.le ((Finset.range n).sum fun i => Norm.norm (f i)) c\nâŠ¢ Summable f","decl":"theorem summable_of_sum_range_norm_le {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {c : â„} {f : â„• â†’ E} (h : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, â€–f iâ€– â‰¤ c) :\n    Summable f :=\n  summable_norm_iff.mp <| summable_of_sum_range_le (fun _ â†¦ norm_nonneg _)  h\n\n"}
{"name":"summable_of_isBigO'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : FiniteDimensional Real F\nf : Î¹ â†’ E\ng : Î¹ â†’ F\nhg : Summable g\nh : Asymptotics.IsBigO Filter.cofinite f g\nâŠ¢ Summable f","decl":"theorem summable_of_isBigO' {Î¹ E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace â„ F] [FiniteDimensional â„ F] {f : Î¹ â†’ E} {g : Î¹ â†’ F}\n    (hg : Summable g) (h : f =O[cofinite] g) : Summable f :=\n  summable_of_isBigO hg.norm h.norm_right\n\n"}
{"name":"Asymptotics.IsBigO.comp_summable","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : CompleteSpace F\nf : E â†’ F\nhf : Asymptotics.IsBigO (nhds 0) f id\ng : Î¹ â†’ E\nhg : Summable g\nâŠ¢ Summable (Function.comp f g)","decl":"lemma Asymptotics.IsBigO.comp_summable {Î¹ E F : Type*}\n    [NormedAddCommGroup E] [NormedSpace â„ E] [FiniteDimensional â„ E]\n    [NormedAddCommGroup F] [CompleteSpace F]\n    {f : E â†’ F} (hf : f =O[ğ“ 0] id) {g : Î¹ â†’ E} (hg : Summable g) : Summable (f âˆ˜ g) :=\n  .of_norm <| hf.comp_summable_norm hg.norm\n\n"}
{"name":"summable_of_isBigO_nat'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : FiniteDimensional Real F\nf : Nat â†’ E\ng : Nat â†’ F\nhg : Summable g\nh : Asymptotics.IsBigO Filter.atTop f g\nâŠ¢ Summable f","decl":"theorem summable_of_isBigO_nat' {E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace â„ F] [FiniteDimensional â„ F] {f : â„• â†’ E} {g : â„• â†’ F}\n    (hg : Summable g) (h : f =O[atTop] g) : Summable f :=\n  summable_of_isBigO_nat hg.norm h.norm_right\n\n"}
{"name":"summable_of_isEquivalent","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf g : Î¹ â†’ E\nhg : Summable g\nh : Asymptotics.IsEquivalent Filter.cofinite f g\nâŠ¢ Summable f","decl":"theorem summable_of_isEquivalent {Î¹ E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {f : Î¹ â†’ E} {g : Î¹ â†’ E} (hg : Summable g) (h : f ~[cofinite] g) :\n    Summable f :=\n  hg.trans_sub (summable_of_isBigO' hg h.isLittleO.isBigO)\n\n"}
{"name":"summable_of_isEquivalent_nat","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf g : Nat â†’ E\nhg : Summable g\nh : Asymptotics.IsEquivalent Filter.atTop f g\nâŠ¢ Summable f","decl":"theorem summable_of_isEquivalent_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {f : â„• â†’ E} {g : â„• â†’ E} (hg : Summable g) (h : f ~[atTop] g) :\n    Summable f :=\n  hg.trans_sub (summable_of_isBigO_nat' hg h.isLittleO.isBigO)\n\n"}
{"name":"IsEquivalent.summable_iff","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf g : Î¹ â†’ E\nh : Asymptotics.IsEquivalent Filter.cofinite f g\nâŠ¢ Iff (Summable f) (Summable g)","decl":"theorem IsEquivalent.summable_iff {Î¹ E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {f : Î¹ â†’ E} {g : Î¹ â†’ E} (h : f ~[cofinite] g) :\n    Summable f â†” Summable g :=\n  âŸ¨fun hf => summable_of_isEquivalent hf h.symm, fun hg => summable_of_isEquivalent hg hâŸ©\n\n"}
{"name":"IsEquivalent.summable_iff_nat","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nf g : Nat â†’ E\nh : Asymptotics.IsEquivalent Filter.atTop f g\nâŠ¢ Iff (Summable f) (Summable g)","decl":"theorem IsEquivalent.summable_iff_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [FiniteDimensional â„ E] {f : â„• â†’ E} {g : â„• â†’ E} (h : f ~[atTop] g) : Summable f â†” Summable g :=\n  âŸ¨fun hf => summable_of_isEquivalent_nat hf h.symm, fun hg => summable_of_isEquivalent_nat hg hâŸ©\n"}
