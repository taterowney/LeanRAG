{"name":"LinearIsometry.coe_toLinearIsometryEquiv","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"F : Type u_1\nE₁ : Type u_2\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NormedAddCommGroup E₁\nR₁ : Type u_3\ninst✝⁴ : Field R₁\ninst✝³ : Module R₁ E₁\ninst✝² : Module R₁ F\ninst✝¹ : FiniteDimensional R₁ E₁\ninst✝ : FiniteDimensional R₁ F\nli : LinearIsometry (RingHom.id R₁) E₁ F\nh : Eq (Module.finrank R₁ E₁) (Module.finrank R₁ F)\n⊢ Eq ⇑(li.toLinearIsometryEquiv h) ⇑li","decl":"@[simp]\ntheorem coe_toLinearIsometryEquiv (li : E₁ →ₗᵢ[R₁] F) (h : finrank R₁ E₁ = finrank R₁ F) :\n    (li.toLinearIsometryEquiv h : E₁ → F) = li :=\n  rfl\n\n"}
{"name":"LinearIsometry.toLinearIsometryEquiv_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"F : Type u_1\nE₁ : Type u_2\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NormedAddCommGroup E₁\nR₁ : Type u_3\ninst✝⁴ : Field R₁\ninst✝³ : Module R₁ E₁\ninst✝² : Module R₁ F\ninst✝¹ : FiniteDimensional R₁ E₁\ninst✝ : FiniteDimensional R₁ F\nli : LinearIsometry (RingHom.id R₁) E₁ F\nh : Eq (Module.finrank R₁ E₁) (Module.finrank R₁ F)\nx : E₁\n⊢ Eq ((li.toLinearIsometryEquiv h) x) (li x)","decl":"@[simp]\ntheorem toLinearIsometryEquiv_apply (li : E₁ →ₗᵢ[R₁] F) (h : finrank R₁ E₁ = finrank R₁ F)\n    (x : E₁) : (li.toLinearIsometryEquiv h) x = li x :=\n  rfl\n\n"}
{"name":"AffineIsometry.coe_toAffineIsometryEquiv","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u_1\nV₁ : Type u_2\nV₂ : Type u_3\nP₁ : Type u_4\nP₂ : Type u_5\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : NormedAddCommGroup V₁\ninst✝⁹ : SeminormedAddCommGroup V₂\ninst✝⁸ : NormedSpace 𝕜 V₁\ninst✝⁷ : NormedSpace 𝕜 V₂\ninst✝⁶ : MetricSpace P₁\ninst✝⁵ : PseudoMetricSpace P₂\ninst✝⁴ : NormedAddTorsor V₁ P₁\ninst✝³ : NormedAddTorsor V₂ P₂\ninst✝² : FiniteDimensional 𝕜 V₁\ninst✝¹ : FiniteDimensional 𝕜 V₂\ninst✝ : Inhabited P₁\nli : AffineIsometry 𝕜 P₁ P₂\nh : Eq (Module.finrank 𝕜 V₁) (Module.finrank 𝕜 V₂)\n⊢ Eq ⇑(li.toAffineIsometryEquiv h) ⇑li","decl":"@[simp]\ntheorem coe_toAffineIsometryEquiv [Inhabited P₁] (li : P₁ →ᵃⁱ[𝕜] P₂)\n    (h : finrank 𝕜 V₁ = finrank 𝕜 V₂) : (li.toAffineIsometryEquiv h : P₁ → P₂) = li :=\n  rfl\n\n"}
{"name":"AffineIsometry.toAffineIsometryEquiv_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u_1\nV₁ : Type u_2\nV₂ : Type u_3\nP₁ : Type u_4\nP₂ : Type u_5\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : NormedAddCommGroup V₁\ninst✝⁹ : SeminormedAddCommGroup V₂\ninst✝⁸ : NormedSpace 𝕜 V₁\ninst✝⁷ : NormedSpace 𝕜 V₂\ninst✝⁶ : MetricSpace P₁\ninst✝⁵ : PseudoMetricSpace P₂\ninst✝⁴ : NormedAddTorsor V₁ P₁\ninst✝³ : NormedAddTorsor V₂ P₂\ninst✝² : FiniteDimensional 𝕜 V₁\ninst✝¹ : FiniteDimensional 𝕜 V₂\ninst✝ : Inhabited P₁\nli : AffineIsometry 𝕜 P₁ P₂\nh : Eq (Module.finrank 𝕜 V₁) (Module.finrank 𝕜 V₂)\nx : P₁\n⊢ Eq ((li.toAffineIsometryEquiv h) x) (li x)","decl":"@[simp]\ntheorem toAffineIsometryEquiv_apply [Inhabited P₁] (li : P₁ →ᵃⁱ[𝕜] P₂)\n    (h : finrank 𝕜 V₁ = finrank 𝕜 V₂) (x : P₁) : (li.toAffineIsometryEquiv h) x = li x :=\n  rfl\n\n"}
{"name":"AffineMap.continuous_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : CompleteSpace 𝕜\nPE : Type u_1\nPF : Type u_2\ninst✝⁴ : MetricSpace PE\ninst✝³ : NormedAddTorsor E PE\ninst✝² : MetricSpace PF\ninst✝¹ : NormedAddTorsor F PF\ninst✝ : FiniteDimensional 𝕜 E\nf : AffineMap 𝕜 PE PF\n⊢ Continuous ⇑f","decl":"theorem AffineMap.continuous_of_finiteDimensional (f : PE →ᵃ[𝕜] PF) : Continuous f :=\n  AffineMap.continuous_linear_iff.1 f.linear.continuous_of_finiteDimensional\n\n"}
{"name":"AffineEquiv.continuous_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : CompleteSpace 𝕜\nPE : Type u_1\nPF : Type u_2\ninst✝⁴ : MetricSpace PE\ninst✝³ : NormedAddTorsor E PE\ninst✝² : MetricSpace PF\ninst✝¹ : NormedAddTorsor F PF\ninst✝ : FiniteDimensional 𝕜 E\nf : AffineEquiv 𝕜 PE PF\n⊢ Continuous ⇑f","decl":"theorem AffineEquiv.continuous_of_finiteDimensional (f : PE ≃ᵃ[𝕜] PF) : Continuous f :=\n  f.toAffineMap.continuous_of_finiteDimensional\n\n"}
{"name":"AffineEquiv.coe_toHomeomorphOfFiniteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : CompleteSpace 𝕜\nPE : Type u_1\nPF : Type u_2\ninst✝⁴ : MetricSpace PE\ninst✝³ : NormedAddTorsor E PE\ninst✝² : MetricSpace PF\ninst✝¹ : NormedAddTorsor F PF\ninst✝ : FiniteDimensional 𝕜 E\nf : AffineEquiv 𝕜 PE PF\n⊢ Eq ⇑f.toHomeomorphOfFiniteDimensional ⇑f","decl":"@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional (f : PE ≃ᵃ[𝕜] PF) :\n    ⇑f.toHomeomorphOfFiniteDimensional = f :=\n  rfl\n\n"}
{"name":"AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : CompleteSpace 𝕜\nPE : Type u_1\nPF : Type u_2\ninst✝⁴ : MetricSpace PE\ninst✝³ : NormedAddTorsor E PE\ninst✝² : MetricSpace PF\ninst✝¹ : NormedAddTorsor F PF\ninst✝ : FiniteDimensional 𝕜 E\nf : AffineEquiv 𝕜 PE PF\n⊢ Eq ⇑f.toHomeomorphOfFiniteDimensional.symm ⇑f.symm","decl":"@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm (f : PE ≃ᵃ[𝕜] PF) :\n    ⇑f.toHomeomorphOfFiniteDimensional.symm = f.symm :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.continuous_det","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\n⊢ Continuous fun f => f.det","decl":"theorem ContinuousLinearMap.continuous_det : Continuous fun f : E →L[𝕜] E => f.det := by\n  change Continuous fun f : E →L[𝕜] E => LinearMap.det (f : E →ₗ[𝕜] E)\n  -- Porting note: this could be easier with `det_cases`\n  by_cases h : ∃ s : Finset E, Nonempty (Basis (↥s) 𝕜 E)\n  · rcases h with ⟨s, ⟨b⟩⟩\n    haveI : FiniteDimensional 𝕜 E := FiniteDimensional.of_fintype_basis b\n    classical\n    simp_rw [LinearMap.det_eq_det_toMatrix_of_finset b]\n    refine Continuous.matrix_det ?_\n    exact\n      ((LinearMap.toMatrix b b).toLinearMap.comp\n          (ContinuousLinearMap.coeLM 𝕜)).continuous_of_finiteDimensional\n  · -- Porting note: was `unfold LinearMap.det`\n    rw [LinearMap.det_def]\n    simpa only [h, MonoidHom.one_apply, dif_neg, not_false_iff] using continuous_const\n\n"}
{"name":"lipschitzExtensionConstant_def","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E' : Type u_1\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace Real E'\ninst✝ : FiniteDimensional Real E'\n⊢ Eq (lipschitzExtensionConstant E')\n    (let A := (Basis.ofVectorSpace Real E').equivFun.toContinuousLinearEquiv;\n    Max.max (HMul.hMul (NNNorm.nnnorm ↑A.symm) (NNNorm.nnnorm ↑A)) 1)","decl":"/-- Any `K`-Lipschitz map from a subset `s` of a metric space `α` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `α`, with a slightly worse\nconstant `C * K` where `C` only depends on `E'`. We record a working value for this constant `C`\nas `lipschitzExtensionConstant E'`. -/\nirreducible_def lipschitzExtensionConstant (E' : Type*) [NormedAddCommGroup E'] [NormedSpace ℝ E']\n  [FiniteDimensional ℝ E'] : ℝ≥0 :=\n  let A := (Basis.ofVectorSpace ℝ E').equivFun.toContinuousLinearEquiv\n  max (‖A.symm.toContinuousLinearMap‖₊ * ‖A.toContinuousLinearMap‖₊) 1\n\n"}
{"name":"lipschitzExtensionConstant_pos","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E' : Type u_1\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace Real E'\ninst✝ : FiniteDimensional Real E'\n⊢ LT.lt 0 (lipschitzExtensionConstant E')","decl":"theorem lipschitzExtensionConstant_pos (E' : Type*) [NormedAddCommGroup E'] [NormedSpace ℝ E']\n    [FiniteDimensional ℝ E'] : 0 < lipschitzExtensionConstant E' := by\n  rw [lipschitzExtensionConstant]\n  exact zero_lt_one.trans_le (le_max_right _ _)\n\n"}
{"name":"LipschitzOnWith.extend_finite_dimension","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nE' : Type u_2\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace Real E'\ninst✝ : FiniteDimensional Real E'\ns : Set α\nf : α → E'\nK : NNReal\nhf : LipschitzOnWith K f s\n⊢ Exists fun g => And (LipschitzWith (HMul.hMul (lipschitzExtensionConstant E') K) g) (Set.EqOn f g s)","decl":"/-- Any `K`-Lipschitz map from a subset `s` of a metric space `α` to a finite-dimensional real\nvector space `E'` can be extended to a Lipschitz map on the whole space `α`, with a slightly worse\nconstant `lipschitzExtensionConstant E' * K`. -/\ntheorem LipschitzOnWith.extend_finite_dimension {α : Type*} [PseudoMetricSpace α] {E' : Type*}\n    [NormedAddCommGroup E'] [NormedSpace ℝ E'] [FiniteDimensional ℝ E'] {s : Set α} {f : α → E'}\n    {K : ℝ≥0} (hf : LipschitzOnWith K f s) :\n    ∃ g : α → E', LipschitzWith (lipschitzExtensionConstant E' * K) g ∧ EqOn f g s := by\n  /- This result is already known for spaces `ι → ℝ`. We use a continuous linear equiv between\n    `E'` and such a space to transfer the result to `E'`. -/\n  let ι : Type _ := Basis.ofVectorSpaceIndex ℝ E'\n  let A := (Basis.ofVectorSpace ℝ E').equivFun.toContinuousLinearEquiv\n  have LA : LipschitzWith ‖A.toContinuousLinearMap‖₊ A := by apply A.lipschitz\n  have L : LipschitzOnWith (‖A.toContinuousLinearMap‖₊ * K) (A ∘ f) s :=\n    LA.comp_lipschitzOnWith hf\n  obtain ⟨g, hg, gs⟩ :\n    ∃ g : α → ι → ℝ, LipschitzWith (‖A.toContinuousLinearMap‖₊ * K) g ∧ EqOn (A ∘ f) g s :=\n    L.extend_pi\n  refine ⟨A.symm ∘ g, ?_, ?_⟩\n  · have LAsymm : LipschitzWith ‖A.symm.toContinuousLinearMap‖₊ A.symm := by\n      apply A.symm.lipschitz\n    apply (LAsymm.comp hg).weaken\n    rw [lipschitzExtensionConstant, ← mul_assoc]\n    exact mul_le_mul' (le_max_left _ _) le_rfl\n  · intro x hx\n    have : A (f x) = g x := gs hx\n    simp only [(· ∘ ·), ← this, A.symm_apply_apply]\n\n"}
{"name":"LinearMap.exists_antilipschitzWith","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 E\nf : LinearMap (RingHom.id 𝕜) E F\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ Exists fun K => And (GT.gt K 0) (AntilipschitzWith K ⇑f)","decl":"theorem LinearMap.exists_antilipschitzWith [FiniteDimensional 𝕜 E] (f : E →ₗ[𝕜] F)\n    (hf : LinearMap.ker f = ⊥) : ∃ K > 0, AntilipschitzWith K f := by\n  cases subsingleton_or_nontrivial E\n  · exact ⟨1, zero_lt_one, AntilipschitzWith.of_subsingleton⟩\n  · rw [LinearMap.ker_eq_bot] at hf\n    let e : E ≃L[𝕜] LinearMap.range f := (LinearEquiv.ofInjective f hf).toContinuousLinearEquiv\n    exact ⟨_, e.nnnorm_symm_pos, e.antilipschitz⟩\n\n"}
{"name":"LinearMap.injective_iff_antilipschitz","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 E\nf : LinearMap (RingHom.id 𝕜) E F\n⊢ Iff (Function.Injective ⇑f) (Exists fun K => And (GT.gt K 0) (AntilipschitzWith K ⇑f))","decl":"open Function in\n/-- A `LinearMap` on a finite-dimensional space over a complete field\n  is injective iff it is anti-Lipschitz. -/\ntheorem LinearMap.injective_iff_antilipschitz [FiniteDimensional 𝕜 E] (f : E →ₗ[𝕜] F) :\n    Injective f ↔ ∃ K > 0, AntilipschitzWith K f := by\n  constructor\n  · rw [← LinearMap.ker_eq_bot]\n    exact f.exists_antilipschitzWith\n  · rintro ⟨K, -, H⟩\n    exact H.injective\n\n"}
{"name":"ContinuousLinearMap.isOpen_injective","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 E\n⊢ IsOpen (setOf fun L => Function.Injective ⇑L)","decl":"open Function in\n/-- The set of injective continuous linear maps `E → F` is open,\n  if `E` is finite-dimensional over a complete field. -/\ntheorem ContinuousLinearMap.isOpen_injective [FiniteDimensional 𝕜 E] :\n    IsOpen { L : E →L[𝕜] F | Injective L } := by\n  rw [isOpen_iff_eventually]\n  rintro φ₀ hφ₀\n  rcases φ₀.injective_iff_antilipschitz.mp hφ₀ with ⟨K, K_pos, H⟩\n  have : ∀ᶠ φ in 𝓝 φ₀, ‖φ - φ₀‖₊ < K⁻¹ := eventually_nnnorm_sub_lt _ <| inv_pos_of_pos K_pos\n  filter_upwards [this] with φ hφ\n  apply φ.injective_iff_antilipschitz.mpr\n  exact ⟨(K⁻¹ - ‖φ - φ₀‖₊)⁻¹, inv_pos_of_pos (tsub_pos_of_lt hφ),\n    H.add_sub_lipschitzWith (φ - φ₀).lipschitz hφ⟩\n\n"}
{"name":"LinearIndependent.eventually","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Finite ι\nf : ι → E\nhf : LinearIndependent 𝕜 f\n⊢ Filter.Eventually (fun g => LinearIndependent 𝕜 g) (nhds f)","decl":"protected theorem LinearIndependent.eventually {ι} [Finite ι] {f : ι → E}\n    (hf : LinearIndependent 𝕜 f) : ∀ᶠ g in 𝓝 f, LinearIndependent 𝕜 g := by\n  cases nonempty_fintype ι\n  classical\n  simp only [Fintype.linearIndependent_iff'] at hf ⊢\n  rcases LinearMap.exists_antilipschitzWith _ hf with ⟨K, K0, hK⟩\n  have : Tendsto (fun g : ι → E => ∑ i, ‖g i - f i‖) (𝓝 f) (𝓝 <| ∑ i, ‖f i - f i‖) :=\n    tendsto_finset_sum _ fun i _ =>\n      Tendsto.norm <| ((continuous_apply i).tendsto _).sub tendsto_const_nhds\n  simp only [sub_self, norm_zero, Finset.sum_const_zero] at this\n  refine (this.eventually (gt_mem_nhds <| inv_pos.2 K0)).mono fun g hg => ?_\n  replace hg : ∑ i, ‖g i - f i‖₊ < K⁻¹ := by\n    rw [← NNReal.coe_lt_coe]\n    push_cast\n    exact hg\n  rw [LinearMap.ker_eq_bot]\n  refine (hK.add_sub_lipschitzWith (LipschitzWith.of_dist_le_mul fun v u => ?_) hg).injective\n  simp only [dist_eq_norm, LinearMap.lsum_apply, Pi.sub_apply, LinearMap.sum_apply,\n    LinearMap.comp_apply, LinearMap.proj_apply, LinearMap.smulRight_apply, LinearMap.id_apply, ←\n    Finset.sum_sub_distrib, ← smul_sub, ← sub_smul, NNReal.coe_sum, coe_nnnorm, Finset.sum_mul]\n  refine norm_sum_le_of_le _ fun i _ => ?_\n  rw [norm_smul, mul_comm]\n  gcongr\n  exact norm_le_pi_norm (v - u) i\n\n"}
{"name":"isOpen_setOf_linearIndependent","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Finite ι\n⊢ IsOpen (setOf fun f => LinearIndependent 𝕜 f)","decl":"theorem isOpen_setOf_linearIndependent {ι : Type*} [Finite ι] :\n    IsOpen { f : ι → E | LinearIndependent 𝕜 f } :=\n  isOpen_iff_mem_nhds.2 fun _ => LinearIndependent.eventually\n\n"}
{"name":"isOpen_setOf_nat_le_rank","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type w\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace 𝕜\nn : Nat\n⊢ IsOpen (setOf fun f => LE.le (↑n) (↑f).rank)","decl":"theorem isOpen_setOf_nat_le_rank (n : ℕ) :\n    IsOpen { f : E →L[𝕜] F | ↑n ≤ (f : E →ₗ[𝕜] F).rank } := by\n  simp only [LinearMap.le_rank_iff_exists_linearIndependent_finset, setOf_exists, ← exists_prop]\n  refine isOpen_biUnion fun t _ => ?_\n  have : Continuous fun f : E →L[𝕜] F => fun x : (t : Set E) => f x :=\n    continuous_pi fun x => (ContinuousLinearMap.apply 𝕜 F (x : E)).continuous\n  exact isOpen_setOf_linearIndependent.preimage this\n\n"}
{"name":"Basis.opNNNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nu : ContinuousLinearMap (RingHom.id 𝕜) E F\nM : NNReal\nhu : ∀ (i : ι), LE.le (NNNorm.nnnorm (u (v i))) M\n⊢ LE.le (NNNorm.nnnorm u) (HMul.hMul (HSMul.hSMul (Fintype.card ι) (NNNorm.nnnorm ↑v.equivFunL)) M)","decl":"theorem Basis.opNNNorm_le {ι : Type*} [Fintype ι] (v : Basis ι 𝕜 E) {u : E →L[𝕜] F} (M : ℝ≥0)\n    (hu : ∀ i, ‖u (v i)‖₊ ≤ M) : ‖u‖₊ ≤ Fintype.card ι • ‖v.equivFunL.toContinuousLinearMap‖₊ * M :=\n  u.opNNNorm_le_bound _ fun e => by\n    set φ := v.equivFunL.toContinuousLinearMap\n    calc\n      ‖u e‖₊ = ‖u (∑ i, v.equivFun e i • v i)‖₊ := by rw [v.sum_equivFun]\n      _ = ‖∑ i, v.equivFun e i • (u <| v i)‖₊ := by simp [map_sum, LinearMap.map_smul]\n      _ ≤ ∑ i, ‖v.equivFun e i • (u <| v i)‖₊ := nnnorm_sum_le _ _\n      _ = ∑ i, ‖v.equivFun e i‖₊ * ‖u (v i)‖₊ := by simp only [nnnorm_smul]\n      _ ≤ ∑ i, ‖v.equivFun e i‖₊ * M := by gcongr; apply hu\n      _ = (∑ i, ‖v.equivFun e i‖₊) * M := by rw [Finset.sum_mul]\n      _ ≤ Fintype.card ι • (‖φ‖₊ * ‖e‖₊) * M := by\n        gcongr\n        calc\n          ∑ i, ‖v.equivFun e i‖₊ ≤ Fintype.card ι • ‖φ e‖₊ := Pi.sum_nnnorm_apply_le_nnnorm _\n          _ ≤ Fintype.card ι • (‖φ‖₊ * ‖e‖₊) := nsmul_le_nsmul_right (φ.le_opNNNorm e) _\n      _ = Fintype.card ι • ‖φ‖₊ * M * ‖e‖₊ := by simp only [smul_mul_assoc, mul_right_comm]\n\n"}
{"name":"Basis.opNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Fintype ι\nv : Basis ι 𝕜 E\nu : ContinuousLinearMap (RingHom.id 𝕜) E F\nM : Real\nhM : LE.le 0 M\nhu : ∀ (i : ι), LE.le (Norm.norm (u (v i))) M\n⊢ LE.le (Norm.norm u) (HMul.hMul (HSMul.hSMul (Fintype.card ι) (Norm.norm ↑v.equivFunL)) M)","decl":"theorem Basis.opNorm_le {ι : Type*} [Fintype ι] (v : Basis ι 𝕜 E) {u : E →L[𝕜] F} {M : ℝ}\n    (hM : 0 ≤ M) (hu : ∀ i, ‖u (v i)‖ ≤ M) :\n    ‖u‖ ≤ Fintype.card ι • ‖v.equivFunL.toContinuousLinearMap‖ * M := by\n  simpa using NNReal.coe_le_coe.mpr (v.opNNNorm_le ⟨M, hM⟩ hu)\n\n"}
{"name":"Basis.exists_opNNNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Finite ι\nv : Basis ι 𝕜 E\n⊢ Exists fun C => And (GT.gt C 0) (∀ {u : ContinuousLinearMap (RingHom.id 𝕜) E F} (M : NNReal), (∀ (i : ι), LE.le (NNNorm.nnnorm (u (v i))) M) → LE.le (NNNorm.nnnorm u) (HMul.hMul C M))","decl":"/-- A weaker version of `Basis.opNNNorm_le` that abstracts away the value of `C`. -/\ntheorem Basis.exists_opNNNorm_le {ι : Type*} [Finite ι] (v : Basis ι 𝕜 E) :\n    ∃ C > (0 : ℝ≥0), ∀ {u : E →L[𝕜] F} (M : ℝ≥0), (∀ i, ‖u (v i)‖₊ ≤ M) → ‖u‖₊ ≤ C * M := by\n  cases nonempty_fintype ι\n  exact\n    ⟨max (Fintype.card ι • ‖v.equivFunL.toContinuousLinearMap‖₊) 1,\n      zero_lt_one.trans_le (le_max_right _ _), fun {u} M hu =>\n      (v.opNNNorm_le M hu).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (zero_le M)⟩\n\n"}
{"name":"Basis.exists_opNorm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\nι : Type u_1\ninst✝ : Finite ι\nv : Basis ι 𝕜 E\n⊢ Exists fun C => And (GT.gt C 0) (∀ {u : ContinuousLinearMap (RingHom.id 𝕜) E F} {M : Real}, LE.le 0 M → (∀ (i : ι), LE.le (Norm.norm (u (v i))) M) → LE.le (Norm.norm u) (HMul.hMul C M))","decl":"/-- A weaker version of `Basis.opNorm_le` that abstracts away the value of `C`. -/\ntheorem Basis.exists_opNorm_le {ι : Type*} [Finite ι] (v : Basis ι 𝕜 E) :\n    ∃ C > (0 : ℝ), ∀ {u : E →L[𝕜] F} {M : ℝ}, 0 ≤ M → (∀ i, ‖u (v i)‖ ≤ M) → ‖u‖ ≤ C * M := by\n  obtain ⟨C, hC, h⟩ := v.exists_opNNNorm_le (F := F)\n  -- Porting note: used `Subtype.forall'` below\n  refine ⟨C, hC, ?_⟩\n  intro u M hM H\n  simpa using h ⟨M, hM⟩ H\n\n"}
{"name":"instSecondCountableTopologyContinuousLinearMapIdOfFiniteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type w\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : SecondCountableTopology F\n⊢ SecondCountableTopology (ContinuousLinearMap (RingHom.id 𝕜) E F)","decl":"instance [FiniteDimensional 𝕜 E] [SecondCountableTopology F] :\n    SecondCountableTopology (E →L[𝕜] F) := by\n  set d := Module.finrank 𝕜 E\n  suffices\n    ∀ ε > (0 : ℝ), ∃ n : (E →L[𝕜] F) → Fin d → ℕ, ∀ f g : E →L[𝕜] F, n f = n g → dist f g ≤ ε from\n    Metric.secondCountable_of_countable_discretization fun ε ε_pos =>\n      ⟨Fin d → ℕ, by infer_instance, this ε ε_pos⟩\n  intro ε ε_pos\n  obtain ⟨u : ℕ → F, hu : DenseRange u⟩ := exists_dense_seq F\n  let v := Module.finBasis 𝕜 E\n  obtain\n    ⟨C : ℝ, C_pos : 0 < C, hC :\n      ∀ {φ : E →L[𝕜] F} {M : ℝ}, 0 ≤ M → (∀ i, ‖φ (v i)‖ ≤ M) → ‖φ‖ ≤ C * M⟩ :=\n    v.exists_opNorm_le (E := E) (F := F)\n  have h_2C : 0 < 2 * C := mul_pos zero_lt_two C_pos\n  have hε2C : 0 < ε / (2 * C) := div_pos ε_pos h_2C\n  have : ∀ φ : E →L[𝕜] F, ∃ n : Fin d → ℕ, ‖φ - (v.constrL <| u ∘ n)‖ ≤ ε / 2 := by\n    intro φ\n    have : ∀ i, ∃ n, ‖φ (v i) - u n‖ ≤ ε / (2 * C) := by\n      simp only [norm_sub_rev]\n      intro i\n      have : φ (v i) ∈ closure (range u) := hu _\n      obtain ⟨n, hn⟩ : ∃ n, ‖u n - φ (v i)‖ < ε / (2 * C) := by\n        rw [mem_closure_iff_nhds_basis Metric.nhds_basis_ball] at this\n        specialize this (ε / (2 * C)) hε2C\n        simpa [dist_eq_norm]\n      exact ⟨n, le_of_lt hn⟩\n    choose n hn using this\n    use n\n    replace hn : ∀ i : Fin d, ‖(φ - (v.constrL <| u ∘ n)) (v i)‖ ≤ ε / (2 * C) := by simp [hn]\n    have : C * (ε / (2 * C)) = ε / 2 := by\n      rw [eq_div_iff (two_ne_zero : (2 : ℝ) ≠ 0), mul_comm, ← mul_assoc,\n        mul_div_cancel₀ _ (ne_of_gt h_2C)]\n    specialize hC (le_of_lt hε2C) hn\n    rwa [this] at hC\n  choose n hn using this\n  set Φ := fun φ : E →L[𝕜] F => v.constrL <| u ∘ n φ\n  change ∀ z, dist z (Φ z) ≤ ε / 2 at hn\n  use n\n  intro x y hxy\n  calc\n    dist x y ≤ dist x (Φ x) + dist (Φ x) y := dist_triangle _ _ _\n    _ = dist x (Φ x) + dist y (Φ y) := by simp [Φ, hxy, dist_comm]\n    _ ≤ ε := by linarith [hn x, hn y]\n\n"}
{"name":"AffineSubspace.closed_of_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace 𝕜\nP : Type u_1\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ns : AffineSubspace 𝕜 P\ninst✝ : FiniteDimensional 𝕜 (Subtype fun x => Membership.mem s.direction x)\n⊢ IsClosed ↑s","decl":"theorem AffineSubspace.closed_of_finiteDimensional {P : Type*} [MetricSpace P]\n    [NormedAddTorsor E P] (s : AffineSubspace 𝕜 P) [FiniteDimensional 𝕜 s.direction] :\n    IsClosed (s : Set P) :=\n  s.isClosed_direction_iff.mp s.direction.closed_of_finiteDimensional\n\n"}
{"name":"exists_norm_le_le_norm_sub_of_finset","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nR : Real\nhR : LT.lt (Norm.norm c) R\nh : Not (FiniteDimensional 𝕜 E)\ns : Finset E\n⊢ Exists fun x => And (LE.le (Norm.norm x) R) (∀ (y : E), Membership.mem s y → LE.le 1 (Norm.norm (HSub.hSub y x)))","decl":"/-- In an infinite dimensional space, given a finite number of points, one may find a point\nwith norm at most `R` which is at distance at least `1` of all these points. -/\ntheorem exists_norm_le_le_norm_sub_of_finset {c : 𝕜} (hc : 1 < ‖c‖) {R : ℝ} (hR : ‖c‖ < R)\n    (h : ¬FiniteDimensional 𝕜 E) (s : Finset E) : ∃ x : E, ‖x‖ ≤ R ∧ ∀ y ∈ s, 1 ≤ ‖y - x‖ := by\n  let F := Submodule.span 𝕜 (s : Set E)\n  haveI : FiniteDimensional 𝕜 F :=\n    Module.finite_def.2\n      ((Submodule.fg_top _).2 (Submodule.fg_def.2 ⟨s, Finset.finite_toSet _, rfl⟩))\n  have Fclosed : IsClosed (F : Set E) := Submodule.closed_of_finiteDimensional _\n  have : ∃ x, x ∉ F := by\n    contrapose! h\n    have : (⊤ : Submodule 𝕜 E) = F := by\n      ext x\n      simp [h]\n    have : FiniteDimensional 𝕜 (⊤ : Submodule 𝕜 E) := by rwa [this]\n    exact Module.finite_def.2 ((Submodule.fg_top _).1 (Module.finite_def.1 this))\n  obtain ⟨x, xR, hx⟩ : ∃ x : E, ‖x‖ ≤ R ∧ ∀ y : E, y ∈ F → 1 ≤ ‖x - y‖ :=\n    riesz_lemma_of_norm_lt hc hR Fclosed this\n  have hx' : ∀ y : E, y ∈ F → 1 ≤ ‖y - x‖ := by\n    intro y hy\n    rw [← norm_neg]\n    simpa using hx y hy\n  exact ⟨x, xR, fun y hy => hx' _ (Submodule.subset_span hy)⟩\n\n"}
{"name":"exists_seq_norm_le_one_le_norm_sub'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nR : Real\nhR : LT.lt (Norm.norm c) R\nh : Not (FiniteDimensional 𝕜 E)\n⊢ Exists fun f => And (∀ (n : Nat), LE.le (Norm.norm (f n)) R) (Pairwise fun m n => LE.le 1 (Norm.norm (HSub.hSub (f m) (f n))))","decl":"/-- In an infinite-dimensional normed space, there exists a sequence of points which are all\nbounded by `R` and at distance at least `1`. For a version not assuming `c` and `R`, see\n`exists_seq_norm_le_one_le_norm_sub`. -/\ntheorem exists_seq_norm_le_one_le_norm_sub' {c : 𝕜} (hc : 1 < ‖c‖) {R : ℝ} (hR : ‖c‖ < R)\n    (h : ¬FiniteDimensional 𝕜 E) :\n    ∃ f : ℕ → E, (∀ n, ‖f n‖ ≤ R) ∧ Pairwise fun m n => 1 ≤ ‖f m - f n‖ := by\n  have : IsSymm E fun x y : E => 1 ≤ ‖x - y‖ := by\n    constructor\n    intro x y hxy\n    rw [← norm_neg]\n    simpa\n  apply\n    exists_seq_of_forall_finset_exists' (fun x : E => ‖x‖ ≤ R) fun (x : E) (y : E) => 1 ≤ ‖x - y‖\n  rintro s -\n  exact exists_norm_le_le_norm_sub_of_finset hc hR h s\n\n"}
{"name":"exists_seq_norm_le_one_le_norm_sub","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\nh : Not (FiniteDimensional 𝕜 E)\n⊢ Exists fun R => Exists fun f => And (LT.lt 1 R) (And (∀ (n : Nat), LE.le (Norm.norm (f n)) R) (Pairwise fun m n => LE.le 1 (Norm.norm (HSub.hSub (f m) (f n)))))","decl":"theorem exists_seq_norm_le_one_le_norm_sub (h : ¬FiniteDimensional 𝕜 E) :\n    ∃ (R : ℝ) (f : ℕ → E), 1 < R ∧ (∀ n, ‖f n‖ ≤ R) ∧ Pairwise fun m n => 1 ≤ ‖f m - f n‖ := by\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 1 < ‖c‖ := NormedField.exists_one_lt_norm 𝕜\n  have A : ‖c‖ < ‖c‖ + 1 := by linarith\n  rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ⟨f, hf⟩\n  exact ⟨‖c‖ + 1, f, hc.trans A, hf.1, hf.2⟩\n\n"}
{"name":"FiniteDimensional.of_isCompact_closedBall₀","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\nr : Real\nrpos : LT.lt 0 r\nh : IsCompact (Metric.closedBall 0 r)\n⊢ FiniteDimensional 𝕜 E","decl":"/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. -/\ntheorem FiniteDimensional.of_isCompact_closedBall₀ {r : ℝ} (rpos : 0 < r)\n    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional 𝕜 E := by\n  by_contra hfin\n  obtain ⟨R, f, Rgt, fle, lef⟩ :\n    ∃ (R : ℝ) (f : ℕ → E), 1 < R ∧ (∀ n, ‖f n‖ ≤ R) ∧ Pairwise fun m n => 1 ≤ ‖f m - f n‖ :=\n    exists_seq_norm_le_one_le_norm_sub hfin\n  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)\n  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 0 < ‖c‖ ∧ ‖c‖ < r / R := NormedField.exists_norm_lt _ rRpos\n  let g := fun n : ℕ => c • f n\n  have A : ∀ n, g n ∈ Metric.closedBall (0 : E) r := by\n    intro n\n    simp only [g, norm_smul, dist_zero_right, Metric.mem_closedBall]\n    calc\n      ‖c‖ * ‖f n‖ ≤ r / R * R := by\n        gcongr\n        · exact hc.2.le\n        · apply fle\n      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']\n  -- Porting note: moved type ascriptions because of exists_prop changes\n  obtain ⟨x : E, _ : x ∈ Metric.closedBall (0 : E) r, φ : ℕ → ℕ, φmono : StrictMono φ,\n    φlim : Tendsto (g ∘ φ) atTop (𝓝 x)⟩ := h.tendsto_subseq A\n  have B : CauchySeq (g ∘ φ) := φlim.cauchySeq\n  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n : ℕ, N ≤ n → dist ((g ∘ φ) n) ((g ∘ φ) N) < ‖c‖ :=\n    Metric.cauchySeq_iff'.1 B ‖c‖ hc.1\n  apply lt_irrefl ‖c‖\n  calc\n    ‖c‖ ≤ dist (g (φ (N + 1))) (g (φ N)) := by\n      conv_lhs => rw [← mul_one ‖c‖]\n      simp only [g, dist_eq_norm, ← smul_sub, norm_smul]\n      gcongr\n      apply lef (ne_of_gt _)\n      exact φmono (Nat.lt_succ_self N)\n    _ < ‖c‖ := hN (N + 1) (Nat.le_succ N)\n\n"}
{"name":"FiniteDimensional.of_isCompact_closedBall","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace 𝕜\nr : Real\nrpos : LT.lt 0 r\nc : E\nh : IsCompact (Metric.closedBall c r)\n⊢ FiniteDimensional 𝕜 E","decl":"/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\nspace is finite-dimensional. -/\ntheorem FiniteDimensional.of_isCompact_closedBall {r : ℝ} (rpos : 0 < r) {c : E}\n    (h : IsCompact (Metric.closedBall c r)) : FiniteDimensional 𝕜 E :=\n  .of_isCompact_closedBall₀ 𝕜 rpos <| by simpa using h.vadd (-c)\n\n"}
{"name":"FiniteDimensional.of_locallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : LocallyCompactSpace E\n⊢ FiniteDimensional 𝕜 E","decl":"/-- **Riesz's theorem**: a locally compact normed vector space is finite-dimensional. -/\ntheorem FiniteDimensional.of_locallyCompactSpace [LocallyCompactSpace E] :\n    FiniteDimensional 𝕜 E :=\n  let ⟨_r, rpos, hr⟩ := exists_isCompact_closedBall (0 : E)\n  .of_isCompact_closedBall₀ 𝕜 rpos hr\n\n"}
{"name":"HasCompactSupport.eq_zero_or_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace 𝕜\nX : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : Zero X\ninst✝ : T1Space X\nf : E → X\nhf : HasCompactSupport f\nh'f : Continuous f\n⊢ Or (Eq f 0) (FiniteDimensional 𝕜 E)","decl":"/-- If a function has compact support, then either the function is trivial\nor the space is finite-dimensional. -/\ntheorem HasCompactSupport.eq_zero_or_finiteDimensional {X : Type*} [TopologicalSpace X] [Zero X]\n    [T1Space X] {f : E → X} (hf : HasCompactSupport f) (h'f : Continuous f) :\n    f = 0 ∨ FiniteDimensional 𝕜 E :=\n  (HasCompactSupport.eq_zero_or_locallyCompactSpace_of_addGroup hf h'f).imp_right fun h ↦\n    -- TODO: Lean doesn't find the instance without this `have`\n    have : LocallyCompactSpace E := h; .of_locallyCompactSpace 𝕜\n\n"}
{"name":"HasCompactMulSupport.eq_one_or_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace 𝕜\nX : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : One X\ninst✝ : T1Space X\nf : E → X\nhf : HasCompactMulSupport f\nh'f : Continuous f\n⊢ Or (Eq f 1) (FiniteDimensional 𝕜 E)","decl":"/-- If a function has compact multiplicative support, then either the function is trivial\nor the space is finite-dimensional. -/\n@[to_additive existing]\ntheorem HasCompactMulSupport.eq_one_or_finiteDimensional {X : Type*} [TopologicalSpace X] [One X]\n    [T1Space X] {f : E → X} (hf : HasCompactMulSupport f) (h'f : Continuous f) :\n    f = 1 ∨ FiniteDimensional 𝕜 E :=\n  have : T1Space (Additive X) := ‹_›\n  HasCompactSupport.eq_zero_or_finiteDimensional (X := Additive X) 𝕜 hf h'f\n\n"}
{"name":"ProperSpace.of_locallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : LocallyCompactSpace E\n⊢ ProperSpace E","decl":"/-- A locally compact normed vector space is proper. -/\nlemma ProperSpace.of_locallyCompactSpace (𝕜 : Type*) [NontriviallyNormedField 𝕜]\n    {E : Type*} [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] [LocallyCompactSpace E] :\n    ProperSpace E := by\n  rcases exists_isCompact_closedBall (0 : E) with ⟨r, rpos, hr⟩\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  have hC : ∀ n, IsCompact (closedBall (0 : E) (‖c‖^n * r)) := fun n ↦ by\n    have : c ^ n ≠ 0 := pow_ne_zero _ <| fun h ↦ by simp [h, zero_le_one.not_lt] at hc\n    simpa [_root_.smul_closedBall' this] using hr.smul (c ^ n)\n  have hTop : Tendsto (fun n ↦ ‖c‖^n * r) atTop atTop :=\n    Tendsto.atTop_mul_const rpos (tendsto_pow_atTop_atTop_of_one_lt hc)\n  exact .of_seq_closedBall hTop (Eventually.of_forall hC)\n\n"}
{"name":"ProperSpace.of_locallyCompact_module","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : CompleteSpace 𝕜\ninst✝¹ : Nontrivial E\ninst✝ : LocallyCompactSpace E\n⊢ ProperSpace 𝕜","decl":"lemma ProperSpace.of_locallyCompact_module [Nontrivial E] [LocallyCompactSpace E] :\n    ProperSpace 𝕜 :=\n  have : LocallyCompactSpace 𝕜 := by\n    obtain ⟨v, hv⟩ : ∃ v : E, v ≠ 0 := exists_ne 0\n    let L : 𝕜 → E := fun t ↦ t • v\n    have : IsClosedEmbedding L := isClosedEmbedding_smul_left hv\n    apply IsClosedEmbedding.locallyCompactSpace this\n  .of_locallyCompactSpace 𝕜\n\n"}
{"name":"continuousOn_clm_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : CompleteSpace 𝕜\nX : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : FiniteDimensional 𝕜 E\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set X\n⊢ Iff (ContinuousOn f s) (∀ (y : E), ContinuousOn (fun x => (f x) y) s)","decl":"/-- A family of continuous linear maps is continuous on `s` if all its applications are. -/\ntheorem continuousOn_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional 𝕜 E]\n    {f : X → E →L[𝕜] F} {s : Set X} : ContinuousOn f s ↔ ∀ y, ContinuousOn (fun x => f x y) s := by\n  refine ⟨fun h y => (ContinuousLinearMap.apply 𝕜 F y).continuous.comp_continuousOn h, fun h => ?_⟩\n  let d := finrank 𝕜 E\n  have hd : d = finrank 𝕜 (Fin d → 𝕜) := (finrank_fin_fun 𝕜).symm\n  let e₁ : E ≃L[𝕜] Fin d → 𝕜 := ContinuousLinearEquiv.ofFinrankEq hd\n  let e₂ : (E →L[𝕜] F) ≃L[𝕜] Fin d → F :=\n    (e₁.arrowCongr (1 : F ≃L[𝕜] F)).trans (ContinuousLinearEquiv.piRing (Fin d))\n  rw [← f.id_comp, ← e₂.symm_comp_self]\n  exact e₂.symm.continuous.comp_continuousOn (continuousOn_pi.mpr fun i => h _)\n\n"}
{"name":"continuous_clm_apply","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type w\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : CompleteSpace 𝕜\nX : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : FiniteDimensional 𝕜 E\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Iff (Continuous f) (∀ (y : E), Continuous fun x => (f x) y)","decl":"theorem continuous_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional 𝕜 E]\n    {f : X → E →L[𝕜] F} : Continuous f ↔ ∀ y, Continuous (f · y) := by\n  simp_rw [continuous_iff_continuousOn_univ, continuousOn_clm_apply]\n\n"}
{"name":"FiniteDimensional.proper","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : LocallyCompactSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 E\n⊢ ProperSpace E","decl":"/-- Any finite-dimensional vector space over a locally compact field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem FiniteDimensional.proper [FiniteDimensional 𝕜 E] : ProperSpace E := by\n  have : ProperSpace 𝕜 := .of_locallyCompactSpace 𝕜\n  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun 𝕜 _ _ (finrank 𝕜 E)).symm\n  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective\n\n"}
{"name":"FiniteDimensional.proper_real","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ ProperSpace E","decl":"instance (priority := 900) FiniteDimensional.proper_real (E : Type u) [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [FiniteDimensional ℝ E] : ProperSpace E :=\n  FiniteDimensional.proper ℝ E\n\n"}
{"name":"instProperSpaceSubtypeMemSubmoduleOfCompleteSpaceOfLocallyCompactSpace","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : CompleteSpace 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : LocallyCompactSpace E\nS : Submodule 𝕜 E\n⊢ ProperSpace (Subtype fun x => Membership.mem S x)","decl":"/-- A submodule of a locally compact space over a complete field is also locally compact (and even\nproper). -/\ninstance {𝕜 E : Type*} [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [LocallyCompactSpace E] (S : Submodule 𝕜 E) :\n    ProperSpace S := by\n  nontriviality E\n  have : ProperSpace 𝕜 := .of_locallyCompact_module 𝕜 E\n  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜\n  exact FiniteDimensional.proper 𝕜 S\n\n"}
{"name":"exists_mem_frontier_infDist_compl_eq_dist","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nx : E\ns : Set E\nhx : Membership.mem s x\nhs : Ne s Set.univ\n⊢ Exists fun y => And (Membership.mem (frontier s) y) (Eq (Metric.infDist x (HasCompl.compl s)) (Dist.dist x y))","decl":"/-- If `E` is a finite dimensional normed real vector space, `x : E`, and `s` is a neighborhood of\n`x` that is not equal to the whole space, then there exists a point `y ∈ frontier s` at distance\n`Metric.infDist x sᶜ` from `x`. See also\n`IsCompact.exists_mem_frontier_infDist_compl_eq_dist`. -/\ntheorem exists_mem_frontier_infDist_compl_eq_dist {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [FiniteDimensional ℝ E] {x : E} {s : Set E} (hx : x ∈ s) (hs : s ≠ univ) :\n    ∃ y ∈ frontier s, Metric.infDist x sᶜ = dist x y := by\n  rcases Metric.exists_mem_closure_infDist_eq_dist (nonempty_compl.2 hs) x with ⟨y, hys, hyd⟩\n  rw [closure_compl] at hys\n  refine ⟨y, ⟨Metric.closedBall_infDist_compl_subset_closure hx <|\n    Metric.mem_closedBall.2 <| ge_of_eq ?_, hys⟩, hyd⟩\n  rwa [dist_comm]\n\n"}
{"name":"IsCompact.exists_mem_frontier_infDist_compl_eq_dist","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : Nontrivial E\nx : E\nK : Set E\nhK : IsCompact K\nhx : Membership.mem K x\n⊢ Exists fun y => And (Membership.mem (frontier K) y) (Eq (Metric.infDist x (HasCompl.compl K)) (Dist.dist x y))","decl":"/-- If `K` is a compact set in a nontrivial real normed space and `x ∈ K`, then there exists a point\n`y` of the boundary of `K` at distance `Metric.infDist x Kᶜ` from `x`. See also\n`exists_mem_frontier_infDist_compl_eq_dist`. -/\nnonrec theorem IsCompact.exists_mem_frontier_infDist_compl_eq_dist {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K)\n    (hx : x ∈ K) :\n    ∃ y ∈ frontier K, Metric.infDist x Kᶜ = dist x y := by\n  obtain hx' | hx' : x ∈ interior K ∪ frontier K := by\n    rw [← closure_eq_interior_union_frontier]\n    exact subset_closure hx\n  · rw [mem_interior_iff_mem_nhds, Metric.nhds_basis_closedBall.mem_iff] at hx'\n    rcases hx' with ⟨r, hr₀, hrK⟩\n    have : FiniteDimensional ℝ E :=\n      .of_isCompact_closedBall ℝ hr₀\n        (hK.of_isClosed_subset Metric.isClosed_ball hrK)\n    exact exists_mem_frontier_infDist_compl_eq_dist hx hK.ne_univ\n  · refine ⟨x, hx', ?_⟩\n    rw [frontier_eq_closure_inter_closure] at hx'\n    rw [Metric.infDist_zero_of_mem_closure hx'.2, dist_self]\n\n"}
{"name":"summable_norm_iff","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf : α → E\n⊢ Iff (Summable fun x => Norm.norm (f x)) (Summable f)","decl":"/-- In a finite dimensional vector space over `ℝ`, the series `∑ x, ‖f x‖` is unconditionally\nsummable if and only if the series `∑ x, f x` is unconditionally summable. One implication holds in\nany complete normed space, while the other holds only in finite dimensional spaces. -/\ntheorem summable_norm_iff {α E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {f : α → E} : (Summable fun x => ‖f x‖) ↔ Summable f := by\n  refine ⟨Summable.of_norm, fun hf ↦ ?_⟩\n  -- First we use a finite basis to reduce the problem to the case `E = Fin N → ℝ`\n  suffices ∀ {N : ℕ} {g : α → Fin N → ℝ}, Summable g → Summable fun x => ‖g x‖ by\n    obtain v := Module.finBasis ℝ E\n    set e := v.equivFunL\n    have H : Summable fun x => ‖e (f x)‖ := this (e.summable.2 hf)\n    refine .of_norm_bounded _ (H.mul_left ↑‖(e.symm : (Fin (finrank ℝ E) → ℝ) →L[ℝ] E)‖₊) fun i ↦ ?_\n    simpa using (e.symm : (Fin (finrank ℝ E) → ℝ) →L[ℝ] E).le_opNorm (e <| f i)\n  clear! E\n  -- Now we deal with `g : α → Fin N → ℝ`\n  intro N g hg\n  have : ∀ i, Summable fun x => ‖g x i‖ := fun i => (Pi.summable.1 hg i).abs\n  refine .of_norm_bounded _ (summable_sum fun i (_ : i ∈ Finset.univ) => this i) fun x => ?_\n  rw [norm_norm, pi_norm_le_iff_of_nonneg]\n  · refine fun i => Finset.single_le_sum (f := fun i => ‖g x i‖) (fun i _ => ?_) (Finset.mem_univ i)\n    exact norm_nonneg (g x i)\n  · exact Finset.sum_nonneg fun _ _ => norm_nonneg _\n\n"}
{"name":"Summable.norm","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf : α → E\na✝ : Summable f\n⊢ Summable fun x => Norm.norm (f x)","decl":"alias ⟨_, Summable.norm⟩ := summable_norm_iff\n\n"}
{"name":"summable_of_sum_range_norm_le","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nc : Real\nf : Nat → E\nh : ∀ (n : Nat), LE.le ((Finset.range n).sum fun i => Norm.norm (f i)) c\n⊢ Summable f","decl":"theorem summable_of_sum_range_norm_le {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {c : ℝ} {f : ℕ → E} (h : ∀ n, ∑ i ∈ Finset.range n, ‖f i‖ ≤ c) :\n    Summable f :=\n  summable_norm_iff.mp <| summable_of_sum_range_le (fun _ ↦ norm_nonneg _)  h\n\n"}
{"name":"summable_of_isBigO'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ι : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : CompleteSpace E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\ninst✝ : FiniteDimensional Real F\nf : ι → E\ng : ι → F\nhg : Summable g\nh : Asymptotics.IsBigO Filter.cofinite f g\n⊢ Summable f","decl":"theorem summable_of_isBigO' {ι E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace ℝ F] [FiniteDimensional ℝ F] {f : ι → E} {g : ι → F}\n    (hg : Summable g) (h : f =O[cofinite] g) : Summable f :=\n  summable_of_isBigO hg.norm h.norm_right\n\n"}
{"name":"Asymptotics.IsBigO.comp_summable","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ι : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : CompleteSpace F\nf : E → F\nhf : Asymptotics.IsBigO (nhds 0) f id\ng : ι → E\nhg : Summable g\n⊢ Summable (Function.comp f g)","decl":"lemma Asymptotics.IsBigO.comp_summable {ι E F : Type*}\n    [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]\n    [NormedAddCommGroup F] [CompleteSpace F]\n    {f : E → F} (hf : f =O[𝓝 0] id) {g : ι → E} (hg : Summable g) : Summable (f ∘ g) :=\n  .of_norm <| hf.comp_summable_norm hg.norm\n\n"}
{"name":"summable_of_isBigO_nat'","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : CompleteSpace E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\ninst✝ : FiniteDimensional Real F\nf : Nat → E\ng : Nat → F\nhg : Summable g\nh : Asymptotics.IsBigO Filter.atTop f g\n⊢ Summable f","decl":"theorem summable_of_isBigO_nat' {E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace ℝ F] [FiniteDimensional ℝ F] {f : ℕ → E} {g : ℕ → F}\n    (hg : Summable g) (h : f =O[atTop] g) : Summable f :=\n  summable_of_isBigO_nat hg.norm h.norm_right\n\n"}
{"name":"summable_of_isEquivalent","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf g : ι → E\nhg : Summable g\nh : Asymptotics.IsEquivalent Filter.cofinite f g\n⊢ Summable f","decl":"theorem summable_of_isEquivalent {ι E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {f : ι → E} {g : ι → E} (hg : Summable g) (h : f ~[cofinite] g) :\n    Summable f :=\n  hg.trans_sub (summable_of_isBigO' hg h.isLittleO.isBigO)\n\n"}
{"name":"summable_of_isEquivalent_nat","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf g : Nat → E\nhg : Summable g\nh : Asymptotics.IsEquivalent Filter.atTop f g\n⊢ Summable f","decl":"theorem summable_of_isEquivalent_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {f : ℕ → E} {g : ℕ → E} (hg : Summable g) (h : f ~[atTop] g) :\n    Summable f :=\n  hg.trans_sub (summable_of_isBigO_nat' hg h.isLittleO.isBigO)\n\n"}
{"name":"IsEquivalent.summable_iff","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf g : ι → E\nh : Asymptotics.IsEquivalent Filter.cofinite f g\n⊢ Iff (Summable f) (Summable g)","decl":"theorem IsEquivalent.summable_iff {ι E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {f : ι → E} {g : ι → E} (h : f ~[cofinite] g) :\n    Summable f ↔ Summable g :=\n  ⟨fun hf => summable_of_isEquivalent hf h.symm, fun hg => summable_of_isEquivalent hg h⟩\n\n"}
{"name":"IsEquivalent.summable_iff_nat","module":"Mathlib.Analysis.Normed.Module.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nf g : Nat → E\nh : Asymptotics.IsEquivalent Filter.atTop f g\n⊢ Iff (Summable f) (Summable g)","decl":"theorem IsEquivalent.summable_iff_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {f : ℕ → E} {g : ℕ → E} (h : f ~[atTop] g) : Summable f ↔ Summable g :=\n  ⟨fun hf => summable_of_isEquivalent_nat hf h.symm, fun hg => summable_of_isEquivalent_nat hg h⟩\n"}
