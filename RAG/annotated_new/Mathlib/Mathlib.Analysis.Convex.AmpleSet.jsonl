{"name":"ampleSet_univ","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\n⊢ AmpleSet Set.univ","decl":"/-- A whole vector space is ample. -/\n@[simp]\ntheorem ampleSet_univ {F : Type*} [NormedAddCommGroup F] [NormedSpace ℝ F] :\n    AmpleSet (univ : Set F) := by\n  intro x _\n  rw [connectedComponentIn_univ, PreconnectedSpace.connectedComponent_eq_univ, convexHull_univ]\n\n"}
{"name":"ampleSet_empty","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝² : AddCommGroup F\ninst✝¹ : Module Real F\ninst✝ : TopologicalSpace F\n⊢ AmpleSet EmptyCollection.emptyCollection","decl":"/-- The empty set in a vector space is ample. -/\n@[simp]\ntheorem ampleSet_empty : AmpleSet (∅ : Set F) := fun _ ↦ False.elim\n\n"}
{"name":"AmpleSet.union","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝² : AddCommGroup F\ninst✝¹ : Module Real F\ninst✝ : TopologicalSpace F\ns t : Set F\nhs : AmpleSet s\nht : AmpleSet t\n⊢ AmpleSet (Union.union s t)","decl":"/-- The union of two ample sets is ample. -/\ntheorem union {s t : Set F} (hs : AmpleSet s) (ht : AmpleSet t) : AmpleSet (s ∪ t) := by\n  intro x hx\n  rcases hx with (h | h) <;>\n  -- The connected component of `x ∈ s` in `s ∪ t` contains the connected component of `x` in `s`,\n  -- hence is also full; similarly for `t`.\n  [have hx := hs x h; have hx := ht x h] <;>\n  rw [← Set.univ_subset_iff, ← hx] <;>\n  apply convexHull_mono <;>\n  apply connectedComponentIn_mono <;>\n  [apply subset_union_left; apply subset_union_right]\n\n"}
{"name":"AmpleSet.image","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝⁵ : AddCommGroup F\ninst✝⁴ : Module Real F\ninst✝³ : TopologicalSpace F\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module Real E\ninst✝ : TopologicalSpace E\ns : Set E\nh : AmpleSet s\nL : ContinuousAffineEquiv Real E F\n⊢ AmpleSet (Set.image (⇑L) s)","decl":"/-- Images of ample sets under continuous affine equivalences are ample. -/\ntheorem image {s : Set E} (h : AmpleSet s) (L : E ≃ᵃL[ℝ] F) :\n    AmpleSet (L '' s) := forall_mem_image.mpr fun x hx ↦\n  calc (convexHull ℝ) (connectedComponentIn (L '' s) (L x))\n    _ = (convexHull ℝ) (L '' (connectedComponentIn s x)) :=\n          .symm <| congrArg _ <| L.toHomeomorph.image_connectedComponentIn hx\n    _ = L '' (convexHull ℝ (connectedComponentIn s x)) :=\n          .symm <| L.toAffineMap.image_convexHull _\n    _ = univ := by rw [h x hx, image_univ, L.surjective.range_eq]\n\n"}
{"name":"AmpleSet.image_iff","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝⁵ : AddCommGroup F\ninst✝⁴ : Module Real F\ninst✝³ : TopologicalSpace F\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module Real E\ninst✝ : TopologicalSpace E\ns : Set E\nL : ContinuousAffineEquiv Real E F\n⊢ Iff (AmpleSet (Set.image (⇑L) s)) (AmpleSet s)","decl":"/-- A set is ample iff its image under a continuous affine equivalence is. -/\ntheorem image_iff {s : Set E} (L : E ≃ᵃL[ℝ] F) :\n    AmpleSet (L '' s) ↔ AmpleSet s :=\n  ⟨fun h ↦ (L.symm_image_image s) ▸ h.image L.symm, fun h ↦ h.image L⟩\n\n"}
{"name":"AmpleSet.preimage","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝⁵ : AddCommGroup F\ninst✝⁴ : Module Real F\ninst✝³ : TopologicalSpace F\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module Real E\ninst✝ : TopologicalSpace E\ns : Set F\nh : AmpleSet s\nL : ContinuousAffineEquiv Real E F\n⊢ AmpleSet (Set.preimage (⇑L) s)","decl":"/-- Pre-images of ample sets under continuous affine equivalences are ample. -/\ntheorem preimage {s : Set F} (h : AmpleSet s) (L : E ≃ᵃL[ℝ] F) : AmpleSet (L ⁻¹' s) := by\n  rw [← L.image_symm_eq_preimage]\n  exact h.image L.symm\n\n"}
{"name":"AmpleSet.preimage_iff","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝⁵ : AddCommGroup F\ninst✝⁴ : Module Real F\ninst✝³ : TopologicalSpace F\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module Real E\ninst✝ : TopologicalSpace E\ns : Set F\nL : ContinuousAffineEquiv Real E F\n⊢ Iff (AmpleSet (Set.preimage (⇑L) s)) (AmpleSet s)","decl":"/-- A set is ample iff its pre-image under a continuous affine equivalence is. -/\ntheorem preimage_iff {s : Set F} (L : E ≃ᵃL[ℝ] F) :\n    AmpleSet (L ⁻¹' s) ↔ AmpleSet s :=\n  ⟨fun h ↦ L.image_preimage s ▸ h.image L, fun h ↦ h.preimage L⟩\n\n"}
{"name":"AmpleSet.vadd","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousAdd E\ns : Set E\nh : AmpleSet s\ny : E\n⊢ AmpleSet (HVAdd.hVAdd y s)","decl":"/-- Affine translations of ample sets are ample. -/\ntheorem vadd [ContinuousAdd E] {s : Set E} (h : AmpleSet s) {y : E} :\n    AmpleSet (y +ᵥ s) :=\n  h.image (ContinuousAffineEquiv.constVAdd ℝ E y)\n\n"}
{"name":"AmpleSet.vadd_iff","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousAdd E\ns : Set E\ny : E\n⊢ Iff (AmpleSet (HVAdd.hVAdd y s)) (AmpleSet s)","decl":"/-- A set is ample iff its affine translation is. -/\ntheorem vadd_iff [ContinuousAdd E] {s : Set E} {y : E} :\n    AmpleSet (y +ᵥ s) ↔ AmpleSet s :=\n  AmpleSet.image_iff (ContinuousAffineEquiv.constVAdd ℝ E y)\n\n"}
{"name":"AmpleSet.of_one_lt_codim","module":"Mathlib.Analysis.Convex.AmpleSet","initialProofState":"F : Type u_1\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module Real F\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousSMul Real F\nE : Submodule Real F\nhcodim : LT.lt 1 (Module.rank Real (HasQuotient.Quotient F E))\n⊢ AmpleSet (HasCompl.compl ↑E)","decl":"/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is ample. -/\ntheorem of_one_lt_codim [TopologicalAddGroup F] [ContinuousSMul ℝ F] {E : Submodule ℝ F}\n    (hcodim : 1 < Module.rank ℝ (F ⧸ E)) :\n    AmpleSet (Eᶜ : Set F) := fun x hx ↦ by\n  rw [E.connectedComponentIn_eq_self_of_one_lt_codim hcodim hx, eq_univ_iff_forall]\n  intro y\n  by_cases h : y ∈ E\n  · obtain ⟨z, hz⟩ : ∃ z, z ∉ E := by\n      rw [← not_forall, ← Submodule.eq_top_iff']\n      rintro rfl\n      simp [rank_zero_iff.2 inferInstance] at hcodim\n    refine segment_subset_convexHull ?_ ?_ (mem_segment_sub_add y z) <;>\n      simpa [sub_eq_add_neg, Submodule.add_mem_iff_right _ h]\n  · exact subset_convexHull ℝ (Eᶜ : Set F) h\n\n"}
