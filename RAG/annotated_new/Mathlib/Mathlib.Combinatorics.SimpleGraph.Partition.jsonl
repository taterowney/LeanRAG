{"name":"SimpleGraph.Partition.mk.inj","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nparts✝ : Set (Set V)\nisPartition✝ : Setoid.IsPartition parts✝\nindependent✝ : ∀ (s : Set V), Membership.mem parts✝ s → IsAntichain G.Adj s\nparts : Set (Set V)\nisPartition : Setoid.IsPartition parts\nindependent : ∀ (s : Set V), Membership.mem parts s → IsAntichain G.Adj s\nx✝ : Eq { parts := parts✝, isPartition := isPartition✝, independent := independent✝ } { parts := parts, isPartition := isPartition, independent := independent }\n⊢ Eq parts✝ parts","decl":"/-- A `Partition` of a simple graph `G` is a structure constituted by\n* `parts`: a set of subsets of the vertices `V` of `G`\n* `isPartition`: a proof that `parts` is a proper partition of `V`\n* `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices\n-/\nstructure Partition where\n  /-- `parts`: a set of subsets of the vertices `V` of `G`. -/\n  parts : Set (Set V)\n  /-- `isPartition`: a proof that `parts` is a proper partition of `V`. -/\n  isPartition : Setoid.IsPartition parts\n  /-- `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n-/\n  independent : ∀ s ∈ parts, IsAntichain G.Adj s\n\n"}
{"name":"SimpleGraph.Partition.mk.injEq","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nparts✝ : Set (Set V)\nisPartition✝ : Setoid.IsPartition parts✝\nindependent✝ : ∀ (s : Set V), Membership.mem parts✝ s → IsAntichain G.Adj s\nparts : Set (Set V)\nisPartition : Setoid.IsPartition parts\nindependent : ∀ (s : Set V), Membership.mem parts s → IsAntichain G.Adj s\n⊢ Eq (Eq { parts := parts✝, isPartition := isPartition✝, independent := independent✝ } { parts := parts, isPartition := isPartition, independent := independent }) (Eq parts✝ parts)","decl":"/-- A `Partition` of a simple graph `G` is a structure constituted by\n* `parts`: a set of subsets of the vertices `V` of `G`\n* `isPartition`: a proof that `parts` is a proper partition of `V`\n* `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices\n-/\nstructure Partition where\n  /-- `parts`: a set of subsets of the vertices `V` of `G`. -/\n  parts : Set (Set V)\n  /-- `isPartition`: a proof that `parts` is a proper partition of `V`. -/\n  isPartition : Setoid.IsPartition parts\n  /-- `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n-/\n  independent : ∀ s ∈ parts, IsAntichain G.Adj s\n\n"}
{"name":"SimpleGraph.Partition.independent","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Partition\ns : Set V\na✝ : Membership.mem self.parts s\n⊢ IsAntichain G.Adj s","decl":"/-- A `Partition` of a simple graph `G` is a structure constituted by\n* `parts`: a set of subsets of the vertices `V` of `G`\n* `isPartition`: a proof that `parts` is a proper partition of `V`\n* `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices\n-/\nstructure Partition where\n  /-- `parts`: a set of subsets of the vertices `V` of `G`. -/\n  parts : Set (Set V)\n  /-- `isPartition`: a proof that `parts` is a proper partition of `V`. -/\n  isPartition : Setoid.IsPartition parts\n  /-- `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n-/\n  independent : ∀ s ∈ parts, IsAntichain G.Adj s\n\n"}
{"name":"SimpleGraph.Partition.isPartition","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Partition\n⊢ Setoid.IsPartition self.parts","decl":"/-- A `Partition` of a simple graph `G` is a structure constituted by\n* `parts`: a set of subsets of the vertices `V` of `G`\n* `isPartition`: a proof that `parts` is a proper partition of `V`\n* `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices\n-/\nstructure Partition where\n  /-- `parts`: a set of subsets of the vertices `V` of `G`. -/\n  parts : Set (Set V)\n  /-- `isPartition`: a proof that `parts` is a proper partition of `V`. -/\n  isPartition : Setoid.IsPartition parts\n  /-- `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n-/\n  independent : ∀ s ∈ parts, IsAntichain G.Adj s\n\n"}
{"name":"SimpleGraph.Partition.mk.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : SizeOf V\nparts : Set (Set V)\nisPartition : Setoid.IsPartition parts\nindependent : ∀ (s : Set V), Membership.mem parts s → IsAntichain G.Adj s\n⊢ Eq (SizeOf.sizeOf { parts := parts, isPartition := isPartition, independent := independent }) (HAdd.hAdd 1 (SizeOf.sizeOf isPartition))","decl":"/-- A `Partition` of a simple graph `G` is a structure constituted by\n* `parts`: a set of subsets of the vertices `V` of `G`\n* `isPartition`: a proof that `parts` is a proper partition of `V`\n* `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices\n-/\nstructure Partition where\n  /-- `parts`: a set of subsets of the vertices `V` of `G`. -/\n  parts : Set (Set V)\n  /-- `isPartition`: a proof that `parts` is a proper partition of `V`. -/\n  isPartition : Setoid.IsPartition parts\n  /-- `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n-/\n  independent : ∀ s ∈ parts, IsAntichain G.Adj s\n\n"}
{"name":"SimpleGraph.Partition.partOfVertex_mem","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\n⊢ Membership.mem P.parts (P.partOfVertex v)","decl":"theorem partOfVertex_mem (v : V) : P.partOfVertex v ∈ P.parts := by\n  obtain ⟨h, -⟩ := (P.isPartition.2 v).choose_spec.1\n  exact h\n\n"}
{"name":"SimpleGraph.Partition.mem_partOfVertex","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nP : G.Partition\nv : V\n⊢ Membership.mem (P.partOfVertex v) v","decl":"theorem mem_partOfVertex (v : V) : v ∈ P.partOfVertex v := by\n  obtain ⟨⟨_, h⟩, _⟩ := (P.isPartition.2 v).choose_spec\n  exact h\n\n"}
{"name":"SimpleGraph.Partition.partOfVertex_ne_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nP : G.Partition\nv w : V\nh : G.Adj v w\n⊢ Ne (P.partOfVertex v) (P.partOfVertex w)","decl":"theorem partOfVertex_ne_of_adj {v w : V} (h : G.Adj v w) : P.partOfVertex v ≠ P.partOfVertex w := by\n  intro hn\n  have hw := P.mem_partOfVertex w\n  rw [← hn] at hw\n  exact P.independent _ (P.partOfVertex_mem v) (P.mem_partOfVertex v) hw (G.ne_of_adj h) h\n\n"}
{"name":"SimpleGraph.Partition.colorable","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nP : G.Partition\ninst✝ : Fintype ↑P.parts\n⊢ G.Colorable (Fintype.card ↑P.parts)","decl":"theorem colorable [Fintype P.parts] : G.Colorable (Fintype.card P.parts) :=\n  P.toColoring.colorable\n\n"}
{"name":"SimpleGraph.Coloring.toPartition_parts","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nα : Type v\nC : G.Coloring α\n⊢ Eq C.toPartition.parts C.colorClasses","decl":"/-- Creates a partition from a coloring. -/\n@[simps]\ndef Coloring.toPartition {α : Type v} (C : G.Coloring α) : G.Partition where\n  parts := C.colorClasses\n  isPartition := C.colorClasses_isPartition\n  independent := by\n    rintro s ⟨c, rfl⟩\n    apply C.color_classes_independent\n\n"}
{"name":"SimpleGraph.instInhabitedPartition_default","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Inhabited.default G.selfColoring.toPartition","decl":"/-- The partition where every vertex is in its own part. -/\n@[simps]\ninstance : Inhabited (Partition G) := ⟨G.selfColoring.toPartition⟩\n\n"}
{"name":"SimpleGraph.partitionable_iff_colorable","module":"Mathlib.Combinatorics.SimpleGraph.Partition","initialProofState":"V : Type u\nG : SimpleGraph V\nn : Nat\n⊢ Iff (G.Partitionable n) (G.Colorable n)","decl":"theorem partitionable_iff_colorable {n : ℕ} : G.Partitionable n ↔ G.Colorable n := by\n  constructor\n  · rintro ⟨P, hf, hc⟩\n    have : Fintype P.parts := hf.fintype\n    rw [Set.Finite.card_toFinset hf] at hc\n    apply P.colorable.mono hc\n  · rintro ⟨C⟩\n    refine ⟨C.toPartition, C.colorClasses_finite, le_trans ?_ (Fintype.card_fin n).le⟩\n    generalize_proofs h\n    change Set.Finite (Coloring.colorClasses C) at h\n    have : Fintype C.colorClasses := C.colorClasses_finite.fintype\n    rw [h.card_toFinset]\n    exact C.card_colorClasses_le\n\n"}
