{"name":"FractionalIdeal.absNorm_div_norm_eq_absNorm_div_norm","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\na : Subtype fun x => Membership.mem (nonZeroDivisors R) x\nI₀ : Ideal R\nh : Eq (HSMul.hSMul a ↑I) (Submodule.map (Algebra.linearMap R K) I₀)\n⊢ Eq (HDiv.hDiv ↑(Ideal.absNorm I.num) ↑(abs ((Algebra.norm Int) ↑I.den))) (HDiv.hDiv ↑(Ideal.absNorm I₀) ↑(abs ((Algebra.norm Int) ↑a)))","decl":"theorem absNorm_div_norm_eq_absNorm_div_norm {I : FractionalIdeal R⁰ K} (a : R⁰) (I₀ : Ideal R)\n    (h : a • (I : Submodule R K) = Submodule.map (Algebra.linearMap R K) I₀) :\n    (Ideal.absNorm I.num : ℚ) / |Algebra.norm ℤ (I.den : R)| =\n      (Ideal.absNorm I₀ : ℚ) / |Algebra.norm ℤ (a : R)| := by\n  rw [div_eq_div_iff]\n  · replace h := congr_arg (I.den • ·) h\n    have h' := congr_arg (a • ·) (den_mul_self_eq_num I)\n    dsimp only at h h'\n    rw [smul_comm] at h\n    rw [h, Submonoid.smul_def, Submonoid.smul_def, ← Submodule.ideal_span_singleton_smul,\n      ← Submodule.ideal_span_singleton_smul, ← Submodule.map_smul'', ← Submodule.map_smul'',\n      (LinearMap.map_injective ?_).eq_iff, smul_eq_mul, smul_eq_mul] at h'\n    · simp_rw [← Int.cast_natAbs, ← Nat.cast_mul, ← Ideal.absNorm_span_singleton]\n      rw [← _root_.map_mul, ← _root_.map_mul, mul_comm, ← h', mul_comm]\n    · exact LinearMap.ker_eq_bot.mpr (IsFractionRing.injective R K)\n  all_goals simp [Algebra.norm_eq_zero_iff]\n\n"}
{"name":"FractionalIdeal.absNorm_eq","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.absNorm I) (HDiv.hDiv ↑(Ideal.absNorm I.num) ↑(abs ((Algebra.norm Int) ↑I.den)))","decl":"theorem absNorm_eq (I : FractionalIdeal R⁰ K) :\n    absNorm I = (Ideal.absNorm I.num : ℚ) / |Algebra.norm ℤ (I.den : R)| := rfl\n\n"}
{"name":"FractionalIdeal.absNorm_eq'","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\na : Subtype fun x => Membership.mem (nonZeroDivisors R) x\nI₀ : Ideal R\nh : Eq (HSMul.hSMul a ↑I) (Submodule.map (Algebra.linearMap R K) I₀)\n⊢ Eq (FractionalIdeal.absNorm I) (HDiv.hDiv ↑(Ideal.absNorm I₀) ↑(abs ((Algebra.norm Int) ↑a)))","decl":"theorem absNorm_eq' {I : FractionalIdeal R⁰ K} (a : R⁰) (I₀ : Ideal R)\n    (h : a • (I : Submodule R K) = Submodule.map (Algebra.linearMap R K) I₀) :\n    absNorm I = (Ideal.absNorm I₀ : ℚ) / |Algebra.norm ℤ (a : R)| := by\n  rw [absNorm, ← absNorm_div_norm_eq_absNorm_div_norm a I₀ h, MonoidWithZeroHom.coe_mk,\n    ZeroHom.coe_mk]\n\n"}
{"name":"FractionalIdeal.absNorm_nonneg","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ LE.le 0 (FractionalIdeal.absNorm I)","decl":"theorem absNorm_nonneg (I : FractionalIdeal R⁰ K) : 0 ≤ absNorm I := by dsimp [absNorm]; positivity\n\n"}
{"name":"FractionalIdeal.absNorm_bot","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (FractionalIdeal.absNorm Bot.bot) 0","decl":"theorem absNorm_bot : absNorm (⊥ : FractionalIdeal R⁰ K) = 0 := absNorm.map_zero'\n\n"}
{"name":"FractionalIdeal.absNorm_one","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (FractionalIdeal.absNorm 1) 1","decl":"theorem absNorm_one : absNorm (1 : FractionalIdeal R⁰ K) = 1 := by convert absNorm.map_one'\n\n"}
{"name":"FractionalIdeal.absNorm_eq_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\ninst✝⁶ : IsDedekindDomain R\ninst✝⁵ : Module.Free Int R\ninst✝⁴ : Module.Finite Int R\nK : Type u_2\ninst✝³ : CommRing K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : NoZeroDivisors K\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Iff (Eq (FractionalIdeal.absNorm I) 0) (Eq I 0)","decl":"theorem absNorm_eq_zero_iff [NoZeroDivisors K] {I : FractionalIdeal R⁰ K} :\n    absNorm I = 0 ↔ I = 0 := by\n  refine ⟨fun h ↦ zero_of_num_eq_bot zero_not_mem_nonZeroDivisors ?_, fun h ↦ h ▸ absNorm_bot⟩\n  rw [absNorm_eq, div_eq_zero_iff] at h\n  refine Ideal.absNorm_eq_zero_iff.mp <| Nat.cast_eq_zero.mp <| h.resolve_right ?_\n  simp [Algebra.norm_eq_zero_iff]\n\n"}
{"name":"FractionalIdeal.coeIdeal_absNorm","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Module.Free Int R\ninst✝³ : Module.Finite Int R\nK : Type u_2\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI₀ : Ideal R\n⊢ Eq (FractionalIdeal.absNorm ↑I₀) ↑(Ideal.absNorm I₀)","decl":"theorem coeIdeal_absNorm (I₀ : Ideal R) :\n    absNorm (I₀ : FractionalIdeal R⁰ K) = Ideal.absNorm I₀ := by\n  rw [absNorm_eq' 1 I₀ (by rw [one_smul]; rfl), OneMemClass.coe_one, _root_.map_one, abs_one,\n    Int.cast_one, _root_.div_one]\n\n"}
{"name":"FractionalIdeal.abs_det_basis_change","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : IsDedekindDomain R\ninst✝⁹ : Module.Free Int R\ninst✝⁸ : Module.Finite Int R\nK : Type u_2\ninst✝⁷ : CommRing K\ninst✝⁶ : Algebra R K\ninst✝⁵ : IsFractionRing R K\ninst✝⁴ : IsLocalization (Algebra.algebraMapSubmonoid R (nonZeroDivisors Int)) K\ninst✝³ : Algebra Rat K\ninst✝² : NoZeroDivisors K\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι Int R\nI : FractionalIdeal (nonZeroDivisors R) K\nbI : Basis ι Int (Subtype fun x => Membership.mem (↑I) x)\n⊢ Eq (abs ((Basis.localizationLocalization Rat (nonZeroDivisors Int) K b).det (Function.comp Subtype.val ⇑bI))) (FractionalIdeal.absNorm I)","decl":"theorem abs_det_basis_change [NoZeroDivisors K] {ι : Type*} [Fintype ι]\n    [DecidableEq ι] (b : Basis ι ℤ R) (I : FractionalIdeal R⁰ K) (bI : Basis ι ℤ I) :\n    |(b.localizationLocalization ℚ ℤ⁰ K).det ((↑) ∘ bI)| = absNorm I := by\n  have := IsFractionRing.nontrivial R K\n  let b₀ : Basis ι ℚ K := b.localizationLocalization ℚ ℤ⁰ K\n  let bI.num : Basis ι ℤ I.num := bI.map\n      ((equivNum (nonZeroDivisors.coe_ne_zero _)).restrictScalars ℤ)\n  rw [absNorm_eq, ← Ideal.natAbs_det_basis_change b I.num bI.num, Int.cast_natAbs, Int.cast_abs,\n    Int.cast_abs, Basis.det_apply, Basis.det_apply]\n  change _ = |algebraMap ℤ ℚ _| / _\n  rw [RingHom.map_det, show RingHom.mapMatrix (algebraMap ℤ ℚ) (b.toMatrix ((↑) ∘ bI.num)) =\n      b₀.toMatrix ((algebraMap R K (den I : R)) • ((↑) ∘ bI)) by\n    ext : 2\n    simp_rw [bI.num, RingHom.mapMatrix_apply, Matrix.map_apply, Basis.toMatrix_apply,\n      ← Basis.localizationLocalization_repr_algebraMap ℚ ℤ⁰ K, Function.comp_apply,\n      Basis.map_apply, LinearEquiv.restrictScalars_apply, equivNum_apply, Submonoid.smul_def,\n      Algebra.smul_def]\n    rfl]\n  rw [Basis.toMatrix_smul, Matrix.det_mul, abs_mul, ← Algebra.norm_eq_matrix_det,\n    Algebra.norm_localization ℤ ℤ⁰, show (Algebra.norm ℤ (den I : R) : ℚ) =\n    algebraMap ℤ ℚ (Algebra.norm ℤ (den I : R)) by rfl, mul_div_assoc, mul_div_cancel₀ _ (by\n    rw [ne_eq, abs_eq_zero, IsFractionRing.to_map_eq_zero_iff, Algebra.norm_eq_zero_iff_of_basis b]\n    exact nonZeroDivisors.coe_ne_zero _)]\n\n"}
{"name":"FractionalIdeal.absNorm_span_singleton","module":"Mathlib.RingTheory.FractionalIdeal.Norm","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\ninst✝⁸ : IsDedekindDomain R\ninst✝⁷ : Module.Free Int R\ninst✝⁶ : Module.Finite Int R\nK : Type u_2\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra R K\ninst✝³ : IsFractionRing R K\ninst✝² : IsLocalization (Algebra.algebraMapSubmonoid R (nonZeroDivisors Int)) K\ninst✝¹ : Algebra Rat K\ninst✝ : Module.Finite Rat K\nx : K\n⊢ Eq (FractionalIdeal.absNorm (FractionalIdeal.spanSingleton (nonZeroDivisors R) x)) (abs ((Algebra.norm Rat) x))","decl":"variable (R) in\n@[simp]\ntheorem absNorm_span_singleton [Module.Finite ℚ K] (x : K) :\n    absNorm (spanSingleton R⁰ x) = |(Algebra.norm ℚ x)| := by\n  have : IsDomain K := IsFractionRing.isDomain R\n  obtain ⟨d, ⟨r, hr⟩⟩ := IsLocalization.exists_integer_multiple R⁰ x\n  rw [absNorm_eq' d (Ideal.span {r})]\n  · rw [Ideal.absNorm_span_singleton]\n    simp_rw [Int.cast_natAbs, Int.cast_abs, show ((Algebra.norm ℤ _) : ℚ) = algebraMap ℤ ℚ\n      (Algebra.norm ℤ _) by rfl, ← Algebra.norm_localization ℤ ℤ⁰ (Sₘ := K) _]\n    rw [hr, Algebra.smul_def, _root_.map_mul, abs_mul, mul_div_assoc, mul_div_cancel₀ _ (by\n      rw [ne_eq, abs_eq_zero, Algebra.norm_eq_zero_iff, IsFractionRing.to_map_eq_zero_iff]\n      exact nonZeroDivisors.coe_ne_zero _)]\n  · ext\n    simp_rw [← SetLike.mem_coe, Submodule.coe_pointwise_smul, Set.mem_smul_set, SetLike.mem_coe,\n      mem_coe, mem_spanSingleton, Submodule.mem_map, Algebra.linearMap_apply, Submonoid.smul_def,\n      Ideal.mem_span_singleton', exists_exists_eq_and, _root_.map_mul, hr, ← Algebra.smul_def,\n      smul_comm (d : R)]\n\n"}
