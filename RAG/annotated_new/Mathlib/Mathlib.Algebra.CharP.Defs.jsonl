{"name":"CharP.cast_eq_zero_iff'","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np : Nat\nself : CharP R p\nx : Nat\n⊢ Iff (Eq (↑x) 0) (Dvd.dvd p x)","decl":"/-- The generator of the kernel of the unique homomorphism ℕ → R for a semiring R.\n\n*Warning*: for a semiring `R`, `CharP R 0` and `CharZero R` need not coincide.\n* `CharP R 0` asks that only `0 : ℕ` maps to `0 : R` under the map `ℕ → R`;\n* `CharZero R` requires an injection `ℕ ↪ R`.\n\nFor instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that\n`CharZero {0, 1}` does not hold and yet `CharP {0, 1} 0` does.\nThis example is formalized in `Counterexamples/CharPZeroNeCharZero.lean`.\n-/\n@[mk_iff]\nclass _root_.CharP : Prop where\n  cast_eq_zero_iff' : ∀ x : ℕ, (x : R) = 0 ↔ p ∣ x\n\n"}
{"name":"charP_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np : Nat\n⊢ Iff (CharP R p) (∀ (x : Nat), Iff (Eq (↑x) 0) (Dvd.dvd p x))","decl":"/-- The generator of the kernel of the unique homomorphism ℕ → R for a semiring R.\n\n*Warning*: for a semiring `R`, `CharP R 0` and `CharZero R` need not coincide.\n* `CharP R 0` asks that only `0 : ℕ` maps to `0 : R` under the map `ℕ → R`;\n* `CharZero R` requires an injection `ℕ ↪ R`.\n\nFor instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that\n`CharZero {0, 1}` does not hold and yet `CharP {0, 1} 0` does.\nThis example is formalized in `Counterexamples/CharPZeroNeCharZero.lean`.\n-/\n@[mk_iff]\nclass _root_.CharP : Prop where\n  cast_eq_zero_iff' : ∀ x : ℕ, (x : R) = 0 ↔ p ∣ x\n\n"}
{"name":"CharP.cast_eq_zero_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\na : Nat\n⊢ Iff (Eq (↑a) 0) (Dvd.dvd p a)","decl":"lemma cast_eq_zero_iff (a : ℕ) : (a : R) = 0 ↔ p ∣ a := cast_eq_zero_iff' a\n\n"}
{"name":"CharP.congr","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\nq : Nat\nh : Eq p q\n⊢ CharP R q","decl":"variable {R} in\nlemma congr {q : ℕ} (h : p = q) : CharP R q := h ▸ ‹CharP R p›\n\n"}
{"name":"CharP.natCast_eq_natCast'","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\na b : Nat\nh : p.ModEq a b\n⊢ Eq ↑a ↑b","decl":"lemma natCast_eq_natCast' (h : a ≡ b [MOD p]) : (a : R) = b := by\n  wlog hle : a ≤ b\n  · exact (this R p h.symm (le_of_not_le hle)).symm\n  rw [Nat.modEq_iff_dvd' hle] at h\n  rw [← Nat.sub_add_cancel hle, Nat.cast_add, (cast_eq_zero_iff R p _).mpr h, zero_add]\n\n"}
{"name":"CharP.cast_eq_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\n⊢ Eq (↑p) 0","decl":"@[simp] lemma cast_eq_zero : (p : R) = 0 := (cast_eq_zero_iff R p p).2 dvd_rfl\n\n-- TODO: This lemma needs to be `@[simp]` for confluence in the presence of `CharP.cast_eq_zero` and\n-- `Nat.cast_ofNat`, but with `no_index` on its entire LHS, it matches literally every expression so\n-- is too expensive. If https://github.com/leanprover/lean4/issues/2867 is fixed in a performant way, this can be made `@[simp]`.\n--\n-- @[simp]\n"}
{"name":"CharP.ofNat_eq_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : AddMonoidWithOne R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : p.AtLeastTwo\n⊢ Eq (OfNat.ofNat p) 0","decl":"lemma ofNat_eq_zero [p.AtLeastTwo] : (ofNat(p) : R) = 0 := cast_eq_zero R p\n\n"}
{"name":"CharP.natCast_eq_natCast_mod","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\na : Nat\n⊢ Eq ↑a ↑(HMod.hMod a p)","decl":"lemma natCast_eq_natCast_mod (a : ℕ) : (a : R) = a % p :=\n  natCast_eq_natCast' R p (Nat.mod_modEq a p).symm\n\n"}
{"name":"CharP.eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np q : Nat\n_hp : CharP R p\n_hq : CharP R q\n⊢ Eq p q","decl":"lemma eq {p q : ℕ} (_hp : CharP R p) (_hq : CharP R q) : p = q :=\n  Nat.dvd_antisymm ((cast_eq_zero_iff R p q).1 (cast_eq_zero _ _))\n    ((cast_eq_zero_iff R q p).1 (cast_eq_zero _ _))\n\n"}
{"name":"CharP.ofCharZero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharZero R\n⊢ CharP R 0","decl":"instance ofCharZero [CharZero R] : CharP R 0 where\n  cast_eq_zero_iff' x := by rw [zero_dvd_iff, ← Nat.cast_zero, Nat.cast_inj]\n\n"}
{"name":"CharP.natCast_eq_natCast","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : AddMonoidWithOne R\np : Nat\ninst✝¹ : CharP R p\na b : Nat\ninst✝ : IsRightCancelAdd R\n⊢ Iff (Eq ↑a ↑b) (p.ModEq a b)","decl":"lemma natCast_eq_natCast : (a : R) = b ↔ a ≡ b [MOD p] := by\n  wlog hle : a ≤ b\n  · rw [eq_comm, this R p (le_of_not_le hle), Nat.ModEq.comm]\n  rw [Nat.modEq_iff_dvd' hle, ← cast_eq_zero_iff R p (b - a),\n    ← add_right_cancel_iff (G := R) (a := a) (b := b - a), zero_add, ← Nat.cast_add,\n    Nat.sub_add_cancel hle, eq_comm]\n\n"}
{"name":"CharP.intCast_eq_zero_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddGroupWithOne R\np : Nat\ninst✝ : CharP R p\na : Int\n⊢ Iff (Eq (↑a) 0) (Dvd.dvd (↑p) a)","decl":"lemma intCast_eq_zero_iff (a : ℤ) : (a : R) = 0 ↔ (p : ℤ) ∣ a := by\n  rcases lt_trichotomy a 0 with (h | rfl | h)\n  · rw [← neg_eq_zero, ← Int.cast_neg, ← Int.dvd_neg]\n    lift -a to ℕ using neg_nonneg.mpr (le_of_lt h) with b\n    rw [Int.cast_natCast, CharP.cast_eq_zero_iff R p, Int.natCast_dvd_natCast]\n  · simp only [Int.cast_zero, eq_self_iff_true, Int.dvd_zero]\n  · lift a to ℕ using le_of_lt h with b\n    rw [Int.cast_natCast, CharP.cast_eq_zero_iff R p, Int.natCast_dvd_natCast]\n\n"}
{"name":"CharP.intCast_eq_intCast","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddGroupWithOne R\np : Nat\ninst✝ : CharP R p\na b : Int\n⊢ Iff (Eq ↑a ↑b) ((↑p).ModEq a b)","decl":"lemma intCast_eq_intCast : (a : R) = b ↔ a ≡ b [ZMOD p] := by\n  rw [eq_comm, ← sub_eq_zero, ← Int.cast_sub, CharP.intCast_eq_zero_iff R p, Int.modEq_iff_dvd]\n\n"}
{"name":"CharP.intCast_eq_intCast_mod","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddGroupWithOne R\np : Nat\ninst✝ : CharP R p\na : Int\n⊢ Eq ↑a ↑(HMod.hMod a ↑p)","decl":"lemma intCast_eq_intCast_mod : (a : R) = a % (p : ℤ) :=\n  (CharP.intCast_eq_intCast R p).mpr (Int.mod_modEq a p).symm\n\n"}
{"name":"CharP.charP_to_charZero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddGroupWithOne R\ninst✝ : CharP R 0\n⊢ CharZero R","decl":"lemma charP_to_charZero [CharP R 0] : CharZero R :=\n  charZero_of_inj_zero fun n h0 => eq_zero_of_zero_dvd ((cast_eq_zero_iff R 0 n).mp h0)\n\n"}
{"name":"CharP.charP_zero_iff_charZero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddGroupWithOne R\n⊢ Iff (CharP R 0) (CharZero R)","decl":"lemma charP_zero_iff_charZero : CharP R 0 ↔ CharZero R :=\n  ⟨fun _ ↦ charP_to_charZero R, fun _ ↦ ofCharZero R⟩\n\n"}
{"name":"CharP.exists","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\n⊢ Exists fun p => CharP R p","decl":"lemma «exists» : ∃ p, CharP R p :=\n  letI := Classical.decEq R\n  by_cases\n    (fun H : ∀ p : ℕ, (p : R) = 0 → p = 0 =>\n      ⟨0, ⟨fun x => by rw [zero_dvd_iff]; exact ⟨H x, by rintro rfl; simp⟩⟩⟩)\n    fun H =>\n    ⟨Nat.find (not_forall.1 H),\n      ⟨fun x =>\n        ⟨fun H1 =>\n          Nat.dvd_of_mod_eq_zero\n            (by_contradiction fun H2 =>\n              Nat.find_min (not_forall.1 H)\n                (Nat.mod_lt x <|\n                  Nat.pos_of_ne_zero <| not_of_not_imp <| Nat.find_spec (not_forall.1 H))\n                (not_imp_of_and_not\n                  ⟨by\n                    rwa [← Nat.mod_add_div x (Nat.find (not_forall.1 H)), Nat.cast_add,\n                      Nat.cast_mul,\n                      of_not_not (not_not_of_not_imp <| Nat.find_spec (not_forall.1 H)),\n                      zero_mul, add_zero] at H1,\n                    H2⟩)),\n          fun H1 => by\n          rw [← Nat.mul_div_cancel' H1, Nat.cast_mul,\n            of_not_not (not_not_of_not_imp <| Nat.find_spec (not_forall.1 H)),\n            zero_mul]⟩⟩⟩\n\n"}
{"name":"CharP.existsUnique","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\n⊢ ExistsUnique fun p => CharP R p","decl":"lemma existsUnique : ∃! p, CharP R p :=\n  let ⟨c, H⟩ := CharP.exists R\n  ⟨c, H, fun _y H2 => CharP.eq R H2 H⟩\n\n"}
{"name":"CharP.exists_unique","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\n⊢ ExistsUnique fun p => CharP R p","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique := existsUnique\n\n"}
{"name":"ringChar.spec","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nx : Nat\n⊢ Iff (Eq (↑x) 0) (Dvd.dvd (ringChar R) x)","decl":"lemma spec : ∀ x : ℕ, (x : R) = 0 ↔ ringChar R ∣ x := by\n  letI : CharP R (ringChar R) := (Classical.choose_spec (CharP.existsUnique R)).1\n  exact CharP.cast_eq_zero_iff R (ringChar R)\n\n"}
{"name":"ringChar.eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nC : CharP R p\n⊢ Eq (ringChar R) p","decl":"lemma eq (p : ℕ) [C : CharP R p] : ringChar R = p :=\n  ((Classical.choose_spec (CharP.existsUnique R)).2 p C).symm\n\n"}
{"name":"ringChar.charP","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\n⊢ CharP R (ringChar R)","decl":"instance charP : CharP R (ringChar R) :=\n  ⟨spec R⟩\n\n"}
{"name":"ringChar.of_eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nh : Eq (ringChar R) p\n⊢ CharP R p","decl":"lemma of_eq {p : ℕ} (h : ringChar R = p) : CharP R p :=\n  CharP.congr (ringChar R) h\n\n"}
{"name":"ringChar.eq_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\n⊢ Iff (Eq (ringChar R) p) (CharP R p)","decl":"lemma eq_iff {p : ℕ} : ringChar R = p ↔ CharP R p :=\n  ⟨of_eq, @eq R _ p⟩\n\n"}
{"name":"ringChar.dvd","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nx : Nat\nhx : Eq (↑x) 0\n⊢ Dvd.dvd (ringChar R) x","decl":"lemma dvd {x : ℕ} (hx : (x : R) = 0) : ringChar R ∣ x :=\n  (spec R x).1 hx\n\n"}
{"name":"ringChar.eq_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : CharZero R\n⊢ Eq (ringChar R) 0","decl":"@[simp]\nlemma eq_zero [CharZero R] : ringChar R = 0 :=\n  eq R 0\n\n"}
{"name":"ringChar.Nat.cast_ringChar","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑(ringChar R)) 0","decl":"lemma Nat.cast_ringChar : (ringChar R : R) = 0 := by rw [ringChar.spec]\n\n"}
{"name":"CharP.neg_one_ne_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : Ring R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : Fact (LT.lt 2 p)\n⊢ Ne (-1) 1","decl":"lemma CharP.neg_one_ne_one [Ring R] (p : ℕ) [CharP R p] [Fact (2 < p)] : (-1 : R) ≠ (1 : R) := by\n  rw [ne_comm, ← sub_ne_zero, sub_neg_eq_add, one_add_one_eq_two, ← Nat.cast_two, Ne,\n    CharP.cast_eq_zero_iff R p 2]\n  exact fun h ↦ (Fact.out : 2 < p).not_le <| Nat.le_of_dvd Nat.zero_lt_two h\n\n"}
{"name":"CharP.cast_eq_mod","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocRing R\np : Nat\ninst✝ : CharP R p\nk : Nat\n⊢ Eq ↑k ↑(HMod.hMod k p)","decl":"lemma cast_eq_mod (p : ℕ) [CharP R p] (k : ℕ) : (k : R) = (k % p : ℕ) :=\n  calc\n    (k : R) = ↑(k % p + p * (k / p)) := by rw [Nat.mod_add_div]\n    _ = ↑(k % p) := by simp [cast_eq_zero]\n\n"}
{"name":"CharP.ringChar_zero_iff_CharZero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\n⊢ Iff (Eq (ringChar R) 0) (CharZero R)","decl":"lemma ringChar_zero_iff_CharZero : ringChar R = 0 ↔ CharZero R := by\n  rw [ringChar.eq_iff, charP_zero_iff_charZero]\n\n"}
{"name":"CharP.char_ne_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\np : Nat\nhc : CharP R p\n⊢ Ne p 1","decl":"lemma char_ne_one [Nontrivial R] (p : ℕ) [hc : CharP R p] : p ≠ 1 := fun hp : p = 1 =>\n  have : (1 : R) = 0 := by simpa using (cast_eq_zero_iff R p 1).mpr (hp ▸ dvd_refl p)\n  absurd this one_ne_zero\n\n"}
{"name":"CharP.char_is_prime_of_two_le","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : NonAssocSemiring R\ninst✝¹ : NoZeroDivisors R\np : Nat\ninst✝ : CharP R p\nhp : LE.le 2 p\n⊢ Nat.Prime p","decl":"lemma char_is_prime_of_two_le (p : ℕ) [CharP R p] (hp : 2 ≤ p) : Nat.Prime p :=\n  suffices ∀ (d) (_ : d ∣ p), d = 1 ∨ d = p from Nat.prime_def.mpr ⟨hp, this⟩\n  fun (d : ℕ) (hdvd : ∃ e, p = d * e) =>\n  let ⟨e, hmul⟩ := hdvd\n  have : (p : R) = 0 := (cast_eq_zero_iff R p p).mpr (dvd_refl p)\n  have : (d : R) * e = 0 := @Nat.cast_mul R _ d e ▸ hmul ▸ this\n  Or.elim (eq_zero_or_eq_zero_of_mul_eq_zero this)\n    (fun hd : (d : R) = 0 =>\n      have : p ∣ d := (cast_eq_zero_iff R p d).mp hd\n      show d = 1 ∨ d = p from Or.inr (this.antisymm' ⟨e, hmul⟩))\n    fun he : (e : R) = 0 =>\n    have : p ∣ e := (cast_eq_zero_iff R p e).mp he\n    have : e ∣ p := dvd_of_mul_left_eq d (Eq.symm hmul)\n    have : e = p := ‹e ∣ p›.antisymm ‹p ∣ e›\n    have h₀ : 0 < p := by omega\n    have : d * p = 1 * p := by rw [‹e = p›] at hmul; rw [one_mul]; exact Eq.symm hmul\n    show d = 1 ∨ d = p from Or.inl (mul_right_cancel₀ h₀.ne' this)\n\n"}
{"name":"CharP.char_is_prime_or_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : NonAssocSemiring R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\np : Nat\nhc : CharP R p\n⊢ Or (Nat.Prime p) (Eq p 0)","decl":"lemma char_is_prime_or_zero (p : ℕ) [hc : CharP R p] : Nat.Prime p ∨ p = 0 :=\n  match p, hc with\n  | 0, _ => Or.inr rfl\n  | 1, hc => absurd (Eq.refl (1 : ℕ)) (@char_ne_one R _ _ (1 : ℕ) hc)\n  | m + 2, hc => Or.inl (@char_is_prime_of_two_le R _ _ (m + 2) hc (Nat.le_add_left 2 m))\n\n"}
{"name":"CharP.char_prime_of_ne_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝³ : NonAssocSemiring R\ninst✝² : NoZeroDivisors R\ninst✝¹ : Nontrivial R\np : Nat\ninst✝ : CharP R p\nhp : Ne p 0\n⊢ Nat.Prime p","decl":"/-- The characteristic is prime if it is non-zero. -/\nlemma char_prime_of_ne_zero {p : ℕ} [CharP R p] (hp : p ≠ 0) : p.Prime :=\n  (CharP.char_is_prime_or_zero R p).resolve_right hp\n\n"}
{"name":"CharP.exists'","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_2\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Or (CharZero R) (Exists fun p => And (Fact (Nat.Prime p)) (CharP R p))","decl":"lemma exists' (R : Type*) [NonAssocRing R] [NoZeroDivisors R] [Nontrivial R] :\n    CharZero R ∨ ∃ p : ℕ, Fact p.Prime ∧ CharP R p := by\n  obtain ⟨p, hchar⟩ := CharP.exists R\n  rcases char_is_prime_or_zero R p with h | rfl\n  exacts [Or.inr ⟨p, Fact.mk h, hchar⟩, Or.inl (charP_to_charZero R)]\n\n"}
{"name":"CharP.char_is_prime_of_pos","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : NonAssocSemiring R\ninst✝³ : NoZeroDivisors R\ninst✝² : Nontrivial R\np : Nat\ninst✝¹ : NeZero p\ninst✝ : CharP R p\n⊢ Fact (Nat.Prime p)","decl":"lemma char_is_prime_of_pos (p : ℕ) [NeZero p] [CharP R p] : Fact p.Prime :=\n  ⟨(CharP.char_is_prime_or_zero R _).resolve_right <| NeZero.ne p⟩\n\n"}
{"name":"CharP.CharOne.subsingleton","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : CharP R 1\n⊢ Subsingleton R","decl":"lemma CharOne.subsingleton [CharP R 1] : Subsingleton R :=\n  Subsingleton.intro <|\n    suffices ∀ r : R, r = 0 from fun a b => show a = b by rw [this a, this b]\n    fun r =>\n    calc\n      r = 1 * r := by rw [one_mul]\n      _ = (1 : ℕ) * r := by rw [Nat.cast_one]\n      _ = 0 * r := by rw [CharP.cast_eq_zero]\n      _ = 0 := by rw [zero_mul]\n\n"}
{"name":"CharP.false_of_nontrivial_of_char_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : NonAssocSemiring R\ninst✝¹ : Nontrivial R\ninst✝ : CharP R 1\n⊢ False","decl":"lemma false_of_nontrivial_of_char_one [Nontrivial R] [CharP R 1] : False := by\n  have : Subsingleton R := CharOne.subsingleton\n  exact false_of_nontrivial_of_subsingleton R\n\n"}
{"name":"CharP.ringChar_ne_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\n⊢ Ne (ringChar R) 1","decl":"lemma ringChar_ne_one [Nontrivial R] : ringChar R ≠ 1 := by\n  intro h\n  apply zero_ne_one' R\n  symm\n  rw [← Nat.cast_one, ringChar.spec, h]\n\n"}
{"name":"CharP.nontrivial_of_char_ne_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nv : Nat\nhv : Ne v 1\nhr : CharP R v\n⊢ Nontrivial R","decl":"lemma nontrivial_of_char_ne_one {v : ℕ} (hv : v ≠ 1) [hr : CharP R v] : Nontrivial R :=\n  ⟨⟨(1 : ℕ), 0, fun h =>\n      hv <| by rwa [CharP.cast_eq_zero_iff _ v, Nat.dvd_one] at h⟩⟩\n\n"}
{"name":"NeZero.of_not_dvd","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\nn p : Nat\ninst✝ : CharP R p\nh : Not (Dvd.dvd p n)\n⊢ NeZero ↑n","decl":"lemma of_not_dvd [CharP R p] (h : ¬p ∣ n) : NeZero (n : R) :=\n  ⟨(CharP.cast_eq_zero_iff R p n).not.mpr h⟩\n\n"}
{"name":"NeZero.not_char_dvd","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\np : Nat\ninst✝ : CharP R p\nk : Nat\nh : NeZero ↑k\n⊢ Not (Dvd.dvd p k)","decl":"lemma not_char_dvd (p : ℕ) [CharP R p] (k : ℕ) [h : NeZero (k : R)] : ¬p ∣ k := by\n  rwa [← CharP.cast_eq_zero_iff R p k, ← Ne, ← neZero_iff]\n\n"}
{"name":"expChar_prime","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝² : AddMonoidWithOne R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : Fact (Nat.Prime p)\n⊢ ExpChar R p","decl":"instance expChar_prime (p) [CharP R p] [Fact p.Prime] : ExpChar R p := ExpChar.prime Fact.out\n"}
{"name":"expChar_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharZero R\n⊢ ExpChar R 1","decl":"instance expChar_one [CharZero R] : ExpChar R 1 := ExpChar.zero\n\n"}
{"name":"expChar_ne_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np : Nat\nhR : ExpChar R p\n⊢ Ne p 0","decl":"lemma expChar_ne_zero (p : ℕ) [hR : ExpChar R p] : p ≠ 0 := by\n  cases hR\n  · exact one_ne_zero\n  · exact ‹p.Prime›.ne_zero\n\n"}
{"name":"ExpChar.eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np q : Nat\nhp : ExpChar R p\nhq : ExpChar R q\n⊢ Eq p q","decl":"variable {R} in\n/-- The exponential characteristic is unique. -/\nlemma ExpChar.eq {p q : ℕ} (hp : ExpChar R p) (hq : ExpChar R q) : p = q := by\n  rcases hp with ⟨hp⟩ | ⟨hp'⟩\n  · rcases hq with hq | hq'\n    exacts [rfl, False.elim (Nat.not_prime_zero (CharP.eq R ‹_› (CharP.ofCharZero R) ▸ hq'))]\n  · rcases hq with hq | hq'\n    exacts [False.elim (Nat.not_prime_zero (CharP.eq R ‹_› (CharP.ofCharZero R) ▸ hp')),\n      CharP.eq R ‹_› ‹_›]\n\n"}
{"name":"ExpChar.congr","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np q : Nat\nhq : ExpChar R q\nh : Eq q p\n⊢ ExpChar R p","decl":"lemma ExpChar.congr {p : ℕ} (q : ℕ) [hq : ExpChar R q] (h : q = p) : ExpChar R p := h ▸ hq\n\n"}
{"name":"expChar_one_of_char_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nq : Nat\nhp : CharP R 0\nhq : ExpChar R q\n⊢ Eq q 1","decl":"/-- The exponential characteristic is one if the characteristic is zero. -/\nlemma expChar_one_of_char_zero (q : ℕ) [hp : CharP R 0] [hq : ExpChar R q] : q = 1 := by\n  rcases hq with q | hq_prime\n  · rfl\n  · exact False.elim <| hq_prime.ne_zero <| ‹CharP R q›.eq R hp\n\n"}
{"name":"char_eq_expChar_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\np q : Nat\nhp : CharP R p\nhq : ExpChar R q\n⊢ Iff (Eq p q) (Nat.Prime p)","decl":"/-- The characteristic equals the exponential characteristic iff the former is prime. -/\nlemma char_eq_expChar_iff (p q : ℕ) [hp : CharP R p] [hq : ExpChar R q] : p = q ↔ p.Prime := by\n  rcases hq with q | hq_prime\n  · rw [(CharP.eq R hp inferInstance : p = 0)]\n    decide\n  · exact ⟨fun hpq => hpq.symm ▸ hq_prime, fun _ => CharP.eq R hp ‹CharP R q›⟩\n\n"}
{"name":"expChar_is_prime_or_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nq : Nat\nhq : ExpChar R q\n⊢ Or (Nat.Prime q) (Eq q 1)","decl":"/-- The exponential characteristic is a prime number or one.\nSee also `CharP.char_is_prime_or_zero`. -/\nlemma expChar_is_prime_or_one (q : ℕ) [hq : ExpChar R q] : Nat.Prime q ∨ q = 1 := by\n  cases hq with\n  | zero => exact .inr rfl\n  | prime hp => exact .inl hp\n\n"}
{"name":"expChar_pos","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\nq : Nat\ninst✝ : ExpChar R q\n⊢ LT.lt 0 q","decl":"/-- The exponential characteristic is positive. -/\nlemma expChar_pos (q : ℕ) [ExpChar R q] : 0 < q := by\n  rcases expChar_is_prime_or_one R q with h | rfl\n  exacts [Nat.Prime.pos h, Nat.one_pos]\n\n"}
{"name":"expChar_pow_pos","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\nq : Nat\ninst✝ : ExpChar R q\nn : Nat\n⊢ LT.lt 0 (HPow.hPow q n)","decl":"/-- Any power of the exponential characteristic is positive. -/\nlemma expChar_pow_pos (q : ℕ) [ExpChar R q] (n : ℕ) : 0 < q ^ n :=\n  Nat.pos_pow_of_pos n (expChar_pos R q)\n\n"}
{"name":"ringExpChar.eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nq : Nat\nh : ExpChar R q\n⊢ Eq (ringExpChar R) q","decl":"lemma ringExpChar.eq (q : ℕ) [h : ExpChar R q] : ringExpChar R = q := by\n  rcases h with _ | h\n  · haveI := CharP.ofCharZero R\n    rw [ringExpChar, ringChar.eq R 0]; rfl\n  rw [ringExpChar, ringChar.eq R q]\n  exact Nat.max_eq_left h.one_lt.le\n\n"}
{"name":"ringExpChar.eq_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : CharZero R\n⊢ Eq (ringExpChar R) 1","decl":"@[simp] lemma ringExpChar.eq_one [CharZero R] : ringExpChar R = 1 := by\n  rw [ringExpChar, ringChar.eq_zero, max_eq_right (Nat.zero_le _)]\n\n"}
{"name":"char_zero_of_expChar_one","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\np : Nat\nhp : CharP R p\nhq : ExpChar R 1\n⊢ Eq p 0","decl":"/-- The exponential characteristic is one if the characteristic is zero. -/\nlemma char_zero_of_expChar_one (p : ℕ) [hp : CharP R p] [hq : ExpChar R 1] : p = 0 := by\n  cases hq\n  · exact CharP.eq R hp inferInstance\n  · exact False.elim (CharP.char_ne_one R 1 rfl)\n\n-- This could be an instance, but there are no `ExpChar R 1` instances in mathlib.\n"}
{"name":"charZero_of_expChar_one'","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\ninst✝ : Nontrivial R\nhq : ExpChar R 1\n⊢ CharZero R","decl":"/-- The characteristic is zero if the exponential characteristic is one. -/\nlemma charZero_of_expChar_one' [hq : ExpChar R 1] : CharZero R := by\n  cases hq\n  · assumption\n  · exact False.elim (CharP.char_ne_one R 1 rfl)\n\n"}
{"name":"expChar_one_iff_char_zero","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝³ : NonAssocSemiring R\ninst✝² : Nontrivial R\np q : Nat\ninst✝¹ : CharP R p\ninst✝ : ExpChar R q\n⊢ Iff (Eq q 1) (Eq p 0)","decl":"/-- The exponential characteristic is one iff the characteristic is zero. -/\nlemma expChar_one_iff_char_zero (p q : ℕ) [CharP R p] [ExpChar R q] : q = 1 ↔ p = 0 := by\n  constructor\n  · rintro rfl\n    exact char_zero_of_expChar_one R p\n  · rintro rfl\n    exact expChar_one_of_char_zero R q\n\n"}
{"name":"ExpChar.exists","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\n⊢ Exists fun q => ExpChar R q","decl":"lemma ExpChar.exists [Ring R] [IsDomain R] : ∃ q, ExpChar R q := by\n  obtain _ | ⟨p, ⟨hp⟩, _⟩ := CharP.exists' R\n  exacts [⟨1, .zero⟩, ⟨p, .prime hp⟩]\n\n"}
{"name":"ExpChar.exists_unique","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\n⊢ ExistsUnique fun q => ExpChar R q","decl":"lemma ExpChar.exists_unique [Ring R] [IsDomain R] : ∃! q, ExpChar R q :=\n  let ⟨q, H⟩ := ExpChar.exists R\n  ⟨q, H, fun _ H2 ↦ ExpChar.eq H2 H⟩\n\n"}
{"name":"ringExpChar.expChar","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\n⊢ ExpChar R (ringExpChar R)","decl":"instance ringExpChar.expChar [Ring R] [IsDomain R] : ExpChar R (ringExpChar R) := by\n  obtain ⟨q, _⟩ := ExpChar.exists R\n  rwa [ringExpChar.eq R q]\n\n"}
{"name":"ringExpChar.of_eq","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\nq : Nat\nh : Eq (ringExpChar R) q\n⊢ ExpChar R q","decl":"variable {R} in\nlemma ringExpChar.of_eq [Ring R] [IsDomain R] {q : ℕ} (h : ringExpChar R = q) : ExpChar R q :=\n  h ▸ ringExpChar.expChar R\n\n"}
{"name":"ringExpChar.eq_iff","module":"Mathlib.Algebra.CharP.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\nq : Nat\n⊢ Iff (Eq (ringExpChar R) q) (ExpChar R q)","decl":"variable {R} in\nlemma ringExpChar.eq_iff [Ring R] [IsDomain R] {q : ℕ} : ringExpChar R = q ↔ ExpChar R q :=\n  ⟨ringExpChar.of_eq, fun _ ↦ ringExpChar.eq R q⟩\n"}
