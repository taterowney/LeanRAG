{"name":"LaurentPolynomial.ext","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : LaurentPolynomial R\nh : ∀ (a : Int), Eq (p a) (q a)\n⊢ Eq p q","decl":"@[ext]\ntheorem LaurentPolynomial.ext [Semiring R] {p q : R[T;T⁻¹]} (h : ∀ a, p a = q a) : p = q :=\n  Finsupp.ext h\n\n"}
{"name":"LaurentPolynomial.ext_iff","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : LaurentPolynomial R\n⊢ Iff (Eq p q) (∀ (a : Int), Eq (p a) (q a))","decl":"@[ext]\ntheorem LaurentPolynomial.ext [Semiring R] {p q : R[T;T⁻¹]} (h : ∀ a, p a = q a) : p = q :=\n  Finsupp.ext h\n\n"}
{"name":"Polynomial.toLaurent_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.toLaurent p) (AddMonoidAlgebra.mapDomain Nat.cast p.toFinsupp)","decl":"/-- This is not a simp lemma, as it is usually preferable to use the lemmas about `C` and `X`\ninstead. -/\ntheorem Polynomial.toLaurent_apply [Semiring R] (p : R[X]) :\n    toLaurent p = p.toFinsupp.mapDomain (↑) :=\n  rfl\n\n"}
{"name":"Polynomial.coe_toLaurentAlg","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ⇑Polynomial.toLaurentAlg ⇑Polynomial.toLaurent","decl":"@[simp] lemma Polynomial.coe_toLaurentAlg [CommSemiring R] :\n    (toLaurentAlg : R[X] → R[T;T⁻¹]) = toLaurent :=\n  rfl\n\n"}
{"name":"Polynomial.toLaurentAlg_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq (Polynomial.toLaurentAlg f) (Polynomial.toLaurent f)","decl":"theorem Polynomial.toLaurentAlg_apply [CommSemiring R] (f : R[X]) : toLaurentAlg f = toLaurent f :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.single_zero_one_eq_one","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Finsupp.single 0 1) 1","decl":"theorem single_zero_one_eq_one : (Finsupp.single 0 1 : R[T;T⁻¹]) = (1 : R[T;T⁻¹]) :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.algebraMap_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (LaurentPolynomial A)) r) (LaurentPolynomial.C ((algebraMap R A) r))","decl":"theorem algebraMap_apply {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) :\n    algebraMap R (LaurentPolynomial A) r = C (algebraMap R A r) :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.C_eq_algebraMap","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (LaurentPolynomial.C r) ((algebraMap R (LaurentPolynomial R)) r)","decl":"/-- When we have `[CommSemiring R]`, the function `C` is the same as `algebraMap R R[T;T⁻¹]`.\n(But note that `C` is defined when `R` is not necessarily commutative, in which case\n`algebraMap` is not available.)\n-/\ntheorem C_eq_algebraMap {R : Type*} [CommSemiring R] (r : R) : C r = algebraMap R R[T;T⁻¹] r :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.single_eq_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (Finsupp.single 0 r) (LaurentPolynomial.C r)","decl":"theorem single_eq_C (r : R) : Finsupp.single 0 r = C r := rfl\n\n"}
{"name":"LaurentPolynomial.C_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nt : R\nn : Int\n⊢ Eq ((LaurentPolynomial.C t) n) (ite (Eq n 0) t 0)","decl":"@[simp] lemma C_apply (t : R) (n : ℤ) : C t n = if n = 0 then t else 0 := by\n  rw [← single_eq_C, Finsupp.single_apply]; aesop\n\n"}
{"name":"LaurentPolynomial.T_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm n : Int\n⊢ Eq ((LaurentPolynomial.T n) m) (ite (Eq n m) 1 0)","decl":"@[simp] lemma T_apply (m n : ℤ) : (T n : R[T;T⁻¹]) m = if n = m then 1 else 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"LaurentPolynomial.T_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (LaurentPolynomial.T 0) 1","decl":"@[simp]\ntheorem T_zero : (T 0 : R[T;T⁻¹]) = 1 :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.T_add","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm n : Int\n⊢ Eq (LaurentPolynomial.T (HAdd.hAdd m n)) (HMul.hMul (LaurentPolynomial.T m) (LaurentPolynomial.T n))","decl":"theorem T_add (m n : ℤ) : (T (m + n) : R[T;T⁻¹]) = T m * T n := by\n  -- Porting note: was `convert single_mul_single.symm`\n  simp [T, single_mul_single]\n\n"}
{"name":"LaurentPolynomial.T_sub","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm n : Int\n⊢ Eq (LaurentPolynomial.T (HSub.hSub m n)) (HMul.hMul (LaurentPolynomial.T m) (LaurentPolynomial.T (Neg.neg n)))","decl":"theorem T_sub (m n : ℤ) : (T (m - n) : R[T;T⁻¹]) = T m * T (-n) := by rw [← T_add, sub_eq_add_neg]\n\n"}
{"name":"LaurentPolynomial.T_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm : Int\nn : Nat\n⊢ Eq (HPow.hPow (LaurentPolynomial.T m) n) (LaurentPolynomial.T (HMul.hMul (↑n) m))","decl":"@[simp]\ntheorem T_pow (m : ℤ) (n : ℕ) : (T m ^ n : R[T;T⁻¹]) = T (n * m) := by\n  rw [T, T, single_pow n, one_pow, nsmul_eq_mul]\n\n"}
{"name":"LaurentPolynomial.mul_T_assoc","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : LaurentPolynomial R\nm n : Int\n⊢ Eq (HMul.hMul (HMul.hMul f (LaurentPolynomial.T m)) (LaurentPolynomial.T n)) (HMul.hMul f (LaurentPolynomial.T (HAdd.hAdd m n)))","decl":"/-- The `simp` version of `mul_assoc`, in the presence of `T`'s. -/\n@[simp]\ntheorem mul_T_assoc (f : R[T;T⁻¹]) (m n : ℤ) : f * T m * T n = f * T (m + n) := by\n  simp [← T_add, mul_assoc]\n\n"}
{"name":"LaurentPolynomial.single_eq_C_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nn : Int\n⊢ Eq (Finsupp.single n r) (HMul.hMul (LaurentPolynomial.C r) (LaurentPolynomial.T n))","decl":"@[simp]\ntheorem single_eq_C_mul_T (r : R) (n : ℤ) :\n    (Finsupp.single n r : R[T;T⁻¹]) = (C r * T n : R[T;T⁻¹]) := by\n  -- Porting note: was `convert single_mul_single.symm`\n  simp [C, T, single_mul_single]\n\n-- This lemma locks in the right changes and is what Lean proved directly.\n-- The actual `simp`-normal form of a Laurent monomial is `C a * T n`, whenever it can be reached.\n"}
{"name":"Polynomial.toLaurent_C_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq (Polynomial.toLaurent ((Polynomial.monomial n) r)) (HMul.hMul (LaurentPolynomial.C r) (LaurentPolynomial.T ↑n))","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_C_mul_T (n : ℕ) (r : R) :\n    (toLaurent (Polynomial.monomial n r) : R[T;T⁻¹]) = C r * T n :=\n  show Finsupp.mapDomain (↑) (monomial n r).toFinsupp = (C r * T n : R[T;T⁻¹]) by\n    rw [toFinsupp_monomial, Finsupp.mapDomain_single, single_eq_C_mul_T]\n\n"}
{"name":"Polynomial.toLaurent_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (Polynomial.toLaurent (Polynomial.C r)) (LaurentPolynomial.C r)","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_C (r : R) : toLaurent (Polynomial.C r) = C r := by\n  convert Polynomial.toLaurent_C_mul_T 0 r\n  simp only [Int.ofNat_zero, T_zero, mul_one]\n\n"}
{"name":"Polynomial.toLaurent_comp_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Function.comp ⇑Polynomial.toLaurent ⇑Polynomial.C) ⇑LaurentPolynomial.C","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_comp_C : toLaurent (R := R) ∘ Polynomial.C = C :=\n  funext Polynomial.toLaurent_C\n\n"}
{"name":"Polynomial.toLaurent_X","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.toLaurent Polynomial.X) (LaurentPolynomial.T 1)","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_X : (toLaurent Polynomial.X : R[T;T⁻¹]) = T 1 := by\n  have : (Polynomial.X : R[X]) = monomial 1 1 := by simp [← C_mul_X_pow_eq_monomial]\n  simp [this, Polynomial.toLaurent_C_mul_T]\n\n"}
{"name":"Polynomial.toLaurent_one","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.toLaurent 1) 1","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_one : (Polynomial.toLaurent : R[X] → R[T;T⁻¹]) 1 = 1 :=\n  map_one Polynomial.toLaurent\n\n"}
{"name":"Polynomial.toLaurent_C_mul_eq","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nf : Polynomial R\n⊢ Eq (Polynomial.toLaurent (HMul.hMul (Polynomial.C r) f)) (HMul.hMul (LaurentPolynomial.C r) (Polynomial.toLaurent f))","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_C_mul_eq (r : R) (f : R[X]) :\n    toLaurent (Polynomial.C r * f) = C r * toLaurent f := by\n  simp only [_root_.map_mul, Polynomial.toLaurent_C]\n\n"}
{"name":"Polynomial.toLaurent_X_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.toLaurent (HPow.hPow Polynomial.X n)) (LaurentPolynomial.T ↑n)","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_X_pow (n : ℕ) : toLaurent (X ^ n : R[X]) = T n := by\n  simp only [map_pow, Polynomial.toLaurent_X, T_pow, mul_one]\n\n"}
{"name":"Polynomial.toLaurent_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq (Polynomial.toLaurent (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n))) (HMul.hMul (LaurentPolynomial.C r) (LaurentPolynomial.T ↑n))","decl":"theorem _root_.Polynomial.toLaurent_C_mul_X_pow (n : ℕ) (r : R) :\n    toLaurent (Polynomial.C r * X ^ n) = C r * T n := by\n  simp only [_root_.map_mul, Polynomial.toLaurent_C, Polynomial.toLaurent_X_pow]\n\n"}
{"name":"LaurentPolynomial.invOf_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\n⊢ Eq (Invertible.invOf (LaurentPolynomial.T n)) (LaurentPolynomial.T (Neg.neg n))","decl":"@[simp]\ntheorem invOf_T (n : ℤ) : ⅟ (T n : R[T;T⁻¹]) = T (-n) :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.isUnit_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\n⊢ IsUnit (LaurentPolynomial.T n)","decl":"theorem isUnit_T (n : ℤ) : IsUnit (T n : R[T;T⁻¹]) :=\n  isUnit_of_invertible _\n\n"}
{"name":"LaurentPolynomial.induction_on","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nM : LaurentPolynomial R → Prop\np : LaurentPolynomial R\nh_C : ∀ (a : R), M (LaurentPolynomial.C a)\nh_add : ∀ {p q : LaurentPolynomial R}, M p → M q → M (HAdd.hAdd p q)\nh_C_mul_T : ∀ (n : Nat) (a : R), M (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T ↑n)) → M (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T (HAdd.hAdd (↑n) 1)))\nh_C_mul_T_Z : ∀ (n : Nat) (a : R), M (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T (Neg.neg ↑n))) → M (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T (HSub.hSub (Neg.neg ↑n) 1)))\n⊢ M p","decl":"@[elab_as_elim]\nprotected theorem induction_on {M : R[T;T⁻¹] → Prop} (p : R[T;T⁻¹]) (h_C : ∀ a, M (C a))\n    (h_add : ∀ {p q}, M p → M q → M (p + q))\n    (h_C_mul_T : ∀ (n : ℕ) (a : R), M (C a * T n) → M (C a * T (n + 1)))\n    (h_C_mul_T_Z : ∀ (n : ℕ) (a : R), M (C a * T (-n)) → M (C a * T (-n - 1))) : M p := by\n  have A : ∀ {n : ℤ} {a : R}, M (C a * T n) := by\n    intro n a\n    refine Int.induction_on n ?_ ?_ ?_\n    · simpa only [T_zero, mul_one] using h_C a\n    · exact fun m => h_C_mul_T m a\n    · exact fun m => h_C_mul_T_Z m a\n  have B : ∀ s : Finset ℤ, M (s.sum fun n : ℤ => C (p.toFun n) * T n) := by\n    apply Finset.induction\n    · convert h_C 0\n      simp only [Finset.sum_empty, _root_.map_zero]\n    · intro n s ns ih\n      rw [Finset.sum_insert ns]\n      exact h_add A ih\n  convert B p.support\n  ext a\n  simp_rw [← single_eq_C_mul_T]\n  -- Porting note: did not make progress in `simp_rw`\n  rw [Finset.sum_apply']\n  simp_rw [Finsupp.single_apply, Finset.sum_ite_eq']\n  split_ifs with h\n  · rfl\n  · exact Finsupp.not_mem_support_iff.mp h\n\n"}
{"name":"LaurentPolynomial.induction_on'","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nM : LaurentPolynomial R → Prop\np : LaurentPolynomial R\nh_add : ∀ (p q : LaurentPolynomial R), M p → M q → M (HAdd.hAdd p q)\nh_C_mul_T : ∀ (n : Int) (a : R), M (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n))\n⊢ M p","decl":"/-- To prove something about Laurent polynomials, it suffices to show that\n* the condition is closed under taking sums, and\n* it holds for monomials.\n-/\n@[elab_as_elim]\nprotected theorem induction_on' {M : R[T;T⁻¹] → Prop} (p : R[T;T⁻¹])\n    (h_add : ∀ p q, M p → M q → M (p + q)) (h_C_mul_T : ∀ (n : ℤ) (a : R), M (C a * T n)) :\n    M p := by\n  refine p.induction_on (fun a => ?_) (fun {p q} => h_add p q) ?_ ?_ <;>\n      try exact fun n f _ => h_C_mul_T _ f\n  convert h_C_mul_T 0 a\n  exact (mul_one _).symm\n\n"}
{"name":"LaurentPolynomial.commute_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\nf : LaurentPolynomial R\n⊢ Commute (LaurentPolynomial.T n) f","decl":"theorem commute_T (n : ℤ) (f : R[T;T⁻¹]) : Commute (T n) f :=\n  f.induction_on' (fun _ _ Tp Tq => Commute.add_right Tp Tq) fun m a =>\n    show T n * _ = _ by\n      rw [T, T, ← single_eq_C, single_mul_single, single_mul_single, single_mul_single]\n      simp [add_comm]\n\n"}
{"name":"LaurentPolynomial.T_mul","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\nf : LaurentPolynomial R\n⊢ Eq (HMul.hMul (LaurentPolynomial.T n) f) (HMul.hMul f (LaurentPolynomial.T n))","decl":"@[simp]\ntheorem T_mul (n : ℤ) (f : R[T;T⁻¹]) : T n * f = f * T n :=\n  (commute_T n f).eq\n\n"}
{"name":"LaurentPolynomial.smul_eq_C_mul","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nf : LaurentPolynomial R\n⊢ Eq (HSMul.hSMul r f) (HMul.hMul (LaurentPolynomial.C r) f)","decl":"theorem smul_eq_C_mul (r : R) (f : R[T;T⁻¹]) : r • f = C r * f := by\n  induction f using LaurentPolynomial.induction_on' with\n  | h_add _ _ hp hq =>\n    rw [smul_add, mul_add, hp, hq]\n  | h_C_mul_T n s =>\n    rw [← mul_assoc, ← smul_mul_assoc, mul_left_inj_of_invertible, ← map_mul, ← single_eq_C,\n      Finsupp.smul_single', single_eq_C]\n\n"}
{"name":"LaurentPolynomial.trunc_C_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\nr : R\n⊢ Eq (LaurentPolynomial.trunc (HMul.hMul (LaurentPolynomial.C r) (LaurentPolynomial.T n))) (ite (LE.le 0 n) ((Polynomial.monomial n.toNat) r) 0)","decl":"@[simp]\ntheorem trunc_C_mul_T (n : ℤ) (r : R) : trunc (C r * T n) = ite (0 ≤ n) (monomial n.toNat r) 0 := by\n  apply (toFinsuppIso R).injective\n  rw [← single_eq_C_mul_T, trunc, AddMonoidHom.coe_comp, Function.comp_apply]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw`\n  erw [comapDomain.addMonoidHom_apply Int.ofNat_injective]\n  rw [toFinsuppIso_apply]\n  -- Porting note: rewrote proof below relative to mathlib3.\n  by_cases n0 : 0 ≤ n\n  · lift n to ℕ using n0\n    erw [comapDomain_single]\n    simp only [Nat.cast_nonneg, Int.toNat_ofNat, ite_true, toFinsupp_monomial]\n  · lift -n to ℕ using (neg_pos.mpr (not_le.mp n0)).le with m\n    rw [toFinsupp_inj, if_neg n0]\n    ext a\n    have := ((not_le.mp n0).trans_le (Int.ofNat_zero_le a)).ne\n    simp only [coeff_ofFinsupp, comapDomain_apply, Int.ofNat_eq_coe, coeff_zero,\n      single_eq_of_ne this]\n\n"}
{"name":"LaurentPolynomial.leftInverse_trunc_toLaurent","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Function.LeftInverse ⇑LaurentPolynomial.trunc ⇑Polynomial.toLaurent","decl":"@[simp]\ntheorem leftInverse_trunc_toLaurent :\n    Function.LeftInverse (trunc : R[T;T⁻¹] → R[X]) Polynomial.toLaurent := by\n  refine fun f => f.induction_on' ?_ ?_\n  · intro f g hf hg\n    simp only [hf, hg, _root_.map_add]\n  · intro n r\n    simp only [Polynomial.toLaurent_C_mul_T, trunc_C_mul_T, Int.natCast_nonneg, Int.toNat_natCast,\n      if_true]\n\n"}
{"name":"Polynomial.trunc_toLaurent","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (LaurentPolynomial.trunc (Polynomial.toLaurent f)) f","decl":"@[simp]\ntheorem _root_.Polynomial.trunc_toLaurent (f : R[X]) : trunc (toLaurent f) = f :=\n  leftInverse_trunc_toLaurent _\n\n"}
{"name":"Polynomial.toLaurent_injective","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Function.Injective ⇑Polynomial.toLaurent","decl":"theorem _root_.Polynomial.toLaurent_injective :\n    Function.Injective (Polynomial.toLaurent : R[X] → R[T;T⁻¹]) :=\n  leftInverse_trunc_toLaurent.injective\n\n"}
{"name":"Polynomial.toLaurent_inj","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Polynomial R\n⊢ Iff (Eq (Polynomial.toLaurent f) (Polynomial.toLaurent g)) (Eq f g)","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_inj (f g : R[X]) : toLaurent f = toLaurent g ↔ f = g :=\n  ⟨fun h => Polynomial.toLaurent_injective h, congr_arg _⟩\n\n"}
{"name":"Polynomial.toLaurent_ne_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Ne (Polynomial.toLaurent f) 0) (Ne f 0)","decl":"theorem _root_.Polynomial.toLaurent_ne_zero {f : R[X]} : toLaurent f ≠ 0 ↔ f ≠ 0 :=\n  map_ne_zero_iff _ Polynomial.toLaurent_injective\n\n"}
{"name":"Polynomial.toLaurent_eq_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Eq (Polynomial.toLaurent f) 0) (Eq f 0)","decl":"@[simp]\ntheorem _root_.Polynomial.toLaurent_eq_zero {f : R[X]} : toLaurent f = 0 ↔ f = 0 :=\n  map_eq_zero_iff _ Polynomial.toLaurent_injective\n\n"}
{"name":"LaurentPolynomial.exists_T_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : LaurentPolynomial R\n⊢ Exists fun n => Exists fun f' => Eq (Polynomial.toLaurent f') (HMul.hMul f (LaurentPolynomial.T ↑n))","decl":"theorem exists_T_pow (f : R[T;T⁻¹]) : ∃ (n : ℕ) (f' : R[X]), toLaurent f' = f * T n := by\n  refine f.induction_on' ?_ fun n a => ?_ <;> clear f\n  · rintro f g ⟨m, fn, hf⟩ ⟨n, gn, hg⟩\n    refine ⟨m + n, fn * X ^ n + gn * X ^ m, ?_⟩\n    simp only [hf, hg, add_mul, add_comm (n : ℤ), map_add, map_mul, Polynomial.toLaurent_X_pow,\n      mul_T_assoc, Int.ofNat_add]\n  · cases' n with n n\n    · exact ⟨0, Polynomial.C a * X ^ n, by simp⟩\n    · refine ⟨n + 1, Polynomial.C a, ?_⟩\n      simp only [Int.negSucc_eq, Polynomial.toLaurent_C, Int.ofNat_succ, mul_T_assoc,\n        neg_add_cancel, T_zero, mul_one]\n\n"}
{"name":"LaurentPolynomial.induction_on_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nQ : LaurentPolynomial R → Prop\nf : LaurentPolynomial R\nQf : ∀ {f : Polynomial R} {n : Nat}, Q (HMul.hMul (Polynomial.toLaurent f) (LaurentPolynomial.T (Neg.neg ↑n)))\n⊢ Q f","decl":"/-- This is a version of `exists_T_pow` stated as an induction principle. -/\n@[elab_as_elim]\ntheorem induction_on_mul_T {Q : R[T;T⁻¹] → Prop} (f : R[T;T⁻¹])\n    (Qf : ∀ {f : R[X]} {n : ℕ}, Q (toLaurent f * T (-n))) : Q f := by\n  rcases f.exists_T_pow with ⟨n, f', hf⟩\n  rw [← mul_one f, ← T_zero, ← Nat.cast_zero, ← Nat.sub_self n, Nat.cast_sub rfl.le, T_sub,\n    ← mul_assoc, ← hf]\n  exact Qf\n\n"}
{"name":"LaurentPolynomial.reduce_to_polynomial_of_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : LaurentPolynomial R\nQ : LaurentPolynomial R → Prop\nQf : ∀ (f : Polynomial R), Q (Polynomial.toLaurent f)\nQT : ∀ (f : LaurentPolynomial R), Q (HMul.hMul f (LaurentPolynomial.T 1)) → Q f\n⊢ Q f","decl":"/-- Suppose that `Q` is a statement about Laurent polynomials such that\n* `Q` is true on *ordinary* polynomials;\n* `Q (f * T)` implies `Q f`;\nit follow that `Q` is true on all Laurent polynomials. -/\ntheorem reduce_to_polynomial_of_mul_T (f : R[T;T⁻¹]) {Q : R[T;T⁻¹] → Prop}\n    (Qf : ∀ f : R[X], Q (toLaurent f)) (QT : ∀ f, Q (f * T 1) → Q f) : Q f := by\n  induction' f using LaurentPolynomial.induction_on_mul_T with f n\n  induction n with\n  | zero => simpa only [Nat.cast_zero, neg_zero, T_zero, mul_one] using Qf _\n  | succ n hn => convert QT _ _; simpa using hn\n\n"}
{"name":"LaurentPolynomial.support_C_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\nn : Int\n⊢ HasSubset.Subset (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n)).support (Singleton.singleton n)","decl":"theorem support_C_mul_T (a : R) (n : ℤ) : Finsupp.support (C a * T n) ⊆ {n} := by\n  -- Porting note: was\n  -- simpa only [← single_eq_C_mul_T] using support_single_subset\n  rw [← single_eq_C_mul_T]\n  exact support_single_subset\n\n"}
{"name":"LaurentPolynomial.support_C_mul_T_of_ne_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\na0 : Ne a 0\nn : Int\n⊢ Eq (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n)).support (Singleton.singleton n)","decl":"theorem support_C_mul_T_of_ne_zero {a : R} (a0 : a ≠ 0) (n : ℤ) :\n    Finsupp.support (C a * T n) = {n} := by\n  rw [← single_eq_C_mul_T]\n  exact support_single_ne_zero _ a0\n\n"}
{"name":"LaurentPolynomial.toLaurent_support","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (Polynomial.toLaurent f).support (Finset.map Nat.castEmbedding f.support)","decl":"/-- The support of a polynomial `f` is a finset in `ℕ`.  The lemma `toLaurent_support f`\nshows that the support of `f.toLaurent` is the same finset, but viewed in `ℤ` under the natural\ninclusion `ℕ ↪ ℤ`. -/\ntheorem toLaurent_support (f : R[X]) : f.toLaurent.support = f.support.map Nat.castEmbedding := by\n  generalize hd : f.support = s\n  revert f\n  refine Finset.induction_on s ?_ ?_ <;> clear s\n  · intro f hf\n    rw [Finset.map_empty, Finsupp.support_eq_empty, toLaurent_eq_zero]\n    exact Polynomial.support_eq_empty.mp hf\n  · intro a s as hf f fs\n    have : (erase a f).toLaurent.support = s.map Nat.castEmbedding := by\n      refine hf (f.erase a) ?_\n      simp only [fs, Finset.erase_eq_of_not_mem as, Polynomial.support_erase,\n        Finset.erase_insert_eq_erase]\n    rw [← monomial_add_erase f a, Finset.map_insert, ← this, map_add, Polynomial.toLaurent_C_mul_T,\n      support_add_eq, Finset.insert_eq]\n    · congr\n      exact support_C_mul_T_of_ne_zero (Polynomial.mem_support_iff.mp (by simp [fs])) _\n    · rw [this]\n      exact Disjoint.mono_left (support_C_mul_T _ _) (by simpa)\n\n"}
{"name":"LaurentPolynomial.degree_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (LaurentPolynomial.degree 0) Bot.bot","decl":"@[simp]\ntheorem degree_zero : degree (0 : R[T;T⁻¹]) = ⊥ :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.degree_eq_bot_iff","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : LaurentPolynomial R\n⊢ Iff (Eq f.degree Bot.bot) (Eq f 0)","decl":"@[simp]\ntheorem degree_eq_bot_iff {f : R[T;T⁻¹]} : f.degree = ⊥ ↔ f = 0 := by\n  refine ⟨fun h => ?_, fun h => by rw [h, degree_zero]⟩\n  rw [degree, Finset.max_eq_sup_withBot] at h\n  ext n\n  simp_rw [Finset.sup_eq_bot_iff, Finsupp.mem_support_iff, Ne, WithBot.coe_ne_bot] at h\n  exact not_not.mp (h n)\n\n"}
{"name":"LaurentPolynomial.degree_C_mul_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\na : R\na0 : Ne a 0\n⊢ Eq (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n)).degree ↑n","decl":"@[simp]\ntheorem degree_C_mul_T (n : ℤ) (a : R) (a0 : a ≠ 0) : degree (C a * T n) = n := by\n  rw [degree, support_C_mul_T_of_ne_zero a0 n]\n  exact Finset.max_singleton\n\n"}
{"name":"LaurentPolynomial.degree_C_mul_T_ite","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : DecidableEq R\nn : Int\na : R\n⊢ Eq (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n)).degree (ite (Eq a 0) Bot.bot ↑n)","decl":"theorem degree_C_mul_T_ite [DecidableEq R] (n : ℤ) (a : R) :\n    degree (C a * T n) = if a = 0 then ⊥ else ↑n := by\n  split_ifs with h <;>\n    simp only [h, map_zero, zero_mul, degree_zero, degree_C_mul_T, Ne,\n      not_false_iff]\n\n"}
{"name":"LaurentPolynomial.degree_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nn : Int\n⊢ Eq (LaurentPolynomial.T n).degree ↑n","decl":"@[simp]\ntheorem degree_T [Nontrivial R] (n : ℤ) : (T n : R[T;T⁻¹]).degree = n := by\n  rw [← one_mul (T n), ← map_one C]\n  exact degree_C_mul_T n 1 (one_ne_zero : (1 : R) ≠ 0)\n\n"}
{"name":"LaurentPolynomial.degree_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\na0 : Ne a 0\n⊢ Eq (LaurentPolynomial.C a).degree 0","decl":"theorem degree_C {a : R} (a0 : a ≠ 0) : (C a).degree = 0 := by\n  rw [← mul_one (C a), ← T_zero]\n  exact degree_C_mul_T 0 a a0\n\n"}
{"name":"LaurentPolynomial.degree_C_ite","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : DecidableEq R\na : R\n⊢ Eq (LaurentPolynomial.C a).degree (ite (Eq a 0) Bot.bot 0)","decl":"theorem degree_C_ite [DecidableEq R] (a : R) : (C a).degree = if a = 0 then ⊥ else 0 := by\n  split_ifs with h <;> simp only [h, map_zero, degree_zero, degree_C, Ne, not_false_iff]\n\n"}
{"name":"LaurentPolynomial.degree_C_mul_T_le","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\na : R\n⊢ LE.le (HMul.hMul (LaurentPolynomial.C a) (LaurentPolynomial.T n)).degree ↑n","decl":"theorem degree_C_mul_T_le (n : ℤ) (a : R) : degree (C a * T n) ≤ n := by\n  by_cases a0 : a = 0\n  · simp only [a0, map_zero, zero_mul, degree_zero, bot_le]\n  · exact (degree_C_mul_T n a a0).le\n\n"}
{"name":"LaurentPolynomial.degree_T_le","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Int\n⊢ LE.le (LaurentPolynomial.T n).degree ↑n","decl":"theorem degree_T_le (n : ℤ) : (T n : R[T;T⁻¹]).degree ≤ n :=\n  (le_of_eq (by rw [map_one, one_mul])).trans (degree_C_mul_T_le n (1 : R))\n\n"}
{"name":"LaurentPolynomial.degree_C_le","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\n⊢ LE.le (LaurentPolynomial.C a).degree 0","decl":"theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=\n  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)\n\n"}
{"name":"LaurentPolynomial.instIsScalarTowerPolynomial","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : Semiring R\n⊢ IsScalarTower (Polynomial R) (Polynomial R) (LaurentPolynomial R)","decl":"instance (R : Type*) [Semiring R] : IsScalarTower R[X] R[X] R[T;T⁻¹] where\n  smul_assoc x y z := by dsimp; simp_rw [MulAction.mul_smul]\n\n"}
{"name":"LaurentPolynomial.algebraMap_X_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq ((algebraMap (Polynomial R) (LaurentPolynomial R)) (HPow.hPow Polynomial.X n)) (LaurentPolynomial.T ↑n)","decl":"theorem algebraMap_X_pow (n : ℕ) : algebraMap R[X] R[T;T⁻¹] (X ^ n) = T n :=\n  Polynomial.toLaurent_X_pow n\n\n"}
{"name":"LaurentPolynomial.algebraMap_eq_toLaurent","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq ((algebraMap (Polynomial R) (LaurentPolynomial R)) f) (Polynomial.toLaurent f)","decl":"@[simp]\ntheorem algebraMap_eq_toLaurent (f : R[X]) : algebraMap R[X] R[T;T⁻¹] f = toLaurent f :=\n  rfl\n\n"}
{"name":"LaurentPolynomial.isLocalization","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ IsLocalization (Submonoid.powers Polynomial.X) (LaurentPolynomial R)","decl":"theorem isLocalization : IsLocalization (Submonoid.powers (X : R[X])) R[T;T⁻¹] :=\n  { map_units' := fun ⟨t, ht⟩ => by\n      obtain ⟨n, rfl⟩ := ht\n      rw [algebraMap_eq_toLaurent, toLaurent_X_pow]\n      exact isUnit_T ↑n\n    surj' := fun f => by\n      induction' f using LaurentPolynomial.induction_on_mul_T with f n\n      have : X ^ n ∈ Submonoid.powers (X : R[X]) := ⟨n, rfl⟩\n      refine ⟨(f, ⟨_, this⟩), ?_⟩\n      simp only [algebraMap_eq_toLaurent, toLaurent_X_pow, mul_T_assoc, neg_add_cancel, T_zero,\n        mul_one]\n    exists_of_eq := fun {f g} => by\n      rw [algebraMap_eq_toLaurent, algebraMap_eq_toLaurent, Polynomial.toLaurent_inj]\n      rintro rfl\n      exact ⟨1, rfl⟩ }\n\n"}
{"name":"LaurentPolynomial.invert_T","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nn : Int\n⊢ Eq (LaurentPolynomial.invert (LaurentPolynomial.T n)) (LaurentPolynomial.T (Neg.neg n))","decl":"@[simp] lemma invert_T (n : ℤ) : invert (T n : R[T;T⁻¹]) = T (-n) :=\n  AddMonoidAlgebra.domCongr_single _ _ _ _ _\n\n"}
{"name":"LaurentPolynomial.invert_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nf : LaurentPolynomial R\nn : Int\n⊢ Eq ((LaurentPolynomial.invert f) n) (f (Neg.neg n))","decl":"@[simp] lemma invert_apply (f : R[T;T⁻¹]) (n : ℤ) : invert f n = f (-n) := rfl\n\n"}
{"name":"LaurentPolynomial.invert_comp_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (Function.comp ⇑LaurentPolynomial.invert ⇑LaurentPolynomial.C) ⇑LaurentPolynomial.C","decl":"@[simp] lemma invert_comp_C : invert ∘ (@C R _) = C := by ext; simp\n\n"}
{"name":"LaurentPolynomial.invert_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nt : R\n⊢ Eq (LaurentPolynomial.invert (LaurentPolynomial.C t)) (LaurentPolynomial.C t)","decl":"@[simp] lemma invert_C (t : R) : invert (C t) = C t := by ext; simp\n\n"}
{"name":"LaurentPolynomial.involutive_invert","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ Function.Involutive ⇑LaurentPolynomial.invert","decl":"lemma involutive_invert : Involutive (invert (R := R)) := fun _ ↦ by ext; simp\n\n"}
{"name":"LaurentPolynomial.invert_symm","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq LaurentPolynomial.invert.symm LaurentPolynomial.invert","decl":"@[simp] lemma invert_symm : (invert (R := R)).symm = invert := rfl\n\n"}
{"name":"LaurentPolynomial.toLaurent_reverse","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Eq (Polynomial.toLaurent p.reverse) (HMul.hMul (LaurentPolynomial.invert (Polynomial.toLaurent p)) (LaurentPolynomial.T ↑p.natDegree))","decl":"lemma toLaurent_reverse (p : R[X]) :\n    toLaurent p.reverse = invert (toLaurent p) * (T p.natDegree) := by\n  nontriviality R\n  induction p using Polynomial.recOnHorner with\n  | M0 => simp\n  | MC _ _ _ _ ih => simp [add_mul, ← ih]\n  | MX _ hp => simpa [natDegree_mul_X hp]\n\n"}
{"name":"LaurentPolynomial.smeval_eq_sum","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nf : LaurentPolynomial R\nx : Units S\n⊢ Eq (f.smeval x) (Finsupp.sum f fun n r => HSMul.hSMul r ↑(HPow.hPow x n))","decl":"theorem smeval_eq_sum : f.smeval x = Finsupp.sum f fun n r => r • (x ^ n).val := rfl\n\n"}
{"name":"LaurentPolynomial.smeval_congr","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nf g : LaurentPolynomial R\nx y : Units S\na✝¹ : Eq f g\na✝ : Eq x y\n⊢ Eq (f.smeval x) (g.smeval y)","decl":"theorem smeval_congr : f = g → x = y → f.smeval x = g.smeval y := by rintro rfl rfl; rfl\n\n"}
{"name":"LaurentPolynomial.smeval_zero","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nx : Units S\n⊢ Eq (LaurentPolynomial.smeval 0 x) 0","decl":"@[simp]\ntheorem smeval_zero : (0 : R[T;T⁻¹]).smeval x = (0 : S) := by\n  simp only [smeval_eq_sum, Finsupp.sum_zero_index]\n\n"}
{"name":"LaurentPolynomial.smeval_single","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nx : Units S\nn : Int\nr : R\n⊢ Eq (LaurentPolynomial.smeval (Finsupp.single n r) x) (HSMul.hSMul r ↑(HPow.hPow x n))","decl":"theorem smeval_single (n : ℤ) (r : R) : smeval (Finsupp.single n r) x = r • (x ^ n).val := by\n  simp only [smeval_eq_sum]\n  rw [Finsupp.sum_single_index (zero_smul R (x ^ n).val)]\n\n"}
{"name":"LaurentPolynomial.smeval_C_mul_T_n","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nx : Units S\nn : Int\nr : R\n⊢ Eq ((HMul.hMul (LaurentPolynomial.C r) (LaurentPolynomial.T n)).smeval x) (HSMul.hSMul r ↑(HPow.hPow x n))","decl":"@[simp]\ntheorem smeval_C_mul_T_n (n : ℤ) (r : R) : (C r * T n).smeval x = r • (x ^ n).val := by\n  rw [← single_eq_C_mul_T, smeval_single]\n\n"}
{"name":"LaurentPolynomial.smeval_C","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : SMulWithZero R S\ninst✝ : Monoid S\nx : Units S\nr : R\n⊢ Eq ((LaurentPolynomial.C r).smeval x) (HSMul.hSMul r 1)","decl":"@[simp]\ntheorem smeval_C (r : R) : (C r).smeval x = r • 1 := by\n  rw [← single_eq_C, smeval_single x (0 : ℤ) r, zpow_zero, Units.val_one]\n\n"}
{"name":"LaurentPolynomial.smeval_T_pow","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : MulActionWithZero R S\ninst✝ : Monoid S\nn : Int\nx : Units S\n⊢ Eq ((LaurentPolynomial.T n).smeval x) ↑(HPow.hPow x n)","decl":"@[simp]\ntheorem smeval_T_pow (n : ℤ) (x : Sˣ) : (T n : R[T;T⁻¹]).smeval x = (x ^ n).val := by\n  rw [T, smeval_single, one_smul]\n\n"}
{"name":"LaurentPolynomial.smeval_one","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : MulActionWithZero R S\ninst✝ : Monoid S\nx : Units S\n⊢ Eq (LaurentPolynomial.smeval 1 x) 1","decl":"@[simp]\ntheorem smeval_one : (1 : R[T;T⁻¹]).smeval x = 1 := by\n  rw [← T_zero, smeval_T_pow 0 x, zpow_zero, Units.val_eq_one]\n\n"}
{"name":"LaurentPolynomial.smeval_add","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : Module R S\ninst✝ : Monoid S\nf g : LaurentPolynomial R\nx : Units S\n⊢ Eq ((HAdd.hAdd f g).smeval x) (HAdd.hAdd (f.smeval x) (g.smeval x))","decl":"@[simp]\ntheorem smeval_add : (f + g).smeval x = f.smeval x + g.smeval x := by\n  simp only [smeval_eq_sum]\n  rw [Finsupp.sum_add_index (fun n _ => zero_smul R (x ^ n).val) (fun n _ r r' => add_smul r r' _)]\n\n"}
{"name":"LaurentPolynomial.smeval_C_mul","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : Module R S\ninst✝ : Monoid S\nf : LaurentPolynomial R\nx : Units S\nr : R\n⊢ Eq ((HMul.hMul (LaurentPolynomial.C r) f).smeval x) (HSMul.hSMul r (f.smeval x))","decl":"@[simp]\ntheorem smeval_C_mul (r : R) : (C r * f).smeval x = r • (f.smeval x) := by\n  induction f using LaurentPolynomial.induction_on' with\n  | h_add p q hp hq=>\n    rw [mul_add, smeval_add, smeval_add, smul_add, hp, hq]\n  | h_C_mul_T n s =>\n    rw [← mul_assoc, ← map_mul, smeval_C_mul_T_n, smeval_C_mul_T_n, mul_smul]\n\n"}
{"name":"LaurentPolynomial.leval_apply","module":"Mathlib.Algebra.Polynomial.Laurent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid S\ninst✝¹ : Module R S\ninst✝ : Monoid S\nx : Units S\nf : LaurentPolynomial R\n⊢ Eq ((LaurentPolynomial.leval R x) f) (f.smeval x)","decl":"variable (R) in\n/-- Evaluation as an `R`-linear map. -/\n@[simps]\ndef leval : R[T;T⁻¹] →ₗ[R] S where\n  toFun f := f.smeval x\n  map_add' f g := smeval_add f g x\n  map_smul' r f := by simp [smul_eq_C_mul]\n\n"}
