{"name":"List.Ico.zero_bot","module":"Mathlib.Data.List.Intervals","initialProofState":"n : Nat\n⊢ Eq (List.Ico 0 n) (List.range n)","decl":"theorem zero_bot (n : ℕ) : Ico 0 n = range n := by rw [Ico, Nat.sub_zero, range_eq_range']\n\n"}
{"name":"List.Ico.length","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ Eq (List.Ico n m).length (HSub.hSub m n)","decl":"@[simp]\ntheorem length (n m : ℕ) : length (Ico n m) = m - n := by\n  dsimp [Ico]\n  simp [length_range']\n\n"}
{"name":"List.Ico.pairwise_lt","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ List.Pairwise (fun x1 x2 => LT.lt x1 x2) (List.Ico n m)","decl":"theorem pairwise_lt (n m : ℕ) : Pairwise (· < ·) (Ico n m) := by\n  dsimp [Ico]\n  simp [pairwise_lt_range']\n\n"}
{"name":"List.Ico.nodup","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ (List.Ico n m).Nodup","decl":"theorem nodup (n m : ℕ) : Nodup (Ico n m) := by\n  dsimp [Ico]\n  simp [nodup_range']\n\n"}
{"name":"List.Ico.mem","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\n⊢ Iff (Membership.mem (List.Ico n m) l) (And (LE.le n l) (LT.lt l m))","decl":"@[simp]\ntheorem mem {n m l : ℕ} : l ∈ Ico n m ↔ n ≤ l ∧ l < m := by\n  suffices n ≤ l ∧ l < n + (m - n) ↔ n ≤ l ∧ l < m by simp [Ico, this]\n  omega\n\n"}
{"name":"List.Ico.eq_nil_of_le","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\nh : LE.le m n\n⊢ Eq (List.Ico n m) List.nil","decl":"theorem eq_nil_of_le {n m : ℕ} (h : m ≤ n) : Ico n m = [] := by\n  simp [Ico, Nat.sub_eq_zero_iff_le.mpr h]\n\n"}
{"name":"List.Ico.map_add","module":"Mathlib.Data.List.Intervals","initialProofState":"n m k : Nat\n⊢ Eq (List.map (fun x => HAdd.hAdd k x) (List.Ico n m)) (List.Ico (HAdd.hAdd n k) (HAdd.hAdd m k))","decl":"theorem map_add (n m k : ℕ) : (Ico n m).map (k + ·) = Ico (n + k) (m + k) := by\n  rw [Ico, Ico, map_add_range', Nat.add_sub_add_right m k, Nat.add_comm n k]\n\n"}
{"name":"List.Ico.map_sub","module":"Mathlib.Data.List.Intervals","initialProofState":"n m k : Nat\nh₁ : LE.le k n\n⊢ Eq (List.map (fun x => HSub.hSub x k) (List.Ico n m)) (List.Ico (HSub.hSub n k) (HSub.hSub m k))","decl":"theorem map_sub (n m k : ℕ) (h₁ : k ≤ n) :\n    ((Ico n m).map fun x => x - k) = Ico (n - k) (m - k) := by\n  rw [Ico, Ico, Nat.sub_sub_sub_cancel_right h₁, map_sub_range' _ _ _ h₁]\n\n"}
{"name":"List.Ico.self_empty","module":"Mathlib.Data.List.Intervals","initialProofState":"n : Nat\n⊢ Eq (List.Ico n n) List.nil","decl":"@[simp]\ntheorem self_empty {n : ℕ} : Ico n n = [] :=\n  eq_nil_of_le (le_refl n)\n\n"}
{"name":"List.Ico.eq_empty_iff","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ Iff (Eq (List.Ico n m) List.nil) (LE.le m n)","decl":"@[simp]\ntheorem eq_empty_iff {n m : ℕ} : Ico n m = [] ↔ m ≤ n :=\n  Iff.intro (fun h => Nat.sub_eq_zero_iff_le.mp <| by rw [← length, h, List.length]) eq_nil_of_le\n\n"}
{"name":"List.Ico.append_consecutive","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhnm : LE.le n m\nhml : LE.le m l\n⊢ Eq (HAppend.hAppend (List.Ico n m) (List.Ico m l)) (List.Ico n l)","decl":"theorem append_consecutive {n m l : ℕ} (hnm : n ≤ m) (hml : m ≤ l) :\n    Ico n m ++ Ico m l = Ico n l := by\n  dsimp only [Ico]\n  convert range'_append n (m-n) (l-m) 1 using 2\n  · rw [Nat.one_mul, Nat.add_sub_cancel' hnm]\n  · rw [Nat.sub_add_sub_cancel hml hnm]\n\n"}
{"name":"List.Ico.inter_consecutive","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\n⊢ Eq (Inter.inter (List.Ico n m) (List.Ico m l)) List.nil","decl":"@[simp]\ntheorem inter_consecutive (n m l : ℕ) : Ico n m ∩ Ico m l = [] := by\n  apply eq_nil_iff_forall_not_mem.2\n  intro a\n  simp only [and_imp, not_and, not_lt, List.mem_inter_iff, List.Ico.mem]\n  intro _ h₂ h₃\n  exfalso\n  exact not_lt_of_ge h₃ h₂\n\n"}
{"name":"List.Ico.bagInter_consecutive","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\n⊢ Eq ((List.Ico n m).bagInter (List.Ico m l)) List.nil","decl":"@[simp]\ntheorem bagInter_consecutive (n m l : Nat) :\n    @List.bagInter ℕ instBEqOfDecidableEq (Ico n m) (Ico m l) = [] :=\n  (bagInter_nil_iff_inter_nil _ _).2 (by convert inter_consecutive n m l)\n\n"}
{"name":"List.Ico.succ_singleton","module":"Mathlib.Data.List.Intervals","initialProofState":"n : Nat\n⊢ Eq (List.Ico n (HAdd.hAdd n 1)) (List.cons n List.nil)","decl":"@[simp]\ntheorem succ_singleton {n : ℕ} : Ico n (n + 1) = [n] := by\n  dsimp [Ico]\n  simp [range', Nat.add_sub_cancel_left]\n\n"}
{"name":"List.Ico.succ_top","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\nh : LE.le n m\n⊢ Eq (List.Ico n (HAdd.hAdd m 1)) (HAppend.hAppend (List.Ico n m) (List.cons m List.nil))","decl":"theorem succ_top {n m : ℕ} (h : n ≤ m) : Ico n (m + 1) = Ico n m ++ [m] := by\n  rwa [← succ_singleton, append_consecutive]\n  exact Nat.le_succ _\n\n"}
{"name":"List.Ico.eq_cons","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\nh : LT.lt n m\n⊢ Eq (List.Ico n m) (List.cons n (List.Ico (HAdd.hAdd n 1) m))","decl":"theorem eq_cons {n m : ℕ} (h : n < m) : Ico n m = n :: Ico (n + 1) m := by\n  rw [← append_consecutive (Nat.le_succ n) h, succ_singleton]\n  rfl\n\n"}
{"name":"List.Ico.pred_singleton","module":"Mathlib.Data.List.Intervals","initialProofState":"m : Nat\nh : LT.lt 0 m\n⊢ Eq (List.Ico (HSub.hSub m 1) m) (List.cons (HSub.hSub m 1) List.nil)","decl":"@[simp]\ntheorem pred_singleton {m : ℕ} (h : 0 < m) : Ico (m - 1) m = [m - 1] := by\n  simp [Ico, Nat.sub_sub_self (succ_le_of_lt h)]\n\n"}
{"name":"List.Ico.chain'_succ","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ List.Chain' (fun a b => Eq b a.succ) (List.Ico n m)","decl":"theorem chain'_succ (n m : ℕ) : Chain' (fun a b => b = succ a) (Ico n m) := by\n  by_cases h : n < m\n  · rw [eq_cons h]\n    exact chain_succ_range' _ _ 1\n  · rw [eq_nil_of_le (le_of_not_gt h)]\n    trivial\n\n"}
{"name":"List.Ico.not_mem_top","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\n⊢ Not (Membership.mem (List.Ico n m) m)","decl":"theorem not_mem_top {n m : ℕ} : m ∉ Ico n m := by simp\n\n"}
{"name":"List.Ico.filter_lt_of_top_le","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhml : LE.le m l\n⊢ Eq (List.filter (fun x => Decidable.decide (LT.lt x l)) (List.Ico n m)) (List.Ico n m)","decl":"theorem filter_lt_of_top_le {n m l : ℕ} (hml : m ≤ l) :\n    ((Ico n m).filter fun x => x < l) = Ico n m :=\n  filter_eq_self.2 fun k hk => by\n    simp only [(lt_of_lt_of_le (mem.1 hk).2 hml), decide_true]\n\n"}
{"name":"List.Ico.filter_lt_of_le_bot","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhln : LE.le l n\n⊢ Eq (List.filter (fun x => Decidable.decide (LT.lt x l)) (List.Ico n m)) List.nil","decl":"theorem filter_lt_of_le_bot {n m l : ℕ} (hln : l ≤ n) : ((Ico n m).filter fun x => x < l) = [] :=\n  filter_eq_nil_iff.2 fun k hk => by\n     simp only [decide_eq_true_eq, not_lt]\n     apply le_trans hln\n     exact (mem.1 hk).1\n\n"}
{"name":"List.Ico.filter_lt_of_ge","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhlm : LE.le l m\n⊢ Eq (List.filter (fun x => Decidable.decide (LT.lt x l)) (List.Ico n m)) (List.Ico n l)","decl":"theorem filter_lt_of_ge {n m l : ℕ} (hlm : l ≤ m) :\n    ((Ico n m).filter fun x => x < l) = Ico n l := by\n  rcases le_total n l with hnl | hln\n  · rw [← append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l),\n      filter_lt_of_le_bot (le_refl l), append_nil]\n  · rw [eq_nil_of_le hln, filter_lt_of_le_bot hln]\n\n"}
{"name":"List.Ico.filter_lt","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\n⊢ Eq (List.filter (fun x => Decidable.decide (LT.lt x l)) (List.Ico n m)) (List.Ico n (Min.min m l))","decl":"@[simp]\ntheorem filter_lt (n m l : ℕ) :\n    ((Ico n m).filter fun x => x < l) = Ico n (min m l) := by\n  rcases le_total m l with hml | hlm\n  · rw [min_eq_left hml, filter_lt_of_top_le hml]\n  · rw [min_eq_right hlm, filter_lt_of_ge hlm]\n\n"}
{"name":"List.Ico.filter_le_of_le_bot","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhln : LE.le l n\n⊢ Eq (List.filter (fun x => Decidable.decide (LE.le l x)) (List.Ico n m)) (List.Ico n m)","decl":"theorem filter_le_of_le_bot {n m l : ℕ} (hln : l ≤ n) :\n    ((Ico n m).filter fun x => l ≤ x) = Ico n m :=\n  filter_eq_self.2 fun k hk => by\n    rw [decide_eq_true_eq]\n    exact le_trans hln (mem.1 hk).1\n\n"}
{"name":"List.Ico.filter_le_of_top_le","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhml : LE.le m l\n⊢ Eq (List.filter (fun x => Decidable.decide (LE.le l x)) (List.Ico n m)) List.nil","decl":"theorem filter_le_of_top_le {n m l : ℕ} (hml : m ≤ l) : ((Ico n m).filter fun x => l ≤ x) = [] :=\n  filter_eq_nil_iff.2 fun k hk => by\n    rw [decide_eq_true_eq]\n    exact not_le_of_gt (lt_of_lt_of_le (mem.1 hk).2 hml)\n\n"}
{"name":"List.Ico.filter_le_of_le","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\nhnl : LE.le n l\n⊢ Eq (List.filter (fun x => Decidable.decide (LE.le l x)) (List.Ico n m)) (List.Ico l m)","decl":"theorem filter_le_of_le {n m l : ℕ} (hnl : n ≤ l) :\n    ((Ico n m).filter fun x => l ≤ x) = Ico l m := by\n  rcases le_total l m with hlm | hml\n  · rw [← append_consecutive hnl hlm, filter_append, filter_le_of_top_le (le_refl l),\n      filter_le_of_le_bot (le_refl l), nil_append]\n  · rw [eq_nil_of_le hml, filter_le_of_top_le hml]\n\n"}
{"name":"List.Ico.filter_le","module":"Mathlib.Data.List.Intervals","initialProofState":"n m l : Nat\n⊢ Eq (List.filter (fun x => Decidable.decide (LE.le l x)) (List.Ico n m)) (List.Ico (Max.max n l) m)","decl":"@[simp]\ntheorem filter_le (n m l : ℕ) : ((Ico n m).filter fun x => l ≤ x) = Ico (max n l) m := by\n  rcases le_total n l with hnl | hln\n  · rw [max_eq_right hnl, filter_le_of_le hnl]\n  · rw [max_eq_left hln, filter_le_of_le_bot hln]\n\n"}
{"name":"List.Ico.filter_lt_of_succ_bot","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\nhnm : LT.lt n m\n⊢ Eq (List.filter (fun x => Decidable.decide (LT.lt x (HAdd.hAdd n 1))) (List.Ico n m)) (List.cons n List.nil)","decl":"theorem filter_lt_of_succ_bot {n m : ℕ} (hnm : n < m) :\n    ((Ico n m).filter fun x => x < n + 1) = [n] := by\n  have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm\n  simp [filter_lt n m (n + 1), r]\n\n"}
{"name":"List.Ico.filter_le_of_bot","module":"Mathlib.Data.List.Intervals","initialProofState":"n m : Nat\nhnm : LT.lt n m\n⊢ Eq (List.filter (fun x => Decidable.decide (LE.le x n)) (List.Ico n m)) (List.cons n List.nil)","decl":"@[simp]\ntheorem filter_le_of_bot {n m : ℕ} (hnm : n < m) : ((Ico n m).filter fun x => x ≤ n) = [n] := by\n  rw [← filter_lt_of_succ_bot hnm]\n  exact filter_congr fun _ _ => by\n    simpa using Nat.lt_succ_iff.symm\n\n"}
{"name":"List.Ico.trichotomy","module":"Mathlib.Data.List.Intervals","initialProofState":"n a b : Nat\n⊢ Or (LT.lt n a) (Or (LE.le b n) (Membership.mem (List.Ico a b) n))","decl":"/-- For any natural numbers n, a, and b, one of the following holds:\n1. n < a\n2. n ≥ b\n3. n ∈ Ico a b\n-/\ntheorem trichotomy (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ Ico a b := by\n  by_cases h₁ : n < a\n  · left\n    exact h₁\n  · right\n    by_cases h₂ : n ∈ Ico a b\n    · right\n      exact h₂\n    · left\n      simp only [Ico.mem, not_and, not_lt] at *\n      exact h₂ h₁\n\n"}
