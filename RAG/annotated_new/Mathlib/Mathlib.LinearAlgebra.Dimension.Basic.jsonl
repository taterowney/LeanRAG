{"name":"Module.rank_def","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.rank R M) (iSup fun ι => Cardinal.mk ↑↑ι)","decl":"/-- The rank of a module, defined as a term of type `Cardinal`.\n\nWe define this as the supremum of the cardinalities of linearly independent subsets.\nThe supremum may not be attained, see https://mathoverflow.net/a/263053.\n\nFor a free module over any ring satisfying the strong rank condition\n(e.g. left-noetherian rings, commutative rings, and in particular division rings and fields),\nthis is the same as the dimension of the space (i.e. the cardinality of any basis).\n\nIn particular this agrees with the usual notion of the dimension of a vector space. -/\n@[stacks 09G3 \"first part\"]\nprotected irreducible_def Module.rank : Cardinal :=\n  ⨆ ι : { s : Set M // LinearIndependent R ((↑) : s → M) }, (#ι.1)\n\n"}
{"name":"rank_le_card","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LE.le (Module.rank R M) (Cardinal.mk M)","decl":"theorem rank_le_card : Module.rank R M ≤ #M :=\n  (Module.rank_def _ _).trans_le (ciSup_le' fun _ ↦ mk_set_le _)\n\n"}
{"name":"nonempty_linearIndependent_set","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Nonempty (Subtype fun s => LinearIndependent R Subtype.val)","decl":"lemma nonempty_linearIndependent_set : Nonempty {s : Set M // LinearIndependent R ((↑) : s → M)} :=\n  ⟨⟨∅, linearIndependent_empty _ _⟩⟩\n\n"}
{"name":"LinearIndependent.cardinal_lift_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nι : Type w\nv : ι → M\nhv : LinearIndependent R v\n⊢ LE.le (Cardinal.lift.{v, w} (Cardinal.mk ι)) (Cardinal.lift.{w, v} (Module.rank R M))","decl":"theorem cardinal_lift_le_rank {ι : Type w} {v : ι → M}\n    (hv : LinearIndependent R v) :\n    Cardinal.lift.{v} #ι ≤ Cardinal.lift.{w} (Module.rank R M) := by\n  rw [Module.rank]\n  refine le_trans ?_ (lift_le.mpr <| le_ciSup (bddAbove_range _) ⟨_, hv.coe_range⟩)\n  exact lift_mk_le'.mpr ⟨(Equiv.ofInjective _ hv.injective).toEmbedding⟩\n\n"}
{"name":"LinearIndependent.aleph0_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\nι : Type w\ninst✝ : Infinite ι\nv : ι → M\nhv : LinearIndependent R v\n⊢ LE.le Cardinal.aleph0 (Module.rank R M)","decl":"lemma aleph0_le_rank {ι : Type w} [Infinite ι] {v : ι → M}\n    (hv : LinearIndependent R v) : ℵ₀ ≤ Module.rank R M :=\n  aleph0_le_lift.mp <| (aleph0_le_lift.mpr <| aleph0_le_mk ι).trans hv.cardinal_lift_le_rank\n\n"}
{"name":"LinearIndependent.cardinal_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nι : Type v\nv : ι → M\nhv : LinearIndependent R v\n⊢ LE.le (Cardinal.mk ι) (Module.rank R M)","decl":"theorem cardinal_le_rank {ι : Type v} {v : ι → M}\n    (hv : LinearIndependent R v) : #ι ≤ Module.rank R M := by\n  simpa using hv.cardinal_lift_le_rank\n\n"}
{"name":"LinearIndependent.cardinal_le_rank'","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ns : Set M\nhs : LinearIndependent R fun x => ↑x\n⊢ LE.le (Cardinal.mk ↑s) (Module.rank R M)","decl":"theorem cardinal_le_rank' {s : Set M}\n    (hs : LinearIndependent R (fun x => x : s → M)) : #s ≤ Module.rank R M :=\n  hs.cardinal_le_rank\n\n"}
{"name":"lift_rank_le_of_injective_injectiveₛ","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\ni : R' → R\nj : AddMonoidHom M M'\nhi : Function.Injective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R' M'))","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R' → R` is an injective map\nnon-zero elements, `j : M →+ M'` is an injective monoid homomorphism, such that the scalar\nmultiplications on `M` and `M'` are compatible, then the rank of `M / R` is smaller than or equal to\nthe rank of `M' / R'`. As a special case, taking `R = R'` it is\n`LinearMap.lift_rank_le_of_injective`. -/\ntheorem lift_rank_le_of_injective_injectiveₛ (i : R' → R) (j : M →+ M')\n    (hi : Injective i) (hj : Injective j)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) :\n    lift.{v'} (Module.rank R M) ≤ lift.{v} (Module.rank R' M') := by\n  simp_rw [Module.rank, lift_iSup (bddAbove_range _)]\n  exact ciSup_mono' (bddAbove_range _) fun ⟨s, h⟩ ↦ ⟨⟨j '' s,\n    (h.map_of_injective_injectiveₛ i j hi hj hc).image⟩,\n      lift_mk_le'.mpr ⟨(Equiv.Set.image j s hj).toEmbedding⟩⟩\n\n"}
{"name":"lift_rank_le_of_surjective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\ni : R → R'\nj : AddMonoidHom M M'\nhi : Function.Surjective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R' M'))","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R → R'` is a surjective map, and\n`j : M →+ M'` is an injective monoid homomorphism, such that the scalar multiplications on `M` and\n`M'` are compatible, then the rank of `M / R` is smaller than or equal to the rank of `M' / R'`.\nAs a special case, taking `R = R'` it is `LinearMap.lift_rank_le_of_injective`. -/\ntheorem lift_rank_le_of_surjective_injective (i : R → R') (j : M →+ M')\n    (hi : Surjective i) (hj : Injective j) (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) :\n    lift.{v'} (Module.rank R M) ≤ lift.{v} (Module.rank R' M') := by\n  obtain ⟨i', hi'⟩ := hi.hasRightInverse\n  refine lift_rank_le_of_injective_injectiveₛ i' j (fun _ _ h ↦ ?_) hj fun r m ↦ ?_\n  · apply_fun i at h\n    rwa [hi', hi'] at h\n  rw [hc (i' r) m, hi']\n\n"}
{"name":"lift_rank_eq_of_equiv_equiv","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\ni : R → R'\nj : AddEquiv M M'\nhi : Function.Bijective i\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ Eq (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R' M'))","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R → R'` is a bijective map which maps zero to zero,\n`j : M ≃+ M'` is a group isomorphism, such that the scalar multiplications on `M` and `M'` are\ncompatible, then the rank of `M / R` is equal to the rank of `M' / R'`.\nAs a special case, taking `R = R'` it is `LinearEquiv.lift_rank_eq`. -/\ntheorem lift_rank_eq_of_equiv_equiv (i : R → R') (j : M ≃+ M')\n    (hi : Bijective i) (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) :\n    lift.{v'} (Module.rank R M) = lift.{v} (Module.rank R' M') :=\n  (lift_rank_le_of_surjective_injective i j hi.2 j.injective hc).antisymm <|\n    lift_rank_le_of_injective_injectiveₛ i j.symm hi.1\n      j.symm.injective fun _ _ ↦ j.symm_apply_eq.2 <| by erw [hc, j.apply_symm_apply]\n"}
{"name":"rank_le_of_injective_injectiveₛ","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM M₁ : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R' M₁\ni : R' → R\nj : AddMonoidHom M M₁\nhi : Function.Injective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LE.le (Module.rank R M) (Module.rank R' M₁)","decl":"/-- The same-universe version of `lift_rank_le_of_injective_injective`. -/\ntheorem rank_le_of_injective_injectiveₛ (i : R' → R) (j : M →+ M₁)\n    (hi : Injective i) (hj : Injective j)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) :\n    Module.rank R M ≤ Module.rank R' M₁ := by\n  simpa only [lift_id] using lift_rank_le_of_injective_injectiveₛ i j hi hj hc\n\n"}
{"name":"rank_le_of_surjective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM M₁ : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R' M₁\ni : R → R'\nj : AddMonoidHom M M₁\nhi : Function.Surjective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ LE.le (Module.rank R M) (Module.rank R' M₁)","decl":"/-- The same-universe version of `lift_rank_le_of_surjective_injective`. -/\ntheorem rank_le_of_surjective_injective (i : R → R') (j : M →+ M₁)\n    (hi : Surjective i) (hj : Injective j)\n    (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) :\n    Module.rank R M ≤ Module.rank R' M₁ := by\n  simpa only [lift_id] using lift_rank_le_of_surjective_injective i j hi hj hc\n\n"}
{"name":"rank_eq_of_equiv_equiv","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM M₁ : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R' M₁\ni : R → R'\nj : AddEquiv M M₁\nhi : Function.Bijective i\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ Eq (Module.rank R M) (Module.rank R' M₁)","decl":"/-- The same-universe version of `lift_rank_eq_of_equiv_equiv`. -/\ntheorem rank_eq_of_equiv_equiv (i : R → R') (j : M ≃+ M₁)\n    (hi : Bijective i) (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) :\n    Module.rank R M = Module.rank R' M₁ := by\n  simpa only [lift_id] using lift_rank_eq_of_equiv_equiv i j hi hc\n\n"}
{"name":"lift_rank_le_of_injective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM : Type v\nM' : Type v'\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Ring R'\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R' M'\ni : R' → R\nj : AddMonoidHom M M'\nhi : ∀ (r : R'), Eq (i r) 0 → Eq r 0\nhj : Function.Injective ⇑j\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R' M'))","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R' → R` is a map which sends non-zero elements to\nnon-zero elements, `j : M →+ M'` is an injective group homomorphism, such that the scalar\nmultiplications on `M` and `M'` are compatible, then the rank of `M / R` is smaller than or equal to\nthe rank of `M' / R'`. As a special case, taking `R = R'` it is\n`LinearMap.lift_rank_le_of_injective`. -/\ntheorem lift_rank_le_of_injective_injective [AddCommGroup M'] [Module R' M']\n    (i : R' → R) (j : M →+ M') (hi : ∀ r, i r = 0 → r = 0) (hj : Injective j)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) :\n    lift.{v'} (Module.rank R M) ≤ lift.{v} (Module.rank R' M') := by\n  simp_rw [Module.rank, lift_iSup (bddAbove_range _)]\n  exact ciSup_mono' (bddAbove_range _) fun ⟨s, h⟩ ↦ ⟨⟨j '' s,\n    (h.map_of_injective_injective i j hi (fun _ _ ↦ hj <| by rwa [j.map_zero]) hc).image⟩,\n      lift_mk_le'.mpr ⟨(Equiv.Set.image j s hj).toEmbedding⟩⟩\n\n"}
{"name":"rank_le_of_injective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nR' : Type u'\nM M₁ : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Ring R'\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R' M₁\ni : R' → R\nj : AddMonoidHom M M₁\nhi : ∀ (r : R'), Eq (i r) 0 → Eq r 0\nhj : Function.Injective ⇑j\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LE.le (Module.rank R M) (Module.rank R' M₁)","decl":"/-- The same-universe version of `lift_rank_le_of_injective_injective`. -/\ntheorem rank_le_of_injective_injective [AddCommGroup M₁] [Module R' M₁]\n    (i : R' → R) (j : M →+ M₁) (hi : ∀ r, i r = 0 → r = 0) (hj : Injective j)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) :\n    Module.rank R M ≤ Module.rank R' M₁ := by\n  simpa only [lift_id] using lift_rank_le_of_injective_injective i j hi hj hc\n\n"}
{"name":"Algebra.lift_rank_le_of_injective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\nS' : Type v'\ninst✝² : CommSemiring R'\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingHom R' R\nj : RingHom S S'\nhi : Function.Injective ⇑i\nhj : Function.Injective ⇑j\nhc : Eq ((j.comp (algebraMap R S)).comp i) (algebraMap R' S')\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R S)) (Cardinal.lift.{v, v'} (Module.rank R' S'))","decl":"/-- If `S / R` and `S' / R'` are algebras, `i : R' →+* R` and `j : S →+* S'` are injective ring\nhomomorphisms, such that `R' → R → S → S'` and `R' → S'` commute, then the rank of `S / R` is\nsmaller than or equal to the rank of `S' / R'`. -/\ntheorem lift_rank_le_of_injective_injective\n    (i : R' →+* R) (j : S →+* S') (hi : Injective i) (hj : Injective j)\n    (hc : (j.comp (algebraMap R S)).comp i = algebraMap R' S') :\n    lift.{v'} (Module.rank R S) ≤ lift.{v} (Module.rank R' S') := by\n  refine _root_.lift_rank_le_of_injective_injectiveₛ i j hi hj fun r _ ↦ ?_\n  have := congr($hc r)\n  simp only [RingHom.coe_comp, comp_apply] at this\n  simp_rw [smul_def, AddMonoidHom.coe_coe, map_mul, this]\n\n"}
{"name":"Algebra.lift_rank_le_of_surjective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\nS' : Type v'\ninst✝² : CommSemiring R'\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingHom R R'\nj : RingHom S S'\nhi : Function.Surjective ⇑i\nhj : Function.Injective ⇑j\nhc : Eq ((algebraMap R' S').comp i) (j.comp (algebraMap R S))\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R S)) (Cardinal.lift.{v, v'} (Module.rank R' S'))","decl":"/-- If `S / R` and `S' / R'` are algebras, `i : R →+* R'` is a surjective ring homomorphism,\n`j : S →+* S'` is an injective ring homomorphism, such that `R → R' → S'` and `R → S → S'` commute,\nthen the rank of `S / R` is smaller than or equal to the rank of `S' / R'`. -/\ntheorem lift_rank_le_of_surjective_injective\n    (i : R →+* R') (j : S →+* S') (hi : Surjective i) (hj : Injective j)\n    (hc : (algebraMap R' S').comp i = j.comp (algebraMap R S)) :\n    lift.{v'} (Module.rank R S) ≤ lift.{v} (Module.rank R' S') := by\n  refine _root_.lift_rank_le_of_surjective_injective i j hi hj fun r _ ↦ ?_\n  have := congr($hc r)\n  simp only [RingHom.coe_comp, comp_apply] at this\n  simp only [smul_def, AddMonoidHom.coe_coe, map_mul, ZeroHom.coe_coe, this]\n\n"}
{"name":"Algebra.lift_rank_eq_of_equiv_equiv","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\nS' : Type v'\ninst✝² : CommSemiring R'\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingEquiv R R'\nj : RingEquiv S S'\nhc : Eq ((algebraMap R' S').comp i.toRingHom) (j.toRingHom.comp (algebraMap R S))\n⊢ Eq (Cardinal.lift.{v', v} (Module.rank R S)) (Cardinal.lift.{v, v'} (Module.rank R' S'))","decl":"/-- If `S / R` and `S' / R'` are algebras, `i : R ≃+* R'` and `j : S ≃+* S'` are\nring isomorphisms, such that `R → R' → S'` and `R → S → S'` commute,\nthen the rank of `S / R` is equal to the rank of `S' / R'`. -/\ntheorem lift_rank_eq_of_equiv_equiv (i : R ≃+* R') (j : S ≃+* S')\n    (hc : (algebraMap R' S').comp i.toRingHom = j.toRingHom.comp (algebraMap R S)) :\n    lift.{v'} (Module.rank R S) = lift.{v} (Module.rank R' S') := by\n  refine _root_.lift_rank_eq_of_equiv_equiv i j i.bijective fun r _ ↦ ?_\n  have := congr($hc r)\n  simp only [RingEquiv.toRingHom_eq_coe, RingHom.coe_comp, RingHom.coe_coe, comp_apply] at this\n  simp only [smul_def, RingEquiv.coe_toAddEquiv, map_mul, ZeroHom.coe_coe, this]\n\n"}
{"name":"Algebra.rank_le_of_injective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\ninst✝² : CommSemiring R'\nS' : Type v\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingHom R' R\nj : RingHom S S'\nhi : Function.Injective ⇑i\nhj : Function.Injective ⇑j\nhc : Eq ((j.comp (algebraMap R S)).comp i) (algebraMap R' S')\n⊢ LE.le (Module.rank R S) (Module.rank R' S')","decl":"/-- The same-universe version of `Algebra.lift_rank_le_of_injective_injective`. -/\ntheorem rank_le_of_injective_injective\n    (i : R' →+* R) (j : S →+* S') (hi : Injective i) (hj : Injective j)\n    (hc : (j.comp (algebraMap R S)).comp i = algebraMap R' S') :\n    Module.rank R S ≤ Module.rank R' S' := by\n  simpa only [lift_id] using lift_rank_le_of_injective_injective i j hi hj hc\n\n"}
{"name":"Algebra.rank_le_of_surjective_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\ninst✝² : CommSemiring R'\nS' : Type v\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingHom R R'\nj : RingHom S S'\nhi : Function.Surjective ⇑i\nhj : Function.Injective ⇑j\nhc : Eq ((algebraMap R' S').comp i) (j.comp (algebraMap R S))\n⊢ LE.le (Module.rank R S) (Module.rank R' S')","decl":"/-- The same-universe version of `Algebra.lift_rank_le_of_surjective_injective`. -/\ntheorem rank_le_of_surjective_injective\n    (i : R →+* R') (j : S →+* S') (hi : Surjective i) (hj : Injective j)\n    (hc : (algebraMap R' S').comp i = j.comp (algebraMap R S)) :\n    Module.rank R S ≤ Module.rank R' S' := by\n  simpa only [lift_id] using lift_rank_le_of_surjective_injective i j hi hj hc\n\n"}
{"name":"Algebra.rank_eq_of_equiv_equiv","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type w\nS : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring S\ninst✝³ : Algebra R S\nR' : Type w'\ninst✝² : CommSemiring R'\nS' : Type v\ninst✝¹ : Semiring S'\ninst✝ : Algebra R' S'\ni : RingEquiv R R'\nj : RingEquiv S S'\nhc : Eq ((algebraMap R' S').comp i.toRingHom) (j.toRingHom.comp (algebraMap R S))\n⊢ Eq (Module.rank R S) (Module.rank R' S')","decl":"/-- The same-universe version of `Algebra.lift_rank_eq_of_equiv_equiv`. -/\ntheorem rank_eq_of_equiv_equiv (i : R ≃+* R') (j : S ≃+* S')\n    (hc : (algebraMap R' S').comp i.toRingHom = j.toRingHom.comp (algebraMap R S)) :\n    Module.rank R S = Module.rank R' S' := by\n  simpa only [lift_id] using lift_rank_eq_of_equiv_equiv i j hc\n\n"}
{"name":"LinearMap.lift_rank_le_of_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ni : Function.Injective ⇑f\n⊢ LE.le (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M'))","decl":"theorem LinearMap.lift_rank_le_of_injective (f : M →ₗ[R] M') (i : Injective f) :\n    Cardinal.lift.{v'} (Module.rank R M) ≤ Cardinal.lift.{v} (Module.rank R M') :=\n  lift_rank_le_of_injective_injectiveₛ (RingHom.id R) f (fun _ _ h ↦ h) i f.map_smul\n\n"}
{"name":"LinearMap.rank_le_of_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\ni : Function.Injective ⇑f\n⊢ LE.le (Module.rank R M) (Module.rank R M₁)","decl":"theorem LinearMap.rank_le_of_injective (f : M →ₗ[R] M₁) (i : Injective f) :\n    Module.rank R M ≤ Module.rank R M₁ :=\n  Cardinal.lift_le.1 (f.lift_rank_le_of_injective i)\n\n"}
{"name":"lift_rank_range_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ LE.le (Cardinal.lift.{v, v'} (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x))) (Cardinal.lift.{v', v} (Module.rank R M))","decl":"/-- The rank of the range of a linear map is at most the rank of the source. -/\n-- The proof is: a free submodule of the range lifts to a free submodule of the\n-- source, by arbitrarily lifting a basis.\ntheorem lift_rank_range_le (f : M →ₗ[R] M') : Cardinal.lift.{v}\n    (Module.rank R (LinearMap.range f)) ≤ Cardinal.lift.{v'} (Module.rank R M) := by\n  simp only [Module.rank_def]\n  rw [Cardinal.lift_iSup (Cardinal.bddAbove_range _)]\n  apply ciSup_le'\n  rintro ⟨s, li⟩\n  apply le_trans\n  swap\n  · apply Cardinal.lift_le.mpr\n    refine le_ciSup (Cardinal.bddAbove_range _) ⟨rangeSplitting f '' s, ?_⟩\n    apply LinearIndependent.of_comp f.rangeRestrict\n    convert li.comp (Equiv.Set.rangeSplittingImageEquiv f s) (Equiv.injective _) using 1\n  · exact (Cardinal.lift_mk_eq'.mpr ⟨Equiv.Set.rangeSplittingImageEquiv f s⟩).ge\n\n"}
{"name":"rank_range_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.rank R M)","decl":"theorem rank_range_le (f : M →ₗ[R] M₁) : Module.rank R (LinearMap.range f) ≤ Module.rank R M := by\n  simpa using lift_rank_range_le f\n\n"}
{"name":"lift_rank_map_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\np : Submodule R M\n⊢ LE.le (Cardinal.lift.{v, v'} (Module.rank R (Subtype fun x => Membership.mem (Submodule.map f p) x))) (Cardinal.lift.{v', v} (Module.rank R (Subtype fun x => Membership.mem p x)))","decl":"theorem lift_rank_map_le (f : M →ₗ[R] M') (p : Submodule R M) :\n    Cardinal.lift.{v} (Module.rank R (p.map f)) ≤ Cardinal.lift.{v'} (Module.rank R p) := by\n  have h := lift_rank_range_le (f.comp (Submodule.subtype p))\n  rwa [LinearMap.range_comp, range_subtype] at h\n\n"}
{"name":"rank_map_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Submodule.map f p) x)) (Module.rank R (Subtype fun x => Membership.mem p x))","decl":"theorem rank_map_le (f : M →ₗ[R] M₁) (p : Submodule R M) :\n    Module.rank R (p.map f) ≤ Module.rank R p := by simpa using lift_rank_map_le f p\n\n"}
{"name":"Submodule.rank_mono","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Submodule R M\nh : LE.le s t\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R (Subtype fun x => Membership.mem t x))","decl":"lemma Submodule.rank_mono {s t : Submodule R M} (h : s ≤ t) : Module.rank R s ≤ Module.rank R t :=\n  (Submodule.inclusion h).rank_le_of_injective fun ⟨x, _⟩ ⟨y, _⟩ eq =>\n    Subtype.eq <| show x = y from Subtype.ext_iff_val.1 eq\n\n"}
{"name":"rank_le_of_submodule","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Submodule R M\nh : LE.le s t\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R (Subtype fun x => Membership.mem t x))","decl":"@[deprecated (since := \"2024-09-30\")] alias rank_le_of_submodule := Submodule.rank_mono\n\n"}
{"name":"LinearEquiv.lift_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M'))","decl":"/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem LinearEquiv.lift_rank_eq (f : M ≃ₗ[R] M') :\n    Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M') := by\n  apply le_antisymm\n  · exact f.toLinearMap.lift_rank_le_of_injective f.injective\n  · exact f.symm.toLinearMap.lift_rank_le_of_injective f.symm.injective\n\n"}
{"name":"LinearEquiv.rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearEquiv (RingHom.id R) M M₁\n⊢ Eq (Module.rank R M) (Module.rank R M₁)","decl":"/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem LinearEquiv.rank_eq (f : M ≃ₗ[R] M₁) : Module.rank R M = Module.rank R M₁ :=\n  Cardinal.lift_inj.1 f.lift_rank_eq\n\n"}
{"name":"lift_rank_range_of_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nh : Function.Injective ⇑f\n⊢ Eq (Cardinal.lift.{v, v'} (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x))) (Cardinal.lift.{v', v} (Module.rank R M))","decl":"theorem lift_rank_range_of_injective (f : M →ₗ[R] M') (h : Injective f) :\n    lift.{v} (Module.rank R (LinearMap.range f)) = lift.{v'} (Module.rank R M) :=\n  (LinearEquiv.ofInjective f h).lift_rank_eq.symm\n\n"}
{"name":"rank_range_of_injective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\nh : Function.Injective ⇑f\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.rank R M)","decl":"theorem rank_range_of_injective (f : M →ₗ[R] M₁) (h : Injective f) :\n    Module.rank R (LinearMap.range f) = Module.rank R M :=\n  (LinearEquiv.ofInjective f h).rank_eq.symm\n\n"}
{"name":"LinearEquiv.lift_rank_map_eq","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearEquiv (RingHom.id R) M M'\np : Submodule R M\n⊢ Eq (Cardinal.lift.{v, v'} (Module.rank R (Subtype fun x => Membership.mem (Submodule.map (↑f) p) x))) (Cardinal.lift.{v', v} (Module.rank R (Subtype fun x => Membership.mem p x)))","decl":"theorem LinearEquiv.lift_rank_map_eq (f : M ≃ₗ[R] M') (p : Submodule R M) :\n    lift.{v} (Module.rank R (p.map (f : M →ₗ[R] M'))) = lift.{v'} (Module.rank R p) :=\n  (f.submoduleMap p).lift_rank_eq.symm\n\n"}
{"name":"LinearEquiv.rank_map_eq","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearEquiv (RingHom.id R) M M₁\np : Submodule R M\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Submodule.map (↑f) p) x)) (Module.rank R (Subtype fun x => Membership.mem p x))","decl":"/-- Pushforwards of submodules along a `LinearEquiv` have the same dimension. -/\ntheorem LinearEquiv.rank_map_eq (f : M ≃ₗ[R] M₁) (p : Submodule R M) :\n    Module.rank R (p.map (f : M →ₗ[R] M₁)) = Module.rank R p :=\n  (f.submoduleMap p).rank_eq.symm\n\n"}
{"name":"rank_top","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem Top.top x)) (Module.rank R M)","decl":"@[simp]\ntheorem rank_top : Module.rank R (⊤ : Submodule R M) = Module.rank R M :=\n  (LinearEquiv.ofTop ⊤ rfl).rank_eq\n\n"}
{"name":"rank_range_of_surjective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nh : Function.Surjective ⇑f\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.rank R M')","decl":"theorem rank_range_of_surjective (f : M →ₗ[R] M') (h : Surjective f) :\n    Module.rank R (LinearMap.range f) = Module.rank R M' := by\n  rw [LinearMap.range_eq_top.2 h, rank_top]\n\n"}
{"name":"Submodule.rank_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Submodule R M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R M)","decl":"theorem Submodule.rank_le (s : Submodule R M) : Module.rank R s ≤ Module.rank R M := by\n  rw [← rank_top R M]\n  exact rank_mono le_top\n\n"}
{"name":"rank_submodule_le","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Submodule R M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R M)","decl":"@[deprecated (since := \"2024-10-02\")] alias rank_submodule_le := Submodule.rank_le\n\n"}
{"name":"LinearMap.lift_rank_le_of_surjective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nh : Function.Surjective ⇑f\n⊢ LE.le (Cardinal.lift.{v, v'} (Module.rank R M')) (Cardinal.lift.{v', v} (Module.rank R M))","decl":"theorem LinearMap.lift_rank_le_of_surjective (f : M →ₗ[R] M') (h : Surjective f) :\n    lift.{v} (Module.rank R M') ≤ lift.{v'} (Module.rank R M) := by\n  rw [← rank_range_of_surjective f h]\n  apply lift_rank_range_le\n\n"}
{"name":"LinearMap.rank_le_of_surjective","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\nh : Function.Surjective ⇑f\n⊢ LE.le (Module.rank R M₁) (Module.rank R M)","decl":"theorem LinearMap.rank_le_of_surjective (f : M →ₗ[R] M₁) (h : Surjective f) :\n    Module.rank R M₁ ≤ Module.rank R M := by\n  rw [← rank_range_of_surjective f h]\n  apply rank_range_le\n\n"}
{"name":"rank_subsingleton","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton R\n⊢ Eq (Module.rank R M) 1","decl":"@[nontriviality, simp]\ntheorem rank_subsingleton [Subsingleton R] : Module.rank R M = 1 := by\n  haveI := Module.subsingleton R M\n  have : Nonempty { s : Set M // LinearIndependent R ((↑) : s → M) } :=\n    ⟨⟨∅, linearIndependent_empty _ _⟩⟩\n  rw [Module.rank_def, ciSup_eq_of_forall_le_of_forall_lt_exists_gt]\n  · rintro ⟨s, hs⟩\n    rw [Cardinal.mk_le_one_iff_set_subsingleton]\n    apply subsingleton_of_subsingleton\n  intro w hw\n  refine ⟨⟨{0}, ?_⟩, ?_⟩\n  · rw [linearIndependent_iff'ₛ]\n    subsingleton\n  · exact hw.trans_eq (Cardinal.mk_singleton _).symm\n\n"}
{"name":"rank_le_of_isSMulRegular","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nS : Type u_1\ninst✝³ : CommSemiring S\ninst✝² : Algebra S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\nL L' : Submodule R M\ns : S\nhr : IsSMulRegular M s\nh : ∀ (x : M), Membership.mem L x → Membership.mem L' (HSMul.hSMul s x)\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem L x)) (Module.rank R (Subtype fun x => Membership.mem L' x))","decl":"lemma rank_le_of_isSMulRegular {S : Type*} [CommSemiring S] [Algebra S R] [Module S M]\n    [IsScalarTower S R M] (L L' : Submodule R M) {s : S} (hr : IsSMulRegular M s)\n    (h : ∀ x ∈ L, s • x ∈ L') :\n    Module.rank R L ≤ Module.rank R L' :=\n  ((Algebra.lsmul S R M s).restrict h).rank_le_of_injective <|\n    fun _ _ h ↦ by simpa using hr (Subtype.ext_iff.mp h)\n\n"}
{"name":"rank_le_of_smul_regular","module":"Mathlib.LinearAlgebra.Dimension.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nS : Type u_1\ninst✝³ : CommSemiring S\ninst✝² : Algebra S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\nL L' : Submodule R M\ns : S\nhr : IsSMulRegular M s\nh : ∀ (x : M), Membership.mem L x → Membership.mem L' (HSMul.hSMul s x)\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem L x)) (Module.rank R (Subtype fun x => Membership.mem L' x))","decl":"@[deprecated (since := \"2024-11-21\")]\nalias rank_le_of_smul_regular := rank_le_of_isSMulRegular\n\n"}
