{"name":"Polynomial.newtonMap_apply","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\n⊢ Eq (P.newtonMap x) (HSub.hSub x (HMul.hMul (Ring.inverse ((Polynomial.aeval x) (Polynomial.derivative P))) ((Polynomial.aeval x) P)))","decl":"theorem newtonMap_apply :\n    P.newtonMap x = x - (Ring.inverse <| aeval x (derivative P)) * (aeval x P) :=\n  rfl\n\n"}
{"name":"Polynomial.newtonMap_apply_of_isUnit","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsUnit ((Polynomial.aeval x) (Polynomial.derivative P))\n⊢ Eq (P.newtonMap x) (HSub.hSub x (HMul.hMul (↑(Inv.inv h.unit)) ((Polynomial.aeval x) P)))","decl":"theorem newtonMap_apply_of_isUnit (h : IsUnit <| aeval x (derivative P)) :\n    P.newtonMap x = x - h.unit⁻¹ * aeval x P := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\n"}
{"name":"Polynomial.newtonMap_apply_of_not_isUnit","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : Not (IsUnit ((Polynomial.aeval x) (Polynomial.derivative P)))\n⊢ Eq (P.newtonMap x) x","decl":"theorem newtonMap_apply_of_not_isUnit (h : ¬ (IsUnit <| aeval x (derivative P))) :\n    P.newtonMap x = x := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\n"}
{"name":"Polynomial.isNilpotent_iterate_newtonMap_sub_of_isNilpotent","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsNilpotent ((Polynomial.aeval x) P)\nn : Nat\n⊢ IsNilpotent (HSub.hSub (Nat.iterate P.newtonMap n x) x)","decl":"theorem isNilpotent_iterate_newtonMap_sub_of_isNilpotent (h : IsNilpotent <| aeval x P) (n : ℕ) :\n    IsNilpotent <| P.newtonMap^[n] x - x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_right_comm]\n    refine (Commute.all _ _).isNilpotent_sub ih <| (Commute.all _ _).isNilpotent_mul_right ?_\n    simpa using Commute.isNilpotent_add (Commute.all _ _)\n      (isNilpotent_aeval_sub_of_isNilpotent_sub P ih) h\n\n"}
{"name":"Polynomial.isFixedPt_newtonMap_of_aeval_eq_zero","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : Eq ((Polynomial.aeval x) P) 0\n⊢ Function.IsFixedPt P.newtonMap x","decl":"theorem isFixedPt_newtonMap_of_aeval_eq_zero (h : aeval x P = 0) :\n    IsFixedPt P.newtonMap x := by\n  rw [IsFixedPt, newtonMap_apply, h, mul_zero, sub_zero]\n\n"}
{"name":"Polynomial.isFixedPt_newtonMap_of_isUnit_iff","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsUnit ((Polynomial.aeval x) (Polynomial.derivative P))\n⊢ Iff (Function.IsFixedPt P.newtonMap x) (Eq ((Polynomial.aeval x) P) 0)","decl":"theorem isFixedPt_newtonMap_of_isUnit_iff (h : IsUnit <| aeval x (derivative P)) :\n    IsFixedPt P.newtonMap x ↔ aeval x P = 0 := by\n  rw [IsFixedPt, newtonMap_apply, sub_eq_self, Ring.inverse_mul_eq_iff_eq_mul _ _ _ h, mul_zero]\n\n"}
{"name":"Polynomial.aeval_pow_two_pow_dvd_aeval_iterate_newtonMap","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsNilpotent ((Polynomial.aeval x) P)\nh' : IsUnit ((Polynomial.aeval x) (Polynomial.derivative P))\nn : Nat\n⊢ Dvd.dvd (HPow.hPow ((Polynomial.aeval x) P) (HPow.hPow 2 n)) ((Polynomial.aeval (Nat.iterate P.newtonMap n x)) P)","decl":"/-- This is really an auxiliary result, en route to\n`Polynomial.existsUnique_nilpotent_sub_and_aeval_eq_zero`. -/\ntheorem aeval_pow_two_pow_dvd_aeval_iterate_newtonMap\n    (h : IsNilpotent (aeval x P)) (h' : IsUnit (aeval x <| derivative P)) (n : ℕ) :\n    (aeval x P) ^ (2 ^ n) ∣ aeval (P.newtonMap^[n] x) P := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    have ⟨d, hd⟩ := binomExpansion (P.map (algebraMap R S)) (P.newtonMap^[n] x)\n      (-Ring.inverse (aeval (P.newtonMap^[n] x) <| derivative P) * aeval (P.newtonMap^[n] x) P)\n    rw [eval_map_algebraMap, eval_map_algebraMap] at hd\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_eq_add_neg, neg_mul_eq_neg_mul, hd]\n    refine dvd_add ?_ (dvd_mul_of_dvd_right ?_ _)\n    · convert dvd_zero _\n      have : IsUnit (aeval (P.newtonMap^[n] x) <| derivative P) :=\n        isUnit_aeval_of_isUnit_aeval_of_isNilpotent_sub h' <|\n        isNilpotent_iterate_newtonMap_sub_of_isNilpotent h n\n      rw [derivative_map, eval_map_algebraMap, ← mul_assoc, mul_neg, Ring.mul_inverse_cancel _ this,\n        neg_mul, one_mul, add_neg_cancel]\n    · rw [neg_mul, even_two.neg_pow, mul_pow, pow_succ, pow_mul]\n      exact dvd_mul_of_dvd_right (pow_dvd_pow_of_dvd ih 2) _\n\n"}
{"name":"Polynomial.existsUnique_nilpotent_sub_and_aeval_eq_zero","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsNilpotent ((Polynomial.aeval x) P)\nh' : IsUnit ((Polynomial.aeval x) (Polynomial.derivative P))\n⊢ ExistsUnique fun r => And (IsNilpotent (HSub.hSub x r)) (Eq ((Polynomial.aeval r) P) 0)","decl":"/-- If `x` is almost a root of `P` in the sense that `P(x)` is nilpotent (and `P'(x)` is a\nunit) then we may write `x` as a sum `x = n + r` where `n` is nilpotent and `r` is a root of `P`.\nMoreover, `n` and `r` are unique.\n\nThis can be used to prove the Jordan-Chevalley decomposition of linear endomorphims. -/\ntheorem existsUnique_nilpotent_sub_and_aeval_eq_zero\n    (h : IsNilpotent (aeval x P)) (h' : IsUnit (aeval x <| derivative P)) :\n    ∃! r, IsNilpotent (x - r) ∧ aeval r P = 0 := by\n  simp_rw [(neg_sub _ x).symm, isNilpotent_neg_iff]\n  refine existsUnique_of_exists_of_unique ?_ fun r₁ r₂ ⟨hr₁, hr₁'⟩ ⟨hr₂, hr₂'⟩ ↦ ?_\n  · -- Existence\n    obtain ⟨n, hn⟩ := id h\n    refine ⟨P.newtonMap^[n] x, isNilpotent_iterate_newtonMap_sub_of_isNilpotent h n, ?_⟩\n    rw [← zero_dvd_iff, ← pow_eq_zero_of_le (n.lt_two_pow_self).le hn]\n    exact aeval_pow_two_pow_dvd_aeval_iterate_newtonMap h h' n\n  · -- Uniqueness\n    have ⟨u, hu⟩ := binomExpansion (P.map (algebraMap R S)) r₁ (r₂ - r₁)\n    suffices IsUnit (aeval r₁ (derivative P) + u * (r₂ - r₁)) by\n      rwa [derivative_map, eval_map_algebraMap, eval_map_algebraMap, eval_map_algebraMap,\n        add_sub_cancel, hr₂', hr₁', zero_add, pow_two, ← mul_assoc, ← add_mul, eq_comm,\n        this.mul_right_eq_zero, sub_eq_zero, eq_comm] at hu\n    have : IsUnit (aeval r₁ (derivative P)) :=\n      isUnit_aeval_of_isUnit_aeval_of_isNilpotent_sub h' hr₁\n    rw [← sub_sub_sub_cancel_right r₂ r₁ x]\n    refine IsNilpotent.isUnit_add_left_of_commute ?_ this (Commute.all _ _)\n    exact (Commute.all _ _).isNilpotent_mul_right <| (Commute.all _ _).isNilpotent_sub hr₂ hr₁\n\n"}
{"name":"Polynomial.exists_unique_nilpotent_sub_and_aeval_eq_zero","module":"Mathlib.Dynamics.Newton","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\nx : S\nh : IsNilpotent ((Polynomial.aeval x) P)\nh' : IsUnit ((Polynomial.aeval x) (Polynomial.derivative P))\n⊢ ExistsUnique fun r => And (IsNilpotent (HSub.hSub x r)) (Eq ((Polynomial.aeval r) P) 0)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias exists_unique_nilpotent_sub_and_aeval_eq_zero := existsUnique_nilpotent_sub_and_aeval_eq_zero\n\n"}
