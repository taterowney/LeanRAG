{"name":"instWeaklyLocallyCompactSpaceProd","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : WeaklyLocallyCompactSpace X\ninst‚úù : WeaklyLocallyCompactSpace Y\n‚ä¢ WeaklyLocallyCompactSpace (Prod X Y)","decl":"instance [WeaklyLocallyCompactSpace X] [WeaklyLocallyCompactSpace Y] :\n    WeaklyLocallyCompactSpace (X √ó Y) where\n  exists_compact_mem_nhds x :=\n    let ‚ü®s‚ÇÅ, hc‚ÇÅ, h‚ÇÅ‚ü© := exists_compact_mem_nhds x.1\n    let ‚ü®s‚ÇÇ, hc‚ÇÇ, h‚ÇÇ‚ü© := exists_compact_mem_nhds x.2\n    ‚ü®s‚ÇÅ √óÀ¢ s‚ÇÇ, hc‚ÇÅ.prod hc‚ÇÇ, prod_mem_nhds h‚ÇÅ h‚ÇÇ‚ü©\n\n"}
{"name":"instWeaklyLocallyCompactSpaceForallOfFinite","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"Œπ : Type u_4\ninst‚úù¬≤ : Finite Œπ\nX : Œπ ‚Üí Type u_5\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), WeaklyLocallyCompactSpace (X i)\n‚ä¢ WeaklyLocallyCompactSpace ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} [Finite Œπ] {X : Œπ ‚Üí Type*} [(i : Œπ) ‚Üí TopologicalSpace (X i)]\n    [(i : Œπ) ‚Üí WeaklyLocallyCompactSpace (X i)] :\n    WeaklyLocallyCompactSpace ((i : Œπ) ‚Üí X i) where\n  exists_compact_mem_nhds f := by\n    choose s hsc hs using fun i ‚Ü¶ exists_compact_mem_nhds (f i)\n    exact ‚ü®pi univ s, isCompact_univ_pi hsc, set_pi_mem_nhds univ.toFinite fun i _ ‚Ü¶ hs i‚ü©\n\n"}
{"name":"instWeaklyLocallyCompactSpaceOfCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\n‚ä¢ WeaklyLocallyCompactSpace X","decl":"instance (priority := 100) [CompactSpace X] : WeaklyLocallyCompactSpace X where\n  exists_compact_mem_nhds _ := ‚ü®univ, isCompact_univ, univ_mem‚ü©\n\n"}
{"name":"Topology.IsClosedEmbedding.weaklyLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : WeaklyLocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ WeaklyLocallyCompactSpace X","decl":"protected theorem Topology.IsClosedEmbedding.weaklyLocallyCompactSpace [WeaklyLocallyCompactSpace Y]\n    {f : X ‚Üí Y} (hf : IsClosedEmbedding f) : WeaklyLocallyCompactSpace X where\n  exists_compact_mem_nhds x :=\n    let ‚ü®K, hK, hKx‚ü© := exists_compact_mem_nhds (f x)\n    ‚ü®f ‚Åª¬π' K, hf.isCompact_preimage hK, hf.continuous.continuousAt hKx‚ü©\n\n"}
{"name":"ClosedEmbedding.weaklyLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : WeaklyLocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ WeaklyLocallyCompactSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.weaklyLocallyCompactSpace := IsClosedEmbedding.weaklyLocallyCompactSpace\n\n"}
{"name":"IsClosed.weaklyLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : WeaklyLocallyCompactSpace X\ns : Set X\nhs : IsClosed s\n‚ä¢ WeaklyLocallyCompactSpace ‚Üës","decl":"protected theorem IsClosed.weaklyLocallyCompactSpace [WeaklyLocallyCompactSpace X]\n    {s : Set X} (hs : IsClosed s) : WeaklyLocallyCompactSpace s :=\n  hs.isClosedEmbedding_subtypeVal.weaklyLocallyCompactSpace\n\n"}
{"name":"IsOpenQuotientMap.weaklyLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : WeaklyLocallyCompactSpace X\nf : X ‚Üí Y\nhf : IsOpenQuotientMap f\n‚ä¢ WeaklyLocallyCompactSpace Y","decl":"theorem IsOpenQuotientMap.weaklyLocallyCompactSpace [WeaklyLocallyCompactSpace X]\n    {f : X ‚Üí Y} (hf : IsOpenQuotientMap f) : WeaklyLocallyCompactSpace Y where\n  exists_compact_mem_nhds := by\n    refine hf.surjective.forall.2 fun x ‚Ü¶ ?_\n    rcases exists_compact_mem_nhds x with ‚ü®K, hKc, hKx‚ü©\n    exact ‚ü®f '' K, hKc.image hf.continuous, hf.isOpenMap.image_mem_nhds hKx‚ü©\n\n"}
{"name":"exists_compact_superset","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : WeaklyLocallyCompactSpace X\nK : Set X\nhK : IsCompact K\n‚ä¢ Exists fun K' => And (IsCompact K') (HasSubset.Subset K (interior K'))","decl":"/-- In a weakly locally compact space,\nevery compact set is contained in the interior of a compact set. -/\ntheorem exists_compact_superset [WeaklyLocallyCompactSpace X] {K : Set X} (hK : IsCompact K) :\n    ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K' := by\n  choose s hc hmem using fun x : X ‚Ü¶ exists_compact_mem_nhds x\n  rcases hK.elim_nhds_subcover _ fun x _ ‚Ü¶ interior_mem_nhds.2 (hmem x) with ‚ü®I, -, hIK‚ü©\n  refine ‚ü®‚ãÉ x ‚àà I, s x, I.isCompact_biUnion fun _ _ ‚Ü¶ hc _, hIK.trans ?_‚ü©\n  exact iUnion‚ÇÇ_subset fun x hx ‚Ü¶ interior_mono <| subset_iUnion‚ÇÇ (s := fun x _ ‚Ü¶ s x) x hx\n\n"}
{"name":"disjoint_nhds_cocompact","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : WeaklyLocallyCompactSpace X\nx : X\n‚ä¢ Disjoint (nhds x) (Filter.cocompact X)","decl":"/-- In a weakly locally compact space,\nthe filters `ùìù x` and `cocompact X` are disjoint for all `X`. -/\ntheorem disjoint_nhds_cocompact [WeaklyLocallyCompactSpace X] (x : X) :\n    Disjoint (ùìù x) (cocompact X) :=\n  let ‚ü®_, hc, hx‚ü© := exists_compact_mem_nhds x\n  disjoint_of_disjoint_of_mem disjoint_compl_right hx hc.compl_mem_cocompact\n\n"}
{"name":"compact_basis_nhds","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (IsCompact s)) fun s => s","decl":"theorem compact_basis_nhds [LocallyCompactSpace X] (x : X) :\n    (ùìù x).HasBasis (fun s => s ‚àà ùìù x ‚àß IsCompact s) fun s => s :=\n  hasBasis_self.2 <| by simpa only [and_comm] using LocallyCompactSpace.local_compact_nhds x\n\n"}
{"name":"local_compact_nhds","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\nx : X\nn : Set X\nh : Membership.mem (nhds x) n\n‚ä¢ Exists fun s => And (Membership.mem (nhds x) s) (And (HasSubset.Subset s n) (IsCompact s))","decl":"theorem local_compact_nhds [LocallyCompactSpace X] {x : X} {n : Set X} (h : n ‚àà ùìù x) :\n    ‚àÉ s ‚àà ùìù x, s ‚äÜ n ‚àß IsCompact s :=\n  LocallyCompactSpace.local_compact_nhds _ _ h\n\n"}
{"name":"LocallyCompactSpace.of_hasBasis","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : X ‚Üí Type u_4\np : (x : X) ‚Üí Œπ x ‚Üí Prop\ns : (x : X) ‚Üí Œπ x ‚Üí Set X\nh : ‚àÄ (x : X), (nhds x).HasBasis (p x) (s x)\nhc : ‚àÄ (x : X) (i : Œπ x), p x i ‚Üí IsCompact (s x i)\n‚ä¢ LocallyCompactSpace X","decl":"theorem LocallyCompactSpace.of_hasBasis {Œπ : X ‚Üí Type*} {p : ‚àÄ x, Œπ x ‚Üí Prop}\n    {s : ‚àÄ x, Œπ x ‚Üí Set X} (h : ‚àÄ x, (ùìù x).HasBasis (p x) (s x))\n    (hc : ‚àÄ x i, p x i ‚Üí IsCompact (s x i)) : LocallyCompactSpace X :=\n  ‚ü®fun x _t ht =>\n    let ‚ü®i, hp, ht‚ü© := (h x).mem_iff.1 ht\n    ‚ü®s x i, (h x).mem_of_mem hp, ht, hc x i hp‚ü©‚ü©\n\n"}
{"name":"Prod.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_4\nY : Type u_5\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : LocallyCompactSpace Y\n‚ä¢ LocallyCompactSpace (Prod X Y)","decl":"instance Prod.locallyCompactSpace (X : Type*) (Y : Type*) [TopologicalSpace X]\n    [TopologicalSpace Y] [LocallyCompactSpace X] [LocallyCompactSpace Y] :\n    LocallyCompactSpace (X √ó Y) :=\n  have := fun x : X √ó Y => (compact_basis_nhds x.1).prod_nhds' (compact_basis_nhds x.2)\n .of_hasBasis this fun _ _ ‚ü®‚ü®_, h‚ÇÅ‚ü©, _, h‚ÇÇ‚ü© => h‚ÇÅ.prod h‚ÇÇ\n\n"}
{"name":"Pi.locallyCompactSpace_of_finite","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : Finite Œπ\n‚ä¢ LocallyCompactSpace ((i : Œπ) ‚Üí X i)","decl":"/-- In general it suffices that all but finitely many of the spaces are compact,\n  but that's not straightforward to state and use. -/\ninstance Pi.locallyCompactSpace_of_finite [Finite Œπ] : LocallyCompactSpace (‚àÄ i, X i) :=\n  ‚ü®fun t n hn => by\n    rw [nhds_pi, Filter.mem_pi] at hn\n    obtain ‚ü®s, -, n', hn', hsub‚ü© := hn\n    choose n'' hn'' hsub' hc using fun i =>\n      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)\n    refine ‚ü®(Set.univ : Set Œπ).pi n'', ?_, subset_trans (fun _ h => ?_) hsub, isCompact_univ_pi hc‚ü©\n    ¬∑ exact (set_pi_mem_nhds_iff (@Set.finite_univ Œπ _) _).mpr fun i _ => hn'' i\n    ¬∑ exact fun i _ => hsub' i (h i trivial)‚ü©\n\n"}
{"name":"Pi.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), CompactSpace (X i)\n‚ä¢ LocallyCompactSpace ((i : Œπ) ‚Üí X i)","decl":"/-- For spaces that are not Hausdorff. -/\ninstance Pi.locallyCompactSpace [‚àÄ i, CompactSpace (X i)] : LocallyCompactSpace (‚àÄ i, X i) :=\n  ‚ü®fun t n hn => by\n    rw [nhds_pi, Filter.mem_pi] at hn\n    obtain ‚ü®s, hs, n', hn', hsub‚ü© := hn\n    choose n'' hn'' hsub' hc using fun i =>\n      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)\n    refine ‚ü®s.pi n'', ?_, subset_trans (fun _ => ?_) hsub, ?_‚ü©\n    ¬∑ exact (set_pi_mem_nhds_iff hs _).mpr fun i _ => hn'' i\n    ¬∑ exact forall‚ÇÇ_imp fun i _ hi' => hsub' i hi'\n    ¬∑ classical\n      rw [‚Üê Set.univ_pi_ite]\n      refine isCompact_univ_pi fun i => ?_\n      by_cases h : i ‚àà s\n      ¬∑ rw [if_pos h]\n        exact hc i\n      ¬∑ rw [if_neg h]\n        exact CompactSpace.isCompact_univ‚ü©\n\n"}
{"name":"Function.locallyCompactSpace_of_finite","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"Y : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : Finite Œπ\ninst‚úù : LocallyCompactSpace Y\n‚ä¢ LocallyCompactSpace (Œπ ‚Üí Y)","decl":"instance Function.locallyCompactSpace_of_finite [Finite Œπ] [LocallyCompactSpace Y] :\n    LocallyCompactSpace (Œπ ‚Üí Y) :=\n  Pi.locallyCompactSpace_of_finite\n\n"}
{"name":"Function.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"Y : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : LocallyCompactSpace Y\ninst‚úù : CompactSpace Y\n‚ä¢ LocallyCompactSpace (Œπ ‚Üí Y)","decl":"instance Function.locallyCompactSpace [LocallyCompactSpace Y] [CompactSpace Y] :\n    LocallyCompactSpace (Œπ ‚Üí Y) :=\n  Pi.locallyCompactSpace\n\n"}
{"name":"instLocallyCompactPairOfLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace X\n‚ä¢ LocallyCompactPair X Y","decl":"instance (priority := 900) [LocallyCompactSpace X] : LocallyCompactPair X Y where\n  exists_mem_nhds_isCompact_mapsTo hf hs :=\n    let ‚ü®K, hKx, hKs, hKc‚ü© := local_compact_nhds (hf.continuousAt hs); ‚ü®K, hKx, hKc, hKs‚ü©\n\n"}
{"name":"instWeaklyLocallyCompactSpaceOfLocallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\n‚ä¢ WeaklyLocallyCompactSpace X","decl":"instance (priority := 100) [LocallyCompactSpace X] : WeaklyLocallyCompactSpace X where\n  exists_compact_mem_nhds (x : X) :=\n    let ‚ü®K, hx, _, hKc‚ü© := local_compact_nhds (x := x) univ_mem; ‚ü®K, hKc, hx‚ü©\n\n"}
{"name":"exists_compact_subset","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\nx : X\nU : Set X\nhU : IsOpen U\nhx : Membership.mem U x\n‚ä¢ Exists fun K => And (IsCompact K) (And (Membership.mem (interior K) x) (HasSubset.Subset K U))","decl":"/-- A reformulation of the definition of locally compact space: In a locally compact space,\n  every open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem exists_compact_subset [LocallyCompactSpace X] {x : X} {U : Set X} (hU : IsOpen U)\n    (hx : x ‚àà U) : ‚àÉ K : Set X, IsCompact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U := by\n  rcases LocallyCompactSpace.local_compact_nhds x U (hU.mem_nhds hx) with ‚ü®K, h1K, h2K, h3K‚ü©\n  exact ‚ü®K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K‚ü©\n\n"}
{"name":"exists_mem_nhdsSet_isCompact_mapsTo","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactPair X Y\nf : X ‚Üí Y\nK : Set X\nU : Set Y\nhf : Continuous f\nhK : IsCompact K\nhU : IsOpen U\nhKU : Set.MapsTo f K U\n‚ä¢ Exists fun L => And (Membership.mem (nhdsSet K) L) (And (IsCompact L) (Set.MapsTo f L U))","decl":"/-- If `f : X ‚Üí Y` is a continuous map in a locally compact pair of topological spaces,\n`K : set X` is a compact set, and `U` is an open neighbourhood of `f '' K`,\nthen there exists a compact neighbourhood `L` of `K` such that `f` maps `L` to `U`.\n\nThis is a generalization of `exists_mem_nhds_isCompact_mapsTo`. -/\nlemma exists_mem_nhdsSet_isCompact_mapsTo [LocallyCompactPair X Y] {f : X ‚Üí Y} {K : Set X}\n    {U : Set Y} (hf : Continuous f) (hK : IsCompact K) (hU : IsOpen U) (hKU : MapsTo f K U) :\n    ‚àÉ L ‚àà ùìùÀ¢ K, IsCompact L ‚àß MapsTo f L U := by\n  choose! V hxV hVc hVU using fun x (hx : x ‚àà K) ‚Ü¶\n    exists_mem_nhds_isCompact_mapsTo hf (hU.mem_nhds (hKU hx))\n  rcases hK.elim_nhds_subcover_nhdsSet hxV with ‚ü®s, hsK, hKs‚ü©\n  exact ‚ü®_, hKs, s.isCompact_biUnion fun x hx ‚Ü¶ hVc x (hsK x hx), mapsTo_iUnion‚ÇÇ.2 fun x hx ‚Ü¶\n    hVU x (hsK x hx)‚ü©\n\n"}
{"name":"exists_compact_between","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\nK U : Set X\nhK : IsCompact K\nhU : IsOpen U\nh_KU : HasSubset.Subset K U\n‚ä¢ Exists fun L => And (IsCompact L) (And (HasSubset.Subset K (interior L)) (HasSubset.Subset L U))","decl":"/-- In a locally compact space, for every containment `K ‚äÜ U` of a compact set `K` in an open\n  set `U`, there is a compact neighborhood `L` such that `K ‚äÜ L ‚äÜ U`: equivalently, there is a\n  compact `L` such that `K ‚äÜ interior L` and `L ‚äÜ U`.\n  See also `exists_compact_closed_between`, in which one guarantees additionally that `L` is closed\n  if the space is regular. -/\ntheorem exists_compact_between [LocallyCompactSpace X] {K U : Set X} (hK : IsCompact K)\n    (hU : IsOpen U) (h_KU : K ‚äÜ U) : ‚àÉ L, IsCompact L ‚àß K ‚äÜ interior L ‚àß L ‚äÜ U :=\n  let ‚ü®L, hKL, hL, hLU‚ü© := exists_mem_nhdsSet_isCompact_mapsTo continuous_id hK hU h_KU\n  ‚ü®L, hL, subset_interior_iff_mem_nhdsSet.2 hKL, hLU‚ü©\n\n"}
{"name":"IsOpenQuotientMap.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace X\nf : X ‚Üí Y\nhf : IsOpenQuotientMap f\n‚ä¢ LocallyCompactSpace Y","decl":"theorem IsOpenQuotientMap.locallyCompactSpace [LocallyCompactSpace X] {f : X ‚Üí Y}\n    (hf : IsOpenQuotientMap f) : LocallyCompactSpace Y where\n  local_compact_nhds := by\n    refine hf.surjective.forall.2 fun x U hU ‚Ü¶ ?_\n    rcases local_compact_nhds (hf.continuous.continuousAt hU) with ‚ü®K, hKx, hKU, hKc‚ü©\n    exact ‚ü®f '' K, hf.isOpenMap.image_mem_nhds hKx, image_subset_iff.2 hKU, hKc.image hf.continuous‚ü©\n\n"}
{"name":"Topology.IsInducing.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : IsLocallyClosed (Set.range f)\n‚ä¢ LocallyCompactSpace X","decl":"/-- If `f` is a topology inducing map with a locally compact codomain and a locally closed range,\nthen the domain of `f` is a locally compact space. -/\ntheorem Topology.IsInducing.locallyCompactSpace [LocallyCompactSpace Y] {f : X ‚Üí Y}\n    (hf : IsInducing f) (h : IsLocallyClosed (range f)) : LocallyCompactSpace X := by\n  rcases h with ‚ü®U, Z, hU, hZ, hUZ‚ü©\n  have (x : X) : (ùìù x).HasBasis (fun s ‚Ü¶ (s ‚àà ùìù (f x) ‚àß IsCompact s) ‚àß s ‚äÜ U)\n      (fun s ‚Ü¶ f ‚Åª¬π' (s ‚à© Z)) := by\n    have H : U ‚àà ùìù (f x) := hU.mem_nhds (hUZ.subset <| mem_range_self _).1\n    rw [hf.nhds_eq_comap, ‚Üê comap_nhdsWithin_range, hUZ,\n      nhdsWithin_inter_of_mem (nhdsWithin_le_nhds H)]\n    exact (nhdsWithin_hasBasis ((compact_basis_nhds (f x)).restrict_subset H) _).comap _\n  refine .of_hasBasis this fun x s ‚ü®‚ü®_, hs‚ü©, hsU‚ü© ‚Ü¶ ?_\n  rw [hf.isCompact_preimage_iff]\n  exacts [hs.inter_right hZ, hUZ ‚ñ∏ by gcongr]\n\n"}
{"name":"Inducing.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : IsLocallyClosed (Set.range f)\n‚ä¢ LocallyCompactSpace X","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.locallyCompactSpace := IsInducing.locallyCompactSpace\n\n"}
{"name":"Topology.IsClosedEmbedding.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ LocallyCompactSpace X","decl":"protected theorem Topology.IsClosedEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X ‚Üí Y}\n    (hf : IsClosedEmbedding f) : LocallyCompactSpace X :=\n  hf.isInducing.locallyCompactSpace hf.isClosed_range.isLocallyClosed\n\n"}
{"name":"ClosedEmbedding.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ LocallyCompactSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.locallyCompactSpace := IsClosedEmbedding.locallyCompactSpace\n\n"}
{"name":"Topology.IsOpenEmbedding.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ LocallyCompactSpace X","decl":"protected theorem Topology.IsOpenEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X ‚Üí Y}\n    (hf : IsOpenEmbedding f) : LocallyCompactSpace X :=\n  hf.isInducing.locallyCompactSpace hf.isOpen_range.isLocallyClosed\n\n"}
{"name":"OpenEmbedding.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocallyCompactSpace Y\nf : X ‚Üí Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ LocallyCompactSpace X","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.locallyCompactSpace := IsOpenEmbedding.locallyCompactSpace\n\n"}
{"name":"IsLocallyClosed.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\ns : Set X\nhs : IsLocallyClosed s\n‚ä¢ LocallyCompactSpace ‚Üës","decl":"protected theorem IsLocallyClosed.locallyCompactSpace [LocallyCompactSpace X] {s : Set X}\n    (hs : IsLocallyClosed s) : LocallyCompactSpace s :=\n  IsEmbedding.subtypeVal.locallyCompactSpace <| by rwa [Subtype.range_val]\n\n"}
{"name":"IsClosed.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\ns : Set X\nhs : IsClosed s\n‚ä¢ LocallyCompactSpace ‚Üës","decl":"protected theorem IsClosed.locallyCompactSpace [LocallyCompactSpace X] {s : Set X}\n    (hs : IsClosed s) : LocallyCompactSpace s :=\n  hs.isLocallyClosed.locallyCompactSpace\n\n"}
{"name":"IsOpen.locallyCompactSpace","module":"Mathlib.Topology.Compactness.LocallyCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyCompactSpace X\ns : Set X\nhs : IsOpen s\n‚ä¢ LocallyCompactSpace ‚Üës","decl":"protected theorem IsOpen.locallyCompactSpace [LocallyCompactSpace X] {s : Set X} (hs : IsOpen s) :\n    LocallyCompactSpace s :=\n  hs.isLocallyClosed.locallyCompactSpace\n"}
