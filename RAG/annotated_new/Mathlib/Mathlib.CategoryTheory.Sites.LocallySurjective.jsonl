{"name":"CategoryTheory.Presheaf.imageSieve_apply","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\nV : C\ni : Quiver.Hom V U\n⊢ Eq ((CategoryTheory.Presheaf.imageSieve f s).arrows i) (Exists fun t => Eq ((f.app { unop := V }) t) ((G.map i.op) s))","decl":"/-- Given `f : F ⟶ G`, a morphism between presieves, and `s : G.obj (op U)`, this is the sieve\nof `U` consisting of the `i : V ⟶ U` such that `s` restricted along `i` is in the image of `f`. -/\n@[simps (config := .lemmasOnly)]\ndef imageSieve {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) {U : C} (s : G.obj (op U)) : Sieve U where\n  arrows V i := ∃ t : F.obj (op V), f.app _ t = G.map i.op s\n  downward_closed := by\n    rintro V W i ⟨t, ht⟩ j\n    refine ⟨F.map j.op t, ?_⟩\n    rw [op_comp, G.map_comp, CategoryTheory.comp_apply, ← ht, elementwise_of% f.naturality]\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_eq_sieveOfSection","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\n⊢ Eq (CategoryTheory.Presheaf.imageSieve f s) ((CategoryTheory.Subpresheaf.range (CategoryTheory.whiskerRight f (CategoryTheory.forget A))).sieveOfSection s)","decl":"theorem imageSieve_eq_sieveOfSection {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) {U : C} (s : G.obj (op U)) :\n    imageSieve f s = (Subpresheaf.range (whiskerRight f (forget A))).sieveOfSection s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_whisker_forget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\n⊢ Eq (CategoryTheory.Presheaf.imageSieve (CategoryTheory.whiskerRight f (CategoryTheory.forget A)) s) (CategoryTheory.Presheaf.imageSieve f s)","decl":"theorem imageSieve_whisker_forget {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) {U : C} (s : G.obj (op U)) :\n    imageSieve (whiskerRight f (forget A)) s = imageSieve f s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_app","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (F.obj { unop := U })\n⊢ Eq (CategoryTheory.Presheaf.imageSieve f ((f.app { unop := U }) s)) Top.top","decl":"theorem imageSieve_app {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) {U : C} (s : F.obj (op U)) :\n    imageSieve f (f.app _ s) = ⊤ := by\n  ext V i\n  simp only [Sieve.top_apply, iff_true, imageSieve_apply]\n  have := elementwise_of% (f.naturality i.op)\n  exact ⟨F.map i.op s, this s⟩\n\n"}
{"name":"CategoryTheory.Presheaf.app_localPreimage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : Opposite C\ns : (CategoryTheory.forget A).obj (G.obj U)\nV : C\ng : Quiver.Hom V (Opposite.unop U)\nhg : (CategoryTheory.Presheaf.imageSieve f s).arrows g\n⊢ Eq ((f.app { unop := V }) (CategoryTheory.Presheaf.localPreimage f s g hg)) ((G.map g.op) s)","decl":"@[simp]\nlemma app_localPreimage {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) {U : Cᵒᵖ} (s : G.obj U)\n    {V : C} (g : V ⟶ U.unop) (hg : imageSieve f s g) :\n    f.app _ (localPreimage f s g hg) = G.map g.op s :=\n  hg.choose_spec\n\n"}
{"name":"CategoryTheory.Presheaf.IsLocallySurjective.imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nself : CategoryTheory.Presheaf.IsLocallySurjective J f\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\n⊢ Membership.mem (J U) (CategoryTheory.Presheaf.imageSieve f s)","decl":"/-- A morphism of presheaves `f : F ⟶ G` is locally surjective with respect to a grothendieck\ntopology if every section of `G` is locally in the image of `f`. -/\nclass IsLocallySurjective {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) : Prop where\n  imageSieve_mem {U : C} (s : G.obj (op U)) : imageSieve f s ∈ J U\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f\nU : Opposite C\ns : (CategoryTheory.forget A).obj (G.obj U)\n⊢ Membership.mem (J (Opposite.unop U)) (CategoryTheory.Presheaf.imageSieve f s)","decl":"lemma imageSieve_mem {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) [IsLocallySurjective J f] {U : Cᵒᵖ}\n    (s : G.obj U) : imageSieve f s ∈ J U.unop :=\n  IsLocallySurjective.imageSieve_mem _\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallySurjectiveWhiskerRightOppositeForget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.whiskerRight f (CategoryTheory.forget A))","decl":"instance {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) [IsLocallySurjective J f] :\n    IsLocallySurjective J (whiskerRight f (forget A)) where\n  imageSieve_mem s := imageSieve_mem J f s\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (Eq (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range (CategoryTheory.whiskerRight f (CategoryTheory.forget A)))) Top.top)","decl":"theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) :\n    IsLocallySurjective J f ↔ (Subpresheaf.range (whiskerRight f (forget A))).sheafify J = ⊤ := by\n  simp only [Subpresheaf.ext_iff, funext_iff, Set.ext_iff, Subpresheaf.top_obj,\n    Set.top_eq_univ, Set.mem_univ, iff_true]\n  exact ⟨fun H _ => H.imageSieve_mem, fun H => ⟨H _⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (Eq (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range f)) Top.top)","decl":"theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top' {F G : Cᵒᵖ ⥤ Type w} (f : F ⟶ G) :\n    IsLocallySurjective J f ↔ (Subpresheaf.range f).sheafify J = ⊤ := by\n  apply isLocallySurjective_iff_imagePresheaf_sheafify_eq_top\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_whisker_forget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.whiskerRight f (CategoryTheory.forget A)))","decl":"theorem isLocallySurjective_iff_whisker_forget {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) :\n    IsLocallySurjective J f ↔ IsLocallySurjective J (whiskerRight f (forget A)) := by\n  simp only [isLocallySurjective_iff_imagePresheaf_sheafify_eq_top]\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_surjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nH : ∀ (U : Opposite C), Function.Surjective ⇑(f.app U)\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f","decl":"theorem isLocallySurjective_of_surjective {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G)\n    (H : ∀ U, Function.Surjective (f.app U)) : IsLocallySurjective J f where\n  imageSieve_mem {U} s := by\n    obtain ⟨t, rfl⟩ := H _ s\n    rw [imageSieve_app]\n    exact J.top_mem _\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f","decl":"instance isLocallySurjective_of_iso {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) [IsIso f] :\n    IsLocallySurjective J f := by\n  apply isLocallySurjective_of_surjective\n  intro U\n  apply Function.Bijective.surjective\n  rw [← isIso_iff_bijective, ← forget_map_eq_coe]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₂\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)","decl":"instance isLocallySurjective_comp {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallySurjective J f₁] [IsLocallySurjective J f₂] :\n    IsLocallySurjective J (f₁ ≫ f₂) where\n  imageSieve_mem s := by\n    have : (Sieve.bind (imageSieve f₂ s) fun _ _ h => imageSieve f₁ h.choose) ≤\n        imageSieve (f₁ ≫ f₂) s := by\n      rintro V i ⟨W, i, j, H, ⟨t', ht'⟩, rfl⟩\n      refine ⟨t', ?_⟩\n      rw [op_comp, F₃.map_comp, NatTrans.comp_app, CategoryTheory.comp_apply,\n        CategoryTheory.comp_apply, ht', elementwise_of% f₂.naturality, H.choose_spec]\n    apply J.superset_covering this\n    apply J.bind_covering\n    · apply imageSieve_mem\n    · intros; apply imageSieve_mem\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f₂","decl":"lemma isLocallySurjective_of_isLocallySurjective\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallySurjective J (f₁ ≫ f₂)] :\n    IsLocallySurjective J f₂ where\n  imageSieve_mem {X} x := by\n    refine J.superset_covering ?_ (imageSieve_mem J (f₁ ≫ f₂) x)\n    intro Y g hg\n    exact ⟨f₁.app _ (localPreimage (f₁ ≫ f₂) x g hg),\n      by simpa using app_localPreimage (f₁ ≫ f₂) x g hg⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\nf₃ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁ f₂) f₃\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₃\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f₂","decl":"lemma isLocallySurjective_of_isLocallySurjective_fac\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} {f₁ : F₁ ⟶ F₂} {f₂ : F₂ ⟶ F₃} {f₃ : F₁ ⟶ F₃} (fac : f₁ ≫ f₂ = f₃)\n    [IsLocallySurjective J f₃] : IsLocallySurjective J f₂ := by\n  subst fac\n  exact isLocallySurjective_of_isLocallySurjective J f₁ f₂\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_of_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\nf₃ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁ f₂) f₃\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f₃) (CategoryTheory.Presheaf.IsLocallySurjective J f₂)","decl":"lemma isLocallySurjective_iff_of_fac\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} {f₁ : F₁ ⟶ F₂} {f₂ : F₂ ⟶ F₃} {f₃ : F₁ ⟶ F₃} (fac : f₁ ≫ f₂ = f₃)\n    [IsLocallySurjective J f₁] :\n    IsLocallySurjective J f₃ ↔ IsLocallySurjective J f₂ := by\n  constructor\n  · intro\n    exact isLocallySurjective_of_isLocallySurjective_fac J fac\n  · intro\n    rw [← fac]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.comp_isLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)) (CategoryTheory.Presheaf.IsLocallySurjective J f₂)","decl":"lemma comp_isLocallySurjective_iff\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallySurjective J f₁] :\n    IsLocallySurjective J (f₁ ≫ f₂) ↔ IsLocallySurjective J f₂ :=\n  isLocallySurjective_iff_of_fac J rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_le","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nK : CategoryTheory.GrothendieckTopology C\nhJK : LE.le J K\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nh : CategoryTheory.Presheaf.IsLocallySurjective J f\n⊢ CategoryTheory.Presheaf.IsLocallySurjective K f","decl":"variable {J} in\nlemma isLocallySurjective_of_le {K : GrothendieckTopology C} (hJK : J ≤ K) {F G : Cᵒᵖ ⥤ A}\n    (f : F ⟶ G) (h : IsLocallySurjective J f) : IsLocallySurjective K f where\n  imageSieve_mem s := by apply hJK; exact h.1 _\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J f₂","decl":"lemma isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallyInjective J (f₁ ≫ f₂)] [IsLocallySurjective J f₁] :\n    IsLocallyInjective J f₂ where\n  equalizerSieve_mem {X} x₁ x₂ h := by\n    let S := imageSieve f₁ x₁ ⊓ imageSieve f₁ x₂\n    have hS : S ∈ J X.unop := by\n      apply J.intersection_covering\n      all_goals apply imageSieve_mem\n    let T : ∀ ⦃Y : C⦄ (f : Y ⟶ X.unop) (_ : S f), Sieve Y := fun Y f hf =>\n      equalizerSieve (localPreimage f₁ x₁ f hf.1) (localPreimage f₁ x₂ f hf.2)\n    refine J.superset_covering ?_ (J.transitive hS (Sieve.bind S.1 T) ?_)\n    · rintro Y f ⟨Z, a, g, hg, ha, rfl⟩\n      simpa using congr_arg (f₁.app _) ha\n    · intro Y f hf\n      apply J.superset_covering (Sieve.le_pullback_bind _ _ _ hf)\n      apply equalizerSieve_mem J (f₁ ≫ f₂)\n      dsimp\n      rw [CategoryTheory.comp_apply, CategoryTheory.comp_apply, app_localPreimage,\n        app_localPreimage, NatTrans.naturality_apply, NatTrans.naturality_apply, h]\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\nf₃ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁ f₂) f₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J f₃\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J f₂","decl":"lemma isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective_fac\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} {f₁ : F₁ ⟶ F₂} {f₂ : F₂ ⟶ F₃} (f₃ : F₁ ⟶ F₃) (fac : f₁ ≫ f₂ = f₃)\n    [IsLocallyInjective J f₃] [IsLocallySurjective J f₁] :\n    IsLocallyInjective J f₂ := by\n  subst fac\n  exact isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective J f₁ f₂\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J f₂\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f₁","decl":"lemma isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallySurjective J (f₁ ≫ f₂)] [IsLocallyInjective J f₂] :\n    IsLocallySurjective J f₁ where\n  imageSieve_mem {X} x := by\n    let S := imageSieve (f₁ ≫ f₂) (f₂.app _ x)\n    let T : ∀ ⦃Y : C⦄ (f : Y ⟶ X) (_ : S f), Sieve Y := fun Y f hf =>\n      equalizerSieve (f₁.app _ (localPreimage (f₁ ≫ f₂) (f₂.app _ x) f hf)) (F₂.map f.op x)\n    refine J.superset_covering ?_ (J.transitive (imageSieve_mem J (f₁ ≫ f₂) (f₂.app _ x))\n      (Sieve.bind S.1 T) ?_)\n    · rintro Y _ ⟨Z, a, g, hg, ha, rfl⟩\n      exact ⟨F₁.map a.op (localPreimage (f₁ ≫ f₂) _ _ hg), by simpa using ha⟩\n    · intro Y f hf\n      apply J.superset_covering (Sieve.le_pullback_bind _ _ _ hf)\n      apply equalizerSieve_mem J f₂\n      rw [NatTrans.naturality_apply, ← app_localPreimage (f₁ ≫ f₂) _ _ hf,\n        NatTrans.comp_app, CategoryTheory.comp_apply]\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\nf₃ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp f₁ f₂) f₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallySurjective J f₃\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J f₂\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J f₁","decl":"lemma isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective_fac\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} {f₁ : F₁ ⟶ F₂} {f₂ : F₂ ⟶ F₃} (f₃ : F₁ ⟶ F₃) (fac : f₁ ≫ f₂ = f₃)\n    [IsLocallySurjective J f₃] [IsLocallyInjective J f₂] :\n    IsLocallySurjective J f₁ := by\n  subst fac\n  exact isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective J f₁ f₂\n\n"}
{"name":"CategoryTheory.Presheaf.comp_isLocallyInjective_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J f₁\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₁\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)) (CategoryTheory.Presheaf.IsLocallyInjective J f₂)","decl":"lemma comp_isLocallyInjective_iff\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallyInjective J f₁] [IsLocallySurjective J f₁] :\n    IsLocallyInjective J (f₁ ≫ f₂) ↔ IsLocallyInjective J f₂ := by\n  constructor\n  · intro\n    exact isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective J f₁ f₂\n  · intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_comp_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) A\nf₁ : Quiver.Hom F₁ F₂\nf₂ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J f₂\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J f₂\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp f₁ f₂)) (CategoryTheory.Presheaf.IsLocallySurjective J f₁)","decl":"lemma isLocallySurjective_comp_iff\n    {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} (f₁ : F₁ ⟶ F₂) (f₂ : F₂ ⟶ F₃)\n    [IsLocallyInjective J f₂] [IsLocallySurjective J f₂] :\n    IsLocallySurjective J (f₁ ≫ f₂) ↔ IsLocallySurjective J f₁ := by\n  constructor\n  · intro\n    exact isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective J f₁ f₂\n  · intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallySurjectiveToRangeSheafify","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F₁ F₂\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.Subpresheaf.toRangeSheafify J f)","decl":"instance {F₁ F₂ : Cᵒᵖ ⥤ Type w} (f : F₁ ⟶ F₂) :\n    IsLocallySurjective J (Subpresheaf.toRangeSheafify J f) where\n  imageSieve_mem {X} := by\n    rintro ⟨s, hs⟩\n    refine J.superset_covering ?_ hs\n    rintro Y g ⟨t, ht⟩\n    exact ⟨t, Subtype.ext ht⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toPlus","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (J.toPlus P)","decl":"instance isLocallySurjective_toPlus (P : Cᵒᵖ ⥤ Type max u v) :\n    IsLocallySurjective J (J.toPlus P) where\n  imageSieve_mem x := by\n    obtain ⟨S, x, rfl⟩ := exists_rep x\n    refine J.superset_covering (fun Y f hf => ⟨x.1 ⟨Y, f, hf⟩, ?_⟩) S.2\n    dsimp\n    rw [toPlus_eq_mk, res_mk_eq_mk_pullback, eq_mk_iff_exists]\n    refine ⟨S.pullback f, homOfLE le_top, 𝟙 _, ?_⟩\n    ext ⟨Z, g, hg⟩\n    simpa using x.2 (Cover.Relation.mk { hf := hf }\n        { hf := S.1.downward_closed hf g } { g₁ := g, g₂ := 𝟙 Z })\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toSheafify","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (J.toSheafify P)","decl":"instance isLocallySurjective_toSheafify (P : Cᵒᵖ ⥤ Type max u v) :\n    IsLocallySurjective J (J.toSheafify P) := by\n  dsimp [GrothendieckTopology.toSheafify]\n  rw [GrothendieckTopology.plusMap_toPlus]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toSheafify'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.HasForget D\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : CategoryTheory.HasWeakSheafify J D\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget D)\ninst✝ : J.PreservesSheafification (CategoryTheory.forget D)\n⊢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.toSheafify J P)","decl":"instance isLocallySurjective_toSheafify' {D : Type*} [Category D]\n    [HasForget.{max u v} D]\n    (P : Cᵒᵖ ⥤ D) [HasWeakSheafify J D] [J.HasSheafCompose (forget D)]\n    [J.PreservesSheafification (forget D)] :\n    IsLocallySurjective J (toSheafify J P) := by\n  rw [isLocallySurjective_iff_whisker_forget,\n    ← sheafComposeIso_hom_fac, ← toSheafify_plusPlusIsoSheafify_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_sheafToPresheaf_map_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : CategoryTheory.HasForget A\nF₁ F₂ : CategoryTheory.Sheaf J A\nφ : Quiver.Hom F₁ F₂\n⊢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J ((CategoryTheory.sheafToPresheaf J A).map φ)) (CategoryTheory.Sheaf.IsLocallySurjective φ)","decl":"lemma isLocallySurjective_sheafToPresheaf_map_iff :\n    Presheaf.IsLocallySurjective J ((sheafToPresheaf J A).map φ) ↔ IsLocallySurjective φ := by rfl\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ F₃ : CategoryTheory.Sheaf J A\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Sheaf.IsLocallySurjective φ\ninst✝ : CategoryTheory.Sheaf.IsLocallySurjective ψ\n⊢ CategoryTheory.Sheaf.IsLocallySurjective (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance isLocallySurjective_comp [IsLocallySurjective φ] [IsLocallySurjective ψ] :\n    IsLocallySurjective (φ ≫ ψ) :=\n  Presheaf.isLocallySurjective_comp J φ.val ψ.val\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\nF₁ F₂ : CategoryTheory.Sheaf J A\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.IsIso φ\n⊢ CategoryTheory.Sheaf.IsLocallySurjective φ","decl":"instance isLocallySurjective_of_iso [IsIso φ] : IsLocallySurjective φ := by\n  have : IsIso φ.val := (inferInstance : IsIso ((sheafToPresheaf J A).map φ))\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallySurjectiveToImage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\n⊢ CategoryTheory.Sheaf.IsLocallySurjective (CategoryTheory.Sheaf.toImage f)","decl":"instance {F G : Sheaf J (Type w)} (f : F ⟶ G) :\n    IsLocallySurjective (Sheaf.toImage f) := by\n  dsimp [Sheaf.toImage]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallySurjectiveMapTypeSheafComposeForget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ : CategoryTheory.Sheaf J A\nφ : Quiver.Hom F₁ F₂\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget A)\ninst✝ : CategoryTheory.Sheaf.IsLocallySurjective φ\n⊢ CategoryTheory.Sheaf.IsLocallySurjective ((CategoryTheory.sheafCompose J (CategoryTheory.forget A)).map φ)","decl":"instance [IsLocallySurjective φ] :\n    IsLocallySurjective ((sheafCompose J (forget A)).map φ) :=\n  (Presheaf.isLocallySurjective_iff_whisker_forget J φ.val).1 inferInstance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_iff_isIso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Sheaf.IsLocallySurjective f) (CategoryTheory.IsIso (CategoryTheory.Sheaf.imageι f))","decl":"theorem isLocallySurjective_iff_isIso {F G : Sheaf J (Type w)} (f : F ⟶ G) :\n    IsLocallySurjective f ↔ IsIso (Sheaf.imageι f) := by\n  dsimp only [IsLocallySurjective]\n  rw [Sheaf.imageι, Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top',\n    Subpresheaf.eq_top_iff_isIso]\n  exact isIso_iff_of_reflects_iso (f := Sheaf.imageι f) (F := sheafToPresheaf J (Type w))\n\n"}
{"name":"CategoryTheory.Sheaf.epi_of_isLocallySurjective'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J (Type w)\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.Sheaf.IsLocallySurjective φ\n⊢ CategoryTheory.Epi φ","decl":"instance epi_of_isLocallySurjective' {F₁ F₂ : Sheaf J (Type w)} (φ : F₁ ⟶ F₂)\n    [IsLocallySurjective φ] : Epi φ where\n  left_cancellation {Z} f₁ f₂ h := by\n    ext X x\n    apply (Presieve.isSeparated_of_isSheaf J Z.1 ((isSheaf_iff_isSheaf_of_type _ _).1 Z.2) _\n      (Presheaf.imageSieve_mem J φ.val x)).ext\n    rintro Y f ⟨s : F₁.val.obj (op Y), hs : φ.val.app _ s = F₂.val.map f.op x⟩\n    dsimp\n    have h₁ := congr_fun (f₁.val.naturality f.op) x\n    have h₂ := congr_fun (f₂.val.naturality f.op) x\n    dsimp at h₁ h₂\n    rw [← h₁, ← h₂, ← hs]\n    exact congr_fun (congr_app ((sheafToPresheaf J _).congr_map h) (op Y)) s\n\n"}
{"name":"CategoryTheory.Sheaf.epi_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} A\ninst✝² : CategoryTheory.HasForget A\nF₁ F₂ : CategoryTheory.Sheaf J A\nφ : Quiver.Hom F₁ F₂\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget A)\ninst✝ : CategoryTheory.Sheaf.IsLocallySurjective φ\n⊢ CategoryTheory.Epi φ","decl":"instance epi_of_isLocallySurjective [IsLocallySurjective φ] : Epi φ :=\n  (sheafCompose J (forget A)).epi_of_epi_map inferInstance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_iff_epi","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nφ : Quiver.Hom F G\ninst✝ : CategoryTheory.HasSheafify J (Type w)\n⊢ Iff (CategoryTheory.Sheaf.IsLocallySurjective φ) (CategoryTheory.Epi φ)","decl":"lemma isLocallySurjective_iff_epi {F G : Sheaf J (Type w)} (φ : F ⟶ G)\n    [HasSheafify J (Type w)] :\n    IsLocallySurjective φ ↔ Epi φ := by\n  constructor\n  · intro\n    infer_instance\n  · intro\n    have := epi_of_epi_fac (Sheaf.toImage_ι φ)\n    rw [isLocallySurjective_iff_isIso φ]\n    apply isIso_of_mono_of_epi\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isAmalgamation_map_localPreimage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nR R' : CategoryTheory.Functor (Opposite C) (Type w)\nφ : Quiver.Hom R R'\nX : Opposite C\nr' : R'.obj X\n⊢ ((CategoryTheory.Presieve.FamilyOfElements.localPreimage φ r').map φ).IsAmalgamation r'","decl":"lemma isAmalgamation_map_localPreimage :\n    ((localPreimage φ r').map φ).IsAmalgamation r' :=\n  fun _ f hf => (Presheaf.app_localPreimage φ r' f hf).symm\n\n"}
