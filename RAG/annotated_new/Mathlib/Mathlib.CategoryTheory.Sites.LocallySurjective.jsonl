{"name":"CategoryTheory.Presheaf.imageSieve_apply","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\nV : C\ni : Quiver.Hom V U\nâŠ¢ Eq ((CategoryTheory.Presheaf.imageSieve f s).arrows i) (Exists fun t => Eq ((f.app { unop := V }) t) ((G.map i.op) s))","decl":"/-- Given `f : F âŸ¶ G`, a morphism between presieves, and `s : G.obj (op U)`, this is the sieve\nof `U` consisting of the `i : V âŸ¶ U` such that `s` restricted along `i` is in the image of `f`. -/\n@[simps (config := .lemmasOnly)]\ndef imageSieve {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) {U : C} (s : G.obj (op U)) : Sieve U where\n  arrows V i := âˆƒ t : F.obj (op V), f.app _ t = G.map i.op s\n  downward_closed := by\n    rintro V W i âŸ¨t, htâŸ© j\n    refine âŸ¨F.map j.op t, ?_âŸ©\n    rw [op_comp, G.map_comp, CategoryTheory.comp_apply, â† ht, elementwise_of% f.naturality]\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_eq_sieveOfSection","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\nâŠ¢ Eq (CategoryTheory.Presheaf.imageSieve f s) ((CategoryTheory.Subpresheaf.range (CategoryTheory.whiskerRight f (CategoryTheory.forget A))).sieveOfSection s)","decl":"theorem imageSieve_eq_sieveOfSection {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) {U : C} (s : G.obj (op U)) :\n    imageSieve f s = (Subpresheaf.range (whiskerRight f (forget A))).sieveOfSection s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_whisker_forget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\nâŠ¢ Eq (CategoryTheory.Presheaf.imageSieve (CategoryTheory.whiskerRight f (CategoryTheory.forget A)) s) (CategoryTheory.Presheaf.imageSieve f s)","decl":"theorem imageSieve_whisker_forget {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) {U : C} (s : G.obj (op U)) :\n    imageSieve (whiskerRight f (forget A)) s = imageSieve f s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_app","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : C\ns : (CategoryTheory.forget A).obj (F.obj { unop := U })\nâŠ¢ Eq (CategoryTheory.Presheaf.imageSieve f ((f.app { unop := U }) s)) Top.top","decl":"theorem imageSieve_app {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) {U : C} (s : F.obj (op U)) :\n    imageSieve f (f.app _ s) = âŠ¤ := by\n  ext V i\n  simp only [Sieve.top_apply, iff_true, imageSieve_apply]\n  have := elementwise_of% (f.naturality i.op)\n  exact âŸ¨F.map i.op s, this sâŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.app_localPreimage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nU : Opposite C\ns : (CategoryTheory.forget A).obj (G.obj U)\nV : C\ng : Quiver.Hom V (Opposite.unop U)\nhg : (CategoryTheory.Presheaf.imageSieve f s).arrows g\nâŠ¢ Eq ((f.app { unop := V }) (CategoryTheory.Presheaf.localPreimage f s g hg)) ((G.map g.op) s)","decl":"@[simp]\nlemma app_localPreimage {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) {U : Cáµ’áµ–} (s : G.obj U)\n    {V : C} (g : V âŸ¶ U.unop) (hg : imageSieve f s g) :\n    f.app _ (localPreimage f s g hg) = G.map g.op s :=\n  hg.choose_spec\n\n"}
{"name":"CategoryTheory.Presheaf.IsLocallySurjective.imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nself : CategoryTheory.Presheaf.IsLocallySurjective J f\nU : C\ns : (CategoryTheory.forget A).obj (G.obj { unop := U })\nâŠ¢ Membership.mem (J U) (CategoryTheory.Presheaf.imageSieve f s)","decl":"/-- A morphism of presheaves `f : F âŸ¶ G` is locally surjective with respect to a grothendieck\ntopology if every section of `G` is locally in the image of `f`. -/\nclass IsLocallySurjective {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) : Prop where\n  imageSieve_mem {U : C} (s : G.obj (op U)) : imageSieve f s âˆˆ J U\n\n"}
{"name":"CategoryTheory.Presheaf.imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J f\nU : Opposite C\ns : (CategoryTheory.forget A).obj (G.obj U)\nâŠ¢ Membership.mem (J (Opposite.unop U)) (CategoryTheory.Presheaf.imageSieve f s)","decl":"lemma imageSieve_mem {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) [IsLocallySurjective J f] {U : Cáµ’áµ–}\n    (s : G.obj U) : imageSieve f s âˆˆ J U.unop :=\n  IsLocallySurjective.imageSieve_mem _\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallySurjectiveWhiskerRightOppositeForget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J f\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.whiskerRight f (CategoryTheory.forget A))","decl":"instance {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) [IsLocallySurjective J f] :\n    IsLocallySurjective J (whiskerRight f (forget A)) where\n  imageSieve_mem s := imageSieve_mem J f s\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (Eq (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range (CategoryTheory.whiskerRight f (CategoryTheory.forget A)))) Top.top)","decl":"theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) :\n    IsLocallySurjective J f â†” (Subpresheaf.range (whiskerRight f (forget A))).sheafify J = âŠ¤ := by\n  simp only [Subpresheaf.ext_iff, funext_iff, Set.ext_iff, Subpresheaf.top_obj,\n    Set.top_eq_univ, Set.mem_univ, iff_true]\n  exact âŸ¨fun H _ => H.imageSieve_mem, fun H => âŸ¨H _âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F G\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (Eq (CategoryTheory.Subpresheaf.sheafify J (CategoryTheory.Subpresheaf.range f)) Top.top)","decl":"theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top' {F G : Cáµ’áµ– â¥¤ Type w} (f : F âŸ¶ G) :\n    IsLocallySurjective J f â†” (Subpresheaf.range f).sheafify J = âŠ¤ := by\n  apply isLocallySurjective_iff_imagePresheaf_sheafify_eq_top\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_whisker_forget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J f) (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.whiskerRight f (CategoryTheory.forget A)))","decl":"theorem isLocallySurjective_iff_whisker_forget {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) :\n    IsLocallySurjective J f â†” IsLocallySurjective J (whiskerRight f (forget A)) := by\n  simp only [isLocallySurjective_iff_imagePresheaf_sheafify_eq_top]\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_surjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nH : âˆ€ (U : Opposite C), Function.Surjective â‡‘(f.app U)\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J f","decl":"theorem isLocallySurjective_of_surjective {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G)\n    (H : âˆ€ U, Function.Surjective (f.app U)) : IsLocallySurjective J f where\n  imageSieve_mem {U} s := by\n    obtain âŸ¨t, rflâŸ© := H _ s\n    rw [imageSieve_app]\n    exact J.top_mem _\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J f","decl":"instance isLocallySurjective_of_iso {F G : Cáµ’áµ– â¥¤ A} (f : F âŸ¶ G) [IsIso f] :\n    IsLocallySurjective J f := by\n  apply isLocallySurjective_of_surjective\n  intro U\n  apply Function.Bijective.surjective\n  rw [â† isIso_iff_bijective, â† forget_map_eq_coe]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)","decl":"instance isLocallySurjective_comp {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallySurjective J fâ‚] [IsLocallySurjective J fâ‚‚] :\n    IsLocallySurjective J (fâ‚ â‰« fâ‚‚) where\n  imageSieve_mem s := by\n    have : (Sieve.bind (imageSieve fâ‚‚ s) fun _ _ h => imageSieve fâ‚ h.choose) â‰¤\n        imageSieve (fâ‚ â‰« fâ‚‚) s := by\n      rintro V i âŸ¨W, i, j, H, âŸ¨t', ht'âŸ©, rflâŸ©\n      refine âŸ¨t', ?_âŸ©\n      rw [op_comp, Fâ‚ƒ.map_comp, NatTrans.comp_app, CategoryTheory.comp_apply,\n        CategoryTheory.comp_apply, ht', elementwise_of% fâ‚‚.naturality, H.choose_spec]\n    apply J.superset_covering this\n    apply J.bind_covering\n    Â· apply imageSieve_mem\n    Â· intros; apply imageSieve_mem\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚","decl":"lemma isLocallySurjective_of_isLocallySurjective\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallySurjective J (fâ‚ â‰« fâ‚‚)] :\n    IsLocallySurjective J fâ‚‚ where\n  imageSieve_mem {X} x := by\n    refine J.superset_covering ?_ (imageSieve_mem J (fâ‚ â‰« fâ‚‚) x)\n    intro Y g hg\n    exact âŸ¨fâ‚.app _ (localPreimage (fâ‚ â‰« fâ‚‚) x g hg),\n      by simpa using app_localPreimage (fâ‚ â‰« fâ‚‚) x g hgâŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\nfâ‚ƒ : Quiver.Hom Fâ‚ Fâ‚ƒ\nfac : Eq (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚ƒ\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚","decl":"lemma isLocallySurjective_of_isLocallySurjective_fac\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} {fâ‚ : Fâ‚ âŸ¶ Fâ‚‚} {fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ} {fâ‚ƒ : Fâ‚ âŸ¶ Fâ‚ƒ} (fac : fâ‚ â‰« fâ‚‚ = fâ‚ƒ)\n    [IsLocallySurjective J fâ‚ƒ] : IsLocallySurjective J fâ‚‚ := by\n  subst fac\n  exact isLocallySurjective_of_isLocallySurjective J fâ‚ fâ‚‚\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_iff_of_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\nfâ‚ƒ : Quiver.Hom Fâ‚ Fâ‚ƒ\nfac : Eq (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J fâ‚ƒ) (CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚)","decl":"lemma isLocallySurjective_iff_of_fac\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} {fâ‚ : Fâ‚ âŸ¶ Fâ‚‚} {fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ} {fâ‚ƒ : Fâ‚ âŸ¶ Fâ‚ƒ} (fac : fâ‚ â‰« fâ‚‚ = fâ‚ƒ)\n    [IsLocallySurjective J fâ‚] :\n    IsLocallySurjective J fâ‚ƒ â†” IsLocallySurjective J fâ‚‚ := by\n  constructor\n  Â· intro\n    exact isLocallySurjective_of_isLocallySurjective_fac J fac\n  Â· intro\n    rw [â† fac]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.comp_isLocallySurjective_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)) (CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚)","decl":"lemma comp_isLocallySurjective_iff\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallySurjective J fâ‚] :\n    IsLocallySurjective J (fâ‚ â‰« fâ‚‚) â†” IsLocallySurjective J fâ‚‚ :=\n  isLocallySurjective_iff_of_fac J rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_le","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nK : CategoryTheory.GrothendieckTopology C\nhJK : LE.le J K\nF G : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom F G\nh : CategoryTheory.Presheaf.IsLocallySurjective J f\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective K f","decl":"variable {J} in\nlemma isLocallySurjective_of_le {K : GrothendieckTopology C} (hJK : J â‰¤ K) {F G : Cáµ’áµ– â¥¤ A}\n    (f : F âŸ¶ G) (h : IsLocallySurjective J f) : IsLocallySurjective K f where\n  imageSieve_mem s := by apply hJK; exact h.1 _\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚","decl":"lemma isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallyInjective J (fâ‚ â‰« fâ‚‚)] [IsLocallySurjective J fâ‚] :\n    IsLocallyInjective J fâ‚‚ where\n  equalizerSieve_mem {X} xâ‚ xâ‚‚ h := by\n    let S := imageSieve fâ‚ xâ‚ âŠ“ imageSieve fâ‚ xâ‚‚\n    have hS : S âˆˆ J X.unop := by\n      apply J.intersection_covering\n      all_goals apply imageSieve_mem\n    let T : âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X.unop) (_ : S f), Sieve Y := fun Y f hf =>\n      equalizerSieve (localPreimage fâ‚ xâ‚ f hf.1) (localPreimage fâ‚ xâ‚‚ f hf.2)\n    refine J.superset_covering ?_ (J.transitive hS (Sieve.bind S.1 T) ?_)\n    Â· rintro Y f âŸ¨Z, a, g, hg, ha, rflâŸ©\n      simpa using congr_arg (fâ‚.app _) ha\n    Â· intro Y f hf\n      apply J.superset_covering (Sieve.le_pullback_bind _ _ _ hf)\n      apply equalizerSieve_mem J (fâ‚ â‰« fâ‚‚)\n      dsimp\n      rw [CategoryTheory.comp_apply, CategoryTheory.comp_apply, app_localPreimage,\n        app_localPreimage, NatTrans.naturality_apply, NatTrans.naturality_apply, h]\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\nfâ‚ƒ : Quiver.Hom Fâ‚ Fâ‚ƒ\nfac : Eq (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallyInjective J fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚","decl":"lemma isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective_fac\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} {fâ‚ : Fâ‚ âŸ¶ Fâ‚‚} {fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ} (fâ‚ƒ : Fâ‚ âŸ¶ Fâ‚ƒ) (fac : fâ‚ â‰« fâ‚‚ = fâ‚ƒ)\n    [IsLocallyInjective J fâ‚ƒ] [IsLocallySurjective J fâ‚] :\n    IsLocallyInjective J fâ‚‚ := by\n  subst fac\n  exact isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective J fâ‚ fâ‚‚\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)\ninstâœ : CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J fâ‚","decl":"lemma isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallySurjective J (fâ‚ â‰« fâ‚‚)] [IsLocallyInjective J fâ‚‚] :\n    IsLocallySurjective J fâ‚ where\n  imageSieve_mem {X} x := by\n    let S := imageSieve (fâ‚ â‰« fâ‚‚) (fâ‚‚.app _ x)\n    let T : âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (_ : S f), Sieve Y := fun Y f hf =>\n      equalizerSieve (fâ‚.app _ (localPreimage (fâ‚ â‰« fâ‚‚) (fâ‚‚.app _ x) f hf)) (Fâ‚‚.map f.op x)\n    refine J.superset_covering ?_ (J.transitive (imageSieve_mem J (fâ‚ â‰« fâ‚‚) (fâ‚‚.app _ x))\n      (Sieve.bind S.1 T) ?_)\n    Â· rintro Y _ âŸ¨Z, a, g, hg, ha, rflâŸ©\n      exact âŸ¨Fâ‚.map a.op (localPreimage (fâ‚ â‰« fâ‚‚) _ _ hg), by simpa using haâŸ©\n    Â· intro Y f hf\n      apply J.superset_covering (Sieve.le_pullback_bind _ _ _ hf)\n      apply equalizerSieve_mem J fâ‚‚\n      rw [NatTrans.naturality_apply, â† app_localPreimage (fâ‚ â‰« fâ‚‚) _ _ hf,\n        NatTrans.comp_app, CategoryTheory.comp_apply]\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\nfâ‚ƒ : Quiver.Hom Fâ‚ Fâ‚ƒ\nfac : Eq (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚) fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚ƒ\ninstâœ : CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J fâ‚","decl":"lemma isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective_fac\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} {fâ‚ : Fâ‚ âŸ¶ Fâ‚‚} {fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ} (fâ‚ƒ : Fâ‚ âŸ¶ Fâ‚ƒ) (fac : fâ‚ â‰« fâ‚‚ = fâ‚ƒ)\n    [IsLocallySurjective J fâ‚ƒ] [IsLocallyInjective J fâ‚‚] :\n    IsLocallySurjective J fâ‚ := by\n  subst fac\n  exact isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective J fâ‚ fâ‚‚\n\n"}
{"name":"CategoryTheory.Presheaf.comp_isLocallyInjective_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallyInjective J fâ‚\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)) (CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚)","decl":"lemma comp_isLocallyInjective_iff\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallyInjective J fâ‚] [IsLocallySurjective J fâ‚] :\n    IsLocallyInjective J (fâ‚ â‰« fâ‚‚) â†” IsLocallyInjective J fâ‚‚ := by\n  constructor\n  Â· intro\n    exact isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective J fâ‚ fâ‚‚\n  Â· intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_comp_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor (Opposite C) A\nfâ‚ : Quiver.Hom Fâ‚ Fâ‚‚\nfâ‚‚ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Presheaf.IsLocallyInjective J fâ‚‚\ninstâœ : CategoryTheory.Presheaf.IsLocallySurjective J fâ‚‚\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.CategoryStruct.comp fâ‚ fâ‚‚)) (CategoryTheory.Presheaf.IsLocallySurjective J fâ‚)","decl":"lemma isLocallySurjective_comp_iff\n    {Fâ‚ Fâ‚‚ Fâ‚ƒ : Cáµ’áµ– â¥¤ A} (fâ‚ : Fâ‚ âŸ¶ Fâ‚‚) (fâ‚‚ : Fâ‚‚ âŸ¶ Fâ‚ƒ)\n    [IsLocallyInjective J fâ‚‚] [IsLocallySurjective J fâ‚‚] :\n    IsLocallySurjective J (fâ‚ â‰« fâ‚‚) â†” IsLocallySurjective J fâ‚ := by\n  constructor\n  Â· intro\n    exact isLocallySurjective_of_isLocallySurjective_of_isLocallyInjective J fâ‚ fâ‚‚\n  Â· intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallySurjectiveToRangeSheafify","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nFâ‚ Fâ‚‚ : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom Fâ‚ Fâ‚‚\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.Subpresheaf.toRangeSheafify J f)","decl":"instance {Fâ‚ Fâ‚‚ : Cáµ’áµ– â¥¤ Type w} (f : Fâ‚ âŸ¶ Fâ‚‚) :\n    IsLocallySurjective J (Subpresheaf.toRangeSheafify J f) where\n  imageSieve_mem {X} := by\n    rintro âŸ¨s, hsâŸ©\n    refine J.superset_covering ?_ hs\n    rintro Y g âŸ¨t, htâŸ©\n    exact âŸ¨t, Subtype.ext htâŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toPlus","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (J.toPlus P)","decl":"instance isLocallySurjective_toPlus (P : Cáµ’áµ– â¥¤ Type max u v) :\n    IsLocallySurjective J (J.toPlus P) where\n  imageSieve_mem x := by\n    obtain âŸ¨S, x, rflâŸ© := exists_rep x\n    refine J.superset_covering (fun Y f hf => âŸ¨x.1 âŸ¨Y, f, hfâŸ©, ?_âŸ©) S.2\n    dsimp\n    rw [toPlus_eq_mk, res_mk_eq_mk_pullback, eq_mk_iff_exists]\n    refine âŸ¨S.pullback f, homOfLE le_top, ðŸ™ _, ?_âŸ©\n    ext âŸ¨Z, g, hgâŸ©\n    simpa using x.2 (Cover.Relation.mk { hf := hf }\n        { hf := S.1.downward_closed hf g } { gâ‚ := g, gâ‚‚ := ðŸ™ Z })\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toSheafify","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (J.toSheafify P)","decl":"instance isLocallySurjective_toSheafify (P : Cáµ’áµ– â¥¤ Type max u v) :\n    IsLocallySurjective J (J.toSheafify P) := by\n  dsimp [GrothendieckTopology.toSheafify]\n  rw [GrothendieckTopology.plusMap_toPlus]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallySurjective_toSheafify'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} D\ninstâœÂ³ : CategoryTheory.HasForget D\nP : CategoryTheory.Functor (Opposite C) D\ninstâœÂ² : CategoryTheory.HasWeakSheafify J D\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forget D)\ninstâœ : J.PreservesSheafification (CategoryTheory.forget D)\nâŠ¢ CategoryTheory.Presheaf.IsLocallySurjective J (CategoryTheory.toSheafify J P)","decl":"instance isLocallySurjective_toSheafify' {D : Type*} [Category D]\n    [HasForget.{max u v} D]\n    (P : Cáµ’áµ– â¥¤ D) [HasWeakSheafify J D] [J.HasSheafCompose (forget D)]\n    [J.PreservesSheafification (forget D)] :\n    IsLocallySurjective J (toSheafify J P) := by\n  rw [isLocallySurjective_iff_whisker_forget,\n    â† sheafComposeIso_hom_fac, â† toSheafify_plusPlusIsoSheafify_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_sheafToPresheaf_map_iff","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} A\ninstâœ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ : CategoryTheory.Sheaf J A\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\nâŠ¢ Iff (CategoryTheory.Presheaf.IsLocallySurjective J ((CategoryTheory.sheafToPresheaf J A).map Ï†)) (CategoryTheory.Sheaf.IsLocallySurjective Ï†)","decl":"lemma isLocallySurjective_sheafToPresheaf_map_iff :\n    Presheaf.IsLocallySurjective J ((sheafToPresheaf J A).map Ï†) â†” IsLocallySurjective Ï† := by rfl\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Sheaf J A\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\nÏˆ : Quiver.Hom Fâ‚‚ Fâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Sheaf.IsLocallySurjective Ï†\ninstâœ : CategoryTheory.Sheaf.IsLocallySurjective Ïˆ\nâŠ¢ CategoryTheory.Sheaf.IsLocallySurjective (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"instance isLocallySurjective_comp [IsLocallySurjective Ï†] [IsLocallySurjective Ïˆ] :\n    IsLocallySurjective (Ï† â‰« Ïˆ) :=\n  Presheaf.isLocallySurjective_comp J Ï†.val Ïˆ.val\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} A\ninstâœÂ¹ : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ : CategoryTheory.Sheaf J A\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\ninstâœ : CategoryTheory.IsIso Ï†\nâŠ¢ CategoryTheory.Sheaf.IsLocallySurjective Ï†","decl":"instance isLocallySurjective_of_iso [IsIso Ï†] : IsLocallySurjective Ï† := by\n  have : IsIso Ï†.val := (inferInstance : IsIso ((sheafToPresheaf J A).map Ï†))\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallySurjectiveToImage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\nâŠ¢ CategoryTheory.Sheaf.IsLocallySurjective (CategoryTheory.Sheaf.toImage f)","decl":"instance {F G : Sheaf J (Type w)} (f : F âŸ¶ G) :\n    IsLocallySurjective (Sheaf.toImage f) := by\n  dsimp [Sheaf.toImage]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallySurjectiveMapTypeSheafComposeForget","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ : CategoryTheory.Sheaf J A\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forget A)\ninstâœ : CategoryTheory.Sheaf.IsLocallySurjective Ï†\nâŠ¢ CategoryTheory.Sheaf.IsLocallySurjective ((CategoryTheory.sheafCompose J (CategoryTheory.forget A)).map Ï†)","decl":"instance [IsLocallySurjective Ï†] :\n    IsLocallySurjective ((sheafCompose J (forget A)).map Ï†) :=\n  (Presheaf.isLocallySurjective_iff_whisker_forget J Ï†.val).1 inferInstance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_iff_isIso","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\nâŠ¢ Iff (CategoryTheory.Sheaf.IsLocallySurjective f) (CategoryTheory.IsIso (CategoryTheory.Sheaf.imageÎ¹ f))","decl":"theorem isLocallySurjective_iff_isIso {F G : Sheaf J (Type w)} (f : F âŸ¶ G) :\n    IsLocallySurjective f â†” IsIso (Sheaf.imageÎ¹ f) := by\n  dsimp only [IsLocallySurjective]\n  rw [Sheaf.imageÎ¹, Presheaf.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top',\n    Subpresheaf.eq_top_iff_isIso]\n  exact isIso_iff_of_reflects_iso (f := Sheaf.imageÎ¹ f) (F := sheafToPresheaf J (Type w))\n\n"}
{"name":"CategoryTheory.Sheaf.epi_of_isLocallySurjective'","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nFâ‚ Fâ‚‚ : CategoryTheory.Sheaf J (Type w)\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\ninstâœ : CategoryTheory.Sheaf.IsLocallySurjective Ï†\nâŠ¢ CategoryTheory.Epi Ï†","decl":"instance epi_of_isLocallySurjective' {Fâ‚ Fâ‚‚ : Sheaf J (Type w)} (Ï† : Fâ‚ âŸ¶ Fâ‚‚)\n    [IsLocallySurjective Ï†] : Epi Ï† where\n  left_cancellation {Z} fâ‚ fâ‚‚ h := by\n    ext X x\n    apply (Presieve.isSeparated_of_isSheaf J Z.1 ((isSheaf_iff_isSheaf_of_type _ _).1 Z.2) _\n      (Presheaf.imageSieve_mem J Ï†.val x)).ext\n    rintro Y f âŸ¨s : Fâ‚.val.obj (op Y), hs : Ï†.val.app _ s = Fâ‚‚.val.map f.op xâŸ©\n    dsimp\n    have hâ‚ := congr_fun (fâ‚.val.naturality f.op) x\n    have hâ‚‚ := congr_fun (fâ‚‚.val.naturality f.op) x\n    dsimp at hâ‚ hâ‚‚\n    rw [â† hâ‚, â† hâ‚‚, â† hs]\n    exact congr_fun (congr_app ((sheafToPresheaf J _).congr_map h) (op Y)) s\n\n"}
{"name":"CategoryTheory.Sheaf.epi_of_isLocallySurjective","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} A\ninstâœÂ² : CategoryTheory.HasForget A\nFâ‚ Fâ‚‚ : CategoryTheory.Sheaf J A\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forget A)\ninstâœ : CategoryTheory.Sheaf.IsLocallySurjective Ï†\nâŠ¢ CategoryTheory.Epi Ï†","decl":"instance epi_of_isLocallySurjective [IsLocallySurjective Ï†] : Epi Ï† :=\n  (sheafCompose J (forget A)).epi_of_epi_map inferInstance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallySurjective_iff_epi","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nÏ† : Quiver.Hom F G\ninstâœ : CategoryTheory.HasSheafify J (Type w)\nâŠ¢ Iff (CategoryTheory.Sheaf.IsLocallySurjective Ï†) (CategoryTheory.Epi Ï†)","decl":"lemma isLocallySurjective_iff_epi {F G : Sheaf J (Type w)} (Ï† : F âŸ¶ G)\n    [HasSheafify J (Type w)] :\n    IsLocallySurjective Ï† â†” Epi Ï† := by\n  constructor\n  Â· intro\n    infer_instance\n  Â· intro\n    have := epi_of_epi_fac (Sheaf.toImage_Î¹ Ï†)\n    rw [isLocallySurjective_iff_isIso Ï†]\n    apply isIso_of_mono_of_epi\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isAmalgamation_map_localPreimage","module":"Mathlib.CategoryTheory.Sites.LocallySurjective","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nR R' : CategoryTheory.Functor (Opposite C) (Type w)\nÏ† : Quiver.Hom R R'\nX : Opposite C\nr' : R'.obj X\nâŠ¢ ((CategoryTheory.Presieve.FamilyOfElements.localPreimage Ï† r').map Ï†).IsAmalgamation r'","decl":"lemma isAmalgamation_map_localPreimage :\n    ((localPreimage Ï† r').map Ï†).IsAmalgamation r' :=\n  fun _ f hf => (Presheaf.app_localPreimage Ï† r' f hf).symm\n\n"}
