{"name":"isEllSequence_id","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"⊢ IsEllSequence id","decl":"lemma isEllSequence_id : IsEllSequence id :=\n  fun _ _ _ => by simp only [id_eq]; ring1\n\n"}
{"name":"isDivSequence_id","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"⊢ IsDivSequence id","decl":"lemma isDivSequence_id : IsDivSequence id :=\n  fun _ _ => Int.ofNat_dvd.mpr\n\n"}
{"name":"isEllDivSequence_id","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"⊢ IsEllDivSequence id","decl":"/-- The identity sequence is an EDS. -/\ntheorem isEllDivSequence_id : IsEllDivSequence id :=\n  ⟨isEllSequence_id, isDivSequence_id⟩\n\n"}
{"name":"IsEllSequence.smul","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : Int → R\nh : IsEllSequence W\nx : R\n⊢ IsEllSequence (HSMul.hSMul x W)","decl":"lemma IsEllSequence.smul (h : IsEllSequence W) (x : R) : IsEllSequence (x • W) :=\n  fun m n r => by\n    linear_combination (norm := (simp only [Pi.smul_apply, smul_eq_mul]; ring1)) x ^ 4 * h m n r\n\n"}
{"name":"IsDivSequence.smul","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : Int → R\nh : IsDivSequence W\nx : R\n⊢ IsDivSequence (HSMul.hSMul x W)","decl":"lemma IsDivSequence.smul (h : IsDivSequence W) (x : R) : IsDivSequence (x • W) :=\n  fun m n r => mul_dvd_mul_left x <| h m n r\n\n"}
{"name":"IsEllDivSequence.smul","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : Int → R\nh : IsEllDivSequence W\nx : R\n⊢ IsEllDivSequence (HSMul.hSMul x W)","decl":"lemma IsEllDivSequence.smul (h : IsEllDivSequence W) (x : R) : IsEllDivSequence (x • W) :=\n  ⟨h.left.smul x, h.right.smul x⟩\n\n"}
{"name":"preNormEDS'_zero","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS' b c d 0) 0","decl":"@[simp]\nlemma preNormEDS'_zero : preNormEDS' b c d 0 = 0 := by\n  rw [preNormEDS']\n\n"}
{"name":"preNormEDS'_one","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS' b c d 1) 1","decl":"@[simp]\nlemma preNormEDS'_one : preNormEDS' b c d 1 = 1 := by\n  rw [preNormEDS']\n\n"}
{"name":"preNormEDS'_two","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS' b c d 2) 1","decl":"@[simp]\nlemma preNormEDS'_two : preNormEDS' b c d 2 = 1 := by\n  rw [preNormEDS']\n\n"}
{"name":"preNormEDS'_three","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS' b c d 3) c","decl":"@[simp]\nlemma preNormEDS'_three : preNormEDS' b c d 3 = c := by\n  rw [preNormEDS']\n\n"}
{"name":"preNormEDS'_four","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS' b c d 4) d","decl":"@[simp]\nlemma preNormEDS'_four : preNormEDS' b c d 4 = d := by\n  rw [preNormEDS']\n\n"}
{"name":"preNormEDS'_odd","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (preNormEDS' b c d (HAdd.hAdd (HMul.hMul 2 (HAdd.hAdd m 2)) 1)) (HSub.hSub (HMul.hMul (HMul.hMul (preNormEDS' b c d (HAdd.hAdd m 4)) (HPow.hPow (preNormEDS' b c d (HAdd.hAdd m 2)) 3)) (ite (Even m) b 1)) (HMul.hMul (HMul.hMul (preNormEDS' b c d (HAdd.hAdd m 1)) (HPow.hPow (preNormEDS' b c d (HAdd.hAdd m 3)) 3)) (ite (Even m) 1 b)))","decl":"lemma preNormEDS'_odd (m : ℕ) : preNormEDS' b c d (2 * (m + 2) + 1) =\n    preNormEDS' b c d (m + 4) * preNormEDS' b c d (m + 2) ^ 3 * (if Even m then b else 1) -\n      preNormEDS' b c d (m + 1) * preNormEDS' b c d (m + 3) ^ 3 * (if Even m then 1 else b) := by\n  rw [show 2 * (m + 2) + 1 = 2 * m + 5 by rfl, preNormEDS', dif_pos <| even_two_mul _]\n  simp only [m.mul_div_cancel_left two_pos]\n\n"}
{"name":"preNormEDS'_even","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (preNormEDS' b c d (HMul.hMul 2 (HAdd.hAdd m 3))) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (preNormEDS' b c d (HAdd.hAdd m 2)) 2) (preNormEDS' b c d (HAdd.hAdd m 3))) (preNormEDS' b c d (HAdd.hAdd m 5))) (HMul.hMul (HMul.hMul (preNormEDS' b c d (HAdd.hAdd m 1)) (preNormEDS' b c d (HAdd.hAdd m 3))) (HPow.hPow (preNormEDS' b c d (HAdd.hAdd m 4)) 2)))","decl":"lemma preNormEDS'_even (m : ℕ) : preNormEDS' b c d (2 * (m + 3)) =\n    preNormEDS' b c d (m + 2) ^ 2 * preNormEDS' b c d (m + 3) * preNormEDS' b c d (m + 5) -\n      preNormEDS' b c d (m + 1) * preNormEDS' b c d (m + 3) * preNormEDS' b c d (m + 4) ^ 2 := by\n  rw [show 2 * (m + 3) = 2 * m + 1 + 5 by rfl, preNormEDS', dif_neg m.not_even_two_mul_add_one]\n  simp only [Nat.mul_add_div two_pos]\n  rfl\n\n"}
{"name":"preNormEDS_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nn : Nat\n⊢ Eq (preNormEDS b c d ↑n) (preNormEDS' b c d n)","decl":"@[simp]\nlemma preNormEDS_ofNat (n : ℕ) : preNormEDS b c d n = preNormEDS' b c d n := by\n  by_cases hn : n = 0\n  · rw [hn, preNormEDS, Nat.cast_zero, Int.sign_zero, Int.cast_zero, zero_mul, preNormEDS'_zero]\n  · rw [preNormEDS, Int.sign_natCast_of_ne_zero hn, Int.cast_one, one_mul, Int.natAbs_cast]\n\n"}
{"name":"preNormEDS_zero","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS b c d 0) 0","decl":"@[simp]\nlemma preNormEDS_zero : preNormEDS b c d 0 = 0 := by\n  erw [preNormEDS_ofNat, preNormEDS'_zero]\n\n"}
{"name":"preNormEDS_one","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS b c d 1) 1","decl":"@[simp]\nlemma preNormEDS_one : preNormEDS b c d 1 = 1 := by\n  erw [preNormEDS_ofNat, preNormEDS'_one]\n\n"}
{"name":"preNormEDS_two","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS b c d 2) 1","decl":"@[simp]\nlemma preNormEDS_two : preNormEDS b c d 2 = 1 := by\n  erw [preNormEDS_ofNat, preNormEDS'_two]\n\n"}
{"name":"preNormEDS_three","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS b c d 3) c","decl":"@[simp]\nlemma preNormEDS_three : preNormEDS b c d 3 = c := by\n  erw [preNormEDS_ofNat, preNormEDS'_three]\n\n"}
{"name":"preNormEDS_four","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (preNormEDS b c d 4) d","decl":"@[simp]\nlemma preNormEDS_four : preNormEDS b c d 4 = d := by\n  erw [preNormEDS_ofNat, preNormEDS'_four]\n\n"}
{"name":"preNormEDS_even_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (preNormEDS b c d (HMul.hMul 2 (HAdd.hAdd (↑m) 3))) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (preNormEDS b c d (HAdd.hAdd (↑m) 2)) 2) (preNormEDS b c d (HAdd.hAdd (↑m) 3))) (preNormEDS b c d (HAdd.hAdd (↑m) 5))) (HMul.hMul (HMul.hMul (preNormEDS b c d (HAdd.hAdd (↑m) 1)) (preNormEDS b c d (HAdd.hAdd (↑m) 3))) (HPow.hPow (preNormEDS b c d (HAdd.hAdd (↑m) 4)) 2)))","decl":"lemma preNormEDS_even_ofNat (m : ℕ) : preNormEDS b c d (2 * (m + 3)) =\n    preNormEDS b c d (m + 2) ^ 2 * preNormEDS b c d (m + 3) * preNormEDS b c d (m + 5) -\n      preNormEDS b c d (m + 1) * preNormEDS b c d (m + 3) * preNormEDS b c d (m + 4) ^ 2 := by\n  repeat erw [preNormEDS_ofNat]\n  exact preNormEDS'_even ..\n\n"}
{"name":"preNormEDS_odd_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (preNormEDS b c d (HAdd.hAdd (HMul.hMul 2 (HAdd.hAdd (↑m) 2)) 1)) (HSub.hSub (HMul.hMul (HMul.hMul (preNormEDS b c d (HAdd.hAdd (↑m) 4)) (HPow.hPow (preNormEDS b c d (HAdd.hAdd (↑m) 2)) 3)) (ite (Even m) b 1)) (HMul.hMul (HMul.hMul (preNormEDS b c d (HAdd.hAdd (↑m) 1)) (HPow.hPow (preNormEDS b c d (HAdd.hAdd (↑m) 3)) 3)) (ite (Even m) 1 b)))","decl":"lemma preNormEDS_odd_ofNat (m : ℕ) : preNormEDS b c d (2 * (m + 2) + 1) =\n    preNormEDS b c d (m + 4) * preNormEDS b c d (m + 2) ^ 3 * (if Even m then b else 1) -\n      preNormEDS b c d (m + 1) * preNormEDS b c d (m + 3) ^ 3 * (if Even m then 1 else b) := by\n  repeat erw [preNormEDS_ofNat]\n  exact preNormEDS'_odd ..\n\n"}
{"name":"preNormEDS_neg","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nn : Int\n⊢ Eq (preNormEDS b c d (Neg.neg n)) (Neg.neg (preNormEDS b c d n))","decl":"@[simp]\nlemma preNormEDS_neg (n : ℤ) : preNormEDS b c d (-n) = -preNormEDS b c d n := by\n  rw [preNormEDS, Int.sign_neg, Int.cast_neg, neg_mul, Int.natAbs_neg, preNormEDS]\n\n"}
{"name":"preNormEDS_even","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Int\n⊢ Eq (preNormEDS b c d (HMul.hMul 2 m)) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (preNormEDS b c d (HSub.hSub m 1)) 2) (preNormEDS b c d m)) (preNormEDS b c d (HAdd.hAdd m 2))) (HMul.hMul (HMul.hMul (preNormEDS b c d (HSub.hSub m 2)) (preNormEDS b c d m)) (HPow.hPow (preNormEDS b c d (HAdd.hAdd m 1)) 2)))","decl":"lemma preNormEDS_even (m : ℤ) : preNormEDS b c d (2 * m) =\n    preNormEDS b c d (m - 1) ^ 2 * preNormEDS b c d m * preNormEDS b c d (m + 2) -\n      preNormEDS b c d (m - 2) * preNormEDS b c d m * preNormEDS b c d (m + 1) ^ 2 := by\n  induction m using Int.negInduction with\n  | nat m =>\n    rcases m with _ | _ | _ | m\n    · simp\n    · simp\n    · simp\n    · simp only [Int.natCast_add, Nat.cast_one]\n      rw [Int.add_sub_cancel, show (m : ℤ) + 1 + 1 + 1 = m + 1 + 2 by rfl, Int.add_sub_cancel]\n      exact preNormEDS_even_ofNat ..\n  | neg h m =>\n    simp_rw [show 2 * -(m : ℤ) = -(2 * m) by omega, show -(m : ℤ) - 1 = -(m + 1) by omega,\n      show -(m : ℤ) + 2 = -(m - 2) by omega, show -(m : ℤ) - 2 = -(m + 2) by omega,\n      show -(m : ℤ) + 1 = -(m - 1) by omega, preNormEDS_neg, h m]\n    ring1\n\n"}
{"name":"preNormEDS_odd","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Int\n⊢ Eq (preNormEDS b c d (HAdd.hAdd (HMul.hMul 2 m) 1)) (HSub.hSub (HMul.hMul (HMul.hMul (preNormEDS b c d (HAdd.hAdd m 2)) (HPow.hPow (preNormEDS b c d m) 3)) (ite (Even m) b 1)) (HMul.hMul (HMul.hMul (preNormEDS b c d (HSub.hSub m 1)) (HPow.hPow (preNormEDS b c d (HAdd.hAdd m 1)) 3)) (ite (Even m) 1 b)))","decl":"lemma preNormEDS_odd (m : ℤ) : preNormEDS b c d (2 * m + 1) =\n    preNormEDS b c d (m + 2) * preNormEDS b c d m ^ 3 * (if Even m then b else 1) -\n      preNormEDS b c d (m - 1) * preNormEDS b c d (m + 1) ^ 3 * (if Even m then 1 else b) := by\n  induction m using Int.negInduction with\n  | nat m =>\n    rcases m with _ | _ | m\n    · simp\n    · simp\n    · simp only [Int.natCast_add, Nat.cast_one, Int.even_add_one, not_not, Int.even_coe_nat]\n      rw [Int.add_sub_cancel]\n      exact preNormEDS_odd_ofNat ..\n  | neg h m =>\n    rcases m with _ | m\n    · simp\n    · simp_rw [Int.natCast_add, Nat.cast_one, show 2 * -(m + 1 : ℤ) + 1 = -(2 * m + 1) by rfl,\n        show -(m + 1 : ℤ) + 2 = -(m - 1) by omega, show -(m + 1 : ℤ) - 1 = -(m + 2) by rfl,\n        show -(m + 1 : ℤ) + 1 = -m by omega, preNormEDS_neg, even_neg, Int.even_add_one, ite_not,\n        h m]\n      ring1\n\n"}
{"name":"normEDS_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nn : Nat\n⊢ Eq (normEDS b c d ↑n) (HMul.hMul (preNormEDS' (HPow.hPow b 4) c d n) (ite (Even n) b 1))","decl":"@[simp]\nlemma normEDS_ofNat (n : ℕ) :\n    normEDS b c d n = preNormEDS' (b ^ 4) c d n * if Even n then b else 1 := by\n  simp only [normEDS, preNormEDS_ofNat, Int.even_coe_nat]\n\n"}
{"name":"normEDS_zero","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (normEDS b c d 0) 0","decl":"@[simp]\nlemma normEDS_zero : normEDS b c d 0 = 0 := by\n  erw [normEDS_ofNat, preNormEDS'_zero, zero_mul]\n\n"}
{"name":"normEDS_one","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (normEDS b c d 1) 1","decl":"@[simp]\nlemma normEDS_one : normEDS b c d 1 = 1 := by\n  erw [normEDS_ofNat, preNormEDS'_one, one_mul, if_neg Nat.not_even_one]\n\n"}
{"name":"normEDS_two","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (normEDS b c d 2) b","decl":"@[simp]\nlemma normEDS_two : normEDS b c d 2 = b := by\n  erw [normEDS_ofNat, preNormEDS'_two, one_mul, if_pos even_two]\n\n"}
{"name":"normEDS_three","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (normEDS b c d 3) c","decl":"@[simp]\nlemma normEDS_three : normEDS b c d 3 = c := by\n  erw [normEDS_ofNat, preNormEDS'_three, if_neg <| by decide, mul_one]\n\n"}
{"name":"normEDS_four","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\n⊢ Eq (normEDS b c d 4) (HMul.hMul d b)","decl":"@[simp]\nlemma normEDS_four : normEDS b c d 4 = d * b := by\n  erw [normEDS_ofNat, preNormEDS'_four, if_pos <| by decide]\n\n"}
{"name":"normEDS_even_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (HMul.hMul (normEDS b c d (HMul.hMul 2 (HAdd.hAdd (↑m) 3))) b) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (normEDS b c d (HAdd.hAdd (↑m) 2)) 2) (normEDS b c d (HAdd.hAdd (↑m) 3))) (normEDS b c d (HAdd.hAdd (↑m) 5))) (HMul.hMul (HMul.hMul (normEDS b c d (HAdd.hAdd (↑m) 1)) (normEDS b c d (HAdd.hAdd (↑m) 3))) (HPow.hPow (normEDS b c d (HAdd.hAdd (↑m) 4)) 2)))","decl":"lemma normEDS_even_ofNat (m : ℕ) : normEDS b c d (2 * (m + 3)) * b =\n    normEDS b c d (m + 2) ^ 2 * normEDS b c d (m + 3) * normEDS b c d (m + 5) -\n      normEDS b c d (m + 1) * normEDS b c d (m + 3) * normEDS b c d (m + 4) ^ 2 := by\n  repeat erw [normEDS_ofNat]\n  simp only [preNormEDS'_even, if_pos <| even_two_mul _, Nat.even_add_one, ite_not]\n  split_ifs <;> ring1\n\n"}
{"name":"normEDS_odd_ofNat","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Nat\n⊢ Eq (normEDS b c d (HAdd.hAdd (HMul.hMul 2 (HAdd.hAdd (↑m) 2)) 1)) (HSub.hSub (HMul.hMul (normEDS b c d (HAdd.hAdd (↑m) 4)) (HPow.hPow (normEDS b c d (HAdd.hAdd (↑m) 2)) 3)) (HMul.hMul (normEDS b c d (HAdd.hAdd (↑m) 1)) (HPow.hPow (normEDS b c d (HAdd.hAdd (↑m) 3)) 3)))","decl":"lemma normEDS_odd_ofNat (m : ℕ) : normEDS b c d (2 * (m + 2) + 1) =\n    normEDS b c d (m + 4) * normEDS b c d (m + 2) ^ 3 -\n      normEDS b c d (m + 1) * normEDS b c d (m + 3) ^ 3 := by\n  repeat erw [normEDS_ofNat]\n  simp_rw [preNormEDS'_odd, if_neg (m + 2).not_even_two_mul_add_one, Nat.even_add_one, ite_not]\n  split_ifs <;> ring1\n\n"}
{"name":"normEDS_neg","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nn : Int\n⊢ Eq (normEDS b c d (Neg.neg n)) (Neg.neg (normEDS b c d n))","decl":"@[simp]\nlemma normEDS_neg (n : ℤ) : normEDS b c d (-n) = -normEDS b c d n := by\n  simp only [normEDS, preNormEDS_neg, neg_mul, even_neg]\n\n"}
{"name":"normEDS_even","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Int\n⊢ Eq (HMul.hMul (normEDS b c d (HMul.hMul 2 m)) b) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (normEDS b c d (HSub.hSub m 1)) 2) (normEDS b c d m)) (normEDS b c d (HAdd.hAdd m 2))) (HMul.hMul (HMul.hMul (normEDS b c d (HSub.hSub m 2)) (normEDS b c d m)) (HPow.hPow (normEDS b c d (HAdd.hAdd m 1)) 2)))","decl":"lemma normEDS_even (m : ℤ) : normEDS b c d (2 * m) * b =\n    normEDS b c d (m - 1) ^ 2 * normEDS b c d m * normEDS b c d (m + 2) -\n      normEDS b c d (m - 2) * normEDS b c d m * normEDS b c d (m + 1) ^ 2 := by\n  simp only [normEDS, preNormEDS_even, if_pos <| even_two_mul m, show m + 2 = m + 1 + 1 by ring1,\n    Int.even_add_one, show m - 2 = m - 1 - 1 by ring1, Int.even_sub_one, ite_not]\n  by_cases hm : Even m\n  · simp only [if_pos hm]\n    ring1\n  · simp only [if_neg hm]\n    ring1\n\n"}
{"name":"normEDS_odd","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝ : CommRing R\nb c d : R\nm : Int\n⊢ Eq (normEDS b c d (HAdd.hAdd (HMul.hMul 2 m) 1)) (HSub.hSub (HMul.hMul (normEDS b c d (HAdd.hAdd m 2)) (HPow.hPow (normEDS b c d m) 3)) (HMul.hMul (normEDS b c d (HSub.hSub m 1)) (HPow.hPow (normEDS b c d (HAdd.hAdd m 1)) 3)))","decl":"lemma normEDS_odd (m : ℤ) : normEDS b c d (2 * m + 1) =\n    normEDS b c d (m + 2) * normEDS b c d m ^ 3 -\n      normEDS b c d (m - 1) * normEDS b c d (m + 1) ^ 3 := by\n  simp only [normEDS, preNormEDS_odd, if_neg m.not_even_two_mul_add_one]\n  conv_lhs => rw [← @one_pow R _ 4, ← ite_pow, ← ite_pow]\n  simp only [show m + 2 = m + 1 + 1 by ring1, Int.even_add_one, Int.even_sub_one, ite_not]\n  ring1\n\n"}
{"name":"map_preNormEDS'","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nb c d : R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\nn : Nat\n⊢ Eq (f (preNormEDS' b c d n)) (preNormEDS' (f b) (f c) (f d) n)","decl":"lemma map_preNormEDS' (n : ℕ) : f (preNormEDS' b c d n) = preNormEDS' (f b) (f c) (f d) n := by\n  induction n using normEDSRec' with\n  | zero => rw [preNormEDS'_zero, map_zero, preNormEDS'_zero]\n  | one => rw [preNormEDS'_one, map_one, preNormEDS'_one]\n  | two => rw [preNormEDS'_two, map_one, preNormEDS'_two]\n  | three => rw [preNormEDS'_three, preNormEDS'_three]\n  | four => rw [preNormEDS'_four, preNormEDS'_four]\n  | _ _ ih =>\n    simp only [preNormEDS'_odd, preNormEDS'_even, map_one, map_sub, map_mul, map_pow, apply_ite f]\n    repeat rw [ih _ <| by linarith only]\n\n"}
{"name":"map_preNormEDS","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nb c d : R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\nn : Int\n⊢ Eq (f (preNormEDS b c d n)) (preNormEDS (f b) (f c) (f d) n)","decl":"lemma map_preNormEDS (n : ℤ) : f (preNormEDS b c d n) = preNormEDS (f b) (f c) (f d) n := by\n  rw [preNormEDS, map_mul, map_intCast, map_preNormEDS', preNormEDS]\n\n"}
{"name":"map_normEDS","module":"Mathlib.NumberTheory.EllipticDivisibilitySequence","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nb c d : R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\nn : Int\n⊢ Eq (f (normEDS b c d n)) (normEDS (f b) (f c) (f d) n)","decl":"lemma map_normEDS (n : ℤ) : f (normEDS b c d n) = normEDS (f b) (f c) (f d) n := by\n  rw [normEDS, map_mul, map_preNormEDS, map_pow, apply_ite f, map_one, normEDS]\n\n"}
