{"name":"IsUniformInducing.comap_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nself : IsUniformInducing f\nâŠ¢ Eq (Filter.comap (fun x => { fst := f x.1, snd := f x.2 }) (uniformity Î²)) (uniformity Î±)","decl":"/-- A map `f : Î± â†’ Î²` between uniform spaces is called *uniform inducing* if the uniformity filter\non `Î±` is the pullback of the uniformity filter on `Î²` under `Prod.map f f`. If `Î±` is a separated\nspace, then this implies that `f` is injective, hence it is a `IsUniformEmbedding`. -/\n@[mk_iff]\nstructure IsUniformInducing (f : Î± â†’ Î²) : Prop where\n  /-- The uniformity filter on the domain is the pullback of the uniformity filter on the codomain\n  under `Prod.map f f`. -/\n  comap_uniformity : comap (fun x : Î± Ã— Î± => (f x.1, f x.2)) (ğ“¤ Î²) = ğ“¤ Î±\n\n"}
{"name":"isUniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (Eq (Filter.comap (fun x => { fst := f x.1, snd := f x.2 }) (uniformity Î²)) (uniformity Î±))","decl":"/-- A map `f : Î± â†’ Î²` between uniform spaces is called *uniform inducing* if the uniformity filter\non `Î±` is the pullback of the uniformity filter on `Î²` under `Prod.map f f`. If `Î±` is a separated\nspace, then this implies that `f` is injective, hence it is a `IsUniformEmbedding`. -/\n@[mk_iff]\nstructure IsUniformInducing (f : Î± â†’ Î²) : Prop where\n  /-- The uniformity filter on the domain is the pullback of the uniformity filter on the codomain\n  under `Prod.map f f`. -/\n  comap_uniformity : comap (fun x : Î± Ã— Î± => (f x.1, f x.2)) (ğ“¤ Î²) = ğ“¤ Î±\n\n"}
{"name":"isUniformInducing_iff_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (Eq (UniformSpace.comap f instâœ) instâœÂ¹)","decl":"lemma isUniformInducing_iff_uniformSpace {f : Î± â†’ Î²} :\n    IsUniformInducing f â†” â€¹UniformSpace Î²â€º.comap f = â€¹UniformSpace Î±â€º := by\n  rw [isUniformInducing_iff, UniformSpace.ext_iff, Filter.ext_iff]\n  rfl\n\n"}
{"name":"uniformInducing_iff_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (Eq (UniformSpace.comap f instâœ) instâœÂ¹)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff_uniformSpace := isUniformInducing_iff_uniformSpace\n\n"}
{"name":"IsUniformInducing.comap_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\naâœ : IsUniformInducing f\nâŠ¢ Eq (UniformSpace.comap f instâœ) instâœÂ¹","decl":"protected alias âŸ¨IsUniformInducing.comap_uniformSpace, _âŸ© := isUniformInducing_iff_uniformSpace\n\n"}
{"name":"UniformInducing.comap_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\naâœ : IsUniformInducing f\nâŠ¢ Eq (UniformSpace.comap f instâœ) instâœÂ¹","decl":"@[deprecated (since := \"2024-10-08\")] alias UniformInducing.comap_uniformSpace :=\n  IsUniformInducing.comap_uniformSpace\n\n"}
{"name":"isUniformInducing_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Î²)) (uniformity Î±)))","decl":"lemma isUniformInducing_iff' {f : Î± â†’ Î²} :\n    IsUniformInducing f â†” UniformContinuous f âˆ§ comap (Prod.map f f) (ğ“¤ Î²) â‰¤ ğ“¤ Î± := by\n  rw [isUniformInducing_iff, UniformContinuous, tendsto_iff_comap, le_antisymm_iff, and_comm]; rfl\n\n"}
{"name":"uniformInducing_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Î²)) (uniformity Î±)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff' := isUniformInducing_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (âˆ€ (i : Î¹'), p' i â†’ Exists fun j => And (p j) (âˆ€ (x y : Î±), Membership.mem (s j) { fst := x, snd := y } â†’ Membership.mem (s' i) { fst := f x, snd := f y })) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y })))","decl":"protected lemma Filter.HasBasis.isUniformInducing_iff {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : (ğ“¤ Î±).HasBasis p s) (h' : (ğ“¤ Î²).HasBasis p' s') {f : Î± â†’ Î²} :\n    IsUniformInducing f â†”\n      (âˆ€ i, p' i â†’ âˆƒ j, p j âˆ§ âˆ€ x y, (x, y) âˆˆ s j â†’ (f x, f y) âˆˆ s' i) âˆ§\n        (âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j) := by\n  simp [isUniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]\n\n"}
{"name":"Filter.HasBasis.uniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (âˆ€ (i : Î¹'), p' i â†’ Exists fun j => And (p j) (âˆ€ (x y : Î±), Membership.mem (s j) { fst := x, snd := y } â†’ Membership.mem (s' i) { fst := f x, snd := f y })) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y })))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias Filter.HasBasis.uniformInducing_iff := Filter.HasBasis.isUniformInducing_iff\n\n"}
{"name":"IsUniformInducing.mk'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : âˆ€ (s : Set (Prod Î± Î±)), Iff (Membership.mem (uniformity Î±) s) (Exists fun t => And (Membership.mem (uniformity Î²) t) (âˆ€ (x y : Î±), Membership.mem t { fst := f x, snd := f y } â†’ Membership.mem s { fst := x, snd := y }))\nâŠ¢ IsUniformInducing f","decl":"theorem IsUniformInducing.mk' {f : Î± â†’ Î²}\n    (h : âˆ€ s, s âˆˆ ğ“¤ Î± â†” âˆƒ t âˆˆ ğ“¤ Î², âˆ€ x y : Î±, (f x, f y) âˆˆ t â†’ (x, y) âˆˆ s) : IsUniformInducing f :=\n  âŸ¨by simp [eq_comm, Filter.ext_iff, subset_def, h]âŸ©\n\n"}
{"name":"UniformInducing.mk'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : âˆ€ (s : Set (Prod Î± Î±)), Iff (Membership.mem (uniformity Î±) s) (Exists fun t => And (Membership.mem (uniformity Î²) t) (âˆ€ (x y : Î±), Membership.mem t { fst := f x, snd := f y } â†’ Membership.mem s { fst := x, snd := y }))\nâŠ¢ IsUniformInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.mk' := IsUniformInducing.mk'\n\n"}
{"name":"IsUniformInducing.id","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ IsUniformInducing id","decl":"theorem IsUniformInducing.id : IsUniformInducing (@id Î±) :=\n  âŸ¨by rw [â† Prod.map_def, Prod.map_id, comap_id]âŸ©\n\n"}
{"name":"uniformInducing_id","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ IsUniformInducing id","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_id := IsUniformInducing.id\n\n"}
{"name":"IsUniformInducing.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp g f)","decl":"theorem IsUniformInducing.comp {g : Î² â†’ Î³} (hg : IsUniformInducing g) {f : Î± â†’ Î²}\n    (hf : IsUniformInducing f) : IsUniformInducing (g âˆ˜ f) :=\n  âŸ¨by rw [â† hf.1, â† hg.1, comap_comap]; rflâŸ©\n\n"}
{"name":"UniformInducing.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.comp := IsUniformInducing.comp\n\n"}
{"name":"IsUniformInducing.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"theorem IsUniformInducing.of_comp_iff {g : Î² â†’ Î³} (hg : IsUniformInducing g) {f : Î± â†’ Î²} :\n    IsUniformInducing (g âˆ˜ f) â†” IsUniformInducing f := by\n  refine âŸ¨fun h â†¦ ?_, hg.compâŸ©\n  rw [isUniformInducing_iff, â† hg.comap_uniformity, comap_comap, â† h.comap_uniformity,\n    Function.comp_def, Function.comp_def]\n\n"}
{"name":"UniformInducing.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.of_comp_iff := IsUniformInducing.of_comp_iff\n\n"}
{"name":"IsUniformInducing.basis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nÎ¹ : Sort u_1\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nH : (uniformity Î²).HasBasis p s\nâŠ¢ (uniformity Î±).HasBasis p fun i => Set.preimage (Prod.map f f) (s i)","decl":"theorem IsUniformInducing.basis_uniformity {f : Î± â†’ Î²} (hf : IsUniformInducing f) {Î¹ : Sort*}\n    {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (H : (ğ“¤ Î²).HasBasis p s) :\n    (ğ“¤ Î±).HasBasis p fun i => Prod.map f f â»Â¹' s i :=\n  hf.1 â–¸ H.comap _\n\n"}
{"name":"UniformInducing.basis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nÎ¹ : Sort u_1\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nH : (uniformity Î²).HasBasis p s\nâŠ¢ (uniformity Î±).HasBasis p fun i => Set.preimage (Prod.map f f) (s i)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.basis_uniformity := IsUniformInducing.basis_uniformity\n\n"}
{"name":"IsUniformInducing.cauchy_map_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nF : Filter Î±\nâŠ¢ Iff (Cauchy (Filter.map f F)) (Cauchy F)","decl":"theorem IsUniformInducing.cauchy_map_iff {f : Î± â†’ Î²} (hf : IsUniformInducing f) {F : Filter Î±} :\n    Cauchy (map f F) â†” Cauchy F := by\n  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_le_iff_le_comap, â† hf.comap_uniformity]\n\n"}
{"name":"UniformInducing.cauchy_map_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nF : Filter Î±\nâŠ¢ Iff (Cauchy (Filter.map f F)) (Cauchy F)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.cauchy_map_iff := IsUniformInducing.cauchy_map_iff\n\n"}
{"name":"IsUniformInducing.of_comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhf : UniformContinuous f\nhg : UniformContinuous g\nhgf : IsUniformInducing (Function.comp g f)\nâŠ¢ IsUniformInducing f","decl":"theorem IsUniformInducing.of_comp {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) (hgf : IsUniformInducing (g âˆ˜ f)) : IsUniformInducing f := by\n  refine âŸ¨le_antisymm ?_ hf.le_comapâŸ©\n  rw [â† hgf.1, â† Prod.map_def, â† Prod.map_def, â† Prod.map_comp_map f f g g, â† comap_comap]\n  exact comap_mono hg.le_comap\n\n"}
{"name":"uniformInducing_of_compose","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhf : UniformContinuous f\nhg : UniformContinuous g\nhgf : IsUniformInducing (Function.comp g f)\nâŠ¢ IsUniformInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_of_compose := IsUniformInducing.of_comp\n\n"}
{"name":"IsUniformInducing.uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ UniformContinuous f","decl":"theorem IsUniformInducing.uniformContinuous {f : Î± â†’ Î²} (hf : IsUniformInducing f) :\n    UniformContinuous f := (isUniformInducing_iff'.1 hf).1\n\n"}
{"name":"UniformInducing.uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ UniformContinuous f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuous := IsUniformInducing.uniformContinuous\n\n"}
{"name":"IsUniformInducing.uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nâŠ¢ Iff (UniformContinuous f) (UniformContinuous (Function.comp g f))","decl":"theorem IsUniformInducing.uniformContinuous_iff {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hg : IsUniformInducing g) :\n    UniformContinuous f â†” UniformContinuous (g âˆ˜ f) := by\n  dsimp only [UniformContinuous, Tendsto]\n  simp only [â† hg.comap_uniformity, â† map_le_iff_le_comap, Filter.map_map, Function.comp_def]\n\n"}
{"name":"UniformInducing.uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nâŠ¢ Iff (UniformContinuous f) (UniformContinuous (Function.comp g f))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuous_iff := IsUniformInducing.uniformContinuous_iff\n\n"}
{"name":"IsUniformInducing.isUniformInducing_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nâŠ¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"protected theorem IsUniformInducing.isUniformInducing_comp_iff {f : Î± â†’ Î²} {g : Î² â†’ Î³}\n    (hg : IsUniformInducing g) : IsUniformInducing (g âˆ˜ f) â†” IsUniformInducing f := by\n  simp only [isUniformInducing_iff, â† hg.comap_uniformity, comap_comap, Function.comp_def]\n\n"}
{"name":"UniformInducing.uniformInducing_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : IsUniformInducing g\nâŠ¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformInducing_comp_iff := IsUniformInducing.isUniformInducing_comp_iff\n\n"}
{"name":"IsUniformInducing.uniformContinuousOn_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nS : Set Î±\nhg : IsUniformInducing g\nâŠ¢ Iff (UniformContinuousOn f S) (UniformContinuousOn (Function.comp g f) S)","decl":"theorem IsUniformInducing.uniformContinuousOn_iff {f : Î± â†’ Î²} {g : Î² â†’ Î³} {S : Set Î±}\n    (hg : IsUniformInducing g) :\n    UniformContinuousOn f S â†” UniformContinuousOn (g âˆ˜ f) S := by\n  dsimp only [UniformContinuousOn, Tendsto]\n  rw [â† hg.comap_uniformity, â† map_le_iff_le_comap, Filter.map_map, comp_def, comp_def]\n\n"}
{"name":"UniformInducing.uniformContinuousOn_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nS : Set Î±\nhg : IsUniformInducing g\nâŠ¢ Iff (UniformContinuousOn f S) (UniformContinuousOn (Function.comp g f) S)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuousOn_iff := IsUniformInducing.uniformContinuousOn_iff\n\n"}
{"name":"IsUniformInducing.isInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Topology.IsInducing f","decl":"theorem IsUniformInducing.isInducing {f : Î± â†’ Î²} (h : IsUniformInducing f) : IsInducing f := by\n  obtain rfl := h.comap_uniformSpace\n  exact .induced f\n\n"}
{"name":"IsUniformInducing.inducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")]\nalias IsUniformInducing.inducing := IsUniformInducing.isInducing\n\n"}
{"name":"UniformInducing.isInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isInducing := IsUniformInducing.isInducing\n\n"}
{"name":"UniformInducing.inducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias UniformInducing.inducing := UniformInducing.isInducing\n\n"}
{"name":"IsUniformInducing.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\nÎ±' : Type u_1\nÎ²' : Type u_2\ninstâœÂ¹ : UniformSpace Î±'\ninstâœ : UniformSpace Î²'\neâ‚ : Î± â†’ Î±'\neâ‚‚ : Î² â†’ Î²'\nhâ‚ : IsUniformInducing eâ‚\nhâ‚‚ : IsUniformInducing eâ‚‚\nâŠ¢ IsUniformInducing fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"theorem IsUniformInducing.prod {Î±' : Type*} {Î²' : Type*} [UniformSpace Î±'] [UniformSpace Î²']\n    {eâ‚ : Î± â†’ Î±'} {eâ‚‚ : Î² â†’ Î²'} (hâ‚ : IsUniformInducing eâ‚) (hâ‚‚ : IsUniformInducing eâ‚‚) :\n    IsUniformInducing fun p : Î± Ã— Î² => (eâ‚ p.1, eâ‚‚ p.2) :=\n  âŸ¨by simp [Function.comp_def, uniformity_prod, â† hâ‚.1, â† hâ‚‚.1, comap_inf, comap_comap]âŸ©\n\n"}
{"name":"UniformInducing.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\nÎ±' : Type u_1\nÎ²' : Type u_2\ninstâœÂ¹ : UniformSpace Î±'\ninstâœ : UniformSpace Î²'\neâ‚ : Î± â†’ Î±'\neâ‚‚ : Î² â†’ Î²'\nhâ‚ : IsUniformInducing eâ‚\nhâ‚‚ : IsUniformInducing eâ‚‚\nâŠ¢ IsUniformInducing fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.prod := IsUniformInducing.prod\n\n"}
{"name":"IsUniformInducing.isDenseInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nhd : DenseRange f\nâŠ¢ IsDenseInducing f","decl":"lemma IsUniformInducing.isDenseInducing (h : IsUniformInducing f) (hd : DenseRange f) :\n    IsDenseInducing f where\n  toIsInducing := h.isInducing\n  dense := hd\n\n"}
{"name":"UniformInducing.isDenseInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformInducing f\nhd : DenseRange f\nâŠ¢ IsDenseInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isDenseInducing := IsUniformInducing.isDenseInducing\n\n"}
{"name":"SeparationQuotient.isUniformInducing_mk","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ IsUniformInducing SeparationQuotient.mk","decl":"lemma SeparationQuotient.isUniformInducing_mk :\n    IsUniformInducing (mk : Î± â†’ SeparationQuotient Î±) :=\n  âŸ¨comap_mk_uniformityâŸ©\n\n"}
{"name":"SeparationQuotient.uniformInducing_mk","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ IsUniformInducing SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-05\")]\nalias SeparationQuotient.uniformInducing_mk := SeparationQuotient.isUniformInducing_mk\n\n"}
{"name":"IsUniformInducing.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Function.Injective f","decl":"protected theorem IsUniformInducing.injective [T0Space Î±] {f : Î± â†’ Î²} (h : IsUniformInducing f) :\n    Injective f :=\n  h.isInducing.injective\n\n"}
{"name":"UniformInducing.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nh : IsUniformInducing f\nâŠ¢ Function.Injective f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.injective := IsUniformInducing.injective\n\n"}
{"name":"IsUniformEmbedding.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nself : IsUniformEmbedding f\nâŠ¢ Function.Injective f","decl":"/-- A map `f : Î± â†’ Î²` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Î±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Î± â†’ Î²) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"IsUniformEmbedding.toIsUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nself : IsUniformEmbedding f\nâŠ¢ IsUniformInducing f","decl":"/-- A map `f : Î± â†’ Î²` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Î±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Î± â†’ Î²) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"isUniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (IsUniformInducing f) (Function.Injective f))","decl":"/-- A map `f : Î± â†’ Î²` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Î±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Î± â†’ Î²) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"IsUniformEmbedding.isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformInducing f","decl":"lemma IsUniformEmbedding.isUniformInducing (hf : IsUniformEmbedding f) : IsUniformInducing f :=\n  hf.toIsUniformInducing\n\n"}
{"name":"isUniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Î²)) (uniformity Î±))))","decl":"theorem isUniformEmbedding_iff' {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†”\n      Injective f âˆ§ UniformContinuous f âˆ§ comap (Prod.map f f) (ğ“¤ Î²) â‰¤ ğ“¤ Î± := by\n  rw [isUniformEmbedding_iff, and_comm, isUniformInducing_iff']\n\n"}
{"name":"uniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Î²)) (uniformity Î±))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff' := isUniformEmbedding_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (âˆ€ (i : Î¹'), p' i â†’ Exists fun j => And (p j) (âˆ€ (x y : Î±), Membership.mem (s j) { fst := x, snd := y } â†’ Membership.mem (s' i) { fst := f x, snd := f y })) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y }))))","decl":"theorem Filter.HasBasis.isUniformEmbedding_iff' {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : (ğ“¤ Î±).HasBasis p s) (h' : (ğ“¤ Î²).HasBasis p' s') {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†” Injective f âˆ§\n      (âˆ€ i, p' i â†’ âˆƒ j, p j âˆ§ âˆ€ x y, (x, y) âˆˆ s j â†’ (f x, f y) âˆˆ s' i) âˆ§\n        (âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j) := by\n  rw [isUniformEmbedding_iff, and_comm, h.isUniformInducing_iff h']\n\n"}
{"name":"Filter.HasBasis.uniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (âˆ€ (i : Î¹'), p' i â†’ Exists fun j => And (p j) (âˆ€ (x y : Î±), Membership.mem (s j) { fst := x, snd := y } â†’ Membership.mem (s' i) { fst := f x, snd := f y })) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y }))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Filter.HasBasis.uniformEmbedding_iff' := Filter.HasBasis.isUniformEmbedding_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y }))))","decl":"theorem Filter.HasBasis.isUniformEmbedding_iff {Î¹ Î¹'} {p : Î¹ â†’ Prop} {p' : Î¹' â†’ Prop} {s s'}\n    (h : (ğ“¤ Î±).HasBasis p s) (h' : (ğ“¤ Î²).HasBasis p' s') {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†” Injective f âˆ§ UniformContinuous f âˆ§\n      (âˆ€ j, p j â†’ âˆƒ i, p' i âˆ§ âˆ€ x y, (f x, f y) âˆˆ s' i â†’ (x, y) âˆˆ s j) := by\n  simp only [h.isUniformEmbedding_iff' h', h.uniformContinuous_iff h']\n\n"}
{"name":"Filter.HasBasis.uniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_1\nÎ¹' : Sort u_2\np : Î¹ â†’ Prop\np' : Î¹' â†’ Prop\ns : Î¹ â†’ Set (Prod Î± Î±)\ns' : Î¹' â†’ Set (Prod Î² Î²)\nh : (uniformity Î±).HasBasis p s\nh' : (uniformity Î²).HasBasis p' s'\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (j : Î¹), p j â†’ Exists fun i => And (p' i) (âˆ€ (x y : Î±), Membership.mem (s' i) { fst := f x, snd := f y } â†’ Membership.mem (s j) { fst := x, snd := y }))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Filter.HasBasis.uniformEmbedding_iff := Filter.HasBasis.isUniformEmbedding_iff\n\n"}
{"name":"isUniformEmbedding_subtype_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\np : Î± â†’ Prop\nâŠ¢ IsUniformEmbedding Subtype.val","decl":"theorem isUniformEmbedding_subtype_val {p : Î± â†’ Prop} :\n    IsUniformEmbedding (Subtype.val : Subtype p â†’ Î±) :=\n  { comap_uniformity := rfl\n    injective := Subtype.val_injective }\n\n"}
{"name":"uniformEmbedding_subtype_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\np : Î± â†’ Prop\nâŠ¢ IsUniformEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_subtype_val := isUniformEmbedding_subtype_val\n\n"}
{"name":"isUniformEmbedding_set_inclusion","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\ns t : Set Î±\nhst : HasSubset.Subset s t\nâŠ¢ IsUniformEmbedding (Set.inclusion hst)","decl":"theorem isUniformEmbedding_set_inclusion {s t : Set Î±} (hst : s âŠ† t) :\n    IsUniformEmbedding (inclusion hst) where\n  comap_uniformity := by rw [uniformity_subtype, uniformity_subtype, comap_comap]; rfl\n  injective := inclusion_injective hst\n\n"}
{"name":"uniformEmbedding_set_inclusion","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\ns t : Set Î±\nhst : HasSubset.Subset s t\nâŠ¢ IsUniformEmbedding (Set.inclusion hst)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_set_inclusion := isUniformEmbedding_set_inclusion\n\n"}
{"name":"IsUniformEmbedding.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformEmbedding g\nf : Î± â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp g f)","decl":"theorem IsUniformEmbedding.comp {g : Î² â†’ Î³} (hg : IsUniformEmbedding g) {f : Î± â†’ Î²}\n    (hf : IsUniformEmbedding f) : IsUniformEmbedding (g âˆ˜ f) where\n  toIsUniformInducing := hg.isUniformInducing.comp hf.isUniformInducing\n  injective := hg.injective.comp hf.injective\n\n"}
{"name":"UniformEmbedding.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformEmbedding g\nf : Î± â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.comp := IsUniformEmbedding.comp\n\n"}
{"name":"IsUniformEmbedding.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformEmbedding g\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding (Function.comp g f)) (IsUniformEmbedding f)","decl":"theorem IsUniformEmbedding.of_comp_iff {g : Î² â†’ Î³} (hg : IsUniformEmbedding g) {f : Î± â†’ Î²} :\n    IsUniformEmbedding (g âˆ˜ f) â†” IsUniformEmbedding f := by\n  simp_rw [isUniformEmbedding_iff, hg.isUniformInducing.of_comp_iff, hg.injective.of_comp_iff f]\n\n"}
{"name":"UniformEmbedding.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\ng : Î² â†’ Î³\nhg : IsUniformEmbedding g\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding (Function.comp g f)) (IsUniformEmbedding f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.of_comp_iff := IsUniformEmbedding.of_comp_iff\n\n"}
{"name":"Equiv.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Equiv Î± Î²\nhâ‚ : UniformContinuous â‡‘f\nhâ‚‚ : UniformContinuous â‡‘f.symm\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"theorem Equiv.isUniformEmbedding {Î± Î² : Type*} [UniformSpace Î±] [UniformSpace Î²] (f : Î± â‰ƒ Î²)\n    (hâ‚ : UniformContinuous f) (hâ‚‚ : UniformContinuous f.symm) : IsUniformEmbedding f :=\n  isUniformEmbedding_iff'.2 âŸ¨f.injective, hâ‚, by rwa [â† Equiv.prodCongr_apply, â† map_equiv_symm]âŸ©\n\n"}
{"name":"Equiv.uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Equiv Î± Î²\nhâ‚ : UniformContinuous â‡‘f\nhâ‚‚ : UniformContinuous â‡‘f.symm\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Equiv.uniformEmbedding := Equiv.isUniformEmbedding\n\n"}
{"name":"isUniformEmbedding_inl","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ IsUniformEmbedding Sum.inl","decl":"theorem isUniformEmbedding_inl : IsUniformEmbedding (Sum.inl : Î± â†’ Î± âŠ• Î²) :=\n  isUniformEmbedding_iff'.2 âŸ¨Sum.inl_injective, uniformContinuous_inl, fun s hs =>\n    âŸ¨Prod.map Sum.inl Sum.inl '' s âˆª range (Prod.map Sum.inr Sum.inr),\n      union_mem_sup (image_mem_map hs) range_mem_map,\n      fun x h => by simpa [Prod.map_apply'] using hâŸ©âŸ©\n\n"}
{"name":"uniformEmbedding_inl","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ IsUniformEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_inl := isUniformEmbedding_inl\n\n"}
{"name":"isUniformEmbedding_inr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ IsUniformEmbedding Sum.inr","decl":"theorem isUniformEmbedding_inr : IsUniformEmbedding (Sum.inr : Î² â†’ Î± âŠ• Î²) :=\n  isUniformEmbedding_iff'.2 âŸ¨Sum.inr_injective, uniformContinuous_inr, fun s hs =>\n    âŸ¨range (Prod.map Sum.inl Sum.inl) âˆª Prod.map Sum.inr Sum.inr '' s,\n      union_mem_sup range_mem_map (image_mem_map hs),\n      fun x h => by simpa [Prod.map_apply'] using hâŸ©âŸ©\n\n"}
{"name":"uniformEmbedding_inr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ IsUniformEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_inr := isUniformEmbedding_inr\n\n"}
{"name":"IsUniformInducing.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformEmbedding f","decl":"/-- If the domain of a `IsUniformInducing` map `f` is a Tâ‚€ space, then `f` is injective,\nhence it is a `IsUniformEmbedding`. -/\nprotected theorem IsUniformInducing.isUniformEmbedding [T0Space Î±] {f : Î± â†’ Î²}\n    (hf : IsUniformInducing f) : IsUniformEmbedding f :=\n  âŸ¨hf, hf.isInducing.injectiveâŸ©\n\n"}
{"name":"UniformInducing.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isUniformEmbedding := IsUniformInducing.isUniformEmbedding\n\n"}
{"name":"IsUniformInducing.uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias IsUniformInducing.uniformEmbedding := IsUniformInducing.isUniformEmbedding\n\n"}
{"name":"isUniformEmbedding_iff_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"theorem isUniformEmbedding_iff_isUniformInducing [T0Space Î±] {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†” IsUniformInducing f :=\n  âŸ¨IsUniformEmbedding.isUniformInducing, IsUniformInducing.isUniformEmbeddingâŸ©\n\n"}
{"name":"isUniformEmbedding_iff_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias isUniformEmbedding_iff_uniformInducing := isUniformEmbedding_iff_isUniformInducing\n\n"}
{"name":"uniformEmbedding_iff_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T0Space Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff_isUniformInducing := isUniformEmbedding_iff_isUniformInducing\n\n"}
{"name":"comap_uniformity_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î² : Type v\ninstâœ : UniformSpace Î²\nÎ± : Type u_1\nf : Î± â†’ Î²\ns : Set (Prod Î² Î²)\nhs : Membership.mem (uniformity Î²) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\nâŠ¢ Eq (Filter.comap (Prod.map f f) (uniformity Î²)) (Filter.principal idRel)","decl":"/-- If a map `f : Î± â†’ Î²` sends any two distinct points to point that are **not** related by a fixed\n`s âˆˆ ğ“¤ Î²`, then `f` is uniform inducing with respect to the discrete uniformity on `Î±`:\nthe preimage of `ğ“¤ Î²` under `Prod.map f f` is the principal filter generated by the diagonal in\n`Î± Ã— Î±`. -/\ntheorem comap_uniformity_of_spaced_out {Î±} {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)} (hs : s âˆˆ ğ“¤ Î²)\n    (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : comap (Prod.map f f) (ğ“¤ Î²) = ğ“Ÿ idRel := by\n  refine le_antisymm ?_ (@refl_le_uniformity Î± (UniformSpace.comap f _))\n  calc\n    comap (Prod.map f f) (ğ“¤ Î²) â‰¤ comap (Prod.map f f) (ğ“Ÿ s) := comap_mono (le_principal_iff.2 hs)\n    _ = ğ“Ÿ (Prod.map f f â»Â¹' s) := comap_principal\n    _ â‰¤ ğ“Ÿ idRel := principal_mono.2 ?_\n  rintro âŸ¨x, yâŸ©; simpa [not_imp_not] using @hf x y\n\n"}
{"name":"isUniformEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î² : Type v\ninstâœ : UniformSpace Î²\nÎ± : Type u_1\nf : Î± â†’ Î²\ns : Set (Prod Î² Î²)\nhs : Membership.mem (uniformity Î²) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\nâŠ¢ IsUniformEmbedding f","decl":"/-- If a map `f : Î± â†’ Î²` sends any two distinct points to point that are **not** related by a fixed\n`s âˆˆ ğ“¤ Î²`, then `f` is a uniform embedding with respect to the discrete uniformity on `Î±`. -/\ntheorem isUniformEmbedding_of_spaced_out {Î±} {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)} (hs : s âˆˆ ğ“¤ Î²)\n    (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : @IsUniformEmbedding Î± Î² âŠ¥ â€¹_â€º f := by\n  let _ : UniformSpace Î± := âŠ¥; have := discreteTopology_bot Î±\n  exact IsUniformInducing.isUniformEmbedding âŸ¨comap_uniformity_of_spaced_out hs hfâŸ©\n\n"}
{"name":"uniformEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î² : Type v\ninstâœ : UniformSpace Î²\nÎ± : Type u_1\nf : Î± â†’ Î²\ns : Set (Prod Î² Î²)\nhs : Membership.mem (uniformity Î²) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\nâŠ¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_of_spaced_out := isUniformEmbedding_of_spaced_out\n\n"}
{"name":"IsUniformEmbedding.isEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ Topology.IsEmbedding f","decl":"protected lemma IsUniformEmbedding.isEmbedding {f : Î± â†’ Î²} (h : IsUniformEmbedding f) :\n    IsEmbedding f where\n  toIsInducing := h.toIsUniformInducing.isInducing\n  injective := h.injective\n\n"}
{"name":"IsUniformEmbedding.embedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias IsUniformEmbedding.embedding := IsUniformEmbedding.isEmbedding\n\n"}
{"name":"UniformEmbedding.embedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.embedding := IsUniformEmbedding.isEmbedding\n\n"}
{"name":"IsUniformEmbedding.isDenseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nhd : DenseRange f\nâŠ¢ IsDenseEmbedding f","decl":"theorem IsUniformEmbedding.isDenseEmbedding {f : Î± â†’ Î²} (h : IsUniformEmbedding f)\n    (hd : DenseRange f) : IsDenseEmbedding f :=\n  { h.isEmbedding with dense := hd }\n\n"}
{"name":"UniformEmbedding.isDenseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nhd : DenseRange f\nâŠ¢ IsDenseEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.isDenseEmbedding := IsUniformEmbedding.isDenseEmbedding\n\n"}
{"name":"IsUniformEmbedding.denseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nhd : DenseRange f\nâŠ¢ IsDenseEmbedding f","decl":"@[deprecated (since := \"2024-09-30\")]\nalias IsUniformEmbedding.denseEmbedding := IsUniformEmbedding.isDenseEmbedding\n\n"}
{"name":"isClosedEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î² : Type v\ninstâœÂ³ : UniformSpace Î²\nÎ± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : DiscreteTopology Î±\ninstâœ : T0Space Î²\nf : Î± â†’ Î²\ns : Set (Prod Î² Î²)\nhs : Membership.mem (uniformity Î²) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\nâŠ¢ Topology.IsClosedEmbedding f","decl":"theorem isClosedEmbedding_of_spaced_out {Î±} [TopologicalSpace Î±] [DiscreteTopology Î±]\n    [T0Space Î²] {f : Î± â†’ Î²} {s : Set (Î² Ã— Î²)} (hs : s âˆˆ ğ“¤ Î²)\n    (hf : Pairwise fun x y => (f x, f y) âˆ‰ s) : IsClosedEmbedding f := by\n  rcases @DiscreteTopology.eq_bot Î± _ _ with rfl; let _ : UniformSpace Î± := âŠ¥\n  exact\n    { (isUniformEmbedding_of_spaced_out hs hf).isEmbedding with\n      isClosed_range := isClosed_range_of_spaced_out hs hf }\n\n"}
{"name":"closedEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î² : Type v\ninstâœÂ³ : UniformSpace Î²\nÎ± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : DiscreteTopology Î±\ninstâœ : T0Space Î²\nf : Î± â†’ Î²\ns : Set (Prod Î² Î²)\nhs : Membership.mem (uniformity Î²) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\nâŠ¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_of_spaced_out := isClosedEmbedding_of_spaced_out\n\n"}
{"name":"closure_image_mem_nhds_of_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\ns : Set (Prod Î± Î±)\ne : Î± â†’ Î²\nb : Î²\nheâ‚ : IsUniformInducing e\nheâ‚‚ : IsDenseInducing e\nhs : Membership.mem (uniformity Î±) s\nâŠ¢ Exists fun a => Membership.mem (nhds b) (closure (Set.image e (setOf fun a' => Membership.mem s { fst := a, snd := a' })))","decl":"theorem closure_image_mem_nhds_of_isUniformInducing {s : Set (Î± Ã— Î±)} {e : Î± â†’ Î²} (b : Î²)\n    (heâ‚ : IsUniformInducing e) (heâ‚‚ : IsDenseInducing e) (hs : s âˆˆ ğ“¤ Î±) :\n    âˆƒ a, closure (e '' { a' | (a, a') âˆˆ s }) âˆˆ ğ“ b := by\n  obtain âŸ¨U, âŸ¨hU, hUo, hsymmâŸ©, hsâŸ© :\n    âˆƒ U, (U âˆˆ ğ“¤ Î² âˆ§ IsOpen U âˆ§ SymmetricRel U) âˆ§ Prod.map e e â»Â¹' U âŠ† s := by\n      rwa [â† heâ‚.comap_uniformity, (uniformity_hasBasis_open_symmetric.comap _).mem_iff] at hs\n  rcases heâ‚‚.dense.mem_nhds (UniformSpace.ball_mem_nhds b hU) with âŸ¨a, haâŸ©\n  refine âŸ¨a, mem_of_superset ?_ (closure_mono <| image_subset _ <| UniformSpace.ball_mono hs a)âŸ©\n  have ho : IsOpen (UniformSpace.ball (e a) U) := UniformSpace.isOpen_ball (e a) hUo\n  refine mem_of_superset (ho.mem_nhds <| (UniformSpace.mem_ball_symmetry hsymm).2 ha) fun y hy => ?_\n  refine mem_closure_iff_nhds.2 fun V hV => ?_\n  rcases heâ‚‚.dense.mem_nhds (inter_mem hV (ho.mem_nhds hy)) with âŸ¨x, hxV, hxUâŸ©\n  exact âŸ¨e x, hxV, mem_image_of_mem e hxUâŸ©\n\n"}
{"name":"closure_image_mem_nhds_of_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\ns : Set (Prod Î± Î±)\ne : Î± â†’ Î²\nb : Î²\nheâ‚ : IsUniformInducing e\nheâ‚‚ : IsDenseInducing e\nhs : Membership.mem (uniformity Î±) s\nâŠ¢ Exists fun a => Membership.mem (nhds b) (closure (Set.image e (setOf fun a' => Membership.mem s { fst := a, snd := a' })))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias closure_image_mem_nhds_of_uniformInducing := closure_image_mem_nhds_of_isUniformInducing\n\n"}
{"name":"isUniformEmbedding_subtypeEmb","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\np : Î± â†’ Prop\ne : Î± â†’ Î²\nue : IsUniformEmbedding e\nde : IsDenseEmbedding e\nâŠ¢ IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"theorem isUniformEmbedding_subtypeEmb (p : Î± â†’ Prop) {e : Î± â†’ Î²} (ue : IsUniformEmbedding e)\n    (de : IsDenseEmbedding e) : IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e) :=\n  { comap_uniformity := by\n      simp [comap_comap, Function.comp_def, IsDenseEmbedding.subtypeEmb, uniformity_subtype,\n        ue.comap_uniformity.symm]\n    injective := (de.subtype p).injective }\n\n"}
{"name":"uniformEmbedding_subtypeEmb","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\np : Î± â†’ Prop\ne : Î± â†’ Î²\nue : IsUniformEmbedding e\nde : IsDenseEmbedding e\nâŠ¢ IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_subtypeEmb := isUniformEmbedding_subtypeEmb\n\n"}
{"name":"IsUniformEmbedding.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\nÎ±' : Type u_1\nÎ²' : Type u_2\ninstâœÂ¹ : UniformSpace Î±'\ninstâœ : UniformSpace Î²'\neâ‚ : Î± â†’ Î±'\neâ‚‚ : Î² â†’ Î²'\nhâ‚ : IsUniformEmbedding eâ‚\nhâ‚‚ : IsUniformEmbedding eâ‚‚\nâŠ¢ IsUniformEmbedding fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"theorem IsUniformEmbedding.prod {Î±' : Type*} {Î²' : Type*} [UniformSpace Î±'] [UniformSpace Î²']\n    {eâ‚ : Î± â†’ Î±'} {eâ‚‚ : Î² â†’ Î²'} (hâ‚ : IsUniformEmbedding eâ‚) (hâ‚‚ : IsUniformEmbedding eâ‚‚) :\n    IsUniformEmbedding fun p : Î± Ã— Î² => (eâ‚ p.1, eâ‚‚ p.2) where\n  toIsUniformInducing := hâ‚.isUniformInducing.prod hâ‚‚.isUniformInducing\n  injective := hâ‚.injective.prodMap hâ‚‚.injective\n\n"}
{"name":"UniformEmbedding.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\nÎ±' : Type u_1\nÎ²' : Type u_2\ninstâœÂ¹ : UniformSpace Î±'\ninstâœ : UniformSpace Î²'\neâ‚ : Î± â†’ Î±'\neâ‚‚ : Î² â†’ Î²'\nhâ‚ : IsUniformEmbedding eâ‚\nhâ‚‚ : IsUniformEmbedding eâ‚‚\nâŠ¢ IsUniformEmbedding fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.prod := IsUniformEmbedding.prod\n\n"}
{"name":"isComplete_image_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nm : Î± â†’ Î²\ns : Set Î±\nhm : IsUniformInducing m\nâŠ¢ Iff (IsComplete (Set.image m s)) (IsComplete s)","decl":"/-- A set is complete iff its image under a uniform inducing map is complete. -/\ntheorem isComplete_image_iff {m : Î± â†’ Î²} {s : Set Î±} (hm : IsUniformInducing m) :\n    IsComplete (m '' s) â†” IsComplete s := by\n  have fact1 : SurjOn (map m) (Iic <| ğ“Ÿ s) (Iic <| ğ“Ÿ <| m '' s) := surjOn_image .. |>.filter_map_Iic\n  have fact2 : MapsTo (map m) (Iic <| ğ“Ÿ s) (Iic <| ğ“Ÿ <| m '' s) := mapsTo_image .. |>.filter_map_Iic\n  simp_rw [IsComplete, imp.swap (a := Cauchy _), â† mem_Iic (b := ğ“Ÿ _), fact1.forall fact2,\n    hm.cauchy_map_iff, exists_mem_image, map_le_iff_le_comap, hm.isInducing.nhds_eq_comap]\n\n"}
{"name":"IsUniformInducing.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhf : IsUniformInducing f\nâŠ¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"/-- If `f : X â†’ Y` is an `IsUniformInducing` map, the image `f '' s` of a set `s` is complete\n  if and only if `s` is complete. -/\ntheorem IsUniformInducing.isComplete_iff {f : Î± â†’ Î²} {s : Set Î±} (hf : IsUniformInducing f) :\n    IsComplete (f '' s) â†” IsComplete s := isComplete_image_iff hf\n\n"}
{"name":"UniformInducing.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhf : IsUniformInducing f\nâŠ¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isComplete_iff := IsUniformInducing.isComplete_iff\n\n"}
{"name":"IsUniformEmbedding.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhf : IsUniformEmbedding f\nâŠ¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"/-- If `f : X â†’ Y` is an `IsUniformEmbedding`, the image `f '' s` of a set `s` is complete\n  if and only if `s` is complete. -/\ntheorem IsUniformEmbedding.isComplete_iff {f : Î± â†’ Î²} {s : Set Î±} (hf : IsUniformEmbedding f) :\n    IsComplete (f '' s) â†” IsComplete s := hf.isUniformInducing.isComplete_iff\n\n"}
{"name":"UniformEmbedding.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhf : IsUniformEmbedding f\nâŠ¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.isComplete_iff := IsUniformEmbedding.isComplete_iff\n\n"}
{"name":"Subtype.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\np : Î± â†’ Prop\ns : Set (Subtype fun x => p x)\nâŠ¢ Iff (IsComplete s) (IsComplete (Set.image Subtype.val s))","decl":"/-- Sets of a subtype are complete iff their image under the coercion is complete. -/\ntheorem Subtype.isComplete_iff {p : Î± â†’ Prop} {s : Set { x // p x }} :\n    IsComplete s â†” IsComplete ((â†‘) '' s : Set Î±) :=\n  isUniformEmbedding_subtype_val.isComplete_iff.symm\n\n"}
{"name":"isComplete_of_complete_image","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nm : Î± â†’ Î²\ns : Set Î±\nhm : IsUniformInducing m\naâœ : IsComplete (Set.image m s)\nâŠ¢ IsComplete s","decl":"alias âŸ¨isComplete_of_complete_image, _âŸ© := isComplete_image_iff\n\n"}
{"name":"completeSpace_iff_isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ Iff (CompleteSpace Î±) (IsComplete (Set.range f))","decl":"theorem completeSpace_iff_isComplete_range {f : Î± â†’ Î²} (hf : IsUniformInducing f) :\n    CompleteSpace Î± â†” IsComplete (range f) := by\n  rw [completeSpace_iff_isComplete_univ, â† isComplete_image_iff hf, image_univ]\n\n"}
{"name":"IsUniformInducing.completeSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\naâœ : IsComplete (Set.range f)\nâŠ¢ CompleteSpace Î±","decl":"alias âŸ¨_, IsUniformInducing.completeSpaceâŸ© := completeSpace_iff_isComplete_range\n\n"}
{"name":"UniformInducing.completeSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\naâœ : IsComplete (Set.range f)\nâŠ¢ CompleteSpace Î±","decl":"@[deprecated (since := \"2024-10-08\")] alias UniformInducing.completeSpace :=\n  IsUniformInducing.completeSpace\n\n"}
{"name":"IsUniformInducing.isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\nf : Î± â†’ Î²\ninstâœ : CompleteSpace Î±\nhf : IsUniformInducing f\nâŠ¢ IsComplete (Set.range f)","decl":"lemma IsUniformInducing.isComplete_range [CompleteSpace Î±] (hf : IsUniformInducing f) :\n    IsComplete (range f) :=\n  (completeSpace_iff_isComplete_range hf).1 â€¹_â€º\n\n"}
{"name":"UniformInducing.isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\nf : Î± â†’ Î²\ninstâœ : CompleteSpace Î±\nhf : IsUniformInducing f\nâŠ¢ IsComplete (Set.range f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isComplete_range := IsUniformInducing.isComplete_range\n\n"}
{"name":"IsUniformInducing.completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nhsurj : Function.Surjective f\nâŠ¢ Iff (CompleteSpace Î±) (CompleteSpace Î²)","decl":"/-- If `f` is a surjective uniform inducing map,\nthen its domain is a complete space iff its codomain is a complete space.\nSee also `_root_.completeSpace_congr` for a version that assumes `f` to be an equivalence. -/\ntheorem IsUniformInducing.completeSpace_congr {f : Î± â†’ Î²} (hf : IsUniformInducing f)\n    (hsurj : f.Surjective) : CompleteSpace Î± â†” CompleteSpace Î² := by\n  rw [completeSpace_iff_isComplete_range hf, hsurj.range_eq, completeSpace_iff_isComplete_univ]\n\n"}
{"name":"UniformInducing.completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\nhf : IsUniformInducing f\nhsurj : Function.Surjective f\nâŠ¢ Iff (CompleteSpace Î±) (CompleteSpace Î²)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.completeSpace_congr := IsUniformInducing.completeSpace_congr\n\n"}
{"name":"SeparationQuotient.completeSpace_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ Iff (CompleteSpace (SeparationQuotient Î±)) (CompleteSpace Î±)","decl":"theorem SeparationQuotient.completeSpace_iff :\n    CompleteSpace (SeparationQuotient Î±) â†” CompleteSpace Î± :=\n  .symm <| isUniformInducing_mk.completeSpace_congr surjective_mk\n\n"}
{"name":"SeparationQuotient.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ CompleteSpace (SeparationQuotient Î±)","decl":"instance SeparationQuotient.instCompleteSpace [CompleteSpace Î±] :\n    CompleteSpace (SeparationQuotient Î±) :=\n  completeSpace_iff.2 â€¹_â€º\n\n"}
{"name":"completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\ne : Equiv Î± Î²\nhe : IsUniformEmbedding â‡‘e\nâŠ¢ Iff (CompleteSpace Î±) (CompleteSpace Î²)","decl":"/-- See also `IsUniformInducing.completeSpace_congr`\nfor a version that works for non-injective maps. -/\ntheorem completeSpace_congr {e : Î± â‰ƒ Î²} (he : IsUniformEmbedding e) :\n    CompleteSpace Î± â†” CompleteSpace Î² :=\n  he.completeSpace_congr e.surjective\n\n"}
{"name":"completeSpace_coe_iff_isComplete","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\ns : Set Î±\nâŠ¢ Iff (CompleteSpace â†‘s) (IsComplete s)","decl":"theorem completeSpace_coe_iff_isComplete {s : Set Î±} : CompleteSpace s â†” IsComplete s := by\n  rw [completeSpace_iff_isComplete_range isUniformEmbedding_subtype_val.isUniformInducing,\n    Subtype.range_coe]\n\n"}
{"name":"IsComplete.completeSpace_coe","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\ns : Set Î±\naâœ : IsComplete s\nâŠ¢ CompleteSpace â†‘s","decl":"alias âŸ¨_, IsComplete.completeSpace_coeâŸ© := completeSpace_coe_iff_isComplete\n\n"}
{"name":"IsClosed.completeSpace_coe","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : CompleteSpace Î±\ns : Set Î±\nhs : IsClosed s\nâŠ¢ CompleteSpace â†‘s","decl":"theorem IsClosed.completeSpace_coe [CompleteSpace Î±] {s : Set Î±} (hs : IsClosed s) :\n    CompleteSpace s :=\n  hs.isComplete.completeSpace_coe\n\n"}
{"name":"completeSpace_ulift_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœ : UniformSpace Î±\nâŠ¢ Iff (CompleteSpace (ULift.{u_1, u} Î±)) (CompleteSpace Î±)","decl":"theorem completeSpace_ulift_iff : CompleteSpace (ULift Î±) â†” CompleteSpace Î± :=\n  IsUniformInducing.completeSpace_congr âŸ¨rflâŸ© ULift.down_surjective\n\n"}
{"name":"ULift.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ CompleteSpace (ULift.{u_1, u} Î±)","decl":"/-- The lift of a complete space to another universe is still complete. -/\ninstance ULift.instCompleteSpace [CompleteSpace Î±] : CompleteSpace (ULift Î±) :=\n  completeSpace_ulift_iff.2 â€¹_â€º\n\n"}
{"name":"completeSpace_extension","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nm : Î² â†’ Î±\nhm : IsUniformInducing m\ndense : DenseRange m\nh : âˆ€ (f : Filter Î²), Cauchy f â†’ Exists fun x => LE.le (Filter.map m f) (nhds x)\nâŠ¢ CompleteSpace Î±","decl":"theorem completeSpace_extension {m : Î² â†’ Î±} (hm : IsUniformInducing m) (dense : DenseRange m)\n    (h : âˆ€ f : Filter Î², Cauchy f â†’ âˆƒ x : Î±, map m f â‰¤ ğ“ x) : CompleteSpace Î± :=\n  âŸ¨fun {f : Filter Î±} (hf : Cauchy f) =>\n    let p : Set (Î± Ã— Î±) â†’ Set Î± â†’ Set Î± := fun s t => { y : Î± | âˆƒ x : Î±, x âˆˆ t âˆ§ (x, y) âˆˆ s }\n    let g := (ğ“¤ Î±).lift fun s => f.lift' (p s)\n    have mpâ‚€ : Monotone p := fun _ _ h _ _ âŸ¨x, xs, xaâŸ© => âŸ¨x, xs, h xaâŸ©\n    have mpâ‚ : âˆ€ {s}, Monotone (p s) := fun h _ âŸ¨y, ya, yxsâŸ© => âŸ¨y, h ya, yxsâŸ©\n    have : f â‰¤ g := le_iInfâ‚‚ fun _ hs => le_iInfâ‚‚ fun _ ht =>\n      le_principal_iff.mpr <| mem_of_superset ht fun x hx => âŸ¨x, hx, refl_mem_uniformity hsâŸ©\n    have : NeBot g := hf.left.mono this\n    have : NeBot (comap m g) :=\n      comap_neBot fun _ ht =>\n        let âŸ¨t', ht', ht_memâŸ© := (mem_lift_sets <| monotone_lift' monotone_const mpâ‚€).mp ht\n        let âŸ¨_, ht'', ht'_subâŸ© := (mem_lift'_sets mpâ‚).mp ht_mem\n        let âŸ¨x, hxâŸ© := hf.left.nonempty_of_mem ht''\n        have hâ‚€ : NeBot (ğ“[range m] x) := dense.nhdsWithin_neBot x\n        have hâ‚ : { y | (x, y) âˆˆ t' } âˆˆ ğ“[range m] x :=\n          @mem_inf_of_left Î± (ğ“ x) (ğ“Ÿ (range m)) _ <| mem_nhds_left x ht'\n        have hâ‚‚ : range m âˆˆ ğ“[range m] x :=\n          @mem_inf_of_right Î± (ğ“ x) (ğ“Ÿ (range m)) _ <| Subset.refl _\n        have : { y | (x, y) âˆˆ t' } âˆ© range m âˆˆ ğ“[range m] x := @inter_mem Î± (ğ“[range m] x) _ _ hâ‚ hâ‚‚\n        let âŸ¨_, xyt', b, b_eqâŸ© := hâ‚€.nonempty_of_mem this\n        âŸ¨b, b_eq.symm â–¸ ht'_sub âŸ¨x, hx, xyt'âŸ©âŸ©\n    have : Cauchy g :=\n      âŸ¨â€¹NeBot gâ€º, fun _ hs =>\n        let âŸ¨sâ‚, hsâ‚, comp_sâ‚âŸ© := comp_mem_uniformity_sets hs\n        let âŸ¨sâ‚‚, hsâ‚‚, comp_sâ‚‚âŸ© := comp_mem_uniformity_sets hsâ‚\n        let âŸ¨t, ht, (prod_t : t Ã—Ë¢ t âŠ† sâ‚‚)âŸ© := mem_prod_same_iff.mp (hf.right hsâ‚‚)\n        have hgâ‚ : p (preimage Prod.swap sâ‚) t âˆˆ g :=\n          mem_lift (symm_le_uniformity hsâ‚) <| @mem_lift' Î± Î± f _ t ht\n        have hgâ‚‚ : p sâ‚‚ t âˆˆ g := mem_lift hsâ‚‚ <| @mem_lift' Î± Î± f _ t ht\n        have hg : p (Prod.swap â»Â¹' sâ‚) t Ã—Ë¢ p sâ‚‚ t âˆˆ g Ã—Ë¢ g := @prod_mem_prod Î± Î± _ _ g g hgâ‚ hgâ‚‚\n        (g Ã—Ë¢ g).sets_of_superset hg fun âŸ¨_, _âŸ© âŸ¨âŸ¨câ‚, câ‚t, hcâ‚âŸ©, âŸ¨câ‚‚, câ‚‚t, hcâ‚‚âŸ©âŸ© =>\n          have : (câ‚, câ‚‚) âˆˆ t Ã—Ë¢ t := âŸ¨câ‚t, câ‚‚tâŸ©\n          comp_sâ‚ <| prod_mk_mem_compRel hcâ‚ <| comp_sâ‚‚ <| prod_mk_mem_compRel (prod_t this) hcâ‚‚âŸ©\n    have : Cauchy (Filter.comap m g) := â€¹Cauchy gâ€º.comap' (le_of_eq hm.comap_uniformity) â€¹_â€º\n    let âŸ¨x, (hx : map m (Filter.comap m g) â‰¤ ğ“ x)âŸ© := h _ this\n    have : ClusterPt x (map m (Filter.comap m g)) :=\n      (le_nhds_iff_adhp_of_cauchy (this.map hm.uniformContinuous)).mp hx\n    have : ClusterPt x g := this.mono map_comap_le\n    âŸ¨x,\n      calc\n        f â‰¤ g := by assumption\n        _ â‰¤ ğ“ x := le_nhds_of_cauchy_adhp â€¹Cauchy gâ€º this\n        âŸ©âŸ©\n\n"}
{"name":"totallyBounded_image_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhf : IsUniformInducing f\nâŠ¢ Iff (TotallyBounded (Set.image f s)) (TotallyBounded s)","decl":"lemma totallyBounded_image_iff {f : Î± â†’ Î²} {s : Set Î±} (hf : IsUniformInducing f) :\n    TotallyBounded (f '' s) â†” TotallyBounded s := by\n  refine âŸ¨fun hs â†¦ ?_, fun h â†¦ h.image hf.uniformContinuousâŸ©\n  simp_rw [(hf.basis_uniformity (basis_sets _)).totallyBounded_iff]\n  intro t ht\n  rcases exists_subset_image_finite_and.1 (hs.exists_subset ht) with âŸ¨u, -, hfin, hâŸ©\n  use u, hfin\n  rwa [biUnion_image, image_subset_iff, preimage_iUnionâ‚‚] at h\n\n"}
{"name":"totallyBounded_preimage","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nf : Î± â†’ Î²\ns : Set Î²\nhf : IsUniformInducing f\nhs : TotallyBounded s\nâŠ¢ TotallyBounded (Set.preimage f s)","decl":"theorem totallyBounded_preimage {f : Î± â†’ Î²} {s : Set Î²} (hf : IsUniformInducing f)\n    (hs : TotallyBounded s) : TotallyBounded (f â»Â¹' s) :=\n  (totallyBounded_image_iff hf).1 <| hs.subset <| image_preimage_subset ..\n\n"}
{"name":"CompleteSpace.sum","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : CompleteSpace Î²\nâŠ¢ CompleteSpace (Sum Î± Î²)","decl":"instance CompleteSpace.sum [CompleteSpace Î±] [CompleteSpace Î²] : CompleteSpace (Î± âŠ• Î²) := by\n  rw [completeSpace_iff_isComplete_univ, â† range_inl_union_range_inr]\n  exact isUniformEmbedding_inl.isUniformInducing.isComplete_range.union\n    isUniformEmbedding_inr.isUniformInducing.isComplete_range\n\n"}
{"name":"isUniformEmbedding_comap","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nu : UniformSpace Î²\nhf : Function.Injective f\nâŠ¢ IsUniformEmbedding f","decl":"theorem isUniformEmbedding_comap {Î± : Type*} {Î² : Type*} {f : Î± â†’ Î²} [u : UniformSpace Î²]\n    (hf : Function.Injective f) : @IsUniformEmbedding Î± Î² (UniformSpace.comap f u) u f :=\n  @IsUniformEmbedding.mk _ _ (UniformSpace.comap f u) _ _\n    (@IsUniformInducing.mk _ _ (UniformSpace.comap f u) _ _ rfl) hf\n\n"}
{"name":"uniformEmbedding_comap","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nu : UniformSpace Î²\nhf : Function.Injective f\nâŠ¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_comap := isUniformEmbedding_comap\n\n"}
{"name":"Embedding.to_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î±\nu : UniformSpace Î²\nf : Î± â†’ Î²\nh : Topology.IsEmbedding f\nâŠ¢ IsUniformEmbedding f","decl":"theorem Embedding.to_isUniformEmbedding {Î± Î²} [TopologicalSpace Î±] [u : UniformSpace Î²] (f : Î± â†’ Î²)\n    (h : IsEmbedding f) : @IsUniformEmbedding Î± Î² (h.comapUniformSpace f) u f :=\n  let _ := h.comapUniformSpace f\n  { comap_uniformity := rfl\n    injective := h.injective }\n\n"}
{"name":"Embedding.to_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î±\nu : UniformSpace Î²\nf : Î± â†’ Î²\nh : Topology.IsEmbedding f\nâŠ¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Embedding.to_uniformEmbedding := Embedding.to_isUniformEmbedding\n\n"}
{"name":"uniformly_extend_exists","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ne : Î² â†’ Î±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Î² â†’ Î³\nh_f : UniformContinuous f\ninstâœ : CompleteSpace Î³\na : Î±\nâŠ¢ Exists fun c => Filter.Tendsto f (Filter.comap e (nhds a)) (nhds c)","decl":"include h_e h_dense h_f in\ntheorem uniformly_extend_exists [CompleteSpace Î³] (a : Î±) : âˆƒ c, Tendsto f (comap e (ğ“ a)) (ğ“ c) :=\n  let de := h_e.isDenseInducing h_dense\n  have : Cauchy (ğ“ a) := cauchy_nhds\n  have : Cauchy (comap e (ğ“ a)) :=\n    this.comap' (le_of_eq h_e.comap_uniformity) (de.comap_nhds_neBot _)\n  have : Cauchy (map f (comap e (ğ“ a))) := this.map h_f\n  CompleteSpace.complete this\n\n"}
{"name":"uniform_extend_subtype","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ninstâœ : CompleteSpace Î³\np : Î± â†’ Prop\ne : Î± â†’ Î²\nf : Î± â†’ Î³\nb : Î²\ns : Set Î±\nhf : UniformContinuous fun x => f â†‘x\nhe : IsUniformEmbedding e\nhd : âˆ€ (x : Î²), Membership.mem (closure (Set.range e)) x\nhb : Membership.mem (nhds b) (closure (Set.image e s))\nhs : IsClosed s\nhp : âˆ€ (x : Î±), Membership.mem s x â†’ p x\nâŠ¢ Exists fun c => Filter.Tendsto f (Filter.comap e (nhds b)) (nhds c)","decl":"theorem uniform_extend_subtype [CompleteSpace Î³] {p : Î± â†’ Prop} {e : Î± â†’ Î²} {f : Î± â†’ Î³} {b : Î²}\n    {s : Set Î±} (hf : UniformContinuous fun x : Subtype p => f x.val) (he : IsUniformEmbedding e)\n    (hd : âˆ€ x : Î², x âˆˆ closure (range e)) (hb : closure (e '' s) âˆˆ ğ“ b) (hs : IsClosed s)\n    (hp : âˆ€ x âˆˆ s, p x) : âˆƒ c, Tendsto f (comap e (ğ“ b)) (ğ“ c) := by\n  have de : IsDenseEmbedding e := he.isDenseEmbedding hd\n  have de' : IsDenseEmbedding (IsDenseEmbedding.subtypeEmb p e) := de.subtype p\n  have ue' : IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e) :=\n    isUniformEmbedding_subtypeEmb _ he de\n  have : b âˆˆ closure (e '' { x | p x }) :=\n    (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)\n  let âŸ¨c, hcâŸ© := uniformly_extend_exists ue'.isUniformInducing de'.dense hf âŸ¨b, thisâŸ©\n  replace hc : Tendsto (f âˆ˜ Subtype.val (p := p)) (((ğ“ b).comap e).comap Subtype.val) (ğ“ c) := by\n    simpa only [nhds_subtype_eq_comap, comap_comap, IsDenseEmbedding.subtypeEmb_coe] using hc\n  refine âŸ¨c, (tendsto_comap'_iff ?_).1 hcâŸ©\n  rw [Subtype.range_coe_subtype]\n  exact âŸ¨_, hb, by rwa [â† de.isInducing.closure_eq_preimage_closure_image, hs.closure_eq]âŸ©\n\n"}
{"name":"uniformly_extend_spec","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ne : Î² â†’ Î±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Î² â†’ Î³\nh_f : UniformContinuous f\ninstâœ : CompleteSpace Î³\na : Î±\nâŠ¢ Filter.Tendsto f (Filter.comap e (nhds a)) (nhds (â‹¯.extend f a))","decl":"include h_e h_f in\ntheorem uniformly_extend_spec [CompleteSpace Î³] (a : Î±) : Tendsto f (comap e (ğ“ a)) (ğ“ (Ïˆ a)) := by\n  simpa only [IsDenseInducing.extend] using\n    tendsto_nhds_limUnder (uniformly_extend_exists h_e â€¹_â€º h_f _)\n\n"}
{"name":"uniformContinuous_uniformly_extend","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ne : Î² â†’ Î±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Î² â†’ Î³\nh_f : UniformContinuous f\ninstâœ : CompleteSpace Î³\nâŠ¢ UniformContinuous (â‹¯.extend f)","decl":"include h_f in\ntheorem uniformContinuous_uniformly_extend [CompleteSpace Î³] : UniformContinuous Ïˆ := fun d hd =>\n  let âŸ¨s, hs, hs_compâŸ© := comp3_mem_uniformity hd\n  have h_pnt : âˆ€ {a m}, m âˆˆ ğ“ a â†’ âˆƒ c âˆˆ f '' (e â»Â¹' m), (c, Ïˆ a) âˆˆ s âˆ§ (Ïˆ a, c) âˆˆ s :=\n    fun {a m} hm =>\n    have nb : NeBot (map f (comap e (ğ“ a))) :=\n      ((h_e.isDenseInducing h_dense).comap_nhds_neBot _).map _\n    have :\n      f '' (e â»Â¹' m) âˆ© ({ c | (c, Ïˆ a) âˆˆ s } âˆ© { c | (Ïˆ a, c) âˆˆ s }) âˆˆ map f (comap e (ğ“ a)) :=\n      inter_mem (image_mem_map <| preimage_mem_comap <| hm)\n        (uniformly_extend_spec h_e h_dense h_f _\n          (inter_mem (mem_nhds_right _ hs) (mem_nhds_left _ hs)))\n    nb.nonempty_of_mem this\n  have : (Prod.map f f) â»Â¹' s âˆˆ ğ“¤ Î² := h_f hs\n  have : (Prod.map f f) â»Â¹' s âˆˆ comap (Prod.map e e) (ğ“¤ Î±) := by\n    rwa [â† h_e.comap_uniformity] at this\n  let âŸ¨t, ht, tsâŸ© := this\n  show (Prod.map Ïˆ Ïˆ) â»Â¹' d âˆˆ ğ“¤ Î± from\n    mem_of_superset (interior_mem_uniformity ht) fun âŸ¨xâ‚, xâ‚‚âŸ© hx_t => by\n      have : interior t âˆˆ ğ“ (xâ‚, xâ‚‚) := isOpen_interior.mem_nhds hx_t\n      let âŸ¨mâ‚, hmâ‚, mâ‚‚, hmâ‚‚, (hm : mâ‚ Ã—Ë¢ mâ‚‚ âŠ† interior t)âŸ© := mem_nhds_prod_iff.mp this\n      obtain âŸ¨_, âŸ¨a, haâ‚, rflâŸ©, _, haâ‚‚âŸ© := h_pnt hmâ‚\n      obtain âŸ¨_, âŸ¨b, hbâ‚, rflâŸ©, hbâ‚‚, _âŸ© := h_pnt hmâ‚‚\n      have : Prod.map f f (a, b) âˆˆ s :=\n        ts <| mem_preimage.2 <| interior_subset (@hm (e a, e b) âŸ¨haâ‚, hbâ‚âŸ©)\n      exact hs_comp âŸ¨f a, haâ‚‚, âŸ¨f b, this, hbâ‚‚âŸ©âŸ©\n\n"}
{"name":"uniformly_extend_of_ind","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ne : Î² â†’ Î±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Î² â†’ Î³\nh_f : UniformContinuous f\ninstâœ : T0Space Î³\nb : Î²\nâŠ¢ Eq (â‹¯.extend f (e b)) (f b)","decl":"include h_f in\ntheorem uniformly_extend_of_ind (b : Î²) : Ïˆ (e b) = f b :=\n  IsDenseInducing.extend_eq_at _ h_f.continuous.continuousAt\n\n"}
{"name":"uniformly_extend_unique","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : UniformSpace Î³\ne : Î² â†’ Î±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Î² â†’ Î³\ninstâœ : T0Space Î³\ng : Î± â†’ Î³\nhg : âˆ€ (b : Î²), Eq (g (e b)) (f b)\nhc : Continuous g\nâŠ¢ Eq (â‹¯.extend f) g","decl":"theorem uniformly_extend_unique {g : Î± â†’ Î³} (hg : âˆ€ b, g (e b) = f b) (hc : Continuous g) : Ïˆ = g :=\n  IsDenseInducing.extend_unique _ hg hc\n\n"}
{"name":"isUniformInducing_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\ninstâœ : UniformSpace Î±\ns : Set Î±\nâŠ¢ IsUniformInducing Subtype.val","decl":"theorem isUniformInducing_val (s : Set Î±) :\n    IsUniformInducing (@Subtype.val Î± s) := âŸ¨uniformity_setCoeâŸ©\n\n"}
{"name":"Dense.extend_exists","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : CompleteSpace Î²\nhs : Dense s\nhf : UniformContinuous f\na : Î±\nâŠ¢ Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)","decl":"theorem extend_exists [CompleteSpace Î²] (hs : Dense s) (hf : UniformContinuous f) (a : Î±) :\n    âˆƒ b, Tendsto f (comap (â†‘) (ğ“ a)) (ğ“ b) :=\n  uniformly_extend_exists (isUniformInducing_val s) hs.denseRange_val hf a\n\n"}
{"name":"Dense.extend_spec","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : CompleteSpace Î²\nhs : Dense s\nhf : UniformContinuous f\na : Î±\nâŠ¢ Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds (hs.extend f a))","decl":"theorem extend_spec [CompleteSpace Î²] (hs : Dense s) (hf : UniformContinuous f) (a : Î±) :\n    Tendsto f (comap (â†‘) (ğ“ a)) (ğ“ (hs.extend f a)) :=\n  uniformly_extend_spec (isUniformInducing_val s) hs.denseRange_val hf a\n\n"}
{"name":"Dense.uniformContinuous_extend","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : CompleteSpace Î²\nhs : Dense s\nhf : UniformContinuous f\nâŠ¢ UniformContinuous (hs.extend f)","decl":"theorem uniformContinuous_extend [CompleteSpace Î²] (hs : Dense s) (hf : UniformContinuous f) :\n    UniformContinuous (hs.extend f) :=\n  uniformContinuous_uniformly_extend (isUniformInducing_val s) hs.denseRange_val hf\n\n"}
{"name":"Dense.extend_of_ind","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T0Space Î²\nhs : Dense s\nhf : UniformContinuous f\nx : â†‘s\nâŠ¢ Eq (hs.extend f â†‘x) (f x)","decl":"theorem extend_of_ind (hs : Dense s) (hf : UniformContinuous f) (x : s) :\n    hs.extend f x = f x :=\n  IsDenseInducing.extend_eq_at _ hf.continuous.continuousAt\n\n"}
