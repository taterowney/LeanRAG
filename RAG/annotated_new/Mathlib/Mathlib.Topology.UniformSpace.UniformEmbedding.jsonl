{"name":"IsUniformInducing.comap_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nself : IsUniformInducing f\n‚ä¢ Eq (Filter.comap (fun x => { fst := f x.1, snd := f x.2 }) (uniformity Œ≤)) (uniformity Œ±)","decl":"/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is called *uniform inducing* if the uniformity filter\non `Œ±` is the pullback of the uniformity filter on `Œ≤` under `Prod.map f f`. If `Œ±` is a separated\nspace, then this implies that `f` is injective, hence it is a `IsUniformEmbedding`. -/\n@[mk_iff]\nstructure IsUniformInducing (f : Œ± ‚Üí Œ≤) : Prop where\n  /-- The uniformity filter on the domain is the pullback of the uniformity filter on the codomain\n  under `Prod.map f f`. -/\n  comap_uniformity : comap (fun x : Œ± √ó Œ± => (f x.1, f x.2)) (ùì§ Œ≤) = ùì§ Œ±\n\n"}
{"name":"isUniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (Eq (Filter.comap (fun x => { fst := f x.1, snd := f x.2 }) (uniformity Œ≤)) (uniformity Œ±))","decl":"/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is called *uniform inducing* if the uniformity filter\non `Œ±` is the pullback of the uniformity filter on `Œ≤` under `Prod.map f f`. If `Œ±` is a separated\nspace, then this implies that `f` is injective, hence it is a `IsUniformEmbedding`. -/\n@[mk_iff]\nstructure IsUniformInducing (f : Œ± ‚Üí Œ≤) : Prop where\n  /-- The uniformity filter on the domain is the pullback of the uniformity filter on the codomain\n  under `Prod.map f f`. -/\n  comap_uniformity : comap (fun x : Œ± √ó Œ± => (f x.1, f x.2)) (ùì§ Œ≤) = ùì§ Œ±\n\n"}
{"name":"isUniformInducing_iff_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (Eq (UniformSpace.comap f inst‚úù) inst‚úù¬π)","decl":"lemma isUniformInducing_iff_uniformSpace {f : Œ± ‚Üí Œ≤} :\n    IsUniformInducing f ‚Üî ‚ÄπUniformSpace Œ≤‚Ä∫.comap f = ‚ÄπUniformSpace Œ±‚Ä∫ := by\n  rw [isUniformInducing_iff, UniformSpace.ext_iff, Filter.ext_iff]\n  rfl\n\n"}
{"name":"uniformInducing_iff_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (Eq (UniformSpace.comap f inst‚úù) inst‚úù¬π)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff_uniformSpace := isUniformInducing_iff_uniformSpace\n\n"}
{"name":"IsUniformInducing.comap_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\na‚úù : IsUniformInducing f\n‚ä¢ Eq (UniformSpace.comap f inst‚úù) inst‚úù¬π","decl":"protected alias ‚ü®IsUniformInducing.comap_uniformSpace, _‚ü© := isUniformInducing_iff_uniformSpace\n\n"}
{"name":"UniformInducing.comap_uniformSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\na‚úù : IsUniformInducing f\n‚ä¢ Eq (UniformSpace.comap f inst‚úù) inst‚úù¬π","decl":"@[deprecated (since := \"2024-10-08\")] alias UniformInducing.comap_uniformSpace :=\n  IsUniformInducing.comap_uniformSpace\n\n"}
{"name":"isUniformInducing_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Œ≤)) (uniformity Œ±)))","decl":"lemma isUniformInducing_iff' {f : Œ± ‚Üí Œ≤} :\n    IsUniformInducing f ‚Üî UniformContinuous f ‚àß comap (Prod.map f f) (ùì§ Œ≤) ‚â§ ùì§ Œ± := by\n  rw [isUniformInducing_iff, UniformContinuous, tendsto_iff_comap, le_antisymm_iff, and_comm]; rfl\n\n"}
{"name":"uniformInducing_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Œ≤)) (uniformity Œ±)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff' := isUniformInducing_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (And (‚àÄ (i : Œπ'), p' i ‚Üí Exists fun j => And (p j) (‚àÄ (x y : Œ±), Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (s' i) { fst := f x, snd := f y })) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y })))","decl":"protected lemma Filter.HasBasis.isUniformInducing_iff {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}\n    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :\n    IsUniformInducing f ‚Üî\n      (‚àÄ i, p' i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà s' i) ‚àß\n        (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by\n  simp [isUniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]\n\n"}
{"name":"Filter.HasBasis.uniformInducing_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing f) (And (‚àÄ (i : Œπ'), p' i ‚Üí Exists fun j => And (p j) (‚àÄ (x y : Œ±), Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (s' i) { fst := f x, snd := f y })) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y })))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias Filter.HasBasis.uniformInducing_iff := Filter.HasBasis.isUniformInducing_iff\n\n"}
{"name":"IsUniformInducing.mk'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (s : Set (Prod Œ± Œ±)), Iff (Membership.mem (uniformity Œ±) s) (Exists fun t => And (Membership.mem (uniformity Œ≤) t) (‚àÄ (x y : Œ±), Membership.mem t { fst := f x, snd := f y } ‚Üí Membership.mem s { fst := x, snd := y }))\n‚ä¢ IsUniformInducing f","decl":"theorem IsUniformInducing.mk' {f : Œ± ‚Üí Œ≤}\n    (h : ‚àÄ s, s ‚àà ùì§ Œ± ‚Üî ‚àÉ t ‚àà ùì§ Œ≤, ‚àÄ x y : Œ±, (f x, f y) ‚àà t ‚Üí (x, y) ‚àà s) : IsUniformInducing f :=\n  ‚ü®by simp [eq_comm, Filter.ext_iff, subset_def, h]‚ü©\n\n"}
{"name":"UniformInducing.mk'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (s : Set (Prod Œ± Œ±)), Iff (Membership.mem (uniformity Œ±) s) (Exists fun t => And (Membership.mem (uniformity Œ≤) t) (‚àÄ (x y : Œ±), Membership.mem t { fst := f x, snd := f y } ‚Üí Membership.mem s { fst := x, snd := y }))\n‚ä¢ IsUniformInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.mk' := IsUniformInducing.mk'\n\n"}
{"name":"IsUniformInducing.id","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ IsUniformInducing id","decl":"theorem IsUniformInducing.id : IsUniformInducing (@id Œ±) :=\n  ‚ü®by rw [‚Üê Prod.map_def, Prod.map_id, comap_id]‚ü©\n\n"}
{"name":"uniformInducing_id","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ IsUniformInducing id","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_id := IsUniformInducing.id\n\n"}
{"name":"IsUniformInducing.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ IsUniformInducing (Function.comp g f)","decl":"theorem IsUniformInducing.comp {g : Œ≤ ‚Üí Œ≥} (hg : IsUniformInducing g) {f : Œ± ‚Üí Œ≤}\n    (hf : IsUniformInducing f) : IsUniformInducing (g ‚àò f) :=\n  ‚ü®by rw [‚Üê hf.1, ‚Üê hg.1, comap_comap]; rfl‚ü©\n\n"}
{"name":"UniformInducing.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ IsUniformInducing (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.comp := IsUniformInducing.comp\n\n"}
{"name":"IsUniformInducing.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"theorem IsUniformInducing.of_comp_iff {g : Œ≤ ‚Üí Œ≥} (hg : IsUniformInducing g) {f : Œ± ‚Üí Œ≤} :\n    IsUniformInducing (g ‚àò f) ‚Üî IsUniformInducing f := by\n  refine ‚ü®fun h ‚Ü¶ ?_, hg.comp‚ü©\n  rw [isUniformInducing_iff, ‚Üê hg.comap_uniformity, comap_comap, ‚Üê h.comap_uniformity,\n    Function.comp_def, Function.comp_def]\n\n"}
{"name":"UniformInducing.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.of_comp_iff := IsUniformInducing.of_comp_iff\n\n"}
{"name":"IsUniformInducing.basis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nŒπ : Sort u_1\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ≤ Œ≤)\nH : (uniformity Œ≤).HasBasis p s\n‚ä¢ (uniformity Œ±).HasBasis p fun i => Set.preimage (Prod.map f f) (s i)","decl":"theorem IsUniformInducing.basis_uniformity {f : Œ± ‚Üí Œ≤} (hf : IsUniformInducing f) {Œπ : Sort*}\n    {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (H : (ùì§ Œ≤).HasBasis p s) :\n    (ùì§ Œ±).HasBasis p fun i => Prod.map f f ‚Åª¬π' s i :=\n  hf.1 ‚ñ∏ H.comap _\n\n"}
{"name":"UniformInducing.basis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nŒπ : Sort u_1\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ≤ Œ≤)\nH : (uniformity Œ≤).HasBasis p s\n‚ä¢ (uniformity Œ±).HasBasis p fun i => Set.preimage (Prod.map f f) (s i)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.basis_uniformity := IsUniformInducing.basis_uniformity\n\n"}
{"name":"IsUniformInducing.cauchy_map_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nF : Filter Œ±\n‚ä¢ Iff (Cauchy (Filter.map f F)) (Cauchy F)","decl":"theorem IsUniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : IsUniformInducing f) {F : Filter Œ±} :\n    Cauchy (map f F) ‚Üî Cauchy F := by\n  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_le_iff_le_comap, ‚Üê hf.comap_uniformity]\n\n"}
{"name":"UniformInducing.cauchy_map_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nF : Filter Œ±\n‚ä¢ Iff (Cauchy (Filter.map f F)) (Cauchy F)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.cauchy_map_iff := IsUniformInducing.cauchy_map_iff\n\n"}
{"name":"IsUniformInducing.of_comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhf : UniformContinuous f\nhg : UniformContinuous g\nhgf : IsUniformInducing (Function.comp g f)\n‚ä¢ IsUniformInducing f","decl":"theorem IsUniformInducing.of_comp {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) (hgf : IsUniformInducing (g ‚àò f)) : IsUniformInducing f := by\n  refine ‚ü®le_antisymm ?_ hf.le_comap‚ü©\n  rw [‚Üê hgf.1, ‚Üê Prod.map_def, ‚Üê Prod.map_def, ‚Üê Prod.map_comp_map f f g g, ‚Üê comap_comap]\n  exact comap_mono hg.le_comap\n\n"}
{"name":"uniformInducing_of_compose","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhf : UniformContinuous f\nhg : UniformContinuous g\nhgf : IsUniformInducing (Function.comp g f)\n‚ä¢ IsUniformInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_of_compose := IsUniformInducing.of_comp\n\n"}
{"name":"IsUniformInducing.uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ UniformContinuous f","decl":"theorem IsUniformInducing.uniformContinuous {f : Œ± ‚Üí Œ≤} (hf : IsUniformInducing f) :\n    UniformContinuous f := (isUniformInducing_iff'.1 hf).1\n\n"}
{"name":"UniformInducing.uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ UniformContinuous f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuous := IsUniformInducing.uniformContinuous\n\n"}
{"name":"IsUniformInducing.uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\n‚ä¢ Iff (UniformContinuous f) (UniformContinuous (Function.comp g f))","decl":"theorem IsUniformInducing.uniformContinuous_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : IsUniformInducing g) :\n    UniformContinuous f ‚Üî UniformContinuous (g ‚àò f) := by\n  dsimp only [UniformContinuous, Tendsto]\n  simp only [‚Üê hg.comap_uniformity, ‚Üê map_le_iff_le_comap, Filter.map_map, Function.comp_def]\n\n"}
{"name":"UniformInducing.uniformContinuous_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\n‚ä¢ Iff (UniformContinuous f) (UniformContinuous (Function.comp g f))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuous_iff := IsUniformInducing.uniformContinuous_iff\n\n"}
{"name":"IsUniformInducing.isUniformInducing_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\n‚ä¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"protected theorem IsUniformInducing.isUniformInducing_comp_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}\n    (hg : IsUniformInducing g) : IsUniformInducing (g ‚àò f) ‚Üî IsUniformInducing f := by\n  simp only [isUniformInducing_iff, ‚Üê hg.comap_uniformity, comap_comap, Function.comp_def]\n\n"}
{"name":"UniformInducing.uniformInducing_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformInducing g\n‚ä¢ Iff (IsUniformInducing (Function.comp g f)) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformInducing_comp_iff := IsUniformInducing.isUniformInducing_comp_iff\n\n"}
{"name":"IsUniformInducing.uniformContinuousOn_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nS : Set Œ±\nhg : IsUniformInducing g\n‚ä¢ Iff (UniformContinuousOn f S) (UniformContinuousOn (Function.comp g f) S)","decl":"theorem IsUniformInducing.uniformContinuousOn_iff {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} {S : Set Œ±}\n    (hg : IsUniformInducing g) :\n    UniformContinuousOn f S ‚Üî UniformContinuousOn (g ‚àò f) S := by\n  dsimp only [UniformContinuousOn, Tendsto]\n  rw [‚Üê hg.comap_uniformity, ‚Üê map_le_iff_le_comap, Filter.map_map, comp_def, comp_def]\n\n"}
{"name":"UniformInducing.uniformContinuousOn_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nS : Set Œ±\nhg : IsUniformInducing g\n‚ä¢ Iff (UniformContinuousOn f S) (UniformContinuousOn (Function.comp g f) S)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuousOn_iff := IsUniformInducing.uniformContinuousOn_iff\n\n"}
{"name":"IsUniformInducing.isInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Topology.IsInducing f","decl":"theorem IsUniformInducing.isInducing {f : Œ± ‚Üí Œ≤} (h : IsUniformInducing f) : IsInducing f := by\n  obtain rfl := h.comap_uniformSpace\n  exact .induced f\n\n"}
{"name":"IsUniformInducing.inducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")]\nalias IsUniformInducing.inducing := IsUniformInducing.isInducing\n\n"}
{"name":"UniformInducing.isInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isInducing := IsUniformInducing.isInducing\n\n"}
{"name":"UniformInducing.inducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias UniformInducing.inducing := UniformInducing.isInducing\n\n"}
{"name":"IsUniformInducing.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\nŒ±' : Type u_1\nŒ≤' : Type u_2\ninst‚úù¬π : UniformSpace Œ±'\ninst‚úù : UniformSpace Œ≤'\ne‚ÇÅ : Œ± ‚Üí Œ±'\ne‚ÇÇ : Œ≤ ‚Üí Œ≤'\nh‚ÇÅ : IsUniformInducing e‚ÇÅ\nh‚ÇÇ : IsUniformInducing e‚ÇÇ\n‚ä¢ IsUniformInducing fun p => { fst := e‚ÇÅ p.1, snd := e‚ÇÇ p.2 }","decl":"theorem IsUniformInducing.prod {Œ±' : Type*} {Œ≤' : Type*} [UniformSpace Œ±'] [UniformSpace Œ≤']\n    {e‚ÇÅ : Œ± ‚Üí Œ±'} {e‚ÇÇ : Œ≤ ‚Üí Œ≤'} (h‚ÇÅ : IsUniformInducing e‚ÇÅ) (h‚ÇÇ : IsUniformInducing e‚ÇÇ) :\n    IsUniformInducing fun p : Œ± √ó Œ≤ => (e‚ÇÅ p.1, e‚ÇÇ p.2) :=\n  ‚ü®by simp [Function.comp_def, uniformity_prod, ‚Üê h‚ÇÅ.1, ‚Üê h‚ÇÇ.1, comap_inf, comap_comap]‚ü©\n\n"}
{"name":"UniformInducing.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\nŒ±' : Type u_1\nŒ≤' : Type u_2\ninst‚úù¬π : UniformSpace Œ±'\ninst‚úù : UniformSpace Œ≤'\ne‚ÇÅ : Œ± ‚Üí Œ±'\ne‚ÇÇ : Œ≤ ‚Üí Œ≤'\nh‚ÇÅ : IsUniformInducing e‚ÇÅ\nh‚ÇÇ : IsUniformInducing e‚ÇÇ\n‚ä¢ IsUniformInducing fun p => { fst := e‚ÇÅ p.1, snd := e‚ÇÇ p.2 }","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.prod := IsUniformInducing.prod\n\n"}
{"name":"IsUniformInducing.isDenseInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\nhd : DenseRange f\n‚ä¢ IsDenseInducing f","decl":"lemma IsUniformInducing.isDenseInducing (h : IsUniformInducing f) (hd : DenseRange f) :\n    IsDenseInducing f where\n  toIsInducing := h.isInducing\n  dense := hd\n\n"}
{"name":"UniformInducing.isDenseInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\nhd : DenseRange f\n‚ä¢ IsDenseInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isDenseInducing := IsUniformInducing.isDenseInducing\n\n"}
{"name":"SeparationQuotient.isUniformInducing_mk","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ IsUniformInducing SeparationQuotient.mk","decl":"lemma SeparationQuotient.isUniformInducing_mk :\n    IsUniformInducing (mk : Œ± ‚Üí SeparationQuotient Œ±) :=\n  ‚ü®comap_mk_uniformity‚ü©\n\n"}
{"name":"SeparationQuotient.uniformInducing_mk","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ IsUniformInducing SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-05\")]\nalias SeparationQuotient.uniformInducing_mk := SeparationQuotient.isUniformInducing_mk\n\n"}
{"name":"IsUniformInducing.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Function.Injective f","decl":"protected theorem IsUniformInducing.injective [T0Space Œ±] {f : Œ± ‚Üí Œ≤} (h : IsUniformInducing f) :\n    Injective f :=\n  h.isInducing.injective\n\n"}
{"name":"UniformInducing.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\nh : IsUniformInducing f\n‚ä¢ Function.Injective f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.injective := IsUniformInducing.injective\n\n"}
{"name":"IsUniformEmbedding.injective","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nself : IsUniformEmbedding f\n‚ä¢ Function.Injective f","decl":"/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Œ±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Œ± ‚Üí Œ≤) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"IsUniformEmbedding.toIsUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nself : IsUniformEmbedding f\n‚ä¢ IsUniformInducing f","decl":"/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Œ±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Œ± ‚Üí Œ≤) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"isUniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (IsUniformInducing f) (Function.Injective f))","decl":"/-- A map `f : Œ± ‚Üí Œ≤` between uniform spaces is a *uniform embedding* if it is uniform inducing and\ninjective. If `Œ±` is a separated space, then the latter assumption follows from the former. -/\n@[mk_iff]\nstructure IsUniformEmbedding (f : Œ± ‚Üí Œ≤) extends IsUniformInducing f : Prop where\n  /-- A uniform embedding is injective. -/\n  injective : Function.Injective f\n\n"}
{"name":"IsUniformEmbedding.isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformEmbedding f\n‚ä¢ IsUniformInducing f","decl":"lemma IsUniformEmbedding.isUniformInducing (hf : IsUniformEmbedding f) : IsUniformInducing f :=\n  hf.toIsUniformInducing\n\n"}
{"name":"isUniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Œ≤)) (uniformity Œ±))))","decl":"theorem isUniformEmbedding_iff' {f : Œ± ‚Üí Œ≤} :\n    IsUniformEmbedding f ‚Üî\n      Injective f ‚àß UniformContinuous f ‚àß comap (Prod.map f f) (ùì§ Œ≤) ‚â§ ùì§ Œ± := by\n  rw [isUniformEmbedding_iff, and_comm, isUniformInducing_iff']\n\n"}
{"name":"uniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (LE.le (Filter.comap (Prod.map f f) (uniformity Œ≤)) (uniformity Œ±))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff' := isUniformEmbedding_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (‚àÄ (i : Œπ'), p' i ‚Üí Exists fun j => And (p j) (‚àÄ (x y : Œ±), Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (s' i) { fst := f x, snd := f y })) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y }))))","decl":"theorem Filter.HasBasis.isUniformEmbedding_iff' {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}\n    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :\n    IsUniformEmbedding f ‚Üî Injective f ‚àß\n      (‚àÄ i, p' i ‚Üí ‚àÉ j, p j ‚àß ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà s' i) ‚àß\n        (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by\n  rw [isUniformEmbedding_iff, and_comm, h.isUniformInducing_iff h']\n\n"}
{"name":"Filter.HasBasis.uniformEmbedding_iff'","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (‚àÄ (i : Œπ'), p' i ‚Üí Exists fun j => And (p j) (‚àÄ (x y : Œ±), Membership.mem (s j) { fst := x, snd := y } ‚Üí Membership.mem (s' i) { fst := f x, snd := f y })) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y }))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Filter.HasBasis.uniformEmbedding_iff' := Filter.HasBasis.isUniformEmbedding_iff'\n\n"}
{"name":"Filter.HasBasis.isUniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y }))))","decl":"theorem Filter.HasBasis.isUniformEmbedding_iff {Œπ Œπ'} {p : Œπ ‚Üí Prop} {p' : Œπ' ‚Üí Prop} {s s'}\n    (h : (ùì§ Œ±).HasBasis p s) (h' : (ùì§ Œ≤).HasBasis p' s') {f : Œ± ‚Üí Œ≤} :\n    IsUniformEmbedding f ‚Üî Injective f ‚àß UniformContinuous f ‚àß\n      (‚àÄ j, p j ‚Üí ‚àÉ i, p' i ‚àß ‚àÄ x y, (f x, f y) ‚àà s' i ‚Üí (x, y) ‚àà s j) := by\n  simp only [h.isUniformEmbedding_iff' h', h.uniformContinuous_iff h']\n\n"}
{"name":"Filter.HasBasis.uniformEmbedding_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Sort u_1\nŒπ' : Sort u_2\np : Œπ ‚Üí Prop\np' : Œπ' ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\ns' : Œπ' ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ±).HasBasis p s\nh' : (uniformity Œ≤).HasBasis p' s'\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (‚àÄ (j : Œπ), p j ‚Üí Exists fun i => And (p' i) (‚àÄ (x y : Œ±), Membership.mem (s' i) { fst := f x, snd := f y } ‚Üí Membership.mem (s j) { fst := x, snd := y }))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Filter.HasBasis.uniformEmbedding_iff := Filter.HasBasis.isUniformEmbedding_iff\n\n"}
{"name":"isUniformEmbedding_subtype_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\np : Œ± ‚Üí Prop\n‚ä¢ IsUniformEmbedding Subtype.val","decl":"theorem isUniformEmbedding_subtype_val {p : Œ± ‚Üí Prop} :\n    IsUniformEmbedding (Subtype.val : Subtype p ‚Üí Œ±) :=\n  { comap_uniformity := rfl\n    injective := Subtype.val_injective }\n\n"}
{"name":"uniformEmbedding_subtype_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\np : Œ± ‚Üí Prop\n‚ä¢ IsUniformEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_subtype_val := isUniformEmbedding_subtype_val\n\n"}
{"name":"isUniformEmbedding_set_inclusion","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\ns t : Set Œ±\nhst : HasSubset.Subset s t\n‚ä¢ IsUniformEmbedding (Set.inclusion hst)","decl":"theorem isUniformEmbedding_set_inclusion {s t : Set Œ±} (hst : s ‚äÜ t) :\n    IsUniformEmbedding (inclusion hst) where\n  comap_uniformity := by rw [uniformity_subtype, uniformity_subtype, comap_comap]; rfl\n  injective := inclusion_injective hst\n\n"}
{"name":"uniformEmbedding_set_inclusion","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\ns t : Set Œ±\nhst : HasSubset.Subset s t\n‚ä¢ IsUniformEmbedding (Set.inclusion hst)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_set_inclusion := isUniformEmbedding_set_inclusion\n\n"}
{"name":"IsUniformEmbedding.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformEmbedding g\nf : Œ± ‚Üí Œ≤\nhf : IsUniformEmbedding f\n‚ä¢ IsUniformEmbedding (Function.comp g f)","decl":"theorem IsUniformEmbedding.comp {g : Œ≤ ‚Üí Œ≥} (hg : IsUniformEmbedding g) {f : Œ± ‚Üí Œ≤}\n    (hf : IsUniformEmbedding f) : IsUniformEmbedding (g ‚àò f) where\n  toIsUniformInducing := hg.isUniformInducing.comp hf.isUniformInducing\n  injective := hg.injective.comp hf.injective\n\n"}
{"name":"UniformEmbedding.comp","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformEmbedding g\nf : Œ± ‚Üí Œ≤\nhf : IsUniformEmbedding f\n‚ä¢ IsUniformEmbedding (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.comp := IsUniformEmbedding.comp\n\n"}
{"name":"IsUniformEmbedding.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformEmbedding g\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding (Function.comp g f)) (IsUniformEmbedding f)","decl":"theorem IsUniformEmbedding.of_comp_iff {g : Œ≤ ‚Üí Œ≥} (hg : IsUniformEmbedding g) {f : Œ± ‚Üí Œ≤} :\n    IsUniformEmbedding (g ‚àò f) ‚Üî IsUniformEmbedding f := by\n  simp_rw [isUniformEmbedding_iff, hg.isUniformInducing.of_comp_iff, hg.injective.of_comp_iff f]\n\n"}
{"name":"UniformEmbedding.of_comp_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : IsUniformEmbedding g\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding (Function.comp g f)) (IsUniformEmbedding f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.of_comp_iff := IsUniformEmbedding.of_comp_iff\n\n"}
{"name":"Equiv.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Equiv Œ± Œ≤\nh‚ÇÅ : UniformContinuous ‚áëf\nh‚ÇÇ : UniformContinuous ‚áëf.symm\n‚ä¢ IsUniformEmbedding ‚áëf","decl":"theorem Equiv.isUniformEmbedding {Œ± Œ≤ : Type*} [UniformSpace Œ±] [UniformSpace Œ≤] (f : Œ± ‚âÉ Œ≤)\n    (h‚ÇÅ : UniformContinuous f) (h‚ÇÇ : UniformContinuous f.symm) : IsUniformEmbedding f :=\n  isUniformEmbedding_iff'.2 ‚ü®f.injective, h‚ÇÅ, by rwa [‚Üê Equiv.prodCongr_apply, ‚Üê map_equiv_symm]‚ü©\n\n"}
{"name":"Equiv.uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Equiv Œ± Œ≤\nh‚ÇÅ : UniformContinuous ‚áëf\nh‚ÇÇ : UniformContinuous ‚áëf.symm\n‚ä¢ IsUniformEmbedding ‚áëf","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Equiv.uniformEmbedding := Equiv.isUniformEmbedding\n\n"}
{"name":"isUniformEmbedding_inl","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding Sum.inl","decl":"theorem isUniformEmbedding_inl : IsUniformEmbedding (Sum.inl : Œ± ‚Üí Œ± ‚äï Œ≤) :=\n  isUniformEmbedding_iff'.2 ‚ü®Sum.inl_injective, uniformContinuous_inl, fun s hs =>\n    ‚ü®Prod.map Sum.inl Sum.inl '' s ‚à™ range (Prod.map Sum.inr Sum.inr),\n      union_mem_sup (image_mem_map hs) range_mem_map,\n      fun x h => by simpa [Prod.map_apply'] using h‚ü©‚ü©\n\n"}
{"name":"uniformEmbedding_inl","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_inl := isUniformEmbedding_inl\n\n"}
{"name":"isUniformEmbedding_inr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding Sum.inr","decl":"theorem isUniformEmbedding_inr : IsUniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=\n  isUniformEmbedding_iff'.2 ‚ü®Sum.inr_injective, uniformContinuous_inr, fun s hs =>\n    ‚ü®range (Prod.map Sum.inl Sum.inl) ‚à™ Prod.map Sum.inr Sum.inr '' s,\n      union_mem_sup range_mem_map (image_mem_map hs),\n      fun x h => by simpa [Prod.map_apply'] using h‚ü©‚ü©\n\n"}
{"name":"uniformEmbedding_inr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_inr := isUniformEmbedding_inr\n\n"}
{"name":"IsUniformInducing.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ IsUniformEmbedding f","decl":"/-- If the domain of a `IsUniformInducing` map `f` is a T‚ÇÄ space, then `f` is injective,\nhence it is a `IsUniformEmbedding`. -/\nprotected theorem IsUniformInducing.isUniformEmbedding [T0Space Œ±] {f : Œ± ‚Üí Œ≤}\n    (hf : IsUniformInducing f) : IsUniformEmbedding f :=\n  ‚ü®hf, hf.isInducing.injective‚ü©\n\n"}
{"name":"UniformInducing.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isUniformEmbedding := IsUniformInducing.isUniformEmbedding\n\n"}
{"name":"IsUniformInducing.uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias IsUniformInducing.uniformEmbedding := IsUniformInducing.isUniformEmbedding\n\n"}
{"name":"isUniformEmbedding_iff_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"theorem isUniformEmbedding_iff_isUniformInducing [T0Space Œ±] {f : Œ± ‚Üí Œ≤} :\n    IsUniformEmbedding f ‚Üî IsUniformInducing f :=\n  ‚ü®IsUniformEmbedding.isUniformInducing, IsUniformInducing.isUniformEmbedding‚ü©\n\n"}
{"name":"isUniformEmbedding_iff_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias isUniformEmbedding_iff_uniformInducing := isUniformEmbedding_iff_isUniformInducing\n\n"}
{"name":"uniformEmbedding_iff_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : T0Space Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsUniformEmbedding f) (IsUniformInducing f)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff_isUniformInducing := isUniformEmbedding_iff_isUniformInducing\n\n"}
{"name":"comap_uniformity_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ≤ : Type v\ninst‚úù : UniformSpace Œ≤\nŒ± : Type u_1\nf : Œ± ‚Üí Œ≤\ns : Set (Prod Œ≤ Œ≤)\nhs : Membership.mem (uniformity Œ≤) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\n‚ä¢ Eq (Filter.comap (Prod.map f f) (uniformity Œ≤)) (Filter.principal idRel)","decl":"/-- If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed\n`s ‚àà ùì§ Œ≤`, then `f` is uniform inducing with respect to the discrete uniformity on `Œ±`:\nthe preimage of `ùì§ Œ≤` under `Prod.map f f` is the principal filter generated by the diagonal in\n`Œ± √ó Œ±`. -/\ntheorem comap_uniformity_of_spaced_out {Œ±} {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)\n    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : comap (Prod.map f f) (ùì§ Œ≤) = ùìü idRel := by\n  refine le_antisymm ?_ (@refl_le_uniformity Œ± (UniformSpace.comap f _))\n  calc\n    comap (Prod.map f f) (ùì§ Œ≤) ‚â§ comap (Prod.map f f) (ùìü s) := comap_mono (le_principal_iff.2 hs)\n    _ = ùìü (Prod.map f f ‚Åª¬π' s) := comap_principal\n    _ ‚â§ ùìü idRel := principal_mono.2 ?_\n  rintro ‚ü®x, y‚ü©; simpa [not_imp_not] using @hf x y\n\n"}
{"name":"isUniformEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ≤ : Type v\ninst‚úù : UniformSpace Œ≤\nŒ± : Type u_1\nf : Œ± ‚Üí Œ≤\ns : Set (Prod Œ≤ Œ≤)\nhs : Membership.mem (uniformity Œ≤) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\n‚ä¢ IsUniformEmbedding f","decl":"/-- If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed\n`s ‚àà ùì§ Œ≤`, then `f` is a uniform embedding with respect to the discrete uniformity on `Œ±`. -/\ntheorem isUniformEmbedding_of_spaced_out {Œ±} {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)\n    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : @IsUniformEmbedding Œ± Œ≤ ‚ä• ‚Äπ_‚Ä∫ f := by\n  let _ : UniformSpace Œ± := ‚ä•; have := discreteTopology_bot Œ±\n  exact IsUniformInducing.isUniformEmbedding ‚ü®comap_uniformity_of_spaced_out hs hf‚ü©\n\n"}
{"name":"uniformEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ≤ : Type v\ninst‚úù : UniformSpace Œ≤\nŒ± : Type u_1\nf : Œ± ‚Üí Œ≤\ns : Set (Prod Œ≤ Œ≤)\nhs : Membership.mem (uniformity Œ≤) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_of_spaced_out := isUniformEmbedding_of_spaced_out\n\n"}
{"name":"IsUniformEmbedding.isEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\n‚ä¢ Topology.IsEmbedding f","decl":"protected lemma IsUniformEmbedding.isEmbedding {f : Œ± ‚Üí Œ≤} (h : IsUniformEmbedding f) :\n    IsEmbedding f where\n  toIsInducing := h.toIsUniformInducing.isInducing\n  injective := h.injective\n\n"}
{"name":"IsUniformEmbedding.embedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias IsUniformEmbedding.embedding := IsUniformEmbedding.isEmbedding\n\n"}
{"name":"UniformEmbedding.embedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.embedding := IsUniformEmbedding.isEmbedding\n\n"}
{"name":"IsUniformEmbedding.isDenseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\nhd : DenseRange f\n‚ä¢ IsDenseEmbedding f","decl":"theorem IsUniformEmbedding.isDenseEmbedding {f : Œ± ‚Üí Œ≤} (h : IsUniformEmbedding f)\n    (hd : DenseRange f) : IsDenseEmbedding f :=\n  { h.isEmbedding with dense := hd }\n\n"}
{"name":"UniformEmbedding.isDenseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\nhd : DenseRange f\n‚ä¢ IsDenseEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.isDenseEmbedding := IsUniformEmbedding.isDenseEmbedding\n\n"}
{"name":"IsUniformEmbedding.denseEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : IsUniformEmbedding f\nhd : DenseRange f\n‚ä¢ IsDenseEmbedding f","decl":"@[deprecated (since := \"2024-09-30\")]\nalias IsUniformEmbedding.denseEmbedding := IsUniformEmbedding.isDenseEmbedding\n\n"}
{"name":"isClosedEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ≤\nŒ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : DiscreteTopology Œ±\ninst‚úù : T0Space Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set (Prod Œ≤ Œ≤)\nhs : Membership.mem (uniformity Œ≤) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\n‚ä¢ Topology.IsClosedEmbedding f","decl":"theorem isClosedEmbedding_of_spaced_out {Œ±} [TopologicalSpace Œ±] [DiscreteTopology Œ±]\n    [T0Space Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà ùì§ Œ≤)\n    (hf : Pairwise fun x y => (f x, f y) ‚àâ s) : IsClosedEmbedding f := by\n  rcases @DiscreteTopology.eq_bot Œ± _ _ with rfl; let _ : UniformSpace Œ± := ‚ä•\n  exact\n    { (isUniformEmbedding_of_spaced_out hs hf).isEmbedding with\n      isClosed_range := isClosed_range_of_spaced_out hs hf }\n\n"}
{"name":"closedEmbedding_of_spaced_out","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ≤\nŒ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : DiscreteTopology Œ±\ninst‚úù : T0Space Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set (Prod Œ≤ Œ≤)\nhs : Membership.mem (uniformity Œ≤) s\nhf : Pairwise fun x y => Not (Membership.mem s { fst := f x, snd := f y })\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_of_spaced_out := isClosedEmbedding_of_spaced_out\n\n"}
{"name":"closure_image_mem_nhds_of_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\ns : Set (Prod Œ± Œ±)\ne : Œ± ‚Üí Œ≤\nb : Œ≤\nhe‚ÇÅ : IsUniformInducing e\nhe‚ÇÇ : IsDenseInducing e\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun a => Membership.mem (nhds b) (closure (Set.image e (setOf fun a' => Membership.mem s { fst := a, snd := a' })))","decl":"theorem closure_image_mem_nhds_of_isUniformInducing {s : Set (Œ± √ó Œ±)} {e : Œ± ‚Üí Œ≤} (b : Œ≤)\n    (he‚ÇÅ : IsUniformInducing e) (he‚ÇÇ : IsDenseInducing e) (hs : s ‚àà ùì§ Œ±) :\n    ‚àÉ a, closure (e '' { a' | (a, a') ‚àà s }) ‚àà ùìù b := by\n  obtain ‚ü®U, ‚ü®hU, hUo, hsymm‚ü©, hs‚ü© :\n    ‚àÉ U, (U ‚àà ùì§ Œ≤ ‚àß IsOpen U ‚àß SymmetricRel U) ‚àß Prod.map e e ‚Åª¬π' U ‚äÜ s := by\n      rwa [‚Üê he‚ÇÅ.comap_uniformity, (uniformity_hasBasis_open_symmetric.comap _).mem_iff] at hs\n  rcases he‚ÇÇ.dense.mem_nhds (UniformSpace.ball_mem_nhds b hU) with ‚ü®a, ha‚ü©\n  refine ‚ü®a, mem_of_superset ?_ (closure_mono <| image_subset _ <| UniformSpace.ball_mono hs a)‚ü©\n  have ho : IsOpen (UniformSpace.ball (e a) U) := UniformSpace.isOpen_ball (e a) hUo\n  refine mem_of_superset (ho.mem_nhds <| (UniformSpace.mem_ball_symmetry hsymm).2 ha) fun y hy => ?_\n  refine mem_closure_iff_nhds.2 fun V hV => ?_\n  rcases he‚ÇÇ.dense.mem_nhds (inter_mem hV (ho.mem_nhds hy)) with ‚ü®x, hxV, hxU‚ü©\n  exact ‚ü®e x, hxV, mem_image_of_mem e hxU‚ü©\n\n"}
{"name":"closure_image_mem_nhds_of_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\ns : Set (Prod Œ± Œ±)\ne : Œ± ‚Üí Œ≤\nb : Œ≤\nhe‚ÇÅ : IsUniformInducing e\nhe‚ÇÇ : IsDenseInducing e\nhs : Membership.mem (uniformity Œ±) s\n‚ä¢ Exists fun a => Membership.mem (nhds b) (closure (Set.image e (setOf fun a' => Membership.mem s { fst := a, snd := a' })))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias closure_image_mem_nhds_of_uniformInducing := closure_image_mem_nhds_of_isUniformInducing\n\n"}
{"name":"isUniformEmbedding_subtypeEmb","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\np : Œ± ‚Üí Prop\ne : Œ± ‚Üí Œ≤\nue : IsUniformEmbedding e\nde : IsDenseEmbedding e\n‚ä¢ IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"theorem isUniformEmbedding_subtypeEmb (p : Œ± ‚Üí Prop) {e : Œ± ‚Üí Œ≤} (ue : IsUniformEmbedding e)\n    (de : IsDenseEmbedding e) : IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e) :=\n  { comap_uniformity := by\n      simp [comap_comap, Function.comp_def, IsDenseEmbedding.subtypeEmb, uniformity_subtype,\n        ue.comap_uniformity.symm]\n    injective := (de.subtype p).injective }\n\n"}
{"name":"uniformEmbedding_subtypeEmb","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\np : Œ± ‚Üí Prop\ne : Œ± ‚Üí Œ≤\nue : IsUniformEmbedding e\nde : IsDenseEmbedding e\n‚ä¢ IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_subtypeEmb := isUniformEmbedding_subtypeEmb\n\n"}
{"name":"IsUniformEmbedding.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\nŒ±' : Type u_1\nŒ≤' : Type u_2\ninst‚úù¬π : UniformSpace Œ±'\ninst‚úù : UniformSpace Œ≤'\ne‚ÇÅ : Œ± ‚Üí Œ±'\ne‚ÇÇ : Œ≤ ‚Üí Œ≤'\nh‚ÇÅ : IsUniformEmbedding e‚ÇÅ\nh‚ÇÇ : IsUniformEmbedding e‚ÇÇ\n‚ä¢ IsUniformEmbedding fun p => { fst := e‚ÇÅ p.1, snd := e‚ÇÇ p.2 }","decl":"theorem IsUniformEmbedding.prod {Œ±' : Type*} {Œ≤' : Type*} [UniformSpace Œ±'] [UniformSpace Œ≤']\n    {e‚ÇÅ : Œ± ‚Üí Œ±'} {e‚ÇÇ : Œ≤ ‚Üí Œ≤'} (h‚ÇÅ : IsUniformEmbedding e‚ÇÅ) (h‚ÇÇ : IsUniformEmbedding e‚ÇÇ) :\n    IsUniformEmbedding fun p : Œ± √ó Œ≤ => (e‚ÇÅ p.1, e‚ÇÇ p.2) where\n  toIsUniformInducing := h‚ÇÅ.isUniformInducing.prod h‚ÇÇ.isUniformInducing\n  injective := h‚ÇÅ.injective.prodMap h‚ÇÇ.injective\n\n"}
{"name":"UniformEmbedding.prod","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\nŒ±' : Type u_1\nŒ≤' : Type u_2\ninst‚úù¬π : UniformSpace Œ±'\ninst‚úù : UniformSpace Œ≤'\ne‚ÇÅ : Œ± ‚Üí Œ±'\ne‚ÇÇ : Œ≤ ‚Üí Œ≤'\nh‚ÇÅ : IsUniformEmbedding e‚ÇÅ\nh‚ÇÇ : IsUniformEmbedding e‚ÇÇ\n‚ä¢ IsUniformEmbedding fun p => { fst := e‚ÇÅ p.1, snd := e‚ÇÇ p.2 }","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.prod := IsUniformEmbedding.prod\n\n"}
{"name":"isComplete_image_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nm : Œ± ‚Üí Œ≤\ns : Set Œ±\nhm : IsUniformInducing m\n‚ä¢ Iff (IsComplete (Set.image m s)) (IsComplete s)","decl":"/-- A set is complete iff its image under a uniform inducing map is complete. -/\ntheorem isComplete_image_iff {m : Œ± ‚Üí Œ≤} {s : Set Œ±} (hm : IsUniformInducing m) :\n    IsComplete (m '' s) ‚Üî IsComplete s := by\n  have fact1 : SurjOn (map m) (Iic <| ùìü s) (Iic <| ùìü <| m '' s) := surjOn_image .. |>.filter_map_Iic\n  have fact2 : MapsTo (map m) (Iic <| ùìü s) (Iic <| ùìü <| m '' s) := mapsTo_image .. |>.filter_map_Iic\n  simp_rw [IsComplete, imp.swap (a := Cauchy _), ‚Üê mem_Iic (b := ùìü _), fact1.forall fact2,\n    hm.cauchy_map_iff, exists_mem_image, map_le_iff_le_comap, hm.isInducing.nhds_eq_comap]\n\n"}
{"name":"IsUniformInducing.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : IsUniformInducing f\n‚ä¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"/-- If `f : X ‚Üí Y` is an `IsUniformInducing` map, the image `f '' s` of a set `s` is complete\n  if and only if `s` is complete. -/\ntheorem IsUniformInducing.isComplete_iff {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (hf : IsUniformInducing f) :\n    IsComplete (f '' s) ‚Üî IsComplete s := isComplete_image_iff hf\n\n"}
{"name":"UniformInducing.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : IsUniformInducing f\n‚ä¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isComplete_iff := IsUniformInducing.isComplete_iff\n\n"}
{"name":"IsUniformEmbedding.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : IsUniformEmbedding f\n‚ä¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"/-- If `f : X ‚Üí Y` is an `IsUniformEmbedding`, the image `f '' s` of a set `s` is complete\n  if and only if `s` is complete. -/\ntheorem IsUniformEmbedding.isComplete_iff {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (hf : IsUniformEmbedding f) :\n    IsComplete (f '' s) ‚Üî IsComplete s := hf.isUniformInducing.isComplete_iff\n\n"}
{"name":"UniformEmbedding.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : IsUniformEmbedding f\n‚ä¢ Iff (IsComplete (Set.image f s)) (IsComplete s)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias UniformEmbedding.isComplete_iff := IsUniformEmbedding.isComplete_iff\n\n"}
{"name":"Subtype.isComplete_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\np : Œ± ‚Üí Prop\ns : Set (Subtype fun x => p x)\n‚ä¢ Iff (IsComplete s) (IsComplete (Set.image Subtype.val s))","decl":"/-- Sets of a subtype are complete iff their image under the coercion is complete. -/\ntheorem Subtype.isComplete_iff {p : Œ± ‚Üí Prop} {s : Set { x // p x }} :\n    IsComplete s ‚Üî IsComplete ((‚Üë) '' s : Set Œ±) :=\n  isUniformEmbedding_subtype_val.isComplete_iff.symm\n\n"}
{"name":"isComplete_of_complete_image","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nm : Œ± ‚Üí Œ≤\ns : Set Œ±\nhm : IsUniformInducing m\na‚úù : IsComplete (Set.image m s)\n‚ä¢ IsComplete s","decl":"alias ‚ü®isComplete_of_complete_image, _‚ü© := isComplete_image_iff\n\n"}
{"name":"completeSpace_iff_isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\n‚ä¢ Iff (CompleteSpace Œ±) (IsComplete (Set.range f))","decl":"theorem completeSpace_iff_isComplete_range {f : Œ± ‚Üí Œ≤} (hf : IsUniformInducing f) :\n    CompleteSpace Œ± ‚Üî IsComplete (range f) := by\n  rw [completeSpace_iff_isComplete_univ, ‚Üê isComplete_image_iff hf, image_univ]\n\n"}
{"name":"IsUniformInducing.completeSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\na‚úù : IsComplete (Set.range f)\n‚ä¢ CompleteSpace Œ±","decl":"alias ‚ü®_, IsUniformInducing.completeSpace‚ü© := completeSpace_iff_isComplete_range\n\n"}
{"name":"UniformInducing.completeSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\na‚úù : IsComplete (Set.range f)\n‚ä¢ CompleteSpace Œ±","decl":"@[deprecated (since := \"2024-10-08\")] alias UniformInducing.completeSpace :=\n  IsUniformInducing.completeSpace\n\n"}
{"name":"IsUniformInducing.isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ±\nhf : IsUniformInducing f\n‚ä¢ IsComplete (Set.range f)","decl":"lemma IsUniformInducing.isComplete_range [CompleteSpace Œ±] (hf : IsUniformInducing f) :\n    IsComplete (range f) :=\n  (completeSpace_iff_isComplete_range hf).1 ‚Äπ_‚Ä∫\n\n"}
{"name":"UniformInducing.isComplete_range","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ±\nhf : IsUniformInducing f\n‚ä¢ IsComplete (Set.range f)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.isComplete_range := IsUniformInducing.isComplete_range\n\n"}
{"name":"IsUniformInducing.completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nhsurj : Function.Surjective f\n‚ä¢ Iff (CompleteSpace Œ±) (CompleteSpace Œ≤)","decl":"/-- If `f` is a surjective uniform inducing map,\nthen its domain is a complete space iff its codomain is a complete space.\nSee also `_root_.completeSpace_congr` for a version that assumes `f` to be an equivalence. -/\ntheorem IsUniformInducing.completeSpace_congr {f : Œ± ‚Üí Œ≤} (hf : IsUniformInducing f)\n    (hsurj : f.Surjective) : CompleteSpace Œ± ‚Üî CompleteSpace Œ≤ := by\n  rw [completeSpace_iff_isComplete_range hf, hsurj.range_eq, completeSpace_iff_isComplete_univ]\n\n"}
{"name":"UniformInducing.completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : IsUniformInducing f\nhsurj : Function.Surjective f\n‚ä¢ Iff (CompleteSpace Œ±) (CompleteSpace Œ≤)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.completeSpace_congr := IsUniformInducing.completeSpace_congr\n\n"}
{"name":"SeparationQuotient.completeSpace_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Iff (CompleteSpace (SeparationQuotient Œ±)) (CompleteSpace Œ±)","decl":"theorem SeparationQuotient.completeSpace_iff :\n    CompleteSpace (SeparationQuotient Œ±) ‚Üî CompleteSpace Œ± :=\n  .symm <| isUniformInducing_mk.completeSpace_congr surjective_mk\n\n"}
{"name":"SeparationQuotient.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : CompleteSpace Œ±\n‚ä¢ CompleteSpace (SeparationQuotient Œ±)","decl":"instance SeparationQuotient.instCompleteSpace [CompleteSpace Œ±] :\n    CompleteSpace (SeparationQuotient Œ±) :=\n  completeSpace_iff.2 ‚Äπ_‚Ä∫\n\n"}
{"name":"completeSpace_congr","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\ne : Equiv Œ± Œ≤\nhe : IsUniformEmbedding ‚áëe\n‚ä¢ Iff (CompleteSpace Œ±) (CompleteSpace Œ≤)","decl":"/-- See also `IsUniformInducing.completeSpace_congr`\nfor a version that works for non-injective maps. -/\ntheorem completeSpace_congr {e : Œ± ‚âÉ Œ≤} (he : IsUniformEmbedding e) :\n    CompleteSpace Œ± ‚Üî CompleteSpace Œ≤ :=\n  he.completeSpace_congr e.surjective\n\n"}
{"name":"completeSpace_coe_iff_isComplete","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (CompleteSpace ‚Üës) (IsComplete s)","decl":"theorem completeSpace_coe_iff_isComplete {s : Set Œ±} : CompleteSpace s ‚Üî IsComplete s := by\n  rw [completeSpace_iff_isComplete_range isUniformEmbedding_subtype_val.isUniformInducing,\n    Subtype.range_coe]\n\n"}
{"name":"IsComplete.completeSpace_coe","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\na‚úù : IsComplete s\n‚ä¢ CompleteSpace ‚Üës","decl":"alias ‚ü®_, IsComplete.completeSpace_coe‚ü© := completeSpace_coe_iff_isComplete\n\n"}
{"name":"IsClosed.completeSpace_coe","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : CompleteSpace Œ±\ns : Set Œ±\nhs : IsClosed s\n‚ä¢ CompleteSpace ‚Üës","decl":"theorem IsClosed.completeSpace_coe [CompleteSpace Œ±] {s : Set Œ±} (hs : IsClosed s) :\n    CompleteSpace s :=\n  hs.isComplete.completeSpace_coe\n\n"}
{"name":"completeSpace_ulift_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù : UniformSpace Œ±\n‚ä¢ Iff (CompleteSpace (ULift.{u_1, u} Œ±)) (CompleteSpace Œ±)","decl":"theorem completeSpace_ulift_iff : CompleteSpace (ULift Œ±) ‚Üî CompleteSpace Œ± :=\n  IsUniformInducing.completeSpace_congr ‚ü®rfl‚ü© ULift.down_surjective\n\n"}
{"name":"ULift.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : CompleteSpace Œ±\n‚ä¢ CompleteSpace (ULift.{u_1, u} Œ±)","decl":"/-- The lift of a complete space to another universe is still complete. -/\ninstance ULift.instCompleteSpace [CompleteSpace Œ±] : CompleteSpace (ULift Œ±) :=\n  completeSpace_ulift_iff.2 ‚Äπ_‚Ä∫\n\n"}
{"name":"completeSpace_extension","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nm : Œ≤ ‚Üí Œ±\nhm : IsUniformInducing m\ndense : DenseRange m\nh : ‚àÄ (f : Filter Œ≤), Cauchy f ‚Üí Exists fun x => LE.le (Filter.map m f) (nhds x)\n‚ä¢ CompleteSpace Œ±","decl":"theorem completeSpace_extension {m : Œ≤ ‚Üí Œ±} (hm : IsUniformInducing m) (dense : DenseRange m)\n    (h : ‚àÄ f : Filter Œ≤, Cauchy f ‚Üí ‚àÉ x : Œ±, map m f ‚â§ ùìù x) : CompleteSpace Œ± :=\n  ‚ü®fun {f : Filter Œ±} (hf : Cauchy f) =>\n    let p : Set (Œ± √ó Œ±) ‚Üí Set Œ± ‚Üí Set Œ± := fun s t => { y : Œ± | ‚àÉ x : Œ±, x ‚àà t ‚àß (x, y) ‚àà s }\n    let g := (ùì§ Œ±).lift fun s => f.lift' (p s)\n    have mp‚ÇÄ : Monotone p := fun _ _ h _ _ ‚ü®x, xs, xa‚ü© => ‚ü®x, xs, h xa‚ü©\n    have mp‚ÇÅ : ‚àÄ {s}, Monotone (p s) := fun h _ ‚ü®y, ya, yxs‚ü© => ‚ü®y, h ya, yxs‚ü©\n    have : f ‚â§ g := le_iInf‚ÇÇ fun _ hs => le_iInf‚ÇÇ fun _ ht =>\n      le_principal_iff.mpr <| mem_of_superset ht fun x hx => ‚ü®x, hx, refl_mem_uniformity hs‚ü©\n    have : NeBot g := hf.left.mono this\n    have : NeBot (comap m g) :=\n      comap_neBot fun _ ht =>\n        let ‚ü®t', ht', ht_mem‚ü© := (mem_lift_sets <| monotone_lift' monotone_const mp‚ÇÄ).mp ht\n        let ‚ü®_, ht'', ht'_sub‚ü© := (mem_lift'_sets mp‚ÇÅ).mp ht_mem\n        let ‚ü®x, hx‚ü© := hf.left.nonempty_of_mem ht''\n        have h‚ÇÄ : NeBot (ùìù[range m] x) := dense.nhdsWithin_neBot x\n        have h‚ÇÅ : { y | (x, y) ‚àà t' } ‚àà ùìù[range m] x :=\n          @mem_inf_of_left Œ± (ùìù x) (ùìü (range m)) _ <| mem_nhds_left x ht'\n        have h‚ÇÇ : range m ‚àà ùìù[range m] x :=\n          @mem_inf_of_right Œ± (ùìù x) (ùìü (range m)) _ <| Subset.refl _\n        have : { y | (x, y) ‚àà t' } ‚à© range m ‚àà ùìù[range m] x := @inter_mem Œ± (ùìù[range m] x) _ _ h‚ÇÅ h‚ÇÇ\n        let ‚ü®_, xyt', b, b_eq‚ü© := h‚ÇÄ.nonempty_of_mem this\n        ‚ü®b, b_eq.symm ‚ñ∏ ht'_sub ‚ü®x, hx, xyt'‚ü©‚ü©\n    have : Cauchy g :=\n      ‚ü®‚ÄπNeBot g‚Ä∫, fun _ hs =>\n        let ‚ü®s‚ÇÅ, hs‚ÇÅ, comp_s‚ÇÅ‚ü© := comp_mem_uniformity_sets hs\n        let ‚ü®s‚ÇÇ, hs‚ÇÇ, comp_s‚ÇÇ‚ü© := comp_mem_uniformity_sets hs‚ÇÅ\n        let ‚ü®t, ht, (prod_t : t √óÀ¢ t ‚äÜ s‚ÇÇ)‚ü© := mem_prod_same_iff.mp (hf.right hs‚ÇÇ)\n        have hg‚ÇÅ : p (preimage Prod.swap s‚ÇÅ) t ‚àà g :=\n          mem_lift (symm_le_uniformity hs‚ÇÅ) <| @mem_lift' Œ± Œ± f _ t ht\n        have hg‚ÇÇ : p s‚ÇÇ t ‚àà g := mem_lift hs‚ÇÇ <| @mem_lift' Œ± Œ± f _ t ht\n        have hg : p (Prod.swap ‚Åª¬π' s‚ÇÅ) t √óÀ¢ p s‚ÇÇ t ‚àà g √óÀ¢ g := @prod_mem_prod Œ± Œ± _ _ g g hg‚ÇÅ hg‚ÇÇ\n        (g √óÀ¢ g).sets_of_superset hg fun ‚ü®_, _‚ü© ‚ü®‚ü®c‚ÇÅ, c‚ÇÅt, hc‚ÇÅ‚ü©, ‚ü®c‚ÇÇ, c‚ÇÇt, hc‚ÇÇ‚ü©‚ü© =>\n          have : (c‚ÇÅ, c‚ÇÇ) ‚àà t √óÀ¢ t := ‚ü®c‚ÇÅt, c‚ÇÇt‚ü©\n          comp_s‚ÇÅ <| prod_mk_mem_compRel hc‚ÇÅ <| comp_s‚ÇÇ <| prod_mk_mem_compRel (prod_t this) hc‚ÇÇ‚ü©\n    have : Cauchy (Filter.comap m g) := ‚ÄπCauchy g‚Ä∫.comap' (le_of_eq hm.comap_uniformity) ‚Äπ_‚Ä∫\n    let ‚ü®x, (hx : map m (Filter.comap m g) ‚â§ ùìù x)‚ü© := h _ this\n    have : ClusterPt x (map m (Filter.comap m g)) :=\n      (le_nhds_iff_adhp_of_cauchy (this.map hm.uniformContinuous)).mp hx\n    have : ClusterPt x g := this.mono map_comap_le\n    ‚ü®x,\n      calc\n        f ‚â§ g := by assumption\n        _ ‚â§ ùìù x := le_nhds_of_cauchy_adhp ‚ÄπCauchy g‚Ä∫ this\n        ‚ü©‚ü©\n\n"}
{"name":"totallyBounded_image_iff","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : IsUniformInducing f\n‚ä¢ Iff (TotallyBounded (Set.image f s)) (TotallyBounded s)","decl":"lemma totallyBounded_image_iff {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (hf : IsUniformInducing f) :\n    TotallyBounded (f '' s) ‚Üî TotallyBounded s := by\n  refine ‚ü®fun hs ‚Ü¶ ?_, fun h ‚Ü¶ h.image hf.uniformContinuous‚ü©\n  simp_rw [(hf.basis_uniformity (basis_sets _)).totallyBounded_iff]\n  intro t ht\n  rcases exists_subset_image_finite_and.1 (hs.exists_subset ht) with ‚ü®u, -, hfin, h‚ü©\n  use u, hfin\n  rwa [biUnion_image, image_subset_iff, preimage_iUnion‚ÇÇ] at h\n\n"}
{"name":"totallyBounded_preimage","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nhf : IsUniformInducing f\nhs : TotallyBounded s\n‚ä¢ TotallyBounded (Set.preimage f s)","decl":"theorem totallyBounded_preimage {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} (hf : IsUniformInducing f)\n    (hs : TotallyBounded s) : TotallyBounded (f ‚Åª¬π' s) :=\n  (totallyBounded_image_iff hf).1 <| hs.subset <| image_preimage_subset ..\n\n"}
{"name":"CompleteSpace.sum","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : CompleteSpace Œ±\ninst‚úù : CompleteSpace Œ≤\n‚ä¢ CompleteSpace (Sum Œ± Œ≤)","decl":"instance CompleteSpace.sum [CompleteSpace Œ±] [CompleteSpace Œ≤] : CompleteSpace (Œ± ‚äï Œ≤) := by\n  rw [completeSpace_iff_isComplete_univ, ‚Üê range_inl_union_range_inr]\n  exact isUniformEmbedding_inl.isUniformInducing.isComplete_range.union\n    isUniformEmbedding_inr.isUniformInducing.isComplete_range\n\n"}
{"name":"isUniformEmbedding_comap","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\nu : UniformSpace Œ≤\nhf : Function.Injective f\n‚ä¢ IsUniformEmbedding f","decl":"theorem isUniformEmbedding_comap {Œ± : Type*} {Œ≤ : Type*} {f : Œ± ‚Üí Œ≤} [u : UniformSpace Œ≤]\n    (hf : Function.Injective f) : @IsUniformEmbedding Œ± Œ≤ (UniformSpace.comap f u) u f :=\n  @IsUniformEmbedding.mk _ _ (UniformSpace.comap f u) _ _\n    (@IsUniformInducing.mk _ _ (UniformSpace.comap f u) _ _ rfl) hf\n\n"}
{"name":"uniformEmbedding_comap","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí Œ≤\nu : UniformSpace Œ≤\nhf : Function.Injective f\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_comap := isUniformEmbedding_comap\n\n"}
{"name":"Embedding.to_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ±\nu : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : Topology.IsEmbedding f\n‚ä¢ IsUniformEmbedding f","decl":"theorem Embedding.to_isUniformEmbedding {Œ± Œ≤} [TopologicalSpace Œ±] [u : UniformSpace Œ≤] (f : Œ± ‚Üí Œ≤)\n    (h : IsEmbedding f) : @IsUniformEmbedding Œ± Œ≤ (h.comapUniformSpace f) u f :=\n  let _ := h.comapUniformSpace f\n  { comap_uniformity := rfl\n    injective := h.injective }\n\n"}
{"name":"Embedding.to_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ±\nu : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : Topology.IsEmbedding f\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias Embedding.to_uniformEmbedding := Embedding.to_isUniformEmbedding\n\n"}
{"name":"uniformly_extend_exists","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ne : Œ≤ ‚Üí Œ±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Œ≤ ‚Üí Œ≥\nh_f : UniformContinuous f\ninst‚úù : CompleteSpace Œ≥\na : Œ±\n‚ä¢ Exists fun c => Filter.Tendsto f (Filter.comap e (nhds a)) (nhds c)","decl":"include h_e h_dense h_f in\ntheorem uniformly_extend_exists [CompleteSpace Œ≥] (a : Œ±) : ‚àÉ c, Tendsto f (comap e (ùìù a)) (ùìù c) :=\n  let de := h_e.isDenseInducing h_dense\n  have : Cauchy (ùìù a) := cauchy_nhds\n  have : Cauchy (comap e (ùìù a)) :=\n    this.comap' (le_of_eq h_e.comap_uniformity) (de.comap_nhds_neBot _)\n  have : Cauchy (map f (comap e (ùìù a))) := this.map h_f\n  CompleteSpace.complete this\n\n"}
{"name":"uniform_extend_subtype","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ninst‚úù : CompleteSpace Œ≥\np : Œ± ‚Üí Prop\ne : Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≥\nb : Œ≤\ns : Set Œ±\nhf : UniformContinuous fun x => f ‚Üëx\nhe : IsUniformEmbedding e\nhd : ‚àÄ (x : Œ≤), Membership.mem (closure (Set.range e)) x\nhb : Membership.mem (nhds b) (closure (Set.image e s))\nhs : IsClosed s\nhp : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí p x\n‚ä¢ Exists fun c => Filter.Tendsto f (Filter.comap e (nhds b)) (nhds c)","decl":"theorem uniform_extend_subtype [CompleteSpace Œ≥] {p : Œ± ‚Üí Prop} {e : Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≥} {b : Œ≤}\n    {s : Set Œ±} (hf : UniformContinuous fun x : Subtype p => f x.val) (he : IsUniformEmbedding e)\n    (hd : ‚àÄ x : Œ≤, x ‚àà closure (range e)) (hb : closure (e '' s) ‚àà ùìù b) (hs : IsClosed s)\n    (hp : ‚àÄ x ‚àà s, p x) : ‚àÉ c, Tendsto f (comap e (ùìù b)) (ùìù c) := by\n  have de : IsDenseEmbedding e := he.isDenseEmbedding hd\n  have de' : IsDenseEmbedding (IsDenseEmbedding.subtypeEmb p e) := de.subtype p\n  have ue' : IsUniformEmbedding (IsDenseEmbedding.subtypeEmb p e) :=\n    isUniformEmbedding_subtypeEmb _ he de\n  have : b ‚àà closure (e '' { x | p x }) :=\n    (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)\n  let ‚ü®c, hc‚ü© := uniformly_extend_exists ue'.isUniformInducing de'.dense hf ‚ü®b, this‚ü©\n  replace hc : Tendsto (f ‚àò Subtype.val (p := p)) (((ùìù b).comap e).comap Subtype.val) (ùìù c) := by\n    simpa only [nhds_subtype_eq_comap, comap_comap, IsDenseEmbedding.subtypeEmb_coe] using hc\n  refine ‚ü®c, (tendsto_comap'_iff ?_).1 hc‚ü©\n  rw [Subtype.range_coe_subtype]\n  exact ‚ü®_, hb, by rwa [‚Üê de.isInducing.closure_eq_preimage_closure_image, hs.closure_eq]‚ü©\n\n"}
{"name":"uniformly_extend_spec","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ne : Œ≤ ‚Üí Œ±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Œ≤ ‚Üí Œ≥\nh_f : UniformContinuous f\ninst‚úù : CompleteSpace Œ≥\na : Œ±\n‚ä¢ Filter.Tendsto f (Filter.comap e (nhds a)) (nhds (‚ãØ.extend f a))","decl":"include h_e h_f in\ntheorem uniformly_extend_spec [CompleteSpace Œ≥] (a : Œ±) : Tendsto f (comap e (ùìù a)) (ùìù (œà a)) := by\n  simpa only [IsDenseInducing.extend] using\n    tendsto_nhds_limUnder (uniformly_extend_exists h_e ‚Äπ_‚Ä∫ h_f _)\n\n"}
{"name":"uniformContinuous_uniformly_extend","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ne : Œ≤ ‚Üí Œ±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Œ≤ ‚Üí Œ≥\nh_f : UniformContinuous f\ninst‚úù : CompleteSpace Œ≥\n‚ä¢ UniformContinuous (‚ãØ.extend f)","decl":"include h_f in\ntheorem uniformContinuous_uniformly_extend [CompleteSpace Œ≥] : UniformContinuous œà := fun d hd =>\n  let ‚ü®s, hs, hs_comp‚ü© := comp3_mem_uniformity hd\n  have h_pnt : ‚àÄ {a m}, m ‚àà ùìù a ‚Üí ‚àÉ c ‚àà f '' (e ‚Åª¬π' m), (c, œà a) ‚àà s ‚àß (œà a, c) ‚àà s :=\n    fun {a m} hm =>\n    have nb : NeBot (map f (comap e (ùìù a))) :=\n      ((h_e.isDenseInducing h_dense).comap_nhds_neBot _).map _\n    have :\n      f '' (e ‚Åª¬π' m) ‚à© ({ c | (c, œà a) ‚àà s } ‚à© { c | (œà a, c) ‚àà s }) ‚àà map f (comap e (ùìù a)) :=\n      inter_mem (image_mem_map <| preimage_mem_comap <| hm)\n        (uniformly_extend_spec h_e h_dense h_f _\n          (inter_mem (mem_nhds_right _ hs) (mem_nhds_left _ hs)))\n    nb.nonempty_of_mem this\n  have : (Prod.map f f) ‚Åª¬π' s ‚àà ùì§ Œ≤ := h_f hs\n  have : (Prod.map f f) ‚Åª¬π' s ‚àà comap (Prod.map e e) (ùì§ Œ±) := by\n    rwa [‚Üê h_e.comap_uniformity] at this\n  let ‚ü®t, ht, ts‚ü© := this\n  show (Prod.map œà œà) ‚Åª¬π' d ‚àà ùì§ Œ± from\n    mem_of_superset (interior_mem_uniformity ht) fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© hx_t => by\n      have : interior t ‚àà ùìù (x‚ÇÅ, x‚ÇÇ) := isOpen_interior.mem_nhds hx_t\n      let ‚ü®m‚ÇÅ, hm‚ÇÅ, m‚ÇÇ, hm‚ÇÇ, (hm : m‚ÇÅ √óÀ¢ m‚ÇÇ ‚äÜ interior t)‚ü© := mem_nhds_prod_iff.mp this\n      obtain ‚ü®_, ‚ü®a, ha‚ÇÅ, rfl‚ü©, _, ha‚ÇÇ‚ü© := h_pnt hm‚ÇÅ\n      obtain ‚ü®_, ‚ü®b, hb‚ÇÅ, rfl‚ü©, hb‚ÇÇ, _‚ü© := h_pnt hm‚ÇÇ\n      have : Prod.map f f (a, b) ‚àà s :=\n        ts <| mem_preimage.2 <| interior_subset (@hm (e a, e b) ‚ü®ha‚ÇÅ, hb‚ÇÅ‚ü©)\n      exact hs_comp ‚ü®f a, ha‚ÇÇ, ‚ü®f b, this, hb‚ÇÇ‚ü©‚ü©\n\n"}
{"name":"uniformly_extend_of_ind","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ne : Œ≤ ‚Üí Œ±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Œ≤ ‚Üí Œ≥\nh_f : UniformContinuous f\ninst‚úù : T0Space Œ≥\nb : Œ≤\n‚ä¢ Eq (‚ãØ.extend f (e b)) (f b)","decl":"include h_f in\ntheorem uniformly_extend_of_ind (b : Œ≤) : œà (e b) = f b :=\n  IsDenseInducing.extend_eq_at _ h_f.continuous.continuousAt\n\n"}
{"name":"uniformly_extend_unique","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ≥\ne : Œ≤ ‚Üí Œ±\nh_e : IsUniformInducing e\nh_dense : DenseRange e\nf : Œ≤ ‚Üí Œ≥\ninst‚úù : T0Space Œ≥\ng : Œ± ‚Üí Œ≥\nhg : ‚àÄ (b : Œ≤), Eq (g (e b)) (f b)\nhc : Continuous g\n‚ä¢ Eq (‚ãØ.extend f) g","decl":"theorem uniformly_extend_unique {g : Œ± ‚Üí Œ≥} (hg : ‚àÄ b, g (e b) = f b) (hc : Continuous g) : œà = g :=\n  IsDenseInducing.extend_unique _ hg hc\n\n"}
{"name":"isUniformInducing_val","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\ninst‚úù : UniformSpace Œ±\ns : Set Œ±\n‚ä¢ IsUniformInducing Subtype.val","decl":"theorem isUniformInducing_val (s : Set Œ±) :\n    IsUniformInducing (@Subtype.val Œ± s) := ‚ü®uniformity_setCoe‚ü©\n\n"}
{"name":"Dense.extend_exists","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ns : Set Œ±\nf : ‚Üës ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ≤\nhs : Dense s\nhf : UniformContinuous f\na : Œ±\n‚ä¢ Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)","decl":"theorem extend_exists [CompleteSpace Œ≤] (hs : Dense s) (hf : UniformContinuous f) (a : Œ±) :\n    ‚àÉ b, Tendsto f (comap (‚Üë) (ùìù a)) (ùìù b) :=\n  uniformly_extend_exists (isUniformInducing_val s) hs.denseRange_val hf a\n\n"}
{"name":"Dense.extend_spec","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ns : Set Œ±\nf : ‚Üës ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ≤\nhs : Dense s\nhf : UniformContinuous f\na : Œ±\n‚ä¢ Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds (hs.extend f a))","decl":"theorem extend_spec [CompleteSpace Œ≤] (hs : Dense s) (hf : UniformContinuous f) (a : Œ±) :\n    Tendsto f (comap (‚Üë) (ùìù a)) (ùìù (hs.extend f a)) :=\n  uniformly_extend_spec (isUniformInducing_val s) hs.denseRange_val hf a\n\n"}
{"name":"Dense.uniformContinuous_extend","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ns : Set Œ±\nf : ‚Üës ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ≤\nhs : Dense s\nhf : UniformContinuous f\n‚ä¢ UniformContinuous (hs.extend f)","decl":"theorem uniformContinuous_extend [CompleteSpace Œ≤] (hs : Dense s) (hf : UniformContinuous f) :\n    UniformContinuous (hs.extend f) :=\n  uniformContinuous_uniformly_extend (isUniformInducing_val s) hs.denseRange_val hf\n\n"}
{"name":"Dense.extend_of_ind","module":"Mathlib.Topology.UniformSpace.UniformEmbedding","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ns : Set Œ±\nf : ‚Üës ‚Üí Œ≤\ninst‚úù : T0Space Œ≤\nhs : Dense s\nhf : UniformContinuous f\nx : ‚Üës\n‚ä¢ Eq (hs.extend f ‚Üëx) (f x)","decl":"theorem extend_of_ind (hs : Dense s) (hf : UniformContinuous f) (x : s) :\n    hs.extend f x = f x :=\n  IsDenseInducing.extend_eq_at _ hf.continuous.continuousAt\n\n"}
