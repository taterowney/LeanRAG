{"name":"AbsoluteValue.isEquiv_refl","module":"Mathlib.Algebra.Order.AbsoluteValue.Equivalence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : AbsoluteValue R Real\n⊢ f.IsEquiv f","decl":"/-- Equivalence of absolute values is reflexive. -/\nlemma isEquiv_refl (f : AbsoluteValue R ℝ) : IsEquiv f f :=\n  ⟨1, Real.zero_lt_one, funext fun x ↦ Real.rpow_one (f x)⟩\n\n"}
{"name":"AbsoluteValue.isEquiv_symm","module":"Mathlib.Algebra.Order.AbsoluteValue.Equivalence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : AbsoluteValue R Real\nhfg : f.IsEquiv g\n⊢ g.IsEquiv f","decl":"/-- Equivalence of absolute values is symmetric. -/\nlemma isEquiv_symm {f g : AbsoluteValue R ℝ} (hfg : IsEquiv f g) : IsEquiv g f := by\n  rcases hfg with ⟨c, hcpos, h⟩\n  refine ⟨1 / c, one_div_pos.mpr hcpos, ?_⟩\n  simp [← h, Real.rpow_rpow_inv (apply_nonneg f _) (ne_of_lt hcpos).symm]\n\n"}
{"name":"AbsoluteValue.isEquiv_trans","module":"Mathlib.Algebra.Order.AbsoluteValue.Equivalence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g k : AbsoluteValue R Real\nhfg : f.IsEquiv g\nhgk : g.IsEquiv k\n⊢ f.IsEquiv k","decl":"/-- Equivalence of absolute values is transitive. -/\nlemma isEquiv_trans {f g k : AbsoluteValue R ℝ} (hfg : IsEquiv f g) (hgk : IsEquiv g k) :\n    IsEquiv f k := by\n  rcases hfg with ⟨c, hcPos, hfg⟩\n  rcases hgk with ⟨d, hdPos, hgk⟩\n  refine ⟨c * d, mul_pos hcPos hdPos, ?_⟩\n  simp [← hgk, ← hfg, Real.rpow_mul (apply_nonneg f _)]\n\n"}
{"name":"AbsoluteValue.eq_trivial_of_isEquiv_trivial","module":"Mathlib.Algebra.Order.AbsoluteValue.Equivalence","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : DecidablePred fun x => Eq x 0\ninst✝ : NoZeroDivisors R\nf : AbsoluteValue R Real\n⊢ Iff (HasEquiv.Equiv f AbsoluteValue.trivial) (Eq f AbsoluteValue.trivial)","decl":"/-- An absolute value is equivalent to the trivial iff it is trivial itself. -/\n@[simp]\nlemma eq_trivial_of_isEquiv_trivial [DecidablePred fun x : R ↦ x = 0] [NoZeroDivisors R]\n    (f : AbsoluteValue R ℝ) :\n    f ≈ .trivial ↔ f = .trivial := by\n  refine ⟨fun ⟨c, hc₀, hc⟩ ↦ ext fun x ↦ ?_, fun H ↦ H ▸ isEquiv_refl f⟩\n  apply_fun (· x) at hc\n  rcases eq_or_ne x 0 with rfl | hx\n  · simp\n  · simp only [ne_eq, hx, not_false_eq_true, trivial_apply] at hc ⊢\n    exact (Real.rpow_left_inj (f.nonneg x) zero_le_one hc₀.ne').mp <| (Real.one_rpow c).symm ▸ hc\n\n"}
