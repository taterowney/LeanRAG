{"name":"imageToKernel_op","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"V : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} V\ninst✝ : CategoryTheory.Abelian V\nX Y Z : V\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (imageToKernel g.op f.op ⋯) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.imageSubobjectIso g.op).trans (CategoryTheory.imageOpOp g).symm).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.factorThruImage g) ⋯).op ((CategoryTheory.Limits.kernelSubobjectIso f.op).trans (CategoryTheory.kernelOpOp f)).inv))","decl":"theorem imageToKernel_op {X Y Z : V} (f : X ⟶ Y) (g : Y ⟶ Z) (w : f ≫ g = 0) :\n    imageToKernel g.op f.op (by rw [← op_comp, w, op_zero]) =\n      (imageSubobjectIso _ ≪≫ (imageOpOp _).symm).hom ≫\n        (cokernel.desc f (factorThruImage g)\n              (by rw [← cancel_mono (image.ι g), Category.assoc, image.fac, w, zero_comp])).op ≫\n          (kernelSubobjectIso _ ≪≫ kernelOpOp _).inv := by\n  ext\n  simp only [Iso.trans_hom, Iso.symm_hom, Iso.trans_inv, kernelOpOp_inv, Category.assoc,\n    imageToKernel_arrow, kernelSubobject_arrow', kernel.lift_ι, ← op_comp, cokernel.π_desc,\n    ← imageSubobject_arrow, ← imageUnopOp_inv_comp_op_factorThruImage g.op]\n  rfl\n\n"}
{"name":"imageToKernel_unop","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"V : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} V\ninst✝ : CategoryTheory.Abelian V\nX Y Z : Opposite V\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (imageToKernel g.unop f.unop ⋯) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.imageSubobjectIso g.unop).trans (CategoryTheory.imageUnopUnop g).symm).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.factorThruImage g) ⋯).unop ((CategoryTheory.Limits.kernelSubobjectIso f.unop).trans (CategoryTheory.kernelUnopUnop f)).inv))","decl":"theorem imageToKernel_unop {X Y Z : Vᵒᵖ} (f : X ⟶ Y) (g : Y ⟶ Z) (w : f ≫ g = 0) :\n    imageToKernel g.unop f.unop (by rw [← unop_comp, w, unop_zero]) =\n      (imageSubobjectIso _ ≪≫ (imageUnopUnop _).symm).hom ≫\n        (cokernel.desc f (factorThruImage g)\n              (by rw [← cancel_mono (image.ι g), Category.assoc, image.fac, w, zero_comp])).unop ≫\n          (kernelSubobjectIso _ ≪≫ kernelUnopUnop _).inv := by\n  ext\n  dsimp only [imageUnopUnop]\n  simp only [Iso.trans_hom, Iso.symm_hom, Iso.trans_inv, kernelUnopUnop_inv, Category.assoc,\n    imageToKernel_arrow, kernelSubobject_arrow', kernel.lift_ι, cokernel.π_desc, Iso.unop_inv,\n    ← unop_comp, factorThruImage_comp_imageUnopOp_inv, Quiver.Hom.unop_op, imageSubobject_arrow]\n\n"}
{"name":"HomologicalComplex.op_X","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V c\ni : ι\n⊢ Eq (X.op.X i) { unop := X.X i }","decl":"/-- Sends a complex `X` with objects in `V` to the corresponding complex with objects in `Vᵒᵖ`. -/\n@[simps]\nprotected def op (X : HomologicalComplex V c) : HomologicalComplex Vᵒᵖ c.symm where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← op_comp, X.d_comp_d, op_zero]\n\n"}
{"name":"HomologicalComplex.op_d","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V c\ni j : ι\n⊢ Eq (X.op.d i j) (X.d j i).op","decl":"/-- Sends a complex `X` with objects in `V` to the corresponding complex with objects in `Vᵒᵖ`. -/\n@[simps]\nprotected def op (X : HomologicalComplex V c) : HomologicalComplex Vᵒᵖ c.symm where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← op_comp, X.d_comp_d, op_zero]\n\n"}
{"name":"HomologicalComplex.opSymm_d","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V c.symm\ni j : ι\n⊢ Eq (X.opSymm.d i j) (X.d j i).op","decl":"/-- Sends a complex `X` with objects in `V` to the corresponding complex with objects in `Vᵒᵖ`. -/\n@[simps]\nprotected def opSymm (X : HomologicalComplex V c.symm) : HomologicalComplex Vᵒᵖ c where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← op_comp, X.d_comp_d, op_zero]\n\n"}
{"name":"HomologicalComplex.opSymm_X","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V c.symm\ni : ι\n⊢ Eq (X.opSymm.X i) { unop := X.X i }","decl":"/-- Sends a complex `X` with objects in `V` to the corresponding complex with objects in `Vᵒᵖ`. -/\n@[simps]\nprotected def opSymm (X : HomologicalComplex V c.symm) : HomologicalComplex Vᵒᵖ c where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← op_comp, X.d_comp_d, op_zero]\n\n"}
{"name":"HomologicalComplex.unop_d","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex (Opposite V) c\ni j : ι\n⊢ Eq (X.unop.d i j) (X.d j i).unop","decl":"/-- Sends a complex `X` with objects in `Vᵒᵖ` to the corresponding complex with objects in `V`. -/\n@[simps]\nprotected def unop (X : HomologicalComplex Vᵒᵖ c) : HomologicalComplex V c.symm where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← unop_comp, X.d_comp_d, unop_zero]\n\n"}
{"name":"HomologicalComplex.unop_X","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex (Opposite V) c\ni : ι\n⊢ Eq (X.unop.X i) (Opposite.unop (X.X i))","decl":"/-- Sends a complex `X` with objects in `Vᵒᵖ` to the corresponding complex with objects in `V`. -/\n@[simps]\nprotected def unop (X : HomologicalComplex Vᵒᵖ c) : HomologicalComplex V c.symm where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← unop_comp, X.d_comp_d, unop_zero]\n\n"}
{"name":"HomologicalComplex.unopSymm_X","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex (Opposite V) c.symm\ni : ι\n⊢ Eq (X.unopSymm.X i) (Opposite.unop (X.X i))","decl":"/-- Sends a complex `X` with objects in `Vᵒᵖ` to the corresponding complex with objects in `V`. -/\n@[simps]\nprotected def unopSymm (X : HomologicalComplex Vᵒᵖ c.symm) : HomologicalComplex V c where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← unop_comp, X.d_comp_d, unop_zero]\n\n"}
{"name":"HomologicalComplex.unopSymm_d","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex (Opposite V) c.symm\ni j : ι\n⊢ Eq (X.unopSymm.d i j) (X.d j i).unop","decl":"/-- Sends a complex `X` with objects in `Vᵒᵖ` to the corresponding complex with objects in `V`. -/\n@[simps]\nprotected def unopSymm (X : HomologicalComplex Vᵒᵖ c.symm) : HomologicalComplex V c where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [← unop_comp, X.d_comp_d, unop_zero]\n\n"}
{"name":"HomologicalComplex.opFunctor_obj","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : Opposite (HomologicalComplex V c)\n⊢ Eq ((HomologicalComplex.opFunctor V c).obj X) (Opposite.unop X).op","decl":"/-- Auxiliary definition for `opEquivalence`. -/\n@[simps]\ndef opFunctor : (HomologicalComplex V c)ᵒᵖ ⥤ HomologicalComplex Vᵒᵖ c.symm where\n  obj X := (unop X).op\n  map f :=\n    { f := fun i => (f.unop.f i).op\n      comm' := fun i j _ => by simp only [op_d, ← op_comp, f.unop.comm] }\n\n"}
{"name":"HomologicalComplex.opFunctor_map_f","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX✝ Y✝ : Opposite (HomologicalComplex V c)\nf : Quiver.Hom X✝ Y✝\ni : ι\n⊢ Eq (((HomologicalComplex.opFunctor V c).map f).f i) (f.unop.f i).op","decl":"/-- Auxiliary definition for `opEquivalence`. -/\n@[simps]\ndef opFunctor : (HomologicalComplex V c)ᵒᵖ ⥤ HomologicalComplex Vᵒᵖ c.symm where\n  obj X := (unop X).op\n  map f :=\n    { f := fun i => (f.unop.f i).op\n      comm' := fun i j _ => by simp only [op_d, ← op_comp, f.unop.comm] }\n\n"}
{"name":"HomologicalComplex.opInverse_obj","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex (Opposite V) c.symm\n⊢ Eq ((HomologicalComplex.opInverse V c).obj X) { unop := X.unopSymm }","decl":"/-- Auxiliary definition for `opEquivalence`. -/\n@[simps]\ndef opInverse : HomologicalComplex Vᵒᵖ c.symm ⥤ (HomologicalComplex V c)ᵒᵖ where\n  obj X := op X.unopSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).unop\n      comm' := fun i j _ => by simp only [unopSymm_d, ← unop_comp, f.comm] }\n\n"}
{"name":"HomologicalComplex.opInverse_map","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX✝ Y✝ : HomologicalComplex (Opposite V) c.symm\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((HomologicalComplex.opInverse V c).map f) (Quiver.Hom.op { f := fun i => (f.f i).unop, comm' := ⋯ })","decl":"/-- Auxiliary definition for `opEquivalence`. -/\n@[simps]\ndef opInverse : HomologicalComplex Vᵒᵖ c.symm ⥤ (HomologicalComplex V c)ᵒᵖ where\n  obj X := op X.unopSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).unop\n      comm' := fun i j _ => by simp only [unopSymm_d, ← unop_comp, f.comm] }\n\n"}
{"name":"HomologicalComplex.opEquivalence_functor","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.opEquivalence V c).functor (HomologicalComplex.opFunctor V c)","decl":"/-- Given a category of complexes with objects in `V`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `Vᵒᵖ`. -/\n@[simps]\ndef opEquivalence : (HomologicalComplex V c)ᵒᵖ ≌ HomologicalComplex Vᵒᵖ c.symm where\n  functor := opFunctor V c\n  inverse := opInverse V c\n  unitIso := opUnitIso V c\n  counitIso := opCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.opEquivalence_inverse","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.opEquivalence V c).inverse (HomologicalComplex.opInverse V c)","decl":"/-- Given a category of complexes with objects in `V`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `Vᵒᵖ`. -/\n@[simps]\ndef opEquivalence : (HomologicalComplex V c)ᵒᵖ ≌ HomologicalComplex Vᵒᵖ c.symm where\n  functor := opFunctor V c\n  inverse := opInverse V c\n  unitIso := opUnitIso V c\n  counitIso := opCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.opEquivalence_counitIso","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.opEquivalence V c).counitIso (HomologicalComplex.opCounitIso V c)","decl":"/-- Given a category of complexes with objects in `V`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `Vᵒᵖ`. -/\n@[simps]\ndef opEquivalence : (HomologicalComplex V c)ᵒᵖ ≌ HomologicalComplex Vᵒᵖ c.symm where\n  functor := opFunctor V c\n  inverse := opInverse V c\n  unitIso := opUnitIso V c\n  counitIso := opCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.opEquivalence_unitIso","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.opEquivalence V c).unitIso (HomologicalComplex.opUnitIso V c)","decl":"/-- Given a category of complexes with objects in `V`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `Vᵒᵖ`. -/\n@[simps]\ndef opEquivalence : (HomologicalComplex V c)ᵒᵖ ≌ HomologicalComplex Vᵒᵖ c.symm where\n  functor := opFunctor V c\n  inverse := opInverse V c\n  unitIso := opUnitIso V c\n  counitIso := opCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.unopFunctor_map_f","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX✝ Y✝ : Opposite (HomologicalComplex (Opposite V) c)\nf : Quiver.Hom X✝ Y✝\ni : ι\n⊢ Eq (((HomologicalComplex.unopFunctor V c).map f).f i) (f.unop.f i).unop","decl":"/-- Auxiliary definition for `unopEquivalence`. -/\n@[simps]\ndef unopFunctor : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ⥤ HomologicalComplex V c.symm where\n  obj X := (unop X).unop\n  map f :=\n    { f := fun i => (f.unop.f i).unop\n      comm' := fun i j _ => by simp only [unop_d, ← unop_comp, f.unop.comm] }\n\n"}
{"name":"HomologicalComplex.unopFunctor_obj","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : Opposite (HomologicalComplex (Opposite V) c)\n⊢ Eq ((HomologicalComplex.unopFunctor V c).obj X) (Opposite.unop X).unop","decl":"/-- Auxiliary definition for `unopEquivalence`. -/\n@[simps]\ndef unopFunctor : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ⥤ HomologicalComplex V c.symm where\n  obj X := (unop X).unop\n  map f :=\n    { f := fun i => (f.unop.f i).unop\n      comm' := fun i j _ => by simp only [unop_d, ← unop_comp, f.unop.comm] }\n\n"}
{"name":"HomologicalComplex.unopInverse_map","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX✝ Y✝ : HomologicalComplex V c.symm\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((HomologicalComplex.unopInverse V c).map f) (Quiver.Hom.op { f := fun i => (f.f i).op, comm' := ⋯ })","decl":"/-- Auxiliary definition for `unopEquivalence`. -/\n@[simps]\ndef unopInverse : HomologicalComplex V c.symm ⥤ (HomologicalComplex Vᵒᵖ c)ᵒᵖ where\n  obj X := op X.opSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).op\n      comm' := fun i j _ => by simp only [opSymm_d, ← op_comp, f.comm] }\n\n"}
{"name":"HomologicalComplex.unopInverse_obj","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V c.symm\n⊢ Eq ((HomologicalComplex.unopInverse V c).obj X) { unop := X.opSymm }","decl":"/-- Auxiliary definition for `unopEquivalence`. -/\n@[simps]\ndef unopInverse : HomologicalComplex V c.symm ⥤ (HomologicalComplex Vᵒᵖ c)ᵒᵖ where\n  obj X := op X.opSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).op\n      comm' := fun i j _ => by simp only [opSymm_d, ← op_comp, f.comm] }\n\n"}
{"name":"HomologicalComplex.unopEquivalence_functor","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.unopEquivalence V c).functor (HomologicalComplex.unopFunctor V c)","decl":"/-- Given a category of complexes with objects in `Vᵒᵖ`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `V`. -/\n@[simps]\ndef unopEquivalence : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ≌ HomologicalComplex V c.symm where\n  functor := unopFunctor V c\n  inverse := unopInverse V c\n  unitIso := unopUnitIso V c\n  counitIso := unopCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.unopEquivalence_inverse","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.unopEquivalence V c).inverse (HomologicalComplex.unopInverse V c)","decl":"/-- Given a category of complexes with objects in `Vᵒᵖ`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `V`. -/\n@[simps]\ndef unopEquivalence : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ≌ HomologicalComplex V c.symm where\n  functor := unopFunctor V c\n  inverse := unopInverse V c\n  unitIso := unopUnitIso V c\n  counitIso := unopCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.unopEquivalence_unitIso","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.unopEquivalence V c).unitIso (HomologicalComplex.unopUnitIso V c)","decl":"/-- Given a category of complexes with objects in `Vᵒᵖ`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `V`. -/\n@[simps]\ndef unopEquivalence : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ≌ HomologicalComplex V c.symm where\n  functor := unopFunctor V c\n  inverse := unopInverse V c\n  unitIso := unopUnitIso V c\n  counitIso := unopCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.unopEquivalence_counitIso","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.unopEquivalence V c).counitIso (HomologicalComplex.unopCounitIso V c)","decl":"/-- Given a category of complexes with objects in `Vᵒᵖ`, there is a natural equivalence between its\nopposite category and a category of complexes with objects in `V`. -/\n@[simps]\ndef unopEquivalence : (HomologicalComplex Vᵒᵖ c)ᵒᵖ ≌ HomologicalComplex V c.symm where\n  functor := unopFunctor V c\n  inverse := unopInverse V c\n  unitIso := unopUnitIso V c\n  counitIso := unopCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _\n\n"}
{"name":"HomologicalComplex.instHasHomologyOppositeOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\n⊢ K.op.HasHomology i","decl":"instance (K : HomologicalComplex V c) (i : ι) [K.HasHomology i] :\n    K.op.HasHomology i :=\n  (inferInstance : (K.sc i).op.HasHomology)\n\n"}
{"name":"HomologicalComplex.instHasHomologyUnopOfOpposite","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex (Opposite V) c\ni : ι\ninst✝ : K.HasHomology i\n⊢ K.unop.HasHomology i","decl":"instance (K : HomologicalComplex Vᵒᵖ c) (i : ι) [K.HasHomology i] :\n    K.unop.HasHomology i :=\n  (inferInstance : (K.sc i).unop.HasHomology)\n\n"}
{"name":"HomologicalComplex.instHasHomologyOppositeObjSymmOpFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\n⊢ ((HomologicalComplex.opFunctor V c).obj { unop := K }).HasHomology i","decl":"instance (K : HomologicalComplex V c) (i : ι) [K.HasHomology i] :\n    ((opFunctor _ _).obj (op K)).HasHomology i := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.instHasHomologyObjOppositeSymmUnopFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex (Opposite V) c\ni : ι\ninst✝ : K.HasHomology i\n⊢ ((HomologicalComplex.unopFunctor V c).obj { unop := K }).HasHomology i","decl":"instance (K : HomologicalComplex Vᵒᵖ c) (i : ι) [K.HasHomology i] :\n    ((unopFunctor _ _).obj (op K)).HasHomology i := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.quasiIsoAt_opFunctor_map_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Iff (QuasiIsoAt ((HomologicalComplex.opFunctor V c).map φ.op) i) (QuasiIsoAt φ i)","decl":"@[simp]\nlemma quasiIsoAt_opFunctor_map_iff\n    {K L : HomologicalComplex V c} (φ : K ⟶ L) (i : ι)\n    [K.HasHomology i] [L.HasHomology i] :\n    QuasiIsoAt ((opFunctor _ _).map φ.op) i ↔ QuasiIsoAt φ i := by\n  simp only [quasiIsoAt_iff]\n  exact ShortComplex.quasiIso_opMap_iff ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.quasiIsoAt_unopFunctor_map_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex (Opposite V) c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Iff (QuasiIsoAt ((HomologicalComplex.unopFunctor V c).map φ.op) i) (QuasiIsoAt φ i)","decl":"@[simp]\nlemma quasiIsoAt_unopFunctor_map_iff\n    {K L : HomologicalComplex Vᵒᵖ c} (φ : K ⟶ L) (i : ι)\n    [K.HasHomology i] [L.HasHomology i] :\n    QuasiIsoAt ((unopFunctor _ _).map φ.op) i ↔ QuasiIsoAt φ i := by\n  rw [← quasiIsoAt_opFunctor_map_iff]\n  rfl\n\n"}
{"name":"HomologicalComplex.instQuasiIsoAtOppositeMapSymmOpFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝² : K.HasHomology i\ninst✝¹ : L.HasHomology i\ninst✝ : QuasiIsoAt φ i\n⊢ QuasiIsoAt ((HomologicalComplex.opFunctor V c).map φ.op) i","decl":"instance {K L : HomologicalComplex V c} (φ : K ⟶ L) (i : ι)\n    [K.HasHomology i] [L.HasHomology i] [QuasiIsoAt φ i] :\n    QuasiIsoAt ((opFunctor _ _).map φ.op) i := by\n  rw [quasiIsoAt_opFunctor_map_iff]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.instQuasiIsoAtMapOppositeSymmUnopFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex (Opposite V) c\nφ : Quiver.Hom K L\ni : ι\ninst✝² : K.HasHomology i\ninst✝¹ : L.HasHomology i\ninst✝ : QuasiIsoAt φ i\n⊢ QuasiIsoAt ((HomologicalComplex.unopFunctor V c).map φ.op) i","decl":"instance {K L : HomologicalComplex Vᵒᵖ c} (φ : K ⟶ L) (i : ι)\n    [K.HasHomology i] [L.HasHomology i] [QuasiIsoAt φ i] :\n    QuasiIsoAt ((unopFunctor _ _).map φ.op) i := by\n  rw [quasiIsoAt_unopFunctor_map_iff]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.quasiIso_opFunctor_map_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ninst✝¹ : ∀ (i : ι), K.HasHomology i\ninst✝ : ∀ (i : ι), L.HasHomology i\n⊢ Iff (QuasiIso ((HomologicalComplex.opFunctor V c).map φ.op)) (QuasiIso φ)","decl":"@[simp]\nlemma quasiIso_opFunctor_map_iff\n    {K L : HomologicalComplex V c} (φ : K ⟶ L)\n    [∀ i, K.HasHomology i] [∀ i, L.HasHomology i] :\n    QuasiIso ((opFunctor _ _).map φ.op) ↔ QuasiIso φ := by\n  simp only [quasiIso_iff, quasiIsoAt_opFunctor_map_iff]\n\n"}
{"name":"HomologicalComplex.quasiIso_unopFunctor_map_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex (Opposite V) c\nφ : Quiver.Hom K L\ninst✝¹ : ∀ (i : ι), K.HasHomology i\ninst✝ : ∀ (i : ι), L.HasHomology i\n⊢ Iff (QuasiIso ((HomologicalComplex.unopFunctor V c).map φ.op)) (QuasiIso φ)","decl":"@[simp]\nlemma quasiIso_unopFunctor_map_iff\n    {K L : HomologicalComplex Vᵒᵖ c} (φ : K ⟶ L)\n    [∀ i, K.HasHomology i] [∀ i, L.HasHomology i] :\n    QuasiIso ((unopFunctor _ _).map φ.op) ↔ QuasiIso φ := by\n  simp only [quasiIso_iff, quasiIsoAt_unopFunctor_map_iff]\n\n"}
{"name":"HomologicalComplex.instQuasiIsoOppositeMapSymmOpFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ninst✝² : ∀ (i : ι), K.HasHomology i\ninst✝¹ : ∀ (i : ι), L.HasHomology i\ninst✝ : QuasiIso φ\n⊢ QuasiIso ((HomologicalComplex.opFunctor V c).map φ.op)","decl":"instance {K L : HomologicalComplex V c} (φ : K ⟶ L)\n    [∀ i, K.HasHomology i] [∀ i, L.HasHomology i] [QuasiIso φ] :\n    QuasiIso ((opFunctor _ _).map φ.op) := by\n  rw [quasiIso_opFunctor_map_iff]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.instQuasiIsoMapOppositeSymmUnopFunctorOp","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex (Opposite V) c\nφ : Quiver.Hom K L\ninst✝² : ∀ (i : ι), K.HasHomology i\ninst✝¹ : ∀ (i : ι), L.HasHomology i\ninst✝ : QuasiIso φ\n⊢ QuasiIso ((HomologicalComplex.unopFunctor V c).map φ.op)","decl":"instance {K L : HomologicalComplex Vᵒᵖ c} (φ : K ⟶ L)\n    [∀ i, K.HasHomology i] [∀ i, L.HasHomology i] [QuasiIso φ] :\n    QuasiIso ((unopFunctor _ _).map φ.op) := by\n  rw [quasiIso_unopFunctor_map_iff]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.ExactAt.op","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\nh : K.ExactAt i\n⊢ K.op.ExactAt i","decl":"lemma ExactAt.op {K : HomologicalComplex V c} {i : ι} (h : K.ExactAt i) :\n    K.op.ExactAt i :=\n  ShortComplex.Exact.op h\n\n"}
{"name":"HomologicalComplex.ExactAt.unop","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex (Opposite V) c\ni : ι\nh : K.ExactAt i\n⊢ K.unop.ExactAt i","decl":"lemma ExactAt.unop {K : HomologicalComplex Vᵒᵖ c} {i : ι} (h : K.ExactAt i) :\n    K.unop.ExactAt i :=\n  ShortComplex.Exact.unop h\n\n"}
{"name":"HomologicalComplex.exactAt_op_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\n⊢ Iff (K.op.ExactAt i) (K.ExactAt i)","decl":"@[simp]\nlemma exactAt_op_iff (K : HomologicalComplex V c) {i : ι} :\n    K.op.ExactAt i ↔ K.ExactAt i :=\n  ⟨fun h ↦ h.unop, fun h ↦ h.op⟩\n\n"}
{"name":"HomologicalComplex.Acyclic.op","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\nh : K.Acyclic\n⊢ K.op.Acyclic","decl":"lemma Acyclic.op {K : HomologicalComplex V c} (h : K.Acyclic) :\n    K.op.Acyclic :=\n  fun i ↦ (h i).op\n\n"}
{"name":"HomologicalComplex.Acyclic.unop","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex (Opposite V) c\nh : K.Acyclic\n⊢ K.unop.Acyclic","decl":"lemma Acyclic.unop {K : HomologicalComplex Vᵒᵖ c} (h : K.Acyclic) :\n    K.unop.Acyclic :=\n  fun i ↦ (h i).unop\n\n"}
{"name":"HomologicalComplex.acyclic_op_iff","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\n⊢ Iff K.op.Acyclic K.Acyclic","decl":"@[simp]\nlemma acyclic_op_iff (K : HomologicalComplex V c) :\n    K.op.Acyclic ↔ K.Acyclic :=\n  ⟨fun h ↦ h.unop, fun h ↦ h.op⟩\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_hom_toCycles_op","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesOpIso i).hom (K.toCycles j i).op) (K.op.fromOpcycles i j)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesOpIso_hom_toCycles_op :\n    (K.opcyclesOpIso i).hom ≫ (K.toCycles j i).op = K.op.fromOpcycles i j := by\n  by_cases hij : c.Rel j i\n  · obtain rfl := c.prev_eq' hij\n    exact (K.sc i).opcyclesOpIso_hom_toCycles_op\n  · rw [K.toCycles_eq_zero hij, K.op.fromOpcycles_eq_zero hij, op_zero, comp_zero]\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_hom_toCycles_op_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\nj : ι\nZ : Opposite V\nh : Quiver.Hom { unop := K.X j } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesOpIso i).hom (CategoryTheory.CategoryStruct.comp (K.toCycles j i).op h)) (CategoryTheory.CategoryStruct.comp (K.op.fromOpcycles i j) h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesOpIso_hom_toCycles_op :\n    (K.opcyclesOpIso i).hom ≫ (K.toCycles j i).op = K.op.fromOpcycles i j := by\n  by_cases hij : c.Rel j i\n  · obtain rfl := c.prev_eq' hij\n    exact (K.sc i).opcyclesOpIso_hom_toCycles_op\n  · rw [K.toCycles_eq_zero hij, K.op.fromOpcycles_eq_zero hij, op_zero, comp_zero]\n\n"}
{"name":"HomologicalComplex.fromOpcycles_op_cyclesOpIso_inv_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\nj : ι\nZ : Opposite V\nh : Quiver.Hom (K.op.cycles i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.fromOpcycles i j).op (CategoryTheory.CategoryStruct.comp (K.cyclesOpIso i).inv h)) (CategoryTheory.CategoryStruct.comp (K.op.toCycles j i) h)","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_op_cyclesOpIso_inv :\n    (K.fromOpcycles i j).op ≫ (K.cyclesOpIso i).inv = K.op.toCycles j i := by\n  by_cases hij : c.Rel i j\n  · obtain rfl := c.next_eq' hij\n    exact (K.sc i).fromOpcycles_op_cyclesOpIso_inv\n  · rw [K.op.toCycles_eq_zero hij, K.fromOpcycles_eq_zero hij, op_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.fromOpcycles_op_cyclesOpIso_inv","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nK : HomologicalComplex V c\ni : ι\ninst✝ : K.HasHomology i\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.fromOpcycles i j).op (K.cyclesOpIso i).inv) (K.op.toCycles j i)","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_op_cyclesOpIso_inv :\n    (K.fromOpcycles i j).op ≫ (K.cyclesOpIso i).inv = K.op.toCycles j i := by\n  by_cases hij : c.Rel i j\n  · obtain rfl := c.next_eq' hij\n    exact (K.sc i).fromOpcycles_op_cyclesOpIso_inv\n  · rw [K.op.toCycles_eq_zero hij, K.fromOpcycles_eq_zero hij, op_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.homologyOp_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\nZ : Opposite V\nh : Quiver.Hom { unop := K.homology i } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (CategoryTheory.CategoryStruct.comp (K.homologyOp i).hom h)) (CategoryTheory.CategoryStruct.comp (L.homologyOp i).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap φ i).op h))","decl":"@[reassoc]\nlemma homologyOp_hom_naturality :\n    homologyMap ((opFunctor _ _).map φ.op) _ ≫ (K.homologyOp i).hom =\n      (L.homologyOp i).hom ≫ (homologyMap φ i).op :=\n  ShortComplex.homologyOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.homologyOp_hom_naturality","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (K.homologyOp i).hom) (CategoryTheory.CategoryStruct.comp (L.homologyOp i).hom (HomologicalComplex.homologyMap φ i).op)","decl":"@[reassoc]\nlemma homologyOp_hom_naturality :\n    homologyMap ((opFunctor _ _).map φ.op) _ ≫ (K.homologyOp i).hom =\n      (L.homologyOp i).hom ≫ (homologyMap φ i).op :=\n  ShortComplex.homologyOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_hom_naturality","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (K.opcyclesOpIso i).hom) (CategoryTheory.CategoryStruct.comp (L.opcyclesOpIso i).hom (HomologicalComplex.cyclesMap φ i).op)","decl":"@[reassoc]\nlemma opcyclesOpIso_hom_naturality :\n    opcyclesMap ((opFunctor _ _).map φ.op) _ ≫ (K.opcyclesOpIso i).hom =\n      (L.opcyclesOpIso i).hom ≫ (cyclesMap φ i).op :=\n  ShortComplex.opcyclesOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\nZ : Opposite V\nh : Quiver.Hom { unop := K.cycles i } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (CategoryTheory.CategoryStruct.comp (K.opcyclesOpIso i).hom h)) (CategoryTheory.CategoryStruct.comp (L.opcyclesOpIso i).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ i).op h))","decl":"@[reassoc]\nlemma opcyclesOpIso_hom_naturality :\n    opcyclesMap ((opFunctor _ _).map φ.op) _ ≫ (K.opcyclesOpIso i).hom =\n      (L.opcyclesOpIso i).hom ≫ (cyclesMap φ i).op :=\n  ShortComplex.opcyclesOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\nZ : Opposite V\nh : Quiver.Hom (K.op.opcycles i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ i).op (CategoryTheory.CategoryStruct.comp (K.opcyclesOpIso i).inv h)) (CategoryTheory.CategoryStruct.comp (L.opcyclesOpIso i).inv (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) h))","decl":"@[reassoc]\nlemma opcyclesOpIso_inv_naturality :\n    (cyclesMap φ i).op ≫ (K.opcyclesOpIso i).inv =\n      (L.opcyclesOpIso i).inv ≫ opcyclesMap ((opFunctor _ _).map φ.op) _ :=\n  ShortComplex.opcyclesOpIso_inv_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.opcyclesOpIso_inv_naturality","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ i).op (K.opcyclesOpIso i).inv) (CategoryTheory.CategoryStruct.comp (L.opcyclesOpIso i).inv (HomologicalComplex.opcyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i))","decl":"@[reassoc]\nlemma opcyclesOpIso_inv_naturality :\n    (cyclesMap φ i).op ≫ (K.opcyclesOpIso i).inv =\n      (L.opcyclesOpIso i).inv ≫ opcyclesMap ((opFunctor _ _).map φ.op) _ :=\n  ShortComplex.opcyclesOpIso_inv_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.cyclesOpIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\nZ : Opposite V\nh : Quiver.Hom { unop := K.opcycles i } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (CategoryTheory.CategoryStruct.comp (K.cyclesOpIso i).hom h)) (CategoryTheory.CategoryStruct.comp (L.cyclesOpIso i).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap φ i).op h))","decl":"@[reassoc]\nlemma cyclesOpIso_hom_naturality :\n    cyclesMap ((opFunctor _ _).map φ.op) _ ≫ (K.cyclesOpIso i).hom =\n      (L.cyclesOpIso i).hom ≫ (opcyclesMap φ i).op :=\n  ShortComplex.cyclesOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.cyclesOpIso_hom_naturality","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) (K.cyclesOpIso i).hom) (CategoryTheory.CategoryStruct.comp (L.cyclesOpIso i).hom (HomologicalComplex.opcyclesMap φ i).op)","decl":"@[reassoc]\nlemma cyclesOpIso_hom_naturality :\n    cyclesMap ((opFunctor _ _).map φ.op) _ ≫ (K.cyclesOpIso i).hom =\n      (L.cyclesOpIso i).hom ≫ (opcyclesMap φ i).op :=\n  ShortComplex.cyclesOpIso_hom_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.cyclesOpIso_inv_naturality","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap φ i).op (K.cyclesOpIso i).inv) (CategoryTheory.CategoryStruct.comp (L.cyclesOpIso i).inv (HomologicalComplex.cyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i))","decl":"@[reassoc]\nlemma cyclesOpIso_inv_naturality :\n    (opcyclesMap φ i).op ≫ (K.cyclesOpIso i).inv =\n      (L.cyclesOpIso i).inv ≫ cyclesMap ((opFunctor _ _).map φ.op) _ :=\n  ShortComplex.cyclesOpIso_inv_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.cyclesOpIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\nZ : Opposite V\nh : Quiver.Hom (K.op.cycles i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap φ i).op (CategoryTheory.CategoryStruct.comp (K.cyclesOpIso i).inv h)) (CategoryTheory.CategoryStruct.comp (L.cyclesOpIso i).inv (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap ((HomologicalComplex.opFunctor V c).map φ.op) i) h))","decl":"@[reassoc]\nlemma cyclesOpIso_inv_naturality :\n    (opcyclesMap φ i).op ≫ (K.cyclesOpIso i).inv =\n      (L.cyclesOpIso i).inv ≫ cyclesMap ((opFunctor _ _).map φ.op) _ :=\n  ShortComplex.cyclesOpIso_inv_naturality ((shortComplexFunctor V c i).map φ)\n\n"}
{"name":"HomologicalComplex.cyclesOpNatIso_inv_app","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.CategoryWithHomology V\ni : ι\nX : Opposite (HomologicalComplex V c)\n⊢ Eq ((HomologicalComplex.cyclesOpNatIso V c i).inv.app X) ((Opposite.unop X).cyclesOpIso i).inv","decl":"/-- The natural isomorphism `K.op.cycles i ≅ op (K.opcycles i)`. -/\n@[simps!]\ndef cyclesOpNatIso :\n    opFunctor V c ⋙ cyclesFunctor Vᵒᵖ c.symm i ≅ (opcyclesFunctor V c i).op :=\n  NatIso.ofComponents (fun K ↦ (unop K).cyclesOpIso i)\n    (fun _ ↦ cyclesOpIso_hom_naturality _ _)\n\n"}
{"name":"HomologicalComplex.cyclesOpNatIso_hom_app","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.CategoryWithHomology V\ni : ι\nX : Opposite (HomologicalComplex V c)\n⊢ Eq ((HomologicalComplex.cyclesOpNatIso V c i).hom.app X) ((Opposite.unop X).cyclesOpIso i).hom","decl":"/-- The natural isomorphism `K.op.cycles i ≅ op (K.opcycles i)`. -/\n@[simps!]\ndef cyclesOpNatIso :\n    opFunctor V c ⋙ cyclesFunctor Vᵒᵖ c.symm i ≅ (opcyclesFunctor V c i).op :=\n  NatIso.ofComponents (fun K ↦ (unop K).cyclesOpIso i)\n    (fun _ ↦ cyclesOpIso_hom_naturality _ _)\n\n"}
{"name":"HomologicalComplex.opFunctor_additive","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Preadditive V\n⊢ (HomologicalComplex.opFunctor V c).Additive","decl":"instance opFunctor_additive : (@opFunctor ι V _ c _).Additive where\n\n"}
{"name":"HomologicalComplex.unopFunctor_additive","module":"Mathlib.Algebra.Homology.Opposite","initialProofState":"ι : Type u_1\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Preadditive V\n⊢ (HomologicalComplex.unopFunctor V c).Additive","decl":"instance unopFunctor_additive : (@unopFunctor ι V _ c _).Additive where\n\n"}
