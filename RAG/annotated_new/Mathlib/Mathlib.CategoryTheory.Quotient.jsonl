{"name":"CategoryTheory.Functor.homRel_iff","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (F.homRel f g) (Eq (F.map f) (F.map g))","decl":"@[simp]\nlemma Functor.homRel_iff {X Y : C} (f g : X ‚ü∂ Y) :\n    F.homRel f g ‚Üî F.map f = F.map g := Iff.rfl\n\n"}
{"name":"CategoryTheory.Congruence.compRight","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nself : CategoryTheory.Congruence r\nX Y Z : C\nf f' : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na‚úù : r f f'\n‚ä¢ r (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g)","decl":"/-- A `HomRel` is a congruence when it's an equivalence on every hom-set, and it can be composed\nfrom left and right. -/\nclass Congruence : Prop where\n  /-- `r` is an equivalence on every hom-set. -/\n  equivalence : ‚àÄ {X Y}, _root_.Equivalence (@r X Y)\n  /-- Precomposition with an arrow respects `r`. -/\n  compLeft : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) {g g' : Y ‚ü∂ Z}, r g g' ‚Üí r (f ‚â´ g) (f ‚â´ g')\n  /-- Postcomposition with an arrow respects `r`. -/\n  compRight : ‚àÄ {X Y Z} {f f' : X ‚ü∂ Y} (g : Y ‚ü∂ Z), r f f' ‚Üí r (f ‚â´ g) (f' ‚â´ g)\n\n"}
{"name":"CategoryTheory.Congruence.compLeft","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nself : CategoryTheory.Congruence r\nX Y Z : C\nf : Quiver.Hom X Y\ng g' : Quiver.Hom Y Z\na‚úù : r g g'\n‚ä¢ r (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g')","decl":"/-- A `HomRel` is a congruence when it's an equivalence on every hom-set, and it can be composed\nfrom left and right. -/\nclass Congruence : Prop where\n  /-- `r` is an equivalence on every hom-set. -/\n  equivalence : ‚àÄ {X Y}, _root_.Equivalence (@r X Y)\n  /-- Precomposition with an arrow respects `r`. -/\n  compLeft : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) {g g' : Y ‚ü∂ Z}, r g g' ‚Üí r (f ‚â´ g) (f ‚â´ g')\n  /-- Postcomposition with an arrow respects `r`. -/\n  compRight : ‚àÄ {X Y Z} {f f' : X ‚ü∂ Y} (g : Y ‚ü∂ Z), r f f' ‚Üí r (f ‚â´ g) (f' ‚â´ g)\n\n"}
{"name":"CategoryTheory.Congruence.equivalence","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nself : CategoryTheory.Congruence r\nX Y : C\n‚ä¢ Equivalence r","decl":"/-- A `HomRel` is a congruence when it's an equivalence on every hom-set, and it can be composed\nfrom left and right. -/\nclass Congruence : Prop where\n  /-- `r` is an equivalence on every hom-set. -/\n  equivalence : ‚àÄ {X Y}, _root_.Equivalence (@r X Y)\n  /-- Precomposition with an arrow respects `r`. -/\n  compLeft : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) {g g' : Y ‚ü∂ Z}, r g g' ‚Üí r (f ‚â´ g) (f ‚â´ g')\n  /-- Postcomposition with an arrow respects `r`. -/\n  compRight : ‚àÄ {X Y Z} {f f' : X ‚ü∂ Y} (g : Y ‚ü∂ Z), r f f' ‚Üí r (f ‚â´ g) (f' ‚â´ g)\n\n"}
{"name":"CategoryTheory.Functor.congruence_homRel","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\n‚ä¢ CategoryTheory.Congruence F.homRel","decl":"/-- For `F : C ‚•§ D`, `F.homRel` is a congruence.-/\ninstance Functor.congruence_homRel {C D : Type*} [Category C] [Category D] (F : C ‚•§ D) :\n    Congruence F.homRel where\n  equivalence :=\n    { refl := fun _ ‚Ü¶ rfl\n      symm := by aesop\n      trans := by aesop }\n  compLeft := by aesop\n  compRight := by aesop\n\n"}
{"name":"CategoryTheory.Quotient.ext_iff","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nx y : CategoryTheory.Quotient r\n‚ä¢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- A type synonym for `C`, thought of as the objects of the quotient category. -/\n@[ext]\nstructure Quotient (r : HomRel C) where\n  /-- The object of `C`. -/\n  as : C\n\n"}
{"name":"CategoryTheory.Quotient.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\ninst‚úù¬π : SizeOf C\ninst‚úù : ‚¶ÉX Y : C‚¶Ñ ‚Üí (a a_1 : Quiver.Hom X Y) ‚Üí SizeOf (r a a_1)\nas : C\n‚ä¢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- A type synonym for `C`, thought of as the objects of the quotient category. -/\n@[ext]\nstructure Quotient (r : HomRel C) where\n  /-- The object of `C`. -/\n  as : C\n\n"}
{"name":"CategoryTheory.Quotient.mk.inj","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nas‚úù as : C\nx‚úù : Eq { as := as‚úù } { as := as }\n‚ä¢ Eq as‚úù as","decl":"/-- A type synonym for `C`, thought of as the objects of the quotient category. -/\n@[ext]\nstructure Quotient (r : HomRel C) where\n  /-- The object of `C`. -/\n  as : C\n\n"}
{"name":"CategoryTheory.Quotient.ext","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nx y : CategoryTheory.Quotient r\nas : Eq x.as y.as\n‚ä¢ Eq x y","decl":"/-- A type synonym for `C`, thought of as the objects of the quotient category. -/\n@[ext]\nstructure Quotient (r : HomRel C) where\n  /-- The object of `C`. -/\n  as : C\n\n"}
{"name":"CategoryTheory.Quotient.mk.injEq","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nas‚úù as : C\n‚ä¢ Eq (Eq { as := as‚úù } { as := as }) (Eq as‚úù as)","decl":"/-- A type synonym for `C`, thought of as the objects of the quotient category. -/\n@[ext]\nstructure Quotient (r : HomRel C) where\n  /-- The object of `C`. -/\n  as : C\n\n"}
{"name":"CategoryTheory.Quotient.CompClosure.of","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\na b : C\nm‚ÇÅ m‚ÇÇ : Quiver.Hom a b\nh : r m‚ÇÅ m‚ÇÇ\n‚ä¢ CategoryTheory.Quotient.CompClosure r m‚ÇÅ m‚ÇÇ","decl":"theorem CompClosure.of {a b : C} (m‚ÇÅ m‚ÇÇ : a ‚ü∂ b) (h : r m‚ÇÅ m‚ÇÇ) : CompClosure r m‚ÇÅ m‚ÇÇ := by\n  simpa using CompClosure.intro (ùüô _) m‚ÇÅ m‚ÇÇ (ùüô _) h\n\n"}
{"name":"CategoryTheory.Quotient.comp_left","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\na b c : C\nf : Quiver.Hom a b\ng‚ÇÅ g‚ÇÇ : Quiver.Hom b c\nx‚úù : CategoryTheory.Quotient.CompClosure r g‚ÇÅ g‚ÇÇ\n‚ä¢ CategoryTheory.Quotient.CompClosure r (CategoryTheory.CategoryStruct.comp f g‚ÇÅ) (CategoryTheory.CategoryStruct.comp f g‚ÇÇ)","decl":"theorem comp_left {a b c : C} (f : a ‚ü∂ b) :\n    ‚àÄ (g‚ÇÅ g‚ÇÇ : b ‚ü∂ c) (_ : CompClosure r g‚ÇÅ g‚ÇÇ), CompClosure r (f ‚â´ g‚ÇÅ) (f ‚â´ g‚ÇÇ)\n  | _, _, ‚ü®x, m‚ÇÅ, m‚ÇÇ, y, h‚ü© => by simpa using CompClosure.intro (f ‚â´ x) m‚ÇÅ m‚ÇÇ y h\n\n"}
{"name":"CategoryTheory.Quotient.comp_right","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\na b c : C\ng : Quiver.Hom b c\nf‚ÇÅ f‚ÇÇ : Quiver.Hom a b\nx‚úù : CategoryTheory.Quotient.CompClosure r f‚ÇÅ f‚ÇÇ\n‚ä¢ CategoryTheory.Quotient.CompClosure r (CategoryTheory.CategoryStruct.comp f‚ÇÅ g) (CategoryTheory.CategoryStruct.comp f‚ÇÇ g)","decl":"theorem comp_right {a b c : C} (g : b ‚ü∂ c) :\n    ‚àÄ (f‚ÇÅ f‚ÇÇ : a ‚ü∂ b) (_ : CompClosure r f‚ÇÅ f‚ÇÇ), CompClosure r (f‚ÇÅ ‚â´ g) (f‚ÇÇ ‚â´ g)\n  | _, _, ‚ü®x, m‚ÇÅ, m‚ÇÇ, y, h‚ü© => by simpa using CompClosure.intro x m‚ÇÅ m‚ÇÇ (y ‚â´ g) h\n\n"}
{"name":"CategoryTheory.Quotient.comp_mk","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\na b c : CategoryTheory.Quotient r\nf : Quiver.Hom a.as b.as\ng : Quiver.Hom b.as c.as\n‚ä¢ Eq (CategoryTheory.Quotient.comp r (Quot.mk (CategoryTheory.Quotient.CompClosure r) f) (Quot.mk (CategoryTheory.Quotient.CompClosure r) g)) (Quot.mk (CategoryTheory.Quotient.CompClosure r) (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\ntheorem comp_mk {a b c : Quotient r} (f : a.as ‚ü∂ b.as) (g : b.as ‚ü∂ c.as) :\n    comp r (Quot.mk _ f) (Quot.mk _ g) = Quot.mk _ (f ‚â´ g) :=\n  rfl\n\n-- Porting note: Had to manually add the proofs of `comp_id` `id_comp` and `assoc`\n"}
{"name":"CategoryTheory.Quotient.full_functor","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\n‚ä¢ (CategoryTheory.Quotient.functor r).Full","decl":"instance full_functor : (functor r).Full where\n  map_surjective f := ‚ü®Quot.out f, by simp [functor]‚ü©\n\n"}
{"name":"CategoryTheory.Quotient.essSurj_functor","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\n‚ä¢ (CategoryTheory.Quotient.functor r).EssSurj","decl":"instance essSurj_functor : (functor r).EssSurj where\n  mem_essImage Y :=\n    ‚ü®Y.as, ‚ü®eqToIso (by\n            ext\n            rfl)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Quotient.induction","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nP : {a b : CategoryTheory.Quotient r} ‚Üí Quiver.Hom a b ‚Üí Prop\nh : ‚àÄ {x y : C} (f : Quiver.Hom x y), P ((CategoryTheory.Quotient.functor r).map f)\na b : CategoryTheory.Quotient r\nf : Quiver.Hom a b\n‚ä¢ P f","decl":"protected theorem induction {P : ‚àÄ {a b : Quotient r}, (a ‚ü∂ b) ‚Üí Prop}\n    (h : ‚àÄ {x y : C} (f : x ‚ü∂ y), P ((functor r).map f)) :\n    ‚àÄ {a b : Quotient r} (f : a ‚ü∂ b), P f := by\n  rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f‚ü©\n  exact h f\n\n"}
{"name":"CategoryTheory.Quotient.sound","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\na b : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom a b\nh : r f‚ÇÅ f‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Quotient.functor r).map f‚ÇÅ) ((CategoryTheory.Quotient.functor r).map f‚ÇÇ)","decl":"protected theorem sound {a b : C} {f‚ÇÅ f‚ÇÇ : a ‚ü∂ b} (h : r f‚ÇÅ f‚ÇÇ) :\n    (functor r).map f‚ÇÅ = (functor r).map f‚ÇÇ := by\n  simpa using Quot.sound (CompClosure.intro (ùüô a) f‚ÇÅ f‚ÇÇ (ùüô b) h)\n\n"}
{"name":"CategoryTheory.Quotient.compClosure_iff_self","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nh : CategoryTheory.Congruence r\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Quotient.CompClosure r f g) (r f g)","decl":"lemma compClosure_iff_self [h : Congruence r] {X Y : C} (f g : X ‚ü∂ Y) :\n    CompClosure r f g ‚Üî r f g := by\n  constructor\n  ¬∑ intro hfg\n    induction' hfg with m m' hm\n    exact Congruence.compLeft _ (Congruence.compRight _ (by assumption))\n  ¬∑ exact CompClosure.of _ _ _\n\n"}
{"name":"CategoryTheory.Quotient.compClosure_eq_self","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nh : CategoryTheory.Congruence r\n‚ä¢ Eq (CategoryTheory.Quotient.CompClosure r) r","decl":"@[simp]\ntheorem compClosure_eq_self [h : Congruence r] :\n    CompClosure r = r := by\n  ext\n  simp only [compClosure_iff_self]\n\n"}
{"name":"CategoryTheory.Quotient.functor_map_eq_iff","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nh : CategoryTheory.Congruence r\nX Y : C\nf f' : Quiver.Hom X Y\n‚ä¢ Iff (Eq ((CategoryTheory.Quotient.functor r).map f) ((CategoryTheory.Quotient.functor r).map f')) (r f f')","decl":"theorem functor_map_eq_iff [h : Congruence r] {X Y : C} (f f' : X ‚ü∂ Y) :\n    (functor r).map f = (functor r).map f' ‚Üî r f f' := by\n  dsimp [functor]\n  rw [Equivalence.quot_mk_eq_iff, compClosure_eq_self r]\n  simpa only [compClosure_eq_self r] using h.equivalence\n\n"}
{"name":"CategoryTheory.Quotient.functor_homRel_eq_compClosure_eqvGen","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff ((CategoryTheory.Quotient.functor r).homRel f g) (Relation.EqvGen (CategoryTheory.Quotient.CompClosure r) f g)","decl":"theorem functor_homRel_eq_compClosure_eqvGen {X Y : C} (f g : X ‚ü∂ Y) :\n    (functor r).homRel f g ‚Üî Relation.EqvGen (@CompClosure C _ r X Y) f g :=\n  Quot.eq\n\n"}
{"name":"CategoryTheory.Quotient.compClosure.congruence","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\n‚ä¢ CategoryTheory.Congruence fun X Y => Relation.EqvGen (CategoryTheory.Quotient.CompClosure r)","decl":"theorem compClosure.congruence :\n    Congruence fun X Y => Relation.EqvGen (@CompClosure C _ r X Y) := by\n  convert inferInstanceAs (Congruence (functor r).homRel)\n  ext\n  rw [functor_homRel_eq_compClosure_eqvGen]\n\n"}
{"name":"CategoryTheory.Quotient.lift_spec","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\n‚ä¢ Eq ((CategoryTheory.Quotient.functor r).comp (CategoryTheory.Quotient.lift r F H)) F","decl":"theorem lift_spec : functor r ‚ãô lift r F H = F := by\n  apply Functor.ext; rotate_left\n  ¬∑ rintro X\n    rfl\n  ¬∑ rintro X Y f\n    dsimp [lift, functor]\n    simp\n\n"}
{"name":"CategoryTheory.Quotient.lift_unique","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\nŒ¶ : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nhŒ¶ : Eq ((CategoryTheory.Quotient.functor r).comp Œ¶) F\n‚ä¢ Eq Œ¶ (CategoryTheory.Quotient.lift r F H)","decl":"theorem lift_unique (Œ¶ : Quotient r ‚•§ D) (hŒ¶ : functor r ‚ãô Œ¶ = F) : Œ¶ = lift r F H := by\n  subst_vars\n  fapply Functor.hext\n  ¬∑ rintro X\n    dsimp [lift, Functor]\n    congr\n  ¬∑ rintro _ _ f\n    dsimp [lift, Functor]\n    refine Quot.inductionOn f (fun _ ‚Ü¶ ?_) -- Porting note: this line was originally an `apply`\n    simp only [heq_eq_eq]\n    congr\n\n"}
{"name":"CategoryTheory.Quotient.lift_unique'","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nh : Eq ((CategoryTheory.Quotient.functor r).comp F‚ÇÅ) ((CategoryTheory.Quotient.functor r).comp F‚ÇÇ)\n‚ä¢ Eq F‚ÇÅ F‚ÇÇ","decl":"lemma lift_unique' (F‚ÇÅ F‚ÇÇ : Quotient r ‚•§ D) (h : functor r ‚ãô F‚ÇÅ = functor r ‚ãô F‚ÇÇ) :\n    F‚ÇÅ = F‚ÇÇ := by\n  rw [lift_unique r (functor r ‚ãô F‚ÇÇ) _ F‚ÇÇ rfl]; swap\n  ¬∑ rintro X Y f g h\n    dsimp\n    rw [Quotient.sound r h]\n  apply lift_unique\n  rw [h]\n\n"}
{"name":"CategoryTheory.Quotient.lift.isLift_hom","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_4} C\nr : HomRel C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\nX : C\n‚ä¢ Eq ((CategoryTheory.Quotient.lift.isLift r F H).hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp]\ntheorem lift.isLift_hom (X : C) : (lift.isLift r F H).hom.app X = ùüô (F.obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Quotient.lift.isLift_inv","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_4} C\nr : HomRel C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_1, u_2} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\nX : C\n‚ä¢ Eq ((CategoryTheory.Quotient.lift.isLift r F H).inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp]\ntheorem lift.isLift_inv (X : C) : (lift.isLift r F H).inv.app X = ùüô (F.obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Quotient.lift_obj_functor_obj","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_4} C\nr : HomRel C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_3, u_1} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\nX : C\n‚ä¢ Eq ((CategoryTheory.Quotient.lift r F H).obj ((CategoryTheory.Quotient.functor r).obj X)) (F.obj X)","decl":"theorem lift_obj_functor_obj (X : C) :\n    (lift r F H).obj ((functor r).obj X) = F.obj X := rfl\n\n"}
{"name":"CategoryTheory.Quotient.lift_map_functor_map","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_2} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_3, u_4} D\nF : CategoryTheory.Functor C D\nH : ‚àÄ (x y : C) (f‚ÇÅ f‚ÇÇ : Quiver.Hom x y), r f‚ÇÅ f‚ÇÇ ‚Üí Eq (F.map f‚ÇÅ) (F.map f‚ÇÇ)\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Quotient.lift r F H).map ((CategoryTheory.Quotient.functor r).map f)) (F.map f)","decl":"theorem lift_map_functor_map {X Y : C} (f : X ‚ü∂ Y) :\n    (lift r F H).map ((functor r).map f) = F.map f := by\n  rw [‚Üê NatIso.naturality_1 (lift.isLift r F H)]\n  dsimp [lift, functor]\n  simp\n\n"}
{"name":"CategoryTheory.Quotient.natTrans_ext","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF G : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ‚ÇÅ œÑ‚ÇÇ : Quiver.Hom F G\nh : Eq (CategoryTheory.whiskerLeft (CategoryTheory.Quotient.functor r) œÑ‚ÇÅ) (CategoryTheory.whiskerLeft (CategoryTheory.Quotient.functor r) œÑ‚ÇÇ)\n‚ä¢ Eq œÑ‚ÇÅ œÑ‚ÇÇ","decl":"lemma natTrans_ext {F G : Quotient r ‚•§ D} (œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G)\n    (h : whiskerLeft (Quotient.functor r) œÑ‚ÇÅ = whiskerLeft (Quotient.functor r) œÑ‚ÇÇ) : œÑ‚ÇÅ = œÑ‚ÇÇ :=\n  NatTrans.ext (by ext1 ‚ü®X‚ü©; exact NatTrans.congr_app h X)\n\n"}
{"name":"CategoryTheory.Quotient.natTransLift_app","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF G : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ : Quiver.Hom ((CategoryTheory.Quotient.functor r).comp F) ((CategoryTheory.Quotient.functor r).comp G)\nX : C\n‚ä¢ Eq ((CategoryTheory.Quotient.natTransLift r œÑ).app ((CategoryTheory.Quotient.functor r).obj X)) (œÑ.app X)","decl":"@[simp]\nlemma natTransLift_app (F G : Quotient r ‚•§ D)\n    (œÑ : Quotient.functor r ‚ãô F ‚ü∂ Quotient.functor r ‚ãô G) (X : C) :\n  (natTransLift r œÑ).app ((Quotient.functor r).obj X) = œÑ.app X := rfl\n\n"}
{"name":"CategoryTheory.Quotient.comp_natTransLift_assoc","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF G H : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ : Quiver.Hom ((CategoryTheory.Quotient.functor r).comp F) ((CategoryTheory.Quotient.functor r).comp G)\nœÑ' : Quiver.Hom ((CategoryTheory.Quotient.functor r).comp G) ((CategoryTheory.Quotient.functor r).comp H)\nZ : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nh : Quiver.Hom H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quotient.natTransLift r œÑ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quotient.natTransLift r œÑ') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quotient.natTransLift r (CategoryTheory.CategoryStruct.comp œÑ œÑ')) h)","decl":"@[reassoc]\nlemma comp_natTransLift {F G H : Quotient r ‚•§ D}\n    (œÑ : Quotient.functor r ‚ãô F ‚ü∂ Quotient.functor r ‚ãô G)\n    (œÑ' : Quotient.functor r ‚ãô G ‚ü∂ Quotient.functor r ‚ãô H) :\n    natTransLift r œÑ ‚â´ natTransLift r œÑ' =  natTransLift r (œÑ ‚â´ œÑ') := by aesop_cat\n\n"}
{"name":"CategoryTheory.Quotient.comp_natTransLift","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF G H : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ : Quiver.Hom ((CategoryTheory.Quotient.functor r).comp F) ((CategoryTheory.Quotient.functor r).comp G)\nœÑ' : Quiver.Hom ((CategoryTheory.Quotient.functor r).comp G) ((CategoryTheory.Quotient.functor r).comp H)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quotient.natTransLift r œÑ) (CategoryTheory.Quotient.natTransLift r œÑ')) (CategoryTheory.Quotient.natTransLift r (CategoryTheory.CategoryStruct.comp œÑ œÑ'))","decl":"@[reassoc]\nlemma comp_natTransLift {F G H : Quotient r ‚•§ D}\n    (œÑ : Quotient.functor r ‚ãô F ‚ü∂ Quotient.functor r ‚ãô G)\n    (œÑ' : Quotient.functor r ‚ãô G ‚ü∂ Quotient.functor r ‚ãô H) :\n    natTransLift r œÑ ‚â´ natTransLift r œÑ' =  natTransLift r (œÑ ‚â´ œÑ') := by aesop_cat\n\n"}
{"name":"CategoryTheory.Quotient.natTransLift_id","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_1, u_3} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\nF : CategoryTheory.Functor (CategoryTheory.Quotient r) D\n‚ä¢ Eq (CategoryTheory.Quotient.natTransLift r (CategoryTheory.CategoryStruct.id ((CategoryTheory.Quotient.functor r).comp F))) (CategoryTheory.CategoryStruct.id F)","decl":"@[simp]\nlemma natTransLift_id (F : Quotient r ‚•§ D) :\n    natTransLift r (ùüô (Quotient.functor r ‚ãô F)) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Quotient.natIsoLift_inv","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\nF G : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ : CategoryTheory.Iso ((CategoryTheory.Quotient.functor r).comp F) ((CategoryTheory.Quotient.functor r).comp G)\n‚ä¢ Eq (CategoryTheory.Quotient.natIsoLift r œÑ).inv (CategoryTheory.Quotient.natTransLift r œÑ.inv)","decl":"/-- In order to define a natural isomorphism `F ‚âÖ G` with `F G : Quotient r ‚•§ D`, it suffices\nto do so after precomposing with `Quotient.functor r`. -/\n@[simps]\ndef natIsoLift {F G : Quotient r ‚•§ D} (œÑ : Quotient.functor r ‚ãô F ‚âÖ Quotient.functor r ‚ãô G) :\n    F ‚âÖ G where\n  hom := natTransLift _ œÑ.hom\n  inv := natTransLift _ œÑ.inv\n  hom_inv_id := by rw [comp_natTransLift, œÑ.hom_inv_id, natTransLift_id]\n  inv_hom_id := by rw [comp_natTransLift, œÑ.inv_hom_id, natTransLift_id]\n\n"}
{"name":"CategoryTheory.Quotient.natIsoLift_hom","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nr : HomRel C\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\nF G : CategoryTheory.Functor (CategoryTheory.Quotient r) D\nœÑ : CategoryTheory.Iso ((CategoryTheory.Quotient.functor r).comp F) ((CategoryTheory.Quotient.functor r).comp G)\n‚ä¢ Eq (CategoryTheory.Quotient.natIsoLift r œÑ).hom (CategoryTheory.Quotient.natTransLift r œÑ.hom)","decl":"/-- In order to define a natural isomorphism `F ‚âÖ G` with `F G : Quotient r ‚•§ D`, it suffices\nto do so after precomposing with `Quotient.functor r`. -/\n@[simps]\ndef natIsoLift {F G : Quotient r ‚•§ D} (œÑ : Quotient.functor r ‚ãô F ‚âÖ Quotient.functor r ‚ãô G) :\n    F ‚âÖ G where\n  hom := natTransLift _ œÑ.hom\n  inv := natTransLift _ œÑ.inv\n  hom_inv_id := by rw [comp_natTransLift, œÑ.hom_inv_id, natTransLift_id]\n  inv_hom_id := by rw [comp_natTransLift, œÑ.inv_hom_id, natTransLift_id]\n\n"}
{"name":"CategoryTheory.Quotient.full_whiskeringLeft_functor","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\n‚ä¢ ((CategoryTheory.whiskeringLeft C (CategoryTheory.Quotient r) D).obj (CategoryTheory.Quotient.functor r)).Full","decl":"instance full_whiskeringLeft_functor :\n    ((whiskeringLeft C _ D).obj (functor r)).Full where\n  map_surjective f := ‚ü®natTransLift r f, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Quotient.faithful_whiskeringLeft_functor","module":"Mathlib.CategoryTheory.Quotient","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nr : HomRel C\nD : Type u_4\ninst‚úù : CategoryTheory.Category.{u_2, u_4} D\n‚ä¢ ((CategoryTheory.whiskeringLeft C (CategoryTheory.Quotient r) D).obj (CategoryTheory.Quotient.functor r)).Faithful","decl":"instance faithful_whiskeringLeft_functor :\n    ((whiskeringLeft C _ D).obj (functor r)).Faithful := ‚ü®by apply natTrans_ext‚ü©\n\n"}
