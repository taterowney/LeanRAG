{"name":"Finset.le_prod_nonempty_of_submultiplicative_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : OrderedCommMonoid N\nf : M → N\np : M → Prop\nh_mul : ∀ (x y : M), p x → p y → LE.le (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhp_mul : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\ng : ι → M\ns : Finset ι\nhs_nonempty : s.Nonempty\nhs : ∀ (i : ι), Membership.mem s i → p (g i)\n⊢ LE.le (f (s.prod fun i => g i)) (s.prod fun i => f (g i))","decl":"/-- Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M → N` be a map\nsubmultiplicative on `{x | p x}`, i.e., `p x → p y → f (x * y) ≤ f x * f y`. Let `g i`, `i ∈ s`, be\na nonempty finite family of elements of `M` such that `∀ i ∈ s, p (g i)`. Then\n`f (∏ x ∈ s, g x) ≤ ∏ x ∈ s, f (g x)`. -/\n@[to_additive le_sum_nonempty_of_subadditive_on_pred]\ntheorem le_prod_nonempty_of_submultiplicative_on_pred (f : M → N) (p : M → Prop)\n    (h_mul : ∀ x y, p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ x y, p x → p y → p (x * y))\n    (g : ι → M) (s : Finset ι) (hs_nonempty : s.Nonempty) (hs : ∀ i ∈ s, p (g i)) :\n    f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  refine le_trans\n    (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ ?_ ?_) ?_\n  · simp [hs_nonempty.ne_empty]\n  · exact Multiset.forall_mem_map_iff.mpr hs\n  rw [Multiset.map_map]\n  rfl\n\n"}
{"name":"Finset.le_sum_nonempty_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : OrderedAddCommMonoid N\nf : M → N\np : M → Prop\nh_mul : ∀ (x y : M), p x → p y → LE.le (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nhp_mul : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\ng : ι → M\ns : Finset ι\nhs_nonempty : s.Nonempty\nhs : ∀ (i : ι), Membership.mem s i → p (g i)\n⊢ LE.le (f (s.sum fun i => g i)) (s.sum fun i => f (g i))","decl":"/-- Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M → N` be a map\nsubmultiplicative on `{x | p x}`, i.e., `p x → p y → f (x * y) ≤ f x * f y`. Let `g i`, `i ∈ s`, be\na nonempty finite family of elements of `M` such that `∀ i ∈ s, p (g i)`. Then\n`f (∏ x ∈ s, g x) ≤ ∏ x ∈ s, f (g x)`. -/\n@[to_additive le_sum_nonempty_of_subadditive_on_pred]\ntheorem le_prod_nonempty_of_submultiplicative_on_pred (f : M → N) (p : M → Prop)\n    (h_mul : ∀ x y, p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ x y, p x → p y → p (x * y))\n    (g : ι → M) (s : Finset ι) (hs_nonempty : s.Nonempty) (hs : ∀ i ∈ s, p (g i)) :\n    f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  refine le_trans\n    (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ ?_ ?_) ?_\n  · simp [hs_nonempty.ne_empty]\n  · exact Multiset.forall_mem_map_iff.mpr hs\n  rw [Multiset.map_map]\n  rfl\n\n"}
{"name":"Finset.le_sum_nonempty_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : OrderedAddCommMonoid N\nf : M → N\nh_mul : ∀ (x y : M), LE.le (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\ns : Finset ι\nhs : s.Nonempty\ng : ι → M\n⊢ LE.le (f (s.sum fun i => g i)) (s.sum fun i => f (g i))","decl":"/-- If `f : M → N` is a submultiplicative function, `f (x * y) ≤ f x * f y` and `g i`, `i ∈ s`, is a\nnonempty finite family of elements of `M`, then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_nonempty_of_subadditive]\ntheorem le_prod_nonempty_of_submultiplicative (f : M → N) (h_mul : ∀ x y, f (x * y) ≤ f x * f y)\n    {s : Finset ι} (hs : s.Nonempty) (g : ι → M) : f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) :=\n  le_prod_nonempty_of_submultiplicative_on_pred f (fun _ ↦ True) (fun x y _ _ ↦ h_mul x y)\n    (fun _ _ _ _ ↦ trivial) g s hs fun _ _ ↦ trivial\n\n"}
{"name":"Finset.le_prod_nonempty_of_submultiplicative","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : OrderedCommMonoid N\nf : M → N\nh_mul : ∀ (x y : M), LE.le (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ns : Finset ι\nhs : s.Nonempty\ng : ι → M\n⊢ LE.le (f (s.prod fun i => g i)) (s.prod fun i => f (g i))","decl":"/-- If `f : M → N` is a submultiplicative function, `f (x * y) ≤ f x * f y` and `g i`, `i ∈ s`, is a\nnonempty finite family of elements of `M`, then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_nonempty_of_subadditive]\ntheorem le_prod_nonempty_of_submultiplicative (f : M → N) (h_mul : ∀ x y, f (x * y) ≤ f x * f y)\n    {s : Finset ι} (hs : s.Nonempty) (g : ι → M) : f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) :=\n  le_prod_nonempty_of_submultiplicative_on_pred f (fun _ ↦ True) (fun x y _ _ ↦ h_mul x y)\n    (fun _ _ _ _ ↦ trivial) g s hs fun _ _ ↦ trivial\n\n"}
{"name":"Finset.le_prod_of_submultiplicative_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : OrderedCommMonoid N\nf : M → N\np : M → Prop\nh_one : Eq (f 1) 1\nh_mul : ∀ (x y : M), p x → p y → LE.le (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhp_mul : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\ng : ι → M\ns : Finset ι\nhs : ∀ (i : ι), Membership.mem s i → p (g i)\n⊢ LE.le (f (s.prod fun i => g i)) (s.prod fun i => f (g i))","decl":"/-- Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M → N` be a map\nsuch that `f 1 = 1` and `f` is submultiplicative on `{x | p x}`, i.e.,\n`p x → p y → f (x * y) ≤ f x * f y`. Let `g i`, `i ∈ s`, be a finite family of elements of `M` such\nthat `∀ i ∈ s, p (g i)`. Then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_of_subadditive_on_pred]\ntheorem le_prod_of_submultiplicative_on_pred (f : M → N) (p : M → Prop) (h_one : f 1 = 1)\n    (h_mul : ∀ x y, p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ x y, p x → p y → p (x * y))\n    (g : ι → M) {s : Finset ι} (hs : ∀ i ∈ s, p (g i)) : f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  rcases eq_empty_or_nonempty s with (rfl | hs_nonempty)\n  · simp [h_one]\n  · exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs\n\n"}
{"name":"Finset.le_sum_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : OrderedAddCommMonoid N\nf : M → N\np : M → Prop\nh_one : Eq (f 0) 0\nh_mul : ∀ (x y : M), p x → p y → LE.le (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nhp_mul : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\ng : ι → M\ns : Finset ι\nhs : ∀ (i : ι), Membership.mem s i → p (g i)\n⊢ LE.le (f (s.sum fun i => g i)) (s.sum fun i => f (g i))","decl":"/-- Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M → N` be a map\nsuch that `f 1 = 1` and `f` is submultiplicative on `{x | p x}`, i.e.,\n`p x → p y → f (x * y) ≤ f x * f y`. Let `g i`, `i ∈ s`, be a finite family of elements of `M` such\nthat `∀ i ∈ s, p (g i)`. Then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_of_subadditive_on_pred]\ntheorem le_prod_of_submultiplicative_on_pred (f : M → N) (p : M → Prop) (h_one : f 1 = 1)\n    (h_mul : ∀ x y, p x → p y → f (x * y) ≤ f x * f y) (hp_mul : ∀ x y, p x → p y → p (x * y))\n    (g : ι → M) {s : Finset ι} (hs : ∀ i ∈ s, p (g i)) : f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  rcases eq_empty_or_nonempty s with (rfl | hs_nonempty)\n  · simp [h_one]\n  · exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs\n\n"}
{"name":"Finset.le_prod_of_submultiplicative","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : OrderedCommMonoid N\nf : M → N\nh_one : Eq (f 1) 1\nh_mul : ∀ (x y : M), LE.le (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ns : Finset ι\ng : ι → M\n⊢ LE.le (f (s.prod fun i => g i)) (s.prod fun i => f (g i))","decl":"/-- If `f : M → N` is a submultiplicative function, `f (x * y) ≤ f x * f y`, `f 1 = 1`, and `g i`,\n`i ∈ s`, is a finite family of elements of `M`, then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_of_subadditive]\ntheorem le_prod_of_submultiplicative (f : M → N) (h_one : f 1 = 1)\n    (h_mul : ∀ x y, f (x * y) ≤ f x * f y) (s : Finset ι) (g : ι → M) :\n    f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  refine le_trans (Multiset.le_prod_of_submultiplicative f h_one h_mul _) ?_\n  rw [Multiset.map_map]\n  rfl\n\n"}
{"name":"Finset.le_sum_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : OrderedAddCommMonoid N\nf : M → N\nh_one : Eq (f 0) 0\nh_mul : ∀ (x y : M), LE.le (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\ns : Finset ι\ng : ι → M\n⊢ LE.le (f (s.sum fun i => g i)) (s.sum fun i => f (g i))","decl":"/-- If `f : M → N` is a submultiplicative function, `f (x * y) ≤ f x * f y`, `f 1 = 1`, and `g i`,\n`i ∈ s`, is a finite family of elements of `M`, then `f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i)`. -/\n@[to_additive le_sum_of_subadditive]\ntheorem le_prod_of_submultiplicative (f : M → N) (h_one : f 1 = 1)\n    (h_mul : ∀ x y, f (x * y) ≤ f x * f y) (s : Finset ι) (g : ι → M) :\n    f (∏ i ∈ s, g i) ≤ ∏ i ∈ s, f (g i) := by\n  refine le_trans (Multiset.le_prod_of_submultiplicative f h_one h_mul _) ?_\n  rw [Multiset.map_map]\n  rfl\n\n"}
{"name":"Finset.sum_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf g : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (s.sum fun i => f i) (s.sum fun i => g i)","decl":"/-- In an ordered commutative monoid, if each factor `f i` of one finite product is less than or\nequal to the corresponding factor `g i` of another finite product, then\n`∏ i ∈ s, f i ≤ ∏ i ∈ s, g i`. -/\n@[to_additive (attr := gcongr) sum_le_sum]\ntheorem prod_le_prod' (h : ∀ i ∈ s, f i ≤ g i) : ∏ i ∈ s, f i ≤ ∏ i ∈ s, g i :=\n  Multiset.prod_map_le_prod_map f g h\n\n"}
{"name":"Finset.prod_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf g : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (s.prod fun i => f i) (s.prod fun i => g i)","decl":"/-- In an ordered commutative monoid, if each factor `f i` of one finite product is less than or\nequal to the corresponding factor `g i` of another finite product, then\n`∏ i ∈ s, f i ≤ ∏ i ∈ s, g i`. -/\n@[to_additive (attr := gcongr) sum_le_sum]\ntheorem prod_le_prod' (h : ∀ i ∈ s, f i ≤ g i) : ∏ i ∈ s, f i ≤ ∏ i ∈ s, g i :=\n  Multiset.prod_map_le_prod_map f g h\n\n"}
{"name":"Finset.one_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le 1 (f i)\n⊢ LE.le 1 (s.prod fun i => f i)","decl":"@[to_additive sum_nonneg]\ntheorem one_le_prod' (h : ∀ i ∈ s, 1 ≤ f i) : 1 ≤ ∏ i ∈ s, f i :=\n  le_trans (by rw [prod_const_one]) (prod_le_prod' h)\n\n"}
{"name":"Finset.sum_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ LE.le 0 (s.sum fun i => f i)","decl":"@[to_additive sum_nonneg]\ntheorem one_le_prod' (h : ∀ i ∈ s, 1 ≤ f i) : 1 ≤ ∏ i ∈ s, f i :=\n  le_trans (by rw [prod_const_one]) (prod_le_prod' h)\n\n"}
{"name":"Finset.sum_nonneg'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), LE.le 0 (f i)\n⊢ LE.le 0 (s.sum fun i => f i)","decl":"@[to_additive Finset.sum_nonneg']\ntheorem one_le_prod'' (h : ∀ i : ι, 1 ≤ f i) : 1 ≤ ∏ i ∈ s, f i :=\n  Finset.one_le_prod' fun i _ ↦ h i\n\n"}
{"name":"Finset.one_le_prod''","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), LE.le 1 (f i)\n⊢ LE.le 1 (s.prod fun i => f i)","decl":"@[to_additive Finset.sum_nonneg']\ntheorem one_le_prod'' (h : ∀ i : ι, 1 ≤ f i) : 1 ≤ ∏ i ∈ s, f i :=\n  Finset.one_le_prod' fun i _ ↦ h i\n\n"}
{"name":"Finset.prod_le_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) 1\n⊢ LE.le (s.prod fun i => f i) 1","decl":"@[to_additive sum_nonpos]\ntheorem prod_le_one' (h : ∀ i ∈ s, f i ≤ 1) : ∏ i ∈ s, f i ≤ 1 :=\n  (prod_le_prod' h).trans_eq (by rw [prod_const_one])\n\n"}
{"name":"Finset.sum_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) 0\n⊢ LE.le (s.sum fun i => f i) 0","decl":"@[to_additive sum_nonpos]\ntheorem prod_le_one' (h : ∀ i ∈ s, f i ≤ 1) : ∏ i ∈ s, f i ≤ 1 :=\n  (prod_le_prod' h).trans_eq (by rw [prod_const_one])\n\n"}
{"name":"Finset.prod_le_prod_of_subset_of_one_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns t : Finset ι\nh : HasSubset.Subset s t\nhf : ∀ (i : ι), Membership.mem t i → Not (Membership.mem s i) → LE.le 1 (f i)\n⊢ LE.le (s.prod fun i => f i) (t.prod fun i => f i)","decl":"@[to_additive (attr := gcongr) sum_le_sum_of_subset_of_nonneg]\ntheorem prod_le_prod_of_subset_of_one_le' (h : s ⊆ t) (hf : ∀ i ∈ t, i ∉ s → 1 ≤ f i) :\n    ∏ i ∈ s, f i ≤ ∏ i ∈ t, f i := by\n  classical calc\n      ∏ i ∈ s, f i ≤ (∏ i ∈ t \\ s, f i) * ∏ i ∈ s, f i :=\n        le_mul_of_one_le_left' <| one_le_prod' <| by simpa only [mem_sdiff, and_imp]\n      _ = ∏ i ∈ t \\ s ∪ s, f i := (prod_union sdiff_disjoint).symm\n      _ = ∏ i ∈ t, f i := by rw [sdiff_union_of_subset h]\n\n"}
{"name":"Finset.sum_le_sum_of_subset_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns t : Finset ι\nh : HasSubset.Subset s t\nhf : ∀ (i : ι), Membership.mem t i → Not (Membership.mem s i) → LE.le 0 (f i)\n⊢ LE.le (s.sum fun i => f i) (t.sum fun i => f i)","decl":"@[to_additive (attr := gcongr) sum_le_sum_of_subset_of_nonneg]\ntheorem prod_le_prod_of_subset_of_one_le' (h : s ⊆ t) (hf : ∀ i ∈ t, i ∉ s → 1 ≤ f i) :\n    ∏ i ∈ s, f i ≤ ∏ i ∈ t, f i := by\n  classical calc\n      ∏ i ∈ s, f i ≤ (∏ i ∈ t \\ s, f i) * ∏ i ∈ s, f i :=\n        le_mul_of_one_le_left' <| one_le_prod' <| by simpa only [mem_sdiff, and_imp]\n      _ = ∏ i ∈ t \\ s ∪ s, f i := (prod_union sdiff_disjoint).symm\n      _ = ∏ i ∈ t, f i := by rw [sdiff_union_of_subset h]\n\n"}
{"name":"Finset.sum_mono_set_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\nhf : ∀ (x : ι), LE.le 0 (f x)\n⊢ Monotone fun s => s.sum fun x => f x","decl":"@[to_additive sum_mono_set_of_nonneg]\ntheorem prod_mono_set_of_one_le' (hf : ∀ x, 1 ≤ f x) : Monotone fun s ↦ ∏ x ∈ s, f x :=\n  fun _ _ hst ↦ prod_le_prod_of_subset_of_one_le' hst fun x _ _ ↦ hf x\n\n"}
{"name":"Finset.prod_mono_set_of_one_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\nhf : ∀ (x : ι), LE.le 1 (f x)\n⊢ Monotone fun s => s.prod fun x => f x","decl":"@[to_additive sum_mono_set_of_nonneg]\ntheorem prod_mono_set_of_one_le' (hf : ∀ x, 1 ≤ f x) : Monotone fun s ↦ ∏ x ∈ s, f x :=\n  fun _ _ hst ↦ prod_le_prod_of_subset_of_one_le' hst fun x _ _ ↦ hf x\n\n"}
{"name":"Finset.prod_le_univ_prod_of_one_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedCommMonoid N\nf : ι → N\ninst✝ : Fintype ι\ns : Finset ι\nw : ∀ (x : ι), LE.le 1 (f x)\n⊢ LE.le (s.prod fun x => f x) (Finset.univ.prod fun x => f x)","decl":"@[to_additive sum_le_univ_sum_of_nonneg]\ntheorem prod_le_univ_prod_of_one_le' [Fintype ι] {s : Finset ι} (w : ∀ x, 1 ≤ f x) :\n    ∏ x ∈ s, f x ≤ ∏ x, f x :=\n  prod_le_prod_of_subset_of_one_le' (subset_univ s) fun a _ _ ↦ w a\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO -- The two next lemmas give the same lemma in additive version\n"}
{"name":"Finset.sum_le_univ_sum_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedAddCommMonoid N\nf : ι → N\ninst✝ : Fintype ι\ns : Finset ι\nw : ∀ (x : ι), LE.le 0 (f x)\n⊢ LE.le (s.sum fun x => f x) (Finset.univ.sum fun x => f x)","decl":"@[to_additive sum_le_univ_sum_of_nonneg]\ntheorem prod_le_univ_prod_of_one_le' [Fintype ι] {s : Finset ι} (w : ∀ x, 1 ≤ f x) :\n    ∏ x ∈ s, f x ≤ ∏ x, f x :=\n  prod_le_prod_of_subset_of_one_le' (subset_univ s) fun a _ _ ↦ w a\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO -- The two next lemmas give the same lemma in additive version\n"}
{"name":"Finset.prod_eq_one_iff_of_one_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → LE.le 1 (f i)\n⊢ Iff (Eq (s.prod fun i => f i) 1) (∀ (i : ι), Membership.mem s i → Eq (f i) 1)","decl":"@[to_additive sum_eq_zero_iff_of_nonneg]\ntheorem prod_eq_one_iff_of_one_le' :\n    (∀ i ∈ s, 1 ≤ f i) → ((∏ i ∈ s, f i) = 1 ↔ ∀ i ∈ s, f i = 1) := by\n  classical\n    refine Finset.induction_on s\n      (fun _ ↦ ⟨fun _ _ h ↦ False.elim (Finset.not_mem_empty _ h), fun _ ↦ rfl⟩) ?_\n    intro a s ha ih H\n    have : ∀ i ∈ s, 1 ≤ f i := fun _ ↦ H _ ∘ mem_insert_of_mem\n    rw [prod_insert ha, mul_eq_one_iff_of_one_le (H _ <| mem_insert_self _ _) (one_le_prod' this),\n      forall_mem_insert, ih this]\n\n"}
{"name":"Finset.sum_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ Iff (Eq (s.sum fun i => f i) 0) (∀ (i : ι), Membership.mem s i → Eq (f i) 0)","decl":"@[to_additive sum_eq_zero_iff_of_nonneg]\ntheorem prod_eq_one_iff_of_one_le' :\n    (∀ i ∈ s, 1 ≤ f i) → ((∏ i ∈ s, f i) = 1 ↔ ∀ i ∈ s, f i = 1) := by\n  classical\n    refine Finset.induction_on s\n      (fun _ ↦ ⟨fun _ _ h ↦ False.elim (Finset.not_mem_empty _ h), fun _ ↦ rfl⟩) ?_\n    intro a s ha ih H\n    have : ∀ i ∈ s, 1 ≤ f i := fun _ ↦ H _ ∘ mem_insert_of_mem\n    rw [prod_insert ha, mul_eq_one_iff_of_one_le (H _ <| mem_insert_self _ _) (one_le_prod' this),\n      forall_mem_insert, ih this]\n\n"}
{"name":"Finset.sum_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → LE.le (f i) 0\n⊢ Iff (Eq (s.sum fun i => f i) 0) (∀ (i : ι), Membership.mem s i → Eq (f i) 0)","decl":"@[to_additive sum_eq_zero_iff_of_nonpos]\ntheorem prod_eq_one_iff_of_le_one' :\n    (∀ i ∈ s, f i ≤ 1) → ((∏ i ∈ s, f i) = 1 ↔ ∀ i ∈ s, f i = 1) :=\n  @prod_eq_one_iff_of_one_le' _ Nᵒᵈ _ _ _\n\n"}
{"name":"Finset.prod_eq_one_iff_of_le_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\na✝ : ∀ (i : ι), Membership.mem s i → LE.le (f i) 1\n⊢ Iff (Eq (s.prod fun i => f i) 1) (∀ (i : ι), Membership.mem s i → Eq (f i) 1)","decl":"@[to_additive sum_eq_zero_iff_of_nonpos]\ntheorem prod_eq_one_iff_of_le_one' :\n    (∀ i ∈ s, f i ≤ 1) → ((∏ i ∈ s, f i) = 1 ↔ ∀ i ∈ s, f i = 1) :=\n  @prod_eq_one_iff_of_one_le' _ Nᵒᵈ _ _ _\n\n"}
{"name":"Finset.single_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 1 (f i)\na : ι\nh : Membership.mem s a\n⊢ LE.le (f a) (s.prod fun x => f x)","decl":"@[to_additive single_le_sum]\ntheorem single_le_prod' (hf : ∀ i ∈ s, 1 ≤ f i) {a} (h : a ∈ s) : f a ≤ ∏ x ∈ s, f x :=\n  calc\n    f a = ∏ i ∈ {a}, f i := (prod_singleton _ _).symm\n    _ ≤ ∏ i ∈ s, f i :=\n      prod_le_prod_of_subset_of_one_le' (singleton_subset_iff.2 h) fun i hi _ ↦ hf i hi\n\n"}
{"name":"Finset.single_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\na : ι\nh : Membership.mem s a\n⊢ LE.le (f a) (s.sum fun x => f x)","decl":"@[to_additive single_le_sum]\ntheorem single_le_prod' (hf : ∀ i ∈ s, 1 ≤ f i) {a} (h : a ∈ s) : f a ≤ ∏ x ∈ s, f x :=\n  calc\n    f a = ∏ i ∈ {a}, f i := (prod_singleton _ _).symm\n    _ ≤ ∏ i ∈ s, f i :=\n      prod_le_prod_of_subset_of_one_le' (singleton_subset_iff.2 h) fun i hi _ ↦ hf i hi\n\n"}
{"name":"Finset.mul_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\nf : ι → N\ns : Finset ι\ni j : ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 1 (f i)\nhi : Membership.mem s i\nhj : Membership.mem s j\nhne : Ne i j\n⊢ LE.le (HMul.hMul (f i) (f j)) (s.prod fun k => f k)","decl":"@[to_additive]\nlemma mul_le_prod {i j : ι} (hf : ∀ i ∈ s, 1 ≤ f i) (hi : i ∈ s) (hj : j ∈ s) (hne : i ≠ j) :\n    f i * f j ≤ ∏ k ∈ s, f k :=\n  calc\n    f i * f j = ∏ k ∈ .cons i {j} (by simpa), f k := by rw [prod_cons, prod_singleton]\n    _ ≤ ∏ k ∈ s, f k := by\n      refine prod_le_prod_of_subset_of_one_le' ?_ fun k hk _ ↦ hf k hk\n      simp [cons_subset, *]\n\n"}
{"name":"Finset.add_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\nf : ι → N\ns : Finset ι\ni j : ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nhi : Membership.mem s i\nhj : Membership.mem s j\nhne : Ne i j\n⊢ LE.le (HAdd.hAdd (f i) (f j)) (s.sum fun k => f k)","decl":"@[to_additive]\nlemma mul_le_prod {i j : ι} (hf : ∀ i ∈ s, 1 ≤ f i) (hi : i ∈ s) (hj : j ∈ s) (hne : i ≠ j) :\n    f i * f j ≤ ∏ k ∈ s, f k :=\n  calc\n    f i * f j = ∏ k ∈ .cons i {j} (by simpa), f k := by rw [prod_cons, prod_singleton]\n    _ ≤ ∏ k ∈ s, f k := by\n      refine prod_le_prod_of_subset_of_one_le' ?_ fun k hk _ ↦ hf k hk\n      simp [cons_subset, *]\n\n"}
{"name":"Finset.sum_le_card_nsmul","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\ns : Finset ι\nf : ι → N\nn : N\nh : ∀ (x : ι), Membership.mem s x → LE.le (f x) n\n⊢ LE.le (s.sum f) (HSMul.hSMul s.card n)","decl":"@[to_additive sum_le_card_nsmul]\ntheorem prod_le_pow_card (s : Finset ι) (f : ι → N) (n : N) (h : ∀ x ∈ s, f x ≤ n) :\n    s.prod f ≤ n ^ #s := by\n  refine (Multiset.prod_le_pow_card (s.val.map f) n ?_).trans ?_\n  · simpa using h\n  · simp\n\n"}
{"name":"Finset.prod_le_pow_card","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\ns : Finset ι\nf : ι → N\nn : N\nh : ∀ (x : ι), Membership.mem s x → LE.le (f x) n\n⊢ LE.le (s.prod f) (HPow.hPow n s.card)","decl":"@[to_additive sum_le_card_nsmul]\ntheorem prod_le_pow_card (s : Finset ι) (f : ι → N) (n : N) (h : ∀ x ∈ s, f x ≤ n) :\n    s.prod f ≤ n ^ #s := by\n  refine (Multiset.prod_le_pow_card (s.val.map f) n ?_).trans ?_\n  · simpa using h\n  · simp\n\n"}
{"name":"Finset.pow_card_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedCommMonoid N\ns : Finset ι\nf : ι → N\nn : N\nh : ∀ (x : ι), Membership.mem s x → LE.le n (f x)\n⊢ LE.le (HPow.hPow n s.card) (s.prod f)","decl":"@[to_additive card_nsmul_le_sum]\ntheorem pow_card_le_prod (s : Finset ι) (f : ι → N) (n : N) (h : ∀ x ∈ s, n ≤ f x) :\n    n ^ #s ≤ s.prod f := @Finset.prod_le_pow_card _ Nᵒᵈ _ _ _ _ h\n\n"}
{"name":"Finset.card_nsmul_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝ : OrderedAddCommMonoid N\ns : Finset ι\nf : ι → N\nn : N\nh : ∀ (x : ι), Membership.mem s x → LE.le n (f x)\n⊢ LE.le (HSMul.hSMul s.card n) (s.sum f)","decl":"@[to_additive card_nsmul_le_sum]\ntheorem pow_card_le_prod (s : Finset ι) (f : ι → N) (n : N) (h : ∀ x ∈ s, n ≤ f x) :\n    n ^ #s ≤ s.prod f := @Finset.prod_le_pow_card _ Nᵒᵈ _ _ _ _ h\n\n"}
{"name":"Finset.card_biUnion_le_card_mul","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nβ : Type u_3\ninst✝ : DecidableEq β\ns : Finset ι\nf : ι → Finset β\nn : Nat\nh : ∀ (a : ι), Membership.mem s a → LE.le (f a).card n\n⊢ LE.le (s.biUnion f).card (HMul.hMul s.card n)","decl":"theorem card_biUnion_le_card_mul [DecidableEq β] (s : Finset ι) (f : ι → Finset β) (n : ℕ)\n    (h : ∀ a ∈ s, #(f a) ≤ n) : #(s.biUnion f) ≤ #s * n :=\n  card_biUnion_le.trans <| sum_le_card_nsmul _ _ _ h\n\n"}
{"name":"Finset.sum_fiberwise_le_sum_of_sum_fiber_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedAddCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\nt : Finset ι'\ng : ι → ι'\nf : ι → N\nh : ∀ (y : ι'), Not (Membership.mem t y) → LE.le 0 ((Finset.filter (fun x => Eq (g x) y) s).sum fun x => f x)\n⊢ LE.le (t.sum fun y => (Finset.filter (fun x => Eq (g x) y) s).sum fun x => f x) (s.sum fun x => f x)","decl":"@[to_additive sum_fiberwise_le_sum_of_sum_fiber_nonneg]\ntheorem prod_fiberwise_le_prod_of_one_le_prod_fiber' {t : Finset ι'} {g : ι → ι'} {f : ι → N}\n    (h : ∀ y ∉ t, (1 : N) ≤ ∏ x ∈ s with g x = y, f x) :\n    (∏ y ∈ t, ∏ x ∈ s with g x = y, f x) ≤ ∏ x ∈ s, f x :=\n  calc\n    (∏ y ∈ t, ∏ x ∈ s with g x = y, f x) ≤\n        ∏ y ∈ t ∪ s.image g, ∏ x ∈ s with g x = y, f x :=\n      prod_le_prod_of_subset_of_one_le' subset_union_left fun y _ ↦ h y\n    _ = ∏ x ∈ s, f x :=\n      prod_fiberwise_of_maps_to (fun _ hx ↦ mem_union.2 <| Or.inr <| mem_image_of_mem _ hx) _\n\n"}
{"name":"Finset.prod_fiberwise_le_prod_of_one_le_prod_fiber'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\nt : Finset ι'\ng : ι → ι'\nf : ι → N\nh : ∀ (y : ι'), Not (Membership.mem t y) → LE.le 1 ((Finset.filter (fun x => Eq (g x) y) s).prod fun x => f x)\n⊢ LE.le (t.prod fun y => (Finset.filter (fun x => Eq (g x) y) s).prod fun x => f x) (s.prod fun x => f x)","decl":"@[to_additive sum_fiberwise_le_sum_of_sum_fiber_nonneg]\ntheorem prod_fiberwise_le_prod_of_one_le_prod_fiber' {t : Finset ι'} {g : ι → ι'} {f : ι → N}\n    (h : ∀ y ∉ t, (1 : N) ≤ ∏ x ∈ s with g x = y, f x) :\n    (∏ y ∈ t, ∏ x ∈ s with g x = y, f x) ≤ ∏ x ∈ s, f x :=\n  calc\n    (∏ y ∈ t, ∏ x ∈ s with g x = y, f x) ≤\n        ∏ y ∈ t ∪ s.image g, ∏ x ∈ s with g x = y, f x :=\n      prod_le_prod_of_subset_of_one_le' subset_union_left fun y _ ↦ h y\n    _ = ∏ x ∈ s, f x :=\n      prod_fiberwise_of_maps_to (fun _ hx ↦ mem_union.2 <| Or.inr <| mem_image_of_mem _ hx) _\n\n"}
{"name":"Finset.sum_le_sum_fiberwise_of_sum_fiber_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedAddCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\nt : Finset ι'\ng : ι → ι'\nf : ι → N\nh : ∀ (y : ι'), Not (Membership.mem t y) → LE.le ((Finset.filter (fun x => Eq (g x) y) s).sum fun x => f x) 0\n⊢ LE.le (s.sum fun x => f x) (t.sum fun y => (Finset.filter (fun x => Eq (g x) y) s).sum fun x => f x)","decl":"@[to_additive sum_le_sum_fiberwise_of_sum_fiber_nonpos]\ntheorem prod_le_prod_fiberwise_of_prod_fiber_le_one' {t : Finset ι'} {g : ι → ι'} {f : ι → N}\n    (h : ∀ y ∉ t, ∏ x ∈ s with g x = y, f x ≤ 1) :\n    ∏ x ∈ s, f x ≤ ∏ y ∈ t, ∏ x ∈ s with g x = y, f x :=\n  @prod_fiberwise_le_prod_of_one_le_prod_fiber' _ Nᵒᵈ _ _ _ _ _ _ _ h\n\n"}
{"name":"Finset.prod_le_prod_fiberwise_of_prod_fiber_le_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\nt : Finset ι'\ng : ι → ι'\nf : ι → N\nh : ∀ (y : ι'), Not (Membership.mem t y) → LE.le ((Finset.filter (fun x => Eq (g x) y) s).prod fun x => f x) 1\n⊢ LE.le (s.prod fun x => f x) (t.prod fun y => (Finset.filter (fun x => Eq (g x) y) s).prod fun x => f x)","decl":"@[to_additive sum_le_sum_fiberwise_of_sum_fiber_nonpos]\ntheorem prod_le_prod_fiberwise_of_prod_fiber_le_one' {t : Finset ι'} {g : ι → ι'} {f : ι → N}\n    (h : ∀ y ∉ t, ∏ x ∈ s with g x = y, f x ≤ 1) :\n    ∏ x ∈ s, f x ≤ ∏ y ∈ t, ∏ x ∈ s with g x = y, f x :=\n  @prod_fiberwise_le_prod_of_one_le_prod_fiber' _ Nᵒᵈ _ _ _ _ _ _ _ h\n\n"}
{"name":"Finset.prod_image_le_of_one_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\ng : ι → ι'\nf : ι' → N\nhf : ∀ (u : ι'), Membership.mem (Finset.image g s) u → LE.le 1 (f u)\n⊢ LE.le ((Finset.image g s).prod fun u => f u) (s.prod fun u => f (g u))","decl":"@[to_additive]\nlemma prod_image_le_of_one_le\n    {g : ι → ι'} {f : ι' → N} (hf : ∀ u ∈ s.image g, 1 ≤ f u) :\n    ∏ u ∈ s.image g, f u ≤ ∏ u ∈ s, f (g u) := by\n  rw [prod_comp f g]\n  refine prod_le_prod' fun a hag ↦ ?_\n  obtain ⟨i, hi, hig⟩ := Finset.mem_image.mp hag\n  apply le_self_pow (hf a hag)\n  rw [← Nat.pos_iff_ne_zero, card_pos]\n  exact ⟨i, mem_filter.mpr ⟨hi, hig⟩⟩\n\n"}
{"name":"Finset.sum_image_le_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : OrderedAddCommMonoid N\ns : Finset ι\nι' : Type u_9\ninst✝ : DecidableEq ι'\ng : ι → ι'\nf : ι' → N\nhf : ∀ (u : ι'), Membership.mem (Finset.image g s) u → LE.le 0 (f u)\n⊢ LE.le ((Finset.image g s).sum fun u => f u) (s.sum fun u => f (g u))","decl":"@[to_additive]\nlemma prod_image_le_of_one_le\n    {g : ι → ι'} {f : ι' → N} (hf : ∀ u ∈ s.image g, 1 ≤ f u) :\n    ∏ u ∈ s.image g, f u ≤ ∏ u ∈ s, f (g u) := by\n  rw [prod_comp f g]\n  refine prod_le_prod' fun a hag ↦ ?_\n  obtain ⟨i, hi, hig⟩ := Finset.mem_image.mp hag\n  apply le_self_pow (hf a hag)\n  rw [← Nat.pos_iff_ne_zero, card_pos]\n  exact ⟨i, mem_filter.mpr ⟨hi, hig⟩⟩\n\n"}
{"name":"Finset.max_prod_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCommMonoid M\nf g : ι → M\ns : Finset ι\n⊢ LE.le (Max.max (s.prod f) (s.prod g)) (s.prod fun i => Max.max (f i) (g i))","decl":"@[to_additive]\nlemma max_prod_le [LinearOrderedCommMonoid M] {f g : ι → M} {s : Finset ι} :\n    max (s.prod f) (s.prod g) ≤ s.prod (fun i ↦ max (f i) (g i)) :=\n  Multiset.max_prod_le\n\n"}
{"name":"Finset.max_sum_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedAddCommMonoid M\nf g : ι → M\ns : Finset ι\n⊢ LE.le (Max.max (s.sum f) (s.sum g)) (s.sum fun i => Max.max (f i) (g i))","decl":"@[to_additive]\nlemma max_prod_le [LinearOrderedCommMonoid M] {f g : ι → M} {s : Finset ι} :\n    max (s.prod f) (s.prod g) ≤ s.prod (fun i ↦ max (f i) (g i)) :=\n  Multiset.max_prod_le\n\n"}
{"name":"Finset.prod_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCommMonoid M\nf g : ι → M\ns : Finset ι\n⊢ LE.le (s.prod fun i => Min.min (f i) (g i)) (Min.min (s.prod f) (s.prod g))","decl":"@[to_additive]\nlemma prod_min_le [LinearOrderedCommMonoid M] {f g : ι → M} {s : Finset ι} :\n    s.prod (fun i ↦ min (f i) (g i)) ≤ min (s.prod f) (s.prod g) :=\n  Multiset.prod_min_le\n\n"}
{"name":"Finset.sum_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedAddCommMonoid M\nf g : ι → M\ns : Finset ι\n⊢ LE.le (s.sum fun i => Min.min (f i) (g i)) (Min.min (s.sum f) (s.sum g))","decl":"@[to_additive]\nlemma prod_min_le [LinearOrderedCommMonoid M] {f g : ι → M} {s : Finset ι} :\n    s.prod (fun i ↦ min (f i) (g i)) ≤ min (s.prod f) (s.prod g) :=\n  Multiset.prod_min_le\n\n"}
{"name":"Finset.abs_sum_le_sum_abs","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_9\ninst✝ : LinearOrderedAddCommGroup G\nf : ι → G\ns : Finset ι\n⊢ LE.le (abs (s.sum fun i => f i)) (s.sum fun i => abs (f i))","decl":"theorem abs_sum_le_sum_abs {G : Type*} [LinearOrderedAddCommGroup G] (f : ι → G) (s : Finset ι) :\n    |∑ i ∈ s, f i| ≤ ∑ i ∈ s, |f i| := le_sum_of_subadditive _ abs_zero abs_add s f\n\n"}
{"name":"Finset.abs_sum_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_9\ninst✝ : LinearOrderedAddCommGroup G\nf : ι → G\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ Eq (abs (s.sum fun i => f i)) (s.sum fun i => f i)","decl":"theorem abs_sum_of_nonneg {G : Type*} [LinearOrderedAddCommGroup G] {f : ι → G} {s : Finset ι}\n    (hf : ∀ i ∈ s, 0 ≤ f i) : |∑ i ∈ s, f i| = ∑ i ∈ s, f i := by\n  rw [abs_of_nonneg (Finset.sum_nonneg hf)]\n\n"}
{"name":"Finset.abs_sum_of_nonneg'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_9\ninst✝ : LinearOrderedAddCommGroup G\nf : ι → G\ns : Finset ι\nhf : ∀ (i : ι), LE.le 0 (f i)\n⊢ Eq (abs (s.sum fun i => f i)) (s.sum fun i => f i)","decl":"theorem abs_sum_of_nonneg' {G : Type*} [LinearOrderedAddCommGroup G] {f : ι → G} {s : Finset ι}\n    (hf : ∀ i, 0 ≤ f i) : |∑ i ∈ s, f i| = ∑ i ∈ s, f i := by\n  rw [abs_of_nonneg (Finset.sum_nonneg' hf)]\n\n"}
{"name":"Finset.mulLECancellable_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\ns : Finset ι\nf : ι → α\n⊢ Iff (MulLECancellable (s.prod fun i => f i)) (∀ ⦃i : ι⦄, Membership.mem s i → MulLECancellable (f i))","decl":"@[to_additive (attr := simp)]\nlemma mulLECancellable_prod :\n    MulLECancellable (∏ i ∈ s, f i) ↔ ∀ ⦃i⦄, i ∈ s → MulLECancellable (f i) := by\n  induction' s using Finset.cons_induction with i s hi ih <;> simp [*]\n\n"}
{"name":"Finset.addLECancellable_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\ns : Finset ι\nf : ι → α\n⊢ Iff (AddLECancellable (s.sum fun i => f i)) (∀ ⦃i : ι⦄, Membership.mem s i → AddLECancellable (f i))","decl":"@[to_additive (attr := simp)]\nlemma mulLECancellable_prod :\n    MulLECancellable (∏ i ∈ s, f i) ↔ ∀ ⦃i⦄, i ∈ s → MulLECancellable (f i) := by\n  induction' s using Finset.cons_induction with i s hi ih <;> simp [*]\n\n"}
{"name":"Finset.card_le_mul_card_image_of_maps_to","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\nHf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nn : Nat\nhn : ∀ (b : β), Membership.mem t b → LE.le (Finset.filter (fun a => Eq (f a) b) s).card n\n⊢ LE.le s.card (HMul.hMul n t.card)","decl":"theorem card_le_mul_card_image_of_maps_to {f : α → β} {s : Finset α} {t : Finset β}\n    (Hf : ∀ a ∈ s, f a ∈ t) (n : ℕ) (hn : ∀ b ∈ t, #{a ∈ s | f a = b} ≤ n) : #s ≤ n * #t :=\n  calc\n    #s = ∑ b ∈ t, #{a ∈ s | f a = b} := card_eq_sum_card_fiberwise Hf\n    _ ≤ ∑ _b ∈ t, n := sum_le_sum hn\n    _ = _ := by simp [mul_comm]\n\n"}
{"name":"Finset.card_le_mul_card_image","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nn : Nat\nhn : ∀ (b : β), Membership.mem (Finset.image f s) b → LE.le (Finset.filter (fun a => Eq (f a) b) s).card n\n⊢ LE.le s.card (HMul.hMul n (Finset.image f s).card)","decl":"theorem card_le_mul_card_image {f : α → β} (s : Finset α) (n : ℕ)\n    (hn : ∀ b ∈ s.image f, #{a ∈ s | f a = b} ≤ n) : #s ≤ n * #(s.image f) :=\n  card_le_mul_card_image_of_maps_to (fun _ ↦ mem_image_of_mem _) n hn\n\n"}
{"name":"Finset.mul_card_image_le_card_of_maps_to","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\nHf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nn : Nat\nhn : ∀ (b : β), Membership.mem t b → LE.le n (Finset.filter (fun a => Eq (f a) b) s).card\n⊢ LE.le (HMul.hMul n t.card) s.card","decl":"theorem mul_card_image_le_card_of_maps_to {f : α → β} {s : Finset α} {t : Finset β}\n    (Hf : ∀ a ∈ s, f a ∈ t) (n : ℕ) (hn : ∀ b ∈ t, n ≤ #{a ∈ s | f a = b}) :\n    n * #t ≤ #s :=\n  calc\n    n * #t = ∑ _a ∈ t, n := by simp [mul_comm]\n    _ ≤ ∑ b ∈ t, #{a ∈ s | f a = b} := sum_le_sum hn\n    _ = #s := by rw [← card_eq_sum_card_fiberwise Hf]\n\n"}
{"name":"Finset.mul_card_image_le_card","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nn : Nat\nhn : ∀ (b : β), Membership.mem (Finset.image f s) b → LE.le n (Finset.filter (fun a => Eq (f a) b) s).card\n⊢ LE.le (HMul.hMul n (Finset.image f s).card) s.card","decl":"theorem mul_card_image_le_card {f : α → β} (s : Finset α) (n : ℕ)\n    (hn : ∀ b ∈ s.image f, n ≤ #{a ∈ s | f a = b}) : n * #(s.image f) ≤ #s :=\n  mul_card_image_le_card_of_maps_to (fun _ ↦ mem_image_of_mem _) n hn\n\n"}
{"name":"Finset.sum_card_inter_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\ns : Finset α\nB : Finset (Finset α)\nn : Nat\nh : ∀ (a : α), Membership.mem s a → LE.le (Finset.filter (fun b => Membership.mem b a) B).card n\n⊢ LE.le (B.sum fun t => (Inter.inter s t).card) (HMul.hMul s.card n)","decl":"/-- If every element belongs to at most `n` Finsets, then the sum of their sizes is at most `n`\ntimes how many they are. -/\ntheorem sum_card_inter_le (h : ∀ a ∈ s, #{b ∈ B | a ∈ b} ≤ n) : (∑ t ∈ B, #(s ∩ t)) ≤ #s * n := by\n  refine le_trans ?_ (s.sum_le_card_nsmul _ _ h)\n  simp_rw [← filter_mem_eq_inter, card_eq_sum_ones, sum_filter]\n  exact sum_comm.le\n\n"}
{"name":"Finset.sum_card_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\nB : Finset (Finset α)\nn : Nat\ninst✝ : Fintype α\nh : ∀ (a : α), LE.le (Finset.filter (fun b => Membership.mem b a) B).card n\n⊢ LE.le (B.sum fun s => s.card) (HMul.hMul (Fintype.card α) n)","decl":"/-- If every element belongs to at most `n` Finsets, then the sum of their sizes is at most `n`\ntimes how many they are. -/\nlemma sum_card_le [Fintype α] (h : ∀ a, #{b ∈ B | a ∈ b} ≤ n) : ∑ s ∈ B, #s ≤ Fintype.card α * n :=\n  calc\n    ∑ s ∈ B, #s = ∑ s ∈ B, #(univ ∩ s) := by simp_rw [univ_inter]\n    _ ≤ Fintype.card α * n := sum_card_inter_le fun a _ ↦ h a\n\n"}
{"name":"Finset.le_sum_card_inter","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\ns : Finset α\nB : Finset (Finset α)\nn : Nat\nh : ∀ (a : α), Membership.mem s a → LE.le n (Finset.filter (fun b => Membership.mem b a) B).card\n⊢ LE.le (HMul.hMul s.card n) (B.sum fun t => (Inter.inter s t).card)","decl":"/-- If every element belongs to at least `n` Finsets, then the sum of their sizes is at least `n`\ntimes how many they are. -/\ntheorem le_sum_card_inter (h : ∀ a ∈ s, n ≤ #{b ∈ B | a ∈ b}) : #s * n ≤ ∑ t ∈ B, #(s ∩ t) := by\n  apply (s.card_nsmul_le_sum _ _ h).trans\n  simp_rw [← filter_mem_eq_inter, card_eq_sum_ones, sum_filter]\n  exact sum_comm.le\n\n"}
{"name":"Finset.le_sum_card","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\nB : Finset (Finset α)\nn : Nat\ninst✝ : Fintype α\nh : ∀ (a : α), LE.le n (Finset.filter (fun b => Membership.mem b a) B).card\n⊢ LE.le (HMul.hMul (Fintype.card α) n) (B.sum fun s => s.card)","decl":"/-- If every element belongs to at least `n` Finsets, then the sum of their sizes is at least `n`\ntimes how many they are. -/\ntheorem le_sum_card [Fintype α] (h : ∀ a, n ≤ #{b ∈ B | a ∈ b}) :\n    Fintype.card α * n ≤ ∑ s ∈ B, #s :=\n  calc\n    Fintype.card α * n ≤ ∑ s ∈ B, #(univ ∩ s) := le_sum_card_inter fun a _ ↦ h a\n    _ = ∑ s ∈ B, #s := by simp_rw [univ_inter]\n\n"}
{"name":"Finset.sum_card_inter","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\ns : Finset α\nB : Finset (Finset α)\nn : Nat\nh : ∀ (a : α), Membership.mem s a → Eq (Finset.filter (fun b => Membership.mem b a) B).card n\n⊢ Eq (B.sum fun t => (Inter.inter s t).card) (HMul.hMul s.card n)","decl":"/-- If every element belongs to exactly `n` Finsets, then the sum of their sizes is `n` times how\nmany they are. -/\ntheorem sum_card_inter (h : ∀ a ∈ s, #{b ∈ B | a ∈ b} = n) :\n    (∑ t ∈ B, #(s ∩ t)) = #s * n :=\n  (sum_card_inter_le fun a ha ↦ (h a ha).le).antisymm (le_sum_card_inter fun a ha ↦ (h a ha).ge)\n\n"}
{"name":"Finset.sum_card","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\nB : Finset (Finset α)\nn : Nat\ninst✝ : Fintype α\nh : ∀ (a : α), Eq (Finset.filter (fun b => Membership.mem b a) B).card n\n⊢ Eq (B.sum fun s => s.card) (HMul.hMul (Fintype.card α) n)","decl":"/-- If every element belongs to exactly `n` Finsets, then the sum of their sizes is `n` times how\nmany they are. -/\ntheorem sum_card [Fintype α] (h : ∀ a, #{b ∈ B | a ∈ b} = n) :\n    ∑ s ∈ B, #s = Fintype.card α * n := by\n  simp_rw [Fintype.card, ← sum_card_inter fun a _ ↦ h a, univ_inter]\n\n"}
{"name":"Finset.card_le_card_biUnion","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\nhs : (↑s).PairwiseDisjoint f\nhf : ∀ (i : ι), Membership.mem s i → (f i).Nonempty\n⊢ LE.le s.card (s.biUnion f).card","decl":"theorem card_le_card_biUnion {s : Finset ι} {f : ι → Finset α} (hs : (s : Set ι).PairwiseDisjoint f)\n    (hf : ∀ i ∈ s, (f i).Nonempty) : #s ≤ #(s.biUnion f) := by\n  rw [card_biUnion hs, card_eq_sum_ones]\n  exact sum_le_sum fun i hi ↦ (hf i hi).card_pos\n\n"}
{"name":"Finset.card_le_card_biUnion_add_card_fiber","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\nhs : (↑s).PairwiseDisjoint f\n⊢ LE.le s.card (HAdd.hAdd (s.biUnion f).card (Finset.filter (fun i => Eq (f i) EmptyCollection.emptyCollection) s).card)","decl":"theorem card_le_card_biUnion_add_card_fiber {s : Finset ι} {f : ι → Finset α}\n    (hs : (s : Set ι).PairwiseDisjoint f) : #s ≤ #(s.biUnion f) + #{i ∈ s | f i = ∅} := by\n  rw [← Finset.filter_card_add_filter_neg_card_eq_card fun i ↦ f i = ∅, add_comm]\n  exact\n    add_le_add_right\n      ((card_le_card_biUnion (hs.subset <| filter_subset _ _) fun i hi ↦\n            nonempty_of_ne_empty <| (mem_filter.1 hi).2).trans <|\n        card_le_card <| biUnion_subset_biUnion_of_subset_left _ <| filter_subset _ _)\n      _\n\n"}
{"name":"Finset.card_le_card_biUnion_add_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\nhf : Function.Injective f\nhs : (↑s).PairwiseDisjoint f\n⊢ LE.le s.card (HAdd.hAdd (s.biUnion f).card 1)","decl":"theorem card_le_card_biUnion_add_one {s : Finset ι} {f : ι → Finset α} (hf : Injective f)\n    (hs : (s : Set ι).PairwiseDisjoint f) : #s ≤ #(s.biUnion f) + 1 :=\n  (card_le_card_biUnion_add_card_fiber hs).trans <|\n    add_le_add_left\n      (card_le_one.2 fun _ hi _ hj ↦ hf <| (mem_filter.1 hi).2.trans (mem_filter.1 hj).2.symm) _\n\n"}
{"name":"CanonicallyOrderedCommMonoid.single_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nf : ι → M\ns : Finset ι\ni : ι\nhi : Membership.mem s i\n⊢ LE.le (f i) (s.prod fun j => f j)","decl":"/-- In a canonically-ordered monoid, a product bounds each of its terms.\n\nSee also `Finset.single_le_prod'`. -/\n@[to_additive \"In a canonically-ordered additive monoid, a sum bounds each of its terms.\n\nSee also `Finset.single_le_sum`.\"]\nlemma _root_.CanonicallyOrderedCommMonoid.single_le_prod {i : ι} (hi : i ∈ s) :\n    f i ≤ ∏ j ∈ s, f j :=\n  single_le_prod' (fun _ _ ↦ one_le _) hi\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.single_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nf : ι → M\ns : Finset ι\ni : ι\nhi : Membership.mem s i\n⊢ LE.le (f i) (s.sum fun j => f j)","decl":"/-- In a canonically-ordered monoid, a product bounds each of its terms.\n\nSee also `Finset.single_le_prod'`. -/\n@[to_additive \"In a canonically-ordered additive monoid, a sum bounds each of its terms.\n\nSee also `Finset.single_le_sum`.\"]\nlemma _root_.CanonicallyOrderedCommMonoid.single_le_prod {i : ι} (hi : i ∈ s) :\n    f i ≤ ∏ j ∈ s, f j :=\n  single_le_prod' (fun _ _ ↦ one_le _) hi\n\n"}
{"name":"Finset.prod_eq_one_iff'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nf : ι → M\ns : Finset ι\n⊢ Iff (Eq (s.prod fun x => f x) 1) (∀ (x : ι), Membership.mem s x → Eq (f x) 1)","decl":"@[to_additive (attr := simp) sum_eq_zero_iff]\ntheorem prod_eq_one_iff' : ∏ x ∈ s, f x = 1 ↔ ∀ x ∈ s, f x = 1 :=\n  prod_eq_one_iff_of_one_le' fun x _ ↦ one_le (f x)\n\n"}
{"name":"Finset.sum_eq_zero_iff","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nf : ι → M\ns : Finset ι\n⊢ Iff (Eq (s.sum fun x => f x) 0) (∀ (x : ι), Membership.mem s x → Eq (f x) 0)","decl":"@[to_additive (attr := simp) sum_eq_zero_iff]\ntheorem prod_eq_one_iff' : ∏ x ∈ s, f x = 1 ↔ ∀ x ∈ s, f x = 1 :=\n  prod_eq_one_iff_of_one_le' fun x _ ↦ one_le (f x)\n\n"}
{"name":"Finset.prod_le_prod_of_subset'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nf : ι → M\ns t : Finset ι\nh : HasSubset.Subset s t\n⊢ LE.le (s.prod fun x => f x) (t.prod fun x => f x)","decl":"@[to_additive sum_le_sum_of_subset]\ntheorem prod_le_prod_of_subset' (h : s ⊆ t) : ∏ x ∈ s, f x ≤ ∏ x ∈ t, f x :=\n  prod_le_prod_of_subset_of_one_le' h fun _ _ _ ↦ one_le _\n\n"}
{"name":"Finset.sum_le_sum_of_subset","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nf : ι → M\ns t : Finset ι\nh : HasSubset.Subset s t\n⊢ LE.le (s.sum fun x => f x) (t.sum fun x => f x)","decl":"@[to_additive sum_le_sum_of_subset]\ntheorem prod_le_prod_of_subset' (h : s ⊆ t) : ∏ x ∈ s, f x ≤ ∏ x ∈ t, f x :=\n  prod_le_prod_of_subset_of_one_le' h fun _ _ _ ↦ one_le _\n\n"}
{"name":"Finset.sum_mono_set","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nf : ι → M\n⊢ Monotone fun s => s.sum fun x => f x","decl":"@[to_additive sum_mono_set]\ntheorem prod_mono_set' (f : ι → M) : Monotone fun s ↦ ∏ x ∈ s, f x := fun _ _ hs ↦\n  prod_le_prod_of_subset' hs\n\n"}
{"name":"Finset.prod_mono_set'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nf : ι → M\n⊢ Monotone fun s => s.prod fun x => f x","decl":"@[to_additive sum_mono_set]\ntheorem prod_mono_set' (f : ι → M) : Monotone fun s ↦ ∏ x ∈ s, f x := fun _ _ hs ↦\n  prod_le_prod_of_subset' hs\n\n"}
{"name":"Finset.prod_le_prod_of_ne_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nf : ι → M\ns t : Finset ι\nh : ∀ (x : ι), Membership.mem s x → Ne (f x) 1 → Membership.mem t x\n⊢ LE.le (s.prod fun x => f x) (t.prod fun x => f x)","decl":"@[to_additive sum_le_sum_of_ne_zero]\ntheorem prod_le_prod_of_ne_one' (h : ∀ x ∈ s, f x ≠ 1 → x ∈ t) :\n    ∏ x ∈ s, f x ≤ ∏ x ∈ t, f x := by\n  classical calc\n    ∏ x ∈ s, f x = (∏ x ∈ s with f x = 1, f x) * ∏ x ∈ s with f x ≠ 1, f x := by\n      rw [← prod_union, filter_union_filter_neg_eq]\n      exact disjoint_filter.2 fun _ _ h n_h ↦ n_h h\n    _ ≤ ∏ x ∈ t, f x :=\n      mul_le_of_le_one_of_le\n        (prod_le_one' <| by simp only [mem_filter, and_imp]; exact fun _ _ ↦ le_of_eq)\n        (prod_le_prod_of_subset' <| by simpa only [subset_iff, mem_filter, and_imp] )\n\n"}
{"name":"Finset.sum_le_sum_of_ne_zero","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nf : ι → M\ns t : Finset ι\nh : ∀ (x : ι), Membership.mem s x → Ne (f x) 0 → Membership.mem t x\n⊢ LE.le (s.sum fun x => f x) (t.sum fun x => f x)","decl":"@[to_additive sum_le_sum_of_ne_zero]\ntheorem prod_le_prod_of_ne_one' (h : ∀ x ∈ s, f x ≠ 1 → x ∈ t) :\n    ∏ x ∈ s, f x ≤ ∏ x ∈ t, f x := by\n  classical calc\n    ∏ x ∈ s, f x = (∏ x ∈ s with f x = 1, f x) * ∏ x ∈ s with f x ≠ 1, f x := by\n      rw [← prod_union, filter_union_filter_neg_eq]\n      exact disjoint_filter.2 fun _ _ h n_h ↦ n_h h\n    _ ≤ ∏ x ∈ t, f x :=\n      mul_le_of_le_one_of_le\n        (prod_le_one' <| by simp only [mem_filter, and_imp]; exact fun _ _ ↦ le_of_eq)\n        (prod_le_prod_of_subset' <| by simpa only [subset_iff, mem_filter, and_imp] )\n\n"}
{"name":"Finset.prod_lt_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf g : ι → M\ns : Finset ι\nhle : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\nhlt : Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))\n⊢ LT.lt (s.prod fun i => f i) (s.prod fun i => g i)","decl":"@[to_additive sum_lt_sum]\ntheorem prod_lt_prod' (hle : ∀ i ∈ s, f i ≤ g i) (hlt : ∃ i ∈ s, f i < g i) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i :=\n  Multiset.prod_lt_prod' hle hlt\n\n"}
{"name":"Finset.sum_lt_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf g : ι → M\ns : Finset ι\nhle : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\nhlt : Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))\n⊢ LT.lt (s.sum fun i => f i) (s.sum fun i => g i)","decl":"@[to_additive sum_lt_sum]\ntheorem prod_lt_prod' (hle : ∀ i ∈ s, f i ≤ g i) (hlt : ∃ i ∈ s, f i < g i) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i :=\n  Multiset.prod_lt_prod' hle hlt\n\n"}
{"name":"Finset.sum_lt_sum_of_nonempty","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf g : ι → M\ns : Finset ι\nhs : s.Nonempty\nhlt : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (s.sum fun i => f i) (s.sum fun i => g i)","decl":"/-- In an ordered commutative monoid, if each factor `f i` of one nontrivial finite product is\nstrictly less than the corresponding factor `g i` of another nontrivial finite product, then\n`s.prod f < s.prod g`. -/\n@[to_additive (attr := gcongr) sum_lt_sum_of_nonempty]\ntheorem prod_lt_prod_of_nonempty' (hs : s.Nonempty) (hlt : ∀ i ∈ s, f i < g i) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i :=\n  Multiset.prod_lt_prod_of_nonempty' (by aesop) hlt\n\n"}
{"name":"Finset.prod_lt_prod_of_nonempty'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf g : ι → M\ns : Finset ι\nhs : s.Nonempty\nhlt : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (s.prod fun i => f i) (s.prod fun i => g i)","decl":"/-- In an ordered commutative monoid, if each factor `f i` of one nontrivial finite product is\nstrictly less than the corresponding factor `g i` of another nontrivial finite product, then\n`s.prod f < s.prod g`. -/\n@[to_additive (attr := gcongr) sum_lt_sum_of_nonempty]\ntheorem prod_lt_prod_of_nonempty' (hs : s.Nonempty) (hlt : ∀ i ∈ s, f i < g i) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i :=\n  Multiset.prod_lt_prod_of_nonempty' (by aesop) hlt\n\n"}
{"name":"Finset.sum_lt_sum_of_subset","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns t : Finset ι\nh : HasSubset.Subset s t\ni : ι\nht : Membership.mem t i\nhs : Not (Membership.mem s i)\nhlt : LT.lt 0 (f i)\nhle : ∀ (j : ι), Membership.mem t j → Not (Membership.mem s j) → LE.le 0 (f j)\n⊢ LT.lt (s.sum fun j => f j) (t.sum fun j => f j)","decl":"@[to_additive sum_lt_sum_of_subset]\ntheorem prod_lt_prod_of_subset' (h : s ⊆ t) {i : ι} (ht : i ∈ t) (hs : i ∉ s) (hlt : 1 < f i)\n    (hle : ∀ j ∈ t, j ∉ s → 1 ≤ f j) : ∏ j ∈ s, f j < ∏ j ∈ t, f j := by\n  classical calc\n    ∏ j ∈ s, f j < ∏ j ∈ insert i s, f j := by\n      rw [prod_insert hs]\n      exact lt_mul_of_one_lt_left' (∏ j ∈ s, f j) hlt\n    _ ≤ ∏ j ∈ t, f j := by\n      apply prod_le_prod_of_subset_of_one_le'\n      · simp [Finset.insert_subset_iff, h, ht]\n      · intro x hx h'x\n        simp only [mem_insert, not_or] at h'x\n        exact hle x hx h'x.2\n\n"}
{"name":"Finset.prod_lt_prod_of_subset'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns t : Finset ι\nh : HasSubset.Subset s t\ni : ι\nht : Membership.mem t i\nhs : Not (Membership.mem s i)\nhlt : LT.lt 1 (f i)\nhle : ∀ (j : ι), Membership.mem t j → Not (Membership.mem s j) → LE.le 1 (f j)\n⊢ LT.lt (s.prod fun j => f j) (t.prod fun j => f j)","decl":"@[to_additive sum_lt_sum_of_subset]\ntheorem prod_lt_prod_of_subset' (h : s ⊆ t) {i : ι} (ht : i ∈ t) (hs : i ∉ s) (hlt : 1 < f i)\n    (hle : ∀ j ∈ t, j ∉ s → 1 ≤ f j) : ∏ j ∈ s, f j < ∏ j ∈ t, f j := by\n  classical calc\n    ∏ j ∈ s, f j < ∏ j ∈ insert i s, f j := by\n      rw [prod_insert hs]\n      exact lt_mul_of_one_lt_left' (∏ j ∈ s, f j) hlt\n    _ ≤ ∏ j ∈ t, f j := by\n      apply prod_le_prod_of_subset_of_one_le'\n      · simp [Finset.insert_subset_iff, h, ht]\n      · intro x hx h'x\n        simp only [mem_insert, not_or] at h'x\n        exact hle x hx h'x.2\n\n"}
{"name":"Finset.single_lt_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns : Finset ι\ni j : ι\nhij : Ne j i\nhi : Membership.mem s i\nhj : Membership.mem s j\nhlt : LT.lt 1 (f j)\nhle : ∀ (k : ι), Membership.mem s k → Ne k i → LE.le 1 (f k)\n⊢ LT.lt (f i) (s.prod fun k => f k)","decl":"@[to_additive single_lt_sum]\ntheorem single_lt_prod' {i j : ι} (hij : j ≠ i) (hi : i ∈ s) (hj : j ∈ s) (hlt : 1 < f j)\n    (hle : ∀ k ∈ s, k ≠ i → 1 ≤ f k) : f i < ∏ k ∈ s, f k :=\n  calc\n    f i = ∏ k ∈ {i}, f k := by rw [prod_singleton]\n    _ < ∏ k ∈ s, f k :=\n      prod_lt_prod_of_subset' (singleton_subset_iff.2 hi) hj (mt mem_singleton.1 hij) hlt\n        fun k hks hki ↦ hle k hks (mt mem_singleton.2 hki)\n\n"}
{"name":"Finset.single_lt_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns : Finset ι\ni j : ι\nhij : Ne j i\nhi : Membership.mem s i\nhj : Membership.mem s j\nhlt : LT.lt 0 (f j)\nhle : ∀ (k : ι), Membership.mem s k → Ne k i → LE.le 0 (f k)\n⊢ LT.lt (f i) (s.sum fun k => f k)","decl":"@[to_additive single_lt_sum]\ntheorem single_lt_prod' {i j : ι} (hij : j ≠ i) (hi : i ∈ s) (hj : j ∈ s) (hlt : 1 < f j)\n    (hle : ∀ k ∈ s, k ≠ i → 1 ≤ f k) : f i < ∏ k ∈ s, f k :=\n  calc\n    f i = ∏ k ∈ {i}, f k := by rw [prod_singleton]\n    _ < ∏ k ∈ s, f k :=\n      prod_lt_prod_of_subset' (singleton_subset_iff.2 hi) hj (mt mem_singleton.1 hij) hlt\n        fun k hks hki ↦ hle k hks (mt mem_singleton.2 hki)\n\n"}
{"name":"Finset.sum_pos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nhs : s.Nonempty\n⊢ LT.lt 0 (s.sum fun i => f i)","decl":"@[to_additive sum_pos]\ntheorem one_lt_prod (h : ∀ i ∈ s, 1 < f i) (hs : s.Nonempty) : 1 < ∏ i ∈ s, f i :=\n  lt_of_le_of_lt (by rw [prod_const_one]) <| prod_lt_prod_of_nonempty' hs h\n\n"}
{"name":"Finset.one_lt_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LT.lt 1 (f i)\nhs : s.Nonempty\n⊢ LT.lt 1 (s.prod fun i => f i)","decl":"@[to_additive sum_pos]\ntheorem one_lt_prod (h : ∀ i ∈ s, 1 < f i) (hs : s.Nonempty) : 1 < ∏ i ∈ s, f i :=\n  lt_of_le_of_lt (by rw [prod_const_one]) <| prod_lt_prod_of_nonempty' hs h\n\n"}
{"name":"Finset.prod_lt_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LT.lt (f i) 1\nhs : s.Nonempty\n⊢ LT.lt (s.prod fun i => f i) 1","decl":"@[to_additive]\ntheorem prod_lt_one (h : ∀ i ∈ s, f i < 1) (hs : s.Nonempty) : ∏ i ∈ s, f i < 1 :=\n  (prod_lt_prod_of_nonempty' hs h).trans_le (by rw [prod_const_one])\n\n"}
{"name":"Finset.sum_neg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LT.lt (f i) 0\nhs : s.Nonempty\n⊢ LT.lt (s.sum fun i => f i) 0","decl":"@[to_additive]\ntheorem prod_lt_one (h : ∀ i ∈ s, f i < 1) (hs : s.Nonempty) : ∏ i ∈ s, f i < 1 :=\n  (prod_lt_prod_of_nonempty' hs h).trans_le (by rw [prod_const_one])\n\n"}
{"name":"Finset.one_lt_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le 1 (f i)\nhs : Exists fun i => And (Membership.mem s i) (LT.lt 1 (f i))\n⊢ LT.lt 1 (s.prod fun i => f i)","decl":"@[to_additive sum_pos']\ntheorem one_lt_prod' (h : ∀ i ∈ s, 1 ≤ f i) (hs : ∃ i ∈ s, 1 < f i) : 1 < ∏ i ∈ s, f i :=\n  prod_const_one.symm.trans_lt <| prod_lt_prod' h hs\n\n"}
{"name":"Finset.sum_pos'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nhs : Exists fun i => And (Membership.mem s i) (LT.lt 0 (f i))\n⊢ LT.lt 0 (s.sum fun i => f i)","decl":"@[to_additive sum_pos']\ntheorem one_lt_prod' (h : ∀ i ∈ s, 1 ≤ f i) (hs : ∃ i ∈ s, 1 < f i) : 1 < ∏ i ∈ s, f i :=\n  prod_const_one.symm.trans_lt <| prod_lt_prod' h hs\n\n"}
{"name":"Finset.prod_lt_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) 1\nhs : Exists fun i => And (Membership.mem s i) (LT.lt (f i) 1)\n⊢ LT.lt (s.prod fun i => f i) 1","decl":"@[to_additive]\ntheorem prod_lt_one' (h : ∀ i ∈ s, f i ≤ 1) (hs : ∃ i ∈ s, f i < 1) : ∏ i ∈ s, f i < 1 :=\n  prod_const_one.le.trans_lt' <| prod_lt_prod' h hs\n\n"}
{"name":"Finset.sum_neg'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) 0\nhs : Exists fun i => And (Membership.mem s i) (LT.lt (f i) 0)\n⊢ LT.lt (s.sum fun i => f i) 0","decl":"@[to_additive]\ntheorem prod_lt_one' (h : ∀ i ∈ s, f i ≤ 1) (hs : ∃ i ∈ s, f i < 1) : ∏ i ∈ s, f i < 1 :=\n  prod_const_one.le.trans_lt' <| prod_lt_prod' h hs\n\n"}
{"name":"Finset.sum_eq_sum_iff_of_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelAddCommMonoid M\ns : Finset ι\nf g : ι → M\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ Iff (Eq (s.sum fun i => f i) (s.sum fun i => g i)) (∀ (i : ι), Membership.mem s i → Eq (f i) (g i))","decl":"@[to_additive]\ntheorem prod_eq_prod_iff_of_le {f g : ι → M} (h : ∀ i ∈ s, f i ≤ g i) :\n    ((∏ i ∈ s, f i) = ∏ i ∈ s, g i) ↔ ∀ i ∈ s, f i = g i := by\n  classical\n    revert h\n    refine Finset.induction_on s (fun _ ↦ ⟨fun _ _ h ↦ False.elim (Finset.not_mem_empty _ h),\n      fun _ ↦ rfl⟩) fun a s ha ih H ↦ ?_\n    specialize ih fun i ↦ H i ∘ Finset.mem_insert_of_mem\n    rw [Finset.prod_insert ha, Finset.prod_insert ha, Finset.forall_mem_insert, ← ih]\n    exact\n      mul_eq_mul_iff_eq_and_eq (H a (s.mem_insert_self a))\n        (Finset.prod_le_prod' fun i ↦ H i ∘ Finset.mem_insert_of_mem)\n\n"}
{"name":"Finset.prod_eq_prod_iff_of_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : OrderedCancelCommMonoid M\ns : Finset ι\nf g : ι → M\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ Iff (Eq (s.prod fun i => f i) (s.prod fun i => g i)) (∀ (i : ι), Membership.mem s i → Eq (f i) (g i))","decl":"@[to_additive]\ntheorem prod_eq_prod_iff_of_le {f g : ι → M} (h : ∀ i ∈ s, f i ≤ g i) :\n    ((∏ i ∈ s, f i) = ∏ i ∈ s, g i) ↔ ∀ i ∈ s, f i = g i := by\n  classical\n    revert h\n    refine Finset.induction_on s (fun _ ↦ ⟨fun _ _ h ↦ False.elim (Finset.not_mem_empty _ h),\n      fun _ ↦ rfl⟩) fun a s ha ih H ↦ ?_\n    specialize ih fun i ↦ H i ∘ Finset.mem_insert_of_mem\n    rw [Finset.prod_insert ha, Finset.prod_insert ha, Finset.forall_mem_insert, ← ih]\n    exact\n      mul_eq_mul_iff_eq_and_eq (H a (s.mem_insert_self a))\n        (Finset.prod_le_prod' fun i ↦ H i ∘ Finset.mem_insert_of_mem)\n\n"}
{"name":"Finset.prod_sdiff_le_prod_sdiff","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCancelCommMonoid M\nf : ι → M\ns t : Finset ι\ninst✝ : DecidableEq ι\n⊢ Iff (LE.le ((SDiff.sdiff s t).prod fun i => f i) ((SDiff.sdiff t s).prod fun i => f i)) (LE.le (s.prod fun i => f i) (t.prod fun i => f i))","decl":"@[to_additive] lemma prod_sdiff_le_prod_sdiff :\n    ∏ i ∈ s \\ t, f i ≤ ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i ≤ ∏ i ∈ t, f i := by\n  rw [← mul_le_mul_iff_right, ← prod_union (disjoint_sdiff_inter _ _), sdiff_union_inter,\n    ← prod_union, inter_comm, sdiff_union_inter]\n  simpa only [inter_comm] using disjoint_sdiff_inter t s\n\n"}
{"name":"Finset.sum_sdiff_le_sum_sdiff","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCancelAddCommMonoid M\nf : ι → M\ns t : Finset ι\ninst✝ : DecidableEq ι\n⊢ Iff (LE.le ((SDiff.sdiff s t).sum fun i => f i) ((SDiff.sdiff t s).sum fun i => f i)) (LE.le (s.sum fun i => f i) (t.sum fun i => f i))","decl":"@[to_additive] lemma prod_sdiff_le_prod_sdiff :\n    ∏ i ∈ s \\ t, f i ≤ ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i ≤ ∏ i ∈ t, f i := by\n  rw [← mul_le_mul_iff_right, ← prod_union (disjoint_sdiff_inter _ _), sdiff_union_inter,\n    ← prod_union, inter_comm, sdiff_union_inter]\n  simpa only [inter_comm] using disjoint_sdiff_inter t s\n\n"}
{"name":"Finset.prod_sdiff_lt_prod_sdiff","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCancelCommMonoid M\nf : ι → M\ns t : Finset ι\ninst✝ : DecidableEq ι\n⊢ Iff (LT.lt ((SDiff.sdiff s t).prod fun i => f i) ((SDiff.sdiff t s).prod fun i => f i)) (LT.lt (s.prod fun i => f i) (t.prod fun i => f i))","decl":"@[to_additive] lemma prod_sdiff_lt_prod_sdiff :\n    ∏ i ∈ s \\ t, f i < ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i < ∏ i ∈ t, f i := by\n  rw [← mul_lt_mul_iff_right, ← prod_union (disjoint_sdiff_inter _ _), sdiff_union_inter,\n    ← prod_union, inter_comm, sdiff_union_inter]\n  simpa only [inter_comm] using disjoint_sdiff_inter t s\n\n"}
{"name":"Finset.sum_sdiff_lt_sum_sdiff","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : OrderedCancelAddCommMonoid M\nf : ι → M\ns t : Finset ι\ninst✝ : DecidableEq ι\n⊢ Iff (LT.lt ((SDiff.sdiff s t).sum fun i => f i) ((SDiff.sdiff t s).sum fun i => f i)) (LT.lt (s.sum fun i => f i) (t.sum fun i => f i))","decl":"@[to_additive] lemma prod_sdiff_lt_prod_sdiff :\n    ∏ i ∈ s \\ t, f i < ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i < ∏ i ∈ t, f i := by\n  rw [← mul_lt_mul_iff_right, ← prod_union (disjoint_sdiff_inter _ _), sdiff_union_inter,\n    ← prod_union, inter_comm, sdiff_union_inter]\n  simpa only [inter_comm] using disjoint_sdiff_inter t s\n\n"}
{"name":"Finset.exists_lt_of_prod_lt'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelCommMonoid M\nf g : ι → M\ns : Finset ι\nHlt : LT.lt (s.prod fun i => f i) (s.prod fun i => g i)\n⊢ Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))","decl":"@[to_additive exists_lt_of_sum_lt]\ntheorem exists_lt_of_prod_lt' (Hlt : ∏ i ∈ s, f i < ∏ i ∈ s, g i) : ∃ i ∈ s, f i < g i := by\n  contrapose! Hlt with Hle\n  exact prod_le_prod' Hle\n\n"}
{"name":"Finset.exists_lt_of_sum_lt","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelAddCommMonoid M\nf g : ι → M\ns : Finset ι\nHlt : LT.lt (s.sum fun i => f i) (s.sum fun i => g i)\n⊢ Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))","decl":"@[to_additive exists_lt_of_sum_lt]\ntheorem exists_lt_of_prod_lt' (Hlt : ∏ i ∈ s, f i < ∏ i ∈ s, g i) : ∃ i ∈ s, f i < g i := by\n  contrapose! Hlt with Hle\n  exact prod_le_prod' Hle\n\n"}
{"name":"Finset.exists_le_of_prod_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelCommMonoid M\nf g : ι → M\ns : Finset ι\nhs : s.Nonempty\nHle : LE.le (s.prod fun i => f i) (s.prod fun i => g i)\n⊢ Exists fun i => And (Membership.mem s i) (LE.le (f i) (g i))","decl":"@[to_additive exists_le_of_sum_le]\ntheorem exists_le_of_prod_le' (hs : s.Nonempty) (Hle : ∏ i ∈ s, f i ≤ ∏ i ∈ s, g i) :\n    ∃ i ∈ s, f i ≤ g i := by\n  contrapose! Hle with Hlt\n  exact prod_lt_prod_of_nonempty' hs Hlt\n\n"}
{"name":"Finset.exists_le_of_sum_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelAddCommMonoid M\nf g : ι → M\ns : Finset ι\nhs : s.Nonempty\nHle : LE.le (s.sum fun i => f i) (s.sum fun i => g i)\n⊢ Exists fun i => And (Membership.mem s i) (LE.le (f i) (g i))","decl":"@[to_additive exists_le_of_sum_le]\ntheorem exists_le_of_prod_le' (hs : s.Nonempty) (Hle : ∏ i ∈ s, f i ≤ ∏ i ∈ s, g i) :\n    ∃ i ∈ s, f i ≤ g i := by\n  contrapose! Hle with Hlt\n  exact prod_lt_prod_of_nonempty' hs Hlt\n\n"}
{"name":"Finset.exists_pos_of_sum_zero_of_exists_nonzero","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelAddCommMonoid M\ns : Finset ι\nf : ι → M\nh₁ : Eq (s.sum fun i => f i) 0\nh₂ : Exists fun i => And (Membership.mem s i) (Ne (f i) 0)\n⊢ Exists fun i => And (Membership.mem s i) (LT.lt 0 (f i))","decl":"@[to_additive exists_pos_of_sum_zero_of_exists_nonzero]\ntheorem exists_one_lt_of_prod_one_of_exists_ne_one' (f : ι → M) (h₁ : ∏ i ∈ s, f i = 1)\n    (h₂ : ∃ i ∈ s, f i ≠ 1) : ∃ i ∈ s, 1 < f i := by\n  contrapose! h₁\n  obtain ⟨i, m, i_ne⟩ : ∃ i ∈ s, f i ≠ 1 := h₂\n  apply ne_of_lt\n  calc\n    ∏ j ∈ s, f j < ∏ j ∈ s, 1 := prod_lt_prod' h₁ ⟨i, m, (h₁ i m).lt_of_ne i_ne⟩\n    _ = 1 := prod_const_one\n\n"}
{"name":"Finset.exists_one_lt_of_prod_one_of_exists_ne_one'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : LinearOrderedCancelCommMonoid M\ns : Finset ι\nf : ι → M\nh₁ : Eq (s.prod fun i => f i) 1\nh₂ : Exists fun i => And (Membership.mem s i) (Ne (f i) 1)\n⊢ Exists fun i => And (Membership.mem s i) (LT.lt 1 (f i))","decl":"@[to_additive exists_pos_of_sum_zero_of_exists_nonzero]\ntheorem exists_one_lt_of_prod_one_of_exists_ne_one' (f : ι → M) (h₁ : ∏ i ∈ s, f i = 1)\n    (h₂ : ∃ i ∈ s, f i ≠ 1) : ∃ i ∈ s, 1 < f i := by\n  contrapose! h₁\n  obtain ⟨i, m, i_ne⟩ : ∃ i ∈ s, f i ≠ 1 := h₂\n  apply ne_of_lt\n  calc\n    ∏ j ∈ s, f j < ∏ j ∈ s, 1 := prod_lt_prod' h₁ ⟨i, m, (h₁ i m).lt_of_ne i_ne⟩\n    _ = 1 := prod_const_one\n\n"}
{"name":"Fintype.sum_mono","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedAddCommMonoid M\n⊢ Monotone fun f => Finset.univ.sum fun i => f i","decl":"@[to_additive (attr := mono) sum_mono]\ntheorem prod_mono' : Monotone fun f : ι → M ↦ ∏ i, f i := fun _ _ hfg ↦\n  Finset.prod_le_prod' fun x _ ↦ hfg x\n\n"}
{"name":"Fintype.prod_mono'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCommMonoid M\n⊢ Monotone fun f => Finset.univ.prod fun i => f i","decl":"@[to_additive (attr := mono) sum_mono]\ntheorem prod_mono' : Monotone fun f : ι → M ↦ ∏ i, f i := fun _ _ hfg ↦\n  Finset.prod_le_prod' fun x _ ↦ hfg x\n\n"}
{"name":"Fintype.one_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCommMonoid M\nf : ι → M\nhf : LE.le 1 f\n⊢ LE.le 1 (Finset.univ.prod fun i => f i)","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod (hf : 1 ≤ f) : 1 ≤ ∏ i, f i := Finset.one_le_prod' fun _ _ ↦ hf _\n\n"}
{"name":"Fintype.sum_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedAddCommMonoid M\nf : ι → M\nhf : LE.le 0 f\n⊢ LE.le 0 (Finset.univ.sum fun i => f i)","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod (hf : 1 ≤ f) : 1 ≤ ∏ i, f i := Finset.one_le_prod' fun _ _ ↦ hf _\n\n"}
{"name":"Fintype.prod_le_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCommMonoid M\nf : ι → M\nhf : LE.le f 1\n⊢ LE.le (Finset.univ.prod fun i => f i) 1","decl":"@[to_additive] lemma prod_le_one (hf : f ≤ 1) : ∏ i, f i ≤ 1 := Finset.prod_le_one' fun _ _ ↦ hf _\n\n"}
{"name":"Fintype.sum_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedAddCommMonoid M\nf : ι → M\nhf : LE.le f 0\n⊢ LE.le (Finset.univ.sum fun i => f i) 0","decl":"@[to_additive] lemma prod_le_one (hf : f ≤ 1) : ∏ i, f i ≤ 1 := Finset.prod_le_one' fun _ _ ↦ hf _\n\n"}
{"name":"Fintype.prod_eq_one_iff_of_one_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCommMonoid M\nf : ι → M\nhf : LE.le 1 f\n⊢ Iff (Eq (Finset.univ.prod fun i => f i) 1) (Eq f 1)","decl":"@[to_additive]\nlemma prod_eq_one_iff_of_one_le (hf : 1 ≤ f) : ∏ i, f i = 1 ↔ f = 1 :=\n  (Finset.prod_eq_one_iff_of_one_le' fun i _ ↦ hf i).trans <| by simp [funext_iff]\n\n"}
{"name":"Fintype.sum_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedAddCommMonoid M\nf : ι → M\nhf : LE.le 0 f\n⊢ Iff (Eq (Finset.univ.sum fun i => f i) 0) (Eq f 0)","decl":"@[to_additive]\nlemma prod_eq_one_iff_of_one_le (hf : 1 ≤ f) : ∏ i, f i = 1 ↔ f = 1 :=\n  (Finset.prod_eq_one_iff_of_one_le' fun i _ ↦ hf i).trans <| by simp [funext_iff]\n\n"}
{"name":"Fintype.sum_eq_zero_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedAddCommMonoid M\nf : ι → M\nhf : LE.le f 0\n⊢ Iff (Eq (Finset.univ.sum fun i => f i) 0) (Eq f 0)","decl":"@[to_additive]\nlemma prod_eq_one_iff_of_le_one (hf : f ≤ 1) : ∏ i, f i = 1 ↔ f = 1 :=\n  (Finset.prod_eq_one_iff_of_le_one' fun i _ ↦ hf i).trans <| by simp [funext_iff]\n\n"}
{"name":"Fintype.prod_eq_one_iff_of_le_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCommMonoid M\nf : ι → M\nhf : LE.le f 1\n⊢ Iff (Eq (Finset.univ.prod fun i => f i) 1) (Eq f 1)","decl":"@[to_additive]\nlemma prod_eq_one_iff_of_le_one (hf : f ≤ 1) : ∏ i, f i = 1 ↔ f = 1 :=\n  (Finset.prod_eq_one_iff_of_le_one' fun i _ ↦ hf i).trans <| by simp [funext_iff]\n\n"}
{"name":"Fintype.sum_strictMono","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelAddCommMonoid M\n⊢ StrictMono fun f => Finset.univ.sum fun x => f x","decl":"@[to_additive sum_strictMono]\ntheorem prod_strictMono' : StrictMono fun f : ι → M ↦ ∏ x, f x :=\n  fun _ _ hfg ↦\n  let ⟨hle, i, hlt⟩ := Pi.lt_def.mp hfg\n  Finset.prod_lt_prod' (fun i _ ↦ hle i) ⟨i, Finset.mem_univ i, hlt⟩\n\n"}
{"name":"Fintype.prod_strictMono'","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelCommMonoid M\n⊢ StrictMono fun f => Finset.univ.prod fun x => f x","decl":"@[to_additive sum_strictMono]\ntheorem prod_strictMono' : StrictMono fun f : ι → M ↦ ∏ x, f x :=\n  fun _ _ hfg ↦\n  let ⟨hle, i, hlt⟩ := Pi.lt_def.mp hfg\n  Finset.prod_lt_prod' (fun i _ ↦ hle i) ⟨i, Finset.mem_univ i, hlt⟩\n\n"}
{"name":"Fintype.sum_pos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\nhf : LT.lt 0 f\n⊢ LT.lt 0 (Finset.univ.sum fun i => f i)","decl":"@[to_additive sum_pos]\nlemma one_lt_prod (hf : 1 < f) : 1 < ∏ i, f i :=\n  Finset.one_lt_prod' (fun _ _ ↦ hf.le _) <| by simpa using (Pi.lt_def.1 hf).2\n\n"}
{"name":"Fintype.one_lt_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\nhf : LT.lt 1 f\n⊢ LT.lt 1 (Finset.univ.prod fun i => f i)","decl":"@[to_additive sum_pos]\nlemma one_lt_prod (hf : 1 < f) : 1 < ∏ i, f i :=\n  Finset.one_lt_prod' (fun _ _ ↦ hf.le _) <| by simpa using (Pi.lt_def.1 hf).2\n\n"}
{"name":"Fintype.prod_lt_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\nhf : LT.lt f 1\n⊢ LT.lt (Finset.univ.prod fun i => f i) 1","decl":"@[to_additive]\nlemma prod_lt_one (hf : f < 1) : ∏ i, f i < 1 :=\n  Finset.prod_lt_one' (fun _ _ ↦ hf.le _) <| by simpa using (Pi.lt_def.1 hf).2\n\n"}
{"name":"Fintype.sum_neg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\nhf : LT.lt f 0\n⊢ LT.lt (Finset.univ.sum fun i => f i) 0","decl":"@[to_additive]\nlemma prod_lt_one (hf : f < 1) : ∏ i, f i < 1 :=\n  Finset.prod_lt_one' (fun _ _ ↦ hf.le _) <| by simpa using (Pi.lt_def.1 hf).2\n\n"}
{"name":"Fintype.sum_pos_iff_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\nhf : LE.le 0 f\n⊢ Iff (LT.lt 0 (Finset.univ.sum fun i => f i)) (LT.lt 0 f)","decl":"@[to_additive sum_pos_iff_of_nonneg]\nlemma one_lt_prod_iff_of_one_le (hf : 1 ≤ f) : 1 < ∏ i, f i ↔ 1 < f := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, one_lt_prod]\n\n"}
{"name":"Fintype.one_lt_prod_iff_of_one_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\nhf : LE.le 1 f\n⊢ Iff (LT.lt 1 (Finset.univ.prod fun i => f i)) (LT.lt 1 f)","decl":"@[to_additive sum_pos_iff_of_nonneg]\nlemma one_lt_prod_iff_of_one_le (hf : 1 ≤ f) : 1 < ∏ i, f i ↔ 1 < f := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, one_lt_prod]\n\n"}
{"name":"Fintype.prod_lt_one_iff_of_le_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\nhf : LE.le f 1\n⊢ Iff (LT.lt (Finset.univ.prod fun i => f i) 1) (LT.lt f 1)","decl":"@[to_additive]\nlemma prod_lt_one_iff_of_le_one (hf : f ≤ 1) : ∏ i, f i < 1 ↔ f < 1 := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, prod_lt_one]\n\n"}
{"name":"Fintype.sum_neg_iff_of_nonpos","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\nhf : LE.le f 0\n⊢ Iff (LT.lt (Finset.univ.sum fun i => f i) 0) (LT.lt f 0)","decl":"@[to_additive]\nlemma prod_lt_one_iff_of_le_one (hf : f ≤ 1) : ∏ i, f i < 1 ↔ f < 1 := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, prod_lt_one]\n\n"}
{"name":"Multiset.finset_sum_eq_sup_iff_disjoint","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\ni : Finset β\nf : β → Multiset α\n⊢ Iff (Eq (i.sum f) (i.sup f)) (∀ (x : β), Membership.mem i x → ∀ (y : β), Membership.mem i y → Ne x y → Disjoint (f x) (f y))","decl":"theorem finset_sum_eq_sup_iff_disjoint [DecidableEq α] {i : Finset β} {f : β → Multiset α} :\n    i.sum f = i.sup f ↔ ∀ x ∈ i, ∀ y ∈ i, x ≠ y → Disjoint (f x) (f y) := by\n  induction' i using Finset.cons_induction_on with z i hz hr\n  · simp only [Finset.not_mem_empty, IsEmpty.forall_iff, imp_true_iff, Finset.sum_empty,\n      Finset.sup_empty, bot_eq_zero, eq_self_iff_true]\n  · simp_rw [Finset.sum_cons hz, Finset.sup_cons, Finset.mem_cons, Multiset.sup_eq_union,\n      forall_eq_or_imp, Ne, not_true_eq_false, IsEmpty.forall_iff, true_and,\n      imp_and, forall_and, ← hr, @eq_comm _ z]\n    have := fun x (H : x ∈ i) => ne_of_mem_of_not_mem H hz\n    simp +contextual only [this, not_false_iff, true_imp_iff]\n    simp_rw [← disjoint_finset_sum_left, ← disjoint_finset_sum_right, disjoint_comm, ← and_assoc,\n      and_self_iff]\n    exact add_eq_union_left_of_le (Finset.sup_le fun x hx => le_sum_of_mem (mem_map_of_mem f hx))\n\n"}
{"name":"Multiset.sup_powerset_len","module":"Mathlib.Algebra.Order.BigOperators.Group.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nx : Multiset α\n⊢ Eq ((Finset.range (HAdd.hAdd x.card 1)).sup fun k => Multiset.powersetCard k x) x.powerset","decl":"theorem sup_powerset_len [DecidableEq α] (x : Multiset α) :\n    (Finset.sup (Finset.range (card x + 1)) fun k => x.powersetCard k) = x.powerset := by\n  convert bind_powerset_len x using 1\n  rw [Multiset.bind, Multiset.join, ← Finset.range_val, ← Finset.sum_eq_multiset_sum]\n  exact\n    Eq.symm (finset_sum_eq_sup_iff_disjoint.mpr fun _ _ _ _ h => pairwise_disjoint_powersetCard x h)\n\n"}
