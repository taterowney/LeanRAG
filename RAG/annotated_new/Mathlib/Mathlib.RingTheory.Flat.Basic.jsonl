{"name":"LinearMap.rTensor_injective_of_fg","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nh : ∀ (N' : Submodule R N) (P' : Submodule R P), N'.FG → P'.FG → ∀ (h : LE.le N' (Submodule.comap f P')), Function.Injective ⇑(LinearMap.rTensor M (f.restrict h))\n⊢ Function.Injective ⇑(LinearMap.rTensor M f)","decl":"theorem _root_.LinearMap.rTensor_injective_of_fg {f : N →ₗ[R] P}\n    (h :  ∀ (N' : Submodule R N) (P' : Submodule R P),\n      N'.FG → P'.FG → ∀ h : N' ≤ P'.comap f, Function.Injective ((f.restrict h).rTensor M)) :\n    Function.Injective (f.rTensor M) := fun x y eq ↦ by\n  have ⟨N', Nfg, sub⟩ := Submodule.exists_fg_le_subset_range_rTensor_subtype {x, y} (by simp)\n  obtain ⟨x, rfl⟩ := sub (.inl rfl)\n  obtain ⟨y, rfl⟩ := sub (.inr rfl)\n  simp_rw [← rTensor_comp_apply, show f ∘ₗ N'.subtype = (N'.map f).subtype ∘ₗ f.submoduleMap N'\n    from rfl, rTensor_comp_apply] at eq\n  have ⟨P', Pfg, le, eq⟩ := (Nfg.map _).exists_rTensor_fg_inclusion_eq eq\n  simp_rw [← rTensor_comp_apply] at eq\n  rw [h _ _ Nfg Pfg (map_le_iff_le_comap.mp le) eq]\n\n"}
{"name":"LinearMap.rTensor_injective_iff_subtype","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\nQ : Type u_3\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective ⇑f\ne : LinearEquiv (RingHom.id R) P Q\n⊢ Iff (Function.Injective ⇑(LinearMap.rTensor M f)) (Function.Injective ⇑(LinearMap.rTensor M (LinearMap.range ((↑e).comp f)).subtype))","decl":"lemma _root_.LinearMap.rTensor_injective_iff_subtype {f : N →ₗ[R] P} (hf : Function.Injective f)\n    (e : P ≃ₗ[R] Q) : Function.Injective (f.rTensor M) ↔\n      Function.Injective ((range <| e.toLinearMap ∘ₗ f).subtype.rTensor M) := by\n  simp_rw [← EquivLike.injective_comp <| (LinearEquiv.ofInjective (e.toLinearMap ∘ₗ f)\n    (e.injective.comp hf)).rTensor M, ← EquivLike.comp_injective _ (e.rTensor M),\n    ← LinearEquiv.coe_coe, ← coe_comp, LinearEquiv.coe_rTensor,  ← rTensor_comp]\n  rfl\n\n"}
{"name":"Module.flat_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃P : Type u⦄ [inst : AddCommMonoid P] [inst_1 : Module R P] [inst_2 : Module.Finite R P] (N : Submodule R P), N.FG → Function.Injective ⇑(LinearMap.rTensor M N.subtype))","decl":"variable (R M) in\n/-- An `R`-module `M` is flat if for every finitely generated submodule `N` of every\nfinitely generated `R`-module `P` in the same universe as `R`,\nthe canonical map `N ⊗ M → P ⊗ M` is injective. This implies the same is true for\narbitrary `R`-modules `N` and `P` and injective linear maps `N →ₗ[R] P`, see\n`Flat.rTensor_preserves_injective_linearMap`. To show a module over a ring `R` is flat, it\nsuffices to consider the case `P = R`, see `Flat.iff_rTensor_injective`. -/\n@[mk_iff] class Flat : Prop where\n  out ⦃P : Type u⦄ [AddCommMonoid P] [Module R P] [Module.Finite R P] (N : Submodule R P) : N.FG →\n    Function.Injective (N.subtype.rTensor M)\n\n"}
{"name":"Module.Flat.out","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nself : Module.Flat R M\nP : Type u\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R P\ninst✝ : Module.Finite R P\nN : Submodule R P\na✝ : N.FG\n⊢ Function.Injective ⇑(LinearMap.rTensor M N.subtype)","decl":"variable (R M) in\n/-- An `R`-module `M` is flat if for every finitely generated submodule `N` of every\nfinitely generated `R`-module `P` in the same universe as `R`,\nthe canonical map `N ⊗ M → P ⊗ M` is injective. This implies the same is true for\narbitrary `R`-modules `N` and `P` and injective linear maps `N →ₗ[R] P`, see\n`Flat.rTensor_preserves_injective_linearMap`. To show a module over a ring `R` is flat, it\nsuffices to consider the case `P = R`, see `Flat.iff_rTensor_injective`. -/\n@[mk_iff] class Flat : Prop where\n  out ⦃P : Type u⦄ [AddCommMonoid P] [Module R P] [Module.Finite R P] (N : Submodule R P) : N.FG →\n    Function.Injective (N.subtype.rTensor M)\n\n"}
{"name":"Module.Flat.rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R P\ninst✝ : Module.Flat R M\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(LinearMap.rTensor M f)","decl":"/-- If `M` is a flat module, then `f ⊗ 𝟙 M` is injective for all injective linear maps `f`. -/\ntheorem rTensor_preserves_injective_linearMap [Flat R M] (f : N →ₗ[R] P)\n    (hf : Function.Injective f) : Function.Injective (f.rTensor M) := by\n  refine rTensor_injective_of_fg fun N P Nfg Pfg le ↦ ?_\n  rw [← Finite.iff_fg] at Nfg Pfg\n  have := Finite.small R P\n  let se := (Shrink.linearEquiv.{_, u} P R).symm\n  have := Module.Finite.equiv se\n  rw [rTensor_injective_iff_subtype (fun _ _ ↦ (Subtype.ext <| hf <| Subtype.ext_iff.mp ·)) se]\n  exact (flat_iff R M).mp ‹_› _ (Finite.iff_fg.mp inferInstance)\n\n"}
{"name":"Module.Flat.lTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R P\ninst✝ : Module.Flat R M\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(LinearMap.lTensor M f)","decl":"/-- If `M` is a flat module, then `𝟙 M ⊗ f` is injective for all injective linear maps `f`. -/\ntheorem lTensor_preserves_injective_linearMap [Flat R M] (f : N →ₗ[R] P)\n    (hf : Function.Injective f) : Function.Injective (f.lTensor M) :=\n  (f.lTensor_inj_iff_rTensor_inj M).2 (rTensor_preserves_injective_linearMap f hf)\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMapₛ","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type v'⦄ [inst : AddCommMonoid N] [inst_1 : AddCommMonoid N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f ⊗ 𝟙 M` is injective whenever `f` is an injective linear map\nin a universe that `R` fits in. -/\nlemma iff_rTensor_preserves_injective_linearMapₛ [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' : Type v'⦄ [AddCommMonoid N] [AddCommMonoid N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.rTensor M) :=\n  ⟨by introv _; apply rTensor_preserves_injective_linearMap, fun h ↦ ⟨fun P _ _ _ _ _ ↦ by\n    have := Finite.small.{v'} R P\n    rw [rTensor_injective_iff_subtype Subtype.val_injective (Shrink.linearEquiv.{_, v'} P R).symm]\n    exact h _ Subtype.val_injective⟩⟩\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMapₛ","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type v'⦄ [inst : AddCommMonoid N] [inst_1 : AddCommMonoid N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `𝟙 M ⊗ f` is injective whenever `f` is an injective linear map\nin a universe that `R` fits in. -/\nlemma iff_lTensor_preserves_injective_linearMapₛ [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' : Type v'⦄ [AddCommMonoid N] [AddCommMonoid N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.lTensor M) := by\n  simp_rw [iff_rTensor_preserves_injective_linearMapₛ, LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.iff_rTensor_injectiveₛ","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃P : Type u⦄ [inst : AddCommMonoid P] [inst_1 : Module R P] (N : Submodule R P), Function.Injective ⇑(LinearMap.rTensor M N.subtype))","decl":"/-- An easier-to-use version of `Module.flat_iff`, with finiteness conditions removed. -/\nlemma iff_rTensor_injectiveₛ : Flat R M ↔ ∀ ⦃P : Type u⦄ [AddCommMonoid P] [Module R P]\n    (N : Submodule R P), Function.Injective (N.subtype.rTensor M) :=\n  ⟨fun _ _ _ _ _ ↦ rTensor_preserves_injective_linearMap _ Subtype.val_injective,\n    fun h ↦ ⟨fun _ _ _ _ _ _ ↦ h _⟩⟩\n\n"}
{"name":"Module.Flat.iff_lTensor_injectiveₛ","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃P : Type u⦄ [inst : AddCommMonoid P] [inst_1 : Module R P] (N : Submodule R P), Function.Injective ⇑(LinearMap.lTensor M N.subtype))","decl":"lemma iff_lTensor_injectiveₛ : Flat R M ↔ ∀ ⦃P : Type u⦄ [AddCommMonoid P] [Module R P]\n    (N : Submodule R P), Function.Injective (N.subtype.lTensor M) := by\n  simp_rw [iff_rTensor_injectiveₛ, LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.instSubalgebraToSubmodule","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nS : Type v\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nA : Subalgebra R S\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\n⊢ Module.Flat R (Subtype fun x => Membership.mem (Subalgebra.toSubmodule A) x)","decl":"instance instSubalgebraToSubmodule {S : Type v} [Semiring S] [Algebra R S]\n    (A : Subalgebra R S) [Flat R A] : Flat R A.toSubmodule := ‹Flat R A›\n\n"}
{"name":"Module.Flat.self","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Module.Flat R R","decl":"instance self : Flat R R where\n  out _ _ _ _ I _ := by\n    rw [← (TensorProduct.rid R I).symm.injective_comp, ← (TensorProduct.rid R _).comp_injective]\n    convert Subtype.coe_injective using 1\n    ext; simp\n\n"}
{"name":"Module.Flat.of_retract","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : Module.Flat R M\ni : LinearMap (RingHom.id R) N M\nr : LinearMap (RingHom.id R) M N\nh : Eq (r.comp i) LinearMap.id\n⊢ Module.Flat R N","decl":"/-- A retract of a flat `R`-module is flat. -/\nlemma of_retract [f : Flat R M] (i : N →ₗ[R] M) (r : M →ₗ[R] N) (h : r.comp i = LinearMap.id) :\n    Flat R N := by\n  rw [iff_rTensor_injectiveₛ] at *\n  refine fun P _ _ Q ↦ .of_comp (f := lTensor P i) ?_\n  rw [← coe_comp, lTensor_comp_rTensor, ← rTensor_comp_lTensor, coe_comp]\n  refine (f Q).comp (Function.RightInverse.injective (g := lTensor Q r) fun x ↦ ?_)\n  simp [← comp_apply, ← lTensor_comp, h]\n\n"}
{"name":"Module.Flat.of_linearEquiv","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module.Flat R M\ne : LinearEquiv (RingHom.id R) N M\n⊢ Module.Flat R N","decl":"/-- A `R`-module linearly equivalent to a flat `R`-module is flat. -/\nlemma of_linearEquiv [Flat R M] (e : N ≃ₗ[R] M) : Flat R N :=\n  of_retract e.toLinearMap e.symm (by simp)\n\n"}
{"name":"Module.Flat.equiv_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ Iff (Module.Flat R M) (Module.Flat R N)","decl":"/-- If an `R`-module `M` is linearly equivalent to another `R`-module `N`, then `M` is flat\n  if and only if `N` is flat. -/\nlemma equiv_iff (e : M ≃ₗ[R] N) : Flat R M ↔ Flat R N :=\n  ⟨fun _ ↦ of_linearEquiv e.symm, fun _ ↦ of_linearEquiv e⟩\n\n"}
{"name":"Module.Flat.ulift","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Flat R M\n⊢ Module.Flat R (ULift.{v', v} M)","decl":"instance ulift [Flat R M] : Flat R (ULift.{v'} M) :=\n  of_linearEquiv ULift.moduleEquiv\n\n-- Making this an instance causes an infinite sequence `M → ULift M → ULift (ULift M) → ...`.\n"}
{"name":"Module.Flat.of_ulift","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Flat R (ULift.{v', v} M)\n⊢ Module.Flat R M","decl":"lemma of_ulift [Flat R (ULift.{v'} M)] : Flat R M :=\n  of_linearEquiv ULift.moduleEquiv.symm\n\n"}
{"name":"Module.Flat.shrink","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Small.{v', v} M\ninst✝ : Module.Flat R M\n⊢ Module.Flat R (Shrink.{v', v} M)","decl":"instance shrink [Small.{v'} M] [Flat R M] : Flat R (Shrink.{v'} M) :=\n  of_linearEquiv (Shrink.linearEquiv M R)\n\n-- Making this an instance causes an infinite sequence `M → Shrink M → Shrink (Shrink M) → ...`.\n"}
{"name":"Module.Flat.of_shrink","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Small.{v', v} M\ninst✝ : Module.Flat R (Shrink.{v', v} M)\n⊢ Module.Flat R M","decl":"lemma of_shrink [Small.{v'} M] [Flat R (Shrink.{v'} M)] : Flat R M :=\n  of_linearEquiv (Shrink.linearEquiv M R).symm\n\n"}
{"name":"Module.Flat.directSum_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\n⊢ Iff (Module.Flat R (DirectSum ι fun i => M i)) (∀ (i : ι), Module.Flat R (M i))","decl":"theorem directSum_iff : Flat R (⨁ i, M i) ↔ ∀ i, Flat R (M i) := by\n  classical\n  simp_rw [iff_rTensor_injectiveₛ, ← EquivLike.comp_injective _ (directSumRight R _ _),\n    ← LinearEquiv.coe_coe, ← coe_comp, directSumRight_comp_rTensor, coe_comp, LinearEquiv.coe_coe,\n    EquivLike.injective_comp, lmap_injective]\n  constructor <;> (intro h; intros; apply h)\n\n"}
{"name":"Module.Flat.dfinsupp_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\n⊢ Iff (Module.Flat R (DFinsupp fun i => M i)) (∀ (i : ι), Module.Flat R (M i))","decl":"theorem dfinsupp_iff : Flat R (Π₀ i, M i) ↔ ∀ i, Flat R (M i) := directSum_iff ..\n\n"}
{"name":"Module.Flat.directSum","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Flat R (M i)\n⊢ Module.Flat R (DirectSum ι fun i => M i)","decl":"/-- A direct sum of flat `R`-modules is flat. -/\ninstance directSum [∀ i, Flat R (M i)] : Flat R (⨁ i, M i) := directSum_iff.mpr ‹_›\n\n"}
{"name":"Module.Flat.dfinsupp","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Flat R (M i)\n⊢ Module.Flat R (DFinsupp fun i => M i)","decl":"instance dfinsupp [∀ i, Flat R (M i)] : Flat R (Π₀ i, M i) := dfinsupp_iff.mpr ‹_›\n\n"}
{"name":"Module.Flat.finsupp","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type v\n⊢ Module.Flat R (Finsupp ι R)","decl":"/-- Free `R`-modules over discrete types are flat. -/\ninstance finsupp (ι : Type v) : Flat R (ι →₀ R) := by\n  classical exact of_linearEquiv (finsuppLEquivDirectSum R R ι)\n\n"}
{"name":"Module.Flat.of_projective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R M\n⊢ Module.Flat R M","decl":"instance of_projective [Projective R M] : Flat R M :=\n  have ⟨e, he⟩:= Module.projective_def'.mp ‹_›\n  of_retract _ _ he\n\n"}
{"name":"Module.Flat.of_projective_surjective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R M\n⊢ Module.Flat R M","decl":"@[deprecated (since := \"2024-12-26\")] alias of_projective_surjective := of_projective\n\n"}
{"name":"Module.Flat.of_free","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Module.Flat R M","decl":"instance of_free [Free R M] : Flat R M := inferInstance\n\n"}
{"name":"Module.Flat.instTensorProduct","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\nS : Type u_4\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Module.Flat S M\ninst✝ : Module.Flat R N\n⊢ Module.Flat S (TensorProduct R M N)","decl":"instance {S} [CommSemiring S] [Algebra R S] [Module S M] [IsScalarTower R S M]\n    [Flat S M] [Flat R N] : Flat S (M ⊗[R] N) :=\n  iff_rTensor_injectiveₛ.mpr fun P _ _ I ↦ by\n    letI := RestrictScalars.moduleOrig R S P\n    change Submodule S (RestrictScalars R S P) at I\n    change Function.Injective (rTensor _ I.subtype)\n    simpa [AlgebraTensorModule.rTensor_tensor] using\n      rTensor_preserves_injective_linearMap (.restrictScalars R <| I.subtype.rTensor M)\n      (rTensor_preserves_injective_linearMap _ I.injective_subtype)\n\n"}
{"name":"Module.Flat.linearIndependent_one_tmul","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\ninst✝ : Module.Flat R S\nι : Type u_5\nv : ι → M\nhv : LinearIndependent R v\n⊢ LinearIndependent S fun x => TensorProduct.tmul R 1 (v x)","decl":"theorem linearIndependent_one_tmul {S} [Semiring S] [Algebra R S] [Flat R S] {ι} {v : ι → M}\n    (hv : LinearIndependent R v) : LinearIndependent S ((1 : S) ⊗ₜ[R] v ·) := by\n  classical rw [LinearIndependent, ← LinearMap.coe_restrictScalars R,\n    Finsupp.linearCombination_one_tmul]\n  simpa using lTensor_preserves_injective_linearMap _ hv\n\n"}
{"name":"Module.Flat.tensorProduct_mapIncl_injective_of_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\np : Submodule R M\nq : Submodule R N\ninst✝¹ : Module.Flat R M\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem q x)\n⊢ Function.Injective ⇑(TensorProduct.mapIncl p q)","decl":"/-- If p and q are submodules of M and N respectively, and M and q are flat,\nthen `p ⊗ q → M ⊗ N` is injective. -/\ntheorem tensorProduct_mapIncl_injective_of_right\n    [Flat R M] [Flat R q] : Function.Injective (mapIncl p q) := by\n  rw [mapIncl, ← lTensor_comp_rTensor]\n  exact (lTensor_preserves_injective_linearMap _ q.injective_subtype).comp\n    (rTensor_preserves_injective_linearMap _ p.injective_subtype)\n\n"}
{"name":"Module.Flat.tensorProduct_mapIncl_injective_of_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\np : Submodule R M\nq : Submodule R N\ninst✝¹ : Module.Flat R (Subtype fun x => Membership.mem p x)\ninst✝ : Module.Flat R N\n⊢ Function.Injective ⇑(TensorProduct.mapIncl p q)","decl":"/-- If p and q are submodules of M and N respectively, and N and p are flat,\nthen `p ⊗ q → M ⊗ N` is injective. -/\ntheorem tensorProduct_mapIncl_injective_of_left\n    [Flat R p] [Flat R N] : Function.Injective (mapIncl p q) := by\n  rw [mapIncl, ← rTensor_comp_lTensor]\n  exact (rTensor_preserves_injective_linearMap _ p.injective_subtype).comp\n    (lTensor_preserves_injective_linearMap _ q.injective_subtype)\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMap'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type v'⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f ⊗ 𝟙 M` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_rTensor_preserves_injective_linearMap` to specialize the universe of\n  `N, N', N''` to `Type (max u v)`. -/\nlemma iff_rTensor_preserves_injective_linearMap' [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' : Type v'⦄ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.rTensor M) :=\n  ⟨by introv _; apply rTensor_preserves_injective_linearMap, fun h ↦\n    iff_rTensor_preserves_injective_linearMapₛ.mpr fun P N _ _ _ _ ↦ by\n      letI := Module.addCommMonoidToAddCommGroup R (M := P)\n      letI := Module.addCommMonoidToAddCommGroup R (M := N)\n      apply h⟩\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type (max u v)⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f ⊗ 𝟙 M` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_rTensor_preserves_injective_linearMap'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\nlemma iff_rTensor_preserves_injective_linearMap : Flat R M ↔\n    ∀ ⦃N N' : Type (max u v)⦄ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.rTensor M) :=\n  iff_rTensor_preserves_injective_linearMap'\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMap'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type v'⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `𝟙 M ⊗ f` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_lTensor_preserves_injective_linearMap` to specialize the universe of\n  `N, N', N''` to `Type (max u v)`. -/\nlemma iff_lTensor_preserves_injective_linearMap' [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' : Type v'⦄ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.lTensor M) := by\n  simp_rw [iff_rTensor_preserves_injective_linearMap', LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' : Type (max u v)⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `𝟙 M ⊗ f` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_lTensor_preserves_injective_linearMap'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\nlemma iff_lTensor_preserves_injective_linearMap : Flat R M ↔\n    ∀ ⦃N N' : Type (max u v)⦄ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.lTensor M) :=\n  iff_lTensor_preserves_injective_linearMap'\n\n"}
{"name":"Module.Flat.injective_characterModule_iff_rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Injective R (CharacterModule M)) (∀ ⦃N N' : Type v⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective ⇑f → Function.Injective ⇑(LinearMap.rTensor M f))","decl":"/--\nDefine the character module of `M` to be `M →+ ℚ ⧸ ℤ`.\nThe character module of `M` is an injective module if and only if\n `f ⊗ 𝟙 M` is injective for any linear map `f` in the same universe as `M`.\n-/\nlemma injective_characterModule_iff_rTensor_preserves_injective_linearMap :\n    Module.Injective R (CharacterModule M) ↔\n    ∀ ⦃N N' : Type v⦄ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N →ₗ[R] N'), Function.Injective f → Function.Injective (f.rTensor M) := by\n  simp_rw [injective_iff, rTensor_injective_iff_lcomp_surjective, Surjective, DFunLike.ext_iff]; rfl\n\n"}
{"name":"Module.Flat.iff_characterModule_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v, u} R\n⊢ Iff (Module.Flat R M) (Module.Injective R (CharacterModule M))","decl":"/-- `CharacterModule M` is an injective module iff `M` is flat.\nSee [Lambek_1964] for a self-contained proof. -/\ntheorem iff_characterModule_injective [Small.{v} R] :\n    Flat R M ↔ Module.Injective R (CharacterModule M) := by\n  rw [injective_characterModule_iff_rTensor_preserves_injective_linearMap,\n    iff_rTensor_preserves_injective_linearMap']\n\n"}
{"name":"Module.Flat.iff_characterModule_baer","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (Module.Baer R (CharacterModule M))","decl":"/-- `CharacterModule M` is Baer iff `M` is flat. -/\ntheorem iff_characterModule_baer : Flat R M ↔ Baer R (CharacterModule M) := by\n  rw [equiv_iff (N := ULift.{u} M) ULift.moduleEquiv.symm, iff_characterModule_injective,\n    ← Baer.iff_injective, Baer.congr (CharacterModule.congr ULift.moduleEquiv)]\n\n"}
{"name":"Module.Flat.iff_rTensor_injective'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ (I : Ideal R), Function.Injective ⇑(LinearMap.rTensor M (Submodule.subtype I)))","decl":"/-- An `R`-module `M` is flat iff for all ideals `I` of `R`, the tensor product of the\ninclusion `I → R` and the identity `M → M` is injective. See `iff_rTensor_injective` to\nrestrict to finitely generated ideals `I`. --/\ntheorem iff_rTensor_injective' :\n    Flat R M ↔ ∀ I : Ideal R, Function.Injective (rTensor M I.subtype) := by\n  simp_rw [iff_characterModule_baer, Baer, rTensor_injective_iff_lcomp_surjective,\n    Surjective, DFunLike.ext_iff, Subtype.forall]\n  rfl\n\n"}
{"name":"Module.Flat.iff_lTensor_injective'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ (I : Ideal R), Function.Injective ⇑(LinearMap.lTensor M (Submodule.subtype I)))","decl":"/-- The `lTensor`-variant of `iff_rTensor_injective'`. . -/\ntheorem iff_lTensor_injective' :\n    Flat R M ↔ ∀ (I : Ideal R), Function.Injective (lTensor M I.subtype) := by\n  simpa [← comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective'\n\n"}
{"name":"Module.Flat.iff_rTensor_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃I : Ideal R⦄, I.FG → Function.Injective ⇑(LinearMap.rTensor M (Submodule.subtype I)))","decl":"/-- A module `M` over a ring `R` is flat iff for all finitely generated ideals `I` of `R`, the\ntensor product of the inclusion `I → R` and the identity `M → M` is injective. See\n`iff_rTensor_injective'` to extend to all ideals `I`. -/\nlemma iff_rTensor_injective :\n    Flat R M ↔ ∀ ⦃I : Ideal R⦄, I.FG → Function.Injective (I.subtype.rTensor M) := by\n  refine iff_rTensor_injective'.trans ⟨fun h I _ ↦ h I,\n    fun h I ↦ (injective_iff_map_eq_zero _).mpr fun x hx ↦ ?_⟩\n  obtain ⟨J, hfg, hle, y, rfl⟩ := Submodule.exists_fg_le_eq_rTensor_inclusion x\n  rw [← rTensor_comp_apply] at hx\n  rw [(injective_iff_map_eq_zero _).mp (h hfg) y hx, map_zero]\n\n"}
{"name":"Module.Flat.iff_lTensor_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃I : Ideal R⦄, I.FG → Function.Injective ⇑(LinearMap.lTensor M (Submodule.subtype I)))","decl":"/-- The `lTensor`-variant of `iff_rTensor_injective`. -/\ntheorem iff_lTensor_injective :\n    Flat R M ↔ ∀ ⦃I : Ideal R⦄, I.FG → Function.Injective (I.subtype.lTensor M) := by\n  simpa [← comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective\n\n"}
{"name":"Module.Flat.iff_lift_lsmul_comp_subtype_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃I : Ideal R⦄, I.FG → Function.Injective ⇑(TensorProduct.lift ((LinearMap.lsmul R M).comp (Submodule.subtype I))))","decl":"/-- An `R`-module `M` is flat if for all finitely generated ideals `I` of `R`,\nthe canonical map `I ⊗ M →ₗ M` is injective. -/\nlemma iff_lift_lsmul_comp_subtype_injective : Flat R M ↔ ∀ ⦃I : Ideal R⦄, I.FG →\n    Function.Injective (TensorProduct.lift ((lsmul R M).comp I.subtype)) := by\n  simp [iff_rTensor_injective, ← lid_comp_rTensor]\n\n"}
{"name":"Module.Flat.lTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module.Flat R M\nN : Type u_1\nN' : Type u_2\nN'' : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : AddCommGroup N'\ninst✝³ : AddCommGroup N''\ninst✝² : Module R N\ninst✝¹ : Module R N'\ninst✝ : Module R N''\nf : LinearMap (RingHom.id R) N N'\ng : LinearMap (RingHom.id R) N' N''\nexact : Function.Exact ⇑f ⇑g\n⊢ Function.Exact ⇑(LinearMap.lTensor M f) ⇑(LinearMap.lTensor M g)","decl":"variable (M) in\n/-- If `M` is flat then `M ⊗ -` is an exact functor. -/\nlemma lTensor_exact [Flat R M] ⦃N N' N'' : Type*⦄\n    [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N''] [Module R N] [Module R N'] [Module R N'']\n    ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄ (exact : Function.Exact f g) :\n    Function.Exact (f.lTensor M) (g.lTensor M) := by\n  let π : N' →ₗ[R] N' ⧸ LinearMap.range f := Submodule.mkQ _\n  let ι : N' ⧸ LinearMap.range f →ₗ[R] N'' :=\n    Submodule.subtype _ ∘ₗ (LinearMap.quotKerEquivRange g).toLinearMap ∘ₗ\n      Submodule.quotEquivOfEq (LinearMap.range f) (LinearMap.ker g)\n        (LinearMap.exact_iff.mp exact).symm\n  suffices exact1 : Function.Exact (f.lTensor M) (π.lTensor M) by\n    rw [show g = ι.comp π from rfl, lTensor_comp]\n    exact exact1.comp_injective _ (lTensor_preserves_injective_linearMap ι <| by\n      simpa [ι, - Subtype.val_injective] using Subtype.val_injective) (map_zero _)\n  exact _root_.lTensor_exact _ (fun x ↦ by simp [π]) Quotient.mk''_surjective\n\n"}
{"name":"Module.Flat.rTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module.Flat R M\nN : Type u_1\nN' : Type u_2\nN'' : Type u_3\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : AddCommGroup N'\ninst✝³ : AddCommGroup N''\ninst✝² : Module R N\ninst✝¹ : Module R N'\ninst✝ : Module R N''\nf : LinearMap (RingHom.id R) N N'\ng : LinearMap (RingHom.id R) N' N''\nexact : Function.Exact ⇑f ⇑g\n⊢ Function.Exact ⇑(LinearMap.rTensor M f) ⇑(LinearMap.rTensor M g)","decl":"variable (M) in\n/-- If `M` is flat then `- ⊗ M` is an exact functor. -/\nlemma rTensor_exact [Flat R M] ⦃N N' N'' : Type*⦄\n    [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N''] [Module R N] [Module R N'] [Module R N'']\n    ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄ (exact : Function.Exact f g) :\n    Function.Exact (f.rTensor M) (g.rTensor M) := by\n  let π : N' →ₗ[R] N' ⧸ LinearMap.range f := Submodule.mkQ _\n  let ι : N' ⧸ LinearMap.range f →ₗ[R] N'' :=\n    Submodule.subtype _ ∘ₗ (LinearMap.quotKerEquivRange g).toLinearMap ∘ₗ\n      Submodule.quotEquivOfEq (LinearMap.range f) (LinearMap.ker g)\n        (LinearMap.exact_iff.mp exact).symm\n  suffices exact1 : Function.Exact (f.rTensor M) (π.rTensor M) by\n    rw [show g = ι.comp π from rfl, rTensor_comp]\n    exact exact1.comp_injective _ (rTensor_preserves_injective_linearMap ι <| by\n      simpa [ι, - Subtype.val_injective] using Subtype.val_injective) (map_zero _)\n  exact _root_.rTensor_exact M (fun x ↦ by simp [π]) Quotient.mk''_surjective\n\n"}
{"name":"Module.Flat.iff_lTensor_exact'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' N'' : Type v'⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] ⦃f : LinearMap (RingHom.id R) N N'⦄ ⦃g : LinearMap (RingHom.id R) N' N''⦄, Function.Exact ⇑f ⇑g → Function.Exact ⇑(LinearMap.lTensor M f) ⇑(LinearMap.lTensor M g))","decl":"/-- `M` is flat if and only if `M ⊗ -` is an exact functor. See\n  `Module.Flat.iff_lTensor_exact` to specialize the universe of `N, N', N''` to `Type (max u v)`. -/\ntheorem iff_lTensor_exact' [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' N'' : Type v'⦄ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄,\n        Function.Exact f g → Function.Exact (f.lTensor M) (g.lTensor M) := by\n  refine ⟨fun _ ↦ lTensor_exact _, fun H ↦ iff_lTensor_preserves_injective_linearMap'.mpr\n    fun N' N'' _ _ _ _ L hL ↦ LinearMap.ker_eq_bot |>.mp <| eq_bot_iff |>.mpr\n      fun x (hx : _ = 0) ↦ ?_⟩\n  simpa [Eq.comm] using @H PUnit N' N'' _ _ _ _ _ _ 0 L (fun x ↦ by\n    simp_rw [Set.mem_range, LinearMap.zero_apply, exists_const]\n    exact (L.map_eq_zero_iff hL).trans eq_comm) x |>.mp  hx\n\n"}
{"name":"Module.Flat.iff_lTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' N'' : Type (max u v)⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] ⦃f : LinearMap (RingHom.id R) N N'⦄ ⦃g : LinearMap (RingHom.id R) N' N''⦄, Function.Exact ⇑f ⇑g → Function.Exact ⇑(LinearMap.lTensor M f) ⇑(LinearMap.lTensor M g))","decl":"/-- `M` is flat if and only if `M ⊗ -` is an exact functor.\n  See `Module.Flat.iff_lTensor_exact'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\ntheorem iff_lTensor_exact : Flat R M ↔\n    ∀ ⦃N N' N'' : Type (max u v)⦄ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄,\n        Function.Exact f g → Function.Exact (f.lTensor M) (g.lTensor M) :=\n  iff_lTensor_exact'\n\n"}
{"name":"Module.Flat.iff_rTensor_exact'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v', u} R\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' N'' : Type v'⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] ⦃f : LinearMap (RingHom.id R) N N'⦄ ⦃g : LinearMap (RingHom.id R) N' N''⦄, Function.Exact ⇑f ⇑g → Function.Exact ⇑(LinearMap.rTensor M f) ⇑(LinearMap.rTensor M g))","decl":"/-- `M` is flat if and only if `- ⊗ M` is an exact functor. See\n  `Module.Flat.iff_rTensor_exact` to specialize the universe of `N, N', N''` to `Type (max u v)`. -/\ntheorem iff_rTensor_exact' [Small.{v'} R] : Flat R M ↔\n    ∀ ⦃N N' N'' : Type v'⦄ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄,\n        Function.Exact f g → Function.Exact (f.rTensor M) (g.rTensor M) := by\n  refine ⟨fun _ ↦ rTensor_exact _, fun H ↦ iff_rTensor_preserves_injective_linearMap'.mpr\n    fun N' N'' _ _ _ _ f hf ↦ LinearMap.ker_eq_bot |>.mp <| eq_bot_iff |>.mpr\n      fun x (hx : _ = 0) ↦ ?_⟩\n  simpa [Eq.comm] using @H PUnit N' N'' _ _ _ _ _ _ 0 f (fun x ↦ by\n    simp_rw [Set.mem_range, LinearMap.zero_apply, exists_const]\n    exact (f.map_eq_zero_iff hf).trans eq_comm) x |>.mp hx\n\n"}
{"name":"Module.Flat.iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.Flat R M) (∀ ⦃N N' N'' : Type (max u v)⦄ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] ⦃f : LinearMap (RingHom.id R) N N'⦄ ⦃g : LinearMap (RingHom.id R) N' N''⦄, Function.Exact ⇑f ⇑g → Function.Exact ⇑(LinearMap.rTensor M f) ⇑(LinearMap.rTensor M g))","decl":"/-- `M` is flat if and only if `- ⊗ M` is an exact functor.\n  See `Module.Flat.iff_rTensor_exact'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\ntheorem iff_rTensor_exact : Flat R M ↔\n    ∀ ⦃N N' N'' : Type (max u v)⦄ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] ⦃f : N →ₗ[R] N'⦄ ⦃g : N' →ₗ[R] N''⦄,\n        Function.Exact f g → Function.Exact (f.rTensor M) (g.rTensor M) :=\n  iff_rTensor_exact'\n\n"}
{"name":"Algebra.TensorProduct.includeLeft_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : CommSemiring S\ninst✝² : Algebra S A\ninst✝¹ : SMulCommClass R S A\ninst✝ : Module.Flat R A\nhb : Function.Injective ⇑(algebraMap R B)\n⊢ Function.Injective ⇑Algebra.TensorProduct.includeLeft","decl":"theorem includeLeft_injective [Module.Flat R A] (hb : Function.Injective (algebraMap R B)) :\n    Function.Injective (includeLeft : A →ₐ[S] A ⊗[R] B) := by\n  convert Module.Flat.lTensor_preserves_injective_linearMap (M := A) (Algebra.linearMap R B) hb\n    |>.comp (_root_.TensorProduct.rid R A).symm.injective\n  ext; simp\n\n"}
{"name":"Algebra.TensorProduct.includeRight_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Module.Flat R B\nha : Function.Injective ⇑(algebraMap R A)\n⊢ Function.Injective ⇑Algebra.TensorProduct.includeRight","decl":"theorem includeRight_injective [Module.Flat R B] (ha : Function.Injective (algebraMap R A)) :\n    Function.Injective (includeRight : B →ₐ[R] A ⊗[R] B) := by\n  convert Module.Flat.rTensor_preserves_injective_linearMap (M := B) (Algebra.linearMap R A) ha\n    |>.comp (_root_.TensorProduct.lid R B).symm.injective\n  ext; simp\n\n"}
{"name":"TensorProduct.nontrivial_of_linearMap_injective_of_flat_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\nf : LinearMap (RingHom.id R) R N\nh : Function.Injective ⇑f\ninst✝¹ : Module.Flat R M\ninst✝ : Nontrivial M\n⊢ Nontrivial (TensorProduct R M N)","decl":"/-- If `M`, `N` are `R`-modules, there exists an injective `R`-linear map from `R` to `N`,\nand `M` is a nontrivial flat `R`-module, then `M ⊗[R] N` is nontrivial. -/\ntheorem nontrivial_of_linearMap_injective_of_flat_left (f : R →ₗ[R] N) (h : Function.Injective f)\n    [Module.Flat R M] [Nontrivial M] : Nontrivial (M ⊗[R] N) :=\n  Module.Flat.lTensor_preserves_injective_linearMap (M := M) f h |>.comp\n    (TensorProduct.rid R M).symm.injective |>.nontrivial\n\n"}
{"name":"TensorProduct.nontrivial_of_linearMap_injective_of_flat_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\nf : LinearMap (RingHom.id R) R M\nh : Function.Injective ⇑f\ninst✝¹ : Module.Flat R N\ninst✝ : Nontrivial N\n⊢ Nontrivial (TensorProduct R M N)","decl":"/-- If `M`, `N` are `R`-modules, there exists an injective `R`-linear map from `R` to `M`,\nand `N` is a nontrivial flat `R`-module, then `M ⊗[R] N` is nontrivial. -/\ntheorem nontrivial_of_linearMap_injective_of_flat_right (f : R →ₗ[R] M) (h : Function.Injective f)\n    [Module.Flat R N] [Nontrivial N] : Nontrivial (M ⊗[R] N) :=\n  Module.Flat.rTensor_preserves_injective_linearMap (M := N) f h |>.comp\n    (TensorProduct.lid R N).symm.injective |>.nontrivial\n\n"}
{"name":"Algebra.TensorProduct.nontrivial_of_algebraMap_injective_of_flat_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommSemiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nh : Function.Injective ⇑(algebraMap R B)\ninst✝¹ : Module.Flat R A\ninst✝ : Nontrivial A\n⊢ Nontrivial (TensorProduct R A B)","decl":"/-- If `A`, `B` are `R`-algebras, `R` injects into `B`,\nand `A` is a nontrivial flat `R`-algebra, then `A ⊗[R] B` is nontrivial. -/\ntheorem nontrivial_of_algebraMap_injective_of_flat_left (h : Function.Injective (algebraMap R B))\n    [Module.Flat R A] [Nontrivial A] : Nontrivial (A ⊗[R] B) :=\n  TensorProduct.nontrivial_of_linearMap_injective_of_flat_left R A B (Algebra.linearMap R B) h\n\n"}
{"name":"Algebra.TensorProduct.nontrivial_of_algebraMap_injective_of_flat_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommSemiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nh : Function.Injective ⇑(algebraMap R A)\ninst✝¹ : Module.Flat R B\ninst✝ : Nontrivial B\n⊢ Nontrivial (TensorProduct R A B)","decl":"/-- If `A`, `B` are `R`-algebras, `R` injects into `A`,\nand `B` is a nontrivial flat `R`-algebra, then `A ⊗[R] B` is nontrivial. -/\ntheorem nontrivial_of_algebraMap_injective_of_flat_right (h : Function.Injective (algebraMap R A))\n    [Module.Flat R B] [Nontrivial B] : Nontrivial (A ⊗[R] B) :=\n  TensorProduct.nontrivial_of_linearMap_injective_of_flat_right R A B (Algebra.linearMap R A) h\n\n"}
