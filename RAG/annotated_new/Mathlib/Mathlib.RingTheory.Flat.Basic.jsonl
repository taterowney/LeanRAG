{"name":"LinearMap.rTensor_injective_of_fg","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninstâœâ¶ : CommSemiring R\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : AddCommMonoid N\ninstâœÂ² : Module R N\ninstâœÂ¹ : AddCommMonoid P\ninstâœ : Module R P\nf : LinearMap (RingHom.id R) N P\nh : âˆ€ (N' : Submodule R N) (P' : Submodule R P), N'.FG â†’ P'.FG â†’ âˆ€ (h : LE.le N' (Submodule.comap f P')), Function.Injective â‡‘(LinearMap.rTensor M (f.restrict h))\nâŠ¢ Function.Injective â‡‘(LinearMap.rTensor M f)","decl":"theorem _root_.LinearMap.rTensor_injective_of_fg {f : N â†’â‚—[R] P}\n    (h :  âˆ€ (N' : Submodule R N) (P' : Submodule R P),\n      N'.FG â†’ P'.FG â†’ âˆ€ h : N' â‰¤ P'.comap f, Function.Injective ((f.restrict h).rTensor M)) :\n    Function.Injective (f.rTensor M) := fun x y eq â†¦ by\n  have âŸ¨N', Nfg, subâŸ© := Submodule.exists_fg_le_subset_range_rTensor_subtype {x, y} (by simp)\n  obtain âŸ¨x, rflâŸ© := sub (.inl rfl)\n  obtain âŸ¨y, rflâŸ© := sub (.inr rfl)\n  simp_rw [â† rTensor_comp_apply, show f âˆ˜â‚— N'.subtype = (N'.map f).subtype âˆ˜â‚— f.submoduleMap N'\n    from rfl, rTensor_comp_apply] at eq\n  have âŸ¨P', Pfg, le, eqâŸ© := (Nfg.map _).exists_rTensor_fg_inclusion_eq eq\n  simp_rw [â† rTensor_comp_apply] at eq\n  rw [h _ _ Nfg Pfg (map_le_iff_le_comap.mp le) eq]\n\n"}
{"name":"LinearMap.rTensor_injective_iff_subtype","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\nQ : Type u_3\ninstâœâ¸ : CommSemiring R\ninstâœâ· : AddCommMonoid M\ninstâœâ¶ : Module R M\ninstâœâµ : AddCommMonoid N\ninstâœâ´ : Module R N\ninstâœÂ³ : AddCommMonoid P\ninstâœÂ² : Module R P\ninstâœÂ¹ : AddCommMonoid Q\ninstâœ : Module R Q\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective â‡‘f\ne : LinearEquiv (RingHom.id R) P Q\nâŠ¢ Iff (Function.Injective â‡‘(LinearMap.rTensor M f)) (Function.Injective â‡‘(LinearMap.rTensor M (LinearMap.range ((â†‘e).comp f)).subtype))","decl":"lemma _root_.LinearMap.rTensor_injective_iff_subtype {f : N â†’â‚—[R] P} (hf : Function.Injective f)\n    (e : P â‰ƒâ‚—[R] Q) : Function.Injective (f.rTensor M) â†”\n      Function.Injective ((range <| e.toLinearMap âˆ˜â‚— f).subtype.rTensor M) := by\n  simp_rw [â† EquivLike.injective_comp <| (LinearEquiv.ofInjective (e.toLinearMap âˆ˜â‚— f)\n    (e.injective.comp hf)).rTensor M, â† EquivLike.comp_injective _ (e.rTensor M),\n    â† LinearEquiv.coe_coe, â† coe_comp, LinearEquiv.coe_rTensor,  â† rTensor_comp]\n  rfl\n\n"}
{"name":"Module.flat_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒP : Type uâ¦„ [inst : AddCommMonoid P] [inst_1 : Module R P] [inst_2 : Module.Finite R P] (N : Submodule R P), N.FG â†’ Function.Injective â‡‘(LinearMap.rTensor M N.subtype))","decl":"variable (R M) in\n/-- An `R`-module `M` is flat if for every finitely generated submodule `N` of every\nfinitely generated `R`-module `P` in the same universe as `R`,\nthe canonical map `N âŠ— M â†’ P âŠ— M` is injective. This implies the same is true for\narbitrary `R`-modules `N` and `P` and injective linear maps `N â†’â‚—[R] P`, see\n`Flat.rTensor_preserves_injective_linearMap`. To show a module over a ring `R` is flat, it\nsuffices to consider the case `P = R`, see `Flat.iff_rTensor_injective`. -/\n@[mk_iff] class Flat : Prop where\n  out â¦ƒP : Type uâ¦„ [AddCommMonoid P] [Module R P] [Module.Finite R P] (N : Submodule R P) : N.FG â†’\n    Function.Injective (N.subtype.rTensor M)\n\n"}
{"name":"Module.Flat.out","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\nself : Module.Flat R M\nP : Type u\ninstâœÂ² : AddCommMonoid P\ninstâœÂ¹ : Module R P\ninstâœ : Module.Finite R P\nN : Submodule R P\naâœ : N.FG\nâŠ¢ Function.Injective â‡‘(LinearMap.rTensor M N.subtype)","decl":"variable (R M) in\n/-- An `R`-module `M` is flat if for every finitely generated submodule `N` of every\nfinitely generated `R`-module `P` in the same universe as `R`,\nthe canonical map `N âŠ— M â†’ P âŠ— M` is injective. This implies the same is true for\narbitrary `R`-modules `N` and `P` and injective linear maps `N â†’â‚—[R] P`, see\n`Flat.rTensor_preserves_injective_linearMap`. To show a module over a ring `R` is flat, it\nsuffices to consider the case `P = R`, see `Flat.iff_rTensor_injective`. -/\n@[mk_iff] class Flat : Prop where\n  out â¦ƒP : Type uâ¦„ [AddCommMonoid P] [Module R P] [Module.Finite R P] (N : Submodule R P) : N.FG â†’\n    Function.Injective (N.subtype.rTensor M)\n\n"}
{"name":"Module.Flat.rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninstâœâ· : CommSemiring R\ninstâœâ¶ : AddCommMonoid M\ninstâœâµ : Module R M\ninstâœâ´ : AddCommMonoid N\ninstâœÂ³ : Module R N\ninstâœÂ² : AddCommMonoid P\ninstâœÂ¹ : Module R P\ninstâœ : Module.Flat R M\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective â‡‘f\nâŠ¢ Function.Injective â‡‘(LinearMap.rTensor M f)","decl":"/-- If `M` is a flat module, then `f âŠ— ğŸ™ M` is injective for all injective linear maps `f`. -/\ntheorem rTensor_preserves_injective_linearMap [Flat R M] (f : N â†’â‚—[R] P)\n    (hf : Function.Injective f) : Function.Injective (f.rTensor M) := by\n  refine rTensor_injective_of_fg fun N P Nfg Pfg le â†¦ ?_\n  rw [â† Finite.iff_fg] at Nfg Pfg\n  have := Finite.small R P\n  let se := (Shrink.linearEquiv.{_, u} P R).symm\n  have := Module.Finite.equiv se\n  rw [rTensor_injective_iff_subtype (fun _ _ â†¦ (Subtype.ext <| hf <| Subtype.ext_iff.mp Â·)) se]\n  exact (flat_iff R M).mp â€¹_â€º _ (Finite.iff_fg.mp inferInstance)\n\n"}
{"name":"Module.Flat.lTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\nP : Type u_2\ninstâœâ· : CommSemiring R\ninstâœâ¶ : AddCommMonoid M\ninstâœâµ : Module R M\ninstâœâ´ : AddCommMonoid N\ninstâœÂ³ : Module R N\ninstâœÂ² : AddCommMonoid P\ninstâœÂ¹ : Module R P\ninstâœ : Module.Flat R M\nf : LinearMap (RingHom.id R) N P\nhf : Function.Injective â‡‘f\nâŠ¢ Function.Injective â‡‘(LinearMap.lTensor M f)","decl":"/-- If `M` is a flat module, then `ğŸ™ M âŠ— f` is injective for all injective linear maps `f`. -/\ntheorem lTensor_preserves_injective_linearMap [Flat R M] (f : N â†’â‚—[R] P)\n    (hf : Function.Injective f) : Function.Injective (f.lTensor M) :=\n  (f.lTensor_inj_iff_rTensor_inj M).2 (rTensor_preserves_injective_linearMap f hf)\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMapâ‚›","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type v'â¦„ [inst : AddCommMonoid N] [inst_1 : AddCommMonoid N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f âŠ— ğŸ™ M` is injective whenever `f` is an injective linear map\nin a universe that `R` fits in. -/\nlemma iff_rTensor_preserves_injective_linearMapâ‚› [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type v'â¦„ [AddCommMonoid N] [AddCommMonoid N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.rTensor M) :=\n  âŸ¨by introv _; apply rTensor_preserves_injective_linearMap, fun h â†¦ âŸ¨fun P _ _ _ _ _ â†¦ by\n    have := Finite.small.{v'} R P\n    rw [rTensor_injective_iff_subtype Subtype.val_injective (Shrink.linearEquiv.{_, v'} P R).symm]\n    exact h _ Subtype.val_injectiveâŸ©âŸ©\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMapâ‚›","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type v'â¦„ [inst : AddCommMonoid N] [inst_1 : AddCommMonoid N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `ğŸ™ M âŠ— f` is injective whenever `f` is an injective linear map\nin a universe that `R` fits in. -/\nlemma iff_lTensor_preserves_injective_linearMapâ‚› [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type v'â¦„ [AddCommMonoid N] [AddCommMonoid N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.lTensor M) := by\n  simp_rw [iff_rTensor_preserves_injective_linearMapâ‚›, LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.iff_rTensor_injectiveâ‚›","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒP : Type uâ¦„ [inst : AddCommMonoid P] [inst_1 : Module R P] (N : Submodule R P), Function.Injective â‡‘(LinearMap.rTensor M N.subtype))","decl":"/-- An easier-to-use version of `Module.flat_iff`, with finiteness conditions removed. -/\nlemma iff_rTensor_injectiveâ‚› : Flat R M â†” âˆ€ â¦ƒP : Type uâ¦„ [AddCommMonoid P] [Module R P]\n    (N : Submodule R P), Function.Injective (N.subtype.rTensor M) :=\n  âŸ¨fun _ _ _ _ _ â†¦ rTensor_preserves_injective_linearMap _ Subtype.val_injective,\n    fun h â†¦ âŸ¨fun _ _ _ _ _ _ â†¦ h _âŸ©âŸ©\n\n"}
{"name":"Module.Flat.iff_lTensor_injectiveâ‚›","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒP : Type uâ¦„ [inst : AddCommMonoid P] [inst_1 : Module R P] (N : Submodule R P), Function.Injective â‡‘(LinearMap.lTensor M N.subtype))","decl":"lemma iff_lTensor_injectiveâ‚› : Flat R M â†” âˆ€ â¦ƒP : Type uâ¦„ [AddCommMonoid P] [Module R P]\n    (N : Submodule R P), Function.Injective (N.subtype.lTensor M) := by\n  simp_rw [iff_rTensor_injectiveâ‚›, LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.instSubalgebraToSubmodule","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœÂ³ : CommSemiring R\nS : Type v\ninstâœÂ² : Semiring S\ninstâœÂ¹ : Algebra R S\nA : Subalgebra R S\ninstâœ : Module.Flat R (Subtype fun x => Membership.mem A x)\nâŠ¢ Module.Flat R (Subtype fun x => Membership.mem (Subalgebra.toSubmodule A) x)","decl":"instance instSubalgebraToSubmodule {S : Type v} [Semiring S] [Algebra R S]\n    (A : Subalgebra R S) [Flat R A] : Flat R A.toSubmodule := â€¹Flat R Aâ€º\n\n"}
{"name":"Module.Flat.self","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nâŠ¢ Module.Flat R R","decl":"instance self : Flat R R where\n  out _ _ _ _ I _ := by\n    rw [â† (TensorProduct.rid R I).symm.injective_comp, â† (TensorProduct.rid R _).comp_injective]\n    convert Subtype.coe_injective using 1\n    ext; simp\n\n"}
{"name":"Module.Flat.of_retract","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nf : Module.Flat R M\ni : LinearMap (RingHom.id R) N M\nr : LinearMap (RingHom.id R) M N\nh : Eq (r.comp i) LinearMap.id\nâŠ¢ Module.Flat R N","decl":"/-- A retract of a flat `R`-module is flat. -/\nlemma of_retract [f : Flat R M] (i : N â†’â‚—[R] M) (r : M â†’â‚—[R] N) (h : r.comp i = LinearMap.id) :\n    Flat R N := by\n  rw [iff_rTensor_injectiveâ‚›] at *\n  refine fun P _ _ Q â†¦ .of_comp (f := lTensor P i) ?_\n  rw [â† coe_comp, lTensor_comp_rTensor, â† rTensor_comp_lTensor, coe_comp]\n  refine (f Q).comp (Function.RightInverse.injective (g := lTensor Q r) fun x â†¦ ?_)\n  simp [â† comp_apply, â† lTensor_comp, h]\n\n"}
{"name":"Module.Flat.of_linearEquiv","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : Module.Flat R M\ne : LinearEquiv (RingHom.id R) N M\nâŠ¢ Module.Flat R N","decl":"/-- A `R`-module linearly equivalent to a flat `R`-module is flat. -/\nlemma of_linearEquiv [Flat R M] (e : N â‰ƒâ‚—[R] M) : Flat R N :=\n  of_retract e.toLinearMap e.symm (by simp)\n\n"}
{"name":"Module.Flat.equiv_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\ne : LinearEquiv (RingHom.id R) M N\nâŠ¢ Iff (Module.Flat R M) (Module.Flat R N)","decl":"/-- If an `R`-module `M` is linearly equivalent to another `R`-module `N`, then `M` is flat\n  if and only if `N` is flat. -/\nlemma equiv_iff (e : M â‰ƒâ‚—[R] N) : Flat R M â†” Flat R N :=\n  âŸ¨fun _ â†¦ of_linearEquiv e.symm, fun _ â†¦ of_linearEquiv eâŸ©\n\n"}
{"name":"Module.Flat.ulift","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Flat R M\nâŠ¢ Module.Flat R (ULift.{v', v} M)","decl":"instance ulift [Flat R M] : Flat R (ULift.{v'} M) :=\n  of_linearEquiv ULift.moduleEquiv\n\n-- Making this an instance causes an infinite sequence `M â†’ ULift M â†’ ULift (ULift M) â†’ ...`.\n"}
{"name":"Module.Flat.of_ulift","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Flat R (ULift.{v', v} M)\nâŠ¢ Module.Flat R M","decl":"lemma of_ulift [Flat R (ULift.{v'} M)] : Flat R M :=\n  of_linearEquiv ULift.moduleEquiv.symm\n\n"}
{"name":"Module.Flat.shrink","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Small.{v', v} M\ninstâœ : Module.Flat R M\nâŠ¢ Module.Flat R (Shrink.{v', v} M)","decl":"instance shrink [Small.{v'} M] [Flat R M] : Flat R (Shrink.{v'} M) :=\n  of_linearEquiv (Shrink.linearEquiv M R)\n\n-- Making this an instance causes an infinite sequence `M â†’ Shrink M â†’ Shrink (Shrink M) â†’ ...`.\n"}
{"name":"Module.Flat.of_shrink","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Small.{v', v} M\ninstâœ : Module.Flat R (Shrink.{v', v} M)\nâŠ¢ Module.Flat R M","decl":"lemma of_shrink [Small.{v'} M] [Flat R (Shrink.{v'} M)] : Flat R M :=\n  of_linearEquiv (Shrink.linearEquiv M R).symm\n\n"}
{"name":"Module.Flat.directSum_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœÂ² : CommSemiring R\nÎ¹ : Type v\nM : Î¹ â†’ Type w\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (M i)\ninstâœ : (i : Î¹) â†’ Module R (M i)\nâŠ¢ Iff (Module.Flat R (DirectSum Î¹ fun i => M i)) (âˆ€ (i : Î¹), Module.Flat R (M i))","decl":"theorem directSum_iff : Flat R (â¨ i, M i) â†” âˆ€ i, Flat R (M i) := by\n  classical\n  simp_rw [iff_rTensor_injectiveâ‚›, â† EquivLike.comp_injective _ (directSumRight R _ _),\n    â† LinearEquiv.coe_coe, â† coe_comp, directSumRight_comp_rTensor, coe_comp, LinearEquiv.coe_coe,\n    EquivLike.injective_comp, lmap_injective]\n  constructor <;> (intro h; intros; apply h)\n\n"}
{"name":"Module.Flat.dfinsupp_iff","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœÂ² : CommSemiring R\nÎ¹ : Type v\nM : Î¹ â†’ Type w\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (M i)\ninstâœ : (i : Î¹) â†’ Module R (M i)\nâŠ¢ Iff (Module.Flat R (DFinsupp fun i => M i)) (âˆ€ (i : Î¹), Module.Flat R (M i))","decl":"theorem dfinsupp_iff : Flat R (Î â‚€ i, M i) â†” âˆ€ i, Flat R (M i) := directSum_iff ..\n\n"}
{"name":"Module.Flat.directSum","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœÂ³ : CommSemiring R\nÎ¹ : Type v\nM : Î¹ â†’ Type w\ninstâœÂ² : (i : Î¹) â†’ AddCommMonoid (M i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (M i)\ninstâœ : âˆ€ (i : Î¹), Module.Flat R (M i)\nâŠ¢ Module.Flat R (DirectSum Î¹ fun i => M i)","decl":"/-- A direct sum of flat `R`-modules is flat. -/\ninstance directSum [âˆ€ i, Flat R (M i)] : Flat R (â¨ i, M i) := directSum_iff.mpr â€¹_â€º\n\n"}
{"name":"Module.Flat.dfinsupp","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœÂ³ : CommSemiring R\nÎ¹ : Type v\nM : Î¹ â†’ Type w\ninstâœÂ² : (i : Î¹) â†’ AddCommMonoid (M i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (M i)\ninstâœ : âˆ€ (i : Î¹), Module.Flat R (M i)\nâŠ¢ Module.Flat R (DFinsupp fun i => M i)","decl":"instance dfinsupp [âˆ€ i, Flat R (M i)] : Flat R (Î â‚€ i, M i) := dfinsupp_iff.mpr â€¹_â€º\n\n"}
{"name":"Module.Flat.finsupp","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nÎ¹ : Type v\nâŠ¢ Module.Flat R (Finsupp Î¹ R)","decl":"/-- Free `R`-modules over discrete types are flat. -/\ninstance finsupp (Î¹ : Type v) : Flat R (Î¹ â†’â‚€ R) := by\n  classical exact of_linearEquiv (finsuppLEquivDirectSum R R Î¹)\n\n"}
{"name":"Module.Flat.of_projective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Projective R M\nâŠ¢ Module.Flat R M","decl":"instance of_projective [Projective R M] : Flat R M :=\n  have âŸ¨e, heâŸ©:= Module.projective_def'.mp â€¹_â€º\n  of_retract _ _ he\n\n"}
{"name":"Module.Flat.of_projective_surjective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Projective R M\nâŠ¢ Module.Flat R M","decl":"@[deprecated (since := \"2024-12-26\")] alias of_projective_surjective := of_projective\n\n"}
{"name":"Module.Flat.of_free","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Free R M\nâŠ¢ Module.Flat R M","decl":"instance of_free [Free R M] : Flat R M := inferInstance\n\n"}
{"name":"Module.Flat.instTensorProduct","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœÂ¹â° : CommSemiring R\ninstâœâ¹ : AddCommMonoid M\ninstâœâ¸ : Module R M\ninstâœâ· : AddCommMonoid N\ninstâœâ¶ : Module R N\nS : Type u_4\ninstâœâµ : CommSemiring S\ninstâœâ´ : Algebra R S\ninstâœÂ³ : Module S M\ninstâœÂ² : IsScalarTower R S M\ninstâœÂ¹ : Module.Flat S M\ninstâœ : Module.Flat R N\nâŠ¢ Module.Flat S (TensorProduct R M N)","decl":"instance {S} [CommSemiring S] [Algebra R S] [Module S M] [IsScalarTower R S M]\n    [Flat S M] [Flat R N] : Flat S (M âŠ—[R] N) :=\n  iff_rTensor_injectiveâ‚›.mpr fun P _ _ I â†¦ by\n    letI := RestrictScalars.moduleOrig R S P\n    change Submodule S (RestrictScalars R S P) at I\n    change Function.Injective (rTensor _ I.subtype)\n    simpa [AlgebraTensorModule.rTensor_tensor] using\n      rTensor_preserves_injective_linearMap (.restrictScalars R <| I.subtype.rTensor M)\n      (rTensor_preserves_injective_linearMap _ I.injective_subtype)\n\n"}
{"name":"Module.Flat.linearIndependent_one_tmul","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\nS : Type u_4\ninstâœÂ² : Semiring S\ninstâœÂ¹ : Algebra R S\ninstâœ : Module.Flat R S\nÎ¹ : Type u_5\nv : Î¹ â†’ M\nhv : LinearIndependent R v\nâŠ¢ LinearIndependent S fun x => TensorProduct.tmul R 1 (v x)","decl":"theorem linearIndependent_one_tmul {S} [Semiring S] [Algebra R S] [Flat R S] {Î¹} {v : Î¹ â†’ M}\n    (hv : LinearIndependent R v) : LinearIndependent S ((1 : S) âŠ—â‚œ[R] v Â·) := by\n  classical rw [LinearIndependent, â† LinearMap.coe_restrictScalars R,\n    Finsupp.linearCombination_one_tmul]\n  simpa using lTensor_preserves_injective_linearMap _ hv\n\n"}
{"name":"Module.Flat.tensorProduct_mapIncl_injective_of_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœâ¶ : CommSemiring R\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : AddCommMonoid N\ninstâœÂ² : Module R N\np : Submodule R M\nq : Submodule R N\ninstâœÂ¹ : Module.Flat R M\ninstâœ : Module.Flat R (Subtype fun x => Membership.mem q x)\nâŠ¢ Function.Injective â‡‘(TensorProduct.mapIncl p q)","decl":"/-- If p and q are submodules of M and N respectively, and M and q are flat,\nthen `p âŠ— q â†’ M âŠ— N` is injective. -/\ntheorem tensorProduct_mapIncl_injective_of_right\n    [Flat R M] [Flat R q] : Function.Injective (mapIncl p q) := by\n  rw [mapIncl, â† lTensor_comp_rTensor]\n  exact (lTensor_preserves_injective_linearMap _ q.injective_subtype).comp\n    (rTensor_preserves_injective_linearMap _ p.injective_subtype)\n\n"}
{"name":"Module.Flat.tensorProduct_mapIncl_injective_of_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type u_1\ninstâœâ¶ : CommSemiring R\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : AddCommMonoid N\ninstâœÂ² : Module R N\np : Submodule R M\nq : Submodule R N\ninstâœÂ¹ : Module.Flat R (Subtype fun x => Membership.mem p x)\ninstâœ : Module.Flat R N\nâŠ¢ Function.Injective â‡‘(TensorProduct.mapIncl p q)","decl":"/-- If p and q are submodules of M and N respectively, and N and p are flat,\nthen `p âŠ— q â†’ M âŠ— N` is injective. -/\ntheorem tensorProduct_mapIncl_injective_of_left\n    [Flat R p] [Flat R N] : Function.Injective (mapIncl p q) := by\n  rw [mapIncl, â† rTensor_comp_lTensor]\n  exact (rTensor_preserves_injective_linearMap _ p.injective_subtype).comp\n    (lTensor_preserves_injective_linearMap _ q.injective_subtype)\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMap'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type v'â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f âŠ— ğŸ™ M` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_rTensor_preserves_injective_linearMap` to specialize the universe of\n  `N, N', N''` to `Type (max u v)`. -/\nlemma iff_rTensor_preserves_injective_linearMap' [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type v'â¦„ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.rTensor M) :=\n  âŸ¨by introv _; apply rTensor_preserves_injective_linearMap, fun h â†¦\n    iff_rTensor_preserves_injective_linearMapâ‚›.mpr fun P N _ _ _ _ â†¦ by\n      letI := Module.addCommMonoidToAddCommGroup R (M := P)\n      letI := Module.addCommMonoidToAddCommGroup R (M := N)\n      apply hâŸ©\n\n"}
{"name":"Module.Flat.iff_rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type (max u v)â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.rTensor M f))","decl":"/-- `M` is flat if and only if `f âŠ— ğŸ™ M` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_rTensor_preserves_injective_linearMap'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\nlemma iff_rTensor_preserves_injective_linearMap : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type (max u v)â¦„ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.rTensor M) :=\n  iff_rTensor_preserves_injective_linearMap'\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMap'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type v'â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `ğŸ™ M âŠ— f` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_lTensor_preserves_injective_linearMap` to specialize the universe of\n  `N, N', N''` to `Type (max u v)`. -/\nlemma iff_lTensor_preserves_injective_linearMap' [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type v'â¦„ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.lTensor M) := by\n  simp_rw [iff_rTensor_preserves_injective_linearMap', LinearMap.lTensor_inj_iff_rTensor_inj]\n\n"}
{"name":"Module.Flat.iff_lTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' : Type (max u v)â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.lTensor M f))","decl":"/-- `M` is flat if and only if `ğŸ™ M âŠ— f` is injective whenever `f` is an injective linear map.\n  See `Module.Flat.iff_lTensor_preserves_injective_linearMap'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\nlemma iff_lTensor_preserves_injective_linearMap : Flat R M â†”\n    âˆ€ â¦ƒN N' : Type (max u v)â¦„ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.lTensor M) :=\n  iff_lTensor_preserves_injective_linearMap'\n\n"}
{"name":"Module.Flat.injective_characterModule_iff_rTensor_preserves_injective_linearMap","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Injective R (CharacterModule M)) (âˆ€ â¦ƒN N' : Type vâ¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : Module R N] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Function.Injective â‡‘f â†’ Function.Injective â‡‘(LinearMap.rTensor M f))","decl":"/--\nDefine the character module of `M` to be `M â†’+ â„š â§¸ â„¤`.\nThe character module of `M` is an injective module if and only if\n `f âŠ— ğŸ™ M` is injective for any linear map `f` in the same universe as `M`.\n-/\nlemma injective_characterModule_iff_rTensor_preserves_injective_linearMap :\n    Module.Injective R (CharacterModule M) â†”\n    âˆ€ â¦ƒN N' : Type vâ¦„ [AddCommGroup N] [AddCommGroup N'] [Module R N] [Module R N']\n      (f : N â†’â‚—[R] N'), Function.Injective f â†’ Function.Injective (f.rTensor M) := by\n  simp_rw [injective_iff, rTensor_injective_iff_lcomp_surjective, Surjective, DFunLike.ext_iff]; rfl\n\n"}
{"name":"Module.Flat.iff_characterModule_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v, u} R\nâŠ¢ Iff (Module.Flat R M) (Module.Injective R (CharacterModule M))","decl":"/-- `CharacterModule M` is an injective module iff `M` is flat.\nSee [Lambek_1964] for a self-contained proof. -/\ntheorem iff_characterModule_injective [Small.{v} R] :\n    Flat R M â†” Module.Injective R (CharacterModule M) := by\n  rw [injective_characterModule_iff_rTensor_preserves_injective_linearMap,\n    iff_rTensor_preserves_injective_linearMap']\n\n"}
{"name":"Module.Flat.iff_characterModule_baer","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (Module.Baer R (CharacterModule M))","decl":"/-- `CharacterModule M` is Baer iff `M` is flat. -/\ntheorem iff_characterModule_baer : Flat R M â†” Baer R (CharacterModule M) := by\n  rw [equiv_iff (N := ULift.{u} M) ULift.moduleEquiv.symm, iff_characterModule_injective,\n    â† Baer.iff_injective, Baer.congr (CharacterModule.congr ULift.moduleEquiv)]\n\n"}
{"name":"Module.Flat.iff_rTensor_injective'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ (I : Ideal R), Function.Injective â‡‘(LinearMap.rTensor M (Submodule.subtype I)))","decl":"/-- An `R`-module `M` is flat iff for all ideals `I` of `R`, the tensor product of the\ninclusion `I â†’ R` and the identity `M â†’ M` is injective. See `iff_rTensor_injective` to\nrestrict to finitely generated ideals `I`. --/\ntheorem iff_rTensor_injective' :\n    Flat R M â†” âˆ€ I : Ideal R, Function.Injective (rTensor M I.subtype) := by\n  simp_rw [iff_characterModule_baer, Baer, rTensor_injective_iff_lcomp_surjective,\n    Surjective, DFunLike.ext_iff, Subtype.forall]\n  rfl\n\n"}
{"name":"Module.Flat.iff_lTensor_injective'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ (I : Ideal R), Function.Injective â‡‘(LinearMap.lTensor M (Submodule.subtype I)))","decl":"/-- The `lTensor`-variant of `iff_rTensor_injective'`. . -/\ntheorem iff_lTensor_injective' :\n    Flat R M â†” âˆ€ (I : Ideal R), Function.Injective (lTensor M I.subtype) := by\n  simpa [â† comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective'\n\n"}
{"name":"Module.Flat.iff_rTensor_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’ Function.Injective â‡‘(LinearMap.rTensor M (Submodule.subtype I)))","decl":"/-- A module `M` over a ring `R` is flat iff for all finitely generated ideals `I` of `R`, the\ntensor product of the inclusion `I â†’ R` and the identity `M â†’ M` is injective. See\n`iff_rTensor_injective'` to extend to all ideals `I`. -/\nlemma iff_rTensor_injective :\n    Flat R M â†” âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’ Function.Injective (I.subtype.rTensor M) := by\n  refine iff_rTensor_injective'.trans âŸ¨fun h I _ â†¦ h I,\n    fun h I â†¦ (injective_iff_map_eq_zero _).mpr fun x hx â†¦ ?_âŸ©\n  obtain âŸ¨J, hfg, hle, y, rflâŸ© := Submodule.exists_fg_le_eq_rTensor_inclusion x\n  rw [â† rTensor_comp_apply] at hx\n  rw [(injective_iff_map_eq_zero _).mp (h hfg) y hx, map_zero]\n\n"}
{"name":"Module.Flat.iff_lTensor_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’ Function.Injective â‡‘(LinearMap.lTensor M (Submodule.subtype I)))","decl":"/-- The `lTensor`-variant of `iff_rTensor_injective`. -/\ntheorem iff_lTensor_injective :\n    Flat R M â†” âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’ Function.Injective (I.subtype.lTensor M) := by\n  simpa [â† comm_comp_rTensor_comp_comm_eq] using iff_rTensor_injective\n\n"}
{"name":"Module.Flat.iff_lift_lsmul_comp_subtype_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’ Function.Injective â‡‘(TensorProduct.lift ((LinearMap.lsmul R M).comp (Submodule.subtype I))))","decl":"/-- An `R`-module `M` is flat if for all finitely generated ideals `I` of `R`,\nthe canonical map `I âŠ— M â†’â‚— M` is injective. -/\nlemma iff_lift_lsmul_comp_subtype_injective : Flat R M â†” âˆ€ â¦ƒI : Ideal Râ¦„, I.FG â†’\n    Function.Injective (TensorProduct.lift ((lsmul R M).comp I.subtype)) := by\n  simp [iff_rTensor_injective, â† lid_comp_rTensor]\n\n"}
{"name":"Module.Flat.lTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ¹ : CommRing R\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : Module.Flat R M\nN : Type u_1\nN' : Type u_2\nN'' : Type u_3\ninstâœâµ : AddCommGroup N\ninstâœâ´ : AddCommGroup N'\ninstâœÂ³ : AddCommGroup N''\ninstâœÂ² : Module R N\ninstâœÂ¹ : Module R N'\ninstâœ : Module R N''\nf : LinearMap (RingHom.id R) N N'\ng : LinearMap (RingHom.id R) N' N''\nexact : Function.Exact â‡‘f â‡‘g\nâŠ¢ Function.Exact â‡‘(LinearMap.lTensor M f) â‡‘(LinearMap.lTensor M g)","decl":"variable (M) in\n/-- If `M` is flat then `M âŠ— -` is an exact functor. -/\nlemma lTensor_exact [Flat R M] â¦ƒN N' N'' : Type*â¦„\n    [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N''] [Module R N] [Module R N'] [Module R N'']\n    â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„ (exact : Function.Exact f g) :\n    Function.Exact (f.lTensor M) (g.lTensor M) := by\n  let Ï€ : N' â†’â‚—[R] N' â§¸ LinearMap.range f := Submodule.mkQ _\n  let Î¹ : N' â§¸ LinearMap.range f â†’â‚—[R] N'' :=\n    Submodule.subtype _ âˆ˜â‚— (LinearMap.quotKerEquivRange g).toLinearMap âˆ˜â‚—\n      Submodule.quotEquivOfEq (LinearMap.range f) (LinearMap.ker g)\n        (LinearMap.exact_iff.mp exact).symm\n  suffices exact1 : Function.Exact (f.lTensor M) (Ï€.lTensor M) by\n    rw [show g = Î¹.comp Ï€ from rfl, lTensor_comp]\n    exact exact1.comp_injective _ (lTensor_preserves_injective_linearMap Î¹ <| by\n      simpa [Î¹, - Subtype.val_injective] using Subtype.val_injective) (map_zero _)\n  exact _root_.lTensor_exact _ (fun x â†¦ by simp [Ï€]) Quotient.mk''_surjective\n\n"}
{"name":"Module.Flat.rTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœâ¹ : CommRing R\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : Module.Flat R M\nN : Type u_1\nN' : Type u_2\nN'' : Type u_3\ninstâœâµ : AddCommGroup N\ninstâœâ´ : AddCommGroup N'\ninstâœÂ³ : AddCommGroup N''\ninstâœÂ² : Module R N\ninstâœÂ¹ : Module R N'\ninstâœ : Module R N''\nf : LinearMap (RingHom.id R) N N'\ng : LinearMap (RingHom.id R) N' N''\nexact : Function.Exact â‡‘f â‡‘g\nâŠ¢ Function.Exact â‡‘(LinearMap.rTensor M f) â‡‘(LinearMap.rTensor M g)","decl":"variable (M) in\n/-- If `M` is flat then `- âŠ— M` is an exact functor. -/\nlemma rTensor_exact [Flat R M] â¦ƒN N' N'' : Type*â¦„\n    [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N''] [Module R N] [Module R N'] [Module R N'']\n    â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„ (exact : Function.Exact f g) :\n    Function.Exact (f.rTensor M) (g.rTensor M) := by\n  let Ï€ : N' â†’â‚—[R] N' â§¸ LinearMap.range f := Submodule.mkQ _\n  let Î¹ : N' â§¸ LinearMap.range f â†’â‚—[R] N'' :=\n    Submodule.subtype _ âˆ˜â‚— (LinearMap.quotKerEquivRange g).toLinearMap âˆ˜â‚—\n      Submodule.quotEquivOfEq (LinearMap.range f) (LinearMap.ker g)\n        (LinearMap.exact_iff.mp exact).symm\n  suffices exact1 : Function.Exact (f.rTensor M) (Ï€.rTensor M) by\n    rw [show g = Î¹.comp Ï€ from rfl, rTensor_comp]\n    exact exact1.comp_injective _ (rTensor_preserves_injective_linearMap Î¹ <| by\n      simpa [Î¹, - Subtype.val_injective] using Subtype.val_injective) (map_zero _)\n  exact _root_.rTensor_exact M (fun x â†¦ by simp [Ï€]) Quotient.mk''_surjective\n\n"}
{"name":"Module.Flat.iff_lTensor_exact'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' N'' : Type v'â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] â¦ƒf : LinearMap (RingHom.id R) N N'â¦„ â¦ƒg : LinearMap (RingHom.id R) N' N''â¦„, Function.Exact â‡‘f â‡‘g â†’ Function.Exact â‡‘(LinearMap.lTensor M f) â‡‘(LinearMap.lTensor M g))","decl":"/-- `M` is flat if and only if `M âŠ— -` is an exact functor. See\n  `Module.Flat.iff_lTensor_exact` to specialize the universe of `N, N', N''` to `Type (max u v)`. -/\ntheorem iff_lTensor_exact' [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' N'' : Type v'â¦„ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„,\n        Function.Exact f g â†’ Function.Exact (f.lTensor M) (g.lTensor M) := by\n  refine âŸ¨fun _ â†¦ lTensor_exact _, fun H â†¦ iff_lTensor_preserves_injective_linearMap'.mpr\n    fun N' N'' _ _ _ _ L hL â†¦ LinearMap.ker_eq_bot |>.mp <| eq_bot_iff |>.mpr\n      fun x (hx : _ = 0) â†¦ ?_âŸ©\n  simpa [Eq.comm] using @H PUnit N' N'' _ _ _ _ _ _ 0 L (fun x â†¦ by\n    simp_rw [Set.mem_range, LinearMap.zero_apply, exists_const]\n    exact (L.map_eq_zero_iff hL).trans eq_comm) x |>.mp  hx\n\n"}
{"name":"Module.Flat.iff_lTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' N'' : Type (max u v)â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] â¦ƒf : LinearMap (RingHom.id R) N N'â¦„ â¦ƒg : LinearMap (RingHom.id R) N' N''â¦„, Function.Exact â‡‘f â‡‘g â†’ Function.Exact â‡‘(LinearMap.lTensor M f) â‡‘(LinearMap.lTensor M g))","decl":"/-- `M` is flat if and only if `M âŠ— -` is an exact functor.\n  See `Module.Flat.iff_lTensor_exact'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\ntheorem iff_lTensor_exact : Flat R M â†”\n    âˆ€ â¦ƒN N' N'' : Type (max u v)â¦„ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„,\n        Function.Exact f g â†’ Function.Exact (f.lTensor M) (g.lTensor M) :=\n  iff_lTensor_exact'\n\n"}
{"name":"Module.Flat.iff_rTensor_exact'","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Small.{v', u} R\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' N'' : Type v'â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] â¦ƒf : LinearMap (RingHom.id R) N N'â¦„ â¦ƒg : LinearMap (RingHom.id R) N' N''â¦„, Function.Exact â‡‘f â‡‘g â†’ Function.Exact â‡‘(LinearMap.rTensor M f) â‡‘(LinearMap.rTensor M g))","decl":"/-- `M` is flat if and only if `- âŠ— M` is an exact functor. See\n  `Module.Flat.iff_rTensor_exact` to specialize the universe of `N, N', N''` to `Type (max u v)`. -/\ntheorem iff_rTensor_exact' [Small.{v'} R] : Flat R M â†”\n    âˆ€ â¦ƒN N' N'' : Type v'â¦„ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„,\n        Function.Exact f g â†’ Function.Exact (f.rTensor M) (g.rTensor M) := by\n  refine âŸ¨fun _ â†¦ rTensor_exact _, fun H â†¦ iff_rTensor_preserves_injective_linearMap'.mpr\n    fun N' N'' _ _ _ _ f hf â†¦ LinearMap.ker_eq_bot |>.mp <| eq_bot_iff |>.mpr\n      fun x (hx : _ = 0) â†¦ ?_âŸ©\n  simpa [Eq.comm] using @H PUnit N' N'' _ _ _ _ _ _ 0 f (fun x â†¦ by\n    simp_rw [Set.mem_range, LinearMap.zero_apply, exists_const]\n    exact (f.map_eq_zero_iff hf).trans eq_comm) x |>.mp hx\n\n"}
{"name":"Module.Flat.iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u\nM : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Iff (Module.Flat R M) (âˆ€ â¦ƒN N' N'' : Type (max u v)â¦„ [inst : AddCommGroup N] [inst_1 : AddCommGroup N'] [inst_2 : AddCommGroup N''] [inst_3 : Module R N] [inst_4 : Module R N'] [inst_5 : Module R N''] â¦ƒf : LinearMap (RingHom.id R) N N'â¦„ â¦ƒg : LinearMap (RingHom.id R) N' N''â¦„, Function.Exact â‡‘f â‡‘g â†’ Function.Exact â‡‘(LinearMap.rTensor M f) â‡‘(LinearMap.rTensor M g))","decl":"/-- `M` is flat if and only if `- âŠ— M` is an exact functor.\n  See `Module.Flat.iff_rTensor_exact'` to generalize the universe of\n  `N, N', N''` to any universe that is higher than `R` and `M`. -/\ntheorem iff_rTensor_exact : Flat R M â†”\n    âˆ€ â¦ƒN N' N'' : Type (max u v)â¦„ [AddCommGroup N] [AddCommGroup N'] [AddCommGroup N'']\n      [Module R N] [Module R N'] [Module R N''] â¦ƒf : N â†’â‚—[R] N'â¦„ â¦ƒg : N' â†’â‚—[R] N''â¦„,\n        Function.Exact f g â†’ Function.Exact (f.rTensor M) (g.rTensor M) :=\n  iff_rTensor_exact'\n\n"}
{"name":"Algebra.TensorProduct.includeLeft_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring R\ninstâœâ· : Semiring A\ninstâœâ¶ : Algebra R A\ninstâœâµ : Semiring B\ninstâœâ´ : Algebra R B\ninstâœÂ³ : CommSemiring S\ninstâœÂ² : Algebra S A\ninstâœÂ¹ : SMulCommClass R S A\ninstâœ : Module.Flat R A\nhb : Function.Injective â‡‘(algebraMap R B)\nâŠ¢ Function.Injective â‡‘Algebra.TensorProduct.includeLeft","decl":"theorem includeLeft_injective [Module.Flat R A] (hb : Function.Injective (algebraMap R B)) :\n    Function.Injective (includeLeft : A â†’â‚[S] A âŠ—[R] B) := by\n  convert Module.Flat.lTensor_preserves_injective_linearMap (M := A) (Algebra.linearMap R B) hb\n    |>.comp (_root_.TensorProduct.rid R A).symm.injective\n  ext; simp\n\n"}
{"name":"Algebra.TensorProduct.includeRight_injective","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_4\ninstâœâµ : CommSemiring R\ninstâœâ´ : Semiring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra R B\ninstâœ : Module.Flat R B\nha : Function.Injective â‡‘(algebraMap R A)\nâŠ¢ Function.Injective â‡‘Algebra.TensorProduct.includeRight","decl":"theorem includeRight_injective [Module.Flat R B] (ha : Function.Injective (algebraMap R A)) :\n    Function.Injective (includeRight : B â†’â‚[R] A âŠ—[R] B) := by\n  convert Module.Flat.rTensor_preserves_injective_linearMap (M := B) (Algebra.linearMap R A) ha\n    |>.comp (_root_.TensorProduct.lid R B).symm.injective\n  ext; simp\n\n"}
{"name":"TensorProduct.nontrivial_of_linearMap_injective_of_flat_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninstâœâ¶ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : AddCommMonoid N\ninstâœÂ³ : Module R M\ninstâœÂ² : Module R N\nf : LinearMap (RingHom.id R) R N\nh : Function.Injective â‡‘f\ninstâœÂ¹ : Module.Flat R M\ninstâœ : Nontrivial M\nâŠ¢ Nontrivial (TensorProduct R M N)","decl":"/-- If `M`, `N` are `R`-modules, there exists an injective `R`-linear map from `R` to `N`,\nand `M` is a nontrivial flat `R`-module, then `M âŠ—[R] N` is nontrivial. -/\ntheorem nontrivial_of_linearMap_injective_of_flat_left (f : R â†’â‚—[R] N) (h : Function.Injective f)\n    [Module.Flat R M] [Nontrivial M] : Nontrivial (M âŠ—[R] N) :=\n  Module.Flat.lTensor_preserves_injective_linearMap (M := M) f h |>.comp\n    (TensorProduct.rid R M).symm.injective |>.nontrivial\n\n"}
{"name":"TensorProduct.nontrivial_of_linearMap_injective_of_flat_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninstâœâ¶ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : AddCommMonoid N\ninstâœÂ³ : Module R M\ninstâœÂ² : Module R N\nf : LinearMap (RingHom.id R) R M\nh : Function.Injective â‡‘f\ninstâœÂ¹ : Module.Flat R N\ninstâœ : Nontrivial N\nâŠ¢ Nontrivial (TensorProduct R M N)","decl":"/-- If `M`, `N` are `R`-modules, there exists an injective `R`-linear map from `R` to `M`,\nand `N` is a nontrivial flat `R`-module, then `M âŠ—[R] N` is nontrivial. -/\ntheorem nontrivial_of_linearMap_injective_of_flat_right (f : R â†’â‚—[R] M) (h : Function.Injective f)\n    [Module.Flat R N] [Nontrivial N] : Nontrivial (M âŠ—[R] N) :=\n  Module.Flat.rTensor_preserves_injective_linearMap (M := N) f h |>.comp\n    (TensorProduct.lid R N).symm.injective |>.nontrivial\n\n"}
{"name":"Algebra.TensorProduct.nontrivial_of_algebraMap_injective_of_flat_left","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninstâœâ¶ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommSemiring A\ninstâœâ´ : CommSemiring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nh : Function.Injective â‡‘(algebraMap R B)\ninstâœÂ¹ : Module.Flat R A\ninstâœ : Nontrivial A\nâŠ¢ Nontrivial (TensorProduct R A B)","decl":"/-- If `A`, `B` are `R`-algebras, `R` injects into `B`,\nand `A` is a nontrivial flat `R`-algebra, then `A âŠ—[R] B` is nontrivial. -/\ntheorem nontrivial_of_algebraMap_injective_of_flat_left (h : Function.Injective (algebraMap R B))\n    [Module.Flat R A] [Nontrivial A] : Nontrivial (A âŠ—[R] B) :=\n  TensorProduct.nontrivial_of_linearMap_injective_of_flat_left R A B (Algebra.linearMap R B) h\n\n"}
{"name":"Algebra.TensorProduct.nontrivial_of_algebraMap_injective_of_flat_right","module":"Mathlib.RingTheory.Flat.Basic","initialProofState":"R : Type u_1\ninstâœâ¶ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommSemiring A\ninstâœâ´ : CommSemiring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nh : Function.Injective â‡‘(algebraMap R A)\ninstâœÂ¹ : Module.Flat R B\ninstâœ : Nontrivial B\nâŠ¢ Nontrivial (TensorProduct R A B)","decl":"/-- If `A`, `B` are `R`-algebras, `R` injects into `A`,\nand `B` is a nontrivial flat `R`-algebra, then `A âŠ—[R] B` is nontrivial. -/\ntheorem nontrivial_of_algebraMap_injective_of_flat_right (h : Function.Injective (algebraMap R A))\n    [Module.Flat R B] [Nontrivial B] : Nontrivial (A âŠ—[R] B) :=\n  TensorProduct.nontrivial_of_linearMap_injective_of_flat_right R A B (Algebra.linearMap R A) h\n\n"}
