{"name":"CategoryTheory.Comma.ext","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nT : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nx y : CategoryTheory.Comma L R\nleft : Eq x.left y.left\nright : Eq x.right y.right\nhom : HEq x.hom y.hom\n‚ä¢ Eq x y","decl":"attribute [local ext] CategoryTheory.Comma\n\n"}
{"name":"CategoryTheory.Comma.ext_iff","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nT : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nx y : CategoryTheory.Comma L R\n‚ä¢ Iff (Eq x y) (And (Eq x.left y.left) (And (Eq x.right y.right) (HEq x.hom y.hom)))","decl":"attribute [local ext] CategoryTheory.Comma\n\n"}
{"name":"CategoryTheory.Subobject.ind","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\np : CategoryTheory.Subobject X ‚Üí Prop\nh : ‚àÄ ‚¶ÉA : C‚¶Ñ (f : Quiver.Hom A X) [inst : CategoryTheory.Mono f], p (CategoryTheory.Subobject.mk f)\nP : CategoryTheory.Subobject X\n‚ä¢ p P","decl":"protected theorem ind {X : C} (p : Subobject X ‚Üí Prop)\n    (h : ‚àÄ ‚¶ÉA : C‚¶Ñ (f : A ‚ü∂ X) [Mono f], p (Subobject.mk f)) (P : Subobject X) : p P := by\n  apply Quotient.inductionOn'\n  intro a\n  exact h a.arrow\n\n"}
{"name":"CategoryTheory.Subobject.ind‚ÇÇ","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\np : CategoryTheory.Subobject X ‚Üí CategoryTheory.Subobject X ‚Üí Prop\nh : ‚àÄ ‚¶ÉA B : C‚¶Ñ (f : Quiver.Hom A X) (g : Quiver.Hom B X) [inst : CategoryTheory.Mono f] [inst_1 : CategoryTheory.Mono g], p (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nP Q : CategoryTheory.Subobject X\n‚ä¢ p P Q","decl":"protected theorem ind‚ÇÇ {X : C} (p : Subobject X ‚Üí Subobject X ‚Üí Prop)\n    (h : ‚àÄ ‚¶ÉA B : C‚¶Ñ (f : A ‚ü∂ X) (g : B ‚ü∂ X) [Mono f] [Mono g],\n      p (Subobject.mk f) (Subobject.mk g))\n    (P Q : Subobject X) : p P Q := by\n  apply Quotient.inductionOn‚ÇÇ'\n  intro a b\n  exact h a.arrow b.arrow\n\n"}
{"name":"CategoryTheory.Subobject.lift_mk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ± : Sort u_1\nX : C\nF : ‚¶ÉA : C‚¶Ñ ‚Üí (f : Quiver.Hom A X) ‚Üí [inst : CategoryTheory.Mono f] ‚Üí Œ±\nh : ‚àÄ ‚¶ÉA B : C‚¶Ñ (f : Quiver.Hom A X) (g : Quiver.Hom B X) [inst : CategoryTheory.Mono f] [inst_1 : CategoryTheory.Mono g] (i : CategoryTheory.Iso A B), Eq (CategoryTheory.CategoryStruct.comp i.hom g) f ‚Üí Eq (F f) (F g)\nA : C\nf : Quiver.Hom A X\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Subobject.lift F h (CategoryTheory.Subobject.mk f)) (F f)","decl":"@[simp]\nprotected theorem lift_mk {Œ± : Sort*} {X : C} (F : ‚àÄ ‚¶ÉA : C‚¶Ñ (f : A ‚ü∂ X) [Mono f], Œ±) {h A}\n    (f : A ‚ü∂ X) [Mono f] : Subobject.lift F h (Subobject.mk f) = F f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.arrow_mono","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY : CategoryTheory.Subobject X\n‚ä¢ CategoryTheory.Mono Y.arrow","decl":"instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=\n  (representative.obj Y).property\n\n"}
{"name":"CategoryTheory.Subobject.arrow_congr","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : C\nX Y : CategoryTheory.Subobject A\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) Y.arrow) X.arrow","decl":"@[simp]\ntheorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :\n    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) ‚â´ Y.arrow = X.arrow := by\n  induction h\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.representative_coe","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY : CategoryTheory.Subobject X\n‚ä¢ Eq (CategoryTheory.Subobject.representative.obj Y).obj.left (CategoryTheory.Subobject.underlying.obj Y)","decl":"@[simp]\ntheorem representative_coe (Y : Subobject X) : (representative.obj Y : C) = (Y : C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.representative_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY : CategoryTheory.Subobject X\n‚ä¢ Eq (CategoryTheory.Subobject.representative.obj Y).arrow Y.arrow","decl":"@[simp]\ntheorem representative_arrow (Y : Subobject X) : (representative.obj Y).arrow = Y.arrow :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.underlying_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY Z : CategoryTheory.Subobject X\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlying.map f) Z.arrow) Y.arrow","decl":"@[reassoc (attr := simp)]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y ‚ü∂ Z) :\n    underlying.map f ‚â´ arrow Z = arrow Y :=\n  Over.w (representative.map f)\n\n"}
{"name":"CategoryTheory.Subobject.underlying_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY Z‚úù : CategoryTheory.Subobject X\nf : Quiver.Hom Y Z‚úù\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlying.map f) (CategoryTheory.CategoryStruct.comp Z‚úù.arrow h)) (CategoryTheory.CategoryStruct.comp Y.arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y ‚ü∂ Z) :\n    underlying.map f ‚â´ arrow Z = arrow Y :=\n  Over.w (representative.map f)\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.mk f).arrow h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ‚ü∂ Y) [Mono f] :\n    (underlyingIso f).inv ‚â´ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).inv (CategoryTheory.Subobject.mk f).arrow) f","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ‚ü∂ Y) [Mono f] :\n    (underlyingIso f).inv ‚â´ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq ((CategoryTheory.Subobject.mk f).arrow ((CategoryTheory.Subobject.underlyingIso f).inv x)) (f x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ‚ü∂ Y) [Mono f] :\n    (underlyingIso f).inv ‚â´ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).hom (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.mk f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X ‚ü∂ Y) [Mono f] :\n    (underlyingIso f).hom ‚â´ f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).hom f) (CategoryTheory.Subobject.mk f).arrow","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X ‚ü∂ Y) [Mono f] :\n    (underlyingIso f).hom ‚â´ f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comp_arrow_eq","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\nh : Eq (CategoryTheory.CategoryStruct.comp f P.arrow) (CategoryTheory.CategoryStruct.comp g P.arrow)\n‚ä¢ Eq f g","decl":"/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X ‚ü∂ P}\n    (h : f ‚â´ P.arrow = g ‚â´ P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comp_arrow_eq_iff","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\n‚ä¢ Iff (Eq f g) (Eq (CategoryTheory.CategoryStruct.comp f P.arrow) (CategoryTheory.CategoryStruct.comp g P.arrow))","decl":"/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X ‚ü∂ P}\n    (h : f ‚â´ P.arrow = g ‚â´ P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n\n"}
{"name":"CategoryTheory.Subobject.mk_le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf‚ÇÅ : Quiver.Hom A‚ÇÅ B\nf‚ÇÇ : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f‚ÇÅ\ninst‚úù : CategoryTheory.Mono f‚ÇÇ\ng : Quiver.Hom A‚ÇÅ A‚ÇÇ\nw : Eq (CategoryTheory.CategoryStruct.comp g f‚ÇÇ) f‚ÇÅ\n‚ä¢ LE.le (CategoryTheory.Subobject.mk f‚ÇÅ) (CategoryTheory.Subobject.mk f‚ÇÇ)","decl":"theorem mk_le_mk_of_comm {B A‚ÇÅ A‚ÇÇ : C} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B} [Mono f‚ÇÅ] [Mono f‚ÇÇ] (g : A‚ÇÅ ‚ü∂ A‚ÇÇ)\n    (w : g ‚â´ f‚ÇÇ = f‚ÇÅ) : mk f‚ÇÅ ‚â§ mk f‚ÇÇ :=\n  ‚ü®MonoOver.homMk _ w‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.mk_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nP : CategoryTheory.Subobject X\n‚ä¢ Eq (CategoryTheory.Subobject.mk P.arrow) P","decl":"@[simp]\ntheorem mk_arrow (P : Subobject X) : mk P.arrow = P :=\n  Quotient.inductionOn' P fun Q => by\n    obtain ‚ü®e‚ü© := @Quotient.mk_out' _ (isIsomorphicSetoid _) Q\n    exact Quotient.sound' ‚ü®MonoOver.isoMk (Iso.refl _) ‚â™‚â´ e‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.le_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) (CategoryTheory.Subobject.underlying.obj Y)\nw : Eq (CategoryTheory.CategoryStruct.comp f Y.arrow) X.arrow\n‚ä¢ LE.le X Y","decl":"theorem le_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ‚ü∂ (Y : C)) (w : f ‚â´ Y.arrow = X.arrow) :\n    X ‚â§ Y := by\n  convert mk_le_mk_of_comm _ w <;> simp\n\n"}
{"name":"CategoryTheory.Subobject.le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\ng : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) A\nw : Eq (CategoryTheory.CategoryStruct.comp g f) X.arrow\n‚ä¢ LE.le X (CategoryTheory.Subobject.mk f)","decl":"theorem le_mk_of_comm {B A : C} {X : Subobject B} {f : A ‚ü∂ B} [Mono f] (g : (X : C) ‚ü∂ A)\n    (w : g ‚â´ f = X.arrow) : X ‚â§ mk f :=\n  le_of_comm (g ‚â´ (underlyingIso f).inv) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_le_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\ng : Quiver.Hom A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp g X.arrow) f\n‚ä¢ LE.le (CategoryTheory.Subobject.mk f) X","decl":"theorem mk_le_of_comm {B A : C} {X : Subobject B} {f : A ‚ü∂ B} [Mono f] (g : A ‚ü∂ (X : C))\n    (w : g ‚â´ X.arrow = f) : mk f ‚â§ X :=\n  le_of_comm ((underlyingIso f).hom ‚â´ g) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nf : CategoryTheory.Iso (CategoryTheory.Subobject.underlying.obj X) (CategoryTheory.Subobject.underlying.obj Y)\nw : Eq (CategoryTheory.CategoryStruct.comp f.hom Y.arrow) X.arrow\n‚ä¢ Eq X Y","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext (iff := false)]\ntheorem eq_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ‚âÖ (Y : C))\n    (w : f.hom ‚â´ Y.arrow = X.arrow) : X = Y :=\n  le_antisymm (le_of_comm f.hom w) <| le_of_comm f.inv <| f.inv_comp_eq.2 w.symm\n\n"}
{"name":"CategoryTheory.Subobject.eq_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\ni : CategoryTheory.Iso (CategoryTheory.Subobject.underlying.obj X) A\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom f) X.arrow\n‚ä¢ Eq X (CategoryTheory.Subobject.mk f)","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem eq_mk_of_comm {B A : C} {X : Subobject B} (f : A ‚ü∂ B) [Mono f] (i : (X : C) ‚âÖ A)\n    (w : i.hom ‚â´ f = X.arrow) : X = mk f :=\n  eq_of_comm (i.trans (underlyingIso f).symm) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\ni : CategoryTheory.Iso A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom X.arrow) f\n‚ä¢ Eq (CategoryTheory.Subobject.mk f) X","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem mk_eq_of_comm {B A : C} {X : Subobject B} (f : A ‚ü∂ B) [Mono f] (i : A ‚âÖ (X : C))\n    (w : i.hom ‚â´ X.arrow = f) : mk f = X :=\n  Eq.symm <| eq_mk_of_comm _ i.symm <| by rw [Iso.symm_hom, Iso.inv_comp_eq, w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\ni : CategoryTheory.Iso A‚ÇÅ A‚ÇÇ\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom g) f\n‚ä¢ Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem mk_eq_mk_of_comm {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [Mono f] [Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n    (w : i.hom ‚â´ g = f) : mk f = mk g :=\n  eq_mk_of_comm _ ((underlyingIso f).trans i) <| by simp [w]\n\n-- We make `X` and `Y` explicit arguments here so that when `ofLE` appears in goal statements\n-- it is possible to see its source and target\n-- (`h` will just display as `_`, because it is in `Prop`).\n"}
{"name":"CategoryTheory.Subobject.ofLE_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : LE.le X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h) Y.arrow) X.arrow","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X ‚â§ Y) : ofLE X Y h ‚â´ Y.arrow = X.arrow :=\n  underlying_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nh‚úù : LE.le X Y\nZ : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚úù) (CategoryTheory.CategoryStruct.comp Y.arrow h)) (CategoryTheory.CategoryStruct.comp X.arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X ‚â§ Y) : ofLE X Y h ‚â´ Y.arrow = X.arrow :=\n  underlying_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : LE.le X Y\n‚ä¢ CategoryTheory.Mono (X.ofLE Y h)","decl":"instance {B : C} (X Y : Subobject B) (h : X ‚â§ Y) : Mono (ofLE X Y h) := by\n  fconstructor\n  intro Z f g w\n  replace w := w =‚â´ Y.arrow\n  ext\n  simpa using w\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_mk_le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf‚ÇÅ : Quiver.Hom A‚ÇÅ B\nf‚ÇÇ : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f‚ÇÅ\ninst‚úù : CategoryTheory.Mono f‚ÇÇ\ng : Quiver.Hom A‚ÇÅ A‚ÇÇ\nw : Eq (CategoryTheory.CategoryStruct.comp g f‚ÇÇ) f‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.Subobject.mk f‚ÇÅ).ofLE (CategoryTheory.Subobject.mk f‚ÇÇ) ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f‚ÇÅ).hom (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Subobject.underlyingIso f‚ÇÇ).inv))","decl":"theorem ofLE_mk_le_mk_of_comm {B A‚ÇÅ A‚ÇÇ : C} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B} [Mono f‚ÇÅ] [Mono f‚ÇÇ]\n    (g : A‚ÇÅ ‚ü∂ A‚ÇÇ) (w : g ‚â´ f‚ÇÇ = f‚ÇÅ) :\n    ofLE _ _ (mk_le_mk_of_comm g w) = (underlyingIso _).hom ‚â´ g ‚â´ (underlyingIso _).inv := by\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh : LE.le X (CategoryTheory.Subobject.mk f)\n‚ä¢ CategoryTheory.Mono (X.ofLEMk f h)","decl":"instance {B A : C} (X : Subobject B) (f : A ‚ü∂ B) [Mono f] (h : X ‚â§ mk f) :\n    Mono (ofLEMk X f h) := by\n  dsimp only [ofLEMk]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh : LE.le X (CategoryTheory.Subobject.mk f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h) f) X.arrow","decl":"@[simp]\ntheorem ofLEMk_comp {B A : C} {X : Subobject B} {f : A ‚ü∂ B} [Mono f] (h : X ‚â§ mk f) :\n    ofLEMk X f h ‚â´ f = X.arrow := by simp [ofLEMk]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : LE.le (CategoryTheory.Subobject.mk f) X\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Subobject.ofMkLE f X h)","decl":"instance {B A : C} (f : A ‚ü∂ B) [Mono f] (X : Subobject B) (h : mk f ‚â§ X) :\n    Mono (ofMkLE f X h) := by\n  dsimp only [ofMkLE]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : LE.le (CategoryTheory.Subobject.mk f) X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h) X.arrow) f","decl":"@[simp]\ntheorem ofMkLE_arrow {B A : C} {f : A ‚ü∂ B} [Mono f] {X : Subobject B} (h : mk f ‚â§ X) :\n    ofMkLE f X h ‚â´ X.arrow = f := by simp [ofMkLE]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\nh : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Subobject.ofMkLEMk f g h)","decl":"instance {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [Mono f] [Mono g] (h : mk f ‚â§ mk g) :\n    Mono (ofMkLEMk f g h) := by\n  dsimp only [ofMkLEMk]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\nh : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h) g) f","decl":"@[simp]\ntheorem ofMkLEMk_comp {B A‚ÇÅ A‚ÇÇ : C} {f : A‚ÇÅ ‚ü∂ B} {g : A‚ÇÇ ‚ü∂ B} [Mono f] [Mono g] (h : mk f ‚â§ mk g) :\n    ofMkLEMk f g h ‚â´ g = f := by simp [ofMkLEMk]\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y Z‚úù : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le X Y\nh‚ÇÇ : LE.le Y Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (Y.ofLE Z‚úù h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (X.ofLE Z‚úù ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h‚ÇÅ : X ‚â§ Y) (h‚ÇÇ : Y ‚â§ Z) :\n    ofLE X Y h‚ÇÅ ‚â´ ofLE Y Z h‚ÇÇ = ofLE X Z (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofLE, ‚Üê Functor.map_comp underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y Z : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le X Y\nh‚ÇÇ : LE.le Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚ÇÅ) (Y.ofLE Z h‚ÇÇ)) (X.ofLE Z ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h‚ÇÅ : X ‚â§ Y) (h‚ÇÇ : Y ‚â§ Z) :\n    ofLE X Y h‚ÇÅ ‚â´ ofLE Y Z h‚ÇÇ = ofLE X Z (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofLE, ‚Üê Functor.map_comp underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh‚ÇÅ : LE.le X Y\nh‚ÇÇ : LE.le Y (CategoryTheory.Subobject.mk f)\nZ : C\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (Y.ofLEMk f h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (X.ofLEMk f ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A ‚ü∂ B) [Mono f] (h‚ÇÅ : X ‚â§ Y)\n    (h‚ÇÇ : Y ‚â§ mk f) : ofLE X Y h‚ÇÅ ‚â´ ofLEMk Y f h‚ÇÇ = ofLEMk X f (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ‚Üê Functor.map_comp_assoc underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh‚ÇÅ : LE.le X Y\nh‚ÇÇ : LE.le Y (CategoryTheory.Subobject.mk f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚ÇÅ) (Y.ofLEMk f h‚ÇÇ)) (X.ofLEMk f ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A ‚ü∂ B) [Mono f] (h‚ÇÅ : X ‚â§ Y)\n    (h‚ÇÇ : Y ‚â§ mk f) : ofLE X Y h‚ÇÅ ‚â´ ofLEMk Y f h‚ÇÇ = ofLEMk X f (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ‚Üê Functor.map_comp_assoc underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nY : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le X (CategoryTheory.Subobject.mk f)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk f) Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f Y h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (X.ofLE Y ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A ‚ü∂ B) [Mono f] (Y : Subobject B)\n    (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ Y) : ofLEMk X f h‚ÇÅ ‚â´ ofMkLE f Y h‚ÇÇ = ofLE X Y (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ‚Üê Functor.map_comp underlying, assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nY : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le X (CategoryTheory.Subobject.mk f)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk f) Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h‚ÇÅ) (CategoryTheory.Subobject.ofMkLE f Y h‚ÇÇ)) (X.ofLE Y ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A ‚ü∂ B) [Mono f] (Y : Subobject B)\n    (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ Y) : ofLEMk X f h‚ÇÅ ‚â´ ofMkLE f Y h‚ÇÇ = ofLE X Y (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ‚Üê Functor.map_comp underlying, assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nh‚ÇÅ : LE.le X (CategoryTheory.Subobject.mk f)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nZ : C\nh : Quiver.Hom A‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (X.ofLEMk g ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLEMk {B A‚ÇÅ A‚ÇÇ : C} (X : Subobject B) (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B)\n    [Mono g] (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ mk g) :\n    ofLEMk X f h‚ÇÅ ‚â´ ofMkLEMk f g h‚ÇÇ = ofLEMk X g (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nh‚ÇÅ : LE.le X (CategoryTheory.Subobject.mk f)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h‚ÇÅ) (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÇ)) (X.ofLEMk g ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLEMk {B A‚ÇÅ A‚ÇÇ : C} (X : Subobject B) (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B)\n    [Mono g] (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ mk g) :\n    ofLEMk X f h‚ÇÅ ‚â´ ofMkLEMk f g h‚ÇÇ = ofLEMk X g (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù : CategoryTheory.Mono f\nX Y : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) X\nh‚ÇÇ : LE.le X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (X.ofLE Y h‚ÇÇ)) (CategoryTheory.Subobject.ofMkLE f Y ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLE {B A‚ÇÅ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (X Y : Subobject B) (h‚ÇÅ : mk f ‚â§ X)\n    (h‚ÇÇ : X ‚â§ Y) : ofMkLE f X h‚ÇÅ ‚â´ ofLE X Y h‚ÇÇ = ofMkLE f Y (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp underlying,\n    assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù : CategoryTheory.Mono f\nX Y : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) X\nh‚ÇÇ : LE.le X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (X.ofLE Y h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f Y ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLE {B A‚ÇÅ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (X Y : Subobject B) (h‚ÇÅ : mk f ‚â§ X)\n    (h‚ÇÇ : X ‚â§ Y) : ofMkLE f X h‚ÇÅ ‚â´ ofLE X Y h‚ÇÇ = ofMkLE f Y (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp underlying,\n    assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) X\nh‚ÇÇ : LE.le X (CategoryTheory.Subobject.mk g)\nZ : C\nh : Quiver.Hom A‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (X.ofLEMk g h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLEMk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (X : Subobject B) (g : A‚ÇÇ ‚ü∂ B)\n    [Mono g] (h‚ÇÅ : mk f ‚â§ X) (h‚ÇÇ : X ‚â§ mk g) :\n    ofMkLE f X h‚ÇÅ ‚â´ ofLEMk X g h‚ÇÇ = ofMkLEMk f g (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying, assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) X\nh‚ÇÇ : LE.le X (CategoryTheory.Subobject.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (X.ofLEMk g h‚ÇÇ)) (CategoryTheory.Subobject.ofMkLEMk f g ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLEMk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (X : Subobject B) (g : A‚ÇÇ ‚ü∂ B)\n    [Mono g] (h‚ÇÅ : mk f ‚â§ X) (h‚ÇÇ : X ‚â§ mk g) :\n    ofMkLE f X h‚ÇÅ ‚â´ ofLEMk X g h‚ÇÇ = ofMkLEMk f g (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying, assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nX : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk g) X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÅ) (CategoryTheory.Subobject.ofMkLE g X h‚ÇÇ)) (CategoryTheory.Subobject.ofMkLE f X ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLE {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B) [Mono g]\n    (X : Subobject B) (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ X) :\n    ofMkLEMk f g h‚ÇÅ ‚â´ ofMkLE g X h‚ÇÇ = ofMkLE f X (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬π : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù : CategoryTheory.Mono g\nX : CategoryTheory.Subobject B\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk g) X\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE g X h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLE {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B) [Mono g]\n    (X : Subobject B) (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ X) :\n    ofMkLEMk f g h‚ÇÅ ‚â´ ofMkLE g X h‚ÇÇ = ofMkLE f X (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ A‚ÇÉ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬≤ : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono g\nh : Quiver.Hom A‚ÇÉ B\ninst‚úù : CategoryTheory.Mono h\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk g) (CategoryTheory.Subobject.mk h)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÅ) (CategoryTheory.Subobject.ofMkLEMk g h h‚ÇÇ)) (CategoryTheory.Subobject.ofMkLEMk f h ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLEMk {B A‚ÇÅ A‚ÇÇ A‚ÇÉ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B) [Mono g]\n    (h : A‚ÇÉ ‚ü∂ B) [Mono h] (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ mk h) :\n    ofMkLEMk f g h‚ÇÅ ‚â´ ofMkLEMk g h h‚ÇÇ = ofMkLEMk f h (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying, assoc,\n    Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ A‚ÇÉ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù¬≤ : CategoryTheory.Mono f\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono g\nh‚úù : Quiver.Hom A‚ÇÉ B\ninst‚úù : CategoryTheory.Mono h‚úù\nh‚ÇÅ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh‚ÇÇ : LE.le (CategoryTheory.Subobject.mk g) (CategoryTheory.Subobject.mk h‚úù)\nZ : C\nh : Quiver.Hom A‚ÇÉ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk g h‚úù h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f h‚úù ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLEMk {B A‚ÇÅ A‚ÇÇ A‚ÇÉ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] (g : A‚ÇÇ ‚ü∂ B) [Mono g]\n    (h : A‚ÇÉ ‚ü∂ B) [Mono h] (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ mk h) :\n    ofMkLEMk f g h‚ÇÅ ‚â´ ofMkLEMk g h h‚ÇÇ = ofMkLEMk f h (h‚ÇÅ.trans h‚ÇÇ) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ‚Üê Functor.map_comp_assoc underlying, assoc,\n    Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_refl","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX : CategoryTheory.Subobject B\n‚ä¢ Eq (X.ofLE X ‚ãØ) (CategoryTheory.CategoryStruct.id (CategoryTheory.Subobject.underlying.obj X))","decl":"@[simp]\ntheorem ofLE_refl {B : C} (X : Subobject B) : ofLE X X le_rfl = ùüô _ := by\n  apply (cancel_mono X.arrow).mp\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_refl","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ : C\nf : Quiver.Hom A‚ÇÅ B\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Subobject.ofMkLEMk f f ‚ãØ) (CategoryTheory.CategoryStruct.id A‚ÇÅ)","decl":"@[simp]\ntheorem ofMkLEMk_refl {B A‚ÇÅ : C} (f : A‚ÇÅ ‚ü∂ B) [Mono f] : ofMkLEMk f f le_rfl = ùüô _ := by\n  apply (cancel_mono f).mp\n  simp\n\n-- As with `ofLE`, we have `X` and `Y` as explicit arguments for readability.\n"}
{"name":"CategoryTheory.Subobject.isoOfEq_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : Eq X Y\n‚ä¢ Eq (X.isoOfEq Y h).hom (X.ofLE Y ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) -/\n@[simps]\ndef isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) ‚âÖ (Y : C) where\n  hom := ofLE _ _ h.le\n  inv := ofLE _ _ h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEq_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : Eq X Y\n‚ä¢ Eq (X.isoOfEq Y h).inv (Y.ofLE X ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) -/\n@[simps]\ndef isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) ‚âÖ (Y : C) where\n  hom := ofLE _ _ h.le\n  inv := ofLE _ _ h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEqMk_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh : Eq X (CategoryTheory.Subobject.mk f)\n‚ä¢ Eq (X.isoOfEqMk f h).hom (X.ofLEMk f ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfEqMk {B A : C} (X : Subobject B) (f : A ‚ü∂ B) [Mono f] (h : X = mk f) : (X : C) ‚âÖ A where\n  hom := ofLEMk X f h.le\n  inv := ofMkLE f X h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEqMk_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nh : Eq X (CategoryTheory.Subobject.mk f)\n‚ä¢ Eq (X.isoOfEqMk f h).inv (CategoryTheory.Subobject.ofMkLE f X ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfEqMk {B A : C} (X : Subobject B) (f : A ‚ü∂ B) [Mono f] (h : X = mk f) : (X : C) ‚âÖ A where\n  hom := ofLEMk X f h.le\n  inv := ofMkLE f X h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEq_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : Eq (CategoryTheory.Subobject.mk f) X\n‚ä¢ Eq (CategoryTheory.Subobject.isoOfMkEq f X h).inv (X.ofLEMk f ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEq {B A : C} (f : A ‚ü∂ B) [Mono f] (X : Subobject B) (h : mk f = X) : A ‚âÖ (X : C) where\n  hom := ofMkLE f X h.le\n  inv := ofLEMk X f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEq_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : Eq (CategoryTheory.Subobject.mk f) X\n‚ä¢ Eq (CategoryTheory.Subobject.isoOfMkEq f X h).hom (CategoryTheory.Subobject.ofMkLE f X ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEq {B A : C} (f : A ‚ü∂ B) [Mono f] (X : Subobject B) (h : mk f = X) : A ‚âÖ (X : C) where\n  hom := ofMkLE f X h.le\n  inv := ofLEMk X f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEqMk_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\nh : Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n‚ä¢ Eq (CategoryTheory.Subobject.isoOfMkEqMk f g h).inv (CategoryTheory.Subobject.ofMkLEMk g f ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEqMk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [Mono f] [Mono g] (h : mk f = mk g) :\n    A‚ÇÅ ‚âÖ A‚ÇÇ where\n  hom := ofMkLEMk f g h.le\n  inv := ofMkLEMk g f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEqMk_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nB A‚ÇÅ A‚ÇÇ : C\nf : Quiver.Hom A‚ÇÅ B\ng : Quiver.Hom A‚ÇÇ B\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\nh : Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n‚ä¢ Eq (CategoryTheory.Subobject.isoOfMkEqMk f g h).hom (CategoryTheory.Subobject.ofMkLEMk f g ‚ãØ)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEqMk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [Mono f] [Mono g] (h : mk f = mk g) :\n    A‚ÇÅ ‚âÖ A‚ÇÇ where\n  hom := ofMkLEMk f g h.le\n  inv := ofMkLEMk g f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.lower_iso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (CategoryTheory.MonoOver X) (CategoryTheory.MonoOver Y)\nh : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Subobject.lower F‚ÇÅ) (CategoryTheory.Subobject.lower F‚ÇÇ)","decl":"/-- Isomorphic functors become equal when lowered to `Subobject`.\n(It's not as evil as usual to talk about equality between functors\nbecause the categories are thin and skeletal.) -/\ntheorem lower_iso (F‚ÇÅ F‚ÇÇ : MonoOver X ‚•§ MonoOver Y) (h : F‚ÇÅ ‚âÖ F‚ÇÇ) : lower F‚ÇÅ = lower F‚ÇÇ :=\n  ThinSkeleton.map_iso_eq h\n\n"}
{"name":"CategoryTheory.Subobject.lower_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF : CategoryTheory.Functor (CategoryTheory.MonoOver Y) (CategoryTheory.MonoOver X)\n‚ä¢ Eq ((CategoryTheory.toThinSkeleton (CategoryTheory.MonoOver Y)).comp (CategoryTheory.Subobject.lower F)) (F.comp (CategoryTheory.toThinSkeleton (CategoryTheory.MonoOver X)))","decl":"@[simp]\ntheorem lower_comm (F : MonoOver Y ‚•§ MonoOver X) :\n    toThinSkeleton _ ‚ãô lower F = F ‚ãô toThinSkeleton _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_counitIso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n‚ä¢ Eq (CategoryTheory.Subobject.lowerEquivalence e).counitIso (CategoryTheory.eqToIso ‚ãØ)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ‚âå MonoOver B) : Subobject A ‚âå Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_inverse","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n‚ä¢ Eq (CategoryTheory.Subobject.lowerEquivalence e).inverse (CategoryTheory.Subobject.lower e.inverse)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ‚âå MonoOver B) : Subobject A ‚âå Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_unitIso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n‚ä¢ Eq (CategoryTheory.Subobject.lowerEquivalence e).unitIso (CategoryTheory.eqToIso ‚ãØ)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ‚âå MonoOver B) : Subobject A ‚âå Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_functor","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n‚ä¢ Eq (CategoryTheory.Subobject.lowerEquivalence e).functor (CategoryTheory.Subobject.lower e.functor)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ‚âå MonoOver B) : Subobject A ‚âå Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    ¬∑ exact (ThinSkeleton.map_comp_eq _ _).symm\n    ¬∑ exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.pullback_id","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nx : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback (CategoryTheory.CategoryStruct.id X)).obj x) x","decl":"theorem pullback_id (x : Subobject X) : (pullback (ùüô X)).obj x = x := by\n  induction' x using Quotient.inductionOn' with f\n  exact Quotient.sound ‚ü®MonoOver.pullbackId.app f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.pullback_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : CategoryTheory.Subobject Z\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback (CategoryTheory.CategoryStruct.comp f g)).obj x) ((CategoryTheory.Subobject.pullback f).obj ((CategoryTheory.Subobject.pullback g).obj x))","decl":"theorem pullback_comp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : Subobject Z) :\n    (pullback (f ‚â´ g)).obj x = (pullback f).obj ((pullback g).obj x) := by\n  induction' x using Quotient.inductionOn' with t\n  exact Quotient.sound ‚ü®(MonoOver.pullbackComp _ _).app t‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.instFaithfulPullback","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.Subobject.pullback f).Faithful","decl":"instance (f : X ‚ü∂ Y) : (pullback f).Faithful where\n\n"}
{"name":"CategoryTheory.Subobject.map_id","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nx : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Subobject.map (CategoryTheory.CategoryStruct.id X)).obj x) x","decl":"theorem map_id (x : Subobject X) : (map (ùüô X)).obj x = x := by\n  induction' x using Quotient.inductionOn' with f\n  exact Quotient.sound ‚ü®(MonoOver.mapId _).app f‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.map_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.Mono g\nx : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Subobject.map (CategoryTheory.CategoryStruct.comp f g)).obj x) ((CategoryTheory.Subobject.map g).obj ((CategoryTheory.Subobject.map f).obj x))","decl":"theorem map_comp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [Mono f] [Mono g] (x : Subobject X) :\n    (map (f ‚â´ g)).obj x = (map g).obj ((map f).obj x) := by\n  induction' x using Quotient.inductionOn' with t\n  exact Quotient.sound ‚ü®(MonoOver.mapComp _ _).app t‚ü©\n\n"}
{"name":"CategoryTheory.Subobject.mapIsoToOrderIso_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ne : CategoryTheory.Iso X Y\nP : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Subobject.mapIsoToOrderIso e) P) ((CategoryTheory.Subobject.map e.hom).obj P)","decl":"@[simp]\ntheorem mapIsoToOrderIso_apply (e : X ‚âÖ Y) (P : Subobject X) :\n    mapIsoToOrderIso e P = (map e.hom).obj P :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.mapIsoToOrderIso_symm_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ne : CategoryTheory.Iso X Y\nQ : CategoryTheory.Subobject Y\n‚ä¢ Eq ((CategoryTheory.Subobject.mapIsoToOrderIso e).symm Q) ((CategoryTheory.Subobject.map e.inv).obj Q)","decl":"@[simp]\ntheorem mapIsoToOrderIso_symm_apply (e : X ‚âÖ Y) (Q : Subobject Y) :\n    (mapIsoToOrderIso e).symm Q = (map e.inv).obj Q :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.pullback_map_self","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\ng : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Subobject.pullback f).obj ((CategoryTheory.Subobject.map f).obj g)) g","decl":"@[simp]\ntheorem pullback_map_self [HasPullbacks C] (f : X ‚ü∂ Y) [Mono f] (g : Subobject X) :\n    (pullback f).obj ((map f).obj g) = g := by\n  revert g\n  exact Quotient.ind (fun g' => Quotient.sound ‚ü®(MonoOver.pullbackMapSelf f).app _‚ü©)\n\n"}
{"name":"CategoryTheory.Subobject.map_pullback","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullbacks C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\ninst‚úù¬π : CategoryTheory.Mono h\ninst‚úù : CategoryTheory.Mono g\ncomm : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\nt : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk f g comm)\np : CategoryTheory.Subobject Y\n‚ä¢ Eq ((CategoryTheory.Subobject.map g).obj ((CategoryTheory.Subobject.pullback f).obj p)) ((CategoryTheory.Subobject.pullback k).obj ((CategoryTheory.Subobject.map h).obj p))","decl":"theorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W}\n    [Mono h] [Mono g] (comm : f ‚â´ h = g ‚â´ k) (t : IsLimit (PullbackCone.mk f g comm))\n    (p : Subobject Y) : (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) := by\n  revert p\n  apply Quotient.ind'\n  intro a\n  apply Quotient.sound\n  apply ThinSkeleton.equiv_of_both_ways\n  ¬∑ refine MonoOver.homMk (pullback.lift (pullback.fst _ _) _ ?_) (pullback.lift_snd _ _ _)\n    change _ ‚â´ a.arrow ‚â´ h = (pullback.snd _ _ ‚â´ g) ‚â´ _\n    rw [assoc, ‚Üê comm, pullback.condition_assoc]\n  ¬∑ refine MonoOver.homMk (pullback.lift (pullback.fst _ _)\n      (PullbackCone.IsLimit.lift t (pullback.fst _ _ ‚â´ a.arrow) (pullback.snd _ _) _)\n      (PullbackCone.IsLimit.lift_fst _ _ _ ?_).symm) ?_\n    ¬∑ rw [‚Üê pullback.condition, assoc]\n      rfl\n    ¬∑ dsimp\n      rw [pullback.lift_snd_assoc]\n      apply PullbackCone.IsLimit.lift_snd\n\n"}
{"name":"CategoryTheory.Subobject.exists_iso_map","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Subobject.exists f) (CategoryTheory.Subobject.map f)","decl":"/-- When `f : X ‚ü∂ Y` is a monomorphism, `exists f` agrees with `map f`.\n-/\ntheorem exists_iso_map (f : X ‚ü∂ Y) [Mono f] : ¬´exists¬ª f = map f :=\n  lower_iso _ _ (MonoOver.existsIsoMap f)\n\n"}
