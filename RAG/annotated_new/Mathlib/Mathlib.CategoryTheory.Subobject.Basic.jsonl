{"name":"CategoryTheory.Comma.ext","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nx y : CategoryTheory.Comma L R\nleft : Eq x.left y.left\nright : Eq x.right y.right\nhom : HEq x.hom y.hom\n⊢ Eq x y","decl":"attribute [local ext] CategoryTheory.Comma\n\n"}
{"name":"CategoryTheory.Comma.ext_iff","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nx y : CategoryTheory.Comma L R\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (And (Eq x.right y.right) (HEq x.hom y.hom)))","decl":"attribute [local ext] CategoryTheory.Comma\n\n"}
{"name":"CategoryTheory.Subobject.ind","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\np : CategoryTheory.Subobject X → Prop\nh : ∀ ⦃A : C⦄ (f : Quiver.Hom A X) [inst : CategoryTheory.Mono f], p (CategoryTheory.Subobject.mk f)\nP : CategoryTheory.Subobject X\n⊢ p P","decl":"protected theorem ind {X : C} (p : Subobject X → Prop)\n    (h : ∀ ⦃A : C⦄ (f : A ⟶ X) [Mono f], p (Subobject.mk f)) (P : Subobject X) : p P := by\n  apply Quotient.inductionOn'\n  intro a\n  exact h a.arrow\n\n"}
{"name":"CategoryTheory.Subobject.ind₂","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\np : CategoryTheory.Subobject X → CategoryTheory.Subobject X → Prop\nh : ∀ ⦃A B : C⦄ (f : Quiver.Hom A X) (g : Quiver.Hom B X) [inst : CategoryTheory.Mono f] [inst_1 : CategoryTheory.Mono g], p (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nP Q : CategoryTheory.Subobject X\n⊢ p P Q","decl":"protected theorem ind₂ {X : C} (p : Subobject X → Subobject X → Prop)\n    (h : ∀ ⦃A B : C⦄ (f : A ⟶ X) (g : B ⟶ X) [Mono f] [Mono g],\n      p (Subobject.mk f) (Subobject.mk g))\n    (P Q : Subobject X) : p P Q := by\n  apply Quotient.inductionOn₂'\n  intro a b\n  exact h a.arrow b.arrow\n\n"}
{"name":"CategoryTheory.Subobject.lift_mk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Sort u_1\nX : C\nF : ⦃A : C⦄ → (f : Quiver.Hom A X) → [inst : CategoryTheory.Mono f] → α\nh : ∀ ⦃A B : C⦄ (f : Quiver.Hom A X) (g : Quiver.Hom B X) [inst : CategoryTheory.Mono f] [inst_1 : CategoryTheory.Mono g] (i : CategoryTheory.Iso A B), Eq (CategoryTheory.CategoryStruct.comp i.hom g) f → Eq (F f) (F g)\nA : C\nf : Quiver.Hom A X\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Subobject.lift F h (CategoryTheory.Subobject.mk f)) (F f)","decl":"@[simp]\nprotected theorem lift_mk {α : Sort*} {X : C} (F : ∀ ⦃A : C⦄ (f : A ⟶ X) [Mono f], α) {h A}\n    (f : A ⟶ X) [Mono f] : Subobject.lift F h (Subobject.mk f) = F f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.arrow_mono","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nY : CategoryTheory.Subobject X\n⊢ CategoryTheory.Mono Y.arrow","decl":"instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=\n  (representative.obj Y).property\n\n"}
{"name":"CategoryTheory.Subobject.arrow_congr","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA : C\nX Y : CategoryTheory.Subobject A\nh : Eq X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) Y.arrow) X.arrow","decl":"@[simp]\ntheorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :\n    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) ≫ Y.arrow = X.arrow := by\n  induction h\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.representative_coe","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nY : CategoryTheory.Subobject X\n⊢ Eq (CategoryTheory.Subobject.representative.obj Y).obj.left (CategoryTheory.Subobject.underlying.obj Y)","decl":"@[simp]\ntheorem representative_coe (Y : Subobject X) : (representative.obj Y : C) = (Y : C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.representative_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nY : CategoryTheory.Subobject X\n⊢ Eq (CategoryTheory.Subobject.representative.obj Y).arrow Y.arrow","decl":"@[simp]\ntheorem representative_arrow (Y : Subobject X) : (representative.obj Y).arrow = Y.arrow :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.underlying_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nY Z : CategoryTheory.Subobject X\nf : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlying.map f) Z.arrow) Y.arrow","decl":"@[reassoc (attr := simp)]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y ⟶ Z) :\n    underlying.map f ≫ arrow Z = arrow Y :=\n  Over.w (representative.map f)\n\n"}
{"name":"CategoryTheory.Subobject.underlying_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nY Z✝ : CategoryTheory.Subobject X\nf : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlying.map f) (CategoryTheory.CategoryStruct.comp Z✝.arrow h)) (CategoryTheory.CategoryStruct.comp Y.arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y ⟶ Z) :\n    underlying.map f ≫ arrow Z = arrow Y :=\n  Over.w (representative.map f)\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.mk f).arrow h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ⟶ Y) [Mono f] :\n    (underlyingIso f).inv ≫ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).inv (CategoryTheory.Subobject.mk f).arrow) f","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ⟶ Y) [Mono f] :\n    (underlyingIso f).inv ≫ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj X\n⊢ Eq ((CategoryTheory.Subobject.mk f).arrow ((CategoryTheory.Subobject.underlyingIso f).inv x)) (f x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X ⟶ Y) [Mono f] :\n    (underlyingIso f).inv ≫ (Subobject.mk f).arrow = f :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).hom (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.mk f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X ⟶ Y) [Mono f] :\n    (underlyingIso f).hom ≫ f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm\n\n"}
{"name":"CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f).hom f) (CategoryTheory.Subobject.mk f).arrow","decl":"@[reassoc (attr := simp)]\ntheorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X ⟶ Y) [Mono f] :\n    (underlyingIso f).hom ≫ f = (mk f).arrow :=\n  (Iso.eq_inv_comp _).1 (underlyingIso_arrow f).symm\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comp_arrow_eq","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\nh : Eq (CategoryTheory.CategoryStruct.comp f P.arrow) (CategoryTheory.CategoryStruct.comp g P.arrow)\n⊢ Eq f g","decl":"/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X ⟶ P}\n    (h : f ≫ P.arrow = g ≫ P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comp_arrow_eq_iff","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nP : CategoryTheory.Subobject Y\nf g : Quiver.Hom X (CategoryTheory.Subobject.underlying.obj P)\n⊢ Iff (Eq f g) (Eq (CategoryTheory.CategoryStruct.comp f P.arrow) (CategoryTheory.CategoryStruct.comp g P.arrow))","decl":"/-- Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal -/\n@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X ⟶ P}\n    (h : f ≫ P.arrow = g ≫ P.arrow) : f = g :=\n  (cancel_mono P.arrow).mp h\n\n"}
{"name":"CategoryTheory.Subobject.mk_le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf₁ : Quiver.Hom A₁ B\nf₂ : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f₁\ninst✝ : CategoryTheory.Mono f₂\ng : Quiver.Hom A₁ A₂\nw : Eq (CategoryTheory.CategoryStruct.comp g f₂) f₁\n⊢ LE.le (CategoryTheory.Subobject.mk f₁) (CategoryTheory.Subobject.mk f₂)","decl":"theorem mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : A₁ ⟶ B} {f₂ : A₂ ⟶ B} [Mono f₁] [Mono f₂] (g : A₁ ⟶ A₂)\n    (w : g ≫ f₂ = f₁) : mk f₁ ≤ mk f₂ :=\n  ⟨MonoOver.homMk _ w⟩\n\n"}
{"name":"CategoryTheory.Subobject.mk_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Subobject X\n⊢ Eq (CategoryTheory.Subobject.mk P.arrow) P","decl":"@[simp]\ntheorem mk_arrow (P : Subobject X) : mk P.arrow = P :=\n  Quotient.inductionOn' P fun Q => by\n    obtain ⟨e⟩ := @Quotient.mk_out' _ (isIsomorphicSetoid _) Q\n    exact Quotient.sound' ⟨MonoOver.isoMk (Iso.refl _) ≪≫ e⟩\n\n"}
{"name":"CategoryTheory.Subobject.le_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) (CategoryTheory.Subobject.underlying.obj Y)\nw : Eq (CategoryTheory.CategoryStruct.comp f Y.arrow) X.arrow\n⊢ LE.le X Y","decl":"theorem le_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ⟶ (Y : C)) (w : f ≫ Y.arrow = X.arrow) :\n    X ≤ Y := by\n  convert mk_le_mk_of_comm _ w <;> simp\n\n"}
{"name":"CategoryTheory.Subobject.le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\ng : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) A\nw : Eq (CategoryTheory.CategoryStruct.comp g f) X.arrow\n⊢ LE.le X (CategoryTheory.Subobject.mk f)","decl":"theorem le_mk_of_comm {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (g : (X : C) ⟶ A)\n    (w : g ≫ f = X.arrow) : X ≤ mk f :=\n  le_of_comm (g ≫ (underlyingIso f).inv) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_le_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\ng : Quiver.Hom A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp g X.arrow) f\n⊢ LE.le (CategoryTheory.Subobject.mk f) X","decl":"theorem mk_le_of_comm {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (g : A ⟶ (X : C))\n    (w : g ≫ X.arrow = f) : mk f ≤ X :=\n  le_of_comm ((underlyingIso f).hom ≫ g) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nf : CategoryTheory.Iso (CategoryTheory.Subobject.underlying.obj X) (CategoryTheory.Subobject.underlying.obj Y)\nw : Eq (CategoryTheory.CategoryStruct.comp f.hom Y.arrow) X.arrow\n⊢ Eq X Y","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\n@[ext (iff := false)]\ntheorem eq_of_comm {B : C} {X Y : Subobject B} (f : (X : C) ≅ (Y : C))\n    (w : f.hom ≫ Y.arrow = X.arrow) : X = Y :=\n  le_antisymm (le_of_comm f.hom w) <| le_of_comm f.inv <| f.inv_comp_eq.2 w.symm\n\n"}
{"name":"CategoryTheory.Subobject.eq_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\ni : CategoryTheory.Iso (CategoryTheory.Subobject.underlying.obj X) A\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom f) X.arrow\n⊢ Eq X (CategoryTheory.Subobject.mk f)","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem eq_mk_of_comm {B A : C} {X : Subobject B} (f : A ⟶ B) [Mono f] (i : (X : C) ≅ A)\n    (w : i.hom ≫ f = X.arrow) : X = mk f :=\n  eq_of_comm (i.trans (underlyingIso f).symm) <| by simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\ni : CategoryTheory.Iso A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom X.arrow) f\n⊢ Eq (CategoryTheory.Subobject.mk f) X","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem mk_eq_of_comm {B A : C} {X : Subobject B} (f : A ⟶ B) [Mono f] (i : A ≅ (X : C))\n    (w : i.hom ≫ X.arrow = f) : mk f = X :=\n  Eq.symm <| eq_mk_of_comm _ i.symm <| by rw [Iso.symm_hom, Iso.inv_comp_eq, w]\n\n"}
{"name":"CategoryTheory.Subobject.mk_eq_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\ni : CategoryTheory.Iso A₁ A₂\nw : Eq (CategoryTheory.CategoryStruct.comp i.hom g) f\n⊢ Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)","decl":"/-- To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\n    the arrows. -/\ntheorem mk_eq_mk_of_comm {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (i : A₁ ≅ A₂)\n    (w : i.hom ≫ g = f) : mk f = mk g :=\n  eq_mk_of_comm _ ((underlyingIso f).trans i) <| by simp [w]\n\n-- We make `X` and `Y` explicit arguments here so that when `ofLE` appears in goal statements\n-- it is possible to see its source and target\n-- (`h` will just display as `_`, because it is in `Prop`).\n"}
{"name":"CategoryTheory.Subobject.ofLE_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : LE.le X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h) Y.arrow) X.arrow","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X ≤ Y) : ofLE X Y h ≫ Y.arrow = X.arrow :=\n  underlying_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nh✝ : LE.le X Y\nZ : C\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h✝) (CategoryTheory.CategoryStruct.comp Y.arrow h)) (CategoryTheory.CategoryStruct.comp X.arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X ≤ Y) : ofLE X Y h ≫ Y.arrow = X.arrow :=\n  underlying_arrow _\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : LE.le X Y\n⊢ CategoryTheory.Mono (X.ofLE Y h)","decl":"instance {B : C} (X Y : Subobject B) (h : X ≤ Y) : Mono (ofLE X Y h) := by\n  fconstructor\n  intro Z f g w\n  replace w := w =≫ Y.arrow\n  ext\n  simpa using w\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_mk_le_mk_of_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf₁ : Quiver.Hom A₁ B\nf₂ : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f₁\ninst✝ : CategoryTheory.Mono f₂\ng : Quiver.Hom A₁ A₂\nw : Eq (CategoryTheory.CategoryStruct.comp g f₂) f₁\n⊢ Eq ((CategoryTheory.Subobject.mk f₁).ofLE (CategoryTheory.Subobject.mk f₂) ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.underlyingIso f₁).hom (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Subobject.underlyingIso f₂).inv))","decl":"theorem ofLE_mk_le_mk_of_comm {B A₁ A₂ : C} {f₁ : A₁ ⟶ B} {f₂ : A₂ ⟶ B} [Mono f₁] [Mono f₂]\n    (g : A₁ ⟶ A₂) (w : g ≫ f₂ = f₁) :\n    ofLE _ _ (mk_le_mk_of_comm g w) = (underlyingIso _).hom ≫ g ≫ (underlyingIso _).inv := by\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh : LE.le X (CategoryTheory.Subobject.mk f)\n⊢ CategoryTheory.Mono (X.ofLEMk f h)","decl":"instance {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (h : X ≤ mk f) :\n    Mono (ofLEMk X f h) := by\n  dsimp only [ofLEMk]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh : LE.le X (CategoryTheory.Subobject.mk f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h) f) X.arrow","decl":"@[simp]\ntheorem ofLEMk_comp {B A : C} {X : Subobject B} {f : A ⟶ B} [Mono f] (h : X ≤ mk f) :\n    ofLEMk X f h ≫ f = X.arrow := by simp [ofLEMk]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : LE.le (CategoryTheory.Subobject.mk f) X\n⊢ CategoryTheory.Mono (CategoryTheory.Subobject.ofMkLE f X h)","decl":"instance {B A : C} (f : A ⟶ B) [Mono f] (X : Subobject B) (h : mk f ≤ X) :\n    Mono (ofMkLE f X h) := by\n  dsimp only [ofMkLE]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_arrow","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : LE.le (CategoryTheory.Subobject.mk f) X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h) X.arrow) f","decl":"@[simp]\ntheorem ofMkLE_arrow {B A : C} {f : A ⟶ B} [Mono f] {X : Subobject B} (h : mk f ≤ X) :\n    ofMkLE f X h ≫ X.arrow = f := by simp [ofMkLE]\n\n"}
{"name":"CategoryTheory.Subobject.instMonoOfMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\nh : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n⊢ CategoryTheory.Mono (CategoryTheory.Subobject.ofMkLEMk f g h)","decl":"instance {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (h : mk f ≤ mk g) :\n    Mono (ofMkLEMk f g h) := by\n  dsimp only [ofMkLEMk]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\nh : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h) g) f","decl":"@[simp]\ntheorem ofMkLEMk_comp {B A₁ A₂ : C} {f : A₁ ⟶ B} {g : A₂ ⟶ B} [Mono f] [Mono g] (h : mk f ≤ mk g) :\n    ofMkLEMk f g h ≫ g = f := by simp [ofMkLEMk]\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y Z✝ : CategoryTheory.Subobject B\nh₁ : LE.le X Y\nh₂ : LE.le Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h₁) (CategoryTheory.CategoryStruct.comp (Y.ofLE Z✝ h₂) h)) (CategoryTheory.CategoryStruct.comp (X.ofLE Z✝ ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h₁ : X ≤ Y) (h₂ : Y ≤ Z) :\n    ofLE X Y h₁ ≫ ofLE Y Z h₂ = ofLE X Z (h₁.trans h₂) := by\n  simp only [ofLE, ← Functor.map_comp underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y Z : CategoryTheory.Subobject B\nh₁ : LE.le X Y\nh₂ : LE.le Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h₁) (Y.ofLE Z h₂)) (X.ofLE Z ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h₁ : X ≤ Y) (h₂ : Y ≤ Z) :\n    ofLE X Y h₁ ≫ ofLE Y Z h₂ = ofLE X Z (h₁.trans h₂) := by\n  simp only [ofLE, ← Functor.map_comp underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh₁ : LE.le X Y\nh₂ : LE.le Y (CategoryTheory.Subobject.mk f)\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h₁) (CategoryTheory.CategoryStruct.comp (Y.ofLEMk f h₂) h)) (CategoryTheory.CategoryStruct.comp (X.ofLEMk f ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A ⟶ B) [Mono f] (h₁ : X ≤ Y)\n    (h₂ : Y ≤ mk f) : ofLE X Y h₁ ≫ ofLEMk Y f h₂ = ofLEMk X f (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ← Functor.map_comp_assoc underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_comp_ofLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX Y : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh₁ : LE.le X Y\nh₂ : LE.le Y (CategoryTheory.Subobject.mk f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLE Y h₁) (Y.ofLEMk f h₂)) (X.ofLEMk f ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A ⟶ B) [Mono f] (h₁ : X ≤ Y)\n    (h₂ : Y ≤ mk f) : ofLE X Y h₁ ≫ ofLEMk Y f h₂ = ofLEMk X f (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ← Functor.map_comp_assoc underlying]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nY : CategoryTheory.Subobject B\nh₁ : LE.le X (CategoryTheory.Subobject.mk f)\nh₂ : LE.le (CategoryTheory.Subobject.mk f) Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f Y h₂) h)) (CategoryTheory.CategoryStruct.comp (X.ofLE Y ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (Y : Subobject B)\n    (h₁ : X ≤ mk f) (h₂ : mk f ≤ Y) : ofLEMk X f h₁ ≫ ofMkLE f Y h₂ = ofLE X Y (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ← Functor.map_comp underlying, assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nY : CategoryTheory.Subobject B\nh₁ : LE.le X (CategoryTheory.Subobject.mk f)\nh₂ : LE.le (CategoryTheory.Subobject.mk f) Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h₁) (CategoryTheory.Subobject.ofMkLE f Y h₂)) (X.ofLE Y ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (Y : Subobject B)\n    (h₁ : X ≤ mk f) (h₂ : mk f ≤ Y) : ofLEMk X f h₁ ≫ ofMkLE f Y h₂ = ofLE X Y (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ← Functor.map_comp underlying, assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nh₁ : LE.le X (CategoryTheory.Subobject.mk f)\nh₂ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nZ : C\nh : Quiver.Hom A₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h₂) h)) (CategoryTheory.CategoryStruct.comp (X.ofLEMk g ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLEMk {B A₁ A₂ : C} (X : Subobject B) (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B)\n    [Mono g] (h₁ : X ≤ mk f) (h₂ : mk f ≤ mk g) :\n    ofLEMk X f h₁ ≫ ofMkLEMk f g h₂ = ofLEMk X g (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nh₁ : LE.le X (CategoryTheory.Subobject.mk f)\nh₂ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.ofLEMk f h₁) (CategoryTheory.Subobject.ofMkLEMk f g h₂)) (X.ofLEMk g ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLEMk {B A₁ A₂ : C} (X : Subobject B) (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B)\n    [Mono g] (h₁ : X ≤ mk f) (h₂ : mk f ≤ mk g) :\n    ofLEMk X f h₁ ≫ ofMkLEMk f g h₂ = ofLEMk X g (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A₁ : C\nf : Quiver.Hom A₁ B\ninst✝ : CategoryTheory.Mono f\nX Y : CategoryTheory.Subobject B\nh₁ : LE.le (CategoryTheory.Subobject.mk f) X\nh₂ : LE.le X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (X.ofLE Y h₂)) (CategoryTheory.Subobject.ofMkLE f Y ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLE {B A₁ : C} (f : A₁ ⟶ B) [Mono f] (X Y : Subobject B) (h₁ : mk f ≤ X)\n    (h₂ : X ≤ Y) : ofMkLE f X h₁ ≫ ofLE X Y h₂ = ofMkLE f Y (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp underlying,\n    assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A₁ : C\nf : Quiver.Hom A₁ B\ninst✝ : CategoryTheory.Mono f\nX Y : CategoryTheory.Subobject B\nh₁ : LE.le (CategoryTheory.Subobject.mk f) X\nh₂ : LE.le X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (CategoryTheory.CategoryStruct.comp (X.ofLE Y h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f Y ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLE {B A₁ : C} (f : A₁ ⟶ B) [Mono f] (X Y : Subobject B) (h₁ : mk f ≤ X)\n    (h₂ : X ≤ Y) : ofMkLE f X h₁ ≫ ofLE X Y h₂ = ofMkLE f Y (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp underlying,\n    assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nh₁ : LE.le (CategoryTheory.Subobject.mk f) X\nh₂ : LE.le X (CategoryTheory.Subobject.mk g)\nZ : C\nh : Quiver.Hom A₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (CategoryTheory.CategoryStruct.comp (X.ofLEMk g h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLEMk {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (X : Subobject B) (g : A₂ ⟶ B)\n    [Mono g] (h₁ : mk f ≤ X) (h₂ : X ≤ mk g) :\n    ofMkLE f X h₁ ≫ ofLEMk X g h₂ = ofMkLEMk f g (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying, assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLE_comp_ofLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nh₁ : LE.le (CategoryTheory.Subobject.mk f) X\nh₂ : LE.le X (CategoryTheory.Subobject.mk g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (X.ofLEMk g h₂)) (CategoryTheory.Subobject.ofMkLEMk f g ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLEMk {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (X : Subobject B) (g : A₂ ⟶ B)\n    [Mono g] (h₁ : mk f ≤ X) (h₂ : X ≤ mk g) :\n    ofMkLE f X h₁ ≫ ofLEMk X g h₂ = ofMkLEMk f g (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying, assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nX : CategoryTheory.Subobject B\nh₁ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh₂ : LE.le (CategoryTheory.Subobject.mk g) X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h₁) (CategoryTheory.Subobject.ofMkLE g X h₂)) (CategoryTheory.Subobject.ofMkLE f X ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLE {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]\n    (X : Subobject B) (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ X) :\n    ofMkLEMk f g h₁ ≫ ofMkLE g X h₂ = ofMkLE f X (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ninst✝¹ : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝ : CategoryTheory.Mono g\nX : CategoryTheory.Subobject B\nh₁ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh₂ : LE.le (CategoryTheory.Subobject.mk g) X\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE g X h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLE {B A₁ A₂ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]\n    (X : Subobject B) (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ X) :\n    ofMkLEMk f g h₁ ≫ ofMkLE g X h₂ = ofMkLE f X (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp underlying,\n    assoc, Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ A₃ : C\nf : Quiver.Hom A₁ B\ninst✝² : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono g\nh : Quiver.Hom A₃ B\ninst✝ : CategoryTheory.Mono h\nh₁ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh₂ : LE.le (CategoryTheory.Subobject.mk g) (CategoryTheory.Subobject.mk h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h₁) (CategoryTheory.Subobject.ofMkLEMk g h h₂)) (CategoryTheory.Subobject.ofMkLEMk f h ⋯)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLEMk {B A₁ A₂ A₃ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]\n    (h : A₃ ⟶ B) [Mono h] (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ mk h) :\n    ofMkLEMk f g h₁ ≫ ofMkLEMk g h h₂ = ofMkLEMk f h (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying, assoc,\n    Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk_assoc","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ A₃ : C\nf : Quiver.Hom A₁ B\ninst✝² : CategoryTheory.Mono f\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono g\nh✝ : Quiver.Hom A₃ B\ninst✝ : CategoryTheory.Mono h✝\nh₁ : LE.le (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\nh₂ : LE.le (CategoryTheory.Subobject.mk g) (CategoryTheory.Subobject.mk h✝)\nZ : C\nh : Quiver.Hom A₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f g h₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk g h✝ h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLEMk f h✝ ⋯) h)","decl":"@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLEMk {B A₁ A₂ A₃ : C} (f : A₁ ⟶ B) [Mono f] (g : A₂ ⟶ B) [Mono g]\n    (h : A₃ ⟶ B) [Mono h] (h₁ : mk f ≤ mk g) (h₂ : mk g ≤ mk h) :\n    ofMkLEMk f g h₁ ≫ ofMkLEMk g h h₂ = ofMkLEMk f h (h₁.trans h₂) := by\n  simp only [ofMkLE, ofLEMk, ofLE, ofMkLEMk, ← Functor.map_comp_assoc underlying, assoc,\n    Iso.hom_inv_id_assoc]\n  congr 1\n\n"}
{"name":"CategoryTheory.Subobject.ofLE_refl","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX : CategoryTheory.Subobject B\n⊢ Eq (X.ofLE X ⋯) (CategoryTheory.CategoryStruct.id (CategoryTheory.Subobject.underlying.obj X))","decl":"@[simp]\ntheorem ofLE_refl {B : C} (X : Subobject B) : ofLE X X le_rfl = 𝟙 _ := by\n  apply (cancel_mono X.arrow).mp\n  simp\n\n"}
{"name":"CategoryTheory.Subobject.ofMkLEMk_refl","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A₁ : C\nf : Quiver.Hom A₁ B\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Subobject.ofMkLEMk f f ⋯) (CategoryTheory.CategoryStruct.id A₁)","decl":"@[simp]\ntheorem ofMkLEMk_refl {B A₁ : C} (f : A₁ ⟶ B) [Mono f] : ofMkLEMk f f le_rfl = 𝟙 _ := by\n  apply (cancel_mono f).mp\n  simp\n\n-- As with `ofLE`, we have `X` and `Y` as explicit arguments for readability.\n"}
{"name":"CategoryTheory.Subobject.isoOfEq_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : Eq X Y\n⊢ Eq (X.isoOfEq Y h).hom (X.ofLE Y ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) -/\n@[simps]\ndef isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) ≅ (Y : C) where\n  hom := ofLE _ _ h.le\n  inv := ofLE _ _ h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEq_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nB : C\nX Y : CategoryTheory.Subobject B\nh : Eq X Y\n⊢ Eq (X.isoOfEq Y h).inv (Y.ofLE X ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) -/\n@[simps]\ndef isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) ≅ (Y : C) where\n  hom := ofLE _ _ h.le\n  inv := ofLE _ _ h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEqMk_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh : Eq X (CategoryTheory.Subobject.mk f)\n⊢ Eq (X.isoOfEqMk f h).hom (X.ofLEMk f ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfEqMk {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (h : X = mk f) : (X : C) ≅ A where\n  hom := ofLEMk X f h.le\n  inv := ofMkLE f X h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfEqMk_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nh : Eq X (CategoryTheory.Subobject.mk f)\n⊢ Eq (X.isoOfEqMk f h).inv (CategoryTheory.Subobject.ofMkLE f X ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfEqMk {B A : C} (X : Subobject B) (f : A ⟶ B) [Mono f] (h : X = mk f) : (X : C) ≅ A where\n  hom := ofLEMk X f h.le\n  inv := ofMkLE f X h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEq_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : Eq (CategoryTheory.Subobject.mk f) X\n⊢ Eq (CategoryTheory.Subobject.isoOfMkEq f X h).inv (X.ofLEMk f ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEq {B A : C} (f : A ⟶ B) [Mono f] (X : Subobject B) (h : mk f = X) : A ≅ (X : C) where\n  hom := ofMkLE f X h.le\n  inv := ofLEMk X f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEq_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nB A : C\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\nX : CategoryTheory.Subobject B\nh : Eq (CategoryTheory.Subobject.mk f) X\n⊢ Eq (CategoryTheory.Subobject.isoOfMkEq f X h).hom (CategoryTheory.Subobject.ofMkLE f X ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEq {B A : C} (f : A ⟶ B) [Mono f] (X : Subobject B) (h : mk f = X) : A ≅ (X : C) where\n  hom := ofMkLE f X h.le\n  inv := ofLEMk X f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEqMk_inv","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\nh : Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n⊢ Eq (CategoryTheory.Subobject.isoOfMkEqMk f g h).inv (CategoryTheory.Subobject.ofMkLEMk g f ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEqMk {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (h : mk f = mk g) :\n    A₁ ≅ A₂ where\n  hom := ofMkLEMk f g h.le\n  inv := ofMkLEMk g f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.isoOfMkEqMk_hom","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nB A₁ A₂ : C\nf : Quiver.Hom A₁ B\ng : Quiver.Hom A₂ B\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\nh : Eq (CategoryTheory.Subobject.mk f) (CategoryTheory.Subobject.mk g)\n⊢ Eq (CategoryTheory.Subobject.isoOfMkEqMk f g h).hom (CategoryTheory.Subobject.ofMkLEMk f g ⋯)","decl":"/-- An equality of subobjects gives an isomorphism of the corresponding objects. -/\n@[simps]\ndef isoOfMkEqMk {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [Mono f] [Mono g] (h : mk f = mk g) :\n    A₁ ≅ A₂ where\n  hom := ofMkLEMk f g h.le\n  inv := ofMkLEMk g f h.ge\n\n"}
{"name":"CategoryTheory.Subobject.lower_iso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nF₁ F₂ : CategoryTheory.Functor (CategoryTheory.MonoOver X) (CategoryTheory.MonoOver Y)\nh : CategoryTheory.Iso F₁ F₂\n⊢ Eq (CategoryTheory.Subobject.lower F₁) (CategoryTheory.Subobject.lower F₂)","decl":"/-- Isomorphic functors become equal when lowered to `Subobject`.\n(It's not as evil as usual to talk about equality between functors\nbecause the categories are thin and skeletal.) -/\ntheorem lower_iso (F₁ F₂ : MonoOver X ⥤ MonoOver Y) (h : F₁ ≅ F₂) : lower F₁ = lower F₂ :=\n  ThinSkeleton.map_iso_eq h\n\n"}
{"name":"CategoryTheory.Subobject.lower_comm","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nF : CategoryTheory.Functor (CategoryTheory.MonoOver Y) (CategoryTheory.MonoOver X)\n⊢ Eq ((CategoryTheory.toThinSkeleton (CategoryTheory.MonoOver Y)).comp (CategoryTheory.Subobject.lower F)) (F.comp (CategoryTheory.toThinSkeleton (CategoryTheory.MonoOver X)))","decl":"@[simp]\ntheorem lower_comm (F : MonoOver Y ⥤ MonoOver X) :\n    toThinSkeleton _ ⋙ lower F = F ⋙ toThinSkeleton _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_counitIso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n⊢ Eq (CategoryTheory.Subobject.lowerEquivalence e).counitIso (CategoryTheory.eqToIso ⋯)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ≌ MonoOver B) : Subobject A ≌ Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    · exact ThinSkeleton.map_id_eq.symm\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n    · exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_inverse","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n⊢ Eq (CategoryTheory.Subobject.lowerEquivalence e).inverse (CategoryTheory.Subobject.lower e.inverse)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ≌ MonoOver B) : Subobject A ≌ Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    · exact ThinSkeleton.map_id_eq.symm\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n    · exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_unitIso","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n⊢ Eq (CategoryTheory.Subobject.lowerEquivalence e).unitIso (CategoryTheory.eqToIso ⋯)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ≌ MonoOver B) : Subobject A ≌ Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    · exact ThinSkeleton.map_id_eq.symm\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n    · exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.lowerEquivalence_functor","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA : C\nB : D\ne : CategoryTheory.Equivalence (CategoryTheory.MonoOver A) (CategoryTheory.MonoOver B)\n⊢ Eq (CategoryTheory.Subobject.lowerEquivalence e).functor (CategoryTheory.Subobject.lower e.functor)","decl":"/-- An equivalence between `MonoOver A` and `MonoOver B` gives an equivalence\nbetween `Subobject A` and `Subobject B`. -/\n@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A ≌ MonoOver B) : Subobject A ≌ Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    · exact ThinSkeleton.map_id_eq.symm\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    · exact (ThinSkeleton.map_comp_eq _ _).symm\n    · exact ThinSkeleton.map_id_eq.symm\n\n"}
{"name":"CategoryTheory.Subobject.pullback_id","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nx : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Subobject.pullback (CategoryTheory.CategoryStruct.id X)).obj x) x","decl":"theorem pullback_id (x : Subobject X) : (pullback (𝟙 X)).obj x = x := by\n  induction' x using Quotient.inductionOn' with f\n  exact Quotient.sound ⟨MonoOver.pullbackId.app f⟩\n\n"}
{"name":"CategoryTheory.Subobject.pullback_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : CategoryTheory.Subobject Z\n⊢ Eq ((CategoryTheory.Subobject.pullback (CategoryTheory.CategoryStruct.comp f g)).obj x) ((CategoryTheory.Subobject.pullback f).obj ((CategoryTheory.Subobject.pullback g).obj x))","decl":"theorem pullback_comp (f : X ⟶ Y) (g : Y ⟶ Z) (x : Subobject Z) :\n    (pullback (f ≫ g)).obj x = (pullback f).obj ((pullback g).obj x) := by\n  induction' x using Quotient.inductionOn' with t\n  exact Quotient.sound ⟨(MonoOver.pullbackComp _ _).app t⟩\n\n"}
{"name":"CategoryTheory.Subobject.instFaithfulPullback","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.Subobject.pullback f).Faithful","decl":"instance (f : X ⟶ Y) : (pullback f).Faithful where\n\n"}
{"name":"CategoryTheory.Subobject.map_id","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nx : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Subobject.map (CategoryTheory.CategoryStruct.id X)).obj x) x","decl":"theorem map_id (x : Subobject X) : (map (𝟙 X)).obj x = x := by\n  induction' x using Quotient.inductionOn' with f\n  exact Quotient.sound ⟨(MonoOver.mapId _).app f⟩\n\n"}
{"name":"CategoryTheory.Subobject.map_comp","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Mono g\nx : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Subobject.map (CategoryTheory.CategoryStruct.comp f g)).obj x) ((CategoryTheory.Subobject.map g).obj ((CategoryTheory.Subobject.map f).obj x))","decl":"theorem map_comp (f : X ⟶ Y) (g : Y ⟶ Z) [Mono f] [Mono g] (x : Subobject X) :\n    (map (f ≫ g)).obj x = (map g).obj ((map f).obj x) := by\n  induction' x using Quotient.inductionOn' with t\n  exact Quotient.sound ⟨(MonoOver.mapComp _ _).app t⟩\n\n"}
{"name":"CategoryTheory.Subobject.mapIsoToOrderIso_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ne : CategoryTheory.Iso X Y\nP : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Subobject.mapIsoToOrderIso e) P) ((CategoryTheory.Subobject.map e.hom).obj P)","decl":"@[simp]\ntheorem mapIsoToOrderIso_apply (e : X ≅ Y) (P : Subobject X) :\n    mapIsoToOrderIso e P = (map e.hom).obj P :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.mapIsoToOrderIso_symm_apply","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ne : CategoryTheory.Iso X Y\nQ : CategoryTheory.Subobject Y\n⊢ Eq ((CategoryTheory.Subobject.mapIsoToOrderIso e).symm Q) ((CategoryTheory.Subobject.map e.inv).obj Q)","decl":"@[simp]\ntheorem mapIsoToOrderIso_symm_apply (e : X ≅ Y) (Q : Subobject Y) :\n    (mapIsoToOrderIso e).symm Q = (map e.inv).obj Q :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subobject.pullback_map_self","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Subobject.pullback f).obj ((CategoryTheory.Subobject.map f).obj g)) g","decl":"@[simp]\ntheorem pullback_map_self [HasPullbacks C] (f : X ⟶ Y) [Mono f] (g : Subobject X) :\n    (pullback f).obj ((map f).obj g) = g := by\n  revert g\n  exact Quotient.ind (fun g' => Quotient.sound ⟨(MonoOver.pullbackMapSelf f).app _⟩)\n\n"}
{"name":"CategoryTheory.Subobject.map_pullback","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nh : Quiver.Hom Y W\nk : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Mono h\ninst✝ : CategoryTheory.Mono g\ncomm : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\nt : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk f g comm)\np : CategoryTheory.Subobject Y\n⊢ Eq ((CategoryTheory.Subobject.map g).obj ((CategoryTheory.Subobject.pullback f).obj p)) ((CategoryTheory.Subobject.pullback k).obj ((CategoryTheory.Subobject.map h).obj p))","decl":"theorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : X ⟶ Y} {g : X ⟶ Z} {h : Y ⟶ W} {k : Z ⟶ W}\n    [Mono h] [Mono g] (comm : f ≫ h = g ≫ k) (t : IsLimit (PullbackCone.mk f g comm))\n    (p : Subobject Y) : (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) := by\n  revert p\n  apply Quotient.ind'\n  intro a\n  apply Quotient.sound\n  apply ThinSkeleton.equiv_of_both_ways\n  · refine MonoOver.homMk (pullback.lift (pullback.fst _ _) _ ?_) (pullback.lift_snd _ _ _)\n    change _ ≫ a.arrow ≫ h = (pullback.snd _ _ ≫ g) ≫ _\n    rw [assoc, ← comm, pullback.condition_assoc]\n  · refine MonoOver.homMk (pullback.lift (pullback.fst _ _)\n      (PullbackCone.IsLimit.lift t (pullback.fst _ _ ≫ a.arrow) (pullback.snd _ _) _)\n      (PullbackCone.IsLimit.lift_fst _ _ _ ?_).symm) ?_\n    · rw [← pullback.condition, assoc]\n      rfl\n    · dsimp\n      rw [pullback.lift_snd_assoc]\n      apply PullbackCone.IsLimit.lift_snd\n\n"}
{"name":"CategoryTheory.Subobject.exists_iso_map","module":"Mathlib.CategoryTheory.Subobject.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasImages C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Subobject.exists f) (CategoryTheory.Subobject.map f)","decl":"/-- When `f : X ⟶ Y` is a monomorphism, `exists f` agrees with `map f`.\n-/\ntheorem exists_iso_map (f : X ⟶ Y) [Mono f] : «exists» f = map f :=\n  lower_iso _ _ (MonoOver.existsIsoMap f)\n\n"}
