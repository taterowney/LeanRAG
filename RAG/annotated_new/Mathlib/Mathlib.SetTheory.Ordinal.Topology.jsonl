{"name":"Ordinal.instOrderTopology","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"‚ä¢ OrderTopology Ordinal.{u}","decl":"instance : OrderTopology Ordinal.{u} := ‚ü®rfl‚ü©\n\n"}
{"name":"Ordinal.isOpen_singleton_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\n‚ä¢ Iff (IsOpen (Singleton.singleton a)) (Not a.IsLimit)","decl":"theorem isOpen_singleton_iff : IsOpen ({a} : Set Ordinal) ‚Üî ¬¨IsLimit a := by\n  refine ‚ü®fun h ha => ?_, fun ha => ?_‚ü©\n  ¬∑ obtain ‚ü®b, c, hbc, hbc'‚ü© :=\n      (mem_nhds_iff_exists_Ioo_subset' ‚ü®0, ha.pos‚ü© ‚ü®_, lt_succ a‚ü©).1\n        (h.mem_nhds rfl)\n    have hba := ha.succ_lt hbc.1\n    exact hba.ne (hbc' ‚ü®lt_succ b, hba.trans hbc.2‚ü©)\n  ¬∑ rcases zero_or_succ_or_limit a with (rfl | ‚ü®b, rfl‚ü© | ha')\n    ¬∑ rw [‚Üê bot_eq_zero, ‚Üê Set.Iic_bot, ‚Üê Iio_succ]\n      exact isOpen_Iio\n    ¬∑ rw [‚Üê Set.Icc_self, Icc_succ_left, ‚Üê Ioo_succ_right]\n      exact isOpen_Ioo\n    ¬∑ exact (ha ha').elim\n\n"}
{"name":"Ordinal.nhdsGT","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Ioi a)) Bot.bot","decl":"protected theorem nhdsGT (a : Ordinal) : ùìù[>] a = ‚ä• := SuccOrder.nhdsGT\n\n"}
{"name":"Ordinal.nhds_right'","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Ioi a)) Bot.bot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_right' := Ordinal.nhdsGT\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhdsLT_eq_nhdsNE","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Iio a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))","decl":"theorem nhdsLT_eq_nhdsNE (a : Ordinal) : ùìù[<] a = ùìù[‚â†] a := by\n  rw [‚Üê nhdsLT_sup_nhdsGT, Ordinal.nhdsGT, sup_bot_eq]\n\n"}
{"name":"Ordinal.nhds_left'_eq_nhds_ne","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Iio a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_left'_eq_nhds_ne := nhdsLT_eq_nhdsNE\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhdsLE_eq_nhds","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (nhds a)","decl":"theorem nhdsLE_eq_nhds (a : Ordinal) : ùìù[‚â§] a = ùìù a := by\n  rw [‚Üê nhdsLE_sup_nhdsGT, SuccOrder.nhdsGT, sup_bot_eq]\n\n"}
{"name":"Ordinal.nhds_left_eq_nhds","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (nhds a)","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_left_eq_nhds := nhdsLE_eq_nhds\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.hasBasis_nhds_Ioc","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\nh : Ne a 0\n‚ä¢ (nhds a).HasBasis (fun x => LT.lt x a) fun x => Set.Ioc x a","decl":"theorem hasBasis_nhds_Ioc (h : a ‚â† 0) : (ùìù a).HasBasis (¬∑ < a) (Set.Ioc ¬∑ a) :=\n  nhdsLE_eq_nhds a ‚ñ∏ nhdsLE_basis_of_exists_lt ‚ü®0, h.bot_lt‚ü©\n\n"}
{"name":"Ordinal.nhdsBasis_Ioc","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\nh : Ne a 0\n‚ä¢ (nhds a).HasBasis (fun x => LT.lt x a) fun x => Set.Ioc x a","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsBasis_Ioc := hasBasis_nhds_Ioc\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhds_eq_pure","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\n‚ä¢ Iff (Eq (nhds a) (Pure.pure a)) (Not a.IsLimit)","decl":"theorem nhds_eq_pure : ùìù a = pure a ‚Üî ¬¨IsLimit a :=\n  (isOpen_singleton_iff_nhds_eq_pure _).symm.trans isOpen_singleton_iff\n\n-- todo: generalize `Ordinal.IsLimit` and this lemma to a `SuccOrder`\n"}
{"name":"Ordinal.isOpen_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n‚ä¢ Iff (IsOpen s) (‚àÄ (o : Ordinal.{u}), Membership.mem s o ‚Üí o.IsLimit ‚Üí Exists fun a => And (LT.lt a o) (HasSubset.Subset (Set.Ioo a o) s))","decl":"theorem isOpen_iff : IsOpen s ‚Üî ‚àÄ o ‚àà s, IsLimit o ‚Üí ‚àÉ a < o, Set.Ioo a o ‚äÜ s := by\n  refine isOpen_iff_mem_nhds.trans <| forall‚ÇÇ_congr fun o ho => ?_\n  by_cases ho' : IsLimit o\n  ¬∑ simp only [(hasBasis_nhds_Ioc ho'.ne_zero).mem_iff, ho', true_implies]\n    refine exists_congr fun a => and_congr_right fun ha => ?_\n    simp only [‚Üê Set.Ioo_insert_right ha, Set.insert_subset_iff, ho, true_and]\n  ¬∑ simp [nhds_eq_pure.2 ho', ho, ho']\n\n"}
{"name":"Ordinal.mem_closure_tfae","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\ns : Set Ordinal.{u}\n‚ä¢ (List.cons (Membership.mem (closure s) a) (List.cons (Membership.mem (closure (Inter.inter s (Set.Iic a))) a) (List.cons (And (Inter.inter s (Set.Iic a)).Nonempty (Eq (SupSet.sSup (Inter.inter s (Set.Iic a))) a)) (List.cons (Exists fun t => And (HasSubset.Subset t s) (And t.Nonempty (And (BddAbove t) (Eq (SupSet.sSup t) a)))) (List.cons (Exists fun o => And (Ne o 0) (Exists fun f => And (‚àÄ (x : Ordinal.{u}) (hx : LT.lt x o), Membership.mem s (f x hx)) (Eq (o.bsup f) a))) (List.cons (Exists fun Œπ => And (Nonempty Œπ) (Exists fun f => And (‚àÄ (i : Œπ), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))) List.nil)))))).TFAE","decl":"open List Set in\ntheorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :\n    TFAE [a ‚àà closure s,\n      a ‚àà closure (s ‚à© Iic a),\n      (s ‚à© Iic a).Nonempty ‚àß sSup (s ‚à© Iic a) = a,\n      ‚àÉ t, t ‚äÜ s ‚àß t.Nonempty ‚àß BddAbove t ‚àß sSup t = a,\n      ‚àÉ (o : Ordinal.{u}), o ‚â† 0 ‚àß ‚àÉ (f : ‚àÄ x < o, Ordinal),\n        (‚àÄ x hx, f x hx ‚àà s) ‚àß bsup.{u, u} o f = a,\n      ‚àÉ (Œπ : Type u), Nonempty Œπ ‚àß ‚àÉ f : Œπ ‚Üí Ordinal, (‚àÄ i, f i ‚àà s) ‚àß ‚®Ü i, f i = a] := by\n  tfae_have 1 ‚Üí 2 := by\n    simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhdsLE_eq_nhds]\n    exact id\n  tfae_have 2 ‚Üí 3\n  | h => by\n    rcases (s ‚à© Iic a).eq_empty_or_nonempty with he | hne\n    ¬∑ simp [he] at h\n    ¬∑ refine ‚ü®hne, (isLUB_of_mem_closure ?_ h).csSup_eq hne‚ü©\n      exact fun x hx => hx.2\n  tfae_have 3 ‚Üí 4\n  | h => ‚ü®_, inter_subset_left, h.1, bddAbove_Iic.mono inter_subset_right, h.2‚ü©\n  tfae_have 4 ‚Üí 5 := by\n    rintro ‚ü®t, hts, hne, hbdd, rfl‚ü©\n    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd\n    let ‚ü®y, hyt‚ü© := hne\n    classical\n      refine ‚ü®succ (sSup t), succ_ne_zero _, fun x _ => if x ‚àà t then x else y, fun x _ => ?_, ?_‚ü©\n      ¬∑ simp only\n        split_ifs with h <;> exact hts ‚Äπ_‚Ä∫\n      ¬∑ refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)\n        ¬∑ split_ifs <;> exact hlub.1 ‚Äπ_‚Ä∫\n        ¬∑ refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))\n  tfae_have 5 ‚Üí 6 := by\n    rintro ‚ü®o, h‚ÇÄ, f, hfs, rfl‚ü©\n    exact ‚ü®_, toType_nonempty_iff_ne_zero.2 h‚ÇÄ, familyOfBFamily o f, fun _ => hfs _ _, rfl‚ü©\n  tfae_have 6 ‚Üí 1 := by\n    rintro ‚ü®Œπ, hne, f, hfs, rfl‚ü©\n    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)\n      (bddAbove_range.{u, u} f)\n  tfae_finish\n\n"}
{"name":"Ordinal.mem_closure_iff_iSup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n‚ä¢ Iff (Membership.mem (closure s) a) (Exists fun Œπ => Exists fun x => Exists fun f => And (‚àÄ (i : Œπ), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))","decl":"theorem mem_closure_iff_iSup :\n    a ‚àà closure s ‚Üî\n      ‚àÉ (Œπ : Type u) (_ : Nonempty Œπ) (f : Œπ ‚Üí Ordinal), (‚àÄ i, f i ‚àà s) ‚àß ‚®Ü i, f i = a := by\n  apply ((mem_closure_tfae a s).out 0 5).trans\n  simp_rw [exists_prop]\n\n"}
{"name":"Ordinal.mem_closure_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n‚ä¢ Iff (Membership.mem (closure s) a) (Exists fun Œπ => Exists fun x => Exists fun f => And (‚àÄ (i : Œπ), Membership.mem s (f i)) (Eq (Ordinal.sup f) a))","decl":"set_option linter.deprecated false in\n@[deprecated mem_closure_iff_iSup (since := \"2024-08-27\")]\ntheorem mem_closure_iff_sup :\n    a ‚àà closure s ‚Üî\n      ‚àÉ (Œπ : Type u) (_ : Nonempty Œπ) (f : Œπ ‚Üí Ordinal), (‚àÄ i, f i ‚àà s) ‚àß sup f = a :=\n  mem_closure_iff_iSup\n\n"}
{"name":"Ordinal.mem_iff_iSup_of_isClosed","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n‚ä¢ Iff (Membership.mem s a) (Exists fun Œπ => Exists fun _hŒπ => Exists fun f => And (‚àÄ (i : Œπ), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))","decl":"theorem mem_iff_iSup_of_isClosed (hs : IsClosed s) :\n    a ‚àà s ‚Üî ‚àÉ (Œπ : Type u) (_hŒπ : Nonempty Œπ) (f : Œπ ‚Üí Ordinal),\n      (‚àÄ i, f i ‚àà s) ‚àß ‚®Ü i, f i = a := by\n  rw [‚Üê mem_closure_iff_iSup, hs.closure_eq]\n\n"}
{"name":"Ordinal.mem_closed_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n‚ä¢ Iff (Membership.mem s a) (Exists fun Œπ => Exists fun _hŒπ => Exists fun f => And (‚àÄ (i : Œπ), Membership.mem s (f i)) (Eq (Ordinal.sup f) a))","decl":"set_option linter.deprecated false in\n@[deprecated mem_iff_iSup_of_isClosed (since := \"2024-08-27\")]\ntheorem mem_closed_iff_sup (hs : IsClosed s) :\n    a ‚àà s ‚Üî ‚àÉ (Œπ : Type u) (_hŒπ : Nonempty Œπ) (f : Œπ ‚Üí Ordinal),\n      (‚àÄ i, f i ‚àà s) ‚àß sup f = a :=\n  mem_iff_iSup_of_isClosed hs\n\n"}
{"name":"Ordinal.mem_closure_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n‚ä¢ Iff (Membership.mem (closure s) a) (Exists fun o => Exists fun _ho => Exists fun f => And (‚àÄ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) (Eq (o.bsup f) a))","decl":"theorem mem_closure_iff_bsup :\n    a ‚àà closure s ‚Üî\n      ‚àÉ (o : Ordinal) (_ho : o ‚â† 0) (f : ‚àÄ a < o, Ordinal),\n        (‚àÄ i hi, f i hi ‚àà s) ‚àß bsup.{u, u} o f = a := by\n  apply ((mem_closure_tfae a s).out 0 4).trans\n  simp_rw [exists_prop]\n\n"}
{"name":"Ordinal.mem_closed_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n‚ä¢ Iff (Membership.mem s a) (Exists fun o => Exists fun _ho => Exists fun f => And (‚àÄ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) (Eq (o.bsup f) a))","decl":"theorem mem_closed_iff_bsup (hs : IsClosed s) :\n    a ‚àà s ‚Üî\n      ‚àÉ (o : Ordinal) (_ho : o ‚â† 0) (f : ‚àÄ a < o, Ordinal),\n        (‚àÄ i hi, f i hi ‚àà s) ‚àß bsup.{u, u} o f = a := by\n  rw [‚Üê mem_closure_iff_bsup, hs.closure_eq]\n\n"}
{"name":"Ordinal.isClosed_iff_iSup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n‚ä¢ Iff (IsClosed s) (‚àÄ {Œπ : Type u}, Nonempty Œπ ‚Üí ‚àÄ (f : Œπ ‚Üí Ordinal.{u}), (‚àÄ (i : Œπ), Membership.mem s (f i)) ‚Üí Membership.mem s (iSup fun i => f i))","decl":"theorem isClosed_iff_iSup :\n    IsClosed s ‚Üî\n      ‚àÄ {Œπ : Type u}, Nonempty Œπ ‚Üí ‚àÄ f : Œπ ‚Üí Ordinal, (‚àÄ i, f i ‚àà s) ‚Üí ‚®Ü i, f i ‚àà s := by\n  use fun hs Œπ hŒπ f hf => (mem_iff_iSup_of_isClosed hs).2 ‚ü®Œπ, hŒπ, f, hf, rfl‚ü©\n  rw [‚Üê closure_subset_iff_isClosed]\n  intro h x hx\n  rcases mem_closure_iff_iSup.1 hx with ‚ü®Œπ, hŒπ, f, hf, rfl‚ü©\n  exact h hŒπ f hf\n\n"}
{"name":"Ordinal.isClosed_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n‚ä¢ Iff (IsClosed s) (‚àÄ {Œπ : Type u}, Nonempty Œπ ‚Üí ‚àÄ (f : Œπ ‚Üí Ordinal.{u}), (‚àÄ (i : Œπ), Membership.mem s (f i)) ‚Üí Membership.mem s (iSup fun i => f i))","decl":"set_option linter.deprecated false in\n@[deprecated mem_iff_iSup_of_isClosed (since := \"2024-08-27\")]\ntheorem isClosed_iff_sup :\n    IsClosed s ‚Üî\n      ‚àÄ {Œπ : Type u}, Nonempty Œπ ‚Üí ‚àÄ f : Œπ ‚Üí Ordinal, (‚àÄ i, f i ‚àà s) ‚Üí ‚®Ü i, f i ‚àà s := by\n  use fun hs Œπ hŒπ f hf => (mem_closed_iff_sup hs).2 ‚ü®Œπ, hŒπ, f, hf, rfl‚ü©\n  rw [‚Üê closure_subset_iff_isClosed]\n  intro h x hx\n  rcases mem_closure_iff_sup.1 hx with ‚ü®Œπ, hŒπ, f, hf, rfl‚ü©\n  exact h hŒπ f hf\n\n"}
{"name":"Ordinal.isClosed_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n‚ä¢ Iff (IsClosed s) (‚àÄ {o : Ordinal.{u}}, Ne o 0 ‚Üí ‚àÄ (f : (a : Ordinal.{u}) ‚Üí LT.lt a o ‚Üí Ordinal.{u}), (‚àÄ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) ‚Üí Membership.mem s (o.bsup f))","decl":"theorem isClosed_iff_bsup :\n    IsClosed s ‚Üî\n      ‚àÄ {o : Ordinal}, o ‚â† 0 ‚Üí ‚àÄ f : ‚àÄ a < o, Ordinal,\n        (‚àÄ i hi, f i hi ‚àà s) ‚Üí bsup.{u, u} o f ‚àà s := by\n  rw [isClosed_iff_iSup]\n  refine ‚ü®fun H o ho f hf => H (toType_nonempty_iff_ne_zero.2 ho) _ ?_, fun H Œπ hŒπ f hf => ?_‚ü©\n  ¬∑ exact fun i => hf _ _\n  ¬∑ rw [‚Üê Ordinal.sup, ‚Üê bsup_eq_sup]\n    apply H (type_ne_zero_iff_nonempty.2 hŒπ)\n    exact fun i hi => hf _\n\n"}
{"name":"Ordinal.isLimit_of_mem_frontier","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nha : Membership.mem (frontier s) a\n‚ä¢ a.IsLimit","decl":"theorem isLimit_of_mem_frontier (ha : a ‚àà frontier s) : IsLimit a := by\n  simp only [frontier_eq_closure_inter_closure, Set.mem_inter_iff, mem_closure_iff] at ha\n  by_contra h\n  rw [‚Üê isOpen_singleton_iff] at h\n  rcases ha.1 _ h rfl with ‚ü®b, hb, hb'‚ü©\n  rcases ha.2 _ h rfl with ‚ü®c, hc, hc'‚ü©\n  rw [Set.mem_singleton_iff] at *\n  subst hb; subst hc\n  exact hc' hb'\n\n"}
{"name":"Ordinal.isNormal_iff_strictMono_and_continuous","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"f : Ordinal.{u} ‚Üí Ordinal.{u}\n‚ä¢ Iff (Ordinal.IsNormal f) (And (StrictMono f) (Continuous f))","decl":"theorem isNormal_iff_strictMono_and_continuous (f : Ordinal.{u} ‚Üí Ordinal.{u}) :\n    IsNormal f ‚Üî StrictMono f ‚àß Continuous f := by\n  refine ‚ü®fun h => ‚ü®h.strictMono, ?_‚ü©, ?_‚ü©\n  ¬∑ rw [continuous_def]\n    intro s hs\n    rw [isOpen_iff] at *\n    intro o ho ho'\n    rcases hs _ ho (h.isLimit ho') with ‚ü®a, ha, has‚ü©\n    rw [‚Üê IsNormal.bsup_eq.{u, u} h ho', lt_bsup] at ha\n    rcases ha with ‚ü®b, hb, hab‚ü©\n    exact\n      ‚ü®b, hb, fun c hc =>\n        Set.mem_preimage.2 (has ‚ü®hab.trans (h.strictMono hc.1), h.strictMono hc.2‚ü©)‚ü©\n  ¬∑ rw [isNormal_iff_strictMono_limit]\n    rintro ‚ü®h, h'‚ü©\n    refine ‚ü®h, fun o ho a h => ?_‚ü©\n    suffices o ‚àà f ‚Åª¬π' Set.Iic a from Set.mem_preimage.1 this\n    rw [mem_iff_iSup_of_isClosed (IsClosed.preimage h' (@isClosed_Iic _ _ _ _ a))]\n    exact\n      ‚ü®_, toType_nonempty_iff_ne_zero.2 ho.ne_zero, typein (¬∑ < ¬∑), fun i => h _ (typein_lt_self i),\n        sup_typein_limit fun _ ‚Ü¶ ho.succ_lt‚ü©\n\n"}
{"name":"Ordinal.enumOrd_isNormal_iff_isClosed","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n‚ä¢ Iff (Ordinal.IsNormal (Ordinal.enumOrd s)) (IsClosed s)","decl":"theorem enumOrd_isNormal_iff_isClosed (hs : ¬¨ BddAbove s) :\n    IsNormal (enumOrd s) ‚Üî IsClosed s := by\n  have Hs := enumOrd_strictMono hs\n  refine\n    ‚ü®fun h => isClosed_iff_iSup.2 fun {Œπ} hŒπ f hf => ?_, fun h =>\n      (isNormal_iff_strictMono_limit _).2 ‚ü®Hs, fun a ha o H => ?_‚ü©‚ü©\n  ¬∑ let g : Œπ ‚Üí Ordinal.{u} := fun i => (enumOrdOrderIso s hs).symm ‚ü®_, hf i‚ü©\n    suffices enumOrd s (‚®Ü i, g i) = ‚®Ü i, f i by\n      rw [‚Üê this]\n      exact enumOrd_mem hs _\n    rw [IsNormal.map_iSup h g]\n    congr\n    ext x\n    change (enumOrdOrderIso s hs _).val = f x\n    rw [OrderIso.apply_symm_apply]\n  ¬∑ rw [isClosed_iff_bsup] at h\n    suffices enumOrd s a ‚â§ bsup.{u, u} a fun b (_ : b < a) => enumOrd s b from\n      this.trans (bsup_le H)\n    obtain ‚ü®b, hb‚ü© := enumOrd_surjective hs (h ha.ne_zero (fun b _ => enumOrd s b)\n      fun b _ => enumOrd_mem hs b)\n    rw [‚Üê hb]\n    apply Hs.monotone\n    by_contra! hba\n    apply (Hs (lt_succ b)).not_le\n    rw [hb]\n    exact le_bsup.{u, u} _ _ (ha.succ_lt hba)\n\n"}
{"name":"Ordinal.isAcc_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\n‚ä¢ Iff (o.IsAcc S) (And (Ne o 0) (‚àÄ (p : Ordinal.{u_1}), LT.lt p o ‚Üí (Inter.inter S (Set.Ioo p o)).Nonempty))","decl":"theorem isAcc_iff (o : Ordinal) (S : Set Ordinal) : o.IsAcc S ‚Üî\n    o ‚â† 0 ‚àß ‚àÄ p < o, (S ‚à© Ioo p o).Nonempty := by\n  dsimp [IsAcc]\n  constructor\n  ¬∑ rw [accPt_iff_nhds]\n    intro h\n    constructor\n    ¬∑ rintro rfl\n      obtain ‚ü®x, hx‚ü© := h (Iio 1) (Iio_mem_nhds zero_lt_one)\n      exact hx.2 <| lt_one_iff_zero.mp hx.1.1\n    ¬∑ intro p plt\n      obtain ‚ü®x, hx‚ü© := h (Ioo p (o + 1)) <| Ioo_mem_nhds plt (lt_succ o)\n      use x\n      refine ‚ü®hx.1.2, ‚ü®hx.1.1.1, lt_of_le_of_ne ?_ hx.2‚ü©‚ü©\n      have := hx.1.1.2\n      rwa [‚Üê succ_eq_add_one, lt_succ_iff] at this\n  ¬∑ rw [accPt_iff_nhds]\n    intro h u umem\n    obtain ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds umem ‚ü®0, Ordinal.pos_iff_ne_zero.mpr h.1‚ü©\n    obtain ‚ü®x, hx‚ü© := h.2 l hl.1\n    use x\n    exact ‚ü®‚ü®hl.2 ‚ü®hx.2.1, hx.2.2.le‚ü©, hx.1‚ü©, hx.2.2.ne‚ü©\n\n"}
{"name":"Ordinal.IsAcc.forall_lt","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\np : Ordinal.{u_1}\na‚úù : LT.lt p o\n‚ä¢ (Inter.inter S (Set.Ioo p o)).Nonempty","decl":"theorem IsAcc.forall_lt {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) :\n    ‚àÄ p < o, (S ‚à© Ioo p o).Nonempty := ((isAcc_iff _ _).mp h).2\n\n"}
{"name":"Ordinal.IsAcc.pos","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\n‚ä¢ LT.lt 0 o","decl":"theorem IsAcc.pos {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) :\n    0 < o := Ordinal.pos_iff_ne_zero.mpr ((isAcc_iff _ _).mp h).1\n\n"}
{"name":"Ordinal.IsAcc.isLimit","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\n‚ä¢ o.IsLimit","decl":"theorem IsAcc.isLimit {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) : IsLimit o := by\n  rw [isAcc_iff] at h\n  refine isLimit_of_not_succ_of_ne_zero (fun ‚ü®x, hx‚ü© ‚Ü¶ ?_) h.1\n  rcases h.2 x (lt_of_lt_of_le (lt_succ x) hx.symm.le) with ‚ü®p, hp‚ü©\n  exact (hx.symm ‚ñ∏ (succ_le_iff.mpr hp.2.1)).not_lt hp.2.2\n\n"}
{"name":"Ordinal.IsAcc.mono","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS T : Set Ordinal.{u_1}\nh : HasSubset.Subset S T\nho : o.IsAcc S\n‚ä¢ o.IsAcc T","decl":"theorem IsAcc.mono {o : Ordinal} {S T : Set Ordinal} (h : S ‚äÜ T) (ho : o.IsAcc S) :\n    o.IsAcc T := by\n  rw [isAcc_iff] at *\n  exact ‚ü®ho.1, fun p plto ‚Ü¶ (ho.2 p plto).casesOn fun s hs ‚Ü¶ ‚ü®s, h hs.1, hs.2‚ü©‚ü©\n\n"}
{"name":"Ordinal.IsAcc.inter_Ioo_nonempty","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nhS : o.IsAcc S\np : Ordinal.{u_1}\nhp : LT.lt p o\n‚ä¢ (Inter.inter S (Set.Ioo p o)).Nonempty","decl":"theorem IsAcc.inter_Ioo_nonempty {o : Ordinal} {S : Set Ordinal} (hS : o.IsAcc S)\n    {p : Ordinal} (hp : p < o) : (S ‚à© Ioo p o).Nonempty := hS.forall_lt p hp\n\n-- todo: prove this for a general linear `SuccOrder`.\n"}
{"name":"Ordinal.accPt_subtype","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"p o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nhpo : LT.lt p o\n‚ä¢ Iff (AccPt p (Filter.principal S)) (AccPt ‚ü®p, hpo‚ü© (Filter.principal (Set.preimage Subtype.val S)))","decl":"theorem accPt_subtype {p o : Ordinal} (S : Set Ordinal) (hpo : p < o) :\n    AccPt p (ùìü S) ‚Üî AccPt ‚ü®p, hpo‚ü© (ùìü (Iio o ‚Üì‚à© S)) := by\n  constructor\n  ¬∑ intro h\n    have plim : p.IsLimit := IsAcc.isLimit h\n    rw [accPt_iff_nhds] at *\n    intro u hu\n    obtain ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds hu ‚ü®‚ü®0, plim.pos.trans hpo‚ü©, plim.pos‚ü©\n    obtain ‚ü®x, hx‚ü© := h (Ioo l (p + 1)) (Ioo_mem_nhds hl.1 (lt_add_one _))\n    use ‚ü®x, lt_of_le_of_lt (lt_succ_iff.mp hx.1.1.2) hpo‚ü©\n    refine ‚ü®?_, Subtype.coe_ne_coe.mp hx.2‚ü©\n    exact ‚ü®hl.2 ‚ü®hx.1.1.1, by exact_mod_cast lt_succ_iff.mp hx.1.1.2‚ü©, hx.1.2‚ü©\n  ¬∑ intro h\n    rw [accPt_iff_nhds] at *\n    intro u hu\n    by_cases ho : p + 1 < o\n    ¬∑ have ppos : p ‚â† 0 := by\n        rintro rfl\n        rw [zero_add] at ho\n        specialize h (Iio ‚ü®1, ho‚ü©) (Iio_mem_nhds (Subtype.mk_lt_mk.mpr zero_lt_one))\n        obtain ‚ü®_, h‚ü© := h\n        exact h.2 <| Subtype.mk_eq_mk.mpr (lt_one_iff_zero.mp h.1.1)\n      have plim : p.IsLimit := by\n        contrapose! h\n        obtain ‚ü®q, hq‚ü© := ((zero_or_succ_or_limit p).resolve_left ppos).resolve_right h\n        use (Ioo ‚ü®q, ((hq ‚ñ∏ lt_succ q).trans hpo)‚ü© ‚ü®p + 1, ho‚ü©)\n        constructor\n        ¬∑ exact Ioo_mem_nhds (by simp only [hq, Subtype.mk_lt_mk, lt_succ]) (lt_succ p)\n        ¬∑ intro _ mem\n          have aux1 := Subtype.mk_lt_mk.mp mem.1.1\n          have aux2 := Subtype.mk_lt_mk.mp mem.1.2\n          rw [Subtype.mk_eq_mk]\n          rw [hq] at aux2 ‚ä¢\n          exact ((succ_le_iff.mpr aux1).antisymm (le_of_lt_succ aux2)).symm\n      obtain ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds hu ‚ü®0, plim.pos‚ü©\n      obtain ‚ü®x, hx‚ü© := h (Ioo ‚ü®l, hl.1.trans hpo‚ü© ‚ü®p + 1, ho‚ü©) (Ioo_mem_nhds hl.1 (lt_add_one p))\n      use x\n      exact ‚ü®‚ü®hl.2 ‚ü®hx.1.1.1, lt_succ_iff.mp hx.1.1.2‚ü©, hx.1.2‚ü©, fun h ‚Ü¶ hx.2 (SetCoe.ext h)‚ü©\n    have hp : o = p + 1 := (le_succ_iff_eq_or_le.mp (le_of_not_lt ho)).resolve_right\n      (not_le_of_lt hpo)\n    have ppos : p ‚â† 0 := by\n      rintro rfl\n      obtain ‚ü®x, hx‚ü© := h Set.univ univ_mem\n      have : ‚Üëx < o := x.2\n      simp_rw [hp, zero_add, lt_one_iff_zero] at this\n      exact hx.2 (SetCoe.ext this)\n    obtain ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds hu ‚ü®0, Ordinal.pos_iff_ne_zero.mpr ppos‚ü©\n    obtain ‚ü®x, hx‚ü© := h (Ioi ‚ü®l, hl.1.trans hpo‚ü©) (Ioi_mem_nhds hl.1)\n    use x\n    refine ‚ü®‚ü®hl.2 ‚ü®hx.1.1, ?_‚ü©, hx.1.2‚ü©, fun h ‚Ü¶ hx.2 (SetCoe.ext h)‚ü©\n    rw [‚Üê lt_add_one_iff, ‚Üê hp]\n    exact x.2\n\n"}
{"name":"Ordinal.isClosedBelow_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"S : Set Ordinal.{u_1}\no : Ordinal.{u_1}\n‚ä¢ Iff (Ordinal.IsClosedBelow S o) (‚àÄ (p : Ordinal.{u_1}), LT.lt p o ‚Üí p.IsAcc S ‚Üí Membership.mem S p)","decl":"theorem isClosedBelow_iff {S : Set Ordinal} {o : Ordinal} : IsClosedBelow S o ‚Üî\n    ‚àÄ p < o, IsAcc p S ‚Üí p ‚àà S := by\n  dsimp [IsClosedBelow]\n  constructor\n  ¬∑ intro h p plto hp\n    have : AccPt ‚ü®p, plto‚ü© (ùìü (Iio o ‚Üì‚à© S)) := (accPt_subtype _ _).mp hp\n    rw [isClosed_iff_clusterPt] at h\n    exact h ‚ü®p, plto‚ü© this.clusterPt\n  ¬∑ intro h\n    rw [isClosed_iff_clusterPt]\n    intro r hr\n    match clusterPt_principal.mp hr with\n    | .inl h => exact h\n    | .inr h' => exact h r.1 r.2 <| (accPt_subtype _ _).mpr h'\n\n"}
{"name":"Ordinal.IsClosedBelow.forall_lt","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"S : Set Ordinal.{u_1}\no : Ordinal.{u_1}\na‚úù¬≤ : Ordinal.IsClosedBelow S o\np : Ordinal.{u_1}\na‚úù¬π : LT.lt p o\na‚úù : p.IsAcc S\n‚ä¢ Membership.mem S p","decl":"alias ‚ü®IsClosedBelow.forall_lt, _‚ü© := isClosedBelow_iff\n\n"}
{"name":"Ordinal.IsClosedBelow.sInter","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set (Set Ordinal.{u_1})\nh : ‚àÄ (C : Set Ordinal.{u_1}), Membership.mem S C ‚Üí Ordinal.IsClosedBelow C o\n‚ä¢ Ordinal.IsClosedBelow S.sInter o","decl":"theorem IsClosedBelow.sInter {o : Ordinal} {S : Set (Set Ordinal)}\n    (h : ‚àÄ C ‚àà S, IsClosedBelow C o) : IsClosedBelow (‚ãÇ‚ÇÄ S) o := by\n  rw [isClosedBelow_iff]\n  intro p plto pAcc C CmemS\n  exact (h C CmemS).forall_lt p plto (pAcc.mono (sInter_subset_of_mem CmemS))\n\n"}
{"name":"Ordinal.IsClosedBelow.iInter","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Set Ordinal.{u_1}\no : Ordinal.{u_1}\nh : ‚àÄ (i : Œπ), Ordinal.IsClosedBelow (f i) o\n‚ä¢ Ordinal.IsClosedBelow (Set.iInter fun i => f i) o","decl":"theorem IsClosedBelow.iInter {Œπ : Type u} {f : Œπ ‚Üí Set Ordinal} {o : Ordinal}\n    (h : ‚àÄ i, IsClosedBelow (f i) o) : IsClosedBelow (‚ãÇ i, f i) o :=\n  IsClosedBelow.sInter fun _ ‚ü®i, hi‚ü© ‚Ü¶ hi ‚ñ∏ (h i)\n\n"}
