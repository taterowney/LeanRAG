{"name":"Ordinal.instOrderTopology","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"⊢ OrderTopology Ordinal.{u}","decl":"instance : OrderTopology Ordinal.{u} := ⟨rfl⟩\n\n"}
{"name":"Ordinal.isOpen_singleton_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\n⊢ Iff (IsOpen (Singleton.singleton a)) (Not a.IsLimit)","decl":"theorem isOpen_singleton_iff : IsOpen ({a} : Set Ordinal) ↔ ¬IsLimit a := by\n  refine ⟨fun h ha => ?_, fun ha => ?_⟩\n  · obtain ⟨b, c, hbc, hbc'⟩ :=\n      (mem_nhds_iff_exists_Ioo_subset' ⟨0, ha.pos⟩ ⟨_, lt_succ a⟩).1\n        (h.mem_nhds rfl)\n    have hba := ha.succ_lt hbc.1\n    exact hba.ne (hbc' ⟨lt_succ b, hba.trans hbc.2⟩)\n  · rcases zero_or_succ_or_limit a with (rfl | ⟨b, rfl⟩ | ha')\n    · rw [← bot_eq_zero, ← Set.Iic_bot, ← Iio_succ]\n      exact isOpen_Iio\n    · rw [← Set.Icc_self, Icc_succ_left, ← Ioo_succ_right]\n      exact isOpen_Ioo\n    · exact (ha ha').elim\n\n"}
{"name":"Ordinal.nhdsGT","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Ioi a)) Bot.bot","decl":"protected theorem nhdsGT (a : Ordinal) : 𝓝[>] a = ⊥ := SuccOrder.nhdsGT\n\n"}
{"name":"Ordinal.nhds_right'","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Ioi a)) Bot.bot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_right' := Ordinal.nhdsGT\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhdsLT_eq_nhdsNE","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Iio a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))","decl":"theorem nhdsLT_eq_nhdsNE (a : Ordinal) : 𝓝[<] a = 𝓝[≠] a := by\n  rw [← nhdsLT_sup_nhdsGT, Ordinal.nhdsGT, sup_bot_eq]\n\n"}
{"name":"Ordinal.nhds_left'_eq_nhds_ne","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Iio a)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_left'_eq_nhds_ne := nhdsLT_eq_nhdsNE\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhdsLE_eq_nhds","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Iic a)) (nhds a)","decl":"theorem nhdsLE_eq_nhds (a : Ordinal) : 𝓝[≤] a = 𝓝 a := by\n  rw [← nhdsLE_sup_nhdsGT, SuccOrder.nhdsGT, sup_bot_eq]\n\n"}
{"name":"Ordinal.nhds_left_eq_nhds","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (nhdsWithin a (Set.Iic a)) (nhds a)","decl":"@[deprecated (since := \"2024-12-22\")] alias nhds_left_eq_nhds := nhdsLE_eq_nhds\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.hasBasis_nhds_Ioc","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\nh : Ne a 0\n⊢ (nhds a).HasBasis (fun x => LT.lt x a) fun x => Set.Ioc x a","decl":"theorem hasBasis_nhds_Ioc (h : a ≠ 0) : (𝓝 a).HasBasis (· < a) (Set.Ioc · a) :=\n  nhdsLE_eq_nhds a ▸ nhdsLE_basis_of_exists_lt ⟨0, h.bot_lt⟩\n\n"}
{"name":"Ordinal.nhdsBasis_Ioc","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\nh : Ne a 0\n⊢ (nhds a).HasBasis (fun x => LT.lt x a) fun x => Set.Ioc x a","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsBasis_Ioc := hasBasis_nhds_Ioc\n\n-- todo: generalize to a `SuccOrder`\n"}
{"name":"Ordinal.nhds_eq_pure","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\n⊢ Iff (Eq (nhds a) (Pure.pure a)) (Not a.IsLimit)","decl":"theorem nhds_eq_pure : 𝓝 a = pure a ↔ ¬IsLimit a :=\n  (isOpen_singleton_iff_nhds_eq_pure _).symm.trans isOpen_singleton_iff\n\n-- todo: generalize `Ordinal.IsLimit` and this lemma to a `SuccOrder`\n"}
{"name":"Ordinal.isOpen_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n⊢ Iff (IsOpen s) (∀ (o : Ordinal.{u}), Membership.mem s o → o.IsLimit → Exists fun a => And (LT.lt a o) (HasSubset.Subset (Set.Ioo a o) s))","decl":"theorem isOpen_iff : IsOpen s ↔ ∀ o ∈ s, IsLimit o → ∃ a < o, Set.Ioo a o ⊆ s := by\n  refine isOpen_iff_mem_nhds.trans <| forall₂_congr fun o ho => ?_\n  by_cases ho' : IsLimit o\n  · simp only [(hasBasis_nhds_Ioc ho'.ne_zero).mem_iff, ho', true_implies]\n    refine exists_congr fun a => and_congr_right fun ha => ?_\n    simp only [← Set.Ioo_insert_right ha, Set.insert_subset_iff, ho, true_and]\n  · simp [nhds_eq_pure.2 ho', ho, ho']\n\n"}
{"name":"Ordinal.mem_closure_tfae","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"a : Ordinal.{u}\ns : Set Ordinal.{u}\n⊢ (List.cons (Membership.mem (closure s) a) (List.cons (Membership.mem (closure (Inter.inter s (Set.Iic a))) a) (List.cons (And (Inter.inter s (Set.Iic a)).Nonempty (Eq (SupSet.sSup (Inter.inter s (Set.Iic a))) a)) (List.cons (Exists fun t => And (HasSubset.Subset t s) (And t.Nonempty (And (BddAbove t) (Eq (SupSet.sSup t) a)))) (List.cons (Exists fun o => And (Ne o 0) (Exists fun f => And (∀ (x : Ordinal.{u}) (hx : LT.lt x o), Membership.mem s (f x hx)) (Eq (o.bsup f) a))) (List.cons (Exists fun ι => And (Nonempty ι) (Exists fun f => And (∀ (i : ι), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))) List.nil)))))).TFAE","decl":"open List Set in\ntheorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :\n    TFAE [a ∈ closure s,\n      a ∈ closure (s ∩ Iic a),\n      (s ∩ Iic a).Nonempty ∧ sSup (s ∩ Iic a) = a,\n      ∃ t, t ⊆ s ∧ t.Nonempty ∧ BddAbove t ∧ sSup t = a,\n      ∃ (o : Ordinal.{u}), o ≠ 0 ∧ ∃ (f : ∀ x < o, Ordinal),\n        (∀ x hx, f x hx ∈ s) ∧ bsup.{u, u} o f = a,\n      ∃ (ι : Type u), Nonempty ι ∧ ∃ f : ι → Ordinal, (∀ i, f i ∈ s) ∧ ⨆ i, f i = a] := by\n  tfae_have 1 → 2 := by\n    simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhdsLE_eq_nhds]\n    exact id\n  tfae_have 2 → 3\n  | h => by\n    rcases (s ∩ Iic a).eq_empty_or_nonempty with he | hne\n    · simp [he] at h\n    · refine ⟨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hne⟩\n      exact fun x hx => hx.2\n  tfae_have 3 → 4\n  | h => ⟨_, inter_subset_left, h.1, bddAbove_Iic.mono inter_subset_right, h.2⟩\n  tfae_have 4 → 5 := by\n    rintro ⟨t, hts, hne, hbdd, rfl⟩\n    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd\n    let ⟨y, hyt⟩ := hne\n    classical\n      refine ⟨succ (sSup t), succ_ne_zero _, fun x _ => if x ∈ t then x else y, fun x _ => ?_, ?_⟩\n      · simp only\n        split_ifs with h <;> exact hts ‹_›\n      · refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)\n        · split_ifs <;> exact hlub.1 ‹_›\n        · refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))\n  tfae_have 5 → 6 := by\n    rintro ⟨o, h₀, f, hfs, rfl⟩\n    exact ⟨_, toType_nonempty_iff_ne_zero.2 h₀, familyOfBFamily o f, fun _ => hfs _ _, rfl⟩\n  tfae_have 6 → 1 := by\n    rintro ⟨ι, hne, f, hfs, rfl⟩\n    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)\n      (bddAbove_range.{u, u} f)\n  tfae_finish\n\n"}
{"name":"Ordinal.mem_closure_iff_iSup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n⊢ Iff (Membership.mem (closure s) a) (Exists fun ι => Exists fun x => Exists fun f => And (∀ (i : ι), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))","decl":"theorem mem_closure_iff_iSup :\n    a ∈ closure s ↔\n      ∃ (ι : Type u) (_ : Nonempty ι) (f : ι → Ordinal), (∀ i, f i ∈ s) ∧ ⨆ i, f i = a := by\n  apply ((mem_closure_tfae a s).out 0 5).trans\n  simp_rw [exists_prop]\n\n"}
{"name":"Ordinal.mem_closure_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n⊢ Iff (Membership.mem (closure s) a) (Exists fun ι => Exists fun x => Exists fun f => And (∀ (i : ι), Membership.mem s (f i)) (Eq (Ordinal.sup f) a))","decl":"set_option linter.deprecated false in\n@[deprecated mem_closure_iff_iSup (since := \"2024-08-27\")]\ntheorem mem_closure_iff_sup :\n    a ∈ closure s ↔\n      ∃ (ι : Type u) (_ : Nonempty ι) (f : ι → Ordinal), (∀ i, f i ∈ s) ∧ sup f = a :=\n  mem_closure_iff_iSup\n\n"}
{"name":"Ordinal.mem_iff_iSup_of_isClosed","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n⊢ Iff (Membership.mem s a) (Exists fun ι => Exists fun _hι => Exists fun f => And (∀ (i : ι), Membership.mem s (f i)) (Eq (iSup fun i => f i) a))","decl":"theorem mem_iff_iSup_of_isClosed (hs : IsClosed s) :\n    a ∈ s ↔ ∃ (ι : Type u) (_hι : Nonempty ι) (f : ι → Ordinal),\n      (∀ i, f i ∈ s) ∧ ⨆ i, f i = a := by\n  rw [← mem_closure_iff_iSup, hs.closure_eq]\n\n"}
{"name":"Ordinal.mem_closed_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n⊢ Iff (Membership.mem s a) (Exists fun ι => Exists fun _hι => Exists fun f => And (∀ (i : ι), Membership.mem s (f i)) (Eq (Ordinal.sup f) a))","decl":"set_option linter.deprecated false in\n@[deprecated mem_iff_iSup_of_isClosed (since := \"2024-08-27\")]\ntheorem mem_closed_iff_sup (hs : IsClosed s) :\n    a ∈ s ↔ ∃ (ι : Type u) (_hι : Nonempty ι) (f : ι → Ordinal),\n      (∀ i, f i ∈ s) ∧ sup f = a :=\n  mem_iff_iSup_of_isClosed hs\n\n"}
{"name":"Ordinal.mem_closure_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\n⊢ Iff (Membership.mem (closure s) a) (Exists fun o => Exists fun _ho => Exists fun f => And (∀ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) (Eq (o.bsup f) a))","decl":"theorem mem_closure_iff_bsup :\n    a ∈ closure s ↔\n      ∃ (o : Ordinal) (_ho : o ≠ 0) (f : ∀ a < o, Ordinal),\n        (∀ i hi, f i hi ∈ s) ∧ bsup.{u, u} o f = a := by\n  apply ((mem_closure_tfae a s).out 0 4).trans\n  simp_rw [exists_prop]\n\n"}
{"name":"Ordinal.mem_closed_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nhs : IsClosed s\n⊢ Iff (Membership.mem s a) (Exists fun o => Exists fun _ho => Exists fun f => And (∀ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) (Eq (o.bsup f) a))","decl":"theorem mem_closed_iff_bsup (hs : IsClosed s) :\n    a ∈ s ↔\n      ∃ (o : Ordinal) (_ho : o ≠ 0) (f : ∀ a < o, Ordinal),\n        (∀ i hi, f i hi ∈ s) ∧ bsup.{u, u} o f = a := by\n  rw [← mem_closure_iff_bsup, hs.closure_eq]\n\n"}
{"name":"Ordinal.isClosed_iff_iSup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n⊢ Iff (IsClosed s) (∀ {ι : Type u}, Nonempty ι → ∀ (f : ι → Ordinal.{u}), (∀ (i : ι), Membership.mem s (f i)) → Membership.mem s (iSup fun i => f i))","decl":"theorem isClosed_iff_iSup :\n    IsClosed s ↔\n      ∀ {ι : Type u}, Nonempty ι → ∀ f : ι → Ordinal, (∀ i, f i ∈ s) → ⨆ i, f i ∈ s := by\n  use fun hs ι hι f hf => (mem_iff_iSup_of_isClosed hs).2 ⟨ι, hι, f, hf, rfl⟩\n  rw [← closure_subset_iff_isClosed]\n  intro h x hx\n  rcases mem_closure_iff_iSup.1 hx with ⟨ι, hι, f, hf, rfl⟩\n  exact h hι f hf\n\n"}
{"name":"Ordinal.isClosed_iff_sup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n⊢ Iff (IsClosed s) (∀ {ι : Type u}, Nonempty ι → ∀ (f : ι → Ordinal.{u}), (∀ (i : ι), Membership.mem s (f i)) → Membership.mem s (iSup fun i => f i))","decl":"set_option linter.deprecated false in\n@[deprecated mem_iff_iSup_of_isClosed (since := \"2024-08-27\")]\ntheorem isClosed_iff_sup :\n    IsClosed s ↔\n      ∀ {ι : Type u}, Nonempty ι → ∀ f : ι → Ordinal, (∀ i, f i ∈ s) → ⨆ i, f i ∈ s := by\n  use fun hs ι hι f hf => (mem_closed_iff_sup hs).2 ⟨ι, hι, f, hf, rfl⟩\n  rw [← closure_subset_iff_isClosed]\n  intro h x hx\n  rcases mem_closure_iff_sup.1 hx with ⟨ι, hι, f, hf, rfl⟩\n  exact h hι f hf\n\n"}
{"name":"Ordinal.isClosed_iff_bsup","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\n⊢ Iff (IsClosed s) (∀ {o : Ordinal.{u}}, Ne o 0 → ∀ (f : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}), (∀ (i : Ordinal.{u}) (hi : LT.lt i o), Membership.mem s (f i hi)) → Membership.mem s (o.bsup f))","decl":"theorem isClosed_iff_bsup :\n    IsClosed s ↔\n      ∀ {o : Ordinal}, o ≠ 0 → ∀ f : ∀ a < o, Ordinal,\n        (∀ i hi, f i hi ∈ s) → bsup.{u, u} o f ∈ s := by\n  rw [isClosed_iff_iSup]\n  refine ⟨fun H o ho f hf => H (toType_nonempty_iff_ne_zero.2 ho) _ ?_, fun H ι hι f hf => ?_⟩\n  · exact fun i => hf _ _\n  · rw [← Ordinal.sup, ← bsup_eq_sup]\n    apply H (type_ne_zero_iff_nonempty.2 hι)\n    exact fun i hi => hf _\n\n"}
{"name":"Ordinal.isLimit_of_mem_frontier","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\na : Ordinal.{u}\nha : Membership.mem (frontier s) a\n⊢ a.IsLimit","decl":"theorem isLimit_of_mem_frontier (ha : a ∈ frontier s) : IsLimit a := by\n  simp only [frontier_eq_closure_inter_closure, Set.mem_inter_iff, mem_closure_iff] at ha\n  by_contra h\n  rw [← isOpen_singleton_iff] at h\n  rcases ha.1 _ h rfl with ⟨b, hb, hb'⟩\n  rcases ha.2 _ h rfl with ⟨c, hc, hc'⟩\n  rw [Set.mem_singleton_iff] at *\n  subst hb; subst hc\n  exact hc' hb'\n\n"}
{"name":"Ordinal.isNormal_iff_strictMono_and_continuous","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\n⊢ Iff (Ordinal.IsNormal f) (And (StrictMono f) (Continuous f))","decl":"theorem isNormal_iff_strictMono_and_continuous (f : Ordinal.{u} → Ordinal.{u}) :\n    IsNormal f ↔ StrictMono f ∧ Continuous f := by\n  refine ⟨fun h => ⟨h.strictMono, ?_⟩, ?_⟩\n  · rw [continuous_def]\n    intro s hs\n    rw [isOpen_iff] at *\n    intro o ho ho'\n    rcases hs _ ho (h.isLimit ho') with ⟨a, ha, has⟩\n    rw [← IsNormal.bsup_eq.{u, u} h ho', lt_bsup] at ha\n    rcases ha with ⟨b, hb, hab⟩\n    exact\n      ⟨b, hb, fun c hc =>\n        Set.mem_preimage.2 (has ⟨hab.trans (h.strictMono hc.1), h.strictMono hc.2⟩)⟩\n  · rw [isNormal_iff_strictMono_limit]\n    rintro ⟨h, h'⟩\n    refine ⟨h, fun o ho a h => ?_⟩\n    suffices o ∈ f ⁻¹' Set.Iic a from Set.mem_preimage.1 this\n    rw [mem_iff_iSup_of_isClosed (IsClosed.preimage h' (@isClosed_Iic _ _ _ _ a))]\n    exact\n      ⟨_, toType_nonempty_iff_ne_zero.2 ho.ne_zero, typein (· < ·), fun i => h _ (typein_lt_self i),\n        sup_typein_limit fun _ ↦ ho.succ_lt⟩\n\n"}
{"name":"Ordinal.enumOrd_isNormal_iff_isClosed","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ Iff (Ordinal.IsNormal (Ordinal.enumOrd s)) (IsClosed s)","decl":"theorem enumOrd_isNormal_iff_isClosed (hs : ¬ BddAbove s) :\n    IsNormal (enumOrd s) ↔ IsClosed s := by\n  have Hs := enumOrd_strictMono hs\n  refine\n    ⟨fun h => isClosed_iff_iSup.2 fun {ι} hι f hf => ?_, fun h =>\n      (isNormal_iff_strictMono_limit _).2 ⟨Hs, fun a ha o H => ?_⟩⟩\n  · let g : ι → Ordinal.{u} := fun i => (enumOrdOrderIso s hs).symm ⟨_, hf i⟩\n    suffices enumOrd s (⨆ i, g i) = ⨆ i, f i by\n      rw [← this]\n      exact enumOrd_mem hs _\n    rw [IsNormal.map_iSup h g]\n    congr\n    ext x\n    change (enumOrdOrderIso s hs _).val = f x\n    rw [OrderIso.apply_symm_apply]\n  · rw [isClosed_iff_bsup] at h\n    suffices enumOrd s a ≤ bsup.{u, u} a fun b (_ : b < a) => enumOrd s b from\n      this.trans (bsup_le H)\n    obtain ⟨b, hb⟩ := enumOrd_surjective hs (h ha.ne_zero (fun b _ => enumOrd s b)\n      fun b _ => enumOrd_mem hs b)\n    rw [← hb]\n    apply Hs.monotone\n    by_contra! hba\n    apply (Hs (lt_succ b)).not_le\n    rw [hb]\n    exact le_bsup.{u, u} _ _ (ha.succ_lt hba)\n\n"}
{"name":"Ordinal.isAcc_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\n⊢ Iff (o.IsAcc S) (And (Ne o 0) (∀ (p : Ordinal.{u_1}), LT.lt p o → (Inter.inter S (Set.Ioo p o)).Nonempty))","decl":"theorem isAcc_iff (o : Ordinal) (S : Set Ordinal) : o.IsAcc S ↔\n    o ≠ 0 ∧ ∀ p < o, (S ∩ Ioo p o).Nonempty := by\n  dsimp [IsAcc]\n  constructor\n  · rw [accPt_iff_nhds]\n    intro h\n    constructor\n    · rintro rfl\n      obtain ⟨x, hx⟩ := h (Iio 1) (Iio_mem_nhds zero_lt_one)\n      exact hx.2 <| lt_one_iff_zero.mp hx.1.1\n    · intro p plt\n      obtain ⟨x, hx⟩ := h (Ioo p (o + 1)) <| Ioo_mem_nhds plt (lt_succ o)\n      use x\n      refine ⟨hx.1.2, ⟨hx.1.1.1, lt_of_le_of_ne ?_ hx.2⟩⟩\n      have := hx.1.1.2\n      rwa [← succ_eq_add_one, lt_succ_iff] at this\n  · rw [accPt_iff_nhds]\n    intro h u umem\n    obtain ⟨l, hl⟩ := exists_Ioc_subset_of_mem_nhds umem ⟨0, Ordinal.pos_iff_ne_zero.mpr h.1⟩\n    obtain ⟨x, hx⟩ := h.2 l hl.1\n    use x\n    exact ⟨⟨hl.2 ⟨hx.2.1, hx.2.2.le⟩, hx.1⟩, hx.2.2.ne⟩\n\n"}
{"name":"Ordinal.IsAcc.forall_lt","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\np : Ordinal.{u_1}\na✝ : LT.lt p o\n⊢ (Inter.inter S (Set.Ioo p o)).Nonempty","decl":"theorem IsAcc.forall_lt {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) :\n    ∀ p < o, (S ∩ Ioo p o).Nonempty := ((isAcc_iff _ _).mp h).2\n\n"}
{"name":"Ordinal.IsAcc.pos","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\n⊢ LT.lt 0 o","decl":"theorem IsAcc.pos {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) :\n    0 < o := Ordinal.pos_iff_ne_zero.mpr ((isAcc_iff _ _).mp h).1\n\n"}
{"name":"Ordinal.IsAcc.isLimit","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nh : o.IsAcc S\n⊢ o.IsLimit","decl":"theorem IsAcc.isLimit {o : Ordinal} {S : Set Ordinal} (h : o.IsAcc S) : IsLimit o := by\n  rw [isAcc_iff] at h\n  refine isLimit_of_not_succ_of_ne_zero (fun ⟨x, hx⟩ ↦ ?_) h.1\n  rcases h.2 x (lt_of_lt_of_le (lt_succ x) hx.symm.le) with ⟨p, hp⟩\n  exact (hx.symm ▸ (succ_le_iff.mpr hp.2.1)).not_lt hp.2.2\n\n"}
{"name":"Ordinal.IsAcc.mono","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS T : Set Ordinal.{u_1}\nh : HasSubset.Subset S T\nho : o.IsAcc S\n⊢ o.IsAcc T","decl":"theorem IsAcc.mono {o : Ordinal} {S T : Set Ordinal} (h : S ⊆ T) (ho : o.IsAcc S) :\n    o.IsAcc T := by\n  rw [isAcc_iff] at *\n  exact ⟨ho.1, fun p plto ↦ (ho.2 p plto).casesOn fun s hs ↦ ⟨s, h hs.1, hs.2⟩⟩\n\n"}
{"name":"Ordinal.IsAcc.inter_Ioo_nonempty","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nhS : o.IsAcc S\np : Ordinal.{u_1}\nhp : LT.lt p o\n⊢ (Inter.inter S (Set.Ioo p o)).Nonempty","decl":"theorem IsAcc.inter_Ioo_nonempty {o : Ordinal} {S : Set Ordinal} (hS : o.IsAcc S)\n    {p : Ordinal} (hp : p < o) : (S ∩ Ioo p o).Nonempty := hS.forall_lt p hp\n\n-- todo: prove this for a general linear `SuccOrder`.\n"}
{"name":"Ordinal.accPt_subtype","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"p o : Ordinal.{u_1}\nS : Set Ordinal.{u_1}\nhpo : LT.lt p o\n⊢ Iff (AccPt p (Filter.principal S)) (AccPt ⟨p, hpo⟩ (Filter.principal (Set.preimage Subtype.val S)))","decl":"theorem accPt_subtype {p o : Ordinal} (S : Set Ordinal) (hpo : p < o) :\n    AccPt p (𝓟 S) ↔ AccPt ⟨p, hpo⟩ (𝓟 (Iio o ↓∩ S)) := by\n  constructor\n  · intro h\n    have plim : p.IsLimit := IsAcc.isLimit h\n    rw [accPt_iff_nhds] at *\n    intro u hu\n    obtain ⟨l, hl⟩ := exists_Ioc_subset_of_mem_nhds hu ⟨⟨0, plim.pos.trans hpo⟩, plim.pos⟩\n    obtain ⟨x, hx⟩ := h (Ioo l (p + 1)) (Ioo_mem_nhds hl.1 (lt_add_one _))\n    use ⟨x, lt_of_le_of_lt (lt_succ_iff.mp hx.1.1.2) hpo⟩\n    refine ⟨?_, Subtype.coe_ne_coe.mp hx.2⟩\n    exact ⟨hl.2 ⟨hx.1.1.1, by exact_mod_cast lt_succ_iff.mp hx.1.1.2⟩, hx.1.2⟩\n  · intro h\n    rw [accPt_iff_nhds] at *\n    intro u hu\n    by_cases ho : p + 1 < o\n    · have ppos : p ≠ 0 := by\n        rintro rfl\n        rw [zero_add] at ho\n        specialize h (Iio ⟨1, ho⟩) (Iio_mem_nhds (Subtype.mk_lt_mk.mpr zero_lt_one))\n        obtain ⟨_, h⟩ := h\n        exact h.2 <| Subtype.mk_eq_mk.mpr (lt_one_iff_zero.mp h.1.1)\n      have plim : p.IsLimit := by\n        contrapose! h\n        obtain ⟨q, hq⟩ := ((zero_or_succ_or_limit p).resolve_left ppos).resolve_right h\n        use (Ioo ⟨q, ((hq ▸ lt_succ q).trans hpo)⟩ ⟨p + 1, ho⟩)\n        constructor\n        · exact Ioo_mem_nhds (by simp only [hq, Subtype.mk_lt_mk, lt_succ]) (lt_succ p)\n        · intro _ mem\n          have aux1 := Subtype.mk_lt_mk.mp mem.1.1\n          have aux2 := Subtype.mk_lt_mk.mp mem.1.2\n          rw [Subtype.mk_eq_mk]\n          rw [hq] at aux2 ⊢\n          exact ((succ_le_iff.mpr aux1).antisymm (le_of_lt_succ aux2)).symm\n      obtain ⟨l, hl⟩ := exists_Ioc_subset_of_mem_nhds hu ⟨0, plim.pos⟩\n      obtain ⟨x, hx⟩ := h (Ioo ⟨l, hl.1.trans hpo⟩ ⟨p + 1, ho⟩) (Ioo_mem_nhds hl.1 (lt_add_one p))\n      use x\n      exact ⟨⟨hl.2 ⟨hx.1.1.1, lt_succ_iff.mp hx.1.1.2⟩, hx.1.2⟩, fun h ↦ hx.2 (SetCoe.ext h)⟩\n    have hp : o = p + 1 := (le_succ_iff_eq_or_le.mp (le_of_not_lt ho)).resolve_right\n      (not_le_of_lt hpo)\n    have ppos : p ≠ 0 := by\n      rintro rfl\n      obtain ⟨x, hx⟩ := h Set.univ univ_mem\n      have : ↑x < o := x.2\n      simp_rw [hp, zero_add, lt_one_iff_zero] at this\n      exact hx.2 (SetCoe.ext this)\n    obtain ⟨l, hl⟩ := exists_Ioc_subset_of_mem_nhds hu ⟨0, Ordinal.pos_iff_ne_zero.mpr ppos⟩\n    obtain ⟨x, hx⟩ := h (Ioi ⟨l, hl.1.trans hpo⟩) (Ioi_mem_nhds hl.1)\n    use x\n    refine ⟨⟨hl.2 ⟨hx.1.1, ?_⟩, hx.1.2⟩, fun h ↦ hx.2 (SetCoe.ext h)⟩\n    rw [← lt_add_one_iff, ← hp]\n    exact x.2\n\n"}
{"name":"Ordinal.isClosedBelow_iff","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"S : Set Ordinal.{u_1}\no : Ordinal.{u_1}\n⊢ Iff (Ordinal.IsClosedBelow S o) (∀ (p : Ordinal.{u_1}), LT.lt p o → p.IsAcc S → Membership.mem S p)","decl":"theorem isClosedBelow_iff {S : Set Ordinal} {o : Ordinal} : IsClosedBelow S o ↔\n    ∀ p < o, IsAcc p S → p ∈ S := by\n  dsimp [IsClosedBelow]\n  constructor\n  · intro h p plto hp\n    have : AccPt ⟨p, plto⟩ (𝓟 (Iio o ↓∩ S)) := (accPt_subtype _ _).mp hp\n    rw [isClosed_iff_clusterPt] at h\n    exact h ⟨p, plto⟩ this.clusterPt\n  · intro h\n    rw [isClosed_iff_clusterPt]\n    intro r hr\n    match clusterPt_principal.mp hr with\n    | .inl h => exact h\n    | .inr h' => exact h r.1 r.2 <| (accPt_subtype _ _).mpr h'\n\n"}
{"name":"Ordinal.IsClosedBelow.forall_lt","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"S : Set Ordinal.{u_1}\no : Ordinal.{u_1}\na✝² : Ordinal.IsClosedBelow S o\np : Ordinal.{u_1}\na✝¹ : LT.lt p o\na✝ : p.IsAcc S\n⊢ Membership.mem S p","decl":"alias ⟨IsClosedBelow.forall_lt, _⟩ := isClosedBelow_iff\n\n"}
{"name":"Ordinal.IsClosedBelow.sInter","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"o : Ordinal.{u_1}\nS : Set (Set Ordinal.{u_1})\nh : ∀ (C : Set Ordinal.{u_1}), Membership.mem S C → Ordinal.IsClosedBelow C o\n⊢ Ordinal.IsClosedBelow S.sInter o","decl":"theorem IsClosedBelow.sInter {o : Ordinal} {S : Set (Set Ordinal)}\n    (h : ∀ C ∈ S, IsClosedBelow C o) : IsClosedBelow (⋂₀ S) o := by\n  rw [isClosedBelow_iff]\n  intro p plto pAcc C CmemS\n  exact (h C CmemS).forall_lt p plto (pAcc.mono (sInter_subset_of_mem CmemS))\n\n"}
{"name":"Ordinal.IsClosedBelow.iInter","module":"Mathlib.SetTheory.Ordinal.Topology","initialProofState":"ι : Type u\nf : ι → Set Ordinal.{u_1}\no : Ordinal.{u_1}\nh : ∀ (i : ι), Ordinal.IsClosedBelow (f i) o\n⊢ Ordinal.IsClosedBelow (Set.iInter fun i => f i) o","decl":"theorem IsClosedBelow.iInter {ι : Type u} {f : ι → Set Ordinal} {o : Ordinal}\n    (h : ∀ i, IsClosedBelow (f i) o) : IsClosedBelow (⋂ i, f i) o :=\n  IsClosedBelow.sInter fun _ ⟨i, hi⟩ ↦ hi ▸ (h i)\n\n"}
