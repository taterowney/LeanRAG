{"name":"MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Ω → F\ninst✝ : TopologicalSpace F\nhm : LE.le m mΩ\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := id ω, snd := id ω }) μ)","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id [TopologicalSpace F]\n    (hm : m ≤ mΩ) (hf : AEStronglyMeasurable f μ) :\n    AEStronglyMeasurable[m.prod mΩ] (fun x : Ω × Ω => f x.2)\n      (@Measure.map Ω (Ω × Ω) mΩ (m.prod mΩ) (fun ω => (id ω, id ω)) μ) := by\n  rw [← aestronglyMeasurable_comp_snd_map_prod_mk_iff (measurable_id'' hm)] at hf\n  simp_rw [id] at hf ⊢\n  exact hf\n\n"}
{"name":"MeasureTheory.Integrable.comp_snd_map_prod_id","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Ω → F\ninst✝ : NormedAddCommGroup F\nhm : LE.le m mΩ\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := id ω, snd := id ω }) μ)","decl":"theorem _root_.MeasureTheory.Integrable.comp_snd_map_prod_id [NormedAddCommGroup F] (hm : m ≤ mΩ)\n    (hf : Integrable f μ) : Integrable (fun x : Ω × Ω => f x.2)\n      (@Measure.map Ω (Ω × Ω) mΩ (m.prod mΩ) (fun ω => (id ω, id ω)) μ) := by\n  rw [← integrable_comp_snd_map_prod_mk_iff (measurable_id'' hm)] at hf\n  simp_rw [id] at hf ⊢\n  exact hf\n\n"}
{"name":"ProbabilityTheory.condExpKernel_def","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_3\nmΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace Ω\n⊢ Eq (ProbabilityTheory.condExpKernel μ m) (dite (Nonempty Ω) (fun _h => (ProbabilityTheory.condDistrib id id μ).comap id ⋯) fun _h => 0)","decl":"open Classical in\n/-- Kernel associated with the conditional expectation with respect to a σ-algebra. It satisfies\n`μ[f | m] =ᵐ[μ] fun ω => ∫ y, f y ∂(condExpKernel μ m ω)`.\nIt is defined as the conditional distribution of the identity given the identity, where the second\nidentity is understood as a map from `Ω` with the σ-algebra `mΩ` to `Ω` with σ-algebra `m ⊓ mΩ`.\nWe use `m ⊓ mΩ` instead of `m` to ensure that it is a sub-σ-algebra of `mΩ`. We then use\n`Kernel.comap` to get a kernel from `m` to `mΩ` instead of from `m ⊓ mΩ` to `mΩ`. -/\nnoncomputable irreducible_def condExpKernel (μ : Measure Ω) [IsFiniteMeasure μ]\n    (m : MeasurableSpace Ω) : @Kernel Ω Ω m mΩ :=\n  if _h : Nonempty Ω then\n    Kernel.comap (@condDistrib Ω Ω Ω mΩ _ _ mΩ (m ⊓ mΩ) id id μ _) id\n      (measurable_id'' (inf_le_left : m ⊓ mΩ ≤ m))\n  else 0\n\n"}
{"name":"ProbabilityTheory.condExpKernel_eq","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : Nonempty Ω\nm : MeasurableSpace Ω\n⊢ Eq (ProbabilityTheory.condExpKernel μ m) ((ProbabilityTheory.condDistrib id id μ).comap id ⋯)","decl":"lemma condExpKernel_eq (μ : Measure Ω) [IsFiniteMeasure μ] [h : Nonempty Ω]\n    (m : MeasurableSpace Ω) :\n    condExpKernel (mΩ := mΩ) μ m = Kernel.comap (@condDistrib Ω Ω Ω mΩ _ _ mΩ (m ⊓ mΩ) id id μ _) id\n      (measurable_id'' (inf_le_left : m ⊓ mΩ ≤ m)) := by\n  simp [condExpKernel, h]\n\n"}
{"name":"ProbabilityTheory.condexpKernel_eq","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : Nonempty Ω\nm : MeasurableSpace Ω\n⊢ Eq (ProbabilityTheory.condExpKernel μ m) ((ProbabilityTheory.condDistrib id id μ).comap id ⋯)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexpKernel_eq := condExpKernel_eq\n\n"}
{"name":"ProbabilityTheory.condExpKernel_apply_eq_condDistrib","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Nonempty Ω\nω : Ω\n⊢ Eq ((ProbabilityTheory.condExpKernel μ m) ω) ((ProbabilityTheory.condDistrib id id μ) (id ω))","decl":"lemma condExpKernel_apply_eq_condDistrib [Nonempty Ω] {ω : Ω} :\n    condExpKernel μ m ω = @condDistrib Ω Ω Ω mΩ _ _ mΩ (m ⊓ mΩ) id id μ _ (id ω) := by\n  simp [condExpKernel_eq, Kernel.comap_apply]\n\n"}
{"name":"ProbabilityTheory.condexpKernel_apply_eq_condDistrib","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Nonempty Ω\nω : Ω\n⊢ Eq ((ProbabilityTheory.condExpKernel μ m) ω) ((ProbabilityTheory.condDistrib id id μ) (id ω))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexpKernel_apply_eq_condDistrib := condExpKernel_apply_eq_condDistrib\n\n"}
{"name":"ProbabilityTheory.instIsMarkovKernelCondExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.condExpKernel μ m)","decl":"instance : IsMarkovKernel (condExpKernel μ m) := by\n  rcases isEmpty_or_nonempty Ω with h | h\n  · exact ⟨fun a ↦ (IsEmpty.false a).elim⟩\n  · simp [condExpKernel, h]; infer_instance\n\n"}
{"name":"ProbabilityTheory.measurable_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ Measurable fun ω => ((ProbabilityTheory.condExpKernel μ m) ω) s","decl":"theorem measurable_condExpKernel {s : Set Ω} (hs : MeasurableSet s) :\n    Measurable[m] fun ω => condExpKernel μ m ω s := by\n  nontriviality Ω\n  simp_rw [condExpKernel_apply_eq_condDistrib]\n  refine Measurable.mono ?_ (inf_le_left : m ⊓ mΩ ≤ m) le_rfl\n  convert measurable_condDistrib (μ := μ) hs\n  rw [MeasurableSpace.comap_id]\n\n"}
{"name":"ProbabilityTheory.measurable_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ Measurable fun ω => ((ProbabilityTheory.condExpKernel μ m) ω) s","decl":"@[deprecated (since := \"2025-01-21\")] alias measurable_condexpKernel := measurable_condExpKernel\n\n"}
{"name":"ProbabilityTheory.stronglyMeasurable_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ MeasureTheory.StronglyMeasurable fun ω => ((ProbabilityTheory.condExpKernel μ m) ω) s","decl":"theorem stronglyMeasurable_condExpKernel {s : Set Ω} (hs : MeasurableSet s) :\n    StronglyMeasurable[m] fun ω => condExpKernel μ m ω s :=\n  Measurable.stronglyMeasurable (measurable_condExpKernel hs)\n\n"}
{"name":"ProbabilityTheory.stronglyMeasurable_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ MeasureTheory.StronglyMeasurable fun ω => ((ProbabilityTheory.condExpKernel μ m) ω) s","decl":"@[deprecated (since := \"2025-01-21\")]\nalias stronglyMeasurable_condexpKernel := stronglyMeasurable_condExpKernel\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condExpKernel [NormedSpace ℝ F]\n    (hf : AEStronglyMeasurable f μ) :\n    AEStronglyMeasurable (fun ω => ∫ y, f y ∂condExpKernel μ m ω) μ := by\n  nontriviality Ω\n  simp_rw [condExpKernel_apply_eq_condDistrib]\n  exact AEStronglyMeasurable.integral_condDistrib\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf.comp_snd_map_prod_id inf_le_right)\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias _root_.MeasureTheory.AEStronglyMeasurable.integral_condexpKernel :=\n  _root_.MeasureTheory.AEStronglyMeasurable.integral_condExpKernel\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable_integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"theorem aestronglyMeasurable_integral_condExpKernel [NormedSpace ℝ F]\n    (hf : AEStronglyMeasurable f μ) :\n    AEStronglyMeasurable[m] (fun ω => ∫ y, f y ∂condExpKernel μ m ω) μ := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  have h := aestronglyMeasurable_integral_condDistrib\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf.comp_snd_map_prod_id (inf_le_right : m ⊓ mΩ ≤ mΩ))\n  rw [MeasurableSpace.comap_id] at h\n  exact h.mono inf_le_left\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable'_integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"@[deprecated (since := \"2025-01-24\")]\nalias aestronglyMeasurable'_integral_condExpKernel := aestronglyMeasurable_integral_condExpKernel\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable'_integral_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias aestronglyMeasurable'_integral_condexpKernel := aestronglyMeasurable_integral_condExpKernel\n\n"}
{"name":"MeasureTheory.Integrable.condExpKernel_ae","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NormedAddCommGroup F\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ Filter.Eventually (fun ω => MeasureTheory.Integrable f ((ProbabilityTheory.condExpKernel μ m) ω)) (MeasureTheory.ae μ)","decl":"theorem _root_.MeasureTheory.Integrable.condExpKernel_ae (hf_int : Integrable f μ) :\n    ∀ᵐ ω ∂μ, Integrable f (condExpKernel μ m ω) := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  convert Integrable.condDistrib_ae\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf_int.comp_snd_map_prod_id (inf_le_right : m ⊓ mΩ ≤ mΩ)) using 1\n\n"}
{"name":"MeasureTheory.Integrable.condexpKernel_ae","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NormedAddCommGroup F\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ Filter.Eventually (fun ω => MeasureTheory.Integrable f ((ProbabilityTheory.condExpKernel μ m) ω)) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias _root_.MeasureTheory.Integrable.condexpKernel_ae :=\n  _root_.MeasureTheory.Integrable.condExpKernel_ae\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NormedAddCommGroup F\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => Norm.norm (f y)) μ","decl":"theorem _root_.MeasureTheory.Integrable.integral_norm_condExpKernel (hf_int : Integrable f μ) :\n    Integrable (fun ω => ∫ y, ‖f y‖ ∂condExpKernel μ m ω) μ := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  convert Integrable.integral_norm_condDistrib\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf_int.comp_snd_map_prod_id (inf_le_right : m ⊓ mΩ ≤ mΩ)) using 1\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NormedAddCommGroup F\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => Norm.norm (f y)) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias _root_.MeasureTheory.Integrable.integral_norm_condexpKernel :=\n  _root_.MeasureTheory.Integrable.integral_norm_condExpKernel\n\n"}
{"name":"MeasureTheory.Integrable.norm_integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => Norm.norm (MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y)) μ","decl":"theorem _root_.MeasureTheory.Integrable.norm_integral_condExpKernel [NormedSpace ℝ F]\n    (hf_int : Integrable f μ) :\n    Integrable (fun ω => ‖∫ y, f y ∂condExpKernel μ m ω‖) μ := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  convert Integrable.norm_integral_condDistrib\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf_int.comp_snd_map_prod_id (inf_le_right : m ⊓ mΩ ≤ mΩ)) using 1\n\n"}
{"name":"MeasureTheory.Integrable.norm_integral_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => Norm.norm (MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y)) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias _root_.MeasureTheory.Integrable.norm_integral_condexpKernel :=\n  _root_.MeasureTheory.Integrable.norm_integral_condExpKernel\n\n"}
{"name":"MeasureTheory.Integrable.integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"theorem _root_.MeasureTheory.Integrable.integral_condExpKernel [NormedSpace ℝ F]\n    (hf_int : Integrable f μ) :\n    Integrable (fun ω => ∫ y, f y ∂condExpKernel μ m ω) μ := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  convert Integrable.integral_condDistrib\n    (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) aemeasurable_id\n    (hf_int.comp_snd_map_prod_id (inf_le_right : m ⊓ mΩ ≤ mΩ)) using 1\n\n"}
{"name":"MeasureTheory.Integrable.integral_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : NormedAddCommGroup F\nf : Ω → F\ninst✝ : NormedSpace Real F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias _root_.MeasureTheory.Integrable.integral_condexpKernel :=\n  _root_.MeasureTheory.Integrable.integral_condExpKernel\n\n"}
{"name":"ProbabilityTheory.integrable_toReal_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ MeasureTheory.Integrable (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) μ","decl":"theorem integrable_toReal_condExpKernel {s : Set Ω} (hs : MeasurableSet s) :\n    Integrable (fun ω => (condExpKernel μ m ω s).toReal) μ := by\n  nontriviality Ω\n  rw [condExpKernel_eq]\n  exact integrable_toReal_condDistrib (aemeasurable_id'' μ (inf_le_right : m ⊓ mΩ ≤ mΩ)) hs\n\n"}
{"name":"ProbabilityTheory.integrable_toReal_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ MeasureTheory.Integrable (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) μ","decl":"@[deprecated (since := \"2025-01-21\")]\nalias integrable_toReal_condexpKernel := integrable_toReal_condExpKernel\n\n"}
{"name":"ProbabilityTheory.condExpKernel_ae_eq_condExp'","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp (Min.min m mΩ) μ (s.indicator fun ω => 1))","decl":"lemma condExpKernel_ae_eq_condExp' {s : Set Ω} (hs : MeasurableSet s) :\n    (fun ω ↦ (condExpKernel μ m ω s).toReal) =ᵐ[μ] μ⟦s | m ⊓ mΩ⟧ := by\n  rcases isEmpty_or_nonempty Ω with h | h\n  · have : μ = 0 := Measure.eq_zero_of_isEmpty μ\n    simpa [this] using trivial\n  have h := condDistrib_ae_eq_condExp (μ := μ)\n    (measurable_id'' (inf_le_right : m ⊓ mΩ ≤ mΩ)) measurable_id hs\n  simp only [id_eq, MeasurableSpace.comap_id, preimage_id_eq] at h\n  simp_rw [condExpKernel_apply_eq_condDistrib]\n  exact h\n\n"}
{"name":"ProbabilityTheory.condexpKernel_ae_eq_condexp'","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp (Min.min m mΩ) μ (s.indicator fun ω => 1))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexpKernel_ae_eq_condexp' := condExpKernel_ae_eq_condExp'\n\n"}
{"name":"ProbabilityTheory.condExpKernel_ae_eq_condExp","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhm : LE.le m mΩ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp m μ (s.indicator fun ω => 1))","decl":"lemma condExpKernel_ae_eq_condExp\n    (hm : m ≤ mΩ) {s : Set Ω} (hs : MeasurableSet s) :\n    (fun ω ↦ (condExpKernel μ m ω s).toReal) =ᵐ[μ] μ⟦s | m⟧ :=\n  (condExpKernel_ae_eq_condExp' hs).trans (by rw [inf_of_le_left hm])\n\n"}
{"name":"ProbabilityTheory.condexpKernel_ae_eq_condexp","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhm : LE.le m mΩ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp m μ (s.indicator fun ω => 1))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexpKernel_ae_eq_condexp := condExpKernel_ae_eq_condExp\n\n"}
{"name":"ProbabilityTheory.condExpKernel_ae_eq_trim_condExp","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhm : LE.le m mΩ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.trim hm)).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp m μ (s.indicator fun ω => 1))","decl":"lemma condExpKernel_ae_eq_trim_condExp\n    (hm : m ≤ mΩ) {s : Set Ω} (hs : MeasurableSet s) :\n    (fun ω ↦ (condExpKernel μ m ω s).toReal) =ᵐ[μ.trim hm] μ⟦s | m⟧ := by\n  rw [(measurable_condExpKernel hs).ennreal_toReal.stronglyMeasurable.ae_eq_trim_iff hm\n    stronglyMeasurable_condExp]\n  exact condExpKernel_ae_eq_condExp hm hs\n\n"}
{"name":"ProbabilityTheory.condexpKernel_ae_eq_trim_condexp","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nm mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhm : LE.le m mΩ\ns : Set Ω\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.trim hm)).EventuallyEq (fun ω => (((ProbabilityTheory.condExpKernel μ m) ω) s).toReal) (MeasureTheory.condExp m μ (s.indicator fun ω => 1))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexpKernel_ae_eq_trim_condexp := condExpKernel_ae_eq_trim_condExp\n\n"}
{"name":"ProbabilityTheory.condExp_ae_eq_integral_condExpKernel'","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ninst✝² : NormedAddCommGroup F\nf : Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (Min.min m mΩ) μ f) fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y","decl":"theorem condExp_ae_eq_integral_condExpKernel' [NormedAddCommGroup F] {f : Ω → F}\n    [NormedSpace ℝ F] [CompleteSpace F] (hf_int : Integrable f μ) :\n    μ[f|m ⊓ mΩ] =ᵐ[μ] fun ω => ∫ y, f y ∂condExpKernel μ m ω := by\n  rcases isEmpty_or_nonempty Ω with h | h\n  · have : μ = 0 := Measure.eq_zero_of_isEmpty μ\n    simpa [this] using trivial\n  have hX : @Measurable Ω Ω mΩ (m ⊓ mΩ) id := measurable_id.mono le_rfl (inf_le_right : m ⊓ mΩ ≤ mΩ)\n  simp_rw [condExpKernel_apply_eq_condDistrib]\n  have h := condExp_ae_eq_integral_condDistrib_id hX hf_int\n  simpa only [MeasurableSpace.comap_id, id_eq] using h\n\n"}
{"name":"ProbabilityTheory.condexp_ae_eq_integral_condexpKernel'","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ninst✝² : NormedAddCommGroup F\nf : Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (Min.min m mΩ) μ f) fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_integral_condexpKernel' := condExp_ae_eq_integral_condExpKernel'\n\n"}
{"name":"ProbabilityTheory.condExp_ae_eq_integral_condExpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ninst✝² : NormedAddCommGroup F\nf : Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhm : LE.le m mΩ\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ f) fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y","decl":"/-- The conditional expectation of `f` with respect to a σ-algebra `m` is almost everywhere equal to\nthe integral `∫ y, f y ∂(condExpKernel μ m ω)`. -/\ntheorem condExp_ae_eq_integral_condExpKernel [NormedAddCommGroup F] {f : Ω → F}\n    [NormedSpace ℝ F] [CompleteSpace F] (hm : m ≤ mΩ) (hf_int : Integrable f μ) :\n    μ[f|m] =ᵐ[μ] fun ω => ∫ y, f y ∂condExpKernel μ m ω :=\n  ((condExp_ae_eq_integral_condExpKernel' hf_int).symm.trans (by rw [inf_of_le_left hm])).symm\n\n"}
{"name":"ProbabilityTheory.condexp_ae_eq_integral_condexpKernel","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nm mΩ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ninst✝² : NormedAddCommGroup F\nf : Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhm : LE.le m mΩ\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ f) fun ω => MeasureTheory.integral ((ProbabilityTheory.condExpKernel μ m) ω) fun y => f y","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_integral_condexpKernel := condExp_ae_eq_integral_condExpKernel\n\n"}
{"name":"ProbabilityTheory.condExp_generateFrom_singleton","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhs : MeasurableSet s\nf : Ω → F\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.generateFrom (Singleton.singleton s)) μ f) fun x => MeasureTheory.integral (ProbabilityTheory.cond μ s) fun x => f x","decl":"lemma condExp_generateFrom_singleton (hs : MeasurableSet s) {f : Ω → F} (hf : Integrable f μ) :\n    μ[f | generateFrom {s}] =ᵐ[μ.restrict s] fun _ ↦ ∫ x, f x ∂μ[|s] := by\n  by_cases hμs : μ s = 0\n  · rw [Measure.restrict_eq_zero.2 hμs]\n    rfl\n  refine ae_eq_trans (condExp_restrict_ae_eq_restrict\n    (generateFrom_singleton_le hs)\n    (measurableSet_generateFrom rfl) hf).symm ?_\n  · refine (ae_eq_condExp_of_forall_setIntegral_eq (generateFrom_singleton_le hs) hf.restrict ?_ ?_\n      stronglyMeasurable_const.aestronglyMeasurable).symm\n    · rintro t - -\n      rw [integrableOn_const]\n      exact Or.inr <| measure_lt_top (μ.restrict s) t\n    · rintro t ht -\n      obtain (h | h | h | h) := measurableSet_generateFrom_singleton_iff.1 ht\n      · simp [h]\n      · simp only [h, cond, integral_smul_measure, ENNReal.toReal_inv, integral_const,\n          MeasurableSet.univ, Measure.restrict_apply, univ_inter, Measure.restrict_apply_self]\n        rw [smul_inv_smul₀, Measure.restrict_restrict hs, inter_self]\n        exact ENNReal.toReal_ne_zero.2 ⟨hμs, measure_ne_top _ _⟩\n      · simp only [h, integral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter,\n          ((Measure.restrict_apply_eq_zero hs.compl).2 <| compl_inter_self s ▸ measure_empty),\n          ENNReal.zero_toReal, zero_smul, setIntegral_zero_measure]\n      · simp only [h, Measure.restrict_univ, cond, integral_smul_measure, ENNReal.toReal_inv,\n          integral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter,\n          smul_inv_smul₀ <| ENNReal.toReal_ne_zero.2 ⟨hμs, measure_ne_top _ _⟩]\n\n"}
{"name":"ProbabilityTheory.condexp_generateFrom_singleton","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nF : Type u_2\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhs : MeasurableSet s\nf : Ω → F\nhf : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.generateFrom (Singleton.singleton s)) μ f) fun x => MeasureTheory.integral (ProbabilityTheory.cond μ s) fun x => f x","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_generateFrom_singleton := condExp_generateFrom_singleton\n\n"}
{"name":"ProbabilityTheory.condExp_set_generateFrom_singleton","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.generateFrom (Singleton.singleton s)) μ (t.indicator fun ω => 1)) fun x => ((ProbabilityTheory.cond μ s) t).toReal","decl":"lemma condExp_set_generateFrom_singleton (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ⟦t | generateFrom {s}⟧ =ᵐ[μ.restrict s] fun _ ↦ (μ[t|s]).toReal := by\n  rw [← integral_indicator_one ht]\n  exact condExp_generateFrom_singleton hs <| Integrable.indicator (integrable_const 1) ht\n\n"}
{"name":"ProbabilityTheory.condexp_set_generateFrom_singleton","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.generateFrom (Singleton.singleton s)) μ (t.indicator fun ω => 1)) fun x => ((ProbabilityTheory.cond μ s) t).toReal","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_set_generateFrom_singleton := condExp_set_generateFrom_singleton\n\n"}
{"name":"ProbabilityTheory.condExpKernel_singleton_ae_eq_cond","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ns t : Set Ω\ninst✝ : StandardBorelSpace Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Filter.Eventually (fun ω => Eq (((ProbabilityTheory.condExpKernel μ (MeasurableSpace.generateFrom (Singleton.singleton s))) ω) t) ((ProbabilityTheory.cond μ s) t)) (MeasureTheory.ae (μ.restrict s))","decl":"lemma condExpKernel_singleton_ae_eq_cond [StandardBorelSpace Ω] (hs : MeasurableSet s)\n    (ht : MeasurableSet t) :\n    ∀ᵐ ω ∂μ.restrict s,\n      condExpKernel μ (generateFrom {s}) ω t = μ[t|s] := by\n  have : (fun ω ↦ (condExpKernel μ (generateFrom {s}) ω t).toReal) =ᵐ[μ.restrict s]\n      μ⟦t | generateFrom {s}⟧ :=\n    ae_restrict_le <| condExpKernel_ae_eq_condExp\n      (generateFrom_singleton_le hs) ht\n  filter_upwards [condExp_set_generateFrom_singleton hs ht, this] with ω hω₁ hω₂\n  rwa [hω₁, ENNReal.toReal_eq_toReal (measure_ne_top _ t) (measure_ne_top _ t)] at hω₂\n\n"}
{"name":"ProbabilityTheory.condexpKernel_singleton_ae_eq_cond","module":"Mathlib.Probability.Kernel.Condexp","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ns t : Set Ω\ninst✝ : StandardBorelSpace Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Filter.Eventually (fun ω => Eq (((ProbabilityTheory.condExpKernel μ (MeasurableSpace.generateFrom (Singleton.singleton s))) ω) t) ((ProbabilityTheory.cond μ s) t)) (MeasureTheory.ae (μ.restrict s))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexpKernel_singleton_ae_eq_cond := condExpKernel_singleton_ae_eq_cond\n\n"}
