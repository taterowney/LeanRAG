{"name":"AlgebraicGeometry.IsLocallyNoetherian.component_noetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocallyNoetherian X\nU : ↑X.affineOpens\n⊢ IsNoetherianRing ↑(X.presheaf.obj { unop := ↑U })","decl":"/-- A scheme `X` is locally Noetherian if `𝒪ₓ(U)` is Noetherian for all affine `U`. -/\nclass IsLocallyNoetherian (X : Scheme) : Prop where\n  component_noetherian : ∀ (U : X.affineOpens),\n    IsNoetherianRing Γ(X, U) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.isNoetherianRing_of_away","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : Type u\ninst✝ : CommRing R\nS : Finset R\nhS : Eq (Ideal.span ↑S) Top.top\nhN : ∀ (s : Subtype fun x => Membership.mem S x), IsNoetherianRing (Localization.Away ↑s)\n⊢ IsNoetherianRing R","decl":"include hS hN in\n/-- Let `R` be a ring, and `f i` a finite collection of elements of `R` generating the unit ideal.\nIf the localization of `R` at each `f i` is noetherian, so is `R`.\n\nWe follow the proof given in [Har77], Proposition II.3.2 -/\ntheorem isNoetherianRing_of_away : IsNoetherianRing R := by\n  apply monotone_stabilizes_iff_noetherian.mp\n  intro I\n  let floc s := algebraMap R (Away (M := R) s)\n  let suitableN s :=\n    { n : ℕ | ∀ m : ℕ, n ≤ m → (Ideal.map (floc s) (I n)) = (Ideal.map (floc s) (I m)) }\n  let minN s := sInf (suitableN s)\n  have hSuit : ∀ s : S, minN s ∈ suitableN s := by\n    intro s\n    apply Nat.sInf_mem\n    let f : ℕ →o Ideal (Away (M := R) s) :=\n      ⟨fun n ↦ Ideal.map (floc s) (I n), fun _ _ h ↦ Ideal.map_mono (I.monotone h)⟩\n    exact monotone_stabilizes_iff_noetherian.mpr (hN s) f\n  let N := Finset.sup S minN\n  use N\n  have hN : ∀ s : S, minN s ≤ N := fun s => Finset.le_sup s.prop\n  intro n hn\n  rw [IsLocalization.ideal_eq_iInf_comap_map_away hS (I N),\n      IsLocalization.ideal_eq_iInf_comap_map_away hS (I n),\n      iInf_subtype', iInf_subtype']\n  apply iInf_congr\n  intro s\n  congr 1\n  rw [← hSuit s N (hN s)]\n  exact hSuit s n <| Nat.le_trans (hN s) hn\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_of_affine_cover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nι : Sort u_1\nS : ι → ↑X.affineOpens\nhS : Eq (iSup fun i => ↑(S i)) Top.top\nhS' : ∀ (i : ι), IsNoetherianRing ↑(X.presheaf.obj { unop := ↑(S i) })\n⊢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"/-- If a scheme `X` has a cover by affine opens whose sections are Noetherian rings,\nthen `X` is locally Noetherian. -/\ntheorem isLocallyNoetherian_of_affine_cover {ι} {S : ι → X.affineOpens}\n    (hS : (⨆ i, S i : X.Opens) = ⊤)\n    (hS' : ∀ i, IsNoetherianRing Γ(X, S i)) : IsLocallyNoetherian X := by\n  refine ⟨fun U => ?_⟩\n  induction U using of_affine_open_cover S hS with\n  | basicOpen U f hN =>\n    have := U.prop.isLocalization_basicOpen f\n    exact IsLocalization.isNoetherianRing (.powers f) Γ(X, X.basicOpen f) hN\n  | openCover U s _ hN =>\n    apply isNoetherianRing_of_away s ‹_›\n    intro ⟨f, hf⟩\n    have : IsNoetherianRing Γ(X, X.basicOpen f) := hN ⟨f, hf⟩\n    have := U.prop.isLocalization_basicOpen f\n    have hEq := IsLocalization.algEquiv (.powers f) (Localization.Away f) Γ(X, X.basicOpen f)\n    exact isNoetherianRing_of_ringEquiv Γ(X, X.basicOpen f) hEq.symm.toRingEquiv\n  | hU => exact hS' _\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nι : Sort u_1\nS : ι → ↑X.affineOpens\nhS : Eq (iSup fun i => ↑(S i)) Top.top\n⊢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (∀ (i : ι), IsNoetherianRing ↑(X.presheaf.obj { unop := ↑(S i) }))","decl":"/-- A scheme is locally Noetherian if and only if it is covered by affine opens whose sections\nare noetherian rings.\n\nSee [Har77], Proposition II.3.2. -/\ntheorem isLocallyNoetherian_iff_of_iSup_eq_top {ι} {S : ι → X.affineOpens}\n    (hS : (⨆ i, S i : X.Opens) = ⊤) :\n    IsLocallyNoetherian X ↔ ∀ i, IsNoetherianRing Γ(X, S i) :=\n  ⟨fun _ i => IsLocallyNoetherian.component_noetherian (S i),\n   isLocallyNoetherian_of_affine_cover hS⟩\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_of_affine_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\ninst✝ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\n⊢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (∀ (i : 𝒰.J), IsNoetherianRing ↑((𝒰.obj i).presheaf.obj { unop := Top.top }))","decl":"open CategoryTheory in\n/-- A version of `isLocallyNoetherian_iff_of_iSup_eq_top` using `Scheme.OpenCover`. -/\ntheorem isLocallyNoetherian_iff_of_affine_openCover (𝒰 : Scheme.OpenCover.{v, u} X)\n    [∀ i, IsAffine (𝒰.obj i)] :\n    IsLocallyNoetherian X ↔ ∀ (i : 𝒰.J), IsNoetherianRing Γ(𝒰.obj i, ⊤) := by\n  constructor\n  · intro h i\n    let U := Scheme.Hom.opensRange (𝒰.map i)\n    have := h.component_noetherian ⟨U, isAffineOpen_opensRange _⟩\n    apply isNoetherianRing_of_ringEquiv (R := Γ(X, U))\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact (IsOpenImmersion.ΓIsoTop (𝒰.map i)).symm\n  · intro hCNoeth\n    let fS i : X.affineOpens := ⟨Scheme.Hom.opensRange (𝒰.map i), isAffineOpen_opensRange _⟩\n    apply isLocallyNoetherian_of_affine_cover (S := fS)\n    · rw [← Scheme.OpenCover.iSup_opensRange 𝒰]\n    intro i\n    apply isNoetherianRing_of_ringEquiv (R := Γ(𝒰.obj i, ⊤))\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact IsOpenImmersion.ΓIsoTop (𝒰.map i)\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsLocallyNoetherian Y\n⊢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"lemma isLocallyNoetherian_of_isOpenImmersion {Y : Scheme} (f : X ⟶ Y) [IsOpenImmersion f]\n    [IsLocallyNoetherian Y] : IsLocallyNoetherian X := by\n  refine ⟨fun U => ?_⟩\n  let V : Y.affineOpens := ⟨f ''ᵁ U, IsAffineOpen.image_of_isOpenImmersion U.prop _⟩\n  suffices Γ(X, U) ≅ Γ(Y, V) by\n    convert isNoetherianRing_of_ringEquiv (R := Γ(Y, V)) _\n    · apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n      exact this.symm\n    · exact IsLocallyNoetherian.component_noetherian V\n  rw [← Scheme.Hom.preimage_image_eq f U]\n  trans\n  · apply IsOpenImmersion.ΓIso\n  · suffices Scheme.Hom.opensRange f ⊓ V = V by\n      rw [this]\n    rw [← Opens.coe_inj]\n    rw [Opens.coe_inf, Scheme.Hom.coe_opensRange, IsOpenMap.coe_functor_obj,\n      Set.inter_eq_right, Set.image_subset_iff, Set.preimage_range]\n    exact Set.subset_univ _\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (∀ (i : 𝒰.J), AlgebraicGeometry.IsLocallyNoetherian (𝒰.obj i))","decl":"/-- If `𝒰` is an open cover of a scheme `X`, then `X` is locally noetherian if and only if\n`𝒰.obj i` are all locally noetherian. -/\ntheorem isLocallyNoetherian_iff_openCover (𝒰 : Scheme.OpenCover X) :\n    IsLocallyNoetherian X ↔ ∀ (i : 𝒰.J), IsLocallyNoetherian (𝒰.obj i) := by\n  constructor\n  · intro h i\n    exact isLocallyNoetherian_of_isOpenImmersion (𝒰.map i)\n  · rw [isLocallyNoetherian_iff_of_affine_openCover (𝒰 := 𝒰.affineRefinement.openCover)]\n    intro h i\n    exact @isNoetherianRing_of_ringEquiv _ _ _ _\n      (IsOpenImmersion.ΓIsoTop (Scheme.Cover.map _ i.2)).symm.commRingCatIsoToRingEquiv\n      (IsLocallyNoetherian.component_noetherian ⟨_, isAffineOpen_opensRange _⟩)\n\n"}
{"name":"AlgebraicGeometry.instNoetherianSpaceαTopologicalSpaceCarrierCommRingCatSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninst✝ : IsNoetherianRing ↑R\n⊢ TopologicalSpace.NoetherianSpace ↑↑(AlgebraicGeometry.Spec R).toPresheafedSpace","decl":"/-- If `R` is a noetherian ring, `Spec R` is a noetherian topological space. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    NoetherianSpace (Spec R) := by\n  convert PrimeSpectrum.instNoetherianSpace (R := R)\n\n"}
{"name":"AlgebraicGeometry.noetherianSpace_of_isAffine","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : IsNoetherianRing ↑(X.presheaf.obj { unop := Top.top })\n⊢ TopologicalSpace.NoetherianSpace ↑↑X.toPresheafedSpace","decl":"lemma noetherianSpace_of_isAffine [IsAffine X] [IsNoetherianRing Γ(X, ⊤)] :\n    NoetherianSpace X :=\n  (noetherianSpace_iff_of_homeomorph X.isoSpec.inv.homeomorph).mp inferInstance\n\n"}
{"name":"AlgebraicGeometry.noetherianSpace_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ninst✝ : IsNoetherianRing ↑(X.presheaf.obj { unop := U })\n⊢ TopologicalSpace.NoetherianSpace ↑↑(↑U).toPresheafedSpace","decl":"lemma noetherianSpace_of_isAffineOpen (U : X.Opens) (hU : IsAffineOpen U)\n    [IsNoetherianRing Γ(X, U)] :\n    NoetherianSpace U := by\n  have : IsNoetherianRing Γ(U, ⊤) := isNoetherianRing_of_ringEquiv _\n    (Scheme.restrictFunctorΓ.app (op U)).symm.commRingCatIsoToRingEquiv\n  exact @noetherianSpace_of_isAffine _ hU _\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactOfIsLocallyNoetherianOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Z : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsLocallyNoetherian X\nf : Quiver.Hom Z X\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.QuasiCompact f","decl":"/-- Any open immersion `Z ⟶ X` with `X` locally Noetherian is quasi-compact. -/\n@[stacks 01OX]\ninstance (priority := 100) {Z : Scheme} [IsLocallyNoetherian X]\n    {f : Z ⟶ X} [IsOpenImmersion f] : QuasiCompact f := by\n  apply (quasiCompact_iff_forall_affine f).mpr\n  intro U hU\n  rw [Opens.map_coe, ← Set.preimage_inter_range]\n  apply f.isOpenEmbedding.isInducing.isCompact_preimage'\n  · apply (noetherianSpace_set_iff _).mp\n    · convert noetherianSpace_of_isAffineOpen U hU\n      apply IsLocallyNoetherian.component_noetherian ⟨U, hU⟩\n    · exact Set.inter_subset_left\n  · exact Set.inter_subset_right\n\n"}
{"name":"AlgebraicGeometry.IsLocallyNoetherian.quasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsLocallyNoetherian X\n⊢ QuasiSeparatedSpace ↑↑X.toPresheafedSpace","decl":"/-- A locally Noetherian scheme is quasi-separated. -/\n@[stacks 01OY]\ninstance (priority := 100) IsLocallyNoetherian.quasiSeparatedSpace [IsLocallyNoetherian X] :\n    QuasiSeparatedSpace X := by\n  apply (quasiSeparatedSpace_iff_affine X).mpr\n  intro U V\n  have hInd := U.2.fromSpec.isOpenEmbedding.isInducing\n  apply (hInd.isCompact_preimage_iff ?_).mp\n  · rw [← Set.preimage_inter_range, IsAffineOpen.range_fromSpec, Set.inter_comm]\n    apply hInd.isCompact_preimage'\n    · apply (noetherianSpace_set_iff _).mp\n      · convert noetherianSpace_of_isAffineOpen U.1 U.2\n        apply IsLocallyNoetherian.component_noetherian\n      · exact Set.inter_subset_left\n    · rw [IsAffineOpen.range_fromSpec]\n      exact Set.inter_subset_left\n  · rw [IsAffineOpen.range_fromSpec]\n    exact Set.inter_subset_left\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (AlgebraicGeometry.IsNoetherian X) (And (AlgebraicGeometry.IsLocallyNoetherian X) (CompactSpace ↑↑X.toPresheafedSpace))","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.toCompactSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsNoetherian X\n⊢ CompactSpace ↑↑X.toPresheafedSpace","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.toIsLocallyNoetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsNoetherian X\n⊢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff_of_finite_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nι : Sort u_1\ninst✝ : Finite ι\nS : ι → ↑X.affineOpens\nhS : Eq (iSup fun i => ↑(S i)) Top.top\n⊢ Iff (AlgebraicGeometry.IsNoetherian X) (∀ (i : ι), IsNoetherianRing ↑(X.presheaf.obj { unop := ↑(S i) }))","decl":"/-- A scheme is Noetherian if and only if it is covered by finitely many affine opens whose\nsections are noetherian rings. -/\ntheorem isNoetherian_iff_of_finite_iSup_eq_top {ι} [Finite ι] {S : ι → X.affineOpens}\n    (hS : (⨆ i, S i : X.Opens) = ⊤) :\n    IsNoetherian X ↔ ∀ i, IsNoetherianRing Γ(X, S i) := by\n  constructor\n  · intro h i\n    apply (isLocallyNoetherian_iff_of_iSup_eq_top hS).mp\n    exact h.toIsLocallyNoetherian\n  · intro h\n    convert IsNoetherian.mk\n    · exact isLocallyNoetherian_of_affine_cover hS h\n    · constructor\n      rw [← Opens.coe_top, ← hS, Opens.iSup_mk]\n      apply isCompact_iUnion\n      intro i\n      apply isCompact_iff_isCompact_univ.mpr\n      convert CompactSpace.isCompact_univ\n      have : NoetherianSpace (S i) := by\n        apply noetherianSpace_of_isAffineOpen (S i).1 (S i).2\n      apply NoetherianSpace.compactSpace (S i)\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff_of_finite_affine_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\ninst✝¹ : Finite 𝒰.J\ninst✝ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\n⊢ Iff (AlgebraicGeometry.IsNoetherian X) (∀ (i : 𝒰.J), IsNoetherianRing ↑((𝒰.obj i).presheaf.obj { unop := Top.top }))","decl":"/-- A version of `isNoetherian_iff_of_finite_iSup_eq_top` using `Scheme.OpenCover`. -/\ntheorem isNoetherian_iff_of_finite_affine_openCover {𝒰 : Scheme.OpenCover.{v, u} X}\n    [Finite 𝒰.J] [∀ i, IsAffine (𝒰.obj i)] :\n    IsNoetherian X ↔ ∀ (i : 𝒰.J), IsNoetherianRing Γ(𝒰.obj i, ⊤) := by\n  constructor\n  · intro h i\n    apply (isLocallyNoetherian_iff_of_affine_openCover _).mp\n    exact h.toIsLocallyNoetherian\n  · intro hNoeth\n    convert IsNoetherian.mk\n    · exact (isLocallyNoetherian_iff_of_affine_openCover _).mpr hNoeth\n    · exact Scheme.OpenCover.compactSpace 𝒰\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.noetherianSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsNoetherian X\n⊢ TopologicalSpace.NoetherianSpace ↑↑X.toPresheafedSpace","decl":"open CategoryTheory in\n/-- A Noetherian scheme has a Noetherian underlying topological space. -/\n@[stacks 01OZ]\ninstance (priority := 100) IsNoetherian.noetherianSpace [IsNoetherian X] :\n    NoetherianSpace X := by\n  apply TopologicalSpace.noetherian_univ_iff.mp\n  let 𝒰 := X.affineCover.finiteSubcover\n  rw [← 𝒰.iUnion_range]\n  suffices ∀ i : 𝒰.J, NoetherianSpace (Set.range <| (𝒰.map i).base) by\n    apply NoetherianSpace.iUnion\n  intro i\n  have : IsAffine (𝒰.obj i) := by\n    rw [X.affineCover.finiteSubcover_obj]\n    apply Scheme.isAffine_affineCover\n  let U : X.affineOpens := ⟨Scheme.Hom.opensRange (𝒰.map i), isAffineOpen_opensRange _⟩\n  convert noetherianSpace_of_isAffineOpen U.1 U.2\n  apply IsLocallyNoetherian.component_noetherian\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_of_noetherianSpace_source","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : TopologicalSpace.NoetherianSpace ↑↑X.toPresheafedSpace\nf : Quiver.Hom X Y\n⊢ AlgebraicGeometry.QuasiCompact f","decl":"/-- Any morphism of schemes `f : X ⟶ Y` with `X` Noetherian is quasi-compact. -/\n@[stacks 01P0]\ninstance (priority := 100) quasiCompact_of_noetherianSpace_source {X Y : Scheme}\n    [NoetherianSpace X] (f : X ⟶ Y) : QuasiCompact f :=\n  ⟨fun _ _ _ => NoetherianSpace.isCompact _⟩\n\n"}
{"name":"AlgebraicGeometry.instIsLocallyNoetherianSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninst✝ : IsNoetherianRing ↑R\n⊢ AlgebraicGeometry.IsLocallyNoetherian (AlgebraicGeometry.Spec R)","decl":"/-- If `R` is a Noetherian ring, `Spec R` is a locally Noetherian scheme. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    IsLocallyNoetherian (Spec R) := by\n  apply isLocallyNoetherian_of_affine_cover\n    (ι := Fin 1) (S := fun _ => ⟨⊤, isAffineOpen_top (Spec R)⟩)\n  · exact iSup_const\n  · intro\n    apply isNoetherianRing_of_ringEquiv R\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact (Scheme.ΓSpecIso R).symm\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianRingCarrierOfIsLocallyNoetherianSpec","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninst✝ : AlgebraicGeometry.IsLocallyNoetherian (AlgebraicGeometry.Spec R)\n⊢ IsNoetherianRing ↑R","decl":"instance (priority := 100) {R : CommRingCat}\n    [IsLocallyNoetherian (Spec R)] : IsNoetherianRing R := by\n  have := IsLocallyNoetherian.component_noetherian ⟨⊤, AlgebraicGeometry.isAffineOpen_top (Spec R)⟩\n  apply isNoetherianRing_of_ringEquiv Γ(Spec R, ⊤)\n  apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n  exact Scheme.ΓSpecIso R\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninst✝ : IsNoetherianRing ↑R\n⊢ AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec R)","decl":"/-- If `R` is a Noetherian ring, `Spec R` is a Noetherian scheme. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    IsNoetherian (Spec R) where\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianSpecOfOfIsNoetherianRing","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\n⊢ AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec (CommRingCat.of R))","decl":"instance {R} [CommRing R] [IsNoetherianRing R] :\n    IsNoetherian (Spec (.of R)) := by\n  suffices IsNoetherianRing (CommRingCat.of R) by infer_instance\n  simp only [CommRingCat.coe_of]\n  assumption\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_Spec","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\n⊢ Iff (AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec R)) (IsNoetherianRing ↑R)","decl":"/-- `R` is a Noetherian ring if and only if `Spec R` is a Noetherian scheme. -/\ntheorem isNoetherian_Spec {R : CommRingCat} :\n    IsNoetherian (Spec R) ↔ IsNoetherianRing R :=\n  ⟨fun _ => inferInstance,\n   fun _ => inferInstance⟩\n\n"}
{"name":"AlgebraicGeometry.finite_irreducibleComponents_of_isNoetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsNoetherian X\n⊢ (irreducibleComponents ↑↑X.toPresheafedSpace).Finite","decl":"/-- A Noetherian scheme has a finite number of irreducible components. -/\n@[stacks 0BA8]\ntheorem finite_irreducibleComponents_of_isNoetherian [IsNoetherian X] :\n    (irreducibleComponents X).Finite := NoetherianSpace.finite_irreducibleComponents\n\n"}
