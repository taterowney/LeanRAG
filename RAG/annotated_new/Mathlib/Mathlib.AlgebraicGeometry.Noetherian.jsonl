{"name":"AlgebraicGeometry.IsLocallyNoetherian.component_noetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocallyNoetherian X\nU : â†‘X.affineOpens\nâŠ¢ IsNoetherianRing â†‘(X.presheaf.obj { unop := â†‘U })","decl":"/-- A scheme `X` is locally Noetherian if `ğ’ªâ‚“(U)` is Noetherian for all affine `U`. -/\nclass IsLocallyNoetherian (X : Scheme) : Prop where\n  component_noetherian : âˆ€ (U : X.affineOpens),\n    IsNoetherianRing Î“(X, U) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.isNoetherianRing_of_away","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : Type u\ninstâœ : CommRing R\nS : Finset R\nhS : Eq (Ideal.span â†‘S) Top.top\nhN : âˆ€ (s : Subtype fun x => Membership.mem S x), IsNoetherianRing (Localization.Away â†‘s)\nâŠ¢ IsNoetherianRing R","decl":"include hS hN in\n/-- Let `R` be a ring, and `f i` a finite collection of elements of `R` generating the unit ideal.\nIf the localization of `R` at each `f i` is noetherian, so is `R`.\n\nWe follow the proof given in [Har77], Proposition II.3.2 -/\ntheorem isNoetherianRing_of_away : IsNoetherianRing R := by\n  apply monotone_stabilizes_iff_noetherian.mp\n  intro I\n  let floc s := algebraMap R (Away (M := R) s)\n  let suitableN s :=\n    { n : â„• | âˆ€ m : â„•, n â‰¤ m â†’ (Ideal.map (floc s) (I n)) = (Ideal.map (floc s) (I m)) }\n  let minN s := sInf (suitableN s)\n  have hSuit : âˆ€ s : S, minN s âˆˆ suitableN s := by\n    intro s\n    apply Nat.sInf_mem\n    let f : â„• â†’o Ideal (Away (M := R) s) :=\n      âŸ¨fun n â†¦ Ideal.map (floc s) (I n), fun _ _ h â†¦ Ideal.map_mono (I.monotone h)âŸ©\n    exact monotone_stabilizes_iff_noetherian.mpr (hN s) f\n  let N := Finset.sup S minN\n  use N\n  have hN : âˆ€ s : S, minN s â‰¤ N := fun s => Finset.le_sup s.prop\n  intro n hn\n  rw [IsLocalization.ideal_eq_iInf_comap_map_away hS (I N),\n      IsLocalization.ideal_eq_iInf_comap_map_away hS (I n),\n      iInf_subtype', iInf_subtype']\n  apply iInf_congr\n  intro s\n  congr 1\n  rw [â† hSuit s N (hN s)]\n  exact hSuit s n <| Nat.le_trans (hN s) hn\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_of_affine_cover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nÎ¹ : Sort u_1\nS : Î¹ â†’ â†‘X.affineOpens\nhS : Eq (iSup fun i => â†‘(S i)) Top.top\nhS' : âˆ€ (i : Î¹), IsNoetherianRing â†‘(X.presheaf.obj { unop := â†‘(S i) })\nâŠ¢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"/-- If a scheme `X` has a cover by affine opens whose sections are Noetherian rings,\nthen `X` is locally Noetherian. -/\ntheorem isLocallyNoetherian_of_affine_cover {Î¹} {S : Î¹ â†’ X.affineOpens}\n    (hS : (â¨† i, S i : X.Opens) = âŠ¤)\n    (hS' : âˆ€ i, IsNoetherianRing Î“(X, S i)) : IsLocallyNoetherian X := by\n  refine âŸ¨fun U => ?_âŸ©\n  induction U using of_affine_open_cover S hS with\n  | basicOpen U f hN =>\n    have := U.prop.isLocalization_basicOpen f\n    exact IsLocalization.isNoetherianRing (.powers f) Î“(X, X.basicOpen f) hN\n  | openCover U s _ hN =>\n    apply isNoetherianRing_of_away s â€¹_â€º\n    intro âŸ¨f, hfâŸ©\n    have : IsNoetherianRing Î“(X, X.basicOpen f) := hN âŸ¨f, hfâŸ©\n    have := U.prop.isLocalization_basicOpen f\n    have hEq := IsLocalization.algEquiv (.powers f) (Localization.Away f) Î“(X, X.basicOpen f)\n    exact isNoetherianRing_of_ringEquiv Î“(X, X.basicOpen f) hEq.symm.toRingEquiv\n  | hU => exact hS' _\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nÎ¹ : Sort u_1\nS : Î¹ â†’ â†‘X.affineOpens\nhS : Eq (iSup fun i => â†‘(S i)) Top.top\nâŠ¢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (âˆ€ (i : Î¹), IsNoetherianRing â†‘(X.presheaf.obj { unop := â†‘(S i) }))","decl":"/-- A scheme is locally Noetherian if and only if it is covered by affine opens whose sections\nare noetherian rings.\n\nSee [Har77], Proposition II.3.2. -/\ntheorem isLocallyNoetherian_iff_of_iSup_eq_top {Î¹} {S : Î¹ â†’ X.affineOpens}\n    (hS : (â¨† i, S i : X.Opens) = âŠ¤) :\n    IsLocallyNoetherian X â†” âˆ€ i, IsNoetherianRing Î“(X, S i) :=\n  âŸ¨fun _ i => IsLocallyNoetherian.component_noetherian (S i),\n   isLocallyNoetherian_of_affine_cover hSâŸ©\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_of_affine_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\ninstâœ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nâŠ¢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (âˆ€ (i : ğ’°.J), IsNoetherianRing â†‘((ğ’°.obj i).presheaf.obj { unop := Top.top }))","decl":"open CategoryTheory in\n/-- A version of `isLocallyNoetherian_iff_of_iSup_eq_top` using `Scheme.OpenCover`. -/\ntheorem isLocallyNoetherian_iff_of_affine_openCover (ğ’° : Scheme.OpenCover.{v, u} X)\n    [âˆ€ i, IsAffine (ğ’°.obj i)] :\n    IsLocallyNoetherian X â†” âˆ€ (i : ğ’°.J), IsNoetherianRing Î“(ğ’°.obj i, âŠ¤) := by\n  constructor\n  Â· intro h i\n    let U := Scheme.Hom.opensRange (ğ’°.map i)\n    have := h.component_noetherian âŸ¨U, isAffineOpen_opensRange _âŸ©\n    apply isNoetherianRing_of_ringEquiv (R := Î“(X, U))\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact (IsOpenImmersion.Î“IsoTop (ğ’°.map i)).symm\n  Â· intro hCNoeth\n    let fS i : X.affineOpens := âŸ¨Scheme.Hom.opensRange (ğ’°.map i), isAffineOpen_opensRange _âŸ©\n    apply isLocallyNoetherian_of_affine_cover (S := fS)\n    Â· rw [â† Scheme.OpenCover.iSup_opensRange ğ’°]\n    intro i\n    apply isNoetherianRing_of_ringEquiv (R := Î“(ğ’°.obj i, âŠ¤))\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact IsOpenImmersion.Î“IsoTop (ğ’°.map i)\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœÂ¹ : AlgebraicGeometry.IsOpenImmersion f\ninstâœ : AlgebraicGeometry.IsLocallyNoetherian Y\nâŠ¢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"lemma isLocallyNoetherian_of_isOpenImmersion {Y : Scheme} (f : X âŸ¶ Y) [IsOpenImmersion f]\n    [IsLocallyNoetherian Y] : IsLocallyNoetherian X := by\n  refine âŸ¨fun U => ?_âŸ©\n  let V : Y.affineOpens := âŸ¨f ''áµ U, IsAffineOpen.image_of_isOpenImmersion U.prop _âŸ©\n  suffices Î“(X, U) â‰… Î“(Y, V) by\n    convert isNoetherianRing_of_ringEquiv (R := Î“(Y, V)) _\n    Â· apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n      exact this.symm\n    Â· exact IsLocallyNoetherian.component_noetherian V\n  rw [â† Scheme.Hom.preimage_image_eq f U]\n  trans\n  Â· apply IsOpenImmersion.Î“Iso\n  Â· suffices Scheme.Hom.opensRange f âŠ“ V = V by\n      rw [this]\n    rw [â† Opens.coe_inj]\n    rw [Opens.coe_inf, Scheme.Hom.coe_opensRange, IsOpenMap.coe_functor_obj,\n      Set.inter_eq_right, Set.image_subset_iff, Set.preimage_range]\n    exact Set.subset_univ _\n\n"}
{"name":"AlgebraicGeometry.isLocallyNoetherian_iff_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Iff (AlgebraicGeometry.IsLocallyNoetherian X) (âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsLocallyNoetherian (ğ’°.obj i))","decl":"/-- If `ğ’°` is an open cover of a scheme `X`, then `X` is locally noetherian if and only if\n`ğ’°.obj i` are all locally noetherian. -/\ntheorem isLocallyNoetherian_iff_openCover (ğ’° : Scheme.OpenCover X) :\n    IsLocallyNoetherian X â†” âˆ€ (i : ğ’°.J), IsLocallyNoetherian (ğ’°.obj i) := by\n  constructor\n  Â· intro h i\n    exact isLocallyNoetherian_of_isOpenImmersion (ğ’°.map i)\n  Â· rw [isLocallyNoetherian_iff_of_affine_openCover (ğ’° := ğ’°.affineRefinement.openCover)]\n    intro h i\n    exact @isNoetherianRing_of_ringEquiv _ _ _ _\n      (IsOpenImmersion.Î“IsoTop (Scheme.Cover.map _ i.2)).symm.commRingCatIsoToRingEquiv\n      (IsLocallyNoetherian.component_noetherian âŸ¨_, isAffineOpen_opensRange _âŸ©)\n\n"}
{"name":"AlgebraicGeometry.instNoetherianSpaceÎ±TopologicalSpaceCarrierCommRingCatSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninstâœ : IsNoetherianRing â†‘R\nâŠ¢ TopologicalSpace.NoetherianSpace â†‘â†‘(AlgebraicGeometry.Spec R).toPresheafedSpace","decl":"/-- If `R` is a noetherian ring, `Spec R` is a noetherian topological space. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    NoetherianSpace (Spec R) := by\n  convert PrimeSpectrum.instNoetherianSpace (R := R)\n\n"}
{"name":"AlgebraicGeometry.noetherianSpace_of_isAffine","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsAffine X\ninstâœ : IsNoetherianRing â†‘(X.presheaf.obj { unop := Top.top })\nâŠ¢ TopologicalSpace.NoetherianSpace â†‘â†‘X.toPresheafedSpace","decl":"lemma noetherianSpace_of_isAffine [IsAffine X] [IsNoetherianRing Î“(X, âŠ¤)] :\n    NoetherianSpace X :=\n  (noetherianSpace_iff_of_homeomorph X.isoSpec.inv.homeomorph).mp inferInstance\n\n"}
{"name":"AlgebraicGeometry.noetherianSpace_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ninstâœ : IsNoetherianRing â†‘(X.presheaf.obj { unop := U })\nâŠ¢ TopologicalSpace.NoetherianSpace â†‘â†‘(â†‘U).toPresheafedSpace","decl":"lemma noetherianSpace_of_isAffineOpen (U : X.Opens) (hU : IsAffineOpen U)\n    [IsNoetherianRing Î“(X, U)] :\n    NoetherianSpace U := by\n  have : IsNoetherianRing Î“(U, âŠ¤) := isNoetherianRing_of_ringEquiv _\n    (Scheme.restrictFunctorÎ“.app (op U)).symm.commRingCatIsoToRingEquiv\n  exact @noetherianSpace_of_isAffine _ hU _\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactOfIsLocallyNoetherianOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Z : AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocallyNoetherian X\nf : Quiver.Hom Z X\ninstâœ : AlgebraicGeometry.IsOpenImmersion f\nâŠ¢ AlgebraicGeometry.QuasiCompact f","decl":"/-- Any open immersion `Z âŸ¶ X` with `X` locally Noetherian is quasi-compact. -/\n@[stacks 01OX]\ninstance (priority := 100) {Z : Scheme} [IsLocallyNoetherian X]\n    {f : Z âŸ¶ X} [IsOpenImmersion f] : QuasiCompact f := by\n  apply (quasiCompact_iff_forall_affine f).mpr\n  intro U hU\n  rw [Opens.map_coe, â† Set.preimage_inter_range]\n  apply f.isOpenEmbedding.isInducing.isCompact_preimage'\n  Â· apply (noetherianSpace_set_iff _).mp\n    Â· convert noetherianSpace_of_isAffineOpen U hU\n      apply IsLocallyNoetherian.component_noetherian âŸ¨U, hUâŸ©\n    Â· exact Set.inter_subset_left\n  Â· exact Set.inter_subset_right\n\n"}
{"name":"AlgebraicGeometry.IsLocallyNoetherian.quasiSeparatedSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocallyNoetherian X\nâŠ¢ QuasiSeparatedSpace â†‘â†‘X.toPresheafedSpace","decl":"/-- A locally Noetherian scheme is quasi-separated. -/\n@[stacks 01OY]\ninstance (priority := 100) IsLocallyNoetherian.quasiSeparatedSpace [IsLocallyNoetherian X] :\n    QuasiSeparatedSpace X := by\n  apply (quasiSeparatedSpace_iff_affine X).mpr\n  intro U V\n  have hInd := U.2.fromSpec.isOpenEmbedding.isInducing\n  apply (hInd.isCompact_preimage_iff ?_).mp\n  Â· rw [â† Set.preimage_inter_range, IsAffineOpen.range_fromSpec, Set.inter_comm]\n    apply hInd.isCompact_preimage'\n    Â· apply (noetherianSpace_set_iff _).mp\n      Â· convert noetherianSpace_of_isAffineOpen U.1 U.2\n        apply IsLocallyNoetherian.component_noetherian\n      Â· exact Set.inter_subset_left\n    Â· rw [IsAffineOpen.range_fromSpec]\n      exact Set.inter_subset_left\n  Â· rw [IsAffineOpen.range_fromSpec]\n    exact Set.inter_subset_left\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ Iff (AlgebraicGeometry.IsNoetherian X) (And (AlgebraicGeometry.IsLocallyNoetherian X) (CompactSpace â†‘â†‘X.toPresheafedSpace))","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.toCompactSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsNoetherian X\nâŠ¢ CompactSpace â†‘â†‘X.toPresheafedSpace","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.toIsLocallyNoetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsNoetherian X\nâŠ¢ AlgebraicGeometry.IsLocallyNoetherian X","decl":"/-- A scheme `X` is Noetherian if it is locally Noetherian and compact. -/\n@[mk_iff]\nclass IsNoetherian (X : Scheme) extends IsLocallyNoetherian X, CompactSpace X : Prop\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff_of_finite_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nÎ¹ : Sort u_1\ninstâœ : Finite Î¹\nS : Î¹ â†’ â†‘X.affineOpens\nhS : Eq (iSup fun i => â†‘(S i)) Top.top\nâŠ¢ Iff (AlgebraicGeometry.IsNoetherian X) (âˆ€ (i : Î¹), IsNoetherianRing â†‘(X.presheaf.obj { unop := â†‘(S i) }))","decl":"/-- A scheme is Noetherian if and only if it is covered by finitely many affine opens whose\nsections are noetherian rings. -/\ntheorem isNoetherian_iff_of_finite_iSup_eq_top {Î¹} [Finite Î¹] {S : Î¹ â†’ X.affineOpens}\n    (hS : (â¨† i, S i : X.Opens) = âŠ¤) :\n    IsNoetherian X â†” âˆ€ i, IsNoetherianRing Î“(X, S i) := by\n  constructor\n  Â· intro h i\n    apply (isLocallyNoetherian_iff_of_iSup_eq_top hS).mp\n    exact h.toIsLocallyNoetherian\n  Â· intro h\n    convert IsNoetherian.mk\n    Â· exact isLocallyNoetherian_of_affine_cover hS h\n    Â· constructor\n      rw [â† Opens.coe_top, â† hS, Opens.iSup_mk]\n      apply isCompact_iUnion\n      intro i\n      apply isCompact_iff_isCompact_univ.mpr\n      convert CompactSpace.isCompact_univ\n      have : NoetherianSpace (S i) := by\n        apply noetherianSpace_of_isAffineOpen (S i).1 (S i).2\n      apply NoetherianSpace.compactSpace (S i)\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_iff_of_finite_affine_openCover","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\ninstâœÂ¹ : Finite ğ’°.J\ninstâœ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nâŠ¢ Iff (AlgebraicGeometry.IsNoetherian X) (âˆ€ (i : ğ’°.J), IsNoetherianRing â†‘((ğ’°.obj i).presheaf.obj { unop := Top.top }))","decl":"/-- A version of `isNoetherian_iff_of_finite_iSup_eq_top` using `Scheme.OpenCover`. -/\ntheorem isNoetherian_iff_of_finite_affine_openCover {ğ’° : Scheme.OpenCover.{v, u} X}\n    [Finite ğ’°.J] [âˆ€ i, IsAffine (ğ’°.obj i)] :\n    IsNoetherian X â†” âˆ€ (i : ğ’°.J), IsNoetherianRing Î“(ğ’°.obj i, âŠ¤) := by\n  constructor\n  Â· intro h i\n    apply (isLocallyNoetherian_iff_of_affine_openCover _).mp\n    exact h.toIsLocallyNoetherian\n  Â· intro hNoeth\n    convert IsNoetherian.mk\n    Â· exact (isLocallyNoetherian_iff_of_affine_openCover _).mpr hNoeth\n    Â· exact Scheme.OpenCover.compactSpace ğ’°\n\n"}
{"name":"AlgebraicGeometry.IsNoetherian.noetherianSpace","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsNoetherian X\nâŠ¢ TopologicalSpace.NoetherianSpace â†‘â†‘X.toPresheafedSpace","decl":"open CategoryTheory in\n/-- A Noetherian scheme has a Noetherian underlying topological space. -/\n@[stacks 01OZ]\ninstance (priority := 100) IsNoetherian.noetherianSpace [IsNoetherian X] :\n    NoetherianSpace X := by\n  apply TopologicalSpace.noetherian_univ_iff.mp\n  let ğ’° := X.affineCover.finiteSubcover\n  rw [â† ğ’°.iUnion_range]\n  suffices âˆ€ i : ğ’°.J, NoetherianSpace (Set.range <| (ğ’°.map i).base) by\n    apply NoetherianSpace.iUnion\n  intro i\n  have : IsAffine (ğ’°.obj i) := by\n    rw [X.affineCover.finiteSubcover_obj]\n    apply Scheme.isAffine_affineCover\n  let U : X.affineOpens := âŸ¨Scheme.Hom.opensRange (ğ’°.map i), isAffineOpen_opensRange _âŸ©\n  convert noetherianSpace_of_isAffineOpen U.1 U.2\n  apply IsLocallyNoetherian.component_noetherian\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_of_noetherianSpace_source","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninstâœ : TopologicalSpace.NoetherianSpace â†‘â†‘X.toPresheafedSpace\nf : Quiver.Hom X Y\nâŠ¢ AlgebraicGeometry.QuasiCompact f","decl":"/-- Any morphism of schemes `f : X âŸ¶ Y` with `X` Noetherian is quasi-compact. -/\n@[stacks 01P0]\ninstance (priority := 100) quasiCompact_of_noetherianSpace_source {X Y : Scheme}\n    [NoetherianSpace X] (f : X âŸ¶ Y) : QuasiCompact f :=\n  âŸ¨fun _ _ _ => NoetherianSpace.isCompact _âŸ©\n\n"}
{"name":"AlgebraicGeometry.instIsLocallyNoetherianSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninstâœ : IsNoetherianRing â†‘R\nâŠ¢ AlgebraicGeometry.IsLocallyNoetherian (AlgebraicGeometry.Spec R)","decl":"/-- If `R` is a Noetherian ring, `Spec R` is a locally Noetherian scheme. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    IsLocallyNoetherian (Spec R) := by\n  apply isLocallyNoetherian_of_affine_cover\n    (Î¹ := Fin 1) (S := fun _ => âŸ¨âŠ¤, isAffineOpen_top (Spec R)âŸ©)\n  Â· exact iSup_const\n  Â· intro\n    apply isNoetherianRing_of_ringEquiv R\n    apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n    exact (Scheme.Î“SpecIso R).symm\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianRingCarrierOfIsLocallyNoetherianSpec","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninstâœ : AlgebraicGeometry.IsLocallyNoetherian (AlgebraicGeometry.Spec R)\nâŠ¢ IsNoetherianRing â†‘R","decl":"instance (priority := 100) {R : CommRingCat}\n    [IsLocallyNoetherian (Spec R)] : IsNoetherianRing R := by\n  have := IsLocallyNoetherian.component_noetherian âŸ¨âŠ¤, AlgebraicGeometry.isAffineOpen_top (Spec R)âŸ©\n  apply isNoetherianRing_of_ringEquiv Î“(Spec R, âŠ¤)\n  apply CategoryTheory.Iso.commRingCatIsoToRingEquiv\n  exact Scheme.Î“SpecIso R\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianSpecOfIsNoetherianRingCarrier","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\ninstâœ : IsNoetherianRing â†‘R\nâŠ¢ AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec R)","decl":"/-- If `R` is a Noetherian ring, `Spec R` is a Noetherian scheme. -/\ninstance {R : CommRingCat} [IsNoetherianRing R] :\n    IsNoetherian (Spec R) where\n\n"}
{"name":"AlgebraicGeometry.instIsNoetherianSpecOfOfIsNoetherianRing","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\ninstâœ : IsNoetherianRing R\nâŠ¢ AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec (CommRingCat.of R))","decl":"instance {R} [CommRing R] [IsNoetherianRing R] :\n    IsNoetherian (Spec (.of R)) := by\n  suffices IsNoetherianRing (CommRingCat.of R) by infer_instance\n  simp only [CommRingCat.coe_of]\n  assumption\n\n"}
{"name":"AlgebraicGeometry.isNoetherian_Spec","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"R : CommRingCat\nâŠ¢ Iff (AlgebraicGeometry.IsNoetherian (AlgebraicGeometry.Spec R)) (IsNoetherianRing â†‘R)","decl":"/-- `R` is a Noetherian ring if and only if `Spec R` is a Noetherian scheme. -/\ntheorem isNoetherian_Spec {R : CommRingCat} :\n    IsNoetherian (Spec R) â†” IsNoetherianRing R :=\n  âŸ¨fun _ => inferInstance,\n   fun _ => inferInstanceâŸ©\n\n"}
{"name":"AlgebraicGeometry.finite_irreducibleComponents_of_isNoetherian","module":"Mathlib.AlgebraicGeometry.Noetherian","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsNoetherian X\nâŠ¢ (irreducibleComponents â†‘â†‘X.toPresheafedSpace).Finite","decl":"/-- A Noetherian scheme has a finite number of irreducible components. -/\n@[stacks 0BA8]\ntheorem finite_irreducibleComponents_of_isNoetherian [IsNoetherian X] :\n    (irreducibleComponents X).Finite := NoetherianSpace.finite_irreducibleComponents\n\n"}
