{"name":"CategoryTheory.mono_iff_fst_eq_snd","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PullbackCone f f\nhc : CategoryTheory.Limits.IsLimit c\nâŠ¢ Iff (CategoryTheory.Mono f) (Eq c.fst c.snd)","decl":"lemma mono_iff_fst_eq_snd (hc : IsLimit c) : Mono f â†” c.fst = c.snd := by\n  constructor\n  Â· intro hf\n    simpa only [â† cancel_mono f] using c.condition\n  Â· intro hf\n    constructor\n    intro Z g g' h\n    obtain âŸ¨Ï†, rfl, rflâŸ© := PullbackCone.IsLimit.lift' hc g g' h\n    rw [hf]\n\n"}
{"name":"CategoryTheory.mono_iff_isIso_fst","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PullbackCone f f\nhc : CategoryTheory.Limits.IsLimit c\nâŠ¢ Iff (CategoryTheory.Mono f) (CategoryTheory.IsIso c.fst)","decl":"lemma mono_iff_isIso_fst (hc : IsLimit c) : Mono f â†” IsIso c.fst := by\n  rw [mono_iff_fst_eq_snd hc]\n  constructor\n  Â· intro h\n    obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := PullbackCone.IsLimit.lift' hc (ğŸ™ X) (ğŸ™ X) (by simp)\n    refine âŸ¨Ï†, PullbackCone.IsLimit.hom_ext hc ?_ ?_, hÏ†â‚âŸ©\n    Â· dsimp\n      simp only [assoc, hÏ†â‚, id_comp, comp_id]\n    Â· dsimp\n      simp only [assoc, hÏ†â‚‚, id_comp, comp_id, h]\n  Â· intro\n    obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := PullbackCone.IsLimit.lift' hc (ğŸ™ X) (ğŸ™ X) (by simp)\n    have : IsSplitEpi Ï† := IsSplitEpi.mk âŸ¨SplitEpi.mk c.fst (by\n      rw [â† cancel_mono c.fst, assoc, id_comp, hÏ†â‚, comp_id])âŸ©\n    rw [â† cancel_epi Ï†, hÏ†â‚, hÏ†â‚‚]\n\n"}
{"name":"CategoryTheory.mono_iff_isIso_snd","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PullbackCone f f\nhc : CategoryTheory.Limits.IsLimit c\nâŠ¢ Iff (CategoryTheory.Mono f) (CategoryTheory.IsIso c.snd)","decl":"lemma mono_iff_isIso_snd (hc : IsLimit c) : Mono f â†” IsIso c.snd :=\n  mono_iff_isIso_fst (PullbackCone.flipIsLimit hc)\n\n"}
{"name":"CategoryTheory.mono_iff_isPullback","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.Mono f) (CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X) f f)","decl":"lemma mono_iff_isPullback : Mono f â†” IsPullback (ğŸ™ X) (ğŸ™ X) f f := by\n  constructor\n  Â· intro\n    exact IsPullback.of_isLimit (PullbackCone.isLimitMkIdId f)\n  Â· intro hf\n    exact (mono_iff_fst_eq_snd hf.isLimit).2 rfl\n\n"}
{"name":"CategoryTheory.epi_iff_inl_eq_inr","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PushoutCocone f f\nhc : CategoryTheory.Limits.IsColimit c\nâŠ¢ Iff (CategoryTheory.Epi f) (Eq c.inl c.inr)","decl":"lemma epi_iff_inl_eq_inr (hc : IsColimit c) : Epi f â†” c.inl = c.inr := by\n  constructor\n  Â· intro hf\n    simpa only [â† cancel_epi f] using c.condition\n  Â· intro hf\n    constructor\n    intro Z g g' h\n    obtain âŸ¨Ï†, rfl, rflâŸ© := PushoutCocone.IsColimit.desc' hc g g' h\n    rw [hf]\n\n"}
{"name":"CategoryTheory.epi_iff_isIso_inl","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PushoutCocone f f\nhc : CategoryTheory.Limits.IsColimit c\nâŠ¢ Iff (CategoryTheory.Epi f) (CategoryTheory.IsIso c.inl)","decl":"lemma epi_iff_isIso_inl (hc : IsColimit c) : Epi f â†” IsIso c.inl := by\n  rw [epi_iff_inl_eq_inr hc]\n  constructor\n  Â· intro h\n    obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := PushoutCocone.IsColimit.desc' hc (ğŸ™ Y) (ğŸ™ Y) (by simp)\n    refine âŸ¨Ï†, hÏ†â‚, PushoutCocone.IsColimit.hom_ext hc ?_ ?_âŸ©\n    Â· dsimp\n      simp only [comp_id, reassoc_of% hÏ†â‚]\n    Â· dsimp\n      simp only [comp_id, h, reassoc_of% hÏ†â‚‚]\n  Â· intro\n    obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := PushoutCocone.IsColimit.desc' hc (ğŸ™ Y) (ğŸ™ Y) (by simp)\n    have : IsSplitMono Ï† := IsSplitMono.mk âŸ¨SplitMono.mk c.inl (by\n      rw [â† cancel_epi c.inl, reassoc_of% hÏ†â‚, comp_id])âŸ©\n    rw [â† cancel_mono Ï†, hÏ†â‚, hÏ†â‚‚]\n\n"}
{"name":"CategoryTheory.epi_iff_isIso_inr","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.PushoutCocone f f\nhc : CategoryTheory.Limits.IsColimit c\nâŠ¢ Iff (CategoryTheory.Epi f) (CategoryTheory.IsIso c.inr)","decl":"lemma epi_iff_isIso_inr (hc : IsColimit c) : Epi f â†” IsIso c.inr :=\n  epi_iff_isIso_inl (PushoutCocone.flipIsColimit hc)\n\n"}
{"name":"CategoryTheory.epi_iff_isPushout","module":"Mathlib.CategoryTheory.Limits.EpiMono","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.Epi f) (CategoryTheory.IsPushout f f (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y))","decl":"lemma epi_iff_isPushout : Epi f â†” IsPushout f f (ğŸ™ Y) (ğŸ™ Y) := by\n  constructor\n  Â· intro\n    exact IsPushout.of_isColimit (PushoutCocone.isColimitMkIdId f)\n  Â· intro hf\n    exact (epi_iff_inl_eq_inr hf.isColimit).2 rfl\n\n"}
