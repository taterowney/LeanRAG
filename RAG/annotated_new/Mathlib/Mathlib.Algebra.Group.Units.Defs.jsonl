{"name":"Units.val_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nself : Units α\n⊢ Eq (HMul.hMul self.val self.inv) 1","decl":"/-- Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. -/\nstructure Units (α : Type u) [Monoid α] where\n  /-- The underlying value in the base `Monoid`. -/\n  val : α\n  /-- The inverse value of `val` in the base `Monoid`. -/\n  inv : α\n  /-- `inv` is the right inverse of `val` in the base `Monoid`. -/\n  val_inv : val * inv = 1\n  /-- `inv` is the left inverse of `val` in the base `Monoid`. -/\n  inv_val : inv * val = 1\n\n"}
{"name":"Units.mk.injEq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nval✝ inv✝ : α\nval_inv✝ : Eq (HMul.hMul val✝ inv✝) 1\ninv_val✝ : Eq (HMul.hMul inv✝ val✝) 1\nval inv : α\nval_inv : Eq (HMul.hMul val inv) 1\ninv_val : Eq (HMul.hMul inv val) 1\n⊢ Eq (Eq { val := val✝, inv := inv✝, val_inv := val_inv✝, inv_val := inv_val✝ } { val := val, inv := inv, val_inv := val_inv, inv_val := inv_val }) (And (Eq val✝ val) (Eq inv✝ inv))","decl":"/-- Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. -/\nstructure Units (α : Type u) [Monoid α] where\n  /-- The underlying value in the base `Monoid`. -/\n  val : α\n  /-- The inverse value of `val` in the base `Monoid`. -/\n  inv : α\n  /-- `inv` is the right inverse of `val` in the base `Monoid`. -/\n  val_inv : val * inv = 1\n  /-- `inv` is the left inverse of `val` in the base `Monoid`. -/\n  inv_val : inv * val = 1\n\n"}
{"name":"Units.mk.inj","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nval✝ inv✝ : α\nval_inv✝ : Eq (HMul.hMul val✝ inv✝) 1\ninv_val✝ : Eq (HMul.hMul inv✝ val✝) 1\nval inv : α\nval_inv : Eq (HMul.hMul val inv) 1\ninv_val : Eq (HMul.hMul inv val) 1\nx✝ : Eq { val := val✝, inv := inv✝, val_inv := val_inv✝, inv_val := inv_val✝ } { val := val, inv := inv, val_inv := val_inv, inv_val := inv_val }\n⊢ And (Eq val✝ val) (Eq inv✝ inv)","decl":"/-- Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. -/\nstructure Units (α : Type u) [Monoid α] where\n  /-- The underlying value in the base `Monoid`. -/\n  val : α\n  /-- The inverse value of `val` in the base `Monoid`. -/\n  inv : α\n  /-- `inv` is the right inverse of `val` in the base `Monoid`. -/\n  val_inv : val * inv = 1\n  /-- `inv` is the left inverse of `val` in the base `Monoid`. -/\n  inv_val : inv * val = 1\n\n"}
{"name":"Units.inv_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nself : Units α\n⊢ Eq (HMul.hMul self.inv self.val) 1","decl":"/-- Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. -/\nstructure Units (α : Type u) [Monoid α] where\n  /-- The underlying value in the base `Monoid`. -/\n  val : α\n  /-- The inverse value of `val` in the base `Monoid`. -/\n  inv : α\n  /-- `inv` is the right inverse of `val` in the base `Monoid`. -/\n  val_inv : val * inv = 1\n  /-- `inv` is the left inverse of `val` in the base `Monoid`. -/\n  inv_val : inv * val = 1\n\n"}
{"name":"Units.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : SizeOf α\nval inv : α\nval_inv : Eq (HMul.hMul val inv) 1\ninv_val : Eq (HMul.hMul inv val) 1\n⊢ Eq (SizeOf.sizeOf { val := val, inv := inv, val_inv := val_inv, inv_val := inv_val }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf val_inv)) (SizeOf.sizeOf inv_val))","decl":"/-- Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. -/\nstructure Units (α : Type u) [Monoid α] where\n  /-- The underlying value in the base `Monoid`. -/\n  val : α\n  /-- The inverse value of `val` in the base `Monoid`. -/\n  inv : α\n  /-- `inv` is the right inverse of `val` in the base `Monoid`. -/\n  val_inv : val * inv = 1\n  /-- `inv` is the left inverse of `val` in the base `Monoid`. -/\n  inv_val : inv * val = 1\n\n"}
{"name":"AddUnits.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝¹ : AddMonoid α\ninst✝ : SizeOf α\nval neg : α\nval_neg : Eq (HAdd.hAdd val neg) 0\nneg_val : Eq (HAdd.hAdd neg val) 0\n⊢ Eq (SizeOf.sizeOf { val := val, neg := neg, val_neg := val_neg, neg_val := neg_val }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf val)) (SizeOf.sizeOf neg)) (SizeOf.sizeOf val_neg)) (SizeOf.sizeOf neg_val))","decl":"/-- Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. -/\nstructure AddUnits (α : Type u) [AddMonoid α] where\n  /-- The underlying value in the base `AddMonoid`. -/\n  val : α\n  /-- The additive inverse value of `val` in the base `AddMonoid`. -/\n  neg : α\n  /-- `neg` is the right additive inverse of `val` in the base `AddMonoid`. -/\n  val_neg : val + neg = 0\n  /-- `neg` is the left additive inverse of `val` in the base `AddMonoid`. -/\n  neg_val : neg + val = 0\n\n"}
{"name":"AddUnits.val_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nself : AddUnits α\n⊢ Eq (HAdd.hAdd self.val self.neg) 0","decl":"/-- Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. -/\nstructure AddUnits (α : Type u) [AddMonoid α] where\n  /-- The underlying value in the base `AddMonoid`. -/\n  val : α\n  /-- The additive inverse value of `val` in the base `AddMonoid`. -/\n  neg : α\n  /-- `neg` is the right additive inverse of `val` in the base `AddMonoid`. -/\n  val_neg : val + neg = 0\n  /-- `neg` is the left additive inverse of `val` in the base `AddMonoid`. -/\n  neg_val : neg + val = 0\n\n"}
{"name":"AddUnits.mk.injEq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nval✝ neg✝ : α\nval_neg✝ : Eq (HAdd.hAdd val✝ neg✝) 0\nneg_val✝ : Eq (HAdd.hAdd neg✝ val✝) 0\nval neg : α\nval_neg : Eq (HAdd.hAdd val neg) 0\nneg_val : Eq (HAdd.hAdd neg val) 0\n⊢ Eq (Eq { val := val✝, neg := neg✝, val_neg := val_neg✝, neg_val := neg_val✝ } { val := val, neg := neg, val_neg := val_neg, neg_val := neg_val }) (And (Eq val✝ val) (Eq neg✝ neg))","decl":"/-- Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. -/\nstructure AddUnits (α : Type u) [AddMonoid α] where\n  /-- The underlying value in the base `AddMonoid`. -/\n  val : α\n  /-- The additive inverse value of `val` in the base `AddMonoid`. -/\n  neg : α\n  /-- `neg` is the right additive inverse of `val` in the base `AddMonoid`. -/\n  val_neg : val + neg = 0\n  /-- `neg` is the left additive inverse of `val` in the base `AddMonoid`. -/\n  neg_val : neg + val = 0\n\n"}
{"name":"AddUnits.neg_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nself : AddUnits α\n⊢ Eq (HAdd.hAdd self.neg self.val) 0","decl":"/-- Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. -/\nstructure AddUnits (α : Type u) [AddMonoid α] where\n  /-- The underlying value in the base `AddMonoid`. -/\n  val : α\n  /-- The additive inverse value of `val` in the base `AddMonoid`. -/\n  neg : α\n  /-- `neg` is the right additive inverse of `val` in the base `AddMonoid`. -/\n  val_neg : val + neg = 0\n  /-- `neg` is the left additive inverse of `val` in the base `AddMonoid`. -/\n  neg_val : neg + val = 0\n\n"}
{"name":"AddUnits.mk.inj","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nval✝ neg✝ : α\nval_neg✝ : Eq (HAdd.hAdd val✝ neg✝) 0\nneg_val✝ : Eq (HAdd.hAdd neg✝ val✝) 0\nval neg : α\nval_neg : Eq (HAdd.hAdd val neg) 0\nneg_val : Eq (HAdd.hAdd neg val) 0\nx✝ : Eq { val := val✝, neg := neg✝, val_neg := val_neg✝, neg_val := neg_val✝ } { val := val, neg := neg, val_neg := val_neg, neg_val := neg_val }\n⊢ And (Eq val✝ val) (Eq neg✝ neg)","decl":"/-- Units of an `AddMonoid`, bundled version.\n\nAn element of an `AddMonoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `isAddUnit`. -/\nstructure AddUnits (α : Type u) [AddMonoid α] where\n  /-- The underlying value in the base `AddMonoid`. -/\n  val : α\n  /-- The additive inverse value of `val` in the base `AddMonoid`. -/\n  neg : α\n  /-- `neg` is the right additive inverse of `val` in the base `AddMonoid`. -/\n  val_neg : val + neg = 0\n  /-- `neg` is the left additive inverse of `val` in the base `AddMonoid`. -/\n  neg_val : neg + val = 0\n\n"}
{"name":"Units.val_mk","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\nh₁ : Eq (HMul.hMul a b) 1\nh₂ : Eq (HMul.hMul b a) 1\n⊢ Eq (↑{ val := a, inv := b, val_inv := h₁, inv_val := h₂ }) a","decl":"@[to_additive]\ntheorem val_mk (a : α) (b h₁ h₂) : ↑(Units.mk a b h₁ h₂) = a :=\n  rfl\n\n"}
{"name":"AddUnits.val_mk","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na b : α\nh₁ : Eq (HAdd.hAdd a b) 0\nh₂ : Eq (HAdd.hAdd b a) 0\n⊢ Eq (↑{ val := a, neg := b, val_neg := h₁, neg_val := h₂ }) a","decl":"@[to_additive]\ntheorem val_mk (a : α) (b h₁ h₂) : ↑(Units.mk a b h₁ h₂) = a :=\n  rfl\n\n"}
{"name":"Units.ext_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na₁ a₂ : Units α\n⊢ Iff (Eq a₁ a₂) (Eq ↑a₁ ↑a₂)","decl":"@[to_additive (attr := ext)]\ntheorem ext : Function.Injective (val : αˣ → α)\n  | ⟨v, i₁, vi₁, iv₁⟩, ⟨v', i₂, vi₂, iv₂⟩, e => by\n    simp only at e; subst v'; congr\n    simpa only [iv₂, vi₁, one_mul, mul_one] using mul_assoc i₂ v i₁\n\n"}
{"name":"AddUnits.ext_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na₁ a₂ : AddUnits α\n⊢ Iff (Eq a₁ a₂) (Eq ↑a₁ ↑a₂)","decl":"@[to_additive (attr := ext)]\ntheorem ext : Function.Injective (val : αˣ → α)\n  | ⟨v, i₁, vi₁, iv₁⟩, ⟨v', i₂, vi₂, iv₂⟩, e => by\n    simp only at e; subst v'; congr\n    simpa only [iv₂, vi₁, one_mul, mul_one] using mul_assoc i₂ v i₁\n\n"}
{"name":"Units.ext","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\n⊢ Function.Injective Units.val","decl":"@[to_additive (attr := ext)]\ntheorem ext : Function.Injective (val : αˣ → α)\n  | ⟨v, i₁, vi₁, iv₁⟩, ⟨v', i₂, vi₂, iv₂⟩, e => by\n    simp only at e; subst v'; congr\n    simpa only [iv₂, vi₁, one_mul, mul_one] using mul_assoc i₂ v i₁\n\n"}
{"name":"AddUnits.ext","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\n⊢ Function.Injective AddUnits.val","decl":"@[to_additive (attr := ext)]\ntheorem ext : Function.Injective (val : αˣ → α)\n  | ⟨v, i₁, vi₁, iv₁⟩, ⟨v', i₂, vi₂, iv₂⟩, e => by\n    simp only at e; subst v'; congr\n    simpa only [iv₂, vi₁, one_mul, mul_one] using mul_assoc i₂ v i₁\n\n"}
{"name":"AddUnits.eq_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na b : AddUnits α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[to_additive (attr := norm_cast)]\ntheorem eq_iff {a b : αˣ} : (a : α) = b ↔ a = b :=\n  ext.eq_iff\n\n"}
{"name":"Units.eq_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : Units α\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[to_additive (attr := norm_cast)]\ntheorem eq_iff {a b : αˣ} : (a : α) = b ↔ a = b :=\n  ext.eq_iff\n\n"}
{"name":"AddUnits.mk_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\ny : α\nh₁ : Eq (HAdd.hAdd (↑u) y) 0\nh₂ : Eq (HAdd.hAdd y ↑u) 0\n⊢ Eq { val := ↑u, neg := y, val_neg := h₁, neg_val := h₂ } u","decl":"@[to_additive (attr := simp)]\ntheorem mk_val (u : αˣ) (y h₁ h₂) : mk (u : α) y h₁ h₂ = u :=\n  ext rfl\n\n"}
{"name":"Units.mk_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\ny : α\nh₁ : Eq (HMul.hMul (↑u) y) 1\nh₂ : Eq (HMul.hMul y ↑u) 1\n⊢ Eq { val := ↑u, inv := y, val_inv := h₁, inv_val := h₂ } u","decl":"@[to_additive (attr := simp)]\ntheorem mk_val (u : αˣ) (y h₁ h₂) : mk (u : α) y h₁ h₂ = u :=\n  ext rfl\n\n"}
{"name":"Units.val_copy","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Inv.inv u)\n⊢ Eq (↑(u.copy val hv inv hi)) val","decl":"/-- Copy a unit, adjusting definition equalities. -/\n@[to_additive (attr := simps) \"Copy an `AddUnit`, adjusting definitional equalities.\"]\ndef copy (u : αˣ) (val : α) (hv : val = u) (inv : α) (hi : inv = ↑u⁻¹) : αˣ :=\n  { val, inv, inv_val := hv.symm ▸ hi.symm ▸ u.inv_val, val_inv := hv.symm ▸ hi.symm ▸ u.val_inv }\n\n"}
{"name":"Units.val_inv_copy","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Inv.inv u)\n⊢ Eq (↑(Inv.inv (u.copy val hv inv hi))) inv","decl":"/-- Copy a unit, adjusting definition equalities. -/\n@[to_additive (attr := simps) \"Copy an `AddUnit`, adjusting definitional equalities.\"]\ndef copy (u : αˣ) (val : α) (hv : val = u) (inv : α) (hi : inv = ↑u⁻¹) : αˣ :=\n  { val, inv, inv_val := hv.symm ▸ hi.symm ▸ u.inv_val, val_inv := hv.symm ▸ hi.symm ▸ u.val_inv }\n\n"}
{"name":"AddUnits.val_copy","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Neg.neg u)\n⊢ Eq (↑(u.copy val hv inv hi)) val","decl":"/-- Copy a unit, adjusting definition equalities. -/\n@[to_additive (attr := simps) \"Copy an `AddUnit`, adjusting definitional equalities.\"]\ndef copy (u : αˣ) (val : α) (hv : val = u) (inv : α) (hi : inv = ↑u⁻¹) : αˣ :=\n  { val, inv, inv_val := hv.symm ▸ hi.symm ▸ u.inv_val, val_inv := hv.symm ▸ hi.symm ▸ u.val_inv }\n\n"}
{"name":"AddUnits.val_neg_copy","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Neg.neg u)\n⊢ Eq (↑(Neg.neg (u.copy val hv inv hi))) inv","decl":"/-- Copy a unit, adjusting definition equalities. -/\n@[to_additive (attr := simps) \"Copy an `AddUnit`, adjusting definitional equalities.\"]\ndef copy (u : αˣ) (val : α) (hv : val = u) (inv : α) (hi : inv = ↑u⁻¹) : αˣ :=\n  { val, inv, inv_val := hv.symm ▸ hi.symm ▸ u.inv_val, val_inv := hv.symm ▸ hi.symm ▸ u.val_inv }\n\n"}
{"name":"AddUnits.copy_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Neg.neg u)\n⊢ Eq (u.copy val hv inv hi) u","decl":"@[to_additive]\ntheorem copy_eq (u : αˣ) (val hv inv hi) : u.copy val hv inv hi = u :=\n  ext hv\n\n"}
{"name":"Units.copy_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\nval : α\nhv : Eq val ↑u\ninv : α\nhi : Eq inv ↑(Inv.inv u)\n⊢ Eq (u.copy val hv inv hi) u","decl":"@[to_additive]\ntheorem copy_eq (u : αˣ) (val hv inv hi) : u.copy val hv inv hi = u :=\n  ext hv\n\n"}
{"name":"AddUnits.val_add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na b : AddUnits α\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_mul : (↑(a * b) : α) = a * b :=\n  rfl\n\n"}
{"name":"Units.val_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : Units α\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_mul : (↑(a * b) : α) = a * b :=\n  rfl\n\n"}
{"name":"Units.val_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_one : ((1 : αˣ) : α) = 1 :=\n  rfl\n\n"}
{"name":"AddUnits.val_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_one : ((1 : αˣ) : α) = 1 :=\n  rfl\n\n"}
{"name":"Units.val_eq_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Iff (Eq (↑a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_eq_one {a : αˣ} : (a : α) = 1 ↔ a = 1 := by rw [← Units.val_one, eq_iff]\n\n"}
{"name":"AddUnits.val_eq_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ Iff (Eq (↑a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_eq_one {a : αˣ} : (a : α) = 1 ↔ a = 1 := by rw [← Units.val_one, eq_iff]\n\n"}
{"name":"AddUnits.neg_mk","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nx y : α\nh₁ : Eq (HAdd.hAdd x y) 0\nh₂ : Eq (HAdd.hAdd y x) 0\n⊢ Eq (Neg.neg { val := x, neg := y, val_neg := h₁, neg_val := h₂ }) { val := y, neg := x, val_neg := h₂, neg_val := h₁ }","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk (x y : α) (h₁ h₂) : (mk x y h₁ h₂)⁻¹ = mk y x h₂ h₁ :=\n  rfl\n\n-- Porting note: coercions are now eagerly elaborated, so no need for `val_eq_coe`\n\n"}
{"name":"Units.inv_mk","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nx y : α\nh₁ : Eq (HMul.hMul x y) 1\nh₂ : Eq (HMul.hMul y x) 1\n⊢ Eq (Inv.inv { val := x, inv := y, val_inv := h₁, inv_val := h₂ }) { val := y, inv := x, val_inv := h₂, inv_val := h₁ }","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk (x y : α) (h₁ h₂) : (mk x y h₁ h₂)⁻¹ = mk y x h₂ h₁ :=\n  rfl\n\n-- Porting note: coercions are now eagerly elaborated, so no need for `val_eq_coe`\n\n"}
{"name":"AddUnits.neg_eq_val_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ Eq a.neg ↑(Neg.neg a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_val_inv : a.inv = ((a⁻¹ : αˣ) : α) :=\n  rfl\n\n"}
{"name":"Units.inv_eq_val_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Eq a.inv ↑(Inv.inv a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_val_inv : a.inv = ((a⁻¹ : αˣ) : α) :=\n  rfl\n\n"}
{"name":"Units.inv_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Eq (HMul.hMul ↑(Inv.inv a) ↑a) 1","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul : (↑a⁻¹ * a : α) = 1 :=\n  inv_val _\n\n"}
{"name":"AddUnits.neg_add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ Eq (HAdd.hAdd ↑(Neg.neg a) ↑a) 0","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul : (↑a⁻¹ * a : α) = 1 :=\n  inv_val _\n\n"}
{"name":"AddUnits.add_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ Eq (HAdd.hAdd ↑a ↑(Neg.neg a)) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv : (a * ↑a⁻¹ : α) = 1 :=\n  val_inv _\n\n"}
{"name":"Units.mul_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Eq (HMul.hMul ↑a ↑(Inv.inv a)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv : (a * ↑a⁻¹ : α) = 1 :=\n  val_inv _\n\n"}
{"name":"AddUnits.addCommute_coe_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ AddCommute ↑a ↑(Neg.neg a)","decl":"@[to_additive] lemma commute_coe_inv : Commute (a : α) ↑a⁻¹ := by\n  rw [Commute, SemiconjBy, inv_mul, mul_inv]\n\n"}
{"name":"Units.commute_coe_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Commute ↑a ↑(Inv.inv a)","decl":"@[to_additive] lemma commute_coe_inv : Commute (a : α) ↑a⁻¹ := by\n  rw [Commute, SemiconjBy, inv_mul, mul_inv]\n\n"}
{"name":"Units.commute_inv_coe","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\n⊢ Commute ↑(Inv.inv a) ↑a","decl":"@[to_additive] lemma commute_inv_coe : Commute ↑a⁻¹ (a : α) := a.commute_coe_inv.symm\n\n"}
{"name":"AddUnits.addCommute_neg_coe","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\n⊢ AddCommute ↑(Neg.neg a) ↑a","decl":"@[to_additive] lemma commute_inv_coe : Commute ↑a⁻¹ (a : α) := a.commute_coe_inv.symm\n\n"}
{"name":"Units.inv_mul_of_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (↑u) a\n⊢ Eq (HMul.hMul (↑(Inv.inv u)) a) 1","decl":"@[to_additive]\ntheorem inv_mul_of_eq {a : α} (h : ↑u = a) : ↑u⁻¹ * a = 1 := by rw [← h, u.inv_mul]\n\n"}
{"name":"AddUnits.neg_add_of_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (↑u) a\n⊢ Eq (HAdd.hAdd (↑(Neg.neg u)) a) 0","decl":"@[to_additive]\ntheorem inv_mul_of_eq {a : α} (h : ↑u = a) : ↑u⁻¹ * a = 1 := by rw [← h, u.inv_mul]\n\n"}
{"name":"AddUnits.add_neg_of_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (↑u) a\n⊢ Eq (HAdd.hAdd a ↑(Neg.neg u)) 0","decl":"@[to_additive]\ntheorem mul_inv_of_eq {a : α} (h : ↑u = a) : a * ↑u⁻¹ = 1 := by rw [← h, u.mul_inv]\n\n"}
{"name":"Units.mul_inv_of_eq","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (↑u) a\n⊢ Eq (HMul.hMul a ↑(Inv.inv u)) 1","decl":"@[to_additive]\ntheorem mul_inv_of_eq {a : α} (h : ↑u = a) : a * ↑u⁻¹ = 1 := by rw [← h, u.mul_inv]\n\n"}
{"name":"Units.mul_inv_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nb : α\n⊢ Eq (HMul.hMul (↑a) (HMul.hMul (↑(Inv.inv a)) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a : αˣ) (b : α) : (a : α) * (↑a⁻¹ * b) = b := by\n  rw [← mul_assoc, mul_inv, one_mul]\n\n"}
{"name":"AddUnits.add_neg_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nb : α\n⊢ Eq (HAdd.hAdd (↑a) (HAdd.hAdd (↑(Neg.neg a)) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a : αˣ) (b : α) : (a : α) * (↑a⁻¹ * b) = b := by\n  rw [← mul_assoc, mul_inv, one_mul]\n\n"}
{"name":"AddUnits.neg_add_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nb : α\n⊢ Eq (HAdd.hAdd (↑(Neg.neg a)) (HAdd.hAdd (↑a) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a : αˣ) (b : α) : (↑a⁻¹ : α) * (a * b) = b := by\n  rw [← mul_assoc, inv_mul, one_mul]\n\n"}
{"name":"Units.inv_mul_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nb : α\n⊢ Eq (HMul.hMul (↑(Inv.inv a)) (HMul.hMul (↑a) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a : αˣ) (b : α) : (↑a⁻¹ : α) * (a * b) = b := by\n  rw [← mul_assoc, inv_mul, one_mul]\n\n"}
{"name":"Units.inv_mul_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nb c : α\n⊢ Iff (Eq (HMul.hMul (↑(Inv.inv a)) b) c) (Eq b (HMul.hMul (↑a) c))","decl":"@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul {b c : α} : ↑a⁻¹ * b = c ↔ b = a * c :=\n  ⟨fun h => by rw [← h, mul_inv_cancel_left], fun h => by rw [h, inv_mul_cancel_left]⟩\n\n"}
{"name":"AddUnits.neg_add_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nb c : α\n⊢ Iff (Eq (HAdd.hAdd (↑(Neg.neg a)) b) c) (Eq b (HAdd.hAdd (↑a) c))","decl":"@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul {b c : α} : ↑a⁻¹ * b = c ↔ b = a * c :=\n  ⟨fun h => by rw [← h, mul_inv_cancel_left], fun h => by rw [h, inv_mul_cancel_left]⟩\n\n"}
{"name":"AddUnits.val_nsmul_eq_nsmul_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma val_pow_eq_pow_val (n : ℕ) : ↑(a ^ n) = (a ^ n : α) := rfl\n\n"}
{"name":"Units.val_pow_eq_pow_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma val_pow_eq_pow_val (n : ℕ) : ↑(a ^ n) = (a ^ n : α) := rfl\n\n"}
{"name":"Units.val_inv_eq_inv_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nu : Units α\n⊢ Eq (↑(Inv.inv u)) (Inv.inv ↑u)","decl":"@[to_additive (attr := simp, norm_cast)] lemma val_inv_eq_inv_val (u : αˣ) : ↑u⁻¹ = (u⁻¹ : α) :=\n  Eq.symm <| inv_eq_of_mul_eq_one_right u.mul_inv\n\n"}
{"name":"AddUnits.val_neg_eq_neg_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nu : AddUnits α\n⊢ Eq (↑(Neg.neg u)) (Neg.neg ↑u)","decl":"@[to_additive (attr := simp, norm_cast)] lemma val_inv_eq_inv_val (u : αˣ) : ↑u⁻¹ = (u⁻¹ : α) :=\n  Eq.symm <| inv_eq_of_mul_eq_one_right u.mul_inv\n\n"}
{"name":"Units.val_div_eq_div_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nu₁ u₂ : Units α\n⊢ Eq (↑(HDiv.hDiv u₁ u₂)) (HDiv.hDiv ↑u₁ ↑u₂)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma val_div_eq_div_val : ∀ u₁ u₂ : αˣ, ↑(u₁ / u₂) = (u₁ / u₂ : α) := by simp [div_eq_mul_inv]\n\n"}
{"name":"AddUnits.val_sub_eq_sub_val","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nu₁ u₂ : AddUnits α\n⊢ Eq (↑(HSub.hSub u₁ u₂)) (HSub.hSub ↑u₁ ↑u₂)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma val_div_eq_div_val : ∀ u₁ u₂ : αˣ, ↑(u₁ / u₂) = (u₁ / u₂ : α) := by simp [div_eq_mul_inv]\n\n"}
{"name":"Units.val_mkOfMulEqOne","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : CommMonoid α\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq (↑(Units.mkOfMulEqOne a b h)) a","decl":"@[to_additive (attr := simp)]\ntheorem Units.val_mkOfMulEqOne [CommMonoid α] {a b : α} (h : a * b = 1) :\n    (Units.mkOfMulEqOne a b h : α) = a :=\n  rfl\n\n"}
{"name":"AddUnits.val_mkOfAddEqZero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddCommMonoid α\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq (↑(AddUnits.mkOfAddEqZero a b h)) a","decl":"@[to_additive (attr := simp)]\ntheorem Units.val_mkOfMulEqOne [CommMonoid α] {a b : α} (h : a * b = 1) :\n    (Units.mkOfMulEqOne a b h : α) = a :=\n  rfl\n\n"}
{"name":"divp_self","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\n⊢ Eq (divp (↑u) u) 1","decl":"@[simp]\ntheorem divp_self (u : αˣ) : (u : α) /ₚ u = 1 :=\n  Units.mul_inv _\n\n"}
{"name":"divp_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Eq (divp a 1) a","decl":"@[simp]\ntheorem divp_one (a : α) : a /ₚ 1 = a :=\n  mul_one _\n\n"}
{"name":"divp_assoc","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\nu : Units α\n⊢ Eq (divp (HMul.hMul a b) u) (HMul.hMul a (divp b u))","decl":"theorem divp_assoc (a b : α) (u : αˣ) : a * b /ₚ u = a * (b /ₚ u) :=\n  mul_assoc _ _ _\n\n"}
{"name":"divp_assoc'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nx y : α\nu : Units α\n⊢ Eq (HMul.hMul x (divp y u)) (divp (HMul.hMul x y) u)","decl":"/-- `field_simp` needs the reverse direction of `divp_assoc` to move all `/ₚ` to the right. -/\n@[field_simps]\ntheorem divp_assoc' (x y : α) (u : αˣ) : x * (y /ₚ u) = x * y /ₚ u :=\n  (divp_assoc _ _ _).symm\n\n"}
{"name":"divp_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Eq (divp a (Inv.inv u)) (HMul.hMul a ↑u)","decl":"@[simp]\ntheorem divp_inv (u : αˣ) : a /ₚ u⁻¹ = a * u :=\n  rfl\n\n"}
{"name":"divp_mul_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Eq (HMul.hMul (divp a u) ↑u) a","decl":"@[simp]\ntheorem divp_mul_cancel (a : α) (u : αˣ) : a /ₚ u * u = a :=\n  (mul_assoc _ _ _).trans <| by rw [Units.inv_mul, mul_one]\n\n"}
{"name":"mul_divp_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Eq (divp (HMul.hMul a ↑u) u) a","decl":"@[simp]\ntheorem mul_divp_cancel (a : α) (u : αˣ) : a * u /ₚ u = a :=\n  (mul_assoc _ _ _).trans <| by rw [Units.mul_inv, mul_one]\n\n"}
{"name":"divp_divp_eq_divp_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nx : α\nu₁ u₂ : Units α\n⊢ Eq (divp (divp x u₁) u₂) (divp x (HMul.hMul u₂ u₁))","decl":"@[field_simps]\ntheorem divp_divp_eq_divp_mul (x : α) (u₁ u₂ : αˣ) : x /ₚ u₁ /ₚ u₂ = x /ₚ (u₂ * u₁) := by\n  simp only [divp, mul_inv_rev, Units.val_mul, mul_assoc]\n\n"}
{"name":"one_divp","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\n⊢ Eq (divp 1 u) ↑(Inv.inv u)","decl":"@[simp]\ntheorem one_divp (u : αˣ) : 1 /ₚ u = ↑u⁻¹ :=\n  one_mul _\n\n"}
{"name":"inv_eq_one_divp","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\n⊢ Eq (↑(Inv.inv u)) (divp 1 u)","decl":"/-- Used for `field_simp` to deal with inverses of units. -/\n@[field_simps]\ntheorem inv_eq_one_divp (u : αˣ) : ↑u⁻¹ = 1 /ₚ u := by rw [one_divp]\n\n"}
{"name":"val_div_eq_divp","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Monoid α\nu₁ u₂ : Units α\n⊢ Eq (↑(HDiv.hDiv u₁ u₂)) (divp (↑u₁) u₂)","decl":"/-- `field_simp` moves division inside `αˣ` to the right, and this lemma\nlifts the calculation to `α`.\n-/\n@[field_simps]\ntheorem val_div_eq_divp (u₁ u₂ : αˣ) : ↑(u₁ / u₂) = ↑u₁ /ₚ u₂ := by\n  rw [divp, division_def, Units.val_mul]\n\n"}
{"name":"isAddUnit_iff_exists","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : M\n⊢ Iff (IsAddUnit x) (Exists fun b => And (Eq (HAdd.hAdd x b) 0) (Eq (HAdd.hAdd b x) 0))","decl":"/-- See `isUnit_iff_exists_and_exists` for a similar lemma with two existentials. -/\n@[to_additive \"See `isAddUnit_iff_exists_and_exists` for a similar lemma with two existentials.\"]\nlemma isUnit_iff_exists [Monoid M] {x : M} : IsUnit x ↔ ∃ b, x * b = 1 ∧ b * x = 1 := by\n  refine ⟨fun ⟨u, hu⟩ => ?_, fun ⟨b, h1b, h2b⟩ => ⟨⟨x, b, h1b, h2b⟩, rfl⟩⟩\n  subst x\n  exact ⟨u.inv, u.val_inv, u.inv_val⟩\n\n"}
{"name":"isUnit_iff_exists","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Iff (IsUnit x) (Exists fun b => And (Eq (HMul.hMul x b) 1) (Eq (HMul.hMul b x) 1))","decl":"/-- See `isUnit_iff_exists_and_exists` for a similar lemma with two existentials. -/\n@[to_additive \"See `isAddUnit_iff_exists_and_exists` for a similar lemma with two existentials.\"]\nlemma isUnit_iff_exists [Monoid M] {x : M} : IsUnit x ↔ ∃ b, x * b = 1 ∧ b * x = 1 := by\n  refine ⟨fun ⟨u, hu⟩ => ?_, fun ⟨b, h1b, h2b⟩ => ⟨⟨x, b, h1b, h2b⟩, rfl⟩⟩\n  subst x\n  exact ⟨u.inv, u.val_inv, u.inv_val⟩\n\n"}
{"name":"isUnit_iff_exists_and_exists","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (IsUnit a) (And (Exists fun b => Eq (HMul.hMul a b) 1) (Exists fun c => Eq (HMul.hMul c a) 1))","decl":"/-- See `isUnit_iff_exists` for a similar lemma with one existential. -/\n@[to_additive \"See `isAddUnit_iff_exists` for a similar lemma with one existential.\"]\ntheorem isUnit_iff_exists_and_exists [Monoid M] {a : M} :\n    IsUnit a ↔ (∃ b, a * b = 1) ∧ (∃ c, c * a = 1) :=\n  isUnit_iff_exists.trans\n    ⟨fun ⟨b, hba, hab⟩ => ⟨⟨b, hba⟩, ⟨b, hab⟩⟩,\n      fun ⟨⟨b, hb⟩, ⟨_, hc⟩⟩ => ⟨b, hb, left_inv_eq_right_inv hc hb ▸ hc⟩⟩\n\n"}
{"name":"isAddUnit_iff_exists_and_exists","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\n⊢ Iff (IsAddUnit a) (And (Exists fun b => Eq (HAdd.hAdd a b) 0) (Exists fun c => Eq (HAdd.hAdd c a) 0))","decl":"/-- See `isUnit_iff_exists` for a similar lemma with one existential. -/\n@[to_additive \"See `isAddUnit_iff_exists` for a similar lemma with one existential.\"]\ntheorem isUnit_iff_exists_and_exists [Monoid M] {a : M} :\n    IsUnit a ↔ (∃ b, a * b = 1) ∧ (∃ c, c * a = 1) :=\n  isUnit_iff_exists.trans\n    ⟨fun ⟨b, hba, hab⟩ => ⟨⟨b, hba⟩, ⟨b, hab⟩⟩,\n      fun ⟨⟨b, hb⟩, ⟨_, hc⟩⟩ => ⟨b, hb, left_inv_eq_right_inv hc hb ▸ hc⟩⟩\n\n"}
{"name":"Units.isUnit","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu : Units M\n⊢ IsUnit ↑u","decl":"@[to_additive (attr := simp)]\nprotected theorem Units.isUnit [Monoid M] (u : Mˣ) : IsUnit (u : M) :=\n  ⟨u, rfl⟩\n\n"}
{"name":"AddUnits.isAddUnit","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nu : AddUnits M\n⊢ IsAddUnit ↑u","decl":"@[to_additive (attr := simp)]\nprotected theorem Units.isUnit [Monoid M] (u : Mˣ) : IsUnit (u : M) :=\n  ⟨u, rfl⟩\n\n"}
{"name":"isAddUnit_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ IsAddUnit 0","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_one [Monoid M] : IsUnit (1 : M) :=\n  ⟨1, rfl⟩\n\n"}
{"name":"isUnit_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ IsUnit 1","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_one [Monoid M] : IsUnit (1 : M) :=\n  ⟨1, rfl⟩\n\n"}
{"name":"isAddUnit_of_add_eq_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\na b : M\nh : Eq (HAdd.hAdd a b) 0\n⊢ IsAddUnit a","decl":"@[to_additive]\ntheorem isUnit_of_mul_eq_one [CommMonoid M] (a b : M) (h : a * b = 1) : IsUnit a :=\n  ⟨Units.mkOfMulEqOne a b h, rfl⟩\n\n"}
{"name":"isUnit_of_mul_eq_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\nh : Eq (HMul.hMul a b) 1\n⊢ IsUnit a","decl":"@[to_additive]\ntheorem isUnit_of_mul_eq_one [CommMonoid M] (a b : M) (h : a * b = 1) : IsUnit a :=\n  ⟨Units.mkOfMulEqOne a b h, rfl⟩\n\n"}
{"name":"isUnit_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\nh : Eq (HMul.hMul a b) 1\n⊢ IsUnit b","decl":"@[to_additive]\ntheorem isUnit_of_mul_eq_one_right [CommMonoid M] (a b : M) (h : a * b = 1) : IsUnit b := by\n  rw [mul_comm] at h\n  exact isUnit_of_mul_eq_one b a h\n\n"}
{"name":"isAddUnit_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\na b : M\nh : Eq (HAdd.hAdd a b) 0\n⊢ IsAddUnit b","decl":"@[to_additive]\ntheorem isUnit_of_mul_eq_one_right [CommMonoid M] (a b : M) (h : a * b = 1) : IsUnit b := by\n  rw [mul_comm] at h\n  exact isUnit_of_mul_eq_one b a h\n\n"}
{"name":"IsAddUnit.exists_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Exists fun b => Eq (HAdd.hAdd a b) 0","decl":"@[to_additive IsAddUnit.exists_neg]\nlemma IsUnit.exists_right_inv (h : IsUnit a) : ∃ b, a * b = 1 := by\n  rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩\n  exact ⟨b, hab⟩\n\n"}
{"name":"IsUnit.exists_right_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Exists fun b => Eq (HMul.hMul a b) 1","decl":"@[to_additive IsAddUnit.exists_neg]\nlemma IsUnit.exists_right_inv (h : IsUnit a) : ∃ b, a * b = 1 := by\n  rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩\n  exact ⟨b, hab⟩\n\n"}
{"name":"IsUnit.exists_left_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Exists fun b => Eq (HMul.hMul b a) 1","decl":"@[to_additive IsAddUnit.exists_neg']\nlemma IsUnit.exists_left_inv {a : M} (h : IsUnit a) : ∃ b, b * a = 1 := by\n  rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩\n  exact ⟨b, hba⟩\n\n"}
{"name":"IsAddUnit.exists_neg'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Exists fun b => Eq (HAdd.hAdd b a) 0","decl":"@[to_additive IsAddUnit.exists_neg']\nlemma IsUnit.exists_left_inv {a : M} (h : IsUnit a) : ∃ b, b * a = 1 := by\n  rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩\n  exact ⟨b, hba⟩\n\n"}
{"name":"IsUnit.mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\na✝¹ : IsUnit a\na✝ : IsUnit b\n⊢ IsUnit (HMul.hMul a b)","decl":"@[to_additive] lemma IsUnit.mul : IsUnit a → IsUnit b → IsUnit (a * b) := by\n  rintro ⟨x, rfl⟩ ⟨y, rfl⟩; exact ⟨x * y, rfl⟩\n\n"}
{"name":"IsAddUnit.add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b : M\na✝¹ : IsAddUnit a\na✝ : IsAddUnit b\n⊢ IsAddUnit (HAdd.hAdd a b)","decl":"@[to_additive] lemma IsUnit.mul : IsUnit a → IsUnit b → IsUnit (a * b) := by\n  rintro ⟨x, rfl⟩ ⟨y, rfl⟩; exact ⟨x * y, rfl⟩\n\n"}
{"name":"IsAddUnit.nsmul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nn : Nat\na✝ : IsAddUnit a\n⊢ IsAddUnit (HSMul.hSMul n a)","decl":"@[to_additive] lemma IsUnit.pow (n : ℕ) : IsUnit a → IsUnit (a ^ n) := by\n  rintro ⟨u, rfl⟩; exact ⟨u ^ n, rfl⟩\n\n"}
{"name":"IsUnit.pow","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nn : Nat\na✝ : IsUnit a\n⊢ IsUnit (HPow.hPow a n)","decl":"@[to_additive] lemma IsUnit.pow (n : ℕ) : IsUnit a → IsUnit (a ^ n) := by\n  rintro ⟨u, rfl⟩; exact ⟨u ^ n, rfl⟩\n\n"}
{"name":"isAddUnit_iff_eq_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\ninst✝ : Subsingleton (AddUnits M)\nx : M\n⊢ Iff (IsAddUnit x) (Eq x 0)","decl":"@[to_additive] lemma isUnit_iff_eq_one [Subsingleton Mˣ] {x : M} : IsUnit x ↔ x = 1 :=\n  ⟨fun ⟨u, hu⟩ ↦ by rw [← hu, Subsingleton.elim u 1, Units.val_one], fun h ↦ h ▸ isUnit_one⟩\n\n"}
{"name":"isUnit_iff_eq_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton (Units M)\nx : M\n⊢ Iff (IsUnit x) (Eq x 1)","decl":"@[to_additive] lemma isUnit_iff_eq_one [Subsingleton Mˣ] {x : M} : IsUnit x ↔ x = 1 :=\n  ⟨fun ⟨u, hu⟩ ↦ by rw [← hu, Subsingleton.elim u 1, Units.val_one], fun h ↦ h ▸ isUnit_one⟩\n\n"}
{"name":"isUnit_iff_exists_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\n⊢ Iff (IsUnit a) (Exists fun b => Eq (HMul.hMul a b) 1)","decl":"@[to_additive]\ntheorem isUnit_iff_exists_inv [CommMonoid M] {a : M} : IsUnit a ↔ ∃ b, a * b = 1 :=\n  ⟨fun h => h.exists_right_inv, fun ⟨b, hab⟩ => isUnit_of_mul_eq_one _ b hab⟩\n\n"}
{"name":"isAddUnit_iff_exists_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\na : M\n⊢ Iff (IsAddUnit a) (Exists fun b => Eq (HAdd.hAdd a b) 0)","decl":"@[to_additive]\ntheorem isUnit_iff_exists_inv [CommMonoid M] {a : M} : IsUnit a ↔ ∃ b, a * b = 1 :=\n  ⟨fun h => h.exists_right_inv, fun ⟨b, hab⟩ => isUnit_of_mul_eq_one _ b hab⟩\n\n"}
{"name":"isUnit_iff_exists_inv'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\n⊢ Iff (IsUnit a) (Exists fun b => Eq (HMul.hMul b a) 1)","decl":"@[to_additive]\ntheorem isUnit_iff_exists_inv' [CommMonoid M] {a : M} : IsUnit a ↔ ∃ b, b * a = 1 := by\n  simp [isUnit_iff_exists_inv, mul_comm]\n\n"}
{"name":"isAddUnit_iff_exists_neg'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\na : M\n⊢ Iff (IsAddUnit a) (Exists fun b => Eq (HAdd.hAdd b a) 0)","decl":"@[to_additive]\ntheorem isUnit_iff_exists_inv' [CommMonoid M] {a : M} : IsUnit a ↔ ∃ b, b * a = 1 := by\n  simp [isUnit_iff_exists_inv, mul_comm]\n\n"}
{"name":"Units.isUnit_mul_units","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\n⊢ Iff (IsUnit (HMul.hMul a ↑u)) (IsUnit a)","decl":"/-- Multiplication by a `u : Mˣ` on the right doesn't affect `IsUnit`. -/\n@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_mul_units [Monoid M] (a : M) (u : Mˣ) : IsUnit (a * u) ↔ IsUnit a :=\n  Iff.intro\n    (fun ⟨v, hv⟩ => by\n      have : IsUnit (a * ↑u * ↑u⁻¹) := by exists v * u⁻¹; rw [← hv, Units.val_mul]\n      rwa [mul_assoc, Units.mul_inv, mul_one] at this)\n    fun v => v.mul u.isUnit\n\n"}
{"name":"AddUnits.isAddUnit_add_addUnits","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\n⊢ Iff (IsAddUnit (HAdd.hAdd a ↑u)) (IsAddUnit a)","decl":"/-- Multiplication by a `u : Mˣ` on the right doesn't affect `IsUnit`. -/\n@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_mul_units [Monoid M] (a : M) (u : Mˣ) : IsUnit (a * u) ↔ IsUnit a :=\n  Iff.intro\n    (fun ⟨v, hv⟩ => by\n      have : IsUnit (a * ↑u * ↑u⁻¹) := by exists v * u⁻¹; rw [← hv, Units.val_mul]\n      rwa [mul_assoc, Units.mul_inv, mul_one] at this)\n    fun v => v.mul u.isUnit\n\n"}
{"name":"AddUnits.isAddUnit_addUnits_add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\nu : AddUnits M\na : M\n⊢ Iff (IsAddUnit (HAdd.hAdd (↑u) a)) (IsAddUnit a)","decl":"/-- Multiplication by a `u : Mˣ` on the left doesn't affect `IsUnit`. -/\n@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the left doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_units_mul {M : Type*} [Monoid M] (u : Mˣ) (a : M) :\n    IsUnit (↑u * a) ↔ IsUnit a :=\n  Iff.intro\n    (fun ⟨v, hv⟩ => by\n      have : IsUnit (↑u⁻¹ * (↑u * a)) := by exists u⁻¹ * v; rw [← hv, Units.val_mul]\n      rwa [← mul_assoc, Units.inv_mul, one_mul] at this)\n    u.isUnit.mul\n\n"}
{"name":"Units.isUnit_units_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nu : Units M\na : M\n⊢ Iff (IsUnit (HMul.hMul (↑u) a)) (IsUnit a)","decl":"/-- Multiplication by a `u : Mˣ` on the left doesn't affect `IsUnit`. -/\n@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the left doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_units_mul {M : Type*} [Monoid M] (u : Mˣ) (a : M) :\n    IsUnit (↑u * a) ↔ IsUnit a :=\n  Iff.intro\n    (fun ⟨v, hv⟩ => by\n      have : IsUnit (↑u⁻¹ * (↑u * a)) := by exists u⁻¹ * v; rw [← hv, Units.val_mul]\n      rwa [← mul_assoc, Units.inv_mul, one_mul] at this)\n    u.isUnit.mul\n\n"}
{"name":"isAddUnit_of_add_isAddUnit_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nx y : M\nhu : IsAddUnit (HAdd.hAdd x y)\n⊢ IsAddUnit x","decl":"@[to_additive]\ntheorem isUnit_of_mul_isUnit_left [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit x :=\n  let ⟨z, hz⟩ := isUnit_iff_exists_inv.1 hu\n  isUnit_iff_exists_inv.2 ⟨y * z, by rwa [← mul_assoc]⟩\n\n"}
{"name":"isUnit_of_mul_isUnit_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nx y : M\nhu : IsUnit (HMul.hMul x y)\n⊢ IsUnit x","decl":"@[to_additive]\ntheorem isUnit_of_mul_isUnit_left [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit x :=\n  let ⟨z, hz⟩ := isUnit_iff_exists_inv.1 hu\n  isUnit_iff_exists_inv.2 ⟨y * z, by rwa [← mul_assoc]⟩\n\n"}
{"name":"isAddUnit_of_add_isAddUnit_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nx y : M\nhu : IsAddUnit (HAdd.hAdd x y)\n⊢ IsAddUnit y","decl":"@[to_additive]\ntheorem isUnit_of_mul_isUnit_right [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit y :=\n  @isUnit_of_mul_isUnit_left _ _ y x <| by rwa [mul_comm]\n\n"}
{"name":"isUnit_of_mul_isUnit_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nx y : M\nhu : IsUnit (HMul.hMul x y)\n⊢ IsUnit y","decl":"@[to_additive]\ntheorem isUnit_of_mul_isUnit_right [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit y :=\n  @isUnit_of_mul_isUnit_left _ _ y x <| by rwa [mul_comm]\n\n"}
{"name":"IsAddUnit.add_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nx y : M\n⊢ Iff (IsAddUnit (HAdd.hAdd x y)) (And (IsAddUnit x) (IsAddUnit y))","decl":"@[to_additive (attr := simp)]\ntheorem mul_iff [CommMonoid M] {x y : M} : IsUnit (x * y) ↔ IsUnit x ∧ IsUnit y :=\n  ⟨fun h => ⟨isUnit_of_mul_isUnit_left h, isUnit_of_mul_isUnit_right h⟩,\n   fun h => IsUnit.mul h.1 h.2⟩\n\n"}
{"name":"IsUnit.mul_iff","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nx y : M\n⊢ Iff (IsUnit (HMul.hMul x y)) (And (IsUnit x) (IsUnit y))","decl":"@[to_additive (attr := simp)]\ntheorem mul_iff [CommMonoid M] {x y : M} : IsUnit (x * y) ↔ IsUnit x ∧ IsUnit y :=\n  ⟨fun h => ⟨isUnit_of_mul_isUnit_left h, isUnit_of_mul_isUnit_right h⟩,\n   fun h => IsUnit.mul h.1 h.2⟩\n\n"}
{"name":"IsAddUnit.addUnit_of_val_addUnits","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : AddUnits M\nh : IsAddUnit ↑a\n⊢ Eq h.addUnit a","decl":"@[to_additive (attr := simp)]\ntheorem unit_of_val_units {a : Mˣ} (h : IsUnit (a : M)) : h.unit = a :=\n  Units.ext <| rfl\n\n"}
{"name":"IsUnit.unit_of_val_units","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nh : IsUnit ↑a\n⊢ Eq h.unit a","decl":"@[to_additive (attr := simp)]\ntheorem unit_of_val_units {a : Mˣ} (h : IsUnit (a : M)) : h.unit = a :=\n  Units.ext <| rfl\n\n"}
{"name":"IsAddUnit.addUnit_spec","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Eq (↑h.addUnit) a","decl":"@[to_additive (attr := simp)]\ntheorem unit_spec (h : IsUnit a) : ↑h.unit = a :=\n  rfl\n\n"}
{"name":"IsUnit.unit_spec","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Eq (↑h.unit) a","decl":"@[to_additive (attr := simp)]\ntheorem unit_spec (h : IsUnit a) : ↑h.unit = a :=\n  rfl\n\n"}
{"name":"IsUnit.unit_one","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nh : IsUnit 1\n⊢ Eq h.unit 1","decl":"@[to_additive (attr := simp)]\ntheorem unit_one (h : IsUnit (1 : M)) : h.unit = 1 :=\n  Units.eq_iff.1 rfl\n\n"}
{"name":"IsAddUnit.addUnit_zero","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nh : IsAddUnit 0\n⊢ Eq h.addUnit 0","decl":"@[to_additive (attr := simp)]\ntheorem unit_one (h : IsUnit (1 : M)) : h.unit = 1 :=\n  Units.eq_iff.1 rfl\n\n"}
{"name":"IsAddUnit.val_neg_add","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Eq (HAdd.hAdd (↑(Neg.neg h.addUnit)) a) 0","decl":"@[to_additive (attr := simp)]\ntheorem val_inv_mul (h : IsUnit a) : ↑h.unit⁻¹ * a = 1 :=\n  Units.mul_inv _\n\n"}
{"name":"IsUnit.val_inv_mul","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Eq (HMul.hMul (↑(Inv.inv h.unit)) a) 1","decl":"@[to_additive (attr := simp)]\ntheorem val_inv_mul (h : IsUnit a) : ↑h.unit⁻¹ * a = 1 :=\n  Units.mul_inv _\n\n"}
{"name":"IsUnit.mul_val_inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Eq (HMul.hMul a ↑(Inv.inv h.unit)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_val_inv (h : IsUnit a) : a * ↑h.unit⁻¹ = 1 := by\n  rw [← h.unit.mul_inv]; congr\n\n"}
{"name":"IsAddUnit.add_val_neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Eq (HAdd.hAdd a ↑(Neg.neg h.addUnit)) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_val_inv (h : IsUnit a) : a * ↑h.unit⁻¹ = 1 := by\n  rw [← h.unit.mul_inv]; congr\n\n"}
{"name":"IsUnit.inv_mul_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\na✝ : IsUnit a\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_mul_cancel : IsUnit a → a⁻¹ * a = 1 := by\n  rintro ⟨u, rfl⟩\n  rw [← Units.val_inv_eq_inv_val, Units.inv_mul]\n\n"}
{"name":"IsAddUnit.neg_add_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\na✝ : IsAddUnit a\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_mul_cancel : IsUnit a → a⁻¹ * a = 1 := by\n  rintro ⟨u, rfl⟩\n  rw [← Units.val_inv_eq_inv_val, Units.inv_mul]\n\n"}
{"name":"IsAddUnit.add_neg_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\na✝ : IsAddUnit a\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_inv_cancel : IsUnit a → a * a⁻¹ = 1 := by\n  rintro ⟨u, rfl⟩\n  rw [← Units.val_inv_eq_inv_val, Units.mul_inv]\n\n"}
{"name":"IsUnit.mul_inv_cancel","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\na✝ : IsUnit a\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_inv_cancel : IsUnit a → a * a⁻¹ = 1 := by\n  rintro ⟨u, rfl⟩\n  rw [← Units.val_inv_eq_inv_val, Units.mul_inv]\n\n"}
{"name":"IsUnit.val_unit'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ Eq (↑h.unit') a","decl":"/-- The element of the group of units, corresponding to an element of a monoid which is a unit. As\nopposed to `IsUnit.unit`, the inverse is computable and comes from the inversion on `α`. This is\nuseful to transfer properties of inversion in `Units α` to `α`. See also `toUnits`. -/\n@[to_additive (attr := simps val )\n\"The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. As opposed to `IsAddUnit.addUnit`, the negation is\ncomputable and comes from the negation on `α`. This is useful to transfer properties of negation\nin `AddUnits α` to `α`. See also `toAddUnits`.\"]\ndef unit' (h : IsUnit a) : αˣ := ⟨a, a⁻¹, h.mul_inv_cancel, h.inv_mul_cancel⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `simps val_inv` fails\n"}
{"name":"IsAddUnit.val_addUnit'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ Eq (↑h.addUnit') a","decl":"/-- The element of the group of units, corresponding to an element of a monoid which is a unit. As\nopposed to `IsUnit.unit`, the inverse is computable and comes from the inversion on `α`. This is\nuseful to transfer properties of inversion in `Units α` to `α`. See also `toUnits`. -/\n@[to_additive (attr := simps val )\n\"The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. As opposed to `IsAddUnit.addUnit`, the negation is\ncomputable and comes from the negation on `α`. This is useful to transfer properties of negation\nin `AddUnits α` to `α`. See also `toAddUnits`.\"]\ndef unit' (h : IsUnit a) : αˣ := ⟨a, a⁻¹, h.mul_inv_cancel, h.inv_mul_cancel⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `simps val_inv` fails\n"}
{"name":"IsAddUnit.val_neg_addUnit'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ Eq (↑(Neg.neg h.addUnit')) (Neg.neg a)","decl":"@[to_additive] lemma val_inv_unit' (h : IsUnit a) : ↑(h.unit'⁻¹) = a⁻¹ := rfl\n\n"}
{"name":"IsUnit.val_inv_unit'","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ Eq (↑(Inv.inv h.unit')) (Inv.inv a)","decl":"@[to_additive] lemma val_inv_unit' (h : IsUnit a) : ↑(h.unit'⁻¹) = a⁻¹ := rfl\n\n"}
{"name":"IsAddUnit.add_neg_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd (Neg.neg a) b)) b","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_inv_cancel_left (h : IsUnit a) : ∀ b, a * (a⁻¹ * b) = b :=\n  h.unit'.mul_inv_cancel_left\n\n"}
{"name":"IsUnit.mul_inv_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HMul.hMul a (HMul.hMul (Inv.inv a) b)) b","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_inv_cancel_left (h : IsUnit a) : ∀ b, a * (a⁻¹ * b) = b :=\n  h.unit'.mul_inv_cancel_left\n\n"}
{"name":"IsUnit.inv_mul_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul a b)) b","decl":"@[to_additive (attr := simp)]\nprotected lemma inv_mul_cancel_left (h : IsUnit a) : ∀ b, a⁻¹ * (a * b) = b :=\n  h.unit'.inv_mul_cancel_left\n\n"}
{"name":"IsAddUnit.neg_add_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HAdd.hAdd (Neg.neg a) (HAdd.hAdd a b)) b","decl":"@[to_additive (attr := simp)]\nprotected lemma inv_mul_cancel_left (h : IsUnit a) : ∀ b, a⁻¹ * (a * b) = b :=\n  h.unit'.inv_mul_cancel_left\n\n"}
{"name":"IsAddUnit.sub_self","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ Eq (HSub.hSub a a) 0","decl":"@[to_additive]\nprotected lemma div_self (h : IsUnit a) : a / a = 1 := by rw [div_eq_mul_inv, h.mul_inv_cancel]\n\n"}
{"name":"IsUnit.div_self","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ Eq (HDiv.hDiv a a) 1","decl":"@[to_additive]\nprotected lemma div_self (h : IsUnit a) : a / a = 1 := by rw [div_eq_mul_inv, h.mul_inv_cancel]\n\n"}
{"name":"IsUnit.inv","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ IsUnit (Inv.inv a)","decl":"@[to_additive]\nlemma inv (h : IsUnit a) : IsUnit a⁻¹ := by\n  obtain ⟨u, hu⟩ := h\n  rw [← hu, ← Units.val_inv_eq_inv_val]\n  exact Units.isUnit _\n\n"}
{"name":"IsAddUnit.neg","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ IsAddUnit (Neg.neg a)","decl":"@[to_additive]\nlemma inv (h : IsUnit a) : IsUnit a⁻¹ := by\n  obtain ⟨u, hu⟩ := h\n  rw [← hu, ← Units.val_inv_eq_inv_val]\n  exact Units.isUnit _\n\n"}
{"name":"IsAddUnit.sub","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nha : IsAddUnit a\nhb : IsAddUnit b\n⊢ IsAddUnit (HSub.hSub a b)","decl":"@[to_additive] lemma div (ha : IsUnit a) (hb : IsUnit b) : IsUnit (a / b) := by\n  rw [div_eq_mul_inv]; exact ha.mul hb.inv\n\n"}
{"name":"IsUnit.div","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nha : IsUnit a\nhb : IsUnit b\n⊢ IsUnit (HDiv.hDiv a b)","decl":"@[to_additive] lemma div (ha : IsUnit a) (hb : IsUnit b) : IsUnit (a / b) := by\n  rw [div_eq_mul_inv]; exact ha.mul hb.inv\n\n"}
{"name":"IsUnit.div_mul_cancel_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb : α\nh : IsUnit b\na : α\n⊢ Eq (HDiv.hDiv b (HMul.hMul a b)) (Inv.inv a)","decl":"@[to_additive]\nprotected lemma div_mul_cancel_right (h : IsUnit b) (a : α) : b / (a * b) = a⁻¹ := by\n  rw [div_eq_mul_inv, mul_inv_rev, h.mul_inv_cancel_left]\n\n"}
{"name":"IsAddUnit.sub_add_cancel_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb : α\nh : IsAddUnit b\na : α\n⊢ Eq (HSub.hSub b (HAdd.hAdd a b)) (Neg.neg a)","decl":"@[to_additive]\nprotected lemma div_mul_cancel_right (h : IsUnit b) (a : α) : b / (a * b) = a⁻¹ := by\n  rw [div_eq_mul_inv, mul_inv_rev, h.mul_inv_cancel_left]\n\n"}
{"name":"IsAddUnit.add_sub_add_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nc : α\nh : IsAddUnit c\na b : α\n⊢ Eq (HSub.hSub (HAdd.hAdd a c) (HAdd.hAdd b c)) (HSub.hSub a b)","decl":"@[to_additive]\nprotected lemma mul_div_mul_right (h : IsUnit c) (a b : α) : a * c / (b * c) = a / b := by\n  simp only [div_eq_mul_inv, mul_inv_rev, mul_assoc, h.mul_inv_cancel_left]\n\n"}
{"name":"IsUnit.mul_div_mul_right","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nc : α\nh : IsUnit c\na b : α\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b c)) (HDiv.hDiv a b)","decl":"@[to_additive]\nprotected lemma mul_div_mul_right (h : IsUnit c) (a b : α) : a * c / (b * c) = a / b := by\n  simp only [div_eq_mul_inv, mul_inv_rev, mul_assoc, h.mul_inv_cancel_left]\n\n"}
{"name":"IsAddUnit.sub_add_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HSub.hSub a (HAdd.hAdd a b)) (Neg.neg b)","decl":"@[to_additive]\nprotected lemma div_mul_cancel_left (h : IsUnit a) (b : α) : a / (a * b) = b⁻¹ := by\n  rw [mul_comm, h.div_mul_cancel_right]\n\n"}
{"name":"IsUnit.div_mul_cancel_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HDiv.hDiv a (HMul.hMul a b)) (Inv.inv b)","decl":"@[to_additive]\nprotected lemma div_mul_cancel_left (h : IsUnit a) (b : α) : a / (a * b) = b⁻¹ := by\n  rw [mul_comm, h.div_mul_cancel_right]\n\n"}
{"name":"IsUnit.mul_div_mul_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\nc : α\nh : IsUnit c\na b : α\n⊢ Eq (HDiv.hDiv (HMul.hMul c a) (HMul.hMul c b)) (HDiv.hDiv a b)","decl":"@[to_additive]\nprotected lemma mul_div_mul_left (h : IsUnit c) (a b : α) : c * a / (c * b) = a / b := by\n  rw [mul_comm c, mul_comm c, h.mul_div_mul_right]\n\n"}
{"name":"IsAddUnit.add_sub_add_left","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\nc : α\nh : IsAddUnit c\na b : α\n⊢ Eq (HSub.hSub (HAdd.hAdd c a) (HAdd.hAdd c b)) (HSub.hSub a b)","decl":"@[to_additive]\nprotected lemma mul_div_mul_left (h : IsUnit c) (a b : α) : c * a / (c * b) = a / b := by\n  rw [mul_comm c, mul_comm c, h.mul_div_mul_right]\n\n"}
{"name":"divp_eq_div","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nu : Units α\n⊢ Eq (divp a u) (HDiv.hDiv a ↑u)","decl":"@[field_simps]\nlemma divp_eq_div [DivisionMonoid α] (a : α) (u : αˣ) : a /ₚ u = a / u := by\n  rw [div_eq_mul_inv, divp, u.val_inv_eq_inv_val]\n\n"}
{"name":"AddGroup.isAddUnit","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\n⊢ IsAddUnit a","decl":"@[to_additive]\nlemma Group.isUnit [Group α] (a : α) : IsUnit a :=\n  ⟨⟨a, a⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩, rfl⟩\n\n-- namespace\n"}
{"name":"Group.isUnit","module":"Mathlib.Algebra.Group.Units.Defs","initialProofState":"α : Type u\ninst✝ : Group α\na : α\n⊢ IsUnit a","decl":"@[to_additive]\nlemma Group.isUnit [Group α] (a : α) : IsUnit a :=\n  ⟨⟨a, a⁻¹, mul_inv_cancel _, inv_mul_cancel _⟩, rfl⟩\n\n-- namespace\n"}
