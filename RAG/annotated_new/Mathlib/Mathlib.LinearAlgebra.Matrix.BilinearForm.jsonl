{"name":"Matrix.toBilin'Aux_single","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\ni j : n\n⊢ Eq ((M.toBilin'Aux (Pi.single i 1)) (Pi.single j 1)) (M i j)","decl":"theorem Matrix.toBilin'Aux_single [Fintype n] [DecidableEq n] (M : Matrix n n R₁) (i j : n) :\n    M.toBilin'Aux (Pi.single i 1) (Pi.single j 1) = M i j :=\n  Matrix.toLinearMap₂'Aux_single _ _ _ _ _\n\n"}
{"name":"LinearMap.BilinForm.toMatrixAux_apply","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nn : Type u_5\nB : LinearMap.BilinForm R₁ M₁\nb : n → M₁\ni j : n\n⊢ Eq ((BilinForm.toMatrixAux b) B i j) ((B (b i)) (b j))","decl":"@[simp]\ntheorem LinearMap.BilinForm.toMatrixAux_apply (B : BilinForm R₁ M₁) (b : n → M₁) (i j : n) :\n    -- Porting note: had to hint the base ring even though it should be clear from context...\n    BilinForm.toMatrixAux (R₁ := R₁) b B i j = B (b i) (b j) :=\n  LinearMap.toMatrix₂Aux_apply R₁ B _ _ _ _\n\n"}
{"name":"toBilin'Aux_toMatrixAux","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB₂ : LinearMap.BilinForm R₁ (n → R₁)\n⊢ Eq ((BilinForm.toMatrixAux fun j => Pi.single j 1) B₂).toBilin'Aux B₂","decl":"theorem toBilin'Aux_toMatrixAux [DecidableEq n] (B₂ : BilinForm R₁ (n → R₁)) :\n    -- Porting note: had to hint the base ring even though it should be clear from context...\n    Matrix.toBilin'Aux (BilinForm.toMatrixAux (R₁ := R₁) (fun j => Pi.single j 1) B₂) = B₂ := by\n  rw [BilinForm.toMatrixAux, Matrix.toBilin'Aux, toLinearMap₂'Aux_toMatrix₂Aux]\n\n"}
{"name":"Matrix.toBilin'Aux_eq","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\n⊢ Eq M.toBilin'Aux (Matrix.toBilin' M)","decl":"@[simp]\ntheorem Matrix.toBilin'Aux_eq (M : Matrix n n R₁) : Matrix.toBilin'Aux M = Matrix.toBilin' M :=\n  rfl\n\n"}
{"name":"Matrix.toBilin'_apply","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\nx y : n → R₁\n⊢ Eq (((Matrix.toBilin' M) x) y) (Finset.univ.sum fun i => Finset.univ.sum fun j => HMul.hMul (HMul.hMul (x i) (M i j)) (y j))","decl":"theorem Matrix.toBilin'_apply (M : Matrix n n R₁) (x y : n → R₁) :\n    Matrix.toBilin' M x y = ∑ i, ∑ j, x i * M i j * y j :=\n  (Matrix.toLinearMap₂'_apply _ _ _).trans\n    (by simp only [smul_eq_mul, mul_assoc, mul_comm, mul_left_comm])\n\n"}
{"name":"Matrix.toBilin'_apply'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\nv w : n → R₁\n⊢ Eq (((Matrix.toBilin' M) v) w) (dotProduct v (M.mulVec w))","decl":"theorem Matrix.toBilin'_apply' (M : Matrix n n R₁) (v w : n → R₁) :\n    Matrix.toBilin' M v w = dotProduct v (M *ᵥ w) := Matrix.toLinearMap₂'_apply' _ _ _\n\n"}
{"name":"Matrix.toBilin'_single","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\ni j : n\n⊢ Eq (((Matrix.toBilin' M) (Pi.single i 1)) (Pi.single j 1)) (M i j)","decl":"@[simp]\ntheorem Matrix.toBilin'_single (M : Matrix n n R₁) (i j : n) :\n    Matrix.toBilin' M (Pi.single i 1) (Pi.single j 1) = M i j := by\n  simp [Matrix.toBilin'_apply, Pi.single_apply]\n\n"}
{"name":"Matrix.toBilin'_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\ni j : n\n⊢ Eq (((Matrix.toBilin' M) ((LinearMap.stdBasis R₁ (fun x => R₁) i) 1)) ((LinearMap.stdBasis R₁ (fun x => R₁) j) 1)) (M i j)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Matrix.toBilin'_single (since := \"2024-08-09\")]\ntheorem Matrix.toBilin'_stdBasis (M : Matrix n n R₁) (i j : n) :\n    Matrix.toBilin' M\n      (LinearMap.stdBasis R₁ (fun _ ↦ R₁) i 1)\n      (LinearMap.stdBasis R₁ (fun _ ↦ R₁) j 1) = M i j := Matrix.toBilin'_single _ _ _\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_symm","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq LinearMap.BilinForm.toMatrix'.symm Matrix.toBilin'","decl":"@[simp]\ntheorem LinearMap.BilinForm.toMatrix'_symm :\n    (BilinForm.toMatrix'.symm : Matrix n n R₁ ≃ₗ[R₁] _) = Matrix.toBilin' :=\n  rfl\n\n"}
{"name":"Matrix.toBilin'_symm","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq Matrix.toBilin'.symm LinearMap.BilinForm.toMatrix'","decl":"@[simp]\ntheorem Matrix.toBilin'_symm :\n    (Matrix.toBilin'.symm : _ ≃ₗ[R₁] Matrix n n R₁) = BilinForm.toMatrix' :=\n  BilinForm.toMatrix'.symm_symm\n\n"}
{"name":"Matrix.toBilin'_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\n⊢ Eq (Matrix.toBilin' (LinearMap.BilinForm.toMatrix' B)) B","decl":"@[simp]\ntheorem Matrix.toBilin'_toMatrix' (B : BilinForm R₁ (n → R₁)) :\n    Matrix.toBilin' (BilinForm.toMatrix' B) = B :=\n  Matrix.toBilin'.apply_symm_apply B\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_toBilin'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n R₁\n⊢ Eq (LinearMap.BilinForm.toMatrix' (Matrix.toBilin' M)) M","decl":"@[simp]\ntheorem BilinForm.toMatrix'_toBilin' (M : Matrix n n R₁) :\n    BilinForm.toMatrix' (Matrix.toBilin' M) = M :=\n  (LinearMap.toMatrix₂' R₁).apply_symm_apply M\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_apply","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\ni j : n\n⊢ Eq (LinearMap.BilinForm.toMatrix' B i j) ((B (Pi.single i 1)) (Pi.single j 1))","decl":"@[simp]\ntheorem BilinForm.toMatrix'_apply (B : BilinForm R₁ (n → R₁)) (i j : n) :\n    BilinForm.toMatrix' B i j = B (Pi.single i 1) (Pi.single j 1) :=\n  LinearMap.toMatrix₂'_apply _ _ _\n\n-- Porting note: dot notation for bundled maps doesn't work in the rest of this section\n"}
{"name":"LinearMap.BilinForm.toMatrix'_comp","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝⁴ : CommSemiring R₁\nn : Type u_5\no : Type u_6\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq o\nB : LinearMap.BilinForm R₁ (n → R₁)\nl r : LinearMap (RingHom.id R₁) (o → R₁) (n → R₁)\n⊢ Eq (LinearMap.BilinForm.toMatrix' (B.comp l r)) (HMul.hMul (HMul.hMul (LinearMap.toMatrix' l).transpose (LinearMap.BilinForm.toMatrix' B)) (LinearMap.toMatrix' r))","decl":"@[simp]\ntheorem BilinForm.toMatrix'_comp (B : BilinForm R₁ (n → R₁)) (l r : (o → R₁) →ₗ[R₁] n → R₁) :\n    BilinForm.toMatrix' (B.comp l r) =\n      (LinearMap.toMatrix' l)ᵀ * BilinForm.toMatrix' B * LinearMap.toMatrix' r :=\n  LinearMap.toMatrix₂'_compl₁₂ B _ _\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_compLeft","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\nf : LinearMap (RingHom.id R₁) (n → R₁) (n → R₁)\n⊢ Eq (LinearMap.BilinForm.toMatrix' (B.compLeft f)) (HMul.hMul (LinearMap.toMatrix' f).transpose (LinearMap.BilinForm.toMatrix' B))","decl":"theorem BilinForm.toMatrix'_compLeft (B : BilinForm R₁ (n → R₁)) (f : (n → R₁) →ₗ[R₁] n → R₁) :\n    BilinForm.toMatrix' (B.compLeft f) = (LinearMap.toMatrix' f)ᵀ * BilinForm.toMatrix' B :=\n  LinearMap.toMatrix₂'_comp B _\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_compRight","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\nf : LinearMap (RingHom.id R₁) (n → R₁) (n → R₁)\n⊢ Eq (LinearMap.BilinForm.toMatrix' (B.compRight f)) (HMul.hMul (LinearMap.BilinForm.toMatrix' B) (LinearMap.toMatrix' f))","decl":"theorem BilinForm.toMatrix'_compRight (B : BilinForm R₁ (n → R₁)) (f : (n → R₁) →ₗ[R₁] n → R₁) :\n    BilinForm.toMatrix' (B.compRight f) = BilinForm.toMatrix' B * LinearMap.toMatrix' f :=\n  LinearMap.toMatrix₂'_compl₂ B _\n\n"}
{"name":"LinearMap.BilinForm.mul_toMatrix'_mul","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝⁴ : CommSemiring R₁\nn : Type u_5\no : Type u_6\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq o\nB : LinearMap.BilinForm R₁ (n → R₁)\nM : Matrix o n R₁\nN : Matrix n o R₁\n⊢ Eq (HMul.hMul (HMul.hMul M (LinearMap.BilinForm.toMatrix' B)) N) (LinearMap.BilinForm.toMatrix' (B.comp (Matrix.toLin' M.transpose) (Matrix.toLin' N)))","decl":"theorem BilinForm.mul_toMatrix'_mul (B : BilinForm R₁ (n → R₁)) (M : Matrix o n R₁)\n    (N : Matrix n o R₁) : M * BilinForm.toMatrix' B * N =\n      BilinForm.toMatrix' (B.comp (Matrix.toLin' Mᵀ) (Matrix.toLin' N)) :=\n  LinearMap.mul_toMatrix₂'_mul B _ _\n\n"}
{"name":"LinearMap.BilinForm.mul_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\nM : Matrix n n R₁\n⊢ Eq (HMul.hMul M (LinearMap.BilinForm.toMatrix' B)) (LinearMap.BilinForm.toMatrix' (B.compLeft (Matrix.toLin' M.transpose)))","decl":"theorem BilinForm.mul_toMatrix' (B : BilinForm R₁ (n → R₁)) (M : Matrix n n R₁) :\n    M * BilinForm.toMatrix' B = BilinForm.toMatrix' (B.compLeft (Matrix.toLin' Mᵀ)) :=\n  LinearMap.mul_toMatrix' B _\n\n"}
{"name":"LinearMap.BilinForm.toMatrix'_mul","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nB : LinearMap.BilinForm R₁ (n → R₁)\nM : Matrix n n R₁\n⊢ Eq (HMul.hMul (LinearMap.BilinForm.toMatrix' B) M) (LinearMap.BilinForm.toMatrix' (B.compRight (Matrix.toLin' M)))","decl":"theorem BilinForm.toMatrix'_mul (B : BilinForm R₁ (n → R₁)) (M : Matrix n n R₁) :\n    BilinForm.toMatrix' B * M = BilinForm.toMatrix' (B.compRight (Matrix.toLin' M)) :=\n  LinearMap.toMatrix₂'_mul B _\n\n"}
{"name":"Matrix.toBilin'_comp","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝⁴ : CommSemiring R₁\nn : Type u_5\no : Type u_6\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq o\nM : Matrix n n R₁\nP Q : Matrix n o R₁\n⊢ Eq ((Matrix.toBilin' M).comp (Matrix.toLin' P) (Matrix.toLin' Q)) (Matrix.toBilin' (HMul.hMul (HMul.hMul P.transpose M) Q))","decl":"theorem Matrix.toBilin'_comp (M : Matrix n n R₁) (P Q : Matrix n o R₁) :\n    M.toBilin'.comp (Matrix.toLin' P) (Matrix.toLin' Q) = Matrix.toBilin' (Pᵀ * M * Q) :=\n  BilinForm.toMatrix'.injective\n    (by simp only [BilinForm.toMatrix'_comp, BilinForm.toMatrix'_toBilin', toMatrix'_toLin'])\n\n"}
{"name":"BilinForm.toMatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\ni j : n\n⊢ Eq ((BilinForm.toMatrix b) B i j) ((B (b i)) (b j))","decl":"@[simp]\ntheorem BilinForm.toMatrix_apply (B : BilinForm R₁ M₁) (i j : n) :\n    BilinForm.toMatrix b B i j = B (b i) (b j) :=\n  LinearMap.toMatrix₂_apply _ _ B _ _\n\n"}
{"name":"Matrix.toBilin_apply","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nM : Matrix n n R₁\nx y : M₁\n⊢ Eq ((((Matrix.toBilin b) M) x) y) (Finset.univ.sum fun i => Finset.univ.sum fun j => HMul.hMul (HMul.hMul ((b.repr x) i) (M i j)) ((b.repr y) j))","decl":"@[simp]\ntheorem Matrix.toBilin_apply (M : Matrix n n R₁) (x y : M₁) :\n    Matrix.toBilin b M x y = ∑ i, ∑ j, b.repr x i * M i j * b.repr y j :=\n  (Matrix.toLinearMap₂_apply _ _ _ _ _).trans\n    (by simp only [smul_eq_mul, mul_assoc, mul_comm, mul_left_comm])\n\n-- Not a `simp` lemma since `BilinForm.toMatrix` needs an extra argument\n"}
{"name":"BilinearForm.toMatrixAux_eq","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Eq ((BilinForm.toMatrixAux ⇑b) B) ((BilinForm.toMatrix b) B)","decl":"theorem BilinearForm.toMatrixAux_eq (B : BilinForm R₁ M₁) :\n    BilinForm.toMatrixAux (R₁ := R₁) b B = BilinForm.toMatrix b B :=\n  LinearMap.toMatrix₂Aux_eq _ _ B\n\n"}
{"name":"BilinForm.toMatrix_symm","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\n⊢ Eq (BilinForm.toMatrix b).symm (Matrix.toBilin b)","decl":"@[simp]\ntheorem BilinForm.toMatrix_symm : (BilinForm.toMatrix b).symm = Matrix.toBilin b :=\n  rfl\n\n"}
{"name":"Matrix.toBilin_symm","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\n⊢ Eq (Matrix.toBilin b).symm (BilinForm.toMatrix b)","decl":"@[simp]\ntheorem Matrix.toBilin_symm : (Matrix.toBilin b).symm = BilinForm.toMatrix b :=\n  (BilinForm.toMatrix b).symm_symm\n\n"}
{"name":"Matrix.toBilin_basisFun","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.toBilin (Pi.basisFun R₁ n)) Matrix.toBilin'","decl":"theorem Matrix.toBilin_basisFun : Matrix.toBilin (Pi.basisFun R₁ n) = Matrix.toBilin' := by\n  ext M\n  simp only [coe_comp, coe_single, Function.comp_apply, toBilin_apply, Pi.basisFun_repr,\n    toBilin'_apply]\n\n"}
{"name":"BilinForm.toMatrix_basisFun","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\ninst✝² : CommSemiring R₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (BilinForm.toMatrix (Pi.basisFun R₁ n)) LinearMap.BilinForm.toMatrix'","decl":"theorem BilinForm.toMatrix_basisFun :\n    BilinForm.toMatrix (Pi.basisFun R₁ n) = BilinForm.toMatrix' := by\n  rw [BilinForm.toMatrix, BilinForm.toMatrix', LinearMap.toMatrix₂_basisFun]\n\n"}
{"name":"Matrix.toBilin_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Eq ((Matrix.toBilin b) ((BilinForm.toMatrix b) B)) B","decl":"@[simp]\ntheorem Matrix.toBilin_toMatrix (B : BilinForm R₁ M₁) :\n    Matrix.toBilin b (BilinForm.toMatrix b B) = B :=\n  (Matrix.toBilin b).apply_symm_apply B\n\n"}
{"name":"BilinForm.toMatrix_toBilin","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nM : Matrix n n R₁\n⊢ Eq ((BilinForm.toMatrix b) ((Matrix.toBilin b) M)) M","decl":"@[simp]\ntheorem BilinForm.toMatrix_toBilin (M : Matrix n n R₁) :\n    BilinForm.toMatrix b (Matrix.toBilin b M) = M :=\n  (BilinForm.toMatrix b).apply_symm_apply M\n\n"}
{"name":"BilinForm.toMatrix_comp","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁸ : CommSemiring R₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R₁ M₁\nn : Type u_5\no : Type u_6\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype o\ninst✝³ : DecidableEq n\nb : Basis n R₁ M₁\nM₂' : Type u_7\ninst✝² : AddCommMonoid M₂'\ninst✝¹ : Module R₁ M₂'\nc : Basis o R₁ M₂'\ninst✝ : DecidableEq o\nB : LinearMap.BilinForm R₁ M₁\nl r : LinearMap (RingHom.id R₁) M₂' M₁\n⊢ Eq ((BilinForm.toMatrix c) (B.comp l r)) (HMul.hMul (HMul.hMul ((LinearMap.toMatrix c b) l).transpose ((BilinForm.toMatrix b) B)) ((LinearMap.toMatrix c b) r))","decl":"theorem BilinForm.toMatrix_comp (B : BilinForm R₁ M₁) (l r : M₂' →ₗ[R₁] M₁) :\n    BilinForm.toMatrix c (B.comp l r) =\n      (LinearMap.toMatrix c b l)ᵀ * BilinForm.toMatrix b B * LinearMap.toMatrix c b r :=\n  LinearMap.toMatrix₂_compl₁₂ _ _ _ _ B _ _\n\n"}
{"name":"BilinForm.toMatrix_compLeft","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nf : LinearMap (RingHom.id R₁) M₁ M₁\n⊢ Eq ((BilinForm.toMatrix b) (B.compLeft f)) (HMul.hMul ((LinearMap.toMatrix b b) f).transpose ((BilinForm.toMatrix b) B))","decl":"theorem BilinForm.toMatrix_compLeft (B : BilinForm R₁ M₁) (f : M₁ →ₗ[R₁] M₁) :\n    BilinForm.toMatrix b (B.compLeft f) = (LinearMap.toMatrix b b f)ᵀ * BilinForm.toMatrix b B :=\n  LinearMap.toMatrix₂_comp _ _ _ B _\n\n"}
{"name":"BilinForm.toMatrix_compRight","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nf : LinearMap (RingHom.id R₁) M₁ M₁\n⊢ Eq ((BilinForm.toMatrix b) (B.compRight f)) (HMul.hMul ((BilinForm.toMatrix b) B) ((LinearMap.toMatrix b b) f))","decl":"theorem BilinForm.toMatrix_compRight (B : BilinForm R₁ M₁) (f : M₁ →ₗ[R₁] M₁) :\n    BilinForm.toMatrix b (B.compRight f) = BilinForm.toMatrix b B * LinearMap.toMatrix b b f :=\n  LinearMap.toMatrix₂_compl₂ _ _ _ B _\n\n"}
{"name":"BilinForm.toMatrix_mul_basis_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁶ : CommSemiring R₁\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R₁ M₁\nn : Type u_5\no : Type u_6\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : DecidableEq n\nb : Basis n R₁ M₁\ninst✝ : DecidableEq o\nc : Basis o R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Eq (HMul.hMul (HMul.hMul (b.toMatrix ⇑c).transpose ((BilinForm.toMatrix b) B)) (b.toMatrix ⇑c)) ((BilinForm.toMatrix c) B)","decl":"@[simp]\ntheorem BilinForm.toMatrix_mul_basis_toMatrix (c : Basis o R₁ M₁) (B : BilinForm R₁ M₁) :\n    (b.toMatrix c)ᵀ * BilinForm.toMatrix b B * b.toMatrix c = BilinForm.toMatrix c B :=\n  LinearMap.toMatrix₂_mul_basis_toMatrix _ _ _  _ B\n\n"}
{"name":"BilinForm.mul_toMatrix_mul","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁸ : CommSemiring R₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R₁ M₁\nn : Type u_5\no : Type u_6\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype o\ninst✝³ : DecidableEq n\nb : Basis n R₁ M₁\nM₂' : Type u_7\ninst✝² : AddCommMonoid M₂'\ninst✝¹ : Module R₁ M₂'\nc : Basis o R₁ M₂'\ninst✝ : DecidableEq o\nB : LinearMap.BilinForm R₁ M₁\nM : Matrix o n R₁\nN : Matrix n o R₁\n⊢ Eq (HMul.hMul (HMul.hMul M ((BilinForm.toMatrix b) B)) N) ((BilinForm.toMatrix c) (B.comp ((Matrix.toLin c b) M.transpose) ((Matrix.toLin c b) N)))","decl":"theorem BilinForm.mul_toMatrix_mul (B : BilinForm R₁ M₁) (M : Matrix o n R₁) (N : Matrix n o R₁) :\n    M * BilinForm.toMatrix b B * N =\n      BilinForm.toMatrix c (B.comp (Matrix.toLin c b Mᵀ) (Matrix.toLin c b N)) :=\n  LinearMap.mul_toMatrix₂_mul _ _ _ _ B _ _\n\n"}
{"name":"BilinForm.mul_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nM : Matrix n n R₁\n⊢ Eq (HMul.hMul M ((BilinForm.toMatrix b) B)) ((BilinForm.toMatrix b) (B.compLeft ((Matrix.toLin b b) M.transpose)))","decl":"theorem BilinForm.mul_toMatrix (B : BilinForm R₁ M₁) (M : Matrix n n R₁) :\n    M * BilinForm.toMatrix b B = BilinForm.toMatrix b (B.compLeft (Matrix.toLin b b Mᵀ)) :=\n  LinearMap.mul_toMatrix₂ _ _ _ B _\n\n"}
{"name":"BilinForm.toMatrix_mul","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nb : Basis n R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nM : Matrix n n R₁\n⊢ Eq (HMul.hMul ((BilinForm.toMatrix b) B) M) ((BilinForm.toMatrix b) (B.compRight ((Matrix.toLin b b) M)))","decl":"theorem BilinForm.toMatrix_mul (B : BilinForm R₁ M₁) (M : Matrix n n R₁) :\n    BilinForm.toMatrix b B * M = BilinForm.toMatrix b (B.compRight (Matrix.toLin b b M)) :=\n  LinearMap.toMatrix₂_mul _ _ _  B _\n\n"}
{"name":"Matrix.toBilin_comp","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁸ : CommSemiring R₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R₁ M₁\nn : Type u_5\no : Type u_6\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype o\ninst✝³ : DecidableEq n\nb : Basis n R₁ M₁\nM₂' : Type u_7\ninst✝² : AddCommMonoid M₂'\ninst✝¹ : Module R₁ M₂'\nc : Basis o R₁ M₂'\ninst✝ : DecidableEq o\nM : Matrix n n R₁\nP Q : Matrix n o R₁\n⊢ Eq (((Matrix.toBilin b) M).comp ((Matrix.toLin c b) P) ((Matrix.toLin c b) Q)) ((Matrix.toBilin c) (HMul.hMul (HMul.hMul P.transpose M) Q))","decl":"theorem Matrix.toBilin_comp (M : Matrix n n R₁) (P Q : Matrix n o R₁) :\n    (Matrix.toBilin b M).comp (toLin c b P) (toLin c b Q) = Matrix.toBilin c (Pᵀ * M * Q) := by\n  ext x y\n  rw [Matrix.toBilin, BilinForm.toMatrix, Matrix.toBilin, BilinForm.toMatrix, toMatrix₂_symm,\n    toMatrix₂_symm, ← Matrix.toLinearMap₂_compl₁₂ b b c c]\n  simp\n\n"}
{"name":"Matrix.isAdjointPair_equiv'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nn : Type u_5\ninst✝¹ : Fintype n\nJ A A' : Matrix n n R₂\ninst✝ : DecidableEq n\nP : Matrix n n R₂\nh : IsUnit P\n⊢ Iff ((HMul.hMul (HMul.hMul P.transpose J) P).IsAdjointPair (HMul.hMul (HMul.hMul P.transpose J) P) A A') (J.IsAdjointPair J (HMul.hMul (HMul.hMul P A) (Inv.inv P)) (HMul.hMul (HMul.hMul P A') (Inv.inv P)))","decl":"theorem Matrix.isAdjointPair_equiv' [DecidableEq n] (P : Matrix n n R₂) (h : IsUnit P) :\n    (Pᵀ * J * P).IsAdjointPair (Pᵀ * J * P) A A' ↔\n      J.IsAdjointPair J (P * A * P⁻¹) (P * A' * P⁻¹) :=\n  Matrix.isAdjointPair_equiv _ _ _ _ h\n\n"}
{"name":"mem_pairSelfAdjointMatricesSubmodule'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nn : Type u_5\ninst✝¹ : Fintype n\nJ J₃ A : Matrix n n R₂\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (pairSelfAdjointMatricesSubmodule J J₃) A) (J.IsAdjointPair J₃ A A)","decl":"theorem mem_pairSelfAdjointMatricesSubmodule' :\n    A ∈ pairSelfAdjointMatricesSubmodule J J₃ ↔ Matrix.IsAdjointPair J J₃ A A := by\n  simp only [mem_pairSelfAdjointMatricesSubmodule]\n\n"}
{"name":"mem_selfAdjointMatricesSubmodule'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nn : Type u_5\ninst✝¹ : Fintype n\nJ A : Matrix n n R₂\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (selfAdjointMatricesSubmodule J) A) (J.IsSelfAdjoint A)","decl":"theorem mem_selfAdjointMatricesSubmodule' :\n    A ∈ selfAdjointMatricesSubmodule J ↔ J.IsSelfAdjoint A := by\n  simp only [mem_selfAdjointMatricesSubmodule]\n\n"}
{"name":"mem_skewAdjointMatricesSubmodule'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nn : Type u_5\ninst✝¹ : Fintype n\nJ A : Matrix n n R₂\ninst✝ : DecidableEq n\n⊢ Iff (Membership.mem (skewAdjointMatricesSubmodule J) A) (J.IsSkewAdjoint A)","decl":"theorem mem_skewAdjointMatricesSubmodule' :\n    A ∈ skewAdjointMatricesSubmodule J ↔ J.IsSkewAdjoint A := by\n  simp only [mem_skewAdjointMatricesSubmodule]\n\n"}
{"name":"Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₁ : Type u_1\nM₁ : Type u_2\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₁\nb : Basis ι R₁ M₁\n⊢ Iff (Matrix.toBilin' M).Nondegenerate ((Matrix.toBilin b) M).Nondegenerate","decl":"theorem _root_.Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin {M : Matrix ι ι R₁}\n    (b : Basis ι R₁ M₁) : M.toBilin'.Nondegenerate ↔ (Matrix.toBilin b M).Nondegenerate :=\n  (nondegenerate_congr_iff b.equivFun.symm).symm\n\n-- Lemmas transferring nondegeneracy between a matrix and its associated bilinear form\n"}
{"name":"Matrix.Nondegenerate.toBilin'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₂\nh : M.Nondegenerate\n⊢ (Matrix.toBilin' M).Nondegenerate","decl":"theorem _root_.Matrix.Nondegenerate.toBilin' {M : Matrix ι ι R₂} (h : M.Nondegenerate) :\n    M.toBilin'.Nondegenerate := fun x hx =>\n  h.eq_zero_of_ortho fun y => by simpa only [toBilin'_apply'] using hx y\n\n"}
{"name":"Matrix.nondegenerate_toBilin'_iff","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₂\n⊢ Iff (Matrix.toBilin' M).Nondegenerate M.Nondegenerate","decl":"@[simp]\ntheorem _root_.Matrix.nondegenerate_toBilin'_iff {M : Matrix ι ι R₂} :\n    M.toBilin'.Nondegenerate ↔ M.Nondegenerate :=\n  ⟨fun h v hv => h v fun w => (M.toBilin'_apply' _ _).trans <| hv w, Matrix.Nondegenerate.toBilin'⟩\n\n"}
{"name":"Matrix.Nondegenerate.toBilin","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R₂ M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₂\nh : M.Nondegenerate\nb : Basis ι R₂ M₂\n⊢ ((Matrix.toBilin b) M).Nondegenerate","decl":"theorem _root_.Matrix.Nondegenerate.toBilin {M : Matrix ι ι R₂} (h : M.Nondegenerate)\n    (b : Basis ι R₂ M₂) : (Matrix.toBilin b M).Nondegenerate :=\n  (Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin b).mp h.toBilin'\n\n"}
{"name":"Matrix.nondegenerate_toBilin_iff","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R₂ M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι R₂\nb : Basis ι R₂ M₂\n⊢ Iff ((Matrix.toBilin b) M).Nondegenerate M.Nondegenerate","decl":"@[simp]\ntheorem _root_.Matrix.nondegenerate_toBilin_iff {M : Matrix ι ι R₂} (b : Basis ι R₂ M₂) :\n    (Matrix.toBilin b M).Nondegenerate ↔ M.Nondegenerate := by\n  rw [← Matrix.nondegenerate_toBilin'_iff_nondegenerate_toBilin, Matrix.nondegenerate_toBilin'_iff]\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_toMatrix'_iff","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap.BilinForm R₂ (ι → R₂)\n⊢ Iff (LinearMap.BilinForm.toMatrix' B).Nondegenerate B.Nondegenerate","decl":"@[simp]\ntheorem nondegenerate_toMatrix'_iff {B : BilinForm R₂ (ι → R₂)} :\n    B.toMatrix'.Nondegenerate (m := ι) ↔ B.Nondegenerate :=\n  Matrix.nondegenerate_toBilin'_iff.symm.trans <| (Matrix.toBilin'_toMatrix' B).symm ▸ Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\ninst✝² : CommRing R₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap.BilinForm R₂ (ι → R₂)\nh : B.Nondegenerate\n⊢ (LinearMap.BilinForm.toMatrix' B).Nondegenerate","decl":"theorem Nondegenerate.toMatrix' {B : BilinForm R₂ (ι → R₂)} (h : B.Nondegenerate) :\n    B.toMatrix'.Nondegenerate :=\n  nondegenerate_toMatrix'_iff.mpr h\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_toMatrix_iff","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R₂ M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap.BilinForm R₂ M₂\nb : Basis ι R₂ M₂\n⊢ Iff ((BilinForm.toMatrix b) B).Nondegenerate B.Nondegenerate","decl":"@[simp]\ntheorem nondegenerate_toMatrix_iff {B : BilinForm R₂ M₂} (b : Basis ι R₂ M₂) :\n    (BilinForm.toMatrix b B).Nondegenerate ↔ B.Nondegenerate :=\n  (Matrix.nondegenerate_toBilin_iff b).symm.trans <| (Matrix.toBilin_toMatrix b B).symm ▸ Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.toMatrix","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"R₂ : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R₂ M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap.BilinForm R₂ M₂\nh : B.Nondegenerate\nb : Basis ι R₂ M₂\n⊢ ((BilinForm.toMatrix b) B).Nondegenerate","decl":"theorem Nondegenerate.toMatrix {B : BilinForm R₂ M₂} (h : B.Nondegenerate) (b : Basis ι R₂ M₂) :\n    (BilinForm.toMatrix b B).Nondegenerate :=\n  (nondegenerate_toMatrix_iff b).mpr h\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_toBilin'_iff_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"A : Type u_5\ninst✝³ : CommRing A\ninst✝² : IsDomain A\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι A\n⊢ Iff (Matrix.toBilin' M).Nondegenerate (Ne M.det 0)","decl":"theorem nondegenerate_toBilin'_iff_det_ne_zero {M : Matrix ι ι A} :\n    M.toBilin'.Nondegenerate ↔ M.det ≠ 0 := by\n  rw [Matrix.nondegenerate_toBilin'_iff, Matrix.nondegenerate_iff_det_ne_zero]\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_toBilin'_of_det_ne_zero'","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"A : Type u_5\ninst✝³ : CommRing A\ninst✝² : IsDomain A\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nM : Matrix ι ι A\nh : Ne M.det 0\n⊢ (Matrix.toBilin' M).Nondegenerate","decl":"theorem nondegenerate_toBilin'_of_det_ne_zero' (M : Matrix ι ι A) (h : M.det ≠ 0) :\n    M.toBilin'.Nondegenerate :=\n  nondegenerate_toBilin'_iff_det_ne_zero.mpr h\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_iff_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"M₂ : Type u_4\ninst✝⁵ : AddCommGroup M₂\nA : Type u_5\ninst✝⁴ : CommRing A\ninst✝³ : IsDomain A\ninst✝² : Module A M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nB : LinearMap.BilinForm A M₂\nb : Basis ι A M₂\n⊢ Iff B.Nondegenerate (Ne ((BilinForm.toMatrix b) B).det 0)","decl":"theorem nondegenerate_iff_det_ne_zero {B : BilinForm A M₂} (b : Basis ι A M₂) :\n    B.Nondegenerate ↔ (BilinForm.toMatrix b B).det ≠ 0 := by\n  rw [← Matrix.nondegenerate_iff_det_ne_zero, nondegenerate_toMatrix_iff]\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.BilinearForm","initialProofState":"M₂ : Type u_4\ninst✝⁵ : AddCommGroup M₂\nA : Type u_5\ninst✝⁴ : CommRing A\ninst✝³ : IsDomain A\ninst✝² : Module A M₂\nB₃ : LinearMap.BilinForm A M₂\nι : Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι A M₂\nh : Ne ((BilinForm.toMatrix b) B₃).det 0\n⊢ B₃.Nondegenerate","decl":"theorem nondegenerate_of_det_ne_zero (b : Basis ι A M₂) (h : (BilinForm.toMatrix b B₃).det ≠ 0) :\n    B₃.Nondegenerate :=\n  (nondegenerate_iff_det_ne_zero b).mpr h\n\n"}
