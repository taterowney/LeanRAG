{"name":"ENNReal.div_eq_inv_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul (Inv.inv b) a)","decl":"protected theorem div_eq_inv_mul : a / b = b⁻¹ * a := by rw [div_eq_mul_inv, mul_comm]\n\n"}
{"name":"ENNReal.inv_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (Inv.inv 0) Top.top","decl":"@[simp] theorem inv_zero : (0 : ℝ≥0∞)⁻¹ = ∞ :=\n  show sInf { b : ℝ≥0∞ | 1 ≤ 0 * b } = ∞ by simp\n\n"}
{"name":"ENNReal.inv_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (Inv.inv Top.top) 0","decl":"@[simp] theorem inv_top : ∞⁻¹ = 0 :=\n  bot_unique <| le_of_forall_gt_imp_ge_of_dense fun a (h : 0 < a) => sInf_le <| by\n    simp [*, h.ne', top_mul]\n\n"}
{"name":"ENNReal.coe_inv_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"r : NNReal\n⊢ LE.le (↑(Inv.inv r)) (Inv.inv ↑r)","decl":"theorem coe_inv_le : (↑r⁻¹ : ℝ≥0∞) ≤ (↑r)⁻¹ :=\n  le_sInf fun b (hb : 1 ≤ ↑r * b) =>\n    coe_le_iff.2 <| by\n      rintro b rfl\n      apply NNReal.inv_le_of_le_mul\n      rwa [← coe_mul, ← coe_one, coe_le_coe] at hb\n\n"}
{"name":"ENNReal.coe_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"r : NNReal\nhr : Ne r 0\n⊢ Eq (↑(Inv.inv r)) (Inv.inv ↑r)","decl":"@[simp, norm_cast]\ntheorem coe_inv (hr : r ≠ 0) : (↑r⁻¹ : ℝ≥0∞) = (↑r)⁻¹ :=\n  coe_inv_le.antisymm <| sInf_le <| mem_setOf.2 <| by rw [← coe_mul, mul_inv_cancel₀ hr, coe_one]\n\n"}
{"name":"ENNReal.coe_inv_two","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (↑(Inv.inv 2)) (Inv.inv 2)","decl":"@[norm_cast]\ntheorem coe_inv_two : ((2⁻¹ : ℝ≥0) : ℝ≥0∞) = 2⁻¹ := by rw [coe_inv _root_.two_ne_zero, coe_two]\n\n"}
{"name":"ENNReal.coe_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"r p : NNReal\nhr : Ne r 0\n⊢ Eq (↑(HDiv.hDiv p r)) (HDiv.hDiv ↑p ↑r)","decl":"@[simp, norm_cast]\ntheorem coe_div (hr : r ≠ 0) : (↑(p / r) : ℝ≥0∞) = p / r := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, coe_mul, coe_inv hr]\n\n"}
{"name":"ENNReal.coe_div_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"r p : NNReal\n⊢ LE.le (↑(HDiv.hDiv p r)) (HDiv.hDiv ↑p ↑r)","decl":"lemma coe_div_le : ↑(p / r) ≤ (p / r : ℝ≥0∞) := by\n  simpa only [div_eq_mul_inv, coe_mul] using mul_le_mul_left' coe_inv_le _\n\n"}
{"name":"ENNReal.div_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : Ne a 0\n⊢ Eq (HDiv.hDiv a 0) Top.top","decl":"theorem div_zero (h : a ≠ 0) : a / 0 = ∞ := by simp [div_eq_mul_inv, h]\n\n"}
{"name":"ENNReal.inv_pow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nn : Nat\n⊢ Eq (Inv.inv (HPow.hPow a n)) (HPow.hPow (Inv.inv a) n)","decl":"protected theorem inv_pow : ∀ {a : ℝ≥0∞} {n : ℕ}, (a ^ n)⁻¹ = a⁻¹ ^ n\n  | _, 0 => by simp only [pow_zero, inv_one]\n  | ⊤, n + 1 => by simp [top_pow]\n  | (a : ℝ≥0), n + 1 => by\n    rcases eq_or_ne a 0 with (rfl | ha)\n    · simp [top_pow]\n    · have := pow_ne_zero (n + 1) ha\n      norm_cast\n      rw [inv_pow]\n\n"}
{"name":"ENNReal.mul_inv_cancel","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh0 : Ne a 0\nht : Ne a Top.top\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"protected theorem mul_inv_cancel (h0 : a ≠ 0) (ht : a ≠ ∞) : a * a⁻¹ = 1 := by\n  lift a to ℝ≥0 using ht\n  norm_cast at h0; norm_cast\n  exact mul_inv_cancel₀ h0\n\n"}
{"name":"ENNReal.inv_mul_cancel","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh0 : Ne a 0\nht : Ne a Top.top\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"protected theorem inv_mul_cancel (h0 : a ≠ 0) (ht : a ≠ ∞) : a⁻¹ * a = 1 :=\n  mul_comm a a⁻¹ ▸ ENNReal.mul_inv_cancel h0 ht\n\n"}
{"name":"ENNReal.inv_mul_cancel_left'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Eq a 0 → Eq b 0\nha : Eq a Top.top → Eq b 0\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul a b)) b","decl":"/-- See `ENNReal.inv_mul_cancel_left` for a simpler version assuming `a ≠ 0`, `a ≠ ∞`. -/\nprotected lemma inv_mul_cancel_left' (ha₀ : a = 0 → b = 0) (ha : a = ∞ → b = 0) :\n    a⁻¹ * (a * b) = b := by\n  obtain rfl | ha₀ := eq_or_ne a 0\n  · simp_all\n  obtain rfl | ha := eq_or_ne a ⊤\n  · simp_all\n  · simp [← mul_assoc, ENNReal.inv_mul_cancel, *]\n\n"}
{"name":"ENNReal.inv_mul_cancel_left","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul a b)) b","decl":"/-- See `ENNReal.inv_mul_cancel_left'` for a stronger version. -/\nprotected lemma inv_mul_cancel_left (ha₀ : a ≠ 0) (ha : a ≠ ∞) : a⁻¹ * (a * b) = b :=\n  ENNReal.inv_mul_cancel_left' (by simp [ha₀]) (by simp [ha])\n\n"}
{"name":"ENNReal.mul_inv_cancel_left'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Eq a 0 → Eq b 0\nha : Eq a Top.top → Eq b 0\n⊢ Eq (HMul.hMul a (HMul.hMul (Inv.inv a) b)) b","decl":"/-- See `ENNReal.mul_inv_cancel_left` for a simpler version assuming `a ≠ 0`, `a ≠ ∞`. -/\nprotected lemma mul_inv_cancel_left' (ha₀ : a = 0 → b = 0) (ha : a = ∞ → b = 0) :\n    a * (a⁻¹ * b) = b := by\n  obtain rfl | ha₀ := eq_or_ne a 0\n  · simp_all\n  obtain rfl | ha := eq_or_ne a ⊤\n  · simp_all\n  · simp [← mul_assoc, ENNReal.mul_inv_cancel, *]\n\n"}
{"name":"ENNReal.mul_inv_cancel_left","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul a (HMul.hMul (Inv.inv a) b)) b","decl":"/-- See `ENNReal.mul_inv_cancel_left'` for a stronger version. -/\nprotected lemma mul_inv_cancel_left (ha₀ : a ≠ 0) (ha : a ≠ ∞) : a * (a⁻¹ * b) = b :=\n  ENNReal.mul_inv_cancel_left' (by simp [ha₀]) (by simp [ha])\n\n"}
{"name":"ENNReal.mul_inv_cancel_right'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Eq b 0 → Eq a 0\nhb : Eq b Top.top → Eq a 0\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv b)) a","decl":"/-- See `ENNReal.mul_inv_cancel_right` for a simpler version assuming `b ≠ 0`, `b ≠ ∞`. -/\nprotected lemma mul_inv_cancel_right' (hb₀ : b = 0 → a = 0) (hb : b = ∞ → a = 0) :\n    a * b * b⁻¹ = a := by\n  obtain rfl | hb₀ := eq_or_ne b 0\n  · simp_all\n  obtain rfl | hb := eq_or_ne b ⊤\n  · simp_all\n  · simp [mul_assoc, ENNReal.mul_inv_cancel, *]\n\n"}
{"name":"ENNReal.mul_inv_cancel_right","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Ne b 0\nhb : Ne b Top.top\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv b)) a","decl":"/-- See `ENNReal.mul_inv_cancel_right'` for a stronger version. -/\nprotected lemma mul_inv_cancel_right (hb₀ : b ≠ 0) (hb : b ≠ ∞) : a * b * b⁻¹ = a :=\n  ENNReal.mul_inv_cancel_right' (by simp [hb₀]) (by simp [hb])\n\n"}
{"name":"ENNReal.inv_mul_cancel_right'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Eq b 0 → Eq a 0\nhb : Eq b Top.top → Eq a 0\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv b)) b) a","decl":"/-- See `ENNReal.inv_mul_cancel_right` for a simpler version assuming `b ≠ 0`, `b ≠ ∞`. -/\nprotected lemma inv_mul_cancel_right' (hb₀ : b = 0 → a = 0) (hb : b = ∞ → a = 0) :\n    a * b⁻¹ * b = a := by\n  obtain rfl | hb₀ := eq_or_ne b 0\n  · simp_all\n  obtain rfl | hb := eq_or_ne b ⊤\n  · simp_all\n  · simp [mul_assoc, ENNReal.inv_mul_cancel, *]\n\n"}
{"name":"ENNReal.inv_mul_cancel_right","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Ne b 0\nhb : Ne b Top.top\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv b)) b) a","decl":"/-- See `ENNReal.inv_mul_cancel_right'` for a stronger version. -/\nprotected lemma inv_mul_cancel_right (hb₀ : b ≠ 0) (hb : b ≠ ∞) : a * b⁻¹ * b = a :=\n  ENNReal.inv_mul_cancel_right' (by simp [hb₀]) (by simp [hb])\n\n"}
{"name":"ENNReal.mul_div_cancel_right'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Eq b 0 → Eq a 0\nhb : Eq b Top.top → Eq a 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"/-- See `ENNReal.mul_div_cancel_right` for a simpler version assuming `b ≠ 0`, `b ≠ ∞`. -/\nprotected lemma mul_div_cancel_right' (hb₀ : b = 0 → a = 0) (hb : b = ∞ → a = 0) :\n    a * b / b = a := ENNReal.mul_inv_cancel_right' hb₀ hb\n\n"}
{"name":"ENNReal.mul_div_cancel_right","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Ne b 0\nhb : Ne b Top.top\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"/-- See `ENNReal.mul_div_cancel_right'` for a stronger version. -/\nprotected lemma mul_div_cancel_right (hb₀ : b ≠ 0) (hb : b ≠ ∞) : a * b / b = a :=\n  ENNReal.mul_div_cancel_right' (by simp [hb₀]) (by simp [hb])\n\n"}
{"name":"ENNReal.div_mul_cancel'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Eq a 0 → Eq b 0\nha : Eq a Top.top → Eq b 0\n⊢ Eq (HMul.hMul (HDiv.hDiv b a) a) b","decl":"/-- See `ENNReal.div_mul_cancel` for a simpler version assuming `a ≠ 0`, `a ≠ ∞`. -/\nprotected lemma div_mul_cancel' (ha₀ : a = 0 → b = 0) (ha : a = ∞ → b = 0) : b / a * a = b :=\n  ENNReal.inv_mul_cancel_right' ha₀ ha\n\n"}
{"name":"ENNReal.div_mul_cancel","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul (HDiv.hDiv b a) a) b","decl":"/-- See `ENNReal.div_mul_cancel'` for a stronger version. -/\nprotected lemma div_mul_cancel (ha₀ : a ≠ 0) (ha : a ≠ ∞) : b / a * a = b :=\n  ENNReal.div_mul_cancel' (by simp [ha₀]) (by simp [ha])\n\n"}
{"name":"ENNReal.mul_div_cancel'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Eq a 0 → Eq b 0\nha : Eq a Top.top → Eq b 0\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"/-- See `ENNReal.mul_div_cancel` for a simpler version assuming `a ≠ 0`, `a ≠ ∞`. -/\nprotected lemma mul_div_cancel' (ha₀ : a = 0 → b = 0) (ha : a = ∞ → b = 0) : a * (b / a) = b := by\n  rw [mul_comm, ENNReal.div_mul_cancel' ha₀ ha]\n\n"}
{"name":"ENNReal.mul_div_cancel","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"/-- See `ENNReal.mul_div_cancel'` for a stronger version. -/\nprotected lemma mul_div_cancel (ha₀ : a ≠ 0) (ha : a ≠ ∞) : a * (b / a) = b :=\n  ENNReal.mul_div_cancel' (by simp [ha₀]) (by simp [ha])\n\n-- Porting note: `simp only [div_eq_mul_inv, mul_comm, mul_assoc]` doesn't work in the following two\n"}
{"name":"ENNReal.mul_comm_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HMul.hMul a (HDiv.hDiv c b))","decl":"protected theorem mul_comm_div : a / b * c = a * (c / b) := by\n  simp only [div_eq_mul_inv, mul_right_comm, ← mul_assoc]\n\n"}
{"name":"ENNReal.mul_div_right_comm","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) c) (HMul.hMul (HDiv.hDiv a c) b)","decl":"protected theorem mul_div_right_comm : a * b / c = a / c * b := by\n  simp only [div_eq_mul_inv, mul_right_comm]\n\n"}
{"name":"ENNReal.inv_eq_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (Eq (Inv.inv a) 1) (Eq a 1)","decl":"@[simp] protected lemma inv_eq_one : a⁻¹ = 1 ↔ a = 1 := by rw [← inv_inj, inv_inv, inv_one]\n\n"}
{"name":"ENNReal.inv_eq_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (Eq (Inv.inv a) Top.top) (Eq a 0)","decl":"@[simp] theorem inv_eq_top : a⁻¹ = ∞ ↔ a = 0 := inv_zero ▸ inv_inj\n\n"}
{"name":"ENNReal.inv_ne_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (Ne (Inv.inv a) Top.top) (Ne a 0)","decl":"theorem inv_ne_top : a⁻¹ ≠ ∞ ↔ a ≠ 0 := by simp\n\n"}
{"name":"ENNReal.Finiteness.inv_ne_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\na✝ : Ne a 0\n⊢ Ne (Inv.inv a) Top.top","decl":"@[aesop (rule_sets := [finiteness]) safe apply]\nprotected alias ⟨_, Finiteness.inv_ne_top⟩ := ENNReal.inv_ne_top\n\n"}
{"name":"ENNReal.inv_lt_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt (Inv.inv x) Top.top) (LT.lt 0 x)","decl":"@[simp]\ntheorem inv_lt_top {x : ℝ≥0∞} : x⁻¹ < ∞ ↔ 0 < x := by\n  simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]\n\n"}
{"name":"ENNReal.div_lt_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y : ENNReal\nh1 : Ne x Top.top\nh2 : Ne y 0\n⊢ LT.lt (HDiv.hDiv x y) Top.top","decl":"theorem div_lt_top {x y : ℝ≥0∞} (h1 : x ≠ ∞) (h2 : y ≠ 0) : x / y < ∞ :=\n  mul_lt_top h1.lt_top (inv_ne_top.mpr h2).lt_top\n\n"}
{"name":"ENNReal.inv_eq_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (Eq (Inv.inv a) 0) (Eq a Top.top)","decl":"@[simp]\nprotected theorem inv_eq_zero : a⁻¹ = 0 ↔ a = ∞ :=\n  inv_top ▸ inv_inj\n\n"}
{"name":"ENNReal.inv_ne_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (Ne (Inv.inv a) 0) (Ne a Top.top)","decl":"protected theorem inv_ne_zero : a⁻¹ ≠ 0 ↔ a ≠ ∞ := by simp\n\n"}
{"name":"ENNReal.div_pos","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Ne a 0\nhb : Ne b Top.top\n⊢ LT.lt 0 (HDiv.hDiv a b)","decl":"protected theorem div_pos (ha : a ≠ 0) (hb : b ≠ ∞) : 0 < a / b :=\n  ENNReal.mul_pos ha <| ENNReal.inv_ne_zero.2 hb\n\n"}
{"name":"ENNReal.inv_mul_le_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y z : ENNReal\nh1 : Ne x 0\nh2 : Ne x Top.top\n⊢ Iff (LE.le (HMul.hMul (Inv.inv x) y) z) (LE.le y (HMul.hMul x z))","decl":"protected theorem inv_mul_le_iff {x y z : ℝ≥0∞} (h1 : x ≠ 0) (h2 : x ≠ ∞) :\n    x⁻¹ * y ≤ z ↔ y ≤ x * z := by\n  rw [← mul_le_mul_left h1 h2, ← mul_assoc, ENNReal.mul_inv_cancel h1 h2, one_mul]\n\n"}
{"name":"ENNReal.mul_inv_le_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y z : ENNReal\nh1 : Ne y 0\nh2 : Ne y Top.top\n⊢ Iff (LE.le (HMul.hMul x (Inv.inv y)) z) (LE.le x (HMul.hMul z y))","decl":"protected theorem mul_inv_le_iff {x y z : ℝ≥0∞} (h1 : y ≠ 0) (h2 : y ≠ ∞) :\n    x * y⁻¹ ≤ z ↔ x ≤ z * y := by\n  rw [mul_comm, ENNReal.inv_mul_le_iff h1 h2, mul_comm]\n\n"}
{"name":"ENNReal.div_le_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y z : ENNReal\nh1 : Ne y 0\nh2 : Ne y Top.top\n⊢ Iff (LE.le (HDiv.hDiv x y) z) (LE.le x (HMul.hMul z y))","decl":"protected theorem div_le_iff {x y z : ℝ≥0∞} (h1 : y ≠ 0) (h2 : y ≠ ∞) :\n    x / y ≤ z ↔ x ≤ z * y := by\n  rw [div_eq_mul_inv, ENNReal.mul_inv_le_iff h1 h2]\n\n"}
{"name":"ENNReal.div_le_iff'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y z : ENNReal\nh1 : Ne y 0\nh2 : Ne y Top.top\n⊢ Iff (LE.le (HDiv.hDiv x y) z) (LE.le x (HMul.hMul y z))","decl":"protected theorem div_le_iff' {x y z : ℝ≥0∞} (h1 : y ≠ 0) (h2 : y ≠ ∞) :\n    x / y ≤ z ↔ x ≤ y * z := by\n  rw [mul_comm, ENNReal.div_le_iff h1 h2]\n\n"}
{"name":"ENNReal.mul_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Or (Ne a 0) (Ne b Top.top)\nhb : Or (Ne a Top.top) (Ne b 0)\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv a) (Inv.inv b))","decl":"protected theorem mul_inv {a b : ℝ≥0∞} (ha : a ≠ 0 ∨ b ≠ ∞) (hb : a ≠ ∞ ∨ b ≠ 0) :\n    (a * b)⁻¹ = a⁻¹ * b⁻¹ := by\n  induction' b with b\n  · replace ha : a ≠ 0 := ha.neg_resolve_right rfl\n    simp [ha]\n  induction' a with a\n  · replace hb : b ≠ 0 := coe_ne_zero.1 (hb.neg_resolve_left rfl)\n    simp [hb]\n  by_cases h'a : a = 0\n  · simp only [h'a, top_mul, ENNReal.inv_zero, ENNReal.coe_ne_top, zero_mul, Ne,\n      not_false_iff, ENNReal.coe_zero, ENNReal.inv_eq_zero]\n  by_cases h'b : b = 0\n  · simp only [h'b, ENNReal.inv_zero, ENNReal.coe_ne_top, mul_top, Ne, not_false_iff,\n      mul_zero, ENNReal.coe_zero, ENNReal.inv_eq_zero]\n  rw [← ENNReal.coe_mul, ← ENNReal.coe_inv, ← ENNReal.coe_inv h'a, ← ENNReal.coe_inv h'b, ←\n    ENNReal.coe_mul, mul_inv_rev, mul_comm]\n  simp [h'a, h'b]\n\n"}
{"name":"ENNReal.inv_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhtop : Or (Ne b Top.top) (Ne a Top.top)\nhzero : Or (Ne b 0) (Ne a 0)\n⊢ Eq (Inv.inv (HDiv.hDiv a b)) (HDiv.hDiv b a)","decl":"protected theorem inv_div {a b : ℝ≥0∞} (htop : b ≠ ∞ ∨ a ≠ ∞) (hzero : b ≠ 0 ∨ a ≠ 0) :\n    (a / b)⁻¹ = b / a := by\n  rw [← ENNReal.inv_ne_zero] at htop\n  rw [← ENNReal.inv_ne_top] at hzero\n  rw [ENNReal.div_eq_inv_mul, ENNReal.div_eq_inv_mul, ENNReal.mul_inv htop hzero, mul_comm, inv_inv]\n\n"}
{"name":"ENNReal.prod_inv_distrib","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Type u_1\nf : ι → ENNReal\ns : Finset ι\nhf : (↑s).Pairwise fun i j => Or (Ne (f i) 0) (Ne (f j) Top.top)\n⊢ Eq (Inv.inv (s.prod fun i => f i)) (s.prod fun i => Inv.inv (f i))","decl":"lemma prod_inv_distrib {ι : Type*} {f : ι → ℝ≥0∞} {s : Finset ι}\n    (hf : s.toSet.Pairwise fun i j ↦ f i ≠ 0 ∨ f j ≠ ∞) : (∏ i ∈ s, f i)⁻¹ = ∏ i ∈ s, (f i)⁻¹ := by\n  induction' s using Finset.cons_induction with i s hi ih\n  · simp\n  simp [← ih (hf.mono <| by simp)]\n  refine ENNReal.mul_inv (not_or_of_imp fun hi₀ ↦ prod_ne_top fun j hj ↦ ?_)\n    (not_or_of_imp fun hi₀ ↦ Finset.prod_ne_zero_iff.2 fun j hj ↦ ?_)\n  · exact imp_iff_not_or.2 (hf (by simp) (by simp [hj]) <| .symm <| ne_of_mem_of_not_mem hj hi) hi₀\n  · exact imp_iff_not_or.2 (hf (by simp [hj]) (by simp) <| ne_of_mem_of_not_mem hj hi).symm hi₀\n\n"}
{"name":"ENNReal.mul_div_mul_left","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"c a b : ENNReal\nhc : Ne c 0\nhc' : Ne c Top.top\n⊢ Eq (HDiv.hDiv (HMul.hMul c a) (HMul.hMul c b)) (HDiv.hDiv a b)","decl":"protected theorem mul_div_mul_left (a b : ℝ≥0∞) (hc : c ≠ 0) (hc' : c ≠ ⊤) :\n    c * a / (c * b) = a / b := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inl hc) (Or.inl hc'), mul_mul_mul_comm,\n    ENNReal.mul_inv_cancel hc hc', one_mul]\n\n"}
{"name":"ENNReal.mul_div_mul_right","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"c a b : ENNReal\nhc : Ne c 0\nhc' : Ne c Top.top\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b c)) (HDiv.hDiv a b)","decl":"protected theorem mul_div_mul_right (a b : ℝ≥0∞) (hc : c ≠ 0) (hc' : c ≠ ⊤) :\n    a * c / (b * c) = a / b := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (Or.inr hc') (Or.inr hc), mul_mul_mul_comm,\n    ENNReal.mul_inv_cancel hc hc', mul_one]\n\n"}
{"name":"ENNReal.sub_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LT.lt 0 b → LT.lt b a → Ne c 0\n⊢ Eq (HDiv.hDiv (HSub.hSub a b) c) (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"protected theorem sub_div (h : 0 < b → b < a → c ≠ 0) : (a - b) / c = a / c - b / c := by\n  simp_rw [div_eq_mul_inv]\n  exact ENNReal.sub_mul (by simpa using h)\n\n"}
{"name":"ENNReal.inv_pos","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt 0 (Inv.inv a)) (Ne a Top.top)","decl":"@[simp]\nprotected theorem inv_pos : 0 < a⁻¹ ↔ a ≠ ∞ :=\n  pos_iff_ne_zero.trans ENNReal.inv_ne_zero\n\n"}
{"name":"ENNReal.inv_strictAnti","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ StrictAnti Inv.inv","decl":"theorem inv_strictAnti : StrictAnti (Inv.inv : ℝ≥0∞ → ℝ≥0∞) := by\n  intro a b h\n  lift a to ℝ≥0 using h.ne_top\n  induction b; · simp\n  rw [coe_lt_coe] at h\n  rcases eq_or_ne a 0 with (rfl | ha); · simp [h]\n  rw [← coe_inv h.ne_bot, ← coe_inv ha, coe_lt_coe]\n  exact NNReal.inv_lt_inv ha h\n\n"}
{"name":"ENNReal.inv_lt_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt (Inv.inv a) (Inv.inv b)) (LT.lt b a)","decl":"@[simp]\nprotected theorem inv_lt_inv : a⁻¹ < b⁻¹ ↔ b < a :=\n  inv_strictAnti.lt_iff_lt\n\n"}
{"name":"ENNReal.inv_lt_iff_inv_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt (Inv.inv a) b) (LT.lt (Inv.inv b) a)","decl":"theorem inv_lt_iff_inv_lt : a⁻¹ < b ↔ b⁻¹ < a := by\n  simpa only [inv_inv] using @ENNReal.inv_lt_inv a b⁻¹\n\n"}
{"name":"ENNReal.lt_inv_iff_lt_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a (Inv.inv b)) (LT.lt b (Inv.inv a))","decl":"theorem lt_inv_iff_lt_inv : a < b⁻¹ ↔ b < a⁻¹ := by\n  simpa only [inv_inv] using @ENNReal.inv_lt_inv a⁻¹ b\n\n"}
{"name":"ENNReal.inv_le_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LE.le (Inv.inv a) (Inv.inv b)) (LE.le b a)","decl":"@[simp]\nprotected theorem inv_le_inv : a⁻¹ ≤ b⁻¹ ↔ b ≤ a :=\n  inv_strictAnti.le_iff_le\n\n"}
{"name":"ENNReal.inv_le_iff_inv_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LE.le (Inv.inv a) b) (LE.le (Inv.inv b) a)","decl":"theorem inv_le_iff_inv_le : a⁻¹ ≤ b ↔ b⁻¹ ≤ a := by\n  simpa only [inv_inv] using @ENNReal.inv_le_inv a b⁻¹\n\n"}
{"name":"ENNReal.le_inv_iff_le_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LE.le a (Inv.inv b)) (LE.le b (Inv.inv a))","decl":"theorem le_inv_iff_le_inv : a ≤ b⁻¹ ↔ b ≤ a⁻¹ := by\n  simpa only [inv_inv] using @ENNReal.inv_le_inv a⁻¹ b\n\n"}
{"name":"ENNReal.inv_le_inv'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh : LE.le a b\n⊢ LE.le (Inv.inv b) (Inv.inv a)","decl":"@[gcongr] protected theorem inv_le_inv' (h : a ≤ b) : b⁻¹ ≤ a⁻¹ :=\n  ENNReal.inv_strictAnti.antitone h\n\n"}
{"name":"ENNReal.inv_lt_inv'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh : LT.lt a b\n⊢ LT.lt (Inv.inv b) (Inv.inv a)","decl":"@[gcongr] protected theorem inv_lt_inv' (h : a < b) : b⁻¹ < a⁻¹ := ENNReal.inv_strictAnti h\n\n"}
{"name":"ENNReal.inv_le_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (LE.le (Inv.inv a) 1) (LE.le 1 a)","decl":"@[simp]\nprotected theorem inv_le_one : a⁻¹ ≤ 1 ↔ 1 ≤ a := by rw [inv_le_iff_inv_le, inv_one]\n\n"}
{"name":"ENNReal.one_le_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (LE.le 1 (Inv.inv a)) (LE.le a 1)","decl":"protected theorem one_le_inv : 1 ≤ a⁻¹ ↔ a ≤ 1 := by rw [le_inv_iff_le_inv, inv_one]\n\n"}
{"name":"ENNReal.inv_lt_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt (Inv.inv a) 1) (LT.lt 1 a)","decl":"@[simp]\nprotected theorem inv_lt_one : a⁻¹ < 1 ↔ 1 < a := by rw [inv_lt_iff_inv_lt, inv_one]\n\n"}
{"name":"ENNReal.one_lt_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt 1 (Inv.inv a)) (LT.lt a 1)","decl":"@[simp]\nprotected theorem one_lt_inv : 1 < a⁻¹ ↔ a < 1 := by rw [lt_inv_iff_lt_inv, inv_one]\n\n"}
{"name":"OrderIso.invENNReal_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a✝ : ENNReal\n⊢ Eq (OrderIso.invENNReal a✝) (Inv.inv (OrderDual.toDual a✝))","decl":"/-- The inverse map `fun x ↦ x⁻¹` is an order isomorphism between `ℝ≥0∞` and its `OrderDual` -/\n@[simps! apply]\ndef _root_.OrderIso.invENNReal : ℝ≥0∞ ≃o ℝ≥0∞ᵒᵈ where\n  map_rel_iff' := ENNReal.inv_le_inv\n  toEquiv := (Equiv.inv ℝ≥0∞).trans OrderDual.toDual\n\n"}
{"name":"OrderIso.invENNReal_symm_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : OrderDual ENNReal\n⊢ Eq (OrderIso.invENNReal.symm a) (Inv.inv (OrderDual.ofDual a))","decl":"@[simp]\ntheorem _root_.OrderIso.invENNReal_symm_apply (a : ℝ≥0∞ᵒᵈ) :\n    OrderIso.invENNReal.symm a = (OrderDual.ofDual a)⁻¹ :=\n  rfl\n\n"}
{"name":"ENNReal.div_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (HDiv.hDiv a Top.top) 0","decl":"@[simp] theorem div_top : a / ∞ = 0 := by rw [div_eq_mul_inv, inv_top, mul_zero]\n\n-- Porting note: reordered 4 lemmas\n\n"}
{"name":"ENNReal.top_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (HDiv.hDiv Top.top a) (ite (Eq a Top.top) 0 Top.top)","decl":"theorem top_div : ∞ / a = if a = ∞ then 0 else ∞ := by simp [div_eq_mul_inv, top_mul']\n\n"}
{"name":"ENNReal.top_div_of_ne_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : Ne a Top.top\n⊢ Eq (HDiv.hDiv Top.top a) Top.top","decl":"theorem top_div_of_ne_top (h : a ≠ ∞) : ∞ / a = ∞ := by simp [top_div, h]\n\n"}
{"name":"ENNReal.top_div_coe","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"p : NNReal\n⊢ Eq (HDiv.hDiv Top.top ↑p) Top.top","decl":"@[simp] theorem top_div_coe : ∞ / p = ∞ := top_div_of_ne_top coe_ne_top\n\n"}
{"name":"ENNReal.top_div_of_lt_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : LT.lt a Top.top\n⊢ Eq (HDiv.hDiv Top.top a) Top.top","decl":"theorem top_div_of_lt_top (h : a < ∞) : ∞ / a = ∞ := top_div_of_ne_top h.ne\n\n"}
{"name":"ENNReal.zero_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (HDiv.hDiv 0 a) 0","decl":"@[simp] protected theorem zero_div : 0 / a = 0 := zero_mul a⁻¹\n\n"}
{"name":"ENNReal.div_eq_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (HDiv.hDiv a b) Top.top) (Or (And (Ne a 0) (Eq b 0)) (And (Eq a Top.top) (Ne b Top.top)))","decl":"theorem div_eq_top : a / b = ∞ ↔ a ≠ 0 ∧ b = 0 ∨ a = ∞ ∧ b ≠ ∞ := by\n  simp [div_eq_mul_inv, ENNReal.mul_eq_top]\n\n"}
{"name":"ENNReal.le_div_iff_mul_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh0 : Or (Ne b 0) (Ne c 0)\nht : Or (Ne b Top.top) (Ne c Top.top)\n⊢ Iff (LE.le a (HDiv.hDiv c b)) (LE.le (HMul.hMul a b) c)","decl":"protected theorem le_div_iff_mul_le (h0 : b ≠ 0 ∨ c ≠ 0) (ht : b ≠ ∞ ∨ c ≠ ∞) :\n    a ≤ c / b ↔ a * b ≤ c := by\n  induction' b with b\n  · lift c to ℝ≥0 using ht.neg_resolve_left rfl\n    rw [div_top, nonpos_iff_eq_zero]\n    rcases eq_or_ne a 0 with (rfl | ha) <;> simp [*]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · have hc : c ≠ 0 := h0.neg_resolve_left rfl\n    simp [div_zero hc]\n  · rw [← coe_ne_zero] at hb\n    rw [← ENNReal.mul_le_mul_right hb coe_ne_top, ENNReal.div_mul_cancel hb coe_ne_top]\n\n"}
{"name":"ENNReal.div_le_iff_le_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nhb0 : Or (Ne b 0) (Ne c Top.top)\nhbt : Or (Ne b Top.top) (Ne c 0)\n⊢ Iff (LE.le (HDiv.hDiv a b) c) (LE.le a (HMul.hMul c b))","decl":"protected theorem div_le_iff_le_mul (hb0 : b ≠ 0 ∨ c ≠ ∞) (hbt : b ≠ ∞ ∨ c ≠ 0) :\n    a / b ≤ c ↔ a ≤ c * b := by\n  suffices a * b⁻¹ ≤ c ↔ a ≤ c / b⁻¹ by simpa [div_eq_mul_inv]\n  refine (ENNReal.le_div_iff_mul_le ?_ ?_).symm <;> simpa\n\n"}
{"name":"ENNReal.lt_div_iff_mul_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nhb0 : Or (Ne b 0) (Ne c Top.top)\nhbt : Or (Ne b Top.top) (Ne c 0)\n⊢ Iff (LT.lt c (HDiv.hDiv a b)) (LT.lt (HMul.hMul c b) a)","decl":"protected theorem lt_div_iff_mul_lt (hb0 : b ≠ 0 ∨ c ≠ ∞) (hbt : b ≠ ∞ ∨ c ≠ 0) :\n    c < a / b ↔ c * b < a :=\n  lt_iff_lt_of_le_iff_le (ENNReal.div_le_iff_le_mul hb0 hbt)\n\n"}
{"name":"ENNReal.div_le_of_le_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LE.le a (HMul.hMul b c)\n⊢ LE.le (HDiv.hDiv a c) b","decl":"theorem div_le_of_le_mul (h : a ≤ b * c) : a / c ≤ b := by\n  by_cases h0 : c = 0\n  · have : a = 0 := by simpa [h0] using h\n    simp [*]\n  by_cases hinf : c = ∞; · simp [hinf]\n  exact (ENNReal.div_le_iff_le_mul (Or.inl h0) (Or.inl hinf)).2 h\n\n"}
{"name":"ENNReal.div_le_of_le_mul'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LE.le a (HMul.hMul b c)\n⊢ LE.le (HDiv.hDiv a b) c","decl":"theorem div_le_of_le_mul' (h : a ≤ b * c) : a / b ≤ c :=\n  div_le_of_le_mul <| mul_comm b c ▸ h\n\n"}
{"name":"ENNReal.div_self_le_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ LE.le (HDiv.hDiv a a) 1","decl":"@[simp] protected theorem div_self_le_one : a / a ≤ 1 := div_le_of_le_mul <| by rw [one_mul]\n\n"}
{"name":"ENNReal.mul_inv_le_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ LE.le (HMul.hMul a (Inv.inv a)) 1","decl":"@[simp] protected lemma mul_inv_le_one (a : ℝ≥0∞) : a * a⁻¹ ≤ 1 := ENNReal.div_self_le_one\n"}
{"name":"ENNReal.inv_mul_le_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ LE.le (HMul.hMul (Inv.inv a) a) 1","decl":"@[simp] protected lemma inv_mul_le_one (a : ℝ≥0∞) : a⁻¹ * a ≤ 1 := by simp [mul_comm]\n\n"}
{"name":"ENNReal.mul_inv_ne_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Ne (HMul.hMul a (Inv.inv a)) Top.top","decl":"@[simp] lemma mul_inv_ne_top (a : ℝ≥0∞) : a * a⁻¹ ≠ ⊤ :=\n  ne_top_of_le_ne_top one_ne_top a.mul_inv_le_one\n\n"}
{"name":"ENNReal.inv_mul_ne_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Ne (HMul.hMul (Inv.inv a) a) Top.top","decl":"@[simp] lemma inv_mul_ne_top (a : ℝ≥0∞) : a⁻¹ * a ≠ ⊤ := by simp [mul_comm]\n\n"}
{"name":"ENNReal.mul_le_of_le_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LE.le a (HDiv.hDiv b c)\n⊢ LE.le (HMul.hMul a c) b","decl":"theorem mul_le_of_le_div (h : a ≤ b / c) : a * c ≤ b := by\n  rw [← inv_inv c]\n  exact div_le_of_le_mul h\n\n"}
{"name":"ENNReal.mul_le_of_le_div'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LE.le a (HDiv.hDiv b c)\n⊢ LE.le (HMul.hMul c a) b","decl":"theorem mul_le_of_le_div' (h : a ≤ b / c) : c * a ≤ b :=\n  mul_comm a c ▸ mul_le_of_le_div h\n\n"}
{"name":"ENNReal.div_lt_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh0 : Or (Ne b 0) (Ne c 0)\nht : Or (Ne b Top.top) (Ne c Top.top)\n⊢ Iff (LT.lt (HDiv.hDiv c b) a) (LT.lt c (HMul.hMul a b))","decl":"protected theorem div_lt_iff (h0 : b ≠ 0 ∨ c ≠ 0) (ht : b ≠ ∞ ∨ c ≠ ∞) : c / b < a ↔ c < a * b :=\n  lt_iff_lt_of_le_iff_le <| ENNReal.le_div_iff_mul_le h0 ht\n\n"}
{"name":"ENNReal.mul_lt_of_lt_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LT.lt a (HDiv.hDiv b c)\n⊢ LT.lt (HMul.hMul a c) b","decl":"theorem mul_lt_of_lt_div (h : a < b / c) : a * c < b := by\n  contrapose! h\n  exact ENNReal.div_le_of_le_mul h\n\n"}
{"name":"ENNReal.mul_lt_of_lt_div'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LT.lt a (HDiv.hDiv b c)\n⊢ LT.lt (HMul.hMul c a) b","decl":"theorem mul_lt_of_lt_div' (h : a < b / c) : c * a < b :=\n  mul_comm a c ▸ mul_lt_of_lt_div h\n\n"}
{"name":"ENNReal.div_lt_of_lt_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LT.lt a (HMul.hMul b c)\n⊢ LT.lt (HDiv.hDiv a c) b","decl":"theorem div_lt_of_lt_mul (h : a < b * c) : a / c < b :=\n  mul_lt_of_lt_div <| by rwa [div_eq_mul_inv, inv_inv]\n\n"}
{"name":"ENNReal.div_lt_of_lt_mul'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : LT.lt a (HMul.hMul b c)\n⊢ LT.lt (HDiv.hDiv a b) c","decl":"theorem div_lt_of_lt_mul' (h : a < b * c) : a / b < c :=\n  div_lt_of_lt_mul <| by rwa [mul_comm]\n\n"}
{"name":"ENNReal.inv_le_iff_le_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh₁ : Eq b Top.top → Ne a 0\nh₂ : Eq a Top.top → Ne b 0\n⊢ Iff (LE.le (Inv.inv a) b) (LE.le 1 (HMul.hMul a b))","decl":"theorem inv_le_iff_le_mul (h₁ : b = ∞ → a ≠ 0) (h₂ : a = ∞ → b ≠ 0) : a⁻¹ ≤ b ↔ 1 ≤ a * b := by\n  rw [← one_div, ENNReal.div_le_iff_le_mul, mul_comm]\n  exacts [or_not_of_imp h₁, not_or_of_imp h₂]\n\n"}
{"name":"ENNReal.le_inv_iff_mul_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LE.le a (Inv.inv b)) (LE.le (HMul.hMul a b) 1)","decl":"@[simp 900]\ntheorem le_inv_iff_mul_le : a ≤ b⁻¹ ↔ a * b ≤ 1 := by\n  rw [← one_div, ENNReal.le_div_iff_mul_le] <;>\n    · right\n      simp\n\n"}
{"name":"ENNReal.div_le_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c d : ENNReal\nhab : LE.le a b\nhdc : LE.le d c\n⊢ LE.le (HDiv.hDiv a c) (HDiv.hDiv b d)","decl":"@[gcongr] protected theorem div_le_div (hab : a ≤ b) (hdc : d ≤ c) : a / c ≤ b / d :=\n  div_eq_mul_inv b d ▸ div_eq_mul_inv a c ▸ mul_le_mul' hab (ENNReal.inv_le_inv.mpr hdc)\n\n"}
{"name":"ENNReal.div_le_div_left","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh : LE.le a b\nc : ENNReal\n⊢ LE.le (HDiv.hDiv c b) (HDiv.hDiv c a)","decl":"@[gcongr] protected theorem div_le_div_left (h : a ≤ b) (c : ℝ≥0∞) : c / b ≤ c / a :=\n  ENNReal.div_le_div le_rfl h\n\n"}
{"name":"ENNReal.div_le_div_right","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh : LE.le a b\nc : ENNReal\n⊢ LE.le (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"@[gcongr] protected theorem div_le_div_right (h : a ≤ b) (c : ℝ≥0∞) : a / c ≤ b / c :=\n  ENNReal.div_le_div h le_rfl\n\n"}
{"name":"ENNReal.eq_inv_of_mul_eq_one_left","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a (Inv.inv b)","decl":"protected theorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b⁻¹ := by\n  rw [← mul_one a, ← ENNReal.mul_inv_cancel (right_ne_zero_of_mul_eq_one h), ← mul_assoc, h,\n    one_mul]\n  rintro rfl\n  simp [left_ne_zero_of_mul_eq_one h] at h\n\n"}
{"name":"ENNReal.mul_le_iff_le_inv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b r : ENNReal\nhr₀ : Ne r 0\nhr₁ : Ne r Top.top\n⊢ Iff (LE.le (HMul.hMul r a) b) (LE.le a (HMul.hMul (Inv.inv r) b))","decl":"theorem mul_le_iff_le_inv {a b r : ℝ≥0∞} (hr₀ : r ≠ 0) (hr₁ : r ≠ ∞) : r * a ≤ b ↔ a ≤ r⁻¹ * b := by\n  rw [← @ENNReal.mul_le_mul_left _ a _ hr₀ hr₁, ← mul_assoc, ENNReal.mul_inv_cancel hr₀ hr₁,\n    one_mul]\n\n"}
{"name":"ENNReal.instPosSMulStrictMonoNNReal","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ PosSMulStrictMono NNReal ENNReal","decl":"instance : PosSMulStrictMono ℝ≥0 ℝ≥0∞ where\n  elim _r hr _a _b hab := ENNReal.mul_lt_mul_left' (coe_pos.2 hr).ne' coe_ne_top hab\n\n"}
{"name":"ENNReal.instSMulPosMonoNNReal","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ SMulPosMono NNReal ENNReal","decl":"instance : SMulPosMono ℝ≥0 ℝ≥0∞ where\n  elim _r _ _a _b hab := mul_le_mul_right' (coe_le_coe.2 hab) _\n\n"}
{"name":"ENNReal.le_of_forall_nnreal_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y : ENNReal\nh : ∀ (r : NNReal), LT.lt (↑r) x → LE.le (↑r) y\n⊢ LE.le x y","decl":"theorem le_of_forall_nnreal_lt {x y : ℝ≥0∞} (h : ∀ r : ℝ≥0, ↑r < x → ↑r ≤ y) : x ≤ y := by\n  refine le_of_forall_lt_imp_le_of_dense fun r hr => ?_\n  lift r to ℝ≥0 using ne_top_of_lt hr\n  exact h r hr\n\n"}
{"name":"ENNReal.le_of_forall_pos_nnreal_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y : ENNReal\nh : ∀ (r : NNReal), LT.lt 0 r → LT.lt (↑r) x → LE.le (↑r) y\n⊢ LE.le x y","decl":"theorem le_of_forall_pos_nnreal_lt {x y : ℝ≥0∞} (h : ∀ r : ℝ≥0, 0 < r → ↑r < x → ↑r ≤ y) : x ≤ y :=\n  le_of_forall_nnreal_lt fun r hr =>\n    (zero_le r).eq_or_lt.elim (fun h => h ▸ zero_le _) fun h0 => h r h0 hr\n\n"}
{"name":"ENNReal.eq_top_of_forall_nnreal_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nh : ∀ (r : NNReal), LE.le (↑r) x\n⊢ Eq x Top.top","decl":"theorem eq_top_of_forall_nnreal_le {x : ℝ≥0∞} (h : ∀ r : ℝ≥0, ↑r ≤ x) : x = ∞ :=\n  top_unique <| le_of_forall_nnreal_lt fun r _ => h r\n\n"}
{"name":"ENNReal.add_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"protected theorem add_div : (a + b) / c = a / c + b / c :=\n  right_distrib a b c⁻¹\n\n"}
{"name":"ENNReal.div_add_div_same","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv (HAdd.hAdd a b) c)","decl":"protected theorem div_add_div_same {a b c : ℝ≥0∞} : a / c + b / c = (a + b) / c :=\n  ENNReal.add_div.symm\n\n"}
{"name":"ENNReal.div_self","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh0 : Ne a 0\nhI : Ne a Top.top\n⊢ Eq (HDiv.hDiv a a) 1","decl":"protected theorem div_self (h0 : a ≠ 0) (hI : a ≠ ∞) : a / a = 1 :=\n  ENNReal.mul_inv_cancel h0 hI\n\n"}
{"name":"ENNReal.mul_div_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ LE.le (HMul.hMul a (HDiv.hDiv b a)) b","decl":"theorem mul_div_le : a * (b / a) ≤ b :=\n  mul_le_of_le_div' le_rfl\n\n"}
{"name":"ENNReal.eq_div_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nha : Ne a 0\nha' : Ne a Top.top\n⊢ Iff (Eq b (HDiv.hDiv c a)) (Eq (HMul.hMul a b) c)","decl":"theorem eq_div_iff (ha : a ≠ 0) (ha' : a ≠ ∞) : b = c / a ↔ a * b = c :=\n  ⟨fun h => by rw [h, ENNReal.mul_div_cancel ha ha'], fun h => by\n    rw [← h, mul_div_assoc, ENNReal.mul_div_cancel ha ha']⟩\n\n"}
{"name":"ENNReal.div_eq_div_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c d : ENNReal\nha : Ne a 0\nha' : Ne a Top.top\nhb : Ne b 0\nhb' : Ne b Top.top\n⊢ Iff (Eq (HDiv.hDiv c b) (HDiv.hDiv d a)) (Eq (HMul.hMul a c) (HMul.hMul b d))","decl":"protected theorem div_eq_div_iff (ha : a ≠ 0) (ha' : a ≠ ∞) (hb : b ≠ 0) (hb' : b ≠ ∞) :\n    c / b = d / a ↔ a * c = b * d := by\n  rw [eq_div_iff ha ha']\n  conv_rhs => rw [eq_comm]\n  rw [← eq_div_iff hb hb', mul_div_assoc, eq_comm]\n\n"}
{"name":"ENNReal.div_eq_one_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nhb₀ : Ne b 0\nhb₁ : Ne b Top.top\n⊢ Iff (Eq (HDiv.hDiv a b) 1) (Eq a b)","decl":"theorem div_eq_one_iff {a b : ℝ≥0∞} (hb₀ : b ≠ 0) (hb₁ : b ≠ ∞) : a / b = 1 ↔ a = b :=\n  ⟨fun h => by rw [← (eq_div_iff hb₀ hb₁).mp h.symm, mul_one], fun h =>\n    h.symm ▸ ENNReal.div_self hb₀ hb₁⟩\n\n"}
{"name":"ENNReal.inv_two_add_inv_two","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (HAdd.hAdd (Inv.inv 2) (Inv.inv 2)) 1","decl":"theorem inv_two_add_inv_two : (2 : ℝ≥0∞)⁻¹ + 2⁻¹ = 1 := by\n  rw [← two_mul, ← div_eq_mul_inv, ENNReal.div_self two_ne_zero ofNat_ne_top]\n\n"}
{"name":"ENNReal.inv_three_add_inv_three","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (HAdd.hAdd (HAdd.hAdd (Inv.inv 3) (Inv.inv 3)) (Inv.inv 3)) 1","decl":"theorem inv_three_add_inv_three : (3 : ℝ≥0∞)⁻¹ + 3⁻¹ + 3⁻¹ = 1 := by\n  rw [← ENNReal.mul_inv_cancel three_ne_zero ofNat_ne_top]\n  ring\n\n"}
{"name":"ENNReal.add_halves","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a 2) (HDiv.hDiv a 2)) a","decl":"@[simp]\nprotected theorem add_halves (a : ℝ≥0∞) : a / 2 + a / 2 = a := by\n  rw [div_eq_mul_inv, ← mul_add, inv_two_add_inv_two, mul_one]\n\n"}
{"name":"ENNReal.add_thirds","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HDiv.hDiv a 3) (HDiv.hDiv a 3)) (HDiv.hDiv a 3)) a","decl":"@[simp]\ntheorem add_thirds (a : ℝ≥0∞) : a / 3 + a / 3 + a / 3 = a := by\n  rw [div_eq_mul_inv, ← mul_add, ← mul_add, inv_three_add_inv_three, mul_one]\n\n"}
{"name":"ENNReal.div_eq_zero_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (HDiv.hDiv a b) 0) (Or (Eq a 0) (Eq b Top.top))","decl":"@[simp] theorem div_eq_zero_iff : a / b = 0 ↔ a = 0 ∨ b = ∞ := by simp [div_eq_mul_inv]\n\n"}
{"name":"ENNReal.div_pos_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt 0 (HDiv.hDiv a b)) (And (Ne a 0) (Ne b Top.top))","decl":"@[simp] theorem div_pos_iff : 0 < a / b ↔ a ≠ 0 ∧ b ≠ ∞ := by simp [pos_iff_ne_zero, not_or]\n\n"}
{"name":"ENNReal.div_ne_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\n⊢ Iff (Ne (HDiv.hDiv a b) 0) (And (Ne a 0) (Ne b Top.top))","decl":"protected lemma div_ne_zero : a / b ≠ 0 ↔ a ≠ 0 ∧ b ≠ ⊤ := by\n  rw [← pos_iff_ne_zero, div_pos_iff]\n\n"}
{"name":"ENNReal.half_pos","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : Ne a 0\n⊢ LT.lt 0 (HDiv.hDiv a 2)","decl":"protected theorem half_pos (h : a ≠ 0) : 0 < a / 2 :=\n  ENNReal.div_pos h ofNat_ne_top\n\n"}
{"name":"ENNReal.one_half_lt_one","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ LT.lt (Inv.inv 2) 1","decl":"protected theorem one_half_lt_one : (2⁻¹ : ℝ≥0∞) < 1 :=\n  ENNReal.inv_lt_one.2 <| one_lt_two\n\n"}
{"name":"ENNReal.half_lt_self","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nhz : Ne a 0\nht : Ne a Top.top\n⊢ LT.lt (HDiv.hDiv a 2) a","decl":"protected theorem half_lt_self (hz : a ≠ 0) (ht : a ≠ ∞) : a / 2 < a := by\n  lift a to ℝ≥0 using ht\n  rw [coe_ne_zero] at hz\n  rw [← coe_two, ← coe_div, coe_lt_coe]\n  exacts [NNReal.half_lt_self hz, two_ne_zero' _]\n\n"}
{"name":"ENNReal.half_le_self","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ LE.le (HDiv.hDiv a 2) a","decl":"protected theorem half_le_self : a / 2 ≤ a :=\n  le_add_self.trans_eq <| ENNReal.add_halves _\n\n"}
{"name":"ENNReal.sub_half","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : Ne a Top.top\n⊢ Eq (HSub.hSub a (HDiv.hDiv a 2)) (HDiv.hDiv a 2)","decl":"theorem sub_half (h : a ≠ ∞) : a - a / 2 = a / 2 := ENNReal.sub_eq_of_eq_add' h a.add_halves.symm\n\n"}
{"name":"ENNReal.one_sub_inv_two","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (HSub.hSub 1 (Inv.inv 2)) (Inv.inv 2)","decl":"@[simp]\ntheorem one_sub_inv_two : (1 : ℝ≥0∞) - 2⁻¹ = 2⁻¹ := by\n  rw [← one_div, sub_half one_ne_top]\n\n"}
{"name":"ENNReal.mul_le_of_forall_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh : ∀ (a' : ENNReal), LT.lt a' a → ∀ (b' : ENNReal), LT.lt b' b → LE.le (HMul.hMul a' b') c\n⊢ LE.le (HMul.hMul a b) c","decl":"lemma mul_le_of_forall_lt {a b c : ℝ≥0∞} (h : ∀ a' < a, ∀ b' < b, a' * b' ≤ c) : a * b ≤ c := by\n  refine le_of_forall_lt_imp_le_of_dense fun d hd ↦ ?_\n  obtain ⟨a', ha', hd⟩ := exists_lt_mul_left hd\n  obtain ⟨b', hb', hd⟩ := exists_lt_mul_right hd\n  exact le_trans hd.le <| h _ ha' _ hb'\n\n"}
{"name":"ENNReal.le_mul_of_forall_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b c : ENNReal\nh₁ : Or (Ne a 0) (Ne b Top.top)\nh₂ : Or (Ne a Top.top) (Ne b 0)\nh : ∀ (a' : ENNReal), GT.gt a' a → ∀ (b' : ENNReal), GT.gt b' b → LE.le c (HMul.hMul a' b')\n⊢ LE.le c (HMul.hMul a b)","decl":"lemma le_mul_of_forall_lt {a b c : ℝ≥0∞} (h₁ : a ≠ 0 ∨ b ≠ ∞) (h₂ : a ≠ ∞ ∨ b ≠ 0)\n    (h : ∀ a' > a, ∀ b' > b, c ≤ a' * b') : c ≤ a * b := by\n  rw [← ENNReal.inv_le_inv, ENNReal.mul_inv h₁ h₂]\n  exact mul_le_of_forall_lt fun a' ha' b' hb' ↦ ENNReal.le_inv_iff_le_inv.1 <|\n    (h _ (ENNReal.lt_inv_iff_lt_inv.1 ha') _ (ENNReal.lt_inv_iff_lt_inv.1 hb')).trans_eq\n    (ENNReal.mul_inv (Or.inr hb'.ne_top) (Or.inl ha'.ne_top)).symm\n\n"}
{"name":"ENNReal.orderIsoIicOneBirational_apply_coe","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\n⊢ Eq (↑(ENNReal.orderIsoIicOneBirational x)) (Inv.inv (HAdd.hAdd (Inv.inv x) 1))","decl":"/-- The birational order isomorphism between `ℝ≥0∞` and the unit interval `Set.Iic (1 : ℝ≥0∞)`. -/\n@[simps! apply_coe]\ndef orderIsoIicOneBirational : ℝ≥0∞ ≃o Iic (1 : ℝ≥0∞) := by\n  refine StrictMono.orderIsoOfRightInverse\n    (fun x => ⟨(x⁻¹ + 1)⁻¹, ENNReal.inv_le_one.2 <| le_add_self⟩)\n    (fun x y hxy => ?_) (fun x => (x.1⁻¹ - 1)⁻¹) fun x => Subtype.ext ?_\n  · simpa only [Subtype.mk_lt_mk, ENNReal.inv_lt_inv, ENNReal.add_lt_add_iff_right one_ne_top]\n  · have : (1 : ℝ≥0∞) ≤ x.1⁻¹ := ENNReal.one_le_inv.2 x.2\n    simp only [inv_inv, Subtype.coe_mk, tsub_add_cancel_of_le this]\n\n"}
{"name":"ENNReal.orderIsoIicOneBirational_symm_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ↑(Set.Iic 1)\n⊢ Eq (ENNReal.orderIsoIicOneBirational.symm x) (Inv.inv (HSub.hSub (Inv.inv ↑x) 1))","decl":"@[simp]\ntheorem orderIsoIicOneBirational_symm_apply (x : Iic (1 : ℝ≥0∞)) :\n    orderIsoIicOneBirational.symm x = (x.1⁻¹ - 1)⁻¹ :=\n  rfl\n\n"}
{"name":"ENNReal.orderIsoIicCoe_apply_coe","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : NNReal\na✝ : ↑(Set.Iic ↑a)\n⊢ Eq (↑((ENNReal.orderIsoIicCoe a) a✝)) (↑a✝).toNNReal","decl":"/-- Order isomorphism between an initial interval in `ℝ≥0∞` and an initial interval in `ℝ≥0`. -/\n@[simps! apply_coe]\ndef orderIsoIicCoe (a : ℝ≥0) : Iic (a : ℝ≥0∞) ≃o Iic a :=\n  OrderIso.symm\n    { toFun := fun x => ⟨x, coe_le_coe.2 x.2⟩\n      invFun := fun x => ⟨ENNReal.toNNReal x, coe_le_coe.1 <| coe_toNNReal_le_self.trans x.2⟩\n      left_inv := fun _ => Subtype.ext <| toNNReal_coe _\n      right_inv := fun x => Subtype.ext <| coe_toNNReal (ne_top_of_le_ne_top coe_ne_top x.2)\n      map_rel_iff' := fun {_ _} => by\n        simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, coe_le_coe, Subtype.coe_le_coe] }\n\n"}
{"name":"ENNReal.orderIsoIicCoe_symm_apply_coe","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : NNReal\nb : ↑(Set.Iic a)\n⊢ Eq ↑((ENNReal.orderIsoIicCoe a).symm b) ↑↑b","decl":"@[simp]\ntheorem orderIsoIicCoe_symm_apply_coe (a : ℝ≥0) (b : Iic a) :\n    ((orderIsoIicCoe a).symm b : ℝ≥0∞) = b :=\n  rfl\n\n"}
{"name":"ENNReal.orderIsoUnitIntervalBirational_apply_coe","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\n⊢ Eq (↑(ENNReal.orderIsoUnitIntervalBirational x)) (Inv.inv (HAdd.hAdd (Inv.inv x) 1)).toReal","decl":"@[simp]\ntheorem orderIsoUnitIntervalBirational_apply_coe (x : ℝ≥0∞) :\n    (orderIsoUnitIntervalBirational x : ℝ) = (x⁻¹ + 1)⁻¹.toReal :=\n  rfl\n\n"}
{"name":"ENNReal.exists_inv_nat_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nh : Ne a 0\n⊢ Exists fun n => LT.lt (Inv.inv ↑n) a","decl":"theorem exists_inv_nat_lt {a : ℝ≥0∞} (h : a ≠ 0) : ∃ n : ℕ, (n : ℝ≥0∞)⁻¹ < a :=\n  inv_inv a ▸ by simp only [ENNReal.inv_lt_inv, ENNReal.exists_nat_gt (inv_ne_top.2 h)]\n\n"}
{"name":"ENNReal.exists_nat_pos_mul_gt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Ne a 0\nhb : Ne b Top.top\n⊢ Exists fun n => And (GT.gt n 0) (LT.lt b (HMul.hMul (↑n) a))","decl":"theorem exists_nat_pos_mul_gt (ha : a ≠ 0) (hb : b ≠ ∞) : ∃ n > 0, b < (n : ℕ) * a :=\n  let ⟨n, hn⟩ := ENNReal.exists_nat_gt (div_lt_top hb ha).ne\n  ⟨n, Nat.cast_pos.1 ((zero_le _).trans_lt hn), by\n    rwa [← ENNReal.div_lt_iff (Or.inl ha) (Or.inr hb)]⟩\n\n"}
{"name":"ENNReal.exists_nat_mul_gt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Ne a 0\nhb : Ne b Top.top\n⊢ Exists fun n => LT.lt b (HMul.hMul (↑n) a)","decl":"theorem exists_nat_mul_gt (ha : a ≠ 0) (hb : b ≠ ∞) : ∃ n : ℕ, b < n * a :=\n  (exists_nat_pos_mul_gt ha hb).imp fun _ => And.right\n\n"}
{"name":"ENNReal.exists_nat_pos_inv_mul_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b 0\n⊢ Exists fun n => And (GT.gt n 0) (LT.lt (HMul.hMul (Inv.inv ↑n) a) b)","decl":"theorem exists_nat_pos_inv_mul_lt (ha : a ≠ ∞) (hb : b ≠ 0) :\n    ∃ n > 0, ((n : ℕ) : ℝ≥0∞)⁻¹ * a < b := by\n  rcases exists_nat_pos_mul_gt hb ha with ⟨n, npos, hn⟩\n  use n, npos\n  rw [← ENNReal.div_eq_inv_mul]\n  exact div_lt_of_lt_mul' hn\n\n"}
{"name":"ENNReal.exists_nnreal_pos_mul_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b 0\n⊢ Exists fun n => And (GT.gt n 0) (LT.lt (HMul.hMul (↑n) a) b)","decl":"theorem exists_nnreal_pos_mul_lt (ha : a ≠ ∞) (hb : b ≠ 0) : ∃ n > 0, ↑(n : ℝ≥0) * a < b := by\n  rcases exists_nat_pos_inv_mul_lt ha hb with ⟨n, npos : 0 < n, hn⟩\n  use (n : ℝ≥0)⁻¹\n  simp [*, npos.ne', zero_lt_one]\n\n"}
{"name":"ENNReal.exists_inv_two_pow_lt","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : Ne a 0\n⊢ Exists fun n => LT.lt (HPow.hPow (Inv.inv 2) n) a","decl":"theorem exists_inv_two_pow_lt (ha : a ≠ 0) : ∃ n : ℕ, 2⁻¹ ^ n < a := by\n  rcases exists_inv_nat_lt ha with ⟨n, hn⟩\n  refine ⟨n, lt_trans ?_ hn⟩\n  rw [← ENNReal.inv_pow, ENNReal.inv_lt_inv]\n  norm_cast\n  exact n.lt_two_pow_self\n\n"}
{"name":"ENNReal.coe_zpow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"r : NNReal\nhr : Ne r 0\nn : Int\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[simp, norm_cast]\ntheorem coe_zpow (hr : r ≠ 0) (n : ℤ) : (↑(r ^ n) : ℝ≥0∞) = (r : ℝ≥0∞) ^ n := by\n  cases' n with n n\n  · simp only [Int.ofNat_eq_coe, coe_pow, zpow_natCast]\n  · have : r ^ n.succ ≠ 0 := pow_ne_zero (n + 1) hr\n    simp only [zpow_negSucc, coe_inv this, coe_pow]\n\n"}
{"name":"ENNReal.zpow_pos","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : Ne a 0\nh'a : Ne a Top.top\nn : Int\n⊢ LT.lt 0 (HPow.hPow a n)","decl":"theorem zpow_pos (ha : a ≠ 0) (h'a : a ≠ ∞) (n : ℤ) : 0 < a ^ n := by\n  cases n\n  · simpa using ENNReal.pow_pos ha.bot_lt _\n  · simp only [h'a, pow_eq_top_iff, zpow_negSucc, Ne, not_false, ENNReal.inv_pos, false_and,\n      not_false_eq_true]\n\n"}
{"name":"ENNReal.zpow_lt_top","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : Ne a 0\nh'a : Ne a Top.top\nn : Int\n⊢ LT.lt (HPow.hPow a n) Top.top","decl":"theorem zpow_lt_top (ha : a ≠ 0) (h'a : a ≠ ∞) (n : ℤ) : a ^ n < ∞ := by\n  cases n\n  · simpa using ENNReal.pow_lt_top h'a.lt_top _\n  · simp only [ENNReal.pow_pos ha.bot_lt, zpow_negSucc, inv_lt_top]\n\n"}
{"name":"ENNReal.exists_mem_Ico_zpow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y : ENNReal\nhx : Ne x 0\nh'x : Ne x Top.top\nhy : LT.lt 1 y\nh'y : Ne y Top.top\n⊢ Exists fun n => Membership.mem (Set.Ico (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"theorem exists_mem_Ico_zpow {x y : ℝ≥0∞} (hx : x ≠ 0) (h'x : x ≠ ∞) (hy : 1 < y) (h'y : y ≠ ⊤) :\n    ∃ n : ℤ, x ∈ Ico (y ^ n) (y ^ (n + 1)) := by\n  lift x to ℝ≥0 using h'x\n  lift y to ℝ≥0 using h'y\n  have A : y ≠ 0 := by simpa only [Ne, coe_eq_zero] using (zero_lt_one.trans hy).ne'\n  obtain ⟨n, hn, h'n⟩ : ∃ n : ℤ, y ^ n ≤ x ∧ x < y ^ (n + 1) := by\n    refine NNReal.exists_mem_Ico_zpow ?_ (one_lt_coe_iff.1 hy)\n    simpa only [Ne, coe_eq_zero] using hx\n  refine ⟨n, ?_, ?_⟩\n  · rwa [← ENNReal.coe_zpow A, ENNReal.coe_le_coe]\n  · rwa [← ENNReal.coe_zpow A, ENNReal.coe_lt_coe]\n\n"}
{"name":"ENNReal.exists_mem_Ioc_zpow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y : ENNReal\nhx : Ne x 0\nh'x : Ne x Top.top\nhy : LT.lt 1 y\nh'y : Ne y Top.top\n⊢ Exists fun n => Membership.mem (Set.Ioc (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"theorem exists_mem_Ioc_zpow {x y : ℝ≥0∞} (hx : x ≠ 0) (h'x : x ≠ ∞) (hy : 1 < y) (h'y : y ≠ ⊤) :\n    ∃ n : ℤ, x ∈ Ioc (y ^ n) (y ^ (n + 1)) := by\n  lift x to ℝ≥0 using h'x\n  lift y to ℝ≥0 using h'y\n  have A : y ≠ 0 := by simpa only [Ne, coe_eq_zero] using (zero_lt_one.trans hy).ne'\n  obtain ⟨n, hn, h'n⟩ : ∃ n : ℤ, y ^ n < x ∧ x ≤ y ^ (n + 1) := by\n    refine NNReal.exists_mem_Ioc_zpow ?_ (one_lt_coe_iff.1 hy)\n    simpa only [Ne, coe_eq_zero] using hx\n  refine ⟨n, ?_, ?_⟩\n  · rwa [← ENNReal.coe_zpow A, ENNReal.coe_lt_coe]\n  · rwa [← ENNReal.coe_zpow A, ENNReal.coe_le_coe]\n\n"}
{"name":"ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"y : ENNReal\nhy : LT.lt 1 y\nh'y : Ne y Top.top\n⊢ Eq (Set.Ioo 0 Top.top) (Set.iUnion fun n => Set.Ico (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1)))","decl":"theorem Ioo_zero_top_eq_iUnion_Ico_zpow {y : ℝ≥0∞} (hy : 1 < y) (h'y : y ≠ ⊤) :\n    Ioo (0 : ℝ≥0∞) (∞ : ℝ≥0∞) = ⋃ n : ℤ, Ico (y ^ n) (y ^ (n + 1)) := by\n  ext x\n  simp only [mem_iUnion, mem_Ioo, mem_Ico]\n  constructor\n  · rintro ⟨hx, h'x⟩\n    exact exists_mem_Ico_zpow hx.ne' h'x.ne hy h'y\n  · rintro ⟨n, hn, h'n⟩\n    constructor\n    · apply lt_of_lt_of_le _ hn\n      exact ENNReal.zpow_pos (zero_lt_one.trans hy).ne' h'y _\n    · apply lt_trans h'n _\n      exact ENNReal.zpow_lt_top (zero_lt_one.trans hy).ne' h'y _\n\n"}
{"name":"ENNReal.zpow_le_of_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nhx : LE.le 1 x\na b : Int\nh : LE.le a b\n⊢ LE.le (HPow.hPow x a) (HPow.hPow x b)","decl":"@[gcongr]\ntheorem zpow_le_of_le {x : ℝ≥0∞} (hx : 1 ≤ x) {a b : ℤ} (h : a ≤ b) : x ^ a ≤ x ^ b := by\n  induction' a with a a <;> induction' b with b b\n  · simp only [Int.ofNat_eq_coe, zpow_natCast]\n    exact pow_right_mono₀ hx (Int.le_of_ofNat_le_ofNat h)\n  · apply absurd h (not_le_of_gt _)\n    exact lt_of_lt_of_le (Int.negSucc_lt_zero _) (Int.ofNat_nonneg _)\n  · simp only [zpow_negSucc, Int.ofNat_eq_coe, zpow_natCast]\n    refine (ENNReal.inv_le_one.2 ?_).trans ?_ <;> exact one_le_pow_of_one_le' hx _\n  · simp only [zpow_negSucc, ENNReal.inv_le_inv]\n    apply pow_right_mono₀ hx\n    simpa only [← Int.ofNat_le, neg_le_neg_iff, Int.ofNat_add, Int.ofNat_one, Int.negSucc_eq] using\n      h\n\n"}
{"name":"ENNReal.monotone_zpow","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nhx : LE.le 1 x\n⊢ Monotone fun x_1 => HPow.hPow x x_1","decl":"theorem monotone_zpow {x : ℝ≥0∞} (hx : 1 ≤ x) : Monotone ((x ^ ·) : ℤ → ℝ≥0∞) := fun _ _ h =>\n  zpow_le_of_le hx h\n\n"}
{"name":"ENNReal.zpow_add","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nhx : Ne x 0\nh'x : Ne x Top.top\nm n : Int\n⊢ Eq (HPow.hPow x (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow x m) (HPow.hPow x n))","decl":"protected theorem zpow_add {x : ℝ≥0∞} (hx : x ≠ 0) (h'x : x ≠ ∞) (m n : ℤ) :\n    x ^ (m + n) = x ^ m * x ^ n := by\n  lift x to ℝ≥0 using h'x\n  replace hx : x ≠ 0 := by simpa only [Ne, coe_eq_zero] using hx\n  simp only [← coe_zpow hx, zpow_add₀ hx, coe_mul]\n\n"}
{"name":"ENNReal.zpow_neg","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nx_ne_zero : Ne x 0\nx_ne_top : Ne x Top.top\nm : Int\n⊢ Eq (HPow.hPow x (Neg.neg m)) (Inv.inv (HPow.hPow x m))","decl":"protected theorem zpow_neg {x : ℝ≥0∞} (x_ne_zero : x ≠ 0) (x_ne_top : x ≠ ⊤) (m : ℤ) :\n    x ^ (-m) = (x ^ m)⁻¹ :=\n  ENNReal.eq_inv_of_mul_eq_one_left (by simp [← ENNReal.zpow_add x_ne_zero x_ne_top])\n\n"}
{"name":"ENNReal.zpow_sub","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x : ENNReal\nx_ne_zero : Ne x 0\nx_ne_top : Ne x Top.top\nm n : Int\n⊢ Eq (HPow.hPow x (HSub.hSub m n)) (HMul.hMul (HPow.hPow x m) (Inv.inv (HPow.hPow x n)))","decl":"protected theorem zpow_sub {x : ℝ≥0∞} (x_ne_zero : x ≠ 0) (x_ne_top : x ≠ ⊤) (m n : ℤ) :\n    x ^ (m - n) = (x ^ m) * (x ^ n)⁻¹ := by\n  rw [sub_eq_add_neg, ENNReal.zpow_add x_ne_zero x_ne_top, ENNReal.zpow_neg x_ne_zero x_ne_top n]\n\n"}
{"name":"ENNReal.iSup_eq_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\n⊢ Iff (Eq (iSup fun i => f i) 0) (∀ (i : ι), Eq (f i) 0)","decl":"@[simp] lemma iSup_eq_zero : ⨆ i, f i = 0 ↔ ∀ i, f i = 0 := iSup_eq_bot\n\n"}
{"name":"ENNReal.iSup_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\n⊢ Eq (iSup fun x => 0) 0","decl":"@[simp] lemma iSup_zero : ⨆ _ : ι, (0 : ℝ≥0∞) = 0 := by simp\n\n"}
{"name":"ENNReal.iSup_zero_eq_zero","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\n⊢ Eq (iSup fun x => 0) 0","decl":"@[deprecated (since := \"2024-10-22\")]\nalias iSup_zero_eq_zero := iSup_zero\n\n"}
{"name":"ENNReal.iSup_natCast","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"⊢ Eq (iSup fun n => ↑n) Top.top","decl":"lemma iSup_natCast : ⨆ n : ℕ, (n : ℝ≥0∞) = ∞ :=\n  (iSup_eq_top _).2 fun _b hb => ENNReal.exists_nat_gt (lt_top_iff_ne_top.1 hb)\n\n"}
{"name":"ENNReal.iSup_lt_eq_self","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Eq (iSup fun b => iSup fun x => b) a","decl":"@[simp] lemma iSup_lt_eq_self (a : ℝ≥0∞) : ⨆ b, ⨆ _ : b < a, b = a := by\n  refine le_antisymm (iSup₂_le fun b hb ↦ hb.le) ?_\n  refine le_of_forall_lt fun c hca ↦ ?_\n  obtain ⟨d, hcd, hdb⟩ := exists_between hca\n  exact hcd.trans_le <| le_iSup₂_of_le d hdb le_rfl\n\n"}
{"name":"ENNReal.isUnit_iff","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\n⊢ Iff (IsUnit a) (And (Ne a 0) (Ne a Top.top))","decl":"lemma isUnit_iff : IsUnit a ↔ a ≠ 0 ∧ a ≠ ∞ := by\n  refine ⟨fun ha ↦ ⟨ha.ne_zero, ?_⟩,\n    fun ha ↦ ⟨⟨a, a⁻¹, ENNReal.mul_inv_cancel ha.1 ha.2, ENNReal.inv_mul_cancel ha.1 ha.2⟩, rfl⟩⟩\n  obtain ⟨u, rfl⟩ := ha\n  rintro hu\n  have := congr($hu * u⁻¹)\n  norm_cast at this\n  simp [mul_inv_cancel] at this\n\n"}
{"name":"ENNReal.mulLeftOrderIso_toEquiv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\n⊢ Eq (a.mulLeftOrderIso ha).toEquiv ha.unit.mulLeft","decl":"/-- Left multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulLeftOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulLeft\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_left, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mulLeftOrderIso_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\nx : ENNReal\n⊢ Eq ((a.mulLeftOrderIso ha) x) (HMul.hMul a x)","decl":"/-- Left multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulLeftOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulLeft\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_left, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mulLeftOrderIso_symm_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\nx : ENNReal\n⊢ Eq ((RelIso.symm (a.mulLeftOrderIso ha)) x) (HMul.hMul (↑(Inv.inv ha.unit)) x)","decl":"/-- Left multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulLeftOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulLeft\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_left, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mulRightOrderIso_toEquiv","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\n⊢ Eq (a.mulRightOrderIso ha).toEquiv ha.unit.mulRight","decl":"/-- Right multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulRightOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulRight\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_right, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mulRightOrderIso_symm_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\nx : ENNReal\n⊢ Eq ((RelIso.symm (a.mulRightOrderIso ha)) x) (HMul.hMul x ↑(Inv.inv ha.unit))","decl":"/-- Right multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulRightOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulRight\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_right, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mulRightOrderIso_apply","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nha : IsUnit a\nx : ENNReal\n⊢ Eq ((a.mulRightOrderIso ha) x) (HMul.hMul x a)","decl":"/-- Right multiplication by a nonzero finite `a` as an order isomorphism. -/\n@[simps! toEquiv apply symm_apply]\ndef mulRightOrderIso (a  : ℝ≥0∞) (ha : IsUnit a) : ℝ≥0∞ ≃o ℝ≥0∞ where\n  toEquiv := ha.unit.mulRight\n  map_rel_iff' := by simp [ENNReal.mul_le_mul_right, ha.ne_zero, (isUnit_iff.1 ha).2]\n\n"}
{"name":"ENNReal.mul_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\na : ENNReal\nf : ι → ENNReal\n⊢ Eq (HMul.hMul a (iSup fun i => f i)) (iSup fun i => HMul.hMul a (f i))","decl":"lemma mul_iSup (a : ℝ≥0∞) (f : ι → ℝ≥0∞) : a * ⨆ i, f i = ⨆ i, a * f i := by\n  by_cases hf : ∀ i, f i = 0\n  · simp [hf]\n  obtain rfl | ha₀ := eq_or_ne a 0\n  · simp\n  obtain rfl | ha := eq_or_ne a ∞\n  · obtain ⟨i, hi⟩ := not_forall.1 hf\n    simpa [iSup_eq_zero.not.2 hf, eq_comm (a := ⊤)]\n      using le_iSup_of_le (f := fun i => ⊤ * f i) i (top_mul hi).ge\n  · exact (mulLeftOrderIso _ <| isUnit_iff.2 ⟨ha₀, ha⟩).map_iSup _\n\n"}
{"name":"ENNReal.iSup_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HMul.hMul (iSup fun i => f i) a) (iSup fun i => HMul.hMul (f i) a)","decl":"lemma iSup_mul (f : ι → ℝ≥0∞) (a : ℝ≥0∞) : (⨆ i, f i) * a = ⨆ i, f i * a := by\n  simp [mul_comm, mul_iSup]\n\n"}
{"name":"ENNReal.mul_sSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\na : ENNReal\n⊢ Eq (HMul.hMul a (SupSet.sSup s)) (iSup fun b => iSup fun h => HMul.hMul a b)","decl":"lemma mul_sSup {a : ℝ≥0∞} : a * sSup s = ⨆ b ∈ s, a * b := by\n  simp only [sSup_eq_iSup, mul_iSup]\n\n"}
{"name":"ENNReal.sSup_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\na : ENNReal\n⊢ Eq (HMul.hMul (SupSet.sSup s) a) (iSup fun b => iSup fun h => HMul.hMul b a)","decl":"lemma sSup_mul {a : ℝ≥0∞} : sSup s * a = ⨆ b ∈ s, b * a := by\n  simp only [sSup_eq_iSup, iSup_mul]\n\n"}
{"name":"ENNReal.iSup_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\n⊢ Eq (HDiv.hDiv (iSup f) a) (iSup fun i => HDiv.hDiv (f i) a)","decl":"lemma iSup_div (f : ι → ℝ≥0∞) (a : ℝ≥0∞) : iSup f / a = ⨆ i, f i / a := iSup_mul ..\n"}
{"name":"ENNReal.sSup_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\na : ENNReal\n⊢ Eq (HDiv.hDiv (SupSet.sSup s) a) (iSup fun b => iSup fun h => HDiv.hDiv b a)","decl":"lemma sSup_div (s : Set ℝ≥0∞) (a : ℝ≥0∞) : sSup s / a = ⨆ b ∈ s, b / a := sSup_mul ..\n\n"}
{"name":"ENNReal.mul_iInf'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nhinfty : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\nh₀ : Eq a 0 → Nonempty ι\n⊢ Eq (HMul.hMul a (iInf fun i => f i)) (iInf fun i => HMul.hMul a (f i))","decl":"/-- Very general version for distributivity of multiplication over an infimum.\n\nSee `ENNReal.mul_iInf_of_ne` for the special case assuming `a ≠ 0` and `a ≠ ∞`, and\n`ENNReal.mul_iInf` for the special case assuming `Nonempty ι`. -/\nlemma mul_iInf' (hinfty : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) (h₀ : a = 0 → Nonempty ι) :\n    a * ⨅ i, f i = ⨅ i, a * f i := by\n  obtain rfl | ha₀ := eq_or_ne a 0\n  · simp [h₀ rfl]\n  obtain rfl | ha := eq_or_ne a ∞\n  · obtain ⟨i, hi⟩ | hf := em (∃ i, f i = 0)\n    · rw [(iInf_eq_bot _).2, (iInf_eq_bot _).2, bot_eq_zero, mul_zero] <;>\n        exact fun _ _↦ ⟨i, by simpa [hi]⟩\n    · rw [top_mul (mt (hinfty rfl) hf), eq_comm, iInf_eq_top]\n      exact fun i ↦ top_mul fun hi ↦ hf ⟨i, hi⟩\n  · exact (mulLeftOrderIso _ <| isUnit_iff.2 ⟨ha₀, ha⟩).map_iInf _\n\n"}
{"name":"ENNReal.iInf_mul'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nhinfty : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\nh₀ : Eq a 0 → Nonempty ι\n⊢ Eq (HMul.hMul (iInf fun i => f i) a) (iInf fun i => HMul.hMul (f i) a)","decl":"/-- Very general version for distributivity of multiplication over an infimum.\n\nSee `ENNReal.iInf_mul_of_ne` for the special case assuming `a ≠ 0` and `a ≠ ∞`, and\n`ENNReal.iInf_mul` for the special case assuming `Nonempty ι`. -/\nlemma iInf_mul' (hinfty : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) (h₀ : a = 0 → Nonempty ι) :\n    (⨅ i, f i) * a = ⨅ i, f i * a := by simpa only [mul_comm a] using mul_iInf' hinfty h₀\n\n"}
{"name":"ENNReal.mul_iInf_of_ne","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul a (iInf fun i => f i)) (iInf fun i => HMul.hMul a (f i))","decl":"/-- If `a ≠ 0` and `a ≠ ∞`, then right multiplication by `a` maps infimum to infimum.\n\nSee `ENNReal.mul_iInf'` for the general case, and `ENNReal.iInf_mul` for another special case that\nassumes `Nonempty ι` but does not require `a ≠ 0`, and `ENNReal`. -/\nlemma mul_iInf_of_ne (ha₀ : a ≠ 0) (ha : a ≠ ∞) : a * ⨅ i, f i = ⨅ i, a * f i :=\n  mul_iInf' (by simp [ha]) (by simp [ha₀])\n\n"}
{"name":"ENNReal.iInf_mul_of_ne","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HMul.hMul (iInf fun i => f i) a) (iInf fun i => HMul.hMul (f i) a)","decl":"/-- If `a ≠ 0` and `a ≠ ∞`, then right multiplication by `a` maps infimum to infimum.\n\nSee `ENNReal.iInf_mul'` for the general case, and `ENNReal.iInf_mul` for another special case that\nassumes `Nonempty ι` but does not require `a ≠ 0`. -/\nlemma iInf_mul_of_ne (ha₀ : a ≠ 0) (ha : a ≠ ∞) : (⨅ i, f i) * a = ⨅ i, f i * a :=\n  iInf_mul' (by simp [ha]) (by simp [ha₀])\n\n"}
{"name":"ENNReal.mul_iInf","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\ninst✝ : Nonempty ι\nhinfty : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\n⊢ Eq (HMul.hMul a (iInf fun i => f i)) (iInf fun i => HMul.hMul a (f i))","decl":"/-- See `ENNReal.mul_iInf'` for the general case, and `ENNReal.mul_iInf_of_ne` for another special\ncase that assumes `a ≠ 0` but does not require `Nonempty ι`. -/\nlemma mul_iInf [Nonempty ι] (hinfty : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) :\n    a * ⨅ i, f i = ⨅ i, a * f i := mul_iInf' hinfty fun _ ↦ ‹Nonempty ι›\n\n"}
{"name":"ENNReal.iInf_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\ninst✝ : Nonempty ι\nhinfty : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\n⊢ Eq (HMul.hMul (iInf fun i => f i) a) (iInf fun i => HMul.hMul (f i) a)","decl":"/-- See `ENNReal.iInf_mul'` for the general case, and `ENNReal.iInf_mul_of_ne` for another special\ncase that assumes `a ≠ 0` but does not require `Nonempty ι`. -/\nlemma iInf_mul [Nonempty ι] (hinfty : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) :\n    (⨅ i, f i) * a = ⨅ i, f i * a := iInf_mul' hinfty fun _ ↦ ‹Nonempty ι›\n\n"}
{"name":"ENNReal.iInf_div'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nhinfty : Eq a 0 → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\nh₀ : Eq a Top.top → Nonempty ι\n⊢ Eq (HDiv.hDiv (iInf fun i => f i) a) (iInf fun i => HDiv.hDiv (f i) a)","decl":"/-- Very general version for distributivity of division over an infimum.\n\nSee `ENNReal.iInf_div_of_ne` for the special case assuming `a ≠ 0` and `a ≠ ∞`, and\n`ENNReal.iInf_div` for the special case assuming `Nonempty ι`. -/\nlemma iInf_div' (hinfty : a = 0 → ⨅ i, f i = 0 → ∃ i, f i = 0) (h₀ : a = ∞ → Nonempty ι) :\n    (⨅ i, f i) / a = ⨅ i, f i / a := iInf_mul' (by simpa) (by simpa)\n\n"}
{"name":"ENNReal.iInf_div_of_ne","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Eq (HDiv.hDiv (iInf fun i => f i) a) (iInf fun i => HDiv.hDiv (f i) a)","decl":"/-- If `a ≠ 0` and `a ≠ ∞`, then division by `a` maps infimum to infimum.\n\nSee `ENNReal.iInf_div'` for the general case, and `ENNReal.iInf_div` for another special case that\nassumes `Nonempty ι` but does not require `a ≠ ∞`. -/\nlemma iInf_div_of_ne (ha₀ : a ≠ 0) (ha : a ≠ ∞) : (⨅ i, f i) / a = ⨅ i, f i / a :=\n  iInf_div' (by simp [ha₀]) (by simp [ha])\n\n"}
{"name":"ENNReal.iInf_div","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\ninst✝ : Nonempty ι\nhinfty : Eq a 0 → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\n⊢ Eq (HDiv.hDiv (iInf fun i => f i) a) (iInf fun i => HDiv.hDiv (f i) a)","decl":"/-- See `ENNReal.iInf_div'` for the general case, and `ENNReal.iInf_div_of_ne` for another special\ncase that assumes `a ≠ ∞` but does not require `Nonempty ι`. -/\nlemma iInf_div [Nonempty ι] (hinfty : a = 0 → ⨅ i, f i = 0 → ∃ i, f i = 0) :\n    (⨅ i, f i) / a = ⨅ i, f i / a := iInf_div' hinfty fun _ ↦ ‹Nonempty ι›\n\n"}
{"name":"ENNReal.inv_iInf","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\n⊢ Eq (Inv.inv (iInf fun i => f i)) (iSup fun i => Inv.inv (f i))","decl":"lemma inv_iInf (f : ι → ℝ≥0∞) : (⨅ i, f i)⁻¹ = ⨆ i, (f i)⁻¹ := OrderIso.invENNReal.map_iInf _\n"}
{"name":"ENNReal.inv_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\n⊢ Eq (Inv.inv (iSup fun i => f i)) (iInf fun i => Inv.inv (f i))","decl":"lemma inv_iSup (f : ι → ℝ≥0∞) : (⨆ i, f i)⁻¹ = ⨅ i, (f i)⁻¹ := OrderIso.invENNReal.map_iSup _\n\n"}
{"name":"ENNReal.inv_sInf","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\n⊢ Eq (Inv.inv (InfSet.sInf s)) (iSup fun a => iSup fun h => Inv.inv a)","decl":"lemma inv_sInf (s : Set ℝ≥0∞) : (sInf s)⁻¹ = ⨆ a ∈ s, a⁻¹ := by simp [sInf_eq_iInf, inv_iInf]\n"}
{"name":"ENNReal.inv_sSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\n⊢ Eq (Inv.inv (SupSet.sSup s)) (iInf fun a => iInf fun h => Inv.inv a)","decl":"lemma inv_sSup (s : Set ℝ≥0∞) : (sSup s)⁻¹ = ⨅ a ∈ s, a⁻¹ := by simp [sSup_eq_iSup, inv_iSup]\n\n"}
{"name":"ENNReal.le_iInf_mul","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Type u_3\nu v : ι → ENNReal\n⊢ LE.le (HMul.hMul (iInf fun i => u i) (iInf fun i => v i)) (iInf fun i => HMul.hMul (u i) (v i))","decl":"lemma le_iInf_mul {ι : Type*} (u v : ι → ℝ≥0∞) :\n    (⨅ i, u i) * ⨅ i, v i ≤ ⨅ i, u i * v i :=\n  le_iInf fun i ↦ mul_le_mul' (iInf_le u i) (iInf_le v i)\n\n"}
{"name":"ENNReal.iSup_mul_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Type u_3\nu v : ι → ENNReal\n⊢ LE.le (iSup fun i => HMul.hMul (u i) (v i)) (HMul.hMul (iSup fun i => u i) (iSup fun i => v i))","decl":"lemma iSup_mul_le {ι : Type*} {u v : ι → ℝ≥0∞} :\n    ⨆ i, u i * v i ≤ (⨆ i, u i) * ⨆ i, v i :=\n  iSup_le fun i ↦ mul_le_mul' (le_iSup u i) (le_iSup v i)\n\n"}
{"name":"ENNReal.add_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\na : ENNReal\ninst✝ : Nonempty ι\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd a (iSup fun i => f i)) (iSup fun i => HAdd.hAdd a (f i))","decl":"lemma add_iSup [Nonempty ι] (f : ι → ℝ≥0∞) : a + ⨆ i, f i = ⨆ i, a + f i := by\n  obtain rfl | ha := eq_or_ne a ∞\n  · simp\n  refine le_antisymm ?_ <| iSup_le fun i ↦ add_le_add_left (le_iSup ..) _\n  refine add_le_of_le_tsub_left_of_le (le_iSup_of_le (Classical.arbitrary _) le_self_add) ?_\n  exact iSup_le fun i ↦ ENNReal.le_sub_of_add_le_left ha <| le_iSup (a + f ·) i\n\n"}
{"name":"ENNReal.iSup_add","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\na : ENNReal\ninst✝ : Nonempty ι\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd (iSup fun i => f i) a) (iSup fun i => HAdd.hAdd (f i) a)","decl":"lemma iSup_add [Nonempty ι] (f : ι → ℝ≥0∞) : (⨆ i, f i) + a = ⨆ i, f i + a := by\n  simp [add_comm, add_iSup]\n\n"}
{"name":"ENNReal.add_biSup'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\na : ENNReal\np : ι → Prop\nh : Exists fun i => p i\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd a (iSup fun i => iSup fun x => f i)) (iSup fun i => iSup fun x => HAdd.hAdd a (f i))","decl":"lemma add_biSup' {p : ι → Prop} (h : ∃ i, p i) (f : ι → ℝ≥0∞) :\n    a + ⨆ i, ⨆ _ : p i, f i = ⨆ i, ⨆ _ : p i, a + f i := by\n  haveI : Nonempty {i // p i} := nonempty_subtype.2 h\n  simp only [iSup_subtype', add_iSup]\n\n"}
{"name":"ENNReal.biSup_add'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\na : ENNReal\np : ι → Prop\nh : Exists fun i => p i\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd (iSup fun i => iSup fun x => f i) a) (iSup fun i => iSup fun x => HAdd.hAdd (f i) a)","decl":"lemma biSup_add' {p : ι → Prop} (h : ∃ i, p i) (f : ι → ℝ≥0∞) :\n    (⨆ i, ⨆ _ : p i, f i) + a = ⨆ i, ⨆ _ : p i, f i + a := by simp only [add_comm, add_biSup' h]\n\n"}
{"name":"ENNReal.add_biSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nι : Type u_3\ns : Set ι\nhs : s.Nonempty\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd a (iSup fun i => iSup fun h => f i)) (iSup fun i => iSup fun h => HAdd.hAdd a (f i))","decl":"lemma add_biSup {ι : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → ℝ≥0∞) :\n    a + ⨆ i ∈ s, f i = ⨆ i ∈ s, a + f i := add_biSup' hs _\n\n"}
{"name":"ENNReal.biSup_add","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"a : ENNReal\nι : Type u_3\ns : Set ι\nhs : s.Nonempty\nf : ι → ENNReal\n⊢ Eq (HAdd.hAdd (iSup fun i => iSup fun h => f i) a) (iSup fun i => iSup fun h => HAdd.hAdd (f i) a)","decl":"lemma biSup_add {ι : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → ℝ≥0∞) :\n    (⨆ i ∈ s, f i) + a = ⨆ i ∈ s, f i + a := biSup_add' hs _\n\n"}
{"name":"ENNReal.add_sSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\na : ENNReal\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd a (SupSet.sSup s)) (iSup fun b => iSup fun h => HAdd.hAdd a b)","decl":"lemma add_sSup (hs : s.Nonempty) : a + sSup s = ⨆ b ∈ s, a + b := by\n  rw [sSup_eq_iSup, add_biSup hs]\n\n"}
{"name":"ENNReal.sSup_add","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"s : Set ENNReal\na : ENNReal\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd (SupSet.sSup s) a) (iSup fun b => iSup fun h => HAdd.hAdd b a)","decl":"lemma sSup_add (hs : s.Nonempty) : sSup s + a = ⨆ b ∈ s, b + a := by\n  rw [sSup_eq_iSup, biSup_add hs]\n\n"}
{"name":"ENNReal.iSup_add_iSup_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nκ : Sort u_2\nf : ι → ENNReal\na : ENNReal\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty κ\ng : κ → ENNReal\nh : ∀ (i : ι) (j : κ), LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup f) (iSup g)) a","decl":"lemma iSup_add_iSup_le [Nonempty ι] [Nonempty κ] {g : κ → ℝ≥0∞} (h : ∀ i j, f i + g j ≤ a) :\n    iSup f + iSup g ≤ a := by simp_rw [iSup_add, add_iSup]; exact iSup₂_le h\n\n"}
{"name":"ENNReal.biSup_add_biSup_le'","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nκ : Sort u_2\nf : ι → ENNReal\na : ENNReal\np : ι → Prop\nq : κ → Prop\nhp : Exists fun i => p i\nhq : Exists fun j => q j\ng : κ → ENNReal\nh : ∀ (i : ι), p i → ∀ (j : κ), q j → LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup fun i => iSup fun x => f i) (iSup fun j => iSup fun x => g j)) a","decl":"lemma biSup_add_biSup_le' {p : ι → Prop} {q : κ → Prop} (hp : ∃ i, p i) (hq : ∃ j, q j)\n    {g : κ → ℝ≥0∞} (h : ∀ i, p i → ∀ j, q j → f i + g j ≤ a) :\n    (⨆ i, ⨆ _ : p i, f i) + ⨆ j, ⨆ _ : q j, g j ≤ a := by\n  simp_rw [biSup_add' hp, add_biSup' hq]\n  exact iSup₂_le fun i hi => iSup₂_le (h i hi)\n\n"}
{"name":"ENNReal.biSup_add_biSup_le","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Type u_3\nκ : Type u_4\ns : Set ι\nt : Set κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → ENNReal\ng : κ → ENNReal\na : ENNReal\nh : ∀ (i : ι), Membership.mem s i → ∀ (j : κ), Membership.mem t j → LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup fun i => iSup fun h => f i) (iSup fun j => iSup fun h => g j)) a","decl":"lemma biSup_add_biSup_le {ι κ : Type*} {s : Set ι} {t : Set κ} (hs : s.Nonempty) (ht : t.Nonempty)\n    {f : ι → ℝ≥0∞} {g : κ → ℝ≥0∞} {a : ℝ≥0∞} (h : ∀ i ∈ s, ∀ j ∈ t, f i + g j ≤ a) :\n    (⨆ i ∈ s, f i) + ⨆ j ∈ t, g j ≤ a := biSup_add_biSup_le' hs ht h\n\n"}
{"name":"ENNReal.iSup_add_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf g : ι → ENNReal\nh : ∀ (i j : ι), Exists fun k => LE.le (HAdd.hAdd (f i) (g j)) (HAdd.hAdd (f k) (g k))\n⊢ Eq (HAdd.hAdd (iSup f) (iSup g)) (iSup fun i => HAdd.hAdd (f i) (g i))","decl":"lemma iSup_add_iSup (h : ∀ i j, ∃ k, f i + g j ≤ f k + g k) : iSup f + iSup g = ⨆ i, f i + g i := by\n  cases isEmpty_or_nonempty ι\n  · simp only [iSup_of_empty, bot_eq_zero, zero_add]\n  · refine le_antisymm ?_ (iSup_le fun a => add_le_add (le_iSup _ _) (le_iSup _ _))\n    refine iSup_add_iSup_le fun i j => ?_\n    rcases h i j with ⟨k, hk⟩\n    exact le_iSup_of_le k hk\n\n"}
{"name":"ENNReal.iSup_add_iSup_of_monotone","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Type u_3\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf g : ι → ENNReal\nhf : Monotone f\nhg : Monotone g\n⊢ Eq (HAdd.hAdd (iSup f) (iSup g)) (iSup fun a => HAdd.hAdd (f a) (g a))","decl":"lemma iSup_add_iSup_of_monotone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f g : ι → ℝ≥0∞}\n    (hf : Monotone f) (hg : Monotone g) : iSup f + iSup g = ⨆ a, f a + g a :=\n  iSup_add_iSup fun i j ↦ (exists_ge_ge i j).imp fun _k ⟨hi, hj⟩ ↦ by gcongr <;> apply_rules\n\n"}
{"name":"ENNReal.finsetSum_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"α : Type u_3\nι : Type u_4\ns : Finset α\nf : α → ι → ENNReal\nhf : ∀ (i j : ι), Exists fun k => ∀ (a : α), And (LE.le (f a i) (f a k)) (LE.le (f a j) (f a k))\n⊢ Eq (s.sum fun a => iSup fun i => f a i) (iSup fun i => s.sum fun a => f a i)","decl":"lemma finsetSum_iSup {α ι : Type*} {s : Finset α} {f : α → ι → ℝ≥0∞}\n    (hf : ∀ i j, ∃ k, ∀ a, f a i ≤ f a k ∧ f a j ≤ f a k) :\n    ∑ a ∈ s, ⨆ i, f a i = ⨆ i, ∑ a ∈ s, f a i := by\n  induction' s using Finset.cons_induction with a s ha ihs\n  · simp\n  simp_rw [Finset.sum_cons, ihs]\n  refine iSup_add_iSup fun i j ↦ (hf i j).imp fun k hk ↦ ?_\n  gcongr\n  exacts [(hk a).1, (hk _).2]\n\n"}
{"name":"ENNReal.finsetSum_iSup_of_monotone","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"α : Type u_3\nι : Type u_4\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ns : Finset α\nf : α → ι → ENNReal\nhf : ∀ (a : α), Monotone (f a)\n⊢ Eq (s.sum fun a => iSup (f a)) (iSup fun n => s.sum fun a => f a n)","decl":"lemma finsetSum_iSup_of_monotone {α ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {s : Finset α}\n    {f : α → ι → ℝ≥0∞} (hf : ∀ a, Monotone (f a)) : (∑ a ∈ s, iSup (f a)) = ⨆ n, ∑ a ∈ s, f a n :=\n  finsetSum_iSup fun i j ↦ (exists_ge_ge i j).imp fun _k ⟨hi, hj⟩ a ↦ ⟨hf a hi, hf a hj⟩\n\n"}
{"name":"ENNReal.le_iInf_mul_iInf","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nκ : Sort u_2\nf : ι → ENNReal\na : ENNReal\ng : κ → ENNReal\nhf : Exists fun i => Ne (f i) Top.top\nhg : Exists fun j => Ne (g j) Top.top\nha : ∀ (i : ι) (j : κ), LE.le a (HMul.hMul (f i) (g j))\n⊢ LE.le a (HMul.hMul (iInf fun i => f i) (iInf fun j => g j))","decl":"lemma le_iInf_mul_iInf {g : κ → ℝ≥0∞} (hf : ∃ i, f i ≠ ∞) (hg : ∃ j, g j ≠ ∞)\n    (ha : ∀ i j, a ≤ f i * g j) : a ≤ (⨅ i, f i) * ⨅ j, g j := by\n  rw [← iInf_ne_top_subtype]\n  have := nonempty_subtype.2 hf\n  have := hg.nonempty\n  replace hg : ⨅ j, g j ≠ ∞ := by simpa using hg\n  rw [iInf_mul fun h ↦ (hg h).elim, le_iInf_iff]\n  rintro ⟨i, hi⟩\n  simpa [mul_iInf fun h ↦ (hi h).elim] using ha i\n\n"}
{"name":"ENNReal.iInf_mul_iInf","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf g : ι → ENNReal\nhf : Exists fun i => Ne (f i) Top.top\nhg : Exists fun j => Ne (g j) Top.top\nh : ∀ (i j : ι), Exists fun k => LE.le (HMul.hMul (f k) (g k)) (HMul.hMul (f i) (g j))\n⊢ Eq (HMul.hMul (iInf fun i => f i) (iInf fun i => g i)) (iInf fun i => HMul.hMul (f i) (g i))","decl":"lemma iInf_mul_iInf {f g : ι → ℝ≥0∞} (hf : ∃ i, f i ≠ ∞) (hg : ∃ j, g j ≠ ∞)\n    (h : ∀ i j, ∃ k, f k * g k ≤ f i * g j) : (⨅ i, f i) * ⨅ i, g i = ⨅ i, f i * g i := by\n  refine le_antisymm (le_iInf fun i ↦ mul_le_mul' (iInf_le ..) (iInf_le ..))\n    (le_iInf_mul_iInf hf hg fun i j ↦ ?_)\n  obtain ⟨k, hk⟩ := h i j\n  exact iInf_le_of_le k hk\n\n"}
{"name":"ENNReal.smul_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nR : Type u_3\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nf : ι → ENNReal\nc : R\n⊢ Eq (HSMul.hSMul c (iSup fun i => f i)) (iSup fun i => HSMul.hSMul c (f i))","decl":"lemma smul_iSup {R} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] (f : ι → ℝ≥0∞) (c : R) :\n    c • ⨆ i, f i = ⨆ i, c • f i := by\n  simp only [← smul_one_mul c (f _), ← smul_one_mul c (iSup _), ENNReal.mul_iSup]\n\n"}
{"name":"ENNReal.smul_sSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"R : Type u_3\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\ns : Set ENNReal\nc : R\n⊢ Eq (HSMul.hSMul c (SupSet.sSup s)) (iSup fun a => iSup fun h => HSMul.hSMul c a)","decl":"lemma smul_sSup {R} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] (s : Set ℝ≥0∞) (c : R) :\n    c • sSup s = ⨆ a ∈ s, c • a := by\n  simp_rw [← smul_one_mul c (sSup s), ENNReal.mul_sSup, smul_one_mul]\n\n"}
{"name":"ENNReal.sub_iSup","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"ι : Sort u_1\nf : ι → ENNReal\na : ENNReal\ninst✝ : Nonempty ι\nha : Ne a Top.top\n⊢ Eq (HSub.hSub a (iSup fun i => f i)) (iInf fun i => HSub.hSub a (f i))","decl":"lemma sub_iSup [Nonempty ι] (ha : a ≠ ∞) : a - ⨆ i, f i = ⨅ i, a - f i := by\n  obtain ⟨i, hi⟩ | h := em (∃ i, a < f i)\n  · rw [tsub_eq_zero_iff_le.2 <| le_iSup_of_le _ hi.le, (iInf_eq_bot _).2, bot_eq_zero]\n    exact fun x hx ↦ ⟨i, by simpa [hi.le, tsub_eq_zero_of_le]⟩\n  simp_rw [not_exists, not_lt] at h\n  refine le_antisymm (le_iInf fun i ↦ tsub_le_tsub_left (le_iSup ..) _) <|\n    ENNReal.le_sub_of_add_le_left (ne_top_of_le_ne_top ha <| iSup_le h) <|\n    add_le_of_le_tsub_right_of_le (iInf_le_of_le (Classical.arbitrary _) tsub_le_self) <|\n    iSup_le fun i ↦ ?_\n  rw [← sub_sub_cancel ha (h _)]\n  exact tsub_le_tsub_left (iInf_le (a - f ·) i) _\n\n-- TODO: Prove the two one-side versions\n"}
{"name":"ENNReal.exists_lt_add_of_lt_add","module":"Mathlib.Data.ENNReal.Inv","initialProofState":"x y z : ENNReal\nh : LT.lt x (HAdd.hAdd y z)\nhy : Ne y 0\nhz : Ne z 0\n⊢ Exists fun y' => And (LT.lt y' y) (Exists fun z' => And (LT.lt z' z) (LT.lt x (HAdd.hAdd y' z')))","decl":"lemma exists_lt_add_of_lt_add {x y z : ℝ≥0∞} (h : x < y + z) (hy : y ≠ 0) (hz : z ≠ 0) :\n    ∃ y' < y, ∃ z' < z, x < y' + z' := by\n  contrapose! h\n  simpa using biSup_add_biSup_le' (by exact ⟨0, hy.bot_lt⟩) (by exact ⟨0, hz.bot_lt⟩) h\n\n"}
