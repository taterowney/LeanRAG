{"name":"PosNum.minFacAux_to_nat","module":"Mathlib.Data.Num.Prime","initialProofState":"fuel : Nat\nn k : PosNum\nh : LT.lt (↑n).sqrt (HAdd.hAdd fuel ↑k.bit1)\n⊢ Eq (↑(n.minFacAux fuel k)) ((↑n).minFacAux ↑k.bit1)","decl":"theorem minFacAux_to_nat {fuel : ℕ} {n k : PosNum} (h : Nat.sqrt n < fuel + k.bit1) :\n    (minFacAux n fuel k : ℕ) = Nat.minFacAux n k.bit1 := by\n  induction' fuel with fuel ih generalizing k <;> rw [minFacAux, Nat.minFacAux]\n  · rw [Nat.zero_add, Nat.sqrt_lt] at h\n    simp only [h, ite_true]\n  simp_rw [← mul_to_nat]\n  simp only [cast_lt, dvd_to_nat]\n  split_ifs <;> try rfl\n  rw [ih] <;> [congr; convert Nat.lt_succ_of_lt h using 1] <;>\n    simp only [cast_bit1, cast_succ, Nat.succ_eq_add_one, add_assoc,\n      add_left_comm, ← one_add_one_eq_two]\n\n"}
{"name":"PosNum.minFac_to_nat","module":"Mathlib.Data.Num.Prime","initialProofState":"n : PosNum\n⊢ Eq (↑n.minFac) (↑n).minFac","decl":"@[simp]\ntheorem minFac_to_nat (n : PosNum) : (minFac n : ℕ) = Nat.minFac n := by\n  cases' n with n\n  · rfl\n  · rw [minFac, Nat.minFac_eq, if_neg]\n    swap\n    · simp [← two_mul]\n    rw [minFacAux_to_nat]\n    · rfl\n    simp only [cast_one, cast_bit1]\n    rw [Nat.sqrt_lt]\n    calc\n      (n : ℕ) + (n : ℕ) + 1 ≤ (n : ℕ) + (n : ℕ) + (n : ℕ) := by simp\n      _ = (n : ℕ) * (1 + 1 + 1) := by simp only [mul_add, mul_one]\n      _ < _ := by\n        set_option simprocs false in simp [mul_lt_mul]\n  · rw [minFac, Nat.minFac_eq, if_pos]\n    · rfl\n    simp [← two_mul]\n\n"}
{"name":"Num.minFac_to_nat","module":"Mathlib.Data.Num.Prime","initialProofState":"n : Num\n⊢ Eq (↑n.minFac) (↑n).minFac","decl":"@[simp]\ntheorem minFac_to_nat : ∀ n : Num, (minFac n : ℕ) = Nat.minFac n\n  | 0 => rfl\n  | pos _ => PosNum.minFac_to_nat _\n\n"}
