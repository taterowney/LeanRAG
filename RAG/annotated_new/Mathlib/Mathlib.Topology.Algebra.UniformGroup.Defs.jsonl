{"name":"UniformGroup.uniformContinuous_div","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : Group Œ±\nself : UniformGroup Œ±\n‚ä¢ UniformContinuous fun p => HDiv.hDiv p.1 p.2","decl":"/-- A uniform group is a group in which multiplication and inversion are uniformly continuous. -/\nclass UniformGroup (Œ± : Type*) [UniformSpace Œ±] [Group Œ±] : Prop where\n  uniformContinuous_div : UniformContinuous fun p : Œ± √ó Œ± => p.1 / p.2\n\n"}
{"name":"UniformAddGroup.uniformContinuous_sub","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : AddGroup Œ±\nself : UniformAddGroup Œ±\n‚ä¢ UniformContinuous fun p => HSub.hSub p.1 p.2","decl":"/-- A uniform additive group is an additive group in which addition\n  and negation are uniformly continuous. -/\nclass UniformAddGroup (Œ± : Type*) [UniformSpace Œ±] [AddGroup Œ±] : Prop where\n  uniformContinuous_sub : UniformContinuous fun p : Œ± √ó Œ± => p.1 - p.2\n\n"}
{"name":"UniformAddGroup.mk'","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : AddGroup Œ±\nh‚ÇÅ : UniformContinuous fun p => HAdd.hAdd p.1 p.2\nh‚ÇÇ : UniformContinuous fun p => Neg.neg p\n‚ä¢ UniformAddGroup Œ±","decl":"@[to_additive]\ntheorem UniformGroup.mk' {Œ±} [UniformSpace Œ±] [Group Œ±]\n    (h‚ÇÅ : UniformContinuous fun p : Œ± √ó Œ± => p.1 * p.2) (h‚ÇÇ : UniformContinuous fun p : Œ± => p‚Åª¬π) :\n    UniformGroup Œ± :=\n  ‚ü®by simpa only [div_eq_mul_inv] using\n    h‚ÇÅ.comp (uniformContinuous_fst.prod_mk (h‚ÇÇ.comp uniformContinuous_snd))‚ü©\n\n"}
{"name":"UniformGroup.mk'","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : Group Œ±\nh‚ÇÅ : UniformContinuous fun p => HMul.hMul p.1 p.2\nh‚ÇÇ : UniformContinuous fun p => Inv.inv p\n‚ä¢ UniformGroup Œ±","decl":"@[to_additive]\ntheorem UniformGroup.mk' {Œ±} [UniformSpace Œ±] [Group Œ±]\n    (h‚ÇÅ : UniformContinuous fun p : Œ± √ó Œ± => p.1 * p.2) (h‚ÇÇ : UniformContinuous fun p : Œ± => p‚Åª¬π) :\n    UniformGroup Œ± :=\n  ‚ü®by simpa only [div_eq_mul_inv] using\n    h‚ÇÅ.comp (uniformContinuous_fst.prod_mk (h‚ÇÇ.comp uniformContinuous_snd))‚ü©\n\n"}
{"name":"uniformContinuous_sub","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ UniformContinuous fun p => HSub.hSub p.1 p.2","decl":"@[to_additive]\ntheorem uniformContinuous_div : UniformContinuous fun p : Œ± √ó Œ± => p.1 / p.2 :=\n  UniformGroup.uniformContinuous_div\n\n"}
{"name":"uniformContinuous_div","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ UniformContinuous fun p => HDiv.hDiv p.1 p.2","decl":"@[to_additive]\ntheorem uniformContinuous_div : UniformContinuous fun p : Œ± √ó Œ± => p.1 / p.2 :=\n  UniformGroup.uniformContinuous_div\n\n"}
{"name":"UniformContinuous.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf g : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous fun x => HSub.hSub (f x) (g x)","decl":"@[to_additive]\ntheorem UniformContinuous.div [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x / g x :=\n  uniformContinuous_div.comp (hf.prod_mk hg)\n\n"}
{"name":"UniformContinuous.div","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf g : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous fun x => HDiv.hDiv (f x) (g x)","decl":"@[to_additive]\ntheorem UniformContinuous.div [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x / g x :=\n  uniformContinuous_div.comp (hf.prod_mk hg)\n\n"}
{"name":"UniformContinuous.neg","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\n‚ä¢ UniformContinuous fun x => Neg.neg (f x)","decl":"@[to_additive]\ntheorem UniformContinuous.inv [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    UniformContinuous fun x => (f x)‚Åª¬π := by\n  have : UniformContinuous fun x => 1 / f x := uniformContinuous_const.div hf\n  simp_all\n\n"}
{"name":"UniformContinuous.inv","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\n‚ä¢ UniformContinuous fun x => Inv.inv (f x)","decl":"@[to_additive]\ntheorem UniformContinuous.inv [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    UniformContinuous fun x => (f x)‚Åª¬π := by\n  have : UniformContinuous fun x => 1 / f x := uniformContinuous_const.div hf\n  simp_all\n\n"}
{"name":"uniformContinuous_neg","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ UniformContinuous fun x => Neg.neg x","decl":"@[to_additive]\ntheorem uniformContinuous_inv : UniformContinuous fun x : Œ± => x‚Åª¬π :=\n  uniformContinuous_id.inv\n\n"}
{"name":"uniformContinuous_inv","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ UniformContinuous fun x => Inv.inv x","decl":"@[to_additive]\ntheorem uniformContinuous_inv : UniformContinuous fun x : Œ± => x‚Åª¬π :=\n  uniformContinuous_id.inv\n\n"}
{"name":"UniformContinuous.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf g : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous fun x => HMul.hMul (f x) (g x)","decl":"@[to_additive]\ntheorem UniformContinuous.mul [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x * g x := by\n  have : UniformContinuous fun x => f x / (g x)‚Åª¬π := hf.div hg.inv\n  simp_all\n\n"}
{"name":"UniformContinuous.add","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf g : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nhg : UniformContinuous g\n‚ä¢ UniformContinuous fun x => HAdd.hAdd (f x) (g x)","decl":"@[to_additive]\ntheorem UniformContinuous.mul [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x * g x := by\n  have : UniformContinuous fun x => f x / (g x)‚Åª¬π := hf.div hg.inv\n  simp_all\n\n"}
{"name":"uniformContinuous_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ UniformContinuous fun p => HMul.hMul p.1 p.2","decl":"@[to_additive]\ntheorem uniformContinuous_mul : UniformContinuous fun p : Œ± √ó Œ± => p.1 * p.2 :=\n  uniformContinuous_fst.mul uniformContinuous_snd\n\n"}
{"name":"uniformContinuous_add","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ UniformContinuous fun p => HAdd.hAdd p.1 p.2","decl":"@[to_additive]\ntheorem uniformContinuous_mul : UniformContinuous fun p : Œ± √ó Œ± => p.1 * p.2 :=\n  uniformContinuous_fst.mul uniformContinuous_snd\n\n"}
{"name":"UniformContinuous.mul_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HMul.hMul (f x) a","decl":"@[to_additive]\ntheorem UniformContinuous.mul_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ f x * a :=\n  hf.mul uniformContinuous_const\n\n"}
{"name":"UniformContinuous.add_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HAdd.hAdd (f x) a","decl":"@[to_additive]\ntheorem UniformContinuous.mul_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ f x * a :=\n  hf.mul uniformContinuous_const\n\n"}
{"name":"UniformContinuous.const_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HMul.hMul a (f x)","decl":"@[to_additive]\ntheorem UniformContinuous.const_mul [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ a * f x :=\n  uniformContinuous_const.mul hf\n\n"}
{"name":"UniformContinuous.const_add","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HAdd.hAdd a (f x)","decl":"@[to_additive]\ntheorem UniformContinuous.const_mul [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ a * f x :=\n  uniformContinuous_const.mul hf\n\n"}
{"name":"uniformContinuous_mul_left","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HMul.hMul a b","decl":"@[to_additive]\ntheorem uniformContinuous_mul_left (a : Œ±) : UniformContinuous fun b : Œ± => a * b :=\n  uniformContinuous_id.const_mul _\n\n"}
{"name":"uniformContinuous_add_left","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HAdd.hAdd a b","decl":"@[to_additive]\ntheorem uniformContinuous_mul_left (a : Œ±) : UniformContinuous fun b : Œ± => a * b :=\n  uniformContinuous_id.const_mul _\n\n"}
{"name":"uniformContinuous_mul_right","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HMul.hMul b a","decl":"@[to_additive]\ntheorem uniformContinuous_mul_right (a : Œ±) : UniformContinuous fun b : Œ± => b * a :=\n  uniformContinuous_id.mul_const _\n\n"}
{"name":"uniformContinuous_add_right","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HAdd.hAdd b a","decl":"@[to_additive]\ntheorem uniformContinuous_mul_right (a : Œ±) : UniformContinuous fun b : Œ± => b * a :=\n  uniformContinuous_id.mul_const _\n\n"}
{"name":"UniformContinuous.div_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HDiv.hDiv (f x) a","decl":"@[to_additive]\ntheorem UniformContinuous.div_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ f x / a :=\n  hf.div uniformContinuous_const\n\n"}
{"name":"UniformContinuous.sub_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\na : Œ±\n‚ä¢ UniformContinuous fun x => HSub.hSub (f x) a","decl":"@[to_additive]\ntheorem UniformContinuous.div_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f)\n    (a : Œ±) : UniformContinuous fun x ‚Ü¶ f x / a :=\n  hf.div uniformContinuous_const\n\n"}
{"name":"uniformContinuous_div_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HDiv.hDiv b a","decl":"@[to_additive]\ntheorem uniformContinuous_div_const (a : Œ±) : UniformContinuous fun b : Œ± => b / a :=\n  uniformContinuous_id.div_const _\n\n"}
{"name":"uniformContinuous_sub_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\na : Œ±\n‚ä¢ UniformContinuous fun b => HSub.hSub b a","decl":"@[to_additive]\ntheorem uniformContinuous_div_const (a : Œ±) : UniformContinuous fun b : Œ± => b / a :=\n  uniformContinuous_id.div_const _\n\n"}
{"name":"UniformContinuous.const_nsmul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nn : Nat\n‚ä¢ UniformContinuous fun x => HSMul.hSMul n (f x)","decl":"@[to_additive UniformContinuous.const_nsmul]\ntheorem UniformContinuous.pow_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    ‚àÄ n : ‚Ñï, UniformContinuous fun x => f x ^ n\n  | 0 => by\n    simp_rw [pow_zero]\n    exact uniformContinuous_const\n  | n + 1 => by\n    simp_rw [pow_succ']\n    exact hf.mul (hf.pow_const n)\n\n"}
{"name":"UniformContinuous.pow_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nn : Nat\n‚ä¢ UniformContinuous fun x => HPow.hPow (f x) n","decl":"@[to_additive UniformContinuous.const_nsmul]\ntheorem UniformContinuous.pow_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    ‚àÄ n : ‚Ñï, UniformContinuous fun x => f x ^ n\n  | 0 => by\n    simp_rw [pow_zero]\n    exact uniformContinuous_const\n  | n + 1 => by\n    simp_rw [pow_succ']\n    exact hf.mul (hf.pow_const n)\n\n"}
{"name":"uniformContinuous_const_nsmul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nn : Nat\n‚ä¢ UniformContinuous fun x => HSMul.hSMul n x","decl":"@[to_additive uniformContinuous_const_nsmul]\ntheorem uniformContinuous_pow_const (n : ‚Ñï) : UniformContinuous fun x : Œ± => x ^ n :=\n  uniformContinuous_id.pow_const n\n\n"}
{"name":"uniformContinuous_pow_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nn : Nat\n‚ä¢ UniformContinuous fun x => HPow.hPow x n","decl":"@[to_additive uniformContinuous_const_nsmul]\ntheorem uniformContinuous_pow_const (n : ‚Ñï) : UniformContinuous fun x : Œ± => x ^ n :=\n  uniformContinuous_id.pow_const n\n\n"}
{"name":"UniformContinuous.zpow_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nn : Int\n‚ä¢ UniformContinuous fun x => HPow.hPow (f x) n","decl":"@[to_additive UniformContinuous.const_zsmul]\ntheorem UniformContinuous.zpow_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    ‚àÄ n : ‚Ñ§, UniformContinuous fun x => f x ^ n\n  | (n : ‚Ñï) => by\n    simp_rw [zpow_natCast]\n    exact hf.pow_const _\n  | Int.negSucc n => by\n    simp_rw [zpow_negSucc]\n    exact (hf.pow_const _).inv\n\n"}
{"name":"UniformContinuous.const_zsmul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : UniformSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : UniformContinuous f\nn : Int\n‚ä¢ UniformContinuous fun x => HSMul.hSMul n (f x)","decl":"@[to_additive UniformContinuous.const_zsmul]\ntheorem UniformContinuous.zpow_const [UniformSpace Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : UniformContinuous f) :\n    ‚àÄ n : ‚Ñ§, UniformContinuous fun x => f x ^ n\n  | (n : ‚Ñï) => by\n    simp_rw [zpow_natCast]\n    exact hf.pow_const _\n  | Int.negSucc n => by\n    simp_rw [zpow_negSucc]\n    exact (hf.pow_const _).inv\n\n"}
{"name":"uniformContinuous_const_zsmul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nn : Int\n‚ä¢ UniformContinuous fun x => HSMul.hSMul n x","decl":"@[to_additive uniformContinuous_const_zsmul]\ntheorem uniformContinuous_zpow_const (n : ‚Ñ§) : UniformContinuous fun x : Œ± => x ^ n :=\n  uniformContinuous_id.zpow_const n\n\n"}
{"name":"uniformContinuous_zpow_const","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nn : Int\n‚ä¢ UniformContinuous fun x => HPow.hPow x n","decl":"@[to_additive uniformContinuous_const_zsmul]\ntheorem uniformContinuous_zpow_const (n : ‚Ñ§) : UniformContinuous fun x : Œ± => x ^ n :=\n  uniformContinuous_id.zpow_const n\n\n"}
{"name":"UniformAddGroup.to_topologicalAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ TopologicalAddGroup Œ±","decl":"@[to_additive]\ninstance (priority := 10) UniformGroup.to_topologicalGroup : TopologicalGroup Œ± where\n  continuous_mul := uniformContinuous_mul.continuous\n  continuous_inv := uniformContinuous_inv.continuous\n\n"}
{"name":"UniformGroup.to_topologicalGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ TopologicalGroup Œ±","decl":"@[to_additive]\ninstance (priority := 10) UniformGroup.to_topologicalGroup : TopologicalGroup Œ± where\n  continuous_mul := uniformContinuous_mul.continuous\n  continuous_inv := uniformContinuous_inv.continuous\n\n"}
{"name":"instUniformGroupProd","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : UniformSpace Œ±\ninst‚úù‚Å¥ : Group Œ±\ninst‚úù¬≥ : UniformGroup Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : Group Œ≤\ninst‚úù : UniformGroup Œ≤\n‚ä¢ UniformGroup (Prod Œ± Œ≤)","decl":"@[to_additive]\ninstance [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤] : UniformGroup (Œ± √ó Œ≤) :=\n  ‚ü®((uniformContinuous_fst.comp uniformContinuous_fst).div\n          (uniformContinuous_fst.comp uniformContinuous_snd)).prod_mk\n      ((uniformContinuous_snd.comp uniformContinuous_fst).div\n        (uniformContinuous_snd.comp uniformContinuous_snd))‚ü©\n\n"}
{"name":"instUniformAddGroupSum","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : UniformSpace Œ±\ninst‚úù‚Å¥ : AddGroup Œ±\ninst‚úù¬≥ : UniformAddGroup Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : UniformAddGroup Œ≤\n‚ä¢ UniformAddGroup (Prod Œ± Œ≤)","decl":"@[to_additive]\ninstance [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤] : UniformGroup (Œ± √ó Œ≤) :=\n  ‚ü®((uniformContinuous_fst.comp uniformContinuous_fst).div\n          (uniformContinuous_fst.comp uniformContinuous_snd)).prod_mk\n      ((uniformContinuous_snd.comp uniformContinuous_fst).div\n        (uniformContinuous_snd.comp uniformContinuous_snd))‚ü©\n\n"}
{"name":"uniformity_translate_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\na : Œ±\n‚ä¢ Eq (Filter.map (fun x => { fst := HMul.hMul x.1 a, snd := HMul.hMul x.2 a }) (uniformity Œ±)) (uniformity Œ±)","decl":"@[to_additive]\ntheorem uniformity_translate_mul (a : Œ±) : ((ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a, x.2 * a)) = ùì§ Œ± :=\n  le_antisymm (uniformContinuous_id.mul uniformContinuous_const)\n    (calc\n      ùì§ Œ± =\n          ((ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a‚Åª¬π, x.2 * a‚Åª¬π)).map fun x : Œ± √ó Œ± =>\n            (x.1 * a, x.2 * a) := by simp [Filter.map_map, Function.comp_def]\n      _ ‚â§ (ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a, x.2 * a) :=\n        Filter.map_mono (uniformContinuous_id.mul uniformContinuous_const)\n      )\n\n"}
{"name":"uniformity_translate_add","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\na : Œ±\n‚ä¢ Eq (Filter.map (fun x => { fst := HAdd.hAdd x.1 a, snd := HAdd.hAdd x.2 a }) (uniformity Œ±)) (uniformity Œ±)","decl":"@[to_additive]\ntheorem uniformity_translate_mul (a : Œ±) : ((ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a, x.2 * a)) = ùì§ Œ± :=\n  le_antisymm (uniformContinuous_id.mul uniformContinuous_const)\n    (calc\n      ùì§ Œ± =\n          ((ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a‚Åª¬π, x.2 * a‚Åª¬π)).map fun x : Œ± √ó Œ± =>\n            (x.1 * a, x.2 * a) := by simp [Filter.map_map, Function.comp_def]\n      _ ‚â§ (ùì§ Œ±).map fun x : Œ± √ó Œ± => (x.1 * a, x.2 * a) :=\n        Filter.map_mono (uniformContinuous_id.mul uniformContinuous_const)\n      )\n\n"}
{"name":"AddOpposite.instUniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ UniformAddGroup (AddOpposite Œ±)","decl":"@[to_additive]\ninstance : UniformGroup Œ±·µê·µí·µñ :=\n  ‚ü®uniformContinuous_op.comp\n      ((uniformContinuous_unop.comp uniformContinuous_snd).inv.mul <|\n        uniformContinuous_unop.comp uniformContinuous_fst)‚ü©\n\n"}
{"name":"MulOpposite.instUniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ UniformGroup (MulOpposite Œ±)","decl":"@[to_additive]\ninstance : UniformGroup Œ±·µê·µí·µñ :=\n  ‚ü®uniformContinuous_op.comp\n      ((uniformContinuous_unop.comp uniformContinuous_snd).inv.mul <|\n        uniformContinuous_unop.comp uniformContinuous_fst)‚ü©\n\n"}
{"name":"uniformAddGroup_sInf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : AddGroup Œ≤\nus : Set (UniformSpace Œ≤)\nh : ‚àÄ (u : UniformSpace Œ≤), Membership.mem us u ‚Üí UniformAddGroup Œ≤\n‚ä¢ UniformAddGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_sInf {us : Set (UniformSpace Œ≤)} (h : ‚àÄ u ‚àà us, @UniformGroup Œ≤ u _) :\n    @UniformGroup Œ≤ (sInf us) _ :=\n  -- Porting note: {_} does not find `sInf us` instance, see `continuousSMul_sInf`\n  @UniformGroup.mk Œ≤ (_) _ <|\n    uniformContinuous_sInf_rng.mpr fun u hu =>\n      uniformContinuous_sInf_dom‚ÇÇ hu hu (@UniformGroup.uniformContinuous_div Œ≤ u _ (h u hu))\n\n"}
{"name":"uniformGroup_sInf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : Group Œ≤\nus : Set (UniformSpace Œ≤)\nh : ‚àÄ (u : UniformSpace Œ≤), Membership.mem us u ‚Üí UniformGroup Œ≤\n‚ä¢ UniformGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_sInf {us : Set (UniformSpace Œ≤)} (h : ‚àÄ u ‚àà us, @UniformGroup Œ≤ u _) :\n    @UniformGroup Œ≤ (sInf us) _ :=\n  -- Porting note: {_} does not find `sInf us` instance, see `continuousSMul_sInf`\n  @UniformGroup.mk Œ≤ (_) _ <|\n    uniformContinuous_sInf_rng.mpr fun u hu =>\n      uniformContinuous_sInf_dom‚ÇÇ hu hu (@UniformGroup.uniformContinuous_div Œ≤ u _ (h u hu))\n\n"}
{"name":"uniformGroup_iInf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : Group Œ≤\nŒπ : Sort u_3\nus' : Œπ ‚Üí UniformSpace Œ≤\nh' : ‚àÄ (i : Œπ), UniformGroup Œ≤\n‚ä¢ UniformGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_iInf {Œπ : Sort*} {us' : Œπ ‚Üí UniformSpace Œ≤}\n    (h' : ‚àÄ i, @UniformGroup Œ≤ (us' i) _) : @UniformGroup Œ≤ (‚®Ö i, us' i) _ := by\n  rw [‚Üê sInf_range]\n  exact uniformGroup_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"uniformAddGroup_iInf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : AddGroup Œ≤\nŒπ : Sort u_3\nus' : Œπ ‚Üí UniformSpace Œ≤\nh' : ‚àÄ (i : Œπ), UniformAddGroup Œ≤\n‚ä¢ UniformAddGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_iInf {Œπ : Sort*} {us' : Œπ ‚Üí UniformSpace Œ≤}\n    (h' : ‚àÄ i, @UniformGroup Œ≤ (us' i) _) : @UniformGroup Œ≤ (‚®Ö i, us' i) _ := by\n  rw [‚Üê sInf_range]\n  exact uniformGroup_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"uniformAddGroup_inf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : AddGroup Œ≤\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ≤\nh‚ÇÅ : UniformAddGroup Œ≤\nh‚ÇÇ : UniformAddGroup Œ≤\n‚ä¢ UniformAddGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_inf {u‚ÇÅ u‚ÇÇ : UniformSpace Œ≤} (h‚ÇÅ : @UniformGroup Œ≤ u‚ÇÅ _)\n    (h‚ÇÇ : @UniformGroup Œ≤ u‚ÇÇ _) : @UniformGroup Œ≤ (u‚ÇÅ ‚äì u‚ÇÇ) _ := by\n  rw [inf_eq_iInf]\n  refine uniformGroup_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"uniformGroup_inf","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ≤ : Type u_2\ninst‚úù : Group Œ≤\nu‚ÇÅ u‚ÇÇ : UniformSpace Œ≤\nh‚ÇÅ : UniformGroup Œ≤\nh‚ÇÇ : UniformGroup Œ≤\n‚ä¢ UniformGroup Œ≤","decl":"@[to_additive]\ntheorem uniformGroup_inf {u‚ÇÅ u‚ÇÇ : UniformSpace Œ≤} (h‚ÇÅ : @UniformGroup Œ≤ u‚ÇÅ _)\n    (h‚ÇÇ : @UniformGroup Œ≤ u‚ÇÇ _) : @UniformGroup Œ≤ (u‚ÇÅ ‚äì u‚ÇÇ) _ := by\n  rw [inf_eq_iInf]\n  refine uniformGroup_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"uniformity_eq_comap_nhds_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HDiv.hDiv x.2 x.1) (nhds 1))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one : ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.2 / x.1) (ùìù (1 : Œ±)) := by\n  rw [nhds_eq_comap_uniformity, Filter.comap_comap]\n  refine le_antisymm (Filter.map_le_iff_le_comap.1 ?_) ?_\n  ¬∑ intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_div hs with ‚ü®t, ht, hts‚ü©\n    refine mem_map.2 (mem_of_superset ht ?_)\n    rintro ‚ü®a, b‚ü©\n    simpa [subset_def] using hts a b a\n  ¬∑ intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_mul hs with ‚ü®t, ht, hts‚ü©\n    refine ‚ü®_, ht, ?_‚ü©\n    rintro ‚ü®a, b‚ü©\n    simpa [subset_def] using hts 1 (b / a) a\n\n"}
{"name":"uniformity_eq_comap_nhds_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HSub.hSub x.2 x.1) (nhds 0))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one : ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.2 / x.1) (ùìù (1 : Œ±)) := by\n  rw [nhds_eq_comap_uniformity, Filter.comap_comap]\n  refine le_antisymm (Filter.map_le_iff_le_comap.1 ?_) ?_\n  ¬∑ intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_div hs with ‚ü®t, ht, hts‚ü©\n    refine mem_map.2 (mem_of_superset ht ?_)\n    rintro ‚ü®a, b‚ü©\n    simpa [subset_def] using hts a b a\n  ¬∑ intro s hs\n    rcases mem_uniformity_of_uniformContinuous_invariant uniformContinuous_mul hs with ‚ü®t, ht, hts‚ü©\n    refine ‚ü®_, ht, ?_‚ü©\n    rintro ‚ü®a, b‚ü©\n    simpa [subset_def] using hts 1 (b / a) a\n\n"}
{"name":"uniformity_eq_comap_nhds_zero_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HSub.hSub x.1 x.2) (nhds 0))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one_swapped :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.1 / x.2) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap]\n  rfl\n\n"}
{"name":"uniformity_eq_comap_nhds_one_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HDiv.hDiv x.1 x.2) (nhds 1))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one_swapped :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.1 / x.2) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap]\n  rfl\n\n"}
{"name":"UniformAddGroup.ext","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_3\ninst‚úù : AddGroup G\nu v : UniformSpace G\nhu : UniformAddGroup G\nhv : UniformAddGroup G\nh : Eq (nhds 0) (nhds 0)\n‚ä¢ Eq u v","decl":"@[to_additive]\ntheorem UniformGroup.ext {G : Type*} [Group G] {u v : UniformSpace G} (hu : @UniformGroup G u _)\n    (hv : @UniformGroup G v _)\n    (h : @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1) : u = v :=\n  UniformSpace.ext <| by\n    rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]\n\n"}
{"name":"UniformGroup.ext","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_3\ninst‚úù : Group G\nu v : UniformSpace G\nhu : UniformGroup G\nhv : UniformGroup G\nh : Eq (nhds 1) (nhds 1)\n‚ä¢ Eq u v","decl":"@[to_additive]\ntheorem UniformGroup.ext {G : Type*} [Group G] {u v : UniformSpace G} (hu : @UniformGroup G u _)\n    (hv : @UniformGroup G v _)\n    (h : @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1) : u = v :=\n  UniformSpace.ext <| by\n    rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]\n\n"}
{"name":"UniformAddGroup.ext_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_3\ninst‚úù : AddGroup G\nu v : UniformSpace G\nhu : UniformAddGroup G\nhv : UniformAddGroup G\n‚ä¢ Iff (Eq u v) (Eq (nhds 0) (nhds 0))","decl":"@[to_additive]\ntheorem UniformGroup.ext_iff {G : Type*} [Group G] {u v : UniformSpace G}\n    (hu : @UniformGroup G u _) (hv : @UniformGroup G v _) :\n    u = v ‚Üî @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1 :=\n  ‚ü®fun h => h ‚ñ∏ rfl, hu.ext hv‚ü©\n\n"}
{"name":"UniformGroup.ext_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_3\ninst‚úù : Group G\nu v : UniformSpace G\nhu : UniformGroup G\nhv : UniformGroup G\n‚ä¢ Iff (Eq u v) (Eq (nhds 1) (nhds 1))","decl":"@[to_additive]\ntheorem UniformGroup.ext_iff {G : Type*} [Group G] {u v : UniformSpace G}\n    (hu : @UniformGroup G u _) (hv : @UniformGroup G v _) :\n    u = v ‚Üî @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1 :=\n  ‚ü®fun h => h ‚ñ∏ rfl, hu.ext hv‚ü©\n\n"}
{"name":"UniformGroup.uniformity_countably_generated","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : Group Œ±\ninst‚úù¬π : UniformGroup Œ±\ninst‚úù : (nhds 1).IsCountablyGenerated\n‚ä¢ (uniformity Œ±).IsCountablyGenerated","decl":"@[to_additive]\ntheorem UniformGroup.uniformity_countably_generated [(ùìù (1 : Œ±)).IsCountablyGenerated] :\n    (ùì§ Œ±).IsCountablyGenerated := by\n  rw [uniformity_eq_comap_nhds_one]\n  exact Filter.comap.isCountablyGenerated _ _\n\n"}
{"name":"UniformAddGroup.uniformity_countably_generated","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≥ : UniformSpace Œ±\ninst‚úù¬≤ : AddGroup Œ±\ninst‚úù¬π : UniformAddGroup Œ±\ninst‚úù : (nhds 0).IsCountablyGenerated\n‚ä¢ (uniformity Œ±).IsCountablyGenerated","decl":"@[to_additive]\ntheorem UniformGroup.uniformity_countably_generated [(ùìù (1 : Œ±)).IsCountablyGenerated] :\n    (ùì§ Œ±).IsCountablyGenerated := by\n  rw [uniformity_eq_comap_nhds_one]\n  exact Filter.comap.isCountablyGenerated _ _\n\n"}
{"name":"uniformity_eq_comap_inv_mul_nhds_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HMul.hMul (Inv.inv x.1) x.2) (nhds 1))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.1‚Åª¬π * x.2) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_uniformity_mulOpposite, uniformity_eq_comap_nhds_one, ‚Üê op_one, ‚Üê comap_unop_nhds,\n    comap_comap, comap_comap]\n  simp [Function.comp_def]\n\n"}
{"name":"uniformity_eq_comap_neg_add_nhds_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HAdd.hAdd (Neg.neg x.1) x.2) (nhds 0))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.1‚Åª¬π * x.2) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_uniformity_mulOpposite, uniformity_eq_comap_nhds_one, ‚Üê op_one, ‚Üê comap_unop_nhds,\n    comap_comap, comap_comap]\n  simp [Function.comp_def]\n\n"}
{"name":"uniformity_eq_comap_inv_mul_nhds_one_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HMul.hMul (Inv.inv x.2) x.1) (nhds 1))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.2‚Åª¬π * x.1) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap]\n  rfl\n\n"}
{"name":"uniformity_eq_comap_neg_add_nhds_zero_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun x => HAdd.hAdd (Neg.neg x.2) x.1) (nhds 0))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    ùì§ Œ± = comap (fun x : Œ± √ó Œ± => x.2‚Åª¬π * x.1) (ùìù (1 : Œ±)) := by\n  rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap]\n  rfl\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 1).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HDiv.hDiv x.2 x.1)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.2 / x.1 ‚àà U i } := by\n  rw [uniformity_eq_comap_nhds_one]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 0).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HSub.hSub x.2 x.1)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.2 / x.1 ‚àà U i } := by\n  rw [uniformity_eq_comap_nhds_one]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_zero_neg_add","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 0).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HAdd.hAdd (Neg.neg x.1) x.2)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.1‚Åª¬π * x.2 ‚àà U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_one_inv_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 1).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HMul.hMul (Inv.inv x.1) x.2)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.1‚Åª¬π * x.2 ‚àà U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_zero_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 0).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HSub.hSub x.1 x.2)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_swapped {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.1 / x.2 ‚àà U i } := by\n  rw [uniformity_eq_comap_nhds_one_swapped]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_one_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 1).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HDiv.hDiv x.1 x.2)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_swapped {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.1 / x.2 ‚àà U i } := by\n  rw [uniformity_eq_comap_nhds_one_swapped]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_zero_neg_add_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : UniformAddGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 0).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HAdd.hAdd (Neg.neg x.2) x.1)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.2‚Åª¬π * x.1 ‚àà U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]\n  exact h.comap _\n\n"}
{"name":"Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : UniformSpace Œ±\ninst‚úù¬π : Group Œ±\ninst‚úù : UniformGroup Œ±\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\nU : Œπ ‚Üí Set Œ±\nh : (nhds 1).HasBasis p U\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun x => Membership.mem (U i) (HMul.hMul (Inv.inv x.2) x.1)","decl":"@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí Set Œ±}\n    (h : (ùìù (1 : Œ±)).HasBasis p U) :\n    (ùì§ Œ±).HasBasis p fun i => { x : Œ± √ó Œ± | x.2‚Åª¬π * x.1 ‚àà U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]\n  exact h.comap _\n\n"}
{"name":"uniformContinuous_of_tendsto_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : Group Œ±\ninst‚úù‚Åµ : UniformGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : Group Œ≤\ninst‚úù¬≤ : UniformGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : MonoidHomClass hom Œ± Œ≤\nf : hom\nh : Filter.Tendsto (‚áëf) (nhds 1) (nhds 1)\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem uniformContinuous_of_tendsto_one {hom : Type*} [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤]\n    [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤] {f : hom} (h : Tendsto f (ùìù 1) (ùìù 1)) :\n    UniformContinuous f := by\n  have :\n    ((fun x : Œ≤ √ó Œ≤ => x.2 / x.1) ‚àò fun x : Œ± √ó Œ± => (f x.1, f x.2)) = fun x : Œ± √ó Œ± =>\n      f (x.2 / x.1) := by ext; simp only [Function.comp_apply, map_div]\n  rw [UniformContinuous, uniformity_eq_comap_nhds_one Œ±, uniformity_eq_comap_nhds_one Œ≤,\n    tendsto_comap_iff, this]\n  exact Tendsto.comp h tendsto_comap\n\n"}
{"name":"uniformContinuous_of_tendsto_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : AddGroup Œ±\ninst‚úù‚Åµ : UniformAddGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : AddGroup Œ≤\ninst‚úù¬≤ : UniformAddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : AddMonoidHomClass hom Œ± Œ≤\nf : hom\nh : Filter.Tendsto (‚áëf) (nhds 0) (nhds 0)\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem uniformContinuous_of_tendsto_one {hom : Type*} [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤]\n    [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤] {f : hom} (h : Tendsto f (ùìù 1) (ùìù 1)) :\n    UniformContinuous f := by\n  have :\n    ((fun x : Œ≤ √ó Œ≤ => x.2 / x.1) ‚àò fun x : Œ± √ó Œ± => (f x.1, f x.2)) = fun x : Œ± √ó Œ± =>\n      f (x.2 / x.1) := by ext; simp only [Function.comp_apply, map_div]\n  rw [UniformContinuous, uniformity_eq_comap_nhds_one Œ±, uniformity_eq_comap_nhds_one Œ≤,\n    tendsto_comap_iff, this]\n  exact Tendsto.comp h tendsto_comap\n\n"}
{"name":"uniformContinuous_of_continuousAt_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : AddGroup Œ±\ninst‚úù‚Åµ : UniformAddGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : AddGroup Œ≤\ninst‚úù¬≤ : UniformAddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : AddMonoidHomClass hom Œ± Œ≤\nf : hom\nhf : ContinuousAt (‚áëf) 0\n‚ä¢ UniformContinuous ‚áëf","decl":"/-- A group homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) between\ntwo uniform groups is uniformly continuous provided that it is continuous at one. See also\n`continuous_of_continuousAt_one`. -/\n@[to_additive \"An additive group homomorphism (a bundled morphism of a type that implements\n`AddMonoidHomClass`) between two uniform additive groups is uniformly continuous provided that it\nis continuous at zero. See also `continuous_of_continuousAt_zero`.\"]\ntheorem uniformContinuous_of_continuousAt_one {hom : Type*} [UniformSpace Œ≤] [Group Œ≤]\n    [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤]\n    (f : hom) (hf : ContinuousAt f 1) :\n    UniformContinuous f :=\n  uniformContinuous_of_tendsto_one (by simpa using hf.tendsto)\n\n"}
{"name":"uniformContinuous_of_continuousAt_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : Group Œ±\ninst‚úù‚Åµ : UniformGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : Group Œ≤\ninst‚úù¬≤ : UniformGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : MonoidHomClass hom Œ± Œ≤\nf : hom\nhf : ContinuousAt (‚áëf) 1\n‚ä¢ UniformContinuous ‚áëf","decl":"/-- A group homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) between\ntwo uniform groups is uniformly continuous provided that it is continuous at one. See also\n`continuous_of_continuousAt_one`. -/\n@[to_additive \"An additive group homomorphism (a bundled morphism of a type that implements\n`AddMonoidHomClass`) between two uniform additive groups is uniformly continuous provided that it\nis continuous at zero. See also `continuous_of_continuousAt_zero`.\"]\ntheorem uniformContinuous_of_continuousAt_one {hom : Type*} [UniformSpace Œ≤] [Group Œ≤]\n    [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤]\n    (f : hom) (hf : ContinuousAt f 1) :\n    UniformContinuous f :=\n  uniformContinuous_of_tendsto_one (by simpa using hf.tendsto)\n\n"}
{"name":"MonoidHom.uniformContinuous_of_continuousAt_one","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : UniformSpace Œ±\ninst‚úù‚Å¥ : Group Œ±\ninst‚úù¬≥ : UniformGroup Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : Group Œ≤\ninst‚úù : UniformGroup Œ≤\nf : MonoidHom Œ± Œ≤\nhf : ContinuousAt (‚áëf) 1\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem MonoidHom.uniformContinuous_of_continuousAt_one [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤]\n    (f : Œ± ‚Üí* Œ≤) (hf : ContinuousAt f 1) : UniformContinuous f :=\n  _root_.uniformContinuous_of_continuousAt_one f hf\n\n"}
{"name":"AddMonoidHom.uniformContinuous_of_continuousAt_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : UniformSpace Œ±\ninst‚úù‚Å¥ : AddGroup Œ±\ninst‚úù¬≥ : UniformAddGroup Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : UniformAddGroup Œ≤\nf : AddMonoidHom Œ± Œ≤\nhf : ContinuousAt (‚áëf) 0\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem MonoidHom.uniformContinuous_of_continuousAt_one [UniformSpace Œ≤] [Group Œ≤] [UniformGroup Œ≤]\n    (f : Œ± ‚Üí* Œ≤) (hf : ContinuousAt f 1) : UniformContinuous f :=\n  _root_.uniformContinuous_of_continuousAt_one f hf\n\n"}
{"name":"UniformGroup.uniformContinuous_iff_isOpen_ker","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∏ : UniformSpace Œ±\ninst‚úù‚Å∑ : Group Œ±\ninst‚úù‚Å∂ : UniformGroup Œ±\nhom : Type u_3\ninst‚úù‚Åµ : UniformSpace Œ≤\ninst‚úù‚Å¥ : DiscreteTopology Œ≤\ninst‚úù¬≥ : Group Œ≤\ninst‚úù¬≤ : UniformGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : MonoidHomClass hom Œ± Œ≤\nf : hom\n‚ä¢ Iff (UniformContinuous ‚áëf) (IsOpen ‚Üë(‚Üëf).ker)","decl":"/-- A homomorphism from a uniform group to a discrete uniform group is continuous if and only if\nits kernel is open. -/\n@[to_additive \"A homomorphism from a uniform additive group to a discrete uniform additive group is\ncontinuous if and only if its kernel is open.\"]\ntheorem UniformGroup.uniformContinuous_iff_isOpen_ker {hom : Type*} [UniformSpace Œ≤]\n    [DiscreteTopology Œ≤] [Group Œ≤] [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤]\n    {f : hom} :\n    UniformContinuous f ‚Üî IsOpen ((f : Œ± ‚Üí* Œ≤).ker : Set Œ±) := by\n  refine ‚ü®fun hf => ?_, fun hf => ?_‚ü©\n  ¬∑ apply (isOpen_discrete ({1} : Set Œ≤)).preimage hf.continuous\n  ¬∑ apply uniformContinuous_of_continuousAt_one\n    rw [ContinuousAt, nhds_discrete Œ≤, map_one, tendsto_pure]\n    exact hf.mem_nhds (map_one f)\n\n"}
{"name":"UniformAddGroup.uniformContinuous_iff_isOpen_ker","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∏ : UniformSpace Œ±\ninst‚úù‚Å∑ : AddGroup Œ±\ninst‚úù‚Å∂ : UniformAddGroup Œ±\nhom : Type u_3\ninst‚úù‚Åµ : UniformSpace Œ≤\ninst‚úù‚Å¥ : DiscreteTopology Œ≤\ninst‚úù¬≥ : AddGroup Œ≤\ninst‚úù¬≤ : UniformAddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : AddMonoidHomClass hom Œ± Œ≤\nf : hom\n‚ä¢ Iff (UniformContinuous ‚áëf) (IsOpen ‚Üë(‚Üëf).ker)","decl":"/-- A homomorphism from a uniform group to a discrete uniform group is continuous if and only if\nits kernel is open. -/\n@[to_additive \"A homomorphism from a uniform additive group to a discrete uniform additive group is\ncontinuous if and only if its kernel is open.\"]\ntheorem UniformGroup.uniformContinuous_iff_isOpen_ker {hom : Type*} [UniformSpace Œ≤]\n    [DiscreteTopology Œ≤] [Group Œ≤] [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤]\n    {f : hom} :\n    UniformContinuous f ‚Üî IsOpen ((f : Œ± ‚Üí* Œ≤).ker : Set Œ±) := by\n  refine ‚ü®fun hf => ?_, fun hf => ?_‚ü©\n  ¬∑ apply (isOpen_discrete ({1} : Set Œ≤)).preimage hf.continuous\n  ¬∑ apply uniformContinuous_of_continuousAt_one\n    rw [ContinuousAt, nhds_discrete Œ≤, map_one, tendsto_pure]\n    exact hf.mem_nhds (map_one f)\n\n"}
{"name":"UniformGroup.uniformContinuous_iff_open_ker","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∏ : UniformSpace Œ±\ninst‚úù‚Å∑ : Group Œ±\ninst‚úù‚Å∂ : UniformGroup Œ±\nhom : Type u_3\ninst‚úù‚Åµ : UniformSpace Œ≤\ninst‚úù‚Å¥ : DiscreteTopology Œ≤\ninst‚úù¬≥ : Group Œ≤\ninst‚úù¬≤ : UniformGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : MonoidHomClass hom Œ± Œ≤\nf : hom\n‚ä¢ Iff (UniformContinuous ‚áëf) (IsOpen ‚Üë(‚Üëf).ker)","decl":"@[deprecated (since := \"2024-11-18\")] alias UniformGroup.uniformContinuous_iff_open_ker :=\n  UniformGroup.uniformContinuous_iff_isOpen_ker\n"}
{"name":"UniformAddGroup.uniformContinuous_iff_open_ker","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∏ : UniformSpace Œ±\ninst‚úù‚Å∑ : AddGroup Œ±\ninst‚úù‚Å∂ : UniformAddGroup Œ±\nhom : Type u_3\ninst‚úù‚Åµ : UniformSpace Œ≤\ninst‚úù‚Å¥ : DiscreteTopology Œ≤\ninst‚úù¬≥ : AddGroup Œ≤\ninst‚úù¬≤ : UniformAddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : AddMonoidHomClass hom Œ± Œ≤\nf : hom\n‚ä¢ Iff (UniformContinuous ‚áëf) (IsOpen ‚Üë(‚Üëf).ker)","decl":"@[deprecated (since := \"2024-11-18\")] alias UniformAddGroup.uniformContinuous_iff_open_ker :=\n  UniformAddGroup.uniformContinuous_iff_isOpen_ker\n\n"}
{"name":"uniformContinuous_addMonoidHom_of_continuous","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : AddGroup Œ±\ninst‚úù‚Åµ : UniformAddGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : AddGroup Œ≤\ninst‚úù¬≤ : UniformAddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : AddMonoidHomClass hom Œ± Œ≤\nf : hom\nh : Continuous ‚áëf\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem uniformContinuous_monoidHom_of_continuous {hom : Type*} [UniformSpace Œ≤] [Group Œ≤]\n    [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤] {f : hom} (h : Continuous f) :\n    UniformContinuous f :=\n  uniformContinuous_of_tendsto_one <|\n    suffices Tendsto f (ùìù 1) (ùìù (f 1)) by rwa [map_one] at this\n    h.tendsto 1\n\n"}
{"name":"uniformContinuous_monoidHom_of_continuous","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : UniformSpace Œ±\ninst‚úù‚Å∂ : Group Œ±\ninst‚úù‚Åµ : UniformGroup Œ±\nhom : Type u_3\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : Group Œ≤\ninst‚úù¬≤ : UniformGroup Œ≤\ninst‚úù¬π : FunLike hom Œ± Œ≤\ninst‚úù : MonoidHomClass hom Œ± Œ≤\nf : hom\nh : Continuous ‚áëf\n‚ä¢ UniformContinuous ‚áëf","decl":"@[to_additive]\ntheorem uniformContinuous_monoidHom_of_continuous {hom : Type*} [UniformSpace Œ≤] [Group Œ≤]\n    [UniformGroup Œ≤] [FunLike hom Œ± Œ≤] [MonoidHomClass hom Œ± Œ≤] {f : hom} (h : Continuous f) :\n    UniformContinuous f :=\n  uniformContinuous_of_tendsto_one <|\n    suffices Tendsto f (ùìù 1) (ùìù (f 1)) by rwa [map_one] at this\n    h.tendsto 1\n\n"}
{"name":"uniformity_eq_comap_nhds_one'","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_1\ninst‚úù¬≤ : Group G\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalGroup G\n‚ä¢ Eq (uniformity G) (Filter.comap (fun p => HDiv.hDiv p.2 p.1) (nhds 1))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one' : ùì§ G = comap (fun p : G √ó G => p.2 / p.1) (ùìù (1 : G)) :=\n  rfl\n\n"}
{"name":"uniformity_eq_comap_nhds_zero'","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_1\ninst‚úù¬≤ : AddGroup G\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalAddGroup G\n‚ä¢ Eq (uniformity G) (Filter.comap (fun p => HSub.hSub p.2 p.1) (nhds 0))","decl":"@[to_additive]\ntheorem uniformity_eq_comap_nhds_one' : ùì§ G = comap (fun p : G √ó G => p.2 / p.1) (ùìù (1 : G)) :=\n  rfl\n\n"}
{"name":"comm_topologicalGroup_is_uniform","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_1\ninst‚úù¬≤ : CommGroup G\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalGroup G\n‚ä¢ UniformGroup G","decl":"@[to_additive]\n-- Porting note: renamed theorem to conform to naming convention\ntheorem comm_topologicalGroup_is_uniform : UniformGroup G := by\n  constructor\n  simp only [UniformContinuous, uniformity_prod_eq_prod, uniformity_eq_comap_nhds_one',\n    tendsto_comap_iff, tendsto_map'_iff, prod_comap_comap_eq, Function.comp_def,\n    div_div_div_comm _ (Prod.snd (Prod.snd _)), ‚Üê nhds_prod_eq, Prod.mk_one_one]\n  exact (continuous_div'.tendsto' 1 1 (div_one 1)).comp tendsto_comap\n\n"}
{"name":"comm_topologicalAddGroup_is_uniform","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_1\ninst‚úù¬≤ : AddCommGroup G\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalAddGroup G\n‚ä¢ UniformAddGroup G","decl":"@[to_additive]\n-- Porting note: renamed theorem to conform to naming convention\ntheorem comm_topologicalGroup_is_uniform : UniformGroup G := by\n  constructor\n  simp only [UniformContinuous, uniformity_prod_eq_prod, uniformity_eq_comap_nhds_one',\n    tendsto_comap_iff, tendsto_map'_iff, prod_comap_comap_eq, Function.comp_def,\n    div_div_div_comm _ (Prod.snd (Prod.snd _)), ‚Üê nhds_prod_eq, Prod.mk_one_one]\n  exact (continuous_div'.tendsto' 1 1 (div_one 1)).comp tendsto_comap\n\n"}
{"name":"UniformAddGroup.toUniformSpace_eq","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_2\nu : UniformSpace G\ninst‚úù¬π : AddGroup G\ninst‚úù : UniformAddGroup G\n‚ä¢ Eq (TopologicalAddGroup.toUniformSpace G) u","decl":"@[to_additive]\ntheorem UniformGroup.toUniformSpace_eq {G : Type*} [u : UniformSpace G] [Group G]\n    [UniformGroup G] : TopologicalGroup.toUniformSpace G = u := by\n  ext : 1\n  rw [uniformity_eq_comap_nhds_one' G, uniformity_eq_comap_nhds_one G]\n\n"}
{"name":"UniformGroup.toUniformSpace_eq","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"G : Type u_2\nu : UniformSpace G\ninst‚úù¬π : Group G\ninst‚úù : UniformGroup G\n‚ä¢ Eq (TopologicalGroup.toUniformSpace G) u","decl":"@[to_additive]\ntheorem UniformGroup.toUniformSpace_eq {G : Type*} [u : UniformSpace G] [Group G]\n    [UniformGroup G] : TopologicalGroup.toUniformSpace G = u := by\n  ext : 1\n  rw [uniformity_eq_comap_nhds_one' G, uniformity_eq_comap_nhds_one G]\n\n"}
{"name":"tendsto_sub_comap_self","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nhom : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : AddGroup Œ±\ninst‚úù‚Å¥ : TopologicalAddGroup Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : AddGroup Œ≤\ninst‚úù¬π : FunLike hom Œ≤ Œ±\ninst‚úù : AddMonoidHomClass hom Œ≤ Œ±\ne : hom\nde : IsDenseInducing ‚áëe\nx‚ÇÄ : Œ±\n‚ä¢ Filter.Tendsto (fun t => HSub.hSub t.2 t.1) (Filter.comap (fun p => { fst := e p.1, snd := e p.2 }) (nhds { fst := x‚ÇÄ, snd := x‚ÇÄ })) (nhds 0)","decl":"@[to_additive]\ntheorem tendsto_div_comap_self (de : IsDenseInducing e) (x‚ÇÄ : Œ±) :\n    Tendsto (fun t : Œ≤ √ó Œ≤ => t.2 / t.1) ((comap fun p : Œ≤ √ó Œ≤ => (e p.1, e p.2)) <| ùìù (x‚ÇÄ, x‚ÇÄ))\n      (ùìù 1) := by\n  have comm : ((fun x : Œ± √ó Œ± => x.2 / x.1) ‚àò fun t : Œ≤ √ó Œ≤ => (e t.1, e t.2)) =\n      e ‚àò fun t : Œ≤ √ó Œ≤ => t.2 / t.1 := by\n    ext t\n    change e t.2 / e t.1 = e (t.2 / t.1)\n    rw [‚Üê map_div e t.2 t.1]\n  have lim : Tendsto (fun x : Œ± √ó Œ± => x.2 / x.1) (ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù (e 1)) := by\n    simpa using (continuous_div'.comp (@continuous_swap Œ± Œ± _ _)).tendsto (x‚ÇÄ, x‚ÇÄ)\n  simpa using de.tendsto_comap_nhds_nhds lim comm\n\n"}
{"name":"tendsto_div_comap_self","module":"Mathlib.Topology.Algebra.UniformGroup.Defs","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nhom : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : Group Œ±\ninst‚úù‚Å¥ : TopologicalGroup Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : Group Œ≤\ninst‚úù¬π : FunLike hom Œ≤ Œ±\ninst‚úù : MonoidHomClass hom Œ≤ Œ±\ne : hom\nde : IsDenseInducing ‚áëe\nx‚ÇÄ : Œ±\n‚ä¢ Filter.Tendsto (fun t => HDiv.hDiv t.2 t.1) (Filter.comap (fun p => { fst := e p.1, snd := e p.2 }) (nhds { fst := x‚ÇÄ, snd := x‚ÇÄ })) (nhds 1)","decl":"@[to_additive]\ntheorem tendsto_div_comap_self (de : IsDenseInducing e) (x‚ÇÄ : Œ±) :\n    Tendsto (fun t : Œ≤ √ó Œ≤ => t.2 / t.1) ((comap fun p : Œ≤ √ó Œ≤ => (e p.1, e p.2)) <| ùìù (x‚ÇÄ, x‚ÇÄ))\n      (ùìù 1) := by\n  have comm : ((fun x : Œ± √ó Œ± => x.2 / x.1) ‚àò fun t : Œ≤ √ó Œ≤ => (e t.1, e t.2)) =\n      e ‚àò fun t : Œ≤ √ó Œ≤ => t.2 / t.1 := by\n    ext t\n    change e t.2 / e t.1 = e (t.2 / t.1)\n    rw [‚Üê map_div e t.2 t.1]\n  have lim : Tendsto (fun x : Œ± √ó Œ± => x.2 / x.1) (ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù (e 1)) := by\n    simpa using (continuous_div'.comp (@continuous_swap Œ± Œ± _ _)).tendsto (x‚ÇÄ, x‚ÇÄ)\n  simpa using de.tendsto_comap_nhds_nhds lim comm\n\n"}
