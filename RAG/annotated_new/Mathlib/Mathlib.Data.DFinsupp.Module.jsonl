{"name":"DFinsupp.smul_apply","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\nb : γ\nv : DFinsupp fun i => β i\ni : ι\n⊢ Eq ((HSMul.hSMul b v) i) (HSMul.hSMul b (v i))","decl":"theorem smul_apply [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (b : γ)\n    (v : Π₀ i, β i) (i : ι) : (b • v) i = b • v i :=\n  rfl\n\n"}
{"name":"DFinsupp.coe_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\nb : γ\nv : DFinsupp fun i => β i\n⊢ Eq (⇑(HSMul.hSMul b v)) (HSMul.hSMul b ⇑v)","decl":"@[simp, norm_cast]\ntheorem coe_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (b : γ)\n    (v : Π₀ i, β i) : ⇑(b • v) = b • ⇑v :=\n  rfl\n\n"}
{"name":"DFinsupp.smulCommClass","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\nδ : Type u_1\ninst✝⁵ : Monoid γ\ninst✝⁴ : Monoid δ\ninst✝³ : (i : ι) → AddMonoid (β i)\ninst✝² : (i : ι) → DistribMulAction γ (β i)\ninst✝¹ : (i : ι) → DistribMulAction δ (β i)\ninst✝ : ∀ (i : ι), SMulCommClass γ δ (β i)\n⊢ SMulCommClass γ δ (DFinsupp fun i => β i)","decl":"instance smulCommClass {δ : Type*} [Monoid γ] [Monoid δ] [∀ i, AddMonoid (β i)]\n    [∀ i, DistribMulAction γ (β i)] [∀ i, DistribMulAction δ (β i)] [∀ i, SMulCommClass γ δ (β i)] :\n    SMulCommClass γ δ (Π₀ i, β i) where\n  smul_comm r s m := ext fun i => by simp only [smul_apply, smul_comm r s (m i)]\n\n"}
{"name":"DFinsupp.isScalarTower","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\nδ : Type u_1\ninst✝⁶ : Monoid γ\ninst✝⁵ : Monoid δ\ninst✝⁴ : (i : ι) → AddMonoid (β i)\ninst✝³ : (i : ι) → DistribMulAction γ (β i)\ninst✝² : (i : ι) → DistribMulAction δ (β i)\ninst✝¹ : SMul γ δ\ninst✝ : ∀ (i : ι), IsScalarTower γ δ (β i)\n⊢ IsScalarTower γ δ (DFinsupp fun i => β i)","decl":"instance isScalarTower {δ : Type*} [Monoid γ] [Monoid δ] [∀ i, AddMonoid (β i)]\n    [∀ i, DistribMulAction γ (β i)] [∀ i, DistribMulAction δ (β i)] [SMul γ δ]\n    [∀ i, IsScalarTower γ δ (β i)] : IsScalarTower γ δ (Π₀ i, β i) where\n  smul_assoc r s m := ext fun i => by simp only [smul_apply, smul_assoc r s (m i)]\n\n"}
{"name":"DFinsupp.isCentralScalar","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : Monoid γ\ninst✝³ : (i : ι) → AddMonoid (β i)\ninst✝² : (i : ι) → DistribMulAction γ (β i)\ninst✝¹ : (i : ι) → DistribMulAction (MulOpposite γ) (β i)\ninst✝ : ∀ (i : ι), IsCentralScalar γ (β i)\n⊢ IsCentralScalar γ (DFinsupp fun i => β i)","decl":"instance isCentralScalar [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]\n    [∀ i, DistribMulAction γᵐᵒᵖ (β i)] [∀ i, IsCentralScalar γ (β i)] :\n    IsCentralScalar γ (Π₀ i, β i) where\n  op_smul_eq_smul r m := ext fun i => by simp only [smul_apply, op_smul_eq_smul r (m i)]\n\n"}
{"name":"DFinsupp.filter_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : Monoid γ\ninst✝² : (i : ι) → AddMonoid (β i)\ninst✝¹ : (i : ι) → DistribMulAction γ (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nr : γ\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.filter p (HSMul.hSMul r f)) (HSMul.hSMul r (DFinsupp.filter p f))","decl":"@[simp]\ntheorem filter_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)] (p : ι → Prop)\n    [DecidablePred p] (r : γ) (f : Π₀ i, β i) : (r • f).filter p = r • f.filter p := by\n  ext\n  simp [smul_apply, smul_ite]\n\n"}
{"name":"DFinsupp.filterLinearMap_apply","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : Semiring γ\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → Module γ (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nx : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.filterLinearMap γ β p) x) (DFinsupp.filter p x)","decl":"/-- `DFinsupp.filter` as a `LinearMap`. -/\n@[simps]\ndef filterLinearMap [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)] (p : ι → Prop)\n    [DecidablePred p] : (Π₀ i, β i) →ₗ[γ] Π₀ i, β i where\n  toFun := filter p\n  map_add' := filter_add p\n  map_smul' := filter_smul p\n\n"}
{"name":"DFinsupp.subtypeDomain_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : Monoid γ\ninst✝² : (i : ι) → AddMonoid (β i)\ninst✝¹ : (i : ι) → DistribMulAction γ (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nr : γ\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p (HSMul.hSMul r f)) (HSMul.hSMul r (DFinsupp.subtypeDomain p f))","decl":"@[simp]\ntheorem subtypeDomain_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]\n    {p : ι → Prop} [DecidablePred p] (r : γ) (f : Π₀ i, β i) :\n    (r • f).subtypeDomain p = r • f.subtypeDomain p :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"DFinsupp.subtypeDomainLinearMap_apply","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : Semiring γ\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → Module γ (β i)\np : ι → Prop\ninst✝ : DecidablePred p\nx : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.subtypeDomainLinearMap γ β p) x) (DFinsupp.subtypeDomain p x)","decl":"/-- `DFinsupp.subtypeDomain` as a `LinearMap`. -/\n@[simps]\ndef subtypeDomainLinearMap [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)]\n    (p : ι → Prop) [DecidablePred p] : (Π₀ i, β i) →ₗ[γ] Π₀ i : Subtype p, β i where\n  toFun := subtypeDomain p\n  map_add' := subtypeDomain_add\n  map_smul' := subtypeDomain_smul\n\n"}
{"name":"DFinsupp.mk_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\ns : Finset ι\nc : γ\nx : (i : ↑↑s) → β ↑i\n⊢ Eq (DFinsupp.mk s (HSMul.hSMul c x)) (HSMul.hSMul c (DFinsupp.mk s x))","decl":"@[simp]\ntheorem mk_smul {s : Finset ι} (c : γ) (x : ∀ i : (↑s : Set ι), β (i : ι)) :\n    mk s (c • x) = c • mk s x :=\n  ext fun i => by simp only [smul_apply, mk_apply]; split_ifs <;> [rfl; rw [smul_zero]]\n\n"}
{"name":"DFinsupp.single_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\ni : ι\nc : γ\nx : β i\n⊢ Eq (DFinsupp.single i (HSMul.hSMul c x)) (HSMul.hSMul c (DFinsupp.single i x))","decl":"@[simp]\ntheorem single_smul {i : ι} (c : γ) (x : β i) : single i (c • x) = c • single i x :=\n  ext fun i => by\n    simp only [smul_apply, single_apply]\n    split_ifs with h\n    · cases h; rfl\n    · rw [smul_zero]\n\n"}
{"name":"DFinsupp.support_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\nγ : Type w\ninst✝³ : Semiring γ\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → Module γ (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nb : γ\nv : DFinsupp fun i => β i\n⊢ HasSubset.Subset (HSMul.hSMul b v).support v.support","decl":"theorem support_smul {γ : Type w} [Semiring γ] [∀ i, AddCommMonoid (β i)] [∀ i, Module γ (β i)]\n    [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (b : γ) (v : Π₀ i, β i) :\n    (b • v).support ⊆ v.support :=\n  support_mapRange\n\n"}
{"name":"DFinsupp.comapDomain_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\nκ : Type u_1\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\nh : κ → ι\nhh : Function.Injective h\nr : γ\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.comapDomain h hh (HSMul.hSMul r f)) (HSMul.hSMul r (DFinsupp.comapDomain h hh f))","decl":"@[simp]\ntheorem comapDomain_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]\n    (h : κ → ι) (hh : Function.Injective h) (r : γ) (f : Π₀ i, β i) :\n    comapDomain h hh (r • f) = r • comapDomain h hh f := by\n  ext\n  rw [smul_apply, comapDomain_apply, smul_apply, comapDomain_apply]\n\n"}
{"name":"DFinsupp.comapDomain'_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\nκ : Type u_1\ninst✝² : Monoid γ\ninst✝¹ : (i : ι) → AddMonoid (β i)\ninst✝ : (i : ι) → DistribMulAction γ (β i)\nh : κ → ι\nh' : ι → κ\nhh' : Function.LeftInverse h' h\nr : γ\nf : DFinsupp fun i => β i\n⊢ Eq (DFinsupp.comapDomain' h hh' (HSMul.hSMul r f)) (HSMul.hSMul r (DFinsupp.comapDomain' h hh' f))","decl":"@[simp]\ntheorem comapDomain'_smul [Monoid γ] [∀ i, AddMonoid (β i)] [∀ i, DistribMulAction γ (β i)]\n    (h : κ → ι) {h' : ι → κ} (hh' : Function.LeftInverse h' h) (r : γ) (f : Π₀ i, β i) :\n    comapDomain' h hh' (r • f) = r • comapDomain' h hh' f := by\n  ext\n  rw [smul_apply, comapDomain'_apply, smul_apply, comapDomain'_apply]\n\n"}
{"name":"DFinsupp.equivProdDFinsupp_smul","module":"Mathlib.Data.DFinsupp.Module","initialProofState":"ι : Type u\nγ : Type w\nα : Option ι → Type v\ninst✝² : Monoid γ\ninst✝¹ : (i : Option ι) → AddMonoid (α i)\ninst✝ : (i : Option ι) → DistribMulAction γ (α i)\nr : γ\nf : DFinsupp fun i => α i\n⊢ Eq (DFinsupp.equivProdDFinsupp (HSMul.hSMul r f)) (HSMul.hSMul r (DFinsupp.equivProdDFinsupp f))","decl":"theorem equivProdDFinsupp_smul [Monoid γ] [∀ i, AddMonoid (α i)] [∀ i, DistribMulAction γ (α i)]\n    (r : γ) (f : Π₀ i, α i) : equivProdDFinsupp (r • f) = r • equivProdDFinsupp f :=\n  Prod.ext (smul_apply _ _ _) (comapDomain_smul _ (Option.some_injective _) _ _)\n\n"}
