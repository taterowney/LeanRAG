{"name":"BoundedContinuousFunction.apply_le_nndist_zero","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf : BoundedContinuousFunction X NNReal\nx : X\nâŠ¢ LE.le (f x) (NNDist.nndist 0 f)","decl":"lemma apply_le_nndist_zero {X : Type*} [TopologicalSpace X] (f : X â†’áµ‡ â„â‰¥0) (x : X) :\n    f x â‰¤ nndist 0 f := by\n  convert nndist_coe_le_nndist x\n  simp only [coe_zero, Pi.zero_apply, NNReal.nndist_zero_eq_val]\n\n"}
{"name":"BoundedContinuousFunction.lintegral_le_edist_mul","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : TopologicalSpace X\nf : BoundedContinuousFunction X NNReal\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => â†‘(f x)) (HMul.hMul (EDist.edist 0 f) (Î¼ Set.univ))","decl":"lemma lintegral_le_edist_mul (f : X â†’áµ‡ â„â‰¥0) (Î¼ : Measure X) :\n    (âˆ«â» x, f x âˆ‚Î¼) â‰¤ edist 0 f * (Î¼ Set.univ) :=\n  le_trans (lintegral_mono (fun x â†¦ ENNReal.coe_le_coe.mpr (f.apply_le_nndist_zero x))) (by simp)\n\n"}
{"name":"BoundedContinuousFunction.measurable_coe_ennreal_comp","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\nâŠ¢ Measurable fun x => â†‘(f x)","decl":"theorem measurable_coe_ennreal_comp [OpensMeasurableSpace X] (f : X â†’áµ‡ â„â‰¥0) :\n    Measurable fun x â†¦ (f x : â„â‰¥0âˆ) :=\n  measurable_coe_nnreal_ennreal.comp f.continuous.measurable\n\n"}
{"name":"BoundedContinuousFunction.lintegral_lt_top_of_nnreal","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X NNReal\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => â†‘(f x)) Top.top","decl":"theorem lintegral_lt_top_of_nnreal (f : X â†’áµ‡ â„â‰¥0) : âˆ«â» x, f x âˆ‚Î¼ < âˆ := by\n  apply IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal\n  refine âŸ¨nndist f 0, fun x â†¦ ?_âŸ©\n  have key := BoundedContinuousFunction.NNReal.upper_bound f x\n  rwa [ENNReal.coe_le_coe]\n\n"}
{"name":"BoundedContinuousFunction.integrable_of_nnreal","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasure Î¼\ninstâœ : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\nâŠ¢ MeasureTheory.Integrable (Function.comp NNReal.toReal â‡‘f) Î¼","decl":"theorem integrable_of_nnreal [OpensMeasurableSpace X] (f : X â†’áµ‡ â„â‰¥0) :\n    Integrable (((â†‘) : â„â‰¥0 â†’ â„) âˆ˜ â‡‘f) Î¼ := by\n  refine âŸ¨(NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable, ?_âŸ©\n  simp only [hasFiniteIntegral_iff_enorm, Function.comp_apply, NNReal.enorm_eq]\n  exact lintegral_lt_top_of_nnreal _ f\n\n"}
{"name":"BoundedContinuousFunction.integral_eq_integral_nnrealPart_sub","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasure Î¼\ninstâœ : OpensMeasurableSpace X\nf : BoundedContinuousFunction X Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (HSub.hSub (MeasureTheory.integral Î¼ fun x => â†‘(f.nnrealPart x)) (MeasureTheory.integral Î¼ fun x => â†‘((Neg.neg f).nnrealPart x)))","decl":"theorem integral_eq_integral_nnrealPart_sub [OpensMeasurableSpace X] (f : X â†’áµ‡ â„) :\n    âˆ« x, f x âˆ‚Î¼ = (âˆ« x, (f.nnrealPart x : â„) âˆ‚Î¼) - âˆ« x, ((-f).nnrealPart x : â„) âˆ‚Î¼ := by\n  simp only [f.self_eq_nnrealPart_sub_nnrealPart_neg, Pi.sub_apply, integral_sub,\n             integrable_of_nnreal]\n  simp only [Function.comp_apply]\n\n"}
{"name":"BoundedContinuousFunction.lintegral_of_real_lt_top","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X Real\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x)) Top.top","decl":"theorem lintegral_of_real_lt_top (f : X â†’áµ‡ â„) :\n    âˆ«â» x, ENNReal.ofReal (f x) âˆ‚Î¼ < âˆ := lintegral_lt_top_of_nnreal _ f.nnrealPart\n\n"}
{"name":"BoundedContinuousFunction.toReal_lintegral_coe_eq_integral","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => â†‘(f x)).toReal (MeasureTheory.integral Î¼ fun x => â†‘(f x))","decl":"theorem toReal_lintegral_coe_eq_integral [OpensMeasurableSpace X] (f : X â†’áµ‡ â„â‰¥0) (Î¼ : Measure X) :\n    (âˆ«â» x, (f x : â„â‰¥0âˆ) âˆ‚Î¼).toReal = âˆ« x, (f x : â„) âˆ‚Î¼ := by\n  rw [integral_eq_lintegral_of_nonneg_ae _ (by simpa [Function.comp_apply] using\n        (NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable)]\n  Â· simp only [ENNReal.ofReal_coe_nnreal]\n  Â· exact Eventually.of_forall (by simp only [Pi.zero_apply, NNReal.zero_le_coe, imp_true_iff])\n\n"}
{"name":"BoundedContinuousFunction.lintegral_nnnorm_le","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Type u_2\ninstâœ : NormedAddCommGroup E\nf : BoundedContinuousFunction X E\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => â†‘(NNNorm.nnnorm (f x))) (HMul.hMul (â†‘(NNNorm.nnnorm f)) (Î¼ Set.univ))","decl":"lemma lintegral_nnnorm_le (f : X â†’áµ‡ E) :\n    âˆ«â» x, â€–f xâ€–â‚Š âˆ‚Î¼ â‰¤ â€–fâ€–â‚Š * (Î¼ Set.univ) := by\n  calc  âˆ«â» x, â€–f xâ€–â‚Š âˆ‚Î¼\n    _ â‰¤ âˆ«â» _, â€–fâ€–â‚Š âˆ‚Î¼         := by gcongr; apply nnnorm_coe_le_nnnorm\n    _ = â€–fâ€–â‚Š * (Î¼ Set.univ)   := by rw [lintegral_const]\n\n"}
{"name":"BoundedContinuousFunction.integrable","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ· : MeasurableSpace X\ninstâœâ¶ : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : OpensMeasurableSpace X\ninstâœÂ³ : SecondCountableTopology E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X E\nâŠ¢ MeasureTheory.Integrable (â‡‘f) Î¼","decl":"lemma integrable [IsFiniteMeasure Î¼] (f : X â†’áµ‡ E) :\n    Integrable f Î¼ := by\n  refine âŸ¨f.continuous.measurable.aestronglyMeasurable, (hasFiniteIntegral_def _ _).mp ?_âŸ©\n  calc  âˆ«â» x, â€–f xâ€–â‚Š âˆ‚Î¼\n    _ â‰¤ â€–fâ€–â‚Š * (Î¼ Set.univ)   := f.lintegral_nnnorm_le Î¼\n    _ < âˆ                     := ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top Î¼ Set.univ)\n\n"}
{"name":"BoundedContinuousFunction.norm_integral_le_mul_norm","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ¸ : MeasurableSpace X\ninstâœâ· : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : OpensMeasurableSpace X\ninstâœâ´ : SecondCountableTopology E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X E\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun x => f x)) (HMul.hMul (Î¼ Set.univ).toReal (Norm.norm f))","decl":"lemma norm_integral_le_mul_norm [IsFiniteMeasure Î¼] (f : X â†’áµ‡ E) :\n    â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ ENNReal.toReal (Î¼ Set.univ) * â€–fâ€– := by\n  calc  â€–âˆ« x, f x âˆ‚Î¼â€–\n    _ â‰¤ âˆ« x, â€–f xâ€– âˆ‚Î¼                       := by exact norm_integral_le_integral_norm _\n    _ â‰¤ âˆ« _, â€–fâ€– âˆ‚Î¼                         := ?_\n    _ = ENNReal.toReal (Î¼ Set.univ) â€¢ â€–fâ€–   := by rw [integral_const]\n  apply integral_mono _ (integrable_const â€–fâ€–) (fun x â†¦ f.norm_coe_le_norm x) -- NOTE: `gcongr`?\n  exact (integrable_norm_iff f.continuous.measurable.aestronglyMeasurable).mpr (f.integrable Î¼)\n\n"}
{"name":"BoundedContinuousFunction.norm_integral_le_norm","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ¸ : MeasurableSpace X\ninstâœâ· : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : OpensMeasurableSpace X\ninstâœâ´ : SecondCountableTopology E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.IsProbabilityMeasure Î¼\nf : BoundedContinuousFunction X E\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun x => f x)) (Norm.norm f)","decl":"lemma norm_integral_le_norm [IsProbabilityMeasure Î¼] (f : X â†’áµ‡ E) :\n    â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ â€–fâ€– := by\n  convert f.norm_integral_le_mul_norm Î¼\n  simp only [measure_univ, ENNReal.one_toReal, one_mul]\n\n"}
{"name":"BoundedContinuousFunction.isBounded_range_integral","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ¸ : MeasurableSpace X\ninstâœâ· : TopologicalSpace X\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : OpensMeasurableSpace X\ninstâœâ´ : SecondCountableTopology E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : NormedSpace Real E\nÎ¹ : Type u_3\nÎ¼s : Î¹ â†’ MeasureTheory.Measure X\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nf : BoundedContinuousFunction X E\nâŠ¢ Bornology.IsBounded (Set.range fun i => MeasureTheory.integral (Î¼s i) fun x => f x)","decl":"lemma isBounded_range_integral\n    {Î¹ : Type*} (Î¼s : Î¹ â†’ Measure X) [âˆ€ i, IsProbabilityMeasure (Î¼s i)] (f : X â†’áµ‡ E) :\n    Bornology.IsBounded (Set.range (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i))) := by\n  apply isBounded_iff_forall_norm_le.mpr âŸ¨â€–fâ€–, fun v hv â†¦ ?_âŸ©\n  obtain âŸ¨i, hiâŸ© := hv\n  rw [â† hi]\n  apply f.norm_integral_le_norm (Î¼s i)\n\n"}
{"name":"BoundedContinuousFunction.integral_add_const","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X Real\nc : Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (HAdd.hAdd f (BoundedContinuousFunction.const X c)) x) (HAdd.hAdd (MeasureTheory.integral Î¼ fun x => f x) (HSMul.hSMul (Î¼ Set.univ).toReal c))","decl":"lemma integral_add_const (f : X â†’áµ‡ â„) (c : â„) :\n    âˆ« x, (f + const X c) x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ + ENNReal.toReal (Î¼ (Set.univ)) â€¢ c := by\n  simp [integral_add (f.integrable _) (integrable_const c)]\n\n"}
{"name":"BoundedContinuousFunction.integral_const_sub","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : BoundedContinuousFunction X Real\nc : Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (HSub.hSub (BoundedContinuousFunction.const X c) f) x) (HSub.hSub (HSMul.hSMul (Î¼ Set.univ).toReal c) (MeasureTheory.integral Î¼ fun x => f x))","decl":"lemma integral_const_sub (f : X â†’áµ‡ â„) (c : â„) :\n    âˆ« x, (const X c - f) x âˆ‚Î¼ = ENNReal.toReal (Î¼ (Set.univ)) â€¢ c - âˆ« x, f x âˆ‚Î¼ := by\n  simp [integral_sub (integrable_const c) (f.integrable _)]\n\n"}
{"name":"BoundedContinuousFunction.tendsto_integral_of_forall_limsup_integral_le_integral","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : OpensMeasurableSpace X\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\nÎ¼s : Î¹ â†’ MeasureTheory.Measure X\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nh : âˆ€ (f : BoundedContinuousFunction X Real), LE.le 0 f â†’ LE.le (Filter.limsup (fun i => MeasureTheory.integral (Î¼s i) fun x => f x) L) (MeasureTheory.integral Î¼ fun x => f x)\nf : BoundedContinuousFunction X Real\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼s i) fun x => f x) L (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"lemma tendsto_integral_of_forall_limsup_integral_le_integral {Î¹ : Type*} {L : Filter Î¹}\n    {Î¼ : Measure X} [IsProbabilityMeasure Î¼] {Î¼s : Î¹ â†’ Measure X} [âˆ€ i, IsProbabilityMeasure (Î¼s i)]\n    (h : âˆ€ f : X â†’áµ‡ â„, 0 â‰¤ f â†’ L.limsup (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) â‰¤ âˆ« x, f x âˆ‚Î¼)\n    (f : X â†’áµ‡ â„) :\n    Tendsto (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) L (ğ“ (âˆ« x, f x âˆ‚Î¼)) := by\n  rcases eq_or_neBot L with rfl|hL\n  Â· simp only [tendsto_bot]\n  have obs := BoundedContinuousFunction.isBounded_range_integral Î¼s f\n  have bdd_above := BddAbove.isBoundedUnder L.univ_mem (by simpa using obs.bddAbove)\n  have bdd_below := BddBelow.isBoundedUnder L.univ_mem (by simpa using obs.bddBelow)\n  apply tendsto_of_le_liminf_of_limsup_le _ _ bdd_above bdd_below\n  Â· have key := h _ (f.norm_sub_nonneg)\n    simp_rw [f.integral_const_sub â€–fâ€–] at key\n    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key\n    have := limsup_const_sub L (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) â€–fâ€– bdd_above.isCobounded_ge bdd_below\n    rwa [this, _root_.sub_le_sub_iff_left â€–fâ€–] at key\n  Â· have key := h _ (f.add_norm_nonneg)\n    simp_rw [f.integral_add_const â€–fâ€–] at key\n    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key\n    have := limsup_add_const L (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) â€–fâ€– bdd_above bdd_below.isCobounded_le\n    rwa [this, add_le_add_iff_right] at key\n\n"}
{"name":"BoundedContinuousFunction.tendsto_integral_of_forall_integral_le_liminf_integral","module":"Mathlib.MeasureTheory.Integral.BoundedContinuousFunction","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : OpensMeasurableSpace X\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\nÎ¼s : Î¹ â†’ MeasureTheory.Measure X\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nh : âˆ€ (f : BoundedContinuousFunction X Real), LE.le 0 f â†’ LE.le (MeasureTheory.integral Î¼ fun x => f x) (Filter.liminf (fun i => MeasureTheory.integral (Î¼s i) fun x => f x) L)\nf : BoundedContinuousFunction X Real\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼s i) fun x => f x) L (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"lemma tendsto_integral_of_forall_integral_le_liminf_integral {Î¹ : Type*} {L : Filter Î¹}\n    {Î¼ : Measure X} [IsProbabilityMeasure Î¼] {Î¼s : Î¹ â†’ Measure X} [âˆ€ i, IsProbabilityMeasure (Î¼s i)]\n    (h : âˆ€ f : X â†’áµ‡ â„, 0 â‰¤ f â†’ âˆ« x, f x âˆ‚Î¼ â‰¤ L.liminf (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)))\n    (f : X â†’áµ‡ â„) :\n    Tendsto (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) L (ğ“ (âˆ« x, f x âˆ‚Î¼)) := by\n  rcases eq_or_neBot L with rfl|hL\n  Â· simp only [tendsto_bot]\n  have obs := BoundedContinuousFunction.isBounded_range_integral Î¼s f\n  have bdd_above := BddAbove.isBoundedUnder L.univ_mem (by simpa using obs.bddAbove)\n  have bdd_below := BddBelow.isBoundedUnder L.univ_mem (by simpa using obs.bddBelow)\n  apply @tendsto_of_le_liminf_of_limsup_le â„ Î¹ _ _ _ L (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) (âˆ« x, f x âˆ‚Î¼)\n  Â· have key := h _ (f.add_norm_nonneg)\n    simp_rw [f.integral_add_const â€–fâ€–] at key\n    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key\n    have := liminf_add_const L (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) â€–fâ€– bdd_above.isCobounded_ge bdd_below\n    rwa [this, add_le_add_iff_right] at key\n  Â· have key := h _ (f.norm_sub_nonneg)\n    simp_rw [f.integral_const_sub â€–fâ€–] at key\n    simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul] at key\n    have := liminf_const_sub L (fun i â†¦ âˆ« x, f x âˆ‚ (Î¼s i)) â€–fâ€– bdd_above bdd_below.isCobounded_le\n    rwa [this, sub_le_sub_iff_left] at key\n  Â· exact bdd_above\n  Â· exact bdd_below\n\n"}
