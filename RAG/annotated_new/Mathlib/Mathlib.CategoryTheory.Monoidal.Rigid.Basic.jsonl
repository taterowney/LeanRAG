{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation'","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nself : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.ExactPairing.coevaluation' X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X CategoryTheory.ExactPairing.evaluation'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"/-- An exact pairing is a pair of objects `X Y : C` which admit\n  a coevaluation and evaluation morphism which fulfill two triangle equalities. -/\nclass ExactPairing (X Y : C) where\n  /-- Coevaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.coevaluation` instead. -/\n  coevaluation' : ğŸ™_ C âŸ¶ X âŠ— Y\n  /-- Evaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.evaluation` instead. -/\n  evaluation' : Y âŠ— X âŸ¶ ğŸ™_ C\n  coevaluation_evaluation' :\n    Y â— coevaluation' â‰« (Î±_ _ _ _).inv â‰« evaluation' â–· Y = (Ï_ Y).hom â‰« (Î»_ Y).inv := by\n    aesop_cat\n  evaluation_coevaluation' :\n    coevaluation' â–· X â‰« (Î±_ _ _ _).hom â‰« X â— evaluation' = (Î»_ X).hom â‰« (Ï_ X).inv := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation'","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nself : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y CategoryTheory.ExactPairing.coevaluation') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.ExactPairing.evaluation' Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv)","decl":"/-- An exact pairing is a pair of objects `X Y : C` which admit\n  a coevaluation and evaluation morphism which fulfill two triangle equalities. -/\nclass ExactPairing (X Y : C) where\n  /-- Coevaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.coevaluation` instead. -/\n  coevaluation' : ğŸ™_ C âŸ¶ X âŠ— Y\n  /-- Evaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.evaluation` instead. -/\n  evaluation' : Y âŠ— X âŸ¶ ğŸ™_ C\n  coevaluation_evaluation' :\n    Y â— coevaluation' â‰« (Î±_ _ _ _).inv â‰« evaluation' â–· Y = (Ï_ Y).hom â‰« (Î»_ Y).inv := by\n    aesop_cat\n  evaluation_coevaluation' :\n    coevaluation' â–· X â‰« (Î±_ _ _ _).hom â‰« X â— evaluation' = (Î»_ X).hom â‰« (Ï_ X).inv := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv)","decl":"lemma coevaluation_evaluation :\n    Y â— Î·_ _ _ â‰« (Î±_ _ _ _).inv â‰« Îµ_ X _ â–· Y = (Ï_ Y).hom â‰« (Î»_ Y).inv :=\n  coevaluation_evaluation'\n\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"lemma evaluation_coevaluation :\n    Î·_ _ _ â–· X â‰« (Î±_ _ _ _).hom â‰« X â— Îµ_ _ Y = (Î»_ X).hom â‰« (Ï_ X).inv :=\n  evaluation_coevaluation'\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation''","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y)) CategoryTheory.MonoidalCoherence.iso.hom","decl":"lemma coevaluation_evaluation'' :\n    Y â— Î·_ X Y âŠ—â‰« Îµ_ X Y â–· Y = âŠ—ğŸ™.hom := by\n  convert coevaluation_evaluation X Y <;> simp [monoidalComp]\n\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation''","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y))) CategoryTheory.MonoidalCoherence.iso.hom","decl":"lemma evaluation_coevaluation'' :\n    Î·_ X Y â–· X âŠ—â‰« X â— Îµ_ X Y = âŠ—ğŸ™.hom := by\n  convert evaluation_coevaluation X Y <;> simp [monoidalComp]\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv h))","decl":"attribute [reassoc (attr := simp)] ExactPairing.coevaluation_evaluation\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.ExactPairing X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h))","decl":"attribute [reassoc (attr := simp)] ExactPairing.evaluation_coevaluation\n\n"}
{"name":"CategoryTheory.leftDual_rightDual","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX : C\ninstâœ : CategoryTheory.HasRightDual X\nâŠ¢ Eq (CategoryTheory.HasLeftDual.leftDual (CategoryTheory.HasRightDual.rightDual X)) X","decl":"@[simp]\ntheorem leftDual_rightDual {X : C} [HasRightDual X] : á˜Xá˜ = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.rightDual_leftDual","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX : C\ninstâœ : CategoryTheory.HasLeftDual X\nâŠ¢ Eq (CategoryTheory.HasRightDual.rightDual (CategoryTheory.HasLeftDual.leftDual X)) X","decl":"@[simp]\ntheorem rightDual_leftDual {X : C} [HasLeftDual X] : (á˜X)á˜ = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.rightAdjointMate_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX : C\ninstâœ : CategoryTheory.HasRightDual X\nâŠ¢ Eq (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.HasRightDual.rightDual X))","decl":"@[simp]\ntheorem rightAdjointMate_id {X : C} [HasRightDual X] : (ğŸ™ X)á˜ = ğŸ™ (Xá˜) := by\n  simp [rightAdjointMate]\n\n"}
{"name":"CategoryTheory.leftAdjointMate_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX : C\ninstâœ : CategoryTheory.HasLeftDual X\nâŠ¢ Eq (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.HasLeftDual.leftDual X))","decl":"@[simp]\ntheorem leftAdjointMate_id {X : C} [HasLeftDual X] : (á˜(ğŸ™ X)) = ğŸ™ (á˜X) := by\n  simp [leftAdjointMate]\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\ng : Quiver.Hom (CategoryTheory.HasRightDual.rightDual X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasRightDual.rightDual Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.HasRightDual.rightDual Y) Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)) Z) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Z).hom)))))","decl":"theorem rightAdjointMate_comp {X Y Z : C} [HasRightDual X] [HasRightDual Y] {f : X âŸ¶ Y}\n    {g : Xá˜ âŸ¶ Z} :\n    fá˜ â‰« g =\n      (Ï_ (Yá˜)).inv â‰«\n        _ â— Î·_ X (Xá˜) â‰« _ â— (f âŠ— g) â‰« (Î±_ (Yá˜) Y Z).inv â‰« Îµ_ Y (Yá˜) â–· _ â‰« (Î»_ Z).hom :=\n  calc\n    _ = ğŸ™ _ âŠ—â‰« (Yá˜ : C) â— Î·_ X Xá˜ â‰« Yá˜ â— f â–· Xá˜ âŠ—â‰« (Îµ_ Y Yá˜ â–· Xá˜ â‰« ğŸ™_ C â— g) âŠ—â‰« ğŸ™ _ := by\n      dsimp only [rightAdjointMate]; monoidal\n    _ = _ := by\n      rw [â† whisker_exchange, tensorHom_def]; monoidal\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\ng : Quiver.Hom (CategoryTheory.HasLeftDual.leftDual X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasLeftDual.leftDual Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z Y (CategoryTheory.HasLeftDual.leftDual Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Z).hom)))))","decl":"theorem leftAdjointMate_comp {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] {f : X âŸ¶ Y}\n    {g : (á˜X) âŸ¶ Z} :\n    (á˜f) â‰« g =\n      (Î»_ _).inv â‰«\n        Î·_ (á˜X : C) X â–· _ â‰« (g âŠ— f) â–· _ â‰« (Î±_ _ _ _).hom â‰« _ â— Îµ_ _ _ â‰« (Ï_ _).hom :=\n  calc\n    _ = ğŸ™ _ âŠ—â‰« Î·_ (á˜X : C) X â–· (á˜Y) âŠ—â‰« (á˜X) â— f â–· (á˜Y) âŠ—â‰« ((á˜X) â— Îµ_ (á˜Y) Y â‰« g â–· ğŸ™_ C) âŠ—â‰« ğŸ™ _ := by\n      dsimp only [leftAdjointMate]; monoidal\n    _ = _ := by\n      rw [whisker_exchange, tensorHom_def']; monoidal\n\n"}
{"name":"CategoryTheory.comp_rightAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninstâœÂ² : CategoryTheory.HasRightDual X\ninstâœÂ¹ : CategoryTheory.HasRightDual Y\ninstâœ : CategoryTheory.HasRightDual Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate g) (CategoryTheory.rightAdjointMate f))","decl":"/-- The composition of right adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]\n    {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜ := by\n  rw [rightAdjointMate_comp]\n  simp only [rightAdjointMate, comp_whiskerRight]\n  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [â† MonoidalCategory.whiskerLeft_comp]; congr 2\n  symm\n  calc\n    _ = ğŸ™ _ âŠ—â‰« (Î·_ Y Yá˜ â–· ğŸ™_ C â‰« (Y âŠ— Yá˜) â— Î·_ X Xá˜) âŠ—â‰« Y â— Yá˜ â— f â–· Xá˜ âŠ—â‰«\n        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [tensorHom_def']; monoidal\n    _ = Î·_ X Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· (X âŠ— Xá˜) â‰« (Y âŠ— Yá˜) â— f â–· Xá˜) âŠ—â‰«\n        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_rightAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nX Y Zâœ : C\ninstâœÂ² : CategoryTheory.HasRightDual X\ninstâœÂ¹ : CategoryTheory.HasRightDual Y\ninstâœ : CategoryTheory.HasRightDual Zâœ\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.HasRightDual.rightDual X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) h))","decl":"/-- The composition of right adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]\n    {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜ := by\n  rw [rightAdjointMate_comp]\n  simp only [rightAdjointMate, comp_whiskerRight]\n  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [â† MonoidalCategory.whiskerLeft_comp]; congr 2\n  symm\n  calc\n    _ = ğŸ™ _ âŠ—â‰« (Î·_ Y Yá˜ â–· ğŸ™_ C â‰« (Y âŠ— Yá˜) â— Î·_ X Xá˜) âŠ—â‰« Y â— Yá˜ â— f â–· Xá˜ âŠ—â‰«\n        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [tensorHom_def']; monoidal\n    _ = Î·_ X Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· (X âŠ— Xá˜) â‰« (Y âŠ— Yá˜) â— f â–· Xá˜) âŠ—â‰«\n        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]; monoidal\n    _ = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_leftAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nX Y Zâœ : C\ninstâœÂ² : CategoryTheory.HasLeftDual X\ninstâœÂ¹ : CategoryTheory.HasLeftDual Y\ninstâœ : CategoryTheory.HasLeftDual Zâœ\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.HasLeftDual.leftDual X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) h))","decl":"/-- The composition of left adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_leftAdjointMate {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] [HasLeftDual Z] {f : X âŸ¶ Y}\n    {g : Y âŸ¶ Z} : (á˜f â‰« g) = (á˜g) â‰« á˜f := by\n  rw [leftAdjointMate_comp]\n  simp only [leftAdjointMate, MonoidalCategory.whiskerLeft_comp]\n  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [â† comp_whiskerRight]; congr 2\n  symm\n  calc\n    _ = ğŸ™ _ âŠ—â‰« ((ğŸ™_ C) â— Î·_ (á˜Y) Y â‰« Î·_ (á˜X) X â–· ((á˜Y) âŠ— Y)) âŠ—â‰« (á˜X) â— f â–· (á˜Y) â–· Y âŠ—â‰«\n        (á˜X) â— Îµ_ (á˜Y) Y â–· Y âŠ—â‰« (á˜X) â— g := by\n      rw [tensorHom_def]; monoidal\n    _ = Î·_ (á˜X) X âŠ—â‰« (((á˜X) âŠ— X) â— Î·_ (á˜Y) Y â‰« ((á˜X) â— f) â–· ((á˜Y) âŠ— Y)) âŠ—â‰«\n        (á˜X) â— Îµ_ (á˜Y) Y â–· Y âŠ—â‰« (á˜X) â— g := by\n      rw [whisker_exchange]; monoidal\n    _ = Î·_ (á˜X) X âŠ—â‰« ((á˜X) â— f) âŠ—â‰« (á˜X) â— (Y â— Î·_ (á˜Y) Y âŠ—â‰« Îµ_ (á˜Y) Y â–· Y) âŠ—â‰« (á˜X) â— g := by\n      rw [whisker_exchange]; monoidal\n    _ = Î·_ (á˜X) X â‰« (á˜X) â— f â‰« (á˜X) â— g := by\n      rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_leftAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninstâœÂ² : CategoryTheory.HasLeftDual X\ninstâœÂ¹ : CategoryTheory.HasLeftDual Y\ninstâœ : CategoryTheory.HasLeftDual Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate g) (CategoryTheory.leftAdjointMate f))","decl":"/-- The composition of left adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_leftAdjointMate {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] [HasLeftDual Z] {f : X âŸ¶ Y}\n    {g : Y âŸ¶ Z} : (á˜f â‰« g) = (á˜g) â‰« á˜f := by\n  rw [leftAdjointMate_comp]\n  simp only [leftAdjointMate, MonoidalCategory.whiskerLeft_comp]\n  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [â† comp_whiskerRight]; congr 2\n  symm\n  calc\n    _ = ğŸ™ _ âŠ—â‰« ((ğŸ™_ C) â— Î·_ (á˜Y) Y â‰« Î·_ (á˜X) X â–· ((á˜Y) âŠ— Y)) âŠ—â‰« (á˜X) â— f â–· (á˜Y) â–· Y âŠ—â‰«\n        (á˜X) â— Îµ_ (á˜Y) Y â–· Y âŠ—â‰« (á˜X) â— g := by\n      rw [tensorHom_def]; monoidal\n    _ = Î·_ (á˜X) X âŠ—â‰« (((á˜X) âŠ— X) â— Î·_ (á˜Y) Y â‰« ((á˜X) â— f) â–· ((á˜Y) âŠ— Y)) âŠ—â‰«\n        (á˜X) â— Îµ_ (á˜Y) Y â–· Y âŠ—â‰« (á˜X) â— g := by\n      rw [whisker_exchange]; monoidal\n    _ = Î·_ (á˜X) X âŠ—â‰« ((á˜X) â— f) âŠ—â‰« (á˜X) â— (Y â— Î·_ (á˜Y) Y âŠ—â‰« Îµ_ (á˜Y) Y â–· Y) âŠ—â‰« (á˜X) â— g := by\n      rw [whisker_exchange]; monoidal\n    _ = Î·_ (á˜X) X â‰« (á˜X) â— f â‰« (á˜X) â— g := by\n      rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y Y' Z Z' : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' X) Z\ng : Quiver.Hom Z Z'\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z) f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y g))","decl":"theorem tensorLeftHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : Y' âŠ— X âŸ¶ Z)\n    (g : Z âŸ¶ Z') :\n    (tensorLeftHomEquiv X Y Y' Z') (f â‰« g) = (tensorLeftHomEquiv X Y Y' Z) f â‰« Y â— g := by\n  simp [tensorLeftHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X X'\ng : Quiver.Hom X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y' f) ((CategoryTheory.tensorLeftHomEquiv X' Y Y' Z).symm g))","decl":"theorem tensorLeftHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X âŸ¶ X')\n    (g : X' âŸ¶ Y âŠ— Z) :\n    (tensorLeftHomEquiv X Y Y' Z).symm (f â‰« g) =\n      _ â— f â‰« (tensorLeftHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorLeftHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y Y' Z Z' : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\ng : Quiver.Hom Z Z'\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv X Y Y' Z') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.tensorRightHomEquiv X Y Y' Z) f) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Y'))","decl":"theorem tensorRightHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X âŠ— Y âŸ¶ Z)\n    (g : Z âŸ¶ Z') :\n    (tensorRightHomEquiv X Y Y' Z') (f â‰« g) = (tensorRightHomEquiv X Y Y' Z) f â‰« g â–· Y' := by\n  simp [tensorRightHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X X'\ng : Quiver.Hom X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y')\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv X Y Y' Z).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) ((CategoryTheory.tensorRightHomEquiv X' Y Y' Z).symm g))","decl":"theorem tensorRightHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X âŸ¶ X')\n    (g : X' âŸ¶ Z âŠ— Y') :\n    (tensorRightHomEquiv X Y Y' Z).symm (f â‰« g) =\n      f â–· Y â‰« (tensorRightHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorRightHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_tensor","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)\ng : Quiver.Hom X' Z'\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj X X') Y Y' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Z')).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.MonoidalCategoryStruct.associator Y Z Z').hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y' X X').inv (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z).symm f) g))","decl":"/-- `tensorLeftHomEquiv` commutes with tensoring on the right -/\ntheorem tensorLeftHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X âŸ¶ Y âŠ— Z)\n    (g : X' âŸ¶ Z') :\n    (tensorLeftHomEquiv (X âŠ— X') Y Y' (Z âŠ— Z')).symm ((f âŠ— g) â‰« (Î±_ _ _ _).hom) =\n      (Î±_ _ _ _).inv â‰« ((tensorLeftHomEquiv X Y Y' Z).symm f âŠ— g) := by\n  simp [tensorLeftHomEquiv, tensorHom_def']\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_tensor","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y')\ng : Quiver.Hom X' Z'\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj X' X) Y Y' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z' Z)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.MonoidalCategoryStruct.associator Z' Z Y').inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' X Y).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom g ((CategoryTheory.tensorRightHomEquiv X Y Y' Z).symm f)))","decl":"/-- `tensorRightHomEquiv` commutes with tensoring on the left -/\ntheorem tensorRightHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X âŸ¶ Z âŠ— Y')\n    (g : X' âŸ¶ Z') :\n    (tensorRightHomEquiv (X' âŠ— X) Y Y' (Z' âŠ— Z)).symm ((g âŠ— f) â‰« (Î±_ _ _ _).inv) =\n      (Î±_ _ _ _).hom â‰« (g âŠ— (tensorRightHomEquiv X Y Y' Z).symm f) := by\n  simp [tensorRightHomEquiv, tensorHom_def]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nY Y' Z : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom Y' Z\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y Y' Z).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y Y') (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y').hom f)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_symm_coevaluation_comp_whiskerLeft {Y Y' Z : C} [ExactPairing Y Y']\n    (f : Y' âŸ¶ Z) : (tensorLeftHomEquiv _ _ _ _).symm (Î·_ _ _ â‰« Y â— f) = (Ï_ _).hom â‰« f := by\n  calc\n    _ = Y' â— Î·_ Y Y' âŠ—â‰« ((Y' âŠ— Y) â— f â‰« Îµ_ Y Y' â–· Z) âŠ—â‰« ğŸ™ _ := by\n      dsimp [tensorLeftHomEquiv]; monoidal\n    _ = (Y' â— Î·_ Y Y' âŠ—â‰« Îµ_ Y Y' â–· Y') âŠ—â‰« f := by\n      rw [whisker_exchange]; monoidal\n    _ = _ := by rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.HasRightDual.rightDual X)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasRightDual.rightDual Y)).hom (CategoryTheory.rightAdjointMate f))","decl":"@[simp]\ntheorem tensorLeftHomEquiv_symm_coevaluation_comp_whiskerRight {X Y : C} [HasRightDual X]\n    [HasRightDual Y] (f : X âŸ¶ Y) :\n    (tensorLeftHomEquiv _ _ _ _).symm (Î·_ _ _ â‰« f â–· (Xá˜)) = (Ï_ _).hom â‰« fá˜ := by\n  dsimp [tensorLeftHomEquiv, rightAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.HasLeftDual.leftDual Y) Y (CategoryTheory.HasLeftDual.leftDual X)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasLeftDual.leftDual Y)).hom (CategoryTheory.leftAdjointMate f))","decl":"@[simp]\ntheorem tensorRightHomEquiv_symm_coevaluation_comp_whiskerLeft {X Y : C} [HasLeftDual X]\n    [HasLeftDual Y] (f : X âŸ¶ Y) :\n    (tensorRightHomEquiv _ (á˜Y) _ _).symm (Î·_ (á˜X : C) X â‰« (á˜X : C) â— f) = (Î»_ _).hom â‰« á˜f := by\n  dsimp [tensorRightHomEquiv, leftAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nY Y' Z : C\ninstâœ : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom Y Z\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y Y' Z).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y Y') (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom f)","decl":"@[simp]\ntheorem tensorRightHomEquiv_symm_coevaluation_comp_whiskerRight {Y Y' Z : C} [ExactPairing Y Y']\n    (f : Y âŸ¶ Z) : (tensorRightHomEquiv _ Y _ _).symm (Î·_ Y Y' â‰« f â–· Y') = (Î»_ _).hom â‰« f :=\n  calc\n    _ = Î·_ Y Y' â–· Y âŠ—â‰« (f â–· (Y' âŠ— Y) â‰« Z â— Îµ_ Y Y') âŠ—â‰« ğŸ™ _ := by\n      dsimp [tensorRightHomEquiv]; monoidal\n    _ = (Î·_ Y Y' â–· Y âŠ—â‰« Y â— Îµ_ Y Y') âŠ—â‰« f := by\n      rw [â† whisker_exchange]; monoidal\n    _ = _ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_whiskerLeft_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nY Z : C\ninstâœ : CategoryTheory.HasLeftDual Z\nf : Quiver.Hom Y (CategoryTheory.HasLeftDual.leftDual Z)\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv Y (CategoryTheory.HasLeftDual.leftDual Z) Z CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Z) Z))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasLeftDual.leftDual Z)).inv)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_whiskerLeft_comp_evaluation {Y Z : C} [HasLeftDual Z] (f : Y âŸ¶ á˜Z) :\n    (tensorLeftHomEquiv _ _ _ _) (Z â— f â‰« Îµ_ _ _) = f â‰« (Ï_ _).inv :=\n  calc\n    _ = ğŸ™ _ âŠ—â‰« (Î·_ (á˜Z : C) Z â–· Y â‰« ((á˜Z) âŠ— Z) â— f) âŠ—â‰« (á˜Z) â— Îµ_ (á˜Z) Z := by\n      dsimp [tensorLeftHomEquiv]; monoidal\n    _ = f âŠ—â‰« (Î·_ (á˜Z) Z â–· (á˜Z) âŠ—â‰« (á˜Z) â— Îµ_ (á˜Z) Z) := by\n      rw [â† whisker_exchange]; monoidal\n    _ = _ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_whiskerRight_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.tensorLeftHomEquiv (CategoryTheory.HasLeftDual.leftDual Y) (CategoryTheory.HasLeftDual.leftDual X) X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasLeftDual.leftDual X)).inv)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_whiskerRight_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y]\n    (f : X âŸ¶ Y) : (tensorLeftHomEquiv _ _ _ _) (f â–· _ â‰« Îµ_ _ _) = (á˜f) â‰« (Ï_ _).inv := by\n  dsimp [tensorLeftHomEquiv, leftAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_whiskerLeft_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv (CategoryTheory.HasRightDual.rightDual Y) X (CategoryTheory.HasRightDual.rightDual X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasRightDual.rightDual X)).inv)","decl":"@[simp]\ntheorem tensorRightHomEquiv_whiskerLeft_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y]\n    (f : X âŸ¶ Y) : (tensorRightHomEquiv _ _ _ _) ((Yá˜ : C) â— f â‰« Îµ_ _ _) = fá˜ â‰« (Î»_ _).inv := by\n  dsimp [tensorRightHomEquiv, rightAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_whiskerRight_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœ : CategoryTheory.HasRightDual X\nf : Quiver.Hom Y (CategoryTheory.HasRightDual.rightDual X)\nâŠ¢ Eq ((CategoryTheory.tensorRightHomEquiv Y X (CategoryTheory.HasRightDual.rightDual X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X)))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasRightDual.rightDual X)).inv)","decl":"@[simp]\ntheorem tensorRightHomEquiv_whiskerRight_comp_evaluation {X Y : C} [HasRightDual X] (f : Y âŸ¶ Xá˜) :\n    (tensorRightHomEquiv _ _ _ _) (f â–· X â‰« Îµ_ X (Xá˜)) = f â‰« (Î»_ _).inv :=\n  calc\n    _ = ğŸ™ _ âŠ—â‰« (Y â— Î·_ X Xá˜ â‰« f â–· (X âŠ— Xá˜)) âŠ—â‰« Îµ_ X Xá˜ â–· Xá˜ := by\n      dsimp [tensorRightHomEquiv]; monoidal\n    _ = f âŠ—â‰« (Xá˜ â— Î·_ X Xá˜ âŠ—â‰« Îµ_ X Xá˜ â–· Xá˜) := by\n      rw [whisker_exchange]; monoidal\n    _ = _ := by\n      rw [coevaluation_evaluation'']; monoidal\n\n-- Next four lemmas passing `fá˜` or `á˜f` through (co)evaluations.\n"}
{"name":"CategoryTheory.coevaluation_comp_rightAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y (CategoryTheory.HasRightDual.rightDual Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.rightAdjointMate f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)))","decl":"@[reassoc]\ntheorem coevaluation_comp_rightAdjointMate {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X âŸ¶ Y) :\n    Î·_ Y (Yá˜) â‰« _ â— (fá˜) = Î·_ _ _ â‰« f â–· _ := by\n  apply_fun (tensorLeftHomEquiv _ Y (Yá˜) _).symm\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_rightAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.HasRightDual.rightDual X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y (CategoryTheory.HasRightDual.rightDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.rightAdjointMate f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)) h))","decl":"@[reassoc]\ntheorem coevaluation_comp_rightAdjointMate {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X âŸ¶ Y) :\n    Î·_ Y (Yá˜) â‰« _ â— (fá˜) = Î·_ _ _ â‰« f â–· _ := by\n  apply_fun (tensorLeftHomEquiv _ Y (Yá˜) _).symm\n  simp\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.leftAdjointMate f)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual X) X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y))","decl":"@[reassoc]\ntheorem leftAdjointMate_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X âŸ¶ Y) :\n    X â— (á˜f) â‰« Îµ_ _ _ = f â–· _ â‰« Îµ_ _ _ := by\n  apply_fun tensorLeftHomEquiv _ (á˜X) X _\n  simp\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.leftAdjointMate f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual X) X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) h))","decl":"@[reassoc]\ntheorem leftAdjointMate_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X âŸ¶ Y) :\n    X â— (á˜f) â‰« Îµ_ _ _ = f â–· _ â‰« Îµ_ _ _ := by\n  apply_fun tensorLeftHomEquiv _ (á˜X) X _\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_leftAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.HasLeftDual.leftDual X) Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.leftAdjointMate f) Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f) h))","decl":"@[reassoc]\ntheorem coevaluation_comp_leftAdjointMate {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X âŸ¶ Y) :\n    Î·_ (á˜Y) Y â‰« (á˜f) â–· Y = Î·_ (á˜X) X â‰« (á˜X) â— f := by\n  apply_fun (tensorRightHomEquiv _ (á˜Y) Y _).symm\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_leftAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasLeftDual X\ninstâœ : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.leftAdjointMate f) Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f))","decl":"@[reassoc]\ntheorem coevaluation_comp_leftAdjointMate {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X âŸ¶ Y) :\n    Î·_ (á˜Y) Y â‰« (á˜f) â–· Y = Î·_ (á˜X) X â‰« (á˜X) â— f := by\n  apply_fun (tensorRightHomEquiv _ (á˜Y) Y _).symm\n  simp\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.rightAdjointMate f) X) (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)))","decl":"@[reassoc]\ntheorem rightAdjointMate_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X âŸ¶ Y) :\n    (fá˜ â–· X) â‰« Îµ_ X (Xá˜) = ((Yá˜) â— f) â‰« Îµ_ Y (Yá˜) := by\n  apply_fun tensorRightHomEquiv _ X (Xá˜) _\n  simp\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nX Y : C\ninstâœÂ¹ : CategoryTheory.HasRightDual X\ninstâœ : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.rightAdjointMate f) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)) h))","decl":"@[reassoc]\ntheorem rightAdjointMate_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X âŸ¶ Y) :\n    (fá˜ â–· X) â‰« Îµ_ X (Xá˜) = ((Yá˜) â— f) â‰« Îµ_ Y (Yá˜) := by\n  apply_fun tensorRightHomEquiv _ X (Xá˜) _\n  simp\n\n"}
{"name":"CategoryTheory.rightDualIso_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\np : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.rightDualIso p p) (CategoryTheory.Iso.refl Y)","decl":"@[simp]\ntheorem rightDualIso_id {X Y : C} (p : ExactPairing X Y) : rightDualIso p p = Iso.refl Y := by\n  ext\n  simp only [rightDualIso, Iso.refl_hom, @rightAdjointMate_id _ _ _ _ âŸ¨YâŸ©]\n\n"}
{"name":"CategoryTheory.leftDualIso_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\np : CategoryTheory.ExactPairing X Y\nâŠ¢ Eq (CategoryTheory.leftDualIso p p) (CategoryTheory.Iso.refl X)","decl":"@[simp]\ntheorem leftDualIso_id {X Y : C} (p : ExactPairing X Y) : leftDualIso p p = Iso.refl X := by\n  ext\n  simp only [leftDualIso, Iso.refl_hom, @leftAdjointMate_id _ _ _ _ âŸ¨XâŸ©]\n\n"}
