{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation'","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\nself : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.ExactPairing.coevaluation' X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X CategoryTheory.ExactPairing.evaluation'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"/-- An exact pairing is a pair of objects `X Y : C` which admit\n  a coevaluation and evaluation morphism which fulfill two triangle equalities. -/\nclass ExactPairing (X Y : C) where\n  /-- Coevaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.coevaluation` instead. -/\n  coevaluation' : ùüô_ C ‚ü∂ X ‚äó Y\n  /-- Evaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.evaluation` instead. -/\n  evaluation' : Y ‚äó X ‚ü∂ ùüô_ C\n  coevaluation_evaluation' :\n    Y ‚óÅ coevaluation' ‚â´ (Œ±_ _ _ _).inv ‚â´ evaluation' ‚ñ∑ Y = (œÅ_ Y).hom ‚â´ (Œª_ Y).inv := by\n    aesop_cat\n  evaluation_coevaluation' :\n    coevaluation' ‚ñ∑ X ‚â´ (Œ±_ _ _ _).hom ‚â´ X ‚óÅ evaluation' = (Œª_ X).hom ‚â´ (œÅ_ X).inv := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation'","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\nself : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y CategoryTheory.ExactPairing.coevaluation') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.ExactPairing.evaluation' Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv)","decl":"/-- An exact pairing is a pair of objects `X Y : C` which admit\n  a coevaluation and evaluation morphism which fulfill two triangle equalities. -/\nclass ExactPairing (X Y : C) where\n  /-- Coevaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.coevaluation` instead. -/\n  coevaluation' : ùüô_ C ‚ü∂ X ‚äó Y\n  /-- Evaluation of an exact pairing.\n\n  Do not use directly. Use `ExactPairing.evaluation` instead. -/\n  evaluation' : Y ‚äó X ‚ü∂ ùüô_ C\n  coevaluation_evaluation' :\n    Y ‚óÅ coevaluation' ‚â´ (Œ±_ _ _ _).inv ‚â´ evaluation' ‚ñ∑ Y = (œÅ_ Y).hom ‚â´ (Œª_ Y).inv := by\n    aesop_cat\n  evaluation_coevaluation' :\n    coevaluation' ‚ñ∑ X ‚â´ (Œ±_ _ _ _).hom ‚â´ X ‚óÅ evaluation' = (Œª_ X).hom ‚â´ (œÅ_ X).inv := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv)","decl":"lemma coevaluation_evaluation :\n    Y ‚óÅ Œ∑_ _ _ ‚â´ (Œ±_ _ _ _).inv ‚â´ Œµ_ X _ ‚ñ∑ Y = (œÅ_ Y).hom ‚â´ (Œª_ Y).inv :=\n  coevaluation_evaluation'\n\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"lemma evaluation_coevaluation :\n    Œ∑_ _ _ ‚ñ∑ X ‚â´ (Œ±_ _ _ _).hom ‚â´ X ‚óÅ Œµ_ _ Y = (Œª_ X).hom ‚â´ (œÅ_ X).inv :=\n  evaluation_coevaluation'\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation''","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y)) CategoryTheory.MonoidalCoherence.iso.hom","decl":"lemma coevaluation_evaluation'' :\n    Y ‚óÅ Œ∑_ X Y ‚äó‚â´ Œµ_ X Y ‚ñ∑ Y = ‚äóùüô.hom := by\n  convert coevaluation_evaluation X Y <;> simp [monoidalComp]\n\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation''","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.monoidalComp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y))) CategoryTheory.MonoidalCoherence.iso.hom","decl":"lemma evaluation_coevaluation'' :\n    Œ∑_ X Y ‚ñ∑ X ‚äó‚â´ X ‚óÅ Œµ_ X Y = ‚äóùüô.hom := by\n  convert evaluation_coevaluation X Y <;> simp [monoidalComp]\n\n"}
{"name":"CategoryTheory.ExactPairing.coevaluation_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.ExactPairing.coevaluation X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y X Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation X Y) Y) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv h))","decl":"attribute [reassoc (attr := simp)] ExactPairing.coevaluation_evaluation\n"}
{"name":"CategoryTheory.ExactPairing.evaluation_coevaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.ExactPairing X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation X Y) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.ExactPairing.evaluation X Y)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h))","decl":"attribute [reassoc (attr := simp)] ExactPairing.evaluation_coevaluation\n\n"}
{"name":"CategoryTheory.leftDual_rightDual","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : CategoryTheory.HasRightDual X\n‚ä¢ Eq (CategoryTheory.HasLeftDual.leftDual (CategoryTheory.HasRightDual.rightDual X)) X","decl":"@[simp]\ntheorem leftDual_rightDual {X : C} [HasRightDual X] : ·òÅX·òÅ = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.rightDual_leftDual","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : CategoryTheory.HasLeftDual X\n‚ä¢ Eq (CategoryTheory.HasRightDual.rightDual (CategoryTheory.HasLeftDual.leftDual X)) X","decl":"@[simp]\ntheorem rightDual_leftDual {X : C} [HasLeftDual X] : (·òÅX)·òÅ = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.rightAdjointMate_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : CategoryTheory.HasRightDual X\n‚ä¢ Eq (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.HasRightDual.rightDual X))","decl":"@[simp]\ntheorem rightAdjointMate_id {X : C} [HasRightDual X] : (ùüô X)·òÅ = ùüô (X·òÅ) := by\n  simp [rightAdjointMate]\n\n"}
{"name":"CategoryTheory.leftAdjointMate_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : CategoryTheory.HasLeftDual X\n‚ä¢ Eq (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.HasLeftDual.leftDual X))","decl":"@[simp]\ntheorem leftAdjointMate_id {X : C} [HasLeftDual X] : (·òÅ(ùüô X)) = ùüô (·òÅX) := by\n  simp [leftAdjointMate]\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\ng : Quiver.Hom (CategoryTheory.HasRightDual.rightDual X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasRightDual.rightDual Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.HasRightDual.rightDual Y) Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)) Z) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Z).hom)))))","decl":"theorem rightAdjointMate_comp {X Y Z : C} [HasRightDual X] [HasRightDual Y] {f : X ‚ü∂ Y}\n    {g : X·òÅ ‚ü∂ Z} :\n    f·òÅ ‚â´ g =\n      (œÅ_ (Y·òÅ)).inv ‚â´\n        _ ‚óÅ Œ∑_ X (X·òÅ) ‚â´ _ ‚óÅ (f ‚äó g) ‚â´ (Œ±_ (Y·òÅ) Y Z).inv ‚â´ Œµ_ Y (Y·òÅ) ‚ñ∑ _ ‚â´ (Œª_ Z).hom :=\n  calc\n    _ = ùüô _ ‚äó‚â´ (Y·òÅ : C) ‚óÅ Œ∑_ X X·òÅ ‚â´ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚â´ ùüô_ C ‚óÅ g) ‚äó‚â´ ùüô _ := by\n      dsimp only [rightAdjointMate]; monoidal\n    _ = _ := by\n      rw [‚Üê whisker_exchange, tensorHom_def]; monoidal\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\ng : Quiver.Hom (CategoryTheory.HasLeftDual.leftDual X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasLeftDual.leftDual Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Z Y (CategoryTheory.HasLeftDual.leftDual Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Z).hom)))))","decl":"theorem leftAdjointMate_comp {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] {f : X ‚ü∂ Y}\n    {g : (·òÅX) ‚ü∂ Z} :\n    (·òÅf) ‚â´ g =\n      (Œª_ _).inv ‚â´\n        Œ∑_ (·òÅX : C) X ‚ñ∑ _ ‚â´ (g ‚äó f) ‚ñ∑ _ ‚â´ (Œ±_ _ _ _).hom ‚â´ _ ‚óÅ Œµ_ _ _ ‚â´ (œÅ_ _).hom :=\n  calc\n    _ = ùüô _ ‚äó‚â´ Œ∑_ (·òÅX : C) X ‚ñ∑ (·òÅY) ‚äó‚â´ (·òÅX) ‚óÅ f ‚ñ∑ (·òÅY) ‚äó‚â´ ((·òÅX) ‚óÅ Œµ_ (·òÅY) Y ‚â´ g ‚ñ∑ ùüô_ C) ‚äó‚â´ ùüô _ := by\n      dsimp only [leftAdjointMate]; monoidal\n    _ = _ := by\n      rw [whisker_exchange, tensorHom_def']; monoidal\n\n"}
{"name":"CategoryTheory.comp_rightAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninst‚úù¬≤ : CategoryTheory.HasRightDual X\ninst‚úù¬π : CategoryTheory.HasRightDual Y\ninst‚úù : CategoryTheory.HasRightDual Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate g) (CategoryTheory.rightAdjointMate f))","decl":"/-- The composition of right adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]\n    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ := by\n  rw [rightAdjointMate_comp]\n  simp only [rightAdjointMate, comp_whiskerRight]\n  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2\n  symm\n  calc\n    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´\n        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [tensorHom_def']; monoidal\n    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´\n        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_rightAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nX Y Z‚úù : C\ninst‚úù¬≤ : CategoryTheory.HasRightDual X\ninst‚úù¬π : CategoryTheory.HasRightDual Y\ninst‚úù : CategoryTheory.HasRightDual Z‚úù\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.HasRightDual.rightDual X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) h))","decl":"/-- The composition of right adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]\n    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ := by\n  rw [rightAdjointMate_comp]\n  simp only [rightAdjointMate, comp_whiskerRight]\n  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2\n  symm\n  calc\n    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´\n        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [tensorHom_def']; monoidal\n    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´\n        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_leftAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nX Y Z‚úù : C\ninst‚úù¬≤ : CategoryTheory.HasLeftDual X\ninst‚úù¬π : CategoryTheory.HasLeftDual Y\ninst‚úù : CategoryTheory.HasLeftDual Z‚úù\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.HasLeftDual.leftDual X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) h))","decl":"/-- The composition of left adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_leftAdjointMate {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] [HasLeftDual Z] {f : X ‚ü∂ Y}\n    {g : Y ‚ü∂ Z} : (·òÅf ‚â´ g) = (·òÅg) ‚â´ ·òÅf := by\n  rw [leftAdjointMate_comp]\n  simp only [leftAdjointMate, MonoidalCategory.whiskerLeft_comp]\n  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [‚Üê comp_whiskerRight]; congr 2\n  symm\n  calc\n    _ = ùüô _ ‚äó‚â´ ((ùüô_ C) ‚óÅ Œ∑_ (·òÅY) Y ‚â´ Œ∑_ (·òÅX) X ‚ñ∑ ((·òÅY) ‚äó Y)) ‚äó‚â´ (·òÅX) ‚óÅ f ‚ñ∑ (·òÅY) ‚ñ∑ Y ‚äó‚â´\n        (·òÅX) ‚óÅ Œµ_ (·òÅY) Y ‚ñ∑ Y ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [tensorHom_def]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚äó‚â´ (((·òÅX) ‚äó X) ‚óÅ Œ∑_ (·òÅY) Y ‚â´ ((·òÅX) ‚óÅ f) ‚ñ∑ ((·òÅY) ‚äó Y)) ‚äó‚â´\n        (·òÅX) ‚óÅ Œµ_ (·òÅY) Y ‚ñ∑ Y ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [whisker_exchange]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚äó‚â´ ((·òÅX) ‚óÅ f) ‚äó‚â´ (·òÅX) ‚óÅ (Y ‚óÅ Œ∑_ (·òÅY) Y ‚äó‚â´ Œµ_ (·òÅY) Y ‚ñ∑ Y) ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [whisker_exchange]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚â´ (·òÅX) ‚óÅ f ‚â´ (·òÅX) ‚óÅ g := by\n      rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.comp_leftAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nX Y Z : C\ninst‚úù¬≤ : CategoryTheory.HasLeftDual X\ninst‚úù¬π : CategoryTheory.HasLeftDual Y\ninst‚úù : CategoryTheory.HasLeftDual Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.leftAdjointMate (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate g) (CategoryTheory.leftAdjointMate f))","decl":"/-- The composition of left adjoint mates is the adjoint mate of the composition. -/\n@[reassoc]\ntheorem comp_leftAdjointMate {X Y Z : C} [HasLeftDual X] [HasLeftDual Y] [HasLeftDual Z] {f : X ‚ü∂ Y}\n    {g : Y ‚ü∂ Z} : (·òÅf ‚â´ g) = (·òÅg) ‚â´ ·òÅf := by\n  rw [leftAdjointMate_comp]\n  simp only [leftAdjointMate, MonoidalCategory.whiskerLeft_comp]\n  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]\n  simp only [‚Üê comp_whiskerRight]; congr 2\n  symm\n  calc\n    _ = ùüô _ ‚äó‚â´ ((ùüô_ C) ‚óÅ Œ∑_ (·òÅY) Y ‚â´ Œ∑_ (·òÅX) X ‚ñ∑ ((·òÅY) ‚äó Y)) ‚äó‚â´ (·òÅX) ‚óÅ f ‚ñ∑ (·òÅY) ‚ñ∑ Y ‚äó‚â´\n        (·òÅX) ‚óÅ Œµ_ (·òÅY) Y ‚ñ∑ Y ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [tensorHom_def]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚äó‚â´ (((·òÅX) ‚äó X) ‚óÅ Œ∑_ (·òÅY) Y ‚â´ ((·òÅX) ‚óÅ f) ‚ñ∑ ((·òÅY) ‚äó Y)) ‚äó‚â´\n        (·òÅX) ‚óÅ Œµ_ (·òÅY) Y ‚ñ∑ Y ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [whisker_exchange]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚äó‚â´ ((·òÅX) ‚óÅ f) ‚äó‚â´ (·òÅX) ‚óÅ (Y ‚óÅ Œ∑_ (·òÅY) Y ‚äó‚â´ Œµ_ (·òÅY) Y ‚ñ∑ Y) ‚äó‚â´ (·òÅX) ‚óÅ g := by\n      rw [whisker_exchange]; monoidal\n    _ = Œ∑_ (·òÅX) X ‚â´ (·òÅX) ‚óÅ f ‚â´ (·òÅX) ‚óÅ g := by\n      rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y Y' Z Z' : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' X) Z\ng : Quiver.Hom Z Z'\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z) f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y g))","decl":"theorem tensorLeftHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : Y' ‚äó X ‚ü∂ Z)\n    (g : Z ‚ü∂ Z') :\n    (tensorLeftHomEquiv X Y Y' Z') (f ‚â´ g) = (tensorLeftHomEquiv X Y Y' Z) f ‚â´ Y ‚óÅ g := by\n  simp [tensorLeftHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X X'\ng : Quiver.Hom X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y' f) ((CategoryTheory.tensorLeftHomEquiv X' Y Y' Z).symm g))","decl":"theorem tensorLeftHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X ‚ü∂ X')\n    (g : X' ‚ü∂ Y ‚äó Z) :\n    (tensorLeftHomEquiv X Y Y' Z).symm (f ‚â´ g) =\n      _ ‚óÅ f ‚â´ (tensorLeftHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorLeftHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y Y' Z Z' : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\ng : Quiver.Hom Z Z'\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv X Y Y' Z') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.tensorRightHomEquiv X Y Y' Z) f) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Y'))","decl":"theorem tensorRightHomEquiv_naturality {X Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X ‚äó Y ‚ü∂ Z)\n    (g : Z ‚ü∂ Z') :\n    (tensorRightHomEquiv X Y Y' Z') (f ‚â´ g) = (tensorRightHomEquiv X Y Y' Z) f ‚â´ g ‚ñ∑ Y' := by\n  simp [tensorRightHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_naturality","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X X'\ng : Quiver.Hom X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y')\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv X Y Y' Z).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) ((CategoryTheory.tensorRightHomEquiv X' Y Y' Z).symm g))","decl":"theorem tensorRightHomEquiv_symm_naturality {X X' Y Y' Z : C} [ExactPairing Y Y'] (f : X ‚ü∂ X')\n    (g : X' ‚ü∂ Z ‚äó Y') :\n    (tensorRightHomEquiv X Y Y' Z).symm (f ‚â´ g) =\n      f ‚ñ∑ Y ‚â´ (tensorRightHomEquiv X' Y Y' Z).symm g := by\n  simp [tensorRightHomEquiv]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_tensor","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)\ng : Quiver.Hom X' Z'\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj X X') Y Y' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Z')).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.MonoidalCategoryStruct.associator Y Z Z').hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y' X X').inv (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.tensorLeftHomEquiv X Y Y' Z).symm f) g))","decl":"/-- `tensorLeftHomEquiv` commutes with tensoring on the right -/\ntheorem tensorLeftHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X ‚ü∂ Y ‚äó Z)\n    (g : X' ‚ü∂ Z') :\n    (tensorLeftHomEquiv (X ‚äó X') Y Y' (Z ‚äó Z')).symm ((f ‚äó g) ‚â´ (Œ±_ _ _ _).hom) =\n      (Œ±_ _ _ _).inv ‚â´ ((tensorLeftHomEquiv X Y Y' Z).symm f ‚äó g) := by\n  simp [tensorLeftHomEquiv, tensorHom_def']\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_tensor","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y')\ng : Quiver.Hom X' Z'\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj X' X) Y Y' (CategoryTheory.MonoidalCategoryStruct.tensorObj Z' Z)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.MonoidalCategoryStruct.associator Z' Z Y').inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' X Y).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom g ((CategoryTheory.tensorRightHomEquiv X Y Y' Z).symm f)))","decl":"/-- `tensorRightHomEquiv` commutes with tensoring on the left -/\ntheorem tensorRightHomEquiv_tensor {X X' Y Y' Z Z' : C} [ExactPairing Y Y'] (f : X ‚ü∂ Z ‚äó Y')\n    (g : X' ‚ü∂ Z') :\n    (tensorRightHomEquiv (X' ‚äó X) Y Y' (Z' ‚äó Z)).symm ((g ‚äó f) ‚â´ (Œ±_ _ _ _).inv) =\n      (Œ±_ _ _ _).hom ‚â´ (g ‚äó (tensorRightHomEquiv X Y Y' Z).symm f) := by\n  simp [tensorRightHomEquiv, tensorHom_def]\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nY Y' Z : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom Y' Z\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y Y' Z).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y Y') (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y').hom f)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_symm_coevaluation_comp_whiskerLeft {Y Y' Z : C} [ExactPairing Y Y']\n    (f : Y' ‚ü∂ Z) : (tensorLeftHomEquiv _ _ _ _).symm (Œ∑_ _ _ ‚â´ Y ‚óÅ f) = (œÅ_ _).hom ‚â´ f := by\n  calc\n    _ = Y' ‚óÅ Œ∑_ Y Y' ‚äó‚â´ ((Y' ‚äó Y) ‚óÅ f ‚â´ Œµ_ Y Y' ‚ñ∑ Z) ‚äó‚â´ ùüô _ := by\n      dsimp [tensorLeftHomEquiv]; monoidal\n    _ = (Y' ‚óÅ Œ∑_ Y Y' ‚äó‚â´ Œµ_ Y Y' ‚ñ∑ Y') ‚äó‚â´ f := by\n      rw [whisker_exchange]; monoidal\n    _ = _ := by rw [coevaluation_evaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_symm_coevaluation_comp_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y (CategoryTheory.HasRightDual.rightDual Y) (CategoryTheory.HasRightDual.rightDual X)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasRightDual.rightDual Y)).hom (CategoryTheory.rightAdjointMate f))","decl":"@[simp]\ntheorem tensorLeftHomEquiv_symm_coevaluation_comp_whiskerRight {X Y : C} [HasRightDual X]\n    [HasRightDual Y] (f : X ‚ü∂ Y) :\n    (tensorLeftHomEquiv _ _ _ _).symm (Œ∑_ _ _ ‚â´ f ‚ñ∑ (X·òÅ)) = (œÅ_ _).hom ‚â´ f·òÅ := by\n  dsimp [tensorLeftHomEquiv, rightAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.HasLeftDual.leftDual Y) Y (CategoryTheory.HasLeftDual.leftDual X)).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasLeftDual.leftDual Y)).hom (CategoryTheory.leftAdjointMate f))","decl":"@[simp]\ntheorem tensorRightHomEquiv_symm_coevaluation_comp_whiskerLeft {X Y : C} [HasLeftDual X]\n    [HasLeftDual Y] (f : X ‚ü∂ Y) :\n    (tensorRightHomEquiv _ (·òÅY) _ _).symm (Œ∑_ (·òÅX : C) X ‚â´ (·òÅX : C) ‚óÅ f) = (Œª_ _).hom ‚â´ ·òÅf := by\n  dsimp [tensorRightHomEquiv, leftAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_symm_coevaluation_comp_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nY Y' Z : C\ninst‚úù : CategoryTheory.ExactPairing Y Y'\nf : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit Y Y' Z).symm (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y Y') (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom f)","decl":"@[simp]\ntheorem tensorRightHomEquiv_symm_coevaluation_comp_whiskerRight {Y Y' Z : C} [ExactPairing Y Y']\n    (f : Y ‚ü∂ Z) : (tensorRightHomEquiv _ Y _ _).symm (Œ∑_ Y Y' ‚â´ f ‚ñ∑ Y') = (Œª_ _).hom ‚â´ f :=\n  calc\n    _ = Œ∑_ Y Y' ‚ñ∑ Y ‚äó‚â´ (f ‚ñ∑ (Y' ‚äó Y) ‚â´ Z ‚óÅ Œµ_ Y Y') ‚äó‚â´ ùüô _ := by\n      dsimp [tensorRightHomEquiv]; monoidal\n    _ = (Œ∑_ Y Y' ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y') ‚äó‚â´ f := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = _ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_whiskerLeft_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nY Z : C\ninst‚úù : CategoryTheory.HasLeftDual Z\nf : Quiver.Hom Y (CategoryTheory.HasLeftDual.leftDual Z)\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv Y (CategoryTheory.HasLeftDual.leftDual Z) Z CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Z) Z))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasLeftDual.leftDual Z)).inv)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_whiskerLeft_comp_evaluation {Y Z : C} [HasLeftDual Z] (f : Y ‚ü∂ ·òÅZ) :\n    (tensorLeftHomEquiv _ _ _ _) (Z ‚óÅ f ‚â´ Œµ_ _ _) = f ‚â´ (œÅ_ _).inv :=\n  calc\n    _ = ùüô _ ‚äó‚â´ (Œ∑_ (·òÅZ : C) Z ‚ñ∑ Y ‚â´ ((·òÅZ) ‚äó Z) ‚óÅ f) ‚äó‚â´ (·òÅZ) ‚óÅ Œµ_ (·òÅZ) Z := by\n      dsimp [tensorLeftHomEquiv]; monoidal\n    _ = f ‚äó‚â´ (Œ∑_ (·òÅZ) Z ‚ñ∑ (·òÅZ) ‚äó‚â´ (·òÅZ) ‚óÅ Œµ_ (·òÅZ) Z) := by\n      rw [‚Üê whisker_exchange]; monoidal\n    _ = _ := by\n      rw [evaluation_coevaluation'']; monoidal\n\n"}
{"name":"CategoryTheory.tensorLeftHomEquiv_whiskerRight_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.tensorLeftHomEquiv (CategoryTheory.HasLeftDual.leftDual Y) (CategoryTheory.HasLeftDual.leftDual X) X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftAdjointMate f) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.HasLeftDual.leftDual X)).inv)","decl":"@[simp]\ntheorem tensorLeftHomEquiv_whiskerRight_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y]\n    (f : X ‚ü∂ Y) : (tensorLeftHomEquiv _ _ _ _) (f ‚ñ∑ _ ‚â´ Œµ_ _ _) = (·òÅf) ‚â´ (œÅ_ _).inv := by\n  dsimp [tensorLeftHomEquiv, leftAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_whiskerLeft_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv (CategoryTheory.HasRightDual.rightDual Y) X (CategoryTheory.HasRightDual.rightDual X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightAdjointMate f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasRightDual.rightDual X)).inv)","decl":"@[simp]\ntheorem tensorRightHomEquiv_whiskerLeft_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y]\n    (f : X ‚ü∂ Y) : (tensorRightHomEquiv _ _ _ _) ((Y·òÅ : C) ‚óÅ f ‚â´ Œµ_ _ _) = f·òÅ ‚â´ (Œª_ _).inv := by\n  dsimp [tensorRightHomEquiv, rightAdjointMate]\n  simp\n\n"}
{"name":"CategoryTheory.tensorRightHomEquiv_whiskerRight_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù : CategoryTheory.HasRightDual X\nf : Quiver.Hom Y (CategoryTheory.HasRightDual.rightDual X)\n‚ä¢ Eq ((CategoryTheory.tensorRightHomEquiv Y X (CategoryTheory.HasRightDual.rightDual X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X)))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.HasRightDual.rightDual X)).inv)","decl":"@[simp]\ntheorem tensorRightHomEquiv_whiskerRight_comp_evaluation {X Y : C} [HasRightDual X] (f : Y ‚ü∂ X·òÅ) :\n    (tensorRightHomEquiv _ _ _ _) (f ‚ñ∑ X ‚â´ Œµ_ X (X·òÅ)) = f ‚â´ (Œª_ _).inv :=\n  calc\n    _ = ùüô _ ‚äó‚â´ (Y ‚óÅ Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ (X ‚äó X·òÅ)) ‚äó‚â´ Œµ_ X X·òÅ ‚ñ∑ X·òÅ := by\n      dsimp [tensorRightHomEquiv]; monoidal\n    _ = f ‚äó‚â´ (X·òÅ ‚óÅ Œ∑_ X X·òÅ ‚äó‚â´ Œµ_ X X·òÅ ‚ñ∑ X·òÅ) := by\n      rw [whisker_exchange]; monoidal\n    _ = _ := by\n      rw [coevaluation_evaluation'']; monoidal\n\n-- Next four lemmas passing `f·òÅ` or `·òÅf` through (co)evaluations.\n"}
{"name":"CategoryTheory.coevaluation_comp_rightAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y (CategoryTheory.HasRightDual.rightDual Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.rightAdjointMate f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)))","decl":"@[reassoc]\ntheorem coevaluation_comp_rightAdjointMate {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X ‚ü∂ Y) :\n    Œ∑_ Y (Y·òÅ) ‚â´ _ ‚óÅ (f·òÅ) = Œ∑_ _ _ ‚â´ f ‚ñ∑ _ := by\n  apply_fun (tensorLeftHomEquiv _ Y (Y·òÅ) _).symm\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_rightAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.HasRightDual.rightDual X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation Y (CategoryTheory.HasRightDual.rightDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.rightAdjointMate f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation X (CategoryTheory.HasRightDual.rightDual X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasRightDual.rightDual X)) h))","decl":"@[reassoc]\ntheorem coevaluation_comp_rightAdjointMate {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X ‚ü∂ Y) :\n    Œ∑_ Y (Y·òÅ) ‚â´ _ ‚óÅ (f·òÅ) = Œ∑_ _ _ ‚â´ f ‚ñ∑ _ := by\n  apply_fun (tensorLeftHomEquiv _ Y (Y·òÅ) _).symm\n  simp\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.leftAdjointMate f)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual X) X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y))","decl":"@[reassoc]\ntheorem leftAdjointMate_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X ‚ü∂ Y) :\n    X ‚óÅ (·òÅf) ‚â´ Œµ_ _ _ = f ‚ñ∑ _ ‚â´ Œµ_ _ _ := by\n  apply_fun tensorLeftHomEquiv _ (·òÅX) X _\n  simp\n\n"}
{"name":"CategoryTheory.leftAdjointMate_comp_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.leftAdjointMate f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual X) X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.HasLeftDual.leftDual Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) h))","decl":"@[reassoc]\ntheorem leftAdjointMate_comp_evaluation {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X ‚ü∂ Y) :\n    X ‚óÅ (·òÅf) ‚â´ Œµ_ _ _ = f ‚ñ∑ _ ‚â´ Œµ_ _ _ := by\n  apply_fun tensorLeftHomEquiv _ (·òÅX) X _\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_leftAdjointMate_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.HasLeftDual.leftDual X) Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.leftAdjointMate f) Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f) h))","decl":"@[reassoc]\ntheorem coevaluation_comp_leftAdjointMate {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X ‚ü∂ Y) :\n    Œ∑_ (·òÅY) Y ‚â´ (·òÅf) ‚ñ∑ Y = Œ∑_ (·òÅX) X ‚â´ (·òÅX) ‚óÅ f := by\n  apply_fun (tensorRightHomEquiv _ (·òÅY) Y _).symm\n  simp\n\n"}
{"name":"CategoryTheory.coevaluation_comp_leftAdjointMate","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasLeftDual X\ninst‚úù : CategoryTheory.HasLeftDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual Y) Y) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.leftAdjointMate f) Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.coevaluation (CategoryTheory.HasLeftDual.leftDual X) X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasLeftDual.leftDual X) f))","decl":"@[reassoc]\ntheorem coevaluation_comp_leftAdjointMate {X Y : C} [HasLeftDual X] [HasLeftDual Y] (f : X ‚ü∂ Y) :\n    Œ∑_ (·òÅY) Y ‚â´ (·òÅf) ‚ñ∑ Y = Œ∑_ (·òÅX) X ‚â´ (·òÅX) ‚óÅ f := by\n  apply_fun (tensorRightHomEquiv _ (·òÅY) Y _).symm\n  simp\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp_evaluation","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.rightAdjointMate f) X) (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)))","decl":"@[reassoc]\ntheorem rightAdjointMate_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X ‚ü∂ Y) :\n    (f·òÅ ‚ñ∑ X) ‚â´ Œµ_ X (X·òÅ) = ((Y·òÅ) ‚óÅ f) ‚â´ Œµ_ Y (Y·òÅ) := by\n  apply_fun tensorRightHomEquiv _ X (X·òÅ) _\n  simp\n\n"}
{"name":"CategoryTheory.rightAdjointMate_comp_evaluation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nX Y : C\ninst‚úù¬π : CategoryTheory.HasRightDual X\ninst‚úù : CategoryTheory.HasRightDual Y\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.rightAdjointMate f) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation X (CategoryTheory.HasRightDual.rightDual X)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.HasRightDual.rightDual Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ExactPairing.evaluation Y (CategoryTheory.HasRightDual.rightDual Y)) h))","decl":"@[reassoc]\ntheorem rightAdjointMate_comp_evaluation {X Y : C} [HasRightDual X] [HasRightDual Y] (f : X ‚ü∂ Y) :\n    (f·òÅ ‚ñ∑ X) ‚â´ Œµ_ X (X·òÅ) = ((Y·òÅ) ‚óÅ f) ‚â´ Œµ_ Y (Y·òÅ) := by\n  apply_fun tensorRightHomEquiv _ X (X·òÅ) _\n  simp\n\n"}
{"name":"CategoryTheory.rightDualIso_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\np : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.rightDualIso p p) (CategoryTheory.Iso.refl Y)","decl":"@[simp]\ntheorem rightDualIso_id {X Y : C} (p : ExactPairing X Y) : rightDualIso p p = Iso.refl Y := by\n  ext\n  simp only [rightDualIso, Iso.refl_hom, @rightAdjointMate_id _ _ _ _ ‚ü®Y‚ü©]\n\n"}
{"name":"CategoryTheory.leftDualIso_id","module":"Mathlib.CategoryTheory.Monoidal.Rigid.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : C\np : CategoryTheory.ExactPairing X Y\n‚ä¢ Eq (CategoryTheory.leftDualIso p p) (CategoryTheory.Iso.refl X)","decl":"@[simp]\ntheorem leftDualIso_id {X Y : C} (p : ExactPairing X Y) : leftDualIso p p = Iso.refl X := by\n  ext\n  simp only [leftDualIso, Iso.refl_hom, @leftAdjointMate_id _ _ _ _ ‚ü®X‚ü©]\n\n"}
