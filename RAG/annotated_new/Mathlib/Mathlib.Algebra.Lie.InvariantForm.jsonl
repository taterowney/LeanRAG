{"name":"LinearMap.BilinForm.lieInvariant_iff","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nΦ : LinearMap.BilinForm R M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ Iff (LinearMap.BilinForm.lieInvariant L Φ) (Membership.mem (LieModule.maxTrivSubmodule R L (LinearMap.BilinForm R M)) Φ)","decl":"lemma _root_.LinearMap.BilinForm.lieInvariant_iff [LieAlgebra R L] [LieModule R L M] :\n    Φ.lieInvariant L ↔ Φ ∈ LieModule.maxTrivSubmodule R L (LinearMap.BilinForm R M) := by\n  refine ⟨fun h x ↦ ?_, fun h x y z ↦ ?_⟩\n  · ext y z\n    rw [LieHom.lie_apply, LinearMap.sub_apply, Module.Dual.lie_apply, LinearMap.zero_apply,\n      LinearMap.zero_apply, h, sub_self]\n  · replace h := LinearMap.congr_fun₂ (h x) y z\n    simp only [LieHom.lie_apply, LinearMap.sub_apply, Module.Dual.lie_apply,\n      LinearMap.zero_apply, sub_eq_zero] at h\n    simp [← h]\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_carrier","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nΦ : LinearMap.BilinForm R M\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nN : LieSubmodule R L M\n⊢ Eq (↑(LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv N)) (setOf fun m => ∀ (n : M), Membership.mem N n → Φ.IsOrtho n m)","decl":"/--\nThe orthogonal complement of a Lie submodule `N` with respect to an invariant bilinear form `Φ` is\nthe Lie submodule of elements `y` such that `Φ x y = 0` for all `x ∈ N`.\n-/\n@[simps!]\ndef orthogonal (hΦ_inv : Φ.lieInvariant L) (N : LieSubmodule R L M) : LieSubmodule R L M where\n  __ := Φ.orthogonal N\n  lie_mem {x y} := by\n    suffices (∀ n ∈ N, Φ n y = 0) → ∀ n ∈ N, Φ n ⁅x, y⁆ = 0 by\n      simpa only [LinearMap.BilinForm.isOrtho_def, -- and some default simp lemmas\n        AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup, Submodule.mem_toAddSubmonoid,\n        LinearMap.BilinForm.mem_orthogonal_iff, LieSubmodule.mem_toSubmodule]\n    intro H a ha\n    rw [← neg_eq_zero, ← hΦ_inv]\n    exact H _ <| N.lie_mem ha\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_toSubmodule","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nΦ : LinearMap.BilinForm R M\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nN : LieSubmodule R L M\n⊢ Eq (↑(LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv N)) (Φ.orthogonal ↑N)","decl":"@[simp]\nlemma orthogonal_toSubmodule (N : LieSubmodule R L M) :\n    (orthogonal Φ hΦ_inv N).toSubmodule = Φ.orthogonal N.toSubmodule := rfl\n\n"}
{"name":"LieAlgebra.InvariantForm.mem_orthogonal","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nΦ : LinearMap.BilinForm R M\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nN : LieSubmodule R L M\ny : M\n⊢ Iff (Membership.mem (LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv N) y) (∀ (x : M), Membership.mem N x → Eq ((Φ x) y) 0)","decl":"lemma mem_orthogonal (N : LieSubmodule R L M) (y : M) :\n    y ∈ orthogonal Φ hΦ_inv N ↔ ∀ x ∈ N, Φ x y = 0 := by\n  simp [orthogonal, LinearMap.BilinForm.isOrtho_def, LinearMap.BilinForm.mem_orthogonal_iff]\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_disjoint","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nΦ : LinearMap.BilinForm R L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhL : ∀ (I : LieIdeal R L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal R L\nhI : IsAtom I\n⊢ Disjoint I (LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv I)","decl":"lemma orthogonal_disjoint\n    (Φ : LinearMap.BilinForm R L) (hΦ_nondeg : Φ.Nondegenerate) (hΦ_inv : Φ.lieInvariant L)\n    -- TODO: replace the following assumption by a typeclass assumption `[HasNonAbelianAtoms]`\n    (hL : ∀ I : LieIdeal R L, IsAtom I → ¬IsLieAbelian I)\n    (I : LieIdeal R L) (hI : IsAtom I) :\n    Disjoint I (orthogonal Φ hΦ_inv I) := by\n  rw [disjoint_iff, ← hI.lt_iff, lt_iff_le_and_ne]\n  suffices ¬I ≤ orthogonal Φ hΦ_inv I by simpa\n  intro contra\n  apply hI.1\n  rw [eq_bot_iff, ← lie_eq_self_of_isAtom_of_nonabelian I hI (hL I hI),\n      LieSubmodule.lieIdeal_oper_eq_span, LieSubmodule.lieSpan_le]\n  rintro _ ⟨x, y, rfl⟩\n  simp only [LieSubmodule.bot_coe, Set.mem_singleton_iff]\n  apply hΦ_nondeg\n  intro z\n  rw [hΦ_inv, neg_eq_zero]\n  have hyz : ⁅(x : L), z⁆ ∈ I := lie_mem_left _ _ _ _ _ x.2\n  exact contra hyz y y.2\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_isCompl_toSubmodule","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\nhI : IsAtom I\n⊢ IsCompl ↑I ↑(LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv I)","decl":"open Module Submodule in\nlemma orthogonal_isCompl_toSubmodule (I : LieIdeal K L) (hI : IsAtom I) :\n    IsCompl I.toSubmodule (orthogonal Φ hΦ_inv I).toSubmodule := by\n  rw [orthogonal_toSubmodule, LinearMap.BilinForm.isCompl_orthogonal_iff_disjoint hΦ_refl,\n      ← orthogonal_toSubmodule _ hΦ_inv, ← LieSubmodule.disjoint_iff_toSubmodule]\n  exact orthogonal_disjoint Φ hΦ_nondeg hΦ_inv hL I hI\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_isCompl_coe_submodule","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\nhI : IsAtom I\n⊢ IsCompl ↑I ↑(LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv I)","decl":"@[deprecated (since := \"2024-12-30\")]\nalias orthogonal_isCompl_coe_submodule := orthogonal_isCompl_toSubmodule\n\n"}
{"name":"LieAlgebra.InvariantForm.orthogonal_isCompl","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\nhI : IsAtom I\n⊢ IsCompl I (LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv I)","decl":"open Module Submodule in\nlemma orthogonal_isCompl (I : LieIdeal K L) (hI : IsAtom I) :\n    IsCompl I (orthogonal Φ hΦ_inv I) := by\n  rw [LieSubmodule.isCompl_iff_toSubmodule]\n  exact orthogonal_isCompl_toSubmodule Φ hΦ_nondeg hΦ_inv hΦ_refl hL I hI\n\n"}
{"name":"LieAlgebra.InvariantForm.restrict_nondegenerate","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\nhI : IsAtom I\n⊢ (Φ.restrict (LieIdeal.toLieSubalgebra K L I).toSubmodule).Nondegenerate","decl":"lemma restrict_nondegenerate (I : LieIdeal K L) (hI : IsAtom I) :\n    (Φ.restrict I).Nondegenerate := by\n  rw [LinearMap.BilinForm.restrict_nondegenerate_iff_isCompl_orthogonal hΦ_refl]\n  exact orthogonal_isCompl_toSubmodule Φ hΦ_nondeg hΦ_inv hΦ_refl hL I hI\n\n"}
{"name":"LieAlgebra.InvariantForm.restrict_orthogonal_nondegenerate","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\nhI : IsAtom I\n⊢ (Φ.restrict (LieIdeal.toLieSubalgebra K L (LieAlgebra.InvariantForm.orthogonal Φ hΦ_inv I)).toSubmodule).Nondegenerate","decl":"lemma restrict_orthogonal_nondegenerate (I : LieIdeal K L) (hI : IsAtom I) :\n    (Φ.restrict (orthogonal Φ hΦ_inv I)).Nondegenerate := by\n  rw [LinearMap.BilinForm.restrict_nondegenerate_iff_isCompl_orthogonal hΦ_refl]\n  simp only [LieIdeal.toLieSubalgebra_toSubmodule, orthogonal_toSubmodule,\n    LinearMap.BilinForm.orthogonal_orthogonal hΦ_nondeg hΦ_refl]\n  exact (orthogonal_isCompl_toSubmodule Φ hΦ_nondeg hΦ_inv hΦ_refl hL I hI).symm\n\n"}
{"name":"LieAlgebra.InvariantForm.atomistic","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\nI : LieIdeal K L\n⊢ Eq (SupSet.sSup (setOf fun J => And (IsAtom J) (LE.le J I))) I","decl":"open Module Submodule in\nlemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I := by\n  intro I\n  apply le_antisymm\n  · apply sSup_le\n    rintro J ⟨-, hJ'⟩\n    exact hJ'\n  by_cases hI : I = ⊥\n  · exact hI.le.trans bot_le\n  obtain ⟨J, hJ, hJI⟩ := (eq_bot_or_exists_atom_le I).resolve_left hI\n  let J' := orthogonal Φ hΦ_inv J\n  suffices I ≤ J ⊔ (J' ⊓ I) by\n    refine this.trans ?_\n    apply sup_le\n    · exact le_sSup ⟨hJ, hJI⟩\n    rw [← atomistic (J' ⊓ I)]\n    apply sSup_le_sSup\n    simp only [le_inf_iff, Set.setOf_subset_setOf, and_imp]\n    tauto\n  suffices J ⊔ J' = ⊤ by rw [← sup_inf_assoc_of_le _ hJI, this, top_inf_eq]\n  exact (orthogonal_isCompl Φ hΦ_nondeg hΦ_inv hΦ_refl hL J hJ).codisjoint.eq_top\ntermination_by I => finrank K I\ndecreasing_by\n  apply finrank_lt_finrank_of_lt\n  suffices ¬I ≤ J' by simpa\n  intro hIJ'\n  apply hJ.1\n  rw [eq_bot_iff]\n  exact orthogonal_disjoint Φ hΦ_nondeg hΦ_inv hL J hJ le_rfl (hJI.trans hIJ')\n\n"}
{"name":"LieAlgebra.InvariantForm.isSemisimple_of_nondegenerate","module":"Mathlib.Algebra.Lie.InvariantForm","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nΦ : LinearMap.BilinForm K L\nhΦ_nondeg : Φ.Nondegenerate\nhΦ_inv : LinearMap.BilinForm.lieInvariant L Φ\nhΦ_refl : Φ.IsRefl\nhL : ∀ (I : LieIdeal K L), IsAtom I → Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\n⊢ LieAlgebra.IsSemisimple K L","decl":"open LieSubmodule in\n/--\nA finite-dimensional Lie algebra over a field is semisimple\nif it does not have non-trivial abelian ideals and it admits a\nnon-degenerate reflexive invariant bilinear form.\nHere a form is *invariant* if it is compatible with the Lie bracket: `Φ ⁅x, y⁆ z = Φ x ⁅y, z⁆`.\n-/\ntheorem isSemisimple_of_nondegenerate : IsSemisimple K L := by\n  refine ⟨?_, ?_, hL⟩\n  · simpa using atomistic Φ hΦ_nondeg hΦ_inv hΦ_refl hL ⊤\n  intro I hI\n  apply (orthogonal_disjoint Φ hΦ_nondeg hΦ_inv hL I hI).mono_right\n  apply sSup_le\n  simp only [Set.mem_diff, Set.mem_setOf_eq, Set.mem_singleton_iff, and_imp]\n  intro J hJ hJI\n  rw [← lie_eq_self_of_isAtom_of_nonabelian J hJ (hL J hJ), lieIdeal_oper_eq_span, lieSpan_le]\n  rintro _ ⟨x, y, rfl⟩\n  simp only [orthogonal_carrier, Φ.isOrtho_def, Set.mem_setOf_eq]\n  intro z hz\n  rw [← neg_eq_zero, ← hΦ_inv]\n  suffices ⁅(x : L), z⁆ = 0 by simp only [this, map_zero, LinearMap.zero_apply]\n  rw [← LieSubmodule.mem_bot (R := K) (L := L), ← (hJ.disjoint_of_ne hI hJI).eq_bot]\n  apply lie_le_inf\n  exact lie_mem_lie x.2 hz\n\n"}
