{"name":"CategoryTheory.Equalizer.FirstObj.ext_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\nz₁ z₂ : CategoryTheory.Equalizer.FirstObj P R\n⊢ Iff (Eq z₁ z₂) (∀ (Y : C) (f : Quiver.Hom Y X) (hf : R f), Eq (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.fst }) ⟨Y, ⟨f, hf⟩⟩ z₁) (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.fst }) ⟨Y, ⟨f, hf⟩⟩ z₂))","decl":"@[ext]\nlemma FirstObj.ext (z₁ z₂ : FirstObj P R) (h : ∀ (Y : C) (f : Y ⟶ X)\n    (hf : R f), (Pi.π _ ⟨Y, f, hf⟩ : FirstObj P R ⟶ _) z₁ =\n      (Pi.π _ ⟨Y, f, hf⟩ : FirstObj P R ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨⟨Y, f, hf⟩⟩\n  exact h Y f hf\n\n"}
{"name":"CategoryTheory.Equalizer.FirstObj.ext","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\nz₁ z₂ : CategoryTheory.Equalizer.FirstObj P R\nh : ∀ (Y : C) (f : Quiver.Hom Y X) (hf : R f), Eq (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.fst }) ⟨Y, ⟨f, hf⟩⟩ z₁) (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.fst }) ⟨Y, ⟨f, hf⟩⟩ z₂)\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma FirstObj.ext (z₁ z₂ : FirstObj P R) (h : ∀ (Y : C) (f : Y ⟶ X)\n    (hf : R f), (Pi.π _ ⟨Y, f, hf⟩ : FirstObj P R ⟶ _) z₁ =\n      (Pi.π _ ⟨Y, f, hf⟩ : FirstObj P R ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨⟨Y, f, hf⟩⟩\n  exact h Y f hf\n\n"}
{"name":"CategoryTheory.Equalizer.firstObjEqFamily_hom","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Equalizer.FirstObj P R\nx✝¹ : C\nx✝ : Quiver.Hom x✝¹ X\nhf : R x✝\n⊢ Eq ((CategoryTheory.Equalizer.firstObjEqFamily P R).hom t x✝ hf) (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.fst }) ⟨x✝¹, ⟨x✝, hf⟩⟩ t)","decl":"/-- Show that `FirstObj` is isomorphic to `FamilyOfElements`. -/\n@[simps]\ndef firstObjEqFamily : FirstObj P R ≅ R.FamilyOfElements P where\n  hom t _ _ hf := Pi.π (fun f : ΣY, { f : Y ⟶ X // R f } => P.obj (op f.1)) ⟨_, _, hf⟩ t\n  inv := Pi.lift fun f x => x _ f.2.2\n\n"}
{"name":"CategoryTheory.Equalizer.firstObjEqFamily_inv","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\na✝ : CategoryTheory.Presieve.FamilyOfElements P R\n⊢ Eq ((CategoryTheory.Equalizer.firstObjEqFamily P R).inv a✝) (CategoryTheory.Limits.Pi.lift (fun f x => x ↑f.snd ⋯) a✝)","decl":"/-- Show that `FirstObj` is isomorphic to `FamilyOfElements`. -/\n@[simps]\ndef firstObjEqFamily : FirstObj P R ≅ R.FamilyOfElements P where\n  hom t _ _ hf := Pi.π (fun f : ΣY, { f : Y ⟶ X // R f } => P.obj (op f.1)) ⟨_, _, hf⟩ t\n  inv := Pi.lift fun f x => x _ f.2.2\n\n"}
{"name":"CategoryTheory.Equalizer.Sieve.SecondObj.ext_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nS : CategoryTheory.Sieve X\nz₁ z₂ : CategoryTheory.Equalizer.Sieve.SecondObj P S\n⊢ Iff (Eq z₁ z₂) (∀ (Y Z : C) (g : Quiver.Hom Z Y) (f : Quiver.Hom Y X) (hf : S.arrows f), Eq (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.snd.fst }) ⟨Y, ⟨Z, ⟨g, ⟨f, hf⟩⟩⟩⟩ z₁) (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.snd.fst }) ⟨Y, ⟨Z, ⟨g, ⟨f, hf⟩⟩⟩⟩ z₂))","decl":"@[ext]\nlemma SecondObj.ext (z₁ z₂ : SecondObj P S) (h : ∀ (Y Z : C) (g : Z ⟶ Y) (f : Y ⟶ X)\n    (hf : S.arrows f), (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₁ =\n      (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨⟨Y, Z, g, f, hf⟩⟩\n  apply h\n\n"}
{"name":"CategoryTheory.Equalizer.Sieve.SecondObj.ext","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nS : CategoryTheory.Sieve X\nz₁ z₂ : CategoryTheory.Equalizer.Sieve.SecondObj P S\nh : ∀ (Y Z : C) (g : Quiver.Hom Z Y) (f : Quiver.Hom Y X) (hf : S.arrows f), Eq (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.snd.fst }) ⟨Y, ⟨Z, ⟨g, ⟨f, hf⟩⟩⟩⟩ z₁) (CategoryTheory.Limits.Pi.π (fun f => P.obj { unop := f.snd.fst }) ⟨Y, ⟨Z, ⟨g, ⟨f, hf⟩⟩⟩⟩ z₂)\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma SecondObj.ext (z₁ z₂ : SecondObj P S) (h : ∀ (Y Z : C) (g : Z ⟶ Y) (f : Y ⟶ X)\n    (hf : S.arrows f), (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₁ =\n      (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨⟨Y, Z, g, f, hf⟩⟩\n  apply h\n\n"}
{"name":"CategoryTheory.Equalizer.Sieve.w","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows) (CategoryTheory.Equalizer.Sieve.firstMap P S)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows) (CategoryTheory.Equalizer.Sieve.secondMap P S))","decl":"theorem w : forkMap P (S : Presieve X) ≫ firstMap P S = forkMap P S ≫ secondMap P S := by\n  ext\n  simp [firstMap, secondMap, forkMap]\n\n"}
{"name":"CategoryTheory.Equalizer.Sieve.compatible_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Equalizer.FirstObj P S.arrows\n⊢ Iff ((CategoryTheory.Equalizer.firstObjEqFamily P S.arrows).hom x).Compatible (Eq (CategoryTheory.Equalizer.Sieve.firstMap P S x) (CategoryTheory.Equalizer.Sieve.secondMap P S x))","decl":"/--\nThe family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n-/\ntheorem compatible_iff (x : FirstObj P S.arrows) :\n    ((firstObjEqFamily P S.arrows).hom x).Compatible ↔ firstMap P S x = secondMap P S x := by\n  rw [Presieve.compatible_iff_sieveCompatible]\n  constructor\n  · intro t\n    apply SecondObj.ext\n    intros Y Z g f hf\n    simpa [firstMap, secondMap] using t _ g hf\n  · intro t Y Z f g hf\n    rw [Types.limit_ext_iff'] at t\n    simpa [firstMap, secondMap] using t ⟨⟨Y, Z, g, f, hf⟩⟩\n\n"}
{"name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P S.arrows) (Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.forkMap P S.arrows) ⋯)))","decl":"/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/\ntheorem equalizer_sheaf_condition :\n    Presieve.IsSheafFor P (S : Presieve X) ↔ Nonempty (IsLimit (Fork.ofι _ (w P S))) := by\n  rw [Types.type_equalizer_iff_unique,\n    ← Equiv.forall_congr_right (firstObjEqFamily P (S : Presieve X)).toEquiv.symm]\n  simp_rw [← compatible_iff]\n  simp only [inv_hom_id_apply, Iso.toEquiv_symm_fun]\n  apply forall₂_congr\n  intro x _\n  apply existsUnique_congr\n  intro t\n  rw [← Iso.toEquiv_symm_fun]\n  rw [Equiv.eq_symm_apply]\n  constructor\n  · intro q\n    funext Y f hf\n    simpa [firstObjEqFamily, forkMap] using q _ _\n  · intro q Y f hf\n    rw [← q]\n    simp [firstObjEqFamily, forkMap]\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.w","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\ninst✝ : R.hasPullbacks\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P R) (CategoryTheory.Equalizer.Presieve.firstMap P R)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P R) (CategoryTheory.Equalizer.Presieve.secondMap P R))","decl":"theorem w : forkMap P R ≫ firstMap P R = forkMap P R ≫ secondMap P R := by\n  dsimp\n  ext fg\n  simp only [firstMap, secondMap, forkMap]\n  simp only [limit.lift_π, limit.lift_π_assoc, assoc, Fan.mk_π_app]\n  haveI := Presieve.hasPullbacks.has_pullbacks fg.1.2.2 fg.2.2.2\n  rw [← P.map_comp, ← op_comp, pullback.condition]\n  simp\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.compatible_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\ninst✝ : R.hasPullbacks\nx : CategoryTheory.Equalizer.FirstObj P R\n⊢ Iff ((CategoryTheory.Equalizer.firstObjEqFamily P R).hom x).Compatible (Eq (CategoryTheory.Equalizer.Presieve.firstMap P R x) (CategoryTheory.Equalizer.Presieve.secondMap P R x))","decl":"/--\nThe family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n-/\ntheorem compatible_iff (x : FirstObj P R) :\n    ((firstObjEqFamily P R).hom x).Compatible ↔ firstMap P R x = secondMap P R x := by\n  rw [Presieve.pullbackCompatible_iff]\n  constructor\n  · intro t\n    apply Limits.Types.limit_ext\n    rintro ⟨⟨Y, f, hf⟩, Z, g, hg⟩\n    simpa [firstMap, secondMap] using t hf hg\n  · intro t Y Z f g hf hg\n    rw [Types.limit_ext_iff'] at t\n    simpa [firstMap, secondMap] using t ⟨⟨⟨Y, f, hf⟩, Z, g, hg⟩⟩\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.sheaf_condition","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type (max v u))\nX : C\nR : CategoryTheory.Presieve X\ninst✝ : R.hasPullbacks\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P R) (Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.forkMap P R) ⋯)))","decl":"/-- `P` is a sheaf for `R`, iff the fork given by `w` is an equalizer. -/\n@[stacks 00VM]\ntheorem sheaf_condition : R.IsSheafFor P ↔ Nonempty (IsLimit (Fork.ofι _ (w P R))) := by\n  rw [Types.type_equalizer_iff_unique,\n    ← Equiv.forall_congr_right (firstObjEqFamily P R).toEquiv.symm]\n  simp_rw [← compatible_iff, ← Iso.toEquiv_fun, Equiv.apply_symm_apply]\n  apply forall₂_congr\n  intro x _\n  apply existsUnique_congr\n  intro t\n  rw [Equiv.eq_symm_apply]\n  constructor\n  · intro q\n    funext Y f hf\n    simpa [forkMap] using q _ _\n  · intro q Y f hf\n    rw [← q]\n    simp [forkMap]\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type\nX : I → C\nz₁ z₂ : CategoryTheory.Equalizer.Presieve.Arrows.FirstObj P X\nh : ∀ (i : I), Eq (CategoryTheory.Limits.Pi.π (fun i => P.obj { unop := X i }) i z₁) (CategoryTheory.Limits.Pi.π (fun i => P.obj { unop := X i }) i z₂)\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma FirstObj.ext (z₁ z₂ : FirstObj P X) (h : ∀ i, (Pi.π _ i : FirstObj P X ⟶ _) z₁ =\n    (Pi.π _ i : FirstObj P X ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨i⟩\n  exact h i\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type\nX : I → C\nz₁ z₂ : CategoryTheory.Equalizer.Presieve.Arrows.FirstObj P X\n⊢ Iff (Eq z₁ z₂) (∀ (i : I), Eq (CategoryTheory.Limits.Pi.π (fun i => P.obj { unop := X i }) i z₁) (CategoryTheory.Limits.Pi.π (fun i => P.obj { unop := X i }) i z₂))","decl":"@[ext]\nlemma FirstObj.ext (z₁ z₂ : FirstObj P X) (h : ∀ i, (Pi.π _ i : FirstObj P X ⟶ _) z₁ =\n    (Pi.π _ i : FirstObj P X ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨i⟩\n  exact h i\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\nz₁ z₂ : CategoryTheory.Equalizer.Presieve.Arrows.SecondObj P X π\nh : ∀ (ij : Prod I I), Eq (CategoryTheory.Limits.Pi.π (fun ij => P.obj { unop := CategoryTheory.Limits.pullback (π ij.1) (π ij.2) }) ij z₁) (CategoryTheory.Limits.Pi.π (fun ij => P.obj { unop := CategoryTheory.Limits.pullback (π ij.1) (π ij.2) }) ij z₂)\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma SecondObj.ext (z₁ z₂ : SecondObj P X π) (h : ∀ ij, (Pi.π _ ij : SecondObj P X π ⟶ _) z₁ =\n    (Pi.π _ ij : SecondObj P X π ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨i⟩\n  exact h i\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\nz₁ z₂ : CategoryTheory.Equalizer.Presieve.Arrows.SecondObj P X π\n⊢ Iff (Eq z₁ z₂) (∀ (ij : Prod I I), Eq (CategoryTheory.Limits.Pi.π (fun ij => P.obj { unop := CategoryTheory.Limits.pullback (π ij.1) (π ij.2) }) ij z₁) (CategoryTheory.Limits.Pi.π (fun ij => P.obj { unop := CategoryTheory.Limits.pullback (π ij.1) (π ij.2) }) ij z₂))","decl":"@[ext]\nlemma SecondObj.ext (z₁ z₂ : SecondObj P X π) (h : ∀ ij, (Pi.π _ ij : SecondObj P X π ⟶ _) z₁ =\n    (Pi.π _ ij : SecondObj P X π ⟶ _) z₂) : z₁ = z₂ := by\n  apply Limits.Types.limit_ext\n  rintro ⟨i⟩\n  exact h i\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.w","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.Presieve.Arrows.forkMap P X π) (CategoryTheory.Equalizer.Presieve.Arrows.firstMap P X π)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.Presieve.Arrows.forkMap P X π) (CategoryTheory.Equalizer.Presieve.Arrows.secondMap P X π))","decl":"theorem w : forkMap P X π ≫ firstMap P X π = forkMap P X π ≫ secondMap P X π := by\n  ext x ij\n  simp only [firstMap, secondMap, forkMap, types_comp_apply, Types.pi_lift_π_apply,\n    ← FunctorToTypes.map_comp_apply, ← op_comp, pullback.condition]\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\nx : CategoryTheory.Equalizer.Presieve.Arrows.FirstObj P X\n⊢ Iff (CategoryTheory.Presieve.Arrows.Compatible P π ((CategoryTheory.Limits.Types.productIso fun i => P.obj { unop := X i }).hom x)) (Eq (CategoryTheory.Equalizer.Presieve.Arrows.firstMap P X π x) (CategoryTheory.Equalizer.Presieve.Arrows.secondMap P X π x))","decl":"/--\nThe family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n-/\ntheorem compatible_iff (x : FirstObj P X) : (Arrows.Compatible P π ((Types.productIso _).hom x)) ↔\n    firstMap P X π x = secondMap P X π x := by\n  rw [Arrows.pullbackCompatible_iff]\n  constructor\n  · intro t\n    ext ij\n    simpa [firstMap, secondMap] using t ij.1 ij.2\n  · intro t i j\n    apply_fun Pi.π (fun (ij : I × I) ↦ P.obj (op (pullback (π ij.1) (π ij.2)))) ⟨i, j⟩ at t\n    simpa [firstMap, secondMap] using t\n\n"}
{"name":"CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition","module":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.ofArrows X π)) (Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.Presieve.Arrows.forkMap P X π) ⋯)))","decl":"/-- `P` is a sheaf for `Presieve.ofArrows X π`, iff the fork given by `w` is an equalizer. -/\n@[stacks 00VM]\ntheorem sheaf_condition : (Presieve.ofArrows X π).IsSheafFor P ↔\n    Nonempty (IsLimit (Fork.ofι (forkMap P X π) (w P X π))) := by\n  rw [Types.type_equalizer_iff_unique, isSheafFor_arrows_iff]\n  erw [← Equiv.forall_congr_right (Types.productIso _).toEquiv.symm]\n  simp_rw [← compatible_iff, ← Iso.toEquiv_fun, Equiv.apply_symm_apply]\n  apply forall₂_congr\n  intro x _\n  apply existsUnique_congr\n  intro t\n  erw [Equiv.eq_symm_apply]\n  constructor\n  · intro q\n    funext i\n    simpa [forkMap] using q i\n  · intro q i\n    rw [← q]\n    simp [forkMap]\n\n"}
