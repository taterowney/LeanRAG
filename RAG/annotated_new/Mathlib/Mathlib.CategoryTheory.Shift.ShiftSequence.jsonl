{"name":"CategoryTheory.Functor.ShiftSequence.shiftIso_add","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : CategoryTheory.HasShift C M\nself : F.ShiftSequence M\nn m a a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (CategoryTheory.Functor.ShiftSequence.shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd C m n) (CategoryTheory.Functor.ShiftSequence.sequence F a)).trans (((CategoryTheory.shiftFunctor C m).associator (CategoryTheory.shiftFunctor C n) (CategoryTheory.Functor.ShiftSequence.sequence F a)).trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C m) (CategoryTheory.Functor.ShiftSequence.shiftIso n a a' ha')).trans (CategoryTheory.Functor.ShiftSequence.shiftIso m a' a'' ha''))))","decl":"/-- A shift sequence for a functor `F : C ⥤ A` when `C` is equipped with a shift\nby a monoid `M` involves a sequence of functor `sequence n : C ⥤ A` for all `n : M`\nwhich behave like `shiftFunctor C n ⋙ F`. -/\nclass ShiftSequence where\n  /-- a sequence of functors -/\n  sequence : M → C ⥤ A\n  /-- `sequence 0` identifies to the given functor -/\n  isoZero : sequence 0 ≅ F\n  /-- compatibility isomorphism with the shift -/\n  shiftIso (n a a' : M) (ha' : n + a = a') : shiftFunctor C n ⋙ sequence a ≅ sequence a'\n  shiftIso_zero (a : M) : shiftIso 0 a a (zero_add a) =\n    isoWhiskerRight (shiftFunctorZero C M) _ ≪≫ leftUnitor _\n  shiftIso_add : ∀ (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a''),\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerRight (shiftFunctorAdd C m n) _ ≪≫ Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (shiftIso n a a' ha') ≪≫ shiftIso m a' a'' ha''\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.shiftIso_zero","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : CategoryTheory.HasShift C M\nself : F.ShiftSequence M\na : M\n⊢ Eq (CategoryTheory.Functor.ShiftSequence.shiftIso 0 a a ⋯) ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorZero C M) (CategoryTheory.Functor.ShiftSequence.sequence F a)).trans (CategoryTheory.Functor.ShiftSequence.sequence F a).leftUnitor)","decl":"/-- A shift sequence for a functor `F : C ⥤ A` when `C` is equipped with a shift\nby a monoid `M` involves a sequence of functor `sequence n : C ⥤ A` for all `n : M`\nwhich behave like `shiftFunctor C n ⋙ F`. -/\nclass ShiftSequence where\n  /-- a sequence of functors -/\n  sequence : M → C ⥤ A\n  /-- `sequence 0` identifies to the given functor -/\n  isoZero : sequence 0 ≅ F\n  /-- compatibility isomorphism with the shift -/\n  shiftIso (n a a' : M) (ha' : n + a = a') : shiftFunctor C n ⋙ sequence a ≅ sequence a'\n  shiftIso_zero (a : M) : shiftIso 0 a a (zero_add a) =\n    isoWhiskerRight (shiftFunctorZero C M) _ ≪≫ leftUnitor _\n  shiftIso_add : ∀ (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a''),\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerRight (shiftFunctorAdd C m n) _ ≪≫ Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (shiftIso n a a' ha') ≪≫ shiftIso m a' a'' ha''\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y : C\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nf : Quiver.Hom X Y\nZ : A\nh : Quiver.Hom ((F.shift a').obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctor C n).map f)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app X) (CategoryTheory.CategoryStruct.comp ((F.shift a').map f) h))","decl":"@[reassoc (attr := simp)]\nlemma shiftIso_hom_naturality {X Y : C} (n a a' : M) (ha' : n + a = a') (f : X ⟶ Y) :\n    (shift F a).map (f⟦n⟧') ≫ (shiftIso F n a a' ha').hom.app Y =\n      (shiftIso F n a a' ha').hom.app X ≫ (shift F a').map f :=\n  (F.shiftIso n a a' ha').hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_naturality","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y : C\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctor C n).map f)) ((F.shiftIso n a a' ha').hom.app Y)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app X) ((F.shift a').map f))","decl":"@[reassoc (attr := simp)]\nlemma shiftIso_hom_naturality {X Y : C} (n a a' : M) (ha' : n + a = a') (f : X ⟶ Y) :\n    (shift F a).map (f⟦n⟧') ≫ (shiftIso F n a a' ha').hom.app Y =\n      (shiftIso F n a a' ha').hom.app X ≫ (shift F a').map f :=\n  (F.shiftIso n a a' ha').hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y : C\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nf : Quiver.Hom X Y\nZ : A\nh : Quiver.Hom ((F.shift a).obj ((CategoryTheory.shiftFunctor C n).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift a').map f) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctor C n).map f)) h))","decl":"@[reassoc]\nlemma shiftIso_inv_naturality {X Y : C} (n a a' : M) (ha' : n + a = a') (f : X ⟶ Y) :\n    (shift F a').map f ≫ (shiftIso F n a a' ha').inv.app Y =\n      (shiftIso F n a a' ha').inv.app X ≫ (shift F a).map (f⟦n⟧') := by\n  simp\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_inv_naturality","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y : C\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift a').map f) ((F.shiftIso n a a' ha').inv.app Y)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) ((F.shift a).map ((CategoryTheory.shiftFunctor C n).map f)))","decl":"@[reassoc]\nlemma shiftIso_inv_naturality {X Y : C} (n a a' : M) (ha' : n + a = a') (f : X ⟶ Y) :\n    (shift F a').map f ≫ (shiftIso F n a a' ha').inv.app Y =\n      (shiftIso F n a a' ha').inv.app X ≫ (shift F a).map (f⟦n⟧') := by\n  simp\n\n"}
{"name":"CategoryTheory.Functor.isoShift_hom_naturality","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn : M\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C n).map f)) ((F.isoShift n).hom.app Y)) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).hom.app X) ((F.shift n).map f))","decl":"@[reassoc]\nlemma isoShift_hom_naturality (n : M) {X Y : C} (f : X ⟶ Y) :\n    F.map (f⟦n⟧') ≫ (F.isoShift n).hom.app Y =\n      (F.isoShift n).hom.app X ≫ (F.shift n).map f :=\n  (F.isoShift n).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.isoShift_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn : M\nX Y : C\nf : Quiver.Hom X Y\nZ : A\nh : Quiver.Hom ((F.shift n).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C n).map f)) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.shift n).map f) h))","decl":"@[reassoc]\nlemma isoShift_hom_naturality (n : M) {X Y : C} (f : X ⟶ Y) :\n    F.map (f⟦n⟧') ≫ (F.isoShift n).hom.app Y =\n      (F.isoShift n).hom.app X ≫ (F.shift n).map f :=\n  (F.isoShift n).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.isoShift_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn : M\nX Y : C\nf : Quiver.Hom X Y\nZ : A\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C n).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n).map f) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).inv.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C n).map f)) h))","decl":"@[reassoc]\nlemma isoShift_inv_naturality (n : M) {X Y : C} (f : X ⟶ Y) :\n    (F.shift n).map f ≫ (F.isoShift n).inv.app Y =\n      (F.isoShift n).inv.app X ≫ F.map (f⟦n⟧') :=\n  (F.isoShift n).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.isoShift_inv_naturality","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn : M\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n).map f) ((F.isoShift n).inv.app Y)) (CategoryTheory.CategoryStruct.comp ((F.isoShift n).inv.app X) (F.map ((CategoryTheory.shiftFunctor C n).map f)))","decl":"@[reassoc]\nlemma isoShift_inv_naturality (n : M) {X Y : C} (f : X ⟶ Y) :\n    (F.shift n).map f ≫ (F.isoShift n).inv.app Y =\n      (F.isoShift n).inv.app X ≫ F.map (f⟦n⟧') :=\n  (F.isoShift n).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_zero","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\na : M\n⊢ Eq (F.shiftIso 0 a a ⋯) ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorZero C M) (F.shift a)).trans (F.shift a).leftUnitor)","decl":"lemma shiftIso_zero (a : M) :\n    F.shiftIso 0 a a (zero_add a) =\n      isoWhiskerRight (shiftFunctorZero C M) _ ≪≫ leftUnitor _ :=\n  ShiftSequence.shiftIso_zero a\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\na : M\nX : C\n⊢ Eq ((F.shiftIso 0 a a ⋯).hom.app X) ((F.shift a).map ((CategoryTheory.shiftFunctorZero C M).hom.app X))","decl":"@[simp]\nlemma shiftIso_zero_hom_app (a : M) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).hom.app X =\n      (shift F a).map ((shiftFunctorZero C M).hom.app X) := by\n  simp [F.shiftIso_zero a]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\na : M\nX : C\n⊢ Eq ((F.shiftIso 0 a a ⋯).inv.app X) ((F.shift a).map ((CategoryTheory.shiftFunctorZero C M).inv.app X))","decl":"@[simp]\nlemma shiftIso_zero_inv_app (a : M) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).inv.app X =\n      (shift F a).map ((shiftFunctorZero C M).inv.app X) := by\n  simp [F.shiftIso_zero a]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m a a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (F.shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd C m n) (F.shift a)).trans (((CategoryTheory.shiftFunctor C m).associator (CategoryTheory.shiftFunctor C n) (F.shift a)).trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C m) (F.shiftIso n a a' ha')).trans (F.shiftIso m a' a'' ha''))))","decl":"lemma shiftIso_add (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerRight (shiftFunctorAdd C m n) _ ≪≫ Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (F.shiftIso n a a' ha') ≪≫ F.shiftIso m a' a'' ha'' :=\n  ShiftSequence.shiftIso_add _ _ _ _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add_hom_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m a a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctorAdd C m n).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app ((CategoryTheory.shiftFunctor C m).obj X)) ((F.shiftIso m a' a'' ha'').hom.app X)))","decl":"lemma shiftIso_add_hom_app (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).hom.app X =\n      (shift F a).map ((shiftFunctorAdd C m n).hom.app X) ≫\n        (shiftIso F n a a' ha').hom.app ((shiftFunctor C m).obj X) ≫\n          (shiftIso F m a' a'' ha'').hom.app X := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add_inv_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m a a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' ⋯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso m a' a'' ha'').inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app ((CategoryTheory.shiftFunctor C m).obj X)) ((F.shift a).map ((CategoryTheory.shiftFunctorAdd C m n).inv.app X))))","decl":"lemma shiftIso_add_inv_app (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).inv.app X =\n      (shiftIso F m a' a'' ha'').inv.app X ≫\n        (shiftIso F n a a' ha').inv.app ((shiftFunctor C m).obj X) ≫\n          (shift F a).map ((shiftFunctorAdd C m n).inv.app X) := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add'","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (F.shiftIso mn a a'' ⋯) ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd' C m n mn hnm) (F.shift a)).trans (((CategoryTheory.shiftFunctor C m).associator (CategoryTheory.shiftFunctor C n) (F.shift a)).trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C m) (F.shiftIso n a a' ha')).trans (F.shiftIso m a' a'' ha''))))","decl":"lemma shiftIso_add' (n m mn : M) (hnm : m + n = mn) (a a' a'' : M)\n    (ha' : n + a = a') (ha'' : m + a' = a'') :\n    F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc]) =\n      isoWhiskerRight (shiftFunctorAdd' C m n _ hnm) _ ≪≫ Functor.associator _ _ _ ≪≫\n        isoWhiskerLeft _ (F.shiftIso n a a' ha') ≪≫ F.shiftIso m a' a'' ha'' := by\n  subst hnm\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftIso_add]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add'_hom_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso mn a a'' ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctorAdd' C m n mn hnm).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app ((CategoryTheory.shiftFunctor C m).obj X)) ((F.shiftIso m a' a'' ha'').hom.app X)))","decl":"lemma shiftIso_add'_hom_app (n m mn : M) (hnm : m + n = mn) (a a' a'' : M)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).hom.app X =\n      (shift F a).map ((shiftFunctorAdd' C m n mn hnm).hom.app X) ≫\n        (shiftIso F n a a' ha').hom.app ((shiftFunctor C m).obj X) ≫\n          (shiftIso F m a' a'' ha'').hom.app X := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_add'_inv_app","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso mn a a'' ⋯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso m a' a'' ha'').inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app ((CategoryTheory.shiftFunctor C m).obj X)) ((F.shift a).map ((CategoryTheory.shiftFunctorAdd' C m n mn hnm).inv.app X))))","decl":"lemma shiftIso_add'_inv_app (n m mn : M) (hnm : m + n = mn) (a a' a'' : M)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).inv.app X =\n      (shiftIso F m a' a'' ha'').inv.app X ≫\n        (shiftIso F n a a' ha').inv.app ((shiftFunctor C m).obj X) ≫\n        (shift F a).map ((shiftFunctorAdd' C m n mn hnm).inv.app X) := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_app_comp","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app ((CategoryTheory.shiftFunctor C m).obj X)) ((F.shiftIso m a' a'' ha'').hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctorAdd' C m n mn hnm).inv.app X)) ((F.shiftIso mn a a'' ⋯).hom.app X))","decl":"@[reassoc]\nlemma shiftIso_hom_app_comp (n m mn : M) (hnm : m + n = mn)\n    (a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (shiftIso F n a a' ha').hom.app ((shiftFunctor C m).obj X) ≫\n      (shiftIso F m a' a'' ha'').hom.app X =\n        (shift F a).map ((shiftFunctorAdd' C m n mn hnm).inv.app X) ≫\n          (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).hom.app X := by\n  rw [F.shiftIso_add'_hom_app n m mn hnm a a' a'' ha' ha'', ← Functor.map_comp_assoc,\n    Iso.inv_hom_id_app, Functor.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_app_comp_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nn m mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\nZ : A\nh : Quiver.Hom ((F.shift a'').obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app ((CategoryTheory.shiftFunctor C m).obj X)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso m a' a'' ha'').hom.app X) h)) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctorAdd' C m n mn hnm).inv.app X)) (CategoryTheory.CategoryStruct.comp ((F.shiftIso mn a a'' ⋯).hom.app X) h))","decl":"@[reassoc]\nlemma shiftIso_hom_app_comp (n m mn : M) (hnm : m + n = mn)\n    (a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (shiftIso F n a a' ha').hom.app ((shiftFunctor C m).obj X) ≫\n      (shiftIso F m a' a'' ha'').hom.app X =\n        (shift F a).map ((shiftFunctorAdd' C m n mn hnm).inv.app X) ≫\n          (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).hom.app X := by\n  rw [F.shiftIso_add'_hom_app n m mn hnm a a' a'' ha' ha'', ← Functor.map_comp_assoc,\n    Iso.inv_hom_id_app, Functor.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.shiftMap_comp","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y Z : C\nn : M\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C n).obj Y)\ng : Quiver.Hom Y Z\na a' : M\nha' : Eq (HAdd.hAdd n a) a'\n⊢ Eq (F.shiftMap (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctor C n).map g)) a a' ha') (CategoryTheory.CategoryStruct.comp (F.shiftMap f a a' ha') ((F.shift a').map g))","decl":"@[reassoc]\nlemma shiftMap_comp {X Y Z : C} {n : M} (f : X ⟶ Y⟦n⟧) (g : Y ⟶ Z) (a a' : M) (ha' : n + a = a') :\n    F.shiftMap (f ≫ g⟦n⟧') a a' ha' = F.shiftMap f a a' ha' ≫ (F.shift a').map g := by\n  simp [shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.shiftMap_comp_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y Z✝ : C\nn : M\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C n).obj Y)\ng : Quiver.Hom Y Z✝\na a' : M\nha' : Eq (HAdd.hAdd n a) a'\nZ : A\nh : Quiver.Hom ((F.shift a').obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftMap (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctor C n).map g)) a a' ha') h) (CategoryTheory.CategoryStruct.comp (F.shiftMap f a a' ha') (CategoryTheory.CategoryStruct.comp ((F.shift a').map g) h))","decl":"@[reassoc]\nlemma shiftMap_comp {X Y Z : C} {n : M} (f : X ⟶ Y⟦n⟧) (g : Y ⟶ Z) (a a' : M) (ha' : n + a = a') :\n    F.shiftMap (f ≫ g⟦n⟧') a a' ha' = F.shiftMap f a a' ha' ≫ (F.shift a').map g := by\n  simp [shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.shiftMap_comp'_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y Z✝ : C\nn : M\nf : Quiver.Hom X Y\ng : Quiver.Hom Y ((CategoryTheory.shiftFunctor C n).obj Z✝)\na a' : M\nha' : Eq (HAdd.hAdd n a) a'\nZ : A\nh : Quiver.Hom ((F.shift a').obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftMap (CategoryTheory.CategoryStruct.comp f g) a a' ha') h) (CategoryTheory.CategoryStruct.comp ((F.shift a).map f) (CategoryTheory.CategoryStruct.comp (F.shiftMap g a a' ha') h))","decl":"@[reassoc]\nlemma shiftMap_comp' {X Y Z : C} {n : M} (f : X ⟶ Y) (g : Y ⟶ Z⟦n⟧) (a a' : M) (ha' : n + a = a') :\n    F.shiftMap (f ≫ g) a a' ha' = (F.shift a).map f ≫ F.shiftMap g a a' ha' := by\n  simp [shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.shiftMap_comp'","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y Z : C\nn : M\nf : Quiver.Hom X Y\ng : Quiver.Hom Y ((CategoryTheory.shiftFunctor C n).obj Z)\na a' : M\nha' : Eq (HAdd.hAdd n a) a'\n⊢ Eq (F.shiftMap (CategoryTheory.CategoryStruct.comp f g) a a' ha') (CategoryTheory.CategoryStruct.comp ((F.shift a).map f) (F.shiftMap g a a' ha'))","decl":"@[reassoc]\nlemma shiftMap_comp' {X Y Z : C} {n : M} (f : X ⟶ Y) (g : Y ⟶ Z⟦n⟧) (a a' : M) (ha' : n + a = a') :\n    F.shiftMap (f ≫ g) a a' ha' = (F.shift a).map f ≫ F.shiftMap g a a' ha' := by\n  simp [shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_app_comp_shiftMap","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : CategoryTheory.HasShift C M\ninst✝ : F.ShiftSequence M\nX Y : C\nm : M\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C m).obj Y)\nn mn : M\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : M\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app X) (F.shiftMap f a' a'' ha'')) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctor C n).map f)) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((CategoryTheory.shiftFunctorAdd' C m n mn hnm).inv.app Y)) ((F.shiftIso mn a a'' ⋯).hom.app Y)))","decl":"/--\nWhen `f : X ⟶ Y⟦m⟧`, `m + n = mn`, `n + a = a'` and `ha'' : m + a' = a''`, this lemma\nrelates the two morphisms `F.shiftMap f a' a'' ha''` and `(F.shift a).map (f⟦n⟧')`. Indeed,\nvia canonical isomorphisms, they both identity to morphisms\n`(F.shift a').obj X ⟶ (F.shift a'').obj Y`.\n-/\nlemma shiftIso_hom_app_comp_shiftMap {X Y : C} {m : M} (f : X ⟶ Y⟦m⟧) (n mn : M) (hnm : m + n = mn)\n    (a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    (F.shiftIso n a a' ha').hom.app X ≫ F.shiftMap f a' a'' ha'' =\n      (F.shift a).map (f⟦n⟧') ≫ (F.shift a).map ((shiftFunctorAdd' C m n mn hnm).inv.app Y) ≫\n        (F.shiftIso mn a a'' (by rw [← ha'', ← ha', ← hnm, add_assoc])).hom.app Y := by\n  simp only [F.shiftIso_add'_hom_app n m mn hnm a a' a'' ha' ha'' Y,\n    ← Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.map_id,\n    id_comp, comp_obj, shiftIso_hom_naturality_assoc, shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.shiftIso_hom_app_comp_shiftMap_of_add_eq_zero","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nG : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : CategoryTheory.HasShift C G\ninst✝ : F.ShiftSequence G\nX Y : C\nm : G\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C m).obj Y)\nn : G\nhnm : Eq (HAdd.hAdd n m) 0\na a' : G\nha' : Eq (HAdd.hAdd m a) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a' a ⋯).hom.app X) (F.shiftMap f a a' ha')) ((F.shift a').map (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map f) ((CategoryTheory.shiftFunctorCompIsoId C m n ⋯).hom.app Y)))","decl":"/--\nIf `f : X ⟶ Y⟦m⟧`, `n + m = 0` and `ha' : m + a = a'`, this lemma relates the two\nmorphisms `F.shiftMap f a a' ha'` and `(F.shift a').map (f⟦n⟧')`. Indeed,\nvia canonical isomorphisms, they both identify to morphisms\n`(F.shift a).obj X ⟶ (F.shift a').obj Y`.\n-/\nlemma shiftIso_hom_app_comp_shiftMap_of_add_eq_zero [F.ShiftSequence G]\n    {X Y : C} {m : G} (f : X ⟶ Y⟦m⟧)\n    (n : G) (hnm : n + m = 0) (a a' : G) (ha' : m + a = a') :\n    (F.shiftIso n a' a (by rw [← ha', ← add_assoc, hnm, zero_add])).hom.app X ≫\n      F.shiftMap f a a' ha' =\n    (F.shift a').map (f⟦n⟧' ≫ (shiftFunctorCompIsoId C m n\n      (by rw [← add_left_inj m, add_assoc, hnm, zero_add, add_zero])).hom.app Y) := by\n  have hnm' : m + n = 0 := by\n    rw [← add_left_inj m, add_assoc, hnm, zero_add, add_zero]\n  dsimp\n  simp [F.shiftIso_hom_app_comp_shiftMap f n 0 hnm' a' a, shiftIso_zero_hom_app,\n    shiftFunctorCompIsoId]\n\n"}
{"name":"CategoryTheory.Functor.instPreservesZeroMorphismsShift","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : F.ShiftSequence M\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms A\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ (n : M), (CategoryTheory.shiftFunctor C n).PreservesZeroMorphisms\nn : M\n⊢ (F.shift n).PreservesZeroMorphisms","decl":"instance (n : M) : (F.shift n).PreservesZeroMorphisms :=\n  preservesZeroMorphisms_of_iso (F.isoShift n)\n\n"}
{"name":"CategoryTheory.Functor.shiftMap_zero","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : F.ShiftSequence M\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms A\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ (n : M), (CategoryTheory.shiftFunctor C n).PreservesZeroMorphisms\nX Y : C\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\n⊢ Eq (F.shiftMap 0 a a' ha') 0","decl":"@[simp]\nlemma shiftMap_zero (X Y : C) (n a a' : M) (ha' : n + a = a') :\n    F.shiftMap (0 : X ⟶ Y⟦n⟧) a a' ha' = 0 := by\n  simp [shiftMap]\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveShift","module":"Mathlib.CategoryTheory.Shift.ShiftSequence","initialProofState":"C : Type u_1\nA : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_6, u_2} A\nF : CategoryTheory.Functor C A\nM : Type u_3\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : F.ShiftSequence M\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Preadditive A\ninst✝¹ : F.Additive\ninst✝ : ∀ (n : M), (CategoryTheory.shiftFunctor C n).Additive\nn : M\n⊢ (F.shift n).Additive","decl":"instance (n : M) : (F.shift n).Additive := additive_of_iso (F.isoShift n)\n\n"}
