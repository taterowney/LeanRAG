{"name":"algebraMap_mono","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : OrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosMono α β\n⊢ Monotone ⇑(algebraMap α β)","decl":"@[mono] lemma algebraMap_mono : Monotone (algebraMap α β) :=\n  fun a₁ a₂ ha ↦ by\n    simpa only [Algebra.algebraMap_eq_smul_one] using smul_le_smul_of_nonneg_right ha zero_le_one\n\n"}
{"name":"GCongr.algebraMap_le_algebraMap","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : OrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosMono α β\na₁ a₂ : α\nha : LE.le a₁ a₂\n⊢ LE.le ((algebraMap α β) a₁) ((algebraMap α β) a₂)","decl":"/-- A version of `algebraMap_mono` for use by `gcongr` since it currently does not preprocess\n`Monotone` conclusions. -/\n@[gcongr] protected lemma GCongr.algebraMap_le_algebraMap {a₁ a₂ : α} (ha : a₁ ≤ a₂) :\n    algebraMap α β a₁ ≤ algebraMap α β a₂ := algebraMap_mono _ ha\n\n"}
{"name":"algebraMap_nonneg","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : OrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosMono α β\na : α\nha : LE.le 0 a\n⊢ LE.le 0 ((algebraMap α β) a)","decl":"lemma algebraMap_nonneg (ha : 0 ≤ a) : 0 ≤ algebraMap α β a := by simpa using algebraMap_mono β ha\n\n"}
{"name":"algebraMap_le_algebraMap","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : OrderedCommSemiring α\ninst✝³ : StrictOrderedSemiring β\ninst✝² : Algebra α β\ninst✝¹ : SMulPosMono α β\ninst✝ : SMulPosReflectLE α β\na₁ a₂ : α\n⊢ Iff (LE.le ((algebraMap α β) a₁) ((algebraMap α β) a₂)) (LE.le a₁ a₂)","decl":"@[simp] lemma algebraMap_le_algebraMap : algebraMap α β a₁ ≤ algebraMap α β a₂ ↔ a₁ ≤ a₂ := by\n  simp [Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"algebraMap_strictMono","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : StrictOrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosStrictMono α β\n⊢ StrictMono ⇑(algebraMap α β)","decl":"@[mono] lemma algebraMap_strictMono : StrictMono (algebraMap α β) :=\n  fun a₁ a₂ ha ↦ by\n    simpa only [Algebra.algebraMap_eq_smul_one] using smul_lt_smul_of_pos_right ha zero_lt_one\n\n"}
{"name":"GCongr.algebraMap_lt_algebraMap","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : StrictOrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosStrictMono α β\na₁ a₂ : α\nha : LT.lt a₁ a₂\n⊢ LT.lt ((algebraMap α β) a₁) ((algebraMap α β) a₂)","decl":"/-- A version of `algebraMap_strictMono` for use by `gcongr` since it currently does not preprocess\n`Monotone` conclusions. -/\n@[gcongr] protected lemma GCongr.algebraMap_lt_algebraMap {a₁ a₂ : α} (ha : a₁ < a₂) :\n    algebraMap α β a₁ < algebraMap α β a₂ := algebraMap_strictMono _ ha\n\n"}
{"name":"algebraMap_pos","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : OrderedCommSemiring α\ninst✝² : StrictOrderedSemiring β\ninst✝¹ : Algebra α β\ninst✝ : SMulPosStrictMono α β\na : α\nha : LT.lt 0 a\n⊢ LT.lt 0 ((algebraMap α β) a)","decl":"lemma algebraMap_pos (ha : 0 < a) : 0 < algebraMap α β a := by\n  simpa using algebraMap_strictMono β ha\n\n"}
{"name":"algebraMap_lt_algebraMap","module":"Mathlib.Algebra.Order.Module.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : OrderedCommSemiring α\ninst✝³ : StrictOrderedSemiring β\ninst✝² : Algebra α β\ninst✝¹ : SMulPosStrictMono α β\na₁ a₂ : α\ninst✝ : SMulPosReflectLT α β\n⊢ Iff (LT.lt ((algebraMap α β) a₁) ((algebraMap α β) a₂)) (LT.lt a₁ a₂)","decl":"@[simp] lemma algebraMap_lt_algebraMap : algebraMap α β a₁ < algebraMap α β a₂ ↔ a₁ < a₂ := by\n  simp [Algebra.algebraMap_eq_smul_one]\n\n"}
