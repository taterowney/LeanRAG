{"name":"Stream'.eta","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.cons s.head s.tail) s","decl":"@[simp] protected theorem eta (s : Stream' α) : head s :: tail s = s :=\n  funext fun i => by cases i <;> rfl\n\n"}
{"name":"Stream'.cons_head_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.cons s.head s.tail) s","decl":"/-- Alias for `Stream'.eta` to match `List` API. -/\nalias cons_head_tail := Stream'.eta\n\n"}
{"name":"Stream'.ext","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\na✝ : ∀ (n : Nat), Eq (s₁.get n) (s₂.get n)\n⊢ Eq s₁ s₂","decl":"@[ext]\nprotected theorem ext {s₁ s₂ : Stream' α} : (∀ n, get s₁ n = get s₂ n) → s₁ = s₂ :=\n  fun h => funext h\n\n"}
{"name":"Stream'.ext_iff","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\n⊢ Iff (Eq s₁ s₂) (∀ (n : Nat), Eq (s₁.get n) (s₂.get n))","decl":"@[ext]\nprotected theorem ext {s₁ s₂ : Stream' α} : (∀ n, get s₁ n = get s₂ n) → s₁ = s₂ :=\n  fun h => funext h\n\n"}
{"name":"Stream'.get_zero_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\n⊢ Eq ((Stream'.cons a s).get 0) a","decl":"@[simp]\ntheorem get_zero_cons (a : α) (s : Stream' α) : get (a::s) 0 = a :=\n  rfl\n\n"}
{"name":"Stream'.head_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\n⊢ Eq (Stream'.cons a s).head a","decl":"@[simp]\ntheorem head_cons (a : α) (s : Stream' α) : head (a::s) = a :=\n  rfl\n\n"}
{"name":"Stream'.tail_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\n⊢ Eq (Stream'.cons a s).tail s","decl":"@[simp]\ntheorem tail_cons (a : α) (s : Stream' α) : tail (a::s) = s :=\n  rfl\n\n"}
{"name":"Stream'.get_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn m : Nat\ns : Stream' α\n⊢ Eq ((Stream'.drop m s).get n) (s.get (HAdd.hAdd m n))","decl":"@[simp]\ntheorem get_drop (n m : ℕ) (s : Stream' α) : get (drop m s) n = get s (m + n) := by\n  rw [Nat.add_comm]\n  rfl\n\n"}
{"name":"Stream'.tail_eq_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.tail (Stream'.drop 1 s)","decl":"theorem tail_eq_drop (s : Stream' α) : tail s = drop 1 s :=\n  rfl\n\n"}
{"name":"Stream'.drop_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn m : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop n (Stream'.drop m s)) (Stream'.drop (HAdd.hAdd m n) s)","decl":"@[simp]\ntheorem drop_drop (n m : ℕ) (s : Stream' α) : drop n (drop m s) = drop (m + n) s := by\n  ext; simp [Nat.add_assoc]\n\n"}
{"name":"Stream'.get_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.tail.get n) (s.get (HAdd.hAdd n 1))","decl":"@[simp] theorem get_tail {n : ℕ} {s : Stream' α} : s.tail.get n = s.get (n + 1) := rfl\n\n"}
{"name":"Stream'.tail_drop'","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ni : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop i s).tail (Stream'.drop (HAdd.hAdd i 1) s)","decl":"@[simp] theorem tail_drop' {i : ℕ} {s : Stream' α} : tail (drop i s) = s.drop (i + 1) := by\n  ext; simp [Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]\n\n"}
{"name":"Stream'.drop_tail'","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ni : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop i s.tail) (Stream'.drop (HAdd.hAdd i 1) s)","decl":"@[simp] theorem drop_tail' {i : ℕ} {s : Stream' α} : drop i (tail s) = s.drop (i + 1) := rfl\n\n"}
{"name":"Stream'.tail_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop n s).tail (Stream'.drop n s.tail)","decl":"theorem tail_drop (n : ℕ) (s : Stream' α) : tail (drop n s) = drop n (tail s) := by simp\n\n"}
{"name":"Stream'.get_succ","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.get n.succ) (s.tail.get n)","decl":"theorem get_succ (n : ℕ) (s : Stream' α) : get s (succ n) = get (tail s) n :=\n  rfl\n\n"}
{"name":"Stream'.get_succ_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\nx : α\n⊢ Eq ((Stream'.cons x s).get n.succ) (s.get n)","decl":"@[simp]\ntheorem get_succ_cons (n : ℕ) (s : Stream' α) (x : α) : get (x :: s) n.succ = get s n :=\n  rfl\n\n"}
{"name":"Stream'.get_cons_append_zero","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nx : List α\ns : Stream' α\n⊢ Eq ((Stream'.appendStream' (List.cons a x) s).get 0) a","decl":"@[simp] lemma get_cons_append_zero {a : α} {x : List α} {s : Stream' α} :\n  (a :: x ++ₛ s).get 0 = a := rfl\n\n"}
{"name":"Stream'.append_eq_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nas : Stream' α\n⊢ Eq (Stream'.appendStream' (List.cons a List.nil) as) (Stream'.cons a as)","decl":"@[simp] lemma append_eq_cons {a : α} {as : Stream' α} : [a] ++ₛ as = a :: as := by rfl\n\n"}
{"name":"Stream'.drop_zero","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.drop 0 s) s","decl":"@[simp] theorem drop_zero {s : Stream' α} : s.drop 0 = s := rfl\n\n"}
{"name":"Stream'.drop_succ","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop n.succ s) (Stream'.drop n s.tail)","decl":"theorem drop_succ (n : ℕ) (s : Stream' α) : drop (succ n) s = drop n (tail s) :=\n  rfl\n\n"}
{"name":"Stream'.head_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : Stream' α\nn : Nat\n⊢ Eq (Stream'.drop n a).head (a.get n)","decl":"theorem head_drop (a : Stream' α) (n : ℕ) : (a.drop n).head = a.get n := by simp\n\n"}
{"name":"Stream'.cons_injective2","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\n⊢ Function.Injective2 Stream'.cons","decl":"theorem cons_injective2 : Function.Injective2 (cons : α → Stream' α → Stream' α) := fun x y s t h =>\n  ⟨by rw [← get_zero_cons x s, h, get_zero_cons],\n    Stream'.ext fun n => by rw [← get_succ_cons n _ x, h, get_succ_cons]⟩\n\n"}
{"name":"Stream'.cons_injective_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Function.Injective fun x => Stream'.cons x s","decl":"theorem cons_injective_left (s : Stream' α) : Function.Injective fun x => cons x s :=\n  cons_injective2.left _\n\n"}
{"name":"Stream'.cons_injective_right","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nx : α\n⊢ Function.Injective (Stream'.cons x)","decl":"theorem cons_injective_right (x : α) : Function.Injective (cons x) :=\n  cons_injective2.right _\n\n"}
{"name":"Stream'.all_def","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\np : α → Prop\ns : Stream' α\n⊢ Eq (Stream'.All p s) (∀ (n : Nat), p (s.get n))","decl":"theorem all_def (p : α → Prop) (s : Stream' α) : All p s = ∀ n, p (get s n) :=\n  rfl\n\n"}
{"name":"Stream'.any_def","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\np : α → Prop\ns : Stream' α\n⊢ Eq (Stream'.Any p s) (Exists fun n => p (s.get n))","decl":"theorem any_def (p : α → Prop) (s : Stream' α) : Any p s = ∃ n, p (get s n) :=\n  rfl\n\n"}
{"name":"Stream'.mem_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\n⊢ Membership.mem (Stream'.cons a s) a","decl":"@[simp]\ntheorem mem_cons (a : α) (s : Stream' α) : a ∈ a::s :=\n  Exists.intro 0 rfl\n\n"}
{"name":"Stream'.mem_cons_of_mem","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\nb : α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.cons b s) a","decl":"theorem mem_cons_of_mem {a : α} {s : Stream' α} (b : α) : a ∈ s → a ∈ b::s := fun ⟨n, h⟩ =>\n  Exists.intro (succ n) (by rw [get_succ, tail_cons, h])\n\n"}
{"name":"Stream'.eq_or_mem_of_mem_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na b : α\ns : Stream' α\na✝ : Membership.mem (Stream'.cons b s) a\n⊢ Or (Eq a b) (Membership.mem s a)","decl":"theorem eq_or_mem_of_mem_cons {a b : α} {s : Stream' α} : (a ∈ b::s) → a = b ∨ a ∈ s :=\n    fun ⟨n, h⟩ => by\n  cases' n with n'\n  · left\n    exact h\n  · right\n    rw [get_succ, tail_cons] at h\n    exact ⟨n', h⟩\n\n"}
{"name":"Stream'.mem_of_get_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\na : α\na✝ : Eq a (s.get n)\n⊢ Membership.mem s a","decl":"theorem mem_of_get_eq {n : ℕ} {s : Stream' α} {a : α} : a = get s n → a ∈ s := fun h =>\n  Exists.intro n h\n\n"}
{"name":"Stream'.drop_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.drop n (Stream'.map f s)) (Stream'.map f (Stream'.drop n s))","decl":"theorem drop_map (n : ℕ) (s : Stream' α) : drop n (map f s) = map f (drop n s) :=\n  Stream'.ext fun _ => rfl\n\n"}
{"name":"Stream'.get_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nn : Nat\ns : Stream' α\n⊢ Eq ((Stream'.map f s).get n) (f (s.get n))","decl":"@[simp]\ntheorem get_map (n : ℕ) (s : Stream' α) : get (map f s) n = f (get s n) :=\n  rfl\n\n"}
{"name":"Stream'.tail_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map f s).tail (Stream'.map f s.tail)","decl":"theorem tail_map (s : Stream' α) : tail (map f s) = map f (tail s) := rfl\n\n"}
{"name":"Stream'.head_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map f s).head (f s.head)","decl":"@[simp]\ntheorem head_map (s : Stream' α) : head (map f s) = f (head s) :=\n  rfl\n\n"}
{"name":"Stream'.map_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map f s) (Stream'.cons (f s.head) (Stream'.map f s.tail))","decl":"theorem map_eq (s : Stream' α) : map f s = f (head s)::map f (tail s) := by\n  rw [← Stream'.eta (map f s), tail_map, head_map]\n\n"}
{"name":"Stream'.map_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream' α\n⊢ Eq (Stream'.map f (Stream'.cons a s)) (Stream'.cons (f a) (Stream'.map f s))","decl":"theorem map_cons (a : α) (s : Stream' α) : map f (a::s) = f a::map f s := by\n  rw [← Stream'.eta (map f (a::s)), map_eq]; rfl\n\n"}
{"name":"Stream'.map_id","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.map id s) s","decl":"@[simp]\ntheorem map_id (s : Stream' α) : map id s = s :=\n  rfl\n\n"}
{"name":"Stream'.map_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\ng : β → δ\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map g (Stream'.map f s)) (Stream'.map (Function.comp g f) s)","decl":"@[simp]\ntheorem map_map (g : β → δ) (f : α → β) (s : Stream' α) : map g (map f s) = map (g ∘ f) s :=\n  rfl\n\n"}
{"name":"Stream'.map_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map f s.tail) (Stream'.map f s).tail","decl":"@[simp]\ntheorem map_tail (s : Stream' α) : map f (tail s) = tail (map f s) :=\n  rfl\n\n"}
{"name":"Stream'.mem_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream' α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.map f s) (f a)","decl":"theorem mem_map {a : α} {s : Stream' α} : a ∈ s → f a ∈ map f s := fun ⟨n, h⟩ =>\n  Exists.intro n (by rw [get_map, h])\n\n"}
{"name":"Stream'.exists_of_mem_map","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nb : β\ns : Stream' α\na✝ : Membership.mem (Stream'.map f s) b\n⊢ Exists fun a => And (Membership.mem s a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {f} {b : β} {s : Stream' α} : b ∈ map f s → ∃ a, a ∈ s ∧ f a = b :=\n  fun ⟨n, h⟩ => ⟨get s n, ⟨n, rfl⟩, h.symm⟩\n\n"}
{"name":"Stream'.drop_zip","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\nf : α → β → δ\nn : Nat\ns₁ : Stream' α\ns₂ : Stream' β\n⊢ Eq (Stream'.drop n (Stream'.zip f s₁ s₂)) (Stream'.zip f (Stream'.drop n s₁) (Stream'.drop n s₂))","decl":"theorem drop_zip (n : ℕ) (s₁ : Stream' α) (s₂ : Stream' β) :\n    drop n (zip f s₁ s₂) = zip f (drop n s₁) (drop n s₂) :=\n  Stream'.ext fun _ => rfl\n\n"}
{"name":"Stream'.get_zip","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\nf : α → β → δ\nn : Nat\ns₁ : Stream' α\ns₂ : Stream' β\n⊢ Eq ((Stream'.zip f s₁ s₂).get n) (f (s₁.get n) (s₂.get n))","decl":"@[simp]\ntheorem get_zip (n : ℕ) (s₁ : Stream' α) (s₂ : Stream' β) :\n    get (zip f s₁ s₂) n = f (get s₁ n) (get s₂ n) :=\n  rfl\n\n"}
{"name":"Stream'.head_zip","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\nf : α → β → δ\ns₁ : Stream' α\ns₂ : Stream' β\n⊢ Eq (Stream'.zip f s₁ s₂).head (f s₁.head s₂.head)","decl":"theorem head_zip (s₁ : Stream' α) (s₂ : Stream' β) : head (zip f s₁ s₂) = f (head s₁) (head s₂) :=\n  rfl\n\n"}
{"name":"Stream'.tail_zip","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\nf : α → β → δ\ns₁ : Stream' α\ns₂ : Stream' β\n⊢ Eq (Stream'.zip f s₁ s₂).tail (Stream'.zip f s₁.tail s₂.tail)","decl":"theorem tail_zip (s₁ : Stream' α) (s₂ : Stream' β) :\n    tail (zip f s₁ s₂) = zip f (tail s₁) (tail s₂) :=\n  rfl\n\n"}
{"name":"Stream'.zip_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\nf : α → β → δ\ns₁ : Stream' α\ns₂ : Stream' β\n⊢ Eq (Stream'.zip f s₁ s₂) (Stream'.cons (f s₁.head s₂.head) (Stream'.zip f s₁.tail s₂.tail))","decl":"theorem zip_eq (s₁ : Stream' α) (s₂ : Stream' β) :\n    zip f s₁ s₂ = f (head s₁) (head s₂)::zip f (tail s₁) (tail s₂) := by\n  rw [← Stream'.eta (zip f s₁ s₂)]; rfl\n\n"}
{"name":"Stream'.get_enum","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\nn : Nat\n⊢ Eq (s.enum.get n) { fst := n, snd := s.get n }","decl":"@[simp]\ntheorem get_enum (s : Stream' α) (n : ℕ) : get (enum s) n = (n, s.get n) :=\n  rfl\n\n"}
{"name":"Stream'.enum_eq_zip","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.enum (Stream'.zip Prod.mk Stream'.nats s)","decl":"theorem enum_eq_zip (s : Stream' α) : enum s = zip Prod.mk nats s :=\n  rfl\n\n"}
{"name":"Stream'.mem_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Membership.mem (Stream'.const a) a","decl":"@[simp]\ntheorem mem_const (a : α) : a ∈ const a :=\n  Exists.intro 0 rfl\n\n"}
{"name":"Stream'.const_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Eq (Stream'.const a) (Stream'.cons a (Stream'.const a))","decl":"theorem const_eq (a : α) : const a = a::const a := by\n  apply Stream'.ext; intro n\n  cases n <;> rfl\n\n"}
{"name":"Stream'.tail_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Eq (Stream'.const a).tail (Stream'.const a)","decl":"@[simp]\ntheorem tail_const (a : α) : tail (const a) = const a :=\n  suffices tail (a::const a) = const a by rwa [← const_eq] at this\n  rfl\n\n"}
{"name":"Stream'.map_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq (Stream'.map f (Stream'.const a)) (Stream'.const (f a))","decl":"@[simp]\ntheorem map_const (f : α → β) (a : α) : map f (const a) = const (f a) :=\n  rfl\n\n"}
{"name":"Stream'.get_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\na : α\n⊢ Eq ((Stream'.const a).get n) a","decl":"@[simp]\ntheorem get_const (n : ℕ) (a : α) : get (const a) n = a :=\n  rfl\n\n"}
{"name":"Stream'.drop_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\na : α\n⊢ Eq (Stream'.drop n (Stream'.const a)) (Stream'.const a)","decl":"@[simp]\ntheorem drop_const (n : ℕ) (a : α) : drop n (const a) = const a :=\n  Stream'.ext fun _ => rfl\n\n"}
{"name":"Stream'.head_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq (Stream'.iterate f a).head a","decl":"@[simp]\ntheorem head_iterate (f : α → α) (a : α) : head (iterate f a) = a :=\n  rfl\n\n"}
{"name":"Stream'.get_succ_iterate'","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nf : α → α\na : α\n⊢ Eq ((Stream'.iterate f a).get n.succ) (f ((Stream'.iterate f a).get n))","decl":"theorem get_succ_iterate' (n : ℕ) (f : α → α) (a : α) :\n    get (iterate f a) (succ n) = f (get (iterate f a) n) := rfl\n\n"}
{"name":"Stream'.tail_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq (Stream'.iterate f a).tail (Stream'.iterate f (f a))","decl":"theorem tail_iterate (f : α → α) (a : α) : tail (iterate f a) = iterate f (f a) := by\n  ext n\n  rw [get_tail]\n  induction' n with n' ih\n  · rfl\n  · rw [get_succ_iterate', ih, get_succ_iterate']\n\n"}
{"name":"Stream'.iterate_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq (Stream'.iterate f a) (Stream'.cons a (Stream'.iterate f (f a)))","decl":"theorem iterate_eq (f : α → α) (a : α) : iterate f a = a::iterate f (f a) := by\n  rw [← Stream'.eta (iterate f a)]\n  rw [tail_iterate]; rfl\n\n"}
{"name":"Stream'.get_zero_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq ((Stream'.iterate f a).get 0) a","decl":"@[simp]\ntheorem get_zero_iterate (f : α → α) (a : α) : get (iterate f a) 0 = a :=\n  rfl\n\n"}
{"name":"Stream'.get_succ_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nf : α → α\na : α\n⊢ Eq ((Stream'.iterate f a).get n.succ) ((Stream'.iterate f (f a)).get n)","decl":"theorem get_succ_iterate (n : ℕ) (f : α → α) (a : α) :\n    get (iterate f a) (succ n) = get (iterate f (f a)) n := by rw [get_succ, tail_iterate]\n\n"}
{"name":"Stream'.get_of_bisim","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nR : Stream' α → Stream' α → Prop\nbisim : Stream'.IsBisimulation R\ns₁ s₂ : Stream' α\nn : Nat\na✝ : R s₁ s₂\n⊢ And (Eq (s₁.get n) (s₂.get n)) (R (Stream'.drop (HAdd.hAdd n 1) s₁) (Stream'.drop (HAdd.hAdd n 1) s₂))","decl":"theorem get_of_bisim (bisim : IsBisimulation R) {s₁ s₂} :\n    ∀ n, s₁ ~ s₂ → get s₁ n = get s₂ n ∧ drop (n + 1) s₁ ~ drop (n + 1) s₂\n  | 0, h => bisim h\n  | n + 1, h =>\n    match bisim h with\n    | ⟨_, trel⟩ => get_of_bisim bisim n trel\n\n-- If two streams are bisimilar, then they are equal\n"}
{"name":"Stream'.eq_of_bisim","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nR : Stream' α → Stream' α → Prop\nbisim : Stream'.IsBisimulation R\ns₁ s₂ : Stream' α\na✝ : R s₁ s₂\n⊢ Eq s₁ s₂","decl":"theorem eq_of_bisim (bisim : IsBisimulation R) {s₁ s₂} : s₁ ~ s₂ → s₁ = s₂ := fun r =>\n  Stream'.ext fun n => And.left (get_of_bisim R bisim n r)\n\n"}
{"name":"Stream'.bisim_simple","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\na✝² : Eq s₁.head s₂.head\na✝¹ : Eq s₁ s₁.tail\na✝ : Eq s₂ s₂.tail\n⊢ Eq s₁ s₂","decl":"theorem bisim_simple (s₁ s₂ : Stream' α) :\n    head s₁ = head s₂ → s₁ = tail s₁ → s₂ = tail s₂ → s₁ = s₂ := fun hh ht₁ ht₂ =>\n  eq_of_bisim (fun s₁ s₂ => head s₁ = head s₂ ∧ s₁ = tail s₁ ∧ s₂ = tail s₂)\n    (fun s₁ s₂ ⟨h₁, h₂, h₃⟩ => by\n      constructor\n      · exact h₁\n      rw [← h₂, ← h₃]\n      (repeat' constructor) <;> assumption)\n    (And.intro hh (And.intro ht₁ ht₂))\n\n"}
{"name":"Stream'.coinduction","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\na✝¹ : Eq s₁.head s₂.head\na✝ : ∀ (β : Type u) (fr : Stream' α → β), Eq (fr s₁) (fr s₂) → Eq (fr s₁.tail) (fr s₂.tail)\n⊢ Eq s₁ s₂","decl":"theorem coinduction {s₁ s₂ : Stream' α} :\n    head s₁ = head s₂ →\n      (∀ (β : Type u) (fr : Stream' α → β),\n      fr s₁ = fr s₂ → fr (tail s₁) = fr (tail s₂)) → s₁ = s₂ :=\n  fun hh ht =>\n  eq_of_bisim\n    (fun s₁ s₂ =>\n      head s₁ = head s₂ ∧\n        ∀ (β : Type u) (fr : Stream' α → β), fr s₁ = fr s₂ → fr (tail s₁) = fr (tail s₂))\n    (fun s₁ s₂ h =>\n      have h₁ : head s₁ = head s₂ := And.left h\n      have h₂ : head (tail s₁) = head (tail s₂) := And.right h α (@head α) h₁\n      have h₃ :\n        ∀ (β : Type u) (fr : Stream' α → β),\n          fr (tail s₁) = fr (tail s₂) → fr (tail (tail s₁)) = fr (tail (tail s₂)) :=\n        fun β fr => And.right h β fun s => fr (tail s)\n      And.intro h₁ (And.intro h₂ h₃))\n    (And.intro hh ht)\n\n"}
{"name":"Stream'.iterate_id","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Eq (Stream'.iterate id a) (Stream'.const a)","decl":"@[simp]\ntheorem iterate_id (a : α) : iterate id a = const a :=\n  coinduction rfl fun β fr ch => by rw [tail_iterate, tail_const]; exact ch\n\n"}
{"name":"Stream'.map_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq (Stream'.iterate f (f a)) (Stream'.map f (Stream'.iterate f a))","decl":"theorem map_iterate (f : α → α) (a : α) : iterate f (f a) = map f (iterate f a) := by\n  funext n\n  induction' n with n' ih\n  · rfl\n  · unfold map iterate get\n    rw [map, get] at ih\n    rw [iterate]\n    exact congrArg f ih\n\n"}
{"name":"Stream'.corec_def","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : α → α\na : α\n⊢ Eq (Stream'.corec f g a) (Stream'.map f (Stream'.iterate g a))","decl":"theorem corec_def (f : α → β) (g : α → α) (a : α) : corec f g a = map f (iterate g a) :=\n  rfl\n\n"}
{"name":"Stream'.corec_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : α → α\na : α\n⊢ Eq (Stream'.corec f g a) (Stream'.cons (f a) (Stream'.corec f g (g a)))","decl":"theorem corec_eq (f : α → β) (g : α → α) (a : α) : corec f g a = f a :: corec f g (g a) := by\n  rw [corec_def, map_eq, head_iterate, tail_iterate]; rfl\n\n"}
{"name":"Stream'.corec_id_id_eq_const","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Eq (Stream'.corec id id a) (Stream'.const a)","decl":"theorem corec_id_id_eq_const (a : α) : corec id id a = const a := by\n  rw [corec_def, map_id, iterate_id]\n\n"}
{"name":"Stream'.corec_id_f_eq_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nf : α → α\na : α\n⊢ Eq (Stream'.corec id f a) (Stream'.iterate f a)","decl":"theorem corec_id_f_eq_iterate (f : α → α) (a : α) : corec id f a = iterate f a :=\n  rfl\n\n"}
{"name":"Stream'.corec'_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → Prod β α\na : α\n⊢ Eq (Stream'.corec' f a) (Stream'.cons (f a).fst (Stream'.corec' f (f a).snd))","decl":"theorem corec'_eq (f : α → β × α) (a : α) : corec' f a = (f a).1 :: corec' f (f a).2 :=\n  corec_eq _ _ _\n\n"}
{"name":"Stream'.unfolds_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\ng : α → β\nf : α → α\na : α\n⊢ Eq (Stream'.unfolds g f a) (Stream'.cons (g a) (Stream'.unfolds g f (f a)))","decl":"theorem unfolds_eq (g : α → β) (f : α → α) (a : α) : unfolds g f a = g a :: unfolds g f (f a) := by\n  unfold unfolds; rw [corec_eq]\n\n"}
{"name":"Stream'.get_unfolds_head_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq ((Stream'.unfolds Stream'.head Stream'.tail s).get n) (s.get n)","decl":"theorem get_unfolds_head_tail : ∀ (n : ℕ) (s : Stream' α),\n    get (unfolds head tail s) n = get s n := by\n  intro n; induction' n with n' ih\n  · intro s\n    rfl\n  · intro s\n    rw [get_succ, get_succ, unfolds_eq, tail_cons, ih]\n\n"}
{"name":"Stream'.unfolds_head_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.unfolds Stream'.head Stream'.tail s) s","decl":"theorem unfolds_head_eq : ∀ s : Stream' α, unfolds head tail s = s := fun s =>\n  Stream'.ext fun n => get_unfolds_head_tail n s\n\n"}
{"name":"Stream'.interleave_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\n⊢ Eq (s₁.interleave s₂) (Stream'.cons s₁.head (Stream'.cons s₂.head (s₁.tail.interleave s₂.tail)))","decl":"theorem interleave_eq (s₁ s₂ : Stream' α) : s₁ ⋈ s₂ = head s₁::head s₂::(tail s₁ ⋈ tail s₂) := by\n  let t := tail s₁ ⋈ tail s₂\n  show s₁ ⋈ s₂ = head s₁::head s₂::t\n  unfold interleave; unfold corecOn; rw [corec_eq]; dsimp; rw [corec_eq]; rfl\n\n"}
{"name":"Stream'.tail_interleave","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\n⊢ Eq (s₁.interleave s₂).tail (s₂.interleave s₁.tail)","decl":"theorem tail_interleave (s₁ s₂ : Stream' α) : tail (s₁ ⋈ s₂) = s₂ ⋈ tail s₁ := by\n  unfold interleave corecOn; rw [corec_eq]; rfl\n\n"}
{"name":"Stream'.interleave_tail_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\n⊢ Eq (s₁.tail.interleave s₂.tail) (s₁.interleave s₂).tail.tail","decl":"theorem interleave_tail_tail (s₁ s₂ : Stream' α) : tail s₁ ⋈ tail s₂ = tail (tail (s₁ ⋈ s₂)) := by\n  rw [interleave_eq s₁ s₂]; rfl\n\n"}
{"name":"Stream'.get_interleave_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns₁ s₂ : Stream' α\n⊢ Eq ((s₁.interleave s₂).get (HMul.hMul 2 n)) (s₁.get n)","decl":"theorem get_interleave_left : ∀ (n : ℕ) (s₁ s₂ : Stream' α),\n    get (s₁ ⋈ s₂) (2 * n) = get s₁ n\n  | 0, _, _ => rfl\n  | n + 1, s₁, s₂ => by\n    change get (s₁ ⋈ s₂) (succ (succ (2 * n))) = get s₁ (succ n)\n    rw [get_succ, get_succ, interleave_eq, tail_cons, tail_cons]\n    rw [get_interleave_left n (tail s₁) (tail s₂)]\n    rfl\n\n"}
{"name":"Stream'.get_interleave_right","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns₁ s₂ : Stream' α\n⊢ Eq ((s₁.interleave s₂).get (HAdd.hAdd (HMul.hMul 2 n) 1)) (s₂.get n)","decl":"theorem get_interleave_right : ∀ (n : ℕ) (s₁ s₂ : Stream' α),\n    get (s₁ ⋈ s₂) (2 * n + 1) = get s₂ n\n  | 0, _, _ => rfl\n  | n + 1, s₁, s₂ => by\n    change get (s₁ ⋈ s₂) (succ (succ (2 * n + 1))) = get s₂ (succ n)\n    rw [get_succ, get_succ, interleave_eq, tail_cons, tail_cons,\n      get_interleave_right n (tail s₁) (tail s₂)]\n    rfl\n\n"}
{"name":"Stream'.mem_interleave_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns₁ s₂ : Stream' α\na✝ : Membership.mem s₁ a\n⊢ Membership.mem (s₁.interleave s₂) a","decl":"theorem mem_interleave_left {a : α} {s₁ : Stream' α} (s₂ : Stream' α) : a ∈ s₁ → a ∈ s₁ ⋈ s₂ :=\n  fun ⟨n, h⟩ => Exists.intro (2 * n) (by rw [h, get_interleave_left])\n\n"}
{"name":"Stream'.mem_interleave_right","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns₁ s₂ : Stream' α\na✝ : Membership.mem s₂ a\n⊢ Membership.mem (s₁.interleave s₂) a","decl":"theorem mem_interleave_right {a : α} {s₁ : Stream' α} (s₂ : Stream' α) : a ∈ s₂ → a ∈ s₁ ⋈ s₂ :=\n  fun ⟨n, h⟩ => Exists.intro (2 * n + 1) (by rw [h, get_interleave_right])\n\n"}
{"name":"Stream'.odd_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.odd s.tail.even","decl":"theorem odd_eq (s : Stream' α) : odd s = even (tail s) :=\n  rfl\n\n"}
{"name":"Stream'.head_even","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.even.head s.head","decl":"@[simp]\ntheorem head_even (s : Stream' α) : head (even s) = head s :=\n  rfl\n\n"}
{"name":"Stream'.tail_even","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.even.tail s.tail.tail.even","decl":"theorem tail_even (s : Stream' α) : tail (even s) = even (tail (tail s)) := by\n  unfold even\n  rw [corec_eq]\n  rfl\n\n"}
{"name":"Stream'.even_cons_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na₁ a₂ : α\ns : Stream' α\n⊢ Eq (Stream'.cons a₁ (Stream'.cons a₂ s)).even (Stream'.cons a₁ s.even)","decl":"theorem even_cons_cons (a₁ a₂ : α) (s : Stream' α) : even (a₁::a₂::s) = a₁::even s := by\n  unfold even\n  rw [corec_eq]; rfl\n\n"}
{"name":"Stream'.even_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.tail.even s.odd","decl":"theorem even_tail (s : Stream' α) : even (tail s) = odd s :=\n  rfl\n\n"}
{"name":"Stream'.even_interleave","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\n⊢ Eq (s₁.interleave s₂).even s₁","decl":"theorem even_interleave (s₁ s₂ : Stream' α) : even (s₁ ⋈ s₂) = s₁ :=\n  eq_of_bisim (fun s₁' s₁ => ∃ s₂, s₁' = even (s₁ ⋈ s₂))\n    (fun s₁' s₁ ⟨s₂, h₁⟩ => by\n      rw [h₁]\n      constructor\n      · rfl\n      · exact ⟨tail s₂, by rw [interleave_eq, even_cons_cons, tail_cons]⟩)\n    (Exists.intro s₂ rfl)\n\n"}
{"name":"Stream'.interleave_even_odd","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ : Stream' α\n⊢ Eq (s₁.even.interleave s₁.odd) s₁","decl":"theorem interleave_even_odd (s₁ : Stream' α) : even s₁ ⋈ odd s₁ = s₁ :=\n  eq_of_bisim (fun s' s => s' = even s ⋈ odd s)\n    (fun s' s (h : s' = even s ⋈ odd s) => by\n      rw [h]; constructor\n      · rfl\n      · simp [odd_eq, odd_eq, tail_interleave, tail_even])\n    rfl\n\n"}
{"name":"Stream'.get_even","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.even.get n) (s.get (HMul.hMul 2 n))","decl":"theorem get_even : ∀ (n : ℕ) (s : Stream' α), get (even s) n = get s (2 * n)\n  | 0, _ => rfl\n  | succ n, s => by\n    change get (even s) (succ n) = get s (succ (succ (2 * n)))\n    rw [get_succ, get_succ, tail_even, get_even n]; rfl\n\n"}
{"name":"Stream'.get_odd","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.odd.get n) (s.get (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"theorem get_odd : ∀ (n : ℕ) (s : Stream' α), get (odd s) n = get s (2 * n + 1) := fun n s => by\n  rw [odd_eq, get_even]; rfl\n\n"}
{"name":"Stream'.mem_of_mem_even","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\na✝ : Membership.mem s.even a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_even (a : α) (s : Stream' α) : a ∈ even s → a ∈ s := fun ⟨n, h⟩ =>\n  Exists.intro (2 * n) (by rw [h, get_even])\n\n"}
{"name":"Stream'.mem_of_mem_odd","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\ns : Stream' α\na✝ : Membership.mem s.odd a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_odd (a : α) (s : Stream' α) : a ∈ odd s → a ∈ s := fun ⟨n, h⟩ =>\n  Exists.intro (2 * n + 1) (by rw [h, get_odd])\n\n"}
{"name":"Stream'.nil_append_stream","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.appendStream' List.nil s) s","decl":"@[simp] theorem nil_append_stream (s : Stream' α) : appendStream' [] s = s :=\n  rfl\n\n"}
{"name":"Stream'.cons_append_stream","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nl : List α\ns : Stream' α\n⊢ Eq (Stream'.appendStream' (List.cons a l) s) (Stream'.cons a (Stream'.appendStream' l s))","decl":"theorem cons_append_stream (a : α) (l : List α) (s : Stream' α) :\n    appendStream' (a::l) s = a::appendStream' l s :=\n  rfl\n\n"}
{"name":"Stream'.append_append_stream","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nl₁ l₂ : List α\ns : Stream' α\n⊢ Eq (Stream'.appendStream' (HAppend.hAppend l₁ l₂) s) (Stream'.appendStream' l₁ (Stream'.appendStream' l₂ s))","decl":"@[simp] theorem append_append_stream : ∀ (l₁ l₂ : List α) (s : Stream' α),\n    l₁ ++ l₂ ++ₛ s = l₁ ++ₛ (l₂ ++ₛ s)\n  | [], _, _ => rfl\n  | List.cons a l₁, l₂, s => by\n    rw [List.cons_append, cons_append_stream, cons_append_stream, append_append_stream l₁]\n\n"}
{"name":"Stream'.get_append_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nx : List α\na : Stream' α\nh : LT.lt n x.length\n⊢ Eq ((Stream'.appendStream' x a).get n) (GetElem.getElem x n ⋯)","decl":"lemma get_append_left (h : n < x.length) : (x ++ₛ a).get n = x[n] := by\n  induction' x with b x ih generalizing n\n  · simp at h\n  · rcases n with (_ | n)\n    · simp\n    · simp [ih n (by simpa using h), cons_append_stream]\n\n"}
{"name":"Stream'.get_append_right","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nx : List α\na : Stream' α\n⊢ Eq ((Stream'.appendStream' x a).get (HAdd.hAdd x.length n)) (a.get n)","decl":"@[simp] lemma get_append_right : (x ++ₛ a).get (x.length + n) = a.get n := by\n  induction' x <;> simp [Nat.succ_add, *, cons_append_stream]\n\n"}
{"name":"Stream'.get_append_length","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nx : List α\na : Stream' α\n⊢ Eq ((Stream'.appendStream' x a).get x.length) (a.get 0)","decl":"@[simp] lemma get_append_length : (x ++ₛ a).get x.length = a.get 0 := get_append_right 0 x a\n\n"}
{"name":"Stream'.append_right_injective","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nx : List α\na b : Stream' α\nh : Eq (Stream'.appendStream' x a) (Stream'.appendStream' x b)\n⊢ Eq a b","decl":"lemma append_right_injective (h : x ++ₛ a = x ++ₛ b) : a = b := by\n  ext n; replace h := congr_arg (fun a ↦ a.get (x.length + n)) h; simpa using h\n\n"}
{"name":"Stream'.append_right_inj","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nx : List α\na b : Stream' α\n⊢ Iff (Eq (Stream'.appendStream' x a) (Stream'.appendStream' x b)) (Eq a b)","decl":"@[simp] lemma append_right_inj : x ++ₛ a = x ++ₛ b ↔ a = b :=\n  ⟨append_right_injective x a b, by simp (config := {contextual := true})⟩\n\n"}
{"name":"Stream'.append_left_injective","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nx y : List α\na b : Stream' α\nh : Eq (Stream'.appendStream' x a) (Stream'.appendStream' y b)\nhl : Eq x.length y.length\n⊢ Eq x y","decl":"lemma append_left_injective (h : x ++ₛ a = y ++ₛ b) (hl : x.length = y.length) : x = y := by\n  apply List.ext_getElem hl\n  intros\n  rw [← get_append_left, ← get_append_left, h]\n\n"}
{"name":"Stream'.map_append_stream","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\ns : Stream' α\n⊢ Eq (Stream'.map f (Stream'.appendStream' l s)) (Stream'.appendStream' (List.map f l) (Stream'.map f s))","decl":"theorem map_append_stream (f : α → β) :\n    ∀ (l : List α) (s : Stream' α), map f (l ++ₛ s) = List.map f l ++ₛ map f s\n  | [], _ => rfl\n  | List.cons a l, s => by\n    rw [cons_append_stream, List.map_cons, map_cons, cons_append_stream, map_append_stream f l]\n\n"}
{"name":"Stream'.drop_append_stream","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nl : List α\ns : Stream' α\n⊢ Eq (Stream'.drop l.length (Stream'.appendStream' l s)) s","decl":"theorem drop_append_stream : ∀ (l : List α) (s : Stream' α), drop l.length (l ++ₛ s) = s\n  | [], s => by rfl\n  | List.cons a l, s => by\n    rw [List.length_cons, drop_succ, cons_append_stream, tail_cons, drop_append_stream l s]\n\n"}
{"name":"Stream'.append_stream_head_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.appendStream' (List.cons s.head List.nil) s.tail) s","decl":"theorem append_stream_head_tail (s : Stream' α) : [head s] ++ₛ tail s = s := by\n  simp\n\n"}
{"name":"Stream'.mem_append_stream_right","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nl : List α\ns : Stream' α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.appendStream' l s) a","decl":"theorem mem_append_stream_right : ∀ {a : α} (l : List α) {s : Stream' α}, a ∈ s → a ∈ l ++ₛ s\n  | _, [], _, h => h\n  | a, List.cons _ l, s, h =>\n    have ih : a ∈ l ++ₛ s := mem_append_stream_right l h\n    mem_cons_of_mem _ ih\n\n"}
{"name":"Stream'.mem_append_stream_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nl : List α\ns : Stream' α\na✝ : Membership.mem l a\n⊢ Membership.mem (Stream'.appendStream' l s) a","decl":"theorem mem_append_stream_left : ∀ {a : α} {l : List α} (s : Stream' α), a ∈ l → a ∈ l ++ₛ s\n  | _, [], _, h => absurd h (List.not_mem_nil _)\n  | a, List.cons b l, s, h =>\n    Or.elim (List.eq_or_mem_of_mem_cons h) (fun aeqb : a = b => Exists.intro 0 aeqb)\n      fun ainl : a ∈ l => mem_cons_of_mem b (mem_append_stream_left s ainl)\n\n"}
{"name":"Stream'.take_zero","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.take 0 s) List.nil","decl":"@[simp]\ntheorem take_zero (s : Stream' α) : take 0 s = [] :=\n  rfl\n\n-- This lemma used to be simp, but we removed it from the simp set because:\n-- 1) It duplicates the (often large) `s` term, resulting in large tactic states.\n-- 2) It conflicts with the very useful `dropLast_take` lemma below (causing nonconfluence).\n"}
{"name":"Stream'.take_succ","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.take n.succ s) (List.cons s.head (Stream'.take n s.tail))","decl":"theorem take_succ (n : ℕ) (s : Stream' α) : take (succ n) s = head s::take n (tail s) :=\n  rfl\n\n"}
{"name":"Stream'.take_succ_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.take (HAdd.hAdd n 1) (Stream'.cons a s)) (List.cons a (Stream'.take n s))","decl":"@[simp] theorem take_succ_cons {a : α} (n : ℕ) (s : Stream' α) :\n    take (n+1) (a::s) = a :: take n s := rfl\n\n"}
{"name":"Stream'.take_succ'","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\nn : Nat\n⊢ Eq (Stream'.take (HAdd.hAdd n 1) s) (HAppend.hAppend (Stream'.take n s) (List.cons (s.get n) List.nil))","decl":"theorem take_succ' {s : Stream' α} : ∀ n, s.take (n+1) = s.take n ++ [s.get n]\n  | 0 => rfl\n  | n+1 => by rw [take_succ, take_succ' n, ← List.cons_append, ← take_succ, get_tail]\n\n"}
{"name":"Stream'.length_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.take n s).length n","decl":"@[simp]\ntheorem length_take (n : ℕ) (s : Stream' α) : (take n s).length = n := by\n  induction n generalizing s <;> simp [*, take_succ]\n\n"}
{"name":"Stream'.take_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\nm n : Nat\n⊢ Eq (List.take m (Stream'.take n s)) (Stream'.take (Min.min n m) s)","decl":"@[simp]\ntheorem take_take {s : Stream' α} : ∀ {m n}, (s.take n).take m = s.take (min n m)\n  | 0, n => by rw [Nat.min_zero, List.take_zero, take_zero]\n  | m, 0 => by rw [Nat.zero_min, take_zero, List.take_nil]\n  | m+1, n+1 => by rw [take_succ, List.take_succ_cons, Nat.succ_min_succ, take_succ, take_take]\n\n"}
{"name":"Stream'.concat_take_get","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (HAppend.hAppend (Stream'.take n s) (List.cons (s.get n) List.nil)) (Stream'.take (HAdd.hAdd n 1) s)","decl":"@[simp] theorem concat_take_get {n : ℕ} {s : Stream' α} : s.take n ++ [s.get n] = s.take (n + 1) :=\n  (take_succ' n).symm\n\n"}
{"name":"Stream'.get?_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\nk n : Nat\na✝ : LT.lt k n\n⊢ Eq ((Stream'.take n s).get? k) (Option.some (s.get k))","decl":"theorem get?_take {s : Stream' α} : ∀ {k n}, k < n → (s.take n).get? k = s.get k\n  | 0, _+1, _ => rfl\n  | k+1, n+1, h => by rw [take_succ, List.get?, get?_take (Nat.lt_of_succ_lt_succ h), get_succ]\n\n"}
{"name":"Stream'.get?_take_succ","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq ((Stream'.take n.succ s).get? n) (Option.some (s.get n))","decl":"theorem get?_take_succ (n : ℕ) (s : Stream' α) :\n    List.get? (take (succ n) s) n = some (get s n) :=\n  get?_take (Nat.lt_succ_self n)\n\n"}
{"name":"Stream'.dropLast_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nxs : Stream' α\n⊢ Eq (Stream'.take n xs).dropLast (Stream'.take (HSub.hSub n 1) xs)","decl":"@[simp] theorem dropLast_take {n : ℕ} {xs : Stream' α} :\n    (Stream'.take n xs).dropLast = Stream'.take (n-1) xs := by\n  cases n with\n  | zero => simp\n  | succ n => rw [take_succ', List.dropLast_concat, Nat.add_one_sub_one]\n\n"}
{"name":"Stream'.append_take_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (Stream'.appendStream' (Stream'.take n s) (Stream'.drop n s)) s","decl":"@[simp]\ntheorem append_take_drop : ∀ (n : ℕ) (s : Stream' α),\n    appendStream' (take n s) (drop n s) = s := by\n  intro n\n  induction' n with n' ih\n  · intro s\n    rfl\n  · intro s\n    rw [take_succ, drop_succ, cons_append_stream, ih (tail s), Stream'.eta]\n\n"}
{"name":"Stream'.append_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nx : List α\na : Stream' α\n⊢ Eq (HAppend.hAppend x (Stream'.take n a)) (Stream'.take (HAdd.hAdd x.length n) (Stream'.appendStream' x a))","decl":"lemma append_take : x ++ (a.take n) = (x ++ₛ a).take (x.length + n) := by\n  induction' x <;> simp [take, Nat.add_comm, cons_append_stream, *]\n\n"}
{"name":"Stream'.take_get","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nm n : Nat\na : Stream' α\nh : LT.lt m (Stream'.take n a).length\n⊢ Eq (GetElem.getElem (Stream'.take n a) m ⋯) (a.get m)","decl":"@[simp] lemma take_get (h : m < (a.take n).length) : (a.take n)[m] = a.get m := by\n  nth_rw 2 [← append_take_drop n a]; rw [get_append_left]\n\n"}
{"name":"Stream'.take_append_of_le_length","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nx : List α\na : Stream' α\nh : LE.le n x.length\n⊢ Eq (Stream'.take n (Stream'.appendStream' x a)) (List.take n x)","decl":"theorem take_append_of_le_length (h : n ≤ x.length) :\n    (x ++ₛ a).take n = x.take n := by\n  apply List.ext_getElem (by simp [h])\n  intro _ _ _; rw [List.getElem_take, take_get, get_append_left]\n\n"}
{"name":"Stream'.take_add","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nm n : Nat\na : Stream' α\n⊢ Eq (Stream'.take (HAdd.hAdd m n) a) (HAppend.hAppend (Stream'.take m a) (Stream'.take n (Stream'.drop m a)))","decl":"lemma take_add : a.take (m + n) = a.take m ++ (a.drop m).take n := by\n  apply append_left_injective _ _ (a.drop (m + n)) ((a.drop m).drop n) <;>\n    simp [- drop_drop]\n\n"}
{"name":"Stream'.take_prefix_take_left","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nm n : Nat\na : Stream' α\nh : LE.le m n\n⊢ (Stream'.take m a).IsPrefix (Stream'.take n a)","decl":"@[gcongr] lemma take_prefix_take_left (h : m ≤ n) : a.take m <+: a.take n := by\n  rw [(by simp [h] : a.take m = (a.take n).take m)]\n  apply List.take_prefix\n\n"}
{"name":"Stream'.take_prefix","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nm n : Nat\na : Stream' α\n⊢ Iff ((Stream'.take m a).IsPrefix (Stream'.take n a)) (LE.le m n)","decl":"@[simp] lemma take_prefix : a.take m <+: a.take n ↔ m ≤ n :=\n  ⟨fun h ↦ by simpa using h.length_le, take_prefix_take_left m n a⟩\n\n"}
{"name":"Stream'.map_take","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nn : Nat\na : Stream' α\nf : α → β\n⊢ Eq (List.map f (Stream'.take n a)) (Stream'.take n (Stream'.map f a))","decl":"lemma map_take (f : α → β) : (a.take n).map f = (a.map f).take n := by\n  apply List.ext_getElem <;> simp\n\n"}
{"name":"Stream'.take_drop","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nm n : Nat\na : Stream' α\n⊢ Eq (Stream'.take n (Stream'.drop m a)) (List.drop m (Stream'.take (HAdd.hAdd m n) a))","decl":"lemma take_drop : (a.drop m).take n = (a.take (m + n)).drop m := by\n  apply List.ext_getElem <;> simp\n\n"}
{"name":"Stream'.drop_append_of_le_length","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\nx : List α\na : Stream' α\nh : LE.le n x.length\n⊢ Eq (Stream'.drop n (Stream'.appendStream' x a)) (Stream'.appendStream' (List.drop n x) a)","decl":"lemma drop_append_of_le_length (h : n ≤ x.length) :\n    (x ++ₛ a).drop n = x.drop n ++ₛ a := by\n  obtain ⟨m, hm⟩ := Nat.exists_eq_add_of_le h\n  ext k; rcases lt_or_ge k m with _ | hk\n  · rw [get_drop, get_append_left, get_append_left, List.getElem_drop]; simpa [hm]\n  · obtain ⟨p, rfl⟩ := Nat.exists_eq_add_of_le hk\n    have hm' : m = (x.drop n).length := by simp [hm]\n    simp_rw [get_drop, ← Nat.add_assoc, ← hm, get_append_right, hm', get_append_right]\n\n-- Take theorem reduces a proof of equality of infinite streams to an\n-- induction over all their finite approximations.\n"}
{"name":"Stream'.take_theorem","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns₁ s₂ : Stream' α\na✝ : ∀ (n : Nat), Eq (Stream'.take n s₁) (Stream'.take n s₂)\n⊢ Eq s₁ s₂","decl":"theorem take_theorem (s₁ s₂ : Stream' α) : (∀ n : ℕ, take n s₁ = take n s₂) → s₁ = s₂ := by\n  intro h; apply Stream'.ext; intro n\n  induction' n with n _\n  · have aux := h 1\n    simp? [take] at aux says\n      simp only [take, List.cons.injEq, and_true] at aux\n    exact aux\n  · have h₁ : some (get s₁ (succ n)) = some (get s₂ (succ n)) := by\n      rw [← get?_take_succ, ← get?_take_succ, h (succ (succ n))]\n    injection h₁\n\n"}
{"name":"Stream'.cycle_g_cons","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na a₁ : α\nl₁ : List α\na₀ : α\nl₀ : List α\n⊢ Eq (Stream'.cycleG { fst := a, snd := { fst := List.cons a₁ l₁, snd := { fst := a₀, snd := l₀ } } }) { fst := a₁, snd := { fst := l₁, snd := { fst := a₀, snd := l₀ } } }","decl":"protected theorem cycle_g_cons (a : α) (a₁ : α) (l₁ : List α) (a₀ : α) (l₀ : List α) :\n    Stream'.cycleG (a, a₁::l₁, a₀, l₀) = (a₁, l₁, a₀, l₀) :=\n  rfl\n\n"}
{"name":"Stream'.cycle_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq (Stream'.cycle l h) (Stream'.appendStream' l (Stream'.cycle l h))","decl":"theorem cycle_eq : ∀ (l : List α) (h : l ≠ []), cycle l h = l ++ₛ cycle l h\n  | [], h => absurd rfl h\n  | List.cons a l, _ =>\n    have gen : ∀ l' a', corec Stream'.cycleF Stream'.cycleG (a', l', a, l) =\n        (a'::l') ++ₛ corec Stream'.cycleF Stream'.cycleG (a, l, a, l) := by\n      intro l'\n      induction' l' with a₁ l₁ ih\n      · intros\n        rw [corec_eq]\n        rfl\n      · intros\n        rw [corec_eq, Stream'.cycle_g_cons, ih a₁]\n        rfl\n    gen l a\n\n"}
{"name":"Stream'.mem_cycle","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nl : List α\nh : Ne l List.nil\na✝ : Membership.mem l a\n⊢ Membership.mem (Stream'.cycle l h) a","decl":"theorem mem_cycle {a : α} {l : List α} : ∀ h : l ≠ [], a ∈ l → a ∈ cycle l h := fun h ainl => by\n  rw [cycle_eq]; exact mem_append_stream_left _ ainl\n\n"}
{"name":"Stream'.cycle_singleton","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\n⊢ Eq (Stream'.cycle (List.cons a List.nil) ⋯) (Stream'.const a)","decl":"@[simp]\ntheorem cycle_singleton (a : α) : cycle [a] (by simp) = const a :=\n  coinduction rfl fun β fr ch => by rwa [cycle_eq, const_eq]\n\n"}
{"name":"Stream'.tails_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.tails (Stream'.cons s.tail s.tail.tails)","decl":"theorem tails_eq (s : Stream' α) : tails s = tail s::tails (tail s) := by\n  unfold tails; rw [corec_eq]; rfl\n\n"}
{"name":"Stream'.get_tails","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.tails.get n) (Stream'.drop n s.tail)","decl":"@[simp]\ntheorem get_tails : ∀ (n : ℕ) (s : Stream' α), get (tails s) n = drop n (tail s) := by\n  intro n; induction' n with n' ih\n  · intros\n    rfl\n  · intro s\n    rw [get_succ, drop_succ, tails_eq, tail_cons, ih]\n\n"}
{"name":"Stream'.tails_eq_iterate","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.tails (Stream'.iterate Stream'.tail s.tail)","decl":"theorem tails_eq_iterate (s : Stream' α) : tails s = iterate tail (tail s) :=\n  rfl\n\n"}
{"name":"Stream'.inits_core_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nl : List α\ns : Stream' α\n⊢ Eq (Stream'.initsCore l s) (Stream'.cons l (Stream'.initsCore (HAppend.hAppend l (List.cons s.head List.nil)) s.tail))","decl":"theorem inits_core_eq (l : List α) (s : Stream' α) :\n    initsCore l s = l::initsCore (l ++ [head s]) (tail s) := by\n    unfold initsCore corecOn\n    rw [corec_eq]\n\n"}
{"name":"Stream'.tail_inits","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.inits.tail (Stream'.initsCore (List.cons s.head (List.cons s.tail.head List.nil)) s.tail.tail)","decl":"theorem tail_inits (s : Stream' α) :\n    tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s)) := by\n    unfold inits\n    rw [inits_core_eq]; rfl\n\n"}
{"name":"Stream'.inits_tail","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.tail.inits (Stream'.initsCore (List.cons s.tail.head List.nil) s.tail.tail)","decl":"theorem inits_tail (s : Stream' α) : inits (tail s) = initsCore [head (tail s)] (tail (tail s)) :=\n  rfl\n\n"}
{"name":"Stream'.cons_get_inits_core","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\na : α\nn : Nat\nl : List α\ns : Stream' α\n⊢ Eq (List.cons a ((Stream'.initsCore l s).get n)) ((Stream'.initsCore (List.cons a l) s).get n)","decl":"theorem cons_get_inits_core :\n    ∀ (a : α) (n : ℕ) (l : List α) (s : Stream' α),\n      (a::get (initsCore l s) n) = get (initsCore (a::l) s) n := by\n  intro a n\n  induction' n with n' ih\n  · intros\n    rfl\n  · intro l s\n    rw [get_succ, inits_core_eq, tail_cons, ih, inits_core_eq (a::l) s]\n    rfl\n\n"}
{"name":"Stream'.get_inits","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nn : Nat\ns : Stream' α\n⊢ Eq (s.inits.get n) (Stream'.take n.succ s)","decl":"@[simp]\ntheorem get_inits : ∀ (n : ℕ) (s : Stream' α), get (inits s) n = take (succ n) s := by\n  intro n; induction' n with n' ih\n  · intros\n    rfl\n  · intros\n    rw [get_succ, take_succ, ← ih, tail_inits, inits_tail, cons_get_inits_core]\n\n"}
{"name":"Stream'.inits_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq s.inits (Stream'.cons (List.cons s.head List.nil) (Stream'.map (List.cons s.head) s.tail.inits))","decl":"theorem inits_eq (s : Stream' α) :\n    inits s = [head s]::map (List.cons (head s)) (inits (tail s)) := by\n  apply Stream'.ext; intro n\n  cases n\n  · rfl\n  · rw [get_inits, get_succ, tail_cons, get_map, get_inits]\n    rfl\n\n"}
{"name":"Stream'.zip_inits_tails","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq (Stream'.zip Stream'.appendStream' s.inits s.tails) (Stream'.const s)","decl":"theorem zip_inits_tails (s : Stream' α) : zip appendStream' (inits s) (tails s) = const s := by\n  apply Stream'.ext; intro n\n  rw [get_zip, get_inits, get_tails, get_const, take_succ, cons_append_stream, append_take_drop,\n    Stream'.eta]\n\n"}
{"name":"Stream'.identity","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\ns : Stream' α\n⊢ Eq ((Stream'.pure id).apply s) s","decl":"theorem identity (s : Stream' α) : pure id ⊛ s = s :=\n  rfl\n\n"}
{"name":"Stream'.composition","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nδ : Type w\ng : Stream' (β → δ)\nf : Stream' (α → β)\ns : Stream' α\n⊢ Eq ((((Stream'.pure Function.comp).apply g).apply f).apply s) (g.apply (f.apply s))","decl":"theorem composition (g : Stream' (β → δ)) (f : Stream' (α → β)) (s : Stream' α) :\n    pure comp ⊛ g ⊛ f ⊛ s = g ⊛ (f ⊛ s) :=\n  rfl\n\n"}
{"name":"Stream'.homomorphism","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq ((Stream'.pure f).apply (Stream'.pure a)) (Stream'.pure (f a))","decl":"theorem homomorphism (f : α → β) (a : α) : pure f ⊛ pure a = pure (f a) :=\n  rfl\n\n"}
{"name":"Stream'.interchange","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nfs : Stream' (α → β)\na : α\n⊢ Eq (fs.apply (Stream'.pure a)) ((Stream'.pure fun f => f a).apply fs)","decl":"theorem interchange (fs : Stream' (α → β)) (a : α) :\n    fs ⊛ pure a = (pure fun f : α → β => f a) ⊛ fs :=\n  rfl\n\n"}
{"name":"Stream'.map_eq_apply","module":"Mathlib.Data.Stream.Init","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream' α\n⊢ Eq (Stream'.map f s) ((Stream'.pure f).apply s)","decl":"theorem map_eq_apply (f : α → β) (s : Stream' α) : map f s = pure f ⊛ s :=\n  rfl\n\n"}
{"name":"Stream'.get_nats","module":"Mathlib.Data.Stream.Init","initialProofState":"n : Nat\n⊢ Eq (Stream'.nats.get n) n","decl":"theorem get_nats (n : ℕ) : get nats n = n :=\n  rfl\n\n"}
{"name":"Stream'.nats_eq","module":"Mathlib.Data.Stream.Init","initialProofState":"⊢ Eq Stream'.nats (Stream'.cons 0 (Stream'.map Nat.succ Stream'.nats))","decl":"theorem nats_eq : nats = cons 0 (map succ nats) := by\n  apply Stream'.ext; intro n\n  cases n\n  · rfl\n  rw [get_succ]; rfl\n\n"}
