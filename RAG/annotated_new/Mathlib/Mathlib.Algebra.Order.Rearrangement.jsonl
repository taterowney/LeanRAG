{"name":"MonovaryOn.sum_smul_comp_perm_le_sum_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HSMul.hSMul (f i) (g (σ i))) (s.sum fun i => HSMul.hSMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_smul_comp_perm_le_sum_smul (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f i • g (σ i) ≤ ∑ i ∈ s, f i • g i := by\n  classical\n  revert hσ σ hfg\n  -- Porting note: Specify `p` to get around `∀ {σ}` in the current goal.\n  apply Finset.induction_on_max_value (fun i ↦ toLex (g i, f i))\n    (p := fun t ↦ ∀ {σ : Perm ι}, MonovaryOn f g t → {x | σ x ≠ x} ⊆ t →\n      ∑ i ∈ t, f i • g (σ i) ≤ ∑ i ∈ t, f i • g i) s\n  · simp only [le_rfl, Finset.sum_empty, imp_true_iff]\n  intro a s has hamax hind σ hfg hσ\n  set τ : Perm ι := σ.trans (swap a (σ a)) with hτ\n  have hτs : {x | τ x ≠ x} ⊆ s := by\n    intro x hx\n    simp only [τ, Ne, Set.mem_setOf_eq, Equiv.coe_trans, Equiv.swap_comp_apply] at hx\n    split_ifs at hx with h₁ h₂\n    · obtain rfl | hax := eq_or_ne x a\n      · contradiction\n      · exact mem_of_mem_insert_of_ne (hσ fun h ↦ hax <| h.symm.trans h₁) hax\n    · exact (hx <| σ.injective h₂.symm).elim\n    · exact mem_of_mem_insert_of_ne (hσ hx) (ne_of_apply_ne _ h₂)\n  specialize hind (hfg.subset <| subset_insert _ _) hτs\n  simp_rw [sum_insert has]\n  refine le_trans ?_ (add_le_add_left hind _)\n  obtain hσa | hσa := eq_or_ne a (σ a)\n  · rw [hτ, ← hσa, swap_self, trans_refl]\n  have h1s : σ⁻¹ a ∈ s := by\n    rw [Ne, ← inv_eq_iff_eq] at hσa\n    refine mem_of_mem_insert_of_ne (hσ fun h ↦ hσa ?_) hσa\n    rwa [apply_inv_self, eq_comm] at h\n  simp only [← s.sum_erase_add _ h1s, add_comm]\n  rw [← add_assoc, ← add_assoc]\n  simp only [hτ, swap_apply_left, Function.comp_apply, Equiv.coe_trans, apply_inv_self]\n  refine add_le_add (smul_add_smul_le_smul_add_smul' ?_ ?_) (sum_congr rfl fun x hx ↦ ?_).le\n  · specialize hamax (σ⁻¹ a) h1s\n    rw [Prod.Lex.toLex_le_toLex] at hamax\n    cases' hamax with hamax hamax\n    · exact hfg (mem_insert_of_mem h1s) (mem_insert_self _ _) hamax\n    · exact hamax.2\n  · specialize hamax (σ a) (mem_of_mem_insert_of_ne (hσ <| σ.injective.ne hσa.symm) hσa.symm)\n    rw [Prod.Lex.toLex_le_toLex] at hamax\n    cases' hamax with hamax hamax\n    · exact hamax.le\n    · exact hamax.1.le\n  · rw [mem_erase, Ne, eq_inv_iff_eq] at hx\n    rw [swap_apply_of_ne_of_ne hx.1 (σ.injective.ne _)]\n    rintro rfl\n    exact has hx.2\n\n"}
{"name":"AntivaryOn.sum_smul_le_sum_smul_comp_perm","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HSMul.hSMul (f i) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g (σ i)))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_smul_le_sum_smul_comp_perm (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f i • g i ≤ ∑ i ∈ s, f i • g (σ i) :=\n  hfg.dual_right.sum_smul_comp_perm_le_sum_smul hσ\n\n"}
{"name":"MonovaryOn.sum_comp_perm_smul_le_sum_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f (σ i) • g i ≤ ∑ i ∈ s, f i • g i := by\n  convert hfg.sum_smul_comp_perm_le_sum_smul\n    (show { x | σ⁻¹ x ≠ x } ⊆ s by simp only [set_support_inv_eq, hσ]) using 1\n  exact σ.sum_comp' s (fun i j ↦ f i • g j) hσ\n\n"}
{"name":"AntivaryOn.sum_smul_le_sum_comp_perm_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HSMul.hSMul (f i) (g i)) (s.sum fun i => HSMul.hSMul (f (σ i)) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_smul_le_sum_comp_perm_smul (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f i • g i ≤ ∑ i ∈ s, f (σ i) • g i :=\n  hfg.dual_right.sum_comp_perm_smul_le_sum_smul hσ\n\n"}
{"name":"Monovary.sum_smul_comp_perm_le_sum_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ LE.le (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i))) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_smul_comp_perm_le_sum_smul (hfg : Monovary f g) :\n    ∑ i, f i • g (σ i) ≤ ∑ i, f i • g i :=\n  (hfg.monovaryOn _).sum_smul_comp_perm_le_sum_smul fun _ _ ↦ mem_univ _\n\n"}
{"name":"Antivary.sum_smul_le_sum_smul_comp_perm","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ LE.le (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i)))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_smul_le_sum_smul_comp_perm (hfg : Antivary f g) :\n    ∑ i, f i • g i ≤ ∑ i, f i • g (σ i) :=\n  (hfg.antivaryOn _).sum_smul_le_sum_smul_comp_perm fun _ _ ↦ mem_univ _\n\n"}
{"name":"Monovary.sum_comp_perm_smul_le_sum_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ LE.le (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `f`. -/\ntheorem Monovary.sum_comp_perm_smul_le_sum_smul (hfg : Monovary f g) :\n    ∑ i, f (σ i) • g i ≤ ∑ i, f i • g i :=\n  (hfg.monovaryOn _).sum_comp_perm_smul_le_sum_smul fun _ _ ↦ mem_univ _\n\n"}
{"name":"Antivary.sum_smul_le_sum_comp_perm_smul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ LE.le (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_smul_le_sum_comp_perm_smul (hfg : Antivary f g) :\n    ∑ i, f i • g i ≤ ∑ i, f (σ i) • g i :=\n  (hfg.antivaryOn _).sum_smul_le_sum_comp_perm_smul fun _ _ ↦ mem_univ _\n\n"}
{"name":"MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HSMul.hSMul (f i) (g (σ i))) (s.sum fun i => HSMul.hSMul (f i) (g i))) (MonovaryOn f (Function.comp g ⇑σ) ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which monovary together on `s`, is unchanged by a permutation if and only if `f` and `g ∘ σ`\nmonovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g (σ i) = ∑ i ∈ s, f i • g i ↔ MonovaryOn f (g ∘ σ) s := by\n  classical\n  refine ⟨not_imp_not.1 fun h ↦ ?_, fun h ↦ (hfg.sum_smul_comp_perm_le_sum_smul hσ).antisymm ?_⟩\n  · rw [MonovaryOn] at h\n    push_neg at h\n    obtain ⟨x, hx, y, hy, hgxy, hfxy⟩ := h\n    set τ : Perm ι := (Equiv.swap x y).trans σ\n    have hτs : {x | τ x ≠ x} ⊆ s := by\n      refine (set_support_mul_subset σ <| swap x y).trans (Set.union_subset hσ fun z hz ↦ ?_)\n      obtain ⟨_, rfl | rfl⟩ := swap_apply_ne_self_iff.1 hz <;> assumption\n    refine ((hfg.sum_smul_comp_perm_le_sum_smul hτs).trans_lt' ?_).ne\n    obtain rfl | hxy := eq_or_ne x y\n    · cases lt_irrefl _ hfxy\n    simp only [τ, ← s.sum_erase_add _ hx,\n      ← (s.erase x).sum_erase_add _ (mem_erase.2 ⟨hxy.symm, hy⟩),\n      add_assoc, Equiv.coe_trans, Function.comp_apply, swap_apply_right, swap_apply_left]\n    refine add_lt_add_of_le_of_lt (Finset.sum_congr rfl fun z hz ↦ ?_).le\n      (smul_add_smul_lt_smul_add_smul hfxy hgxy)\n    simp_rw [mem_erase] at hz\n    rw [swap_apply_of_ne_of_ne hz.2.1 hz.1]\n  · convert h.sum_smul_comp_perm_le_sum_smul ((set_support_inv_eq _).subset.trans hσ) using 1\n    simp_rw [Function.comp_apply, apply_inv_self]\n\n"}
{"name":"AntivaryOn.sum_smul_comp_perm_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HSMul.hSMul (f i) (g (σ i))) (s.sum fun i => HSMul.hSMul (f i) (g i))) (AntivaryOn f (Function.comp g ⇑σ) ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together on `s`, is unchanged by a permutation if and only if `f` and `g ∘ σ`\nantivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_smul_comp_perm_eq_sum_smul_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g (σ i) = ∑ i ∈ s, f i • g i ↔ AntivaryOn f (g ∘ σ) s :=\n  (hfg.dual_right.sum_smul_comp_perm_eq_sum_smul_iff hσ).trans monovaryOn_toDual_right\n\n"}
{"name":"MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g i))) (MonovaryOn (Function.comp f ⇑σ) g ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which monovary together on `s`, is unchanged by a permutation if and only if `f ∘ σ` and `g`\nmonovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) • g i = ∑ i ∈ s, f i • g i ↔ MonovaryOn (f ∘ σ) g s := by\n  have hσinv : { x | σ⁻¹ x ≠ x } ⊆ s := (set_support_inv_eq _).subset.trans hσ\n  refine (Iff.trans ?_ <| hfg.sum_smul_comp_perm_eq_sum_smul_iff hσinv).trans\n    ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · apply eq_iff_eq_cancel_right.2\n    rw [σ.sum_comp' s (fun i j ↦ f i • g j) hσ]\n    congr\n  · convert h.comp_right σ\n    · rw [comp_assoc, inv_def, symm_comp_self, comp_id]\n    · rw [σ.eq_preimage_iff_image_eq, Set.image_perm hσ]\n  · convert h.comp_right σ.symm\n    · rw [comp_assoc, self_comp_symm, comp_id]\n    · rw [σ.symm.eq_preimage_iff_image_eq]\n      exact Set.image_perm hσinv\n\n"}
{"name":"AntivaryOn.sum_comp_perm_smul_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g i))) (AntivaryOn (Function.comp f ⇑σ) g ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together on `s`, is unchanged by a permutation if and only if `f ∘ σ` and `g`\nantivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_comp_perm_smul_eq_sum_smul_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) • g i = ∑ i ∈ s, f i • g i ↔ AntivaryOn (f ∘ σ) g s :=\n  (hfg.dual_right.sum_comp_perm_smul_eq_sum_smul_iff hσ).trans monovaryOn_toDual_right\n\n"}
{"name":"Monovary.sum_smul_comp_perm_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i))) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Monovary f (Function.comp g ⇑σ))","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_smul_comp_perm_eq_sum_smul_iff (hfg : Monovary f g) :\n    ∑ i, f i • g (σ i) = ∑ i, f i • g i ↔ Monovary f (g ∘ σ) := by\n  simp [(hfg.monovaryOn _).sum_smul_comp_perm_eq_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Monovary.sum_comp_perm_smul_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Monovary (Function.comp f ⇑σ) g)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_comp_perm_smul_eq_sum_smul_iff (hfg : Monovary f g) :\n    ∑ i, f (σ i) • g i = ∑ i, f i • g i ↔ Monovary (f ∘ σ) g := by\n  simp [(hfg.monovaryOn _).sum_comp_perm_smul_eq_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Antivary.sum_smul_comp_perm_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i))) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Antivary f (Function.comp g ⇑σ))","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_smul_comp_perm_eq_sum_smul_iff (hfg : Antivary f g) :\n    ∑ i, f i • g (σ i) = ∑ i, f i • g i ↔ Antivary f (g ∘ σ) := by\n  simp [(hfg.antivaryOn _).sum_smul_comp_perm_eq_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Antivary.sum_comp_perm_smul_eq_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Antivary (Function.comp f ⇑σ) g)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_comp_perm_smul_eq_sum_smul_iff (hfg : Antivary f g) :\n    ∑ i, f (σ i) • g i = ∑ i, f i • g i ↔ Antivary (f ∘ σ) g := by\n  simp [(hfg.antivaryOn _).sum_comp_perm_smul_eq_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HSMul.hSMul (f i) (g (σ i))) (s.sum fun i => HSMul.hSMul (f i) (g i))) (Not (MonovaryOn f (Function.comp g ⇑σ) ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together on `s`, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g (σ i) < ∑ i ∈ s, f i • g i ↔ ¬MonovaryOn f (g ∘ σ) s := by\n  simp [← hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ, lt_iff_le_and_ne,\n    hfg.sum_smul_comp_perm_le_sum_smul hσ]\n\n"}
{"name":"AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HSMul.hSMul (f i) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g (σ i)))) (Not (AntivaryOn f (Function.comp g ⇑σ) ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together on `s`, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not antivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g i < ∑ i ∈ s, f i • g (σ i) ↔ ¬AntivaryOn f (g ∘ σ) s := by\n  simp [← hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ, lt_iff_le_and_ne, eq_comm,\n    hfg.sum_smul_le_sum_smul_comp_perm hσ]\n\n"}
{"name":"MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (s.sum fun i => HSMul.hSMul (f i) (g i))) (Not (MonovaryOn (Function.comp f ⇑σ) g ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together on `s`, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not monovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) • g i < ∑ i ∈ s, f i • g i ↔ ¬MonovaryOn (f ∘ σ) g s := by\n  simp [← hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ, lt_iff_le_and_ne,\n    hfg.sum_comp_perm_smul_le_sum_smul hσ]\n\n"}
{"name":"AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : ExistsAddOfLE α\ninst✝² : LinearOrderedCancelAddCommMonoid β\ninst✝¹ : Module α β\ninst✝ : PosSMulStrictMono α β\ns : Finset ι\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HSMul.hSMul (f i) (g i)) (s.sum fun i => HSMul.hSMul (f (σ i)) (g i))) (Not (AntivaryOn (Function.comp f ⇑σ) g ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together on `s`, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not antivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g i < ∑ i ∈ s, f (σ i) • g i ↔ ¬AntivaryOn (f ∘ σ) g s := by\n  simp [← hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ, eq_comm, lt_iff_le_and_ne,\n    hfg.sum_smul_le_sum_comp_perm_smul hσ]\n\n"}
{"name":"Monovary.sum_smul_comp_perm_lt_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i))) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Not (Monovary f (Function.comp g ⇑σ)))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_smul_comp_perm_lt_sum_smul_iff (hfg : Monovary f g) :\n    ∑ i, f i • g (σ i) < ∑ i, f i • g i ↔ ¬Monovary f (g ∘ σ) := by\n  simp [(hfg.monovaryOn _).sum_smul_comp_perm_lt_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Monovary.sum_comp_perm_smul_lt_sum_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i))) (Not (Monovary (Function.comp f ⇑σ) g))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_comp_perm_smul_lt_sum_smul_iff (hfg : Monovary f g) :\n    ∑ i, f (σ i) • g i < ∑ i, f i • g i ↔ ¬Monovary (f ∘ σ) g := by\n  simp [(hfg.monovaryOn _).sum_comp_perm_smul_lt_sum_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Antivary.sum_smul_lt_sum_smul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i)))) (Not (Antivary f (Function.comp g ⇑σ)))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_smul_lt_sum_smul_comp_perm_iff (hfg : Antivary f g) :\n    ∑ i, f i • g i < ∑ i, f i • g (σ i) ↔ ¬Antivary f (g ∘ σ) := by\n  simp [(hfg.antivaryOn _).sum_smul_lt_sum_smul_comp_perm_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"Antivary.sum_smul_lt_sum_comp_perm_smul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : LinearOrderedCancelAddCommMonoid β\ninst✝² : Module α β\ninst✝¹ : PosSMulStrictMono α β\nσ : Equiv.Perm ι\nf : ι → α\ng : ι → β\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f (σ i)) (g i))) (Not (Antivary (Function.comp f ⇑σ) g))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_smul_lt_sum_comp_perm_smul_iff (hfg : Antivary f g) :\n    ∑ i, f i • g i < ∑ i, f (σ i) • g i ↔ ¬Antivary (f ∘ σ) g := by\n  simp [(hfg.antivaryOn _).sum_smul_lt_sum_comp_perm_smul_iff fun _ _ ↦ mem_univ _]\n\n"}
{"name":"MonovaryOn.sum_mul_comp_perm_le_sum_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g (σ i))) (s.sum fun i => HMul.hMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_mul_comp_perm_le_sum_mul (hfg : MonovaryOn f g s) (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i * g (σ i) ≤ ∑ i ∈ s, f i * g i :=\n  hfg.sum_smul_comp_perm_le_sum_smul hσ\n\n"}
{"name":"MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HMul.hMul (f i) (g (σ i))) (s.sum fun i => HMul.hMul (f i) (g i))) (MonovaryOn f (Function.comp g ⇑σ) ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together on `s`, is unchanged by a permutation if and only if `f` and `g ∘ σ`\nmonovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i * g (σ i) = ∑ i ∈ s, f i * g i ↔ MonovaryOn f (g ∘ σ) s :=\n  hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ\n\n"}
{"name":"MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HSMul.hSMul (f i) (g (σ i))) (s.sum fun i => HSMul.hSMul (f i) (g i))) (Not (MonovaryOn f (Function.comp g ⇑σ) ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together on `s`, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i • g (σ i) < ∑ i ∈ s, f i • g i ↔ ¬MonovaryOn f (g ∘ σ) s :=\n  hfg.sum_smul_comp_perm_lt_sum_smul_iff hσ\n\n"}
{"name":"MonovaryOn.sum_comp_perm_mul_le_sum_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HMul.hMul (f (σ i)) (g i)) (s.sum fun i => HMul.hMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_mul_le_sum_mul (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f (σ i) * g i ≤ ∑ i ∈ s, f i * g i :=\n  hfg.sum_comp_perm_smul_le_sum_smul hσ\n\n"}
{"name":"MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HMul.hMul (f (σ i)) (g i)) (s.sum fun i => HMul.hMul (f i) (g i))) (MonovaryOn (Function.comp f ⇑σ) g ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together on `s`, is unchanged by a permutation if and only if `f ∘ σ` and `g`\nmonovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) * g i = ∑ i ∈ s, f i * g i ↔ MonovaryOn (f ∘ σ) g s :=\n  hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ\n\n"}
{"name":"MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : MonovaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HMul.hMul (f (σ i)) (g i)) (s.sum fun i => HMul.hMul (f i) (g i))) (Not (MonovaryOn (Function.comp f ⇑σ) g ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together on `s`, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not monovary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff (hfg : MonovaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) * g i < ∑ i ∈ s, f i * g i ↔ ¬MonovaryOn (f ∘ σ) g s :=\n  hfg.sum_comp_perm_smul_lt_sum_smul_iff hσ\n\n"}
{"name":"AntivaryOn.sum_mul_le_sum_mul_comp_perm","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (s.sum fun i => HMul.hMul (f i) (g (σ i)))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_mul_le_sum_mul_comp_perm (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f i * g i ≤ ∑ i ∈ s, f i * g (σ i) :=\n  hfg.sum_smul_le_sum_smul_comp_perm hσ\n\n"}
{"name":"AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HMul.hMul (f i) (g (σ i))) (s.sum fun i => HMul.hMul (f i) (g i))) (AntivaryOn f (Function.comp g ⇑σ) ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together on `s`, is unchanged by a permutation if and only if `f` and `g ∘ σ`\nantivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i * g (σ i) = ∑ i ∈ s, f i * g i ↔ AntivaryOn f (g ∘ σ) s :=\n  hfg.sum_smul_comp_perm_eq_sum_smul_iff hσ\n\n"}
{"name":"AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HMul.hMul (f i) (g i)) (s.sum fun i => HMul.hMul (f i) (g (σ i)))) (Not (AntivaryOn f (Function.comp g ⇑σ) ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together on `s`, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not antivary together on `s`. Stated by permuting the entries of `g`. -/\ntheorem AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i * g i < ∑ i ∈ s, f i * g (σ i) ↔ ¬AntivaryOn f (g ∘ σ) s :=\n  hfg.sum_smul_lt_sum_smul_comp_perm_iff hσ\n\n"}
{"name":"AntivaryOn.sum_mul_le_sum_comp_perm_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (s.sum fun i => HMul.hMul (f (σ i)) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_mul_le_sum_comp_perm_mul (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) : ∑ i ∈ s, f i * g i ≤ ∑ i ∈ s, f (σ i) * g i :=\n  hfg.sum_smul_le_sum_comp_perm_smul hσ\n\n"}
{"name":"AntivaryOn.sum_comp_perm_mul_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (Eq (s.sum fun i => HMul.hMul (f (σ i)) (g i)) (s.sum fun i => HMul.hMul (f i) (g i))) (AntivaryOn (Function.comp f ⇑σ) g ↑s)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together on `s`, is unchanged by a permutation if and only if `f ∘ σ` and `g`\nantivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_comp_perm_mul_eq_sum_mul_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f (σ i) * g i = ∑ i ∈ s, f i * g i ↔ AntivaryOn (f ∘ σ) g s :=\n  hfg.sum_comp_perm_smul_eq_sum_smul_iff hσ\n\n"}
{"name":"AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : ExistsAddOfLE α\ns : Finset ι\nσ : Equiv.Perm ι\nf g : ι → α\nhfg : AntivaryOn f g ↑s\nhσ : HasSubset.Subset (setOf fun x => Ne (σ x) x) ↑s\n⊢ Iff (LT.lt (s.sum fun i => HMul.hMul (f i) (g i)) (s.sum fun i => HMul.hMul (f (σ i)) (g i))) (Not (AntivaryOn (Function.comp f ⇑σ) g ↑s))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together on `s`, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not antivary together on `s`. Stated by permuting the entries of `f`. -/\ntheorem AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff (hfg : AntivaryOn f g s)\n    (hσ : {x | σ x ≠ x} ⊆ s) :\n    ∑ i ∈ s, f i * g i < ∑ i ∈ s, f (σ i) * g i ↔ ¬AntivaryOn (f ∘ σ) g s :=\n  hfg.sum_smul_lt_sum_comp_perm_smul_iff hσ\n\n"}
{"name":"Monovary.sum_mul_comp_perm_le_sum_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ LE.le (Finset.univ.sum fun i => HMul.hMul (f i) (g (σ i))) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_mul_comp_perm_le_sum_mul (hfg : Monovary f g) :\n    ∑ i, f i * g (σ i) ≤ ∑ i, f i * g i :=\n  hfg.sum_smul_comp_perm_le_sum_smul\n\n"}
{"name":"Monovary.sum_mul_comp_perm_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HMul.hMul (f i) (g (σ i))) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Monovary f (Function.comp g ⇑σ))","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_mul_comp_perm_eq_sum_mul_iff (hfg : Monovary f g) :\n    ∑ i, f i * g (σ i) = ∑ i, f i * g i ↔ Monovary f (g ∘ σ) :=\n  hfg.sum_smul_comp_perm_eq_sum_smul_iff\n\n"}
{"name":"Monovary.sum_mul_comp_perm_lt_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HMul.hMul (f i) (g (σ i))) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Not (Monovary f (Function.comp g ⇑σ)))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_mul_comp_perm_lt_sum_mul_iff (hfg : Monovary f g) :\n    ∑ i, f i * g (σ i) < ∑ i, f i * g i ↔ ¬Monovary f (g ∘ σ) :=\n  hfg.sum_smul_comp_perm_lt_sum_smul_iff\n\n"}
{"name":"Monovary.sum_comp_perm_mul_le_sum_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ LE.le (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `f`. -/\ntheorem Monovary.sum_comp_perm_mul_le_sum_mul (hfg : Monovary f g) :\n    ∑ i, f (σ i) * g i ≤ ∑ i, f i * g i :=\n  hfg.sum_comp_perm_smul_le_sum_smul\n\n"}
{"name":"Monovary.sum_comp_perm_mul_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Monovary (Function.comp f ⇑σ) g)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` monovary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_comp_perm_mul_eq_sum_mul_iff (hfg : Monovary f g) :\n    ∑ i, f (σ i) * g i = ∑ i, f i * g i ↔ Monovary (f ∘ σ) g :=\n  hfg.sum_comp_perm_smul_eq_sum_smul_iff\n\n"}
{"name":"Monovary.sum_comp_perm_mul_lt_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Monovary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Not (Monovary (Function.comp f ⇑σ) g))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not monovary together. Stated by permuting the entries of `g`. -/\ntheorem Monovary.sum_comp_perm_mul_lt_sum_mul_iff (hfg : Monovary f g) :\n    ∑ i, f (σ i) * g i < ∑ i, f i * g i ↔ ¬Monovary (f ∘ σ) g :=\n  hfg.sum_comp_perm_smul_lt_sum_smul_iff\n\n"}
{"name":"Antivary.sum_mul_le_sum_mul_comp_perm","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ LE.le (Finset.univ.sum fun i => HMul.hMul (f i) (g i)) (Finset.univ.sum fun i => HMul.hMul (f i) (g (σ i)))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_mul_le_sum_mul_comp_perm (hfg : Antivary f g) :\n    ∑ i, f i * g i ≤ ∑ i, f i * g (σ i) :=\n  hfg.sum_smul_le_sum_smul_comp_perm\n\n"}
{"name":"Antivary.sum_mul_eq_sum_mul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HMul.hMul (f i) (g (σ i))) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Antivary f (Function.comp g ⇑σ))","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` antivary\ntogether. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_mul_eq_sum_mul_comp_perm_iff (hfg : Antivary f g) :\n    ∑ i, f i * g (σ i) = ∑ i, f i * g i ↔ Antivary f (g ∘ σ) :=\n  hfg.sum_smul_comp_perm_eq_sum_smul_iff\n\n"}
{"name":"Antivary.sum_mul_lt_sum_mul_comp_perm_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HSMul.hSMul (f i) (g i)) (Finset.univ.sum fun i => HSMul.hSMul (f i) (g (σ i)))) (Not (Antivary f (Function.comp g ⇑σ)))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ∘ σ` do not antivary together. Stated by permuting the entries of `g`. -/\ntheorem Antivary.sum_mul_lt_sum_mul_comp_perm_iff (hfg : Antivary f g) :\n    ∑ i, f i • g i < ∑ i, f i • g (σ i) ↔ ¬Antivary f (g ∘ σ) :=\n  hfg.sum_smul_lt_sum_smul_comp_perm_iff\n\n"}
{"name":"Antivary.sum_mul_le_sum_comp_perm_mul","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ LE.le (Finset.univ.sum fun i => HMul.hMul (f i) (g i)) (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i))","decl":"/-- **Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_mul_le_sum_comp_perm_mul (hfg : Antivary f g) :\n    ∑ i, f i * g i ≤ ∑ i, f (σ i) * g i :=\n  hfg.sum_smul_le_sum_comp_perm_smul\n\n"}
{"name":"Antivary.sum_comp_perm_mul_eq_sum_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (Eq (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i)) (Finset.univ.sum fun i => HMul.hMul (f i) (g i))) (Antivary (Function.comp f ⇑σ) g)","decl":"/-- **Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f ∘ σ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_comp_perm_mul_eq_sum_mul_iff (hfg : Antivary f g) :\n    ∑ i, f (σ i) * g i = ∑ i, f i * g i ↔ Antivary (f ∘ σ) g :=\n  hfg.sum_comp_perm_smul_eq_sum_smul_iff\n\n"}
{"name":"Antivary.sum_mul_lt_sum_comp_perm_mul_iff","module":"Mathlib.Algebra.Order.Rearrangement","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : ExistsAddOfLE α\nσ : Equiv.Perm ι\nf g : ι → α\ninst✝ : Fintype ι\nhfg : Antivary f g\n⊢ Iff (LT.lt (Finset.univ.sum fun i => HMul.hMul (f i) (g i)) (Finset.univ.sum fun i => HMul.hMul (f (σ i)) (g i))) (Not (Antivary (Function.comp f ⇑σ) g))","decl":"/-- **Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ∘ σ` and `g` do not antivary together. Stated by permuting the entries of `f`. -/\ntheorem Antivary.sum_mul_lt_sum_comp_perm_mul_iff (hfg : Antivary f g) :\n    ∑ i, f i * g i < ∑ i, f (σ i) * g i ↔ ¬Antivary (f ∘ σ) g :=\n  hfg.sum_smul_lt_sum_comp_perm_smul_iff\n\n"}
