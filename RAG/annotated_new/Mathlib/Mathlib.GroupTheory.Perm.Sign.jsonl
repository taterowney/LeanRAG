{"name":"Equiv.Perm.swap_induction_on","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nP : Equiv.Perm α → Prop\nf : Equiv.Perm α\na✝¹ : P 1\na✝ : ∀ (f : Equiv.Perm α) (x y : α), Ne x y → P f → P (HMul.hMul (Equiv.swap x y) f)\n⊢ P f","decl":"/-- An induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. -/\n@[elab_as_elim]\ntheorem swap_induction_on [Finite α] {P : Perm α → Prop} (f : Perm α) :\n    P 1 → (∀ f x y, x ≠ y → P f → P (swap x y * f)) → P f := by\n  cases nonempty_fintype α\n  cases' (truncSwapFactors f).out with l hl\n  induction' l with g l ih generalizing f\n  · simp +contextual only [hl.left.symm, List.prod_nil, forall_true_iff]\n  · intro h1 hmul_swap\n    rcases hl.2 g (by simp) with ⟨x, y, hxy⟩\n    rw [← hl.1, List.prod_cons, hxy.2]\n    exact\n      hmul_swap _ _ _ hxy.1\n        (ih _ ⟨rfl, fun v hv => hl.2 _ (List.mem_cons_of_mem _ hv)⟩ h1 hmul_swap)\n\n"}
{"name":"Equiv.Perm.mclosure_isSwap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\n⊢ Eq (Submonoid.closure (setOf fun σ => σ.IsSwap)) Top.top","decl":"theorem mclosure_isSwap [Finite α] : Submonoid.closure { σ : Perm α | IsSwap σ } = ⊤ := by\n  cases nonempty_fintype α\n  refine top_unique fun x _ ↦ ?_\n  obtain ⟨h1, h2⟩ := Subtype.mem (truncSwapFactors x).out\n  rw [← h1]\n  exact Submonoid.list_prod_mem _ fun y hy ↦ Submonoid.subset_closure (h2 y hy)\n\n"}
{"name":"Equiv.Perm.closure_isSwap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\n⊢ Eq (Subgroup.closure (setOf fun σ => σ.IsSwap)) Top.top","decl":"theorem closure_isSwap [Finite α] : Subgroup.closure { σ : Perm α | IsSwap σ } = ⊤ :=\n  Subgroup.closure_eq_top_of_mclosure_eq_top mclosure_isSwap\n\n"}
{"name":"Equiv.Perm.mclosure_swap_castSucc_succ","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\n⊢ Eq (Submonoid.closure (Set.range fun i => Equiv.swap i.castSucc i.succ)) Top.top","decl":"/-- Every finite symmetric group is generated by transpositions of adjacent elements. -/\ntheorem mclosure_swap_castSucc_succ (n : ℕ) :\n    Submonoid.closure (Set.range fun i : Fin n ↦ swap i.castSucc i.succ) = ⊤ := by\n  apply top_unique\n  rw [← mclosure_isSwap, Submonoid.closure_le]\n  rintro _ ⟨i, j, ne, rfl⟩\n  wlog lt : i < j generalizing i j\n  · rw [swap_comm]; exact this _ _ ne.symm (ne.lt_or_lt.resolve_left lt)\n  induction' j using Fin.induction with j ih\n  · cases lt\n  have mem : swap j.castSucc j.succ ∈ Submonoid.closure\n      (Set.range fun (i : Fin n) ↦ swap i.castSucc i.succ) := Submonoid.subset_closure ⟨_, rfl⟩\n  obtain rfl | lts := (Fin.le_castSucc_iff.mpr lt).eq_or_lt\n  · exact mem\n  rw [swap_comm, ← swap_mul_swap_mul_swap (y := Fin.castSucc j) lts.ne lt.ne]\n  exact mul_mem (mul_mem mem <| ih lts.ne lts) mem\n\n"}
{"name":"Equiv.Perm.swap_induction_on'","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nP : Equiv.Perm α → Prop\nf : Equiv.Perm α\na✝¹ : P 1\na✝ : ∀ (f : Equiv.Perm α) (x y : α), Ne x y → P f → P (HMul.hMul f (Equiv.swap x y))\n⊢ P f","decl":"/-- Like `swap_induction_on`, but with the composition on the right of `f`.\n\nAn induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. -/\n@[elab_as_elim]\ntheorem swap_induction_on' [Finite α] {P : Perm α → Prop} (f : Perm α) :\n    P 1 → (∀ f x y, x ≠ y → P f → P (f * swap x y)) → P f := fun h1 IH =>\n  inv_inv f ▸ swap_induction_on f⁻¹ h1 fun f => IH f⁻¹\n\n"}
{"name":"Equiv.Perm.isConj_swap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nw x y z : α\nhwx : Ne w x\nhyz : Ne y z\n⊢ IsConj (Equiv.swap w x) (Equiv.swap y z)","decl":"theorem isConj_swap {w x y z : α} (hwx : w ≠ x) (hyz : y ≠ z) : IsConj (swap w x) (swap y z) :=\n  isConj_iff.2\n    (have h :\n      ∀ {y z : α},\n        y ≠ z → w ≠ z → swap w y * swap x z * swap w x * (swap w y * swap x z)⁻¹ = swap y z :=\n      fun {y z} hyz hwz => by\n      rw [mul_inv_rev, swap_inv, swap_inv, mul_assoc (swap w y), mul_assoc (swap w y), ←\n        mul_assoc _ (swap x z), swap_mul_swap_mul_swap hwx hwz, ← mul_assoc,\n        swap_mul_swap_mul_swap hwz.symm hyz.symm]\n    if hwz : w = z then\n      have hwy : w ≠ y := by rw [hwz]; exact hyz.symm\n      ⟨swap w z * swap x y, by rw [swap_comm y z, h hyz.symm hwy]⟩\n    else ⟨swap w y * swap x z, h hyz hwz⟩)\n\n"}
{"name":"Equiv.Perm.mem_finPairsLT","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\na : Sigma fun x => Fin n\n⊢ Iff (Membership.mem (Equiv.Perm.finPairsLT n) a) (LT.lt a.snd a.fst)","decl":"theorem mem_finPairsLT {n : ℕ} {a : Σ_ : Fin n, Fin n} : a ∈ finPairsLT n ↔ a.2 < a.1 := by\n  simp only [finPairsLT, Fin.lt_iff_val_lt_val, true_and, mem_attachFin, mem_range, mem_univ,\n    mem_sigma]\n\n"}
{"name":"Equiv.Perm.signAux_one","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\n⊢ Eq (Equiv.Perm.signAux 1) 1","decl":"@[simp]\ntheorem signAux_one (n : ℕ) : signAux (1 : Perm (Fin n)) = 1 := by\n  unfold signAux\n  conv => rhs; rw [← @Finset.prod_const_one _ _ (finPairsLT n)]\n  exact Finset.prod_congr rfl fun a ha => if_neg (mem_finPairsLT.1 ha).not_le\n\n"}
{"name":"Equiv.Perm.signBijAux_injOn","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nf : Equiv.Perm (Fin n)\n⊢ Set.InjOn f.signBijAux ↑(Equiv.Perm.finPairsLT n)","decl":"theorem signBijAux_injOn {n : ℕ} {f : Perm (Fin n)} :\n    (finPairsLT n : Set (Σ _, Fin n)).InjOn (signBijAux f) := by\n  rintro ⟨a₁, a₂⟩ ha ⟨b₁, b₂⟩ hb h\n  dsimp [signBijAux] at h\n  rw [Finset.mem_coe, mem_finPairsLT] at *\n  have : ¬b₁ < b₂ := hb.le.not_lt\n  split_ifs at h <;>\n  simp_all only [not_lt, Sigma.mk.inj_iff, (Equiv.injective f).eq_iff, heq_eq_eq]\n  · exact absurd this (not_le.mpr ha)\n  · exact absurd this (not_le.mpr ha)\n\n"}
{"name":"Equiv.Perm.signBijAux_surj","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nf : Equiv.Perm (Fin n)\na : Sigma fun x => Fin n\na✝ : Membership.mem (Equiv.Perm.finPairsLT n) a\n⊢ Exists fun b => And (Membership.mem (Equiv.Perm.finPairsLT n) b) (Eq (f.signBijAux b) a)","decl":"theorem signBijAux_surj {n : ℕ} {f : Perm (Fin n)} :\n    ∀ a ∈ finPairsLT n, ∃ b ∈ finPairsLT n, signBijAux f b = a :=\n  fun ⟨a₁, a₂⟩ ha =>\n    if hxa : f⁻¹ a₂ < f⁻¹ a₁ then\n      ⟨⟨f⁻¹ a₁, f⁻¹ a₂⟩, mem_finPairsLT.2 hxa, by\n        dsimp [signBijAux]\n        rw [apply_inv_self, apply_inv_self, if_pos (mem_finPairsLT.1 ha)]⟩\n    else\n      ⟨⟨f⁻¹ a₂, f⁻¹ a₁⟩,\n        mem_finPairsLT.2 <|\n          (le_of_not_gt hxa).lt_of_ne fun h => by\n            simp [mem_finPairsLT, f⁻¹.injective h, lt_irrefl] at ha, by\n              dsimp [signBijAux]\n              rw [apply_inv_self, apply_inv_self, if_neg (mem_finPairsLT.1 ha).le.not_lt]⟩\n\n"}
{"name":"Equiv.Perm.signBijAux_mem","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nf : Equiv.Perm (Fin n)\na : Sigma fun x => Fin n\na✝ : Membership.mem (Equiv.Perm.finPairsLT n) a\n⊢ Membership.mem (Equiv.Perm.finPairsLT n) (f.signBijAux a)","decl":"theorem signBijAux_mem {n : ℕ} {f : Perm (Fin n)} :\n    ∀ a : Σ_ : Fin n, Fin n, a ∈ finPairsLT n → signBijAux f a ∈ finPairsLT n :=\n  fun ⟨a₁, a₂⟩ ha => by\n    unfold signBijAux\n    split_ifs with h\n    · exact mem_finPairsLT.2 h\n    · exact mem_finPairsLT.2\n        ((le_of_not_gt h).lt_of_ne fun h => (mem_finPairsLT.1 ha).ne (f.injective h.symm))\n\n"}
{"name":"Equiv.Perm.signAux_inv","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nf : Equiv.Perm (Fin n)\n⊢ Eq (Inv.inv f).signAux f.signAux","decl":"@[simp]\ntheorem signAux_inv {n : ℕ} (f : Perm (Fin n)) : signAux f⁻¹ = signAux f :=\n  prod_nbij (signBijAux f⁻¹) signBijAux_mem signBijAux_injOn signBijAux_surj fun ⟨a, b⟩ hab ↦\n    if h : f⁻¹ b < f⁻¹ a then by\n      simp_all [signBijAux, dif_pos h, if_neg h.not_le, apply_inv_self, apply_inv_self,\n        if_neg (mem_finPairsLT.1 hab).not_le]\n    else by\n      simp_all [signBijAux, if_pos (le_of_not_gt h), dif_neg h, apply_inv_self, apply_inv_self,\n        if_pos (mem_finPairsLT.1 hab).le]\n\n"}
{"name":"Equiv.Perm.signAux_mul","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nf g : Equiv.Perm (Fin n)\n⊢ Eq (HMul.hMul f g).signAux (HMul.hMul f.signAux g.signAux)","decl":"theorem signAux_mul {n : ℕ} (f g : Perm (Fin n)) : signAux (f * g) = signAux f * signAux g := by\n  rw [← signAux_inv g]\n  unfold signAux\n  rw [← prod_mul_distrib]\n  refine prod_nbij (signBijAux g) signBijAux_mem signBijAux_injOn signBijAux_surj ?_\n  rintro ⟨a, b⟩ hab\n  dsimp only [signBijAux]\n  rw [mul_apply, mul_apply]\n  rw [mem_finPairsLT] at hab\n  by_cases h : g b < g a\n  · rw [dif_pos h]\n    simp only [not_le_of_gt hab, mul_one, mul_ite, mul_neg, Perm.inv_apply_self, if_false]\n  · rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le]\n    by_cases h₁ : f (g b) ≤ f (g a)\n    · have : f (g b) ≠ f (g a) := by\n        rw [Ne, f.injective.eq_iff, g.injective.eq_iff]\n        exact ne_of_lt hab\n      rw [if_pos h₁, if_neg (h₁.lt_of_ne this).not_le]\n      rfl\n    · rw [if_neg h₁, if_pos (lt_of_not_ge h₁).le]\n      rfl\n\n"}
{"name":"Equiv.Perm.signAux_swap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"n : Nat\nx y : Fin n\n_hxy : Ne x y\n⊢ Eq (Equiv.swap x y).signAux (-1)","decl":"theorem signAux_swap : ∀ {n : ℕ} {x y : Fin n} (_hxy : x ≠ y), signAux (swap x y) = -1\n  | 0, x, y => by intro; exact Fin.elim0 x\n  | 1, x, y => by\n    dsimp [signAux, swap, swapCore]\n    simp only [eq_iff_true_of_subsingleton, not_true, ite_true, le_refl, prod_const,\n               IsEmpty.forall_iff]\n  | n + 2, x, y => fun hxy => by\n    have h2n : 2 ≤ n + 2 := by exact le_add_self\n    rw [← isConj_iff_eq, ← signAux_swap_zero_one h2n]\n    exact (MonoidHom.mk' signAux signAux_mul).map_isConj\n      (isConj_swap hxy (by exact of_decide_eq_true rfl))\n\n"}
{"name":"Equiv.Perm.signAux_eq_signAux2","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nn : Nat\nl : List α\nf : Equiv.Perm α\ne : Equiv α (Fin n)\n_h : ∀ (x : α), Ne (f x) x → Membership.mem l x\n⊢ Eq (Equiv.Perm.signAux ((e.symm.trans f).trans e)) (Equiv.Perm.signAux2 l f)","decl":"theorem signAux_eq_signAux2 {n : ℕ} :\n    ∀ (l : List α) (f : Perm α) (e : α ≃ Fin n) (_h : ∀ x, f x ≠ x → x ∈ l),\n      signAux ((e.symm.trans f).trans e) = signAux2 l f\n  | [], f, e, h => by\n    have : f = 1 := Equiv.ext fun y => Classical.not_not.1 (mt (h y) (List.not_mem_nil _))\n    rw [this, one_def, Equiv.trans_refl, Equiv.symm_trans_self, ← one_def, signAux_one, signAux2]\n  | x::l, f, e, h => by\n    rw [signAux2]\n    by_cases hfx : x = f x\n    · rw [if_pos hfx]\n      exact\n        signAux_eq_signAux2 l f _ fun y (hy : f y ≠ y) =>\n          List.mem_of_ne_of_mem (fun h : y = x => by simp [h, hfx.symm] at hy) (h y hy)\n    · have hy : ∀ y : α, (swap x (f x) * f) y ≠ y → y ∈ l := fun y hy =>\n        have : f y ≠ y ∧ y ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hy\n        List.mem_of_ne_of_mem this.2 (h _ this.1)\n      have : (e.symm.trans (swap x (f x) * f)).trans e =\n          swap (e x) (e (f x)) * (e.symm.trans f).trans e := by\n        ext\n        rw [← Equiv.symm_trans_swap_trans, mul_def, Equiv.symm_trans_swap_trans, mul_def]\n        repeat (rw [trans_apply])\n        simp [swap, swapCore]\n        split_ifs <;> rfl\n      have hefx : e x ≠ e (f x) := mt e.injective.eq_iff.1 hfx\n      rw [if_neg hfx, ← signAux_eq_signAux2 _ _ e hy, this, signAux_mul, signAux_swap hefx]\n      simp only [neg_neg, one_mul, neg_mul]\n\n"}
{"name":"Equiv.Perm.signAux3_mul_and_swap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nf g : Equiv.Perm α\ns : Multiset α\nhs : ∀ (x : α), Membership.mem s x\n⊢ And (Eq ((HMul.hMul f g).signAux3 hs) (HMul.hMul (f.signAux3 hs) (g.signAux3 hs))) (Pairwise fun x y => Eq ((Equiv.swap x y).signAux3 hs) (-1))","decl":"theorem signAux3_mul_and_swap [Finite α] (f g : Perm α) (s : Multiset α) (hs : ∀ x, x ∈ s) :\n    signAux3 (f * g) hs = signAux3 f hs * signAux3 g hs ∧\n      Pairwise fun x y => signAux3 (swap x y) hs = -1 := by\n  obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin α\n  induction s using Quotient.inductionOn with | _ l => ?_\n  show\n    signAux2 l (f * g) = signAux2 l f * signAux2 l g ∧\n    Pairwise fun x y => signAux2 l (swap x y) = -1\n  have hfg : (e.symm.trans (f * g)).trans e = (e.symm.trans f).trans e * (e.symm.trans g).trans e :=\n    Equiv.ext fun h => by simp [mul_apply]\n  constructor\n  · rw [← signAux_eq_signAux2 _ _ e fun _ _ => hs _, ←\n      signAux_eq_signAux2 _ _ e fun _ _ => hs _, ← signAux_eq_signAux2 _ _ e fun _ _ => hs _,\n      hfg, signAux_mul]\n  · intro x y hxy\n    rw [← e.injective.ne_iff] at hxy\n    rw [← signAux_eq_signAux2 _ _ e fun _ _ => hs _, symm_trans_swap_trans, signAux_swap hxy]\n\n"}
{"name":"Equiv.Perm.signAux3_symm_trans_trans","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Finite α\ninst✝¹ : DecidableEq β\ninst✝ : Finite β\nf : Equiv.Perm α\ne : Equiv α β\ns : Multiset α\nt : Multiset β\nhs : ∀ (x : α), Membership.mem s x\nht : ∀ (x : β), Membership.mem t x\n⊢ Eq (Equiv.Perm.signAux3 ((e.symm.trans f).trans e) ht) (f.signAux3 hs)","decl":"theorem signAux3_symm_trans_trans [Finite α] [DecidableEq β] [Finite β] (f : Perm α) (e : α ≃ β)\n    {s : Multiset α} {t : Multiset β} (hs : ∀ x, x ∈ s) (ht : ∀ x, x ∈ t) :\n    signAux3 ((e.symm.trans f).trans e) ht = signAux3 f hs := by\n  -- Porting note: switched from term mode to tactic mode\n  induction' t, s using Quotient.inductionOn₂ with t s ht hs\n  show signAux2 _ _ = signAux2 _ _\n  rcases Finite.exists_equiv_fin β with ⟨n, ⟨e'⟩⟩\n  rw [← signAux_eq_signAux2 _ _ e' fun _ _ => ht _,\n    ← signAux_eq_signAux2 _ _ (e.trans e') fun _ _ => hs _]\n  exact congr_arg signAux\n    (Equiv.ext fun x => by simp [Equiv.coe_trans, apply_eq_iff_eq, symm_trans_apply])\n\n"}
{"name":"Equiv.Perm.sign_mul","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (HMul.hMul f g)) (HMul.hMul (Equiv.Perm.sign f) (Equiv.Perm.sign g))","decl":"@[simp]\ntheorem sign_mul (f g : Perm α) : sign (f * g) = sign f * sign g :=\n  MonoidHom.map_mul sign f g\n\n"}
{"name":"Equiv.Perm.sign_trans","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (Equiv.trans f g)) (HMul.hMul (Equiv.Perm.sign g) (Equiv.Perm.sign f))","decl":"@[simp]\ntheorem sign_trans (f g : Perm α) : sign (f.trans g) = sign g * sign f := by\n  rw [← mul_def, sign_mul]\n\n"}
{"name":"Equiv.Perm.sign_one","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Equiv.Perm.sign 1) 1","decl":"@[simp]\ntheorem sign_one : sign (1 : Perm α) = 1 :=\n  MonoidHom.map_one sign\n\n"}
{"name":"Equiv.Perm.sign_refl","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Equiv.Perm.sign (Equiv.refl α)) 1","decl":"@[simp]\ntheorem sign_refl : sign (Equiv.refl α) = 1 :=\n  MonoidHom.map_one sign\n\n"}
{"name":"Equiv.Perm.sign_inv","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (Inv.inv f)) (Equiv.Perm.sign f)","decl":"@[simp]\ntheorem sign_inv (f : Perm α) : sign f⁻¹ = sign f := by\n  rw [MonoidHom.map_inv sign f, Int.units_inv_eq_self]\n\n"}
{"name":"Equiv.Perm.sign_symm","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ne : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (Equiv.symm e)) (Equiv.Perm.sign e)","decl":"@[simp]\ntheorem sign_symm (e : Perm α) : sign e.symm = sign e :=\n  sign_inv e\n\n"}
{"name":"Equiv.Perm.sign_swap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y : α\nh : Ne x y\n⊢ Eq (Equiv.Perm.sign (Equiv.swap x y)) (-1)","decl":"theorem sign_swap {x y : α} (h : x ≠ y) : sign (swap x y) = -1 :=\n  (signAux3_mul_and_swap 1 1 _ mem_univ).2 h\n\n"}
{"name":"Equiv.Perm.sign_swap'","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nx y : α\n⊢ Eq (Equiv.Perm.sign (Equiv.swap x y)) (ite (Eq x y) 1 (-1))","decl":"@[simp]\ntheorem sign_swap' {x y : α} : sign (swap x y) = if x = y then 1 else -1 :=\n  if H : x = y then by simp [H, swap_self] else by simp [sign_swap H, H]\n\n"}
{"name":"Equiv.Perm.IsSwap.sign_eq","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nh : f.IsSwap\n⊢ Eq (Equiv.Perm.sign f) (-1)","decl":"theorem IsSwap.sign_eq {f : Perm α} (h : f.IsSwap) : sign f = -1 :=\n  let ⟨_, _, hxy⟩ := h\n  hxy.2.symm ▸ sign_swap hxy.1\n\n"}
{"name":"Equiv.Perm.sign_symm_trans_trans","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nf : Equiv.Perm α\ne : Equiv α β\n⊢ Eq (Equiv.Perm.sign ((e.symm.trans f).trans e)) (Equiv.Perm.sign f)","decl":"@[simp]\ntheorem sign_symm_trans_trans [DecidableEq β] [Fintype β] (f : Perm α) (e : α ≃ β) :\n    sign ((e.symm.trans f).trans e) = sign f :=\n  signAux3_symm_trans_trans f e mem_univ mem_univ\n\n"}
{"name":"Equiv.Perm.sign_trans_trans_symm","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nf : Equiv.Perm β\ne : Equiv α β\n⊢ Eq (Equiv.Perm.sign ((e.trans f).trans e.symm)) (Equiv.Perm.sign f)","decl":"@[simp]\ntheorem sign_trans_trans_symm [DecidableEq β] [Fintype β] (f : Perm β) (e : α ≃ β) :\n    sign ((e.trans f).trans e.symm) = sign f :=\n  sign_symm_trans_trans f e.symm\n\n"}
{"name":"Equiv.Perm.sign_prod_list_swap","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List (Equiv.Perm α)\nhl : ∀ (g : Equiv.Perm α), Membership.mem l g → g.IsSwap\n⊢ Eq (Equiv.Perm.sign l.prod) (HPow.hPow (-1) l.length)","decl":"theorem sign_prod_list_swap {l : List (Perm α)} (hl : ∀ g ∈ l, IsSwap g) :\n    sign l.prod = (-1) ^ l.length := by\n  have h₁ : l.map sign = List.replicate l.length (-1) :=\n    List.eq_replicate_iff.2\n      ⟨by simp, fun u hu =>\n        let ⟨g, hg⟩ := List.mem_map.1 hu\n        hg.2 ▸ (hl _ hg.1).sign_eq⟩\n  rw [← List.prod_replicate, ← h₁, List.prod_hom _ (@sign α _ _)]\n\n"}
{"name":"Equiv.Perm.sign_abs","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Eq (abs ↑(Equiv.Perm.sign f)) 1","decl":"@[simp]\ntheorem sign_abs (f : Perm α) :\n    |(Equiv.Perm.sign f : ℤ)| = 1 := by\n  rw [Int.abs_eq_natAbs, Int.units_natAbs, Nat.cast_one]\n\n"}
{"name":"Equiv.Perm.sign_surjective","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : Nontrivial α\n⊢ Function.Surjective ⇑Equiv.Perm.sign","decl":"theorem sign_surjective [Nontrivial α] : Function.Surjective (sign : Perm α → ℤˣ) := fun a =>\n  (Int.units_eq_one_or a).elim (fun h => ⟨1, by simp [h]⟩) fun h =>\n    let ⟨x, y, hxy⟩ := exists_pair_ne α\n    ⟨swap x y, by rw [sign_swap hxy, h]⟩\n\n"}
{"name":"Equiv.Perm.eq_sign_of_surjective_hom","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : MonoidHom (Equiv.Perm α) (Units Int)\nhs : Function.Surjective ⇑s\n⊢ Eq s Equiv.Perm.sign","decl":"theorem eq_sign_of_surjective_hom {s : Perm α →* ℤˣ} (hs : Surjective s) : s = sign :=\n  have : ∀ {f}, IsSwap f → s f = -1 := fun {f} ⟨x, y, hxy, hxy'⟩ =>\n    hxy'.symm ▸\n      by_contradiction fun h => by\n        have : ∀ f, IsSwap f → s f = 1 := fun f ⟨a, b, hab, hab'⟩ => by\n          rw [← isConj_iff_eq, ← Or.resolve_right (Int.units_eq_one_or _) h, hab']\n          exact s.map_isConj (isConj_swap hab hxy)\n        let ⟨g, hg⟩ := hs (-1)\n        let ⟨l, hl⟩ := (truncSwapFactors g).out\n        have : ∀ a ∈ l.map s, a = (1 : ℤˣ) := fun a ha =>\n          let ⟨g, hg⟩ := List.mem_map.1 ha\n          hg.2 ▸ this _ (hl.2 _ hg.1)\n        have : s l.prod = 1 := by\n          rw [← l.prod_hom s, List.eq_replicate_length.2 this, List.prod_replicate, one_pow]\n        rw [hl.1, hg] at this\n        exact absurd this (by simp_all)\n  MonoidHom.ext fun f => by\n    let ⟨l, hl₁, hl₂⟩ := (truncSwapFactors f).out\n    have hsl : ∀ a ∈ l.map s, a = (-1 : ℤˣ) := fun a ha =>\n      let ⟨g, hg⟩ := List.mem_map.1 ha\n      hg.2 ▸ this (hl₂ _ hg.1)\n    rw [← hl₁, ← l.prod_hom s, List.eq_replicate_length.2 hsl, List.length_map, List.prod_replicate,\n      sign_prod_list_swap hl₂]\n\n"}
{"name":"Equiv.Perm.sign_subtypePerm","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nf : Equiv.Perm α\np : α → Prop\ninst✝ : DecidablePred p\nh₁ : ∀ (x : α), Iff (p x) (p (f x))\nh₂ : ∀ (x : α), Ne (f x) x → p x\n⊢ Eq (Equiv.Perm.sign (f.subtypePerm h₁)) (Equiv.Perm.sign f)","decl":"theorem sign_subtypePerm (f : Perm α) {p : α → Prop} [DecidablePred p] (h₁ : ∀ x, p x ↔ p (f x))\n    (h₂ : ∀ x, f x ≠ x → p x) : sign (subtypePerm f h₁) = sign f := by\n  let l := (truncSwapFactors (subtypePerm f h₁)).out\n  have hl' : ∀ g' ∈ l.1.map ofSubtype, IsSwap g' := fun g' hg' =>\n    let ⟨g, hg⟩ := List.mem_map.1 hg'\n    hg.2 ▸ (l.2.2 _ hg.1).of_subtype_isSwap\n  have hl'₂ : (l.1.map ofSubtype).prod = f := by\n    rw [l.1.prod_hom ofSubtype, l.2.1, ofSubtype_subtypePerm _ h₂]\n  conv =>\n    congr\n    rw [← l.2.1]\n  simp_rw [← hl'₂]\n  rw [sign_prod_list_swap l.2.2, sign_prod_list_swap hl', List.length_map]\n\n"}
{"name":"Equiv.Perm.sign_eq_sign_of_equiv","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nf : Equiv.Perm α\ng : Equiv.Perm β\ne : Equiv α β\nh : ∀ (x : α), Eq (e (f x)) (g (e x))\n⊢ Eq (Equiv.Perm.sign f) (Equiv.Perm.sign g)","decl":"theorem sign_eq_sign_of_equiv [DecidableEq β] [Fintype β] (f : Perm α) (g : Perm β) (e : α ≃ β)\n    (h : ∀ x, e (f x) = g (e x)) : sign f = sign g := by\n  have hg : g = (e.symm.trans f).trans e := Equiv.ext <| by simp [h]\n  rw [hg, sign_symm_trans_trans]\n\n"}
{"name":"Equiv.Perm.sign_bij","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nf : Equiv.Perm α\ng : Equiv.Perm β\ni : (x : α) → Ne (f x) x → β\nh : ∀ (x : α) (hx : Ne (f x) x) (hx' : Ne (f (f x)) (f x)), Eq (i (f x) hx') (g (i x hx))\nhi : ∀ (x₁ x₂ : α) (hx₁ : Ne (f x₁) x₁) (hx₂ : Ne (f x₂) x₂), Eq (i x₁ hx₁) (i x₂ hx₂) → Eq x₁ x₂\nhg : ∀ (y : β), Ne (g y) y → Exists fun x => Exists fun hx => Eq (i x hx) y\n⊢ Eq (Equiv.Perm.sign f) (Equiv.Perm.sign g)","decl":"theorem sign_bij [DecidableEq β] [Fintype β] {f : Perm α} {g : Perm β} (i : ∀ x : α, f x ≠ x → β)\n    (h : ∀ x hx hx', i (f x) hx' = g (i x hx)) (hi : ∀ x₁ x₂ hx₁ hx₂, i x₁ hx₁ = i x₂ hx₂ → x₁ = x₂)\n    (hg : ∀ y, g y ≠ y → ∃ x hx, i x hx = y) : sign f = sign g :=\n  calc\n    sign f = sign (subtypePerm f <| by simp : Perm { x // f x ≠ x }) :=\n      (sign_subtypePerm _ _ fun _ => id).symm\n    _ = sign (subtypePerm g <| by simp : Perm { x // g x ≠ x }) :=\n      sign_eq_sign_of_equiv _ _\n        (Equiv.ofBijective\n          (fun x : { x // f x ≠ x } =>\n            (⟨i x.1 x.2, by\n                have : f (f x) ≠ f x := mt (fun h => f.injective h) x.2\n                rw [← h _ x.2 this]\n                exact mt (hi _ _ this x.2) x.2⟩ :\n              { y // g y ≠ y }))\n          ⟨fun ⟨_, _⟩ ⟨_, _⟩ h => Subtype.eq (hi _ _ _ _ (Subtype.mk.inj h)), fun ⟨y, hy⟩ =>\n            let ⟨x, hfx, hx⟩ := hg y hy\n            ⟨⟨x, hfx⟩, Subtype.eq hx⟩⟩)\n        fun ⟨x, _⟩ => Subtype.eq (h x _ _)\n    _ = sign g := sign_subtypePerm _ _ fun _ => id\n\n"}
{"name":"Equiv.Perm.prod_prodExtendRight","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"β : Type v\nα : Type u_1\ninst✝ : DecidableEq α\nσ : α → Equiv.Perm β\nl : List α\nhl : l.Nodup\nmem_l : ∀ (a : α), Membership.mem l a\n⊢ Eq (List.map (fun a => Equiv.Perm.prodExtendRight a (σ a)) l).prod (Equiv.prodCongrRight σ)","decl":"/-- If we apply `prod_extendRight a (σ a)` for all `a : α` in turn,\nwe get `prod_congrRight σ`. -/\ntheorem prod_prodExtendRight {α : Type*} [DecidableEq α] (σ : α → Perm β) {l : List α}\n    (hl : l.Nodup) (mem_l : ∀ a, a ∈ l) :\n    (l.map fun a => prodExtendRight a (σ a)).prod = prodCongrRight σ := by\n  ext ⟨a, b⟩ : 1\n  -- We'll use induction on the list of elements,\n  -- but we have to keep track of whether we already passed `a` in the list.\n  suffices a ∈ l ∧ (l.map fun a => prodExtendRight a (σ a)).prod (a, b) = (a, σ a b) ∨\n      a ∉ l ∧ (l.map fun a => prodExtendRight a (σ a)).prod (a, b) = (a, b) by\n    obtain ⟨_, prod_eq⟩ := Or.resolve_right this (not_and.mpr fun h _ => h (mem_l a))\n    rw [prod_eq, prodCongrRight_apply]\n  clear mem_l\n  induction' l with a' l ih\n  · refine Or.inr ⟨List.not_mem_nil _, ?_⟩\n    rw [List.map_nil, List.prod_nil, one_apply]\n  rw [List.map_cons, List.prod_cons, mul_apply]\n  rcases ih (List.nodup_cons.mp hl).2 with (⟨mem_l, prod_eq⟩ | ⟨not_mem_l, prod_eq⟩) <;>\n    rw [prod_eq]\n  · refine Or.inl ⟨List.mem_cons_of_mem _ mem_l, ?_⟩\n    rw [prodExtendRight_apply_ne _ fun h : a = a' => (List.nodup_cons.mp hl).1 (h ▸ mem_l)]\n  by_cases ha' : a = a'\n  · rw [← ha'] at *\n    refine Or.inl ⟨l.mem_cons_self a, ?_⟩\n    rw [prodExtendRight_apply_eq]\n  · refine Or.inr ⟨fun h => not_or_intro ha' not_mem_l ((List.mem_cons).mp h), ?_⟩\n    rw [prodExtendRight_apply_ne _ ha']\n\n"}
{"name":"Equiv.Perm.sign_prodExtendRight","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\na : α\nσ : Equiv.Perm β\n⊢ Eq (Equiv.Perm.sign (Equiv.Perm.prodExtendRight a σ)) (Equiv.Perm.sign σ)","decl":"@[simp]\ntheorem sign_prodExtendRight (a : α) (σ : Perm β) : sign (prodExtendRight a σ) = sign σ :=\n  sign_bij (fun (ab : α × β) _ => ab.snd)\n    (fun ⟨a', b⟩ hab _ => by simp [eq_of_prodExtendRight_ne hab])\n    (fun ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ hab₁ hab₂ h => by\n      simpa [eq_of_prodExtendRight_ne hab₁, eq_of_prodExtendRight_ne hab₂] using h)\n    fun y hy => ⟨(a, y), by simpa, by simp⟩\n\n"}
{"name":"Equiv.Perm.sign_prodCongrRight","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nσ : α → Equiv.Perm β\n⊢ Eq (Equiv.Perm.sign (Equiv.prodCongrRight σ)) (Finset.univ.prod fun k => Equiv.Perm.sign (σ k))","decl":"theorem sign_prodCongrRight (σ : α → Perm β) : sign (prodCongrRight σ) = ∏ k, sign (σ k) := by\n  obtain ⟨l, hl, mem_l⟩ := Finite.exists_univ_list α\n  have l_to_finset : l.toFinset = Finset.univ := by\n    apply eq_top_iff.mpr\n    intro b _\n    exact List.mem_toFinset.mpr (mem_l b)\n  rw [← prod_prodExtendRight σ hl mem_l, map_list_prod sign, List.map_map, ← l_to_finset,\n    List.prod_toFinset _ hl]\n  simp_rw [← fun a => sign_prodExtendRight a (σ a), Function.comp_def]\n\n"}
{"name":"Equiv.Perm.sign_prodCongrLeft","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nσ : α → Equiv.Perm β\n⊢ Eq (Equiv.Perm.sign (Equiv.prodCongrLeft σ)) (Finset.univ.prod fun k => Equiv.Perm.sign (σ k))","decl":"theorem sign_prodCongrLeft (σ : α → Perm β) : sign (prodCongrLeft σ) = ∏ k, sign (σ k) := by\n  refine (sign_eq_sign_of_equiv _ _ (prodComm β α) ?_).trans (sign_prodCongrRight σ)\n  rintro ⟨b, α⟩\n  rfl\n\n"}
{"name":"Equiv.Perm.sign_permCongr","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\ne : Equiv α β\np : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (e.permCongr p)) (Equiv.Perm.sign p)","decl":"@[simp]\ntheorem sign_permCongr (e : α ≃ β) (p : Perm α) : sign (e.permCongr p) = sign p :=\n  sign_eq_sign_of_equiv _ _ e.symm (by simp)\n\n"}
{"name":"Equiv.Perm.sign_sumCongr","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝³ : DecidableEq α\nβ : Type v\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\ninst✝ : Fintype β\nσa : Equiv.Perm α\nσb : Equiv.Perm β\n⊢ Eq (Equiv.Perm.sign (σa.sumCongr σb)) (HMul.hMul (Equiv.Perm.sign σa) (Equiv.Perm.sign σb))","decl":"@[simp]\ntheorem sign_sumCongr (σa : Perm α) (σb : Perm β) : sign (sumCongr σa σb) = sign σa * sign σb := by\n  suffices sign (sumCongr σa (1 : Perm β)) = sign σa ∧ sign (sumCongr (1 : Perm α) σb) = sign σb\n    by rw [← this.1, ← this.2, ← sign_mul, sumCongr_mul, one_mul, mul_one]\n  constructor\n  · refine σa.swap_induction_on ?_ fun σa' a₁ a₂ ha ih => ?_\n    · simp\n    · rw [← one_mul (1 : Perm β), ← sumCongr_mul, sign_mul, sign_mul, ih, sumCongr_swap_one,\n        sign_swap ha, sign_swap (Sum.inl_injective.ne_iff.mpr ha)]\n  · refine σb.swap_induction_on ?_ fun σb' b₁ b₂ hb ih => ?_\n    · simp\n    · rw [← one_mul (1 : Perm α), ← sumCongr_mul, sign_mul, sign_mul, ih, sumCongr_one_swap,\n        sign_swap hb, sign_swap (Sum.inr_injective.ne_iff.mpr hb)]\n\n"}
{"name":"Equiv.Perm.sign_subtypeCongr","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\n⊢ Eq (Equiv.Perm.sign (ep.subtypeCongr en)) (HMul.hMul (Equiv.Perm.sign ep) (Equiv.Perm.sign en))","decl":"@[simp]\ntheorem sign_subtypeCongr {p : α → Prop} [DecidablePred p] (ep : Perm { a // p a })\n    (en : Perm { a // ¬p a }) : sign (ep.subtypeCongr en) = sign ep * sign en := by\n  simp [subtypeCongr]\n\n"}
{"name":"Equiv.Perm.sign_extendDomain","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝⁴ : DecidableEq α\nβ : Type v\ninst✝³ : Fintype α\ninst✝² : DecidableEq β\ninst✝¹ : Fintype β\ne : Equiv.Perm α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\n⊢ Eq (Equiv.Perm.sign (e.extendDomain f)) (Equiv.Perm.sign e)","decl":"@[simp]\ntheorem sign_extendDomain (e : Perm α) {p : β → Prop} [DecidablePred p] (f : α ≃ Subtype p) :\n    Equiv.Perm.sign (e.extendDomain f) = Equiv.Perm.sign e := by\n  simp only [Equiv.Perm.extendDomain, sign_subtypeCongr, sign_permCongr, sign_refl, mul_one]\n\n"}
{"name":"Equiv.Perm.sign_ofSubtype","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\n⊢ Eq (Equiv.Perm.sign (Equiv.Perm.ofSubtype f)) (Equiv.Perm.sign f)","decl":"@[simp]\ntheorem sign_ofSubtype {p : α → Prop} [DecidablePred p] (f : Equiv.Perm (Subtype p)) :\n    sign (ofSubtype f) = sign f :=\n  sign_extendDomain f (Equiv.refl (Subtype p))\n\n"}
{"name":"Equiv.Perm.mem_ofSign","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Units Int\nσ : Equiv.Perm α\n⊢ Iff (Membership.mem (Equiv.Perm.ofSign s) σ) (Eq (Equiv.Perm.sign σ) s)","decl":"@[simp]\nlemma mem_ofSign {s : ℤˣ} {σ : Perm α} : σ ∈ ofSign s ↔ σ.sign = s := by\n  rw [ofSign, mem_filter, and_iff_right (mem_univ σ)]\n\n"}
{"name":"Equiv.Perm.ofSign_disjoint","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Disjoint (Equiv.Perm.ofSign 1) (Equiv.Perm.ofSign (-1))","decl":"lemma ofSign_disjoint : _root_.Disjoint (ofSign 1 : Finset (Perm α)) (ofSign (-1)) := by\n  rw [Finset.disjoint_iff_ne]\n  rintro σ hσ τ hτ rfl\n  rw [mem_ofSign] at hσ hτ\n  have := hσ.symm.trans hτ\n  contradiction\n\n"}
{"name":"Equiv.Perm.ofSign_disjUnion","module":"Mathlib.GroupTheory.Perm.Sign","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq ((Equiv.Perm.ofSign 1).disjUnion (Equiv.Perm.ofSign (-1)) ⋯) Finset.univ","decl":"lemma ofSign_disjUnion :\n    (ofSign 1).disjUnion (ofSign (-1)) ofSign_disjoint = (univ : Finset (Perm α)) := by\n  ext σ\n  simp_rw [mem_disjUnion, mem_ofSign, Int.units_eq_one_or, mem_univ]\n\n"}
