{"name":"Finset.mem_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Finset β\nhf : Set.InjOn f (Set.preimage f ↑s)\nx : α\n⊢ Iff (Membership.mem (s.preimage f hf) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_preimage {f : α → β} {s : Finset β} {hf : Set.InjOn f (f ⁻¹' ↑s)} {x : α} :\n    x ∈ preimage s f hf ↔ f x ∈ s :=\n  Set.Finite.mem_toFinset _\n\n"}
{"name":"Finset.coe_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Finset β\nhf : Set.InjOn f (Set.preimage f ↑s)\n⊢ Eq (↑(s.preimage f hf)) (Set.preimage f ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_preimage {f : α → β} (s : Finset β) (hf : Set.InjOn f (f ⁻¹' ↑s)) :\n    (↑(preimage s f hf) : Set α) = f ⁻¹' ↑s :=\n  Set.Finite.coe_toFinset _\n\n"}
{"name":"Finset.preimage_empty","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (EmptyCollection.emptyCollection.preimage f ⋯) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_empty {f : α → β} : preimage ∅ f (by simp [InjOn]) = ∅ :=\n  Finset.coe_injective (by simp)\n\n"}
{"name":"Finset.preimage_univ","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nhf : Set.InjOn f (Set.preimage f ↑Finset.univ)\n⊢ Eq (Finset.univ.preimage f hf) Finset.univ","decl":"@[simp]\ntheorem preimage_univ {f : α → β} [Fintype α] [Fintype β] (hf) : preimage univ f hf = univ :=\n  Finset.coe_injective (by simp)\n\n"}
{"name":"Finset.preimage_inter","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns t : Finset β\nhs : Set.InjOn f (Set.preimage f ↑s)\nht : Set.InjOn f (Set.preimage f ↑t)\n⊢ Eq ((Inter.inter s t).preimage f ⋯) (Inter.inter (s.preimage f hs) (t.preimage f ht))","decl":"@[simp]\ntheorem preimage_inter [DecidableEq α] [DecidableEq β] {f : α → β} {s t : Finset β}\n    (hs : Set.InjOn f (f ⁻¹' ↑s)) (ht : Set.InjOn f (f ⁻¹' ↑t)) :\n    (preimage (s ∩ t) f fun _ hx₁ _ hx₂ =>\n        hs (mem_of_mem_inter_left hx₁) (mem_of_mem_inter_left hx₂)) =\n      preimage s f hs ∩ preimage t f ht :=\n  Finset.coe_injective (by simp)\n\n"}
{"name":"Finset.preimage_union","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns t : Finset β\nhst : Set.InjOn f (Set.preimage f ↑(Union.union s t))\n⊢ Eq ((Union.union s t).preimage f hst) (Union.union (s.preimage f ⋯) (t.preimage f ⋯))","decl":"@[simp]\ntheorem preimage_union [DecidableEq α] [DecidableEq β] {f : α → β} {s t : Finset β} (hst) :\n    preimage (s ∪ t) f hst =\n      (preimage s f fun _ hx₁ _ hx₂ => hst (mem_union_left _ hx₁) (mem_union_left _ hx₂)) ∪\n        preimage t f fun _ hx₁ _ hx₂ => hst (mem_union_right _ hx₁) (mem_union_right _ hx₂) :=\n  Finset.coe_injective (by simp)\n\n"}
{"name":"Finset.preimage_compl","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq β\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\ns : Finset β\nhf : Function.Injective f\n⊢ Eq ((HasCompl.compl s).preimage f ⋯) (HasCompl.compl (s.preimage f ⋯))","decl":"@[simp, nolint simpNF] -- Porting note: linter complains that LHS doesn't simplify\ntheorem preimage_compl [DecidableEq α] [DecidableEq β] [Fintype α] [Fintype β] {f : α → β}\n    (s : Finset β) (hf : Function.Injective f) :\n    preimage sᶜ f hf.injOn = (preimage s f hf.injOn)ᶜ :=\n  Finset.coe_injective (by simp)\n\n"}
{"name":"Finset.preimage_map","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq ((Finset.map f s).preimage ⇑f ⋯) s","decl":"@[simp]\nlemma preimage_map (f : α ↪ β) (s : Finset α) : (s.map f).preimage f f.injective.injOn = s :=\n  coe_injective <| by simp only [coe_preimage, coe_map, Set.preimage_image_eq _ f.injective]\n\n"}
{"name":"Finset.monotone_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nh : Function.Injective f\n⊢ Monotone fun s => s.preimage f ⋯","decl":"theorem monotone_preimage {f : α → β} (h : Injective f) :\n    Monotone fun s => preimage s f h.injOn := fun _ _ H _ hx =>\n  mem_preimage.2 (H <| mem_preimage.1 hx)\n\n"}
{"name":"Finset.image_subset_iff_subset_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\nhf : Set.InjOn f (Set.preimage f ↑t)\n⊢ Iff (HasSubset.Subset (Finset.image f s) t) (HasSubset.Subset s (t.preimage f hf))","decl":"theorem image_subset_iff_subset_preimage [DecidableEq β] {f : α → β} {s : Finset α} {t : Finset β}\n    (hf : Set.InjOn f (f ⁻¹' ↑t)) : s.image f ⊆ t ↔ s ⊆ t.preimage f hf :=\n  image_subset_iff.trans <| by simp only [subset_iff, mem_preimage]\n\n"}
{"name":"Finset.map_subset_iff_subset_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : Function.Embedding α β\ns : Finset α\nt : Finset β\n⊢ Iff (HasSubset.Subset (Finset.map f s) t) (HasSubset.Subset s (t.preimage ⇑f ⋯))","decl":"theorem map_subset_iff_subset_preimage {f : α ↪ β} {s : Finset α} {t : Finset β} :\n    s.map f ⊆ t ↔ s ⊆ t.preimage f f.injective.injOn := by\n  classical rw [map_eq_image, image_subset_iff_subset_preimage]\n\n"}
{"name":"Finset.card_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ns : Finset β\nf : α → β\nhf : Set.InjOn f (Set.preimage f ↑s)\ninst✝ : DecidablePred fun x => Membership.mem (Set.range f) x\n⊢ Eq (s.preimage f hf).card (Finset.filter (fun x => Membership.mem (Set.range f) x) s).card","decl":"lemma card_preimage (s : Finset β) (f : α → β) (hf) [DecidablePred (· ∈ Set.range f)] :\n    (s.preimage f hf).card = {x ∈ s | x ∈ Set.range f}.card :=\n  card_nbij f (by simp) (by simpa) (fun b hb ↦ by aesop)\n\n"}
{"name":"Finset.image_preimage","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nf : α → β\ns : Finset β\ninst✝ : (x : β) → Decidable (Membership.mem (Set.range f) x)\nhf : Set.InjOn f (Set.preimage f ↑s)\n⊢ Eq (Finset.image f (s.preimage f hf)) (Finset.filter (fun x => Membership.mem (Set.range f) x) s)","decl":"theorem image_preimage [DecidableEq β] (f : α → β) (s : Finset β) [∀ x, Decidable (x ∈ Set.range f)]\n    (hf : Set.InjOn f (f ⁻¹' ↑s)) : image f (preimage s f hf) = s.filter fun x => x ∈ Set.range f :=\n  Finset.coe_inj.1 <| by\n    simp only [coe_image, coe_preimage, coe_filter, Set.image_preimage_eq_inter_range,\n      ← Set.sep_mem_eq]; rfl\n\n"}
{"name":"Finset.image_preimage_of_bij","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\nf : α → β\ns : Finset β\nhf : Set.BijOn f (Set.preimage f ↑s) ↑s\n⊢ Eq (Finset.image f (s.preimage f ⋯)) s","decl":"theorem image_preimage_of_bij [DecidableEq β] (f : α → β) (s : Finset β)\n    (hf : Set.BijOn f (f ⁻¹' ↑s) ↑s) : image f (preimage s f hf.injOn) = s :=\n  Finset.coe_inj.1 <| by simpa using hf.image_eq\n\n"}
{"name":"Finset.preimage_subset_of_subset_image","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\nf : α → β\ns : Finset β\nt : Finset α\nhs : HasSubset.Subset s (Finset.image f t)\nhf : Set.InjOn f (Set.preimage f ↑s)\n⊢ HasSubset.Subset (s.preimage f hf) t","decl":"lemma preimage_subset_of_subset_image [DecidableEq β] {f : α → β} {s : Finset β} {t : Finset α}\n    (hs : s ⊆ t.image f) {hf} : s.preimage f hf ⊆ t := by\n  rw [← coe_subset, coe_preimage]; exact Set.preimage_subset (mod_cast hs) hf\n\n"}
{"name":"Finset.preimage_subset","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : Function.Embedding α β\ns : Finset β\nt : Finset α\nhs : HasSubset.Subset s (Finset.map f t)\n⊢ HasSubset.Subset (s.preimage ⇑f ⋯) t","decl":"theorem preimage_subset {f : α ↪ β} {s : Finset β} {t : Finset α} (hs : s ⊆ t.map f) :\n    s.preimage f f.injective.injOn ⊆ t := fun _ h => (mem_map' f).1 (hs (mem_preimage.1 h))\n\n"}
{"name":"Finset.subset_map_iff","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\nf : Function.Embedding α β\ns : Finset β\nt : Finset α\n⊢ Iff (HasSubset.Subset s (Finset.map f t)) (Exists fun u => And (HasSubset.Subset u t) (Eq s (Finset.map f u)))","decl":"theorem subset_map_iff {f : α ↪ β} {s : Finset β} {t : Finset α} :\n    s ⊆ t.map f ↔ ∃ u ⊆ t, s = u.map f := by\n  classical\n  simp_rw [map_eq_image, subset_image_iff, eq_comm]\n\n"}
{"name":"Finset.sigma_preimage_mk","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : α → Type u_1\ninst✝ : DecidableEq α\ns : Finset (Sigma fun a => β a)\nt : Finset α\n⊢ Eq (t.sigma fun a => s.preimage (Sigma.mk a) ⋯) (Finset.filter (fun a => Membership.mem t a.fst) s)","decl":"theorem sigma_preimage_mk {β : α → Type*} [DecidableEq α] (s : Finset (Σa, β a)) (t : Finset α) :\n    (t.sigma fun a => s.preimage (Sigma.mk a) sigma_mk_injective.injOn) =\n      s.filter fun a => a.1 ∈ t := by\n  ext x\n  simp [and_comm]\n\n"}
{"name":"Finset.sigma_preimage_mk_of_subset","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : α → Type u_1\ninst✝ : DecidableEq α\ns : Finset (Sigma fun a => β a)\nt : Finset α\nht : HasSubset.Subset (Finset.image Sigma.fst s) t\n⊢ Eq (t.sigma fun a => s.preimage (Sigma.mk a) ⋯) s","decl":"theorem sigma_preimage_mk_of_subset {β : α → Type*} [DecidableEq α] (s : Finset (Σa, β a))\n    {t : Finset α} (ht : s.image Sigma.fst ⊆ t) :\n    (t.sigma fun a => s.preimage (Sigma.mk a) sigma_mk_injective.injOn) = s := by\n  rw [sigma_preimage_mk, filter_true_of_mem <| image_subset_iff.1 ht]\n\n"}
{"name":"Finset.sigma_image_fst_preimage_mk","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : α → Type u_1\ninst✝ : DecidableEq α\ns : Finset (Sigma fun a => β a)\n⊢ Eq ((Finset.image Sigma.fst s).sigma fun a => s.preimage (Sigma.mk a) ⋯) s","decl":"theorem sigma_image_fst_preimage_mk {β : α → Type*} [DecidableEq α] (s : Finset (Σa, β a)) :\n    ((s.image Sigma.fst).sigma fun a => s.preimage (Sigma.mk a) sigma_mk_injective.injOn) =\n      s :=\n  s.sigma_preimage_mk_of_subset (Subset.refl _)\n\n"}
{"name":"Finset.preimage_inl","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ns : Finset (Sum α β)\n⊢ Eq (s.preimage Sum.inl ⋯) s.toLeft","decl":"@[simp] lemma preimage_inl (s : Finset (α ⊕ β)) :\n    s.preimage Sum.inl Sum.inl_injective.injOn = s.toLeft := by\n  ext x; simp\n\n"}
{"name":"Finset.preimage_inr","module":"Mathlib.Data.Finset.Preimage","initialProofState":"α : Type u\nβ : Type v\ns : Finset (Sum α β)\n⊢ Eq (s.preimage Sum.inr ⋯) s.toRight","decl":"@[simp] lemma preimage_inr (s : Finset (α ⊕ β)) :\n    s.preimage Sum.inr Sum.inr_injective.injOn = s.toRight := by\n  ext x; simp\n\n"}
