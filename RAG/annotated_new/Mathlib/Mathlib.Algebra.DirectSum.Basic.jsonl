{"name":"DirectSum.sub_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommGroup (β i)\ng₁ g₂ : DirectSum ι fun i => β i\ni : ι\n⊢ Eq ((HSub.hSub g₁ g₂) i) (HSub.hSub (g₁ i) (g₂ i))","decl":"@[simp]\ntheorem sub_apply (g₁ g₂ : ⨁ i, β i) (i : ι) : (g₁ - g₂) i = g₁ i - g₂ i :=\n  rfl\n\n"}
{"name":"DirectSum.ext_iff","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommMonoid (β i)\nx y : DirectSum ι β\n⊢ Iff (Eq x y) (∀ (i : ι), Eq (x i) (y i))","decl":"@[ext] theorem ext {x y : DirectSum ι β} (w : ∀ i, x i = y i) : x = y :=\n  DFunLike.ext _ _ w\n\n"}
{"name":"DirectSum.ext","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommMonoid (β i)\nx y : DirectSum ι β\nw : ∀ (i : ι), Eq (x i) (y i)\n⊢ Eq x y","decl":"@[ext] theorem ext {x y : DirectSum ι β} (w : ∀ i, x i = y i) : x = y :=\n  DFunLike.ext _ _ w\n\n"}
{"name":"DirectSum.zero_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommMonoid (β i)\ni : ι\n⊢ Eq (0 i) 0","decl":"@[simp]\ntheorem zero_apply (i : ι) : (0 : ⨁ i, β i) i = 0 :=\n  rfl\n\n"}
{"name":"DirectSum.add_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommMonoid (β i)\ng₁ g₂ : DirectSum ι fun i => β i\ni : ι\n⊢ Eq ((HAdd.hAdd g₁ g₂) i) (HAdd.hAdd (g₁ i) (g₂ i))","decl":"@[simp]\ntheorem add_apply (g₁ g₂ : ⨁ i, β i) (i : ι) : (g₁ + g₂) i = g₁ i + g₂ i :=\n  rfl\n\n"}
{"name":"DirectSum.of_eq_same","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ni : ι\nx : β i\n⊢ Eq (((DirectSum.of β i) x) i) x","decl":"@[simp]\ntheorem of_eq_same (i : ι) (x : β i) : (of _ i x) i = x :=\n  DFinsupp.single_eq_same\n\n"}
{"name":"DirectSum.of_eq_of_ne","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ni j : ι\nx : β i\nh : Ne i j\n⊢ Eq (((DirectSum.of β i) x) j) 0","decl":"theorem of_eq_of_ne (i j : ι) (x : β i) (h : i ≠ j) : (of _ i x) j = 0 :=\n  DFinsupp.single_eq_of_ne h\n\n"}
{"name":"DirectSum.of_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ni j : ι\nx : β i\n⊢ Eq (((DirectSum.of β i) x) j) (dite (Eq i j) (fun h => Eq.recOn h x) fun h => 0)","decl":"lemma of_apply {i : ι} (j : ι) (x : β i) : of β i x j = if h : i = j then Eq.recOn h x else 0 :=\n  DFinsupp.single_apply\n\n"}
{"name":"DirectSum.mk_apply_of_mem","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\nf : (i : ↑↑s) → β ↑i\nn : ι\nhn : Membership.mem s n\n⊢ Eq (((DirectSum.mk β s) f) n) (f ⟨n, hn⟩)","decl":"theorem mk_apply_of_mem {s : Finset ι} {f : ∀ i : (↑s : Set ι), β i.val} {n : ι} (hn : n ∈ s) :\n    mk β s f n = f ⟨n, hn⟩ := by\n  dsimp only [Finset.coe_sort_coe, mk, AddMonoidHom.coe_mk, ZeroHom.coe_mk, DFinsupp.mk_apply]\n  rw [dif_pos hn]\n\n"}
{"name":"DirectSum.mk_apply_of_not_mem","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\nf : (i : ↑↑s) → β ↑i\nn : ι\nhn : Not (Membership.mem s n)\n⊢ Eq (((DirectSum.mk β s) f) n) 0","decl":"theorem mk_apply_of_not_mem {s : Finset ι} {f : ∀ i : (↑s : Set ι), β i.val} {n : ι} (hn : n ∉ s) :\n    mk β s f n = 0 := by\n  dsimp only [Finset.coe_sort_coe, mk, AddMonoidHom.coe_mk, ZeroHom.coe_mk, DFinsupp.mk_apply]\n  rw [dif_neg hn]\n\n"}
{"name":"DirectSum.support_zero","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\n⊢ Eq (DFinsupp.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] : (0 : ⨁ i, β i).support = ∅ :=\n  DFinsupp.support_zero\n\n"}
{"name":"DirectSum.support_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nx : β i\nh : Ne x 0\n⊢ Eq (DFinsupp.support ((DirectSum.of β i) x)) (Singleton.singleton i)","decl":"@[simp]\ntheorem support_of [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (i : ι) (x : β i) (h : x ≠ 0) :\n    (of _ i x).support = {i} :=\n  DFinsupp.support_single_ne_zero h\n\n"}
{"name":"DirectSum.support_of_subset","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ni : ι\nb : β i\n⊢ HasSubset.Subset (DFinsupp.support ((DirectSum.of β i) b)) (Singleton.singleton i)","decl":"theorem support_of_subset [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] {i : ι} {b : β i} :\n    (of _ i b).support ⊆ {i} :=\n  DFinsupp.support_single_subset\n\n"}
{"name":"DirectSum.sum_support_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nx : DirectSum ι fun i => β i\n⊢ Eq ((DFinsupp.support x).sum fun i => (DirectSum.of β i) (x i)) x","decl":"theorem sum_support_of [∀ (i : ι) (x : β i), Decidable (x ≠ 0)] (x : ⨁ i, β i) :\n    (∑ i ∈ x.support, of β i (x i)) = x :=\n  DFinsupp.sum_single\n\n"}
{"name":"DirectSum.sum_univ_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx : DirectSum ι fun i => β i\n⊢ Eq (Finset.univ.sum fun i => (DirectSum.of β i) (x i)) x","decl":"theorem sum_univ_of [Fintype ι] (x : ⨁ i, β i) :\n    ∑ i ∈ Finset.univ, of β i (x i) = x := by\n  apply DFinsupp.ext (fun i ↦ ?_)\n  rw [DFinsupp.finset_sum_apply]\n  simp [of_apply]\n\n"}
{"name":"DirectSum.mk_injective","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ns : Finset ι\n⊢ Function.Injective ⇑(DirectSum.mk β s)","decl":"theorem mk_injective (s : Finset ι) : Function.Injective (mk β s) :=\n  DFinsupp.mk_injective s\n\n"}
{"name":"DirectSum.of_injective","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Function.Injective ⇑(DirectSum.of β i)","decl":"theorem of_injective (i : ι) : Function.Injective (of β i) :=\n  DFinsupp.single_injective\n\n"}
{"name":"DirectSum.induction_on","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : DecidableEq ι\nC : (DirectSum ι fun i => β i) → Prop\nx : DirectSum ι fun i => β i\nH_zero : C 0\nH_basic : ∀ (i : ι) (x : β i), C ((DirectSum.of β i) x)\nH_plus : ∀ (x y : DirectSum ι fun i => β i), C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"@[elab_as_elim]\nprotected theorem induction_on {C : (⨁ i, β i) → Prop} (x : ⨁ i, β i) (H_zero : C 0)\n    (H_basic : ∀ (i : ι) (x : β i), C (of β i x))\n    (H_plus : ∀ x y, C x → C y → C (x + y)) : C x := by\n  apply DFinsupp.induction x H_zero\n  intro i b f h1 h2 ih\n  solve_by_elim\n\n"}
{"name":"DirectSum.addHom_ext","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u_1\ninst✝ : AddMonoid γ\nf g : AddMonoidHom (DirectSum ι fun i => β i) γ\nH : ∀ (i : ι) (y : β i), Eq (f ((DirectSum.of β i) y)) (g ((DirectSum.of β i) y))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,\nthen they are equal. -/\ntheorem addHom_ext {γ : Type*} [AddMonoid γ] ⦃f g : (⨁ i, β i) →+ γ⦄\n    (H : ∀ (i : ι) (y : β i), f (of _ i y) = g (of _ i y)) : f = g :=\n  DFinsupp.addHom_ext H\n\n"}
{"name":"DirectSum.addHom_ext'_iff","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u_1\ninst✝ : AddMonoid γ\nf g : AddMonoidHom (DirectSum ι fun i => β i) γ\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.comp (DirectSum.of β i)) (g.comp (DirectSum.of β i)))","decl":"/-- If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,\nthen they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem addHom_ext' {γ : Type*} [AddMonoid γ] ⦃f g : (⨁ i, β i) →+ γ⦄\n    (H : ∀ i : ι, f.comp (of _ i) = g.comp (of _ i)) : f = g :=\n  addHom_ext fun i => DFunLike.congr_fun <| H i\n\n"}
{"name":"DirectSum.addHom_ext'","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u_1\ninst✝ : AddMonoid γ\nf g : AddMonoidHom (DirectSum ι fun i => β i) γ\nH : ∀ (i : ι), Eq (f.comp (DirectSum.of β i)) (g.comp (DirectSum.of β i))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `⨁ i, β i` are equal on each `of β i y`,\nthen they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem addHom_ext' {γ : Type*} [AddMonoid γ] ⦃f g : (⨁ i, β i) →+ γ⦄\n    (H : ∀ i : ι, f.comp (of _ i) = g.comp (of _ i)) : f = g :=\n  addHom_ext fun i => DFunLike.congr_fun <| H i\n\n"}
{"name":"DirectSum.toAddMonoid_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\nφ : (i : ι) → AddMonoidHom (β i) γ\ni : ι\nx : β i\n⊢ Eq ((DirectSum.toAddMonoid φ) ((DirectSum.of β i) x)) ((φ i) x)","decl":"@[simp]\ntheorem toAddMonoid_of (i) (x : β i) : toAddMonoid φ (of β i x) = φ i x :=\n  DFinsupp.liftAddHom_apply_single φ i x\n\n"}
{"name":"DirectSum.toAddMonoid.unique","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\nψ : AddMonoidHom (DirectSum ι fun i => β i) γ\nf : DirectSum ι fun i => β i\n⊢ Eq (ψ f) ((DirectSum.toAddMonoid fun i => ψ.comp (DirectSum.of β i)) f)","decl":"theorem toAddMonoid.unique (f : ⨁ i, β i) : ψ f = toAddMonoid (fun i => ψ.comp (of β i)) f := by\n  congr\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` applies addHom_ext' here, which isn't what we want.\n  apply DFinsupp.addHom_ext'\n  simp [toAddMonoid, of]\n\n"}
{"name":"DirectSum.toAddMonoid_injective","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\n⊢ Function.Injective DirectSum.toAddMonoid","decl":"lemma toAddMonoid_injective : Injective (toAddMonoid : (∀ i, β i →+ γ) → (⨁ i, β i) →+ γ) :=\n  DFinsupp.liftAddHom.injective\n\n"}
{"name":"DirectSum.toAddMonoid_inj","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\nf g : (i : ι) → AddMonoidHom (β i) γ\n⊢ Iff (Eq (DirectSum.toAddMonoid f) (DirectSum.toAddMonoid g)) (Eq f g)","decl":"@[simp] lemma toAddMonoid_inj {f g : ∀ i, β i →+ γ} : toAddMonoid f = toAddMonoid g ↔ f = g :=\n  toAddMonoid_injective.eq_iff\n\n"}
{"name":"DirectSum.fromAddMonoid_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\ni : ι\nf : AddMonoidHom γ (β i)\n⊢ Eq (DirectSum.fromAddMonoid ((DirectSum.of (fun i => AddMonoidHom γ (β i)) i) f)) ((DirectSum.of β i).comp f)","decl":"@[simp]\ntheorem fromAddMonoid_of (i : ι) (f : γ →+ β i) : fromAddMonoid (of _ i f) = (of _ i).comp f := by\n  rw [fromAddMonoid, toAddMonoid_of]\n  rfl\n\n"}
{"name":"DirectSum.fromAddMonoid_of_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : DecidableEq ι\nγ : Type u₁\ninst✝ : AddCommMonoid γ\ni : ι\nf : AddMonoidHom γ (β i)\nx : γ\n⊢ Eq ((DirectSum.fromAddMonoid ((DirectSum.of (fun i => AddMonoidHom γ (β i)) i) f)) x) ((DirectSum.of β i) (f x))","decl":"theorem fromAddMonoid_of_apply (i : ι) (f : γ →+ β i) (x : γ) :\n    fromAddMonoid (of _ i f) x = of _ i (f x) := by\n      rw [fromAddMonoid_of, AddMonoidHom.coe_comp, Function.comp]\n\n"}
{"name":"DirectSum.equivCongrLeft_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nβ : ι → Type w\ninst✝ : (i : ι) → AddCommMonoid (β i)\nκ : Type u_1\nh : Equiv ι κ\nf : DirectSum ι fun i => β i\nk : κ\n⊢ Eq (((DirectSum.equivCongrLeft h) f) k) (f (h.symm k))","decl":"@[simp]\ntheorem equivCongrLeft_apply (h : ι ≃ κ) (f : ⨁ i, β i) (k : κ) :\n    equivCongrLeft h f k = f (h.symm k) := by\n  exact DFinsupp.comapDomain'_apply _ h.right_inv _ _\n\n"}
{"name":"DirectSum.addEquivProdDirectSum_symm_apply_support'","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nα : Option ι → Type w\ninst✝ : (i : Option ι) → AddCommMonoid (α i)\nf : Prod ((fun i => α i) Option.none) (DFinsupp fun i => (fun i => α i) (Option.some i))\n⊢ Eq (DirectSum.addEquivProdDirectSum.symm f).support' (Trunc.map (fun s => ⟨Multiset.cons Option.none (Multiset.map Option.some ↑s), ⋯⟩) f.2.support')","decl":"/-- Isomorphism obtained by separating the term of index `none` of a direct sum over `Option ι`. -/\n@[simps!]\nnoncomputable def addEquivProdDirectSum : (⨁ i, α i) ≃+ α none × ⨁ i, α (some i) :=\n  { DFinsupp.equivProdDFinsupp with map_add' := DFinsupp.equivProdDFinsupp_add }\n\n"}
{"name":"DirectSum.addEquivProdDirectSum_symm_apply_toFun","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nα : Option ι → Type w\ninst✝ : (i : Option ι) → AddCommMonoid (α i)\nf : Prod ((fun i => α i) Option.none) (DFinsupp fun i => (fun i => α i) (Option.some i))\ni : Option ι\n⊢ Eq ((DirectSum.addEquivProdDirectSum.symm f) i) (DFinsupp.extendWith.match_1 (fun i => α i) i (fun _ => f.1) fun val => f.2 val)","decl":"/-- Isomorphism obtained by separating the term of index `none` of a direct sum over `Option ι`. -/\n@[simps!]\nnoncomputable def addEquivProdDirectSum : (⨁ i, α i) ≃+ α none × ⨁ i, α (some i) :=\n  { DFinsupp.equivProdDFinsupp with map_add' := DFinsupp.equivProdDFinsupp_add }\n\n"}
{"name":"DirectSum.addEquivProdDirectSum_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nα : Option ι → Type w\ninst✝ : (i : Option ι) → AddCommMonoid (α i)\nf : DFinsupp fun i => (fun i => α i) i\n⊢ Eq (DirectSum.addEquivProdDirectSum f) { fst := f Option.none, snd := DFinsupp.comapDomain Option.some ⋯ f }","decl":"/-- Isomorphism obtained by separating the term of index `none` of a direct sum over `Option ι`. -/\n@[simps!]\nnoncomputable def addEquivProdDirectSum : (⨁ i, α i) ≃+ α none × ⨁ i, α (some i) :=\n  { DFinsupp.equivProdDFinsupp with map_add' := DFinsupp.equivProdDFinsupp_add }\n\n"}
{"name":"DirectSum.sigmaCurry_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\ninst✝¹ : DecidableEq ι\nα : ι → Type u\nδ : (i : ι) → α i → Type w\ninst✝ : (i : ι) → (j : α i) → AddCommMonoid (δ i j)\nf : DirectSum (Sigma fun _i => α _i) fun i => δ i.fst i.snd\ni : ι\nj : α i\n⊢ Eq (((DirectSum.sigmaCurry f) i) j) (f ⟨i, j⟩)","decl":"@[simp]\ntheorem sigmaCurry_apply (f : ⨁ i : Σ _i, _, δ i.1 i.2) (i : ι) (j : α i) :\n    sigmaCurry f i j = f ⟨i, j⟩ :=\n  DFinsupp.sigmaCurry_apply (δ := δ) _ i j\n\n"}
{"name":"DirectSum.sigmaUncurry_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\ninst✝¹ : DecidableEq ι\nα : ι → Type u\nδ : (i : ι) → α i → Type w\ninst✝ : (i : ι) → (j : α i) → AddCommMonoid (δ i j)\nf : DirectSum ι fun i => DirectSum (α i) fun j => δ i j\ni : ι\nj : α i\n⊢ Eq ((DirectSum.sigmaUncurry f) ⟨i, j⟩) ((f i) j)","decl":"@[simp]\ntheorem sigmaUncurry_apply (f : ⨁ (i) (j), δ i j) (i : ι) (j : α i) :\n    sigmaUncurry f ⟨i, j⟩ = f i j :=\n  DFinsupp.sigmaUncurry_apply f i j\n\n"}
{"name":"DirectSum.coeAddMonoidHom_eq_dfinsupp_sum","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\ninst✝⁴ : DecidableEq ι\nM : Type u_1\nS : Type u_2\ninst✝³ : DecidableEq M\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nA : ι → S\nx : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeAddMonoidHom A) x) (DFinsupp.sum x fun i x => ↑x)","decl":"theorem coeAddMonoidHom_eq_dfinsupp_sum [DecidableEq ι]\n    {M S : Type*} [DecidableEq M] [AddCommMonoid M]\n    [SetLike S M] [AddSubmonoidClass S M] (A : ι → S) (x : DirectSum ι fun i => A i) :\n    DirectSum.coeAddMonoidHom A x = DFinsupp.sum x fun i => (fun x : A i => ↑x) := by\n  simp only [DirectSum.coeAddMonoidHom, toAddMonoid, DFinsupp.liftAddHom, AddEquiv.coe_mk,\n    Equiv.coe_fn_mk]\n  exact DFinsupp.sumAddHom_apply _ x\n\n"}
{"name":"DirectSum.coeAddMonoidHom_of","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nM : Type u_1\nS : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nA : ι → S\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeAddMonoidHom A) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) x)) ↑x","decl":"@[simp]\ntheorem coeAddMonoidHom_of {M S : Type*} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] (A : ι → S) (i : ι) (x : A i) :\n    DirectSum.coeAddMonoidHom A (of (fun i => A i) i x) = x :=\n  toAddMonoid_of _ _ _\n\n"}
{"name":"DirectSum.coe_of_apply","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nM : Type u_1\nS : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nA : ι → S\ni j : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq ↑(((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) x) j) ↑(ite (Eq i j) x 0)","decl":"theorem coe_of_apply {M S : Type*} [DecidableEq ι] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] {A : ι → S} (i j : ι) (x : A i) :\n    (of (fun i ↦ {x // x ∈ A i}) i x j : M) = if i = j then x else 0 := by\n  obtain rfl | h := Decidable.eq_or_ne i j\n  · rw [DirectSum.of_eq_same, if_pos rfl]\n  · rw [DirectSum.of_eq_of_ne _ _ _ h, if_neg h, ZeroMemClass.coe_zero, ZeroMemClass.coe_zero]\n\n"}
{"name":"DirectSum.IsInternal.addSubmonoid_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nM : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid M\nA : ι → AddSubmonoid M\nh : DirectSum.IsInternal A\n⊢ Eq (iSup A) Top.top","decl":"theorem IsInternal.addSubmonoid_iSup_eq_top {M : Type*} [DecidableEq ι] [AddCommMonoid M]\n    (A : ι → AddSubmonoid M) (h : IsInternal A) : iSup A = ⊤ := by\n  rw [AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom, AddMonoidHom.mrange_eq_top]\n  exact Function.Bijective.surjective h\n\n"}
{"name":"DirectSum.support_subset","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nM : Type u_1\nS : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : SetLike S M\ninst✝² : AddSubmonoidClass S M\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq M\nA : ι → S\nx : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\n⊢ HasSubset.Subset (Function.support fun i => ↑(x i)) ↑(DFinsupp.support x)","decl":"theorem support_subset [DecidableEq ι] [DecidableEq M] (A : ι → S) (x : DirectSum ι fun i => A i) :\n    (Function.support fun i => (x i : M)) ⊆ ↑(DFinsupp.support x) := by\n  intro m\n  simp only [Function.mem_support, Finset.mem_coe, DFinsupp.mem_support_toFun, not_imp_not,\n    ZeroMemClass.coe_eq_zero, imp_self]\n\n"}
{"name":"DirectSum.finite_support","module":"Mathlib.Algebra.DirectSum.Basic","initialProofState":"ι : Type v\nM : Type u_1\nS : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nA : ι → S\nx : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\n⊢ (Function.support fun i => ↑(x i)).Finite","decl":"theorem finite_support (A : ι → S) (x : DirectSum ι fun i => A i) :\n    (Function.support fun i => (x i : M)).Finite := by\n  classical\n  exact (DFinsupp.support x).finite_toSet.subset (DirectSum.support_subset _ x)\n\n"}
