{"name":"CategoryTheory.InjectiveResolution.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : SizeOf C\ncocomplex : CochainComplex C Nat\ninjective : autoParam (∀ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nι : Quiver.Hom ((CochainComplex.single₀ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso ι) _auto✝\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.InjectiveResolution.mk cocomplex injective ι quasiIso)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cocomplex)) (SizeOf.sizeOf ι)) (SizeOf.sizeOf quasiIso))","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.quasiIso","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\n⊢ QuasiIso self.ι","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.hasHomology","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\ni : Nat\n⊢ HomologicalComplex.HasHomology self.cocomplex i","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncocomplex✝ : CochainComplex C Nat\ninjective✝ : autoParam (∀ (n : Nat), CategoryTheory.Injective (cocomplex✝.X n)) _auto✝\nhasHomology✝ : ∀ (i : Nat), HomologicalComplex.HasHomology cocomplex✝ i\nι✝ : Quiver.Hom ((CochainComplex.single₀ C).obj Z) cocomplex✝\nquasiIso✝ : autoParam (QuasiIso ι✝) _auto✝\ncocomplex : CochainComplex C Nat\ninjective : autoParam (∀ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nι : Quiver.Hom ((CochainComplex.single₀ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso ι) _auto✝\nx✝ : Eq (CategoryTheory.InjectiveResolution.mk cocomplex✝ injective✝ ι✝ quasiIso✝) (CategoryTheory.InjectiveResolution.mk cocomplex injective ι quasiIso)\n⊢ And (Eq cocomplex✝ cocomplex) (HEq ι✝ ι)","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.injective","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ CategoryTheory.Injective (self.cocomplex.X n)","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncocomplex✝ : CochainComplex C Nat\ninjective✝ : autoParam (∀ (n : Nat), CategoryTheory.Injective (cocomplex✝.X n)) _auto✝\nhasHomology✝ : ∀ (i : Nat), HomologicalComplex.HasHomology cocomplex✝ i\nι✝ : Quiver.Hom ((CochainComplex.single₀ C).obj Z) cocomplex✝\nquasiIso✝ : autoParam (QuasiIso ι✝) _auto✝\ncocomplex : CochainComplex C Nat\ninjective : autoParam (∀ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nι : Quiver.Hom ((CochainComplex.single₀ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso ι) _auto✝\n⊢ Eq (Eq (CategoryTheory.InjectiveResolution.mk cocomplex✝ injective✝ ι✝ quasiIso✝) (CategoryTheory.InjectiveResolution.mk cocomplex injective ι quasiIso)) (And (Eq cocomplex✝ cocomplex) (HEq ι✝ ι))","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ℕ\n  /-- the cochain complex must be degreewise injective -/\n  injective : ∀ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ∀ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  ι : (single₀ C).obj Z ⟶ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso ι := by infer_instance\n\n"}
{"name":"CategoryTheory.HasInjectiveResolution.out","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.HasInjectiveResolution Z\n⊢ Nonempty (CategoryTheory.InjectiveResolution Z)","decl":"/-- An object admits an injective resolution. -/\nclass HasInjectiveResolution (Z : C) : Prop where\n  out : Nonempty (InjectiveResolution Z)\n\n"}
{"name":"CategoryTheory.HasInjectiveResolutions.out","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.HasInjectiveResolutions C\nZ : C\n⊢ CategoryTheory.HasInjectiveResolution Z","decl":"/-- You will rarely use this typeclass directly: it is implied by the combination\n`[EnoughInjectives C]` and `[Abelian C]`. -/\nclass HasInjectiveResolutions : Prop where\n  out : ∀ Z : C, HasInjectiveResolution Z\n\n"}
{"name":"CategoryTheory.InjectiveResolution.cocomplex_exactAt_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ HomologicalComplex.ExactAt I.cocomplex (HAdd.hAdd n 1)","decl":"lemma cocomplex_exactAt_succ (n : ℕ) :\n    I.cocomplex.ExactAt (n + 1) := by\n  rw [← quasiIsoAt_iff_exactAt I.ι (n + 1) (exactAt_succ_single_obj _ _)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.exact_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ (CategoryTheory.ShortComplex.mk (I.cocomplex.d n (HAdd.hAdd n 1)) (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) ⋯).Exact","decl":"lemma exact_succ (n : ℕ) :\n    (ShortComplex.mk _ _ (I.cocomplex.d_comp_d n (n + 1) (n + 2))).Exact :=\n  (HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 2) (by simp)\n    (by simp only [CochainComplex.next]; rfl)).1 (I.cocomplex_exactAt_succ n)\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ι_f_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ Eq (I.ι.f (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem ι_f_succ (n : ℕ) : I.ι.f (n + 1) = 0 :=\n  (isZero_single_obj_X _ _ _ _ (by simp)).eq_of_src _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ι_f_zero_comp_complex_d","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (I.cocomplex.d 0 1)) 0","decl":"@[reassoc]\ntheorem ι_f_zero_comp_complex_d :\n    I.ι.f 0 ≫ I.cocomplex.d 0 1 = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ι_f_zero_comp_complex_d_assoc","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ✝ : C\nI : CategoryTheory.InjectiveResolution Z✝\nZ : C\nh : Quiver.Hom (I.cocomplex.X 1) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem ι_f_zero_comp_complex_d :\n    I.ι.f 0 ≫ I.cocomplex.d 0 1 = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.complex_d_comp","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d n (HAdd.hAdd n 1)) (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) 0","decl":"theorem complex_d_comp (n : ℕ) :\n    I.cocomplex.d n (n + 1) ≫ I.cocomplex.d (n + 1) (n + 2) = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instMonoFNatι","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n⊢ CategoryTheory.Mono (I.ι.f n)","decl":"instance (n : ℕ) : Mono (I.ι.f n) := by\n  cases n\n  · exact mono_of_isLimit_fork I.isLimitKernelFork\n  · rw [ι_f_succ]; infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.self_ι","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : CategoryTheory.Injective Z\n⊢ Eq (CategoryTheory.InjectiveResolution.self Z).ι (CategoryTheory.CategoryStruct.id ((CochainComplex.single₀ C).obj Z))","decl":"/-- An injective object admits a trivial injective resolution: itself in degree 0. -/\n@[simps]\ndef self [Injective Z] : InjectiveResolution Z where\n  cocomplex := (CochainComplex.single₀ C).obj Z\n  ι := 𝟙 ((CochainComplex.single₀ C).obj Z)\n  injective n := by\n    cases n\n    · simpa\n    · apply IsZero.injective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.self_cocomplex","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : CategoryTheory.Injective Z\n⊢ Eq (CategoryTheory.InjectiveResolution.self Z).cocomplex ((CochainComplex.single₀ C).obj Z)","decl":"/-- An injective object admits a trivial injective resolution: itself in degree 0. -/\n@[simps]\ndef self [Injective Z] : InjectiveResolution Z where\n  cocomplex := (CochainComplex.single₀ C).obj Z\n  ι := 𝟙 ((CochainComplex.single₀ C).obj Z)\n  injective n := by\n    cases n\n    · simpa\n    · apply IsZero.injective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
