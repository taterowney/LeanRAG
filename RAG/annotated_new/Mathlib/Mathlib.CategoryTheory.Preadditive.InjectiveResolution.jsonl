{"name":"CategoryTheory.InjectiveResolution.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst‚úù : SizeOf C\ncocomplex : CochainComplex C Nat\ninjective : autoParam (‚àÄ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto‚úù\nhasHomology : ‚àÄ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nŒπ : Quiver.Hom ((CochainComplex.single‚ÇÄ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso Œπ) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.InjectiveResolution.mk cocomplex injective Œπ quasiIso)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cocomplex)) (SizeOf.sizeOf Œπ)) (SizeOf.sizeOf quasiIso))","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.quasiIso","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\n‚ä¢ QuasiIso self.Œπ","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.hasHomology","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\ni : Nat\n‚ä¢ HomologicalComplex.HasHomology self.cocomplex i","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncocomplex‚úù : CochainComplex C Nat\ninjective‚úù : autoParam (‚àÄ (n : Nat), CategoryTheory.Injective (cocomplex‚úù.X n)) _auto‚úù\nhasHomology‚úù : ‚àÄ (i : Nat), HomologicalComplex.HasHomology cocomplex‚úù i\nŒπ‚úù : Quiver.Hom ((CochainComplex.single‚ÇÄ C).obj Z) cocomplex‚úù\nquasiIso‚úù : autoParam (QuasiIso Œπ‚úù) _auto‚úù\ncocomplex : CochainComplex C Nat\ninjective : autoParam (‚àÄ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto‚úù\nhasHomology : ‚àÄ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nŒπ : Quiver.Hom ((CochainComplex.single‚ÇÄ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso Œπ) _auto‚úù\nx‚úù : Eq (CategoryTheory.InjectiveResolution.mk cocomplex‚úù injective‚úù Œπ‚úù quasiIso‚úù) (CategoryTheory.InjectiveResolution.mk cocomplex injective Œπ quasiIso)\n‚ä¢ And (Eq cocomplex‚úù cocomplex) (HEq Œπ‚úù Œπ)","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.injective","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ CategoryTheory.Injective (self.cocomplex.X n)","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncocomplex‚úù : CochainComplex C Nat\ninjective‚úù : autoParam (‚àÄ (n : Nat), CategoryTheory.Injective (cocomplex‚úù.X n)) _auto‚úù\nhasHomology‚úù : ‚àÄ (i : Nat), HomologicalComplex.HasHomology cocomplex‚úù i\nŒπ‚úù : Quiver.Hom ((CochainComplex.single‚ÇÄ C).obj Z) cocomplex‚úù\nquasiIso‚úù : autoParam (QuasiIso Œπ‚úù) _auto‚úù\ncocomplex : CochainComplex C Nat\ninjective : autoParam (‚àÄ (n : Nat), CategoryTheory.Injective (cocomplex.X n)) _auto‚úù\nhasHomology : ‚àÄ (i : Nat), HomologicalComplex.HasHomology cocomplex i\nŒπ : Quiver.Hom ((CochainComplex.single‚ÇÄ C).obj Z) cocomplex\nquasiIso : autoParam (QuasiIso Œπ) _auto‚úù\n‚ä¢ Eq (Eq (CategoryTheory.InjectiveResolution.mk cocomplex‚úù injective‚úù Œπ‚úù quasiIso‚úù) (CategoryTheory.InjectiveResolution.mk cocomplex injective Œπ quasiIso)) (And (Eq cocomplex‚úù cocomplex) (HEq Œπ‚úù Œπ))","decl":"/--\nAn `InjectiveResolution Z` consists of a bundled `‚Ñï`-indexed cochain complex of injective objects,\nalong with a quasi-isomorphism from the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure InjectiveResolution (Z : C) where\n  /-- the cochain complex involved in the resolution -/\n  cocomplex : CochainComplex C ‚Ñï\n  /-- the cochain complex must be degreewise injective -/\n  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance\n  /-- the cochain complex must have homology -/\n  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]\n  /-- the morphism from the single cochain complex with `Z` in degree `0` -/\n  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex\n  /-- the morphism from the single cochain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso Œπ := by infer_instance\n\n"}
{"name":"CategoryTheory.HasInjectiveResolution.out","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.HasInjectiveResolution Z\n‚ä¢ Nonempty (CategoryTheory.InjectiveResolution Z)","decl":"/-- An object admits an injective resolution. -/\nclass HasInjectiveResolution (Z : C) : Prop where\n  out : Nonempty (InjectiveResolution Z)\n\n"}
{"name":"CategoryTheory.HasInjectiveResolutions.out","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.HasInjectiveResolutions C\nZ : C\n‚ä¢ CategoryTheory.HasInjectiveResolution Z","decl":"/-- You will rarely use this typeclass directly: it is implied by the combination\n`[EnoughInjectives C]` and `[Abelian C]`. -/\nclass HasInjectiveResolutions : Prop where\n  out : ‚àÄ Z : C, HasInjectiveResolution Z\n\n"}
{"name":"CategoryTheory.InjectiveResolution.cocomplex_exactAt_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ HomologicalComplex.ExactAt I.cocomplex (HAdd.hAdd n 1)","decl":"lemma cocomplex_exactAt_succ (n : ‚Ñï) :\n    I.cocomplex.ExactAt (n + 1) := by\n  rw [‚Üê quasiIsoAt_iff_exactAt I.Œπ (n + 1) (exactAt_succ_single_obj _ _)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.exact_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ (CategoryTheory.ShortComplex.mk (I.cocomplex.d n (HAdd.hAdd n 1)) (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) ‚ãØ).Exact","decl":"lemma exact_succ (n : ‚Ñï) :\n    (ShortComplex.mk _ _ (I.cocomplex.d_comp_d n (n + 1) (n + 2))).Exact :=\n  (HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 2) (by simp)\n    (by simp only [CochainComplex.next]; rfl)).1 (I.cocomplex_exactAt_succ n)\n\n"}
{"name":"CategoryTheory.InjectiveResolution.Œπ_f_succ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ Eq (I.Œπ.f (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem Œπ_f_succ (n : ‚Ñï) : I.Œπ.f (n + 1) = 0 :=\n  (isZero_single_obj_X _ _ _ _ (by simp)).eq_of_src _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.Œπ_f_zero_comp_complex_d","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (I.cocomplex.d 0 1)) 0","decl":"@[reassoc]\ntheorem Œπ_f_zero_comp_complex_d :\n    I.Œπ.f 0 ‚â´ I.cocomplex.d 0 1 = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.Œπ_f_zero_comp_complex_d_assoc","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ‚úù : C\nI : CategoryTheory.InjectiveResolution Z‚úù\nZ : C\nh : Quiver.Hom (I.cocomplex.X 1) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem Œπ_f_zero_comp_complex_d :\n    I.Œπ.f 0 ‚â´ I.cocomplex.d 0 1 = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.complex_d_comp","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d n (HAdd.hAdd n 1)) (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) 0","decl":"theorem complex_d_comp (n : ‚Ñï) :\n    I.cocomplex.d n (n + 1) ‚â´ I.cocomplex.d (n + 1) (n + 2) = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instMonoFNatŒπ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\nn : Nat\n‚ä¢ CategoryTheory.Mono (I.Œπ.f n)","decl":"instance (n : ‚Ñï) : Mono (I.Œπ.f n) := by\n  cases n\n  ¬∑ exact mono_of_isLimit_fork I.isLimitKernelFork\n  ¬∑ rw [Œπ_f_succ]; infer_instance\n\n"}
{"name":"CategoryTheory.InjectiveResolution.self_Œπ","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst‚úù : CategoryTheory.Injective Z\n‚ä¢ Eq (CategoryTheory.InjectiveResolution.self Z).Œπ (CategoryTheory.CategoryStruct.id ((CochainComplex.single‚ÇÄ C).obj Z))","decl":"/-- An injective object admits a trivial injective resolution: itself in degree 0. -/\n@[simps]\ndef self [Injective Z] : InjectiveResolution Z where\n  cocomplex := (CochainComplex.single‚ÇÄ C).obj Z\n  Œπ := ùüô ((CochainComplex.single‚ÇÄ C).obj Z)\n  injective n := by\n    cases n\n    ¬∑ simpa\n    ¬∑ apply IsZero.injective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
{"name":"CategoryTheory.InjectiveResolution.self_cocomplex","module":"Mathlib.CategoryTheory.Preadditive.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst‚úù : CategoryTheory.Injective Z\n‚ä¢ Eq (CategoryTheory.InjectiveResolution.self Z).cocomplex ((CochainComplex.single‚ÇÄ C).obj Z)","decl":"/-- An injective object admits a trivial injective resolution: itself in degree 0. -/\n@[simps]\ndef self [Injective Z] : InjectiveResolution Z where\n  cocomplex := (CochainComplex.single‚ÇÄ C).obj Z\n  Œπ := ùüô ((CochainComplex.single‚ÇÄ C).obj Z)\n  injective n := by\n    cases n\n    ¬∑ simpa\n    ¬∑ apply IsZero.injective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
