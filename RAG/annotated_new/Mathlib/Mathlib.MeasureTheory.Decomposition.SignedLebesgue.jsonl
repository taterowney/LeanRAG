{"name":"MeasureTheory.SignedMeasure.HaveLebesgueDecomposition.posPart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\nself : s.HaveLebesgueDecomposition μ\n⊢ s.toJordanDecomposition.posPart.HaveLebesgueDecomposition μ","decl":"/-- A signed measure `s` is said to `HaveLebesgueDecomposition` with respect to a measure `μ`\nif the positive part and the negative part of `s` both `HaveLebesgueDecomposition` with\nrespect to `μ`. -/\nclass HaveLebesgueDecomposition (s : SignedMeasure α) (μ : Measure α) : Prop where\n  posPart : s.toJordanDecomposition.posPart.HaveLebesgueDecomposition μ\n  negPart : s.toJordanDecomposition.negPart.HaveLebesgueDecomposition μ\n\n"}
{"name":"MeasureTheory.SignedMeasure.HaveLebesgueDecomposition.negPart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\nself : s.HaveLebesgueDecomposition μ\n⊢ s.toJordanDecomposition.negPart.HaveLebesgueDecomposition μ","decl":"/-- A signed measure `s` is said to `HaveLebesgueDecomposition` with respect to a measure `μ`\nif the positive part and the negative part of `s` both `HaveLebesgueDecomposition` with\nrespect to `μ`. -/\nclass HaveLebesgueDecomposition (s : SignedMeasure α) (μ : Measure α) : Prop where\n  posPart : s.toJordanDecomposition.posPart.HaveLebesgueDecomposition μ\n  negPart : s.toJordanDecomposition.negPart.HaveLebesgueDecomposition μ\n\n"}
{"name":"MeasureTheory.SignedMeasure.not_haveLebesgueDecomposition_iff","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Iff (Not (s.HaveLebesgueDecomposition μ)) (Or (Not (s.toJordanDecomposition.posPart.HaveLebesgueDecomposition μ)) (Not (s.toJordanDecomposition.negPart.HaveLebesgueDecomposition μ)))","decl":"theorem not_haveLebesgueDecomposition_iff (s : SignedMeasure α) (μ : Measure α) :\n    ¬s.HaveLebesgueDecomposition μ ↔\n      ¬s.toJordanDecomposition.posPart.HaveLebesgueDecomposition μ ∨\n        ¬s.toJordanDecomposition.negPart.HaveLebesgueDecomposition μ :=\n  ⟨fun h => not_or_of_imp fun hp hn => h ⟨hp, hn⟩, fun h hl => (not_and_or.2 h) ⟨hl.1, hl.2⟩⟩\n\n-- `inferInstance` directly does not work\n-- see Note [lower instance priority]\n"}
{"name":"MeasureTheory.SignedMeasure.haveLebesgueDecomposition_of_sigmaFinite","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ s.HaveLebesgueDecomposition μ","decl":"instance (priority := 100) haveLebesgueDecomposition_of_sigmaFinite (s : SignedMeasure α)\n    (μ : Measure α) [SigmaFinite μ] : s.HaveLebesgueDecomposition μ where\n  posPart := inferInstance\n  negPart := inferInstance\n\n"}
{"name":"MeasureTheory.SignedMeasure.haveLebesgueDecomposition_neg","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : s.HaveLebesgueDecomposition μ\n⊢ (Neg.neg s).HaveLebesgueDecomposition μ","decl":"instance haveLebesgueDecomposition_neg (s : SignedMeasure α) (μ : Measure α)\n    [s.HaveLebesgueDecomposition μ] : (-s).HaveLebesgueDecomposition μ where\n  posPart := by\n    rw [toJordanDecomposition_neg, JordanDecomposition.neg_posPart]\n    infer_instance\n  negPart := by\n    rw [toJordanDecomposition_neg, JordanDecomposition.neg_negPart]\n    infer_instance\n\n"}
{"name":"MeasureTheory.SignedMeasure.haveLebesgueDecomposition_smul","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : s.HaveLebesgueDecomposition μ\nr : NNReal\n⊢ (HSMul.hSMul r s).HaveLebesgueDecomposition μ","decl":"instance haveLebesgueDecomposition_smul (s : SignedMeasure α) (μ : Measure α)\n    [s.HaveLebesgueDecomposition μ] (r : ℝ≥0) : (r • s).HaveLebesgueDecomposition μ where\n  posPart := by\n    rw [toJordanDecomposition_smul, JordanDecomposition.smul_posPart]\n    infer_instance\n  negPart := by\n    rw [toJordanDecomposition_smul, JordanDecomposition.smul_negPart]\n    infer_instance\n\n"}
{"name":"MeasureTheory.SignedMeasure.haveLebesgueDecomposition_smul_real","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : s.HaveLebesgueDecomposition μ\nr : Real\n⊢ (HSMul.hSMul r s).HaveLebesgueDecomposition μ","decl":"instance haveLebesgueDecomposition_smul_real (s : SignedMeasure α) (μ : Measure α)\n    [s.HaveLebesgueDecomposition μ] (r : ℝ) : (r • s).HaveLebesgueDecomposition μ := by\n  by_cases hr : 0 ≤ r\n  · lift r to ℝ≥0 using hr\n    exact s.haveLebesgueDecomposition_smul μ _\n  · rw [not_le] at hr\n    refine\n      { posPart := by\n          rw [toJordanDecomposition_smul_real, JordanDecomposition.real_smul_posPart_neg _ _ hr]\n          infer_instance\n        negPart := by\n          rw [toJordanDecomposition_smul_real, JordanDecomposition.real_smul_negPart_neg _ _ hr]\n          infer_instance }\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ (s.toJordanDecomposition.posPart.singularPart μ).MutuallySingular (s.toJordanDecomposition.negPart.singularPart μ)","decl":"theorem singularPart_mutuallySingular (s : SignedMeasure α) (μ : Measure α) :\n    s.toJordanDecomposition.posPart.singularPart μ ⟂ₘ\n      s.toJordanDecomposition.negPart.singularPart μ := by\n  by_cases hl : s.HaveLebesgueDecomposition μ\n  · obtain ⟨i, hi, hpos, hneg⟩ := s.toJordanDecomposition.mutuallySingular\n    rw [s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add μ] at hpos\n    rw [s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add μ] at hneg\n    rw [add_apply, add_eq_zero] at hpos hneg\n    exact ⟨i, hi, hpos.1, hneg.1⟩\n  · rw [not_haveLebesgueDecomposition_iff] at hl\n    cases' hl with hp hn\n    · rw [Measure.singularPart, dif_neg hp]\n      exact MutuallySingular.zero_left\n    · rw [Measure.singularPart, Measure.singularPart, dif_neg hn]\n      exact MutuallySingular.zero_right\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_totalVariation","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Eq (s.singularPart μ).totalVariation (HAdd.hAdd (s.toJordanDecomposition.posPart.singularPart μ) (s.toJordanDecomposition.negPart.singularPart μ))","decl":"theorem singularPart_totalVariation (s : SignedMeasure α) (μ : Measure α) :\n    (s.singularPart μ).totalVariation =\n      s.toJordanDecomposition.posPart.singularPart μ +\n        s.toJordanDecomposition.negPart.singularPart μ := by\n  have :\n    (s.singularPart μ).toJordanDecomposition =\n      ⟨s.toJordanDecomposition.posPart.singularPart μ,\n        s.toJordanDecomposition.negPart.singularPart μ, singularPart_mutuallySingular s μ⟩ := by\n    refine JordanDecomposition.toSignedMeasure_injective ?_\n    rw [toSignedMeasure_toJordanDecomposition, singularPart, JordanDecomposition.toSignedMeasure]\n  rw [totalVariation, this]\n\n"}
{"name":"MeasureTheory.SignedMeasure.mutuallySingular_singularPart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.VectorMeasure.MutuallySingular (s.singularPart μ) μ.toENNRealVectorMeasure","decl":"nonrec theorem mutuallySingular_singularPart (s : SignedMeasure α) (μ : Measure α) :\n    singularPart s μ ⟂ᵥ μ.toENNRealVectorMeasure := by\n  rw [mutuallySingular_ennreal_iff, singularPart_totalVariation,\n    VectorMeasure.ennrealToMeasure_toENNRealVectorMeasure]\n  exact (mutuallySingular_singularPart _ _).add_left (mutuallySingular_singularPart _ _)\n\n"}
{"name":"MeasureTheory.SignedMeasure.rnDeriv_def","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Eq (s.rnDeriv μ) fun x => HSub.hSub (s.toJordanDecomposition.posPart.rnDeriv μ x).toReal (s.toJordanDecomposition.negPart.rnDeriv μ x).toReal","decl":"theorem rnDeriv_def (s : SignedMeasure α) (μ : Measure α) : rnDeriv s μ = fun x =>\n    (s.toJordanDecomposition.posPart.rnDeriv μ x).toReal -\n      (s.toJordanDecomposition.negPart.rnDeriv μ x).toReal :=\n  rfl\n\n"}
{"name":"MeasureTheory.SignedMeasure.measurable_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Measurable (s.rnDeriv μ)","decl":"@[measurability]\ntheorem measurable_rnDeriv (s : SignedMeasure α) (μ : Measure α) : Measurable (rnDeriv s μ) := by\n  rw [rnDeriv_def]\n  fun_prop\n\n"}
{"name":"MeasureTheory.SignedMeasure.integrable_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Integrable (s.rnDeriv μ) μ","decl":"theorem integrable_rnDeriv (s : SignedMeasure α) (μ : Measure α) : Integrable (rnDeriv s μ) μ := by\n  refine Integrable.sub ?_ ?_ <;>\n    · constructor\n      · apply Measurable.aestronglyMeasurable\n        fun_prop\n      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ μ).ne\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_add_withDensity_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : MeasureTheory.SignedMeasure α\ninst✝ : s.HaveLebesgueDecomposition μ\n⊢ Eq (HAdd.hAdd (s.singularPart μ) (μ.withDensityᵥ (s.rnDeriv μ))) s","decl":"/-- **The Lebesgue Decomposition theorem between a signed measure and a measure**:\nGiven a signed measure `s` and a σ-finite measure `μ`, there exist a signed measure `t` and a\nmeasurable and integrable function `f`, such that `t` is mutually singular with respect to `μ`\nand `s = t + μ.withDensityᵥ f`. In this case `t = s.singularPart μ` and\n`f = s.rnDeriv μ`. -/\ntheorem singularPart_add_withDensity_rnDeriv_eq [s.HaveLebesgueDecomposition μ] :\n    s.singularPart μ + μ.withDensityᵥ (s.rnDeriv μ) = s := by\n  conv_rhs =>\n    rw [← toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]\n  rw [singularPart, rnDeriv_def,\n    withDensityᵥ_sub' (integrable_toReal_of_lintegral_ne_top _ _)\n      (integrable_toReal_of_lintegral_ne_top _ _),\n    withDensityᵥ_toReal, withDensityᵥ_toReal, sub_eq_add_neg, sub_eq_add_neg,\n    add_comm (s.toJordanDecomposition.posPart.singularPart μ).toSignedMeasure, ← add_assoc,\n    add_assoc (-(s.toJordanDecomposition.negPart.singularPart μ).toSignedMeasure),\n    ← toSignedMeasure_add, add_comm, ← add_assoc, ← neg_add, ← toSignedMeasure_add, add_comm,\n    ← sub_eq_add_neg]\n  · convert rfl\n    -- `convert rfl` much faster than `congr`\n    · exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add μ\n    · rw [add_comm]\n      exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add μ\n  all_goals\n    first\n    | exact (lintegral_rnDeriv_lt_top _ _).ne\n    | measurability\n\n"}
{"name":"MeasureTheory.SignedMeasure.jordanDecomposition_add_withDensity_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt : MeasureTheory.SignedMeasure α\nf : α → Real\nhf : Measurable f\nhtμ : MeasureTheory.VectorMeasure.MutuallySingular t μ.toENNRealVectorMeasure\n⊢ (HAdd.hAdd t.toJordanDecomposition.posPart (μ.withDensity fun x => ENNReal.ofReal (f x))).MutuallySingular (HAdd.hAdd t.toJordanDecomposition.negPart (μ.withDensity fun x => ENNReal.ofReal (Neg.neg (f x))))","decl":"theorem jordanDecomposition_add_withDensity_mutuallySingular {f : α → ℝ} (hf : Measurable f)\n    (htμ : t ⟂ᵥ μ.toENNRealVectorMeasure) :\n    (t.toJordanDecomposition.posPart + μ.withDensity fun x : α => ENNReal.ofReal (f x)) ⟂ₘ\n      t.toJordanDecomposition.negPart + μ.withDensity fun x : α => ENNReal.ofReal (-f x) := by\n  rw [mutuallySingular_ennreal_iff, totalVariation_mutuallySingular_iff,\n    VectorMeasure.ennrealToMeasure_toENNRealVectorMeasure] at htμ\n  exact\n    ((JordanDecomposition.mutuallySingular _).add_right\n          (htμ.1.mono_ac (refl _) (withDensity_absolutelyContinuous _ _))).add_left\n      ((htμ.2.symm.mono_ac (withDensity_absolutelyContinuous _ _) (refl _)).add_right\n        (withDensity_ofReal_mutuallySingular hf))\n\n"}
{"name":"MeasureTheory.SignedMeasure.toJordanDecomposition_eq_of_eq_add_withDensity","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : MeasureTheory.SignedMeasure α\nf : α → Real\nhf : Measurable f\nhfi : MeasureTheory.Integrable f μ\nhtμ : MeasureTheory.VectorMeasure.MutuallySingular t μ.toENNRealVectorMeasure\nhadd : Eq s (HAdd.hAdd t (μ.withDensityᵥ f))\n⊢ Eq s.toJordanDecomposition (MeasureTheory.JordanDecomposition.mk (HAdd.hAdd t.toJordanDecomposition.posPart (μ.withDensity fun x => ENNReal.ofReal (f x))) (HAdd.hAdd t.toJordanDecomposition.negPart (μ.withDensity fun x => ENNReal.ofReal (Neg.neg (f x)))) ⋯)","decl":"theorem toJordanDecomposition_eq_of_eq_add_withDensity {f : α → ℝ} (hf : Measurable f)\n    (hfi : Integrable f μ) (htμ : t ⟂ᵥ μ.toENNRealVectorMeasure) (hadd : s = t + μ.withDensityᵥ f) :\n    s.toJordanDecomposition =\n      @JordanDecomposition.mk α _\n        (t.toJordanDecomposition.posPart + μ.withDensity fun x => ENNReal.ofReal (f x))\n        (t.toJordanDecomposition.negPart + μ.withDensity fun x => ENNReal.ofReal (-f x))\n        (by haveI := isFiniteMeasure_withDensity_ofReal hfi.2; infer_instance)\n        (by haveI := isFiniteMeasure_withDensity_ofReal hfi.neg.2; infer_instance)\n        (jordanDecomposition_add_withDensity_mutuallySingular hf htμ) := by\n  haveI := isFiniteMeasure_withDensity_ofReal hfi.2\n  haveI := isFiniteMeasure_withDensity_ofReal hfi.neg.2\n  refine toJordanDecomposition_eq ?_\n  simp_rw [JordanDecomposition.toSignedMeasure, hadd]\n  ext i hi\n  rw [VectorMeasure.sub_apply, toSignedMeasure_apply_measurable hi,\n      toSignedMeasure_apply_measurable hi, add_apply, add_apply, ENNReal.toReal_add,\n      ENNReal.toReal_add, add_sub_add_comm, ← toSignedMeasure_apply_measurable hi,\n      ← toSignedMeasure_apply_measurable hi, ← VectorMeasure.sub_apply,\n      ← JordanDecomposition.toSignedMeasure, toSignedMeasure_toJordanDecomposition,\n      VectorMeasure.add_apply, ← toSignedMeasure_apply_measurable hi,\n      ← toSignedMeasure_apply_measurable hi,\n      withDensityᵥ_eq_withDensity_pos_part_sub_withDensity_neg_part hfi,\n      VectorMeasure.sub_apply] <;>\n    exact (measure_lt_top _ _).ne\n\n"}
{"name":"MeasureTheory.SignedMeasure.haveLebesgueDecomposition_mk","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : Measurable f\nhtμ : MeasureTheory.VectorMeasure.MutuallySingular t μ.toENNRealVectorMeasure\nhadd : Eq s (HAdd.hAdd t (μ.withDensityᵥ f))\n⊢ s.HaveLebesgueDecomposition μ","decl":"theorem haveLebesgueDecomposition_mk (μ : Measure α) {f : α → ℝ} (hf : Measurable f)\n    (htμ : t ⟂ᵥ μ.toENNRealVectorMeasure) (hadd : s = t + μ.withDensityᵥ f) :\n    s.HaveLebesgueDecomposition μ := by\n  by_cases hfi : Integrable f μ\n  · exact haveLebesgueDecomposition_mk' μ hf hfi htμ hadd\n  · rw [withDensityᵥ, dif_neg hfi, add_zero] at hadd\n    refine haveLebesgueDecomposition_mk' μ measurable_zero (integrable_zero _ _ μ) htμ ?_\n    rwa [withDensityᵥ_zero, add_zero]\n\n"}
{"name":"MeasureTheory.SignedMeasure.eq_singularPart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : MeasureTheory.SignedMeasure α\nf : α → Real\nhtμ : MeasureTheory.VectorMeasure.MutuallySingular t μ.toENNRealVectorMeasure\nhadd : Eq s (HAdd.hAdd t (μ.withDensityᵥ f))\n⊢ Eq t (s.singularPart μ)","decl":"/-- Given a measure `μ`, signed measures `s` and `t`, and a function `f` such that `t` is\nmutually singular with respect to `μ` and `s = t + μ.withDensityᵥ f`, we have\n`t = singularPart s μ`, i.e. `t` is the singular part of the Lebesgue decomposition between\n`s` and `μ`. -/\ntheorem eq_singularPart (t : SignedMeasure α) (f : α → ℝ) (htμ : t ⟂ᵥ μ.toENNRealVectorMeasure)\n    (hadd : s = t + μ.withDensityᵥ f) : t = s.singularPart μ := by\n  by_cases hfi : Integrable f μ\n  · refine eq_singularPart' t hfi.1.measurable_mk (hfi.congr hfi.1.ae_eq_mk) htμ ?_\n    convert hadd using 2\n    exact WithDensityᵥEq.congr_ae hfi.1.ae_eq_mk.symm\n  · rw [withDensityᵥ, dif_neg hfi, add_zero] at hadd\n    refine eq_singularPart' t measurable_zero (integrable_zero _ _ μ) htμ ?_\n    rwa [withDensityᵥ_zero, add_zero]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_zero","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.SignedMeasure.singularPart 0 μ) 0","decl":"theorem singularPart_zero (μ : Measure α) : (0 : SignedMeasure α).singularPart μ = 0 := by\n  refine (eq_singularPart 0 0 VectorMeasure.MutuallySingular.zero_left ?_).symm\n  rw [zero_add, withDensityᵥ_zero]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_neg","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\n⊢ Eq ((Neg.neg s).singularPart μ) (Neg.neg (s.singularPart μ))","decl":"theorem singularPart_neg (s : SignedMeasure α) (μ : Measure α) :\n    (-s).singularPart μ = -s.singularPart μ := by\n  have h₁ :\n    ((-s).toJordanDecomposition.posPart.singularPart μ).toSignedMeasure =\n      (s.toJordanDecomposition.negPart.singularPart μ).toSignedMeasure := by\n    refine toSignedMeasure_congr ?_\n    rw [toJordanDecomposition_neg, JordanDecomposition.neg_posPart]\n  have h₂ :\n    ((-s).toJordanDecomposition.negPart.singularPart μ).toSignedMeasure =\n      (s.toJordanDecomposition.posPart.singularPart μ).toSignedMeasure := by\n    refine toSignedMeasure_congr ?_\n    rw [toJordanDecomposition_neg, JordanDecomposition.neg_negPart]\n  rw [singularPart, singularPart, neg_sub, h₁, h₂]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_smul_nnreal","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\nr : NNReal\n⊢ Eq ((HSMul.hSMul r s).singularPart μ) (HSMul.hSMul r (s.singularPart μ))","decl":"theorem singularPart_smul_nnreal (s : SignedMeasure α) (μ : Measure α) (r : ℝ≥0) :\n    (r • s).singularPart μ = r • s.singularPart μ := by\n  rw [singularPart, singularPart, smul_sub, ← toSignedMeasure_smul, ← toSignedMeasure_smul]\n  conv_lhs =>\n    congr\n    · congr\n      · rw [toJordanDecomposition_smul, JordanDecomposition.smul_posPart, singularPart_smul]\n    · congr\n      rw [toJordanDecomposition_smul, JordanDecomposition.smul_negPart, singularPart_smul]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_smul","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\nr : Real\n⊢ Eq ((HSMul.hSMul r s).singularPart μ) (HSMul.hSMul r (s.singularPart μ))","decl":"nonrec theorem singularPart_smul (s : SignedMeasure α) (μ : Measure α) (r : ℝ) :\n    (r • s).singularPart μ = r • s.singularPart μ := by\n  cases le_or_lt 0 r with\n  | inl hr =>\n    lift r to ℝ≥0 using hr\n    exact singularPart_smul_nnreal s μ r\n  | inr hr =>\n    rw [singularPart, singularPart]\n    conv_lhs =>\n      congr\n      · congr\n        · rw [toJordanDecomposition_smul_real,\n            JordanDecomposition.real_smul_posPart_neg _ _ hr, singularPart_smul]\n      · congr\n        · rw [toJordanDecomposition_smul_real,\n            JordanDecomposition.real_smul_negPart_neg _ _ hr, singularPart_smul]\n    rw [toSignedMeasure_smul, toSignedMeasure_smul, ← neg_sub, ← smul_sub, NNReal.smul_def,\n      ← neg_smul, Real.coe_toNNReal _ (le_of_lt (neg_pos.mpr hr)), neg_neg]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_add","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝¹ : s.HaveLebesgueDecomposition μ\ninst✝ : t.HaveLebesgueDecomposition μ\n⊢ Eq ((HAdd.hAdd s t).singularPart μ) (HAdd.hAdd (s.singularPart μ) (t.singularPart μ))","decl":"theorem singularPart_add (s t : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ]\n    [t.HaveLebesgueDecomposition μ] :\n    (s + t).singularPart μ = s.singularPart μ + t.singularPart μ := by\n  refine\n    (eq_singularPart _ (s.rnDeriv μ + t.rnDeriv μ)\n        ((mutuallySingular_singularPart s μ).add_left (mutuallySingular_singularPart t μ))\n        ?_).symm\n  rw [withDensityᵥ_add (integrable_rnDeriv s μ) (integrable_rnDeriv t μ), add_assoc,\n    add_comm (t.singularPart μ), add_assoc, add_comm _ (t.singularPart μ),\n    singularPart_add_withDensity_rnDeriv_eq, ← add_assoc,\n    singularPart_add_withDensity_rnDeriv_eq]\n\n"}
{"name":"MeasureTheory.SignedMeasure.singularPart_sub","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝¹ : s.HaveLebesgueDecomposition μ\ninst✝ : t.HaveLebesgueDecomposition μ\n⊢ Eq ((HSub.hSub s t).singularPart μ) (HSub.hSub (s.singularPart μ) (t.singularPart μ))","decl":"theorem singularPart_sub (s t : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ]\n    [t.HaveLebesgueDecomposition μ] :\n    (s - t).singularPart μ = s.singularPart μ - t.singularPart μ := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, singularPart_add, singularPart_neg]\n\n"}
{"name":"MeasureTheory.SignedMeasure.eq_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : MeasureTheory.SignedMeasure α\nf : α → Real\nhfi : MeasureTheory.Integrable f μ\nhtμ : MeasureTheory.VectorMeasure.MutuallySingular t μ.toENNRealVectorMeasure\nhadd : Eq s (HAdd.hAdd t (μ.withDensityᵥ f))\n⊢ (MeasureTheory.ae μ).EventuallyEq f (s.rnDeriv μ)","decl":"/-- Given a measure `μ`, signed measures `s` and `t`, and a function `f` such that `t` is\nmutually singular with respect to `μ` and `s = t + μ.withDensityᵥ f`, we have\n`f = rnDeriv s μ`, i.e. `f` is the Radon-Nikodym derivative of `s` and `μ`. -/\ntheorem eq_rnDeriv (t : SignedMeasure α) (f : α → ℝ) (hfi : Integrable f μ)\n    (htμ : t ⟂ᵥ μ.toENNRealVectorMeasure) (hadd : s = t + μ.withDensityᵥ f) :\n    f =ᵐ[μ] s.rnDeriv μ := by\n  set f' := hfi.1.mk f\n  have hadd' : s = t + μ.withDensityᵥ f' := by\n    convert hadd using 2\n    exact WithDensityᵥEq.congr_ae hfi.1.ae_eq_mk.symm\n  have := haveLebesgueDecomposition_mk μ hfi.1.measurable_mk htμ hadd'\n  refine (Integrable.ae_eq_of_withDensityᵥ_eq (integrable_rnDeriv _ _) hfi ?_).symm\n  rw [← add_right_inj t, ← hadd, eq_singularPart _ f htμ hadd,\n    singularPart_add_withDensity_rnDeriv_eq]\n\n"}
{"name":"MeasureTheory.SignedMeasure.rnDeriv_neg","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : s.HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((Neg.neg s).rnDeriv μ) (Neg.neg (s.rnDeriv μ))","decl":"theorem rnDeriv_neg (s : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ] :\n    (-s).rnDeriv μ =ᵐ[μ] -s.rnDeriv μ := by\n  refine\n    Integrable.ae_eq_of_withDensityᵥ_eq (integrable_rnDeriv _ _) (integrable_rnDeriv _ _).neg ?_\n  rw [withDensityᵥ_neg, ← add_right_inj ((-s).singularPart μ),\n    singularPart_add_withDensity_rnDeriv_eq, singularPart_neg, ← neg_add,\n    singularPart_add_withDensity_rnDeriv_eq]\n\n"}
{"name":"MeasureTheory.SignedMeasure.rnDeriv_smul","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : s.HaveLebesgueDecomposition μ\nr : Real\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSMul.hSMul r s).rnDeriv μ) (HSMul.hSMul r (s.rnDeriv μ))","decl":"theorem rnDeriv_smul (s : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ] (r : ℝ) :\n    (r • s).rnDeriv μ =ᵐ[μ] r • s.rnDeriv μ := by\n  refine\n    Integrable.ae_eq_of_withDensityᵥ_eq (integrable_rnDeriv _ _)\n      ((integrable_rnDeriv _ _).smul r) ?_\n  rw [withDensityᵥ_smul (rnDeriv s μ) r, ← add_right_inj ((r • s).singularPart μ),\n    singularPart_add_withDensity_rnDeriv_eq, singularPart_smul, ← smul_add,\n    singularPart_add_withDensity_rnDeriv_eq]\n\n"}
{"name":"MeasureTheory.SignedMeasure.rnDeriv_add","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝² : s.HaveLebesgueDecomposition μ\ninst✝¹ : t.HaveLebesgueDecomposition μ\ninst✝ : (HAdd.hAdd s t).HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HAdd.hAdd s t).rnDeriv μ) (HAdd.hAdd (s.rnDeriv μ) (t.rnDeriv μ))","decl":"theorem rnDeriv_add (s t : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ]\n    [t.HaveLebesgueDecomposition μ] [(s + t).HaveLebesgueDecomposition μ] :\n    (s + t).rnDeriv μ =ᵐ[μ] s.rnDeriv μ + t.rnDeriv μ := by\n  refine\n    Integrable.ae_eq_of_withDensityᵥ_eq (integrable_rnDeriv _ _)\n      ((integrable_rnDeriv _ _).add (integrable_rnDeriv _ _)) ?_\n  rw [← add_right_inj ((s + t).singularPart μ), singularPart_add_withDensity_rnDeriv_eq,\n    withDensityᵥ_add (integrable_rnDeriv _ _) (integrable_rnDeriv _ _), singularPart_add,\n    add_assoc, add_comm (t.singularPart μ), add_assoc, add_comm _ (t.singularPart μ),\n    singularPart_add_withDensity_rnDeriv_eq, ← add_assoc,\n    singularPart_add_withDensity_rnDeriv_eq]\n\n"}
{"name":"MeasureTheory.SignedMeasure.rnDeriv_sub","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝¹ : s.HaveLebesgueDecomposition μ\ninst✝ : t.HaveLebesgueDecomposition μ\nhst : (HSub.hSub s t).HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSub.hSub s t).rnDeriv μ) (HSub.hSub (s.rnDeriv μ) (t.rnDeriv μ))","decl":"theorem rnDeriv_sub (s t : SignedMeasure α) (μ : Measure α) [s.HaveLebesgueDecomposition μ]\n    [t.HaveLebesgueDecomposition μ] [hst : (s - t).HaveLebesgueDecomposition μ] :\n    (s - t).rnDeriv μ =ᵐ[μ] s.rnDeriv μ - t.rnDeriv μ := by\n  rw [sub_eq_add_neg] at hst\n  rw [sub_eq_add_neg, sub_eq_add_neg]\n  exact ae_eq_trans (rnDeriv_add _ _ _) (Filter.EventuallyEq.add (ae_eq_refl _) (rnDeriv_neg _ _))\n\n"}
{"name":"MeasureTheory.ComplexMeasure.HaveLebesgueDecomposition.rePart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\nμ : MeasureTheory.Measure α\nself : c.HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ComplexMeasure.re c).HaveLebesgueDecomposition μ","decl":"/-- A complex measure is said to `HaveLebesgueDecomposition` with respect to a positive measure\nif both its real and imaginary part `HaveLebesgueDecomposition` with respect to that measure. -/\nclass HaveLebesgueDecomposition (c : ComplexMeasure α) (μ : Measure α) : Prop where\n  rePart : c.re.HaveLebesgueDecomposition μ\n  imPart : c.im.HaveLebesgueDecomposition μ\n\n"}
{"name":"MeasureTheory.ComplexMeasure.HaveLebesgueDecomposition.imPart","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\nμ : MeasureTheory.Measure α\nself : c.HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ComplexMeasure.im c).HaveLebesgueDecomposition μ","decl":"/-- A complex measure is said to `HaveLebesgueDecomposition` with respect to a positive measure\nif both its real and imaginary part `HaveLebesgueDecomposition` with respect to that measure. -/\nclass HaveLebesgueDecomposition (c : ComplexMeasure α) (μ : Measure α) : Prop where\n  rePart : c.re.HaveLebesgueDecomposition μ\n  imPart : c.im.HaveLebesgueDecomposition μ\n\n"}
{"name":"MeasureTheory.ComplexMeasure.integrable_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nc : MeasureTheory.ComplexMeasure α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Integrable (c.rnDeriv μ) μ","decl":"theorem integrable_rnDeriv (c : ComplexMeasure α) (μ : Measure α) : Integrable (c.rnDeriv μ) μ := by\n  rw [← memℒp_one_iff_integrable, ← memℒp_re_im_iff]\n  exact\n    ⟨memℒp_one_iff_integrable.2 (SignedMeasure.integrable_rnDeriv _ _),\n      memℒp_one_iff_integrable.2 (SignedMeasure.integrable_rnDeriv _ _)⟩\n\n"}
{"name":"MeasureTheory.ComplexMeasure.singularPart_add_withDensity_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.SignedLebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : MeasureTheory.ComplexMeasure α\ninst✝ : c.HaveLebesgueDecomposition μ\n⊢ Eq (HAdd.hAdd (c.singularPart μ) (μ.withDensityᵥ (c.rnDeriv μ))) c","decl":"theorem singularPart_add_withDensity_rnDeriv_eq [c.HaveLebesgueDecomposition μ] :\n    c.singularPart μ + μ.withDensityᵥ (c.rnDeriv μ) = c := by\n  conv_rhs => rw [← c.toComplexMeasure_to_signedMeasure]\n  ext i hi : 1\n  rw [VectorMeasure.add_apply, SignedMeasure.toComplexMeasure_apply]\n  apply Complex.ext\n  · rw [Complex.add_re, withDensityᵥ_apply (c.integrable_rnDeriv μ) hi, ← RCLike.re_eq_complex_re,\n      ← integral_re (c.integrable_rnDeriv μ).integrableOn, RCLike.re_eq_complex_re,\n      ← withDensityᵥ_apply _ hi]\n    · change (c.re.singularPart μ + μ.withDensityᵥ (c.re.rnDeriv μ)) i = _\n      rw [c.re.singularPart_add_withDensity_rnDeriv_eq μ]\n    · exact SignedMeasure.integrable_rnDeriv _ _\n  · rw [Complex.add_im, withDensityᵥ_apply (c.integrable_rnDeriv μ) hi, ← RCLike.im_eq_complex_im,\n      ← integral_im (c.integrable_rnDeriv μ).integrableOn, RCLike.im_eq_complex_im,\n      ← withDensityᵥ_apply _ hi]\n    · change (c.im.singularPart μ + μ.withDensityᵥ (c.im.rnDeriv μ)) i = _\n      rw [c.im.singularPart_add_withDensity_rnDeriv_eq μ]\n    · exact SignedMeasure.integrable_rnDeriv _ _\n\n"}
