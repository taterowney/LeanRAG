{"name":"StarAlgebra.elemental.characterSpaceToSpectrum_coe","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\nx : A\nœÜ : ‚Üë(WeakDual.characterSpace Complex (Subtype fun x_1 => Membership.mem (StarAlgebra.elemental Complex x) x_1))\n‚ä¢ Eq (‚Üë(StarAlgebra.elemental.characterSpaceToSpectrum x œÜ)) (œÜ ‚ü®x, ‚ãØ‚ü©)","decl":"/-- The natural map from `characterSpace ‚ÑÇ (elemental ‚ÑÇ x)` to `spectrum ‚ÑÇ x` given\nby evaluating `œÜ` at `x`. This is essentially just evaluation of the `gelfandTransform` of `x`,\nbut because we want something in `spectrum ‚ÑÇ x`, as opposed to\n`spectrum ‚ÑÇ ‚ü®x, elemental.self_mem ‚ÑÇ x‚ü©` there is slightly more work to do. -/\n@[simps]\nnoncomputable def characterSpaceToSpectrum (x : A)\n    (œÜ : characterSpace ‚ÑÇ (elemental ‚ÑÇ x)) : spectrum ‚ÑÇ x where\n  val := œÜ ‚ü®x, self_mem ‚ÑÇ x‚ü©\n  property := by\n    simpa only [StarSubalgebra.spectrum_eq (hS := isClosed ‚ÑÇ x)\n      (a := ‚ü®x, self_mem ‚ÑÇ x‚ü©)] using AlgHom.apply_mem_spectrum œÜ ‚ü®x, self_mem ‚ÑÇ x‚ü©\n\n"}
{"name":"StarAlgebra.elemental.continuous_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\nx : A\n‚ä¢ Continuous (StarAlgebra.elemental.characterSpaceToSpectrum x)","decl":"theorem continuous_characterSpaceToSpectrum (x : A) :\n    Continuous (characterSpaceToSpectrum x) :=\n  continuous_induced_rng.2\n    (map_continuous <| gelfandTransform ‚ÑÇ (elemental ‚ÑÇ x) ‚ü®x, self_mem ‚ÑÇ x‚ü©)\n\n"}
{"name":"elementalStarAlgebra.continuous_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\nx : A\n‚ä¢ Continuous (StarAlgebra.elemental.characterSpaceToSpectrum x)","decl":"@[deprecated (since := \"2024-11-05\")]\nalias _root_.elementalStarAlgebra.continuous_characterSpaceToSpectrum :=\n  continuous_characterSpaceToSpectrum\n\n"}
{"name":"StarAlgebra.elemental.bijective_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\na : A\ninst‚úù : IsStarNormal a\n‚ä¢ Function.Bijective (StarAlgebra.elemental.characterSpaceToSpectrum a)","decl":"theorem bijective_characterSpaceToSpectrum :\n    Function.Bijective (characterSpaceToSpectrum a) := by\n  refine ‚ü®fun œÜ œà h => starAlgHomClass_ext ‚ÑÇ ?_ ?_ ?_, ?_‚ü©\n  ¬∑ exact (map_continuous œÜ)\n  ¬∑ exact (map_continuous œà)\n  ¬∑ simpa only [characterSpaceToSpectrum, Subtype.mk_eq_mk,\n      ContinuousMap.coe_mk] using h\n  ¬∑ rintro ‚ü®z, hz‚ü©\n    have hz' := (StarSubalgebra.spectrum_eq (hS := isClosed ‚ÑÇ a)\n      (a := ‚ü®a, self_mem ‚ÑÇ a‚ü©) ‚ñ∏ hz)\n    rw [CharacterSpace.mem_spectrum_iff_exists] at hz'\n    obtain ‚ü®œÜ, rfl‚ü© := hz'\n    exact ‚ü®œÜ, rfl‚ü©\n\n"}
{"name":"elementalStarAlgebra.bijective_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\na : A\ninst‚úù : IsStarNormal a\n‚ä¢ Function.Bijective (StarAlgebra.elemental.characterSpaceToSpectrum a)","decl":"@[deprecated (since := \"2024-11-05\")]\nalias _root_.elementalStarAlgebra.bijective_characterSpaceToSpectrum :=\n  bijective_characterSpaceToSpectrum\n\n"}
{"name":"continuousFunctionalCalculus_map_id","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\na : A\ninst‚úù : IsStarNormal a\n‚ä¢ Eq ((continuousFunctionalCalculus a) (ContinuousMap.restrict (spectrum Complex a) (ContinuousMap.id Complex))) ‚ü®a, ‚ãØ‚ü©","decl":"theorem continuousFunctionalCalculus_map_id :\n    continuousFunctionalCalculus a ((ContinuousMap.id ‚ÑÇ).restrict (spectrum ‚ÑÇ a)) =\n      ‚ü®a, self_mem ‚ÑÇ a‚ü© :=\n  (gelfandStarTransform (elemental ‚ÑÇ a)).symm_apply_apply _\n\n"}
{"name":"IsStarNormal.instContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\n‚ä¢ ContinuousFunctionalCalculus Complex IsStarNormal","decl":"instance IsStarNormal.instContinuousFunctionalCalculus {A : Type*} [CStarAlgebra A] :\n    ContinuousFunctionalCalculus ‚ÑÇ (IsStarNormal : A ‚Üí Prop) where\n  predicate_zero := .zero\n  spectrum_nonempty a _ := spectrum.nonempty a\n  exists_cfc_of_predicate a ha := by\n    refine ‚ü®(StarAlgebra.elemental ‚ÑÇ a).subtype.comp <| continuousFunctionalCalculus a,\n      ?hom_isClosedEmbedding, ?hom_id, ?hom_map_spectrum, ?predicate_hom‚ü©\n    case hom_isClosedEmbedding =>\n      exact Isometry.isClosedEmbedding <|\n        isometry_subtype_coe.comp <| StarAlgEquiv.isometry (continuousFunctionalCalculus a)\n    case hom_id => exact congr_arg Subtype.val <| continuousFunctionalCalculus_map_id a\n    case hom_map_spectrum =>\n      intro f\n      simp only [StarAlgHom.comp_apply, StarAlgHom.coe_coe, StarSubalgebra.coe_subtype]\n      rw [‚Üê StarSubalgebra.spectrum_eq (hS := StarAlgebra.elemental.isClosed ‚ÑÇ a),\n        AlgEquiv.spectrum_eq (continuousFunctionalCalculus a), ContinuousMap.spectrum_eq_range]\n    case predicate_hom => exact fun f ‚Ü¶ ‚ü®by rw [‚Üê map_star]; exact Commute.all (star f) f |>.map _‚ü©\n\n"}
{"name":"cfcHom_eq_of_isStarNormal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\na : A\nha : IsStarNormal a\n‚ä¢ Eq (cfcHom ha) ((StarAlgebra.elemental Complex a).subtype.comp ‚Üë(continuousFunctionalCalculus a))","decl":"lemma cfcHom_eq_of_isStarNormal {A : Type*} [CStarAlgebra A] (a : A) [ha : IsStarNormal a] :\n    cfcHom ha = (StarAlgebra.elemental ‚ÑÇ a).subtype.comp (continuousFunctionalCalculus a) := by\n  refine cfcHom_eq_of_continuous_of_map_id ha _ ?_ ?_\n  ¬∑ exact continuous_subtype_val.comp <|\n      (StarAlgEquiv.isometry (continuousFunctionalCalculus a)).continuous\n  ¬∑ simp [continuousFunctionalCalculus_map_id a]\n\n"}
{"name":"IsStarNormal.instNonUnitalContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\n‚ä¢ NonUnitalContinuousFunctionalCalculus Complex IsStarNormal","decl":"instance IsStarNormal.instNonUnitalContinuousFunctionalCalculus {A : Type*}\n    [NonUnitalCStarAlgebra A] : NonUnitalContinuousFunctionalCalculus ‚ÑÇ (IsStarNormal : A ‚Üí Prop) :=\n  RCLike.nonUnitalContinuousFunctionalCalculus Unitization.isStarNormal_inr\n\n"}
{"name":"inr_comp_cfc‚ÇôHom_eq_cfc‚ÇôAux","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\na : A\nha : IsStarNormal a\n‚ä¢ Eq ((Unitization.inrNonUnitalStarAlgHom Complex A).comp (cfc‚ÇôHom ha)) (cfc‚ÇôAux ‚ãØ a ha)","decl":"open Unitization CStarAlgebra in\nlemma inr_comp_cfc‚ÇôHom_eq_cfc‚ÇôAux {A : Type*} [NonUnitalCStarAlgebra A] (a : A)\n    [ha : IsStarNormal a] : (inrNonUnitalStarAlgHom ‚ÑÇ A).comp (cfc‚ÇôHom ha) =\n      cfc‚ÇôAux (isStarNormal_inr (R := ‚ÑÇ) (A := A)) a ha := by\n  have h (a : A) := isStarNormal_inr (R := ‚ÑÇ) (A := A) (a := a)\n  refine @ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id\n    _ _ _ _ _ _ _ _ _ _ _ inferInstance inferInstance _ (œÉ‚Çô ‚ÑÇ a) _ _ rfl _ _ ?_ ?_ ?_\n  ¬∑ show Continuous (fun f ‚Ü¶ (cfc‚ÇôHom ha f : A‚Å∫¬π)); fun_prop\n  ¬∑ exact isClosedEmbedding_cfc‚ÇôAux @(h) a ha |>.continuous\n  ¬∑ trans (a : A‚Å∫¬π)\n    ¬∑ congrm(inr $(cfc‚ÇôHom_id ha))\n    ¬∑ exact cfc‚ÇôAux_id @(h) a ha |>.symm\n\n"}
{"name":"SpectrumRestricts.nnreal_iff_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\na : A\nt : NNReal\nha : IsSelfAdjoint a\nht : LE.le (NNNorm.nnnorm a) t\n‚ä¢ Iff (SpectrumRestricts a ‚áëContinuousMap.realToNNReal) (LE.le (NNNorm.nnnorm (HSub.hSub ((algebraMap Real A) ‚Üët) a)) t)","decl":"lemma SpectrumRestricts.nnreal_iff_nnnorm {a : A} {t : ‚Ñù‚â•0} (ha : IsSelfAdjoint a) (ht : ‚Äña‚Äñ‚Çä ‚â§ t) :\n    SpectrumRestricts a ContinuousMap.realToNNReal ‚Üî ‚ÄñalgebraMap ‚Ñù A t - a‚Äñ‚Çä ‚â§ t := by\n  have : IsSelfAdjoint (algebraMap ‚Ñù A t - a) := IsSelfAdjoint.algebraMap A (.all (t : ‚Ñù)) |>.sub ha\n  rw [‚Üê ENNReal.coe_le_coe, ‚Üê IsSelfAdjoint.spectralRadius_eq_nnnorm,\n    ‚Üê SpectrumRestricts.spectralRadius_eq (f := Complex.reCLM)] at ht ‚ä¢\n  ¬∑ exact SpectrumRestricts.nnreal_iff_spectralRadius_le ht\n  all_goals\n    try apply IsSelfAdjoint.spectrumRestricts\n    assumption\n\n"}
{"name":"SpectrumRestricts.nnreal_add","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\na b : A\nha‚ÇÅ : IsSelfAdjoint a\nhb‚ÇÅ : IsSelfAdjoint b\nha‚ÇÇ : SpectrumRestricts a ‚áëContinuousMap.realToNNReal\nhb‚ÇÇ : SpectrumRestricts b ‚áëContinuousMap.realToNNReal\n‚ä¢ SpectrumRestricts (HAdd.hAdd a b) ‚áëContinuousMap.realToNNReal","decl":"lemma SpectrumRestricts.nnreal_add {a b : A} (ha‚ÇÅ : IsSelfAdjoint a)\n    (hb‚ÇÅ : IsSelfAdjoint b) (ha‚ÇÇ : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (hb‚ÇÇ : SpectrumRestricts b ContinuousMap.realToNNReal) :\n    SpectrumRestricts (a + b) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff_nnnorm (ha‚ÇÅ.add hb‚ÇÅ) (nnnorm_add_le a b), NNReal.coe_add,\n    map_add, add_sub_add_comm]\n  refine nnnorm_add_le _ _ |>.trans ?_\n  gcongr\n  all_goals rw [‚Üê SpectrumRestricts.nnreal_iff_nnnorm] <;> first | rfl | assumption\n\n"}
{"name":"IsSelfAdjoint.sq_spectrumRestricts","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n‚ä¢ SpectrumRestricts (HPow.hPow a 2) ‚áëContinuousMap.realToNNReal","decl":"lemma IsSelfAdjoint.sq_spectrumRestricts {a : A} (ha : IsSelfAdjoint a) :\n    SpectrumRestricts (a ^ 2) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff, ‚Üê cfc_id (R := ‚Ñù) a, ‚Üê cfc_pow .., cfc_map_spectrum ..]\n  rintro - ‚ü®x, -, rfl‚ü©\n  exact sq_nonneg x\n\n"}
{"name":"SpectrumRestricts.eq_zero_of_neg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\nha‚ÇÅ : SpectrumRestricts a ‚áëContinuousMap.realToNNReal\nha‚ÇÇ : SpectrumRestricts (Neg.neg a) ‚áëContinuousMap.realToNNReal\n‚ä¢ Eq a 0","decl":"lemma SpectrumRestricts.eq_zero_of_neg {a : A} (ha : IsSelfAdjoint a)\n    (ha‚ÇÅ : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (ha‚ÇÇ : SpectrumRestricts (-a) ContinuousMap.realToNNReal) :\n    a = 0 := by\n  nontriviality A\n  rw [SpectrumRestricts.nnreal_iff] at ha‚ÇÅ ha‚ÇÇ\n  apply CFC.eq_zero_of_spectrum_subset_zero (R := ‚Ñù) a\n  rw [Set.subset_singleton_iff]\n  simp only [‚Üê spectrum.neg_eq, Set.mem_neg] at ha‚ÇÇ\n  peel ha‚ÇÅ with x hx _\n  linarith [ha‚ÇÇ (-x) ((neg_neg x).symm ‚ñ∏ hx)]\n\n"}
{"name":"SpectrumRestricts.smul_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_3\ninst‚úù¬π : Ring A\ninst‚úù : Algebra Real A\na : A\nha : SpectrumRestricts a ‚áëContinuousMap.realToNNReal\nr : Real\nhr : LE.le 0 r\n‚ä¢ SpectrumRestricts (HSMul.hSMul r a) ‚áëContinuousMap.realToNNReal","decl":"lemma SpectrumRestricts.smul_of_nonneg {A : Type*} [Ring A] [Algebra ‚Ñù A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    SpectrumRestricts (r ‚Ä¢ a) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff] at ha ‚ä¢\n  nontriviality A\n  intro x hx\n  by_cases hr' : r = 0\n  ¬∑ simp [hr'] at hx ‚ä¢\n    exact hx.symm.le\n  ¬∑ lift r to ‚ÑùÀ£ using IsUnit.mk0 r hr'\n    rw [‚Üê Units.smul_def, spectrum.unit_smul_eq_smul, Set.mem_smul_set_iff_inv_smul_mem] at hx\n    refine le_of_smul_le_smul_left ?_ (inv_pos.mpr <| lt_of_le_of_ne hr <| ne_comm.mpr hr')\n    simpa [Units.smul_def] using ha _ hx\n\n"}
{"name":"spectrum_star_mul_self_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\nb : A\nx : Real\na‚úù : Membership.mem (spectrum Real (HMul.hMul (Star.star b) b)) x\n‚ä¢ LE.le 0 x","decl":"lemma spectrum_star_mul_self_nonneg {b : A} : ‚àÄ x ‚àà spectrum ‚Ñù (star b * b), 0 ‚â§ x := by\n  set a := star b * b\n  have a_def : a = star b * b := rfl\n  let a_neg : A := cfc (fun x ‚Ü¶ (- ContinuousMap.id ‚Ñù ‚äî 0) x) a\n  set c := b * a_neg\n  have h_eq_a_neg : - (star c * c) = a_neg ^ 3 := by\n    simp only [c, a_neg, star_mul]\n    rw [‚Üê mul_assoc, mul_assoc _ _ b, ‚Üê cfc_star, ‚Üê cfc_id' ‚Ñù (star b * b), a_def, ‚Üê neg_mul]\n    rw [‚Üê cfc_mul _ _ (star b * b) (by simp; fun_prop), neg_mul]\n    simp only [ContinuousMap.coe_neg, ContinuousMap.coe_id, Pi.sup_apply, Pi.neg_apply,\n      star_trivial]\n    rw [‚Üê cfc_mul .., ‚Üê cfc_neg .., ‚Üê cfc_pow ..]\n    congr\n    ext x\n    by_cases hx : x ‚â§ 0\n    ¬∑ rw [‚Üê neg_nonneg] at hx\n      simp [sup_eq_left.mpr hx, pow_succ]\n    ¬∑ rw [not_le, ‚Üê neg_neg_iff_pos] at hx\n      simp [sup_eq_right.mpr hx.le]\n  have h_c_spec‚ÇÄ : SpectrumRestricts (- (star c * c)) (ContinuousMap.realToNNReal ¬∑) := by\n    simp only [SpectrumRestricts.nnreal_iff, h_eq_a_neg]\n    rw [‚Üê cfc_pow _ _ (ha := .star_mul_self b)]\n    simp only [a, cfc_map_spectrum (R := ‚Ñù) (fun x => (-ContinuousMap.id ‚Ñù ‚äî 0) x ^ 3) (star b * b)]\n    rintro - ‚ü®x, -, rfl‚ü©\n    simp\n  have c_eq := star_mul_self_add_self_mul_star c\n  rw [‚Üê eq_sub_iff_add_eq', sub_eq_add_neg, ‚Üê sq, ‚Üê sq] at c_eq\n  have h_c_spec‚ÇÅ : SpectrumRestricts (c * star c) ContinuousMap.realToNNReal := by\n    rw [c_eq]\n    refine SpectrumRestricts.nnreal_add ?_ ?_ ?_ h_c_spec‚ÇÄ\n    ¬∑ exact IsSelfAdjoint.smul (by rfl) <| ((‚Ñú c).prop.pow 2).add ((‚Ñë c).prop.pow 2)\n    ¬∑ exact (IsSelfAdjoint.star_mul_self c).neg\n    ¬∑ rw [‚Üê Nat.cast_smul_eq_nsmul ‚Ñù]\n      refine (‚Ñú c).2.sq_spectrumRestricts.nnreal_add ((‚Ñú c).2.pow 2) ((‚Ñë c).2.pow 2)\n        (‚Ñë c).2.sq_spectrumRestricts |>.smul_of_nonneg <| by norm_num\n  have h_c_spec‚ÇÇ : SpectrumRestricts (star c * c) ContinuousMap.realToNNReal := by\n    rw [SpectrumRestricts.nnreal_iff] at h_c_spec‚ÇÅ ‚ä¢\n    intro x hx\n    replace hx := Set.subset_diff_union _ {(0 : ‚Ñù)} hx\n    rw [spectrum.nonzero_mul_eq_swap_mul, Set.diff_union_self, Set.union_singleton,\n      Set.mem_insert_iff] at hx\n    obtain (rfl | hx) := hx\n    exacts [le_rfl, h_c_spec‚ÇÅ x hx]\n  rw [h_c_spec‚ÇÇ.eq_zero_of_neg (.star_mul_self c) h_c_spec‚ÇÄ, neg_zero] at h_eq_a_neg\n  simp only [a_neg] at h_eq_a_neg\n  rw [‚Üê cfc_pow _ _ (ha := .star_mul_self b), ‚Üê cfc_zero a (R := ‚Ñù)] at h_eq_a_neg\n  intro x hx\n  by_contra! hx'\n  rw [‚Üê neg_pos] at hx'\n  apply (pow_pos hx' 3).ne\n  have h_eqOn := eqOn_of_cfc_eq_cfc (ha := IsSelfAdjoint.star_mul_self b) h_eq_a_neg\n  simpa [sup_eq_left.mpr hx'.le] using h_eqOn hx\n\n"}
{"name":"IsSelfAdjoint.coe_mem_spectrum_complex","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace A\ninst‚úù¬≥ : Ring A\ninst‚úù¬≤ : StarRing A\ninst‚úù¬π : Algebra Complex A\ninst‚úù : ContinuousFunctionalCalculus Complex IsStarNormal\na : A\nx : Real\nha : autoParam (IsSelfAdjoint a) _auto‚úù\n‚ä¢ Iff (Membership.mem (spectrum Complex a) ‚Üëx) (Membership.mem (spectrum Real a) x)","decl":"lemma IsSelfAdjoint.coe_mem_spectrum_complex {A : Type*} [TopologicalSpace A] [Ring A]\n    [StarRing A] [Algebra ‚ÑÇ A] [ContinuousFunctionalCalculus ‚ÑÇ (IsStarNormal : A ‚Üí Prop)]\n    {a : A} {x : ‚Ñù} (ha : IsSelfAdjoint a := by cfc_tac) :\n    (x : ‚ÑÇ) ‚àà spectrum ‚ÑÇ a ‚Üî x ‚àà spectrum ‚Ñù a := by\n  simp [‚Üê ha.spectrumRestricts.algebraMap_image]\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClass","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : PartialOrder A\n‚ä¢ NonnegSpectrumClass Real A","decl":"instance CStarAlgebra.instNonnegSpectrumClass : NonnegSpectrumClass ‚Ñù A :=\n  .of_spectrum_nonneg fun a ha ‚Ü¶ by\n    rw [StarOrderedRing.nonneg_iff] at ha\n    induction ha using AddSubmonoid.closure_induction with\n    | mem x hx =>\n      obtain ‚ü®b, rfl‚ü© := hx\n      exact spectrum_star_mul_self_nonneg\n    | one =>\n      nontriviality A\n      simp\n    | mul x y x_mem y_mem hx hy =>\n      rw [‚Üê SpectrumRestricts.nnreal_iff] at hx hy ‚ä¢\n      rw [‚Üê StarOrderedRing.nonneg_iff] at x_mem y_mem\n      exact hx.nnreal_add (.of_nonneg x_mem) (.of_nonneg y_mem) hy\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClassComplexUnital","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : PartialOrder A\n‚ä¢ NonnegSpectrumClass Complex A","decl":"open ComplexOrder in\ninstance CStarAlgebra.instNonnegSpectrumClassComplexUnital : NonnegSpectrumClass ‚ÑÇ A where\n  quasispectrum_nonneg_of_nonneg a ha x := by\n    rw [mem_quasispectrum_iff]\n    refine (Or.elim ¬∑ ge_of_eq fun hx ‚Ü¶ ?_)\n    obtain ‚ü®y, hy, rfl‚ü© := (IsSelfAdjoint.of_nonneg ha).spectrumRestricts.algebraMap_image ‚ñ∏ hx\n    simpa using spectrum_nonneg_of_nonneg ha hy\n\n"}
{"name":"CStarAlgebra.spectralOrderedRing","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\n‚ä¢ StarOrderedRing A","decl":"/-- The `CStarAlgebra.spectralOrder` on a C‚ãÜ-algebra is a `StarOrderedRing`. -/\nlemma CStarAlgebra.spectralOrderedRing : @StarOrderedRing A _ (CStarAlgebra.spectralOrder A) _ :=\n  let _ := CStarAlgebra.spectralOrder A\n  { le_iff := by\n      intro x y\n      constructor\n      ¬∑ intro h\n        obtain ‚ü®s, hs‚ÇÅ, _, hs‚ÇÇ‚ü© :=\n          CFC.exists_sqrt_of_isSelfAdjoint_of_quasispectrumRestricts h.1 h.2\n        refine ‚ü®s * s, ?_, by rwa [eq_sub_iff_add_eq', eq_comm] at hs‚ÇÇ‚ü©\n        exact AddSubmonoid.subset_closure ‚ü®s, by simp [hs‚ÇÅ.star_eq, sq]‚ü©\n      ¬∑ rintro ‚ü®p, hp, rfl‚ü©\n        show IsSelfAdjoint (x + p - x) ‚àß\n          QuasispectrumRestricts (x + p - x) ContinuousMap.realToNNReal\n        simp only [add_sub_cancel_left]\n        --suffices IsSelfAdjoint p ‚àß SpectrumRestricts p ContinuousMap.realToNNReal from\n          --‚ü®by simpa using this.1, by simpa using this.2‚ü©\n        induction hp using AddSubmonoid.closure_induction with\n        | mem x hx =>\n          obtain ‚ü®s, rfl‚ü© := hx\n          refine ‚ü®IsSelfAdjoint.star_mul_self s, ?_‚ü©\n          rw [quasispectrumRestricts_iff_spectrumRestricts_inr' ‚ÑÇ,\n            SpectrumRestricts.nnreal_iff, Unitization.inr_mul, Unitization.inr_star]\n          exact spectrum_star_mul_self_nonneg\n        | one =>\n          rw [quasispectrumRestricts_iff_spectrumRestricts_inr' ‚ÑÇ, SpectrumRestricts.nnreal_iff]\n          nontriviality A\n          simp\n        | mul x y _ _ hx hy =>\n          simp +singlePass only [‚Üê Unitization.isSelfAdjoint_inr (R := ‚ÑÇ),\n            quasispectrumRestricts_iff_spectrumRestricts_inr' ‚ÑÇ] at hx hy ‚ä¢\n          rw [Unitization.inr_add]\n          exact ‚ü®hx.1.add hy.1, hx.2.nnreal_add hx.1 hy.1 hy.2‚ü© }\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClass'","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\n‚ä¢ NonnegSpectrumClass Real A","decl":"open scoped CStarAlgebra in\ninstance CStarAlgebra.instNonnegSpectrumClass' : NonnegSpectrumClass ‚Ñù A where\n  quasispectrum_nonneg_of_nonneg a ha := by\n    rw [Unitization.quasispectrum_eq_spectrum_inr' _ ‚ÑÇ]\n    -- should this actually be an instance on the `Unitization`? (probably scoped)\n    let _ := CStarAlgebra.spectralOrder A‚Å∫¬π\n    have := CStarAlgebra.spectralOrderedRing A‚Å∫¬π\n    apply spectrum_nonneg_of_nonneg\n    rw [StarOrderedRing.nonneg_iff] at ha ‚ä¢\n    have := AddSubmonoid.mem_map_of_mem (Unitization.inrNonUnitalStarAlgHom ‚ÑÇ A) ha\n    rw [AddMonoidHom.map_mclosure, ‚Üê Set.range_comp] at this\n    apply AddSubmonoid.closure_mono ?_ this\n    rintro _ ‚ü®s, rfl‚ü©\n    exact ‚ü®s, by simp‚ü©\n\n"}
{"name":"Unitization.cfc‚Çô_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π‚Å¥ : NonUnitalCStarAlgebra A\nR : Type u_3\ninst‚úù¬π¬≥ : Semifield R\ninst‚úù¬π¬≤ : StarRing R\ninst‚úù¬π¬π : MetricSpace R\ninst‚úù¬π‚Å∞ : TopologicalSemiring R\ninst‚úù‚Åπ : ContinuousStar R\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : IsScalarTower R A A\ninst‚úù‚Å∂ : SMulCommClass R A A\ninst‚úù‚Åµ : CompleteSpace R\ninst‚úù‚Å¥ : Algebra R Complex\ninst‚úù¬≥ : IsScalarTower R Complex A\np : A ‚Üí Prop\np' : Unitization Complex A ‚Üí Prop\ninst‚úù¬≤ : NonUnitalContinuousFunctionalCalculus R p\ninst‚úù¬π : ContinuousFunctionalCalculus R p'\ninst‚úù : ContinuousMapZero.UniqueHom R (Unitization Complex A)\nhp : ‚àÄ {a : A}, Iff (p' ‚Üëa) (p a)\na : A\nf : R ‚Üí R\nhf‚ÇÄ : autoParam (Eq (f 0) 0) _auto‚úù\n‚ä¢ Eq (‚Üë(cfc‚Çô f a)) (cfc f ‚Üëa)","decl":"open scoped NonUnitalContinuousFunctionalCalculus in\n/-- This lemma requires a lot from type class synthesis, and so one should instead favor the bespoke\nversions for `‚Ñù‚â•0`, `‚Ñù`, and `‚ÑÇ`. -/\nlemma Unitization.cfc‚Çô_eq_cfc_inr {R : Type*} [Semifield R] [StarRing R] [MetricSpace R]\n    [TopologicalSemiring R] [ContinuousStar R] [Module R A] [IsScalarTower R A A]\n    [SMulCommClass R A A] [CompleteSpace R] [Algebra R ‚ÑÇ] [IsScalarTower R ‚ÑÇ A]\n    {p : A ‚Üí Prop} {p' : A‚Å∫¬π ‚Üí Prop} [NonUnitalContinuousFunctionalCalculus R p]\n    [ContinuousFunctionalCalculus R p']\n    [ContinuousMapZero.UniqueHom R (Unitization ‚ÑÇ A)]\n    (hp : ‚àÄ {a : A}, p' (a : A‚Å∫¬π) ‚Üî p a) (a : A) (f : R ‚Üí R) (hf‚ÇÄ : f 0 = 0 := by cfc_zero_tac) :\n    cfc‚Çô f a = cfc f (a : A‚Å∫¬π) := by\n  by_cases h : ContinuousOn f (œÉ‚Çô R a) ‚àß p a\n  ¬∑ obtain ‚ü®hf, ha‚ü© := h\n    rw [‚Üê cfc‚Çô_eq_cfc (quasispectrum_inr_eq R ‚ÑÇ a ‚ñ∏ hf)]\n    exact (inrNonUnitalStarAlgHom ‚ÑÇ A).map_cfc‚Çô f a\n  ¬∑ obtain (hf | ha) := not_and_or.mp h\n    ¬∑ rw [cfc‚Çô_apply_of_not_continuousOn a hf, inr_zero,\n        cfc_apply_of_not_continuousOn _ (quasispectrum_eq_spectrum_inr' R ‚ÑÇ a ‚ñ∏ hf)]\n    ¬∑ rw [cfc‚Çô_apply_of_not_predicate a ha, inr_zero,\n        cfc_apply_of_not_predicate _ (not_iff_not.mpr hp |>.mpr ha)]\n\n"}
{"name":"Unitization.complex_cfc‚Çô_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\na : A\nf : Complex ‚Üí Complex\nhf‚ÇÄ : autoParam (Eq (f 0) 0) _auto‚úù\n‚ä¢ Eq (‚Üë(cfc‚Çô f a)) (cfc f ‚Üëa)","decl":"lemma Unitization.complex_cfc‚Çô_eq_cfc_inr (a : A) (f : ‚ÑÇ ‚Üí ‚ÑÇ) (hf‚ÇÄ : f 0 = 0 := by cfc_zero_tac) :\n    cfc‚Çô f a = cfc f (a : A‚Å∫¬π) :=\n  Unitization.cfc‚Çô_eq_cfc_inr isStarNormal_inr ..\n\n"}
{"name":"Unitization.real_cfc‚Çô_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\na : A\nf : Real ‚Üí Real\nhf‚ÇÄ : autoParam (Eq (f 0) 0) _auto‚úù\n‚ä¢ Eq (‚Üë(cfc‚Çô f a)) (cfc f ‚Üëa)","decl":"/-- note: the version for `‚Ñù‚â•0`, `Unization.nnreal_cfc‚Çô_eq_cfc_inr`, can be found in\n`Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order` -/\nlemma Unitization.real_cfc‚Çô_eq_cfc_inr (a : A) (f : ‚Ñù ‚Üí ‚Ñù) (hf‚ÇÄ : f 0 = 0 := by cfc_zero_tac) :\n    cfc‚Çô f a = cfc f (a : A‚Å∫¬π) :=\n  Unitization.cfc‚Çô_eq_cfc_inr isSelfAdjoint_inr ..\n\n"}
{"name":"IsStarNormal.instIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\n‚ä¢ IsometricContinuousFunctionalCalculus Complex A IsStarNormal","decl":"instance IsStarNormal.instIsometricContinuousFunctionalCalculus :\n    IsometricContinuousFunctionalCalculus ‚ÑÇ A IsStarNormal where\n  isometric a ha := by\n    rw [cfcHom_eq_of_isStarNormal]\n    exact isometry_subtype_coe.comp <| StarAlgEquiv.isometry (continuousFunctionalCalculus a)\n\n"}
{"name":"IsSelfAdjoint.instIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\n‚ä¢ IsometricContinuousFunctionalCalculus Real A IsSelfAdjoint","decl":"instance IsSelfAdjoint.instIsometricContinuousFunctionalCalculus :\n    IsometricContinuousFunctionalCalculus ‚Ñù A IsSelfAdjoint :=\n  SpectrumRestricts.isometric_cfc Complex.reCLM Complex.isometry_ofReal (.zero _)\n    fun _ ‚Ü¶ isSelfAdjoint_iff_isStarNormal_and_spectrumRestricts\n\n"}
{"name":"IsStarNormal.instNonUnitalIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\n‚ä¢ NonUnitalIsometricContinuousFunctionalCalculus Complex A IsStarNormal","decl":"open ContinuousMapZero in\ninstance IsStarNormal.instNonUnitalIsometricContinuousFunctionalCalculus :\n    NonUnitalIsometricContinuousFunctionalCalculus ‚ÑÇ A IsStarNormal where\n  isometric a ha := by\n    refine AddMonoidHomClass.isometry_of_norm _ fun f ‚Ü¶ ?_\n    rw [‚Üê norm_inr (ùïú := ‚ÑÇ), ‚Üê inrNonUnitalStarAlgHom_apply, ‚Üê NonUnitalStarAlgHom.comp_apply,\n      inr_comp_cfc‚ÇôHom_eq_cfc‚ÇôAux a, cfc‚ÇôAux]\n    simp only [NonUnitalStarAlgHom.comp_assoc, NonUnitalStarAlgHom.comp_apply,\n      toContinuousMapHom_apply, NonUnitalStarAlgHom.coe_coe]\n    rw [norm_cfcHom (a : Unitization ‚ÑÇ A), StarAlgEquiv.norm_map]\n    rfl\n\n"}
{"name":"IsSelfAdjoint.instNonUnitalIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst‚úù : NonUnitalCStarAlgebra A\n‚ä¢ NonUnitalIsometricContinuousFunctionalCalculus Real A IsSelfAdjoint","decl":"instance IsSelfAdjoint.instNonUnitalIsometricContinuousFunctionalCalculus :\n    NonUnitalIsometricContinuousFunctionalCalculus ‚Ñù A IsSelfAdjoint :=\n  QuasispectrumRestricts.isometric_cfc Complex.reCLM Complex.isometry_ofReal (.zero _)\n    fun _ ‚Ü¶ isSelfAdjoint_iff_isStarNormal_and_quasispectrumRestricts\n\n"}
