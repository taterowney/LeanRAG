{"name":"StarAlgebra.elemental.characterSpaceToSpectrum_coe","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝ : CStarAlgebra A\nx : A\nφ : ↑(WeakDual.characterSpace Complex (Subtype fun x_1 => Membership.mem (StarAlgebra.elemental Complex x) x_1))\n⊢ Eq (↑(StarAlgebra.elemental.characterSpaceToSpectrum x φ)) (φ ⟨x, ⋯⟩)","decl":"/-- The natural map from `characterSpace ℂ (elemental ℂ x)` to `spectrum ℂ x` given\nby evaluating `φ` at `x`. This is essentially just evaluation of the `gelfandTransform` of `x`,\nbut because we want something in `spectrum ℂ x`, as opposed to\n`spectrum ℂ ⟨x, elemental.self_mem ℂ x⟩` there is slightly more work to do. -/\n@[simps]\nnoncomputable def characterSpaceToSpectrum (x : A)\n    (φ : characterSpace ℂ (elemental ℂ x)) : spectrum ℂ x where\n  val := φ ⟨x, self_mem ℂ x⟩\n  property := by\n    simpa only [StarSubalgebra.spectrum_eq (hS := isClosed ℂ x)\n      (a := ⟨x, self_mem ℂ x⟩)] using AlgHom.apply_mem_spectrum φ ⟨x, self_mem ℂ x⟩\n\n"}
{"name":"StarAlgebra.elemental.continuous_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝ : CStarAlgebra A\nx : A\n⊢ Continuous (StarAlgebra.elemental.characterSpaceToSpectrum x)","decl":"theorem continuous_characterSpaceToSpectrum (x : A) :\n    Continuous (characterSpaceToSpectrum x) :=\n  continuous_induced_rng.2\n    (map_continuous <| gelfandTransform ℂ (elemental ℂ x) ⟨x, self_mem ℂ x⟩)\n\n"}
{"name":"elementalStarAlgebra.continuous_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝ : CStarAlgebra A\nx : A\n⊢ Continuous (StarAlgebra.elemental.characterSpaceToSpectrum x)","decl":"@[deprecated (since := \"2024-11-05\")]\nalias _root_.elementalStarAlgebra.continuous_characterSpaceToSpectrum :=\n  continuous_characterSpaceToSpectrum\n\n"}
{"name":"StarAlgebra.elemental.bijective_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CStarAlgebra A\na : A\ninst✝ : IsStarNormal a\n⊢ Function.Bijective (StarAlgebra.elemental.characterSpaceToSpectrum a)","decl":"theorem bijective_characterSpaceToSpectrum :\n    Function.Bijective (characterSpaceToSpectrum a) := by\n  refine ⟨fun φ ψ h => starAlgHomClass_ext ℂ ?_ ?_ ?_, ?_⟩\n  · exact (map_continuous φ)\n  · exact (map_continuous ψ)\n  · simpa only [characterSpaceToSpectrum, Subtype.mk_eq_mk,\n      ContinuousMap.coe_mk] using h\n  · rintro ⟨z, hz⟩\n    have hz' := (StarSubalgebra.spectrum_eq (hS := isClosed ℂ a)\n      (a := ⟨a, self_mem ℂ a⟩) ▸ hz)\n    rw [CharacterSpace.mem_spectrum_iff_exists] at hz'\n    obtain ⟨φ, rfl⟩ := hz'\n    exact ⟨φ, rfl⟩\n\n"}
{"name":"elementalStarAlgebra.bijective_characterSpaceToSpectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CStarAlgebra A\na : A\ninst✝ : IsStarNormal a\n⊢ Function.Bijective (StarAlgebra.elemental.characterSpaceToSpectrum a)","decl":"@[deprecated (since := \"2024-11-05\")]\nalias _root_.elementalStarAlgebra.bijective_characterSpaceToSpectrum :=\n  bijective_characterSpaceToSpectrum\n\n"}
{"name":"continuousFunctionalCalculus_map_id","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CStarAlgebra A\na : A\ninst✝ : IsStarNormal a\n⊢ Eq ((continuousFunctionalCalculus a) (ContinuousMap.restrict (spectrum Complex a) (ContinuousMap.id Complex))) ⟨a, ⋯⟩","decl":"theorem continuousFunctionalCalculus_map_id :\n    continuousFunctionalCalculus a ((ContinuousMap.id ℂ).restrict (spectrum ℂ a)) =\n      ⟨a, self_mem ℂ a⟩ :=\n  (gelfandStarTransform (elemental ℂ a)).symm_apply_apply _\n\n"}
{"name":"IsStarNormal.instContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\n⊢ ContinuousFunctionalCalculus Complex IsStarNormal","decl":"instance IsStarNormal.instContinuousFunctionalCalculus {A : Type*} [CStarAlgebra A] :\n    ContinuousFunctionalCalculus ℂ (IsStarNormal : A → Prop) where\n  predicate_zero := .zero\n  spectrum_nonempty a _ := spectrum.nonempty a\n  exists_cfc_of_predicate a ha := by\n    refine ⟨(StarAlgebra.elemental ℂ a).subtype.comp <| continuousFunctionalCalculus a,\n      ?hom_isClosedEmbedding, ?hom_id, ?hom_map_spectrum, ?predicate_hom⟩\n    case hom_isClosedEmbedding =>\n      exact Isometry.isClosedEmbedding <|\n        isometry_subtype_coe.comp <| StarAlgEquiv.isometry (continuousFunctionalCalculus a)\n    case hom_id => exact congr_arg Subtype.val <| continuousFunctionalCalculus_map_id a\n    case hom_map_spectrum =>\n      intro f\n      simp only [StarAlgHom.comp_apply, StarAlgHom.coe_coe, StarSubalgebra.coe_subtype]\n      rw [← StarSubalgebra.spectrum_eq (hS := StarAlgebra.elemental.isClosed ℂ a),\n        AlgEquiv.spectrum_eq (continuousFunctionalCalculus a), ContinuousMap.spectrum_eq_range]\n    case predicate_hom => exact fun f ↦ ⟨by rw [← map_star]; exact Commute.all (star f) f |>.map _⟩\n\n"}
{"name":"cfcHom_eq_of_isStarNormal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\na : A\nha : IsStarNormal a\n⊢ Eq (cfcHom ha) ((StarAlgebra.elemental Complex a).subtype.comp ↑(continuousFunctionalCalculus a))","decl":"lemma cfcHom_eq_of_isStarNormal {A : Type*} [CStarAlgebra A] (a : A) [ha : IsStarNormal a] :\n    cfcHom ha = (StarAlgebra.elemental ℂ a).subtype.comp (continuousFunctionalCalculus a) := by\n  refine cfcHom_eq_of_continuous_of_map_id ha _ ?_ ?_\n  · exact continuous_subtype_val.comp <|\n      (StarAlgEquiv.isometry (continuousFunctionalCalculus a)).continuous\n  · simp [continuousFunctionalCalculus_map_id a]\n\n"}
{"name":"IsStarNormal.instNonUnitalContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\n⊢ NonUnitalContinuousFunctionalCalculus Complex IsStarNormal","decl":"instance IsStarNormal.instNonUnitalContinuousFunctionalCalculus {A : Type*}\n    [NonUnitalCStarAlgebra A] : NonUnitalContinuousFunctionalCalculus ℂ (IsStarNormal : A → Prop) :=\n  RCLike.nonUnitalContinuousFunctionalCalculus Unitization.isStarNormal_inr\n\n"}
{"name":"inr_comp_cfcₙHom_eq_cfcₙAux","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\na : A\nha : IsStarNormal a\n⊢ Eq ((Unitization.inrNonUnitalStarAlgHom Complex A).comp (cfcₙHom ha)) (cfcₙAux ⋯ a ha)","decl":"open Unitization CStarAlgebra in\nlemma inr_comp_cfcₙHom_eq_cfcₙAux {A : Type*} [NonUnitalCStarAlgebra A] (a : A)\n    [ha : IsStarNormal a] : (inrNonUnitalStarAlgHom ℂ A).comp (cfcₙHom ha) =\n      cfcₙAux (isStarNormal_inr (R := ℂ) (A := A)) a ha := by\n  have h (a : A) := isStarNormal_inr (R := ℂ) (A := A) (a := a)\n  refine @ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id\n    _ _ _ _ _ _ _ _ _ _ _ inferInstance inferInstance _ (σₙ ℂ a) _ _ rfl _ _ ?_ ?_ ?_\n  · show Continuous (fun f ↦ (cfcₙHom ha f : A⁺¹)); fun_prop\n  · exact isClosedEmbedding_cfcₙAux @(h) a ha |>.continuous\n  · trans (a : A⁺¹)\n    · congrm(inr $(cfcₙHom_id ha))\n    · exact cfcₙAux_id @(h) a ha |>.symm\n\n"}
{"name":"SpectrumRestricts.nnreal_iff_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\na : A\nt : NNReal\nha : IsSelfAdjoint a\nht : LE.le (NNNorm.nnnorm a) t\n⊢ Iff (SpectrumRestricts a ⇑ContinuousMap.realToNNReal) (LE.le (NNNorm.nnnorm (HSub.hSub ((algebraMap Real A) ↑t) a)) t)","decl":"lemma SpectrumRestricts.nnreal_iff_nnnorm {a : A} {t : ℝ≥0} (ha : IsSelfAdjoint a) (ht : ‖a‖₊ ≤ t) :\n    SpectrumRestricts a ContinuousMap.realToNNReal ↔ ‖algebraMap ℝ A t - a‖₊ ≤ t := by\n  have : IsSelfAdjoint (algebraMap ℝ A t - a) := IsSelfAdjoint.algebraMap A (.all (t : ℝ)) |>.sub ha\n  rw [← ENNReal.coe_le_coe, ← IsSelfAdjoint.spectralRadius_eq_nnnorm,\n    ← SpectrumRestricts.spectralRadius_eq (f := Complex.reCLM)] at ht ⊢\n  · exact SpectrumRestricts.nnreal_iff_spectralRadius_le ht\n  all_goals\n    try apply IsSelfAdjoint.spectrumRestricts\n    assumption\n\n"}
{"name":"SpectrumRestricts.nnreal_add","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\na b : A\nha₁ : IsSelfAdjoint a\nhb₁ : IsSelfAdjoint b\nha₂ : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nhb₂ : SpectrumRestricts b ⇑ContinuousMap.realToNNReal\n⊢ SpectrumRestricts (HAdd.hAdd a b) ⇑ContinuousMap.realToNNReal","decl":"lemma SpectrumRestricts.nnreal_add {a b : A} (ha₁ : IsSelfAdjoint a)\n    (hb₁ : IsSelfAdjoint b) (ha₂ : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (hb₂ : SpectrumRestricts b ContinuousMap.realToNNReal) :\n    SpectrumRestricts (a + b) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff_nnnorm (ha₁.add hb₁) (nnnorm_add_le a b), NNReal.coe_add,\n    map_add, add_sub_add_comm]\n  refine nnnorm_add_le _ _ |>.trans ?_\n  gcongr\n  all_goals rw [← SpectrumRestricts.nnreal_iff_nnnorm] <;> first | rfl | assumption\n\n"}
{"name":"IsSelfAdjoint.sq_spectrumRestricts","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n⊢ SpectrumRestricts (HPow.hPow a 2) ⇑ContinuousMap.realToNNReal","decl":"lemma IsSelfAdjoint.sq_spectrumRestricts {a : A} (ha : IsSelfAdjoint a) :\n    SpectrumRestricts (a ^ 2) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff, ← cfc_id (R := ℝ) a, ← cfc_pow .., cfc_map_spectrum ..]\n  rintro - ⟨x, -, rfl⟩\n  exact sq_nonneg x\n\n"}
{"name":"SpectrumRestricts.eq_zero_of_neg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\nha₁ : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nha₂ : SpectrumRestricts (Neg.neg a) ⇑ContinuousMap.realToNNReal\n⊢ Eq a 0","decl":"lemma SpectrumRestricts.eq_zero_of_neg {a : A} (ha : IsSelfAdjoint a)\n    (ha₁ : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (ha₂ : SpectrumRestricts (-a) ContinuousMap.realToNNReal) :\n    a = 0 := by\n  nontriviality A\n  rw [SpectrumRestricts.nnreal_iff] at ha₁ ha₂\n  apply CFC.eq_zero_of_spectrum_subset_zero (R := ℝ) a\n  rw [Set.subset_singleton_iff]\n  simp only [← spectrum.neg_eq, Set.mem_neg] at ha₂\n  peel ha₁ with x hx _\n  linarith [ha₂ (-x) ((neg_neg x).symm ▸ hx)]\n\n"}
{"name":"SpectrumRestricts.smul_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nha : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : Real\nhr : LE.le 0 r\n⊢ SpectrumRestricts (HSMul.hSMul r a) ⇑ContinuousMap.realToNNReal","decl":"lemma SpectrumRestricts.smul_of_nonneg {A : Type*} [Ring A] [Algebra ℝ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ} (hr : 0 ≤ r) :\n    SpectrumRestricts (r • a) ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff] at ha ⊢\n  nontriviality A\n  intro x hx\n  by_cases hr' : r = 0\n  · simp [hr'] at hx ⊢\n    exact hx.symm.le\n  · lift r to ℝˣ using IsUnit.mk0 r hr'\n    rw [← Units.smul_def, spectrum.unit_smul_eq_smul, Set.mem_smul_set_iff_inv_smul_mem] at hx\n    refine le_of_smul_le_smul_left ?_ (inv_pos.mpr <| lt_of_le_of_ne hr <| ne_comm.mpr hr')\n    simpa [Units.smul_def] using ha _ hx\n\n"}
{"name":"spectrum_star_mul_self_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\nb : A\nx : Real\na✝ : Membership.mem (spectrum Real (HMul.hMul (Star.star b) b)) x\n⊢ LE.le 0 x","decl":"lemma spectrum_star_mul_self_nonneg {b : A} : ∀ x ∈ spectrum ℝ (star b * b), 0 ≤ x := by\n  set a := star b * b\n  have a_def : a = star b * b := rfl\n  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.id ℝ ⊔ 0) x) a\n  set c := b * a_neg\n  have h_eq_a_neg : - (star c * c) = a_neg ^ 3 := by\n    simp only [c, a_neg, star_mul]\n    rw [← mul_assoc, mul_assoc _ _ b, ← cfc_star, ← cfc_id' ℝ (star b * b), a_def, ← neg_mul]\n    rw [← cfc_mul _ _ (star b * b) (by simp; fun_prop), neg_mul]\n    simp only [ContinuousMap.coe_neg, ContinuousMap.coe_id, Pi.sup_apply, Pi.neg_apply,\n      star_trivial]\n    rw [← cfc_mul .., ← cfc_neg .., ← cfc_pow ..]\n    congr\n    ext x\n    by_cases hx : x ≤ 0\n    · rw [← neg_nonneg] at hx\n      simp [sup_eq_left.mpr hx, pow_succ]\n    · rw [not_le, ← neg_neg_iff_pos] at hx\n      simp [sup_eq_right.mpr hx.le]\n  have h_c_spec₀ : SpectrumRestricts (- (star c * c)) (ContinuousMap.realToNNReal ·) := by\n    simp only [SpectrumRestricts.nnreal_iff, h_eq_a_neg]\n    rw [← cfc_pow _ _ (ha := .star_mul_self b)]\n    simp only [a, cfc_map_spectrum (R := ℝ) (fun x => (-ContinuousMap.id ℝ ⊔ 0) x ^ 3) (star b * b)]\n    rintro - ⟨x, -, rfl⟩\n    simp\n  have c_eq := star_mul_self_add_self_mul_star c\n  rw [← eq_sub_iff_add_eq', sub_eq_add_neg, ← sq, ← sq] at c_eq\n  have h_c_spec₁ : SpectrumRestricts (c * star c) ContinuousMap.realToNNReal := by\n    rw [c_eq]\n    refine SpectrumRestricts.nnreal_add ?_ ?_ ?_ h_c_spec₀\n    · exact IsSelfAdjoint.smul (by rfl) <| ((ℜ c).prop.pow 2).add ((ℑ c).prop.pow 2)\n    · exact (IsSelfAdjoint.star_mul_self c).neg\n    · rw [← Nat.cast_smul_eq_nsmul ℝ]\n      refine (ℜ c).2.sq_spectrumRestricts.nnreal_add ((ℜ c).2.pow 2) ((ℑ c).2.pow 2)\n        (ℑ c).2.sq_spectrumRestricts |>.smul_of_nonneg <| by norm_num\n  have h_c_spec₂ : SpectrumRestricts (star c * c) ContinuousMap.realToNNReal := by\n    rw [SpectrumRestricts.nnreal_iff] at h_c_spec₁ ⊢\n    intro x hx\n    replace hx := Set.subset_diff_union _ {(0 : ℝ)} hx\n    rw [spectrum.nonzero_mul_eq_swap_mul, Set.diff_union_self, Set.union_singleton,\n      Set.mem_insert_iff] at hx\n    obtain (rfl | hx) := hx\n    exacts [le_rfl, h_c_spec₁ x hx]\n  rw [h_c_spec₂.eq_zero_of_neg (.star_mul_self c) h_c_spec₀, neg_zero] at h_eq_a_neg\n  simp only [a_neg] at h_eq_a_neg\n  rw [← cfc_pow _ _ (ha := .star_mul_self b), ← cfc_zero a (R := ℝ)] at h_eq_a_neg\n  intro x hx\n  by_contra! hx'\n  rw [← neg_pos] at hx'\n  apply (pow_pos hx' 3).ne\n  have h_eqOn := eqOn_of_cfc_eq_cfc (ha := IsSelfAdjoint.star_mul_self b) h_eq_a_neg\n  simpa [sup_eq_left.mpr hx'.le] using h_eqOn hx\n\n"}
{"name":"IsSelfAdjoint.coe_mem_spectrum_complex","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_3\ninst✝⁴ : TopologicalSpace A\ninst✝³ : Ring A\ninst✝² : StarRing A\ninst✝¹ : Algebra Complex A\ninst✝ : ContinuousFunctionalCalculus Complex IsStarNormal\na : A\nx : Real\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Iff (Membership.mem (spectrum Complex a) ↑x) (Membership.mem (spectrum Real a) x)","decl":"lemma IsSelfAdjoint.coe_mem_spectrum_complex {A : Type*} [TopologicalSpace A] [Ring A]\n    [StarRing A] [Algebra ℂ A] [ContinuousFunctionalCalculus ℂ (IsStarNormal : A → Prop)]\n    {a : A} {x : ℝ} (ha : IsSelfAdjoint a := by cfc_tac) :\n    (x : ℂ) ∈ spectrum ℂ a ↔ x ∈ spectrum ℝ a := by\n  simp [← ha.spectrumRestricts.algebraMap_image]\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClass","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝¹ : CStarAlgebra A\ninst✝ : PartialOrder A\n⊢ NonnegSpectrumClass Real A","decl":"instance CStarAlgebra.instNonnegSpectrumClass : NonnegSpectrumClass ℝ A :=\n  .of_spectrum_nonneg fun a ha ↦ by\n    rw [StarOrderedRing.nonneg_iff] at ha\n    induction ha using AddSubmonoid.closure_induction with\n    | mem x hx =>\n      obtain ⟨b, rfl⟩ := hx\n      exact spectrum_star_mul_self_nonneg\n    | one =>\n      nontriviality A\n      simp\n    | mul x y x_mem y_mem hx hy =>\n      rw [← SpectrumRestricts.nnreal_iff] at hx hy ⊢\n      rw [← StarOrderedRing.nonneg_iff] at x_mem y_mem\n      exact hx.nnreal_add (.of_nonneg x_mem) (.of_nonneg y_mem) hy\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClassComplexUnital","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝¹ : CStarAlgebra A\ninst✝ : PartialOrder A\n⊢ NonnegSpectrumClass Complex A","decl":"open ComplexOrder in\ninstance CStarAlgebra.instNonnegSpectrumClassComplexUnital : NonnegSpectrumClass ℂ A where\n  quasispectrum_nonneg_of_nonneg a ha x := by\n    rw [mem_quasispectrum_iff]\n    refine (Or.elim · ge_of_eq fun hx ↦ ?_)\n    obtain ⟨y, hy, rfl⟩ := (IsSelfAdjoint.of_nonneg ha).spectrumRestricts.algebraMap_image ▸ hx\n    simpa using spectrum_nonneg_of_nonneg ha hy\n\n"}
{"name":"CStarAlgebra.spectralOrderedRing","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\n⊢ StarOrderedRing A","decl":"/-- The `CStarAlgebra.spectralOrder` on a C⋆-algebra is a `StarOrderedRing`. -/\nlemma CStarAlgebra.spectralOrderedRing : @StarOrderedRing A _ (CStarAlgebra.spectralOrder A) _ :=\n  let _ := CStarAlgebra.spectralOrder A\n  { le_iff := by\n      intro x y\n      constructor\n      · intro h\n        obtain ⟨s, hs₁, _, hs₂⟩ :=\n          CFC.exists_sqrt_of_isSelfAdjoint_of_quasispectrumRestricts h.1 h.2\n        refine ⟨s * s, ?_, by rwa [eq_sub_iff_add_eq', eq_comm] at hs₂⟩\n        exact AddSubmonoid.subset_closure ⟨s, by simp [hs₁.star_eq, sq]⟩\n      · rintro ⟨p, hp, rfl⟩\n        show IsSelfAdjoint (x + p - x) ∧\n          QuasispectrumRestricts (x + p - x) ContinuousMap.realToNNReal\n        simp only [add_sub_cancel_left]\n        --suffices IsSelfAdjoint p ∧ SpectrumRestricts p ContinuousMap.realToNNReal from\n          --⟨by simpa using this.1, by simpa using this.2⟩\n        induction hp using AddSubmonoid.closure_induction with\n        | mem x hx =>\n          obtain ⟨s, rfl⟩ := hx\n          refine ⟨IsSelfAdjoint.star_mul_self s, ?_⟩\n          rw [quasispectrumRestricts_iff_spectrumRestricts_inr' ℂ,\n            SpectrumRestricts.nnreal_iff, Unitization.inr_mul, Unitization.inr_star]\n          exact spectrum_star_mul_self_nonneg\n        | one =>\n          rw [quasispectrumRestricts_iff_spectrumRestricts_inr' ℂ, SpectrumRestricts.nnreal_iff]\n          nontriviality A\n          simp\n        | mul x y _ _ hx hy =>\n          simp +singlePass only [← Unitization.isSelfAdjoint_inr (R := ℂ),\n            quasispectrumRestricts_iff_spectrumRestricts_inr' ℂ] at hx hy ⊢\n          rw [Unitization.inr_add]\n          exact ⟨hx.1.add hy.1, hx.2.nnreal_add hx.1 hy.1 hy.2⟩ }\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClass'","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝¹ : NonUnitalCStarAlgebra A\ninst✝ : PartialOrder A\n⊢ NonnegSpectrumClass Real A","decl":"open scoped CStarAlgebra in\ninstance CStarAlgebra.instNonnegSpectrumClass' : NonnegSpectrumClass ℝ A where\n  quasispectrum_nonneg_of_nonneg a ha := by\n    rw [Unitization.quasispectrum_eq_spectrum_inr' _ ℂ]\n    -- should this actually be an instance on the `Unitization`? (probably scoped)\n    let _ := CStarAlgebra.spectralOrder A⁺¹\n    have := CStarAlgebra.spectralOrderedRing A⁺¹\n    apply spectrum_nonneg_of_nonneg\n    rw [StarOrderedRing.nonneg_iff] at ha ⊢\n    have := AddSubmonoid.mem_map_of_mem (Unitization.inrNonUnitalStarAlgHom ℂ A) ha\n    rw [AddMonoidHom.map_mclosure, ← Set.range_comp] at this\n    apply AddSubmonoid.closure_mono ?_ this\n    rintro _ ⟨s, rfl⟩\n    exact ⟨s, by simp⟩\n\n"}
{"name":"Unitization.cfcₙ_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝¹⁴ : NonUnitalCStarAlgebra A\nR : Type u_3\ninst✝¹³ : Semifield R\ninst✝¹² : StarRing R\ninst✝¹¹ : MetricSpace R\ninst✝¹⁰ : TopologicalSemiring R\ninst✝⁹ : ContinuousStar R\ninst✝⁸ : Module R A\ninst✝⁷ : IsScalarTower R A A\ninst✝⁶ : SMulCommClass R A A\ninst✝⁵ : CompleteSpace R\ninst✝⁴ : Algebra R Complex\ninst✝³ : IsScalarTower R Complex A\np : A → Prop\np' : Unitization Complex A → Prop\ninst✝² : NonUnitalContinuousFunctionalCalculus R p\ninst✝¹ : ContinuousFunctionalCalculus R p'\ninst✝ : ContinuousMapZero.UniqueHom R (Unitization Complex A)\nhp : ∀ {a : A}, Iff (p' ↑a) (p a)\na : A\nf : R → R\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\n⊢ Eq (↑(cfcₙ f a)) (cfc f ↑a)","decl":"open scoped NonUnitalContinuousFunctionalCalculus in\n/-- This lemma requires a lot from type class synthesis, and so one should instead favor the bespoke\nversions for `ℝ≥0`, `ℝ`, and `ℂ`. -/\nlemma Unitization.cfcₙ_eq_cfc_inr {R : Type*} [Semifield R] [StarRing R] [MetricSpace R]\n    [TopologicalSemiring R] [ContinuousStar R] [Module R A] [IsScalarTower R A A]\n    [SMulCommClass R A A] [CompleteSpace R] [Algebra R ℂ] [IsScalarTower R ℂ A]\n    {p : A → Prop} {p' : A⁺¹ → Prop} [NonUnitalContinuousFunctionalCalculus R p]\n    [ContinuousFunctionalCalculus R p']\n    [ContinuousMapZero.UniqueHom R (Unitization ℂ A)]\n    (hp : ∀ {a : A}, p' (a : A⁺¹) ↔ p a) (a : A) (f : R → R) (hf₀ : f 0 = 0 := by cfc_zero_tac) :\n    cfcₙ f a = cfc f (a : A⁺¹) := by\n  by_cases h : ContinuousOn f (σₙ R a) ∧ p a\n  · obtain ⟨hf, ha⟩ := h\n    rw [← cfcₙ_eq_cfc (quasispectrum_inr_eq R ℂ a ▸ hf)]\n    exact (inrNonUnitalStarAlgHom ℂ A).map_cfcₙ f a\n  · obtain (hf | ha) := not_and_or.mp h\n    · rw [cfcₙ_apply_of_not_continuousOn a hf, inr_zero,\n        cfc_apply_of_not_continuousOn _ (quasispectrum_eq_spectrum_inr' R ℂ a ▸ hf)]\n    · rw [cfcₙ_apply_of_not_predicate a ha, inr_zero,\n        cfc_apply_of_not_predicate _ (not_iff_not.mpr hp |>.mpr ha)]\n\n"}
{"name":"Unitization.complex_cfcₙ_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\na : A\nf : Complex → Complex\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\n⊢ Eq (↑(cfcₙ f a)) (cfc f ↑a)","decl":"lemma Unitization.complex_cfcₙ_eq_cfc_inr (a : A) (f : ℂ → ℂ) (hf₀ : f 0 = 0 := by cfc_zero_tac) :\n    cfcₙ f a = cfc f (a : A⁺¹) :=\n  Unitization.cfcₙ_eq_cfc_inr isStarNormal_inr ..\n\n"}
{"name":"Unitization.real_cfcₙ_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\na : A\nf : Real → Real\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\n⊢ Eq (↑(cfcₙ f a)) (cfc f ↑a)","decl":"/-- note: the version for `ℝ≥0`, `Unization.nnreal_cfcₙ_eq_cfc_inr`, can be found in\n`Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order` -/\nlemma Unitization.real_cfcₙ_eq_cfc_inr (a : A) (f : ℝ → ℝ) (hf₀ : f 0 = 0 := by cfc_zero_tac) :\n    cfcₙ f a = cfc f (a : A⁺¹) :=\n  Unitization.cfcₙ_eq_cfc_inr isSelfAdjoint_inr ..\n\n"}
{"name":"IsStarNormal.instIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\n⊢ IsometricContinuousFunctionalCalculus Complex A IsStarNormal","decl":"instance IsStarNormal.instIsometricContinuousFunctionalCalculus :\n    IsometricContinuousFunctionalCalculus ℂ A IsStarNormal where\n  isometric a ha := by\n    rw [cfcHom_eq_of_isStarNormal]\n    exact isometry_subtype_coe.comp <| StarAlgEquiv.isometry (continuousFunctionalCalculus a)\n\n"}
{"name":"IsSelfAdjoint.instIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : CStarAlgebra A\n⊢ IsometricContinuousFunctionalCalculus Real A IsSelfAdjoint","decl":"instance IsSelfAdjoint.instIsometricContinuousFunctionalCalculus :\n    IsometricContinuousFunctionalCalculus ℝ A IsSelfAdjoint :=\n  SpectrumRestricts.isometric_cfc Complex.reCLM Complex.isometry_ofReal (.zero _)\n    fun _ ↦ isSelfAdjoint_iff_isStarNormal_and_spectrumRestricts\n\n"}
{"name":"IsStarNormal.instNonUnitalIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\n⊢ NonUnitalIsometricContinuousFunctionalCalculus Complex A IsStarNormal","decl":"open ContinuousMapZero in\ninstance IsStarNormal.instNonUnitalIsometricContinuousFunctionalCalculus :\n    NonUnitalIsometricContinuousFunctionalCalculus ℂ A IsStarNormal where\n  isometric a ha := by\n    refine AddMonoidHomClass.isometry_of_norm _ fun f ↦ ?_\n    rw [← norm_inr (𝕜 := ℂ), ← inrNonUnitalStarAlgHom_apply, ← NonUnitalStarAlgHom.comp_apply,\n      inr_comp_cfcₙHom_eq_cfcₙAux a, cfcₙAux]\n    simp only [NonUnitalStarAlgHom.comp_assoc, NonUnitalStarAlgHom.comp_apply,\n      toContinuousMapHom_apply, NonUnitalStarAlgHom.coe_coe]\n    rw [norm_cfcHom (a : Unitization ℂ A), StarAlgEquiv.norm_map]\n    rfl\n\n"}
{"name":"IsSelfAdjoint.instNonUnitalIsometricContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic","initialProofState":"A : Type u_2\ninst✝ : NonUnitalCStarAlgebra A\n⊢ NonUnitalIsometricContinuousFunctionalCalculus Real A IsSelfAdjoint","decl":"instance IsSelfAdjoint.instNonUnitalIsometricContinuousFunctionalCalculus :\n    NonUnitalIsometricContinuousFunctionalCalculus ℝ A IsSelfAdjoint :=\n  QuasispectrumRestricts.isometric_cfc Complex.reCLM Complex.isometry_ofReal (.zero _)\n    fun _ ↦ isSelfAdjoint_iff_isStarNormal_and_quasispectrumRestricts\n\n"}
