{"name":"CategoryTheory.Meq.congr_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nY : C\nf g : Quiver.Hom Y X\nh : Eq f g\nhf : (‚ÜëS).arrows f\n‚ä¢ Eq (‚Üëx { Y := Y, f := f, hf := hf }) (‚Üëx { Y := Y, f := g, hf := ‚ãØ })","decl":"lemma congr_apply {X} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x : Meq P S) {Y}\n    {f g : Y ‚ü∂ X} (h : f = g) (hf : S f) :\n    x ‚ü®_, _, hf‚ü© = x ‚ü®_, g, by simpa only [‚Üê h] using hf‚ü© := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.ext","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : CategoryTheory.Meq P S\nh : ‚àÄ (I : S.Arrow), Eq (‚Üëx I) (‚Üëy I)\n‚ä¢ Eq x y","decl":"@[ext]\ntheorem ext {X} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x y : Meq P S) (h : ‚àÄ I : S.Arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n\n"}
{"name":"CategoryTheory.Meq.ext_iff","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : CategoryTheory.Meq P S\n‚ä¢ Iff (Eq x y) (‚àÄ (I : S.Arrow), Eq (‚Üëx I) (‚Üëy I))","decl":"@[ext]\ntheorem ext {X} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x y : Meq P S) (h : ‚àÄ I : S.Arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n\n"}
{"name":"CategoryTheory.Meq.condition","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nI : S.Relation\n‚ä¢ Eq ((P.map I.r.g‚ÇÅ.op) (‚Üëx ((S.index P).fstTo I))) ((P.map I.r.g‚ÇÇ.op) (‚Üëx ((S.index P).sndTo I)))","decl":"theorem condition {X} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x : Meq P S) (I : S.Relation) :\n    P.map I.r.g‚ÇÅ.op (x ((S.index P).fstTo I)) = P.map I.r.g‚ÇÇ.op (x ((S.index P).sndTo I)) :=\n  x.2 _\n\n"}
{"name":"CategoryTheory.Meq.refine_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nx : CategoryTheory.Meq P T\ne : Quiver.Hom S T\nI : S.Arrow\n‚ä¢ Eq (‚Üë(x.refine e) I) (‚Üëx { Y := I.Y, f := I.f, hf := ‚ãØ })","decl":"@[simp]\ntheorem refine_apply {X : C} {P : C·µí·µñ ‚•§ D} {S T : J.Cover X} (x : Meq P T) (e : S ‚ü∂ T)\n    (I : S.Arrow) : x.refine e I = x ‚ü®I.Y, I.f, (leOfHom e) _ I.hf‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.pullback_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nf : Quiver.Hom Y X\nI : ((J.pullback f).obj S).Arrow\n‚ä¢ Eq (‚Üë(x.pullback f) I) (‚Üëx { Y := I.Y, f := CategoryTheory.CategoryStruct.comp I.f f, hf := ‚ãØ })","decl":"@[simp]\ntheorem pullback_apply {Y X : C} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x : Meq P S) (f : Y ‚ü∂ X)\n    (I : ((J.pullback f).obj S).Arrow) : x.pullback f I = x ‚ü®_, I.f ‚â´ f, I.hf‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.pullback_refine","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nh : Quiver.Hom S T\nf : Quiver.Hom Y X\nx : CategoryTheory.Meq P T\n‚ä¢ Eq ((x.pullback f).refine ((J.pullback f).map h)) ((x.refine h).pullback f)","decl":"@[simp]\ntheorem pullback_refine {Y X : C} {P : C·µí·µñ ‚•§ D} {S T : J.Cover X} (h : S ‚ü∂ T) (f : Y ‚ü∂ X)\n    (x : Meq P T) : (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.mk_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\nI : S.Arrow\n‚ä¢ Eq (‚Üë(CategoryTheory.Meq.mk S x) I) ((P.map I.f.op) x)","decl":"theorem mk_apply {X : C} {P : C·µí·µñ ‚•§ D} (S : J.Cover X) (x : P.obj (op X)) (I : S.Arrow) :\n    mk S x I = P.map I.f.op x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.equiv_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≤ : CategoryTheory.HasForget D\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\ninst‚úù : CategoryTheory.Limits.HasMultiequalizer (S.index P)\nx : (CategoryTheory.forget D).obj (CategoryTheory.Limits.multiequalizer (S.index P))\nI : S.Arrow\n‚ä¢ Eq (‚Üë((CategoryTheory.Meq.equiv P S) x) I) ((CategoryTheory.Limits.Multiequalizer.Œπ (S.index P) I) x)","decl":"@[simp]\ntheorem equiv_apply {X : C} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} [HasMultiequalizer (S.index P)]\n    (x : (multiequalizer (S.index P) : D)) (I : S.Arrow) :\n    equiv P S x I = Multiequalizer.Œπ (S.index P) I x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.equiv_symm_eq_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≤ : CategoryTheory.HasForget D\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\ninst‚úù : CategoryTheory.Limits.HasMultiequalizer (S.index P)\nx : CategoryTheory.Meq P S\nI : S.Arrow\n‚ä¢ Eq ((CategoryTheory.Limits.Multiequalizer.Œπ (S.index P) I) ((CategoryTheory.Meq.equiv P S).symm x)) (‚Üëx I)","decl":"theorem equiv_symm_eq_apply {X : C} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} [HasMultiequalizer (S.index P)]\n    (x : Meq P S) (I : S.Arrow) :\n    Multiequalizer.Œπ (S.index P) I ((Meq.equiv P S).symm x) = x I := by\n  rw [‚Üê equiv_apply]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullback","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å¥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≥ : CategoryTheory.HasForget D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nf : Quiver.Hom Y X\n‚ä¢ Eq (((J.plusObj P).map f.op) (CategoryTheory.GrothendieckTopology.Plus.mk x)) (CategoryTheory.GrothendieckTopology.Plus.mk (x.pullback f))","decl":"theorem res_mk_eq_mk_pullback {Y X : C} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x : Meq P S) (f : Y ‚ü∂ X) :\n    (J.plusObj P).map f.op (mk x) = mk (x.pullback f) := by\n  dsimp [mk, plusObj]\n  rw [‚Üê comp_apply (x := (Meq.equiv P S).symm x), Œπ_colimMap_assoc, colimit.Œπ_pre,\n    comp_apply (x := (Meq.equiv P S).symm x)]\n  apply congr_arg\n  apply (Meq.equiv P _).injective\n  erw [Equiv.apply_symm_apply]\n  ext i\n  simp only [Functor.op_obj, unop_op, pullback_obj, diagram_obj, Functor.comp_obj,\n    diagramPullback_app, Meq.equiv_apply, Meq.pullback_apply]\n  rw [‚Üê CategoryTheory.comp_apply, Multiequalizer.lift_Œπ]\n  erw [Meq.equiv_symm_eq_apply]\n  cases i; rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_mk","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å¥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≥ : CategoryTheory.HasForget D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\n‚ä¢ Eq (((J.toPlus P).app { unop := X }) x) (CategoryTheory.GrothendieckTopology.Plus.mk (CategoryTheory.Meq.mk S x))","decl":"theorem toPlus_mk {X : C} {P : C·µí·µñ ‚•§ D} (S : J.Cover X) (x : P.obj (op X)) :\n    (J.toPlus P).app _ x = mk (Meq.mk S x) := by\n  dsimp [mk, toPlus]\n  let e : S ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)\n  rw [‚Üê colimit.w _ e.op]\n  delta Cover.toMultiequalizer\n  rw [CategoryTheory.comp_apply]\n  erw [CategoryTheory.comp_apply]\n  apply congr_arg\n  dsimp [diagram]\n  apply Concrete.multiequalizer_ext\n  intro i\n  simp only [‚Üê CategoryTheory.comp_apply, Category.assoc, Multiequalizer.lift_Œπ, Category.comp_id,\n    Meq.equiv_symm_eq_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å¥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≥ : CategoryTheory.HasForget D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nI : S.Arrow\n‚ä¢ Eq (((J.toPlus P).app { unop := I.Y }) (‚Üëx I)) (((J.plusObj P).map I.f.op) (CategoryTheory.GrothendieckTopology.Plus.mk x))","decl":"theorem toPlus_apply {X : C} {P : C·µí·µñ ‚•§ D} (S : J.Cover X) (x : Meq P S) (I : S.Arrow) :\n    (J.toPlus P).app _ (x I) = (J.plusObj P).map I.f.op (mk x) := by\n  dsimp only [toPlus, plusObj]\n  delta Cover.toMultiequalizer\n  dsimp [mk]\n  erw [‚Üê CategoryTheory.comp_apply]\n  rw [Œπ_colimMap_assoc, colimit.Œπ_pre, CategoryTheory.comp_apply, CategoryTheory.comp_apply]\n  dsimp only [Functor.op]\n  let e : (J.pullback I.f).obj (unop (op S)) ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)\n  rw [‚Üê colimit.w _ e.op]\n  erw [CategoryTheory.comp_apply]\n  apply congr_arg\n  apply Concrete.multiequalizer_ext\n  intro i\n  dsimp\n  erw [‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply]\n  rw [Multiequalizer.lift_Œπ, Multiequalizer.lift_Œπ, Multiequalizer.lift_Œπ]\n  erw [Meq.equiv_symm_eq_apply]\n  simpa using (x.condition (Cover.Relation.mk' (I.precompRelation i.f))).symm\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_eq_mk","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å¥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≥ : CategoryTheory.HasForget D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\n‚ä¢ Eq (((J.toPlus P).app { unop := X }) x) (CategoryTheory.GrothendieckTopology.Plus.mk (CategoryTheory.Meq.mk Top.top x))","decl":"theorem toPlus_eq_mk {X : C} {P : C·µí·µñ ‚•§ D} (x : P.obj (op X)) :\n    (J.toPlus P).app _ x = mk (Meq.mk ‚ä§ x) := by\n  dsimp [mk, toPlus]\n  delta Cover.toMultiequalizer\n  simp only [CategoryTheory.comp_apply]\n  apply congr_arg\n  apply (Meq.equiv P ‚ä§).injective\n  ext i\n  rw [Meq.equiv_apply, Equiv.apply_symm_apply, ‚Üê CategoryTheory.comp_apply, Multiequalizer.lift_Œπ]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.exists_rep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å¥ : CategoryTheory.HasForget D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nx : (CategoryTheory.forget D).obj ((J.plusObj P).obj { unop := X })\n‚ä¢ Exists fun S => Exists fun y => Eq x (CategoryTheory.GrothendieckTopology.Plus.mk y)","decl":"theorem exists_rep {X : C} {P : C·µí·µñ ‚•§ D} (x : (J.plusObj P).obj (op X)) :\n    ‚àÉ (S : J.Cover X) (y : Meq P S), x = mk y := by\n  obtain ‚ü®S, y, h‚ü© := Concrete.colimit_exists_rep (J.diagram P X) x\n  use S.unop, Meq.equiv _ _ y\n  rw [‚Üê h]\n  dsimp [mk]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.eq_mk_iff_exists","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å¥ : CategoryTheory.HasForget D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nx : CategoryTheory.Meq P S\ny : CategoryTheory.Meq P T\n‚ä¢ Iff (Eq (CategoryTheory.GrothendieckTopology.Plus.mk x) (CategoryTheory.GrothendieckTopology.Plus.mk y)) (Exists fun W => Exists fun h1 => Exists fun h2 => Eq (x.refine h1) (y.refine h2))","decl":"theorem eq_mk_iff_exists {X : C} {P : C·µí·µñ ‚•§ D} {S T : J.Cover X} (x : Meq P S) (y : Meq P T) :\n    mk x = mk y ‚Üî ‚àÉ (W : J.Cover X) (h1 : W ‚ü∂ S) (h2 : W ‚ü∂ T), x.refine h1 = y.refine h2 := by\n  constructor\n  ¬∑ intro h\n    obtain ‚ü®W, h1, h2, hh‚ü© := Concrete.colimit_exists_of_rep_eq.{u} _ _ _ h\n    use W.unop, h1.unop, h2.unop\n    ext I\n    apply_fun Multiequalizer.Œπ (W.unop.index P) I at hh\n    convert hh\n    all_goals\n      dsimp [diagram]\n      erw [‚Üê CategoryTheory.comp_apply, Multiequalizer.lift_Œπ, Meq.equiv_symm_eq_apply]\n      cases I; rfl\n  ¬∑ rintro ‚ü®S, h1, h2, e‚ü©\n    apply Concrete.colimit_rep_eq_of_exists\n    use op S, h1.op, h2.op\n    apply Concrete.multiequalizer_ext\n    intro i\n    apply_fun fun ee => ee i at e\n    convert e\n    all_goals\n      dsimp\n      erw [‚Üê CategoryTheory.comp_apply, Multiequalizer.lift_Œπ]\n      erw [Meq.equiv_symm_eq_apply]\n      cases i; rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å¥ : CategoryTheory.HasForget D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : (CategoryTheory.forget D).obj ((J.plusObj P).obj { unop := X })\nh : ‚àÄ (I : S.Arrow), Eq (((J.plusObj P).map I.f.op) x) (((J.plusObj P).map I.f.op) y)\n‚ä¢ Eq x y","decl":"/-- `P‚Å∫` is always separated. -/\ntheorem sep {X : C} (P : C·µí·µñ ‚•§ D) (S : J.Cover X) (x y : (J.plusObj P).obj (op X))\n    (h : ‚àÄ I : S.Arrow, (J.plusObj P).map I.f.op x = (J.plusObj P).map I.f.op y) : x = y := by\n  -- First, we choose representatives for x and y.\n  obtain ‚ü®Sx, x, rfl‚ü© := exists_rep x\n  obtain ‚ü®Sy, y, rfl‚ü© := exists_rep y\n  simp only [res_mk_eq_mk_pullback] at h\n  -- Next, using our assumption,\n  -- choose covers over which the pullbacks of these representatives become equal.\n  choose W h1 h2 hh using fun I : S.Arrow => (eq_mk_iff_exists _ _).mp (h I)\n  -- To prove equality, it suffices to prove that there exists a cover over which\n  -- the representatives become equal.\n  rw [eq_mk_iff_exists]\n  -- Construct the cover over which the representatives become equal by combining the various\n  -- covers chosen above.\n  let B : J.Cover X := S.bind W\n  use B\n  -- Prove that this cover refines the two covers over which our representatives are defined\n  -- and use these proofs.\n  let ex : B ‚ü∂ Sx :=\n    homOfLE\n      (by\n        rintro Y f ‚ü®Z, e1, e2, he2, he1, hee‚ü©\n        rw [‚Üê hee]\n        apply leOfHom (h1 ‚ü®_, _, he2‚ü©)\n        exact he1)\n  let ey : B ‚ü∂ Sy :=\n    homOfLE\n      (by\n        rintro Y f ‚ü®Z, e1, e2, he2, he1, hee‚ü©\n        rw [‚Üê hee]\n        apply leOfHom (h2 ‚ü®_, _, he2‚ü©)\n        exact he1)\n  use ex, ey\n  -- Now prove that indeed the representatives become equal over `B`.\n  -- This will follow by using the fact that our representatives become\n  -- equal over the chosen covers.\n  ext1 I\n  let IS : S.Arrow := I.fromMiddle\n  specialize hh IS\n  let IW : (W IS).Arrow := I.toMiddle\n  apply_fun fun e => e IW at hh\n  convert hh using 1\n  ¬∑ exact x.congr_apply I.middle_spec.symm _\n  ¬∑ exact y.congr_apply I.middle_spec.symm _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.inj_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å¥ : CategoryTheory.HasForget D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ‚àÄ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (‚àÄ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) ‚Üí Eq x y\nX : C\n‚ä¢ Function.Injective ‚áë((J.toPlus P).app { unop := X })","decl":"theorem inj_of_sep (P : C·µí·µñ ‚•§ D)\n    (hsep :\n      ‚àÄ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (‚àÄ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) ‚Üí x = y)\n    (X : C) : Function.Injective ((J.toPlus P).app (op X)) := by\n  intro x y h\n  simp only [toPlus_eq_mk] at h\n  rw [eq_mk_iff_exists] at h\n  obtain ‚ü®W, h1, h2, hh‚ü© := h\n  apply hsep X W\n  intro I\n  apply_fun fun e => e I at hh\n  exact hh\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.exists_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å¥ : CategoryTheory.HasForget D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ‚àÄ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (‚àÄ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) ‚Üí Eq x y\nX : C\nS : J.Cover X\ns : CategoryTheory.Meq (J.plusObj P) S\n‚ä¢ Exists fun t => Eq (CategoryTheory.Meq.mk S t) s","decl":"theorem exists_of_sep (P : C·µí·µñ ‚•§ D)\n    (hsep :\n      ‚àÄ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (‚àÄ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) ‚Üí x = y)\n    (X : C) (S : J.Cover X) (s : Meq (J.plusObj P) S) :\n    ‚àÉ t : (J.plusObj P).obj (op X), Meq.mk S t = s := by\n  have inj : ‚àÄ X : C, Function.Injective ((J.toPlus P).app (op X)) := inj_of_sep _ hsep\n  -- Choose representatives for the given local sections.\n  choose T t ht using fun I => exists_rep (s I)\n  -- Construct a large cover over which we will define a representative that will\n  -- provide the gluing of the given local sections.\n  let B : J.Cover X := S.bind T\n  choose Z e1 e2 he2 _ _ using fun I : B.Arrow => I.hf\n  -- Construct a compatible system of local sections over this large cover, using the chosen\n  -- representatives of our local sections.\n  -- The compatibility here follows from the separatedness assumption.\n  let w : Meq P B := meqOfSep P hsep X S s T t ht\n  -- The associated gluing will be the candidate section.\n  use mk w\n  ext I\n  dsimp [Meq.mk]\n  rw [ht, res_mk_eq_mk_pullback]\n  -- Use the separatedness of `P‚Å∫` to prove that this is indeed a gluing of our\n  -- original local sections.\n  apply sep P (T I)\n  intro II\n  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]\n  -- It suffices to prove equality for representatives over a\n  -- convenient sufficiently large cover...\n  use (J.pullback II.f).obj (T I)\n  let e0 : (J.pullback II.f).obj (T I) ‚ü∂ (J.pullback II.f).obj ((J.pullback I.f).obj B) :=\n    homOfLE\n      (by\n        intro Y f hf\n        apply Sieve.le_pullback_bind _ _ _ I.hf\n        ¬∑ cases I\n          exact hf)\n  use e0, ùüô _\n  ext IV\n  let IA : B.Arrow := ‚ü®_, (IV.f ‚â´ II.f) ‚â´ I.f,\n    ‚ü®I.Y, _, _, I.hf, Sieve.downward_closed _ II.hf _, rfl‚ü©‚ü©\n  let IB : S.Arrow := IA.fromMiddle\n  let IC : (T IB).Arrow := IA.toMiddle\n  let ID : (T I).Arrow := ‚ü®IV.Y, IV.f ‚â´ II.f, Sieve.downward_closed (T I).1 II.hf IV.f‚ü©\n  change t IB IC = t I ID\n  apply inj IV.Y\n  erw [toPlus_apply (T I) (t I) ID, toPlus_apply (T IB) (t IB) IC, ‚Üê ht, ‚Üê ht]\n  -- Conclude by constructing the relation showing equality...\n  let IR : S.Relation := Cover.Relation.mk { hf := IB.hf } { hf := I.hf } { w := IA.middle_spec }\n  exact s.condition IR\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬≤ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ‚àÄ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (‚àÄ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) ‚Üí Eq x y\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (J.plusObj P)","decl":"/-- If `P` is separated, then `P‚Å∫` is a sheaf. -/\ntheorem isSheaf_of_sep (P : C·µí·µñ ‚•§ D)\n    (hsep :\n      ‚àÄ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (‚àÄ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) ‚Üí x = y) :\n    Presheaf.IsSheaf J (J.plusObj P) := by\n  rw [Presheaf.isSheaf_iff_multiequalizer]\n  intro X S\n  apply @isIso_of_reflects_iso _ _ _ _ _ _ _ (forget D) ?_\n  rw [isIso_iff_bijective]\n  constructor\n  ¬∑ intro x y h\n    apply sep P S _ _\n    intro I\n    apply_fun Meq.equiv _ _ at h\n    apply_fun fun e => e I at h\n    convert h <;> erw [Meq.equiv_apply, ‚Üê CategoryTheory.comp_apply, Multiequalizer.lift_Œπ] <;> rfl\n  ¬∑ rintro (x : (multiequalizer (S.index _) : D))\n    obtain ‚ü®t, ht‚ü© := exists_of_sep P hsep X S (Meq.equiv _ _ x)\n    use t\n    apply (Meq.equiv _ _).injective\n    rw [‚Üê ht]\n    ext i\n    dsimp\n    erw [‚Üê CategoryTheory.comp_apply]\n    rw [Multiequalizer.lift_Œπ]\n    rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plus","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬≤ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (J.plusObj (J.plusObj P))","decl":"/-- `P‚Å∫‚Å∫` is always a sheaf. -/\ntheorem isSheaf_plus_plus (P : C·µí·µñ ‚•§ D) : Presheaf.IsSheaf J (J.plusObj (J.plusObj P)) := by\n  apply isSheaf_of_sep\n  intro X S x y\n  apply sep\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_id","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (J.sheafifyMap (CategoryTheory.CategoryStruct.id P)) (CategoryTheory.CategoryStruct.id (J.sheafify P))","decl":"@[simp]\ntheorem sheafifyMap_id (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) := by\n  dsimp [sheafifyMap, sheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_comp","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\n‚ä¢ Eq (J.sheafifyMap (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥)) (CategoryTheory.CategoryStruct.comp (J.sheafifyMap Œ∑) (J.sheafifyMap Œ≥))","decl":"@[simp]\ntheorem sheafifyMap_comp {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R) :\n    J.sheafifyMap (Œ∑ ‚â´ Œ≥) = J.sheafifyMap Œ∑ ‚â´ J.sheafifyMap Œ≥ := by\n  dsimp [sheafifyMap, sheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_naturality","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ∑ (J.toSheafify Q)) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (J.sheafifyMap Œ∑))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :\n    Œ∑ ‚â´ J.toSheafify _ = J.toSheafify _ ‚â´ J.sheafifyMap Œ∑ := by\n  dsimp [sheafifyMap, sheafify, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_naturality_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (J.sheafify Q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ∑ (CategoryTheory.CategoryStruct.comp (J.toSheafify Q) h)) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.CategoryStruct.comp (J.sheafifyMap Œ∑) h))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :\n    Œ∑ ‚â´ J.toSheafify _ = J.toSheafify _ ‚â´ J.sheafifyMap Œ∑ := by\n  dsimp [sheafifyMap, sheafify, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafification_obj","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((J.sheafification D).obj P) (J.sheafify P)","decl":"@[simp]\ntheorem sheafification_obj (P : C·µí·µñ ‚•§ D) : (J.sheafification D).obj P = J.sheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafification_map","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\n‚ä¢ Eq ((J.sheafification D).map Œ∑) (J.sheafifyMap Œ∑)","decl":"@[simp]\ntheorem sheafification_map {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :\n    (J.sheafification D).map Œ∑ = J.sheafifyMap Œ∑ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafification_app","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((J.toSheafification D).app P) (J.toSheafify P)","decl":"@[simp]\ntheorem toSheafification_app (P : C·µí·µñ ‚•§ D) :\n    (J.toSheafification D).app P = J.toSheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isIso_toSheafify","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ CategoryTheory.IsIso (J.toSheafify P)","decl":"theorem isIso_toSheafify {P : C·µí·µñ ‚•§ D} (hP : Presheaf.IsSheaf J P) : IsIso (J.toSheafify P) := by\n  dsimp [toSheafify]\n  haveI := isIso_toPlus_of_isSheaf J P hP\n  change (IsIso (toPlus J P ‚â´ (J.plusFunctor D).map (toPlus J P)))\n  infer_instance\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoSheafify_hom","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ Eq (J.isoSheafify hP).hom (J.toSheafify P)","decl":"@[simp]\ntheorem isoSheafify_hom {P : C·µí·µñ ‚•§ D} (hP : Presheaf.IsSheaf J P) :\n    (J.isoSheafify hP).hom = J.toSheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (J.sheafifyLift Œ∑ hQ)) Œ∑","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toSheafify P ‚â´ sheafifyLift J Œ∑ hQ = Œ∑ := by\n  dsimp only [sheafifyLift, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom Q Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift Œ∑ hQ) h)) (CategoryTheory.CategoryStruct.comp Œ∑ h)","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toSheafify P ‚â´ sheafifyLift J Œ∑ hQ = Œ∑ := by\n  dsimp only [sheafifyLift, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyLift_unique","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nŒ≥ : Quiver.Hom (J.sheafify P) Q\na‚úù : Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) Œ≥) Œ∑\n‚ä¢ Eq Œ≥ (J.sheafifyLift Œ∑ hQ)","decl":"theorem sheafifyLift_unique {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q)\n    (Œ≥ : J.sheafify P ‚ü∂ Q) : J.toSheafify P ‚â´ Œ≥ = Œ∑ ‚Üí Œ≥ = sheafifyLift J Œ∑ hQ := by\n  intro h\n  apply plusLift_unique\n  apply plusLift_unique\n  rw [‚Üê Category.assoc, ‚Üê plusMap_toPlus]\n  exact h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoSheafify_inv","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ Eq (J.isoSheafify hP).inv (J.sheafifyLift (CategoryTheory.CategoryStruct.id P) hP)","decl":"@[simp]\ntheorem isoSheafify_inv {P : C·µí·µñ ‚•§ D} (hP : Presheaf.IsSheaf J P) :\n    (J.isoSheafify hP).inv = J.sheafifyLift (ùüô _) hP := by\n  apply J.sheafifyLift_unique\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafify_hom_ext","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ Œ≥ : Quiver.Hom (J.sheafify P) Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nh : Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) Œ∑) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) Œ≥)\n‚ä¢ Eq Œ∑ Œ≥","decl":"theorem sheafify_hom_ext {P Q : C·µí·µñ ‚•§ D} (Œ∑ Œ≥ : J.sheafify P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q)\n    (h : J.toSheafify P ‚â´ Œ∑ = J.toSheafify P ‚â´ Œ≥) : Œ∑ = Œ≥ := by\n  apply J.plus_hom_ext _ _ hQ\n  apply J.plus_hom_ext _ _ hQ\n  rw [‚Üê Category.assoc, ‚Üê Category.assoc, ‚Üê plusMap_toPlus]\n  exact h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom R Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.sheafifyMap Œ∑) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift Œ≥ hR) h)) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥) hR) h)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R)\n    (hR : Presheaf.IsSheaf J R) :\n    J.sheafifyMap Œ∑ ‚â´ J.sheafifyLift Œ≥ hR = J.sheafifyLift (Œ∑ ‚â´ Œ≥) hR := by\n  apply J.sheafifyLift_unique\n  rw [‚Üê Category.assoc, ‚Üê J.toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.sheafifyMap Œ∑) (J.sheafifyLift Œ≥ hR)) (J.sheafifyLift (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥) hR)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R)\n    (hR : Presheaf.IsSheaf J R) :\n    J.sheafifyMap Œ∑ ‚â´ J.sheafifyLift Œ≥ hR = J.sheafifyLift (Œ∑ ‚â´ Œ≥) hR := by\n  apply J.sheafifyLift_unique\n  rw [‚Üê Category.assoc, ‚Üê J.toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafify_isSheaf","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (J.sheafify P)","decl":"theorem GrothendieckTopology.sheafify_isSheaf (P : C·µí·µñ ‚•§ D) : Presheaf.IsSheaf J (J.sheafify P) :=\n  GrothendieckTopology.Plus.isSheaf_plus_plus _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_map_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.plusPlusSheaf J D).map Œ∑).val (J.sheafifyMap Œ∑)","decl":"/-- The sheafification functor, as a functor taking values in `Sheaf`. -/\n@[simps]\nnoncomputable def plusPlusSheaf : (C·µí·µñ ‚•§ D) ‚•§ Sheaf J D where\n  obj P := ‚ü®J.sheafify P, J.sheafify_isSheaf P‚ü©\n  map Œ∑ := ‚ü®J.sheafifyMap Œ∑‚ü©\n  map_id _ := Sheaf.Hom.ext <| J.sheafifyMap_id _\n  map_comp _ _ := Sheaf.Hom.ext <| J.sheafifyMap_comp _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_obj_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((CategoryTheory.plusPlusSheaf J D).obj P).val (J.sheafify P)","decl":"/-- The sheafification functor, as a functor taking values in `Sheaf`. -/\n@[simps]\nnoncomputable def plusPlusSheaf : (C·µí·µñ ‚•§ D) ‚•§ Sheaf J D where\n  obj P := ‚ü®J.sheafify P, J.sheafify_isSheaf P‚ü©\n  map Œ∑ := ‚ü®J.sheafifyMap Œ∑‚ü©\n  map_id _ := Sheaf.Hom.ext <| J.sheafifyMap_id _\n  map_comp _ _ := Sheaf.Hom.ext <| J.sheafifyMap_comp _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∑ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å∂ : CategoryTheory.HasForget D\ninst‚úù‚Åµ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù‚Å¥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≥ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù¬π : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst‚úù : CategoryTheory.Preadditive D\n‚ä¢ (CategoryTheory.plusPlusSheaf J D).PreservesZeroMorphisms","decl":"instance plusPlusSheaf_preservesZeroMorphisms [Preadditive D] :\n    (plusPlusSheaf J D).PreservesZeroMorphisms where\n  map_zero F G := by\n    ext : 3\n    refine colimit.hom_ext (fun j => ?_)\n    erw [colimit.Œπ_map, comp_zero, J.plusMap_zero, J.diagramNatTrans_zero, zero_comp]\n\n"}
{"name":"CategoryTheory.plusPlusAdjunction_counit_app_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nY : CategoryTheory.Sheaf J D\n‚ä¢ Eq ((CategoryTheory.plusPlusAdjunction J D).counit.app Y).val (J.sheafifyLift (CategoryTheory.CategoryStruct.id Y.val) ‚ãØ)","decl":"/-- The sheafification functor is left adjoint to the forgetful functor. -/\n@[simps! unit_app counit_app_val]\nnoncomputable def plusPlusAdjunction : plusPlusSheaf J D ‚ä£ sheafToPresheaf J D :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun P Q =>\n        { toFun := fun e => J.toSheafify P ‚â´ e.val\n          invFun := fun e => ‚ü®J.sheafifyLift e Q.2‚ü©\n          left_inv := fun _ => Sheaf.Hom.ext <| (J.sheafifyLift_unique _ _ _ rfl).symm\n          right_inv := fun _ => J.toSheafify_sheafifyLift _ _ }\n      homEquiv_naturality_left_symm := by\n        intro P Q R Œ∑ Œ≥; ext1; dsimp; symm\n        apply J.sheafifyMap_sheafifyLift\n      homEquiv_naturality_right := fun Œ∑ Œ≥ => by\n        dsimp\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.plusPlusAdjunction_unit_app","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nX : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((CategoryTheory.plusPlusAdjunction J D).unit.app X) (J.toSheafify X)","decl":"/-- The sheafification functor is left adjoint to the forgetful functor. -/\n@[simps! unit_app counit_app_val]\nnoncomputable def plusPlusAdjunction : plusPlusSheaf J D ‚ä£ sheafToPresheaf J D :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun P Q =>\n        { toFun := fun e => J.toSheafify P ‚â´ e.val\n          invFun := fun e => ‚ü®J.sheafifyLift e Q.2‚ü©\n          left_inv := fun _ => Sheaf.Hom.ext <| (J.sheafifyLift_unique _ _ _ rfl).symm\n          right_inv := fun _ => J.toSheafify_sheafifyLift _ _ }\n      homEquiv_naturality_left_symm := by\n        intro P Q R Œ∑ Œ≥; ext1; dsimp; symm\n        apply J.sheafifyMap_sheafifyLift\n      homEquiv_naturality_right := fun Œ∑ Œ≥ => by\n        dsimp\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_isRightAdjoint","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\n‚ä¢ (CategoryTheory.sheafToPresheaf J D).IsRightAdjoint","decl":"instance sheafToPresheaf_isRightAdjoint : (sheafToPresheaf J D).IsRightAdjoint  :=\n  (plusPlusAdjunction J D).isRightAdjoint\n\n"}
{"name":"CategoryTheory.presheaf_mono_of_mono","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∑ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Å∂ : CategoryTheory.HasForget D\ninst‚úù‚Åµ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù‚Å¥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≥ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù¬π : (CategoryTheory.forget D).ReflectsIsomorphisms\nF G : CategoryTheory.Sheaf J D\nf : Quiver.Hom F G\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono f.val","decl":"instance presheaf_mono_of_mono {F G : Sheaf J D} (f : F ‚ü∂ G) [Mono f] : Mono f.1 :=\n  (sheafToPresheaf J D).map_mono _\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mono_iff_presheaf_mono","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù‚Å∂ : CategoryTheory.Category.{max v u, w} D\ninst‚úù‚Åµ : CategoryTheory.HasForget D\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst‚úù¬≥ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬≤ : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst‚úù : (CategoryTheory.forget D).ReflectsIsomorphisms\nF G : CategoryTheory.Sheaf J D\nf : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.Mono f) (CategoryTheory.Mono f.val)","decl":"theorem Sheaf.Hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : F ‚ü∂ G) : Mono f ‚Üî Mono f.1 :=\n  ‚ü®fun m => by infer_instance, fun m => by exact Sheaf.Hom.mono_of_presheaf_mono J D f‚ü©\n\n"}
