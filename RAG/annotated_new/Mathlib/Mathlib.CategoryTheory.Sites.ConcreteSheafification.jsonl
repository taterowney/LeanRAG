{"name":"CategoryTheory.Meq.congr_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nY : C\nf g : Quiver.Hom Y X\nh : Eq f g\nhf : (↑S).arrows f\n⊢ Eq (↑x { Y := Y, f := f, hf := hf }) (↑x { Y := Y, f := g, hf := ⋯ })","decl":"lemma congr_apply {X} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x : Meq P S) {Y}\n    {f g : Y ⟶ X} (h : f = g) (hf : S f) :\n    x ⟨_, _, hf⟩ = x ⟨_, g, by simpa only [← h] using hf⟩ := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.ext","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : CategoryTheory.Meq P S\nh : ∀ (I : S.Arrow), Eq (↑x I) (↑y I)\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {X} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x y : Meq P S) (h : ∀ I : S.Arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n\n"}
{"name":"CategoryTheory.Meq.ext_iff","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : CategoryTheory.Meq P S\n⊢ Iff (Eq x y) (∀ (I : S.Arrow), Eq (↑x I) (↑y I))","decl":"@[ext]\ntheorem ext {X} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x y : Meq P S) (h : ∀ I : S.Arrow, x I = y I) :\n    x = y :=\n  Subtype.ext <| funext <| h\n\n"}
{"name":"CategoryTheory.Meq.condition","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nI : S.Relation\n⊢ Eq ((P.map I.r.g₁.op) (↑x ((S.index P).fstTo I))) ((P.map I.r.g₂.op) (↑x ((S.index P).sndTo I)))","decl":"theorem condition {X} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x : Meq P S) (I : S.Relation) :\n    P.map I.r.g₁.op (x ((S.index P).fstTo I)) = P.map I.r.g₂.op (x ((S.index P).sndTo I)) :=\n  x.2 _\n\n"}
{"name":"CategoryTheory.Meq.refine_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nx : CategoryTheory.Meq P T\ne : Quiver.Hom S T\nI : S.Arrow\n⊢ Eq (↑(x.refine e) I) (↑x { Y := I.Y, f := I.f, hf := ⋯ })","decl":"@[simp]\ntheorem refine_apply {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.Cover X} (x : Meq P T) (e : S ⟶ T)\n    (I : S.Arrow) : x.refine e I = x ⟨I.Y, I.f, (leOfHom e) _ I.hf⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.pullback_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nf : Quiver.Hom Y X\nI : ((J.pullback f).obj S).Arrow\n⊢ Eq (↑(x.pullback f) I) (↑x { Y := I.Y, f := CategoryTheory.CategoryStruct.comp I.f f, hf := ⋯ })","decl":"@[simp]\ntheorem pullback_apply {Y X : C} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x : Meq P S) (f : Y ⟶ X)\n    (I : ((J.pullback f).obj S).Arrow) : x.pullback f I = x ⟨_, I.f ≫ f, I.hf⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.pullback_refine","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nh : Quiver.Hom S T\nf : Quiver.Hom Y X\nx : CategoryTheory.Meq P T\n⊢ Eq ((x.pullback f).refine ((J.pullback f).map h)) ((x.refine h).pullback f)","decl":"@[simp]\ntheorem pullback_refine {Y X : C} {P : Cᵒᵖ ⥤ D} {S T : J.Cover X} (h : S ⟶ T) (f : Y ⟶ X)\n    (x : Meq P T) : (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.mk_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝¹ : CategoryTheory.Category.{max v u, w} D\ninst✝ : CategoryTheory.HasForget D\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\nI : S.Arrow\n⊢ Eq (↑(CategoryTheory.Meq.mk S x) I) ((P.map I.f.op) x)","decl":"theorem mk_apply {X : C} {P : Cᵒᵖ ⥤ D} (S : J.Cover X) (x : P.obj (op X)) (I : S.Arrow) :\n    mk S x I = P.map I.f.op x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.equiv_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\ninst✝ : CategoryTheory.Limits.HasMultiequalizer (S.index P)\nx : (CategoryTheory.forget D).obj (CategoryTheory.Limits.multiequalizer (S.index P))\nI : S.Arrow\n⊢ Eq (↑((CategoryTheory.Meq.equiv P S) x) I) ((CategoryTheory.Limits.Multiequalizer.ι (S.index P) I) x)","decl":"@[simp]\ntheorem equiv_apply {X : C} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} [HasMultiequalizer (S.index P)]\n    (x : (multiequalizer (S.index P) : D)) (I : S.Arrow) :\n    equiv P S x I = Multiequalizer.ι (S.index P) I x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Meq.equiv_symm_eq_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\ninst✝ : CategoryTheory.Limits.HasMultiequalizer (S.index P)\nx : CategoryTheory.Meq P S\nI : S.Arrow\n⊢ Eq ((CategoryTheory.Limits.Multiequalizer.ι (S.index P) I) ((CategoryTheory.Meq.equiv P S).symm x)) (↑x I)","decl":"theorem equiv_symm_eq_apply {X : C} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} [HasMultiequalizer (S.index P)]\n    (x : Meq P S) (I : S.Arrow) :\n    Multiequalizer.ι (S.index P) I ((Meq.equiv P S).symm x) = x I := by\n  rw [← equiv_apply]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullback","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁴ : CategoryTheory.Category.{max v u, w} D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nY X : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nf : Quiver.Hom Y X\n⊢ Eq (((J.plusObj P).map f.op) (CategoryTheory.GrothendieckTopology.Plus.mk x)) (CategoryTheory.GrothendieckTopology.Plus.mk (x.pullback f))","decl":"theorem res_mk_eq_mk_pullback {Y X : C} {P : Cᵒᵖ ⥤ D} {S : J.Cover X} (x : Meq P S) (f : Y ⟶ X) :\n    (J.plusObj P).map f.op (mk x) = mk (x.pullback f) := by\n  dsimp [mk, plusObj]\n  rw [← comp_apply (x := (Meq.equiv P S).symm x), ι_colimMap_assoc, colimit.ι_pre,\n    comp_apply (x := (Meq.equiv P S).symm x)]\n  apply congr_arg\n  apply (Meq.equiv P _).injective\n  erw [Equiv.apply_symm_apply]\n  ext i\n  simp only [Functor.op_obj, unop_op, pullback_obj, diagram_obj, Functor.comp_obj,\n    diagramPullback_app, Meq.equiv_apply, Meq.pullback_apply]\n  rw [← CategoryTheory.comp_apply, Multiequalizer.lift_ι]\n  erw [Meq.equiv_symm_eq_apply]\n  cases i; rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_mk","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁴ : CategoryTheory.Category.{max v u, w} D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\n⊢ Eq (((J.toPlus P).app { unop := X }) x) (CategoryTheory.GrothendieckTopology.Plus.mk (CategoryTheory.Meq.mk S x))","decl":"theorem toPlus_mk {X : C} {P : Cᵒᵖ ⥤ D} (S : J.Cover X) (x : P.obj (op X)) :\n    (J.toPlus P).app _ x = mk (Meq.mk S x) := by\n  dsimp [mk, toPlus]\n  let e : S ⟶ ⊤ := homOfLE (OrderTop.le_top _)\n  rw [← colimit.w _ e.op]\n  delta Cover.toMultiequalizer\n  rw [CategoryTheory.comp_apply]\n  erw [CategoryTheory.comp_apply]\n  apply congr_arg\n  dsimp [diagram]\n  apply Concrete.multiequalizer_ext\n  intro i\n  simp only [← CategoryTheory.comp_apply, Category.assoc, Multiequalizer.lift_ι, Category.comp_id,\n    Meq.equiv_symm_eq_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_apply","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁴ : CategoryTheory.Category.{max v u, w} D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx : CategoryTheory.Meq P S\nI : S.Arrow\n⊢ Eq (((J.toPlus P).app { unop := I.Y }) (↑x I)) (((J.plusObj P).map I.f.op) (CategoryTheory.GrothendieckTopology.Plus.mk x))","decl":"theorem toPlus_apply {X : C} {P : Cᵒᵖ ⥤ D} (S : J.Cover X) (x : Meq P S) (I : S.Arrow) :\n    (J.toPlus P).app _ (x I) = (J.plusObj P).map I.f.op (mk x) := by\n  dsimp only [toPlus, plusObj]\n  delta Cover.toMultiequalizer\n  dsimp [mk]\n  erw [← CategoryTheory.comp_apply]\n  rw [ι_colimMap_assoc, colimit.ι_pre, CategoryTheory.comp_apply, CategoryTheory.comp_apply]\n  dsimp only [Functor.op]\n  let e : (J.pullback I.f).obj (unop (op S)) ⟶ ⊤ := homOfLE (OrderTop.le_top _)\n  rw [← colimit.w _ e.op]\n  erw [CategoryTheory.comp_apply]\n  apply congr_arg\n  apply Concrete.multiequalizer_ext\n  intro i\n  dsimp\n  erw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply]\n  rw [Multiequalizer.lift_ι, Multiequalizer.lift_ι, Multiequalizer.lift_ι]\n  erw [Meq.equiv_symm_eq_apply]\n  simpa using (x.condition (Cover.Relation.mk' (I.precompRelation i.f))).symm\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.toPlus_eq_mk","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁴ : CategoryTheory.Category.{max v u, w} D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nx : (CategoryTheory.forget D).obj (P.obj { unop := X })\n⊢ Eq (((J.toPlus P).app { unop := X }) x) (CategoryTheory.GrothendieckTopology.Plus.mk (CategoryTheory.Meq.mk Top.top x))","decl":"theorem toPlus_eq_mk {X : C} {P : Cᵒᵖ ⥤ D} (x : P.obj (op X)) :\n    (J.toPlus P).app _ x = mk (Meq.mk ⊤ x) := by\n  dsimp [mk, toPlus]\n  delta Cover.toMultiequalizer\n  simp only [CategoryTheory.comp_apply]\n  apply congr_arg\n  apply (Meq.equiv P ⊤).injective\n  ext i\n  rw [Meq.equiv_apply, Equiv.apply_symm_apply, ← CategoryTheory.comp_apply, Multiequalizer.lift_ι]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.exists_rep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁵ : CategoryTheory.Category.{max v u, w} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nx : (CategoryTheory.forget D).obj ((J.plusObj P).obj { unop := X })\n⊢ Exists fun S => Exists fun y => Eq x (CategoryTheory.GrothendieckTopology.Plus.mk y)","decl":"theorem exists_rep {X : C} {P : Cᵒᵖ ⥤ D} (x : (J.plusObj P).obj (op X)) :\n    ∃ (S : J.Cover X) (y : Meq P S), x = mk y := by\n  obtain ⟨S, y, h⟩ := Concrete.colimit_exists_rep (J.diagram P X) x\n  use S.unop, Meq.equiv _ _ y\n  rw [← h]\n  dsimp [mk]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.eq_mk_iff_exists","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁵ : CategoryTheory.Category.{max v u, w} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS T : J.Cover X\nx : CategoryTheory.Meq P S\ny : CategoryTheory.Meq P T\n⊢ Iff (Eq (CategoryTheory.GrothendieckTopology.Plus.mk x) (CategoryTheory.GrothendieckTopology.Plus.mk y)) (Exists fun W => Exists fun h1 => Exists fun h2 => Eq (x.refine h1) (y.refine h2))","decl":"theorem eq_mk_iff_exists {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.Cover X} (x : Meq P S) (y : Meq P T) :\n    mk x = mk y ↔ ∃ (W : J.Cover X) (h1 : W ⟶ S) (h2 : W ⟶ T), x.refine h1 = y.refine h2 := by\n  constructor\n  · intro h\n    obtain ⟨W, h1, h2, hh⟩ := Concrete.colimit_exists_of_rep_eq.{u} _ _ _ h\n    use W.unop, h1.unop, h2.unop\n    ext I\n    apply_fun Multiequalizer.ι (W.unop.index P) I at hh\n    convert hh\n    all_goals\n      dsimp [diagram]\n      erw [← CategoryTheory.comp_apply, Multiequalizer.lift_ι, Meq.equiv_symm_eq_apply]\n      cases I; rfl\n  · rintro ⟨S, h1, h2, e⟩\n    apply Concrete.colimit_rep_eq_of_exists\n    use op S, h1.op, h2.op\n    apply Concrete.multiequalizer_ext\n    intro i\n    apply_fun fun ee => ee i at e\n    convert e\n    all_goals\n      dsimp\n      erw [← CategoryTheory.comp_apply, Multiequalizer.lift_ι]\n      erw [Meq.equiv_symm_eq_apply]\n      cases i; rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁵ : CategoryTheory.Category.{max v u, w} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\nS : J.Cover X\nx y : (CategoryTheory.forget D).obj ((J.plusObj P).obj { unop := X })\nh : ∀ (I : S.Arrow), Eq (((J.plusObj P).map I.f.op) x) (((J.plusObj P).map I.f.op) y)\n⊢ Eq x y","decl":"/-- `P⁺` is always separated. -/\ntheorem sep {X : C} (P : Cᵒᵖ ⥤ D) (S : J.Cover X) (x y : (J.plusObj P).obj (op X))\n    (h : ∀ I : S.Arrow, (J.plusObj P).map I.f.op x = (J.plusObj P).map I.f.op y) : x = y := by\n  -- First, we choose representatives for x and y.\n  obtain ⟨Sx, x, rfl⟩ := exists_rep x\n  obtain ⟨Sy, y, rfl⟩ := exists_rep y\n  simp only [res_mk_eq_mk_pullback] at h\n  -- Next, using our assumption,\n  -- choose covers over which the pullbacks of these representatives become equal.\n  choose W h1 h2 hh using fun I : S.Arrow => (eq_mk_iff_exists _ _).mp (h I)\n  -- To prove equality, it suffices to prove that there exists a cover over which\n  -- the representatives become equal.\n  rw [eq_mk_iff_exists]\n  -- Construct the cover over which the representatives become equal by combining the various\n  -- covers chosen above.\n  let B : J.Cover X := S.bind W\n  use B\n  -- Prove that this cover refines the two covers over which our representatives are defined\n  -- and use these proofs.\n  let ex : B ⟶ Sx :=\n    homOfLE\n      (by\n        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩\n        rw [← hee]\n        apply leOfHom (h1 ⟨_, _, he2⟩)\n        exact he1)\n  let ey : B ⟶ Sy :=\n    homOfLE\n      (by\n        rintro Y f ⟨Z, e1, e2, he2, he1, hee⟩\n        rw [← hee]\n        apply leOfHom (h2 ⟨_, _, he2⟩)\n        exact he1)\n  use ex, ey\n  -- Now prove that indeed the representatives become equal over `B`.\n  -- This will follow by using the fact that our representatives become\n  -- equal over the chosen covers.\n  ext1 I\n  let IS : S.Arrow := I.fromMiddle\n  specialize hh IS\n  let IW : (W IS).Arrow := I.toMiddle\n  apply_fun fun e => e IW at hh\n  convert hh using 1\n  · exact x.congr_apply I.middle_spec.symm _\n  · exact y.congr_apply I.middle_spec.symm _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.inj_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁵ : CategoryTheory.Category.{max v u, w} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ∀ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (∀ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) → Eq x y\nX : C\n⊢ Function.Injective ⇑((J.toPlus P).app { unop := X })","decl":"theorem inj_of_sep (P : Cᵒᵖ ⥤ D)\n    (hsep :\n      ∀ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (∀ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) → x = y)\n    (X : C) : Function.Injective ((J.toPlus P).app (op X)) := by\n  intro x y h\n  simp only [toPlus_eq_mk] at h\n  rw [eq_mk_iff_exists] at h\n  obtain ⟨W, h1, h2, hh⟩ := h\n  apply hsep X W\n  intro I\n  apply_fun fun e => e I at hh\n  exact hh\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.exists_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁵ : CategoryTheory.Category.{max v u, w} D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ∀ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (∀ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) → Eq x y\nX : C\nS : J.Cover X\ns : CategoryTheory.Meq (J.plusObj P) S\n⊢ Exists fun t => Eq (CategoryTheory.Meq.mk S t) s","decl":"theorem exists_of_sep (P : Cᵒᵖ ⥤ D)\n    (hsep :\n      ∀ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (∀ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) → x = y)\n    (X : C) (S : J.Cover X) (s : Meq (J.plusObj P) S) :\n    ∃ t : (J.plusObj P).obj (op X), Meq.mk S t = s := by\n  have inj : ∀ X : C, Function.Injective ((J.toPlus P).app (op X)) := inj_of_sep _ hsep\n  -- Choose representatives for the given local sections.\n  choose T t ht using fun I => exists_rep (s I)\n  -- Construct a large cover over which we will define a representative that will\n  -- provide the gluing of the given local sections.\n  let B : J.Cover X := S.bind T\n  choose Z e1 e2 he2 _ _ using fun I : B.Arrow => I.hf\n  -- Construct a compatible system of local sections over this large cover, using the chosen\n  -- representatives of our local sections.\n  -- The compatibility here follows from the separatedness assumption.\n  let w : Meq P B := meqOfSep P hsep X S s T t ht\n  -- The associated gluing will be the candidate section.\n  use mk w\n  ext I\n  dsimp [Meq.mk]\n  rw [ht, res_mk_eq_mk_pullback]\n  -- Use the separatedness of `P⁺` to prove that this is indeed a gluing of our\n  -- original local sections.\n  apply sep P (T I)\n  intro II\n  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]\n  -- It suffices to prove equality for representatives over a\n  -- convenient sufficiently large cover...\n  use (J.pullback II.f).obj (T I)\n  let e0 : (J.pullback II.f).obj (T I) ⟶ (J.pullback II.f).obj ((J.pullback I.f).obj B) :=\n    homOfLE\n      (by\n        intro Y f hf\n        apply Sieve.le_pullback_bind _ _ _ I.hf\n        · cases I\n          exact hf)\n  use e0, 𝟙 _\n  ext IV\n  let IA : B.Arrow := ⟨_, (IV.f ≫ II.f) ≫ I.f,\n    ⟨I.Y, _, _, I.hf, Sieve.downward_closed _ II.hf _, rfl⟩⟩\n  let IB : S.Arrow := IA.fromMiddle\n  let IC : (T IB).Arrow := IA.toMiddle\n  let ID : (T I).Arrow := ⟨IV.Y, IV.f ≫ II.f, Sieve.downward_closed (T I).1 II.hf IV.f⟩\n  change t IB IC = t I ID\n  apply inj IV.Y\n  erw [toPlus_apply (T I) (t I) ID, toPlus_apply (T IB) (t IB) IC, ← ht, ← ht]\n  -- Conclude by constructing the relation showing equality...\n  let IR : S.Relation := Cover.Relation.mk { hf := IB.hf } { hf := I.hf } { w := IA.middle_spec }\n  exact s.condition IR\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sep","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\nhsep : ∀ (X : C) (S : J.Cover X) (x y : (CategoryTheory.forget D).obj (P.obj { unop := X })), (∀ (I : S.Arrow), Eq ((P.map I.f.op) x) ((P.map I.f.op) y)) → Eq x y\n⊢ CategoryTheory.Presheaf.IsSheaf J (J.plusObj P)","decl":"/-- If `P` is separated, then `P⁺` is a sheaf. -/\ntheorem isSheaf_of_sep (P : Cᵒᵖ ⥤ D)\n    (hsep :\n      ∀ (X : C) (S : J.Cover X) (x y : P.obj (op X)),\n        (∀ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) → x = y) :\n    Presheaf.IsSheaf J (J.plusObj P) := by\n  rw [Presheaf.isSheaf_iff_multiequalizer]\n  intro X S\n  apply @isIso_of_reflects_iso _ _ _ _ _ _ _ (forget D) ?_\n  rw [isIso_iff_bijective]\n  constructor\n  · intro x y h\n    apply sep P S _ _\n    intro I\n    apply_fun Meq.equiv _ _ at h\n    apply_fun fun e => e I at h\n    convert h <;> erw [Meq.equiv_apply, ← CategoryTheory.comp_apply, Multiequalizer.lift_ι] <;> rfl\n  · rintro (x : (multiequalizer (S.index _) : D))\n    obtain ⟨t, ht⟩ := exists_of_sep P hsep X S (Meq.equiv _ _ x)\n    use t\n    apply (Meq.equiv _ _).injective\n    rw [← ht]\n    ext i\n    dsimp\n    erw [← CategoryTheory.comp_apply]\n    rw [Multiequalizer.lift_ι]\n    rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plus","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ CategoryTheory.Presheaf.IsSheaf J (J.plusObj (J.plusObj P))","decl":"/-- `P⁺⁺` is always a sheaf. -/\ntheorem isSheaf_plus_plus (P : Cᵒᵖ ⥤ D) : Presheaf.IsSheaf J (J.plusObj (J.plusObj P)) := by\n  apply isSheaf_of_sep\n  intro X S x y\n  apply sep\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_id","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq (J.sheafifyMap (CategoryTheory.CategoryStruct.id P)) (CategoryTheory.CategoryStruct.id (J.sheafify P))","decl":"@[simp]\ntheorem sheafifyMap_id (P : Cᵒᵖ ⥤ D) : J.sheafifyMap (𝟙 P) = 𝟙 (J.sheafify P) := by\n  dsimp [sheafifyMap, sheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_comp","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\n⊢ Eq (J.sheafifyMap (CategoryTheory.CategoryStruct.comp η γ)) (CategoryTheory.CategoryStruct.comp (J.sheafifyMap η) (J.sheafifyMap γ))","decl":"@[simp]\ntheorem sheafifyMap_comp {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R) :\n    J.sheafifyMap (η ≫ γ) = J.sheafifyMap η ≫ J.sheafifyMap γ := by\n  dsimp [sheafifyMap, sheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_naturality","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp η (J.toSheafify Q)) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (J.sheafifyMap η))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    η ≫ J.toSheafify _ = J.toSheafify _ ≫ J.sheafifyMap η := by\n  dsimp [sheafifyMap, sheafify, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_naturality_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (J.sheafify Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp η (CategoryTheory.CategoryStruct.comp (J.toSheafify Q) h)) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.CategoryStruct.comp (J.sheafifyMap η) h))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    η ≫ J.toSheafify _ = J.toSheafify _ ≫ J.sheafifyMap η := by\n  dsimp [sheafifyMap, sheafify, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafification_obj","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((J.sheafification D).obj P) (J.sheafify P)","decl":"@[simp]\ntheorem sheafification_obj (P : Cᵒᵖ ⥤ D) : (J.sheafification D).obj P = J.sheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafification_map","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\n⊢ Eq ((J.sheafification D).map η) (J.sheafifyMap η)","decl":"@[simp]\ntheorem sheafification_map {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    (J.sheafification D).map η = J.sheafifyMap η :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafification_app","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((J.toSheafification D).app P) (J.toSheafify P)","decl":"@[simp]\ntheorem toSheafification_app (P : Cᵒᵖ ⥤ D) :\n    (J.toSheafification D).app P = J.toSheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isIso_toSheafify","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ CategoryTheory.IsIso (J.toSheafify P)","decl":"theorem isIso_toSheafify {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) : IsIso (J.toSheafify P) := by\n  dsimp [toSheafify]\n  haveI := isIso_toPlus_of_isSheaf J P hP\n  change (IsIso (toPlus J P ≫ (J.plusFunctor D).map (toPlus J P)))\n  infer_instance\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoSheafify_hom","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ Eq (J.isoSheafify hP).hom (J.toSheafify P)","decl":"@[simp]\ntheorem isoSheafify_hom {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :\n    (J.isoSheafify hP).hom = J.toSheafify P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (J.sheafifyLift η hQ)) η","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toSheafify P ≫ sheafifyLift J η hQ = η := by\n  dsimp only [sheafifyLift, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toSheafify_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift η hQ) h)) (CategoryTheory.CategoryStruct.comp η h)","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toSheafify P ≫ sheafifyLift J η hQ = η := by\n  dsimp only [sheafifyLift, toSheafify]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyLift_unique","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nγ : Quiver.Hom (J.sheafify P) Q\na✝ : Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) γ) η\n⊢ Eq γ (J.sheafifyLift η hQ)","decl":"theorem sheafifyLift_unique {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)\n    (γ : J.sheafify P ⟶ Q) : J.toSheafify P ≫ γ = η → γ = sheafifyLift J η hQ := by\n  intro h\n  apply plusLift_unique\n  apply plusLift_unique\n  rw [← Category.assoc, ← plusMap_toPlus]\n  exact h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoSheafify_inv","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ Eq (J.isoSheafify hP).inv (J.sheafifyLift (CategoryTheory.CategoryStruct.id P) hP)","decl":"@[simp]\ntheorem isoSheafify_inv {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :\n    (J.isoSheafify hP).inv = J.sheafifyLift (𝟙 _) hP := by\n  apply J.sheafifyLift_unique\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafify_hom_ext","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nη γ : Quiver.Hom (J.sheafify P) Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nh : Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) η) (CategoryTheory.CategoryStruct.comp (J.toSheafify P) γ)\n⊢ Eq η γ","decl":"theorem sheafify_hom_ext {P Q : Cᵒᵖ ⥤ D} (η γ : J.sheafify P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)\n    (h : J.toSheafify P ≫ η = J.toSheafify P ≫ γ) : η = γ := by\n  apply J.plus_hom_ext _ _ hQ\n  apply J.plus_hom_ext _ _ hQ\n  rw [← Category.assoc, ← Category.assoc, ← plusMap_toPlus]\n  exact h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.sheafifyMap η) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift γ hR) h)) (CategoryTheory.CategoryStruct.comp (J.sheafifyLift (CategoryTheory.CategoryStruct.comp η γ) hR) h)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R)\n    (hR : Presheaf.IsSheaf J R) :\n    J.sheafifyMap η ≫ J.sheafifyLift γ hR = J.sheafifyLift (η ≫ γ) hR := by\n  apply J.sheafifyLift_unique\n  rw [← Category.assoc, ← J.toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafifyMap_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.sheafifyMap η) (J.sheafifyLift γ hR)) (J.sheafifyLift (CategoryTheory.CategoryStruct.comp η γ) hR)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R)\n    (hR : Presheaf.IsSheaf J R) :\n    J.sheafifyMap η ≫ J.sheafifyLift γ hR = J.sheafifyLift (η ≫ γ) hR := by\n  apply J.sheafifyLift_unique\n  rw [← Category.assoc, ← J.toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.sheafify_isSheaf","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ CategoryTheory.Presheaf.IsSheaf J (J.sheafify P)","decl":"theorem GrothendieckTopology.sheafify_isSheaf (P : Cᵒᵖ ⥤ D) : Presheaf.IsSheaf J (J.sheafify P) :=\n  GrothendieckTopology.Plus.isSheaf_plus_plus _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_map_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nX✝ Y✝ : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.plusPlusSheaf J D).map η).val (J.sheafifyMap η)","decl":"/-- The sheafification functor, as a functor taking values in `Sheaf`. -/\n@[simps]\nnoncomputable def plusPlusSheaf : (Cᵒᵖ ⥤ D) ⥤ Sheaf J D where\n  obj P := ⟨J.sheafify P, J.sheafify_isSheaf P⟩\n  map η := ⟨J.sheafifyMap η⟩\n  map_id _ := Sheaf.Hom.ext <| J.sheafifyMap_id _\n  map_comp _ _ := Sheaf.Hom.ext <| J.sheafifyMap_comp _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_obj_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.plusPlusSheaf J D).obj P).val (J.sheafify P)","decl":"/-- The sheafification functor, as a functor taking values in `Sheaf`. -/\n@[simps]\nnoncomputable def plusPlusSheaf : (Cᵒᵖ ⥤ D) ⥤ Sheaf J D where\n  obj P := ⟨J.sheafify P, J.sheafify_isSheaf P⟩\n  map η := ⟨J.sheafifyMap η⟩\n  map_id _ := Sheaf.Hom.ext <| J.sheafifyMap_id _\n  map_comp _ _ := Sheaf.Hom.ext <| J.sheafifyMap_comp _ _\n\n"}
{"name":"CategoryTheory.plusPlusSheaf_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁷ : CategoryTheory.Category.{max v u, w} D\ninst✝⁶ : CategoryTheory.HasForget D\ninst✝⁵ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝⁴ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : CategoryTheory.Preadditive D\n⊢ (CategoryTheory.plusPlusSheaf J D).PreservesZeroMorphisms","decl":"instance plusPlusSheaf_preservesZeroMorphisms [Preadditive D] :\n    (plusPlusSheaf J D).PreservesZeroMorphisms where\n  map_zero F G := by\n    ext : 3\n    refine colimit.hom_ext (fun j => ?_)\n    erw [colimit.ι_map, comp_zero, J.plusMap_zero, J.diagramNatTrans_zero, zero_comp]\n\n"}
{"name":"CategoryTheory.plusPlusAdjunction_counit_app_val","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nY : CategoryTheory.Sheaf J D\n⊢ Eq ((CategoryTheory.plusPlusAdjunction J D).counit.app Y).val (J.sheafifyLift (CategoryTheory.CategoryStruct.id Y.val) ⋯)","decl":"/-- The sheafification functor is left adjoint to the forgetful functor. -/\n@[simps! unit_app counit_app_val]\nnoncomputable def plusPlusAdjunction : plusPlusSheaf J D ⊣ sheafToPresheaf J D :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun P Q =>\n        { toFun := fun e => J.toSheafify P ≫ e.val\n          invFun := fun e => ⟨J.sheafifyLift e Q.2⟩\n          left_inv := fun _ => Sheaf.Hom.ext <| (J.sheafifyLift_unique _ _ _ rfl).symm\n          right_inv := fun _ => J.toSheafify_sheafifyLift _ _ }\n      homEquiv_naturality_left_symm := by\n        intro P Q R η γ; ext1; dsimp; symm\n        apply J.sheafifyMap_sheafifyLift\n      homEquiv_naturality_right := fun η γ => by\n        dsimp\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.plusPlusAdjunction_unit_app","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nX : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.plusPlusAdjunction J D).unit.app X) (J.toSheafify X)","decl":"/-- The sheafification functor is left adjoint to the forgetful functor. -/\n@[simps! unit_app counit_app_val]\nnoncomputable def plusPlusAdjunction : plusPlusSheaf J D ⊣ sheafToPresheaf J D :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun P Q =>\n        { toFun := fun e => J.toSheafify P ≫ e.val\n          invFun := fun e => ⟨J.sheafifyLift e Q.2⟩\n          left_inv := fun _ => Sheaf.Hom.ext <| (J.sheafifyLift_unique _ _ _ rfl).symm\n          right_inv := fun _ => J.toSheafify_sheafifyLift _ _ }\n      homEquiv_naturality_left_symm := by\n        intro P Q R η γ; ext1; dsimp; symm\n        apply J.sheafifyMap_sheafifyLift\n      homEquiv_naturality_right := fun η γ => by\n        dsimp\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_isRightAdjoint","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\n⊢ (CategoryTheory.sheafToPresheaf J D).IsRightAdjoint","decl":"instance sheafToPresheaf_isRightAdjoint : (sheafToPresheaf J D).IsRightAdjoint  :=\n  (plusPlusAdjunction J D).isRightAdjoint\n\n"}
{"name":"CategoryTheory.presheaf_mono_of_mono","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁷ : CategoryTheory.Category.{max v u, w} D\ninst✝⁶ : CategoryTheory.HasForget D\ninst✝⁵ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝⁴ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\nF G : CategoryTheory.Sheaf J D\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono f.val","decl":"instance presheaf_mono_of_mono {F G : Sheaf J D} (f : F ⟶ G) [Mono f] : Mono f.1 :=\n  (sheafToPresheaf J D).map_mono _\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mono_iff_presheaf_mono","module":"Mathlib.CategoryTheory.Sites.ConcreteSheafification","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : CategoryTheory.HasForget D\ninst✝⁴ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝³ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nF G : CategoryTheory.Sheaf J D\nf : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Mono f) (CategoryTheory.Mono f.val)","decl":"theorem Sheaf.Hom.mono_iff_presheaf_mono {F G : Sheaf J D} (f : F ⟶ G) : Mono f ↔ Mono f.1 :=\n  ⟨fun m => by infer_instance, fun m => by exact Sheaf.Hom.mono_of_presheaf_mono J D f⟩\n\n"}
