{"name":"CategoryTheory.Over.pullback_obj_hom","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom X Y\ng : CategoryTheory.Over Y\n⊢ Eq ((CategoryTheory.Over.pullback f).obj g).hom (CategoryTheory.Limits.pullback.snd g.hom f)","decl":"/-- In a category with pullbacks, a morphism `f : X ⟶ Y` induces a functor `Over Y ⥤ Over X`,\nby pulling back a morphism along `f`. -/\n@[simps! (config := { simpRhs := true}) obj_left obj_hom map_left]\ndef pullback {X Y : C} (f : X ⟶ Y) : Over Y ⥤ Over X where\n  obj g := Over.mk (pullback.snd g.hom f)\n  map := fun g {h} {k} =>\n    Over.homMk (pullback.lift (pullback.fst _ _ ≫ k.left) (pullback.snd _ _)\n      (by simp [pullback.condition]))\n\n"}
{"name":"CategoryTheory.Over.pullback_map_left","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom X Y\ng h : CategoryTheory.Over Y\nk : Quiver.Hom g h\n⊢ Eq ((CategoryTheory.Over.pullback f).map k).left (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g.hom f) k.left) (CategoryTheory.Limits.pullback.snd g.hom f) ⋯)","decl":"/-- In a category with pullbacks, a morphism `f : X ⟶ Y` induces a functor `Over Y ⥤ Over X`,\nby pulling back a morphism along `f`. -/\n@[simps! (config := { simpRhs := true}) obj_left obj_hom map_left]\ndef pullback {X Y : C} (f : X ⟶ Y) : Over Y ⥤ Over X where\n  obj g := Over.mk (pullback.snd g.hom f)\n  map := fun g {h} {k} =>\n    Over.homMk (pullback.lift (pullback.fst _ _ ≫ k.left) (pullback.snd _ _)\n      (by simp [pullback.condition]))\n\n"}
{"name":"CategoryTheory.Over.pullback_obj_left","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom X Y\ng : CategoryTheory.Over Y\n⊢ Eq ((CategoryTheory.Over.pullback f).obj g).left (CategoryTheory.Limits.pullback g.hom f)","decl":"/-- In a category with pullbacks, a morphism `f : X ⟶ Y` induces a functor `Over Y ⥤ Over X`,\nby pulling back a morphism along `f`. -/\n@[simps! (config := { simpRhs := true}) obj_left obj_hom map_left]\ndef pullback {X Y : C} (f : X ⟶ Y) : Over Y ⥤ Over X where\n  obj g := Over.mk (pullback.snd g.hom f)\n  map := fun g {h} {k} =>\n    Over.homMk (pullback.lift (pullback.fst _ _ ≫ k.left) (pullback.snd _ _)\n      (by simp [pullback.condition]))\n\n"}
{"name":"CategoryTheory.Over.mapPullbackAdj_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y✝ : C\nf : Quiver.Hom X Y✝\nY : CategoryTheory.Over Y✝\n⊢ Eq ((CategoryTheory.Over.mapPullbackAdj f).counit.app Y) (CategoryTheory.Over.homMk (CategoryTheory.Limits.pullback.fst Y.hom f) ⋯)","decl":"/-- `Over.map f` is left adjoint to `Over.pullback f`. -/\n@[simps! unit_app counit_app]\ndef mapPullbackAdj {X Y : C} (f : X ⟶ Y) : Over.map f ⊣ pullback f :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun x y =>\n        { toFun := fun u =>\n            Over.homMk (pullback.lift u.left x.hom <| by simp)\n          invFun := fun v => Over.homMk (v.left ≫ pullback.fst _ _) <| by\n            simp [← Over.w v, pullback.condition]\n          left_inv := by aesop_cat\n          right_inv := fun v => by\n            ext\n            dsimp\n            ext\n            · simp\n            · simpa using (Over.w v).symm } }\n\n"}
{"name":"CategoryTheory.Over.mapPullbackAdj_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX✝ Y : C\nf : Quiver.Hom X✝ Y\nX : CategoryTheory.Over X✝\n⊢ Eq ((CategoryTheory.Over.mapPullbackAdj f).unit.app X) (CategoryTheory.Over.homMk (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.id X.left) X.hom ⋯) ⋯)","decl":"/-- `Over.map f` is left adjoint to `Over.pullback f`. -/\n@[simps! unit_app counit_app]\ndef mapPullbackAdj {X Y : C} (f : X ⟶ Y) : Over.map f ⊣ pullback f :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun x y =>\n        { toFun := fun u =>\n            Over.homMk (pullback.lift u.left x.hom <| by simp)\n          invFun := fun v => Over.homMk (v.left ≫ pullback.fst _ _) <| by\n            simp [← Over.w v, pullback.condition]\n          left_inv := by aesop_cat\n          right_inv := fun v => by\n            ext\n            dsimp\n            ext\n            · simp\n            · simpa using (Over.w v).symm } }\n\n"}
{"name":"CategoryTheory.Over.pullbackIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.Over.pullback f).IsRightAdjoint","decl":"instance pullbackIsRightAdjoint {X Y : C} (f : X ⟶ Y) : (pullback f).IsRightAdjoint  :=\n  ⟨_, ⟨mapPullbackAdj f⟩⟩\n\n"}
{"name":"CategoryTheory.Over.star_obj_left","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX✝ : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX : C\n⊢ Eq ((CategoryTheory.Over.star X✝).obj X).left (CategoryTheory.Limits.prod X✝ X)","decl":"/--\nThe functor from `C` to `Over X` which sends `Y : C` to `π₁ : X ⨯ Y ⟶ X`, sometimes denoted `X*`.\n-/\n@[simps! obj_left obj_hom map_left]\ndef star [HasBinaryProducts C] : C ⥤ Over X :=\n  cofree _ ⋙ coalgebraToOver X\n\n"}
{"name":"CategoryTheory.Over.star_obj_hom","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX✝ : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX : C\n⊢ Eq ((CategoryTheory.Over.star X✝).obj X).hom CategoryTheory.Limits.prod.fst","decl":"/--\nThe functor from `C` to `Over X` which sends `Y : C` to `π₁ : X ⨯ Y ⟶ X`, sometimes denoted `X*`.\n-/\n@[simps! obj_left obj_hom map_left]\ndef star [HasBinaryProducts C] : C ⥤ Over X :=\n  cofree _ ⋙ coalgebraToOver X\n\n"}
{"name":"CategoryTheory.Over.star_map_left","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Over.star X).map f).left (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) f)","decl":"/--\nThe functor from `C` to `Over X` which sends `Y : C` to `π₁ : X ⨯ Y ⟶ X`, sometimes denoted `X*`.\n-/\n@[simps! obj_left obj_hom map_left]\ndef star [HasBinaryProducts C] : C ⥤ Over X :=\n  cofree _ ⋙ coalgebraToOver X\n\n"}
{"name":"CategoryTheory.Over.instIsLeftAdjointForgetOfHasBinaryProducts","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ (CategoryTheory.Over.forget X).IsLeftAdjoint","decl":"/-- Note that the binary products assumption is necessary: the existence of a right adjoint to\n`Over.forget X` is equivalent to the existence of each binary product `X ⨯ -`.\n-/\ninstance [HasBinaryProducts C] : (forget X).IsLeftAdjoint  :=\n  ⟨_, ⟨forgetAdjStar X⟩⟩\n\n"}
{"name":"CategoryTheory.Under.pushout_obj","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nX Y : C\nf : Quiver.Hom X Y\nx : CategoryTheory.Under X\n⊢ Eq ((CategoryTheory.Under.pushout f).obj x) (CategoryTheory.Under.mk (CategoryTheory.Limits.pushout.inr x.hom f))","decl":"/-- When `C` has pushouts, a morphism `f : X ⟶ Y` induces a functor `Under X ⥤ Under Y`,\nby pushing a morphism forward along `f`. -/\n@[simps]\ndef pushout {X Y : C} (f : X ⟶ Y) : Under X ⥤ Under Y where\n  obj x := Under.mk (pushout.inr x.hom f)\n  map := fun x {x'} {u} =>\n    Under.homMk (pushout.desc (u.right ≫ pushout.inl _ _) (pushout.inr _ _)\n      (by simp [← pushout.condition]))\n\n"}
{"name":"CategoryTheory.Under.pushout_map","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nX Y : C\nf : Quiver.Hom X Y\nx x' : CategoryTheory.Under X\nu : Quiver.Hom x x'\n⊢ Eq ((CategoryTheory.Under.pushout f).map u) (CategoryTheory.Under.homMk (CategoryTheory.Limits.pushout.desc (CategoryTheory.CategoryStruct.comp u.right (CategoryTheory.Limits.pushout.inl x'.hom f)) (CategoryTheory.Limits.pushout.inr x'.hom f) ⋯) ⋯)","decl":"/-- When `C` has pushouts, a morphism `f : X ⟶ Y` induces a functor `Under X ⥤ Under Y`,\nby pushing a morphism forward along `f`. -/\n@[simps]\ndef pushout {X Y : C} (f : X ⟶ Y) : Under X ⥤ Under Y where\n  obj x := Under.mk (pushout.inr x.hom f)\n  map := fun x {x'} {u} =>\n    Under.homMk (pushout.desc (u.right ≫ pushout.inl _ _) (pushout.inr _ _)\n      (by simp [← pushout.condition]))\n\n"}
{"name":"CategoryTheory.Under.mapPushoutAdj_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nX Y✝ : C\nf : Quiver.Hom X Y✝\nY : CategoryTheory.Under Y✝\n⊢ Eq ((CategoryTheory.Under.mapPushoutAdj f).counit.app Y) (CategoryTheory.Under.homMk (CategoryTheory.Limits.pushout.desc (CategoryTheory.CategoryStruct.id Y.right) Y.hom ⋯) ⋯)","decl":"/-- `Under.pushout f` is left adjoint to `Under.map f`. -/\n@[simps! unit_app counit_app]\ndef mapPushoutAdj {X Y : C} (f : X ⟶ Y) : pushout f ⊣ map f :=\n  Adjunction.mkOfHomEquiv {\n    homEquiv := fun x y => {\n      toFun := fun u => Under.homMk (pushout.inl _ _ ≫ u.right) <| by\n        simp only [map_obj_hom]\n        rw [← Under.w u]\n        simp only [Functor.const_obj_obj, map_obj_right, Functor.id_obj, pushout_obj, mk_right,\n          mk_hom]\n        rw [← assoc, ← assoc, pushout.condition]\n      invFun := fun v => Under.homMk (pushout.desc v.right y.hom <| by simp)\n      left_inv := fun u => by\n        ext\n        dsimp\n        ext\n        · simp\n        · simpa using (Under.w u).symm\n      right_inv := by aesop_cat\n    }\n  }\n\n"}
{"name":"CategoryTheory.Under.mapPushoutAdj_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nX✝ Y : C\nf : Quiver.Hom X✝ Y\nX : CategoryTheory.Under X✝\n⊢ Eq ((CategoryTheory.Under.mapPushoutAdj f).unit.app X) (CategoryTheory.Under.homMk (CategoryTheory.Limits.pushout.inl X.hom f) ⋯)","decl":"/-- `Under.pushout f` is left adjoint to `Under.map f`. -/\n@[simps! unit_app counit_app]\ndef mapPushoutAdj {X Y : C} (f : X ⟶ Y) : pushout f ⊣ map f :=\n  Adjunction.mkOfHomEquiv {\n    homEquiv := fun x y => {\n      toFun := fun u => Under.homMk (pushout.inl _ _ ≫ u.right) <| by\n        simp only [map_obj_hom]\n        rw [← Under.w u]\n        simp only [Functor.const_obj_obj, map_obj_right, Functor.id_obj, pushout_obj, mk_right,\n          mk_hom]\n        rw [← assoc, ← assoc, pushout.condition]\n      invFun := fun v => Under.homMk (pushout.desc v.right y.hom <| by simp)\n      left_inv := fun u => by\n        ext\n        dsimp\n        ext\n        · simp\n        · simpa using (Under.w u).symm\n      right_inv := by aesop_cat\n    }\n  }\n\n"}
{"name":"CategoryTheory.Under.pushoutIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Over","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nX Y : C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.Under.pushout f).IsLeftAdjoint","decl":"instance pushoutIsLeftAdjoint {X Y : C} (f : X ⟶ Y) : (pushout f).IsLeftAdjoint  :=\n  ⟨_, ⟨mapPushoutAdj f⟩⟩\n\n"}
