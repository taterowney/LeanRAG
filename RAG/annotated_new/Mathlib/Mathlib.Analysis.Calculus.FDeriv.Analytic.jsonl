{"name":"HasFPowerSeriesWithinAt.hasStrictFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\nâŠ¢ Asymptotics.IsLittleO (nhdsWithin { fst := x, snd := x } (SProd.sprod (Insert.insert x s) (Insert.insert x s))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) (((continuousMultilinearCurryFin1 ğ•œ E F) (p 1)) (HSub.hSub y.1 y.2))) fun y => HSub.hSub y.1 y.2","decl":"/-- A function which is analytic within a set is strictly differentiable there. Since we\ndon't have a predicate `HasStrictFDerivWithinAt`, we spell out what it would mean. -/\ntheorem HasFPowerSeriesWithinAt.hasStrictFDerivWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    (fun y â†¦ f y.1 - f y.2 - (continuousMultilinearCurryFin1 ğ•œ E F (p 1)) (y.1 - y.2))\n      =o[ğ“[insert x s Ã—Ë¢ insert x s] (x, x)] fun y â†¦ y.1 - y.2 := by\n  refine h.isBigO_image_sub_norm_mul_norm_sub.trans_isLittleO (IsLittleO.of_norm_right ?_)\n  refine isLittleO_iff_exists_eq_mul.2 âŸ¨fun y => â€–y - (x, x)â€–, ?_, EventuallyEq.rflâŸ©\n  apply Tendsto.mono_left _ nhdsWithin_le_nhds\n  refine (continuous_id.sub continuous_const).norm.tendsto' _ _ ?_\n  rw [_root_.id, sub_self, norm_zero]\n\n"}
{"name":"HasFPowerSeriesAt.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nh : HasFPowerSeriesAt f p x\nâŠ¢ HasStrictFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p 1)) x","decl":"theorem HasFPowerSeriesAt.hasStrictFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p 1)) x := by\n  simpa only [hasStrictFDerivAt_iff_isLittleO, Set.insert_eq_of_mem, Set.mem_univ,\n      Set.univ_prod_univ, nhdsWithin_univ]\n    using (h.hasFPowerSeriesWithinAt (s := Set.univ)).hasStrictFDerivWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\nâŠ¢ HasFDerivWithinAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p 1)) (Insert.insert x s) x","decl":"theorem HasFPowerSeriesWithinAt.hasFDerivWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    HasFDerivWithinAt f (continuousMultilinearCurryFin1 ğ•œ E F (p 1)) (insert x s) x := by\n  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff]\n  intro c hc\n  have : Tendsto (fun y â†¦ (y, x)) (ğ“[insert x s] x) (ğ“[insert x s Ã—Ë¢ insert x s] (x, x)) := by\n    rw [nhdsWithin_prod_eq]\n    exact Tendsto.prod_mk tendsto_id (tendsto_const_nhdsWithin (by simp))\n  exact this (isLittleO_iff.1 h.hasStrictFDerivWithinAt hc)\n\n"}
{"name":"HasFPowerSeriesAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nh : HasFPowerSeriesAt f p x\nâŠ¢ HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p 1)) x","decl":"theorem HasFPowerSeriesAt.hasFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p 1)) x :=\n  h.hasStrictFDerivAt.hasFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert x s) x","decl":"theorem HasFPowerSeriesWithinAt.differentiableWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    DifferentiableWithinAt ğ•œ f (insert x s) x :=\n  h.hasFDerivWithinAt.differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nh : HasFPowerSeriesAt f p x\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"theorem HasFPowerSeriesAt.differentiableAt (h : HasFPowerSeriesAt f p x) : DifferentiableAt ğ•œ f x :=\n  h.hasFDerivAt.differentiableAt\n\n"}
{"name":"AnalyticWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : AnalyticWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert x s) x","decl":"theorem AnalyticWithinAt.differentiableWithinAt (h : AnalyticWithinAt ğ•œ f s x) :\n    DifferentiableWithinAt ğ•œ f (insert x s) x := by\n  obtain âŸ¨p, hpâŸ© := h\n  exact hp.differentiableWithinAt\n\n"}
{"name":"AnalyticAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\naâœ : AnalyticAt ğ•œ f x\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"@[fun_prop]\ntheorem AnalyticAt.differentiableAt : AnalyticAt ğ•œ f x â†’ DifferentiableAt ğ•œ f x\n  | âŸ¨_, hpâŸ© => hp.differentiableAt\n\n"}
{"name":"AnalyticAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : AnalyticAt ğ•œ f x\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"theorem AnalyticAt.differentiableWithinAt (h : AnalyticAt ğ•œ f x) : DifferentiableWithinAt ğ•œ f s x :=\n  h.differentiableAt.differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\nhu : UniqueDiffWithinAt ğ•œ (Insert.insert x s) x\nâŠ¢ Eq (fderivWithin ğ•œ f (Insert.insert x s) x) ((continuousMultilinearCurryFin1 ğ•œ E F) (p 1))","decl":"theorem HasFPowerSeriesWithinAt.fderivWithin_eq\n    (h : HasFPowerSeriesWithinAt f p s x) (hu : UniqueDiffWithinAt ğ•œ (insert x s) x) :\n    fderivWithin ğ•œ f (insert x s) x = continuousMultilinearCurryFin1 ğ•œ E F (p 1) :=\n  h.hasFDerivWithinAt.fderivWithin hu\n\n"}
{"name":"HasFPowerSeriesAt.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nh : HasFPowerSeriesAt f p x\nâŠ¢ Eq (fderiv ğ•œ f x) ((continuousMultilinearCurryFin1 ğ•œ E F) (p 1))","decl":"theorem HasFPowerSeriesAt.fderiv_eq (h : HasFPowerSeriesAt f p x) :\n    fderiv ğ•œ f x = continuousMultilinearCurryFin1 ğ•œ E F (p 1) :=\n  h.hasFDerivAt.fderiv\n\n"}
{"name":"AnalyticAt.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : AnalyticAt ğ•œ f x\nâŠ¢ HasStrictFDerivAt f (fderiv ğ•œ f x) x","decl":"theorem AnalyticAt.hasStrictFDerivAt (h : AnalyticAt ğ•œ f x) :\n    HasStrictFDerivAt f (fderiv ğ•œ f x) x := by\n  rcases h with âŸ¨p, hpâŸ©\n  rw [hp.fderiv_eq]\n  exact hp.hasStrictFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ DifferentiableOn ğ•œ f (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"theorem HasFPowerSeriesWithinOnBall.differentiableOn [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) :\n    DifferentiableOn ğ•œ f (insert x s âˆ© EMetric.ball x r) := by\n  intro y hy\n  have Z := (h.analyticWithinAt_of_mem hy).differentiableWithinAt\n  rcases eq_or_ne y x with rfl | hy\n  Â· exact Z.mono inter_subset_left\n  Â· apply (Z.mono (subset_insert _ _)).mono_of_mem_nhdsWithin\n    suffices s âˆˆ ğ“[insert x s] y from nhdsWithin_mono _ inter_subset_left this\n    rw [nhdsWithin_insert_of_ne hy]\n    exact self_mem_nhdsWithin\n\n"}
{"name":"HasFPowerSeriesOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\nâŠ¢ DifferentiableOn ğ•œ f (EMetric.ball x r)","decl":"theorem HasFPowerSeriesOnBall.differentiableOn [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) : DifferentiableOn ğ•œ f (EMetric.ball x r) := fun _ hy =>\n  (h.analyticAt_of_mem hy).differentiableWithinAt\n\n"}
{"name":"AnalyticOn.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"theorem AnalyticOn.differentiableOn (h : AnalyticOn ğ•œ f s) : DifferentiableOn ğ•œ f s :=\n  fun y hy â†¦ (h y hy).differentiableWithinAt.mono (by simp)\n\n"}
{"name":"AnalyticOnNhd.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"theorem AnalyticOnNhd.differentiableOn (h : AnalyticOnNhd ğ•œ f s) : DifferentiableOn ğ•œ f s :=\n  fun y hy â†¦ (h y hy).differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nâŠ¢ HasFDerivWithinAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1)) (Insert.insert x s) (HAdd.hAdd x y)","decl":"theorem HasFPowerSeriesWithinOnBall.hasFDerivWithinAt [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) (h'y : x + y âˆˆ insert x s) :\n    HasFDerivWithinAt f (continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1))\n      (insert x s) (x + y) := by\n  rcases eq_or_ne y 0 with rfl | h''y\n  Â· convert (h.changeOrigin hy h'y).hasFPowerSeriesWithinAt.hasFDerivWithinAt\n    simp\n  Â· have Z := (h.changeOrigin hy h'y).hasFPowerSeriesWithinAt.hasFDerivWithinAt\n    apply (Z.mono (subset_insert _ _)).mono_of_mem_nhdsWithin\n    rw [nhdsWithin_insert_of_ne]\n    Â· exact self_mem_nhdsWithin\n    Â· simpa using h''y\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nâŠ¢ HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1)) (HAdd.hAdd x y)","decl":"theorem HasFPowerSeriesOnBall.hasFDerivAt [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1)) (x + y) :=\n  (h.changeOrigin hy).hasFPowerSeriesAt.hasFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhu : UniqueDiffOn ğ•œ (Insert.insert x s)\nâŠ¢ Eq (fderivWithin ğ•œ f (Insert.insert x s) (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1))","decl":"theorem HasFPowerSeriesWithinOnBall.fderivWithin_eq [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) (h'y : x + y âˆˆ insert x s) (hu : UniqueDiffOn ğ•œ (insert x s)) :\n    fderivWithin ğ•œ f (insert x s) (x + y) =\n      continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1) :=\n  (h.hasFDerivWithinAt hy h'y).fderivWithin (hu _ h'y)\n\n"}
{"name":"HasFPowerSeriesOnBall.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nâŠ¢ Eq (fderiv ğ•œ f (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1))","decl":"theorem HasFPowerSeriesOnBall.fderiv_eq [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) :\n    fderiv ğ•œ f (x + y) = continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1) :=\n  (h.hasFDerivAt hy).fderiv\n\n"}
{"name":"HasFPowerSeriesOnBall.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\nâŠ¢ HasFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x r","decl":"/-- If a function has a power series on a ball, then so does its derivative. -/\nprotected theorem HasFPowerSeriesOnBall.fderiv [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x r := by\n  refine .congr (f := fun z â†¦ continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin (z - x) 1)) ?_\n    fun z hz â†¦ ?_\n  Â· refine continuousMultilinearCurryFin1 ğ•œ E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesOnBall ?_\n    simpa using ((p.hasFPowerSeriesOnBall_changeOrigin 1\n      (h.r_pos.trans_le h.r_le)).mono h.r_pos h.r_le).comp_sub x\n  dsimp only\n  rw [â† h.fderiv_eq, add_sub_cancel]\n  simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn ğ•œ (Insert.insert x s)\nâŠ¢ HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f (Insert.insert x s)) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (hu : UniqueDiffOn ğ•œ (insert x s)) :\n    HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f (insert x s)) p.derivSeries s x r := by\n  refine .congr' (f := fun z â†¦ continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin (z - x) 1)) ?_\n    (fun z hz â†¦ ?_)\n  Â· refine continuousMultilinearCurryFin1 ğ•œ E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall ?_\n    apply HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall\n    simpa using ((p.hasFPowerSeriesOnBall_changeOrigin 1\n      (h.r_pos.trans_le h.r_le)).mono h.r_pos h.r_le).comp_sub x\n  Â· dsimp only\n    rw [â† h.fderivWithin_eq _ _ hu, add_sub_cancel]\n    Â· simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz.2\n    Â· simpa using hz.1\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f s) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. For a\nversion without completeness, but assuming that the function is analytic on the set `s`, see\n`HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn`. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin_of_mem [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f s) p.derivSeries s x r := by\n  have : insert x s = s := insert_eq_of_mem hx\n  rw [â† this] at hu\n  convert h.fderivWithin hu\n  exact this.symm\n\n"}
{"name":"AnalyticAt.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nh : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (fderiv ğ•œ f) x","decl":"/-- If a function is analytic on a set `s`, so is its FrÃ©chet derivative. -/\n@[fun_prop]\nprotected theorem AnalyticAt.fderiv [CompleteSpace F] (h : AnalyticAt ğ•œ f x) :\n    AnalyticAt ğ•œ (fderiv ğ•œ f) x := by\n  rcases h with âŸ¨p, r, hpâŸ©\n  exact hp.fderiv.analyticAt\n\n"}
{"name":"AnalyticOnNhd.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fderiv ğ•œ f) s","decl":"/-- If a function is analytic on a set `s`, so is its FrÃ©chet derivative. See also\n`AnalyticOnNhd.fderiv_of_isOpen`, removing the completeness assumption but requiring the set\nto be open. -/\nprotected theorem AnalyticOnNhd.fderiv [CompleteSpace F] (h : AnalyticOnNhd ğ•œ f s) :\n    AnalyticOnNhd ğ•œ (fderiv ğ•œ f) s :=\n  fun y hy â†¦ AnalyticAt.fderiv (h y hy)\n\n"}
{"name":"AnalyticOn.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fderiv ğ•œ f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.fderiv := AnalyticOnNhd.fderiv\n\n"}
{"name":"AnalyticOnNhd.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s","decl":"/-- If a function is analytic on a set `s`, so are its successive FrÃ©chet derivative. See also\n`AnalyticOnNhd.iteratedFDeriv_of_isOpen`, removing the completeness assumption but requiring the set\nto be open.-/\nprotected theorem AnalyticOnNhd.iteratedFDeriv [CompleteSpace F] (h : AnalyticOnNhd ğ•œ f s) (n : â„•) :\n    AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDeriv_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 ğ•œ E F).symm : F â†’L[ğ•œ] E[Ã—0]â†’L[ğ•œ] F).comp_analyticOnNhd h\n  | succ n IH =>\n    rw [iteratedFDeriv_succ_eq_comp_left]\n    -- Porting note: for reasons that I do not understand at all, `?g` cannot be inlined.\n    convert ContinuousLinearMap.comp_analyticOnNhd ?g IH.fderiv\n    case g => exact â†‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) â†¦ E) F).symm\n    simp\n\n"}
{"name":"AnalyticOn.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nprotected alias AnalyticOn.iteratedFDeriv := AnalyticOnNhd.iteratedFDeriv\n\n"}
{"name":"AnalyticOnNhd.hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ninstâœ : CompleteSpace F\nn : WithTop ENat\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ HasFTaylorSeriesUpToOn n f (ftaylorSeries ğ•œ f) s","decl":"/-- If a function is analytic on a neighborhood of a set `s`, then it has a Taylor series given\nby the sequence of its derivatives. Note that, if the function were just analytic on `s`, then\none would have to use instead the sequence of derivatives inside the set, as in\n`AnalyticOn.hasFTaylorSeriesUpToOn`. -/\nlemma AnalyticOnNhd.hasFTaylorSeriesUpToOn [CompleteSpace F]\n    (n : WithTop â„•âˆ) (h : AnalyticOnNhd ğ•œ f s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeries ğ•œ f) s := by\n  refine âŸ¨fun x _hx â†¦ rfl, fun m _hm x hx â†¦ ?_, fun m _hm x hx â†¦ ?_âŸ©\n  Â· apply HasFDerivAt.hasFDerivWithinAt\n    exact ((h.iteratedFDeriv m x hx).differentiableAt).hasFDerivAt\n  Â· apply (DifferentiableAt.continuousAt (ğ•œ := ğ•œ) ?_).continuousWithinAt\n    exact (h.iteratedFDeriv m x hx).differentiableAt\n\n"}
{"name":"AnalyticWithinAt.exists_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\ninstâœ : CompleteSpace F\nn : WithTop ENat\nh : AnalyticWithinAt ğ•œ f s x\nâŠ¢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => And (HasFTaylorSeriesUpToOn n f p u) (âˆ€ (i : Nat), AnalyticOn ğ•œ (fun x => p x i) u))","decl":"lemma AnalyticWithinAt.exists_hasFTaylorSeriesUpToOn [CompleteSpace F]\n    (n : WithTop â„•âˆ) (h : AnalyticWithinAt ğ•œ f s x) :\n    âˆƒ u âˆˆ ğ“[insert x s] x, âˆƒ (p : E â†’ FormalMultilinearSeries ğ•œ E F),\n    HasFTaylorSeriesUpToOn n f p u âˆ§ âˆ€ i, AnalyticOn ğ•œ (fun x â†¦ p x i) u := by\n  rcases h.exists_analyticAt with âŸ¨g, -, fg, hgâŸ©\n  rcases hg.exists_mem_nhds_analyticOnNhd with âŸ¨v, vx, hvâŸ©\n  refine âŸ¨insert x s âˆ© v, inter_mem_nhdsWithin _ vx, ftaylorSeries ğ•œ g, ?_, fun i â†¦ ?_âŸ©\n  Â· suffices HasFTaylorSeriesUpToOn n g (ftaylorSeries ğ•œ g) (insert x s âˆ© v) from\n      this.congr (fun y hy â†¦ fg hy.1)\n    exact AnalyticOnNhd.hasFTaylorSeriesUpToOn _ (hv.mono Set.inter_subset_right)\n  Â· exact (hv.iteratedFDeriv i).analyticOn.mono Set.inter_subset_right\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum_derivSeries_of_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinOnBall f p s x r\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhf' : HasFDerivWithinAt f f' (Insert.insert x s) (HAdd.hAdd x y)\nhu : UniqueDiffOn ğ•œ (Insert.insert x s)\nâŠ¢ HasSum (fun n => (p.derivSeries n) fun x => y) f'","decl":"/-- If a function has a power series `p` within a set of unique differentiability, inside a ball,\nand is differentiable at a point, then the derivative series of `p` is summable at a point, with\nsum the given differential. Note that this theorem does not require completeness of the space.-/\ntheorem HasFPowerSeriesWithinOnBall.hasSum_derivSeries_of_hasFDerivWithinAt\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {f' : E â†’L[ğ•œ] F}\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) (h'y : x + y âˆˆ insert x s)\n    (hf' : HasFDerivWithinAt f f' (insert x s) (x + y))\n    (hu : UniqueDiffOn ğ•œ (insert x s)) :\n    HasSum (fun n â†¦ p.derivSeries n (fun _ â†¦ y)) f' := by\n  /- In the completion of the space, the derivative series is summable, and its sum is a derivative\n  of the function. Therefore, by uniqueness of derivatives, its sum is the image of `f'` under\n  the canonical embedding. As this is an embedding, it means that there was also convergence in\n  the original space, to `f'`. -/\n  let F' := UniformSpace.Completion F\n  let a : F â†’L[ğ•œ] F' := UniformSpace.Completion.toComplL\n  let b : (E â†’L[ğ•œ] F) â†’â‚—áµ¢[ğ•œ] (E â†’L[ğ•œ] F') := UniformSpace.Completion.toComplâ‚—áµ¢.postcomp\n  rw [â† b.isEmbedding.hasSum_iff]\n  have : HasFPowerSeriesWithinOnBall (a âˆ˜ f) (a.compFormalMultilinearSeries p) s x r :=\n    a.comp_hasFPowerSeriesWithinOnBall h\n  have Z := (this.fderivWithin hu).hasSum h'y (by simpa [edist_zero_eq_enorm] using hy)\n  have : fderivWithin ğ•œ (a âˆ˜ f) (insert x s) (x + y) = a âˆ˜L f' := by\n    apply HasFDerivWithinAt.fderivWithin _ (hu _ h'y)\n    exact a.hasFDerivAt.comp_hasFDerivWithinAt (x + y) hf'\n  rw [this] at Z\n  convert Z with n\n  ext v\n  simp only [FormalMultilinearSeries.derivSeries,\n    ContinuousLinearMap.compFormalMultilinearSeries_apply,\n    FormalMultilinearSeries.changeOriginSeries,\n    ContinuousLinearMap.compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe,\n    LinearIsometryEquiv.coe_coe, Function.comp_apply, ContinuousMultilinearMap.sum_apply, map_sum,\n    ContinuousLinearMap.coe_sum', Finset.sum_apply,\n    Matrix.zero_empty]\n  rfl\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nf : E â†’ F\nx : E\ns : Set E\nhr : HasFPowerSeriesWithinOnBall f p s x r\nh : AnalyticOn ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f s) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. Version\nassuming that the function is analytic on `s`. For a version without this assumption but requiring\nthat `F` is complete, see `HasFPowerSeriesWithinOnBall.fderivWithin_of_mem`. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn\n    (hr : HasFPowerSeriesWithinOnBall f p s x r)\n    (h : AnalyticOn ğ•œ f s) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    HasFPowerSeriesWithinOnBall (fderivWithin ğ•œ f s) p.derivSeries s x r := by\n  refine âŸ¨hr.r_le.trans p.radius_le_radius_derivSeries, hr.r_pos, fun {y} hy h'y â†¦ ?_âŸ©\n  apply hr.hasSum_derivSeries_of_hasFDerivWithinAt (by simpa [edist_zero_eq_enorm] using h'y) hy\n  Â· rw [insert_eq_of_mem hx] at hy âŠ¢\n    apply DifferentiableWithinAt.hasFDerivWithinAt\n    exact h.differentiableOn _ hy\n  Â· rwa [insert_eq_of_mem hx]\n\n"}
{"name":"AnalyticOn.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nhu : UniqueDiffOn ğ•œ s\nâŠ¢ AnalyticOn ğ•œ (fderivWithin ğ•œ f s) s","decl":"/-- If a function is analytic within a set with unique differentials, then so is its derivative.\nNote that this theorem does not require completeness of the space. -/\nprotected theorem AnalyticOn.fderivWithin (h : AnalyticOn ğ•œ f s) (hu : UniqueDiffOn ğ•œ s) :\n    AnalyticOn ğ•œ (fderivWithin ğ•œ f s) s := by\n  intro x hx\n  rcases h x hx with âŸ¨p, r, hrâŸ©\n  refine âŸ¨p.derivSeries, r, hr.fderivWithin_of_mem_of_analyticOn h hu hxâŸ©\n\n"}
{"name":"AnalyticOn.iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nhu : UniqueDiffOn ğ•œ s\nn : Nat\nâŠ¢ AnalyticOn ğ•œ (iteratedFDerivWithin ğ•œ n f s) s","decl":"/-- If a function is analytic on a set `s`, so are its successive FrÃ©chet derivative within this\nset. Note that this theorem does not require completeness of the space. -/\nprotected theorem AnalyticOn.iteratedFDerivWithin (h : AnalyticOn ğ•œ f s)\n    (hu : UniqueDiffOn ğ•œ s) (n : â„•) :\n    AnalyticOn ğ•œ (iteratedFDerivWithin ğ•œ n f s) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDerivWithin_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 ğ•œ E F).symm : F â†’L[ğ•œ] E[Ã—0]â†’L[ğ•œ] F)\n      |>.comp_analyticOn h\n  | succ n IH =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left]\n    apply AnalyticOnNhd.comp_analyticOn _ (IH.fderivWithin hu) (mapsTo_univ _ _)\n    apply LinearIsometryEquiv.analyticOnNhd\n\n"}
{"name":"AnalyticOn.hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nn : WithTop ENat\nh : AnalyticOn ğ•œ f s\nhu : UniqueDiffOn ğ•œ s\nâŠ¢ HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin ğ•œ f s) s","decl":"protected lemma AnalyticOn.hasFTaylorSeriesUpToOn {n : WithTop â„•âˆ}\n    (h : AnalyticOn ğ•œ f s) (hu : UniqueDiffOn ğ•œ s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin ğ•œ f s) s := by\n  refine âŸ¨fun x _hx â†¦ rfl, fun m _hm x hx â†¦ ?_, fun m _hm x hx â†¦ ?_âŸ©\n  Â· have := (h.iteratedFDerivWithin hu m x hx).differentiableWithinAt.hasFDerivWithinAt\n    rwa [insert_eq_of_mem hx] at this\n  Â· exact (h.iteratedFDerivWithin hu m x hx).continuousWithinAt\n\n"}
{"name":"AnalyticOn.exists_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nhu : UniqueDiffOn ğ•œ s\nâŠ¢ Exists fun p => And (HasFTaylorSeriesUpToOn Top.top f p s) (âˆ€ (i : Nat), AnalyticOn ğ•œ (fun x => p x i) s)","decl":"lemma AnalyticOn.exists_hasFTaylorSeriesUpToOn\n    (h : AnalyticOn ğ•œ f s) (hu : UniqueDiffOn ğ•œ s) :\n    âˆƒ p : E â†’ FormalMultilinearSeries ğ•œ E F,\n      HasFTaylorSeriesUpToOn âŠ¤ f p s âˆ§ âˆ€ i, AnalyticOn ğ•œ (fun x â†¦ p x i) s :=\n  âŸ¨ftaylorSeriesWithin ğ•œ f s, h.hasFTaylorSeriesUpToOn hu, h.iteratedFDerivWithin huâŸ©\n\n"}
{"name":"AnalyticOnNhd.fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOnNhd ğ•œ f s\nhs : IsOpen s\nâŠ¢ AnalyticOnNhd ğ•œ (fderiv ğ•œ f) s","decl":"theorem AnalyticOnNhd.fderiv_of_isOpen (h : AnalyticOnNhd ğ•œ f s) (hs : IsOpen s) :\n    AnalyticOnNhd ğ•œ (fderiv ğ•œ f) s := by\n  rw [â† hs.analyticOn_iff_analyticOnNhd] at h âŠ¢\n  exact (h.fderivWithin hs.uniqueDiffOn).congr (fun x hx â†¦ (fderivWithin_of_isOpen hs hx).symm)\n\n"}
{"name":"AnalyticOnNhd.iteratedFDeriv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOnNhd ğ•œ f s\nhs : IsOpen s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s","decl":"theorem AnalyticOnNhd.iteratedFDeriv_of_isOpen (h : AnalyticOnNhd ğ•œ f s) (hs : IsOpen s) (n : â„•) :\n    AnalyticOnNhd ğ•œ (iteratedFDeriv ğ•œ n f) s := by\n  rw [â† hs.analyticOn_iff_analyticOnNhd] at h âŠ¢\n  exact (h.iteratedFDerivWithin hs.uniqueDiffOn n).congr\n    (fun x hx â†¦ (iteratedFDerivWithin_of_isOpen n hs hx).symm)\n\n"}
{"name":"PartialHomeomorph.analyticAt_symm'","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\na : E\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nh0 : Membership.mem f.source a\nh : AnalyticAt ğ•œ (â†‘f) a\nh' : Eq (fderiv ğ•œ (â†‘f) a) â†‘i\nâŠ¢ AnalyticAt ğ•œ (â†‘f.symm) (â†‘f a)","decl":"/-- If a partial homeomorphism `f` is analytic at a point `a`, with invertible derivative, then\nits inverse is analytic at `f a`. -/\ntheorem PartialHomeomorph.analyticAt_symm' (f : PartialHomeomorph E F) {a : E}\n    {i : E â‰ƒL[ğ•œ] F} (h0 : a âˆˆ f.source) (h : AnalyticAt ğ•œ f a) (h' : fderiv ğ•œ f a = i) :\n    AnalyticAt ğ•œ f.symm (f a) := by\n  rcases h with âŸ¨p, hpâŸ©\n  have : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i := by simp [â† h', hp.fderiv_eq]\n  exact (f.hasFPowerSeriesAt_symm h0 hp this).analyticAt\n\n"}
{"name":"PartialHomeomorph.analyticAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\na : F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nh0 : Membership.mem f.target a\nh : AnalyticAt ğ•œ (â†‘f) (â†‘f.symm a)\nh' : Eq (fderiv ğ•œ (â†‘f) (â†‘f.symm a)) â†‘i\nâŠ¢ AnalyticAt ğ•œ (â†‘f.symm) a","decl":"/-- If a partial homeomorphism `f` is analytic at a point `f.symm a`, with invertible derivative,\nthen its inverse is analytic at `a`. -/\ntheorem PartialHomeomorph.analyticAt_symm (f : PartialHomeomorph E F) {a : F}\n    {i : E â‰ƒL[ğ•œ] F} (h0 : a âˆˆ f.target) (h : AnalyticAt ğ•œ f (f.symm a))\n    (h' : fderiv ğ•œ f (f.symm a) = i) :\n    AnalyticAt ğ•œ f.symm a := by\n  have : a = f (f.symm a) := by simp [h0]\n  rw [this]\n  exact f.analyticAt_symm' (by simp [h0]) h h'\n\n"}
{"name":"HasFPowerSeriesAt.hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nh : HasFPowerSeriesAt f p x\nâŠ¢ HasStrictDerivAt f ((p 1) fun x => 1) x","decl":"protected theorem HasFPowerSeriesAt.hasStrictDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictDerivAt f (p 1 fun _ => 1) x :=\n  h.hasStrictFDerivAt.hasStrictDerivAt\n\n"}
{"name":"HasFPowerSeriesAt.hasDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nh : HasFPowerSeriesAt f p x\nâŠ¢ HasDerivAt f ((p 1) fun x => 1) x","decl":"protected theorem HasFPowerSeriesAt.hasDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasDerivAt f (p 1 fun _ => 1) x :=\n  h.hasStrictDerivAt.hasDerivAt\n\n"}
{"name":"HasFPowerSeriesAt.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nh : HasFPowerSeriesAt f p x\nâŠ¢ Eq (deriv f x) ((p 1) fun x => 1)","decl":"protected theorem HasFPowerSeriesAt.deriv (h : HasFPowerSeriesAt f p x) :\n    deriv f x = p 1 fun _ => 1 :=\n  h.hasDerivAt.deriv\n\n"}
{"name":"AnalyticOnNhd.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (deriv f) s","decl":"/-- If a function is analytic on a set `s` in a complete space, so is its derivative. -/\nprotected theorem AnalyticOnNhd.deriv [CompleteSpace F] (h : AnalyticOnNhd ğ•œ f s) :\n    AnalyticOnNhd ğ•œ (deriv f) s :=\n  (ContinuousLinearMap.apply ğ•œ F (1 : ğ•œ)).comp_analyticOnNhd h.fderiv\n\n"}
{"name":"AnalyticOn.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (deriv f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.deriv := AnalyticOnNhd.deriv\n\n"}
{"name":"AnalyticOnNhd.deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nh : AnalyticOnNhd ğ•œ f s\nhs : IsOpen s\nâŠ¢ AnalyticOnNhd ğ•œ (deriv f) s","decl":"/-- If a function is analytic on an open set `s`, so is its derivative. -/\ntheorem AnalyticOnNhd.deriv_of_isOpen (h : AnalyticOnNhd ğ•œ f s) (hs : IsOpen s) :\n    AnalyticOnNhd ğ•œ (deriv f) s :=\n  (ContinuousLinearMap.apply ğ•œ F (1 : ğ•œ)).comp_analyticOnNhd (h.fderiv_of_isOpen hs)\n\n"}
{"name":"AnalyticOnNhd.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (Nat.iterate deriv n f) s","decl":"/-- If a function is analytic on a set `s`, so are its successive derivatives. -/\ntheorem AnalyticOnNhd.iterated_deriv [CompleteSpace F] (h : AnalyticOnNhd ğ•œ f s) (n : â„•) :\n    AnalyticOnNhd ğ•œ (_root_.deriv^[n] f) s := by\n  induction n with\n  | zero => exact h\n  | succ n IH => simpa only [Function.iterate_succ', Function.comp_apply] using IH.deriv\n\n"}
{"name":"AnalyticOn.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (Nat.iterate deriv n f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.iterated_deriv := AnalyticOnNhd.iterated_deriv\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nf : E â†’ F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ DifferentiableOn ğ•œ f (EMetric.ball x r)","decl":"theorem HasFiniteFPowerSeriesOnBall.differentiableOn\n    (h : HasFiniteFPowerSeriesOnBall f p x n r) : DifferentiableOn ğ•œ f (EMetric.ball x r) :=\n  fun _ hy â†¦ (h.cPolynomialAt_of_mem hy).analyticAt.differentiableWithinAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nf : E â†’ F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nâŠ¢ HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1)) (HAdd.hAdd x y)","decl":"theorem HasFiniteFPowerSeriesOnBall.hasFDerivAt (h : HasFiniteFPowerSeriesOnBall f p x n r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1)) (x + y) :=\n  (h.changeOrigin hy).toHasFPowerSeriesOnBall.hasFPowerSeriesAt.hasFDerivAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nf : E â†’ F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : LT.lt (â†‘(NNNorm.nnnorm y)) r\nâŠ¢ Eq (fderiv ğ•œ f (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOrigin y 1))","decl":"theorem HasFiniteFPowerSeriesOnBall.fderiv_eq (h : HasFiniteFPowerSeriesOnBall f p x n r)\n    {y : E} (hy : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) :\n    fderiv ğ•œ f (x + y) = continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin y 1) :=\n  (h.hasFDerivAt hy).fderiv\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nf : E â†’ F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x (HAdd.hAdd n 1) r\nâŠ¢ HasFiniteFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x n r","decl":"/-- If a function has a finite power series on a ball, then so does its derivative. -/\nprotected theorem HasFiniteFPowerSeriesOnBall.fderiv\n    (h : HasFiniteFPowerSeriesOnBall f p x (n + 1) r) :\n    HasFiniteFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x n r := by\n  refine .congr (f := fun z â†¦ continuousMultilinearCurryFin1 ğ•œ E F (p.changeOrigin (z - x) 1)) ?_\n    fun z hz â†¦ ?_\n  Â· refine continuousMultilinearCurryFin1 ğ•œ E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall ?_\n    simpa using\n      ((p.hasFiniteFPowerSeriesOnBall_changeOrigin 1 h.finite).mono h.r_pos le_top).comp_sub x\n  dsimp only\n  rw [â† h.fderiv_eq, add_sub_cancel]\n  simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv'","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nf : E â†’ F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ HasFiniteFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x (HSub.hSub n 1) r","decl":"/-- If a function has a finite power series on a ball, then so does its derivative.\nThis is a variant of `HasFiniteFPowerSeriesOnBall.fderiv` where the degree of `f` is `< n`\nand not `< n + 1`. -/\ntheorem HasFiniteFPowerSeriesOnBall.fderiv' (h : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesOnBall (fderiv ğ•œ f) p.derivSeries x (n - 1) r := by\n  obtain rfl | hn := eq_or_ne n 0\n  Â· rw [zero_tsub]\n    refine HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero (fun y hy â†¦ ?_) h.r_pos fun n â†¦ ?_\n    Â· rw [Filter.EventuallyEq.fderiv_eq (f := fun _ â†¦ 0)]\n      Â· rw [fderiv_const, Pi.zero_apply]\n      Â· exact Filter.eventuallyEq_iff_exists_mem.mpr âŸ¨EMetric.ball x r,\n          EMetric.isOpen_ball.mem_nhds hy, fun z hz â†¦ by rw [h.eq_zero_of_bound_zero z hz]âŸ©\n    Â· apply ContinuousMultilinearMap.ext; intro a\n      change (continuousMultilinearCurryFin1 ğ•œ E F) (p.changeOriginSeries 1 n a) = 0\n      rw [p.changeOriginSeries_finite_of_finite h.finite 1 (Nat.zero_le _)]\n      exact map_zero _\n  Â· rw [â† Nat.succ_pred hn] at h\n    exact h.fderiv\n\n"}
{"name":"CPolynomialOn.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : CPolynomialOn ğ•œ f s\nâŠ¢ CPolynomialOn ğ•œ (fderiv ğ•œ f) s","decl":"/-- If a function is polynomial on a set `s`, so is its FrÃ©chet derivative. -/\ntheorem CPolynomialOn.fderiv (h : CPolynomialOn ğ•œ f s) :\n    CPolynomialOn ğ•œ (fderiv ğ•œ f) s := by\n  intro y hy\n  rcases h y hy with âŸ¨p, r, n, hpâŸ©\n  exact hp.fderiv'.cPolynomialAt\n\n"}
{"name":"CPolynomialOn.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : CPolynomialOn ğ•œ f s\nn : Nat\nâŠ¢ CPolynomialOn ğ•œ (iteratedFDeriv ğ•œ n f) s","decl":"/-- If a function is polynomial on a set `s`, so are its successive FrÃ©chet derivative. -/\ntheorem CPolynomialOn.iteratedFDeriv (h : CPolynomialOn ğ•œ f s) (n : â„•) :\n    CPolynomialOn ğ•œ (iteratedFDeriv ğ•œ n f) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDeriv_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 ğ•œ E F).symm : F â†’L[ğ•œ] E[Ã—0]â†’L[ğ•œ] F).comp_cPolynomialOn h\n  | succ n IH =>\n    rw [iteratedFDeriv_succ_eq_comp_left]\n    convert ContinuousLinearMap.comp_cPolynomialOn ?g IH.fderiv\n    case g => exact â†‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) â†¦ E) F).symm\n    simp\n\n"}
{"name":"CPolynomialOn.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nh : CPolynomialOn ğ•œ f s\nâŠ¢ CPolynomialOn ğ•œ (deriv f) s","decl":"/-- If a function is polynomial on a set `s`, so is its derivative. -/\nprotected theorem CPolynomialOn.deriv (h : CPolynomialOn ğ•œ f s) : CPolynomialOn ğ•œ (deriv f) s :=\n  (ContinuousLinearMap.apply ğ•œ F (1 : ğ•œ)).comp_cPolynomialOn h.fderiv\n\n"}
{"name":"CPolynomialOn.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nh : CPolynomialOn ğ•œ f s\nn : Nat\nâŠ¢ CPolynomialOn ğ•œ (Nat.iterate deriv n f) s","decl":"/-- If a function is polynomial on a set `s`, so are its successive derivatives. -/\ntheorem CPolynomialOn.iterated_deriv (h : CPolynomialOn ğ•œ f s) (n : â„•) :\n    CPolynomialOn ğ•œ (deriv^[n] f) s := by\n  induction n with\n  | zero => exact h\n  | succ n IH => simpa only [Function.iterate_succ', Function.comp_apply] using IH.deriv\n\n"}
{"name":"ContinuousMultilinearMap.changeOriginSeries_support","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nk l : Nat\nh : Ne (HAdd.hAdd k l) (Fintype.card Î¹)\nâŠ¢ Eq (f.toFormalMultilinearSeries.changeOriginSeries k l) 0","decl":"theorem changeOriginSeries_support {k l : â„•} (h : k + l â‰  Fintype.card Î¹) :\n    f.toFormalMultilinearSeries.changeOriginSeries k l = 0 :=\n  Finset.sum_eq_zero fun _ _ â†¦ by\n    simp_rw [FormalMultilinearSeries.changeOriginSeriesTerm,\n      toFormalMultilinearSeries, dif_neg h.symm, LinearIsometryEquiv.map_zero]\n\n"}
{"name":"ContinuousMultilinearMap.changeOrigin_toFormalMultilinearSeries","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nx : (i : Î¹) â†’ E i\ninstâœ : DecidableEq Î¹\nâŠ¢ Eq ((continuousMultilinearCurryFin1 ğ•œ ((i : Î¹) â†’ E i) F) (f.toFormalMultilinearSeries.changeOrigin x 1)) (f.linearDeriv x)","decl":"open Finset in\ntheorem changeOrigin_toFormalMultilinearSeries [DecidableEq Î¹] :\n    continuousMultilinearCurryFin1 ğ•œ (âˆ€ i, E i) F (f.toFormalMultilinearSeries.changeOrigin x 1) =\n    f.linearDeriv x := by\n  ext y\n  rw [continuousMultilinearCurryFin1_apply, linearDeriv_apply,\n      changeOrigin, FormalMultilinearSeries.sum]\n  cases isEmpty_or_nonempty Î¹\n  Â· have (l) : 1 + l â‰  Fintype.card Î¹ := by\n      rw [add_comm, Fintype.card_eq_zero]; exact Nat.succ_ne_zero _\n    simp_rw [Fintype.sum_empty, changeOriginSeries_support _ (this _), zero_apply _, tsum_zero]; rfl\n  rw [tsum_eq_single (Fintype.card Î¹ - 1), changeOriginSeries]; swap\n  Â· intro m hm\n    rw [Ne, eq_tsub_iff_add_eq_of_le (by exact Fintype.card_pos), add_comm] at hm\n    rw [f.changeOriginSeries_support hm, zero_apply]\n  rw [sum_apply, ContinuousMultilinearMap.sum_apply, Fin.snoc_zero]\n  simp_rw [changeOriginSeriesTerm_apply]\n  refine (Fintype.sum_bijective (?_ âˆ˜ Fintype.equivFinOfCardEq (Nat.add_sub_of_le\n    Fintype.card_pos).symm) (.comp ?_ <| Equiv.bijective _) _ _ fun i â†¦ ?_).symm\n  Â· exact (âŸ¨{Â·}á¶œ, by\n      rw [card_compl, Fintype.card_fin, Finset.card_singleton, Nat.add_sub_cancel_left]âŸ©)\n  Â· use fun _ _ â†¦ (singleton_injective <| compl_injective <| Subtype.ext_iff.mp Â·)\n    intro âŸ¨s, hsâŸ©\n    have h : #sá¶œ = 1 := by rw [card_compl, hs, Fintype.card_fin, Nat.add_sub_cancel]\n    obtain âŸ¨a, haâŸ© := card_eq_one.mp h\n    exact âŸ¨a, Subtype.ext (compl_eq_comm.mp ha)âŸ©\n  rw [Function.comp_apply, Subtype.coe_mk, compl_singleton, piecewise_erase_univ,\n    toFormalMultilinearSeries, dif_pos (Nat.add_sub_of_le Fintype.card_pos).symm]\n  simp_rw [domDomCongr_apply, compContinuousLinearMap_apply, ContinuousLinearMap.proj_apply,\n    Function.update_apply, (Equiv.injective _).eq_iff, ite_apply]\n  congr; ext j\n  obtain rfl | hj := eq_or_ne j i\n  Â· rw [Function.update_self, if_pos rfl]\n  Â· rw [Function.update_of_ne hj, if_neg hj]\n\n"}
{"name":"ContinuousMultilinearMap.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nx : (i : Î¹) â†’ E i\ninstâœ : DecidableEq Î¹\nâŠ¢ HasFDerivAt (â‡‘f) (f.linearDeriv x) x","decl":"protected theorem hasFDerivAt [DecidableEq Î¹] : HasFDerivAt f (f.linearDeriv x) x := by\n  rw [â† changeOrigin_toFormalMultilinearSeries]\n  convert f.hasFiniteFPowerSeriesOnBall.hasFDerivAt (y := x) ENNReal.coe_lt_top\n  rw [zero_add]\n\n"}
{"name":"HasFDerivWithinAt.multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœâµ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\ninstâœÂ² : DecidableEq Î¹\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : (i : Î¹) â†’ G â†’ E i\ng' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) G (E i)\ns : Set G\nx : G\nhg : âˆ€ (i : Î¹), HasFDerivWithinAt (g i) (g' i) s x\nâŠ¢ HasFDerivWithinAt (fun x => f fun i => g i x) (Finset.univ.sum fun i => (f.toContinuousLinearMap (fun j => g j x) i).comp (g' i)) s x","decl":"/-- Given `f` a multilinear map, then the derivative of `x â†¦ f (gâ‚ x, ..., gâ‚™ x)` at `x` applied\nto a vector `v` is given by `âˆ‘ i, f (gâ‚ x, ..., g'áµ¢ v, ..., gâ‚™ x)`. Version inside a set. -/\ntheorem _root_.HasFDerivWithinAt.multilinear_comp\n    [DecidableEq Î¹] {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    {g : âˆ€ i, G â†’ E i} {g' : âˆ€ i, G â†’L[ğ•œ] E i} {s : Set G} {x : G}\n    (hg : âˆ€ i, HasFDerivWithinAt (g i) (g' i) s x) :\n    HasFDerivWithinAt (fun x â†¦ f (fun i â†¦ g i x))\n      ((âˆ‘ i : Î¹, (f.toContinuousLinearMap (fun j â†¦ g j x) i) âˆ˜L (g' i))) s x := by\n  convert (f.hasFDerivAt (fun j â†¦ g j x)).comp_hasFDerivWithinAt x (hasFDerivWithinAt_pi.2 hg)\n  ext v\n  simp [linearDeriv]\n\n"}
{"name":"HasFDerivAt.multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœâµ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\ninstâœÂ² : DecidableEq Î¹\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : (i : Î¹) â†’ G â†’ E i\ng' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) G (E i)\nx : G\nhg : âˆ€ (i : Î¹), HasFDerivAt (g i) (g' i) x\nâŠ¢ HasFDerivAt (fun x => f fun i => g i x) (Finset.univ.sum fun i => (f.toContinuousLinearMap (fun j => g j x) i).comp (g' i)) x","decl":"/-- Given `f` a multilinear map, then the derivative of `x â†¦ f (gâ‚ x, ..., gâ‚™ x)` at `x` applied\nto a vector `v` is given by `âˆ‘ i, f (gâ‚ x, ..., g'áµ¢ v, ..., gâ‚™ x)`. -/\ntheorem _root_.HasFDerivAt.multilinear_comp\n    [DecidableEq Î¹] {G : Type*} [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    {g : âˆ€ i, G â†’ E i} {g' : âˆ€ i, G â†’L[ğ•œ] E i} {x : G}\n    (hg : âˆ€ i, HasFDerivAt (g i) (g' i) x) :\n    HasFDerivAt (fun x â†¦ f (fun i â†¦ g i x))\n      ((âˆ‘ i : Î¹, (f.toContinuousLinearMap (fun j â†¦ g j x) i) âˆ˜L (g' i))) x := by\n  convert (f.hasFDerivAt (fun j â†¦ g j x)).comp x (hasFDerivAt_pi.2 hg)\n  ext v\n  simp [linearDeriv]\n\n"}
{"name":"ContinuousMultilinearMap.hasFTaylorSeriesUpTo_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ HasFTaylorSeriesUpTo Top.top â‡‘f fun v n => f.iteratedFDeriv n v","decl":"/-- A continuous multilinear function `f` admits a Taylor series, whose successive terms are given\nby `f.iteratedFDeriv n`. This is the point of the definition of `f.iteratedFDeriv`. -/\ntheorem hasFTaylorSeriesUpTo_iteratedFDeriv :\n    HasFTaylorSeriesUpTo âŠ¤ f (fun v n â†¦ f.iteratedFDeriv n v) := by\n  classical\n  constructor\n  Â· simp [ContinuousMultilinearMap.iteratedFDeriv]\n  Â· rintro n - x\n    suffices H : curryLeft (f.iteratedFDeriv (Nat.succ n) x) = (âˆ‘ e : Fin n â†ª Î¹,\n          ((iteratedFDerivComponent f e.toEquivRange).linearDeriv\n            (Pi.compRightL ğ•œ _ Subtype.val x)) âˆ˜L (Pi.compRightL ğ•œ _ Subtype.val)) by\n      have A : HasFDerivAt (f.iteratedFDeriv n) (âˆ‘ e : Fin n â†ª Î¹,\n          ((iteratedFDerivComponent f e.toEquivRange).linearDeriv (Pi.compRightL ğ•œ _ Subtype.val x))\n            âˆ˜L (Pi.compRightL ğ•œ _ Subtype.val)) x := by\n        apply HasFDerivAt.sum (fun s _hs â†¦ ?_)\n        exact (ContinuousMultilinearMap.hasFDerivAt _ _).comp x (ContinuousLinearMap.hasFDerivAt _)\n      rwa [â† H] at A\n    ext v m\n    simp only [ContinuousMultilinearMap.iteratedFDeriv, curryLeft_apply, sum_apply,\n      iteratedFDerivComponent_apply, Finset.univ_sigma_univ,\n      Pi.compRightL_apply, ContinuousLinearMap.coe_sum', ContinuousLinearMap.coe_comp',\n      Finset.sum_apply, Function.comp_apply, linearDeriv_apply, Finset.sum_sigma']\n    rw [â† (Equiv.embeddingFinSucc n Î¹).sum_comp]\n    congr with e\n    congr with k\n    by_cases hke : k âˆˆ Set.range e\n    Â· simp only [hke, â†“reduceDIte]\n      split_ifs with hkf\n      Â· simp only [â† Equiv.succ_embeddingFinSucc_fst_symm_apply e hkf hke, Fin.cons_succ]\n      Â· obtain rfl : k = e 0 := by\n          rcases hke with âŸ¨j, rflâŸ©\n          simpa using hkf\n        simp only [Function.Embedding.toEquivRange_symm_apply_self, Fin.cons_zero, Function.update,\n          Pi.compRightL_apply]\n        split_ifs with h\n        Â· congr!\n        Â· exfalso\n          apply h\n          simp_rw [â† Equiv.embeddingFinSucc_snd e]\n    Â· have hkf : k âˆ‰ Set.range (Equiv.embeddingFinSucc n Î¹ e).1 := by\n        contrapose! hke\n        rw [Equiv.embeddingFinSucc_fst] at hke\n        exact Set.range_comp_subset_range _ _ hke\n      simp only [hke, hkf, â†“reduceDIte, Pi.compRightL,\n        ContinuousLinearMap.coe_mk', LinearMap.coe_mk, AddHom.coe_mk]\n      rw [Function.update_of_ne]\n      contrapose! hke\n      rw [show k = _ from Subtype.ext_iff_val.1 hke, Equiv.embeddingFinSucc_snd e]\n      exact Set.mem_range_self _\n  Â· rintro n -\n    apply continuous_finset_sum _ (fun e _ â†¦ ?_)\n    exact (ContinuousMultilinearMap.coe_continuous _).comp (ContinuousLinearMap.continuous _)\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDeriv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nn : Nat\nâŠ¢ Eq (iteratedFDeriv ğ•œ n â‡‘f) (f.iteratedFDeriv n)","decl":"theorem iteratedFDeriv_eq (n : â„•) :\n    iteratedFDeriv ğ•œ n f = f.iteratedFDeriv n :=\n  funext fun x â†¦ (f.hasFTaylorSeriesUpTo_iteratedFDeriv.eq_iteratedFDeriv (m := n) le_top x).symm\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDeriv_le","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nn : Nat\nx : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (iteratedFDeriv ğ•œ n (â‡‘f) x)) (HMul.hMul (HMul.hMul (â†‘((Fintype.card Î¹).descFactorial n)) (Norm.norm f)) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card Î¹) n)))","decl":"theorem norm_iteratedFDeriv_le (n : â„•) (x : (i : Î¹) â†’ E i) :\n    â€–iteratedFDeriv ğ•œ n f xâ€–\n      â‰¤ Nat.descFactorial (Fintype.card Î¹) n * â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - n) := by\n  rw [f.iteratedFDeriv_eq]\n  exact f.norm_iteratedFDeriv_le' n x\n\n"}
{"name":"ContinuousMultilinearMap.cPolynomialAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nx : (i : Î¹) â†’ E i\nâŠ¢ CPolynomialAt ğ•œ (â‡‘f) x","decl":"lemma cPolynomialAt : CPolynomialAt ğ•œ f x :=\n  f.hasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousMultilinearMap.cPolyomialOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ CPolynomialOn ğ•œ (â‡‘f) Top.top","decl":"lemma cPolyomialOn : CPolynomialOn ğ•œ f âŠ¤ := fun x _ â†¦ f.cPolynomialAt x\n\n"}
{"name":"FormalMultilinearSeries.derivSeries_apply_diag","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nx : E\nâŠ¢ Eq (((p.derivSeries n) fun x_1 => x) x) (HSMul.hSMul (HAdd.hAdd n 1) ((p (HAdd.hAdd n 1)) fun x_1 => x))","decl":"open Fintype ContinuousLinearMap in\ntheorem derivSeries_apply_diag (n : â„•) (x : E) :\n    derivSeries p n (fun _ â†¦ x) x = (n + 1) â€¢ p (n + 1) fun _ â†¦ x := by\n  simp only [derivSeries, compFormalMultilinearSeries_apply, changeOriginSeries,\n    compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe, LinearIsometryEquiv.coe_coe,\n    Function.comp_apply, ContinuousMultilinearMap.sum_apply, map_sum, coe_sum', Finset.sum_apply,\n    continuousMultilinearCurryFin1_apply, Matrix.zero_empty]\n  convert Finset.sum_const _\n  Â· rw [Fin.snoc_zero, changeOriginSeriesTerm_apply, Finset.piecewise_same, add_comm]\n  Â· rw [â† card, card_subtype, â† Finset.powerset_univ, â† Finset.powersetCard_eq_filter,\n      Finset.card_powersetCard, â† card, card_fin, eq_comm, add_comm, Nat.choose_succ_self_right]\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_zero_apply_diag","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\nâŠ¢ Eq (iteratedFDeriv ğ•œ 0 f x) (p 0)","decl":"include h in\ntheorem iteratedFDeriv_zero_apply_diag : iteratedFDeriv ğ•œ 0 f x = p 0 := by\n  ext\n  convert (h.hasSum <| EMetric.mem_ball_self h.r_pos).tsum_eq.symm\n  Â· rw [iteratedFDeriv_zero_apply, add_zero]\n  Â· rw [tsum_eq_single 0 fun n hn â†¦ by haveI := NeZero.mk hn; exact (p n).map_zero]\n    exact congr(p 0 $(Subsingleton.elim _ _))\n\n"}
{"name":"HasFPowerSeriesOnBall.factorial_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ny : E\ninstâœ : CompleteSpace F\nn : Nat\nâŠ¢ Eq (HSMul.hSMul n.factorial ((p n) fun x => y)) ((iteratedFDeriv ğ•œ n f x) fun x => y)","decl":"/-- The iterated derivative of an analytic function, on vectors `(y, ..., y)`, is given by `n!`\ntimes the `n`-th term in the power series. For a more general result giving the full iterated\nderivative as a sum over the permutations of `Fin n`, see\n`HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum`. -/\ntheorem factorial_smul (n : â„•) :\n    n ! â€¢ p n (fun _ â†¦ y) = iteratedFDeriv ğ•œ n f x (fun _ â†¦ y) := by\n  cases n\n  Â· rw [factorial_zero, one_smul, h.iteratedFDeriv_zero_apply_diag]\n  Â· rw [factorial_succ, mul_comm, mul_smul, â† derivSeries_apply_diag,\n      â† ContinuousLinearMap.smul_apply, factorial_smul' _ h.fderiv, iteratedFDeriv_succ_apply_right]\n    rfl\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nf : E â†’ F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CharZero ğ•œ\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ HasSum (fun n => HSMul.hSMul (Inv.inv â†‘n.factorial) ((iteratedFDeriv ğ•œ n f x) fun x => y)) (f (HAdd.hAdd x y))","decl":"theorem hasSum_iteratedFDeriv [CharZero ğ•œ] {y : E} (hy : y âˆˆ EMetric.ball 0 r) :\n    HasSum (fun n â†¦ (n ! : ğ•œ)â»Â¹ â€¢ iteratedFDeriv ğ•œ n f x fun _ â†¦ y) (f (x + y)) := by\n  convert h.hasSum hy with n\n  rw [â† h.factorial_smul y n, smul_comm, â† smul_assoc, nsmul_eq_mul,\n    mul_inv_cancelâ‚€ <| cast_ne_zero.mpr n.factorial_ne_zero, one_smul]\n\n"}
{"name":"ContinuousLinearMap.hasFDerivAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nG : Î¹ â†’ Type u_3\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (G i)\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ G F)\nv : Prod E ((i : Î¹) â†’ G i)\nâŠ¢ HasFDerivAt (fun p => (f p.1) p.2) (HAdd.hAdd ((f.flipMultilinear v.2).comp (ContinuousLinearMap.fst ğ•œ E ((i : Î¹) â†’ G i))) (Finset.univ.sum fun i => ((f v.1).toContinuousLinearMap v.2 i).comp ((ContinuousLinearMap.proj i).comp (ContinuousLinearMap.snd ğ•œ E ((i : Î¹) â†’ G i))))) v","decl":"theorem hasFDerivAt_uncurry_of_multilinear [DecidableEq Î¹]\n    (f : E â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ G F) (v : E Ã— Î  i, G i) :\n    HasFDerivAt (fun (p : E Ã— Î  i, G i) â†¦ f p.1 p.2)\n      ((f.flipMultilinear v.2) âˆ˜L (.fst _ _ _) +\n        âˆ‘ i : Î¹, ((f v.1).toContinuousLinearMap v.2 i) âˆ˜L (.proj _) âˆ˜L (.snd _ _ _)) v := by\n  convert HasFDerivAt.multilinear_comp (f.continuousMultilinearMapOption)\n    (g := fun (_ : Option Î¹) p â†¦ p) (g' := fun _ â†¦ ContinuousLinearMap.id _ _) (x := v)\n    (fun _ â†¦ hasFDerivAt_id _)\n  have I : f.continuousMultilinearMapOption.toContinuousLinearMap (fun _ â†¦ v) none =\n      (f.flipMultilinear v.2) âˆ˜L (.fst _ _ _) := by\n    simp [ContinuousMultilinearMap.toContinuousLinearMap, continuousMultilinearMapOption]\n    apply ContinuousLinearMap.ext (fun w â†¦ ?_)\n    simp\n  have J : âˆ€ (i : Î¹), f.continuousMultilinearMapOption.toContinuousLinearMap (fun _ â†¦ v) (some i)\n      = ((f v.1).toContinuousLinearMap v.2 i) âˆ˜L (.proj _) âˆ˜L (.snd _ _ _) := by\n    intro i\n    apply ContinuousLinearMap.ext (fun w â†¦ ?_)\n    simp only [ContinuousMultilinearMap.toContinuousLinearMap, continuousMultilinearMapOption,\n      coe_mk', MultilinearMap.toLinearMap_apply, ContinuousMultilinearMap.coe_coe,\n      MultilinearMap.coe_mkContinuous, MultilinearMap.coe_mk, ne_eq, reduceCtorEq,\n      not_false_eq_true, Function.update_of_ne, coe_comp', coe_snd', Function.comp_apply,\n      proj_apply]\n    congr\n    ext j\n    rcases eq_or_ne j i with rfl | hij\n    Â· simp\n    Â· simp [hij]\n  simp [I, J]\n\n"}
{"name":"HasFDerivWithinAt.linear_multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type v\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nG : Î¹ â†’ Type u_3\ninstâœâµ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (G i)\ninstâœÂ³ : Fintype Î¹\nH : Type u_4\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : NormedSpace ğ•œ H\ninstâœ : DecidableEq Î¹\na : H â†’ E\na' : ContinuousLinearMap (RingHom.id ğ•œ) H E\nb : (i : Î¹) â†’ H â†’ G i\nb' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) H (G i)\ns : Set H\nx : H\nha : HasFDerivWithinAt a a' s x\nhb : âˆ€ (i : Î¹), HasFDerivWithinAt (b i) (b' i) s x\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ G F)\nâŠ¢ HasFDerivWithinAt (fun y => (f (a y)) fun i => b i y) (HAdd.hAdd ((f.flipMultilinear fun i => b i x).comp a') (Finset.univ.sum fun i => ((f (a x)).toContinuousLinearMap (fun j => b j x) i).comp (b' i))) s x","decl":"/-- Given `f` a linear map into multilinear maps, then the derivative\nof `x â†¦ f (a x) (bâ‚ x, ..., bâ‚™ x)` at `x` applied to a vector `v` is given by\n`f (a' v) (bâ‚ x, ...., bâ‚™ x) + âˆ‘ i, f a (bâ‚ x, ..., b'áµ¢ v, ..., bâ‚™ x)`. Version inside a set. -/\ntheorem _root_.HasFDerivWithinAt.linear_multilinear_comp\n    [DecidableEq Î¹] {a : H â†’ E} {a' : H â†’L[ğ•œ] E}\n    {b : âˆ€ i, H â†’ G i} {b' : âˆ€ i, H â†’L[ğ•œ] G i} {s : Set H} {x : H}\n    (ha : HasFDerivWithinAt a a' s x) (hb : âˆ€ i, HasFDerivWithinAt (b i) (b' i) s x)\n    (f : E â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ G F) :\n    HasFDerivWithinAt (fun y â†¦ f (a y) (fun i â†¦ b i y))\n      ((f.flipMultilinear (fun i â†¦ b i x)) âˆ˜L a' +\n        âˆ‘ i, ((f (a x)).toContinuousLinearMap (fun j â†¦ b j x) i) âˆ˜L (b' i)) s x := by\n  convert (hasFDerivAt_uncurry_of_multilinear f (a x, fun i â†¦ b i x)).comp_hasFDerivWithinAt x\n    (ha.prod (hasFDerivWithinAt_pi.mpr hb))\n  ext v\n  simp\n\n"}
{"name":"HasFDerivAt.linear_multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type v\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ¹ : Type u_2\nG : Î¹ â†’ Type u_3\ninstâœâµ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (G i)\ninstâœÂ³ : Fintype Î¹\nH : Type u_4\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : NormedSpace ğ•œ H\ninstâœ : DecidableEq Î¹\na : H â†’ E\na' : ContinuousLinearMap (RingHom.id ğ•œ) H E\nb : (i : Î¹) â†’ H â†’ G i\nb' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) H (G i)\nx : H\nha : HasFDerivAt a a' x\nhb : âˆ€ (i : Î¹), HasFDerivAt (b i) (b' i) x\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousMultilinearMap ğ•œ G F)\nâŠ¢ HasFDerivAt (fun y => (f (a y)) fun i => b i y) (HAdd.hAdd ((f.flipMultilinear fun i => b i x).comp a') (Finset.univ.sum fun i => ((f (a x)).toContinuousLinearMap (fun j => b j x) i).comp (b' i))) x","decl":"/-- Given `f` a linear map into multilinear maps, then the derivative\nof `x â†¦ f (a x) (bâ‚ x, ..., bâ‚™ x)` at `x` applied to a vector `v` is given by\n`f (a' v) (bâ‚ x, ...., bâ‚™ x) + âˆ‘ i, f a (bâ‚ x, ..., b'áµ¢ v, ..., bâ‚™ x)`. -/\ntheorem _root_.HasFDerivAt.linear_multilinear_comp [DecidableEq Î¹] {a : H â†’ E} {a' : H â†’L[ğ•œ] E}\n    {b : âˆ€ i, H â†’ G i} {b' : âˆ€ i, H â†’L[ğ•œ] G i} {x : H}\n    (ha : HasFDerivAt a a' x) (hb : âˆ€ i, HasFDerivAt (b i) (b' i) x)\n    (f : E â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ G F) :\n    HasFDerivAt (fun y â†¦ f (a y) (fun i â†¦ b i y))\n      ((f.flipMultilinear (fun i â†¦ b i x)) âˆ˜L a' +\n        âˆ‘ i, ((f (a x)).toContinuousLinearMap (fun j â†¦ b j x) i) âˆ˜L (b' i)) x := by\n  simp_rw [â† hasFDerivWithinAt_univ] at ha hb âŠ¢\n  exact HasFDerivWithinAt.linear_multilinear_comp ha hb f\n\n"}
