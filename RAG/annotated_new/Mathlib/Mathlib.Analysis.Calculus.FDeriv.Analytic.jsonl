{"name":"HasFPowerSeriesWithinAt.hasStrictFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\n⊢ Asymptotics.IsLittleO (nhdsWithin { fst := x, snd := x } (SProd.sprod (Insert.insert x s) (Insert.insert x s))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) (((continuousMultilinearCurryFin1 𝕜 E F) (p 1)) (HSub.hSub y.1 y.2))) fun y => HSub.hSub y.1 y.2","decl":"/-- A function which is analytic within a set is strictly differentiable there. Since we\ndon't have a predicate `HasStrictFDerivWithinAt`, we spell out what it would mean. -/\ntheorem HasFPowerSeriesWithinAt.hasStrictFDerivWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    (fun y ↦ f y.1 - f y.2 - (continuousMultilinearCurryFin1 𝕜 E F (p 1)) (y.1 - y.2))\n      =o[𝓝[insert x s ×ˢ insert x s] (x, x)] fun y ↦ y.1 - y.2 := by\n  refine h.isBigO_image_sub_norm_mul_norm_sub.trans_isLittleO (IsLittleO.of_norm_right ?_)\n  refine isLittleO_iff_exists_eq_mul.2 ⟨fun y => ‖y - (x, x)‖, ?_, EventuallyEq.rfl⟩\n  apply Tendsto.mono_left _ nhdsWithin_le_nhds\n  refine (continuous_id.sub continuous_const).norm.tendsto' _ _ ?_\n  rw [_root_.id, sub_self, norm_zero]\n\n"}
{"name":"HasFPowerSeriesAt.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nh : HasFPowerSeriesAt f p x\n⊢ HasStrictFDerivAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p 1)) x","decl":"theorem HasFPowerSeriesAt.hasStrictFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictFDerivAt f (continuousMultilinearCurryFin1 𝕜 E F (p 1)) x := by\n  simpa only [hasStrictFDerivAt_iff_isLittleO, Set.insert_eq_of_mem, Set.mem_univ,\n      Set.univ_prod_univ, nhdsWithin_univ]\n    using (h.hasFPowerSeriesWithinAt (s := Set.univ)).hasStrictFDerivWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\n⊢ HasFDerivWithinAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p 1)) (Insert.insert x s) x","decl":"theorem HasFPowerSeriesWithinAt.hasFDerivWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    HasFDerivWithinAt f (continuousMultilinearCurryFin1 𝕜 E F (p 1)) (insert x s) x := by\n  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff]\n  intro c hc\n  have : Tendsto (fun y ↦ (y, x)) (𝓝[insert x s] x) (𝓝[insert x s ×ˢ insert x s] (x, x)) := by\n    rw [nhdsWithin_prod_eq]\n    exact Tendsto.prod_mk tendsto_id (tendsto_const_nhdsWithin (by simp))\n  exact this (isLittleO_iff.1 h.hasStrictFDerivWithinAt hc)\n\n"}
{"name":"HasFPowerSeriesAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nh : HasFPowerSeriesAt f p x\n⊢ HasFDerivAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p 1)) x","decl":"theorem HasFPowerSeriesAt.hasFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 𝕜 E F (p 1)) x :=\n  h.hasStrictFDerivAt.hasFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert x s) x","decl":"theorem HasFPowerSeriesWithinAt.differentiableWithinAt (h : HasFPowerSeriesWithinAt f p s x) :\n    DifferentiableWithinAt 𝕜 f (insert x s) x :=\n  h.hasFDerivWithinAt.differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nh : HasFPowerSeriesAt f p x\n⊢ DifferentiableAt 𝕜 f x","decl":"theorem HasFPowerSeriesAt.differentiableAt (h : HasFPowerSeriesAt f p x) : DifferentiableAt 𝕜 f x :=\n  h.hasFDerivAt.differentiableAt\n\n"}
{"name":"AnalyticWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : AnalyticWithinAt 𝕜 f s x\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert x s) x","decl":"theorem AnalyticWithinAt.differentiableWithinAt (h : AnalyticWithinAt 𝕜 f s x) :\n    DifferentiableWithinAt 𝕜 f (insert x s) x := by\n  obtain ⟨p, hp⟩ := h\n  exact hp.differentiableWithinAt\n\n"}
{"name":"AnalyticAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\na✝ : AnalyticAt 𝕜 f x\n⊢ DifferentiableAt 𝕜 f x","decl":"@[fun_prop]\ntheorem AnalyticAt.differentiableAt : AnalyticAt 𝕜 f x → DifferentiableAt 𝕜 f x\n  | ⟨_, hp⟩ => hp.differentiableAt\n\n"}
{"name":"AnalyticAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : AnalyticAt 𝕜 f x\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"theorem AnalyticAt.differentiableWithinAt (h : AnalyticAt 𝕜 f x) : DifferentiableWithinAt 𝕜 f s x :=\n  h.differentiableAt.differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinAt.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinAt f p s x\nhu : UniqueDiffWithinAt 𝕜 (Insert.insert x s) x\n⊢ Eq (fderivWithin 𝕜 f (Insert.insert x s) x) ((continuousMultilinearCurryFin1 𝕜 E F) (p 1))","decl":"theorem HasFPowerSeriesWithinAt.fderivWithin_eq\n    (h : HasFPowerSeriesWithinAt f p s x) (hu : UniqueDiffWithinAt 𝕜 (insert x s) x) :\n    fderivWithin 𝕜 f (insert x s) x = continuousMultilinearCurryFin1 𝕜 E F (p 1) :=\n  h.hasFDerivWithinAt.fderivWithin hu\n\n"}
{"name":"HasFPowerSeriesAt.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nh : HasFPowerSeriesAt f p x\n⊢ Eq (fderiv 𝕜 f x) ((continuousMultilinearCurryFin1 𝕜 E F) (p 1))","decl":"theorem HasFPowerSeriesAt.fderiv_eq (h : HasFPowerSeriesAt f p x) :\n    fderiv 𝕜 f x = continuousMultilinearCurryFin1 𝕜 E F (p 1) :=\n  h.hasFDerivAt.fderiv\n\n"}
{"name":"AnalyticAt.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : AnalyticAt 𝕜 f x\n⊢ HasStrictFDerivAt f (fderiv 𝕜 f x) x","decl":"theorem AnalyticAt.hasStrictFDerivAt (h : AnalyticAt 𝕜 f x) :\n    HasStrictFDerivAt f (fderiv 𝕜 f x) x := by\n  rcases h with ⟨p, hp⟩\n  rw [hp.fderiv_eq]\n  exact hp.hasStrictFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\n⊢ DifferentiableOn 𝕜 f (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"theorem HasFPowerSeriesWithinOnBall.differentiableOn [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) :\n    DifferentiableOn 𝕜 f (insert x s ∩ EMetric.ball x r) := by\n  intro y hy\n  have Z := (h.analyticWithinAt_of_mem hy).differentiableWithinAt\n  rcases eq_or_ne y x with rfl | hy\n  · exact Z.mono inter_subset_left\n  · apply (Z.mono (subset_insert _ _)).mono_of_mem_nhdsWithin\n    suffices s ∈ 𝓝[insert x s] y from nhdsWithin_mono _ inter_subset_left this\n    rw [nhdsWithin_insert_of_ne hy]\n    exact self_mem_nhdsWithin\n\n"}
{"name":"HasFPowerSeriesOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\n⊢ DifferentiableOn 𝕜 f (EMetric.ball x r)","decl":"theorem HasFPowerSeriesOnBall.differentiableOn [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) : DifferentiableOn 𝕜 f (EMetric.ball x r) := fun _ hy =>\n  (h.analyticAt_of_mem hy).differentiableWithinAt\n\n"}
{"name":"AnalyticOn.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\n⊢ DifferentiableOn 𝕜 f s","decl":"theorem AnalyticOn.differentiableOn (h : AnalyticOn 𝕜 f s) : DifferentiableOn 𝕜 f s :=\n  fun y hy ↦ (h y hy).differentiableWithinAt.mono (by simp)\n\n"}
{"name":"AnalyticOnNhd.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOnNhd 𝕜 f s\n⊢ DifferentiableOn 𝕜 f s","decl":"theorem AnalyticOnNhd.differentiableOn (h : AnalyticOnNhd 𝕜 f s) : DifferentiableOn 𝕜 f s :=\n  fun y hy ↦ (h y hy).differentiableWithinAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\n⊢ HasFDerivWithinAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1)) (Insert.insert x s) (HAdd.hAdd x y)","decl":"theorem HasFPowerSeriesWithinOnBall.hasFDerivWithinAt [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) (h'y : x + y ∈ insert x s) :\n    HasFDerivWithinAt f (continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1))\n      (insert x s) (x + y) := by\n  rcases eq_or_ne y 0 with rfl | h''y\n  · convert (h.changeOrigin hy h'y).hasFPowerSeriesWithinAt.hasFDerivWithinAt\n    simp\n  · have Z := (h.changeOrigin hy h'y).hasFPowerSeriesWithinAt.hasFDerivWithinAt\n    apply (Z.mono (subset_insert _ _)).mono_of_mem_nhdsWithin\n    rw [nhdsWithin_insert_of_ne]\n    · exact self_mem_nhdsWithin\n    · simpa using h''y\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\n⊢ HasFDerivAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1)) (HAdd.hAdd x y)","decl":"theorem HasFPowerSeriesOnBall.hasFDerivAt [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1)) (x + y) :=\n  (h.changeOrigin hy).hasFPowerSeriesAt.hasFDerivAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhu : UniqueDiffOn 𝕜 (Insert.insert x s)\n⊢ Eq (fderivWithin 𝕜 f (Insert.insert x s) (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1))","decl":"theorem HasFPowerSeriesWithinOnBall.fderivWithin_eq [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) (h'y : x + y ∈ insert x s) (hu : UniqueDiffOn 𝕜 (insert x s)) :\n    fderivWithin 𝕜 f (insert x s) (x + y) =\n      continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1) :=\n  (h.hasFDerivWithinAt hy h'y).fderivWithin (hu _ h'y)\n\n"}
{"name":"HasFPowerSeriesOnBall.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\n⊢ Eq (fderiv 𝕜 f (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1))","decl":"theorem HasFPowerSeriesOnBall.fderiv_eq [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) :\n    fderiv 𝕜 f (x + y) = continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1) :=\n  (h.hasFDerivAt hy).fderiv\n\n"}
{"name":"HasFPowerSeriesOnBall.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesOnBall f p x r\n⊢ HasFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x r","decl":"/-- If a function has a power series on a ball, then so does its derivative. -/\nprotected theorem HasFPowerSeriesOnBall.fderiv [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x r := by\n  refine .congr (f := fun z ↦ continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin (z - x) 1)) ?_\n    fun z hz ↦ ?_\n  · refine continuousMultilinearCurryFin1 𝕜 E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesOnBall ?_\n    simpa using ((p.hasFPowerSeriesOnBall_changeOrigin 1\n      (h.r_pos.trans_le h.r_le)).mono h.r_pos h.r_le).comp_sub x\n  dsimp only\n  rw [← h.fderiv_eq, add_sub_cancel]\n  simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn 𝕜 (Insert.insert x s)\n⊢ HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f (Insert.insert x s)) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (hu : UniqueDiffOn 𝕜 (insert x s)) :\n    HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f (insert x s)) p.derivSeries s x r := by\n  refine .congr' (f := fun z ↦ continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin (z - x) 1)) ?_\n    (fun z hz ↦ ?_)\n  · refine continuousMultilinearCurryFin1 𝕜 E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall ?_\n    apply HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall\n    simpa using ((p.hasFPowerSeriesOnBall_changeOrigin 1\n      (h.r_pos.trans_le h.r_le)).mono h.r_pos h.r_le).comp_sub x\n  · dsimp only\n    rw [← h.fderivWithin_eq _ _ hu, add_sub_cancel]\n    · simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz.2\n    · simpa using hz.1\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f s) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. For a\nversion without completeness, but assuming that the function is analytic on the set `s`, see\n`HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn`. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin_of_mem [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f s) p.derivSeries s x r := by\n  have : insert x s = s := insert_eq_of_mem hx\n  rw [← this] at hu\n  convert h.fderivWithin hu\n  exact this.symm\n\n"}
{"name":"AnalyticAt.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nx : E\ninst✝ : CompleteSpace F\nh : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (fderiv 𝕜 f) x","decl":"/-- If a function is analytic on a set `s`, so is its Fréchet derivative. -/\n@[fun_prop]\nprotected theorem AnalyticAt.fderiv [CompleteSpace F] (h : AnalyticAt 𝕜 f x) :\n    AnalyticAt 𝕜 (fderiv 𝕜 f) x := by\n  rcases h with ⟨p, r, hp⟩\n  exact hp.fderiv.analyticAt\n\n"}
{"name":"AnalyticOnNhd.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fderiv 𝕜 f) s","decl":"/-- If a function is analytic on a set `s`, so is its Fréchet derivative. See also\n`AnalyticOnNhd.fderiv_of_isOpen`, removing the completeness assumption but requiring the set\nto be open. -/\nprotected theorem AnalyticOnNhd.fderiv [CompleteSpace F] (h : AnalyticOnNhd 𝕜 f s) :\n    AnalyticOnNhd 𝕜 (fderiv 𝕜 f) s :=\n  fun y hy ↦ AnalyticAt.fderiv (h y hy)\n\n"}
{"name":"AnalyticOn.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fderiv 𝕜 f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.fderiv := AnalyticOnNhd.fderiv\n\n"}
{"name":"AnalyticOnNhd.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s","decl":"/-- If a function is analytic on a set `s`, so are its successive Fréchet derivative. See also\n`AnalyticOnNhd.iteratedFDeriv_of_isOpen`, removing the completeness assumption but requiring the set\nto be open.-/\nprotected theorem AnalyticOnNhd.iteratedFDeriv [CompleteSpace F] (h : AnalyticOnNhd 𝕜 f s) (n : ℕ) :\n    AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDeriv_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 𝕜 E F).symm : F →L[𝕜] E[×0]→L[𝕜] F).comp_analyticOnNhd h\n  | succ n IH =>\n    rw [iteratedFDeriv_succ_eq_comp_left]\n    -- Porting note: for reasons that I do not understand at all, `?g` cannot be inlined.\n    convert ContinuousLinearMap.comp_analyticOnNhd ?g IH.fderiv\n    case g => exact ↑(continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) ↦ E) F).symm\n    simp\n\n"}
{"name":"AnalyticOn.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nprotected alias AnalyticOn.iteratedFDeriv := AnalyticOnNhd.iteratedFDeriv\n\n"}
{"name":"AnalyticOnNhd.hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ninst✝ : CompleteSpace F\nn : WithTop ENat\nh : AnalyticOnNhd 𝕜 f s\n⊢ HasFTaylorSeriesUpToOn n f (ftaylorSeries 𝕜 f) s","decl":"/-- If a function is analytic on a neighborhood of a set `s`, then it has a Taylor series given\nby the sequence of its derivatives. Note that, if the function were just analytic on `s`, then\none would have to use instead the sequence of derivatives inside the set, as in\n`AnalyticOn.hasFTaylorSeriesUpToOn`. -/\nlemma AnalyticOnNhd.hasFTaylorSeriesUpToOn [CompleteSpace F]\n    (n : WithTop ℕ∞) (h : AnalyticOnNhd 𝕜 f s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeries 𝕜 f) s := by\n  refine ⟨fun x _hx ↦ rfl, fun m _hm x hx ↦ ?_, fun m _hm x hx ↦ ?_⟩\n  · apply HasFDerivAt.hasFDerivWithinAt\n    exact ((h.iteratedFDeriv m x hx).differentiableAt).hasFDerivAt\n  · apply (DifferentiableAt.continuousAt (𝕜 := 𝕜) ?_).continuousWithinAt\n    exact (h.iteratedFDeriv m x hx).differentiableAt\n\n"}
{"name":"AnalyticWithinAt.exists_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\ninst✝ : CompleteSpace F\nn : WithTop ENat\nh : AnalyticWithinAt 𝕜 f s x\n⊢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => And (HasFTaylorSeriesUpToOn n f p u) (∀ (i : Nat), AnalyticOn 𝕜 (fun x => p x i) u))","decl":"lemma AnalyticWithinAt.exists_hasFTaylorSeriesUpToOn [CompleteSpace F]\n    (n : WithTop ℕ∞) (h : AnalyticWithinAt 𝕜 f s x) :\n    ∃ u ∈ 𝓝[insert x s] x, ∃ (p : E → FormalMultilinearSeries 𝕜 E F),\n    HasFTaylorSeriesUpToOn n f p u ∧ ∀ i, AnalyticOn 𝕜 (fun x ↦ p x i) u := by\n  rcases h.exists_analyticAt with ⟨g, -, fg, hg⟩\n  rcases hg.exists_mem_nhds_analyticOnNhd with ⟨v, vx, hv⟩\n  refine ⟨insert x s ∩ v, inter_mem_nhdsWithin _ vx, ftaylorSeries 𝕜 g, ?_, fun i ↦ ?_⟩\n  · suffices HasFTaylorSeriesUpToOn n g (ftaylorSeries 𝕜 g) (insert x s ∩ v) from\n      this.congr (fun y hy ↦ fg hy.1)\n    exact AnalyticOnNhd.hasFTaylorSeriesUpToOn _ (hv.mono Set.inter_subset_right)\n  · exact (hv.iteratedFDeriv i).analyticOn.mono Set.inter_subset_right\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum_derivSeries_of_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\nh : HasFPowerSeriesWithinOnBall f p s x r\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhf' : HasFDerivWithinAt f f' (Insert.insert x s) (HAdd.hAdd x y)\nhu : UniqueDiffOn 𝕜 (Insert.insert x s)\n⊢ HasSum (fun n => (p.derivSeries n) fun x => y) f'","decl":"/-- If a function has a power series `p` within a set of unique differentiability, inside a ball,\nand is differentiable at a point, then the derivative series of `p` is summable at a point, with\nsum the given differential. Note that this theorem does not require completeness of the space.-/\ntheorem HasFPowerSeriesWithinOnBall.hasSum_derivSeries_of_hasFDerivWithinAt\n    (h : HasFPowerSeriesWithinOnBall f p s x r)\n    {f' : E →L[𝕜] F}\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) (h'y : x + y ∈ insert x s)\n    (hf' : HasFDerivWithinAt f f' (insert x s) (x + y))\n    (hu : UniqueDiffOn 𝕜 (insert x s)) :\n    HasSum (fun n ↦ p.derivSeries n (fun _ ↦ y)) f' := by\n  /- In the completion of the space, the derivative series is summable, and its sum is a derivative\n  of the function. Therefore, by uniqueness of derivatives, its sum is the image of `f'` under\n  the canonical embedding. As this is an embedding, it means that there was also convergence in\n  the original space, to `f'`. -/\n  let F' := UniformSpace.Completion F\n  let a : F →L[𝕜] F' := UniformSpace.Completion.toComplL\n  let b : (E →L[𝕜] F) →ₗᵢ[𝕜] (E →L[𝕜] F') := UniformSpace.Completion.toComplₗᵢ.postcomp\n  rw [← b.isEmbedding.hasSum_iff]\n  have : HasFPowerSeriesWithinOnBall (a ∘ f) (a.compFormalMultilinearSeries p) s x r :=\n    a.comp_hasFPowerSeriesWithinOnBall h\n  have Z := (this.fderivWithin hu).hasSum h'y (by simpa [edist_zero_eq_enorm] using hy)\n  have : fderivWithin 𝕜 (a ∘ f) (insert x s) (x + y) = a ∘L f' := by\n    apply HasFDerivWithinAt.fderivWithin _ (hu _ h'y)\n    exact a.hasFDerivAt.comp_hasFDerivWithinAt (x + y) hf'\n  rw [this] at Z\n  convert Z with n\n  ext v\n  simp only [FormalMultilinearSeries.derivSeries,\n    ContinuousLinearMap.compFormalMultilinearSeries_apply,\n    FormalMultilinearSeries.changeOriginSeries,\n    ContinuousLinearMap.compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe,\n    LinearIsometryEquiv.coe_coe, Function.comp_apply, ContinuousMultilinearMap.sum_apply, map_sum,\n    ContinuousLinearMap.coe_sum', Finset.sum_apply,\n    Matrix.zero_empty]\n  rfl\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nf : E → F\nx : E\ns : Set E\nhr : HasFPowerSeriesWithinOnBall f p s x r\nh : AnalyticOn 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f s) p.derivSeries s x r","decl":"/-- If a function has a power series within a set on a ball, then so does its derivative. Version\nassuming that the function is analytic on `s`. For a version without this assumption but requiring\nthat `F` is complete, see `HasFPowerSeriesWithinOnBall.fderivWithin_of_mem`. -/\nprotected theorem HasFPowerSeriesWithinOnBall.fderivWithin_of_mem_of_analyticOn\n    (hr : HasFPowerSeriesWithinOnBall f p s x r)\n    (h : AnalyticOn 𝕜 f s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    HasFPowerSeriesWithinOnBall (fderivWithin 𝕜 f s) p.derivSeries s x r := by\n  refine ⟨hr.r_le.trans p.radius_le_radius_derivSeries, hr.r_pos, fun {y} hy h'y ↦ ?_⟩\n  apply hr.hasSum_derivSeries_of_hasFDerivWithinAt (by simpa [edist_zero_eq_enorm] using h'y) hy\n  · rw [insert_eq_of_mem hx] at hy ⊢\n    apply DifferentiableWithinAt.hasFDerivWithinAt\n    exact h.differentiableOn _ hy\n  · rwa [insert_eq_of_mem hx]\n\n"}
{"name":"AnalyticOn.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\nhu : UniqueDiffOn 𝕜 s\n⊢ AnalyticOn 𝕜 (fderivWithin 𝕜 f s) s","decl":"/-- If a function is analytic within a set with unique differentials, then so is its derivative.\nNote that this theorem does not require completeness of the space. -/\nprotected theorem AnalyticOn.fderivWithin (h : AnalyticOn 𝕜 f s) (hu : UniqueDiffOn 𝕜 s) :\n    AnalyticOn 𝕜 (fderivWithin 𝕜 f s) s := by\n  intro x hx\n  rcases h x hx with ⟨p, r, hr⟩\n  refine ⟨p.derivSeries, r, hr.fderivWithin_of_mem_of_analyticOn h hu hx⟩\n\n"}
{"name":"AnalyticOn.iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\nhu : UniqueDiffOn 𝕜 s\nn : Nat\n⊢ AnalyticOn 𝕜 (iteratedFDerivWithin 𝕜 n f s) s","decl":"/-- If a function is analytic on a set `s`, so are its successive Fréchet derivative within this\nset. Note that this theorem does not require completeness of the space. -/\nprotected theorem AnalyticOn.iteratedFDerivWithin (h : AnalyticOn 𝕜 f s)\n    (hu : UniqueDiffOn 𝕜 s) (n : ℕ) :\n    AnalyticOn 𝕜 (iteratedFDerivWithin 𝕜 n f s) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDerivWithin_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 𝕜 E F).symm : F →L[𝕜] E[×0]→L[𝕜] F)\n      |>.comp_analyticOn h\n  | succ n IH =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left]\n    apply AnalyticOnNhd.comp_analyticOn _ (IH.fderivWithin hu) (mapsTo_univ _ _)\n    apply LinearIsometryEquiv.analyticOnNhd\n\n"}
{"name":"AnalyticOn.hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nn : WithTop ENat\nh : AnalyticOn 𝕜 f s\nhu : UniqueDiffOn 𝕜 s\n⊢ HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin 𝕜 f s) s","decl":"protected lemma AnalyticOn.hasFTaylorSeriesUpToOn {n : WithTop ℕ∞}\n    (h : AnalyticOn 𝕜 f s) (hu : UniqueDiffOn 𝕜 s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin 𝕜 f s) s := by\n  refine ⟨fun x _hx ↦ rfl, fun m _hm x hx ↦ ?_, fun m _hm x hx ↦ ?_⟩\n  · have := (h.iteratedFDerivWithin hu m x hx).differentiableWithinAt.hasFDerivWithinAt\n    rwa [insert_eq_of_mem hx] at this\n  · exact (h.iteratedFDerivWithin hu m x hx).continuousWithinAt\n\n"}
{"name":"AnalyticOn.exists_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\nhu : UniqueDiffOn 𝕜 s\n⊢ Exists fun p => And (HasFTaylorSeriesUpToOn Top.top f p s) (∀ (i : Nat), AnalyticOn 𝕜 (fun x => p x i) s)","decl":"lemma AnalyticOn.exists_hasFTaylorSeriesUpToOn\n    (h : AnalyticOn 𝕜 f s) (hu : UniqueDiffOn 𝕜 s) :\n    ∃ p : E → FormalMultilinearSeries 𝕜 E F,\n      HasFTaylorSeriesUpToOn ⊤ f p s ∧ ∀ i, AnalyticOn 𝕜 (fun x ↦ p x i) s :=\n  ⟨ftaylorSeriesWithin 𝕜 f s, h.hasFTaylorSeriesUpToOn hu, h.iteratedFDerivWithin hu⟩\n\n"}
{"name":"AnalyticOnNhd.fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOnNhd 𝕜 f s\nhs : IsOpen s\n⊢ AnalyticOnNhd 𝕜 (fderiv 𝕜 f) s","decl":"theorem AnalyticOnNhd.fderiv_of_isOpen (h : AnalyticOnNhd 𝕜 f s) (hs : IsOpen s) :\n    AnalyticOnNhd 𝕜 (fderiv 𝕜 f) s := by\n  rw [← hs.analyticOn_iff_analyticOnNhd] at h ⊢\n  exact (h.fderivWithin hs.uniqueDiffOn).congr (fun x hx ↦ (fderivWithin_of_isOpen hs hx).symm)\n\n"}
{"name":"AnalyticOnNhd.iteratedFDeriv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOnNhd 𝕜 f s\nhs : IsOpen s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s","decl":"theorem AnalyticOnNhd.iteratedFDeriv_of_isOpen (h : AnalyticOnNhd 𝕜 f s) (hs : IsOpen s) (n : ℕ) :\n    AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s := by\n  rw [← hs.analyticOn_iff_analyticOnNhd] at h ⊢\n  exact (h.iteratedFDerivWithin hs.uniqueDiffOn n).congr\n    (fun x hx ↦ (iteratedFDerivWithin_of_isOpen n hs hx).symm)\n\n"}
{"name":"PartialHomeomorph.analyticAt_symm'","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\na : E\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nh0 : Membership.mem f.source a\nh : AnalyticAt 𝕜 (↑f) a\nh' : Eq (fderiv 𝕜 (↑f) a) ↑i\n⊢ AnalyticAt 𝕜 (↑f.symm) (↑f a)","decl":"/-- If a partial homeomorphism `f` is analytic at a point `a`, with invertible derivative, then\nits inverse is analytic at `f a`. -/\ntheorem PartialHomeomorph.analyticAt_symm' (f : PartialHomeomorph E F) {a : E}\n    {i : E ≃L[𝕜] F} (h0 : a ∈ f.source) (h : AnalyticAt 𝕜 f a) (h' : fderiv 𝕜 f a = i) :\n    AnalyticAt 𝕜 f.symm (f a) := by\n  rcases h with ⟨p, hp⟩\n  have : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i := by simp [← h', hp.fderiv_eq]\n  exact (f.hasFPowerSeriesAt_symm h0 hp this).analyticAt\n\n"}
{"name":"PartialHomeomorph.analyticAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\na : F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nh0 : Membership.mem f.target a\nh : AnalyticAt 𝕜 (↑f) (↑f.symm a)\nh' : Eq (fderiv 𝕜 (↑f) (↑f.symm a)) ↑i\n⊢ AnalyticAt 𝕜 (↑f.symm) a","decl":"/-- If a partial homeomorphism `f` is analytic at a point `f.symm a`, with invertible derivative,\nthen its inverse is analytic at `a`. -/\ntheorem PartialHomeomorph.analyticAt_symm (f : PartialHomeomorph E F) {a : F}\n    {i : E ≃L[𝕜] F} (h0 : a ∈ f.target) (h : AnalyticAt 𝕜 f (f.symm a))\n    (h' : fderiv 𝕜 f (f.symm a) = i) :\n    AnalyticAt 𝕜 f.symm a := by\n  have : a = f (f.symm a) := by simp [h0]\n  rw [this]\n  exact f.analyticAt_symm' (by simp [h0]) h h'\n\n"}
{"name":"HasFPowerSeriesAt.hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nh : HasFPowerSeriesAt f p x\n⊢ HasStrictDerivAt f ((p 1) fun x => 1) x","decl":"protected theorem HasFPowerSeriesAt.hasStrictDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictDerivAt f (p 1 fun _ => 1) x :=\n  h.hasStrictFDerivAt.hasStrictDerivAt\n\n"}
{"name":"HasFPowerSeriesAt.hasDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nh : HasFPowerSeriesAt f p x\n⊢ HasDerivAt f ((p 1) fun x => 1) x","decl":"protected theorem HasFPowerSeriesAt.hasDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasDerivAt f (p 1 fun _ => 1) x :=\n  h.hasStrictDerivAt.hasDerivAt\n\n"}
{"name":"HasFPowerSeriesAt.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nh : HasFPowerSeriesAt f p x\n⊢ Eq (deriv f x) ((p 1) fun x => 1)","decl":"protected theorem HasFPowerSeriesAt.deriv (h : HasFPowerSeriesAt f p x) :\n    deriv f x = p 1 fun _ => 1 :=\n  h.hasDerivAt.deriv\n\n"}
{"name":"AnalyticOnNhd.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (deriv f) s","decl":"/-- If a function is analytic on a set `s` in a complete space, so is its derivative. -/\nprotected theorem AnalyticOnNhd.deriv [CompleteSpace F] (h : AnalyticOnNhd 𝕜 f s) :\n    AnalyticOnNhd 𝕜 (deriv f) s :=\n  (ContinuousLinearMap.apply 𝕜 F (1 : 𝕜)).comp_analyticOnNhd h.fderiv\n\n"}
{"name":"AnalyticOn.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (deriv f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.deriv := AnalyticOnNhd.deriv\n\n"}
{"name":"AnalyticOnNhd.deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nh : AnalyticOnNhd 𝕜 f s\nhs : IsOpen s\n⊢ AnalyticOnNhd 𝕜 (deriv f) s","decl":"/-- If a function is analytic on an open set `s`, so is its derivative. -/\ntheorem AnalyticOnNhd.deriv_of_isOpen (h : AnalyticOnNhd 𝕜 f s) (hs : IsOpen s) :\n    AnalyticOnNhd 𝕜 (deriv f) s :=\n  (ContinuousLinearMap.apply 𝕜 F (1 : 𝕜)).comp_analyticOnNhd (h.fderiv_of_isOpen hs)\n\n"}
{"name":"AnalyticOnNhd.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (Nat.iterate deriv n f) s","decl":"/-- If a function is analytic on a set `s`, so are its successive derivatives. -/\ntheorem AnalyticOnNhd.iterated_deriv [CompleteSpace F] (h : AnalyticOnNhd 𝕜 f s) (n : ℕ) :\n    AnalyticOnNhd 𝕜 (_root_.deriv^[n] f) s := by\n  induction n with\n  | zero => exact h\n  | succ n IH => simpa only [Function.iterate_succ', Function.comp_apply] using IH.deriv\n\n"}
{"name":"AnalyticOn.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (Nat.iterate deriv n f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.iterated_deriv := AnalyticOnNhd.iterated_deriv\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nf : E → F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ DifferentiableOn 𝕜 f (EMetric.ball x r)","decl":"theorem HasFiniteFPowerSeriesOnBall.differentiableOn\n    (h : HasFiniteFPowerSeriesOnBall f p x n r) : DifferentiableOn 𝕜 f (EMetric.ball x r) :=\n  fun _ hy ↦ (h.cPolynomialAt_of_mem hy).analyticAt.differentiableWithinAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nf : E → F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\n⊢ HasFDerivAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1)) (HAdd.hAdd x y)","decl":"theorem HasFiniteFPowerSeriesOnBall.hasFDerivAt (h : HasFiniteFPowerSeriesOnBall f p x n r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1)) (x + y) :=\n  (h.changeOrigin hy).toHasFPowerSeriesOnBall.hasFPowerSeriesAt.hasFDerivAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nf : E → F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : LT.lt (↑(NNNorm.nnnorm y)) r\n⊢ Eq (fderiv 𝕜 f (HAdd.hAdd x y)) ((continuousMultilinearCurryFin1 𝕜 E F) (p.changeOrigin y 1))","decl":"theorem HasFiniteFPowerSeriesOnBall.fderiv_eq (h : HasFiniteFPowerSeriesOnBall f p x n r)\n    {y : E} (hy : (‖y‖₊ : ℝ≥0∞) < r) :\n    fderiv 𝕜 f (x + y) = continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin y 1) :=\n  (h.hasFDerivAt hy).fderiv\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nf : E → F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x (HAdd.hAdd n 1) r\n⊢ HasFiniteFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x n r","decl":"/-- If a function has a finite power series on a ball, then so does its derivative. -/\nprotected theorem HasFiniteFPowerSeriesOnBall.fderiv\n    (h : HasFiniteFPowerSeriesOnBall f p x (n + 1) r) :\n    HasFiniteFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x n r := by\n  refine .congr (f := fun z ↦ continuousMultilinearCurryFin1 𝕜 E F (p.changeOrigin (z - x) 1)) ?_\n    fun z hz ↦ ?_\n  · refine continuousMultilinearCurryFin1 𝕜 E F\n      |>.toContinuousLinearEquiv.toContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall ?_\n    simpa using\n      ((p.hasFiniteFPowerSeriesOnBall_changeOrigin 1 h.finite).mono h.r_pos le_top).comp_sub x\n  dsimp only\n  rw [← h.fderiv_eq, add_sub_cancel]\n  simpa only [edist_eq_enorm_sub, EMetric.mem_ball] using hz\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.fderiv'","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nf : E → F\nx : E\nh : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ HasFiniteFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x (HSub.hSub n 1) r","decl":"/-- If a function has a finite power series on a ball, then so does its derivative.\nThis is a variant of `HasFiniteFPowerSeriesOnBall.fderiv` where the degree of `f` is `< n`\nand not `< n + 1`. -/\ntheorem HasFiniteFPowerSeriesOnBall.fderiv' (h : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesOnBall (fderiv 𝕜 f) p.derivSeries x (n - 1) r := by\n  obtain rfl | hn := eq_or_ne n 0\n  · rw [zero_tsub]\n    refine HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero (fun y hy ↦ ?_) h.r_pos fun n ↦ ?_\n    · rw [Filter.EventuallyEq.fderiv_eq (f := fun _ ↦ 0)]\n      · rw [fderiv_const, Pi.zero_apply]\n      · exact Filter.eventuallyEq_iff_exists_mem.mpr ⟨EMetric.ball x r,\n          EMetric.isOpen_ball.mem_nhds hy, fun z hz ↦ by rw [h.eq_zero_of_bound_zero z hz]⟩\n    · apply ContinuousMultilinearMap.ext; intro a\n      change (continuousMultilinearCurryFin1 𝕜 E F) (p.changeOriginSeries 1 n a) = 0\n      rw [p.changeOriginSeries_finite_of_finite h.finite 1 (Nat.zero_le _)]\n      exact map_zero _\n  · rw [← Nat.succ_pred hn] at h\n    exact h.fderiv\n\n"}
{"name":"CPolynomialOn.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : CPolynomialOn 𝕜 f s\n⊢ CPolynomialOn 𝕜 (fderiv 𝕜 f) s","decl":"/-- If a function is polynomial on a set `s`, so is its Fréchet derivative. -/\ntheorem CPolynomialOn.fderiv (h : CPolynomialOn 𝕜 f s) :\n    CPolynomialOn 𝕜 (fderiv 𝕜 f) s := by\n  intro y hy\n  rcases h y hy with ⟨p, r, n, hp⟩\n  exact hp.fderiv'.cPolynomialAt\n\n"}
{"name":"CPolynomialOn.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : CPolynomialOn 𝕜 f s\nn : Nat\n⊢ CPolynomialOn 𝕜 (iteratedFDeriv 𝕜 n f) s","decl":"/-- If a function is polynomial on a set `s`, so are its successive Fréchet derivative. -/\ntheorem CPolynomialOn.iteratedFDeriv (h : CPolynomialOn 𝕜 f s) (n : ℕ) :\n    CPolynomialOn 𝕜 (iteratedFDeriv 𝕜 n f) s := by\n  induction n with\n  | zero =>\n    rw [iteratedFDeriv_zero_eq_comp]\n    exact ((continuousMultilinearCurryFin0 𝕜 E F).symm : F →L[𝕜] E[×0]→L[𝕜] F).comp_cPolynomialOn h\n  | succ n IH =>\n    rw [iteratedFDeriv_succ_eq_comp_left]\n    convert ContinuousLinearMap.comp_cPolynomialOn ?g IH.fderiv\n    case g => exact ↑(continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) ↦ E) F).symm\n    simp\n\n"}
{"name":"CPolynomialOn.deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nh : CPolynomialOn 𝕜 f s\n⊢ CPolynomialOn 𝕜 (deriv f) s","decl":"/-- If a function is polynomial on a set `s`, so is its derivative. -/\nprotected theorem CPolynomialOn.deriv (h : CPolynomialOn 𝕜 f s) : CPolynomialOn 𝕜 (deriv f) s :=\n  (ContinuousLinearMap.apply 𝕜 F (1 : 𝕜)).comp_cPolynomialOn h.fderiv\n\n"}
{"name":"CPolynomialOn.iterated_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nh : CPolynomialOn 𝕜 f s\nn : Nat\n⊢ CPolynomialOn 𝕜 (Nat.iterate deriv n f) s","decl":"/-- If a function is polynomial on a set `s`, so are its successive derivatives. -/\ntheorem CPolynomialOn.iterated_deriv (h : CPolynomialOn 𝕜 f s) (n : ℕ) :\n    CPolynomialOn 𝕜 (deriv^[n] f) s := by\n  induction n with\n  | zero => exact h\n  | succ n IH => simpa only [Function.iterate_succ', Function.comp_apply] using IH.deriv\n\n"}
{"name":"ContinuousMultilinearMap.changeOriginSeries_support","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nk l : Nat\nh : Ne (HAdd.hAdd k l) (Fintype.card ι)\n⊢ Eq (f.toFormalMultilinearSeries.changeOriginSeries k l) 0","decl":"theorem changeOriginSeries_support {k l : ℕ} (h : k + l ≠ Fintype.card ι) :\n    f.toFormalMultilinearSeries.changeOriginSeries k l = 0 :=\n  Finset.sum_eq_zero fun _ _ ↦ by\n    simp_rw [FormalMultilinearSeries.changeOriginSeriesTerm,\n      toFormalMultilinearSeries, dif_neg h.symm, LinearIsometryEquiv.map_zero]\n\n"}
{"name":"ContinuousMultilinearMap.changeOrigin_toFormalMultilinearSeries","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝¹ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nx : (i : ι) → E i\ninst✝ : DecidableEq ι\n⊢ Eq ((continuousMultilinearCurryFin1 𝕜 ((i : ι) → E i) F) (f.toFormalMultilinearSeries.changeOrigin x 1)) (f.linearDeriv x)","decl":"open Finset in\ntheorem changeOrigin_toFormalMultilinearSeries [DecidableEq ι] :\n    continuousMultilinearCurryFin1 𝕜 (∀ i, E i) F (f.toFormalMultilinearSeries.changeOrigin x 1) =\n    f.linearDeriv x := by\n  ext y\n  rw [continuousMultilinearCurryFin1_apply, linearDeriv_apply,\n      changeOrigin, FormalMultilinearSeries.sum]\n  cases isEmpty_or_nonempty ι\n  · have (l) : 1 + l ≠ Fintype.card ι := by\n      rw [add_comm, Fintype.card_eq_zero]; exact Nat.succ_ne_zero _\n    simp_rw [Fintype.sum_empty, changeOriginSeries_support _ (this _), zero_apply _, tsum_zero]; rfl\n  rw [tsum_eq_single (Fintype.card ι - 1), changeOriginSeries]; swap\n  · intro m hm\n    rw [Ne, eq_tsub_iff_add_eq_of_le (by exact Fintype.card_pos), add_comm] at hm\n    rw [f.changeOriginSeries_support hm, zero_apply]\n  rw [sum_apply, ContinuousMultilinearMap.sum_apply, Fin.snoc_zero]\n  simp_rw [changeOriginSeriesTerm_apply]\n  refine (Fintype.sum_bijective (?_ ∘ Fintype.equivFinOfCardEq (Nat.add_sub_of_le\n    Fintype.card_pos).symm) (.comp ?_ <| Equiv.bijective _) _ _ fun i ↦ ?_).symm\n  · exact (⟨{·}ᶜ, by\n      rw [card_compl, Fintype.card_fin, Finset.card_singleton, Nat.add_sub_cancel_left]⟩)\n  · use fun _ _ ↦ (singleton_injective <| compl_injective <| Subtype.ext_iff.mp ·)\n    intro ⟨s, hs⟩\n    have h : #sᶜ = 1 := by rw [card_compl, hs, Fintype.card_fin, Nat.add_sub_cancel]\n    obtain ⟨a, ha⟩ := card_eq_one.mp h\n    exact ⟨a, Subtype.ext (compl_eq_comm.mp ha)⟩\n  rw [Function.comp_apply, Subtype.coe_mk, compl_singleton, piecewise_erase_univ,\n    toFormalMultilinearSeries, dif_pos (Nat.add_sub_of_le Fintype.card_pos).symm]\n  simp_rw [domDomCongr_apply, compContinuousLinearMap_apply, ContinuousLinearMap.proj_apply,\n    Function.update_apply, (Equiv.injective _).eq_iff, ite_apply]\n  congr; ext j\n  obtain rfl | hj := eq_or_ne j i\n  · rw [Function.update_self, if_pos rfl]\n  · rw [Function.update_of_ne hj, if_neg hj]\n\n"}
{"name":"ContinuousMultilinearMap.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝¹ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nx : (i : ι) → E i\ninst✝ : DecidableEq ι\n⊢ HasFDerivAt (⇑f) (f.linearDeriv x) x","decl":"protected theorem hasFDerivAt [DecidableEq ι] : HasFDerivAt f (f.linearDeriv x) x := by\n  rw [← changeOrigin_toFormalMultilinearSeries]\n  convert f.hasFiniteFPowerSeriesOnBall.hasFDerivAt (y := x) ENNReal.coe_lt_top\n  rw [zero_add]\n\n"}
{"name":"HasFDerivWithinAt.multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\ninst✝² : DecidableEq ι\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : (i : ι) → G → E i\ng' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) G (E i)\ns : Set G\nx : G\nhg : ∀ (i : ι), HasFDerivWithinAt (g i) (g' i) s x\n⊢ HasFDerivWithinAt (fun x => f fun i => g i x) (Finset.univ.sum fun i => (f.toContinuousLinearMap (fun j => g j x) i).comp (g' i)) s x","decl":"/-- Given `f` a multilinear map, then the derivative of `x ↦ f (g₁ x, ..., gₙ x)` at `x` applied\nto a vector `v` is given by `∑ i, f (g₁ x, ..., g'ᵢ v, ..., gₙ x)`. Version inside a set. -/\ntheorem _root_.HasFDerivWithinAt.multilinear_comp\n    [DecidableEq ι] {G : Type*} [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    {g : ∀ i, G → E i} {g' : ∀ i, G →L[𝕜] E i} {s : Set G} {x : G}\n    (hg : ∀ i, HasFDerivWithinAt (g i) (g' i) s x) :\n    HasFDerivWithinAt (fun x ↦ f (fun i ↦ g i x))\n      ((∑ i : ι, (f.toContinuousLinearMap (fun j ↦ g j x) i) ∘L (g' i))) s x := by\n  convert (f.hasFDerivAt (fun j ↦ g j x)).comp_hasFDerivWithinAt x (hasFDerivWithinAt_pi.2 hg)\n  ext v\n  simp [linearDeriv]\n\n"}
{"name":"HasFDerivAt.multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\ninst✝² : DecidableEq ι\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : (i : ι) → G → E i\ng' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) G (E i)\nx : G\nhg : ∀ (i : ι), HasFDerivAt (g i) (g' i) x\n⊢ HasFDerivAt (fun x => f fun i => g i x) (Finset.univ.sum fun i => (f.toContinuousLinearMap (fun j => g j x) i).comp (g' i)) x","decl":"/-- Given `f` a multilinear map, then the derivative of `x ↦ f (g₁ x, ..., gₙ x)` at `x` applied\nto a vector `v` is given by `∑ i, f (g₁ x, ..., g'ᵢ v, ..., gₙ x)`. -/\ntheorem _root_.HasFDerivAt.multilinear_comp\n    [DecidableEq ι] {G : Type*} [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    {g : ∀ i, G → E i} {g' : ∀ i, G →L[𝕜] E i} {x : G}\n    (hg : ∀ i, HasFDerivAt (g i) (g' i) x) :\n    HasFDerivAt (fun x ↦ f (fun i ↦ g i x))\n      ((∑ i : ι, (f.toContinuousLinearMap (fun j ↦ g j x) i) ∘L (g' i))) x := by\n  convert (f.hasFDerivAt (fun j ↦ g j x)).comp x (hasFDerivAt_pi.2 hg)\n  ext v\n  simp [linearDeriv]\n\n"}
{"name":"ContinuousMultilinearMap.hasFTaylorSeriesUpTo_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\n⊢ HasFTaylorSeriesUpTo Top.top ⇑f fun v n => f.iteratedFDeriv n v","decl":"/-- A continuous multilinear function `f` admits a Taylor series, whose successive terms are given\nby `f.iteratedFDeriv n`. This is the point of the definition of `f.iteratedFDeriv`. -/\ntheorem hasFTaylorSeriesUpTo_iteratedFDeriv :\n    HasFTaylorSeriesUpTo ⊤ f (fun v n ↦ f.iteratedFDeriv n v) := by\n  classical\n  constructor\n  · simp [ContinuousMultilinearMap.iteratedFDeriv]\n  · rintro n - x\n    suffices H : curryLeft (f.iteratedFDeriv (Nat.succ n) x) = (∑ e : Fin n ↪ ι,\n          ((iteratedFDerivComponent f e.toEquivRange).linearDeriv\n            (Pi.compRightL 𝕜 _ Subtype.val x)) ∘L (Pi.compRightL 𝕜 _ Subtype.val)) by\n      have A : HasFDerivAt (f.iteratedFDeriv n) (∑ e : Fin n ↪ ι,\n          ((iteratedFDerivComponent f e.toEquivRange).linearDeriv (Pi.compRightL 𝕜 _ Subtype.val x))\n            ∘L (Pi.compRightL 𝕜 _ Subtype.val)) x := by\n        apply HasFDerivAt.sum (fun s _hs ↦ ?_)\n        exact (ContinuousMultilinearMap.hasFDerivAt _ _).comp x (ContinuousLinearMap.hasFDerivAt _)\n      rwa [← H] at A\n    ext v m\n    simp only [ContinuousMultilinearMap.iteratedFDeriv, curryLeft_apply, sum_apply,\n      iteratedFDerivComponent_apply, Finset.univ_sigma_univ,\n      Pi.compRightL_apply, ContinuousLinearMap.coe_sum', ContinuousLinearMap.coe_comp',\n      Finset.sum_apply, Function.comp_apply, linearDeriv_apply, Finset.sum_sigma']\n    rw [← (Equiv.embeddingFinSucc n ι).sum_comp]\n    congr with e\n    congr with k\n    by_cases hke : k ∈ Set.range e\n    · simp only [hke, ↓reduceDIte]\n      split_ifs with hkf\n      · simp only [← Equiv.succ_embeddingFinSucc_fst_symm_apply e hkf hke, Fin.cons_succ]\n      · obtain rfl : k = e 0 := by\n          rcases hke with ⟨j, rfl⟩\n          simpa using hkf\n        simp only [Function.Embedding.toEquivRange_symm_apply_self, Fin.cons_zero, Function.update,\n          Pi.compRightL_apply]\n        split_ifs with h\n        · congr!\n        · exfalso\n          apply h\n          simp_rw [← Equiv.embeddingFinSucc_snd e]\n    · have hkf : k ∉ Set.range (Equiv.embeddingFinSucc n ι e).1 := by\n        contrapose! hke\n        rw [Equiv.embeddingFinSucc_fst] at hke\n        exact Set.range_comp_subset_range _ _ hke\n      simp only [hke, hkf, ↓reduceDIte, Pi.compRightL,\n        ContinuousLinearMap.coe_mk', LinearMap.coe_mk, AddHom.coe_mk]\n      rw [Function.update_of_ne]\n      contrapose! hke\n      rw [show k = _ from Subtype.ext_iff_val.1 hke, Equiv.embeddingFinSucc_snd e]\n      exact Set.mem_range_self _\n  · rintro n -\n    apply continuous_finset_sum _ (fun e _ ↦ ?_)\n    exact (ContinuousMultilinearMap.coe_continuous _).comp (ContinuousLinearMap.continuous _)\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDeriv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nn : Nat\n⊢ Eq (iteratedFDeriv 𝕜 n ⇑f) (f.iteratedFDeriv n)","decl":"theorem iteratedFDeriv_eq (n : ℕ) :\n    iteratedFDeriv 𝕜 n f = f.iteratedFDeriv n :=\n  funext fun x ↦ (f.hasFTaylorSeriesUpTo_iteratedFDeriv.eq_iteratedFDeriv (m := n) le_top x).symm\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDeriv_le","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nn : Nat\nx : (i : ι) → E i\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (⇑f) x)) (HMul.hMul (HMul.hMul (↑((Fintype.card ι).descFactorial n)) (Norm.norm f)) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card ι) n)))","decl":"theorem norm_iteratedFDeriv_le (n : ℕ) (x : (i : ι) → E i) :\n    ‖iteratedFDeriv 𝕜 n f x‖\n      ≤ Nat.descFactorial (Fintype.card ι) n * ‖f‖ * ‖x‖ ^ (Fintype.card ι - n) := by\n  rw [f.iteratedFDeriv_eq]\n  exact f.norm_iteratedFDeriv_le' n x\n\n"}
{"name":"ContinuousMultilinearMap.cPolynomialAt","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\nx : (i : ι) → E i\n⊢ CPolynomialAt 𝕜 (⇑f) x","decl":"lemma cPolynomialAt : CPolynomialAt 𝕜 f x :=\n  f.hasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousMultilinearMap.cPolyomialOn","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_2\nE : ι → Type u_3\ninst✝² : (i : ι) → NormedAddCommGroup (E i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E F\n⊢ CPolynomialOn 𝕜 (⇑f) Top.top","decl":"lemma cPolyomialOn : CPolynomialOn 𝕜 f ⊤ := fun x _ ↦ f.cPolynomialAt x\n\n"}
{"name":"FormalMultilinearSeries.derivSeries_apply_diag","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nx : E\n⊢ Eq (((p.derivSeries n) fun x_1 => x) x) (HSMul.hSMul (HAdd.hAdd n 1) ((p (HAdd.hAdd n 1)) fun x_1 => x))","decl":"open Fintype ContinuousLinearMap in\ntheorem derivSeries_apply_diag (n : ℕ) (x : E) :\n    derivSeries p n (fun _ ↦ x) x = (n + 1) • p (n + 1) fun _ ↦ x := by\n  simp only [derivSeries, compFormalMultilinearSeries_apply, changeOriginSeries,\n    compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe, LinearIsometryEquiv.coe_coe,\n    Function.comp_apply, ContinuousMultilinearMap.sum_apply, map_sum, coe_sum', Finset.sum_apply,\n    continuousMultilinearCurryFin1_apply, Matrix.zero_empty]\n  convert Finset.sum_const _\n  · rw [Fin.snoc_zero, changeOriginSeriesTerm_apply, Finset.piecewise_same, add_comm]\n  · rw [← card, card_subtype, ← Finset.powerset_univ, ← Finset.powersetCard_eq_filter,\n      Finset.card_powersetCard, ← card, card_fin, eq_comm, add_comm, Nat.choose_succ_self_right]\n\n"}
{"name":"HasFPowerSeriesOnBall.iteratedFDeriv_zero_apply_diag","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\n⊢ Eq (iteratedFDeriv 𝕜 0 f x) (p 0)","decl":"include h in\ntheorem iteratedFDeriv_zero_apply_diag : iteratedFDeriv 𝕜 0 f x = p 0 := by\n  ext\n  convert (h.hasSum <| EMetric.mem_ball_self h.r_pos).tsum_eq.symm\n  · rw [iteratedFDeriv_zero_apply, add_zero]\n  · rw [tsum_eq_single 0 fun n hn ↦ by haveI := NeZero.mk hn; exact (p n).map_zero]\n    exact congr(p 0 $(Subsingleton.elim _ _))\n\n"}
{"name":"HasFPowerSeriesOnBall.factorial_smul","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ny : E\ninst✝ : CompleteSpace F\nn : Nat\n⊢ Eq (HSMul.hSMul n.factorial ((p n) fun x => y)) ((iteratedFDeriv 𝕜 n f x) fun x => y)","decl":"/-- The iterated derivative of an analytic function, on vectors `(y, ..., y)`, is given by `n!`\ntimes the `n`-th term in the power series. For a more general result giving the full iterated\nderivative as a sum over the permutations of `Fin n`, see\n`HasFPowerSeriesOnBall.iteratedFDeriv_eq_sum`. -/\ntheorem factorial_smul (n : ℕ) :\n    n ! • p n (fun _ ↦ y) = iteratedFDeriv 𝕜 n f x (fun _ ↦ y) := by\n  cases n\n  · rw [factorial_zero, one_smul, h.iteratedFDeriv_zero_apply_diag]\n  · rw [factorial_succ, mul_comm, mul_smul, ← derivSeries_apply_diag,\n      ← ContinuousLinearMap.smul_apply, factorial_smul' _ h.fderiv, iteratedFDeriv_succ_apply_right]\n    rfl\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nf : E → F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ninst✝¹ : CompleteSpace F\ninst✝ : CharZero 𝕜\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ HasSum (fun n => HSMul.hSMul (Inv.inv ↑n.factorial) ((iteratedFDeriv 𝕜 n f x) fun x => y)) (f (HAdd.hAdd x y))","decl":"theorem hasSum_iteratedFDeriv [CharZero 𝕜] {y : E} (hy : y ∈ EMetric.ball 0 r) :\n    HasSum (fun n ↦ (n ! : 𝕜)⁻¹ • iteratedFDeriv 𝕜 n f x fun _ ↦ y) (f (x + y)) := by\n  convert h.hasSum hy with n\n  rw [← h.factorial_smul y n, smul_comm, ← smul_assoc, nsmul_eq_mul,\n    mul_inv_cancel₀ <| cast_ne_zero.mpr n.factorial_ne_zero, one_smul]\n\n"}
{"name":"ContinuousLinearMap.hasFDerivAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nι : Type u_2\nG : ι → Type u_3\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (G i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 G F)\nv : Prod E ((i : ι) → G i)\n⊢ HasFDerivAt (fun p => (f p.1) p.2) (HAdd.hAdd ((f.flipMultilinear v.2).comp (ContinuousLinearMap.fst 𝕜 E ((i : ι) → G i))) (Finset.univ.sum fun i => ((f v.1).toContinuousLinearMap v.2 i).comp ((ContinuousLinearMap.proj i).comp (ContinuousLinearMap.snd 𝕜 E ((i : ι) → G i))))) v","decl":"theorem hasFDerivAt_uncurry_of_multilinear [DecidableEq ι]\n    (f : E →L[𝕜] ContinuousMultilinearMap 𝕜 G F) (v : E × Π i, G i) :\n    HasFDerivAt (fun (p : E × Π i, G i) ↦ f p.1 p.2)\n      ((f.flipMultilinear v.2) ∘L (.fst _ _ _) +\n        ∑ i : ι, ((f v.1).toContinuousLinearMap v.2 i) ∘L (.proj _) ∘L (.snd _ _ _)) v := by\n  convert HasFDerivAt.multilinear_comp (f.continuousMultilinearMapOption)\n    (g := fun (_ : Option ι) p ↦ p) (g' := fun _ ↦ ContinuousLinearMap.id _ _) (x := v)\n    (fun _ ↦ hasFDerivAt_id _)\n  have I : f.continuousMultilinearMapOption.toContinuousLinearMap (fun _ ↦ v) none =\n      (f.flipMultilinear v.2) ∘L (.fst _ _ _) := by\n    simp [ContinuousMultilinearMap.toContinuousLinearMap, continuousMultilinearMapOption]\n    apply ContinuousLinearMap.ext (fun w ↦ ?_)\n    simp\n  have J : ∀ (i : ι), f.continuousMultilinearMapOption.toContinuousLinearMap (fun _ ↦ v) (some i)\n      = ((f v.1).toContinuousLinearMap v.2 i) ∘L (.proj _) ∘L (.snd _ _ _) := by\n    intro i\n    apply ContinuousLinearMap.ext (fun w ↦ ?_)\n    simp only [ContinuousMultilinearMap.toContinuousLinearMap, continuousMultilinearMapOption,\n      coe_mk', MultilinearMap.toLinearMap_apply, ContinuousMultilinearMap.coe_coe,\n      MultilinearMap.coe_mkContinuous, MultilinearMap.coe_mk, ne_eq, reduceCtorEq,\n      not_false_eq_true, Function.update_of_ne, coe_comp', coe_snd', Function.comp_apply,\n      proj_apply]\n    congr\n    ext j\n    rcases eq_or_ne j i with rfl | hij\n    · simp\n    · simp [hij]\n  simp [I, J]\n\n"}
{"name":"HasFDerivWithinAt.linear_multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type v\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nι : Type u_2\nG : ι → Type u_3\ninst✝⁵ : (i : ι) → NormedAddCommGroup (G i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (G i)\ninst✝³ : Fintype ι\nH : Type u_4\ninst✝² : NormedAddCommGroup H\ninst✝¹ : NormedSpace 𝕜 H\ninst✝ : DecidableEq ι\na : H → E\na' : ContinuousLinearMap (RingHom.id 𝕜) H E\nb : (i : ι) → H → G i\nb' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) H (G i)\ns : Set H\nx : H\nha : HasFDerivWithinAt a a' s x\nhb : ∀ (i : ι), HasFDerivWithinAt (b i) (b' i) s x\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 G F)\n⊢ HasFDerivWithinAt (fun y => (f (a y)) fun i => b i y) (HAdd.hAdd ((f.flipMultilinear fun i => b i x).comp a') (Finset.univ.sum fun i => ((f (a x)).toContinuousLinearMap (fun j => b j x) i).comp (b' i))) s x","decl":"/-- Given `f` a linear map into multilinear maps, then the derivative\nof `x ↦ f (a x) (b₁ x, ..., bₙ x)` at `x` applied to a vector `v` is given by\n`f (a' v) (b₁ x, ...., bₙ x) + ∑ i, f a (b₁ x, ..., b'ᵢ v, ..., bₙ x)`. Version inside a set. -/\ntheorem _root_.HasFDerivWithinAt.linear_multilinear_comp\n    [DecidableEq ι] {a : H → E} {a' : H →L[𝕜] E}\n    {b : ∀ i, H → G i} {b' : ∀ i, H →L[𝕜] G i} {s : Set H} {x : H}\n    (ha : HasFDerivWithinAt a a' s x) (hb : ∀ i, HasFDerivWithinAt (b i) (b' i) s x)\n    (f : E →L[𝕜] ContinuousMultilinearMap 𝕜 G F) :\n    HasFDerivWithinAt (fun y ↦ f (a y) (fun i ↦ b i y))\n      ((f.flipMultilinear (fun i ↦ b i x)) ∘L a' +\n        ∑ i, ((f (a x)).toContinuousLinearMap (fun j ↦ b j x) i) ∘L (b' i)) s x := by\n  convert (hasFDerivAt_uncurry_of_multilinear f (a x, fun i ↦ b i x)).comp_hasFDerivWithinAt x\n    (ha.prod (hasFDerivWithinAt_pi.mpr hb))\n  ext v\n  simp\n\n"}
{"name":"HasFDerivAt.linear_multilinear_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Analytic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type v\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nι : Type u_2\nG : ι → Type u_3\ninst✝⁵ : (i : ι) → NormedAddCommGroup (G i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (G i)\ninst✝³ : Fintype ι\nH : Type u_4\ninst✝² : NormedAddCommGroup H\ninst✝¹ : NormedSpace 𝕜 H\ninst✝ : DecidableEq ι\na : H → E\na' : ContinuousLinearMap (RingHom.id 𝕜) H E\nb : (i : ι) → H → G i\nb' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) H (G i)\nx : H\nha : HasFDerivAt a a' x\nhb : ∀ (i : ι), HasFDerivAt (b i) (b' i) x\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousMultilinearMap 𝕜 G F)\n⊢ HasFDerivAt (fun y => (f (a y)) fun i => b i y) (HAdd.hAdd ((f.flipMultilinear fun i => b i x).comp a') (Finset.univ.sum fun i => ((f (a x)).toContinuousLinearMap (fun j => b j x) i).comp (b' i))) x","decl":"/-- Given `f` a linear map into multilinear maps, then the derivative\nof `x ↦ f (a x) (b₁ x, ..., bₙ x)` at `x` applied to a vector `v` is given by\n`f (a' v) (b₁ x, ...., bₙ x) + ∑ i, f a (b₁ x, ..., b'ᵢ v, ..., bₙ x)`. -/\ntheorem _root_.HasFDerivAt.linear_multilinear_comp [DecidableEq ι] {a : H → E} {a' : H →L[𝕜] E}\n    {b : ∀ i, H → G i} {b' : ∀ i, H →L[𝕜] G i} {x : H}\n    (ha : HasFDerivAt a a' x) (hb : ∀ i, HasFDerivAt (b i) (b' i) x)\n    (f : E →L[𝕜] ContinuousMultilinearMap 𝕜 G F) :\n    HasFDerivAt (fun y ↦ f (a y) (fun i ↦ b i y))\n      ((f.flipMultilinear (fun i ↦ b i x)) ∘L a' +\n        ∑ i, ((f (a x)).toContinuousLinearMap (fun j ↦ b j x) i) ∘L (b' i)) x := by\n  simp_rw [← hasFDerivWithinAt_univ] at ha hb ⊢\n  exact HasFDerivWithinAt.linear_multilinear_comp ha hb f\n\n"}
