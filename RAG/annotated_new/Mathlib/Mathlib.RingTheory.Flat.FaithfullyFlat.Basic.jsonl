{"name":"Module.FaithfullyFlat.toFlat","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : Module.FaithfullyFlat R M\n⊢ Module.Flat R M","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N → N'` such that `id ⊗ f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ∀ ⦃m : Ideal R⦄ (_ : Ideal.IsMaximal m), m • (⊤ : Submodule R M) ≠ ⊤\n\n"}
{"name":"Module.FaithfullyFlat.submodule_ne_top","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : Module.FaithfullyFlat R M\nm : Ideal R\nx✝ : m.IsMaximal\n⊢ Ne (HSMul.hSMul m Top.top) Top.top","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N → N'` such that `id ⊗ f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ∀ ⦃m : Ideal R⦄ (_ : Ideal.IsMaximal m), m • (⊤ : Submodule R M) ≠ ⊤\n\n"}
{"name":"Module.faithfullyFlat_iff","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ ⦃m : Ideal R⦄, m.IsMaximal → Ne (HSMul.hSMul m Top.top) Top.top))","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N → N'` such that `id ⊗ f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ∀ ⦃m : Ideal R⦄ (_ : Ideal.IsMaximal m), m • (⊤ : Submodule R M) ≠ ⊤\n\n"}
{"name":"Module.FaithfullyFlat.self","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Module.FaithfullyFlat R R","decl":"instance self : FaithfullyFlat R R where\n  submodule_ne_top m h r := Ideal.eq_top_iff_one _ |>.not.1 h.ne_top <| by\n    simpa using show 1 ∈ (m • ⊤ : Ideal R) from r.symm ▸ ⟨⟩\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_proper_ideal","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (I : Ideal R), Ne I Top.top → Ne (HSMul.hSMul I Top.top) Top.top))","decl":"lemma iff_flat_and_proper_ideal :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧ ∀ (I : Ideal R), I ≠ ⊤ → I • (⊤ : Submodule R M) ≠ ⊤) := by\n  rw [faithfullyFlat_iff]\n  refine ⟨fun ⟨flat, h⟩ => ⟨flat, fun I hI r => ?_⟩, fun h => ⟨h.1, fun m hm => h.2 _ hm.ne_top⟩⟩\n  obtain ⟨m, hm, le⟩ := I.exists_le_maximal hI\n  exact h hm <| eq_top_iff.2 <| show ⊤ ≤ m • ⊤ from r ▸ Submodule.smul_mono le (by simp [r])\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_ideal_smul_eq_top","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (I : Ideal R), Eq (HSMul.hSMul I Top.top) Top.top → Eq I Top.top))","decl":"lemma iff_flat_and_ideal_smul_eq_top :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧ ∀ (I : Ideal R), I • (⊤ : Submodule R M) = ⊤ → I = ⊤) :=\n  iff_flat_and_proper_ideal R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun I => eq_iff_iff.2 <| by tauto\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_nontrivial","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nfl : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Nontrivial N\n⊢ Nontrivial (TensorProduct R N M)","decl":"instance rTensor_nontrivial\n    [fl: FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N] [Nontrivial N] :\n    Nontrivial (N ⊗[R] M) := by\n  obtain ⟨n, hn⟩ := nontrivial_iff_exists_ne (0 : N) |>.1 inferInstance\n  let I := (Submodule.span R {n}).annihilator\n  by_cases I_ne_top : I = ⊤\n  · rw [Ideal.eq_top_iff_one, Submodule.mem_annihilator_span_singleton, one_smul] at I_ne_top\n    contradiction\n  let inc : R ⧸ I →ₗ[R] N := Submodule.liftQ _ ((LinearMap.lsmul R N).flip n) <| fun r hr => by\n    simpa only [LinearMap.mem_ker, LinearMap.flip_apply, LinearMap.lsmul_apply,\n      Submodule.mem_annihilator_span_singleton, I] using hr\n  have injective_inc : Function.Injective inc := LinearMap.ker_eq_bot.1 <| eq_bot_iff.2 <| by\n    intro r hr\n    induction r using Quotient.inductionOn' with | h r =>\n    simpa only [Submodule.Quotient.mk''_eq_mk, Submodule.mem_bot, Submodule.Quotient.mk_eq_zero,\n      Submodule.mem_annihilator_span_singleton, LinearMap.mem_ker, Submodule.liftQ_apply,\n      LinearMap.flip_apply, LinearMap.lsmul_apply, I, inc] using hr\n  have ne_top := iff_flat_and_proper_ideal R M |>.1 fl |>.2 I I_ne_top\n  refine subsingleton_or_nontrivial _ |>.resolve_left fun rid => ?_\n  exact False.elim <| ne_top <| Submodule.subsingleton_quotient_iff_eq_top.1 <|\n    Function.Injective.comp (g := LinearMap.rTensor M inc)\n      (fl.toFlat.rTensor_preserves_injective_linearMap inc injective_inc)\n      ((quotTensorEquivQuotSMul M I).symm.injective) |>.subsingleton\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_nontrivial","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Nontrivial N\n⊢ Nontrivial (TensorProduct R M N)","decl":"instance lTensor_nontrivial\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N] [Nontrivial N] :\n    Nontrivial (M ⊗[R] N) :=\n  TensorProduct.comm R M N |>.toEquiv.nontrivial\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nh : Subsingleton (TensorProduct R N M)\n⊢ Subsingleton N","decl":"lemma rTensor_reflects_triviality\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N]\n    [h : Subsingleton (N ⊗[R] M)] : Subsingleton N := by\n  revert h; change _ → _; contrapose\n  simp only [not_subsingleton_iff_nontrivial]\n  intro h\n  infer_instance\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Subsingleton (TensorProduct R M N)\n⊢ Subsingleton N","decl":"lemma lTensor_reflects_triviality\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N]\n    [Subsingleton (M ⊗[R] N)] :\n    Subsingleton N := by\n  haveI : Subsingleton (N ⊗[R] M) := (TensorProduct.comm R N M).toEquiv.injective.subsingleton\n  apply rTensor_reflects_triviality R M\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_rTensor_faithful","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Nontrivial N → Nontrivial (TensorProduct R N M)))","decl":"attribute [-simp] Ideal.Quotient.mk_eq_mk in\nlemma iff_flat_and_rTensor_faithful :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧\n      ∀ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Nontrivial N → Nontrivial (N ⊗[R] M)) := by\n  refine ⟨fun fl => ⟨inferInstance, rTensor_nontrivial R M⟩, fun ⟨flat, faithful⟩ => ⟨?_⟩⟩\n  intro m hm rid\n  specialize faithful (ULift (R ⧸ m)) inferInstance\n  haveI : Nontrivial ((R ⧸ m) ⊗[R] M) :=\n    (congr (ULift.moduleEquiv : ULift (R ⧸ m) ≃ₗ[R] R ⧸ m)\n      (LinearEquiv.refl R M)).symm.toEquiv.nontrivial\n  have := (quotTensorEquivQuotSMul M m).toEquiv.symm.nontrivial\n  haveI H : Subsingleton (M ⧸ m • (⊤ : Submodule R M)) := by\n    rwa [Submodule.subsingleton_quotient_iff_eq_top]\n  rw [← not_nontrivial_iff_subsingleton] at H\n  contradiction\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_rTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Subsingleton (TensorProduct R N M) → Subsingleton N))","decl":"lemma iff_flat_and_rTensor_reflects_triviality :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧\n      ∀ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Subsingleton (N ⊗[R] M) → Subsingleton N) :=\n  iff_flat_and_rTensor_faithful R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun N => forall_congr fun _ => forall_congr fun _ => iff_iff_eq.1 <| by\n      simp only [← not_subsingleton_iff_nontrivial]; tauto\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_lTensor_faithful","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Nontrivial N → Nontrivial (TensorProduct R M N)))","decl":"lemma iff_flat_and_lTensor_faithful :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧\n      ∀ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Nontrivial N → Nontrivial (M ⊗[R] N)) :=\n  iff_flat_and_rTensor_faithful R M |>.trans\n  ⟨fun ⟨flat, faithful⟩ => ⟨flat, fun N _ _ _ =>\n      letI := faithful N inferInstance; (TensorProduct.comm R M N).toEquiv.nontrivial⟩,\n    fun ⟨flat, faithful⟩ => ⟨flat, fun N _ _ _ =>\n      letI := faithful N inferInstance; (TensorProduct.comm R M N).symm.toEquiv.nontrivial⟩⟩\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_lTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Subsingleton (TensorProduct R M N) → Subsingleton N))","decl":"lemma iff_flat_and_lTensor_reflects_triviality :\n    FaithfullyFlat R M ↔\n    (Flat R M ∧\n      ∀ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Subsingleton (M ⊗[R] N) → Subsingleton N) :=\n  iff_flat_and_lTensor_faithful R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun N => forall_congr fun _ => forall_congr fun _ => iff_iff_eq.1 <| by\n      simp only [← not_subsingleton_iff_nontrivial]; tauto\n\n"}
{"name":"Module.FaithfullyFlat.of_linearEquiv","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_1\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.FaithfullyFlat R M\ne : LinearEquiv (RingHom.id R) N M\n⊢ Module.FaithfullyFlat R N","decl":"/-- If `M` is a faithfully flat `R`-module and `N` is `R`-linearly isomorphic to `M`, then\n`N` is faithfully flat. -/\nlemma of_linearEquiv {N : Type*} [AddCommGroup N] [Module R N] [FaithfullyFlat R M]\n    (e : N ≃ₗ[R] M) : FaithfullyFlat R N := by\n  rw [iff_flat_and_lTensor_faithful]\n  exact ⟨Flat.of_linearEquiv e,\n    fun P _ _ hP ↦ (TensorProduct.congr e (LinearEquiv.refl R P)).toEquiv.nontrivial⟩\n\n"}
{"name":"Module.FaithfullyFlat.directSum","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nι : Type u_1\ninst✝³ : Nonempty ι\nM : ι → Type u_2\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.FaithfullyFlat R (M i)\n⊢ Module.FaithfullyFlat R (DirectSum ι fun i => M i)","decl":"/-- A direct sum of faithfully flat `R`-modules is faithfully flat. -/\ninstance directSum {ι : Type*} [Nonempty ι] (M : ι → Type*) [∀ i, AddCommGroup (M i)]\n    [∀ i, Module R (M i)] [∀ i, FaithfullyFlat R (M i)] : FaithfullyFlat R (⨁ i, M i) := by\n  classical\n  rw [iff_flat_and_lTensor_faithful]\n  refine ⟨inferInstance, fun N _ _ hN ↦ ?_⟩\n  obtain ⟨i⟩ := ‹Nonempty ι›\n  obtain ⟨x, y, hxy⟩ := Nontrivial.exists_pair_ne (α := M i ⊗[R] N)\n  haveI : Nontrivial (⨁ (i : ι), M i ⊗[R] N) :=\n    ⟨DirectSum.of _ i x, DirectSum.of _ i y, fun h ↦ hxy (DirectSum.of_injective i h)⟩\n  apply (TensorProduct.directSumLeft R M N).toEquiv.nontrivial\n\n"}
{"name":"Module.FaithfullyFlat.finsupp","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nι : Type v\ninst✝ : Nonempty ι\n⊢ Module.FaithfullyFlat R (Finsupp ι R)","decl":"/-- Free `R`-modules over discrete types are flat. -/\ninstance finsupp (ι : Type v) [Nonempty ι] : FaithfullyFlat R (ι →₀ R) := by\n  classical exact of_linearEquiv _ _ (finsuppLEquivDirectSum R R ι)\n\n"}
{"name":"Module.FaithfullyFlat.instOfNontrivialOfFree","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : Module.Free R M\n⊢ Module.FaithfullyFlat R M","decl":"/-- Any free, nontrivial `R`-module is flat. -/\ninstance [Nontrivial M] [Module.Free R M] : FaithfullyFlat R M :=\n  of_linearEquiv _ _ (Free.repr R M)\n\n"}
{"name":"Module.FaithfullyFlat.range_le_ker_of_exact_rTensor","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN1 : Type u_1\ninst✝⁵ : AddCommGroup N1\ninst✝⁴ : Module R N1\nN2 : Type u_2\ninst✝³ : AddCommGroup N2\ninst✝² : Module R N2\nN3 : Type u_3\ninst✝¹ : AddCommGroup N3\ninst✝ : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ⇑(LinearMap.rTensor M l12) ⇑(LinearMap.rTensor M l23)\n⊢ LE.le (LinearMap.range l12) (LinearMap.ker l23)","decl":"/--\nIf `M` is faithfully flat, then exactness of `N₁ ⊗ M -> N₂ ⊗ M -> N₃ ⊗ M` implies that the\ncomposition `N₁ -> N₂ -> N₃` is `0`.\n\nImplementation detail, please use `rTensor_reflects_exact` instead.\n-/\nlemma range_le_ker_of_exact_rTensor [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.rTensor M) (l23.rTensor M)) :\n    LinearMap.range l12 ≤ LinearMap.ker l23 := by\n  -- let `n1 ∈ N1`. We need to show `l23 (l12 n1) = 0`. Suppose this is not the case.\n  rintro _ ⟨n1, rfl⟩\n  rw [LinearMap.mem_ker]\n  by_contra! hn1\n  -- Let `E` be the submodule spanned by `l23 (l12 n1)`. Then because `l23 (l12 n1) ≠ 0`, we have\n  -- `E ≠ 0`.\n  let E : Submodule R N3 := Submodule.span R {l23 (l12 n1)}\n  have hE : Nontrivial E :=\n    ⟨0, ⟨⟨l23 (l12 n1), Submodule.mem_span_singleton_self _⟩, Subtype.coe_ne_coe.1 hn1.symm⟩⟩\n\n  -- Since `N1 ⊗ M -> N2 ⊗ M -> N3 ⊗ M` is exact, we have `l23 (l12 n1) ⊗ₜ m = 0` for all `m : M`.\n  have eq1 : ∀ (m : M), l23 (l12 n1) ⊗ₜ[R] m = 0 := fun m ↦\n    ex.apply_apply_eq_zero (n1 ⊗ₜ[R] m)\n  -- Then `E ⊗ M = 0`. Indeed,\n  have eq0 : (⊤ : Submodule R (E ⊗[R] M)) = ⊥ := by\n    -- suppose `x ∈ E ⊗ M`. We will show `x = 0`.\n    ext x\n    simp only [Submodule.mem_top, Submodule.mem_bot, true_iff]\n    have mem : x ∈ (⊤ : Submodule R _) := ⟨⟩\n    rw [← TensorProduct.span_tmul_eq_top, mem_span_set] at mem\n    obtain ⟨c, hc, rfl⟩ := mem\n    choose b a hy using hc\n    let r :  ⦃a : E ⊗[R] M⦄ → a ∈ ↑c.support → R := fun a ha =>\n      Submodule.mem_span_singleton.1 (b ha).2 |>.choose\n    have hr : ∀ ⦃i : E ⊗[R] M⦄ (hi : i ∈ c.support), b hi =\n        r hi • ⟨l23 (l12 n1), Submodule.mem_span_singleton_self _⟩ := fun a ha =>\n      Subtype.ext <| Submodule.mem_span_singleton.1 (b ha).2 |>.choose_spec.symm\n    -- Since `M` is flat and `E -> N1` is injective, we only need to check that x = 0\n    -- in `N1 ⊗ M`. We write `x = ∑ μᵢ • (l23 (l12 n1)) ⊗ mᵢ = ∑ μᵢ • 0 = 0`\n    -- (remember `E = span {l23 (l12 n1)}` and `eq1`)\n    refine Finset.sum_eq_zero fun i hi => show c i • i = 0 from\n      (Module.Flat.rTensor_preserves_injective_linearMap (M := M) E.subtype <|\n              Submodule.injective_subtype E) ?_\n    rw [← hy hi, hr hi, smul_tmul, map_smul, LinearMap.rTensor_tmul, Submodule.subtype_apply, eq1,\n      smul_zero, map_zero]\n  have : Subsingleton (E ⊗[R] M) := subsingleton_iff_forall_eq 0 |>.2 fun x =>\n    show x ∈ (⊥ : Submodule R _) from eq0 ▸ ⟨⟩\n\n  -- but `E ⊗ M = 0` implies `E = 0` because `M` is faithfully flat and this is a contradiction.\n  exact not_subsingleton_iff_nontrivial.2 inferInstance <| fl.rTensor_reflects_triviality R M E\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_reflects_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN1 : Type u_1\ninst✝⁵ : AddCommGroup N1\ninst✝⁴ : Module R N1\nN2 : Type u_2\ninst✝³ : AddCommGroup N2\ninst✝² : Module R N2\nN3 : Type u_3\ninst✝¹ : AddCommGroup N3\ninst✝ : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ⇑(LinearMap.rTensor M l12) ⇑(LinearMap.rTensor M l23)\n⊢ Function.Exact ⇑l12 ⇑l23","decl":"lemma rTensor_reflects_exact [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.rTensor M) (l23.rTensor M)) :\n    Function.Exact l12 l23 := LinearMap.exact_iff.2 <| by\n  have complex : LinearMap.range l12 ≤ LinearMap.ker l23 := range_le_ker_of_exact_rTensor R M _ _ ex\n  -- By the previous lemma we have that range l12 ≤ ker l23 and hence the quotient\n  -- H := ker l23 ⧸ range l12 makes sense.\n  -- Hence our goal ker l23 = range l12 follows from the claim that H = 0.\n  let H := LinearMap.ker l23 ⧸ LinearMap.range (Submodule.inclusion complex)\n  suffices triv_coh : Subsingleton H by\n    rw [Submodule.subsingleton_quotient_iff_eq_top, Submodule.range_inclusion,\n      Submodule.comap_subtype_eq_top] at triv_coh\n    exact le_antisymm triv_coh complex\n\n  -- Since `M` is faithfully flat, we need only to show that `H ⊗ M` is trivial.\n  suffices Subsingleton (H ⊗[R] M) from rTensor_reflects_triviality R M H\n  let e : H ⊗[R] M ≃ₗ[R] _ := TensorProduct.quotientTensorEquiv _ _\n  -- Note that `H ⊗ M` is isomorphic to `ker l12 ⊗ M ⧸ range ((range l12 ⊗ M) -> (ker l23 ⊗ M))`.\n  -- So the problem is reduced to proving surjectivity of `range l12 ⊗ M → ker l23 ⊗ M`.\n  rw [e.toEquiv.subsingleton_congr, Submodule.subsingleton_quotient_iff_eq_top,\n    LinearMap.range_eq_top]\n  intro x\n  induction x using TensorProduct.induction_on with\n  | zero => exact ⟨0, by simp⟩\n  -- let `x ⊗ m` be an element in `ker l23 ⊗ M`, then `x ⊗ m` is in the kernel of `l23 ⊗ 𝟙M`.\n  -- Since `N1 ⊗ M -l12 ⊗ M-> N2 ⊗ M -l23 ⊗ M-> N3 ⊗ M` is exact, we have that `x ⊗ m` is in\n  -- the range of `l12 ⊗ 𝟙M`, i.e. `x ⊗ m = (l12 ⊗ 𝟙M) y` for some `y ∈ N1 ⊗ M` as elements of\n  -- `N2 ⊗ M`. We need to prove that `x ⊗ m = (l12 ⊗ 𝟙M) y` still holds in `(ker l23) ⊗ M`.\n  -- This is okay because `M` is flat and `ker l23 -> N2` is injective.\n  | tmul x m =>\n    rcases x with ⟨x, (hx : l23 x = 0)⟩\n    have mem : x ⊗ₜ[R] m ∈ LinearMap.ker (l23.rTensor M) := by simp [hx]\n    rw [LinearMap.exact_iff.1 ex] at mem\n    obtain ⟨y, hy⟩ := mem\n\n    refine ⟨LinearMap.rTensor M (LinearMap.rangeRestrict _ ∘ₗ LinearMap.rangeRestrict l12) y,\n      Module.Flat.rTensor_preserves_injective_linearMap (LinearMap.ker l23).subtype\n      Subtype.val_injective ?_⟩\n    simp only [LinearMap.comp_codRestrict, LinearMap.rTensor_tmul, Submodule.coe_subtype, ← hy]\n    rw [← LinearMap.comp_apply]\n    erw [← LinearMap.rTensor_comp]\n    rw [← LinearMap.comp_apply, ← LinearMap.rTensor_comp, LinearMap.comp_assoc,\n      LinearMap.subtype_comp_codRestrict, ← LinearMap.comp_assoc, Submodule.subtype_comp_inclusion,\n      LinearMap.subtype_comp_codRestrict]\n  | add x y hx hy =>\n    obtain ⟨x, rfl⟩ := hx; obtain ⟨y, rfl⟩ := hy\n    exact ⟨x + y, by simp⟩\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_reflects_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN1 : Type u_1\ninst✝⁵ : AddCommGroup N1\ninst✝⁴ : Module R N1\nN2 : Type u_2\ninst✝³ : AddCommGroup N2\ninst✝² : Module R N2\nN3 : Type u_3\ninst✝¹ : AddCommGroup N3\ninst✝ : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ⇑(LinearMap.lTensor M l12) ⇑(LinearMap.lTensor M l23)\n⊢ Function.Exact ⇑l12 ⇑l23","decl":"lemma lTensor_reflects_exact [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.lTensor M) (l23.lTensor M)) :\n    Function.Exact l12 l23 :=\n  rTensor_reflects_exact R M _ _ <| ex.of_ladder_linearEquiv_of_exact\n    (e₁ := TensorProduct.comm _ _ _) (e₂ := TensorProduct.comm _ _ _)\n    (e₃ := TensorProduct.comm _ _ _) (by ext; rfl) (by ext; rfl)\n\n"}
{"name":"Module.FaithfullyFlat.exact_iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nfl : Module.FaithfullyFlat R M\nN1 : Type (max u v)\ninst✝⁵ : AddCommGroup N1\ninst✝⁴ : Module R N1\nN2 : Type (max u v)\ninst✝³ : AddCommGroup N2\ninst✝² : Module R N2\nN3 : Type (max u v)\ninst✝¹ : AddCommGroup N3\ninst✝ : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\n⊢ Iff (Function.Exact ⇑l12 ⇑l23) (Function.Exact ⇑(LinearMap.rTensor M l12) ⇑(LinearMap.rTensor M l23))","decl":"lemma exact_iff_rTensor_exact [fl : FaithfullyFlat R M]\n    {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n    {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n    {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n    (l12 : N1 →ₗ[R] N2) (l23 : N2 →ₗ[R] N3) :\n    Function.Exact l12 l23 ↔ Function.Exact (l12.rTensor M) (l23.rTensor M) :=\n  ⟨fun e => Module.Flat.iff_rTensor_exact.1 fl.toFlat e,\n    fun ex => rTensor_reflects_exact R M l12 l23 ex⟩\n\n"}
{"name":"Module.FaithfullyFlat.iff_exact_iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (∀ {N1 : Type (max u v)} [inst : AddCommGroup N1] [inst_1 : Module R N1] {N2 : Type (max u v)} [inst_2 : AddCommGroup N2] [inst_3 : Module R N2] {N3 : Type (max u v)} [inst_4 : AddCommGroup N3] [inst_5 : Module R N3] (l12 : LinearMap (RingHom.id R) N1 N2) (l23 : LinearMap (RingHom.id R) N2 N3), Iff (Function.Exact ⇑l12 ⇑l23) (Function.Exact ⇑(LinearMap.rTensor M l12) ⇑(LinearMap.rTensor M l23)))","decl":"lemma iff_exact_iff_rTensor_exact :\n    FaithfullyFlat R M ↔\n    (∀ {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n      {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n      {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n      (l12 : N1 →ₗ[R] N2) (l23 : N2 →ₗ[R] N3),\n        Function.Exact l12 l23 ↔ Function.Exact (l12.rTensor M) (l23.rTensor M)) :=\n  ⟨fun fl => exact_iff_rTensor_exact R M, fun iff_exact =>\n    iff_flat_and_rTensor_reflects_triviality _ _ |>.2 ⟨Flat.iff_rTensor_exact.2 <| by aesop,\n    fun N _ _ h => subsingleton_iff_forall_eq 0 |>.2 <| fun y => by\n      simpa [eq_comm] using (iff_exact (0 : PUnit →ₗ[R] N) (0 : N →ₗ[R] PUnit) |>.2 fun x => by\n        simpa using Subsingleton.elim _ _) y⟩⟩\n\n"}
{"name":"Module.FaithfullyFlat.iff_exact_iff_lTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (∀ {N1 : Type (max u v)} [inst : AddCommGroup N1] [inst_1 : Module R N1] {N2 : Type (max u v)} [inst_2 : AddCommGroup N2] [inst_3 : Module R N2] {N3 : Type (max u v)} [inst_4 : AddCommGroup N3] [inst_5 : Module R N3] (l12 : LinearMap (RingHom.id R) N1 N2) (l23 : LinearMap (RingHom.id R) N2 N3), Iff (Function.Exact ⇑l12 ⇑l23) (Function.Exact ⇑(LinearMap.lTensor M l12) ⇑(LinearMap.lTensor M l23)))","decl":"lemma iff_exact_iff_lTensor_exact :\n    FaithfullyFlat R M ↔\n    (∀ {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n      {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n      {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n      (l12 : N1 →ₗ[R] N2) (l23 : N2 →ₗ[R] N3),\n        Function.Exact l12 l23 ↔ Function.Exact (l12.lTensor M) (l23.lTensor M)) := by\n  simp only [iff_exact_iff_rTensor_exact, LinearMap.rTensor_exact_iff_lTensor_exact]\n\n"}
{"name":"Module.FaithfullyFlat.zero_iff_lTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nh : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nN' : Type u_2\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) N N'\n⊢ Iff (Eq f 0) (Eq (LinearMap.lTensor M f) 0)","decl":"/--\nIf `M` is a faithfully flat module, then for all linear maps `f`, the map `id ⊗ f = 0`, if and only\nif `f = 0`. -/\nlemma zero_iff_lTensor_zero [h: FaithfullyFlat R M]\n    {N : Type*} [AddCommGroup N] [Module R N]\n    {N' : Type*} [AddCommGroup N'] [Module R N'] (f : N →ₗ[R] N') :\n    f = 0 ↔ LinearMap.lTensor M f = 0 :=\n  ⟨fun hf => hf.symm ▸ LinearMap.lTensor_zero M, fun hf => by\n    have := lTensor_reflects_exact R M f LinearMap.id (by\n      rw [LinearMap.exact_iff, hf, LinearMap.range_zero, LinearMap.ker_eq_bot]\n      apply Module.Flat.lTensor_preserves_injective_linearMap\n      exact fun _ _ h => h)\n    ext x; simpa using this (f x)⟩\n\n\n"}
{"name":"Module.FaithfullyFlat.zero_iff_rTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nh : Module.FaithfullyFlat R M\nN : Type u_1\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nN' : Type u_2\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) N N'\n⊢ Iff (Eq f 0) (Eq (LinearMap.rTensor M f) 0)","decl":"/--\nIf `M` is a faithfully flat module, then for all linear maps `f`, the map `f ⊗ id = 0`, if and only\nif `f = 0`. -/\nlemma zero_iff_rTensor_zero [h: FaithfullyFlat R M]\n    {N : Type*} [AddCommGroup N] [Module R N]\n    {N' : Type*} [AddCommGroup N'] [Module R N']\n    (f : N →ₗ[R] N') :\n    f = 0 ↔ LinearMap.rTensor M f = 0 :=\n  zero_iff_lTensor_zero R M f |>.trans\n  ⟨fun h => by ext n m; exact (TensorProduct.comm R N' M).injective <|\n    (by simpa using congr($h (m ⊗ₜ n))), fun h => by\n    ext m n; exact (TensorProduct.comm R M N').injective <| (by simpa using congr($h (n ⊗ₜ m)))⟩\n\n"}
{"name":"Module.FaithfullyFlat.one_tmul_eq_zero_iff","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nA : Type u_1\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Module.FaithfullyFlat R A\nm : M\n⊢ Iff (Eq (TensorProduct.tmul R 1 m) 0) (Eq m 0)","decl":"/-- If `A` is a faithfully flat `R`-algebra, and `m` is a term of an `R`-module `M`,\nthen `1 ⊗ₜ[R] m = 0` if and only if `m = 0`. -/\n@[simp]\ntheorem one_tmul_eq_zero_iff {A : Type*} [CommRing A] [Algebra R A] [FaithfullyFlat R A] (m : M) :\n    (1:A) ⊗ₜ[R] m = 0 ↔ m = 0 := by\n  constructor; swap\n  · rintro rfl; rw [tmul_zero]\n  intro h\n  let f : R →ₗ[R] M := (LinearMap.lsmul R M).flip m\n  suffices f = 0 by simpa [f] using DFunLike.congr_fun this 1\n  rw [Module.FaithfullyFlat.zero_iff_lTensor_zero R A]\n  ext a\n  apply_fun (a • ·) at h\n  rw [smul_zero, smul_tmul', smul_eq_mul, mul_one] at h\n  simpa [f]\n\n"}
{"name":"Module.FaithfullyFlat.iff_zero_iff_lTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ {N : Type (max u v)} [inst : AddCommGroup N] [inst_1 : Module R N] {N' : Type (max u v)} [inst_2 : AddCommGroup N'] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Iff (Eq (LinearMap.lTensor M f) 0) (Eq f 0)))","decl":"/--\nAn `R`-module `M` is faithfully flat iff it is flat and for all linear maps `f`, the map\n`id ⊗ f = 0`, if and only if `f = 0`. -/\nlemma iff_zero_iff_lTensor_zero :\n    FaithfullyFlat R M ↔\n    (Module.Flat R M ∧\n      (∀ {N : Type max u v} [AddCommGroup N] [Module R N]\n        {N' : Type max u v} [AddCommGroup N'] [Module R N']\n        (f : N →ₗ[R] N'), f.lTensor M = 0 ↔ f = 0)) :=\n  ⟨fun fl => ⟨inferInstance, fun f => zero_iff_lTensor_zero R M f |>.symm⟩,\n    fun ⟨flat, Z⟩ => iff_flat_and_lTensor_reflects_triviality R M |>.2 ⟨flat, fun N _ _ _ => by\n      have := Z (LinearMap.id : N →ₗ[R] N) |>.1 (by ext; exact Subsingleton.elim _ _)\n      rw [subsingleton_iff_forall_eq 0]\n      exact fun y => congr($this y)⟩⟩\n\n"}
{"name":"Module.FaithfullyFlat.iff_zero_iff_rTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (∀ {N : Type (max u v)} [inst : AddCommGroup N] [inst_1 : Module R N] {N' : Type (max u v)} [inst_2 : AddCommGroup N'] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Iff (Eq (LinearMap.rTensor M f) 0) (Eq f 0)))","decl":"/--\nAn `R`-module `M` is faithfully flat iff it is flat and for all linear maps `f`, the map\n`id ⊗ f = 0`, if and only if `f = 0`. -/\nlemma iff_zero_iff_rTensor_zero :\n    FaithfullyFlat R M ↔\n    (Module.Flat R M ∧\n      (∀ {N : Type max u v} [AddCommGroup N] [Module R N]\n        {N' : Type max u v} [AddCommGroup N'] [Module R N']\n        (f : N →ₗ[R] N'), f.rTensor M = 0 ↔ (f = 0))) :=\n  ⟨fun fl => ⟨inferInstance, fun f => zero_iff_rTensor_zero R M f |>.symm⟩,\n    fun ⟨flat, Z⟩ => iff_flat_and_rTensor_reflects_triviality R M |>.2 ⟨flat, fun N _ _ _ => by\n      have := Z (LinearMap.id : N →ₗ[R] N) |>.1 (by ext; exact Subsingleton.elim _ _)\n      rw [subsingleton_iff_forall_eq 0]\n      exact fun y => congr($this y)⟩⟩\n\n"}
{"name":"Module.FaithfullyFlat.trans","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nS : Type u_2\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nM : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Module.FaithfullyFlat R S\ninst✝ : Module.FaithfullyFlat S M\n⊢ Module.FaithfullyFlat R M","decl":"include S in\n/-- If `S` is a faithfully flat `R`-algebra, then any faithfully flat `S`-Module is faithfully flat\nas an `R`-module. -/\ntheorem trans : FaithfullyFlat R M := by\n  rw [iff_zero_iff_lTensor_zero]\n  refine ⟨Module.Flat.trans R S M, @fun N _ _ N' _ _ f => ⟨fun aux => ?_, fun eq => eq ▸ by simp⟩⟩\n  rw [zero_iff_lTensor_zero (R:= R) (M := S) f,\n    show f.lTensor S = (AlgebraTensorModule.map (A:= S) LinearMap.id f).restrictScalars R by aesop,\n    show (0 :  S ⊗[R] N →ₗ[R] S ⊗[R] N') = (0 : S ⊗[R] N →ₗ[S] S ⊗[R] N').restrictScalars R by rfl,\n    restrictScalars_inj, zero_iff_lTensor_zero (R:= S) (M := M)]\n  ext m n\n  apply_fun AlgebraTensorModule.cancelBaseChange R S S M N' using LinearEquiv.injective _\n  simpa using congr($aux (m ⊗ₜ[R] n))\n\n"}
{"name":"Module.FaithfullyFlat.comp","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nS : Type u_2\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nM : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Module.FaithfullyFlat R S\ninst✝ : Module.FaithfullyFlat S M\n⊢ Module.FaithfullyFlat R M","decl":"@[deprecated (since := \"2024-11-08\")] alias comp := trans\n\n"}
