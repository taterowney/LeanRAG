{"name":"Module.FaithfullyFlat.toFlat","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nself : Module.FaithfullyFlat R M\n‚ä¢ Module.Flat R M","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N ‚Üí N'` such that `id ‚äó f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ‚àÄ ‚¶Ém : Ideal R‚¶Ñ (_ : Ideal.IsMaximal m), m ‚Ä¢ (‚ä§ : Submodule R M) ‚â† ‚ä§\n\n"}
{"name":"Module.FaithfullyFlat.submodule_ne_top","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nself : Module.FaithfullyFlat R M\nm : Ideal R\nx‚úù : m.IsMaximal\n‚ä¢ Ne (HSMul.hSMul m Top.top) Top.top","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N ‚Üí N'` such that `id ‚äó f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ‚àÄ ‚¶Ém : Ideal R‚¶Ñ (_ : Ideal.IsMaximal m), m ‚Ä¢ (‚ä§ : Submodule R M) ‚â† ‚ä§\n\n"}
{"name":"Module.faithfullyFlat_iff","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ ‚¶Ém : Ideal R‚¶Ñ, m.IsMaximal ‚Üí Ne (HSMul.hSMul m Top.top) Top.top))","decl":"/--\nA module `M` over a commutative ring `R` is *faithfully flat* if it is flat and,\nfor all `R`-linear maps `f : N ‚Üí N'` such that `id ‚äó f = 0`, we have `f = 0`.\n-/\n@[mk_iff] class FaithfullyFlat extends Module.Flat R M : Prop where\n  submodule_ne_top : ‚àÄ ‚¶Ém : Ideal R‚¶Ñ (_ : Ideal.IsMaximal m), m ‚Ä¢ (‚ä§ : Submodule R M) ‚â† ‚ä§\n\n"}
{"name":"Module.FaithfullyFlat.self","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst‚úù : CommRing R\n‚ä¢ Module.FaithfullyFlat R R","decl":"instance self : FaithfullyFlat R R where\n  submodule_ne_top m h r := Ideal.eq_top_iff_one _ |>.not.1 h.ne_top <| by\n    simpa using show 1 ‚àà (m ‚Ä¢ ‚ä§ : Ideal R) from r.symm ‚ñ∏ ‚ü®‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_proper_ideal","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (I : Ideal R), Ne I Top.top ‚Üí Ne (HSMul.hSMul I Top.top) Top.top))","decl":"lemma iff_flat_and_proper_ideal :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí I ‚Ä¢ (‚ä§ : Submodule R M) ‚â† ‚ä§) := by\n  rw [faithfullyFlat_iff]\n  refine ‚ü®fun ‚ü®flat, h‚ü© => ‚ü®flat, fun I hI r => ?_‚ü©, fun h => ‚ü®h.1, fun m hm => h.2 _ hm.ne_top‚ü©‚ü©\n  obtain ‚ü®m, hm, le‚ü© := I.exists_le_maximal hI\n  exact h hm <| eq_top_iff.2 <| show ‚ä§ ‚â§ m ‚Ä¢ ‚ä§ from r ‚ñ∏ Submodule.smul_mono le (by simp [r])\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_ideal_smul_eq_top","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (I : Ideal R), Eq (HSMul.hSMul I Top.top) Top.top ‚Üí Eq I Top.top))","decl":"lemma iff_flat_and_ideal_smul_eq_top :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß ‚àÄ (I : Ideal R), I ‚Ä¢ (‚ä§ : Submodule R M) = ‚ä§ ‚Üí I = ‚ä§) :=\n  iff_flat_and_proper_ideal R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun I => eq_iff_iff.2 <| by tauto\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_nontrivial","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Åµ : CommRing R\ninst‚úù‚Å¥ : AddCommGroup M\ninst‚úù¬≥ : Module R M\nfl : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R N\ninst‚úù : Nontrivial N\n‚ä¢ Nontrivial (TensorProduct R N M)","decl":"instance rTensor_nontrivial\n    [fl: FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N] [Nontrivial N] :\n    Nontrivial (N ‚äó[R] M) := by\n  obtain ‚ü®n, hn‚ü© := nontrivial_iff_exists_ne (0 : N) |>.1 inferInstance\n  let I := (Submodule.span R {n}).annihilator\n  by_cases I_ne_top : I = ‚ä§\n  ¬∑ rw [Ideal.eq_top_iff_one, Submodule.mem_annihilator_span_singleton, one_smul] at I_ne_top\n    contradiction\n  let inc : R ‚ß∏ I ‚Üí‚Çó[R] N := Submodule.liftQ _ ((LinearMap.lsmul R N).flip n) <| fun r hr => by\n    simpa only [LinearMap.mem_ker, LinearMap.flip_apply, LinearMap.lsmul_apply,\n      Submodule.mem_annihilator_span_singleton, I] using hr\n  have injective_inc : Function.Injective inc := LinearMap.ker_eq_bot.1 <| eq_bot_iff.2 <| by\n    intro r hr\n    induction r using Quotient.inductionOn' with | h r =>\n    simpa only [Submodule.Quotient.mk''_eq_mk, Submodule.mem_bot, Submodule.Quotient.mk_eq_zero,\n      Submodule.mem_annihilator_span_singleton, LinearMap.mem_ker, Submodule.liftQ_apply,\n      LinearMap.flip_apply, LinearMap.lsmul_apply, I, inc] using hr\n  have ne_top := iff_flat_and_proper_ideal R M |>.1 fl |>.2 I I_ne_top\n  refine subsingleton_or_nontrivial _ |>.resolve_left fun rid => ?_\n  exact False.elim <| ne_top <| Submodule.subsingleton_quotient_iff_eq_top.1 <|\n    Function.Injective.comp (g := LinearMap.rTensor M inc)\n      (fl.toFlat.rTensor_preserves_injective_linearMap inc injective_inc)\n      ((quotTensorEquivQuotSMul M I).symm.injective) |>.subsingleton\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_nontrivial","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∂ : CommRing R\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\ninst‚úù¬≥ : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R N\ninst‚úù : Nontrivial N\n‚ä¢ Nontrivial (TensorProduct R M N)","decl":"instance lTensor_nontrivial\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N] [Nontrivial N] :\n    Nontrivial (M ‚äó[R] N) :=\n  TensorProduct.comm R M N |>.toEquiv.nontrivial\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Åµ : CommRing R\ninst‚úù‚Å¥ : AddCommGroup M\ninst‚úù¬≥ : Module R M\ninst‚úù¬≤ : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬π : AddCommGroup N\ninst‚úù : Module R N\nh : Subsingleton (TensorProduct R N M)\n‚ä¢ Subsingleton N","decl":"lemma rTensor_reflects_triviality\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N]\n    [h : Subsingleton (N ‚äó[R] M)] : Subsingleton N := by\n  revert h; change _ ‚Üí _; contrapose\n  simp only [not_subsingleton_iff_nontrivial]\n  intro h\n  infer_instance\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∂ : CommRing R\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\ninst‚úù¬≥ : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R N\ninst‚úù : Subsingleton (TensorProduct R M N)\n‚ä¢ Subsingleton N","decl":"lemma lTensor_reflects_triviality\n    [FaithfullyFlat R M] (N : Type*) [AddCommGroup N] [Module R N]\n    [Subsingleton (M ‚äó[R] N)] :\n    Subsingleton N := by\n  haveI : Subsingleton (N ‚äó[R] M) := (TensorProduct.comm R N M).toEquiv.injective.subsingleton\n  apply rTensor_reflects_triviality R M\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_rTensor_faithful","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Nontrivial N ‚Üí Nontrivial (TensorProduct R N M)))","decl":"attribute [-simp] Ideal.Quotient.mk_eq_mk in\nlemma iff_flat_and_rTensor_faithful :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß\n      ‚àÄ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Nontrivial N ‚Üí Nontrivial (N ‚äó[R] M)) := by\n  refine ‚ü®fun fl => ‚ü®inferInstance, rTensor_nontrivial R M‚ü©, fun ‚ü®flat, faithful‚ü© => ‚ü®?_‚ü©‚ü©\n  intro m hm rid\n  specialize faithful (ULift (R ‚ß∏ m)) inferInstance\n  haveI : Nontrivial ((R ‚ß∏ m) ‚äó[R] M) :=\n    (congr (ULift.moduleEquiv : ULift (R ‚ß∏ m) ‚âÉ‚Çó[R] R ‚ß∏ m)\n      (LinearEquiv.refl R M)).symm.toEquiv.nontrivial\n  have := (quotTensorEquivQuotSMul M m).toEquiv.symm.nontrivial\n  haveI H : Subsingleton (M ‚ß∏ m ‚Ä¢ (‚ä§ : Submodule R M)) := by\n    rwa [Submodule.subsingleton_quotient_iff_eq_top]\n  rw [‚Üê not_nontrivial_iff_subsingleton] at H\n  contradiction\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_rTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Subsingleton (TensorProduct R N M) ‚Üí Subsingleton N))","decl":"lemma iff_flat_and_rTensor_reflects_triviality :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß\n      ‚àÄ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Subsingleton (N ‚äó[R] M) ‚Üí Subsingleton N) :=\n  iff_flat_and_rTensor_faithful R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun N => forall_congr fun _ => forall_congr fun _ => iff_iff_eq.1 <| by\n      simp only [‚Üê not_subsingleton_iff_nontrivial]; tauto\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_lTensor_faithful","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Nontrivial N ‚Üí Nontrivial (TensorProduct R M N)))","decl":"lemma iff_flat_and_lTensor_faithful :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß\n      ‚àÄ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Nontrivial N ‚Üí Nontrivial (M ‚äó[R] N)) :=\n  iff_flat_and_rTensor_faithful R M |>.trans\n  ‚ü®fun ‚ü®flat, faithful‚ü© => ‚ü®flat, fun N _ _ _ =>\n      letI := faithful N inferInstance; (TensorProduct.comm R M N).toEquiv.nontrivial‚ü©,\n    fun ‚ü®flat, faithful‚ü© => ‚ü®flat, fun N _ _ _ =>\n      letI := faithful N inferInstance; (TensorProduct.comm R M N).symm.toEquiv.nontrivial‚ü©‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.iff_flat_and_lTensor_reflects_triviality","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ (N : Type (max u v)) [inst : AddCommGroup N] [inst_1 : Module R N], Subsingleton (TensorProduct R M N) ‚Üí Subsingleton N))","decl":"lemma iff_flat_and_lTensor_reflects_triviality :\n    FaithfullyFlat R M ‚Üî\n    (Flat R M ‚àß\n      ‚àÄ (N : Type max u v) [AddCommGroup N] [Module R N],\n        Subsingleton (M ‚äó[R] N) ‚Üí Subsingleton N) :=\n  iff_flat_and_lTensor_faithful R M |>.trans <| and_congr_right_iff.2 fun _ => iff_of_eq <|\n    forall_congr fun N => forall_congr fun _ => forall_congr fun _ => iff_iff_eq.1 <| by\n      simp only [‚Üê not_subsingleton_iff_nontrivial]; tauto\n\n"}
{"name":"Module.FaithfullyFlat.of_linearEquiv","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Åµ : CommRing R\ninst‚úù‚Å¥ : AddCommGroup M\ninst‚úù¬≥ : Module R M\nN : Type u_1\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R N\ninst‚úù : Module.FaithfullyFlat R M\ne : LinearEquiv (RingHom.id R) N M\n‚ä¢ Module.FaithfullyFlat R N","decl":"/-- If `M` is a faithfully flat `R`-module and `N` is `R`-linearly isomorphic to `M`, then\n`N` is faithfully flat. -/\nlemma of_linearEquiv {N : Type*} [AddCommGroup N] [Module R N] [FaithfullyFlat R M]\n    (e : N ‚âÉ‚Çó[R] M) : FaithfullyFlat R N := by\n  rw [iff_flat_and_lTensor_faithful]\n  exact ‚ü®Flat.of_linearEquiv e,\n    fun P _ _ hP ‚Ü¶ (TensorProduct.congr e (LinearEquiv.refl R P)).toEquiv.nontrivial‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.directSum","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : CommRing R\nŒπ : Type u_1\ninst‚úù¬≥ : Nonempty Œπ\nM : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : (i : Œπ) ‚Üí AddCommGroup (M i)\ninst‚úù¬π : (i : Œπ) ‚Üí Module R (M i)\ninst‚úù : ‚àÄ (i : Œπ), Module.FaithfullyFlat R (M i)\n‚ä¢ Module.FaithfullyFlat R (DirectSum Œπ fun i => M i)","decl":"/-- A direct sum of faithfully flat `R`-modules is faithfully flat. -/\ninstance directSum {Œπ : Type*} [Nonempty Œπ] (M : Œπ ‚Üí Type*) [‚àÄ i, AddCommGroup (M i)]\n    [‚àÄ i, Module R (M i)] [‚àÄ i, FaithfullyFlat R (M i)] : FaithfullyFlat R (‚®Å i, M i) := by\n  classical\n  rw [iff_flat_and_lTensor_faithful]\n  refine ‚ü®inferInstance, fun N _ _ hN ‚Ü¶ ?_‚ü©\n  obtain ‚ü®i‚ü© := ‚ÄπNonempty Œπ‚Ä∫\n  obtain ‚ü®x, y, hxy‚ü© := Nontrivial.exists_pair_ne (Œ± := M i ‚äó[R] N)\n  haveI : Nontrivial (‚®Å (i : Œπ), M i ‚äó[R] N) :=\n    ‚ü®DirectSum.of _ i x, DirectSum.of _ i y, fun h ‚Ü¶ hxy (DirectSum.of_injective i h)‚ü©\n  apply (TensorProduct.directSumLeft R M N).toEquiv.nontrivial\n\n"}
{"name":"Module.FaithfullyFlat.finsupp","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nŒπ : Type v\ninst‚úù : Nonempty Œπ\n‚ä¢ Module.FaithfullyFlat R (Finsupp Œπ R)","decl":"/-- Free `R`-modules over discrete types are flat. -/\ninstance finsupp (Œπ : Type v) [Nonempty Œπ] : FaithfullyFlat R (Œπ ‚Üí‚ÇÄ R) := by\n  classical exact of_linearEquiv _ _ (finsuppLEquivDirectSum R R Œπ)\n\n"}
{"name":"Module.FaithfullyFlat.instOfNontrivialOfFree","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å¥ : CommRing R\ninst‚úù¬≥ : AddCommGroup M\ninst‚úù¬≤ : Module R M\ninst‚úù¬π : Nontrivial M\ninst‚úù : Module.Free R M\n‚ä¢ Module.FaithfullyFlat R M","decl":"/-- Any free, nontrivial `R`-module is flat. -/\ninstance [Nontrivial M] [Module.Free R M] : FaithfullyFlat R M :=\n  of_linearEquiv _ _ (Free.repr R M)\n\n"}
{"name":"Module.FaithfullyFlat.range_le_ker_of_exact_rTensor","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∏ : CommRing R\ninst‚úù‚Å∑ : AddCommGroup M\ninst‚úù‚Å∂ : Module R M\nN1 : Type u_1\ninst‚úù‚Åµ : AddCommGroup N1\ninst‚úù‚Å¥ : Module R N1\nN2 : Type u_2\ninst‚úù¬≥ : AddCommGroup N2\ninst‚úù¬≤ : Module R N2\nN3 : Type u_3\ninst‚úù¬π : AddCommGroup N3\ninst‚úù : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ‚áë(LinearMap.rTensor M l12) ‚áë(LinearMap.rTensor M l23)\n‚ä¢ LE.le (LinearMap.range l12) (LinearMap.ker l23)","decl":"/--\nIf `M` is faithfully flat, then exactness of `N‚ÇÅ ‚äó M -> N‚ÇÇ ‚äó M -> N‚ÇÉ ‚äó M` implies that the\ncomposition `N‚ÇÅ -> N‚ÇÇ -> N‚ÇÉ` is `0`.\n\nImplementation detail, please use `rTensor_reflects_exact` instead.\n-/\nlemma range_le_ker_of_exact_rTensor [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.rTensor M) (l23.rTensor M)) :\n    LinearMap.range l12 ‚â§ LinearMap.ker l23 := by\n  -- let `n1 ‚àà N1`. We need to show `l23 (l12 n1) = 0`. Suppose this is not the case.\n  rintro _ ‚ü®n1, rfl‚ü©\n  rw [LinearMap.mem_ker]\n  by_contra! hn1\n  -- Let `E` be the submodule spanned by `l23 (l12 n1)`. Then because `l23 (l12 n1) ‚â† 0`, we have\n  -- `E ‚â† 0`.\n  let E : Submodule R N3 := Submodule.span R {l23 (l12 n1)}\n  have hE : Nontrivial E :=\n    ‚ü®0, ‚ü®‚ü®l23 (l12 n1), Submodule.mem_span_singleton_self _‚ü©, Subtype.coe_ne_coe.1 hn1.symm‚ü©‚ü©\n\n  -- Since `N1 ‚äó M -> N2 ‚äó M -> N3 ‚äó M` is exact, we have `l23 (l12 n1) ‚äó‚Çú m = 0` for all `m : M`.\n  have eq1 : ‚àÄ (m : M), l23 (l12 n1) ‚äó‚Çú[R] m = 0 := fun m ‚Ü¶\n    ex.apply_apply_eq_zero (n1 ‚äó‚Çú[R] m)\n  -- Then `E ‚äó M = 0`. Indeed,\n  have eq0 : (‚ä§ : Submodule R (E ‚äó[R] M)) = ‚ä• := by\n    -- suppose `x ‚àà E ‚äó M`. We will show `x = 0`.\n    ext x\n    simp only [Submodule.mem_top, Submodule.mem_bot, true_iff]\n    have mem : x ‚àà (‚ä§ : Submodule R _) := ‚ü®‚ü©\n    rw [‚Üê TensorProduct.span_tmul_eq_top, mem_span_set] at mem\n    obtain ‚ü®c, hc, rfl‚ü© := mem\n    choose b a hy using hc\n    let r :  ‚¶Éa : E ‚äó[R] M‚¶Ñ ‚Üí a ‚àà ‚Üëc.support ‚Üí R := fun a ha =>\n      Submodule.mem_span_singleton.1 (b ha).2 |>.choose\n    have hr : ‚àÄ ‚¶Éi : E ‚äó[R] M‚¶Ñ (hi : i ‚àà c.support), b hi =\n        r hi ‚Ä¢ ‚ü®l23 (l12 n1), Submodule.mem_span_singleton_self _‚ü© := fun a ha =>\n      Subtype.ext <| Submodule.mem_span_singleton.1 (b ha).2 |>.choose_spec.symm\n    -- Since `M` is flat and `E -> N1` is injective, we only need to check that x = 0\n    -- in `N1 ‚äó M`. We write `x = ‚àë Œº·µ¢ ‚Ä¢ (l23 (l12 n1)) ‚äó m·µ¢ = ‚àë Œº·µ¢ ‚Ä¢ 0 = 0`\n    -- (remember `E = span {l23 (l12 n1)}` and `eq1`)\n    refine Finset.sum_eq_zero fun i hi => show c i ‚Ä¢ i = 0 from\n      (Module.Flat.rTensor_preserves_injective_linearMap (M := M) E.subtype <|\n              Submodule.injective_subtype E) ?_\n    rw [‚Üê hy hi, hr hi, smul_tmul, map_smul, LinearMap.rTensor_tmul, Submodule.subtype_apply, eq1,\n      smul_zero, map_zero]\n  have : Subsingleton (E ‚äó[R] M) := subsingleton_iff_forall_eq 0 |>.2 fun x =>\n    show x ‚àà (‚ä• : Submodule R _) from eq0 ‚ñ∏ ‚ü®‚ü©\n\n  -- but `E ‚äó M = 0` implies `E = 0` because `M` is faithfully flat and this is a contradiction.\n  exact not_subsingleton_iff_nontrivial.2 inferInstance <| fl.rTensor_reflects_triviality R M E\n\n"}
{"name":"Module.FaithfullyFlat.rTensor_reflects_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∏ : CommRing R\ninst‚úù‚Å∑ : AddCommGroup M\ninst‚úù‚Å∂ : Module R M\nN1 : Type u_1\ninst‚úù‚Åµ : AddCommGroup N1\ninst‚úù‚Å¥ : Module R N1\nN2 : Type u_2\ninst‚úù¬≥ : AddCommGroup N2\ninst‚úù¬≤ : Module R N2\nN3 : Type u_3\ninst‚úù¬π : AddCommGroup N3\ninst‚úù : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ‚áë(LinearMap.rTensor M l12) ‚áë(LinearMap.rTensor M l23)\n‚ä¢ Function.Exact ‚áël12 ‚áël23","decl":"lemma rTensor_reflects_exact [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.rTensor M) (l23.rTensor M)) :\n    Function.Exact l12 l23 := LinearMap.exact_iff.2 <| by\n  have complex : LinearMap.range l12 ‚â§ LinearMap.ker l23 := range_le_ker_of_exact_rTensor R M _ _ ex\n  -- By the previous lemma we have that range l12 ‚â§ ker l23 and hence the quotient\n  -- H := ker l23 ‚ß∏ range l12 makes sense.\n  -- Hence our goal ker l23 = range l12 follows from the claim that H = 0.\n  let H := LinearMap.ker l23 ‚ß∏ LinearMap.range (Submodule.inclusion complex)\n  suffices triv_coh : Subsingleton H by\n    rw [Submodule.subsingleton_quotient_iff_eq_top, Submodule.range_inclusion,\n      Submodule.comap_subtype_eq_top] at triv_coh\n    exact le_antisymm triv_coh complex\n\n  -- Since `M` is faithfully flat, we need only to show that `H ‚äó M` is trivial.\n  suffices Subsingleton (H ‚äó[R] M) from rTensor_reflects_triviality R M H\n  let e : H ‚äó[R] M ‚âÉ‚Çó[R] _ := TensorProduct.quotientTensorEquiv _ _\n  -- Note that `H ‚äó M` is isomorphic to `ker l12 ‚äó M ‚ß∏ range ((range l12 ‚äó M) -> (ker l23 ‚äó M))`.\n  -- So the problem is reduced to proving surjectivity of `range l12 ‚äó M ‚Üí ker l23 ‚äó M`.\n  rw [e.toEquiv.subsingleton_congr, Submodule.subsingleton_quotient_iff_eq_top,\n    LinearMap.range_eq_top]\n  intro x\n  induction x using TensorProduct.induction_on with\n  | zero => exact ‚ü®0, by simp‚ü©\n  -- let `x ‚äó m` be an element in `ker l23 ‚äó M`, then `x ‚äó m` is in the kernel of `l23 ‚äó ùüôM`.\n  -- Since `N1 ‚äó M -l12 ‚äó M-> N2 ‚äó M -l23 ‚äó M-> N3 ‚äó M` is exact, we have that `x ‚äó m` is in\n  -- the range of `l12 ‚äó ùüôM`, i.e. `x ‚äó m = (l12 ‚äó ùüôM) y` for some `y ‚àà N1 ‚äó M` as elements of\n  -- `N2 ‚äó M`. We need to prove that `x ‚äó m = (l12 ‚äó ùüôM) y` still holds in `(ker l23) ‚äó M`.\n  -- This is okay because `M` is flat and `ker l23 -> N2` is injective.\n  | tmul x m =>\n    rcases x with ‚ü®x, (hx : l23 x = 0)‚ü©\n    have mem : x ‚äó‚Çú[R] m ‚àà LinearMap.ker (l23.rTensor M) := by simp [hx]\n    rw [LinearMap.exact_iff.1 ex] at mem\n    obtain ‚ü®y, hy‚ü© := mem\n\n    refine ‚ü®LinearMap.rTensor M (LinearMap.rangeRestrict _ ‚àò‚Çó LinearMap.rangeRestrict l12) y,\n      Module.Flat.rTensor_preserves_injective_linearMap (LinearMap.ker l23).subtype\n      Subtype.val_injective ?_‚ü©\n    simp only [LinearMap.comp_codRestrict, LinearMap.rTensor_tmul, Submodule.coe_subtype, ‚Üê hy]\n    rw [‚Üê LinearMap.comp_apply]\n    erw [‚Üê LinearMap.rTensor_comp]\n    rw [‚Üê LinearMap.comp_apply, ‚Üê LinearMap.rTensor_comp, LinearMap.comp_assoc,\n      LinearMap.subtype_comp_codRestrict, ‚Üê LinearMap.comp_assoc, Submodule.subtype_comp_inclusion,\n      LinearMap.subtype_comp_codRestrict]\n  | add x y hx hy =>\n    obtain ‚ü®x, rfl‚ü© := hx; obtain ‚ü®y, rfl‚ü© := hy\n    exact ‚ü®x + y, by simp‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.lTensor_reflects_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∏ : CommRing R\ninst‚úù‚Å∑ : AddCommGroup M\ninst‚úù‚Å∂ : Module R M\nN1 : Type u_1\ninst‚úù‚Åµ : AddCommGroup N1\ninst‚úù‚Å¥ : Module R N1\nN2 : Type u_2\ninst‚úù¬≥ : AddCommGroup N2\ninst‚úù¬≤ : Module R N2\nN3 : Type u_3\ninst‚úù¬π : AddCommGroup N3\ninst‚úù : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\nfl : Module.FaithfullyFlat R M\nex : Function.Exact ‚áë(LinearMap.lTensor M l12) ‚áë(LinearMap.lTensor M l23)\n‚ä¢ Function.Exact ‚áël12 ‚áël23","decl":"lemma lTensor_reflects_exact [fl : FaithfullyFlat R M]\n    (ex : Function.Exact (l12.lTensor M) (l23.lTensor M)) :\n    Function.Exact l12 l23 :=\n  rTensor_reflects_exact R M _ _ <| ex.of_ladder_linearEquiv_of_exact\n    (e‚ÇÅ := TensorProduct.comm _ _ _) (e‚ÇÇ := TensorProduct.comm _ _ _)\n    (e‚ÇÉ := TensorProduct.comm _ _ _) (by ext; rfl) (by ext; rfl)\n\n"}
{"name":"Module.FaithfullyFlat.exact_iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∏ : CommRing R\ninst‚úù‚Å∑ : AddCommGroup M\ninst‚úù‚Å∂ : Module R M\nfl : Module.FaithfullyFlat R M\nN1 : Type (max u v)\ninst‚úù‚Åµ : AddCommGroup N1\ninst‚úù‚Å¥ : Module R N1\nN2 : Type (max u v)\ninst‚úù¬≥ : AddCommGroup N2\ninst‚úù¬≤ : Module R N2\nN3 : Type (max u v)\ninst‚úù¬π : AddCommGroup N3\ninst‚úù : Module R N3\nl12 : LinearMap (RingHom.id R) N1 N2\nl23 : LinearMap (RingHom.id R) N2 N3\n‚ä¢ Iff (Function.Exact ‚áël12 ‚áël23) (Function.Exact ‚áë(LinearMap.rTensor M l12) ‚áë(LinearMap.rTensor M l23))","decl":"lemma exact_iff_rTensor_exact [fl : FaithfullyFlat R M]\n    {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n    {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n    {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n    (l12 : N1 ‚Üí‚Çó[R] N2) (l23 : N2 ‚Üí‚Çó[R] N3) :\n    Function.Exact l12 l23 ‚Üî Function.Exact (l12.rTensor M) (l23.rTensor M) :=\n  ‚ü®fun e => Module.Flat.iff_rTensor_exact.1 fl.toFlat e,\n    fun ex => rTensor_reflects_exact R M l12 l23 ex‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.iff_exact_iff_rTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (‚àÄ {N1 : Type (max u v)} [inst : AddCommGroup N1] [inst_1 : Module R N1] {N2 : Type (max u v)} [inst_2 : AddCommGroup N2] [inst_3 : Module R N2] {N3 : Type (max u v)} [inst_4 : AddCommGroup N3] [inst_5 : Module R N3] (l12 : LinearMap (RingHom.id R) N1 N2) (l23 : LinearMap (RingHom.id R) N2 N3), Iff (Function.Exact ‚áël12 ‚áël23) (Function.Exact ‚áë(LinearMap.rTensor M l12) ‚áë(LinearMap.rTensor M l23)))","decl":"lemma iff_exact_iff_rTensor_exact :\n    FaithfullyFlat R M ‚Üî\n    (‚àÄ {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n      {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n      {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n      (l12 : N1 ‚Üí‚Çó[R] N2) (l23 : N2 ‚Üí‚Çó[R] N3),\n        Function.Exact l12 l23 ‚Üî Function.Exact (l12.rTensor M) (l23.rTensor M)) :=\n  ‚ü®fun fl => exact_iff_rTensor_exact R M, fun iff_exact =>\n    iff_flat_and_rTensor_reflects_triviality _ _ |>.2 ‚ü®Flat.iff_rTensor_exact.2 <| by aesop,\n    fun N _ _ h => subsingleton_iff_forall_eq 0 |>.2 <| fun y => by\n      simpa [eq_comm] using (iff_exact (0 : PUnit ‚Üí‚Çó[R] N) (0 : N ‚Üí‚Çó[R] PUnit) |>.2 fun x => by\n        simpa using Subsingleton.elim _ _) y‚ü©‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.iff_exact_iff_lTensor_exact","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (‚àÄ {N1 : Type (max u v)} [inst : AddCommGroup N1] [inst_1 : Module R N1] {N2 : Type (max u v)} [inst_2 : AddCommGroup N2] [inst_3 : Module R N2] {N3 : Type (max u v)} [inst_4 : AddCommGroup N3] [inst_5 : Module R N3] (l12 : LinearMap (RingHom.id R) N1 N2) (l23 : LinearMap (RingHom.id R) N2 N3), Iff (Function.Exact ‚áël12 ‚áël23) (Function.Exact ‚áë(LinearMap.lTensor M l12) ‚áë(LinearMap.lTensor M l23)))","decl":"lemma iff_exact_iff_lTensor_exact :\n    FaithfullyFlat R M ‚Üî\n    (‚àÄ {N1 : Type max u v} [AddCommGroup N1] [Module R N1]\n      {N2 : Type max u v} [AddCommGroup N2] [Module R N2]\n      {N3 : Type max u v} [AddCommGroup N3] [Module R N3]\n      (l12 : N1 ‚Üí‚Çó[R] N2) (l23 : N2 ‚Üí‚Çó[R] N3),\n        Function.Exact l12 l23 ‚Üî Function.Exact (l12.lTensor M) (l23.lTensor M)) := by\n  simp only [iff_exact_iff_rTensor_exact, LinearMap.rTensor_exact_iff_lTensor_exact]\n\n"}
{"name":"Module.FaithfullyFlat.zero_iff_lTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∂ : CommRing R\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\nh : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬≥ : AddCommGroup N\ninst‚úù¬≤ : Module R N\nN' : Type u_2\ninst‚úù¬π : AddCommGroup N'\ninst‚úù : Module R N'\nf : LinearMap (RingHom.id R) N N'\n‚ä¢ Iff (Eq f 0) (Eq (LinearMap.lTensor M f) 0)","decl":"/--\nIf `M` is a faithfully flat module, then for all linear maps `f`, the map `id ‚äó f = 0`, if and only\nif `f = 0`. -/\nlemma zero_iff_lTensor_zero [h: FaithfullyFlat R M]\n    {N : Type*} [AddCommGroup N] [Module R N]\n    {N' : Type*} [AddCommGroup N'] [Module R N'] (f : N ‚Üí‚Çó[R] N') :\n    f = 0 ‚Üî LinearMap.lTensor M f = 0 :=\n  ‚ü®fun hf => hf.symm ‚ñ∏ LinearMap.lTensor_zero M, fun hf => by\n    have := lTensor_reflects_exact R M f LinearMap.id (by\n      rw [LinearMap.exact_iff, hf, LinearMap.range_zero, LinearMap.ker_eq_bot]\n      apply Module.Flat.lTensor_preserves_injective_linearMap\n      exact fun _ _ h => h)\n    ext x; simpa using this (f x)‚ü©\n\n\n"}
{"name":"Module.FaithfullyFlat.zero_iff_rTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Å∂ : CommRing R\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\nh : Module.FaithfullyFlat R M\nN : Type u_1\ninst‚úù¬≥ : AddCommGroup N\ninst‚úù¬≤ : Module R N\nN' : Type u_2\ninst‚úù¬π : AddCommGroup N'\ninst‚úù : Module R N'\nf : LinearMap (RingHom.id R) N N'\n‚ä¢ Iff (Eq f 0) (Eq (LinearMap.rTensor M f) 0)","decl":"/--\nIf `M` is a faithfully flat module, then for all linear maps `f`, the map `f ‚äó id = 0`, if and only\nif `f = 0`. -/\nlemma zero_iff_rTensor_zero [h: FaithfullyFlat R M]\n    {N : Type*} [AddCommGroup N] [Module R N]\n    {N' : Type*} [AddCommGroup N'] [Module R N']\n    (f : N ‚Üí‚Çó[R] N') :\n    f = 0 ‚Üî LinearMap.rTensor M f = 0 :=\n  zero_iff_lTensor_zero R M f |>.trans\n  ‚ü®fun h => by ext n m; exact (TensorProduct.comm R N' M).injective <|\n    (by simpa using congr($h (m ‚äó‚Çú n))), fun h => by\n    ext m n; exact (TensorProduct.comm R M N').injective <| (by simpa using congr($h (n ‚äó‚Çú m)))‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.one_tmul_eq_zero_iff","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù‚Åµ : CommRing R\ninst‚úù‚Å¥ : AddCommGroup M\ninst‚úù¬≥ : Module R M\nA : Type u_1\ninst‚úù¬≤ : CommRing A\ninst‚úù¬π : Algebra R A\ninst‚úù : Module.FaithfullyFlat R A\nm : M\n‚ä¢ Iff (Eq (TensorProduct.tmul R 1 m) 0) (Eq m 0)","decl":"/-- If `A` is a faithfully flat `R`-algebra, and `m` is a term of an `R`-module `M`,\nthen `1 ‚äó‚Çú[R] m = 0` if and only if `m = 0`. -/\n@[simp]\ntheorem one_tmul_eq_zero_iff {A : Type*} [CommRing A] [Algebra R A] [FaithfullyFlat R A] (m : M) :\n    (1:A) ‚äó‚Çú[R] m = 0 ‚Üî m = 0 := by\n  constructor; swap\n  ¬∑ rintro rfl; rw [tmul_zero]\n  intro h\n  let f : R ‚Üí‚Çó[R] M := (LinearMap.lsmul R M).flip m\n  suffices f = 0 by simpa [f] using DFunLike.congr_fun this 1\n  rw [Module.FaithfullyFlat.zero_iff_lTensor_zero R A]\n  ext a\n  apply_fun (a ‚Ä¢ ¬∑) at h\n  rw [smul_zero, smul_tmul', smul_eq_mul, mul_one] at h\n  simpa [f]\n\n"}
{"name":"Module.FaithfullyFlat.iff_zero_iff_lTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ {N : Type (max u v)} [inst : AddCommGroup N] [inst_1 : Module R N] {N' : Type (max u v)} [inst_2 : AddCommGroup N'] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Iff (Eq (LinearMap.lTensor M f) 0) (Eq f 0)))","decl":"/--\nAn `R`-module `M` is faithfully flat iff it is flat and for all linear maps `f`, the map\n`id ‚äó f = 0`, if and only if `f = 0`. -/\nlemma iff_zero_iff_lTensor_zero :\n    FaithfullyFlat R M ‚Üî\n    (Module.Flat R M ‚àß\n      (‚àÄ {N : Type max u v} [AddCommGroup N] [Module R N]\n        {N' : Type max u v} [AddCommGroup N'] [Module R N']\n        (f : N ‚Üí‚Çó[R] N'), f.lTensor M = 0 ‚Üî f = 0)) :=\n  ‚ü®fun fl => ‚ü®inferInstance, fun f => zero_iff_lTensor_zero R M f |>.symm‚ü©,\n    fun ‚ü®flat, Z‚ü© => iff_flat_and_lTensor_reflects_triviality R M |>.2 ‚ü®flat, fun N _ _ _ => by\n      have := Z (LinearMap.id : N ‚Üí‚Çó[R] N) |>.1 (by ext; exact Subsingleton.elim _ _)\n      rw [subsingleton_iff_forall_eq 0]\n      exact fun y => congr($this y)‚ü©‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.iff_zero_iff_rTensor_zero","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u\nM : Type v\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Iff (Module.FaithfullyFlat R M) (And (Module.Flat R M) (‚àÄ {N : Type (max u v)} [inst : AddCommGroup N] [inst_1 : Module R N] {N' : Type (max u v)} [inst_2 : AddCommGroup N'] [inst_3 : Module R N'] (f : LinearMap (RingHom.id R) N N'), Iff (Eq (LinearMap.rTensor M f) 0) (Eq f 0)))","decl":"/--\nAn `R`-module `M` is faithfully flat iff it is flat and for all linear maps `f`, the map\n`id ‚äó f = 0`, if and only if `f = 0`. -/\nlemma iff_zero_iff_rTensor_zero :\n    FaithfullyFlat R M ‚Üî\n    (Module.Flat R M ‚àß\n      (‚àÄ {N : Type max u v} [AddCommGroup N] [Module R N]\n        {N' : Type max u v} [AddCommGroup N'] [Module R N']\n        (f : N ‚Üí‚Çó[R] N'), f.rTensor M = 0 ‚Üî (f = 0))) :=\n  ‚ü®fun fl => ‚ü®inferInstance, fun f => zero_iff_rTensor_zero R M f |>.symm‚ü©,\n    fun ‚ü®flat, Z‚ü© => iff_flat_and_rTensor_reflects_triviality R M |>.2 ‚ü®flat, fun N _ _ _ => by\n      have := Z (LinearMap.id : N ‚Üí‚Çó[R] N) |>.1 (by ext; exact Subsingleton.elim _ _)\n      rw [subsingleton_iff_forall_eq 0]\n      exact fun y => congr($this y)‚ü©‚ü©\n\n"}
{"name":"Module.FaithfullyFlat.trans","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u_1\ninst‚úù‚Å∏ : CommRing R\nS : Type u_2\ninst‚úù‚Å∑ : CommRing S\ninst‚úù‚Å∂ : Algebra R S\nM : Type u_3\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\ninst‚úù¬≥ : Module S M\ninst‚úù¬≤ : IsScalarTower R S M\ninst‚úù¬π : Module.FaithfullyFlat R S\ninst‚úù : Module.FaithfullyFlat S M\n‚ä¢ Module.FaithfullyFlat R M","decl":"include S in\n/-- If `S` is a faithfully flat `R`-algebra, then any faithfully flat `S`-Module is faithfully flat\nas an `R`-module. -/\ntheorem trans : FaithfullyFlat R M := by\n  rw [iff_zero_iff_lTensor_zero]\n  refine ‚ü®Module.Flat.trans R S M, @fun N _ _ N' _ _ f => ‚ü®fun aux => ?_, fun eq => eq ‚ñ∏ by simp‚ü©‚ü©\n  rw [zero_iff_lTensor_zero (R:= R) (M := S) f,\n    show f.lTensor S = (AlgebraTensorModule.map (A:= S) LinearMap.id f).restrictScalars R by aesop,\n    show (0 :  S ‚äó[R] N ‚Üí‚Çó[R] S ‚äó[R] N') = (0 : S ‚äó[R] N ‚Üí‚Çó[S] S ‚äó[R] N').restrictScalars R by rfl,\n    restrictScalars_inj, zero_iff_lTensor_zero (R:= S) (M := M)]\n  ext m n\n  apply_fun AlgebraTensorModule.cancelBaseChange R S S M N' using LinearEquiv.injective _\n  simpa using congr($aux (m ‚äó‚Çú[R] n))\n\n"}
{"name":"Module.FaithfullyFlat.comp","module":"Mathlib.RingTheory.Flat.FaithfullyFlat.Basic","initialProofState":"R : Type u_1\ninst‚úù‚Å∏ : CommRing R\nS : Type u_2\ninst‚úù‚Å∑ : CommRing S\ninst‚úù‚Å∂ : Algebra R S\nM : Type u_3\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : Module R M\ninst‚úù¬≥ : Module S M\ninst‚úù¬≤ : IsScalarTower R S M\ninst‚úù¬π : Module.FaithfullyFlat R S\ninst‚úù : Module.FaithfullyFlat S M\n‚ä¢ Module.FaithfullyFlat R M","decl":"@[deprecated (since := \"2024-11-08\")] alias comp := trans\n\n"}
