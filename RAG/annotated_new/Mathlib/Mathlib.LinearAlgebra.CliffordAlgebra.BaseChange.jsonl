{"name":"CliffordAlgebra.ofBaseChangeAux_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nv : V\n⊢ Eq ((CliffordAlgebra.ofBaseChangeAux A Q) ((CliffordAlgebra.ι Q) v)) ((CliffordAlgebra.ι (QuadraticForm.baseChange A Q)) (TensorProduct.tmul R 1 v))","decl":"@[simp] theorem ofBaseChangeAux_ι (Q : QuadraticForm R V) (v : V) :\n    ofBaseChangeAux A Q (ι Q v) = ι (Q.baseChange A) (1 ⊗ₜ v) :=\n  CliffordAlgebra.lift_ι_apply _ _ v\n\n"}
{"name":"CliffordAlgebra.ofBaseChange_tmul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nz : A\nv : V\n⊢ Eq ((CliffordAlgebra.ofBaseChange A Q) (TensorProduct.tmul R z ((CliffordAlgebra.ι Q) v))) ((CliffordAlgebra.ι (QuadraticForm.baseChange A Q)) (TensorProduct.tmul R z v))","decl":"@[simp] theorem ofBaseChange_tmul_ι (Q : QuadraticForm R V) (z : A) (v : V) :\n    ofBaseChange A Q (z ⊗ₜ ι Q v) = ι (Q.baseChange A) (z ⊗ₜ v) := by\n  show algebraMap _ _ z * ofBaseChangeAux A Q (ι Q v) = ι (Q.baseChange A) (z ⊗ₜ[R] v)\n  rw [ofBaseChangeAux_ι, ← Algebra.smul_def, ← map_smul, TensorProduct.smul_tmul', smul_eq_mul,\n    mul_one]\n\n"}
{"name":"CliffordAlgebra.ofBaseChange_tmul_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nz : A\n⊢ Eq ((CliffordAlgebra.ofBaseChange A Q) (TensorProduct.tmul R z 1)) ((algebraMap A (CliffordAlgebra (QuadraticForm.baseChange A Q))) z)","decl":"@[simp] theorem ofBaseChange_tmul_one (Q : QuadraticForm R V) (z : A) :\n    ofBaseChange A Q (z ⊗ₜ 1) = algebraMap _ _ z := by\n  show algebraMap _ _ z * ofBaseChangeAux A Q 1 = _\n  rw [map_one, mul_one]\n\n"}
{"name":"CliffordAlgebra.toBaseChange_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nz : A\nv : V\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q) ((CliffordAlgebra.ι (QuadraticForm.baseChange A Q)) (TensorProduct.tmul R z v))) (TensorProduct.tmul R z ((CliffordAlgebra.ι Q) v))","decl":"@[simp] theorem toBaseChange_ι (Q : QuadraticForm R V) (z : A) (v : V) :\n    toBaseChange A Q (ι (Q.baseChange A) (z ⊗ₜ v)) = z ⊗ₜ ι Q v :=\n  CliffordAlgebra.lift_ι_apply _ _ _\n\n"}
{"name":"CliffordAlgebra.toBaseChange_comp_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q).comp CliffordAlgebra.involute) ((Algebra.TensorProduct.map (AlgHom.id A A) CliffordAlgebra.involute).comp (CliffordAlgebra.toBaseChange A Q))","decl":"theorem toBaseChange_comp_involute (Q : QuadraticForm R V) :\n    (toBaseChange A Q).comp (involute : CliffordAlgebra (Q.baseChange A) →ₐ[A] _) =\n      (Algebra.TensorProduct.map (AlgHom.id _ _) involute).comp (toBaseChange A Q) := by\n  ext v\n  show toBaseChange A Q (involute (ι (Q.baseChange A) (1 ⊗ₜ[R] v)))\n    = (Algebra.TensorProduct.map (AlgHom.id _ _) involute :\n        A ⊗[R] CliffordAlgebra Q →ₐ[A] _)\n      (toBaseChange A Q (ι (Q.baseChange A) (1 ⊗ₜ[R] v)))\n  rw [toBaseChange_ι, involute_ι, map_neg (toBaseChange A Q), toBaseChange_ι,\n    Algebra.TensorProduct.map_tmul, AlgHom.id_apply, involute_ι, TensorProduct.tmul_neg]\n\n"}
{"name":"CliffordAlgebra.toBaseChange_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nx : CliffordAlgebra (QuadraticForm.baseChange A Q)\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q) (CliffordAlgebra.involute x)) ((TensorProduct.map LinearMap.id CliffordAlgebra.involute.toLinearMap) ((CliffordAlgebra.toBaseChange A Q) x))","decl":"/-- The involution acts only on the right of the tensor product. -/\ntheorem toBaseChange_involute (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    toBaseChange A Q (involute x) =\n      TensorProduct.map LinearMap.id (involute.toLinearMap) (toBaseChange A Q x) :=\n  DFunLike.congr_fun (toBaseChange_comp_involute A Q) x\n\n"}
{"name":"CliffordAlgebra.toBaseChange_comp_reverseOp","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\n⊢ Eq ((AlgHom.op (CliffordAlgebra.toBaseChange A Q)).comp CliffordAlgebra.reverseOp) ((↑(Algebra.TensorProduct.opAlgEquiv R A A (CliffordAlgebra Q))).comp ((Algebra.TensorProduct.map (↑(AlgEquiv.toOpposite A A)) CliffordAlgebra.reverseOp).comp (CliffordAlgebra.toBaseChange A Q)))","decl":"/-- Auxiliary theorem used to prove `toBaseChange_reverse` without needing induction. -/\ntheorem toBaseChange_comp_reverseOp (Q : QuadraticForm R V) :\n    (toBaseChange A Q).op.comp reverseOp =\n      ((Algebra.TensorProduct.opAlgEquiv R A A (CliffordAlgebra Q)).toAlgHom.comp <|\n        (Algebra.TensorProduct.map\n          (AlgEquiv.toOpposite A A).toAlgHom (reverseOp (Q := Q))).comp\n        (toBaseChange A Q)) := by\n  ext v\n  show op (toBaseChange A Q (reverse (ι (Q.baseChange A) (1 ⊗ₜ[R] v)))) =\n    Algebra.TensorProduct.opAlgEquiv R A A (CliffordAlgebra Q)\n      (Algebra.TensorProduct.map (AlgEquiv.toOpposite A A).toAlgHom (reverseOp (Q := Q))\n        (toBaseChange A Q (ι (Q.baseChange A) (1 ⊗ₜ[R] v))))\n  rw [toBaseChange_ι, reverse_ι, toBaseChange_ι, Algebra.TensorProduct.map_tmul,\n    Algebra.TensorProduct.opAlgEquiv_tmul, reverseOp_ι]\n  rfl\n\n"}
{"name":"CliffordAlgebra.toBaseChange_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nx : CliffordAlgebra (QuadraticForm.baseChange A Q)\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q) (CliffordAlgebra.reverse x)) ((TensorProduct.map LinearMap.id CliffordAlgebra.reverse) ((CliffordAlgebra.toBaseChange A Q) x))","decl":"/-- `reverse` acts only on the right of the tensor product. -/\ntheorem toBaseChange_reverse (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    toBaseChange A Q (reverse x) =\n      TensorProduct.map LinearMap.id reverse (toBaseChange A Q x) := by\n  have := DFunLike.congr_fun (toBaseChange_comp_reverseOp A Q) x\n  refine (congr_arg unop this).trans ?_; clear this\n  refine (LinearMap.congr_fun (TensorProduct.AlgebraTensorModule.map_comp _ _ _ _).symm _).trans ?_\n  rw [reverse, ← AlgEquiv.toLinearMap, ← AlgEquiv.toLinearEquiv_toLinearMap,\n    AlgEquiv.toLinearEquiv_toOpposite]\n  dsimp\n  -- `simp` fails here due to a timeout looking for a `Subsingleton` instance!?\n  rw [LinearEquiv.self_trans_symm]\n  rfl\n\n"}
{"name":"CliffordAlgebra.toBaseChange_comp_ofBaseChange","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q).comp (CliffordAlgebra.ofBaseChange A Q)) (AlgHom.id A (TensorProduct R A (CliffordAlgebra Q)))","decl":"theorem toBaseChange_comp_ofBaseChange (Q : QuadraticForm R V) :\n    (toBaseChange A Q).comp (ofBaseChange A Q) = AlgHom.id _ _ := by\n  ext v\n  change toBaseChange A Q (ofBaseChange A Q (1 ⊗ₜ[R] ι Q v)) = 1 ⊗ₜ[R] ι Q v\n  rw [ofBaseChange_tmul_ι, toBaseChange_ι]\n\n"}
{"name":"CliffordAlgebra.toBaseChange_ofBaseChange","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nx : TensorProduct R A (CliffordAlgebra Q)\n⊢ Eq ((CliffordAlgebra.toBaseChange A Q) ((CliffordAlgebra.ofBaseChange A Q) x)) x","decl":"@[simp] theorem toBaseChange_ofBaseChange (Q : QuadraticForm R V) (x : A ⊗[R] CliffordAlgebra Q) :\n    toBaseChange A Q (ofBaseChange A Q x) = x :=\n  AlgHom.congr_fun (toBaseChange_comp_ofBaseChange A Q :) x\n\n"}
{"name":"CliffordAlgebra.ofBaseChange_comp_toBaseChange","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\n⊢ Eq ((CliffordAlgebra.ofBaseChange A Q).comp (CliffordAlgebra.toBaseChange A Q)) (AlgHom.id A (CliffordAlgebra (QuadraticForm.baseChange A Q)))","decl":"theorem ofBaseChange_comp_toBaseChange (Q : QuadraticForm R V) :\n    (ofBaseChange A Q).comp (toBaseChange A Q) = AlgHom.id _ _ := by\n  ext x\n  show ofBaseChange A Q (toBaseChange A Q (ι (Q.baseChange A) (1 ⊗ₜ[R] x)))\n    = ι (Q.baseChange A) (1 ⊗ₜ[R] x)\n  rw [toBaseChange_ι, ofBaseChange_tmul_ι]\n\n"}
{"name":"CliffordAlgebra.ofBaseChange_toBaseChange","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\nx : CliffordAlgebra (QuadraticForm.baseChange A Q)\n⊢ Eq ((CliffordAlgebra.ofBaseChange A Q) ((CliffordAlgebra.toBaseChange A Q) x)) x","decl":"@[simp] theorem ofBaseChange_toBaseChange\n    (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    ofBaseChange A Q (toBaseChange A Q x) = x :=\n  AlgHom.congr_fun (ofBaseChange_comp_toBaseChange A Q :) x\n\n"}
{"name":"CliffordAlgebra.equivBaseChange_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\na : TensorProduct R A (CliffordAlgebra Q)\n⊢ Eq ((CliffordAlgebra.equivBaseChange A Q).symm a) ((CliffordAlgebra.ofBaseChange A Q) a)","decl":"/-- Base-changing the vector space of a clifford algebra is isomorphic as an A-algebra to\nbase-changing the clifford algebra itself; <|Cℓ(A ⊗_R V, Q_A) ≅ A ⊗_R Cℓ(V, Q)<|.\n\nThis is `CliffordAlgebra.toBaseChange` and `CliffordAlgebra.ofBaseChange` as an equivalence. -/\n@[simps!]\n-- `noncomputable` is a performance workaround for https://github.com/leanprover-community/mathlib4/issues/7103\nnoncomputable def equivBaseChange (Q : QuadraticForm R V) :\n    CliffordAlgebra (Q.baseChange A) ≃ₐ[A] A ⊗[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom (toBaseChange A Q) (ofBaseChange A Q)\n    (toBaseChange_comp_ofBaseChange A Q)\n    (ofBaseChange_comp_toBaseChange A Q)\n\n"}
{"name":"CliffordAlgebra.equivBaseChange_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nV : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup V\ninst✝² : Algebra R A\ninst✝¹ : Module R V\ninst✝ : Invertible 2\nQ : QuadraticForm R V\na : CliffordAlgebra (QuadraticForm.baseChange A Q)\n⊢ Eq ((CliffordAlgebra.equivBaseChange A Q) a) ((CliffordAlgebra.toBaseChange A Q) a)","decl":"/-- Base-changing the vector space of a clifford algebra is isomorphic as an A-algebra to\nbase-changing the clifford algebra itself; <|Cℓ(A ⊗_R V, Q_A) ≅ A ⊗_R Cℓ(V, Q)<|.\n\nThis is `CliffordAlgebra.toBaseChange` and `CliffordAlgebra.ofBaseChange` as an equivalence. -/\n@[simps!]\n-- `noncomputable` is a performance workaround for https://github.com/leanprover-community/mathlib4/issues/7103\nnoncomputable def equivBaseChange (Q : QuadraticForm R V) :\n    CliffordAlgebra (Q.baseChange A) ≃ₐ[A] A ⊗[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom (toBaseChange A Q) (ofBaseChange A Q)\n    (toBaseChange_comp_ofBaseChange A Q)\n    (ofBaseChange_comp_toBaseChange A Q)\n\n"}
