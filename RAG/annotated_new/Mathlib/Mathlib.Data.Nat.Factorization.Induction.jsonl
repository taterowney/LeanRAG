{"name":"induction_on_primes","module":"Mathlib.Data.Nat.Factorization.Induction","initialProofState":"P : Nat → Prop\nh₀ : P 0\nh₁ : P 1\nh : ∀ (p a : Nat), Nat.Prime p → P a → P (HMul.hMul p a)\nn : Nat\n⊢ P n","decl":"lemma _root_.induction_on_primes {P : ℕ → Prop} (h₀ : P 0) (h₁ : P 1)\n    (h : ∀ p a : ℕ, p.Prime → P a → P (p * a)) : ∀ n, P n := by\n  refine recOnPrimePow h₀ h₁ ?_\n  rintro a p n hp - - ha\n  induction' n with n ih\n  · simpa using ha\n  · rw [pow_succ', mul_assoc]\n    exact h _ _ hp ih\n\n"}
{"name":"Nat.prime_composite_induction","module":"Mathlib.Data.Nat.Factorization.Induction","initialProofState":"P : Nat → Prop\nzero : P 0\none : P 1\nprime : ∀ (p : Nat), Nat.Prime p → P p\ncomposite : ∀ (a : Nat), LE.le 2 a → P a → ∀ (b : Nat), LE.le 2 b → P b → P (HMul.hMul a b)\nn : Nat\n⊢ P n","decl":"lemma prime_composite_induction {P : ℕ → Prop} (zero : P 0) (one : P 1)\n    (prime : ∀ p : ℕ, p.Prime → P p) (composite : ∀ a, 2 ≤ a → P a → ∀ b, 2 ≤ b → P b → P (a * b))\n    (n : ℕ) : P n := by\n  refine induction_on_primes zero one ?_ _\n  rintro p (_ | _ | a) hp ha\n  · simpa\n  · simpa using prime _ hp\n  · exact composite _ hp.two_le (prime _ hp) _ a.one_lt_succ_succ ha\n\n"}
{"name":"Nat.multiplicative_factorization","module":"Mathlib.Data.Nat.Factorization.Induction","initialProofState":"β : Type u_1\ninst✝ : CommMonoid β\nf : Nat → β\nh_mult : ∀ (x y : Nat), x.Coprime y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhf : Eq (f 1) 1\nn : Nat\na✝ : Ne n 0\n⊢ Eq (f n) (n.factorization.prod fun p k => f (HPow.hPow p k))","decl":"/-- For any multiplicative function `f` with `f 1 = 1` and any `n ≠ 0`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\ntheorem multiplicative_factorization {β : Type*} [CommMonoid β] (f : ℕ → β)\n    (h_mult : ∀ x y : ℕ, Coprime x y → f (x * y) = f x * f y) (hf : f 1 = 1) :\n    ∀ {n : ℕ}, n ≠ 0 → f n = n.factorization.prod fun p k => f (p ^ k) := by\n  apply Nat.recOnPosPrimePosCoprime\n  · rintro p k hp - -\n    -- Porting note: replaced `simp` with `rw`\n    rw [Prime.factorization_pow hp, Finsupp.prod_single_index _]\n    rwa [pow_zero]\n  · simp\n  · rintro -\n    rw [factorization_one, hf]\n    simp\n  · intro a b _ _ hab ha hb hab_pos\n    rw [h_mult a b hab, ha (left_ne_zero_of_mul hab_pos), hb (right_ne_zero_of_mul hab_pos),\n      factorization_mul_of_coprime hab, ← prod_add_index_of_disjoint]\n    exact hab.disjoint_primeFactors\n\n"}
{"name":"Nat.multiplicative_factorization'","module":"Mathlib.Data.Nat.Factorization.Induction","initialProofState":"n : Nat\nβ : Type u_1\ninst✝ : CommMonoid β\nf : Nat → β\nh_mult : ∀ (x y : Nat), x.Coprime y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhf0 : Eq (f 0) 1\nhf1 : Eq (f 1) 1\n⊢ Eq (f n) (n.factorization.prod fun p k => f (HPow.hPow p k))","decl":"/-- For any multiplicative function `f` with `f 1 = 1` and `f 0 = 1`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\ntheorem multiplicative_factorization' {β : Type*} [CommMonoid β] (f : ℕ → β)\n    (h_mult : ∀ x y : ℕ, Coprime x y → f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) :\n    f n = n.factorization.prod fun p k => f (p ^ k) := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simpa\n  · exact multiplicative_factorization _ h_mult hf1 hn\n\n"}
