{"name":"Polynomial.eval₂_at_zero","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.eval₂ f 0 p) (f (p.coeff 0))","decl":"@[simp]\ntheorem eval₂_at_zero : p.eval₂ f 0 = f (coeff p 0) := by\n  simp +contextual only [eval₂_eq_sum, zero_pow_eq, mul_ite, mul_zero,\n    mul_one, sum, Classical.not_not, mem_support_iff, sum_ite_eq', ite_eq_left_iff,\n    RingHom.map_zero, imp_true_iff, eq_self_iff_true]\n\n"}
{"name":"Polynomial.eval₂_C_X","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.eval₂ Polynomial.C Polynomial.X p) p","decl":"@[simp]\ntheorem eval₂_C_X : eval₂ C X p = p :=\n  Polynomial.induction_on' p (fun p q hp hq => by simp [hp, hq]) fun n x => by\n    rw [eval₂_monomial, ← smul_X_eq_monomial, C_mul']\n\n"}
{"name":"Polynomial.coeff_zero_eq_eval_zero","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.coeff 0) (Polynomial.eval 0 p)","decl":"theorem coeff_zero_eq_eval_zero (p : R[X]) : coeff p 0 = p.eval 0 :=\n  calc\n    coeff p 0 = coeff p 0 * 0 ^ 0 := by simp\n    _ = p.eval 0 := by\n      symm\n      rw [eval_eq_sum]\n      exact Finset.sum_eq_single _ (fun b _ hb => by simp [zero_pow hb]) (by simp)\n\n"}
{"name":"Polynomial.zero_isRoot_of_coeff_zero_eq_zero","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : Eq (p.coeff 0) 0\n⊢ p.IsRoot 0","decl":"theorem zero_isRoot_of_coeff_zero_eq_zero {p : R[X]} (hp : p.coeff 0 = 0) : IsRoot p 0 := by\n  rwa [coeff_zero_eq_eval_zero] at hp\n\n"}
{"name":"Polynomial.coeff_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\n⊢ Eq ((Polynomial.map f p).coeff n) (f (p.coeff n))","decl":"@[simp]\ntheorem coeff_map (n : ℕ) : coeff (p.map f) n = f (coeff p n) := by\n  rw [map, eval₂_def, coeff_sum, sum]\n  conv_rhs => rw [← sum_C_mul_X_pow_eq p, coeff_sum, sum, map_sum]\n  refine Finset.sum_congr rfl fun x _hx => ?_\n  simp only [RingHom.coe_comp, Function.comp, coeff_C_mul_X_pow]\n  split_ifs <;> simp [f.map_zero]\n\n"}
{"name":"Polynomial.coeff_map_eq_comp","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\n⊢ Eq (Polynomial.map f p).coeff (Function.comp (⇑f) p.coeff)","decl":"lemma coeff_map_eq_comp (p : R[X]) (f : R →+* S) : (p.map f).coeff = f ∘ p.coeff := by\n  ext n; exact coeff_map ..\n\n"}
{"name":"Polynomial.map_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : Semiring T\ng : RingHom S T\np : Polynomial R\n⊢ Eq (Polynomial.map g (Polynomial.map f p)) (Polynomial.map (g.comp f) p)","decl":"theorem map_map [Semiring T] (g : S →+* T) (p : R[X]) : (p.map f).map g = p.map (g.comp f) :=\n  ext (by simp [coeff_map])\n\n"}
{"name":"Polynomial.map_id","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.map (RingHom.id R) p) p","decl":"@[simp]\ntheorem map_id : p.map (RingHom.id _) = p := by simp [Polynomial.ext_iff, coeff_map]\n\n"}
{"name":"Polynomial.map_injective","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Function.Injective (Polynomial.map f)","decl":"theorem map_injective (hf : Function.Injective f) : Function.Injective (map f) := fun p q h =>\n  ext fun m => hf <| by rw [← coeff_map f, ← coeff_map f, h]\n\n"}
{"name":"Polynomial.map_surjective","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (Polynomial.map f)","decl":"theorem map_surjective (hf : Function.Surjective f) : Function.Surjective (map f) := fun p =>\n  Polynomial.induction_on' p\n    (fun p q hp hq =>\n      let ⟨p', hp'⟩ := hp\n      let ⟨q', hq'⟩ := hq\n      ⟨p' + q', by rw [Polynomial.map_add f, hp', hq']⟩)\n    fun n s =>\n    let ⟨r, hr⟩ := hf s\n    ⟨monomial n r, by rw [map_monomial f, hr]⟩\n\n"}
{"name":"Polynomial.map_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (Polynomial.map f p) 0) (Eq p 0)","decl":"protected theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 ↔ p = 0 :=\n  map_eq_zero_iff (mapRingHom f) (map_injective f hf)\n\n"}
{"name":"Polynomial.map_ne_zero_iff","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Iff (Ne (Polynomial.map f p) 0) (Ne p 0)","decl":"protected theorem map_ne_zero_iff (hf : Function.Injective f) : p.map f ≠ 0 ↔ p ≠ 0 :=\n  (Polynomial.map_eq_zero_iff hf).not\n\n"}
{"name":"Polynomial.mapRingHom_id","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.mapRingHom (RingHom.id R)) (RingHom.id (Polynomial R))","decl":"@[simp]\ntheorem mapRingHom_id : mapRingHom (RingHom.id R) = RingHom.id R[X] :=\n  RingHom.ext fun _x => map_id\n\n"}
{"name":"Polynomial.mapRingHom_comp","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : Semiring T\nf : RingHom S T\ng : RingHom R S\n⊢ Eq ((Polynomial.mapRingHom f).comp (Polynomial.mapRingHom g)) (Polynomial.mapRingHom (f.comp g))","decl":"@[simp]\ntheorem mapRingHom_comp [Semiring T] (f : S →+* T) (g : R →+* S) :\n    (mapRingHom f).comp (mapRingHom g) = mapRingHom (f.comp g) :=\n  RingHom.ext <| Polynomial.map_map g f\n\n"}
{"name":"Polynomial.eval₂_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\np : Polynomial R\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : Semiring T\ng : RingHom S T\nx : T\n⊢ Eq (Polynomial.eval₂ g x (Polynomial.map f p)) (Polynomial.eval₂ (g.comp f) x p)","decl":"theorem eval₂_map [Semiring T] (g : S →+* T) (x : T) :\n    (p.map f).eval₂ g x = p.eval₂ (g.comp f) x := by\n  rw [eval₂_eq_eval_map, eval₂_eq_eval_map, map_map]\n\n"}
{"name":"Polynomial.eval_zero_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ Eq (Polynomial.eval 0 (Polynomial.map f p)) (f (Polynomial.eval 0 p))","decl":"@[simp]\ntheorem eval_zero_map (f : R →+* S) (p : R[X]) : (p.map f).eval 0 = f (p.eval 0) := by\n  simp [← coeff_zero_eq_eval_zero]\n\n"}
{"name":"Polynomial.eval_one_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ Eq (Polynomial.eval 1 (Polynomial.map f p)) (f (Polynomial.eval 1 p))","decl":"@[simp]\ntheorem eval_one_map (f : R →+* S) (p : R[X]) : (p.map f).eval 1 = f (p.eval 1) := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]\n  | h_monomial n r =>\n    simp only [one_pow, mul_one, eval_monomial, map_monomial]\n\n"}
{"name":"Polynomial.eval_natCast_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.eval (↑n) (Polynomial.map f p)) (f (Polynomial.eval (↑n) p))","decl":"@[simp]\ntheorem eval_natCast_map (f : R →+* S) (p : R[X]) (n : ℕ) :\n    (p.map f).eval (n : S) = f (p.eval n) := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]\n  | h_monomial n r =>\n    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]\n\n"}
{"name":"Polynomial.eval_intCast_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\np : Polynomial R\ni : Int\n⊢ Eq (Polynomial.eval (↑i) (Polynomial.map f p)) (f (Polynomial.eval (↑i) p))","decl":"@[simp]\ntheorem eval_intCast_map {R S : Type*} [Ring R] [Ring S] (f : R →+* S) (p : R[X]) (i : ℤ) :\n    (p.map f).eval (i : S) = f (p.eval i) := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]\n  | h_monomial n r =>\n    simp only [map_intCast, eval_monomial, map_monomial, map_pow, map_mul]\n\n"}
{"name":"Polynomial.hom_eval₂","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\np : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Semiring T\nf : RingHom R S\ng : RingHom S T\nx : S\n⊢ Eq (g (Polynomial.eval₂ f x p)) (Polynomial.eval₂ (g.comp f) (g x) p)","decl":"theorem hom_eval₂ (x : S) : g (p.eval₂ f x) = p.eval₂ (g.comp f) (g x) := by\n  rw [← eval₂_map, eval₂_at_apply, eval_map]\n\n"}
{"name":"Polynomial.eval₂_hom","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : R\n⊢ Eq (Polynomial.eval₂ f (f x) p) (f (Polynomial.eval x p))","decl":"theorem eval₂_hom (x : R) : p.eval₂ f (f x) = f (p.eval x) :=\n  RingHom.comp_id f ▸ (hom_eval₂ p (RingHom.id R) f x).symm\n\n"}
{"name":"Polynomial.evalRingHom_zero","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"⊢ Eq (Polynomial.evalRingHom 0) Polynomial.constantCoeff","decl":"theorem evalRingHom_zero : evalRingHom 0 = constantCoeff :=\n  DFunLike.ext _ _ fun p => p.coeff_zero_eq_eval_zero.symm\n\n"}
{"name":"Polynomial.support_map_subset","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ HasSubset.Subset (Polynomial.map f p).support p.support","decl":"theorem support_map_subset [Semiring R] [Semiring S] (f : R →+* S) (p : R[X]) :\n    (map f p).support ⊆ p.support := by\n  intro x\n  contrapose!\n  simp +contextual\n\n"}
{"name":"Polynomial.support_map_of_injective","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq (Polynomial.map f p).support p.support","decl":"theorem support_map_of_injective [Semiring R] [Semiring S] (p : R[X]) {f : R →+* S}\n    (hf : Function.Injective f) : (map f p).support = p.support := by\n  simp_rw [Finset.ext_iff, mem_support_iff, coeff_map, ← map_zero f, hf.ne_iff,\n    forall_const]\n\n"}
{"name":"Polynomial.IsRoot.map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : R\np : Polynomial R\nh : p.IsRoot x\n⊢ (Polynomial.map f p).IsRoot (f x)","decl":"theorem IsRoot.map {f : R →+* S} {x : R} {p : R[X]} (h : IsRoot p x) : IsRoot (p.map f) (f x) := by\n  rw [IsRoot, eval_map, eval₂_hom, h.eq_zero, f.map_zero]\n\n"}
{"name":"Polynomial.IsRoot.of_map","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"S : Type v\ninst✝¹ : CommSemiring S\nR : Type u_1\ninst✝ : CommRing R\nf : RingHom R S\nx : R\np : Polynomial R\nh : (Polynomial.map f p).IsRoot (f x)\nhf : Function.Injective ⇑f\n⊢ p.IsRoot x","decl":"theorem IsRoot.of_map {R} [CommRing R] {f : R →+* S} {x : R} {p : R[X]} (h : IsRoot (p.map f) (f x))\n    (hf : Function.Injective f) : IsRoot p x := by\n  rwa [IsRoot, ← (injective_iff_map_eq_zero' f).mp hf, ← eval₂_hom, ← eval_map]\n\n"}
{"name":"Polynomial.isRoot_map_iff","module":"Mathlib.Algebra.Polynomial.Eval.Coeff","initialProofState":"S : Type v\ninst✝¹ : CommSemiring S\nR : Type u_1\ninst✝ : CommRing R\nf : RingHom R S\nx : R\np : Polynomial R\nhf : Function.Injective ⇑f\n⊢ Iff ((Polynomial.map f p).IsRoot (f x)) (p.IsRoot x)","decl":"theorem isRoot_map_iff {R : Type*} [CommRing R] {f : R →+* S} {x : R} {p : R[X]}\n    (hf : Function.Injective f) : IsRoot (p.map f) (f x) ↔ IsRoot p x :=\n  ⟨fun h => h.of_map hf, fun h => h.map⟩\n\n"}
