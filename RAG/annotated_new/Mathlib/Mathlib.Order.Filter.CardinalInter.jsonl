{"name":"CardinalInterFilter.cardinal_sInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl : Filter Œ±\nc : Cardinal.{u}\nself : CardinalInterFilter l c\nS : Set (Set Œ±)\na‚úù¬π : LT.lt (Cardinal.mk ‚ÜëS) c\na‚úù : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí Membership.mem l s\n‚ä¢ Membership.mem l S.sInter","decl":"/-- A filter `l` has the cardinal `c` intersection property if for any collection\nof less than `c` sets `s ‚àà l`, their intersection belongs to `l` as well. -/\nclass CardinalInterFilter (l : Filter Œ±) (c : Cardinal.{u}) : Prop where\n  /-- For a collection of sets `s ‚àà l` with cardinality below c,\n  their intersection belongs to `l` as well. -/\n  cardinal_sInter_mem : ‚àÄ S : Set (Set Œ±), (#S < c) ‚Üí (‚àÄ s ‚àà S, s ‚àà l) ‚Üí ‚ãÇ‚ÇÄ S ‚àà l\n\n"}
{"name":"cardinal_sInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\nS : Set (Set Œ±)\ninst‚úù : CardinalInterFilter l c\nhSc : LT.lt (Cardinal.mk ‚ÜëS) c\n‚ä¢ Iff (Membership.mem l S.sInter) (‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí Membership.mem l s)","decl":"theorem cardinal_sInter_mem {S : Set (Set Œ±)} [CardinalInterFilter l c] (hSc : #S < c) :\n    ‚ãÇ‚ÇÄ S ‚àà l ‚Üî ‚àÄ s ‚àà S, s ‚àà l := ‚ü®fun hS _s hs => mem_of_superset hS (sInter_subset_of_mem hs),\n  CardinalInterFilter.cardinal_sInter_mem _ hSc‚ü©\n\n"}
{"name":"Filter.cardinalInterFilter_aleph0","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl : Filter Œ±\n‚ä¢ CardinalInterFilter l Cardinal.aleph0","decl":"/-- Every filter is a CardinalInterFilter with c = ‚Ñµ‚ÇÄ -/\ntheorem _root_.Filter.cardinalInterFilter_aleph0 (l : Filter Œ±) : CardinalInterFilter l ‚Ñµ‚ÇÄ where\n  cardinal_sInter_mem := by\n    simp_all only [aleph_zero, lt_aleph0_iff_subtype_finite, setOf_mem_eq, sInter_mem,\n      implies_true, forall_const]\n\n"}
{"name":"CardinalInterFilter.toCountableInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nhc : LT.lt Cardinal.aleph0 c\n‚ä¢ CountableInterFilter l","decl":"/-- Every CardinalInterFilter with c > ‚Ñµ‚ÇÄ is a CountableInterFilter -/\ntheorem CardinalInterFilter.toCountableInterFilter (l : Filter Œ±) [CardinalInterFilter l c]\n    (hc : ‚Ñµ‚ÇÄ < c) : CountableInterFilter l where\n  countable_sInter_mem S hS a :=\n    CardinalInterFilter.cardinal_sInter_mem S (lt_of_le_of_lt (Set.Countable.le_aleph0 hS) hc) a\n\n"}
{"name":"CountableInterFilter.toCardinalInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl : Filter Œ±\ninst‚úù : CountableInterFilter l\n‚ä¢ CardinalInterFilter l (Cardinal.aleph 1)","decl":"/-- Every CountableInterFilter is a CardinalInterFilter with c = ‚Ñµ‚ÇÅ -/\ninstance CountableInterFilter.toCardinalInterFilter (l : Filter Œ±) [CountableInterFilter l] :\n    CardinalInterFilter l ‚Ñµ‚ÇÅ where\n  cardinal_sInter_mem S hS a :=\n    CountableInterFilter.countable_sInter_mem S ((countable_iff_lt_aleph_one S).mpr hS) a\n\n"}
{"name":"cardinalInterFilter_aleph_one_iff","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl : Filter Œ±\n‚ä¢ Iff (CardinalInterFilter l (Cardinal.aleph 1)) (CountableInterFilter l)","decl":"theorem cardinalInterFilter_aleph_one_iff :\n    CardinalInterFilter l ‚Ñµ‚ÇÅ ‚Üî CountableInterFilter l :=\n  ‚ü®fun _ ‚Ü¶ ‚ü®fun S h a ‚Ü¶\n    CardinalInterFilter.cardinal_sInter_mem S ((countable_iff_lt_aleph_one S).1 h) a‚ü©,\n   fun _ ‚Ü¶ CountableInterFilter.toCardinalInterFilter l‚ü©\n\n"}
{"name":"CardinalInterFilter.of_cardinalInterFilter_of_le","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\na : Cardinal.{u}\nhac : LE.le a c\n‚ä¢ CardinalInterFilter l a","decl":"/-- Every CardinalInterFilter for some c also is a CardinalInterFilter for some a ‚â§ c -/\ntheorem CardinalInterFilter.of_cardinalInterFilter_of_le (l : Filter Œ±) [CardinalInterFilter l c]\n    {a : Cardinal.{u}} (hac : a ‚â§ c) :\n    CardinalInterFilter l a where\n  cardinal_sInter_mem S hS a :=\n    CardinalInterFilter.cardinal_sInter_mem S (lt_of_lt_of_le hS hac) a\n\n"}
{"name":"CardinalInterFilter.of_cardinalInterFilter_of_lt","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\na : Cardinal.{u}\nhac : LT.lt a c\n‚ä¢ CardinalInterFilter l a","decl":"theorem CardinalInterFilter.of_cardinalInterFilter_of_lt (l : Filter Œ±) [CardinalInterFilter l c]\n    {a : Cardinal.{u}} (hac : a < c) : CardinalInterFilter l a :=\n  CardinalInterFilter.of_cardinalInterFilter_of_le l (hac.le)\n\n"}
{"name":"Filter.cardinal_iInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\ns : Œπ ‚Üí Set Œ±\nhic : LT.lt (Cardinal.mk Œπ) c\n‚ä¢ Iff (Membership.mem l (Set.iInter fun i => s i)) (‚àÄ (i : Œπ), Membership.mem l (s i))","decl":"theorem cardinal_iInter_mem {s : Œπ ‚Üí Set Œ±} (hic : #Œπ < c) :\n    (‚ãÇ i, s i) ‚àà l ‚Üî ‚àÄ i, s i ‚àà l := by\n  rw [‚Üê sInter_range _]\n  apply (cardinal_sInter_mem (lt_of_le_of_lt Cardinal.mk_range_le hic)).trans\n  exact forall_mem_range\n\n"}
{"name":"Filter.cardinal_bInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\ns : (i : Œπ) ‚Üí Membership.mem S i ‚Üí Set Œ±\n‚ä¢ Iff (Membership.mem l (Set.iInter fun i => Set.iInter fun hi => s i hi)) (‚àÄ (i : Œπ) (hi : Membership.mem S i), Membership.mem l (s i hi))","decl":"theorem cardinal_bInter_mem {S : Set Œπ} (hS : #S < c)\n    {s : ‚àÄ i ‚àà S, Set Œ±} :\n    (‚ãÇ i, ‚ãÇ hi : i ‚àà S, s i ‚Äπ_‚Ä∫) ‚àà l ‚Üî ‚àÄ i, ‚àÄ hi : i ‚àà S, s i ‚Äπ_‚Ä∫ ‚àà l := by\n  rw [biInter_eq_iInter]\n  exact (cardinal_iInter_mem hS).trans Subtype.forall\n\n"}
{"name":"Filter.eventually_cardinal_forall","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\np : Œ± ‚Üí Œπ ‚Üí Prop\nhic : LT.lt (Cardinal.mk Œπ) c\n‚ä¢ Iff (Filter.Eventually (fun x => ‚àÄ (i : Œπ), p x i) l) (‚àÄ (i : Œπ), Filter.Eventually (fun x => p x i) l)","decl":"theorem eventually_cardinal_forall {p : Œ± ‚Üí Œπ ‚Üí Prop} (hic : #Œπ < c) :\n    (‚àÄ·∂† x in l, ‚àÄ i, p x i) ‚Üî ‚àÄ i, ‚àÄ·∂† x in l, p x i := by\n  simp only [Filter.Eventually, setOf_forall]\n  exact cardinal_iInter_mem hic\n\n"}
{"name":"Filter.eventually_cardinal_ball","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\np : Œ± ‚Üí (i : Œπ) ‚Üí Membership.mem S i ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => ‚àÄ (i : Œπ) (hi : Membership.mem S i), p x i hi) l) (‚àÄ (i : Œπ) (hi : Membership.mem S i), Filter.Eventually (fun x => p x i hi) l)","decl":"theorem eventually_cardinal_ball {S : Set Œπ} (hS : #S < c)\n    {p : Œ± ‚Üí ‚àÄ i ‚àà S, Prop} :\n    (‚àÄ·∂† x in l, ‚àÄ i hi, p x i hi) ‚Üî ‚àÄ i hi, ‚àÄ·∂† x in l, p x i hi := by\n  simp only [Filter.Eventually, setOf_forall]\n  exact cardinal_bInter_mem hS\n\n"}
{"name":"Filter.EventuallyLE.cardinal_iUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\ns t : Œπ ‚Üí Set Œ±\nhic : LT.lt (Cardinal.mk Œπ) c\nh : ‚àÄ (i : Œπ), l.EventuallyLE (s i) (t i)\n‚ä¢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyLE.cardinal_iUnion {s t : Œπ ‚Üí Set Œ±} (hic : #Œπ < c)\n    (h : ‚àÄ i, s i ‚â§·∂†[l] t i) : ‚ãÉ i, s i ‚â§·∂†[l] ‚ãÉ i, t i :=\n  ((eventually_cardinal_forall hic).2 h).mono fun _ hst hs => mem_iUnion.2 <|\n    (mem_iUnion.1 hs).imp hst\n\n"}
{"name":"Filter.EventuallyEq.cardinal_iUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\ns t : Œπ ‚Üí Set Œ±\nhic : LT.lt (Cardinal.mk Œπ) c\nh : ‚àÄ (i : Œπ), l.EventuallyEq (s i) (t i)\n‚ä¢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyEq.cardinal_iUnion {s t : Œπ ‚Üí Set Œ±} (hic : #Œπ < c)\n    (h : ‚àÄ i, s i =·∂†[l] t i) : ‚ãÉ i, s i =·∂†[l] ‚ãÉ i, t i :=\n  (EventuallyLE.cardinal_iUnion hic fun i => (h i).le).antisymm\n    (EventuallyLE.cardinal_iUnion hic fun i => (h i).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_bUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\ns t : (i : Œπ) ‚Üí Membership.mem S i ‚Üí Set Œ±\nh : ‚àÄ (i : Œπ) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n‚ä¢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyLE.cardinal_bUnion {S : Set Œπ} (hS : #S < c)\n    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi ‚â§·∂†[l] t i hi) :\n    ‚ãÉ i ‚àà S, s i ‚Äπ_‚Ä∫ ‚â§·∂†[l] ‚ãÉ i ‚àà S, t i ‚Äπ_‚Ä∫ := by\n  simp only [biUnion_eq_iUnion]\n  exact EventuallyLE.cardinal_iUnion hS fun i => h i i.2\n\n"}
{"name":"Filter.EventuallyEq.cardinal_bUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\ns t : (i : Œπ) ‚Üí Membership.mem S i ‚Üí Set Œ±\nh : ‚àÄ (i : Œπ) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n‚ä¢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyEq.cardinal_bUnion {S : Set Œπ} (hS : #S < c)\n    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi =·∂†[l] t i hi) :\n    ‚ãÉ i ‚àà S, s i ‚Äπ_‚Ä∫ =·∂†[l] ‚ãÉ i ‚àà S, t i ‚Äπ_‚Ä∫ :=\n  (EventuallyLE.cardinal_bUnion hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.cardinal_bUnion hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_iInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\ns t : Œπ ‚Üí Set Œ±\nhic : LT.lt (Cardinal.mk Œπ) c\nh : ‚àÄ (i : Œπ), l.EventuallyLE (s i) (t i)\n‚ä¢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyLE.cardinal_iInter {s t : Œπ ‚Üí Set Œ±} (hic : #Œπ < c)\n    (h : ‚àÄ i, s i ‚â§·∂†[l] t i) : ‚ãÇ i, s i ‚â§·∂†[l] ‚ãÇ i, t i :=\n  ((eventually_cardinal_forall hic).2 h).mono fun _ hst hs =>\n    mem_iInter.2 fun i => hst _ (mem_iInter.1 hs i)\n\n"}
{"name":"Filter.EventuallyEq.cardinal_iInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\ns t : Œπ ‚Üí Set Œ±\nhic : LT.lt (Cardinal.mk Œπ) c\nh : ‚àÄ (i : Œπ), l.EventuallyEq (s i) (t i)\n‚ä¢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyEq.cardinal_iInter {s t : Œπ ‚Üí Set Œ±} (hic : #Œπ < c)\n    (h : ‚àÄ i, s i =·∂†[l] t i) : ‚ãÇ i, s i =·∂†[l] ‚ãÇ i, t i :=\n  (EventuallyLE.cardinal_iInter hic fun i => (h i).le).antisymm\n    (EventuallyLE.cardinal_iInter hic fun i => (h i).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_bInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\ns t : (i : Œπ) ‚Üí Membership.mem S i ‚Üí Set Œ±\nh : ‚àÄ (i : Œπ) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n‚ä¢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyLE.cardinal_bInter {S : Set Œπ} (hS : #S < c)\n    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi ‚â§·∂†[l] t i hi) :\n    ‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫ ‚â§·∂†[l] ‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫ := by\n  simp only [biInter_eq_iInter]\n  exact EventuallyLE.cardinal_iInter hS fun i => h i i.2\n\n"}
{"name":"Filter.EventuallyEq.cardinal_bInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œπ Œ± : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nS : Set Œπ\nhS : LT.lt (Cardinal.mk ‚ÜëS) c\ns t : (i : Œπ) ‚Üí Membership.mem S i ‚Üí Set Œ±\nh : ‚àÄ (i : Œπ) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n‚ä¢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyEq.cardinal_bInter {S : Set Œπ} (hS : #S < c)\n    {s t : ‚àÄ i ‚àà S, Set Œ±} (h : ‚àÄ i hi, s i hi =·∂†[l] t i hi) :\n    ‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫ =·∂†[l] ‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫ :=\n  (EventuallyLE.cardinal_bInter hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.cardinal_bInter hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.cardinalInter_ofCardinalInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Set (Set Œ±)\nhc : LT.lt 2 c\nhl : ‚àÄ (S : Set (Set Œ±)), LT.lt (Cardinal.mk ‚ÜëS) c ‚Üí HasSubset.Subset S l ‚Üí Membership.mem l S.sInter\nh_mono : ‚àÄ (s t : Set Œ±), Membership.mem l s ‚Üí HasSubset.Subset s t ‚Üí Membership.mem l t\n‚ä¢ CardinalInterFilter (Filter.ofCardinalInter l hc hl h_mono) c","decl":"instance cardinalInter_ofCardinalInter (l : Set (Set Œ±)) (hc : 2 < c)\n    (hl : ‚àÄ S : Set (Set Œ±), (#S < c) ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l)\n    (h_mono : ‚àÄ s t, s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l) :\n    CardinalInterFilter (Filter.ofCardinalInter l hc hl h_mono) c :=\n  ‚ü®hl‚ü©\n\n"}
{"name":"Filter.mem_ofCardinalInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Set (Set Œ±)\nhc : LT.lt 2 c\nhl : ‚àÄ (S : Set (Set Œ±)), LT.lt (Cardinal.mk ‚ÜëS) c ‚Üí HasSubset.Subset S l ‚Üí Membership.mem l S.sInter\nh_mono : ‚àÄ (s t : Set Œ±), Membership.mem l s ‚Üí HasSubset.Subset s t ‚Üí Membership.mem l t\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (Filter.ofCardinalInter l hc hl h_mono) s) (Membership.mem l s)","decl":"@[simp]\ntheorem mem_ofCardinalInter {l : Set (Set Œ±)} (hc : 2 < c)\n    (hl : ‚àÄ S : Set (Set Œ±), (#S < c) ‚Üí S ‚äÜ l ‚Üí ‚ãÇ‚ÇÄ S ‚àà l) (h_mono : ‚àÄ s t, s ‚àà l ‚Üí s ‚äÜ t ‚Üí t ‚àà l)\n    {s : Set Œ±} : s ‚àà Filter.ofCardinalInter l hc hl h_mono ‚Üî s ‚àà l :=\n  Iff.rfl\n\n"}
{"name":"Filter.cardinalInter_ofCardinalUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Set (Set Œ±)\nhc : LT.lt 2 c\nh‚ÇÅ : ‚àÄ (S : Set (Set Œ±)), LT.lt (Cardinal.mk ‚ÜëS) c ‚Üí (‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí Membership.mem l s) ‚Üí Membership.mem l S.sUnion\nh‚ÇÇ : ‚àÄ (t : Set Œ±), Membership.mem l t ‚Üí ‚àÄ (s : Set Œ±), HasSubset.Subset s t ‚Üí Membership.mem l s\n‚ä¢ CardinalInterFilter (Filter.ofCardinalUnion l hc h‚ÇÅ h‚ÇÇ) c","decl":"instance cardinalInter_ofCardinalUnion (l : Set (Set Œ±)) (hc : 2 < c) (h‚ÇÅ h‚ÇÇ) :\n    CardinalInterFilter (Filter.ofCardinalUnion l hc h‚ÇÅ h‚ÇÇ) c :=\n  cardinalInter_ofCardinalInter ..\n\n"}
{"name":"Filter.mem_ofCardinalUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl : Set (Set Œ±)\nhc : LT.lt 2 c\nhunion : ‚àÄ (S : Set (Set Œ±)), LT.lt (Cardinal.mk ‚ÜëS) c ‚Üí (‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí Membership.mem l s) ‚Üí Membership.mem l S.sUnion\nhmono : ‚àÄ (t : Set Œ±), Membership.mem l t ‚Üí ‚àÄ (s : Set Œ±), HasSubset.Subset s t ‚Üí Membership.mem l s\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (Filter.ofCardinalUnion l hc hunion hmono) s) (l (HasCompl.compl s))","decl":"@[simp]\ntheorem mem_ofCardinalUnion {l : Set (Set Œ±)} (hc : 2 < c) {hunion hmono s} :\n    s ‚àà ofCardinalUnion l hc hunion hmono ‚Üî l s·∂ú :=\n  Iff.rfl\n\n"}
{"name":"Filter.cardinalInterFilter_principal","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\ns : Set Œ±\n‚ä¢ CardinalInterFilter (Filter.principal s) c","decl":"instance cardinalInterFilter_principal (s : Set Œ±) : CardinalInterFilter (ùìü s) c :=\n  ‚ü®fun _ _ hS => subset_sInter hS‚ü©\n\n"}
{"name":"Filter.cardinalInterFilter_bot","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\n‚ä¢ CardinalInterFilter Bot.bot c","decl":"instance cardinalInterFilter_bot : CardinalInterFilter (‚ä• : Filter Œ±) c := by\n  rw [‚Üê principal_empty]\n  apply cardinalInterFilter_principal\n\n"}
{"name":"Filter.cardinalInterFilter_top","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\n‚ä¢ CardinalInterFilter Top.top c","decl":"instance cardinalInterFilter_top : CardinalInterFilter (‚ä§ : Filter Œ±) c := by\n  rw [‚Üê principal_univ]\n  apply cardinalInterFilter_principal\n\n"}
{"name":"Filter.instCardinalInterFilterComap","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± Œ≤ : Type u\nc : Cardinal.{u}\nl : Filter Œ≤\ninst‚úù : CardinalInterFilter l c\nf : Œ± ‚Üí Œ≤\n‚ä¢ CardinalInterFilter (Filter.comap f l) c","decl":"instance (l : Filter Œ≤) [CardinalInterFilter l c] (f : Œ± ‚Üí Œ≤) :\n    CardinalInterFilter (comap f l) c := by\n  refine ‚ü®fun S hSc hS => ?_‚ü©\n  choose! t htl ht using hS\n  refine ‚ü®_, (cardinal_bInter_mem hSc).2 htl, ?_‚ü©\n  simpa [preimage_iInter] using iInter‚ÇÇ_mono ht\n\n"}
{"name":"Filter.instCardinalInterFilterMap","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± Œ≤ : Type u\nc : Cardinal.{u}\nl : Filter Œ±\ninst‚úù : CardinalInterFilter l c\nf : Œ± ‚Üí Œ≤\n‚ä¢ CardinalInterFilter (Filter.map f l) c","decl":"instance (l : Filter Œ±) [CardinalInterFilter l c] (f : Œ± ‚Üí Œ≤) :\n    CardinalInterFilter (map f l) c := by\n  refine ‚ü®fun S hSc hS => ?_‚ü©\n  simp only [mem_map, sInter_eq_biInter, preimage_iInter‚ÇÇ] at hS ‚ä¢\n  exact (cardinal_bInter_mem hSc).2 hS\n\n"}
{"name":"Filter.cardinalInterFilter_inf_eq","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl‚ÇÅ l‚ÇÇ : Filter Œ±\ninst‚úù¬π : CardinalInterFilter l‚ÇÅ c\ninst‚úù : CardinalInterFilter l‚ÇÇ c\n‚ä¢ CardinalInterFilter (Min.min l‚ÇÅ l‚ÇÇ) c","decl":"/-- Infimum of two `CardinalInterFilter`s is a `CardinalInterFilter`. This is useful, e.g.,\nto automatically get an instance for `residual Œ± ‚äì ùìü s`. -/\ninstance cardinalInterFilter_inf_eq (l‚ÇÅ l‚ÇÇ : Filter Œ±) [CardinalInterFilter l‚ÇÅ c]\n    [CardinalInterFilter l‚ÇÇ c] : CardinalInterFilter (l‚ÇÅ ‚äì l‚ÇÇ) c := by\n  refine ‚ü®fun S hSc hS => ?_‚ü©\n  choose s hs t ht hst using hS\n  replace hs : (‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫) ‚àà l‚ÇÅ := (cardinal_bInter_mem hSc).2 hs\n  replace ht : (‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫) ‚àà l‚ÇÇ := (cardinal_bInter_mem hSc).2 ht\n  refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => ?_)\n  rw [hst i hi]\n  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)\n\n"}
{"name":"Filter.cardinalInterFilter_inf","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl‚ÇÅ l‚ÇÇ : Filter Œ±\nc‚ÇÅ c‚ÇÇ : Cardinal.{u}\ninst‚úù¬π : CardinalInterFilter l‚ÇÅ c‚ÇÅ\ninst‚úù : CardinalInterFilter l‚ÇÇ c‚ÇÇ\n‚ä¢ CardinalInterFilter (Min.min l‚ÇÅ l‚ÇÇ) (Min.min c‚ÇÅ c‚ÇÇ)","decl":"instance cardinalInterFilter_inf (l‚ÇÅ l‚ÇÇ : Filter Œ±) {c‚ÇÅ c‚ÇÇ : Cardinal.{u}}\n    [CardinalInterFilter l‚ÇÅ c‚ÇÅ] [CardinalInterFilter l‚ÇÇ c‚ÇÇ] : CardinalInterFilter (l‚ÇÅ ‚äì l‚ÇÇ)\n    (c‚ÇÅ ‚äì c‚ÇÇ) := by\n  have : CardinalInterFilter l‚ÇÅ (c‚ÇÅ ‚äì c‚ÇÇ) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l‚ÇÅ inf_le_left\n  have : CardinalInterFilter l‚ÇÇ (c‚ÇÅ ‚äì c‚ÇÇ) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l‚ÇÇ inf_le_right\n  exact cardinalInterFilter_inf_eq _ _\n\n"}
{"name":"Filter.cardinalInterFilter_sup_eq","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nl‚ÇÅ l‚ÇÇ : Filter Œ±\ninst‚úù¬π : CardinalInterFilter l‚ÇÅ c\ninst‚úù : CardinalInterFilter l‚ÇÇ c\n‚ä¢ CardinalInterFilter (Max.max l‚ÇÅ l‚ÇÇ) c","decl":"/-- Supremum of two `CardinalInterFilter`s is a `CardinalInterFilter`. -/\ninstance cardinalInterFilter_sup_eq (l‚ÇÅ l‚ÇÇ : Filter Œ±) [CardinalInterFilter l‚ÇÅ c]\n    [CardinalInterFilter l‚ÇÇ c] : CardinalInterFilter (l‚ÇÅ ‚äî l‚ÇÇ) c := by\n  refine ‚ü®fun S hSc hS => ‚ü®?_, ?_‚ü©‚ü© <;> refine (cardinal_sInter_mem hSc).2 fun s hs => ?_\n  exacts [(hS s hs).1, (hS s hs).2]\n\n"}
{"name":"Filter.cardinalInterFilter_sup","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nl‚ÇÅ l‚ÇÇ : Filter Œ±\nc‚ÇÅ c‚ÇÇ : Cardinal.{u}\ninst‚úù¬π : CardinalInterFilter l‚ÇÅ c‚ÇÅ\ninst‚úù : CardinalInterFilter l‚ÇÇ c‚ÇÇ\n‚ä¢ CardinalInterFilter (Max.max l‚ÇÅ l‚ÇÇ) (Min.min c‚ÇÅ c‚ÇÇ)","decl":"instance cardinalInterFilter_sup (l‚ÇÅ l‚ÇÇ : Filter Œ±) {c‚ÇÅ c‚ÇÇ : Cardinal.{u}}\n    [CardinalInterFilter l‚ÇÅ c‚ÇÅ] [CardinalInterFilter l‚ÇÇ c‚ÇÇ] :\n    CardinalInterFilter (l‚ÇÅ ‚äî l‚ÇÇ) (c‚ÇÅ ‚äì c‚ÇÇ) := by\n  have : CardinalInterFilter l‚ÇÅ (c‚ÇÅ ‚äì c‚ÇÇ) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l‚ÇÅ inf_le_left\n  have : CardinalInterFilter l‚ÇÇ (c‚ÇÅ ‚äì c‚ÇÇ) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l‚ÇÇ inf_le_right\n  exact cardinalInterFilter_sup_eq _ _\n\n"}
{"name":"Filter.cardinalInter_ofCardinalGenerate","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\ng : Set (Set Œ±)\nhc : LT.lt 2 c\n‚ä¢ CardinalInterFilter (Filter.cardinalGenerate g hc) c","decl":"lemma cardinalInter_ofCardinalGenerate (hc : 2 < c) :\n    CardinalInterFilter (cardinalGenerate g hc) c := by\n  delta cardinalGenerate\n  apply cardinalInter_ofCardinalInter _ _ _\n\n"}
{"name":"Filter.mem_cardinaleGenerate_iff","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\ng : Set (Set Œ±)\ns : Set Œ±\nhreg : c.IsRegular\n‚ä¢ Iff (Membership.mem (Filter.cardinalGenerate g ‚ãØ) s) (Exists fun S => And (HasSubset.Subset S g) (And (LT.lt (Cardinal.mk ‚ÜëS) c) (HasSubset.Subset S.sInter s)))","decl":"/-- A set is in the `cardinalInterFilter` generated by `g` if and only if\nit contains an intersection of `c` elements of `g`. -/\ntheorem mem_cardinaleGenerate_iff {s : Set Œ±} {hreg : c.IsRegular} :\n    s ‚àà cardinalGenerate g (IsRegular.nat_lt hreg 2) ‚Üî\n    ‚àÉ S : Set (Set Œ±), S ‚äÜ g ‚àß (#S < c) ‚àß ‚ãÇ‚ÇÄ S ‚äÜ s := by\n  constructor <;> intro h\n  ¬∑ induction h with\n    | @basic s hs =>\n      refine ‚ü®{s}, singleton_subset_iff.mpr hs, ?_‚ü©\n      simpa [subset_refl] using IsRegular.nat_lt hreg 1\n    | univ =>\n      exact ‚ü®‚àÖ, ‚ü®empty_subset g, mk_eq_zero (‚àÖ : Set <| Set Œ±) ‚ñ∏ IsRegular.nat_lt hreg 0, by simp‚ü©‚ü©\n    | superset _ _ ih => exact Exists.imp (by tauto) ih\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine ‚ü®‚ãÉ (s) (H : s ‚àà S), T s H, by simpa,\n        (Cardinal.card_biUnion_lt_iff_forall_of_isRegular hreg Sct).2 Tct, ?_‚ü©\n      apply subset_sInter\n      apply fun s H => subset_trans (sInter_subset_sInter (subset_iUnion‚ÇÇ s H)) (hT s H)\n  rcases h with ‚ü®S, Sg, Sct, hS‚ü©\n  have : CardinalInterFilter (cardinalGenerate g (IsRegular.nat_lt hreg 2)) c :=\n    cardinalInter_ofCardinalGenerate _ _\n  exact mem_of_superset ((cardinal_sInter_mem Sct).mpr\n    (fun s H => CardinalGenerateSets.basic (Sg H))) hS\n\n"}
{"name":"Filter.le_cardinalGenerate_iff_of_cardinalInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\ng : Set (Set Œ±)\nf : Filter Œ±\ninst‚úù : CardinalInterFilter f c\nhc : LT.lt 2 c\n‚ä¢ Iff (LE.le f (Filter.cardinalGenerate g hc)) (HasSubset.Subset g f.sets)","decl":"theorem le_cardinalGenerate_iff_of_cardinalInterFilter {f : Filter Œ±} [CardinalInterFilter f c]\n    (hc : 2 < c) : f ‚â§ cardinalGenerate g hc ‚Üî g ‚äÜ f.sets := by\n  constructor <;> intro h\n  ¬∑ exact subset_trans (fun s => CardinalGenerateSets.basic) h\n  intro s hs\n  induction hs with\n  | basic hs => exact h hs\n  | univ => exact univ_mem\n  | superset _ st ih => exact mem_of_superset ih st\n  | sInter Sct _ ih => exact (cardinal_sInter_mem Sct).mpr ih\n\n"}
{"name":"Filter.cardinalGenerate_isGreatest","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\ng : Set (Set Œ±)\nhc : LT.lt 2 c\n‚ä¢ IsGreatest (setOf fun f => And (CardinalInterFilter f c) (HasSubset.Subset g f.sets)) (Filter.cardinalGenerate g hc)","decl":"/-- `cardinalGenerate g hc` is the greatest `cardinalInterFilter c` containing `g`. -/\ntheorem cardinalGenerate_isGreatest (hc : 2 < c) :\n    IsGreatest { f : Filter Œ± | CardinalInterFilter f c ‚àß g ‚äÜ f.sets } (cardinalGenerate g hc) := by\n  refine ‚ü®‚ü®cardinalInter_ofCardinalGenerate _ _, fun s => CardinalGenerateSets.basic‚ü©, ?_‚ü©\n  rintro f ‚ü®fct, hf‚ü©\n  rwa [le_cardinalGenerate_iff_of_cardinalInterFilter]\n\n"}
