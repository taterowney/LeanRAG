{"name":"CardinalInterFilter.cardinal_sInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl : Filter α\nc : Cardinal.{u}\nself : CardinalInterFilter l c\nS : Set (Set α)\na✝¹ : LT.lt (Cardinal.mk ↑S) c\na✝ : ∀ (s : Set α), Membership.mem S s → Membership.mem l s\n⊢ Membership.mem l S.sInter","decl":"/-- A filter `l` has the cardinal `c` intersection property if for any collection\nof less than `c` sets `s ∈ l`, their intersection belongs to `l` as well. -/\nclass CardinalInterFilter (l : Filter α) (c : Cardinal.{u}) : Prop where\n  /-- For a collection of sets `s ∈ l` with cardinality below c,\n  their intersection belongs to `l` as well. -/\n  cardinal_sInter_mem : ∀ S : Set (Set α), (#S < c) → (∀ s ∈ S, s ∈ l) → ⋂₀ S ∈ l\n\n"}
{"name":"cardinal_sInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Filter α\nS : Set (Set α)\ninst✝ : CardinalInterFilter l c\nhSc : LT.lt (Cardinal.mk ↑S) c\n⊢ Iff (Membership.mem l S.sInter) (∀ (s : Set α), Membership.mem S s → Membership.mem l s)","decl":"theorem cardinal_sInter_mem {S : Set (Set α)} [CardinalInterFilter l c] (hSc : #S < c) :\n    ⋂₀ S ∈ l ↔ ∀ s ∈ S, s ∈ l := ⟨fun hS _s hs => mem_of_superset hS (sInter_subset_of_mem hs),\n  CardinalInterFilter.cardinal_sInter_mem _ hSc⟩\n\n"}
{"name":"Filter.cardinalInterFilter_aleph0","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl : Filter α\n⊢ CardinalInterFilter l Cardinal.aleph0","decl":"/-- Every filter is a CardinalInterFilter with c = ℵ₀ -/\ntheorem _root_.Filter.cardinalInterFilter_aleph0 (l : Filter α) : CardinalInterFilter l ℵ₀ where\n  cardinal_sInter_mem := by\n    simp_all only [aleph_zero, lt_aleph0_iff_subtype_finite, setOf_mem_eq, sInter_mem,\n      implies_true, forall_const]\n\n"}
{"name":"CardinalInterFilter.toCountableInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nhc : LT.lt Cardinal.aleph0 c\n⊢ CountableInterFilter l","decl":"/-- Every CardinalInterFilter with c > ℵ₀ is a CountableInterFilter -/\ntheorem CardinalInterFilter.toCountableInterFilter (l : Filter α) [CardinalInterFilter l c]\n    (hc : ℵ₀ < c) : CountableInterFilter l where\n  countable_sInter_mem S hS a :=\n    CardinalInterFilter.cardinal_sInter_mem S (lt_of_le_of_lt (Set.Countable.le_aleph0 hS) hc) a\n\n"}
{"name":"CountableInterFilter.toCardinalInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl : Filter α\ninst✝ : CountableInterFilter l\n⊢ CardinalInterFilter l (Cardinal.aleph 1)","decl":"/-- Every CountableInterFilter is a CardinalInterFilter with c = ℵ₁ -/\ninstance CountableInterFilter.toCardinalInterFilter (l : Filter α) [CountableInterFilter l] :\n    CardinalInterFilter l ℵ₁ where\n  cardinal_sInter_mem S hS a :=\n    CountableInterFilter.countable_sInter_mem S ((countable_iff_lt_aleph_one S).mpr hS) a\n\n"}
{"name":"cardinalInterFilter_aleph_one_iff","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl : Filter α\n⊢ Iff (CardinalInterFilter l (Cardinal.aleph 1)) (CountableInterFilter l)","decl":"theorem cardinalInterFilter_aleph_one_iff :\n    CardinalInterFilter l ℵ₁ ↔ CountableInterFilter l :=\n  ⟨fun _ ↦ ⟨fun S h a ↦\n    CardinalInterFilter.cardinal_sInter_mem S ((countable_iff_lt_aleph_one S).1 h) a⟩,\n   fun _ ↦ CountableInterFilter.toCardinalInterFilter l⟩\n\n"}
{"name":"CardinalInterFilter.of_cardinalInterFilter_of_le","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\na : Cardinal.{u}\nhac : LE.le a c\n⊢ CardinalInterFilter l a","decl":"/-- Every CardinalInterFilter for some c also is a CardinalInterFilter for some a ≤ c -/\ntheorem CardinalInterFilter.of_cardinalInterFilter_of_le (l : Filter α) [CardinalInterFilter l c]\n    {a : Cardinal.{u}} (hac : a ≤ c) :\n    CardinalInterFilter l a where\n  cardinal_sInter_mem S hS a :=\n    CardinalInterFilter.cardinal_sInter_mem S (lt_of_lt_of_le hS hac) a\n\n"}
{"name":"CardinalInterFilter.of_cardinalInterFilter_of_lt","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\na : Cardinal.{u}\nhac : LT.lt a c\n⊢ CardinalInterFilter l a","decl":"theorem CardinalInterFilter.of_cardinalInterFilter_of_lt (l : Filter α) [CardinalInterFilter l c]\n    {a : Cardinal.{u}} (hac : a < c) : CardinalInterFilter l a :=\n  CardinalInterFilter.of_cardinalInterFilter_of_le l (hac.le)\n\n"}
{"name":"Filter.cardinal_iInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\ns : ι → Set α\nhic : LT.lt (Cardinal.mk ι) c\n⊢ Iff (Membership.mem l (Set.iInter fun i => s i)) (∀ (i : ι), Membership.mem l (s i))","decl":"theorem cardinal_iInter_mem {s : ι → Set α} (hic : #ι < c) :\n    (⋂ i, s i) ∈ l ↔ ∀ i, s i ∈ l := by\n  rw [← sInter_range _]\n  apply (cardinal_sInter_mem (lt_of_le_of_lt Cardinal.mk_range_le hic)).trans\n  exact forall_mem_range\n\n"}
{"name":"Filter.cardinal_bInter_mem","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\ns : (i : ι) → Membership.mem S i → Set α\n⊢ Iff (Membership.mem l (Set.iInter fun i => Set.iInter fun hi => s i hi)) (∀ (i : ι) (hi : Membership.mem S i), Membership.mem l (s i hi))","decl":"theorem cardinal_bInter_mem {S : Set ι} (hS : #S < c)\n    {s : ∀ i ∈ S, Set α} :\n    (⋂ i, ⋂ hi : i ∈ S, s i ‹_›) ∈ l ↔ ∀ i, ∀ hi : i ∈ S, s i ‹_› ∈ l := by\n  rw [biInter_eq_iInter]\n  exact (cardinal_iInter_mem hS).trans Subtype.forall\n\n"}
{"name":"Filter.eventually_cardinal_forall","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\np : α → ι → Prop\nhic : LT.lt (Cardinal.mk ι) c\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), p x i) l) (∀ (i : ι), Filter.Eventually (fun x => p x i) l)","decl":"theorem eventually_cardinal_forall {p : α → ι → Prop} (hic : #ι < c) :\n    (∀ᶠ x in l, ∀ i, p x i) ↔ ∀ i, ∀ᶠ x in l, p x i := by\n  simp only [Filter.Eventually, setOf_forall]\n  exact cardinal_iInter_mem hic\n\n"}
{"name":"Filter.eventually_cardinal_ball","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\np : α → (i : ι) → Membership.mem S i → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι) (hi : Membership.mem S i), p x i hi) l) (∀ (i : ι) (hi : Membership.mem S i), Filter.Eventually (fun x => p x i hi) l)","decl":"theorem eventually_cardinal_ball {S : Set ι} (hS : #S < c)\n    {p : α → ∀ i ∈ S, Prop} :\n    (∀ᶠ x in l, ∀ i hi, p x i hi) ↔ ∀ i hi, ∀ᶠ x in l, p x i hi := by\n  simp only [Filter.Eventually, setOf_forall]\n  exact cardinal_bInter_mem hS\n\n"}
{"name":"Filter.EventuallyLE.cardinal_iUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\ns t : ι → Set α\nhic : LT.lt (Cardinal.mk ι) c\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyLE.cardinal_iUnion {s t : ι → Set α} (hic : #ι < c)\n    (h : ∀ i, s i ≤ᶠ[l] t i) : ⋃ i, s i ≤ᶠ[l] ⋃ i, t i :=\n  ((eventually_cardinal_forall hic).2 h).mono fun _ hst hs => mem_iUnion.2 <|\n    (mem_iUnion.1 hs).imp hst\n\n"}
{"name":"Filter.EventuallyEq.cardinal_iUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\ns t : ι → Set α\nhic : LT.lt (Cardinal.mk ι) c\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyEq.cardinal_iUnion {s t : ι → Set α} (hic : #ι < c)\n    (h : ∀ i, s i =ᶠ[l] t i) : ⋃ i, s i =ᶠ[l] ⋃ i, t i :=\n  (EventuallyLE.cardinal_iUnion hic fun i => (h i).le).antisymm\n    (EventuallyLE.cardinal_iUnion hic fun i => (h i).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_bUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n⊢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyLE.cardinal_bUnion {S : Set ι} (hS : #S < c)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi ≤ᶠ[l] t i hi) :\n    ⋃ i ∈ S, s i ‹_› ≤ᶠ[l] ⋃ i ∈ S, t i ‹_› := by\n  simp only [biUnion_eq_iUnion]\n  exact EventuallyLE.cardinal_iUnion hS fun i => h i i.2\n\n"}
{"name":"Filter.EventuallyEq.cardinal_bUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n⊢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyEq.cardinal_bUnion {S : Set ι} (hS : #S < c)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi =ᶠ[l] t i hi) :\n    ⋃ i ∈ S, s i ‹_› =ᶠ[l] ⋃ i ∈ S, t i ‹_› :=\n  (EventuallyLE.cardinal_bUnion hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.cardinal_bUnion hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_iInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\ns t : ι → Set α\nhic : LT.lt (Cardinal.mk ι) c\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyLE.cardinal_iInter {s t : ι → Set α} (hic : #ι < c)\n    (h : ∀ i, s i ≤ᶠ[l] t i) : ⋂ i, s i ≤ᶠ[l] ⋂ i, t i :=\n  ((eventually_cardinal_forall hic).2 h).mono fun _ hst hs =>\n    mem_iInter.2 fun i => hst _ (mem_iInter.1 hs i)\n\n"}
{"name":"Filter.EventuallyEq.cardinal_iInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\ns t : ι → Set α\nhic : LT.lt (Cardinal.mk ι) c\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyEq.cardinal_iInter {s t : ι → Set α} (hic : #ι < c)\n    (h : ∀ i, s i =ᶠ[l] t i) : ⋂ i, s i =ᶠ[l] ⋂ i, t i :=\n  (EventuallyLE.cardinal_iInter hic fun i => (h i).le).antisymm\n    (EventuallyLE.cardinal_iInter hic fun i => (h i).symm.le)\n\n"}
{"name":"Filter.EventuallyLE.cardinal_bInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n⊢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyLE.cardinal_bInter {S : Set ι} (hS : #S < c)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi ≤ᶠ[l] t i hi) :\n    ⋂ i ∈ S, s i ‹_› ≤ᶠ[l] ⋂ i ∈ S, t i ‹_› := by\n  simp only [biInter_eq_iInter]\n  exact EventuallyLE.cardinal_iInter hS fun i => h i i.2\n\n"}
{"name":"Filter.EventuallyEq.cardinal_bInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"ι α : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nS : Set ι\nhS : LT.lt (Cardinal.mk ↑S) c\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n⊢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyEq.cardinal_bInter {S : Set ι} (hS : #S < c)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi =ᶠ[l] t i hi) :\n    ⋂ i ∈ S, s i ‹_› =ᶠ[l] ⋂ i ∈ S, t i ‹_› :=\n  (EventuallyLE.cardinal_bInter hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.cardinal_bInter hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.cardinalInter_ofCardinalInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Set (Set α)\nhc : LT.lt 2 c\nhl : ∀ (S : Set (Set α)), LT.lt (Cardinal.mk ↑S) c → HasSubset.Subset S l → Membership.mem l S.sInter\nh_mono : ∀ (s t : Set α), Membership.mem l s → HasSubset.Subset s t → Membership.mem l t\n⊢ CardinalInterFilter (Filter.ofCardinalInter l hc hl h_mono) c","decl":"instance cardinalInter_ofCardinalInter (l : Set (Set α)) (hc : 2 < c)\n    (hl : ∀ S : Set (Set α), (#S < c) → S ⊆ l → ⋂₀ S ∈ l)\n    (h_mono : ∀ s t, s ∈ l → s ⊆ t → t ∈ l) :\n    CardinalInterFilter (Filter.ofCardinalInter l hc hl h_mono) c :=\n  ⟨hl⟩\n\n"}
{"name":"Filter.mem_ofCardinalInter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Set (Set α)\nhc : LT.lt 2 c\nhl : ∀ (S : Set (Set α)), LT.lt (Cardinal.mk ↑S) c → HasSubset.Subset S l → Membership.mem l S.sInter\nh_mono : ∀ (s t : Set α), Membership.mem l s → HasSubset.Subset s t → Membership.mem l t\ns : Set α\n⊢ Iff (Membership.mem (Filter.ofCardinalInter l hc hl h_mono) s) (Membership.mem l s)","decl":"@[simp]\ntheorem mem_ofCardinalInter {l : Set (Set α)} (hc : 2 < c)\n    (hl : ∀ S : Set (Set α), (#S < c) → S ⊆ l → ⋂₀ S ∈ l) (h_mono : ∀ s t, s ∈ l → s ⊆ t → t ∈ l)\n    {s : Set α} : s ∈ Filter.ofCardinalInter l hc hl h_mono ↔ s ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Filter.cardinalInter_ofCardinalUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Set (Set α)\nhc : LT.lt 2 c\nh₁ : ∀ (S : Set (Set α)), LT.lt (Cardinal.mk ↑S) c → (∀ (s : Set α), Membership.mem S s → Membership.mem l s) → Membership.mem l S.sUnion\nh₂ : ∀ (t : Set α), Membership.mem l t → ∀ (s : Set α), HasSubset.Subset s t → Membership.mem l s\n⊢ CardinalInterFilter (Filter.ofCardinalUnion l hc h₁ h₂) c","decl":"instance cardinalInter_ofCardinalUnion (l : Set (Set α)) (hc : 2 < c) (h₁ h₂) :\n    CardinalInterFilter (Filter.ofCardinalUnion l hc h₁ h₂) c :=\n  cardinalInter_ofCardinalInter ..\n\n"}
{"name":"Filter.mem_ofCardinalUnion","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl : Set (Set α)\nhc : LT.lt 2 c\nhunion : ∀ (S : Set (Set α)), LT.lt (Cardinal.mk ↑S) c → (∀ (s : Set α), Membership.mem S s → Membership.mem l s) → Membership.mem l S.sUnion\nhmono : ∀ (t : Set α), Membership.mem l t → ∀ (s : Set α), HasSubset.Subset s t → Membership.mem l s\ns : Set α\n⊢ Iff (Membership.mem (Filter.ofCardinalUnion l hc hunion hmono) s) (l (HasCompl.compl s))","decl":"@[simp]\ntheorem mem_ofCardinalUnion {l : Set (Set α)} (hc : 2 < c) {hunion hmono s} :\n    s ∈ ofCardinalUnion l hc hunion hmono ↔ l sᶜ :=\n  Iff.rfl\n\n"}
{"name":"Filter.cardinalInterFilter_principal","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\ns : Set α\n⊢ CardinalInterFilter (Filter.principal s) c","decl":"instance cardinalInterFilter_principal (s : Set α) : CardinalInterFilter (𝓟 s) c :=\n  ⟨fun _ _ hS => subset_sInter hS⟩\n\n"}
{"name":"Filter.cardinalInterFilter_bot","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\n⊢ CardinalInterFilter Bot.bot c","decl":"instance cardinalInterFilter_bot : CardinalInterFilter (⊥ : Filter α) c := by\n  rw [← principal_empty]\n  apply cardinalInterFilter_principal\n\n"}
{"name":"Filter.cardinalInterFilter_top","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\n⊢ CardinalInterFilter Top.top c","decl":"instance cardinalInterFilter_top : CardinalInterFilter (⊤ : Filter α) c := by\n  rw [← principal_univ]\n  apply cardinalInterFilter_principal\n\n"}
{"name":"Filter.instCardinalInterFilterComap","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α β : Type u\nc : Cardinal.{u}\nl : Filter β\ninst✝ : CardinalInterFilter l c\nf : α → β\n⊢ CardinalInterFilter (Filter.comap f l) c","decl":"instance (l : Filter β) [CardinalInterFilter l c] (f : α → β) :\n    CardinalInterFilter (comap f l) c := by\n  refine ⟨fun S hSc hS => ?_⟩\n  choose! t htl ht using hS\n  refine ⟨_, (cardinal_bInter_mem hSc).2 htl, ?_⟩\n  simpa [preimage_iInter] using iInter₂_mono ht\n\n"}
{"name":"Filter.instCardinalInterFilterMap","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α β : Type u\nc : Cardinal.{u}\nl : Filter α\ninst✝ : CardinalInterFilter l c\nf : α → β\n⊢ CardinalInterFilter (Filter.map f l) c","decl":"instance (l : Filter α) [CardinalInterFilter l c] (f : α → β) :\n    CardinalInterFilter (map f l) c := by\n  refine ⟨fun S hSc hS => ?_⟩\n  simp only [mem_map, sInter_eq_biInter, preimage_iInter₂] at hS ⊢\n  exact (cardinal_bInter_mem hSc).2 hS\n\n"}
{"name":"Filter.cardinalInterFilter_inf_eq","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl₁ l₂ : Filter α\ninst✝¹ : CardinalInterFilter l₁ c\ninst✝ : CardinalInterFilter l₂ c\n⊢ CardinalInterFilter (Min.min l₁ l₂) c","decl":"/-- Infimum of two `CardinalInterFilter`s is a `CardinalInterFilter`. This is useful, e.g.,\nto automatically get an instance for `residual α ⊓ 𝓟 s`. -/\ninstance cardinalInterFilter_inf_eq (l₁ l₂ : Filter α) [CardinalInterFilter l₁ c]\n    [CardinalInterFilter l₂ c] : CardinalInterFilter (l₁ ⊓ l₂) c := by\n  refine ⟨fun S hSc hS => ?_⟩\n  choose s hs t ht hst using hS\n  replace hs : (⋂ i ∈ S, s i ‹_›) ∈ l₁ := (cardinal_bInter_mem hSc).2 hs\n  replace ht : (⋂ i ∈ S, t i ‹_›) ∈ l₂ := (cardinal_bInter_mem hSc).2 ht\n  refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => ?_)\n  rw [hst i hi]\n  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)\n\n"}
{"name":"Filter.cardinalInterFilter_inf","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl₁ l₂ : Filter α\nc₁ c₂ : Cardinal.{u}\ninst✝¹ : CardinalInterFilter l₁ c₁\ninst✝ : CardinalInterFilter l₂ c₂\n⊢ CardinalInterFilter (Min.min l₁ l₂) (Min.min c₁ c₂)","decl":"instance cardinalInterFilter_inf (l₁ l₂ : Filter α) {c₁ c₂ : Cardinal.{u}}\n    [CardinalInterFilter l₁ c₁] [CardinalInterFilter l₂ c₂] : CardinalInterFilter (l₁ ⊓ l₂)\n    (c₁ ⊓ c₂) := by\n  have : CardinalInterFilter l₁ (c₁ ⊓ c₂) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l₁ inf_le_left\n  have : CardinalInterFilter l₂ (c₁ ⊓ c₂) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l₂ inf_le_right\n  exact cardinalInterFilter_inf_eq _ _\n\n"}
{"name":"Filter.cardinalInterFilter_sup_eq","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\nl₁ l₂ : Filter α\ninst✝¹ : CardinalInterFilter l₁ c\ninst✝ : CardinalInterFilter l₂ c\n⊢ CardinalInterFilter (Max.max l₁ l₂) c","decl":"/-- Supremum of two `CardinalInterFilter`s is a `CardinalInterFilter`. -/\ninstance cardinalInterFilter_sup_eq (l₁ l₂ : Filter α) [CardinalInterFilter l₁ c]\n    [CardinalInterFilter l₂ c] : CardinalInterFilter (l₁ ⊔ l₂) c := by\n  refine ⟨fun S hSc hS => ⟨?_, ?_⟩⟩ <;> refine (cardinal_sInter_mem hSc).2 fun s hs => ?_\n  exacts [(hS s hs).1, (hS s hs).2]\n\n"}
{"name":"Filter.cardinalInterFilter_sup","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nl₁ l₂ : Filter α\nc₁ c₂ : Cardinal.{u}\ninst✝¹ : CardinalInterFilter l₁ c₁\ninst✝ : CardinalInterFilter l₂ c₂\n⊢ CardinalInterFilter (Max.max l₁ l₂) (Min.min c₁ c₂)","decl":"instance cardinalInterFilter_sup (l₁ l₂ : Filter α) {c₁ c₂ : Cardinal.{u}}\n    [CardinalInterFilter l₁ c₁] [CardinalInterFilter l₂ c₂] :\n    CardinalInterFilter (l₁ ⊔ l₂) (c₁ ⊓ c₂) := by\n  have : CardinalInterFilter l₁ (c₁ ⊓ c₂) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l₁ inf_le_left\n  have : CardinalInterFilter l₂ (c₁ ⊓ c₂) :=\n    CardinalInterFilter.of_cardinalInterFilter_of_le l₂ inf_le_right\n  exact cardinalInterFilter_sup_eq _ _\n\n"}
{"name":"Filter.cardinalInter_ofCardinalGenerate","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\ng : Set (Set α)\nhc : LT.lt 2 c\n⊢ CardinalInterFilter (Filter.cardinalGenerate g hc) c","decl":"lemma cardinalInter_ofCardinalGenerate (hc : 2 < c) :\n    CardinalInterFilter (cardinalGenerate g hc) c := by\n  delta cardinalGenerate\n  apply cardinalInter_ofCardinalInter _ _ _\n\n"}
{"name":"Filter.mem_cardinaleGenerate_iff","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\ng : Set (Set α)\ns : Set α\nhreg : c.IsRegular\n⊢ Iff (Membership.mem (Filter.cardinalGenerate g ⋯) s) (Exists fun S => And (HasSubset.Subset S g) (And (LT.lt (Cardinal.mk ↑S) c) (HasSubset.Subset S.sInter s)))","decl":"/-- A set is in the `cardinalInterFilter` generated by `g` if and only if\nit contains an intersection of `c` elements of `g`. -/\ntheorem mem_cardinaleGenerate_iff {s : Set α} {hreg : c.IsRegular} :\n    s ∈ cardinalGenerate g (IsRegular.nat_lt hreg 2) ↔\n    ∃ S : Set (Set α), S ⊆ g ∧ (#S < c) ∧ ⋂₀ S ⊆ s := by\n  constructor <;> intro h\n  · induction h with\n    | @basic s hs =>\n      refine ⟨{s}, singleton_subset_iff.mpr hs, ?_⟩\n      simpa [subset_refl] using IsRegular.nat_lt hreg 1\n    | univ =>\n      exact ⟨∅, ⟨empty_subset g, mk_eq_zero (∅ : Set <| Set α) ▸ IsRegular.nat_lt hreg 0, by simp⟩⟩\n    | superset _ _ ih => exact Exists.imp (by tauto) ih\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine ⟨⋃ (s) (H : s ∈ S), T s H, by simpa,\n        (Cardinal.card_biUnion_lt_iff_forall_of_isRegular hreg Sct).2 Tct, ?_⟩\n      apply subset_sInter\n      apply fun s H => subset_trans (sInter_subset_sInter (subset_iUnion₂ s H)) (hT s H)\n  rcases h with ⟨S, Sg, Sct, hS⟩\n  have : CardinalInterFilter (cardinalGenerate g (IsRegular.nat_lt hreg 2)) c :=\n    cardinalInter_ofCardinalGenerate _ _\n  exact mem_of_superset ((cardinal_sInter_mem Sct).mpr\n    (fun s H => CardinalGenerateSets.basic (Sg H))) hS\n\n"}
{"name":"Filter.le_cardinalGenerate_iff_of_cardinalInterFilter","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\ng : Set (Set α)\nf : Filter α\ninst✝ : CardinalInterFilter f c\nhc : LT.lt 2 c\n⊢ Iff (LE.le f (Filter.cardinalGenerate g hc)) (HasSubset.Subset g f.sets)","decl":"theorem le_cardinalGenerate_iff_of_cardinalInterFilter {f : Filter α} [CardinalInterFilter f c]\n    (hc : 2 < c) : f ≤ cardinalGenerate g hc ↔ g ⊆ f.sets := by\n  constructor <;> intro h\n  · exact subset_trans (fun s => CardinalGenerateSets.basic) h\n  intro s hs\n  induction hs with\n  | basic hs => exact h hs\n  | univ => exact univ_mem\n  | superset _ st ih => exact mem_of_superset ih st\n  | sInter Sct _ ih => exact (cardinal_sInter_mem Sct).mpr ih\n\n"}
{"name":"Filter.cardinalGenerate_isGreatest","module":"Mathlib.Order.Filter.CardinalInter","initialProofState":"α : Type u\nc : Cardinal.{u}\ng : Set (Set α)\nhc : LT.lt 2 c\n⊢ IsGreatest (setOf fun f => And (CardinalInterFilter f c) (HasSubset.Subset g f.sets)) (Filter.cardinalGenerate g hc)","decl":"/-- `cardinalGenerate g hc` is the greatest `cardinalInterFilter c` containing `g`. -/\ntheorem cardinalGenerate_isGreatest (hc : 2 < c) :\n    IsGreatest { f : Filter α | CardinalInterFilter f c ∧ g ⊆ f.sets } (cardinalGenerate g hc) := by\n  refine ⟨⟨cardinalInter_ofCardinalGenerate _ _, fun s => CardinalGenerateSets.basic⟩, ?_⟩\n  rintro f ⟨fct, hf⟩\n  rwa [le_cardinalGenerate_iff_of_cardinalInterFilter]\n\n"}
