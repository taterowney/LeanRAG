{"name":"small_iff","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\n⊢ Iff (Small.{w, v} α) (Exists fun S => Nonempty (Equiv α S))","decl":"/-- A type is `Small.{w}` if there exists an equivalence to some `S : Type w`.\n-/\n@[mk_iff, pp_with_univ]\nclass Small (α : Type v) : Prop where\n  /-- If a type is `Small.{w}`, then there exists an equivalence with some `S : Type w` -/\n  equiv_small : ∃ S : Type w, Nonempty (α ≃ S)\n\n"}
{"name":"Small.equiv_small","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\nself : Small.{w, v} α\n⊢ Exists fun S => Nonempty (Equiv α S)","decl":"/-- A type is `Small.{w}` if there exists an equivalence to some `S : Type w`.\n-/\n@[mk_iff, pp_with_univ]\nclass Small (α : Type v) : Prop where\n  /-- If a type is `Small.{w}`, then there exists an equivalence with some `S : Type w` -/\n  equiv_small : ∃ S : Type w, Nonempty (α ≃ S)\n\n"}
{"name":"Small.mk'","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\nS : Type w\ne : Equiv α S\n⊢ Small.{w, v} α","decl":"/-- Constructor for `Small α` from an explicit witness type and equivalence.\n-/\ntheorem Small.mk' {α : Type v} {S : Type w} (e : α ≃ S) : Small.{w} α :=\n  ⟨⟨S, ⟨e⟩⟩⟩\n\n"}
{"name":"Shrink.ext_iff","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\ninst✝ : Small.{w, v} α\nx y : Shrink.{w, v} α\n⊢ Iff (Eq x y) (Eq ((equivShrink α).symm x) ((equivShrink α).symm y))","decl":"@[ext]\ntheorem Shrink.ext {α : Type v} [Small.{w} α] {x y : Shrink α}\n    (w : (equivShrink _).symm x = (equivShrink _).symm y) : x = y := by\n  simpa using w\n\n-- It would be nice to mark this as `aesop cases` if\n-- https://github.com/JLimperg/aesop/issues/59\n-- is resolved.\n"}
{"name":"Shrink.ext","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\ninst✝ : Small.{w, v} α\nx y : Shrink.{w, v} α\nw : Eq ((equivShrink α).symm x) ((equivShrink α).symm y)\n⊢ Eq x y","decl":"@[ext]\ntheorem Shrink.ext {α : Type v} [Small.{w} α] {x y : Shrink α}\n    (w : (equivShrink _).symm x = (equivShrink _).symm y) : x = y := by\n  simpa using w\n\n-- It would be nice to mark this as `aesop cases` if\n-- https://github.com/JLimperg/aesop/issues/59\n-- is resolved.\n"}
{"name":"small_self","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\n⊢ Small.{v, v} α","decl":"instance (priority := 101) small_self (α : Type v) : Small.{v} α :=\n  Small.mk' <| Equiv.refl α\n\n"}
{"name":"small_map","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nhβ : Small.{w, u_2} β\ne : Equiv α β\n⊢ Small.{w, u_1} α","decl":"theorem small_map {α : Type*} {β : Type*} [hβ : Small.{w} β] (e : α ≃ β) : Small.{w} α :=\n  let ⟨_, ⟨f⟩⟩ := hβ.equiv_small\n  Small.mk' (e.trans f)\n\n"}
{"name":"small_lift","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type u\nhα : Small.{v, u} α\n⊢ Small.{max v w, u} α","decl":"theorem small_lift (α : Type u) [hα : Small.{v} α] : Small.{max v w} α :=\n  let ⟨⟨_, ⟨f⟩⟩⟩ := hα\n  Small.mk' <| f.trans (Equiv.ulift.{w}).symm\n\n"}
{"name":"small_max","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\n⊢ Small.{max w v, v} α","decl":"/-- Due to https://github.com/leanprover/lean4/issues/2297, this is useless as an instance.\n\nSee however `Logic.UnivLE`, whose API is able to indirectly provide this instance. -/\nlemma small_max (α : Type v) : Small.{max w v} α :=\n  small_lift.{v, w} α\n\n"}
{"name":"small_zero","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type\n⊢ Small.{w, 0} α","decl":"instance small_zero (α : Type) : Small.{w} α := small_max α\n\n"}
{"name":"small_succ","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type v\n⊢ Small.{v + 1, v} α","decl":"instance (priority := 100) small_succ (α : Type v) : Small.{v+1} α :=\n  small_lift.{v, v+1} α\n\n"}
{"name":"small_ulift","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type u\ninst✝ : Small.{v, u} α\n⊢ Small.{v, max w u} (ULift.{w, u} α)","decl":"instance small_ulift (α : Type u) [Small.{v} α] : Small.{v} (ULift.{w} α) :=\n  small_map Equiv.ulift\n\n"}
{"name":"small_type","module":"Mathlib.Logic.Small.Defs","initialProofState":"⊢ Small.{max (u + 1) v, u + 1} (Type u)","decl":"theorem small_type : Small.{max (u + 1) v} (Type u) :=\n  small_max.{max (u + 1) v} _\n\n"}
{"name":"small_congr","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Iff (Small.{w, u_1} α) (Small.{w, u_2} β)","decl":"theorem small_congr {α : Type*} {β : Type*} (e : α ≃ β) : Small.{w} α ↔ Small.{w} β :=\n  ⟨fun h => @small_map _ _ h e.symm, fun h => @small_map _ _ h e⟩\n\n"}
{"name":"small_sigma","module":"Mathlib.Logic.Small.Defs","initialProofState":"α : Type u_2\nβ : α → Type u_1\ninst✝¹ : Small.{w, u_2} α\ninst✝ : ∀ (a : α), Small.{w, u_1} (β a)\n⊢ Small.{w, max u_1 u_2} (Sigma fun a => β a)","decl":"instance small_sigma {α} (β : α → Type*) [Small.{w} α] [∀ a, Small.{w} (β a)] :\n    Small.{w} (Σa, β a) :=\n  ⟨⟨Σa' : Shrink α, Shrink (β ((equivShrink α).symm a')),\n      ⟨Equiv.sigmaCongr (equivShrink α) fun a => by simpa using equivShrink (β a)⟩⟩⟩\n\n"}
{"name":"not_small_type","module":"Mathlib.Logic.Small.Defs","initialProofState":"⊢ Not (Small.{u, max (u + 1) (v + 1)} (Type (max u v)))","decl":"theorem not_small_type : ¬Small.{u} (Type max u v)\n  | ⟨⟨S, ⟨e⟩⟩⟩ =>\n    @Function.cantor_injective (Σα, e.symm α) (fun a => ⟨_, cast (e.3 _).symm a⟩) fun a b e => by\n      dsimp at e\n      injection e with h₁ h₂\n      simpa using h₂\n\n"}
