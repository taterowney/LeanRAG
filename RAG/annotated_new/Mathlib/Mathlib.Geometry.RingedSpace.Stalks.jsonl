{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\nU : TopologicalSpace.Opens ↑↑Y\nx : ↑↑X\nhx : Membership.mem U (α.base x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (α.base x) hx) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x)) (CategoryTheory.CategoryStruct.comp (α.c.app { unop := U }) (X.presheaf.germ ((TopologicalSpace.Opens.map α.base).obj U) x hx))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (α : X ⟶ Y) (U : Opens Y)\n    (x : X) (hx : α x ∈ U) :\n    Y.presheaf.germ U (α x) hx ≫ α.stalkMap x = α.c.app (op U) ≫\n      X.presheaf.germ ((Opens.map α.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\nU : TopologicalSpace.Opens ↑↑Y\nx✝ : ↑↑X\nhx : Membership.mem U (α.base x✝)\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (Y.presheaf.obj { unop := U })\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x✝) ((Y.presheaf.germ U (α.base x✝) hx) x)) ((X.presheaf.germ ((TopologicalSpace.Opens.map α.base).obj U) x✝ hx) ((α.c.app { unop := U }) x))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (α : X ⟶ Y) (U : Opens Y)\n    (x : X) (hx : α x ∈ U) :\n    Y.presheaf.germ U (α x) hx ≫ α.stalkMap x = α.c.app (op U) ≫\n      X.presheaf.germ ((Opens.map α.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\nU : TopologicalSpace.Opens ↑↑Y\nx : ↑↑X\nhx : Membership.mem U (α.base x)\nZ : C\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (α.base x) hx) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x) h)) (CategoryTheory.CategoryStruct.comp (α.c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((TopologicalSpace.Opens.map α.base).obj U) x hx) h))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (α : X ⟶ Y) (U : Opens Y)\n    (x : X) (hx : α x ∈ U) :\n    Y.presheaf.germ U (α x) hx ≫ α.stalkMap x = α.c.app (op U) ≫\n      X.presheaf.germ ((Opens.map α.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx✝ : ↑U\nhx : Membership.mem V x✝\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj ((X.restrict h).presheaf.obj { unop := V })\n⊢ Eq ((X.restrictStalkIso h x✝).hom ((TopCat.Presheaf.germ (⋯.functor.op.comp X.presheaf) V x✝ hx) x)) ((X.presheaf.germ (⋯.functor.obj V) (f x✝) ⋯) x)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    (X.restrict h).presheaf.germ _ x hx ≫ (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ :=\n  colimit.ι_pre ((OpenNhds.inclusion (f x)).op ⋙ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op ⟨V, hx⟩)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh✝ : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx : ↑U\nhx : Membership.mem V x\nZ : C\nh : Quiver.Hom (X.presheaf.stalk (f x)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((X.restrict h✝).presheaf.germ V x hx) (CategoryTheory.CategoryStruct.comp (X.restrictStalkIso h✝ x).hom h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (⋯.functor.obj V) (f x) ⋯) h)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    (X.restrict h).presheaf.germ _ x hx ≫ (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ :=\n  colimit.ι_pre ((OpenNhds.inclusion (f x)).op ⋙ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op ⟨V, hx⟩)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx : ↑U\nhx : Membership.mem V x\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((X.restrict h).presheaf.germ V x hx) (X.restrictStalkIso h x).hom) (X.presheaf.germ (⋯.functor.obj V) (f x) ⋯)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    (X.restrict h).presheaf.germ _ x hx ≫ (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ :=\n  colimit.ι_pre ((OpenNhds.inclusion (f x)).op ⋙ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op ⟨V, hx⟩)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx✝ : ↑U\nhx : Membership.mem V x✝\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (X.presheaf.obj { unop := ⋯.functor.obj V })\n⊢ Eq ((X.restrictStalkIso h x✝).inv ((X.presheaf.germ (⋯.functor.obj V) (f x✝) ⋯) x)) ((TopCat.Presheaf.germ (⋯.functor.op.comp X.presheaf) V x✝ hx) x)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ ≫\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [← restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh✝ : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx : ↑U\nhx : Membership.mem V x\nZ : C\nh : Quiver.Hom ((X.restrict h✝).presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (⋯.functor.obj V) (f x) ⋯) (CategoryTheory.CategoryStruct.comp (X.restrictStalkIso h✝ x).inv h)) (CategoryTheory.CategoryStruct.comp ((X.restrict h✝).presheaf.germ V x hx) h)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ ≫\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [← restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nV : TopologicalSpace.Opens ↑U\nx : ↑U\nhx : Membership.mem V x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (⋯.functor.obj V) (f x) ⋯) (X.restrictStalkIso h x).inv) ((X.restrict h).presheaf.germ V x hx)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x ∈ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) ⟨x, hx, rfl⟩ ≫\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [← restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_ofRestrict","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nx : ↑U\n⊢ Eq (X.restrictStalkIso h x).inv (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (X.ofRestrict h) x)","decl":"theorem restrictStalkIso_inv_eq_ofRestrict {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :\n    (X.restrictStalkIso h x).inv = (X.ofRestrict h).stalkMap x := by\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun V => ?_\n  induction V with | h V => ?_\n  let i : (h.isOpenMap.functorNhds x).obj ((OpenNhds.map f x).obj V) ⟶ V :=\n    homOfLE (Set.image_preimage_subset f _)\n  erw [Iso.comp_inv_eq, colimit.ι_map_assoc, colimit.ι_map_assoc, colimit.ι_pre]\n  simp_rw [Category.assoc]\n  erw [colimit.ι_pre ((OpenNhds.inclusion (f x)).op ⋙ X.presheaf)\n      (h.isOpenMap.functorNhds x).op]\n  erw [← X.presheaf.map_comp_assoc]\n  exact (colimit.w ((OpenNhds.inclusion (f x)).op ⋙ X.presheaf) i.op).symm\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_stalkMap_isIso","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ↑X\nh : Topology.IsOpenEmbedding ⇑f\nx : ↑U\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (X.ofRestrict h) x)","decl":"instance ofRestrict_stalkMap_isIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U ⟶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :\n    IsIso ((X.ofRestrict h).stalkMap x) := by\n  rw [← restrictStalkIso_inv_eq_ofRestrict]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.id","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX : AlgebraicGeometry.PresheafedSpace C\nx : ↑↑X\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (CategoryTheory.CategoryStruct.id X) x) (CategoryTheory.CategoryStruct.id (X.presheaf.stalk x))","decl":"@[simp]\ntheorem id (X : PresheafedSpace.{_, _, v} C) (x : X) :\n    (𝟙 X : X ⟶ X).stalkMap x = 𝟙 (X.presheaf.stalk x) := by\n  dsimp [Hom.stalkMap]\n  simp only [stalkPushforward.id]\n  rw [← map_comp]\n  convert (stalkFunctor C x).map_id X.presheaf\n  ext\n  simp only [id_c, id_comp, Pushforward.id_hom_app, op_obj, eqToHom_refl, map_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.comp","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y Z : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\nβ : Quiver.Hom Y Z\nx : ↑↑X\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (CategoryTheory.CategoryStruct.comp α β) x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap β (α.base x)) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x))","decl":"@[simp]\ntheorem comp {X Y Z : PresheafedSpace.{_, _, v} C} (α : X ⟶ Y) (β : Y ⟶ Z) (x : X) :\n    (α ≫ β).stalkMap x =\n      (β.stalkMap (α.base x) : Z.presheaf.stalk (β.base (α.base x)) ⟶ Y.presheaf.stalk (α.base x)) ≫\n        (α.stalkMap x : Y.presheaf.stalk (α.base x) ⟶ X.presheaf.stalk x) := by\n  dsimp [Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  apply colimit.hom_ext\n  rintro ⟨U, hU⟩\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα β : Quiver.Hom X Y\nh₁ : Eq α β\nx x' : ↑↑X\nh₂ : Eq x x'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap β x'))","decl":"/-- If `α = β` and `x = x'`, we would like to say that `stalk_map α x = stalk_map β x'`.\nUnfortunately, this equality is not well-formed, as their types are not _definitionally_ the same.\nTo get a proper congruence lemma, we therefore have to introduce these `eqToHom` arrows on\neither side of the equality.\n-/\ntheorem congr {X Y : PresheafedSpace.{_, _, v} C} (α β : X ⟶ Y)\n    (h₁ : α = β) (x x' : X) (h₂ : x = x') :\n    α.stalkMap x ≫ eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [h₂]) =\n      eqToHom (show Y.presheaf.stalk (α.base x) = Y.presheaf.stalk (β.base x') by rw [h₁, h₂]) ≫\n        β.stalkMap x' := by\n  ext\n  substs h₁ h₂\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr_hom","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα β : Quiver.Hom X Y\nh : Eq α β\nx : ↑↑X\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap β x))","decl":"theorem congr_hom {X Y : PresheafedSpace.{_, _, v} C} (α β : X ⟶ Y) (h : α = β) (x : X) :\n    α.stalkMap x =\n      eqToHom (show Y.presheaf.stalk (α.base x) =\n        Y.presheaf.stalk (β.base x) by rw [h]) ≫ β.stalkMap x := by\n  rw [← stalkMap.congr α β h x x rfl, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr_point","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\nx x' : ↑↑X\nh : Eq x x'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x'))","decl":"theorem congr_point {X Y : PresheafedSpace.{_, _, v} C}\n    (α : X ⟶ Y) (x x' : X) (h : x = x') :\n    α.stalkMap x ≫ eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [h]) =\n      eqToHom (show Y.presheaf.stalk (α.base x) =\n        Y.presheaf.stalk (α.base x') by rw [h]) ≫ α.stalkMap x' := by\n  rw [stalkMap.congr α α rfl x x' h]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.isIso","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nα : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso α\nx : ↑↑X\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap α x)","decl":"instance isIso {X Y : PresheafedSpace.{_, _, v} C} (α : X ⟶ Y) [IsIso α] (x : X) :\n    IsIso (α.stalkMap x) where\n  out := by\n    let β : Y ⟶ X := CategoryTheory.inv α\n    have h_eq : (α ≫ β).base x = x := by rw [IsIso.hom_inv_id α, id_base, TopCat.id_app]\n    -- Intuitively, the inverse of the stalk map of `α` at `x` should just be the stalk map of `β`\n    -- at `α x`. Unfortunately, we have a problem with dependent type theory here: Because `x`\n    -- is not *definitionally* equal to `β (α x)`, the map `stalk_map β (α x)` has not the correct\n    -- type for an inverse.\n    -- To get a proper inverse, we need to compose with the `eqToHom` arrow\n    -- `X.stalk x ⟶ X.stalk ((α ≫ β).base x)`.\n    refine\n      ⟨eqToHom (show X.presheaf.stalk x = X.presheaf.stalk ((α ≫ β).base x) by rw [h_eq]) ≫\n          (β.stalkMap (α.base x) :),\n        ?_, ?_⟩\n    · rw [← Category.assoc, congr_point α x ((α ≫ β).base x) h_eq.symm, Category.assoc]\n      erw [← stalkMap.comp β α (α.base x)]\n      rw [congr_hom _ _ (IsIso.inv_hom_id α), stalkMap.id, eqToHom_trans_assoc, eqToHom_refl,\n        Category.id_comp]\n    · rw [Category.assoc, ← stalkMap.comp, congr_hom _ _ (IsIso.hom_inv_id α), stalkMap.id,\n        eqToHom_trans_assoc, eqToHom_refl, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nx y : ↑↑X\nh : Specializes x y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes ⋯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) (X.presheaf.stalkSpecializes h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X ⟶ Y) {x y : X} (h : x ⤳ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) ≫ f.stalkMap x =\n      f.stalkMap y ≫ X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.ι_desc_assoc, ι_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.ι_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.ι_desc, Cocones.precompose_obj_ι,\n    Cocone.whisker_ι, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nx✝ y : ↑↑X\nh : Specializes x✝ y\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (Y.presheaf.stalk (f.base y))\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f x✝) ((Y.presheaf.stalkSpecializes ⋯) x)) ((X.presheaf.stalkSpecializes h) ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) x))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X ⟶ Y) {x y : X} (h : x ⤳ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) ≫ f.stalkMap x =\n      f.stalkMap y ≫ X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.ι_desc_assoc, ι_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.ι_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.ι_desc, Cocones.precompose_obj_ι,\n    Cocone.whisker_ι, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nx y : ↑↑X\nh✝ : Specializes x y\nZ : C\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes ⋯) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkSpecializes h✝) h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X ⟶ Y) {x y : X} (h : x ⤳ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) ≫ f.stalkMap x =\n      f.stalkMap y ≫ X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.ι_desc_assoc, ι_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.ι_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.ι_desc, Cocones.precompose_obj_ι,\n    Cocone.whisker_ι, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
