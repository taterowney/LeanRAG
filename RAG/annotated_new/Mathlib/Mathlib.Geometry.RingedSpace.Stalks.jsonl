{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\nU : TopologicalSpace.Opens â†‘â†‘Y\nx : â†‘â†‘X\nhx : Membership.mem U (Î±.base x)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (Î±.base x) hx) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x)) (CategoryTheory.CategoryStruct.comp (Î±.c.app { unop := U }) (X.presheaf.germ ((TopologicalSpace.Opens.map Î±.base).obj U) x hx))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (U : Opens Y)\n    (x : X) (hx : Î± x âˆˆ U) :\n    Y.presheaf.germ U (Î± x) hx â‰« Î±.stalkMap x = Î±.c.app (op U) â‰«\n      X.presheaf.germ ((Opens.map Î±.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\nU : TopologicalSpace.Opens â†‘â†‘Y\nxâœ : â†‘â†‘X\nhx : Membership.mem U (Î±.base xâœ)\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (Y.presheaf.obj { unop := U })\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± xâœ) ((Y.presheaf.germ U (Î±.base xâœ) hx) x)) ((X.presheaf.germ ((TopologicalSpace.Opens.map Î±.base).obj U) xâœ hx) ((Î±.c.app { unop := U }) x))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (U : Opens Y)\n    (x : X) (hx : Î± x âˆˆ U) :\n    Y.presheaf.germ U (Î± x) hx â‰« Î±.stalkMap x = Î±.c.app (op U) â‰«\n      X.presheaf.germ ((Opens.map Î±.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\nU : TopologicalSpace.Opens â†‘â†‘Y\nx : â†‘â†‘X\nhx : Membership.mem U (Î±.base x)\nZ : C\nh : Quiver.Hom (X.presheaf.stalk x) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (Î±.base x) hx) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x) h)) (CategoryTheory.CategoryStruct.comp (Î±.c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((TopologicalSpace.Opens.map Î±.base).obj U) x hx) h))","decl":"@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (U : Opens Y)\n    (x : X) (hx : Î± x âˆˆ U) :\n    Y.presheaf.germ U (Î± x) hx â‰« Î±.stalkMap x = Î±.c.app (op U) â‰«\n      X.presheaf.germ ((Opens.map Î±.base).obj U) x hx := by\n  rw [Hom.stalkMap, stalkFunctor_map_germ_assoc, stalkPushforward_germ]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nxâœ : â†‘U\nhx : Membership.mem V xâœ\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj ((X.restrict h).presheaf.obj { unop := V })\nâŠ¢ Eq ((X.restrictStalkIso h xâœ).hom ((TopCat.Presheaf.germ (â‹¯.functor.op.comp X.presheaf) V xâœ hx) x)) ((X.presheaf.germ (â‹¯.functor.obj V) (f xâœ) â‹¯) x)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    (X.restrict h).presheaf.germ _ x hx â‰« (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© :=\n  colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op âŸ¨V, hxâŸ©)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nhâœ : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nx : â†‘U\nhx : Membership.mem V x\nZ : C\nh : Quiver.Hom (X.presheaf.stalk (f x)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((X.restrict hâœ).presheaf.germ V x hx) (CategoryTheory.CategoryStruct.comp (X.restrictStalkIso hâœ x).hom h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (â‹¯.functor.obj V) (f x) â‹¯) h)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    (X.restrict h).presheaf.germ _ x hx â‰« (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© :=\n  colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op âŸ¨V, hxâŸ©)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nx : â†‘U\nhx : Membership.mem V x\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((X.restrict h).presheaf.germ V x hx) (X.restrictStalkIso h x).hom) (X.presheaf.germ (â‹¯.functor.obj V) (f x) â‹¯)","decl":"@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    (X.restrict h).presheaf.germ _ x hx â‰« (restrictStalkIso X h x).hom =\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© :=\n  colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) (h.isOpenMap.functorNhds x).op\n    (op âŸ¨V, hxâŸ©)\n\n-- We intentionally leave `simp` off the lemmas generated by `elementwise` and `reassoc`,\n-- as the simpNF linter claims they never apply.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nxâœ : â†‘U\nhx : Membership.mem V xâœ\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (X.presheaf.obj { unop := â‹¯.functor.obj V })\nâŠ¢ Eq ((X.restrictStalkIso h xâœ).inv ((X.presheaf.germ (â‹¯.functor.obj V) (f xâœ) â‹¯) x)) ((TopCat.Presheaf.germ (â‹¯.functor.op.comp X.presheaf) V xâœ hx) x)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© â‰«\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [â† restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nhâœ : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nx : â†‘U\nhx : Membership.mem V x\nZ : C\nh : Quiver.Hom ((X.restrict hâœ).presheaf.stalk x) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (â‹¯.functor.obj V) (f x) â‹¯) (CategoryTheory.CategoryStruct.comp (X.restrictStalkIso hâœ x).inv h)) (CategoryTheory.CategoryStruct.comp ((X.restrict hâœ).presheaf.germ V x hx) h)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© â‰«\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [â† restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nx : â†‘U\nhx : Membership.mem V x\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ (â‹¯.functor.obj V) (f x) â‹¯) (X.restrictStalkIso h x).inv) ((X.restrict h).presheaf.germ V x hx)","decl":"@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (V : Opens U) (x : U) (hx : x âˆˆ V) :\n    X.presheaf.germ (h.isOpenMap.functor.obj V) (f x) âŸ¨x, hx, rflâŸ© â‰«\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ _ x hx := by\n  rw [â† restrictStalkIso_hom_eq_germ, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_ofRestrict","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nx : â†‘U\nâŠ¢ Eq (X.restrictStalkIso h x).inv (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (X.ofRestrict h) x)","decl":"theorem restrictStalkIso_inv_eq_ofRestrict {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :\n    (X.restrictStalkIso h x).inv = (X.ofRestrict h).stalkMap x := by\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun V => ?_\n  induction V with | h V => ?_\n  let i : (h.isOpenMap.functorNhds x).obj ((OpenNhds.map f x).obj V) âŸ¶ V :=\n    homOfLE (Set.image_preimage_subset f _)\n  erw [Iso.comp_inv_eq, colimit.Î¹_map_assoc, colimit.Î¹_map_assoc, colimit.Î¹_pre]\n  simp_rw [Category.assoc]\n  erw [colimit.Î¹_pre ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf)\n      (h.isOpenMap.functorNhds x).op]\n  erw [â† X.presheaf.map_comp_assoc]\n  exact (colimit.w ((OpenNhds.inclusion (f x)).op â‹™ X.presheaf) i.op).symm\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_stalkMap_isIso","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U â†‘X\nh : Topology.IsOpenEmbedding â‡‘f\nx : â†‘U\nâŠ¢ CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (X.ofRestrict h) x)","decl":"instance ofRestrict_stalkMap_isIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U âŸ¶ (X : TopCat.{v})} (h : IsOpenEmbedding f) (x : U) :\n    IsIso ((X.ofRestrict h).stalkMap x) := by\n  rw [â† restrictStalkIso_inv_eq_ofRestrict]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.id","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX : AlgebraicGeometry.PresheafedSpace C\nx : â†‘â†‘X\nâŠ¢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (CategoryTheory.CategoryStruct.id X) x) (CategoryTheory.CategoryStruct.id (X.presheaf.stalk x))","decl":"@[simp]\ntheorem id (X : PresheafedSpace.{_, _, v} C) (x : X) :\n    (ðŸ™ X : X âŸ¶ X).stalkMap x = ðŸ™ (X.presheaf.stalk x) := by\n  dsimp [Hom.stalkMap]\n  simp only [stalkPushforward.id]\n  rw [â† map_comp]\n  convert (stalkFunctor C x).map_id X.presheaf\n  ext\n  simp only [id_c, id_comp, Pushforward.id_hom_app, op_obj, eqToHom_refl, map_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.comp","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y Z : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\nÎ² : Quiver.Hom Y Z\nx : â†‘â†‘X\nâŠ¢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap (CategoryTheory.CategoryStruct.comp Î± Î²) x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î² (Î±.base x)) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x))","decl":"@[simp]\ntheorem comp {X Y Z : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) (Î² : Y âŸ¶ Z) (x : X) :\n    (Î± â‰« Î²).stalkMap x =\n      (Î².stalkMap (Î±.base x) : Z.presheaf.stalk (Î².base (Î±.base x)) âŸ¶ Y.presheaf.stalk (Î±.base x)) â‰«\n        (Î±.stalkMap x : Y.presheaf.stalk (Î±.base x) âŸ¶ X.presheaf.stalk x) := by\n  dsimp [Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  apply colimit.hom_ext\n  rintro âŸ¨U, hUâŸ©\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± Î² : Quiver.Hom X Y\nhâ‚ : Eq Î± Î²\nx x' : â†‘â†‘X\nhâ‚‚ : Eq x x'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x) (CategoryTheory.eqToHom â‹¯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î² x'))","decl":"/-- If `Î± = Î²` and `x = x'`, we would like to say that `stalk_map Î± x = stalk_map Î² x'`.\nUnfortunately, this equality is not well-formed, as their types are not _definitionally_ the same.\nTo get a proper congruence lemma, we therefore have to introduce these `eqToHom` arrows on\neither side of the equality.\n-/\ntheorem congr {X Y : PresheafedSpace.{_, _, v} C} (Î± Î² : X âŸ¶ Y)\n    (hâ‚ : Î± = Î²) (x x' : X) (hâ‚‚ : x = x') :\n    Î±.stalkMap x â‰« eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [hâ‚‚]) =\n      eqToHom (show Y.presheaf.stalk (Î±.base x) = Y.presheaf.stalk (Î².base x') by rw [hâ‚, hâ‚‚]) â‰«\n        Î².stalkMap x' := by\n  ext\n  substs hâ‚ hâ‚‚\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr_hom","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± Î² : Quiver.Hom X Y\nh : Eq Î± Î²\nx : â†‘â†‘X\nâŠ¢ Eq (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î² x))","decl":"theorem congr_hom {X Y : PresheafedSpace.{_, _, v} C} (Î± Î² : X âŸ¶ Y) (h : Î± = Î²) (x : X) :\n    Î±.stalkMap x =\n      eqToHom (show Y.presheaf.stalk (Î±.base x) =\n        Y.presheaf.stalk (Î².base x) by rw [h]) â‰« Î².stalkMap x := by\n  rw [â† stalkMap.congr Î± Î² h x x rfl, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.congr_point","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\nx x' : â†‘â†‘X\nh : Eq x x'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x) (CategoryTheory.eqToHom â‹¯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x'))","decl":"theorem congr_point {X Y : PresheafedSpace.{_, _, v} C}\n    (Î± : X âŸ¶ Y) (x x' : X) (h : x = x') :\n    Î±.stalkMap x â‰« eqToHom (show X.presheaf.stalk x = X.presheaf.stalk x' by rw [h]) =\n      eqToHom (show Y.presheaf.stalk (Î±.base x) =\n        Y.presheaf.stalk (Î±.base x') by rw [h]) â‰« Î±.stalkMap x' := by\n  rw [stalkMap.congr Î± Î± rfl x x' h]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.isIso","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nÎ± : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso Î±\nx : â†‘â†‘X\nâŠ¢ CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap Î± x)","decl":"instance isIso {X Y : PresheafedSpace.{_, _, v} C} (Î± : X âŸ¶ Y) [IsIso Î±] (x : X) :\n    IsIso (Î±.stalkMap x) where\n  out := by\n    let Î² : Y âŸ¶ X := CategoryTheory.inv Î±\n    have h_eq : (Î± â‰« Î²).base x = x := by rw [IsIso.hom_inv_id Î±, id_base, TopCat.id_app]\n    -- Intuitively, the inverse of the stalk map of `Î±` at `x` should just be the stalk map of `Î²`\n    -- at `Î± x`. Unfortunately, we have a problem with dependent type theory here: Because `x`\n    -- is not *definitionally* equal to `Î² (Î± x)`, the map `stalk_map Î² (Î± x)` has not the correct\n    -- type for an inverse.\n    -- To get a proper inverse, we need to compose with the `eqToHom` arrow\n    -- `X.stalk x âŸ¶ X.stalk ((Î± â‰« Î²).base x)`.\n    refine\n      âŸ¨eqToHom (show X.presheaf.stalk x = X.presheaf.stalk ((Î± â‰« Î²).base x) by rw [h_eq]) â‰«\n          (Î².stalkMap (Î±.base x) :),\n        ?_, ?_âŸ©\n    Â· rw [â† Category.assoc, congr_point Î± x ((Î± â‰« Î²).base x) h_eq.symm, Category.assoc]\n      erw [â† stalkMap.comp Î² Î± (Î±.base x)]\n      rw [congr_hom _ _ (IsIso.inv_hom_id Î±), stalkMap.id, eqToHom_trans_assoc, eqToHom_refl,\n        Category.id_comp]\n    Â· rw [Category.assoc, â† stalkMap.comp, congr_hom _ _ (IsIso.hom_inv_id Î±), stalkMap.id,\n        eqToHom_trans_assoc, eqToHom_refl, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nx y : â†‘â†‘X\nh : Specializes x y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes â‹¯) (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) (X.presheaf.stalkSpecializes h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X âŸ¶ Y) {x y : X} (h : x â¤³ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) â‰« f.stalkMap x =\n      f.stalkMap y â‰« X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.Î¹_desc_assoc, Î¹_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.Î¹_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.Î¹_desc, Cocones.precompose_obj_Î¹,\n    Cocone.whisker_Î¹, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap_apply","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nxâœ y : â†‘â†‘X\nh : Specializes xâœ y\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (Y.presheaf.stalk (f.base y))\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f xâœ) ((Y.presheaf.stalkSpecializes â‹¯) x)) ((X.presheaf.stalkSpecializes h) ((AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) x))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X âŸ¶ Y) {x y : X} (h : x â¤³ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) â‰« f.stalkMap x =\n      f.stalkMap y â‰« X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.Î¹_desc_assoc, Î¹_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.Î¹_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.Î¹_desc, Cocones.precompose_obj_Î¹,\n    Cocone.whisker_Î¹, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap_assoc","module":"Mathlib.Geometry.RingedSpace.Stalks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\nx y : â†‘â†‘X\nhâœ : Specializes x y\nZ : C\nh : Quiver.Hom (X.presheaf.stalk x) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes â‹¯) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.Hom.stalkMap f y) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkSpecializes hâœ) h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X âŸ¶ Y) {x y : X} (h : x â¤³ y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) â‰« f.stalkMap x =\n      f.stalkMap y â‰« X.presheaf.stalkSpecializes h := by\n  -- Porting note: the original one liner `dsimp [stalkMap]; simp [stalkMap]` doesn't work,\n  -- I had to uglify this\n  dsimp [stalkSpecializes, Hom.stalkMap, stalkFunctor, stalkPushforward]\n  -- We can't use `ext` here due to https://github.com/leanprover/std4/pull/159\n  refine colimit.hom_ext fun j => ?_\n  induction j with | h j => ?_\n  dsimp\n  simp only [colimit.Î¹_desc_assoc, Î¹_colimMap_assoc, whiskerLeft_app,\n    whiskerRight_app, NatTrans.id_app, map_id, colimit.Î¹_pre, id_comp, assoc,\n    colimit.pre_desc, colimit.map_desc, colimit.Î¹_desc, Cocones.precompose_obj_Î¹,\n    Cocone.whisker_Î¹, NatTrans.comp_app]\n  erw [X.presheaf.map_id, id_comp]\n  rfl\n\n"}
