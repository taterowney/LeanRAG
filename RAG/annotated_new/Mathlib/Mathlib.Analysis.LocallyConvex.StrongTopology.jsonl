{"name":"UniformConvergenceCLM.locallyConvexSpace","module":"Mathlib.Analysis.LocallyConvex.StrongTopology","initialProofState":"R : Type u_1\n𝕜₁ : Type u_2\n𝕜₂ : Type u_3\nE : Type u_4\nF : Type u_5\ninst✝¹³ : AddCommGroup E\ninst✝¹² : TopologicalSpace E\ninst✝¹¹ : AddCommGroup F\ninst✝¹⁰ : TopologicalSpace F\ninst✝⁹ : TopologicalAddGroup F\ninst✝⁸ : OrderedSemiring R\ninst✝⁷ : NormedField 𝕜₁\ninst✝⁶ : NormedField 𝕜₂\ninst✝⁵ : Module 𝕜₁ E\ninst✝⁴ : Module 𝕜₂ F\nσ : RingHom 𝕜₁ 𝕜₂\ninst✝³ : Module R F\ninst✝² : ContinuousConstSMul R F\ninst✝¹ : LocallyConvexSpace R F\ninst✝ : SMulCommClass 𝕜₂ R F\n𝔖 : Set (Set E)\nh𝔖₁ : 𝔖.Nonempty\nh𝔖₂ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n⊢ LocallyConvexSpace R (UniformConvergenceCLM σ F 𝔖)","decl":"theorem locallyConvexSpace (𝔖 : Set (Set E)) (h𝔖₁ : 𝔖.Nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) :\n    LocallyConvexSpace R (UniformConvergenceCLM σ F 𝔖) := by\n  apply LocallyConvexSpace.ofBasisZero _ _ _ _\n    (UniformConvergenceCLM.hasBasis_nhds_zero_of_basis _ _ _ h𝔖₁ h𝔖₂\n      (LocallyConvexSpace.convex_basis_zero R F)) _\n  rintro ⟨S, V⟩ ⟨_, _, hVconvex⟩ f hf g hg a b ha hb hab x hx\n  exact hVconvex (hf x hx) (hg x hx) ha hb hab\n\n"}
{"name":"ContinuousLinearMap.instLocallyConvexSpace","module":"Mathlib.Analysis.LocallyConvex.StrongTopology","initialProofState":"R : Type u_1\n𝕜₁ : Type u_2\n𝕜₂ : Type u_3\nE : Type u_4\nF : Type u_5\ninst✝¹³ : AddCommGroup E\ninst✝¹² : TopologicalSpace E\ninst✝¹¹ : AddCommGroup F\ninst✝¹⁰ : TopologicalSpace F\ninst✝⁹ : TopologicalAddGroup F\ninst✝⁸ : OrderedSemiring R\ninst✝⁷ : NormedField 𝕜₁\ninst✝⁶ : NormedField 𝕜₂\ninst✝⁵ : Module 𝕜₁ E\ninst✝⁴ : Module 𝕜₂ F\nσ : RingHom 𝕜₁ 𝕜₂\ninst✝³ : Module R F\ninst✝² : ContinuousConstSMul R F\ninst✝¹ : LocallyConvexSpace R F\ninst✝ : SMulCommClass 𝕜₂ R F\n⊢ LocallyConvexSpace R (ContinuousLinearMap σ E F)","decl":"instance instLocallyConvexSpace : LocallyConvexSpace R (E →SL[σ] F) :=\n  UniformConvergenceCLM.locallyConvexSpace R _ ⟨∅, Bornology.isVonNBounded_empty 𝕜₁ E⟩\n    (directedOn_of_sup_mem fun _ _ => Bornology.IsVonNBounded.union)\n\n"}
