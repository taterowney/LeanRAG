{"name":"Set.top_eq_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq Top.top Set.univ","decl":"@[simp]\ntheorem top_eq_univ : (⊤ : Set α) = univ :=\n  rfl\n\n"}
{"name":"Set.bot_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq Bot.bot EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bot_eq_empty : (⊥ : Set α) = ∅ :=\n  rfl\n\n"}
{"name":"Set.sup_eq_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (fun x1 x2 => Max.max x1 x2) fun x1 x2 => Union.union x1 x2","decl":"@[simp]\ntheorem sup_eq_union : ((· ⊔ ·) : Set α → Set α → Set α) = (· ∪ ·) :=\n  rfl\n\n"}
{"name":"Set.inf_eq_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (fun x1 x2 => Min.min x1 x2) fun x1 x2 => Inter.inter x1 x2","decl":"@[simp]\ntheorem inf_eq_inter : ((· ⊓ ·) : Set α → Set α → Set α) = (· ∩ ·) :=\n  rfl\n\n"}
{"name":"Set.le_eq_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (fun x1 x2 => LE.le x1 x2) fun x1 x2 => HasSubset.Subset x1 x2","decl":"@[simp]\ntheorem le_eq_subset : ((· ≤ ·) : Set α → Set α → Prop) = (· ⊆ ·) :=\n  rfl\n\n"}
{"name":"Set.lt_eq_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"@[simp]\ntheorem lt_eq_ssubset : ((· < ·) : Set α → Set α → Prop) = (· ⊂ ·) :=\n  rfl\n\n"}
{"name":"Set.le_iff_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (LE.le s t) (HasSubset.Subset s t)","decl":"theorem le_iff_subset : s ≤ t ↔ s ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"Set.lt_iff_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (LT.lt s t) (HasSSubset.SSubset s t)","decl":"theorem lt_iff_ssubset : s < t ↔ s ⊂ t :=\n  Iff.rfl\n\n"}
{"name":"HasSubset.Subset.le","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset s t\n⊢ LE.le s t","decl":"alias ⟨_root_.LE.le.subset, _root_.HasSubset.Subset.le⟩ := le_iff_subset\n\n"}
{"name":"LE.le.subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : LE.le s t\n⊢ HasSubset.Subset s t","decl":"alias ⟨_root_.LE.le.subset, _root_.HasSubset.Subset.le⟩ := le_iff_subset\n\n"}
{"name":"LT.lt.ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : LT.lt s t\n⊢ HasSSubset.SSubset s t","decl":"alias ⟨_root_.LT.lt.ssubset, _root_.HasSSubset.SSubset.lt⟩ := lt_iff_ssubset\n\n"}
{"name":"HasSSubset.SSubset.lt","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSSubset.SSubset s t\n⊢ LT.lt s t","decl":"alias ⟨_root_.LT.lt.ssubset, _root_.HasSSubset.SSubset.lt⟩ := lt_iff_ssubset\n\n"}
{"name":"Set.PiSetCoe.canLift","module":"Mathlib.Data.Set.Basic","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : ∀ (i : ι), Nonempty (α i)\ns : Set ι\n⊢ CanLift ((i : ↑s) → α ↑i) ((i : ι) → α i) (fun f i => f ↑i) fun x => True","decl":"instance PiSetCoe.canLift (ι : Type u) (α : ι → Type v) [∀ i, Nonempty (α i)] (s : Set ι) :\n    CanLift (∀ i : s, α i) (∀ i, α i) (fun f i => f i) fun _ => True :=\n  PiSubtype.canLift ι α s\n\n"}
{"name":"Set.PiSetCoe.canLift'","module":"Mathlib.Data.Set.Basic","initialProofState":"ι : Type u\nα : Type v\ninst✝ : Nonempty α\ns : Set ι\n⊢ CanLift (↑s → α) (ι → α) (fun f i => f ↑i) fun x => True","decl":"instance PiSetCoe.canLift' (ι : Type u) (α : Type v) [Nonempty α] (s : Set ι) :\n    CanLift (s → α) (ι → α) (fun f i => f i) fun _ => True :=\n  PiSetCoe.canLift ι (fun _ => α) s\n\n"}
{"name":"Set.coe_eq_subtype","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (↑s) (Subtype fun x => Membership.mem s x)","decl":"theorem Set.coe_eq_subtype (s : Set α) : ↥s = { x // x ∈ s } :=\n  rfl\n\n"}
{"name":"Set.coe_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Eq (↑(setOf fun x => p x)) (Subtype fun x => p x)","decl":"@[simp]\ntheorem Set.coe_setOf (p : α → Prop) : ↥{ x | p x } = { x // p x } :=\n  rfl\n\n"}
{"name":"SetCoe.forall","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : ↑s → Prop\n⊢ Iff (∀ (x : ↑s), p x) (∀ (x : α) (h : Membership.mem s x), p ⟨x, h⟩)","decl":"theorem SetCoe.forall {s : Set α} {p : s → Prop} : (∀ x : s, p x) ↔ ∀ (x) (h : x ∈ s), p ⟨x, h⟩ :=\n  Subtype.forall\n\n"}
{"name":"SetCoe.exists","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : ↑s → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => Exists fun h => p ⟨x, h⟩)","decl":"theorem SetCoe.exists {s : Set α} {p : s → Prop} :\n    (∃ x : s, p x) ↔ ∃ (x : _) (h : x ∈ s), p ⟨x, h⟩ :=\n  Subtype.exists\n\n"}
{"name":"SetCoe.exists'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : (x : α) → Membership.mem s x → Prop\n⊢ Iff (Exists fun x => Exists fun h => p x h) (Exists fun x => p ↑x ⋯)","decl":"theorem SetCoe.exists' {s : Set α} {p : ∀ x, x ∈ s → Prop} :\n    (∃ (x : _) (h : x ∈ s), p x h) ↔ ∃ x : s, p x.1 x.2 :=\n  (@SetCoe.exists _ _ fun x => p x.1 x.2).symm\n\n"}
{"name":"SetCoe.forall'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : (x : α) → Membership.mem s x → Prop\n⊢ Iff (∀ (x : α) (h : Membership.mem s x), p x h) (∀ (x : ↑s), p ↑x ⋯)","decl":"theorem SetCoe.forall' {s : Set α} {p : ∀ x, x ∈ s → Prop} :\n    (∀ (x) (h : x ∈ s), p x h) ↔ ∀ x : s, p x.1 x.2 :=\n  (@SetCoe.forall _ _ fun x => p x.1 x.2).symm\n\n"}
{"name":"set_coe_cast","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nH' : Eq s t\nH : Eq ↑s ↑t\nx : ↑s\n⊢ Eq (cast H x) ⟨↑x, ⋯⟩","decl":"@[simp]\ntheorem set_coe_cast :\n    ∀ {s t : Set α} (H' : s = t) (H : ↥s = ↥t) (x : s), cast H x = ⟨x.1, H' ▸ x.2⟩\n  | _, _, rfl, _, _ => rfl\n\n"}
{"name":"SetCoe.ext","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na b : ↑s\na✝ : Eq ↑a ↑b\n⊢ Eq a b","decl":"theorem SetCoe.ext {s : Set α} {a b : s} : (a : α) = b → a = b :=\n  Subtype.eq\n\n"}
{"name":"SetCoe.ext_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na b : ↑s\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem SetCoe.ext_iff {s : Set α} {a b : s} : (↑a : α) = ↑b ↔ a = b :=\n  Iff.intro SetCoe.ext fun h => h ▸ rfl\n\n"}
{"name":"Subtype.mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns : Set α\np : ↑s\n⊢ Membership.mem s ↑p","decl":"/-- See also `Subtype.prop` -/\ntheorem Subtype.mem {α : Type*} {s : Set α} (p : s) : (p : α) ∈ s :=\n  p.prop\n\n"}
{"name":"Eq.subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\na✝ : Eq s t\n⊢ HasSubset.Subset s t","decl":"/-- Duplicate of `Eq.subset'`, which currently has elaboration problems. -/\ntheorem Eq.subset {α} {s t : Set α} : s = t → s ⊆ t :=\n  fun h₁ _ h₂ => by rw [← h₁]; exact h₂\n\n"}
{"name":"Set.mem_of_mem_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns t : Set α\nhx : Membership.mem s x\nh : HasSubset.Subset s t\n⊢ Membership.mem t x","decl":"@[trans]\ntheorem mem_of_mem_of_subset {x : α} {s t : Set α} (hx : x ∈ s) (h : s ⊆ t) : x ∈ t :=\n  h hx\n\n"}
{"name":"Set.forall_in_swap","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\np : α → β → Prop\n⊢ Iff (∀ (a : α), Membership.mem s a → ∀ (b : β), p a b) (∀ (b : β) (a : α), Membership.mem s a → p a b)","decl":"theorem forall_in_swap {p : α → β → Prop} : (∀ a ∈ s, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ s, p a b := by\n  tauto\n\n"}
{"name":"Set.mem_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\np : α → Prop\n⊢ Iff (Membership.mem (setOf fun x => p x) a) (p a)","decl":"theorem mem_setOf {a : α} {p : α → Prop} : a ∈ { x | p x } ↔ p a :=\n  Iff.rfl\n\n"}
{"name":"Set.eq_mem_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Eq p fun x => Membership.mem (setOf fun a => p a) x","decl":"/-- This lemma is intended for use with `rw` where a membership predicate is needed,\nhence the explicit argument and the equality in the reverse direction from normal.\nSee also `Set.mem_setOf_eq` for the reverse direction applied to an argument. -/\ntheorem eq_mem_setOf (p : α → Prop) : p = (· ∈ {a | p a}) := rfl\n\n"}
{"name":"Membership.mem.out","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\na : α\nh : Membership.mem (setOf fun x => p x) a\n⊢ p a","decl":"/-- If `h : a ∈ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`. -/\ntheorem _root_.Membership.mem.out {p : α → Prop} {a : α} (h : a ∈ { x | p x }) : p a :=\n  h\n\n"}
{"name":"Set.nmem_setOf_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\np : α → Prop\n⊢ Iff (Not (Membership.mem (setOf fun x => p x) a)) (Not (p a))","decl":"theorem nmem_setOf_iff {a : α} {p : α → Prop} : a ∉ { x | p x } ↔ ¬p a :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_mem_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (setOf fun x => Membership.mem s x) s","decl":"@[simp]\ntheorem setOf_mem_eq {s : Set α} : { x | x ∈ s } = s :=\n  rfl\n\n"}
{"name":"Set.setOf_set","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (setOf s) s","decl":"theorem setOf_set {s : Set α} : setOf s = s :=\n  rfl\n\n"}
{"name":"Set.setOf_app_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\nx : α\n⊢ Iff (setOf (fun x => p x) x) (p x)","decl":"theorem setOf_app_iff {p : α → Prop} {x : α} : { x | p x } x ↔ p x :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Membership.mem s a) (s a)","decl":"theorem mem_def {a : α} {s : Set α} : a ∈ s ↔ s a :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_bijective","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Function.Bijective setOf","decl":"theorem setOf_bijective : Bijective (setOf : (α → Prop) → Set α) :=\n  bijective_id\n\n"}
{"name":"Set.subset_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\ns : Set α\n⊢ Iff (HasSubset.Subset s (setOf p)) (∀ (x : α), Membership.mem s x → p x)","decl":"theorem subset_setOf {p : α → Prop} {s : Set α} : s ⊆ setOf p ↔ ∀ x, x ∈ s → p x :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\ns : Set α\n⊢ Iff (HasSubset.Subset (setOf p) s) (∀ (x : α), p x → Membership.mem s x)","decl":"theorem setOf_subset {p : α → Prop} {s : Set α} : setOf p ⊆ s ↔ ∀ x, p x → x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_subset_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np q : α → Prop\n⊢ Iff (HasSubset.Subset (setOf fun a => p a) (setOf fun a => q a)) (∀ (a : α), p a → q a)","decl":"@[simp]\ntheorem setOf_subset_setOf {p q : α → Prop} : { a | p a } ⊆ { a | q a } ↔ ∀ a, p a → q a :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_and","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np q : α → Prop\n⊢ Eq (setOf fun a => And (p a) (q a)) (Inter.inter (setOf fun a => p a) (setOf fun a => q a))","decl":"theorem setOf_and {p q : α → Prop} : { a | p a ∧ q a } = { a | p a } ∩ { a | q a } :=\n  rfl\n\n"}
{"name":"Set.setOf_or","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np q : α → Prop\n⊢ Eq (setOf fun a => Or (p a) (q a)) (Union.union (setOf fun a => p a) (setOf fun a => q a))","decl":"theorem setOf_or {p q : α → Prop} : { a | p a ∨ q a } = { a | p a } ∪ { a | q a } :=\n  rfl\n\n"}
{"name":"Set.instIsReflSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsRefl (Set α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsRefl (Set α) (· ⊆ ·) :=\n  show IsRefl (Set α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Set.instIsTransSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsTrans (Set α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsTrans (Set α) (· ⊆ ·) :=\n  show IsTrans (Set α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Set.instIsAntisymmSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsAntisymm (Set α) fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsAntisymm (Set α) (· ⊆ ·) :=\n  show IsAntisymm (Set α) (· ≤ ·) by infer_instance\n\n"}
{"name":"Set.instIsIrreflSSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsIrrefl (Set α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsIrrefl (Set α) (· ⊂ ·) :=\n  show IsIrrefl (Set α) (· < ·) by infer_instance\n\n"}
{"name":"Set.instIsTransSSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsTrans (Set α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsTrans (Set α) (· ⊂ ·) :=\n  show IsTrans (Set α) (· < ·) by infer_instance\n\n"}
{"name":"Set.instIsAsymmSSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsAsymm (Set α) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsAsymm (Set α) (· ⊂ ·) :=\n  show IsAsymm (Set α) (· < ·) by infer_instance\n\n"}
{"name":"Set.instIsNonstrictStrictOrderSubsetSSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsNonstrictStrictOrder (Set α) (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance : IsNonstrictStrictOrder (Set α) (· ⊆ ·) (· ⊂ ·) :=\n  ⟨fun _ _ => Iff.rfl⟩\n\n-- TODO(Jeremy): write a tactic to unfold specific instances of generic notation?\n"}
{"name":"Set.subset_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (HasSubset.Subset s t) (∀ (x : α), Membership.mem s x → Membership.mem t x)","decl":"theorem subset_def : (s ⊆ t) = ∀ x, x ∈ s → x ∈ t :=\n  rfl\n\n"}
{"name":"Set.ssubset_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (HasSSubset.SSubset s t) (And (HasSubset.Subset s t) (Not (HasSubset.Subset t s)))","decl":"theorem ssubset_def : (s ⊂ t) = (s ⊆ t ∧ ¬t ⊆ s) :=\n  rfl\n\n"}
{"name":"Set.Subset.refl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ HasSubset.Subset a a","decl":"@[refl]\ntheorem Subset.refl (a : Set α) : a ⊆ a := fun _ => id\n\n"}
{"name":"Set.Subset.rfl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ HasSubset.Subset s s","decl":"theorem Subset.rfl {s : Set α} : s ⊆ s :=\n  Subset.refl s\n\n"}
{"name":"Set.Subset.trans","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b c : Set α\nab : HasSubset.Subset a b\nbc : HasSubset.Subset b c\n⊢ HasSubset.Subset a c","decl":"@[trans]\ntheorem Subset.trans {a b c : Set α} (ab : a ⊆ b) (bc : b ⊆ c) : a ⊆ c := fun _ h => bc <| ab h\n\n"}
{"name":"Set.mem_of_eq_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y : α\ns : Set α\nhx : Eq x y\nh : Membership.mem s y\n⊢ Membership.mem s x","decl":"@[trans]\ntheorem mem_of_eq_of_mem {x y : α} {s : Set α} (hx : x = y) (h : y ∈ s) : x ∈ s :=\n  hx.symm ▸ h\n\n"}
{"name":"Set.Subset.antisymm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\nh₁ : HasSubset.Subset a b\nh₂ : HasSubset.Subset b a\n⊢ Eq a b","decl":"theorem Subset.antisymm {a b : Set α} (h₁ : a ⊆ b) (h₂ : b ⊆ a) : a = b :=\n  Set.ext fun _ => ⟨@h₁ _, @h₂ _⟩\n\n"}
{"name":"Set.Subset.antisymm_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\n⊢ Iff (Eq a b) (And (HasSubset.Subset a b) (HasSubset.Subset b a))","decl":"theorem Subset.antisymm_iff {a b : Set α} : a = b ↔ a ⊆ b ∧ b ⊆ a :=\n  ⟨fun e => ⟨e.subset, e.symm.subset⟩, fun ⟨h₁, h₂⟩ => Subset.antisymm h₁ h₂⟩\n\n-- an alternative name\n"}
{"name":"Set.eq_of_subset_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b a\n⊢ Eq a b","decl":"theorem eq_of_subset_of_subset {a b : Set α} : a ⊆ b → b ⊆ a → a = b :=\n  Subset.antisymm\n\n"}
{"name":"Set.mem_of_subset_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ : Set α\na : α\nh : HasSubset.Subset s₁ s₂\na✝ : Membership.mem s₁ a\n⊢ Membership.mem s₂ a","decl":"theorem mem_of_subset_of_mem {s₁ s₂ : Set α} {a : α} (h : s₁ ⊆ s₂) : a ∈ s₁ → a ∈ s₂ :=\n  @h _\n\n"}
{"name":"Set.not_mem_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : HasSubset.Subset s t\na✝ : Not (Membership.mem t a)\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_subset (h : s ⊆ t) : a ∉ t → a ∉ s :=\n  mt <| mem_of_subset_of_mem h\n\n"}
{"name":"Set.not_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Not (HasSubset.Subset s t)) (Exists fun a => And (Membership.mem s a) (Not (Membership.mem t a)))","decl":"theorem not_subset : ¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t := by\n  simp only [subset_def, not_forall, exists_prop]\n\n"}
{"name":"Set.eq_of_forall_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : ∀ (u : Set α), Iff (HasSubset.Subset s u) (HasSubset.Subset t u)\n⊢ Eq s t","decl":"lemma eq_of_forall_subset_iff (h : ∀ u, s ⊆ u ↔ t ⊆ u) : s = t := eq_of_forall_ge_iff h\n\n"}
{"name":"Set.eq_or_ssubset_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Or (Eq s t) (HasSSubset.SSubset s t)","decl":"protected theorem eq_or_ssubset_of_subset (h : s ⊆ t) : s = t ∨ s ⊂ t :=\n  eq_or_lt_of_le h\n\n"}
{"name":"Set.exists_of_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSSubset.SSubset s t\n⊢ Exists fun x => And (Membership.mem t x) (Not (Membership.mem s x))","decl":"theorem exists_of_ssubset {s t : Set α} (h : s ⊂ t) : ∃ x ∈ t, x ∉ s :=\n  not_subset.1 h.2\n\n"}
{"name":"Set.ssubset_iff_subset_ne","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSSubset.SSubset s t) (And (HasSubset.Subset s t) (Ne s t))","decl":"protected theorem ssubset_iff_subset_ne {s t : Set α} : s ⊂ t ↔ s ⊆ t ∧ s ≠ t :=\n  @lt_iff_le_and_ne (Set α) _ s t\n\n"}
{"name":"Set.ssubset_iff_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun x => And (Membership.mem t x) (Not (Membership.mem s x)))","decl":"theorem ssubset_iff_of_subset {s t : Set α} (h : s ⊆ t) : s ⊂ t ↔ ∃ x ∈ t, x ∉ s :=\n  ⟨exists_of_ssubset, fun ⟨_, hxt, hxs⟩ => ⟨h, fun h => hxs <| h hxt⟩⟩\n\n"}
{"name":"Set.ssubset_of_ssubset_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\nhs₁s₂ : HasSSubset.SSubset s₁ s₂\nhs₂s₃ : HasSubset.Subset s₂ s₃\n⊢ HasSSubset.SSubset s₁ s₃","decl":"protected theorem ssubset_of_ssubset_of_subset {s₁ s₂ s₃ : Set α} (hs₁s₂ : s₁ ⊂ s₂)\n    (hs₂s₃ : s₂ ⊆ s₃) : s₁ ⊂ s₃ :=\n  ⟨Subset.trans hs₁s₂.1 hs₂s₃, fun hs₃s₁ => hs₁s₂.2 (Subset.trans hs₂s₃ hs₃s₁)⟩\n\n"}
{"name":"Set.ssubset_of_subset_of_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\nhs₁s₂ : HasSubset.Subset s₁ s₂\nhs₂s₃ : HasSSubset.SSubset s₂ s₃\n⊢ HasSSubset.SSubset s₁ s₃","decl":"protected theorem ssubset_of_subset_of_ssubset {s₁ s₂ s₃ : Set α} (hs₁s₂ : s₁ ⊆ s₂)\n    (hs₂s₃ : s₂ ⊂ s₃) : s₁ ⊂ s₃ :=\n  ⟨Subset.trans hs₁s₂ hs₂s₃.1, fun hs₃s₁ => hs₂s₃.2 (Subset.trans hs₃s₁ hs₁s₂)⟩\n\n"}
{"name":"Set.not_mem_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\n⊢ Not (Membership.mem EmptyCollection.emptyCollection x)","decl":"theorem not_mem_empty (x : α) : ¬x ∈ (∅ : Set α) :=\n  id\n\n"}
{"name":"Set.not_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Not (Not (Membership.mem s a))) (Membership.mem s a)","decl":"theorem not_not_mem : ¬a ∉ s ↔ a ∈ s :=\n  not_not\n\n"}
{"name":"Set.nonempty_coe_sort","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Nonempty ↑s) s.Nonempty","decl":"theorem nonempty_coe_sort {s : Set α} : Nonempty (↥s) ↔ s.Nonempty :=\n  nonempty_subtype\n\n"}
{"name":"Set.Nonempty.coe_sort","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Nonempty ↑s","decl":"alias ⟨_, Nonempty.coe_sort⟩ := nonempty_coe_sort\n\n"}
{"name":"Set.nonempty_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Nonempty (Exists fun x => Membership.mem s x)","decl":"theorem nonempty_def : s.Nonempty ↔ ∃ x, x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Set.nonempty_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\nh : Membership.mem s x\n⊢ s.Nonempty","decl":"theorem nonempty_of_mem {x} (h : x ∈ s) : s.Nonempty :=\n  ⟨x, h⟩\n\n"}
{"name":"Set.Nonempty.not_subset_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Not (HasSubset.Subset s EmptyCollection.emptyCollection)","decl":"theorem Nonempty.not_subset_empty : s.Nonempty → ¬s ⊆ ∅\n  | ⟨_, hx⟩, hs => hs hx\n\n"}
{"name":"Set.Nonempty.some_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Nonempty\n⊢ Membership.mem s h.some","decl":"protected theorem Nonempty.some_mem (h : s.Nonempty) : h.some ∈ s :=\n  Classical.choose_spec h\n\n"}
{"name":"Set.Nonempty.mono","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nht : HasSubset.Subset s t\nhs : s.Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.mono (ht : s ⊆ t) (hs : s.Nonempty) : t.Nonempty :=\n  hs.imp ht\n\n"}
{"name":"Set.nonempty_of_not_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : Not (HasSubset.Subset s t)\n⊢ (SDiff.sdiff s t).Nonempty","decl":"theorem nonempty_of_not_subset (h : ¬s ⊆ t) : (s \\ t).Nonempty :=\n  let ⟨x, xs, xt⟩ := not_subset.1 h\n  ⟨x, xs, xt⟩\n\n"}
{"name":"Set.nonempty_of_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nht : HasSSubset.SSubset s t\n⊢ (SDiff.sdiff t s).Nonempty","decl":"theorem nonempty_of_ssubset (ht : s ⊂ t) : (t \\ s).Nonempty :=\n  nonempty_of_not_subset ht.2\n\n"}
{"name":"Set.Nonempty.of_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : (SDiff.sdiff s t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.of_diff (h : (s \\ t).Nonempty) : s.Nonempty :=\n  h.imp fun _ => And.left\n\n"}
{"name":"Set.nonempty_of_ssubset'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nht : HasSSubset.SSubset s t\n⊢ t.Nonempty","decl":"theorem nonempty_of_ssubset' (ht : s ⊂ t) : t.Nonempty :=\n  (nonempty_of_ssubset ht).of_diff\n\n"}
{"name":"Set.Nonempty.inl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Nonempty\n⊢ (Union.union s t).Nonempty","decl":"theorem Nonempty.inl (hs : s.Nonempty) : (s ∪ t).Nonempty :=\n  hs.imp fun _ => Or.inl\n\n"}
{"name":"Set.Nonempty.inr","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nht : t.Nonempty\n⊢ (Union.union s t).Nonempty","decl":"theorem Nonempty.inr (ht : t.Nonempty) : (s ∪ t).Nonempty :=\n  ht.imp fun _ => Or.inr\n\n"}
{"name":"Set.union_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Union.union s t).Nonempty (Or s.Nonempty t.Nonempty)","decl":"@[simp]\ntheorem union_nonempty : (s ∪ t).Nonempty ↔ s.Nonempty ∨ t.Nonempty :=\n  exists_or\n\n"}
{"name":"Set.Nonempty.left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : (Inter.inter s t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.left (h : (s ∩ t).Nonempty) : s.Nonempty :=\n  h.imp fun _ => And.left\n\n"}
{"name":"Set.Nonempty.right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : (Inter.inter s t).Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.right (h : (s ∩ t).Nonempty) : t.Nonempty :=\n  h.imp fun _ => And.right\n\n"}
{"name":"Set.inter_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Inter.inter s t).Nonempty (Exists fun x => And (Membership.mem s x) (Membership.mem t x))","decl":"theorem inter_nonempty : (s ∩ t).Nonempty ↔ ∃ x, x ∈ s ∧ x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Set.inter_nonempty_iff_exists_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Inter.inter s t).Nonempty (Exists fun x => And (Membership.mem s x) (Membership.mem t x))","decl":"theorem inter_nonempty_iff_exists_left : (s ∩ t).Nonempty ↔ ∃ x ∈ s, x ∈ t := by\n  simp_rw [inter_nonempty]\n\n"}
{"name":"Set.inter_nonempty_iff_exists_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Inter.inter s t).Nonempty (Exists fun x => And (Membership.mem t x) (Membership.mem s x))","decl":"theorem inter_nonempty_iff_exists_right : (s ∩ t).Nonempty ↔ ∃ x ∈ t, x ∈ s := by\n  simp_rw [inter_nonempty, and_comm]\n\n"}
{"name":"Set.nonempty_iff_univ_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Iff (Nonempty α) Set.univ.Nonempty","decl":"theorem nonempty_iff_univ_nonempty : Nonempty α ↔ (univ : Set α).Nonempty :=\n  ⟨fun ⟨x⟩ => ⟨x, trivial⟩, fun ⟨x, _⟩ => ⟨x⟩⟩\n\n"}
{"name":"Set.univ_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Set.univ.Nonempty","decl":"@[simp]\ntheorem univ_nonempty : ∀ [Nonempty α], (univ : Set α).Nonempty\n  | ⟨x⟩ => ⟨x, trivial⟩\n\n"}
{"name":"Set.Nonempty.to_subtype","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Nonempty ↑s","decl":"theorem Nonempty.to_subtype : s.Nonempty → Nonempty (↥s) :=\n  nonempty_subtype.2\n\n"}
{"name":"Set.Nonempty.to_type","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Nonempty α","decl":"theorem Nonempty.to_type : s.Nonempty → Nonempty α := fun ⟨x, _⟩ => ⟨x⟩\n\n"}
{"name":"Set.univ.nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nonempty ↑Set.univ","decl":"instance univ.nonempty [Nonempty α] : Nonempty (↥(Set.univ : Set α)) :=\n  Set.univ_nonempty.to_subtype\n\n-- Redeclare for refined keys\n-- `Nonempty (@Subtype _ (@Membership.mem _ (Set _) _ (@Top.top (Set _) _)))`\n"}
{"name":"Set.instNonemptyTop","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nonempty ↑Top.top","decl":"instance instNonemptyTop [Nonempty α] : Nonempty (⊤ : Set α) :=\n  inferInstanceAs (Nonempty (univ : Set α))\n\n"}
{"name":"Set.Nonempty.of_subtype","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Nonempty ↑s\n⊢ s.Nonempty","decl":"theorem Nonempty.of_subtype [Nonempty (↥s)] : s.Nonempty := nonempty_subtype.mp ‹_›\n\n"}
{"name":"Set.nonempty_of_nonempty_subtype","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Nonempty ↑s\n⊢ s.Nonempty","decl":"@[deprecated (since := \"2024-11-23\")] alias nonempty_of_nonempty_subtype := Nonempty.of_subtype\n\n"}
{"name":"Set.empty_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq EmptyCollection.emptyCollection (setOf fun _x => False)","decl":"theorem empty_def : (∅ : Set α) = { _x : α | False } :=\n  rfl\n\n"}
{"name":"Set.mem_empty_iff_false","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\n⊢ Iff (Membership.mem EmptyCollection.emptyCollection x) False","decl":"@[simp]\ntheorem mem_empty_iff_false (x : α) : x ∈ (∅ : Set α) ↔ False :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_false","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (setOf fun _a => False) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem setOf_false : { _a : α | False } = ∅ :=\n  rfl\n\n"}
{"name":"Set.setOf_bot","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (setOf fun _x => Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp] theorem setOf_bot : { _x : α | ⊥ } = ∅ := rfl\n\n"}
{"name":"Set.empty_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ HasSubset.Subset EmptyCollection.emptyCollection s","decl":"@[simp]\ntheorem empty_subset (s : Set α) : ∅ ⊆ s :=\n  nofun\n\n"}
{"name":"Set.subset_empty_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (HasSubset.Subset s EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem subset_empty_iff {s : Set α} : s ⊆ ∅ ↔ s = ∅ :=\n  (Subset.antisymm_iff.trans <| and_iff_left (empty_subset _)).symm\n\n"}
{"name":"Set.eq_empty_iff_forall_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq s EmptyCollection.emptyCollection) (∀ (x : α), Not (Membership.mem s x))","decl":"theorem eq_empty_iff_forall_not_mem {s : Set α} : s = ∅ ↔ ∀ x, x ∉ s :=\n  subset_empty_iff.symm\n\n"}
{"name":"Set.eq_empty_of_forall_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nh : ∀ (x : α), Not (Membership.mem s x)\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_forall_not_mem (h : ∀ x, x ∉ s) : s = ∅ :=\n  subset_empty_iff.1 h\n\n"}
{"name":"Set.eq_empty_of_subset_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : HasSubset.Subset s EmptyCollection.emptyCollection\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_subset_empty {s : Set α} : s ⊆ ∅ → s = ∅ :=\n  subset_empty_iff.1\n\n"}
{"name":"Set.eq_empty_of_isEmpty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : IsEmpty α\ns : Set α\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_isEmpty [IsEmpty α] (s : Set α) : s = ∅ :=\n  eq_empty_of_subset_empty fun x _ => isEmptyElim x\n\n"}
{"name":"Set.not_nonempty_iff_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not s.Nonempty) (Eq s EmptyCollection.emptyCollection)","decl":"/-- See also `Set.nonempty_iff_ne_empty`. -/\ntheorem not_nonempty_iff_eq_empty {s : Set α} : ¬s.Nonempty ↔ s = ∅ := by\n  simp only [Set.Nonempty, not_exists, eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Set.nonempty_iff_ne_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Nonempty (Ne s EmptyCollection.emptyCollection)","decl":"/-- See also `Set.not_nonempty_iff_eq_empty`. -/\ntheorem nonempty_iff_ne_empty : s.Nonempty ↔ s ≠ ∅ :=\n  not_nonempty_iff_eq_empty.not_right\n\n"}
{"name":"Set.not_nonempty_iff_eq_empty'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not (Nonempty ↑s)) (Eq s EmptyCollection.emptyCollection)","decl":"/-- See also `nonempty_iff_ne_empty'`. -/\ntheorem not_nonempty_iff_eq_empty' : ¬Nonempty s ↔ s = ∅ := by\n  rw [nonempty_subtype, not_exists, eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Set.nonempty_iff_ne_empty'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Nonempty ↑s) (Ne s EmptyCollection.emptyCollection)","decl":"/-- See also `not_nonempty_iff_eq_empty'`. -/\ntheorem nonempty_iff_ne_empty' : Nonempty s ↔ s ≠ ∅ :=\n  not_nonempty_iff_eq_empty'.not_right\n\n"}
{"name":"Set.Nonempty.ne_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Ne s EmptyCollection.emptyCollection","decl":"alias ⟨Nonempty.ne_empty, _⟩ := nonempty_iff_ne_empty\n\n"}
{"name":"Set.not_nonempty_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Not EmptyCollection.emptyCollection.Nonempty","decl":"@[simp]\ntheorem not_nonempty_empty : ¬(∅ : Set α).Nonempty := fun ⟨_, hx⟩ => hx\n\n"}
{"name":"Set.isEmpty_coe_sort","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (IsEmpty ↑s) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem isEmpty_coe_sort {s : Set α} : IsEmpty (↥s) ↔ s = ∅ :=\n  not_iff_not.1 <| by simpa using nonempty_iff_ne_empty\n\n"}
{"name":"Set.eq_empty_or_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Or (Eq s EmptyCollection.emptyCollection) s.Nonempty","decl":"theorem eq_empty_or_nonempty (s : Set α) : s = ∅ ∨ s.Nonempty :=\n  or_iff_not_imp_left.2 nonempty_iff_ne_empty.2\n\n"}
{"name":"Set.subset_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset t s\ne : Eq s EmptyCollection.emptyCollection\n⊢ Eq t EmptyCollection.emptyCollection","decl":"theorem subset_eq_empty {s t : Set α} (h : t ⊆ s) (e : s = ∅) : t = ∅ :=\n  subset_empty_iff.1 <| e ▸ h\n\n"}
{"name":"Set.forall_mem_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem EmptyCollection.emptyCollection x → p x) True","decl":"theorem forall_mem_empty {p : α → Prop} : (∀ x ∈ (∅ : Set α), p x) ↔ True :=\n  iff_true_intro fun _ => False.elim\n\n"}
{"name":"Set.instIsEmptyElemEmptyCollection","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ IsEmpty ↑EmptyCollection.emptyCollection","decl":"instance (α : Type u) : IsEmpty.{u + 1} (↥(∅ : Set α)) :=\n  ⟨fun x => x.2⟩\n\n"}
{"name":"Set.empty_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (HasSSubset.SSubset EmptyCollection.emptyCollection s) s.Nonempty","decl":"@[simp]\ntheorem empty_ssubset : ∅ ⊂ s ↔ s.Nonempty :=\n  (@bot_lt_iff_ne_bot (Set α) _ _ _).trans nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.Nonempty.empty_ssubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ HasSSubset.SSubset EmptyCollection.emptyCollection s","decl":"alias ⟨_, Nonempty.empty_ssubset⟩ := empty_ssubset\n\n"}
{"name":"Set.setOf_true","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (setOf fun _x => True) Set.univ","decl":"@[simp]\ntheorem setOf_true : { _x : α | True } = univ :=\n  rfl\n\n"}
{"name":"Set.setOf_top","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (setOf fun _x => Top.top) Set.univ","decl":"@[simp] theorem setOf_top : { _x : α | ⊤ } = univ := rfl\n\n"}
{"name":"Set.univ_eq_empty_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Iff (Eq Set.univ EmptyCollection.emptyCollection) (IsEmpty α)","decl":"@[simp]\ntheorem univ_eq_empty_iff : (univ : Set α) = ∅ ↔ IsEmpty α :=\n  eq_empty_iff_forall_not_mem.trans\n    ⟨fun H => ⟨fun x => H x trivial⟩, fun H x _ => @IsEmpty.false α H x⟩\n\n"}
{"name":"Set.empty_ne_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Ne EmptyCollection.emptyCollection Set.univ","decl":"theorem empty_ne_univ [Nonempty α] : (∅ : Set α) ≠ univ := fun e =>\n  not_isEmpty_of_nonempty α <| univ_eq_empty_iff.1 e.symm\n\n"}
{"name":"Set.subset_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ HasSubset.Subset s Set.univ","decl":"@[simp]\ntheorem subset_univ (s : Set α) : s ⊆ univ := fun _ _ => trivial\n\n"}
{"name":"Set.univ_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (HasSubset.Subset Set.univ s) (Eq s Set.univ)","decl":"@[simp]\ntheorem univ_subset_iff {s : Set α} : univ ⊆ s ↔ s = univ :=\n  @top_le_iff _ _ _ s\n\n"}
{"name":"Set.eq_univ_of_univ_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : HasSubset.Subset Set.univ s\n⊢ Eq s Set.univ","decl":"alias ⟨eq_univ_of_univ_subset, _⟩ := univ_subset_iff\n\n"}
{"name":"Set.eq_univ_iff_forall","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq s Set.univ) (∀ (x : α), Membership.mem s x)","decl":"theorem eq_univ_iff_forall {s : Set α} : s = univ ↔ ∀ x, x ∈ s :=\n  univ_subset_iff.symm.trans <| forall_congr' fun _ => imp_iff_right trivial\n\n"}
{"name":"Set.eq_univ_of_forall","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : ∀ (x : α), Membership.mem s x\n⊢ Eq s Set.univ","decl":"theorem eq_univ_of_forall {s : Set α} : (∀ x, x ∈ s) → s = univ :=\n  eq_univ_iff_forall.2\n\n"}
{"name":"Set.Nonempty.eq_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Subsingleton α\na✝ : s.Nonempty\n⊢ Eq s Set.univ","decl":"theorem Nonempty.eq_univ [Subsingleton α] : s.Nonempty → s = univ := by\n  rintro ⟨x, hx⟩\n  exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]\n\n"}
{"name":"Set.eq_univ_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\nhs : Eq s Set.univ\n⊢ Eq t Set.univ","decl":"theorem eq_univ_of_subset {s t : Set α} (h : s ⊆ t) (hs : s = univ) : t = univ :=\n  eq_univ_of_univ_subset <| (hs ▸ h : univ ⊆ t)\n\n"}
{"name":"Set.exists_mem_of_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Exists fun x => Membership.mem Set.univ x","decl":"theorem exists_mem_of_nonempty (α) : ∀ [Nonempty α], ∃ x : α, x ∈ (univ : Set α)\n  | ⟨x⟩ => ⟨x, trivial⟩\n\n"}
{"name":"Set.ne_univ_iff_exists_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Ne s Set.univ) (Exists fun a => Not (Membership.mem s a))","decl":"theorem ne_univ_iff_exists_not_mem {α : Type*} (s : Set α) : s ≠ univ ↔ ∃ a, a ∉ s := by\n  rw [← not_forall, ← eq_univ_iff_forall]\n\n"}
{"name":"Set.not_subset_iff_exists_mem_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (Not (HasSubset.Subset s t)) (Exists fun x => And (Membership.mem s x) (Not (Membership.mem t x)))","decl":"theorem not_subset_iff_exists_mem_not_mem {α : Type*} {s t : Set α} :\n    ¬s ⊆ t ↔ ∃ x, x ∈ s ∧ x ∉ t := by simp [subset_def]\n\n"}
{"name":"Set.univ_unique","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Unique α\n⊢ Eq Set.univ (Singleton.singleton Inhabited.default)","decl":"theorem univ_unique [Unique α] : @Set.univ α = {default} :=\n  Set.ext fun x => iff_of_true trivial <| Subsingleton.elim x default\n\n"}
{"name":"Set.ssubset_univ_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (HasSSubset.SSubset s Set.univ) (Ne s Set.univ)","decl":"theorem ssubset_univ_iff : s ⊂ univ ↔ s ≠ univ :=\n  lt_top_iff_ne_top\n\n"}
{"name":"Set.nontrivial_of_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nontrivial (Set α)","decl":"instance nontrivial_of_nonempty [Nonempty α] : Nontrivial (Set α) :=\n  ⟨⟨∅, univ, empty_ne_univ⟩⟩\n\n"}
{"name":"Set.union_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ : Set α\n⊢ Eq (Union.union s₁ s₂) (setOf fun a => Or (Membership.mem s₁ a) (Membership.mem s₂ a))","decl":"theorem union_def {s₁ s₂ : Set α} : s₁ ∪ s₂ = { a | a ∈ s₁ ∨ a ∈ s₂ } :=\n  rfl\n\n"}
{"name":"Set.mem_union_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\na✝ : Membership.mem a x\n⊢ Membership.mem (Union.union a b) x","decl":"theorem mem_union_left {x : α} {a : Set α} (b : Set α) : x ∈ a → x ∈ a ∪ b :=\n  Or.inl\n\n"}
{"name":"Set.mem_union_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\nb a : Set α\na✝ : Membership.mem b x\n⊢ Membership.mem (Union.union a b) x","decl":"theorem mem_union_right {x : α} {b : Set α} (a : Set α) : x ∈ b → x ∈ a ∪ b :=\n  Or.inr\n\n"}
{"name":"Set.mem_or_mem_of_mem_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\nH : Membership.mem (Union.union a b) x\n⊢ Or (Membership.mem a x) (Membership.mem b x)","decl":"theorem mem_or_mem_of_mem_union {x : α} {a b : Set α} (H : x ∈ a ∪ b) : x ∈ a ∨ x ∈ b :=\n  H\n\n"}
{"name":"Set.MemUnion.elim","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\nP : Prop\nH₁ : Membership.mem (Union.union a b) x\nH₂ : Membership.mem a x → P\nH₃ : Membership.mem b x → P\n⊢ P","decl":"theorem MemUnion.elim {x : α} {a b : Set α} {P : Prop} (H₁ : x ∈ a ∪ b) (H₂ : x ∈ a → P)\n    (H₃ : x ∈ b → P) : P :=\n  Or.elim H₁ H₂ H₃\n\n"}
{"name":"Set.mem_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\n⊢ Iff (Membership.mem (Union.union a b) x) (Or (Membership.mem a x) (Membership.mem b x))","decl":"@[simp]\ntheorem mem_union (x : α) (a b : Set α) : x ∈ a ∪ b ↔ x ∈ a ∨ x ∈ b :=\n  Iff.rfl\n\n"}
{"name":"Set.union_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Union.union a a) a","decl":"@[simp]\ntheorem union_self (a : Set α) : a ∪ a = a :=\n  ext fun _ => or_self_iff\n\n"}
{"name":"Set.union_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Union.union a EmptyCollection.emptyCollection) a","decl":"@[simp]\ntheorem union_empty (a : Set α) : a ∪ ∅ = a :=\n  ext fun _ => iff_of_eq (or_false _)\n\n"}
{"name":"Set.empty_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Union.union EmptyCollection.emptyCollection a) a","decl":"@[simp]\ntheorem empty_union (a : Set α) : ∅ ∪ a = a :=\n  ext fun _ => iff_of_eq (false_or _)\n\n"}
{"name":"Set.union_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\n⊢ Eq (Union.union a b) (Union.union b a)","decl":"theorem union_comm (a b : Set α) : a ∪ b = b ∪ a :=\n  ext fun _ => or_comm\n\n"}
{"name":"Set.union_assoc","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b c : Set α\n⊢ Eq (Union.union (Union.union a b) c) (Union.union a (Union.union b c))","decl":"theorem union_assoc (a b c : Set α) : a ∪ b ∪ c = a ∪ (b ∪ c) :=\n  ext fun _ => or_assoc\n\n"}
{"name":"Set.union_isAssoc","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Std.Associative fun x1 x2 => Union.union x1 x2","decl":"instance union_isAssoc : Std.Associative (α := Set α) (· ∪ ·) :=\n  ⟨union_assoc⟩\n\n"}
{"name":"Set.union_isComm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Std.Commutative fun x1 x2 => Union.union x1 x2","decl":"instance union_isComm : Std.Commutative (α := Set α) (· ∪ ·) :=\n  ⟨union_comm⟩\n\n"}
{"name":"Set.union_left_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\n⊢ Eq (Union.union s₁ (Union.union s₂ s₃)) (Union.union s₂ (Union.union s₁ s₃))","decl":"theorem union_left_comm (s₁ s₂ s₃ : Set α) : s₁ ∪ (s₂ ∪ s₃) = s₂ ∪ (s₁ ∪ s₃) :=\n  ext fun _ => or_left_comm\n\n"}
{"name":"Set.union_right_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\n⊢ Eq (Union.union (Union.union s₁ s₂) s₃) (Union.union (Union.union s₁ s₃) s₂)","decl":"theorem union_right_comm (s₁ s₂ s₃ : Set α) : s₁ ∪ s₂ ∪ s₃ = s₁ ∪ s₃ ∪ s₂ :=\n  ext fun _ => or_right_comm\n\n"}
{"name":"Set.union_eq_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Union.union s t) s) (HasSubset.Subset t s)","decl":"@[simp]\ntheorem union_eq_left {s t : Set α} : s ∪ t = s ↔ t ⊆ s :=\n  sup_eq_left\n\n"}
{"name":"Set.union_eq_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Union.union s t) t) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem union_eq_right {s t : Set α} : s ∪ t = t ↔ s ⊆ t :=\n  sup_eq_right\n\n"}
{"name":"Set.union_eq_self_of_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (Union.union s t) t","decl":"theorem union_eq_self_of_subset_left {s t : Set α} (h : s ⊆ t) : s ∪ t = t :=\n  union_eq_right.mpr h\n\n"}
{"name":"Set.union_eq_self_of_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset t s\n⊢ Eq (Union.union s t) s","decl":"theorem union_eq_self_of_subset_right {s t : Set α} (h : t ⊆ s) : s ∪ t = s :=\n  union_eq_left.mpr h\n\n"}
{"name":"Set.subset_union_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset s (Union.union s t)","decl":"@[simp]\ntheorem subset_union_left {s t : Set α} : s ⊆ s ∪ t := fun _ => Or.inl\n\n"}
{"name":"Set.subset_union_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset t (Union.union s t)","decl":"@[simp]\ntheorem subset_union_right {s t : Set α} : t ⊆ s ∪ t := fun _ => Or.inr\n\n"}
{"name":"Set.union_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t r : Set α\nsr : HasSubset.Subset s r\ntr : HasSubset.Subset t r\n⊢ HasSubset.Subset (Union.union s t) r","decl":"theorem union_subset {s t r : Set α} (sr : s ⊆ r) (tr : t ⊆ r) : s ∪ t ⊆ r := fun _ =>\n  Or.rec (@sr _) (@tr _)\n\n"}
{"name":"Set.union_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (HasSubset.Subset (Union.union s t) u) (And (HasSubset.Subset s u) (HasSubset.Subset t u))","decl":"@[simp]\ntheorem union_subset_iff {s t u : Set α} : s ∪ t ⊆ u ↔ s ⊆ u ∧ t ⊆ u :=\n  (forall_congr' fun _ => or_imp).trans forall_and\n\n"}
{"name":"Set.union_subset_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t₁ t₂ : Set α\nh₁ : HasSubset.Subset s₁ s₂\nh₂ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (Union.union s₁ t₁) (Union.union s₂ t₂)","decl":"@[gcongr]\ntheorem union_subset_union {s₁ s₂ t₁ t₂ : Set α} (h₁ : s₁ ⊆ s₂) (h₂ : t₁ ⊆ t₂) :\n    s₁ ∪ t₁ ⊆ s₂ ∪ t₂ := fun _ => Or.imp (@h₁ _) (@h₂ _)\n\n"}
{"name":"Set.union_subset_union_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t : Set α\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (Union.union s₁ t) (Union.union s₂ t)","decl":"@[gcongr]\ntheorem union_subset_union_left {s₁ s₂ : Set α} (t) (h : s₁ ⊆ s₂) : s₁ ∪ t ⊆ s₂ ∪ t :=\n  union_subset_union h Subset.rfl\n\n"}
{"name":"Set.union_subset_union_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t₁ t₂ : Set α\nh : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (Union.union s t₁) (Union.union s t₂)","decl":"@[gcongr]\ntheorem union_subset_union_right (s) {t₁ t₂ : Set α} (h : t₁ ⊆ t₂) : s ∪ t₁ ⊆ s ∪ t₂ :=\n  union_subset_union Subset.rfl h\n\n"}
{"name":"Set.subset_union_of_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\nu : Set α\n⊢ HasSubset.Subset s (Union.union t u)","decl":"theorem subset_union_of_subset_left {s t : Set α} (h : s ⊆ t) (u : Set α) : s ⊆ t ∪ u :=\n  h.trans subset_union_left\n\n"}
{"name":"Set.subset_union_of_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns u : Set α\nh : HasSubset.Subset s u\nt : Set α\n⊢ HasSubset.Subset s (Union.union t u)","decl":"theorem subset_union_of_subset_right {s u : Set α} (h : s ⊆ u) (t : Set α) : s ⊆ t ∪ u :=\n  h.trans subset_union_right\n\n-- Porting note: replaced `⊔` in RHS\n"}
{"name":"Set.union_congr_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nht : HasSubset.Subset t (Union.union s u)\nhu : HasSubset.Subset u (Union.union s t)\n⊢ Eq (Union.union s t) (Union.union s u)","decl":"theorem union_congr_left (ht : t ⊆ s ∪ u) (hu : u ⊆ s ∪ t) : s ∪ t = s ∪ u :=\n  sup_congr_left ht hu\n\n"}
{"name":"Set.union_congr_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nhs : HasSubset.Subset s (Union.union t u)\nht : HasSubset.Subset t (Union.union s u)\n⊢ Eq (Union.union s u) (Union.union t u)","decl":"theorem union_congr_right (hs : s ⊆ t ∪ u) (ht : t ⊆ s ∪ u) : s ∪ u = t ∪ u :=\n  sup_congr_right hs ht\n\n"}
{"name":"Set.union_eq_union_iff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Eq (Union.union s t) (Union.union s u)) (And (HasSubset.Subset t (Union.union s u)) (HasSubset.Subset u (Union.union s t)))","decl":"theorem union_eq_union_iff_left : s ∪ t = s ∪ u ↔ t ⊆ s ∪ u ∧ u ⊆ s ∪ t :=\n  sup_eq_sup_iff_left\n\n"}
{"name":"Set.union_eq_union_iff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Eq (Union.union s u) (Union.union t u)) (And (HasSubset.Subset s (Union.union t u)) (HasSubset.Subset t (Union.union s u)))","decl":"theorem union_eq_union_iff_right : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u ∧ t ⊆ s ∪ u :=\n  sup_eq_sup_iff_right\n\n"}
{"name":"Set.union_empty_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Union.union s t) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem union_empty_iff {s t : Set α} : s ∪ t = ∅ ↔ s = ∅ ∧ t = ∅ := by\n  simp only [← subset_empty_iff]\n  exact union_subset_iff\n\n"}
{"name":"Set.union_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Union.union s Set.univ) Set.univ","decl":"@[simp]\ntheorem union_univ (s : Set α) : s ∪ univ = univ := sup_top_eq _\n\n"}
{"name":"Set.univ_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Union.union Set.univ s) Set.univ","decl":"@[simp]\ntheorem univ_union (s : Set α) : univ ∪ s = univ := top_sup_eq _\n\n"}
{"name":"Set.inter_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ : Set α\n⊢ Eq (Inter.inter s₁ s₂) (setOf fun a => And (Membership.mem s₁ a) (Membership.mem s₂ a))","decl":"theorem inter_def {s₁ s₂ : Set α} : s₁ ∩ s₂ = { a | a ∈ s₁ ∧ a ∈ s₂ } :=\n  rfl\n\n"}
{"name":"Set.mem_inter_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\n⊢ Iff (Membership.mem (Inter.inter a b) x) (And (Membership.mem a x) (Membership.mem b x))","decl":"@[simp, mfld_simps]\ntheorem mem_inter_iff (x : α) (a b : Set α) : x ∈ a ∩ b ↔ x ∈ a ∧ x ∈ b :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\nha : Membership.mem a x\nhb : Membership.mem b x\n⊢ Membership.mem (Inter.inter a b) x","decl":"theorem mem_inter {x : α} {a b : Set α} (ha : x ∈ a) (hb : x ∈ b) : x ∈ a ∩ b :=\n  ⟨ha, hb⟩\n\n"}
{"name":"Set.mem_of_mem_inter_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\nh : Membership.mem (Inter.inter a b) x\n⊢ Membership.mem a x","decl":"theorem mem_of_mem_inter_left {x : α} {a b : Set α} (h : x ∈ a ∩ b) : x ∈ a :=\n  h.left\n\n"}
{"name":"Set.mem_of_mem_inter_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\na b : Set α\nh : Membership.mem (Inter.inter a b) x\n⊢ Membership.mem b x","decl":"theorem mem_of_mem_inter_right {x : α} {a b : Set α} (h : x ∈ a ∩ b) : x ∈ b :=\n  h.right\n\n"}
{"name":"Set.inter_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Inter.inter a a) a","decl":"@[simp]\ntheorem inter_self (a : Set α) : a ∩ a = a :=\n  ext fun _ => and_self_iff\n\n"}
{"name":"Set.inter_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Inter.inter a EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_empty (a : Set α) : a ∩ ∅ = ∅ :=\n  ext fun _ => iff_of_eq (and_false _)\n\n"}
{"name":"Set.empty_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Inter.inter EmptyCollection.emptyCollection a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_inter (a : Set α) : ∅ ∩ a = ∅ :=\n  ext fun _ => iff_of_eq (false_and _)\n\n"}
{"name":"Set.inter_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\n⊢ Eq (Inter.inter a b) (Inter.inter b a)","decl":"theorem inter_comm (a b : Set α) : a ∩ b = b ∩ a :=\n  ext fun _ => and_comm\n\n"}
{"name":"Set.inter_assoc","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b c : Set α\n⊢ Eq (Inter.inter (Inter.inter a b) c) (Inter.inter a (Inter.inter b c))","decl":"theorem inter_assoc (a b c : Set α) : a ∩ b ∩ c = a ∩ (b ∩ c) :=\n  ext fun _ => and_assoc\n\n"}
{"name":"Set.inter_isAssoc","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Std.Associative fun x1 x2 => Inter.inter x1 x2","decl":"instance inter_isAssoc : Std.Associative (α := Set α) (· ∩ ·) :=\n  ⟨inter_assoc⟩\n\n"}
{"name":"Set.inter_isComm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Std.Commutative fun x1 x2 => Inter.inter x1 x2","decl":"instance inter_isComm : Std.Commutative (α := Set α) (· ∩ ·) :=\n  ⟨inter_comm⟩\n\n"}
{"name":"Set.inter_left_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\n⊢ Eq (Inter.inter s₁ (Inter.inter s₂ s₃)) (Inter.inter s₂ (Inter.inter s₁ s₃))","decl":"theorem inter_left_comm (s₁ s₂ s₃ : Set α) : s₁ ∩ (s₂ ∩ s₃) = s₂ ∩ (s₁ ∩ s₃) :=\n  ext fun _ => and_left_comm\n\n"}
{"name":"Set.inter_right_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ s₃ : Set α\n⊢ Eq (Inter.inter (Inter.inter s₁ s₂) s₃) (Inter.inter (Inter.inter s₁ s₃) s₂)","decl":"theorem inter_right_comm (s₁ s₂ s₃ : Set α) : s₁ ∩ s₂ ∩ s₃ = s₁ ∩ s₃ ∩ s₂ :=\n  ext fun _ => and_right_comm\n\n"}
{"name":"Set.inter_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset (Inter.inter s t) s","decl":"@[simp, mfld_simps]\ntheorem inter_subset_left {s t : Set α} : s ∩ t ⊆ s := fun _ => And.left\n\n"}
{"name":"Set.inter_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset (Inter.inter s t) t","decl":"@[simp]\ntheorem inter_subset_right {s t : Set α} : s ∩ t ⊆ t := fun _ => And.right\n\n"}
{"name":"Set.subset_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t r : Set α\nrs : HasSubset.Subset r s\nrt : HasSubset.Subset r t\n⊢ HasSubset.Subset r (Inter.inter s t)","decl":"theorem subset_inter {s t r : Set α} (rs : r ⊆ s) (rt : r ⊆ t) : r ⊆ s ∩ t := fun _ h =>\n  ⟨rs h, rt h⟩\n\n"}
{"name":"Set.subset_inter_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t r : Set α\n⊢ Iff (HasSubset.Subset r (Inter.inter s t)) (And (HasSubset.Subset r s) (HasSubset.Subset r t))","decl":"@[simp]\ntheorem subset_inter_iff {s t r : Set α} : r ⊆ s ∩ t ↔ r ⊆ s ∧ r ⊆ t :=\n  (forall_congr' fun _ => imp_and).trans forall_and\n\n"}
{"name":"Set.inter_eq_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Inter.inter s t) s) (HasSubset.Subset s t)","decl":"@[simp] lemma inter_eq_left : s ∩ t = s ↔ s ⊆ t := inf_eq_left\n\n"}
{"name":"Set.inter_eq_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Inter.inter s t) t) (HasSubset.Subset t s)","decl":"@[simp] lemma inter_eq_right : s ∩ t = t ↔ t ⊆ s := inf_eq_right\n\n"}
{"name":"Set.left_eq_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq s (Inter.inter s t)) (HasSubset.Subset s t)","decl":"@[simp] lemma left_eq_inter : s = s ∩ t ↔ s ⊆ t := left_eq_inf\n\n"}
{"name":"Set.right_eq_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq t (Inter.inter s t)) (HasSubset.Subset t s)","decl":"@[simp] lemma right_eq_inter : t = s ∩ t ↔ t ⊆ s := right_eq_inf\n\n"}
{"name":"Set.inter_eq_self_of_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset s t\n⊢ Eq (Inter.inter s t) s","decl":"theorem inter_eq_self_of_subset_left {s t : Set α} : s ⊆ t → s ∩ t = s :=\n  inter_eq_left.mpr\n\n"}
{"name":"Set.inter_eq_self_of_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset t s\n⊢ Eq (Inter.inter s t) t","decl":"theorem inter_eq_self_of_subset_right {s t : Set α} : t ⊆ s → s ∩ t = t :=\n  inter_eq_right.mpr\n\n"}
{"name":"Set.inter_congr_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nht : HasSubset.Subset (Inter.inter s u) t\nhu : HasSubset.Subset (Inter.inter s t) u\n⊢ Eq (Inter.inter s t) (Inter.inter s u)","decl":"theorem inter_congr_left (ht : s ∩ u ⊆ t) (hu : s ∩ t ⊆ u) : s ∩ t = s ∩ u :=\n  inf_congr_left ht hu\n\n"}
{"name":"Set.inter_congr_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nhs : HasSubset.Subset (Inter.inter t u) s\nht : HasSubset.Subset (Inter.inter s u) t\n⊢ Eq (Inter.inter s u) (Inter.inter t u)","decl":"theorem inter_congr_right (hs : t ∩ u ⊆ s) (ht : s ∩ u ⊆ t) : s ∩ u = t ∩ u :=\n  inf_congr_right hs ht\n\n"}
{"name":"Set.inter_eq_inter_iff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Eq (Inter.inter s t) (Inter.inter s u)) (And (HasSubset.Subset (Inter.inter s u) t) (HasSubset.Subset (Inter.inter s t) u))","decl":"theorem inter_eq_inter_iff_left : s ∩ t = s ∩ u ↔ s ∩ u ⊆ t ∧ s ∩ t ⊆ u :=\n  inf_eq_inf_iff_left\n\n"}
{"name":"Set.inter_eq_inter_iff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Eq (Inter.inter s u) (Inter.inter t u)) (And (HasSubset.Subset (Inter.inter t u) s) (HasSubset.Subset (Inter.inter s u) t))","decl":"theorem inter_eq_inter_iff_right : s ∩ u = t ∩ u ↔ t ∩ u ⊆ s ∧ s ∩ u ⊆ t :=\n  inf_eq_inf_iff_right\n\n"}
{"name":"Set.inter_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Inter.inter a Set.univ) a","decl":"@[simp, mfld_simps]\ntheorem inter_univ (a : Set α) : a ∩ univ = a := inf_top_eq _\n\n"}
{"name":"Set.univ_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : Set α\n⊢ Eq (Inter.inter Set.univ a) a","decl":"@[simp, mfld_simps]\ntheorem univ_inter (a : Set α) : univ ∩ a = a := top_inf_eq _\n\n"}
{"name":"Set.inter_subset_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t₁ t₂ : Set α\nh₁ : HasSubset.Subset s₁ t₁\nh₂ : HasSubset.Subset s₂ t₂\n⊢ HasSubset.Subset (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"@[gcongr]\ntheorem inter_subset_inter {s₁ s₂ t₁ t₂ : Set α} (h₁ : s₁ ⊆ t₁) (h₂ : s₂ ⊆ t₂) :\n    s₁ ∩ s₂ ⊆ t₁ ∩ t₂ := fun _ => And.imp (@h₁ _) (@h₂ _)\n\n"}
{"name":"Set.inter_subset_inter_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nH : HasSubset.Subset s t\n⊢ HasSubset.Subset (Inter.inter s u) (Inter.inter t u)","decl":"@[gcongr]\ntheorem inter_subset_inter_left {s t : Set α} (u : Set α) (H : s ⊆ t) : s ∩ u ⊆ t ∩ u :=\n  inter_subset_inter H Subset.rfl\n\n"}
{"name":"Set.inter_subset_inter_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nH : HasSubset.Subset s t\n⊢ HasSubset.Subset (Inter.inter u s) (Inter.inter u t)","decl":"@[gcongr]\ntheorem inter_subset_inter_right {s t : Set α} (u : Set α) (H : s ⊆ t) : u ∩ s ⊆ u ∩ t :=\n  inter_subset_inter Subset.rfl H\n\n"}
{"name":"Set.union_inter_cancel_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Inter.inter (Union.union s t) s) s","decl":"theorem union_inter_cancel_left {s t : Set α} : (s ∪ t) ∩ s = s :=\n  inter_eq_self_of_subset_right subset_union_left\n\n"}
{"name":"Set.union_inter_cancel_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Inter.inter (Union.union s t) t) t","decl":"theorem union_inter_cancel_right {s t : Set α} : (s ∪ t) ∩ t = t :=\n  inter_eq_self_of_subset_right subset_union_right\n\n"}
{"name":"Set.inter_setOf_eq_sep","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\n⊢ Eq (Inter.inter s (setOf fun a => p a)) (setOf fun a => And (Membership.mem s a) (p a))","decl":"theorem inter_setOf_eq_sep (s : Set α) (p : α → Prop) : s ∩ {a | p a} = {a ∈ s | p a} :=\n  rfl\n\n"}
{"name":"Set.setOf_inter_eq_sep","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\ns : Set α\n⊢ Eq (Inter.inter (setOf fun a => p a) s) (setOf fun a => And (Membership.mem s a) (p a))","decl":"theorem setOf_inter_eq_sep (p : α → Prop) (s : Set α) : {a | p a} ∩ s = {a ∈ s | p a} :=\n  inter_comm _ _\n\n"}
{"name":"Set.inter_union_distrib_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter s (Union.union t u)) (Union.union (Inter.inter s t) (Inter.inter s u))","decl":"theorem inter_union_distrib_left (s t u : Set α) : s ∩ (t ∪ u) = s ∩ t ∪ s ∩ u :=\n  inf_sup_left _ _ _\n\n"}
{"name":"Set.union_inter_distrib_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter (Union.union s t) u) (Union.union (Inter.inter s u) (Inter.inter t u))","decl":"theorem union_inter_distrib_right (s t u : Set α) : (s ∪ t) ∩ u = s ∩ u ∪ t ∩ u :=\n  inf_sup_right _ _ _\n\n"}
{"name":"Set.union_inter_distrib_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Union.union s (Inter.inter t u)) (Inter.inter (Union.union s t) (Union.union s u))","decl":"theorem union_inter_distrib_left (s t u : Set α) : s ∪ t ∩ u = (s ∪ t) ∩ (s ∪ u) :=\n  sup_inf_left _ _ _\n\n"}
{"name":"Set.inter_union_distrib_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Union.union (Inter.inter s t) u) (Inter.inter (Union.union s u) (Union.union t u))","decl":"theorem inter_union_distrib_right (s t u : Set α) : s ∩ t ∪ u = (s ∪ u) ∩ (t ∪ u) :=\n  sup_inf_right _ _ _\n\n\n"}
{"name":"Set.union_union_distrib_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Union.union s (Union.union t u)) (Union.union (Union.union s t) (Union.union s u))","decl":"theorem union_union_distrib_left (s t u : Set α) : s ∪ (t ∪ u) = s ∪ t ∪ (s ∪ u) :=\n  sup_sup_distrib_left _ _ _\n\n"}
{"name":"Set.union_union_distrib_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Union.union (Union.union s t) u) (Union.union (Union.union s u) (Union.union t u))","decl":"theorem union_union_distrib_right (s t u : Set α) : s ∪ t ∪ u = s ∪ u ∪ (t ∪ u) :=\n  sup_sup_distrib_right _ _ _\n\n"}
{"name":"Set.inter_inter_distrib_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter s (Inter.inter t u)) (Inter.inter (Inter.inter s t) (Inter.inter s u))","decl":"theorem inter_inter_distrib_left (s t u : Set α) : s ∩ (t ∩ u) = s ∩ t ∩ (s ∩ u) :=\n  inf_inf_distrib_left _ _ _\n\n"}
{"name":"Set.inter_inter_distrib_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter (Inter.inter s t) u) (Inter.inter (Inter.inter s u) (Inter.inter t u))","decl":"theorem inter_inter_distrib_right (s t u : Set α) : s ∩ t ∩ u = s ∩ u ∩ (t ∩ u) :=\n  inf_inf_distrib_right _ _ _\n\n"}
{"name":"Set.union_union_union_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u v : Set α\n⊢ Eq (Union.union (Union.union s t) (Union.union u v)) (Union.union (Union.union s u) (Union.union t v))","decl":"theorem union_union_union_comm (s t u v : Set α) : s ∪ t ∪ (u ∪ v) = s ∪ u ∪ (t ∪ v) :=\n  sup_sup_sup_comm _ _ _ _\n\n"}
{"name":"Set.inter_inter_inter_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u v : Set α\n⊢ Eq (Inter.inter (Inter.inter s t) (Inter.inter u v)) (Inter.inter (Inter.inter s u) (Inter.inter t v))","decl":"theorem inter_inter_inter_comm (s t u v : Set α) : s ∩ t ∩ (u ∩ v) = s ∩ u ∩ (t ∩ v) :=\n  inf_inf_inf_comm _ _ _ _\n\n"}
{"name":"Set.insert_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\n⊢ Eq (Insert.insert x s) (setOf fun y => Or (Eq y x) (Membership.mem s y))","decl":"theorem insert_def (x : α) (s : Set α) : insert x s = { y | y = x ∨ y ∈ s } :=\n  rfl\n\n"}
{"name":"Set.subset_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\n⊢ HasSubset.Subset s (Insert.insert x s)","decl":"@[simp]\ntheorem subset_insert (x : α) (s : Set α) : s ⊆ insert x s := fun _ => Or.inr\n\n"}
{"name":"Set.mem_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\n⊢ Membership.mem (Insert.insert x s) x","decl":"theorem mem_insert (x : α) (s : Set α) : x ∈ insert x s :=\n  Or.inl rfl\n\n"}
{"name":"Set.mem_insert_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\ny : α\na✝ : Membership.mem s x\n⊢ Membership.mem (Insert.insert y s) x","decl":"theorem mem_insert_of_mem {x : α} {s : Set α} (y : α) : x ∈ s → x ∈ insert y s :=\n  Or.inr\n\n"}
{"name":"Set.eq_or_mem_of_mem_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx a : α\ns : Set α\na✝ : Membership.mem (Insert.insert a s) x\n⊢ Or (Eq x a) (Membership.mem s x)","decl":"theorem eq_or_mem_of_mem_insert {x a : α} {s : Set α} : x ∈ insert a s → x = a ∨ x ∈ s :=\n  id\n\n"}
{"name":"Set.mem_of_mem_insert_of_ne","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\na✝¹ : Membership.mem (Insert.insert a s) b\na✝ : Ne b a\n⊢ Membership.mem s b","decl":"theorem mem_of_mem_insert_of_ne : b ∈ insert a s → b ≠ a → b ∈ s :=\n  Or.resolve_left\n\n"}
{"name":"Set.eq_of_not_mem_of_mem_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\na✝¹ : Membership.mem (Insert.insert a s) b\na✝ : Not (Membership.mem s b)\n⊢ Eq b a","decl":"theorem eq_of_not_mem_of_mem_insert : b ∈ insert a s → b ∉ s → b = a :=\n  Or.resolve_right\n\n"}
{"name":"Set.mem_insert_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx a : α\ns : Set α\n⊢ Iff (Membership.mem (Insert.insert a s) x) (Or (Eq x a) (Membership.mem s x))","decl":"@[simp]\ntheorem mem_insert_iff {x a : α} {s : Set α} : x ∈ insert a s ↔ x = a ∨ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Set.insert_eq_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nh : Membership.mem s a\n⊢ Eq (Insert.insert a s) s","decl":"@[simp]\ntheorem insert_eq_of_mem {a : α} {s : Set α} (h : a ∈ s) : insert a s = s :=\n  ext fun _ => or_iff_right_of_imp fun e => e.symm ▸ h\n\n"}
{"name":"Set.ne_insert_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na : α\na✝ : Not (Membership.mem s a)\n⊢ Ne s (Insert.insert a t)","decl":"theorem ne_insert_of_not_mem {s : Set α} (t : Set α) {a : α} : a ∉ s → s ≠ insert a t :=\n  mt fun e => e.symm ▸ mem_insert _ _\n\n"}
{"name":"Set.insert_eq_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Eq (Insert.insert a s) s) (Membership.mem s a)","decl":"@[simp]\ntheorem insert_eq_self : insert a s = s ↔ a ∈ s :=\n  ⟨fun h => h ▸ mem_insert _ _, insert_eq_of_mem⟩\n\n"}
{"name":"Set.insert_ne_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Ne (Insert.insert a s) s) (Not (Membership.mem s a))","decl":"theorem insert_ne_self : insert a s ≠ s ↔ a ∉ s :=\n  insert_eq_self.not\n\n"}
{"name":"Set.insert_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\n⊢ Iff (HasSubset.Subset (Insert.insert a s) t) (And (Membership.mem t a) (HasSubset.Subset s t))","decl":"theorem insert_subset_iff : insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by\n  simp only [subset_def, mem_insert_iff, or_imp, forall_and, forall_eq]\n\n"}
{"name":"Set.insert_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nha : Membership.mem t a\nhs : HasSubset.Subset s t\n⊢ HasSubset.Subset (Insert.insert a s) t","decl":"theorem insert_subset (ha : a ∈ t) (hs : s ⊆ t) : insert a s ⊆ t :=\n  insert_subset_iff.mpr ⟨ha, hs⟩\n\n"}
{"name":"Set.insert_subset_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Insert.insert a s) (Insert.insert a t)","decl":"theorem insert_subset_insert (h : s ⊆ t) : insert a s ⊆ insert a t := fun _ => Or.imp_right (@h _)\n\n"}
{"name":"Set.insert_subset_insert_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nha : Not (Membership.mem s a)\n⊢ Iff (HasSubset.Subset (Insert.insert a s) (Insert.insert a t)) (HasSubset.Subset s t)","decl":"@[simp] theorem insert_subset_insert_iff (ha : a ∉ s) : insert a s ⊆ insert a t ↔ s ⊆ t := by\n  refine ⟨fun h x hx => ?_, insert_subset_insert⟩\n  rcases h (subset_insert _ _ hx) with (rfl | hxt)\n  exacts [(ha hx).elim, hxt]\n\n"}
{"name":"Set.subset_insert_iff_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nha : Not (Membership.mem s a)\n⊢ Iff (HasSubset.Subset s (Insert.insert a t)) (HasSubset.Subset s t)","decl":"theorem subset_insert_iff_of_not_mem (ha : a ∉ s) : s ⊆ insert a t ↔ s ⊆ t :=\n  forall₂_congr fun _ hb => or_iff_right <| ne_of_mem_of_not_mem hb ha\n\n"}
{"name":"Set.ssubset_iff_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun a => And (Not (Membership.mem s a)) (HasSubset.Subset (Insert.insert a s) t))","decl":"theorem ssubset_iff_insert {s t : Set α} : s ⊂ t ↔ ∃ a ∉ s, insert a s ⊆ t := by\n  simp only [insert_subset_iff, exists_and_right, ssubset_def, not_subset]\n  aesop\n\n"}
{"name":"Set.ssubset_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na : α\nh : Not (Membership.mem s a)\n⊢ HasSSubset.SSubset s (Insert.insert a s)","decl":"theorem ssubset_insert {s : Set α} {a : α} (h : a ∉ s) : s ⊂ insert a s :=\n  ssubset_iff_insert.2 ⟨a, h, Subset.rfl⟩\n\n"}
{"name":"Set.insert_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\n⊢ Eq (Insert.insert a (Insert.insert b s)) (Insert.insert b (Insert.insert a s))","decl":"theorem insert_comm (a b : α) (s : Set α) : insert a (insert b s) = insert b (insert a s) :=\n  ext fun _ => or_left_comm\n\n"}
{"name":"Set.insert_idem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Eq (Insert.insert a (Insert.insert a s)) (Insert.insert a s)","decl":"theorem insert_idem (a : α) (s : Set α) : insert a (insert a s) = insert a s :=\n  insert_eq_of_mem <| mem_insert _ _\n\n"}
{"name":"Set.insert_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\n⊢ Eq (Union.union (Insert.insert a s) t) (Insert.insert a (Union.union s t))","decl":"theorem insert_union : insert a s ∪ t = insert a (s ∪ t) :=\n  ext fun _ => or_assoc\n\n"}
{"name":"Set.union_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\n⊢ Eq (Union.union s (Insert.insert a t)) (Insert.insert a (Union.union s t))","decl":"@[simp]\ntheorem union_insert : s ∪ insert a t = insert a (s ∪ t) :=\n  ext fun _ => or_left_comm\n\n"}
{"name":"Set.insert_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ (Insert.insert a s).Nonempty","decl":"@[simp]\ntheorem insert_nonempty (a : α) (s : Set α) : (insert a s).Nonempty :=\n  ⟨a, mem_insert a s⟩\n\n"}
{"name":"Set.instNonemptyElemInsert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Nonempty ↑(Insert.insert a s)","decl":"instance (a : α) (s : Set α) : Nonempty (insert a s : Set α) :=\n  (insert_nonempty a s).to_subtype\n\n"}
{"name":"Set.insert_inter_distrib","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\n⊢ Eq (Insert.insert a (Inter.inter s t)) (Inter.inter (Insert.insert a s) (Insert.insert a t))","decl":"theorem insert_inter_distrib (a : α) (s t : Set α) : insert a (s ∩ t) = insert a s ∩ insert a t :=\n  ext fun _ => or_and_left\n\n"}
{"name":"Set.insert_union_distrib","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\n⊢ Eq (Insert.insert a (Union.union s t)) (Union.union (Insert.insert a s) (Insert.insert a t))","decl":"theorem insert_union_distrib (a : α) (s t : Set α) : insert a (s ∪ t) = insert a s ∪ insert a t :=\n  ext fun _ => or_or_distrib_left\n\n-- useful in proofs by induction\n"}
{"name":"Set.forall_of_forall_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nP : α → Prop\na : α\ns : Set α\nH : ∀ (x : α), Membership.mem (Insert.insert a s) x → P x\nx : α\nh : Membership.mem s x\n⊢ P x","decl":"theorem forall_of_forall_insert {P : α → Prop} {a : α} {s : Set α} (H : ∀ x, x ∈ insert a s → P x)\n    (x) (h : x ∈ s) : P x :=\n  H _ (Or.inr h)\n\n"}
{"name":"Set.forall_insert_of_forall","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nP : α → Prop\na : α\ns : Set α\nH : ∀ (x : α), Membership.mem s x → P x\nha : P a\nx : α\nh : Membership.mem (Insert.insert a s) x\n⊢ P x","decl":"theorem forall_insert_of_forall {P : α → Prop} {a : α} {s : Set α} (H : ∀ x, x ∈ s → P x) (ha : P a)\n    (x) (h : x ∈ insert a s) : P x :=\n  h.elim (fun e => e.symm ▸ ha) (H _)\n\n/- Porting note: ∃ x ∈ insert a s, P x is parsed as ∃ x, x ∈ insert a s ∧ P x,\n where in Lean3 it was parsed as `∃ x, ∃ (h : x ∈ insert a s), P x` -/\n"}
{"name":"Set.exists_mem_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nP : α → Prop\na : α\ns : Set α\n⊢ Iff (Exists fun x => And (Membership.mem (Insert.insert a s) x) (P x)) (Or (P a) (Exists fun x => And (Membership.mem s x) (P x)))","decl":"theorem exists_mem_insert {P : α → Prop} {a : α} {s : Set α} :\n    (∃ x ∈ insert a s, P x) ↔ (P a ∨ ∃ x ∈ s, P x) := by\n  simp [mem_insert_iff, or_and_right, exists_and_left, exists_or]\n\n"}
{"name":"Set.forall_mem_insert","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nP : α → Prop\na : α\ns : Set α\n⊢ Iff (∀ (x : α), Membership.mem (Insert.insert a s) x → P x) (And (P a) (∀ (x : α), Membership.mem s x → P x))","decl":"theorem forall_mem_insert {P : α → Prop} {a : α} {s : Set α} :\n    (∀ x ∈ insert a s, P x) ↔ P a ∧ ∀ x ∈ s, P x :=\n  forall₂_or_left.trans <| and_congr_left' forall_eq\n\n"}
{"name":"Set.instLawfulSingleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ LawfulSingleton α (Set α)","decl":"instance : LawfulSingleton α (Set α) :=\n  ⟨fun x => Set.ext fun a => by\n    simp only [mem_empty_iff_false, mem_insert_iff, or_false]\n    exact Iff.rfl⟩\n\n"}
{"name":"Set.singleton_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (Singleton.singleton a) (Insert.insert a EmptyCollection.emptyCollection)","decl":"theorem singleton_def (a : α) : ({a} : Set α) = insert a ∅ :=\n  (insert_emptyc_eq a).symm\n\n"}
{"name":"Set.mem_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\n⊢ Iff (Membership.mem (Singleton.singleton b) a) (Eq a b)","decl":"@[simp]\ntheorem mem_singleton_iff {a b : α} : a ∈ ({b} : Set α) ↔ a = b :=\n  Iff.rfl\n\n"}
{"name":"Set.not_mem_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\n⊢ Iff (Not (Membership.mem (Singleton.singleton b) a)) (Ne a b)","decl":"theorem not_mem_singleton_iff {a b : α} : a ∉ ({b} : Set α) ↔ a ≠ b :=\n  Iff.rfl\n\n"}
{"name":"Set.setOf_eq_eq_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (setOf fun n => Eq n a) (Singleton.singleton a)","decl":"@[simp]\ntheorem setOf_eq_eq_singleton {a : α} : { n | n = a } = {a} :=\n  rfl\n\n"}
{"name":"Set.setOf_eq_eq_singleton'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (setOf fun x => Eq a x) (Singleton.singleton a)","decl":"@[simp]\ntheorem setOf_eq_eq_singleton' {a : α} : { x | a = x } = {a} :=\n  ext fun _ => eq_comm\n\n-- TODO: again, annotation needed\n--Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute\n"}
{"name":"Set.mem_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Membership.mem (Singleton.singleton a) a","decl":"theorem mem_singleton (a : α) : a ∈ ({a} : Set α) :=\n  @rfl _ _\n\n"}
{"name":"Set.eq_of_mem_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y : α\nh : Membership.mem (Singleton.singleton y) x\n⊢ Eq x y","decl":"theorem eq_of_mem_singleton {x y : α} (h : x ∈ ({y} : Set α)) : x = y :=\n  h\n\n"}
{"name":"Set.singleton_eq_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y : α\n⊢ Iff (Eq (Singleton.singleton x) (Singleton.singleton y)) (Eq x y)","decl":"@[simp]\ntheorem singleton_eq_singleton_iff {x y : α} : {x} = ({y} : Set α) ↔ x = y :=\n  Set.ext_iff.trans eq_iff_eq_cancel_left\n\n"}
{"name":"Set.singleton_injective","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Function.Injective Singleton.singleton","decl":"theorem singleton_injective : Injective (singleton : α → Set α) := fun _ _ =>\n  singleton_eq_singleton_iff.mp\n\n"}
{"name":"Set.mem_singleton_of_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y : α\nH : Eq x y\n⊢ Membership.mem (Singleton.singleton y) x","decl":"theorem mem_singleton_of_eq {x y : α} (H : x = y) : x ∈ ({y} : Set α) :=\n  H\n\n"}
{"name":"Set.insert_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\n⊢ Eq (Insert.insert x s) (Union.union (Singleton.singleton x) s)","decl":"theorem insert_eq (x : α) (s : Set α) : insert x s = ({x} : Set α) ∪ s :=\n  rfl\n\n"}
{"name":"Set.singleton_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ (Singleton.singleton a).Nonempty","decl":"@[simp]\ntheorem singleton_nonempty (a : α) : ({a} : Set α).Nonempty :=\n  ⟨a, rfl⟩\n\n"}
{"name":"Set.singleton_ne_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Ne (Singleton.singleton a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem singleton_ne_empty (a : α) : ({a} : Set α) ≠ ∅ :=\n  (singleton_nonempty _).ne_empty\n\n"}
{"name":"Set.empty_ssubset_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ HasSSubset.SSubset EmptyCollection.emptyCollection (Singleton.singleton a)","decl":"theorem empty_ssubset_singleton : (∅ : Set α) ⊂ {a} :=\n  (singleton_nonempty _).empty_ssubset\n\n"}
{"name":"Set.singleton_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem singleton_subset_iff {a : α} {s : Set α} : {a} ⊆ s ↔ a ∈ s :=\n  forall_eq\n\n"}
{"name":"Set.singleton_subset_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) (Singleton.singleton b)) (Eq a b)","decl":"theorem singleton_subset_singleton : ({a} : Set α) ⊆ {b} ↔ a = b := by simp\n\n"}
{"name":"Set.GCongr.singleton_subset_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\na✝ : Eq a b\n⊢ HasSubset.Subset (Singleton.singleton a) (Singleton.singleton b)","decl":"@[gcongr] protected alias ⟨_, GCongr.singleton_subset_singleton⟩ := singleton_subset_singleton\n\n"}
{"name":"Set.set_compr_eq_eq_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (setOf fun b => Eq b a) (Singleton.singleton a)","decl":"theorem set_compr_eq_eq_singleton {a : α} : { b | b = a } = {a} :=\n  rfl\n\n"}
{"name":"Set.singleton_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Eq (Union.union (Singleton.singleton a) s) (Insert.insert a s)","decl":"@[simp]\ntheorem singleton_union : {a} ∪ s = insert a s :=\n  rfl\n\n"}
{"name":"Set.union_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Eq (Union.union s (Singleton.singleton a)) (Insert.insert a s)","decl":"@[simp]\ntheorem union_singleton : s ∪ {a} = insert a s :=\n  union_comm _ _\n\n"}
{"name":"Set.singleton_inter_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Inter.inter (Singleton.singleton a) s).Nonempty (Membership.mem s a)","decl":"@[simp]\ntheorem singleton_inter_nonempty : ({a} ∩ s).Nonempty ↔ a ∈ s := by\n  simp only [Set.Nonempty, mem_inter_iff, mem_singleton_iff, exists_eq_left]\n\n"}
{"name":"Set.inter_singleton_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Inter.inter s (Singleton.singleton a)).Nonempty (Membership.mem s a)","decl":"@[simp]\ntheorem inter_singleton_nonempty : (s ∩ {a}).Nonempty ↔ a ∈ s := by\n  rw [inter_comm, singleton_inter_nonempty]\n\n"}
{"name":"Set.singleton_inter_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Eq (Inter.inter (Singleton.singleton a) s) EmptyCollection.emptyCollection) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem singleton_inter_eq_empty : {a} ∩ s = ∅ ↔ a ∉ s :=\n  not_nonempty_iff_eq_empty.symm.trans singleton_inter_nonempty.not\n\n"}
{"name":"Set.inter_singleton_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Eq (Inter.inter s (Singleton.singleton a)) EmptyCollection.emptyCollection) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem inter_singleton_eq_empty : s ∩ {a} = ∅ ↔ a ∉ s := by\n  rw [inter_comm, singleton_inter_eq_empty]\n\n"}
{"name":"Set.nmem_singleton_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not (Membership.mem (Singleton.singleton EmptyCollection.emptyCollection) s)) s.Nonempty","decl":"theorem nmem_singleton_empty {s : Set α} : s ∉ ({∅} : Set (Set α)) ↔ s.Nonempty :=\n  nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.eq_singleton_iff_unique_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Eq s (Singleton.singleton a)) (And (Membership.mem s a) (∀ (x : α), Membership.mem s x → Eq x a))","decl":"theorem eq_singleton_iff_unique_mem : s = {a} ↔ a ∈ s ∧ ∀ x ∈ s, x = a :=\n  Subset.antisymm_iff.trans <| and_comm.trans <| and_congr_left' singleton_subset_iff\n\n"}
{"name":"Set.eq_singleton_iff_nonempty_unique_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Eq s (Singleton.singleton a)) (And s.Nonempty (∀ (x : α), Membership.mem s x → Eq x a))","decl":"theorem eq_singleton_iff_nonempty_unique_mem : s = {a} ↔ s.Nonempty ∧ ∀ x ∈ s, x = a :=\n  eq_singleton_iff_unique_mem.trans <|\n    and_congr_left fun H => ⟨fun h' => ⟨_, h'⟩, fun ⟨x, h⟩ => H x h ▸ h⟩\n\n-- while `simp` is capable of proving this, it is not capable of turning the LHS into the RHS.\n"}
{"name":"Set.default_coe_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq Inhabited.default ⟨x, ⋯⟩","decl":"@[simp]\ntheorem default_coe_singleton (x : α) : (default : ({x} : Set α)) = ⟨x, rfl⟩ :=\n  rfl\n\n"}
{"name":"Set.mem_sep","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\nx : α\nxs : Membership.mem s x\npx : p x\n⊢ Membership.mem (setOf fun x => And (Membership.mem s x) (p x)) x","decl":"theorem mem_sep (xs : x ∈ s) (px : p x) : x ∈ { x ∈ s | p x } :=\n  ⟨xs, px⟩\n\n"}
{"name":"Set.sep_mem_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (setOf fun x => And (Membership.mem s x) (Membership.mem t x)) (Inter.inter s t)","decl":"@[simp]\ntheorem sep_mem_eq : { x ∈ s | x ∈ t } = s ∩ t :=\n  rfl\n\n"}
{"name":"Set.mem_sep_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\nx : α\n⊢ Iff (Membership.mem (setOf fun x => And (Membership.mem s x) (p x)) x) (And (Membership.mem s x) (p x))","decl":"@[simp]\ntheorem mem_sep_iff : x ∈ { x ∈ s | p x } ↔ x ∈ s ∧ p x :=\n  Iff.rfl\n\n"}
{"name":"Set.sep_ext_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np q : α → Prop\n⊢ Iff (Eq (setOf fun x => And (Membership.mem s x) (p x)) (setOf fun x => And (Membership.mem s x) (q x))) (∀ (x : α), Membership.mem s x → Iff (p x) (q x))","decl":"theorem sep_ext_iff : { x ∈ s | p x } = { x ∈ s | q x } ↔ ∀ x ∈ s, p x ↔ q x := by\n  simp_rw [Set.ext_iff, mem_sep_iff, and_congr_right_iff]\n\n"}
{"name":"Set.sep_eq_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (setOf fun x => And (Membership.mem t x) (Membership.mem s x)) s","decl":"theorem sep_eq_of_subset (h : s ⊆ t) : { x ∈ t | x ∈ s } = s :=\n  inter_eq_self_of_subset_right h\n\n"}
{"name":"Set.sep_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\n⊢ HasSubset.Subset (setOf fun x => And (Membership.mem s x) (p x)) s","decl":"@[simp]\ntheorem sep_subset (s : Set α) (p : α → Prop) : { x ∈ s | p x } ⊆ s := fun _ => And.left\n\n"}
{"name":"Set.sep_eq_self_iff_mem_true","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\n⊢ Iff (Eq (setOf fun x => And (Membership.mem s x) (p x)) s) (∀ (x : α), Membership.mem s x → p x)","decl":"@[simp]\ntheorem sep_eq_self_iff_mem_true : { x ∈ s | p x } = s ↔ ∀ x ∈ s, p x := by\n  simp_rw [Set.ext_iff, mem_sep_iff, and_iff_left_iff_imp]\n\n"}
{"name":"Set.sep_eq_empty_iff_mem_false","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\n⊢ Iff (Eq (setOf fun x => And (Membership.mem s x) (p x)) EmptyCollection.emptyCollection) (∀ (x : α), Membership.mem s x → Not (p x))","decl":"@[simp]\ntheorem sep_eq_empty_iff_mem_false : { x ∈ s | p x } = ∅ ↔ ∀ x ∈ s, ¬p x := by\n  simp_rw [Set.ext_iff, mem_sep_iff, mem_empty_iff_false, iff_false, not_and]\n\n"}
{"name":"Set.sep_true","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (setOf fun x => And (Membership.mem s x) True) s","decl":"theorem sep_true : { x ∈ s | True } = s :=\n  inter_univ s\n\n"}
{"name":"Set.sep_false","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (setOf fun x => And (Membership.mem s x) False) EmptyCollection.emptyCollection","decl":"theorem sep_false : { x ∈ s | False } = ∅ :=\n  inter_empty s\n\n"}
{"name":"Set.sep_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Eq (setOf fun x => And (Membership.mem EmptyCollection.emptyCollection x) (p x)) EmptyCollection.emptyCollection","decl":"theorem sep_empty (p : α → Prop) : { x ∈ (∅ : Set α) | p x } = ∅ :=\n  empty_inter {x | p x}\n\n"}
{"name":"Set.sep_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Eq (setOf fun x => And (Membership.mem Set.univ x) (p x)) (setOf fun x => p x)","decl":"theorem sep_univ : { x ∈ (univ : Set α) | p x } = { x | p x } :=\n  univ_inter {x | p x}\n\n"}
{"name":"Set.sep_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\np : α → Prop\n⊢ Eq (setOf fun x => And (Or (Membership.mem s x) (Membership.mem t x)) (p x)) (Union.union (setOf fun x => And (Membership.mem s x) (p x)) (setOf fun x => And (Membership.mem t x) (p x)))","decl":"@[simp]\ntheorem sep_union : { x | (x ∈ s ∨ x ∈ t) ∧ p x } = { x ∈ s | p x } ∪ { x ∈ t | p x } :=\n  union_inter_distrib_right { x | x ∈ s } { x | x ∈ t } p\n\n"}
{"name":"Set.sep_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\np : α → Prop\n⊢ Eq (setOf fun x => And (And (Membership.mem s x) (Membership.mem t x)) (p x)) (Inter.inter (setOf fun x => And (Membership.mem s x) (p x)) (setOf fun x => And (Membership.mem t x) (p x)))","decl":"@[simp]\ntheorem sep_inter : { x | (x ∈ s ∧ x ∈ t) ∧ p x } = { x ∈ s | p x } ∩ { x ∈ t | p x } :=\n  inter_inter_distrib_right s t {x | p x}\n\n"}
{"name":"Set.sep_and","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np q : α → Prop\n⊢ Eq (setOf fun x => And (Membership.mem s x) (And (p x) (q x))) (Inter.inter (setOf fun x => And (Membership.mem s x) (p x)) (setOf fun x => And (Membership.mem s x) (q x)))","decl":"@[simp]\ntheorem sep_and : { x ∈ s | p x ∧ q x } = { x ∈ s | p x } ∩ { x ∈ s | q x } :=\n  inter_inter_distrib_left s {x | p x} {x | q x}\n\n"}
{"name":"Set.sep_or","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\np q : α → Prop\n⊢ Eq (setOf fun x => And (Membership.mem s x) (Or (p x) (q x))) (Union.union (setOf fun x => And (Membership.mem s x) (p x)) (setOf fun x => And (Membership.mem s x) (q x)))","decl":"@[simp]\ntheorem sep_or : { x ∈ s | p x ∨ q x } = { x ∈ s | p x } ∪ { x ∈ s | q x } :=\n  inter_union_distrib_left s p q\n\n"}
{"name":"Set.sep_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np q : α → Prop\n⊢ Eq (setOf fun x => And (Membership.mem (setOf fun y => p y) x) (q x)) (setOf fun x => And (p x) (q x))","decl":"@[simp]\ntheorem sep_setOf : { x ∈ { y | p y } | q x } = { x | p x ∧ q x } :=\n  rfl\n\n"}
{"name":"Set.subset_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns : Set α\nx : α\n⊢ Iff (HasSubset.Subset s (Singleton.singleton x)) (∀ (y : α), Membership.mem s y → Eq y x)","decl":"@[simp]\ntheorem subset_singleton_iff {α : Type*} {s : Set α} {x : α} : s ⊆ {x} ↔ ∀ y ∈ s, y = x :=\n  Iff.rfl\n\n"}
{"name":"Set.subset_singleton_iff_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\n⊢ Iff (HasSubset.Subset s (Singleton.singleton x)) (Or (Eq s EmptyCollection.emptyCollection) (Eq s (Singleton.singleton x)))","decl":"theorem subset_singleton_iff_eq {s : Set α} {x : α} : s ⊆ {x} ↔ s = ∅ ∨ s = {x} := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · exact ⟨fun _ => Or.inl rfl, fun _ => empty_subset _⟩\n  · simp [eq_singleton_iff_nonempty_unique_mem, hs, hs.ne_empty]\n\n"}
{"name":"Set.Nonempty.subset_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s (Singleton.singleton a)) (Eq s (Singleton.singleton a))","decl":"theorem Nonempty.subset_singleton_iff (h : s.Nonempty) : s ⊆ {a} ↔ s = {a} :=\n  subset_singleton_iff_eq.trans <| or_iff_right h.ne_empty\n\n"}
{"name":"Set.ssubset_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\n⊢ Iff (HasSSubset.SSubset s (Singleton.singleton x)) (Eq s EmptyCollection.emptyCollection)","decl":"theorem ssubset_singleton_iff {s : Set α} {x : α} : s ⊂ {x} ↔ s = ∅ := by\n  rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_right, and_not_self_iff, or_false,\n    and_iff_left_iff_imp]\n  exact fun h => h ▸ (singleton_ne_empty _).symm\n\n"}
{"name":"Set.eq_empty_of_ssubset_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\nhs : HasSSubset.SSubset s (Singleton.singleton x)\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_ssubset_singleton {s : Set α} {x : α} (hs : s ⊂ {x}) : s = ∅ :=\n  ssubset_singleton_iff.1 hs\n\n"}
{"name":"Set.eq_of_nonempty_of_subsingleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝² : Subsingleton α\ns t : Set α\ninst✝¹ : Nonempty ↑s\ninst✝ : Nonempty ↑t\n⊢ Eq s t","decl":"theorem eq_of_nonempty_of_subsingleton {α} [Subsingleton α] (s t : Set α) [Nonempty s]\n    [Nonempty t] : s = t :=\n  Nonempty.of_subtype.eq_univ.trans Nonempty.of_subtype.eq_univ.symm\n\n"}
{"name":"Set.eq_of_nonempty_of_subsingleton'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Subsingleton α\ns t : Set α\nhs : s.Nonempty\ninst✝ : Nonempty ↑t\n⊢ Eq s t","decl":"theorem eq_of_nonempty_of_subsingleton' {α} [Subsingleton α] {s : Set α} (t : Set α)\n    (hs : s.Nonempty) [Nonempty t] : s = t :=\n  have := hs.to_subtype; eq_of_nonempty_of_subsingleton s t\n\n"}
{"name":"Set.Nonempty.eq_zero","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝¹ : Subsingleton α\ninst✝ : Zero α\ns : Set α\nh : s.Nonempty\n⊢ Eq s (Singleton.singleton 0)","decl":"theorem Nonempty.eq_zero [Subsingleton α] [Zero α] {s : Set α} (h : s.Nonempty) :\n    s = {0} := eq_of_nonempty_of_subsingleton' {0} h\n\n"}
{"name":"Set.Nonempty.eq_one","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝¹ : Subsingleton α\ninst✝ : One α\ns : Set α\nh : s.Nonempty\n⊢ Eq s (Singleton.singleton 1)","decl":"theorem Nonempty.eq_one [Subsingleton α] [One α] {s : Set α} (h : s.Nonempty) :\n    s = {1} := eq_of_nonempty_of_subsingleton' {1} h\n\n"}
{"name":"Set.disjoint_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s t) (HasSubset.Subset (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"protected theorem disjoint_iff : Disjoint s t ↔ s ∩ t ⊆ ∅ :=\n  disjoint_iff_inf_le\n\n"}
{"name":"Set.disjoint_iff_inter_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s t) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"theorem disjoint_iff_inter_eq_empty : Disjoint s t ↔ s ∩ t = ∅ :=\n  disjoint_iff\n\n"}
{"name":"Disjoint.inter_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : Disjoint s t\n⊢ Eq (Inter.inter s t) EmptyCollection.emptyCollection","decl":"theorem _root_.Disjoint.inter_eq : Disjoint s t → s ∩ t = ∅ :=\n  Disjoint.eq_bot\n\n"}
{"name":"Set.disjoint_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s t) (∀ ⦃a : α⦄, Membership.mem s a → Not (Membership.mem t a))","decl":"theorem disjoint_left : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ s → a ∉ t :=\n  disjoint_iff_inf_le.trans <| forall_congr' fun _ => not_and\n\n"}
{"name":"Set.disjoint_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s t) (∀ ⦃a : α⦄, Membership.mem t a → Not (Membership.mem s a))","decl":"theorem disjoint_right : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s := by rw [disjoint_comm, disjoint_left]\n\n"}
{"name":"Set.not_disjoint_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Not (Disjoint s t)) (Exists fun x => And (Membership.mem s x) (Membership.mem t x))","decl":"lemma not_disjoint_iff : ¬Disjoint s t ↔ ∃ x, x ∈ s ∧ x ∈ t :=\n  Set.disjoint_iff.not.trans <| not_forall.trans <| exists_congr fun _ ↦ not_not\n\n"}
{"name":"Set.not_disjoint_iff_nonempty_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Not (Disjoint s t)) (Inter.inter s t).Nonempty","decl":"lemma not_disjoint_iff_nonempty_inter : ¬ Disjoint s t ↔ (s ∩ t).Nonempty := not_disjoint_iff\n\n"}
{"name":"Set.Nonempty.not_disjoint","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : (Inter.inter s t).Nonempty\n⊢ Not (Disjoint s t)","decl":"alias ⟨_, Nonempty.not_disjoint⟩ := not_disjoint_iff_nonempty_inter\n\n"}
{"name":"Set.disjoint_or_nonempty_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Or (Disjoint s t) (Inter.inter s t).Nonempty","decl":"lemma disjoint_or_nonempty_inter (s t : Set α) : Disjoint s t ∨ (s ∩ t).Nonempty :=\n  (em _).imp_right not_disjoint_iff_nonempty_inter.1\n\n"}
{"name":"Set.disjoint_iff_forall_ne","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s t) (∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem t b → Ne a b)","decl":"lemma disjoint_iff_forall_ne : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ t → a ≠ b := by\n  simp only [Ne, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']\n\n"}
{"name":"Disjoint.ne_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝² : Disjoint s t\na : α\na✝¹ : Membership.mem s a\nb : α\na✝ : Membership.mem t b\n⊢ Ne a b","decl":"alias ⟨_root_.Disjoint.ne_of_mem, _⟩ := disjoint_iff_forall_ne\n\n"}
{"name":"Set.disjoint_of_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nh : HasSubset.Subset s u\nd : Disjoint u t\n⊢ Disjoint s t","decl":"lemma disjoint_of_subset_left (h : s ⊆ u) (d : Disjoint u t) : Disjoint s t := d.mono_left h\n"}
{"name":"Set.disjoint_of_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nh : HasSubset.Subset t u\nd : Disjoint s u\n⊢ Disjoint s t","decl":"lemma disjoint_of_subset_right (h : t ⊆ u) (d : Disjoint s u) : Disjoint s t := d.mono_right h\n\n"}
{"name":"Set.disjoint_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t₁ t₂ : Set α\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\nh : Disjoint s₂ t₂\n⊢ Disjoint s₁ t₁","decl":"lemma disjoint_of_subset (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) (h : Disjoint s₂ t₂) : Disjoint s₁ t₁ :=\n  h.mono hs ht\n\n"}
{"name":"Set.disjoint_union_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Disjoint (Union.union s t) u) (And (Disjoint s u) (Disjoint t u))","decl":"@[simp]\nlemma disjoint_union_left : Disjoint (s ∪ t) u ↔ Disjoint s u ∧ Disjoint t u := disjoint_sup_left\n\n"}
{"name":"Set.disjoint_union_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (Disjoint s (Union.union t u)) (And (Disjoint s t) (Disjoint s u))","decl":"@[simp]\nlemma disjoint_union_right : Disjoint s (t ∪ u) ↔ Disjoint s t ∧ Disjoint s u := disjoint_sup_right\n\n"}
{"name":"Set.disjoint_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Disjoint s EmptyCollection.emptyCollection","decl":"@[simp] lemma disjoint_empty (s : Set α) : Disjoint s ∅ := disjoint_bot_right\n"}
{"name":"Set.empty_disjoint","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Disjoint EmptyCollection.emptyCollection s","decl":"@[simp] lemma empty_disjoint (s : Set α) : Disjoint ∅ s := disjoint_bot_left\n\n"}
{"name":"Set.univ_disjoint","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Disjoint Set.univ s) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] lemma univ_disjoint : Disjoint univ s ↔ s = ∅ := top_disjoint\n"}
{"name":"Set.disjoint_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Disjoint s Set.univ) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] lemma disjoint_univ : Disjoint s univ ↔ s = ∅ := disjoint_top\n\n"}
{"name":"Set.disjoint_sdiff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Disjoint (SDiff.sdiff t s) s","decl":"lemma disjoint_sdiff_left : Disjoint (t \\ s) s := disjoint_sdiff_self_left\n\n"}
{"name":"Set.disjoint_sdiff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Disjoint s (SDiff.sdiff t s)","decl":"lemma disjoint_sdiff_right : Disjoint s (t \\ s) := disjoint_sdiff_self_right\n\n-- TODO: prove this in terms of a lattice lemma\n"}
{"name":"Set.disjoint_sdiff_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Disjoint (SDiff.sdiff s t) (Inter.inter s t)","decl":"theorem disjoint_sdiff_inter : Disjoint (s \\ t) (s ∩ t) :=\n  disjoint_of_subset_right inter_subset_right disjoint_sdiff_left\n\n"}
{"name":"Set.inter_diff_assoc","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b c : Set α\n⊢ Eq (SDiff.sdiff (Inter.inter a b) c) (Inter.inter a (SDiff.sdiff b c))","decl":"/-- See also `Set.sdiff_inter_right_comm`. -/\nlemma inter_diff_assoc (a b c : Set α) : (a ∩ b) \\ c = a ∩ (b \\ c) := inf_sdiff_assoc ..\n\n"}
{"name":"Set.sdiff_inter_right_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter (SDiff.sdiff s t) u) (SDiff.sdiff (Inter.inter s u) t)","decl":"/-- See also `Set.inter_diff_assoc`. -/\nlemma sdiff_inter_right_comm (s t u : Set α) : s \\ t ∩ u = (s ∩ u) \\ t := sdiff_inf_right_comm ..\n\n"}
{"name":"Set.inter_sdiff_left_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter s (SDiff.sdiff t u)) (Inter.inter t (SDiff.sdiff s u))","decl":"lemma inter_sdiff_left_comm (s t u : Set α) : s ∩ (t \\ u) = t ∩ (s \\ u) := inf_sdiff_left_comm ..\n\n"}
{"name":"Set.diff_union_diff_cancel","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nhts : HasSubset.Subset t s\nhut : HasSubset.Subset u t\n⊢ Eq (Union.union (SDiff.sdiff s t) (SDiff.sdiff t u)) (SDiff.sdiff s u)","decl":"theorem diff_union_diff_cancel (hts : t ⊆ s) (hut : u ⊆ t) : s \\ t ∪ t \\ u = s \\ u :=\n  sdiff_sup_sdiff_cancel hts hut\n\n"}
{"name":"Set.diff_diff_eq_sdiff_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nh : HasSubset.Subset u s\n⊢ Eq (SDiff.sdiff s (SDiff.sdiff t u)) (Union.union (SDiff.sdiff s t) u)","decl":"theorem diff_diff_eq_sdiff_union (h : u ⊆ s) : s \\ (t \\ u) = s \\ t ∪ u := sdiff_sdiff_eq_sdiff_sup h\n\n"}
{"name":"Set.disjoint_singleton_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Disjoint (Singleton.singleton a) s) (Not (Membership.mem s a))","decl":"@[simp default+1]\nlemma disjoint_singleton_left : Disjoint {a} s ↔ a ∉ s := by simp [Set.disjoint_iff, subset_def]\n\n"}
{"name":"Set.disjoint_singleton_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (Disjoint s (Singleton.singleton a)) (Not (Membership.mem s a))","decl":"@[simp]\nlemma disjoint_singleton_right : Disjoint s {a} ↔ a ∉ s :=\n  disjoint_comm.trans disjoint_singleton_left\n\n"}
{"name":"Set.disjoint_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\n⊢ Iff (Disjoint (Singleton.singleton a) (Singleton.singleton b)) (Ne a b)","decl":"lemma disjoint_singleton : Disjoint ({a} : Set α) {b} ↔ a ≠ b := by\n  simp\n\n"}
{"name":"Set.subset_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (HasSubset.Subset s (SDiff.sdiff t u)) (And (HasSubset.Subset s t) (Disjoint s u))","decl":"lemma subset_diff : s ⊆ t \\ u ↔ s ⊆ t ∧ Disjoint s u := le_iff_subset.symm.trans le_sdiff\n\n"}
{"name":"Set.ssubset_iff_sdiff_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun a => And (Membership.mem t a) (HasSubset.Subset s (SDiff.sdiff t (Singleton.singleton a))))","decl":"lemma ssubset_iff_sdiff_singleton : s ⊂ t ↔ ∃ a ∈ t, s ⊆ t \\ {a} := by\n  simp [ssubset_iff_insert, subset_diff, insert_subset_iff]; aesop\n\n"}
{"name":"Set.inter_diff_distrib_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter s (SDiff.sdiff t u)) (SDiff.sdiff (Inter.inter s t) (Inter.inter s u))","decl":"theorem inter_diff_distrib_left (s t u : Set α) : s ∩ (t \\ u) = (s ∩ t) \\ (s ∩ u) :=\n  inf_sdiff_distrib_left _ _ _\n\n"}
{"name":"Set.inter_diff_distrib_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter (SDiff.sdiff s t) u) (SDiff.sdiff (Inter.inter s u) (Inter.inter t u))","decl":"theorem inter_diff_distrib_right (s t u : Set α) : (s \\ t) ∩ u = (s ∩ u) \\ (t ∩ u) :=\n  inf_sdiff_distrib_right _ _ _\n\n"}
{"name":"Set.disjoint_of_subset_iff_left_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Iff (Disjoint s t) (Eq s EmptyCollection.emptyCollection)","decl":"theorem disjoint_of_subset_iff_left_eq_empty (h : s ⊆ t) :\n    Disjoint s t ↔ s = ∅ := by\n  simp only [disjoint_iff, inf_eq_left.mpr h, bot_eq_empty]\n\n"}
{"name":"Set.compl_def","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (HasCompl.compl s) (setOf fun x => Not (Membership.mem s x))","decl":"theorem compl_def (s : Set α) : sᶜ = { x | x ∉ s } :=\n  rfl\n\n"}
{"name":"Set.mem_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\nh : Not (Membership.mem s x)\n⊢ Membership.mem (HasCompl.compl s) x","decl":"theorem mem_compl {s : Set α} {x : α} (h : x ∉ s) : x ∈ sᶜ :=\n  h\n\n"}
{"name":"Set.compl_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (HasCompl.compl (setOf fun a => p a)) (setOf fun a => Not (p a))","decl":"theorem compl_setOf {α} (p : α → Prop) : { a | p a }ᶜ = { a | ¬p a } :=\n  rfl\n\n"}
{"name":"Set.not_mem_of_mem_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\nh : Membership.mem (HasCompl.compl s) x\n⊢ Not (Membership.mem s x)","decl":"theorem not_mem_of_mem_compl {s : Set α} {x : α} (h : x ∈ sᶜ) : x ∉ s :=\n  h\n\n"}
{"name":"Set.not_mem_compl_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx : α\n⊢ Iff (Not (Membership.mem (HasCompl.compl s) x)) (Membership.mem s x)","decl":"theorem not_mem_compl_iff {x : α} : x ∉ sᶜ ↔ x ∈ s :=\n  not_not\n\n"}
{"name":"Set.inter_compl_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Inter.inter s (HasCompl.compl s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_compl_self (s : Set α) : s ∩ sᶜ = ∅ :=\n  inf_compl_eq_bot\n\n"}
{"name":"Set.compl_inter_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Inter.inter (HasCompl.compl s) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem compl_inter_self (s : Set α) : sᶜ ∩ s = ∅ :=\n  compl_inf_eq_bot\n\n"}
{"name":"Set.compl_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (HasCompl.compl EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem compl_empty : (∅ : Set α)ᶜ = univ :=\n  compl_bot\n\n"}
{"name":"Set.compl_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (HasCompl.compl (Union.union s t)) (Inter.inter (HasCompl.compl s) (HasCompl.compl t))","decl":"@[simp]\ntheorem compl_union (s t : Set α) : (s ∪ t)ᶜ = sᶜ ∩ tᶜ :=\n  compl_sup\n\n"}
{"name":"Set.compl_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (HasCompl.compl (Inter.inter s t)) (Union.union (HasCompl.compl s) (HasCompl.compl t))","decl":"theorem compl_inter (s t : Set α) : (s ∩ t)ᶜ = sᶜ ∪ tᶜ :=\n  compl_inf\n\n"}
{"name":"Set.compl_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq (HasCompl.compl Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem compl_univ : (univ : Set α)ᶜ = ∅ :=\n  compl_top\n\n"}
{"name":"Set.compl_empty_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq (HasCompl.compl s) EmptyCollection.emptyCollection) (Eq s Set.univ)","decl":"@[simp]\ntheorem compl_empty_iff {s : Set α} : sᶜ = ∅ ↔ s = univ :=\n  compl_eq_bot\n\n"}
{"name":"Set.compl_univ_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq (HasCompl.compl s) Set.univ) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem compl_univ_iff {s : Set α} : sᶜ = univ ↔ s = ∅ :=\n  compl_eq_top\n\n"}
{"name":"Set.compl_ne_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Ne (HasCompl.compl s) Set.univ) s.Nonempty","decl":"theorem compl_ne_univ : sᶜ ≠ univ ↔ s.Nonempty :=\n  compl_univ_iff.not.trans nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.inl_compl_union_inr_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (Union.union (Set.image Sum.inl (HasCompl.compl s)) (Set.image Sum.inr (HasCompl.compl t))) (HasCompl.compl (Union.union (Set.image Sum.inl s) (Set.image Sum.inr t)))","decl":"lemma inl_compl_union_inr_compl {α β : Type*} {s : Set α} {t : Set β} :\n    Sum.inl '' sᶜ ∪ Sum.inr '' tᶜ = (Sum.inl '' s ∪ Sum.inr '' t)ᶜ := by\n  rw [compl_union]\n  aesop\n\n"}
{"name":"Set.nonempty_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (HasCompl.compl s).Nonempty (Ne s Set.univ)","decl":"theorem nonempty_compl : sᶜ.Nonempty ↔ s ≠ univ :=\n  (ne_univ_iff_exists_not_mem s).symm\n\n"}
{"name":"Set.nonempty_compl_of_nontrivial","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ninst✝ : Nontrivial α\nx : α\n⊢ (HasCompl.compl (Singleton.singleton x)).Nonempty","decl":"@[simp] lemma nonempty_compl_of_nontrivial [Nontrivial α] (x : α) : Set.Nonempty {x}ᶜ := by\n  obtain ⟨y, hy⟩ := exists_ne x\n  exact ⟨y, by simp [hy]⟩\n\n"}
{"name":"Set.mem_compl_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na x : α\n⊢ Iff (Membership.mem (HasCompl.compl (Singleton.singleton a)) x) (Ne x a)","decl":"theorem mem_compl_singleton_iff {a x : α} : x ∈ ({a} : Set α)ᶜ ↔ x ≠ a :=\n  Iff.rfl\n\n"}
{"name":"Set.compl_singleton_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (HasCompl.compl (Singleton.singleton a)) (setOf fun x => Ne x a)","decl":"theorem compl_singleton_eq (a : α) : ({a} : Set α)ᶜ = { x | x ≠ a } :=\n  rfl\n\n"}
{"name":"Set.compl_ne_eq_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (HasCompl.compl (setOf fun x => Ne x a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem compl_ne_eq_singleton (a : α) : ({ x | x ≠ a } : Set α)ᶜ = {a} :=\n  compl_compl _\n\n"}
{"name":"Set.union_eq_compl_compl_inter_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union s t) (HasCompl.compl (Inter.inter (HasCompl.compl s) (HasCompl.compl t)))","decl":"theorem union_eq_compl_compl_inter_compl (s t : Set α) : s ∪ t = (sᶜ ∩ tᶜ)ᶜ :=\n  ext fun _ => or_iff_not_and_not\n\n"}
{"name":"Set.inter_eq_compl_compl_union_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Inter.inter s t) (HasCompl.compl (Union.union (HasCompl.compl s) (HasCompl.compl t)))","decl":"theorem inter_eq_compl_compl_union_compl (s t : Set α) : s ∩ t = (sᶜ ∪ tᶜ)ᶜ :=\n  ext fun _ => and_iff_not_or_not\n\n"}
{"name":"Set.union_compl_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Union.union s (HasCompl.compl s)) Set.univ","decl":"@[simp]\ntheorem union_compl_self (s : Set α) : s ∪ sᶜ = univ :=\n  eq_univ_iff_forall.2 fun _ => em _\n\n"}
{"name":"Set.compl_union_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Union.union (HasCompl.compl s) s) Set.univ","decl":"@[simp]\ntheorem compl_union_self (s : Set α) : sᶜ ∪ s = univ := by rw [union_comm, union_compl_self]\n\n"}
{"name":"Set.compl_subset_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset (HasCompl.compl s) t) (HasSubset.Subset (HasCompl.compl t) s)","decl":"theorem compl_subset_comm : sᶜ ⊆ t ↔ tᶜ ⊆ s :=\n  @compl_le_iff_compl_le _ s _ _\n\n"}
{"name":"Set.subset_compl_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl t)) (HasSubset.Subset t (HasCompl.compl s))","decl":"theorem subset_compl_comm : s ⊆ tᶜ ↔ t ⊆ sᶜ :=\n  @le_compl_iff_le_compl _ _ _ t\n\n"}
{"name":"Set.compl_subset_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset (HasCompl.compl s) (HasCompl.compl t)) (HasSubset.Subset t s)","decl":"@[simp]\ntheorem compl_subset_compl : sᶜ ⊆ tᶜ ↔ t ⊆ s :=\n  @compl_le_compl_iff_le (Set α) _ _ _\n\n"}
{"name":"Set.compl_subset_compl_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset t s\n⊢ HasSubset.Subset (HasCompl.compl s) (HasCompl.compl t)","decl":"@[gcongr] theorem compl_subset_compl_of_subset (h : t ⊆ s) : sᶜ ⊆ tᶜ := compl_subset_compl.2 h\n\n"}
{"name":"Set.subset_compl_iff_disjoint_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl t)) (Disjoint t s)","decl":"theorem subset_compl_iff_disjoint_left : s ⊆ tᶜ ↔ Disjoint t s :=\n  @le_compl_iff_disjoint_left (Set α) _ _ _\n\n"}
{"name":"Set.subset_compl_iff_disjoint_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl t)) (Disjoint s t)","decl":"theorem subset_compl_iff_disjoint_right : s ⊆ tᶜ ↔ Disjoint s t :=\n  @le_compl_iff_disjoint_right (Set α) _ _ _\n\n"}
{"name":"Set.disjoint_compl_left_iff_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint (HasCompl.compl s) t) (HasSubset.Subset t s)","decl":"theorem disjoint_compl_left_iff_subset : Disjoint sᶜ t ↔ t ⊆ s :=\n  disjoint_compl_left_iff\n\n"}
{"name":"Set.disjoint_compl_right_iff_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Disjoint s (HasCompl.compl t)) (HasSubset.Subset s t)","decl":"theorem disjoint_compl_right_iff_subset : Disjoint s tᶜ ↔ s ⊆ t :=\n  disjoint_compl_right_iff\n\n"}
{"name":"Disjoint.subset_compl_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : Disjoint s t\n⊢ HasSubset.Subset s (HasCompl.compl t)","decl":"alias ⟨_, _root_.Disjoint.subset_compl_right⟩ := subset_compl_iff_disjoint_right\n\n"}
{"name":"Disjoint.subset_compl_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : Disjoint t s\n⊢ HasSubset.Subset s (HasCompl.compl t)","decl":"alias ⟨_, _root_.Disjoint.subset_compl_left⟩ := subset_compl_iff_disjoint_left\n\n"}
{"name":"HasSubset.Subset.disjoint_compl_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset t s\n⊢ Disjoint (HasCompl.compl s) t","decl":"alias ⟨_, _root_.HasSubset.Subset.disjoint_compl_left⟩ := disjoint_compl_left_iff_subset\n\n"}
{"name":"HasSubset.Subset.disjoint_compl_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset s t\n⊢ Disjoint s (HasCompl.compl t)","decl":"alias ⟨_, _root_.HasSubset.Subset.disjoint_compl_right⟩ := disjoint_compl_right_iff_subset\n\n"}
{"name":"Set.subset_union_compl_iff_inter_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (HasSubset.Subset s (Union.union t (HasCompl.compl u))) (HasSubset.Subset (Inter.inter s u) t)","decl":"theorem subset_union_compl_iff_inter_subset {s t u : Set α} : s ⊆ t ∪ uᶜ ↔ s ∩ u ⊆ t :=\n  (@isCompl_compl _ u _).le_sup_right_iff_inf_left_le\n\n"}
{"name":"Set.compl_subset_iff_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset (HasCompl.compl s) t) (Eq (Union.union s t) Set.univ)","decl":"theorem compl_subset_iff_union {s t : Set α} : sᶜ ⊆ t ↔ s ∪ t = univ :=\n  Iff.symm <| eq_univ_iff_forall.trans <| forall_congr' fun _ => or_iff_not_imp_left\n\n"}
{"name":"Set.subset_compl_singleton_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl (Singleton.singleton a))) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem subset_compl_singleton_iff {a : α} {s : Set α} : s ⊆ {a}ᶜ ↔ a ∉ s :=\n  subset_compl_comm.trans singleton_subset_iff\n\n"}
{"name":"Set.inter_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b c : Set α\n⊢ Iff (HasSubset.Subset (Inter.inter a b) c) (HasSubset.Subset a (Union.union (HasCompl.compl b) c))","decl":"theorem inter_subset (a b c : Set α) : a ∩ b ⊆ c ↔ a ⊆ bᶜ ∪ c :=\n  forall_congr' fun _ => and_imp.trans <| imp_congr_right fun _ => imp_iff_not_or\n\n"}
{"name":"Set.inter_compl_nonempty_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Inter.inter s (HasCompl.compl t)).Nonempty (Not (HasSubset.Subset s t))","decl":"theorem inter_compl_nonempty_iff {s t : Set α} : (s ∩ tᶜ).Nonempty ↔ ¬s ⊆ t :=\n  (not_subset.trans <| exists_congr fun x => by simp [mem_compl]).symm\n\n"}
{"name":"Set.not_mem_diff_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nx : α\nhx : Membership.mem t x\n⊢ Not (Membership.mem (SDiff.sdiff s t) x)","decl":"theorem not_mem_diff_of_mem {s t : Set α} {x : α} (hx : x ∈ t) : x ∉ s \\ t := fun h => h.2 hx\n\n"}
{"name":"Set.mem_of_mem_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nx : α\nh : Membership.mem (SDiff.sdiff s t) x\n⊢ Membership.mem s x","decl":"theorem mem_of_mem_diff {s t : Set α} {x : α} (h : x ∈ s \\ t) : x ∈ s :=\n  h.left\n\n"}
{"name":"Set.not_mem_of_mem_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nx : α\nh : Membership.mem (SDiff.sdiff s t) x\n⊢ Not (Membership.mem t x)","decl":"theorem not_mem_of_mem_diff {s t : Set α} {x : α} (h : x ∈ s \\ t) : x ∉ t :=\n  h.right\n\n"}
{"name":"Set.diff_eq_compl_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s t) (Inter.inter (HasCompl.compl t) s)","decl":"theorem diff_eq_compl_inter {s t : Set α} : s \\ t = tᶜ ∩ s := by rw [diff_eq, inter_comm]\n\n"}
{"name":"Set.diff_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (SDiff.sdiff s t).Nonempty (Not (HasSubset.Subset s t))","decl":"theorem diff_nonempty {s t : Set α} : (s \\ t).Nonempty ↔ ¬s ⊆ t :=\n  inter_compl_nonempty_iff\n"}
{"name":"Set.nonempty_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (SDiff.sdiff s t).Nonempty (Not (HasSubset.Subset s t))","decl":"@[deprecated (since := \"2024-08-27\")] alias nonempty_diff := diff_nonempty\n\n"}
{"name":"Set.diff_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset (SDiff.sdiff s t) s","decl":"theorem diff_subset {s t : Set α} : s \\ t ⊆ s := show s \\ t ≤ s from sdiff_le\n\n"}
{"name":"Set.diff_subset_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset (SDiff.sdiff s t) (HasCompl.compl t)","decl":"theorem diff_subset_compl (s t : Set α) : s \\ t ⊆ tᶜ :=\n  diff_eq_compl_inter ▸ inter_subset_left\n\n"}
{"name":"Set.union_diff_cancel'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nh₁ : HasSubset.Subset s t\nh₂ : HasSubset.Subset t u\n⊢ Eq (Union.union t (SDiff.sdiff u s)) u","decl":"theorem union_diff_cancel' {s t u : Set α} (h₁ : s ⊆ t) (h₂ : t ⊆ u) : t ∪ u \\ s = u :=\n  sup_sdiff_cancel' h₁ h₂\n\n"}
{"name":"Set.union_diff_cancel","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (Union.union s (SDiff.sdiff t s)) t","decl":"theorem union_diff_cancel {s t : Set α} (h : s ⊆ t) : s ∪ t \\ s = t :=\n  sup_sdiff_cancel_right h\n\n"}
{"name":"Set.union_diff_cancel_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset (Inter.inter s t) EmptyCollection.emptyCollection\n⊢ Eq (SDiff.sdiff (Union.union s t) s) t","decl":"theorem union_diff_cancel_left {s t : Set α} (h : s ∩ t ⊆ ∅) : (s ∪ t) \\ s = t :=\n  Disjoint.sup_sdiff_cancel_left <| disjoint_iff_inf_le.2 h\n\n"}
{"name":"Set.union_diff_cancel_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset (Inter.inter s t) EmptyCollection.emptyCollection\n⊢ Eq (SDiff.sdiff (Union.union s t) t) s","decl":"theorem union_diff_cancel_right {s t : Set α} (h : s ∩ t ⊆ ∅) : (s ∪ t) \\ t = s :=\n  Disjoint.sup_sdiff_cancel_right <| disjoint_iff_inf_le.2 h\n\n"}
{"name":"Set.union_diff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff (Union.union s t) s) (SDiff.sdiff t s)","decl":"@[simp]\ntheorem union_diff_left {s t : Set α} : (s ∪ t) \\ s = t \\ s :=\n  sup_sdiff_left_self\n\n"}
{"name":"Set.union_diff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff (Union.union s t) t) (SDiff.sdiff s t)","decl":"@[simp]\ntheorem union_diff_right {s t : Set α} : (s ∪ t) \\ t = s \\ t :=\n  sup_sdiff_right_self\n\n"}
{"name":"Set.union_diff_distrib","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (SDiff.sdiff (Union.union s t) u) (Union.union (SDiff.sdiff s u) (SDiff.sdiff t u))","decl":"theorem union_diff_distrib {s t u : Set α} : (s ∪ t) \\ u = s \\ u ∪ t \\ u :=\n  sup_sdiff\n\n"}
{"name":"Set.inter_diff_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\n⊢ Eq (Inter.inter a (SDiff.sdiff b a)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_diff_self (a b : Set α) : a ∩ (b \\ a) = ∅ :=\n  inf_sdiff_self_right\n\n"}
{"name":"Set.inter_union_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union (Inter.inter s t) (SDiff.sdiff s t)) s","decl":"@[simp]\ntheorem inter_union_diff (s t : Set α) : s ∩ t ∪ s \\ t = s :=\n  sup_inf_sdiff s t\n\n"}
{"name":"Set.diff_union_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union (SDiff.sdiff s t) (Inter.inter s t)) s","decl":"@[simp]\ntheorem diff_union_inter (s t : Set α) : s \\ t ∪ s ∩ t = s := by\n  rw [union_comm]\n  exact sup_inf_sdiff _ _\n\n"}
{"name":"Set.inter_union_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union (Inter.inter s t) (Inter.inter s (HasCompl.compl t))) s","decl":"@[simp]\ntheorem inter_union_compl (s t : Set α) : s ∩ t ∪ s ∩ tᶜ = s :=\n  inter_union_diff _ _\n\n"}
{"name":"Set.diff_subset_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t₁ t₂ : Set α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₂ t₁\n⊢ HasSubset.Subset (SDiff.sdiff s₁ t₁) (SDiff.sdiff s₂ t₂)","decl":"@[gcongr]\ntheorem diff_subset_diff {s₁ s₂ t₁ t₂ : Set α} : s₁ ⊆ s₂ → t₂ ⊆ t₁ → s₁ \\ t₁ ⊆ s₂ \\ t₂ :=\n  show s₁ ≤ s₂ → t₂ ≤ t₁ → s₁ \\ t₁ ≤ s₂ \\ t₂ from sdiff_le_sdiff\n\n"}
{"name":"Set.diff_subset_diff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns₁ s₂ t : Set α\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (SDiff.sdiff s₁ t) (SDiff.sdiff s₂ t)","decl":"@[gcongr]\ntheorem diff_subset_diff_left {s₁ s₂ t : Set α} (h : s₁ ⊆ s₂) : s₁ \\ t ⊆ s₂ \\ t :=\n  sdiff_le_sdiff_right ‹s₁ ≤ s₂›\n\n"}
{"name":"Set.diff_subset_diff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\nh : HasSubset.Subset t u\n⊢ HasSubset.Subset (SDiff.sdiff s u) (SDiff.sdiff s t)","decl":"@[gcongr]\ntheorem diff_subset_diff_right {s t u : Set α} (h : t ⊆ u) : s \\ u ⊆ s \\ t :=\n  sdiff_le_sdiff_left ‹t ≤ u›\n\n"}
{"name":"Set.diff_subset_diff_iff_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t r : Set α\nhs : HasSubset.Subset s r\nht : HasSubset.Subset t r\n⊢ Iff (HasSubset.Subset (SDiff.sdiff r s) (SDiff.sdiff r t)) (HasSubset.Subset t s)","decl":"theorem diff_subset_diff_iff_subset {r : Set α} (hs : s ⊆ r) (ht : t ⊆ r) :\n    r \\ s ⊆ r \\ t ↔ t ⊆ s :=\n  sdiff_le_sdiff_iff_le hs ht\n\n"}
{"name":"Set.compl_eq_univ_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (HasCompl.compl s) (SDiff.sdiff Set.univ s)","decl":"theorem compl_eq_univ_diff (s : Set α) : sᶜ = univ \\ s :=\n  top_sdiff.symm\n\n"}
{"name":"Set.empty_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (SDiff.sdiff EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_diff (s : Set α) : (∅ \\ s : Set α) = ∅ :=\n  bot_sdiff\n\n"}
{"name":"Set.diff_eq_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (SDiff.sdiff s t) EmptyCollection.emptyCollection) (HasSubset.Subset s t)","decl":"theorem diff_eq_empty {s t : Set α} : s \\ t = ∅ ↔ s ⊆ t :=\n  sdiff_eq_bot_iff\n\n"}
{"name":"Set.diff_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (SDiff.sdiff s EmptyCollection.emptyCollection) s","decl":"@[simp]\ntheorem diff_empty {s : Set α} : s \\ ∅ = s :=\n  sdiff_bot\n\n"}
{"name":"Set.diff_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (SDiff.sdiff s Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem diff_univ (s : Set α) : s \\ univ = ∅ :=\n  diff_eq_empty.2 (subset_univ s)\n\n"}
{"name":"Set.diff_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (SDiff.sdiff (SDiff.sdiff s t) u) (SDiff.sdiff s (Union.union t u))","decl":"theorem diff_diff {u : Set α} : (s \\ t) \\ u = s \\ (t ∪ u) :=\n  sdiff_sdiff_left\n\n-- the following statement contains parentheses to help the reader\n"}
{"name":"Set.diff_diff_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (SDiff.sdiff (SDiff.sdiff s t) u) (SDiff.sdiff (SDiff.sdiff s u) t)","decl":"theorem diff_diff_comm {s t u : Set α} : (s \\ t) \\ u = (s \\ u) \\ t :=\n  sdiff_sdiff_comm\n\n"}
{"name":"Set.diff_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (HasSubset.Subset (SDiff.sdiff s t) u) (HasSubset.Subset s (Union.union t u))","decl":"theorem diff_subset_iff {s t u : Set α} : s \\ t ⊆ u ↔ s ⊆ t ∪ u :=\n  show s \\ t ≤ u ↔ s ≤ t ∪ u from sdiff_le_iff\n\n"}
{"name":"Set.subset_diff_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ HasSubset.Subset s (Union.union (SDiff.sdiff s t) t)","decl":"theorem subset_diff_union (s t : Set α) : s ⊆ s \\ t ∪ t :=\n  show s ≤ s \\ t ∪ t from le_sdiff_sup\n\n"}
{"name":"Set.diff_union_of_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset t s\n⊢ Eq (Union.union (SDiff.sdiff s t) t) s","decl":"theorem diff_union_of_subset {s t : Set α} (h : t ⊆ s) : s \\ t ∪ t = s :=\n  Subset.antisymm (union_subset diff_subset h) (subset_diff_union _ _)\n\n"}
{"name":"Set.diff_singleton_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns t : Set α\n⊢ Iff (HasSubset.Subset (SDiff.sdiff s (Singleton.singleton x)) t) (HasSubset.Subset s (Insert.insert x t))","decl":"@[simp]\ntheorem diff_singleton_subset_iff {x : α} {s t : Set α} : s \\ {x} ⊆ t ↔ s ⊆ insert x t := by\n  rw [← union_singleton, union_comm]\n  apply diff_subset_iff\n\n"}
{"name":"Set.subset_diff_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns t : Set α\nh : HasSubset.Subset s t\nhx : Not (Membership.mem s x)\n⊢ HasSubset.Subset s (SDiff.sdiff t (Singleton.singleton x))","decl":"theorem subset_diff_singleton {x : α} {s t : Set α} (h : s ⊆ t) (hx : x ∉ s) : s ⊆ t \\ {x} :=\n  subset_inter h <| subset_compl_comm.1 <| singleton_subset_iff.2 hx\n\n"}
{"name":"Set.subset_insert_diff_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\ns : Set α\n⊢ HasSubset.Subset s (Insert.insert x (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem subset_insert_diff_singleton (x : α) (s : Set α) : s ⊆ insert x (s \\ {x}) := by\n  rw [← diff_singleton_subset_iff]\n\n"}
{"name":"Set.diff_subset_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Iff (HasSubset.Subset (SDiff.sdiff s t) u) (HasSubset.Subset (SDiff.sdiff s u) t)","decl":"theorem diff_subset_comm {s t u : Set α} : s \\ t ⊆ u ↔ s \\ u ⊆ t :=\n  show s \\ t ≤ u ↔ s \\ u ≤ t from sdiff_le_comm\n\n"}
{"name":"Set.diff_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (SDiff.sdiff s (Inter.inter t u)) (Union.union (SDiff.sdiff s t) (SDiff.sdiff s u))","decl":"theorem diff_inter {s t u : Set α} : s \\ (t ∩ u) = s \\ t ∪ s \\ u :=\n  sdiff_inf\n\n"}
{"name":"Set.diff_inter_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (Inter.inter (SDiff.sdiff s t) (SDiff.sdiff s u)) (SDiff.sdiff s (Union.union t u))","decl":"theorem diff_inter_diff {s t u : Set α} : s \\ t ∩ (s \\ u) = s \\ (t ∪ u) :=\n  sdiff_sup.symm\n\n"}
{"name":"Set.diff_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s (HasCompl.compl t)) (Inter.inter s t)","decl":"theorem diff_compl : s \\ tᶜ = s ∩ t :=\n  sdiff_compl\n\n"}
{"name":"Set.diff_diff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t u : Set α\n⊢ Eq (SDiff.sdiff s (SDiff.sdiff t u)) (Union.union (SDiff.sdiff s t) (Inter.inter s u))","decl":"theorem diff_diff_right {s t u : Set α} : s \\ (t \\ u) = s \\ t ∪ s ∩ u :=\n  sdiff_sdiff_right'\n\n"}
{"name":"Set.diff_insert_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nx : α\nh : Not (Membership.mem s x)\n⊢ Eq (SDiff.sdiff s (Insert.insert x t)) (SDiff.sdiff s t)","decl":"theorem diff_insert_of_not_mem {x : α} (h : x ∉ s) : s \\ insert x t = s \\ t := by\n  refine Subset.antisymm (diff_subset_diff (refl _) (subset_insert ..)) fun y hy ↦ ?_\n  simp only [mem_diff, mem_insert_iff, not_or] at hy ⊢\n  exact ⟨hy.1, fun hxy ↦ h <| hxy ▸ hy.1, hy.2⟩\n\n"}
{"name":"Set.insert_diff_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\nt s : Set α\nh : Membership.mem t a\n⊢ Eq (SDiff.sdiff (Insert.insert a s) t) (SDiff.sdiff s t)","decl":"@[simp]\ntheorem insert_diff_of_mem (s) (h : a ∈ t) : insert a s \\ t = s \\ t := by\n  ext\n  constructor <;> simp +contextual [or_imp, h]\n\n"}
{"name":"Set.insert_diff_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\nt s : Set α\nh : Not (Membership.mem t a)\n⊢ Eq (SDiff.sdiff (Insert.insert a s) t) (Insert.insert a (SDiff.sdiff s t))","decl":"theorem insert_diff_of_not_mem (s) (h : a ∉ t) : insert a s \\ t = insert a (s \\ t) := by\n  classical\n    ext x\n    by_cases h' : x ∈ t\n    · simp [h, h', ne_of_mem_of_not_mem h' h]\n    · simp [h, h']\n\n"}
{"name":"Set.insert_diff_self_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nh : Not (Membership.mem s a)\n⊢ Eq (SDiff.sdiff (Insert.insert a s) (Singleton.singleton a)) s","decl":"theorem insert_diff_self_of_not_mem {a : α} {s : Set α} (h : a ∉ s) : insert a s \\ {a} = s := by\n  ext x\n  simp [and_iff_left_of_imp (ne_of_mem_of_not_mem · h)]\n\n"}
{"name":"Set.insert_diff_self_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nha : Membership.mem s a\n⊢ Eq (Insert.insert a (SDiff.sdiff s (Singleton.singleton a))) s","decl":"lemma insert_diff_self_of_mem (ha : a ∈ s) : insert a (s \\ {a}) = s := by\n  ext; simp +contextual [or_and_left, em, ha]\n\n"}
{"name":"Set.insert_erase_invOn","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Set.InvOn (Insert.insert a) (fun s => SDiff.sdiff s (Singleton.singleton a)) (setOf fun s => Membership.mem s a) (setOf fun s => Not (Membership.mem s a))","decl":"lemma insert_erase_invOn :\n    InvOn (insert a) (fun s ↦ s \\ {a}) {s : Set α | a ∈ s} {s : Set α | a ∉ s} :=\n  ⟨fun _s ha ↦ insert_diff_self_of_mem ha, fun _s ↦ insert_diff_self_of_not_mem⟩\n\n"}
{"name":"Set.insert_inj","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\nha : Not (Membership.mem s a)\n⊢ Iff (Eq (Insert.insert a s) (Insert.insert b s)) (Eq a b)","decl":"theorem insert_inj (ha : a ∉ s) : insert a s = insert b s ↔ a = b :=\n  ⟨fun h => eq_of_not_mem_of_mem_insert (h ▸ mem_insert a s) ha,\n    congr_arg (fun x => insert x s)⟩\n\n"}
{"name":"Set.insert_diff_eq_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nh : Not (Membership.mem s a)\n⊢ Eq (SDiff.sdiff (Insert.insert a s) s) (Singleton.singleton a)","decl":"@[simp]\ntheorem insert_diff_eq_singleton {a : α} {s : Set α} (h : a ∉ s) : insert a s \\ s = {a} := by\n  ext\n  rw [Set.mem_diff, Set.mem_insert_iff, Set.mem_singleton_iff, or_and_right, and_not_self_iff,\n    or_false, and_iff_left_iff_imp]\n  rintro rfl\n  exact h\n\n"}
{"name":"Set.inter_insert_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : Membership.mem s a\n⊢ Eq (Inter.inter s (Insert.insert a t)) (Insert.insert a (Inter.inter s t))","decl":"theorem inter_insert_of_mem (h : a ∈ s) : s ∩ insert a t = insert a (s ∩ t) := by\n  rw [insert_inter_distrib, insert_eq_of_mem h]\n\n"}
{"name":"Set.insert_inter_of_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : Membership.mem t a\n⊢ Eq (Inter.inter (Insert.insert a s) t) (Insert.insert a (Inter.inter s t))","decl":"theorem insert_inter_of_mem (h : a ∈ t) : insert a s ∩ t = insert a (s ∩ t) := by\n  rw [insert_inter_distrib, insert_eq_of_mem h]\n\n"}
{"name":"Set.inter_insert_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : Not (Membership.mem s a)\n⊢ Eq (Inter.inter s (Insert.insert a t)) (Inter.inter s t)","decl":"theorem inter_insert_of_not_mem (h : a ∉ s) : s ∩ insert a t = s ∩ t :=\n  ext fun _ => and_congr_right fun hx => or_iff_right <| ne_of_mem_of_not_mem hx h\n\n"}
{"name":"Set.insert_inter_of_not_mem","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns t : Set α\nh : Not (Membership.mem t a)\n⊢ Eq (Inter.inter (Insert.insert a s) t) (Inter.inter s t)","decl":"theorem insert_inter_of_not_mem (h : a ∉ t) : insert a s ∩ t = s ∩ t :=\n  ext fun _ => and_congr_left fun hx => or_iff_right <| ne_of_mem_of_not_mem hx h\n\n"}
{"name":"Set.union_diff_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union s (SDiff.sdiff t s)) (Union.union s t)","decl":"@[simp]\ntheorem union_diff_self {s t : Set α} : s ∪ t \\ s = s ∪ t :=\n  sup_sdiff_self _ _\n\n"}
{"name":"Set.diff_union_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union (SDiff.sdiff s t) t) (Union.union s t)","decl":"@[simp]\ntheorem diff_union_self {s t : Set α} : s \\ t ∪ t = s ∪ t :=\n  sdiff_sup_self _ _\n\n"}
{"name":"Set.diff_inter_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : Set α\n⊢ Eq (Inter.inter (SDiff.sdiff b a) a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem diff_inter_self {a b : Set α} : b \\ a ∩ a = ∅ :=\n  inf_sdiff_self_left\n\n"}
{"name":"Set.diff_inter_self_eq_diff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s (Inter.inter t s)) (SDiff.sdiff s t)","decl":"@[simp]\ntheorem diff_inter_self_eq_diff {s t : Set α} : s \\ (t ∩ s) = s \\ t :=\n  sdiff_inf_self_right _ _\n\n"}
{"name":"Set.diff_self_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s (Inter.inter s t)) (SDiff.sdiff s t)","decl":"@[simp]\ntheorem diff_self_inter {s t : Set α} : s \\ (s ∩ t) = s \\ t :=\n  sdiff_inf_self_left _ _\n\n"}
{"name":"Set.diff_singleton_eq_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nh : Not (Membership.mem s a)\n⊢ Eq (SDiff.sdiff s (Singleton.singleton a)) s","decl":"@[simp]\ntheorem diff_singleton_eq_self {a : α} {s : Set α} (h : a ∉ s) : s \\ {a} = s :=\n  sdiff_eq_self_iff_disjoint.2 <| by simp [h]\n\n"}
{"name":"Set.diff_singleton_sSubset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\na : α\n⊢ Iff (HasSSubset.SSubset (SDiff.sdiff s (Singleton.singleton a)) s) (Membership.mem s a)","decl":"@[simp]\ntheorem diff_singleton_sSubset {s : Set α} {a : α} : s \\ {a} ⊂ s ↔ a ∈ s :=\n  sdiff_le.lt_iff_ne.trans <| sdiff_eq_left.not.trans <| by simp\n\n"}
{"name":"Set.insert_diff_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ Eq (Insert.insert a (SDiff.sdiff s (Singleton.singleton a))) (Insert.insert a s)","decl":"@[simp]\ntheorem insert_diff_singleton {a : α} {s : Set α} : insert a (s \\ {a}) = insert a s := by\n  simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]\n\n"}
{"name":"Set.insert_diff_singleton_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\nhab : Ne a b\ns : Set α\n⊢ Eq (Insert.insert a (SDiff.sdiff s (Singleton.singleton b))) (SDiff.sdiff (Insert.insert a s) (Singleton.singleton b))","decl":"theorem insert_diff_singleton_comm (hab : a ≠ b) (s : Set α) :\n    insert a (s \\ {b}) = insert a s \\ {b} := by\n  simp_rw [← union_singleton, union_diff_distrib,\n    diff_singleton_eq_self (mem_singleton_iff.not.2 hab.symm)]\n\n"}
{"name":"Set.diff_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (SDiff.sdiff s s) EmptyCollection.emptyCollection","decl":"theorem diff_self {s : Set α} : s \\ s = ∅ :=\n  sdiff_self\n\n"}
{"name":"Set.diff_diff_right_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (SDiff.sdiff s (SDiff.sdiff s t)) (Inter.inter s t)","decl":"theorem diff_diff_right_self (s t : Set α) : s \\ (s \\ t) = s ∩ t :=\n  sdiff_sdiff_right_self\n\n"}
{"name":"Set.diff_diff_cancel_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (SDiff.sdiff t (SDiff.sdiff t s)) s","decl":"theorem diff_diff_cancel_left {s t : Set α} (h : s ⊆ t) : t \\ (t \\ s) = s :=\n  sdiff_sdiff_eq_self h\n\n"}
{"name":"Set.mem_diff_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y : α\ns : Set α\n⊢ Iff (Membership.mem (SDiff.sdiff s (Singleton.singleton y)) x) (And (Membership.mem s x) (Ne x y))","decl":"theorem mem_diff_singleton {x y : α} {s : Set α} : x ∈ s \\ {y} ↔ x ∈ s ∧ x ≠ y :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_diff_singleton_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nt : Set (Set α)\n⊢ Iff (Membership.mem (SDiff.sdiff t (Singleton.singleton EmptyCollection.emptyCollection)) s) (And (Membership.mem t s) s.Nonempty)","decl":"theorem mem_diff_singleton_empty {t : Set (Set α)} : s ∈ t \\ {∅} ↔ s ∈ t ∧ s.Nonempty :=\n  mem_diff_singleton.trans <| and_congr_right' nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.subset_insert_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\nx : α\n⊢ Iff (HasSubset.Subset s (Insert.insert x t)) (Or (HasSubset.Subset s t) (And (Membership.mem s x) (HasSubset.Subset (SDiff.sdiff s (Singleton.singleton x)) t)))","decl":"theorem subset_insert_iff {s t : Set α} {x : α} :\n    s ⊆ insert x t ↔ s ⊆ t ∨ (x ∈ s ∧ s \\ {x} ⊆ t) := by\n  rw [← diff_singleton_subset_iff]\n  by_cases hx : x ∈ s\n  · rw [and_iff_right hx, or_iff_right_of_imp diff_subset.trans]\n  rw [diff_singleton_eq_self hx, or_iff_left_of_imp And.right]\n\n"}
{"name":"Set.union_eq_diff_union_diff_union_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Union.union s t) (Union.union (Union.union (SDiff.sdiff s t) (SDiff.sdiff t s)) (Inter.inter s t))","decl":"theorem union_eq_diff_union_diff_union_inter (s t : Set α) : s ∪ t = s \\ t ∪ t \\ s ∪ s ∩ t :=\n  sup_eq_sdiff_sup_sdiff_sup_inf\n\n"}
{"name":"Set.pair_eq_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (Insert.insert a (Singleton.singleton a)) (Singleton.singleton a)","decl":"theorem pair_eq_singleton (a : α) : ({a, a} : Set α) = {a} :=\n  union_self _\n\n"}
{"name":"Set.pair_comm","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\n⊢ Eq (Insert.insert a (Singleton.singleton b)) (Insert.insert b (Singleton.singleton a))","decl":"theorem pair_comm (a b : α) : ({a, b} : Set α) = {b, a} :=\n  union_comm _ _\n\n"}
{"name":"Set.pair_eq_pair_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx y z w : α\n⊢ Iff (Eq (Insert.insert x (Singleton.singleton y)) (Insert.insert z (Singleton.singleton w))) (Or (And (Eq x z) (Eq y w)) (And (Eq x w) (Eq y z)))","decl":"theorem pair_eq_pair_iff {x y z w : α} :\n    ({x, y} : Set α) = {z, w} ↔ x = z ∧ y = w ∨ x = w ∧ y = z := by\n  simp [subset_antisymm_iff, insert_subset_iff]; aesop\n\n"}
{"name":"Set.pair_diff_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\nhne : Ne a b\n⊢ Eq (SDiff.sdiff (Insert.insert a (Singleton.singleton b)) (Singleton.singleton a)) (Singleton.singleton b)","decl":"theorem pair_diff_left (hne : a ≠ b) : ({a, b} : Set α) \\ {a} = {b} := by\n  rw [insert_diff_of_mem _ (mem_singleton a), diff_singleton_eq_self (by simpa)]\n\n"}
{"name":"Set.pair_diff_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\nhne : Ne a b\n⊢ Eq (SDiff.sdiff (Insert.insert a (Singleton.singleton b)) (Singleton.singleton b)) (Singleton.singleton a)","decl":"theorem pair_diff_right (hne : a ≠ b) : ({a, b} : Set α) \\ {b} = {a} := by\n  rw [pair_comm, pair_diff_left hne.symm]\n\n"}
{"name":"Set.pair_subset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\n⊢ Iff (HasSubset.Subset (Insert.insert a (Singleton.singleton b)) s) (And (Membership.mem s a) (Membership.mem s b))","decl":"theorem pair_subset_iff : {a, b} ⊆ s ↔ a ∈ s ∧ b ∈ s := by\n  rw [insert_subset_iff, singleton_subset_iff]\n\n"}
{"name":"Set.pair_subset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ HasSubset.Subset (Insert.insert a (Singleton.singleton b)) s","decl":"theorem pair_subset (ha : a ∈ s) (hb : b ∈ s) : {a, b} ⊆ s :=\n  pair_subset_iff.2 ⟨ha,hb⟩\n\n"}
{"name":"Set.subset_pair_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\n⊢ Iff (HasSubset.Subset s (Insert.insert a (Singleton.singleton b))) (∀ (x : α), Membership.mem s x → Or (Eq x a) (Eq x b))","decl":"theorem subset_pair_iff : s ⊆ {a, b} ↔ ∀ x ∈ s, x = a ∨ x = b := by\n  simp [subset_def]\n\n"}
{"name":"Set.subset_pair_iff_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\nx y : α\n⊢ Iff (HasSubset.Subset s (Insert.insert x (Singleton.singleton y))) (Or (Eq s EmptyCollection.emptyCollection) (Or (Eq s (Singleton.singleton x)) (Or (Eq s (Singleton.singleton y)) (Eq s (Insert.insert x (Singleton.singleton y))))))","decl":"theorem subset_pair_iff_eq {x y : α} : s ⊆ {x, y} ↔ s = ∅ ∨ s = {x} ∨ s = {y} ∨ s = {x, y} := by\n  refine ⟨?_, by rintro (rfl | rfl | rfl | rfl) <;> simp [pair_subset_iff]⟩\n  rw [subset_insert_iff, subset_singleton_iff_eq, subset_singleton_iff_eq,\n    ← subset_empty_iff (s := s \\ {x}), diff_subset_iff, union_empty, subset_singleton_iff_eq]\n  have h : x ∈ s → {y} = s \\ {x} → s = {x,y} := fun h₁ h₂ ↦ by simp [h₁, h₂]\n  tauto\n\n"}
{"name":"Set.Nonempty.subset_pair_iff_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\na b : α\ns : Set α\nhs : s.Nonempty\n⊢ Iff (HasSubset.Subset s (Insert.insert a (Singleton.singleton b))) (Or (Eq s (Singleton.singleton a)) (Or (Eq s (Singleton.singleton b)) (Eq s (Insert.insert a (Singleton.singleton b)))))","decl":"theorem Nonempty.subset_pair_iff_eq (hs : s.Nonempty) :\n    s ⊆ {a, b} ↔ s = {a} ∨ s = {b} ∨ s = {a, b} := by\n  rw [Set.subset_pair_iff_eq, or_iff_right]; exact hs.ne_empty\n\n"}
{"name":"Set.mem_powerset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx s : Set α\nh : HasSubset.Subset x s\n⊢ Membership.mem s.powerset x","decl":"theorem mem_powerset {x s : Set α} (h : x ⊆ s) : x ∈ 𝒫 s := @h\n\n"}
{"name":"Set.subset_of_mem_powerset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx s : Set α\nh : Membership.mem s.powerset x\n⊢ HasSubset.Subset x s","decl":"theorem subset_of_mem_powerset {x s : Set α} (h : x ∈ 𝒫 s) : x ⊆ s := @h\n\n"}
{"name":"Set.mem_powerset_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx s : Set α\n⊢ Iff (Membership.mem s.powerset x) (HasSubset.Subset x s)","decl":"@[simp]\ntheorem mem_powerset_iff (x s : Set α) : x ∈ 𝒫 s ↔ x ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Set.powerset_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Inter.inter s t).powerset (Inter.inter s.powerset t.powerset)","decl":"theorem powerset_inter (s t : Set α) : 𝒫(s ∩ t) = 𝒫 s ∩ 𝒫 t :=\n  ext fun _ => subset_inter_iff\n\n"}
{"name":"Set.powerset_mono","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (HasSubset.Subset s.powerset t.powerset) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem powerset_mono : 𝒫 s ⊆ 𝒫 t ↔ s ⊆ t :=\n  ⟨fun h => @h _ (fun _ h => h), fun h _ hu _ ha => h (hu ha)⟩\n\n"}
{"name":"Set.monotone_powerset","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Monotone Set.powerset","decl":"theorem monotone_powerset : Monotone (powerset : Set α → Set (Set α)) := fun _ _ => powerset_mono.2\n\n"}
{"name":"Set.powerset_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ s.powerset.Nonempty","decl":"@[simp]\ntheorem powerset_nonempty : (𝒫 s).Nonempty :=\n  ⟨∅, fun _ h => empty_subset s h⟩\n\n"}
{"name":"Set.powerset_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq EmptyCollection.emptyCollection.powerset (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem powerset_empty : 𝒫(∅ : Set α) = {∅} :=\n  ext fun _ => subset_empty_iff\n\n"}
{"name":"Set.powerset_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\n⊢ Eq Set.univ.powerset Set.univ","decl":"@[simp]\ntheorem powerset_univ : 𝒫(univ : Set α) = univ :=\n  eq_univ_of_forall subset_univ\n\n"}
{"name":"Set.powerset_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (Singleton.singleton x).powerset (Insert.insert EmptyCollection.emptyCollection (Singleton.singleton (Singleton.singleton x)))","decl":"/-- The powerset of a singleton contains only `∅` and the singleton itself. -/\ntheorem powerset_singleton (x : α) : 𝒫({x} : Set α) = {∅, {x}} := by\n  ext y\n  rw [mem_powerset_iff, subset_singleton_iff_eq, mem_insert_iff, mem_singleton_iff]\n\n"}
{"name":"Set.mem_dite","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\ns : p → Set α\nt : Not p → Set α\nx : α\n⊢ Iff (Membership.mem (dite p (fun h => s h) fun h => t h) x) (And (∀ (h : p), Membership.mem (s h) x) (∀ (h : Not p), Membership.mem (t h) x))","decl":"@[deprecated _root_.mem_dite (since := \"2025-01-30\")]\nprotected theorem mem_dite (p : Prop) [Decidable p] (s : p → Set α) (t : ¬ p → Set α) (x : α) :\n    (x ∈ if h : p then s h else t h) ↔ (∀ h : p, x ∈ s h) ∧ ∀ h : ¬p, x ∈ t h :=\n  _root_.mem_dite\n\n"}
{"name":"Set.mem_dite_univ_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : p → Set α\nx : α\n⊢ Iff (Membership.mem (dite p (fun h => t h) fun h => Set.univ) x) (∀ (h : p), Membership.mem (t h) x)","decl":"theorem mem_dite_univ_right (p : Prop) [Decidable p] (t : p → Set α) (x : α) :\n    (x ∈ if h : p then t h else univ) ↔ ∀ h : p, x ∈ t h := by\n  simp [mem_dite]\n\n"}
{"name":"Set.mem_ite_univ_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Set α\nx : α\n⊢ Iff (Membership.mem (ite p t Set.univ) x) (p → Membership.mem t x)","decl":"@[simp]\ntheorem mem_ite_univ_right (p : Prop) [Decidable p] (t : Set α) (x : α) :\n    x ∈ ite p t Set.univ ↔ p → x ∈ t :=\n  mem_dite_univ_right p (fun _ => t) x\n\n"}
{"name":"Set.mem_dite_univ_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Not p → Set α\nx : α\n⊢ Iff (Membership.mem (dite p (fun h => Set.univ) fun h => t h) x) (∀ (h : Not p), Membership.mem (t h) x)","decl":"theorem mem_dite_univ_left (p : Prop) [Decidable p] (t : ¬p → Set α) (x : α) :\n    (x ∈ if h : p then univ else t h) ↔ ∀ h : ¬p, x ∈ t h := by\n  split_ifs <;> simp_all\n\n"}
{"name":"Set.mem_ite_univ_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Set α\nx : α\n⊢ Iff (Membership.mem (ite p Set.univ t) x) (Not p → Membership.mem t x)","decl":"@[simp]\ntheorem mem_ite_univ_left (p : Prop) [Decidable p] (t : Set α) (x : α) :\n    x ∈ ite p Set.univ t ↔ ¬p → x ∈ t :=\n  mem_dite_univ_left p (fun _ => t) x\n\n"}
{"name":"Set.mem_dite_empty_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : p → Set α\nx : α\n⊢ Iff (Membership.mem (dite p (fun h => t h) fun h => EmptyCollection.emptyCollection) x) (Exists fun h => Membership.mem (t h) x)","decl":"theorem mem_dite_empty_right (p : Prop) [Decidable p] (t : p → Set α) (x : α) :\n    (x ∈ if h : p then t h else ∅) ↔ ∃ h : p, x ∈ t h := by\n  simp only [mem_dite, mem_empty_iff_false, imp_false, not_not]\n  exact ⟨fun h => ⟨h.2, h.1 h.2⟩, fun ⟨h₁, h₂⟩ => ⟨fun _ => h₂, h₁⟩⟩\n\n"}
{"name":"Set.mem_ite_empty_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Set α\nx : α\n⊢ Iff (Membership.mem (ite p t EmptyCollection.emptyCollection) x) (And p (Membership.mem t x))","decl":"@[simp]\ntheorem mem_ite_empty_right (p : Prop) [Decidable p] (t : Set α) (x : α) :\n    x ∈ ite p t ∅ ↔ p ∧ x ∈ t :=\n  (mem_dite_empty_right p (fun _ => t) x).trans (by simp)\n\n"}
{"name":"Set.mem_dite_empty_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Not p → Set α\nx : α\n⊢ Iff (Membership.mem (dite p (fun h => EmptyCollection.emptyCollection) fun h => t h) x) (Exists fun h => Membership.mem (t h) x)","decl":"theorem mem_dite_empty_left (p : Prop) [Decidable p] (t : ¬p → Set α) (x : α) :\n    (x ∈ if h : p then ∅ else t h) ↔ ∃ h : ¬p, x ∈ t h := by\n  simp only [mem_dite, mem_empty_iff_false, imp_false]\n  exact ⟨fun h => ⟨h.1, h.2 h.1⟩, fun ⟨h₁, h₂⟩ => ⟨fun h => h₁ h, fun _ => h₂⟩⟩\n\n"}
{"name":"Set.mem_ite_empty_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\np : Prop\ninst✝ : Decidable p\nt : Set α\nx : α\n⊢ Iff (Membership.mem (ite p EmptyCollection.emptyCollection t) x) (And (Not p) (Membership.mem t x))","decl":"@[simp]\ntheorem mem_ite_empty_left (p : Prop) [Decidable p] (t : Set α) (x : α) :\n    x ∈ ite p ∅ t ↔ ¬p ∧ x ∈ t :=\n  (mem_dite_empty_left p (fun _ => t) x).trans (by simp)\n\n"}
{"name":"Set.ite_inter_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ Eq (Inter.inter (t.ite s s') t) (Inter.inter s t)","decl":"@[simp]\ntheorem ite_inter_self (t s s' : Set α) : t.ite s s' ∩ t = s ∩ t := by\n  rw [Set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]\n\n"}
{"name":"Set.ite_compl","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ Eq ((HasCompl.compl t).ite s s') (t.ite s' s)","decl":"@[simp]\ntheorem ite_compl (t s s' : Set α) : tᶜ.ite s s' = t.ite s' s := by\n  rw [Set.ite, Set.ite, diff_compl, union_comm, diff_eq]\n\n"}
{"name":"Set.ite_inter_compl_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ Eq (Inter.inter (t.ite s s') (HasCompl.compl t)) (Inter.inter s' (HasCompl.compl t))","decl":"@[simp]\ntheorem ite_inter_compl_self (t s s' : Set α) : t.ite s s' ∩ tᶜ = s' ∩ tᶜ := by\n  rw [← ite_compl, ite_inter_self]\n\n"}
{"name":"Set.ite_diff_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ Eq (SDiff.sdiff (t.ite s s') t) (SDiff.sdiff s' t)","decl":"@[simp]\ntheorem ite_diff_self (t s s' : Set α) : t.ite s s' \\ t = s' \\ t :=\n  ite_inter_compl_self t s s'\n\n"}
{"name":"Set.ite_same","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s : Set α\n⊢ Eq (t.ite s s) s","decl":"@[simp]\ntheorem ite_same (t s : Set α) : t.ite s s = s :=\n  inter_union_diff _ _\n\n"}
{"name":"Set.ite_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (s.ite s t) (Union.union s t)","decl":"@[simp]\ntheorem ite_left (s t : Set α) : s.ite s t = s ∪ t := by simp [Set.ite]\n\n"}
{"name":"Set.ite_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (s.ite t s) (Inter.inter t s)","decl":"@[simp]\ntheorem ite_right (s t : Set α) : s.ite t s = t ∩ s := by simp [Set.ite]\n\n"}
{"name":"Set.ite_empty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns s' : Set α\n⊢ Eq (EmptyCollection.emptyCollection.ite s s') s'","decl":"@[simp]\ntheorem ite_empty (s s' : Set α) : Set.ite ∅ s s' = s' := by simp [Set.ite]\n\n"}
{"name":"Set.ite_univ","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\ns s' : Set α\n⊢ Eq (Set.univ.ite s s') s","decl":"@[simp]\ntheorem ite_univ (s s' : Set α) : Set.ite univ s s' = s := by simp [Set.ite]\n\n"}
{"name":"Set.ite_empty_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s : Set α\n⊢ Eq (t.ite EmptyCollection.emptyCollection s) (SDiff.sdiff s t)","decl":"@[simp]\ntheorem ite_empty_left (t s : Set α) : t.ite ∅ s = s \\ t := by simp [Set.ite]\n\n"}
{"name":"Set.ite_empty_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s : Set α\n⊢ Eq (t.ite s EmptyCollection.emptyCollection) (Inter.inter s t)","decl":"@[simp]\ntheorem ite_empty_right (t s : Set α) : t.ite s ∅ = s ∩ t := by simp [Set.ite]\n\n"}
{"name":"Set.ite_mono","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₁' s₂ s₂' : Set α\nh : HasSubset.Subset s₁ s₂\nh' : HasSubset.Subset s₁' s₂'\n⊢ HasSubset.Subset (t.ite s₁ s₁') (t.ite s₂ s₂')","decl":"theorem ite_mono (t : Set α) {s₁ s₁' s₂ s₂' : Set α} (h : s₁ ⊆ s₂) (h' : s₁' ⊆ s₂') :\n    t.ite s₁ s₁' ⊆ t.ite s₂ s₂' :=\n  union_subset_union (inter_subset_inter_left _ h) (inter_subset_inter_left _ h')\n\n"}
{"name":"Set.ite_subset_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ HasSubset.Subset (t.ite s s') (Union.union s s')","decl":"theorem ite_subset_union (t s s' : Set α) : t.ite s s' ⊆ s ∪ s' :=\n  union_subset_union inter_subset_left diff_subset\n\n"}
{"name":"Set.inter_subset_ite","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' : Set α\n⊢ HasSubset.Subset (Inter.inter s s') (t.ite s s')","decl":"theorem inter_subset_ite (t s s' : Set α) : s ∩ s' ⊆ t.ite s s' :=\n  ite_same t (s ∩ s') ▸ ite_mono _ inter_subset_left inter_subset_right\n\n"}
{"name":"Set.ite_inter_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₂ s₁' s₂' : Set α\n⊢ Eq (t.ite (Inter.inter s₁ s₂) (Inter.inter s₁' s₂')) (Inter.inter (t.ite s₁ s₁') (t.ite s₂ s₂'))","decl":"theorem ite_inter_inter (t s₁ s₂ s₁' s₂' : Set α) :\n    t.ite (s₁ ∩ s₂) (s₁' ∩ s₂') = t.ite s₁ s₁' ∩ t.ite s₂ s₂' := by\n  ext x\n  simp only [Set.ite, Set.mem_inter_iff, Set.mem_diff, Set.mem_union]\n  tauto\n\n"}
{"name":"Set.ite_inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₂ s : Set α\n⊢ Eq (t.ite (Inter.inter s₁ s) (Inter.inter s₂ s)) (Inter.inter (t.ite s₁ s₂) s)","decl":"theorem ite_inter (t s₁ s₂ s : Set α) : t.ite (s₁ ∩ s) (s₂ ∩ s) = t.ite s₁ s₂ ∩ s := by\n  rw [ite_inter_inter, ite_same]\n\n"}
{"name":"Set.ite_inter_of_inter_eq","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₂ s : Set α\nh : Eq (Inter.inter s₁ s) (Inter.inter s₂ s)\n⊢ Eq (Inter.inter (t.ite s₁ s₂) s) (Inter.inter s₁ s)","decl":"theorem ite_inter_of_inter_eq (t : Set α) {s₁ s₂ s : Set α} (h : s₁ ∩ s = s₂ ∩ s) :\n    t.ite s₁ s₂ ∩ s = s₁ ∩ s := by rw [← ite_inter, ← h, ite_same]\n\n"}
{"name":"Set.subset_ite","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s s' u : Set α\n⊢ Iff (HasSubset.Subset u (t.ite s s')) (And (HasSubset.Subset (Inter.inter u t) s) (HasSubset.Subset (SDiff.sdiff u t) s'))","decl":"theorem subset_ite {t s s' u : Set α} : u ⊆ t.ite s s' ↔ u ∩ t ⊆ s ∧ u \\ t ⊆ s' := by\n  simp only [subset_def, ← forall_and]\n  refine forall_congr' fun x => ?_\n  by_cases hx : x ∈ t <;> simp [*, Set.ite]\n\n"}
{"name":"Set.ite_eq_of_subset_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₂ : Set α\nh : HasSubset.Subset s₁ s₂\n⊢ Eq (t.ite s₁ s₂) (Union.union s₁ (SDiff.sdiff s₂ t))","decl":"theorem ite_eq_of_subset_left (t : Set α) {s₁ s₂ : Set α} (h : s₁ ⊆ s₂) :\n    t.ite s₁ s₂ = s₁ ∪ (s₂ \\ t) := by\n  ext x\n  by_cases hx : x ∈ t <;> simp [*, Set.ite, or_iff_right_of_imp (@h x)]\n\n"}
{"name":"Set.ite_eq_of_subset_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nt s₁ s₂ : Set α\nh : HasSubset.Subset s₂ s₁\n⊢ Eq (t.ite s₁ s₂) (Union.union (Inter.inter s₁ t) s₂)","decl":"theorem ite_eq_of_subset_right (t : Set α) {s₁ s₂ : Set α} (h : s₂ ⊆ s₁) :\n    t.ite s₁ s₂ = (s₁ ∩ t) ∪ s₂ := by\n  ext x\n  by_cases hx : x ∈ t <;> simp [*, Set.ite, or_iff_left_of_imp (@h x)]\n\n"}
{"name":"Set.monotoneOn_iff_monotone","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (MonotoneOn f s) (Monotone fun a => f ↑a)","decl":"theorem monotoneOn_iff_monotone : MonotoneOn f s ↔\n    Monotone fun a : s => f a := by\n  simp [Monotone, MonotoneOn]\n\n"}
{"name":"Set.antitoneOn_iff_antitone","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (AntitoneOn f s) (Antitone fun a => f ↑a)","decl":"theorem antitoneOn_iff_antitone : AntitoneOn f s ↔\n    Antitone fun a : s => f a := by\n  simp [Antitone, AntitoneOn]\n\n"}
{"name":"Set.strictMonoOn_iff_strictMono","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMonoOn f s) (StrictMono fun a => f ↑a)","decl":"theorem strictMonoOn_iff_strictMono : StrictMonoOn f s ↔\n    StrictMono fun a : s => f a := by\n  simp [StrictMono, StrictMonoOn]\n\n"}
{"name":"Set.strictAntiOn_iff_strictAnti","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAntiOn f s) (StrictAnti fun a => f ↑a)","decl":"theorem strictAntiOn_iff_strictAnti : StrictAntiOn f s ↔\n    StrictAnti fun a : s => f a := by\n  simp [StrictAnti, StrictAntiOn]\n\n"}
{"name":"Set.not_monotoneOn_not_antitoneOn_iff_exists_le_le","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Iff (And (Not (MonotoneOn f s)) (Not (AntitoneOn f s))) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem s c) (And (LE.le a b) (And (LE.le b c) (Or (And (LT.lt (f a) (f b)) (LT.lt (f c) (f b))) (And (LT.lt (f b) (f a)) (LT.lt (f b) (f c)))))))))","decl":"/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\ntheorem not_monotoneOn_not_antitoneOn_iff_exists_le_le :\n    ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ᵉ (a ∈ s) (b ∈ s) (c ∈ s), a ≤ b ∧ b ≤ c ∧\n        (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by\n  simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ ∈ s)]\n\n"}
{"name":"Set.not_monotoneOn_not_antitoneOn_iff_exists_lt_lt","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Iff (And (Not (MonotoneOn f s)) (Not (AntitoneOn f s))) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem s c) (And (LT.lt a b) (And (LT.lt b c) (Or (And (LT.lt (f a) (f b)) (LT.lt (f c) (f b))) (And (LT.lt (f b) (f a)) (LT.lt (f b) (f c)))))))))","decl":"/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\ntheorem not_monotoneOn_not_antitoneOn_iff_exists_lt_lt :\n    ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ᵉ (a ∈ s) (b ∈ s) (c ∈ s), a < b ∧ b < c ∧\n        (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by\n  simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ ∈ s)]\n\n"}
{"name":"Function.Injective.nonempty_apply_iff","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Set α → Set β\nhf : Function.Injective f\nh2 : Eq (f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection\ns : Set α\n⊢ Iff (f s).Nonempty s.Nonempty","decl":"theorem Injective.nonempty_apply_iff {f : Set α → Set β} (hf : Injective f) (h2 : f ∅ = ∅)\n    {s : Set α} : (f s).Nonempty ↔ s.Nonempty := by\n  rw [nonempty_iff_ne_empty, ← h2, nonempty_iff_ne_empty, hf.ne_iff]\n\n"}
{"name":"Set.preimage_fst_singleton_eq_range","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\n⊢ Eq (Set.preimage Prod.fst (Singleton.singleton a)) (Set.range fun x => { fst := a, snd := x })","decl":"lemma preimage_fst_singleton_eq_range : (Prod.fst ⁻¹' {a} : Set (α × β)) = range (a, ·) := by\n  aesop\n\n"}
{"name":"Set.preimage_snd_singleton_eq_range","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\n⊢ Eq (Set.preimage Prod.snd (Singleton.singleton b)) (Set.range fun x => { fst := x, snd := b })","decl":"lemma preimage_snd_singleton_eq_range : (Prod.snd ⁻¹' {b} : Set (α × β)) = range (·, b) := by\n  aesop\n\n"}
{"name":"Set.inclusion_self","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns : Set α\nx : ↑s\n⊢ Eq (Set.inclusion ⋯ x) x","decl":"theorem inclusion_self (x : s) : inclusion Subset.rfl x = x := by\n  cases x\n  rfl\n\n"}
{"name":"Set.inclusion_eq_id","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns : Set α\nh : HasSubset.Subset s s\n⊢ Eq (Set.inclusion h) id","decl":"theorem inclusion_eq_id (h : s ⊆ s) : inclusion h = id :=\n  funext inclusion_self\n\n"}
{"name":"Set.inclusion_mk","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\na : α\nha : Membership.mem s a\n⊢ Eq (Set.inclusion h ⟨a, ha⟩) ⟨a, ⋯⟩","decl":"@[simp]\ntheorem inclusion_mk {h : s ⊆ t} (a : α) (ha : a ∈ s) : inclusion h ⟨a, ha⟩ = ⟨a, h ha⟩ :=\n  rfl\n\n"}
{"name":"Set.inclusion_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nx : ↑t\nm : Membership.mem s ↑x\n⊢ Eq (Set.inclusion h ⟨↑x, m⟩) x","decl":"theorem inclusion_right (h : s ⊆ t) (x : t) (m : (x : α) ∈ s) : inclusion h ⟨x, m⟩ = x := by\n  cases x\n  rfl\n\n"}
{"name":"Set.inclusion_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nhst : HasSubset.Subset s t\nhtu : HasSubset.Subset t u\nx : ↑s\n⊢ Eq (Set.inclusion htu (Set.inclusion hst x)) (Set.inclusion ⋯ x)","decl":"@[simp]\ntheorem inclusion_inclusion (hst : s ⊆ t) (htu : t ⊆ u) (x : s) :\n    inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x := by\n  cases x\n  rfl\n\n"}
{"name":"Set.inclusion_comp_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_2\ns t u : Set α\nhst : HasSubset.Subset s t\nhtu : HasSubset.Subset t u\n⊢ Eq (Function.comp (Set.inclusion htu) (Set.inclusion hst)) (Set.inclusion ⋯)","decl":"@[simp]\ntheorem inclusion_comp_inclusion {α} {s t u : Set α} (hst : s ⊆ t) (htu : t ⊆ u) :\n    inclusion htu ∘ inclusion hst = inclusion (hst.trans htu) :=\n  funext (inclusion_inclusion hst htu)\n\n"}
{"name":"Set.coe_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nx : ↑s\n⊢ Eq ↑(Set.inclusion h x) ↑x","decl":"@[simp]\ntheorem coe_inclusion (h : s ⊆ t) (x : s) : (inclusion h x : α) = (x : α) :=\n  rfl\n\n"}
{"name":"Set.val_comp_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (Function.comp Subtype.val (Set.inclusion h)) Subtype.val","decl":"theorem val_comp_inclusion (h : s ⊆ t) : Subtype.val ∘ inclusion h = Subtype.val :=\n  rfl\n\n"}
{"name":"Set.inclusion_injective","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Function.Injective (Set.inclusion h)","decl":"theorem inclusion_injective (h : s ⊆ t) : Injective (inclusion h)\n  | ⟨_, _⟩, ⟨_, _⟩ => Subtype.ext_iff_val.2 ∘ Subtype.ext_iff_val.1\n\n"}
{"name":"Set.inclusion_inj","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nx y : ↑s\n⊢ Iff (Eq (Set.inclusion h x) (Set.inclusion h y)) (Eq x y)","decl":"theorem inclusion_inj (h : s ⊆ t) {x y : s} : inclusion h x = inclusion h y ↔ x = y :=\n  (inclusion_injective h).eq_iff\n\n"}
{"name":"Set.eq_of_inclusion_surjective","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nh_surj : Function.Surjective (Set.inclusion h)\n⊢ Eq s t","decl":"theorem eq_of_inclusion_surjective {s t : Set α} {h : s ⊆ t}\n    (h_surj : Function.Surjective (inclusion h)) : s = t := by\n  refine Set.Subset.antisymm h (fun x hx => ?_)\n  obtain ⟨y, hy⟩ := h_surj ⟨x, hx⟩\n  exact mem_of_eq_of_mem (congr_arg Subtype.val hy).symm y.prop\n\n"}
{"name":"Set.inclusion_le_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\nx y : ↑s\n⊢ Iff (LE.le (Set.inclusion h x) (Set.inclusion h y)) (LE.le x y)","decl":"theorem inclusion_le_inclusion [Preorder α] {s t : Set α} (h : s ⊆ t) {x y : s} :\n    inclusion h x ≤ inclusion h y ↔ x ≤ y := Iff.rfl\n\n"}
{"name":"Set.inclusion_lt_inclusion","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\nx y : ↑s\n⊢ Iff (LT.lt (Set.inclusion h x) (Set.inclusion h y)) (LT.lt x y)","decl":"theorem inclusion_lt_inclusion [Preorder α] {s t : Set α} (h : s ⊆ t) {x y : s} :\n    inclusion h x < inclusion h y ↔ x < y := Iff.rfl\n\n"}
{"name":"Subsingleton.eq_univ_of_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\ns : Set α\na✝ : s.Nonempty\n⊢ Eq s Set.univ","decl":"theorem eq_univ_of_nonempty {s : Set α} : s.Nonempty → s = univ := fun ⟨x, hx⟩ =>\n  eq_univ_of_forall fun y => Subsingleton.elim x y ▸ hx\n\n"}
{"name":"Subsingleton.set_cases","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\np : Set α → Prop\nh0 : p EmptyCollection.emptyCollection\nh1 : p Set.univ\ns : Set α\n⊢ p s","decl":"@[elab_as_elim]\ntheorem set_cases {p : Set α → Prop} (h0 : p ∅) (h1 : p univ) (s) : p s :=\n  (s.eq_empty_or_nonempty.elim fun h => h.symm ▸ h0) fun h => (eq_univ_of_nonempty h).symm ▸ h1\n\n"}
{"name":"Subsingleton.mem_iff_nonempty","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Subsingleton α\ns : Set α\nx : α\n⊢ Iff (Membership.mem s x) s.Nonempty","decl":"theorem mem_iff_nonempty {α : Type*} [Subsingleton α] {s : Set α} {x : α} : x ∈ s ↔ s.Nonempty :=\n  ⟨fun hx => ⟨x, hx⟩, fun ⟨y, hy⟩ => Subsingleton.elim y x ▸ hy⟩\n\n"}
{"name":"Monotone.inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => Inter.inter (f x) (g x)","decl":"theorem Monotone.inter [Preorder β] {f g : β → Set α} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x ∩ g x :=\n  hf.inf hg\n\n"}
{"name":"MonotoneOn.inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\ns : Set β\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => Inter.inter (f x) (g x)) s","decl":"theorem MonotoneOn.inter [Preorder β] {f g : β → Set α} {s : Set β} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => f x ∩ g x) s :=\n  hf.inf hg\n\n"}
{"name":"Antitone.inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => Inter.inter (f x) (g x)","decl":"theorem Antitone.inter [Preorder β] {f g : β → Set α} (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x ∩ g x :=\n  hf.inf hg\n\n"}
{"name":"AntitoneOn.inter","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\ns : Set β\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => Inter.inter (f x) (g x)) s","decl":"theorem AntitoneOn.inter [Preorder β] {f g : β → Set α} {s : Set β} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => f x ∩ g x) s :=\n  hf.inf hg\n\n"}
{"name":"Monotone.union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => Union.union (f x) (g x)","decl":"theorem Monotone.union [Preorder β] {f g : β → Set α} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x ∪ g x :=\n  hf.sup hg\n\n"}
{"name":"MonotoneOn.union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\ns : Set β\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => Union.union (f x) (g x)) s","decl":"theorem MonotoneOn.union [Preorder β] {f g : β → Set α} {s : Set β} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => f x ∪ g x) s :=\n  hf.sup hg\n\n"}
{"name":"Antitone.union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => Union.union (f x) (g x)","decl":"theorem Antitone.union [Preorder β] {f g : β → Set α} (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x ∪ g x :=\n  hf.sup hg\n\n"}
{"name":"AntitoneOn.union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : β → Set α\ns : Set β\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => Union.union (f x) (g x)) s","decl":"theorem AntitoneOn.union [Preorder β] {f g : β → Set α} {s : Set β} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => f x ∪ g x) s :=\n  hf.sup hg\n\n"}
{"name":"Set.monotone_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\np : α → β → Prop\nhp : ∀ (b : β), Monotone fun a => p a b\n⊢ Monotone fun a => setOf fun b => p a b","decl":"theorem monotone_setOf [Preorder α] {p : α → β → Prop} (hp : ∀ b, Monotone fun a => p a b) :\n    Monotone fun a => { b | p a b } := fun _ _ h b => hp b h\n\n"}
{"name":"Set.antitone_setOf","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\np : α → β → Prop\nhp : ∀ (b : β), Antitone fun a => p a b\n⊢ Antitone fun a => setOf fun b => p a b","decl":"theorem antitone_setOf [Preorder α] {p : α → β → Prop} (hp : ∀ b, Antitone fun a => p a b) :\n    Antitone fun a => { b | p a b } := fun _ _ h b => hp b h\n\n"}
{"name":"Set.antitone_bforall","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\nP : α → Prop\n⊢ Antitone fun s => ∀ (x : α), Membership.mem s x → P x","decl":"/-- Quantifying over a set is antitone in the set -/\ntheorem antitone_bforall {P : α → Prop} : Antitone fun s : Set α => ∀ x ∈ s, P x :=\n  fun _ _ hst h x hx => h x <| hst hx\n\n"}
{"name":"Disjoint.union_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nhs : Disjoint s u\nht : Disjoint t u\n⊢ Disjoint (Union.union s t) u","decl":"theorem union_left (hs : Disjoint s u) (ht : Disjoint t u) : Disjoint (s ∪ t) u :=\n  hs.sup_left ht\n\n"}
{"name":"Disjoint.union_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nht : Disjoint s t\nhu : Disjoint s u\n⊢ Disjoint s (Union.union t u)","decl":"theorem union_right (ht : Disjoint s t) (hu : Disjoint s u) : Disjoint s (t ∪ u) :=\n  ht.sup_right hu\n\n"}
{"name":"Disjoint.inter_left","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : Disjoint s t\n⊢ Disjoint (Inter.inter s u) t","decl":"theorem inter_left (u : Set α) (h : Disjoint s t) : Disjoint (s ∩ u) t :=\n  h.inf_left _\n\n"}
{"name":"Disjoint.inter_left'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : Disjoint s t\n⊢ Disjoint (Inter.inter u s) t","decl":"theorem inter_left' (u : Set α) (h : Disjoint s t) : Disjoint (u ∩ s) t :=\n  h.inf_left' _\n\n"}
{"name":"Disjoint.inter_right","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : Disjoint s t\n⊢ Disjoint s (Inter.inter t u)","decl":"theorem inter_right (u : Set α) (h : Disjoint s t) : Disjoint s (t ∩ u) :=\n  h.inf_right _\n\n"}
{"name":"Disjoint.inter_right'","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : Disjoint s t\n⊢ Disjoint s (Inter.inter u t)","decl":"theorem inter_right' (u : Set α) (h : Disjoint s t) : Disjoint s (u ∩ t) :=\n  h.inf_right' _\n\n"}
{"name":"Disjoint.subset_left_of_subset_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : HasSubset.Subset s (Union.union t u)\nhac : Disjoint s u\n⊢ HasSubset.Subset s t","decl":"theorem subset_left_of_subset_union (h : s ⊆ t ∪ u) (hac : Disjoint s u) : s ⊆ t :=\n  hac.left_le_of_le_sup_right h\n\n"}
{"name":"Disjoint.subset_right_of_subset_union","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\ns t u : Set α\nh : HasSubset.Subset s (Union.union t u)\nhab : Disjoint s t\n⊢ HasSubset.Subset s u","decl":"theorem subset_right_of_subset_union (h : s ⊆ t ∪ u) (hab : Disjoint s t) : s ⊆ u :=\n  hab.left_le_of_le_sup_left h\n\n"}
{"name":"Prop.compl_singleton","module":"Mathlib.Data.Set.Basic","initialProofState":"p : Prop\n⊢ Eq (HasCompl.compl (Singleton.singleton p)) (Singleton.singleton (Not p))","decl":"@[simp] theorem Prop.compl_singleton (p : Prop) : ({p}ᶜ : Set Prop) = {¬p} :=\n  ext fun q ↦ by simpa [@Iff.comm q] using not_iff\n\n"}
{"name":"Equiv.setSubtypeComm_apply","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\np : α → Prop\ns : Set (Subtype fun a => p a)\n⊢ Eq ((Equiv.setSubtypeComm p) s) ⟨setOf fun a => Exists fun h => Membership.mem s ⟨a, h⟩, ⋯⟩","decl":"@[simp]\nprotected lemma setSubtypeComm_apply (p : α → Prop) (s : Set {a // p a}) :\n    (Equiv.setSubtypeComm p) s = ⟨{a | ∃ h : p a, ⟨a, h⟩ ∈ s}, fun _ h ↦ h.1⟩ :=\n  rfl\n\n"}
{"name":"Equiv.setSubtypeComm_symm_apply","module":"Mathlib.Data.Set.Basic","initialProofState":"α : Type u_1\np : α → Prop\ns : Subtype fun s => ∀ (a : α), Membership.mem s a → p a\n⊢ Eq ((Equiv.setSubtypeComm p).symm s) (setOf fun a => Membership.mem ↑s ↑a)","decl":"@[simp]\nprotected lemma setSubtypeComm_symm_apply (p : α → Prop) (s : {s // ∀ a ∈ s, p a}) :\n    (Equiv.setSubtypeComm p).symm s = {a | a.val ∈ s.val} :=\n  rfl\n\n"}
