{"name":"unique_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Unique α\ninst✝ : Zero α\n⊢ Eq Inhabited.default 0","decl":"@[to_additive]\ntheorem unique_one {α : Type*} [Unique α] [One α] : default = (1 : α) :=\n  Unique.default_eq 1\n\n"}
{"name":"unique_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Unique α\ninst✝ : One α\n⊢ Eq Inhabited.default 1","decl":"@[to_additive]\ntheorem unique_one {α : Type*} [Unique α] [One α] : default = (1 : α) :=\n  Unique.default_eq 1\n\n"}
{"name":"Units.mul_inv_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nb : Units α\n⊢ Eq (HMul.hMul (HMul.hMul a ↑b) ↑(Inv.inv b)) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a : α) (b : αˣ) : a * b * ↑b⁻¹ = a := by\n  rw [mul_assoc, mul_inv, mul_one]\n\n"}
{"name":"AddUnits.add_neg_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : α\nb : AddUnits α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a ↑b) ↑(Neg.neg b)) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a : α) (b : αˣ) : a * b * ↑b⁻¹ = a := by\n  rw [mul_assoc, mul_inv, mul_one]\n\n"}
{"name":"AddUnits.neg_add_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : α\nb : AddUnits α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a ↑(Neg.neg b)) ↑b) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a : α) (b : αˣ) : a * ↑b⁻¹ * b = a := by\n  rw [mul_assoc, inv_mul, mul_one]\n\n"}
{"name":"Units.inv_mul_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nb : Units α\n⊢ Eq (HMul.hMul (HMul.hMul a ↑(Inv.inv b)) ↑b) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a : α) (b : αˣ) : a * ↑b⁻¹ * b = a := by\n  rw [mul_assoc, inv_mul, mul_one]\n\n"}
{"name":"Units.mul_right_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nb c : α\n⊢ Iff (Eq (HMul.hMul (↑a) b) (HMul.hMul (↑a) c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : αˣ) {b c : α} : (a : α) * b = a * c ↔ b = c :=\n  ⟨fun h => by simpa only [inv_mul_cancel_left] using congr_arg (fun x : α => ↑(a⁻¹ : αˣ) * x) h,\n    congr_arg _⟩\n\n"}
{"name":"AddUnits.add_right_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nb c : α\n⊢ Iff (Eq (HAdd.hAdd (↑a) b) (HAdd.hAdd (↑a) c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : αˣ) {b c : α} : (a : α) * b = a * c ↔ b = c :=\n  ⟨fun h => by simpa only [inv_mul_cancel_left] using congr_arg (fun x : α => ↑(a⁻¹ : αˣ) * x) h,\n    congr_arg _⟩\n\n"}
{"name":"AddUnits.add_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : AddUnits α\nb c : α\n⊢ Iff (Eq (HAdd.hAdd b ↑a) (HAdd.hAdd c ↑a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : αˣ) {b c : α} : b * a = c * a ↔ b = c :=\n  ⟨fun h => by simpa only [mul_inv_cancel_right] using congr_arg (fun x : α => x * ↑(a⁻¹ : αˣ)) h,\n    congr_arg (· * a.val)⟩\n\n"}
{"name":"Units.mul_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : Units α\nb c : α\n⊢ Iff (Eq (HMul.hMul b ↑a) (HMul.hMul c ↑a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : αˣ) {b c : α} : b * a = c * a ↔ b = c :=\n  ⟨fun h => by simpa only [mul_inv_cancel_right] using congr_arg (fun x : α => x * ↑(a⁻¹ : αˣ)) h,\n    congr_arg (· * a.val)⟩\n\n"}
{"name":"Units.eq_mul_inv_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nc : Units α\na b : α\n⊢ Iff (Eq a (HMul.hMul b ↑(Inv.inv c))) (Eq (HMul.hMul a ↑c) b)","decl":"@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq {a b : α} : a = b * ↑c⁻¹ ↔ a * c = b :=\n  ⟨fun h => by rw [h, inv_mul_cancel_right], fun h => by rw [← h, mul_inv_cancel_right]⟩\n\n"}
{"name":"AddUnits.eq_add_neg_iff_add_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nc : AddUnits α\na b : α\n⊢ Iff (Eq a (HAdd.hAdd b ↑(Neg.neg c))) (Eq (HAdd.hAdd a ↑c) b)","decl":"@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq {a b : α} : a = b * ↑c⁻¹ ↔ a * c = b :=\n  ⟨fun h => by rw [h, inv_mul_cancel_right], fun h => by rw [← h, mul_inv_cancel_right]⟩\n\n"}
{"name":"Units.eq_inv_mul_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nb : Units α\na c : α\n⊢ Iff (Eq a (HMul.hMul (↑(Inv.inv b)) c)) (Eq (HMul.hMul (↑b) a) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq {a c : α} : a = ↑b⁻¹ * c ↔ ↑b * a = c :=\n  ⟨fun h => by rw [h, mul_inv_cancel_left], fun h => by rw [← h, inv_mul_cancel_left]⟩\n\n"}
{"name":"AddUnits.eq_neg_add_iff_add_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nb : AddUnits α\na c : α\n⊢ Iff (Eq a (HAdd.hAdd (↑(Neg.neg b)) c)) (Eq (HAdd.hAdd (↑b) a) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq {a c : α} : a = ↑b⁻¹ * c ↔ ↑b * a = c :=\n  ⟨fun h => by rw [h, mul_inv_cancel_left], fun h => by rw [← h, inv_mul_cancel_left]⟩\n\n"}
{"name":"Units.mul_inv_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nb : Units α\na c : α\n⊢ Iff (Eq (HMul.hMul a ↑(Inv.inv b)) c) (Eq a (HMul.hMul c ↑b))","decl":"@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul {a c : α} : a * ↑b⁻¹ = c ↔ a = c * b :=\n  ⟨fun h => by rw [← h, inv_mul_cancel_right], fun h => by rw [h, mul_inv_cancel_right]⟩\n\n-- Porting note: have to explicitly type annotate the 1\n"}
{"name":"AddUnits.add_neg_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nb : AddUnits α\na c : α\n⊢ Iff (Eq (HAdd.hAdd a ↑(Neg.neg b)) c) (Eq a (HAdd.hAdd c ↑b))","decl":"@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul {a c : α} : a * ↑b⁻¹ = c ↔ a = c * b :=\n  ⟨fun h => by rw [← h, inv_mul_cancel_right], fun h => by rw [h, mul_inv_cancel_right]⟩\n\n-- Porting note: have to explicitly type annotate the 1\n"}
{"name":"AddUnits.neg_eq_of_add_eq_zero_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (HAdd.hAdd a ↑u) 0\n⊢ Eq (↑(Neg.neg u)) a","decl":"@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_left {a : α} (h : a * u = 1) : ↑u⁻¹ = a :=\n  calc\n    ↑u⁻¹ = (1 : α) * ↑u⁻¹ := by rw [one_mul]\n    _ = a := by rw [← h, mul_inv_cancel_right]\n\n\n-- Porting note: have to explicitly type annotate the 1\n"}
{"name":"Units.inv_eq_of_mul_eq_one_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (HMul.hMul a ↑u) 1\n⊢ Eq (↑(Inv.inv u)) a","decl":"@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_left {a : α} (h : a * u = 1) : ↑u⁻¹ = a :=\n  calc\n    ↑u⁻¹ = (1 : α) * ↑u⁻¹ := by rw [one_mul]\n    _ = a := by rw [← h, mul_inv_cancel_right]\n\n\n-- Porting note: have to explicitly type annotate the 1\n"}
{"name":"AddUnits.neg_eq_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (HAdd.hAdd (↑u) a) 0\n⊢ Eq (↑(Neg.neg u)) a","decl":"@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_right {a : α} (h : ↑u * a = 1) : ↑u⁻¹ = a :=\n  calc\n    ↑u⁻¹ = ↑u⁻¹ * (1 : α) := by rw [mul_one]\n    _ = a := by rw [← h, inv_mul_cancel_left]\n\n\n"}
{"name":"Units.inv_eq_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (HMul.hMul (↑u) a) 1\n⊢ Eq (↑(Inv.inv u)) a","decl":"@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_right {a : α} (h : ↑u * a = 1) : ↑u⁻¹ = a :=\n  calc\n    ↑u⁻¹ = ↑u⁻¹ * (1 : α) := by rw [mul_one]\n    _ = a := by rw [← h, inv_mul_cancel_left]\n\n\n"}
{"name":"Units.eq_inv_of_mul_eq_one_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (HMul.hMul (↑u) a) 1\n⊢ Eq a ↑(Inv.inv u)","decl":"@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_left {a : α} (h : ↑u * a = 1) : a = ↑u⁻¹ :=\n  (Units.inv_eq_of_mul_eq_one_right h).symm\n\n"}
{"name":"AddUnits.eq_neg_of_add_eq_zero_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (HAdd.hAdd (↑u) a) 0\n⊢ Eq a ↑(Neg.neg u)","decl":"@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_left {a : α} (h : ↑u * a = 1) : a = ↑u⁻¹ :=\n  (Units.inv_eq_of_mul_eq_one_right h).symm\n\n"}
{"name":"AddUnits.eq_neg_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\nh : Eq (HAdd.hAdd a ↑u) 0\n⊢ Eq a ↑(Neg.neg u)","decl":"@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_right {a : α} (h : a * u = 1) : a = ↑u⁻¹ :=\n  (Units.inv_eq_of_mul_eq_one_left h).symm\n\n"}
{"name":"Units.eq_inv_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\nh : Eq (HMul.hMul a ↑u) 1\n⊢ Eq a ↑(Inv.inv u)","decl":"@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_right {a : α} (h : a * u = 1) : a = ↑u⁻¹ :=\n  (Units.inv_eq_of_mul_eq_one_left h).symm\n\n"}
{"name":"Units.mul_inv_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\n⊢ Iff (Eq (HMul.hMul a ↑(Inv.inv u)) 1) (Eq a ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_eq_one {a : α} : a * ↑u⁻¹ = 1 ↔ a = u :=\n  ⟨inv_inv u ▸ Units.eq_inv_of_mul_eq_one_right, fun h => mul_inv_of_eq h.symm⟩\n\n"}
{"name":"AddUnits.add_neg_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\n⊢ Iff (Eq (HAdd.hAdd a ↑(Neg.neg u)) 0) (Eq a ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_eq_one {a : α} : a * ↑u⁻¹ = 1 ↔ a = u :=\n  ⟨inv_inv u ▸ Units.eq_inv_of_mul_eq_one_right, fun h => mul_inv_of_eq h.symm⟩\n\n"}
{"name":"AddUnits.neg_add_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\n⊢ Iff (Eq (HAdd.hAdd (↑(Neg.neg u)) a) 0) (Eq (↑u) a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_eq_one {a : α} : ↑u⁻¹ * a = 1 ↔ ↑u = a :=\n  ⟨inv_inv u ▸ Units.inv_eq_of_mul_eq_one_right, inv_mul_of_eq⟩\n\n"}
{"name":"Units.inv_mul_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\n⊢ Iff (Eq (HMul.hMul (↑(Inv.inv u)) a) 1) (Eq (↑u) a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_eq_one {a : α} : ↑u⁻¹ * a = 1 ↔ ↑u = a :=\n  ⟨inv_inv u ▸ Units.inv_eq_of_mul_eq_one_right, inv_mul_of_eq⟩\n\n"}
{"name":"AddUnits.add_eq_zero_iff_eq_neg","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\n⊢ Iff (Eq (HAdd.hAdd a ↑u) 0) (Eq a ↑(Neg.neg u))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_eq_inv {a : α} : a * u = 1 ↔ a = ↑u⁻¹ := by rw [← mul_inv_eq_one, inv_inv]\n\n"}
{"name":"Units.mul_eq_one_iff_eq_inv","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\n⊢ Iff (Eq (HMul.hMul a ↑u) 1) (Eq a ↑(Inv.inv u))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_eq_inv {a : α} : a * u = 1 ↔ a = ↑u⁻¹ := by rw [← mul_inv_eq_one, inv_inv]\n\n"}
{"name":"AddUnits.add_eq_zero_iff_neg_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu : AddUnits α\na : α\n⊢ Iff (Eq (HAdd.hAdd (↑u) a) 0) (Eq (↑(Neg.neg u)) a)","decl":"@[to_additive]\ntheorem mul_eq_one_iff_inv_eq {a : α} : ↑u * a = 1 ↔ ↑u⁻¹ = a := by rw [← inv_mul_eq_one, inv_inv]\n\n"}
{"name":"Units.mul_eq_one_iff_inv_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na : α\n⊢ Iff (Eq (HMul.hMul (↑u) a) 1) (Eq (↑(Inv.inv u)) a)","decl":"@[to_additive]\ntheorem mul_eq_one_iff_inv_eq {a : α} : ↑u * a = 1 ↔ ↑u⁻¹ = a := by rw [← inv_mul_eq_one, inv_inv]\n\n"}
{"name":"AddUnits.neg_unique","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nu₁ u₂ : AddUnits α\nh : Eq ↑u₁ ↑u₂\n⊢ Eq ↑(Neg.neg u₁) ↑(Neg.neg u₂)","decl":"@[to_additive]\ntheorem inv_unique {u₁ u₂ : αˣ} (h : (↑u₁ : α) = ↑u₂) : (↑u₁⁻¹ : α) = ↑u₂⁻¹ :=\n  Units.inv_eq_of_mul_eq_one_right <| by rw [h, u₂.mul_inv]\n\n"}
{"name":"Units.inv_unique","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu₁ u₂ : Units α\nh : Eq ↑u₁ ↑u₂\n⊢ Eq ↑(Inv.inv u₁) ↑(Inv.inv u₂)","decl":"@[to_additive]\ntheorem inv_unique {u₁ u₂ : αˣ} (h : (↑u₁ : α) = ↑u₂) : (↑u₁⁻¹ : α) = ↑u₂⁻¹ :=\n  Units.inv_eq_of_mul_eq_one_right <| by rw [h, u₂.mul_inv]\n\n"}
{"name":"divp_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\na b : α\n⊢ Iff (Eq (divp a u) (divp b u)) (Eq a b)","decl":"@[simp]\ntheorem divp_left_inj (u : αˣ) {a b : α} : a /ₚ u = b /ₚ u ↔ a = b :=\n  Units.mul_left_inj _\n\n/- Porting note: to match the mathlib3 behavior, this needs to have higher simp\npriority than eq_divp_iff_mul_eq. -/\n"}
{"name":"divp_eq_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nx : α\nu : Units α\ny : α\n⊢ Iff (Eq (divp x u) y) (Eq (HMul.hMul y ↑u) x)","decl":"@[field_simps 1010]\ntheorem divp_eq_iff_mul_eq {x : α} {u : αˣ} {y : α} : x /ₚ u = y ↔ y * u = x :=\n  u.mul_left_inj.symm.trans <| by rw [divp_mul_cancel]; exact ⟨Eq.symm, Eq.symm⟩\n\n"}
{"name":"eq_divp_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nx : α\nu : Units α\ny : α\n⊢ Iff (Eq x (divp y u)) (Eq (HMul.hMul x ↑u) y)","decl":"@[field_simps]\ntheorem eq_divp_iff_mul_eq {x : α} {u : αˣ} {y : α} : x = y /ₚ u ↔ x * u = y := by\n  rw [eq_comm, divp_eq_iff_mul_eq]\n\n"}
{"name":"divp_eq_one_iff_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Iff (Eq (divp a u) 1) (Eq a ↑u)","decl":"theorem divp_eq_one_iff_eq {a : α} {u : αˣ} : a /ₚ u = 1 ↔ a = u :=\n  (Units.mul_left_inj u).symm.trans <| by rw [divp_mul_cancel, one_mul]\n\n"}
{"name":"inv_eq_one_divp'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nu : Units α\n⊢ Eq (↑(HDiv.hDiv 1 u)) (divp 1 u)","decl":"/-- Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`↑u⁻¹ = ↑(1 / u)`.\n-/\n@[field_simps]\ntheorem inv_eq_one_divp' (u : αˣ) : ((1 / u : αˣ) : α) = 1 /ₚ u := by\n  rw [one_div, one_divp]\n\n"}
{"name":"AddLeftCancelMonoid.eq_zero_of_add_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddLeftCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by\n    rw [← mul_left_cancel_iff (a := a), ← mul_assoc, h, one_mul, mul_one]) h) 1\n\n"}
{"name":"LeftCancelMonoid.eq_one_of_mul_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : LeftCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a 1","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by\n    rw [← mul_left_cancel_iff (a := a), ← mul_assoc, h, one_mul, mul_one]) h) 1\n\n"}
{"name":"AddLeftCancelMonoid.eq_zero_of_add_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddLeftCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_left (h : a * b = 1) : b = 1 := by\n  rwa [LeftCancelMonoid.eq_one_of_mul_right h, one_mul] at h\n\n"}
{"name":"LeftCancelMonoid.eq_one_of_mul_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : LeftCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b 1","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_left (h : a * b = 1) : b = 1 := by\n  rwa [LeftCancelMonoid.eq_one_of_mul_right h, one_mul] at h\n\n"}
{"name":"LeftCancelMonoid.mul_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : LeftCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Eq (HMul.hMul a b) 1) (And (Eq a 1) (Eq b 1))","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨LeftCancelMonoid.eq_one_of_mul_right h, LeftCancelMonoid.eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"AddLeftCancelMonoid.add_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddLeftCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨LeftCancelMonoid.eq_one_of_mul_right h, LeftCancelMonoid.eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"LeftCancelMonoid.mul_ne_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : LeftCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Ne (HMul.hMul a b) 1) (Or (Ne a 1) (Ne b 1))","decl":"@[to_additive]\nprotected theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"AddLeftCancelMonoid.add_ne_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddLeftCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Ne (HAdd.hAdd a b) 0) (Or (Ne a 0) (Ne b 0))","decl":"@[to_additive]\nprotected theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"RightCancelMonoid.eq_one_of_mul_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : RightCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a 1","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by\n    rw [← mul_right_cancel_iff (a := b), mul_assoc, h, one_mul, mul_one]) h) 1\n\n"}
{"name":"AddRightCancelMonoid.eq_zero_of_add_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddRightCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by\n    rw [← mul_right_cancel_iff (a := b), mul_assoc, h, one_mul, mul_one]) h) 1\n\n"}
{"name":"AddRightCancelMonoid.eq_zero_of_add_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddRightCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_left (h : a * b = 1) : b = 1 := by\n  rwa [RightCancelMonoid.eq_one_of_mul_right h, one_mul] at h\n\n"}
{"name":"RightCancelMonoid.eq_one_of_mul_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : RightCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b 1","decl":"@[to_additive]\nprotected theorem eq_one_of_mul_left (h : a * b = 1) : b = 1 := by\n  rwa [RightCancelMonoid.eq_one_of_mul_right h, one_mul] at h\n\n"}
{"name":"AddRightCancelMonoid.add_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddRightCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨RightCancelMonoid.eq_one_of_mul_right h, RightCancelMonoid.eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"RightCancelMonoid.mul_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : RightCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Eq (HMul.hMul a b) 1) (And (Eq a 1) (Eq b 1))","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨RightCancelMonoid.eq_one_of_mul_right h, RightCancelMonoid.eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"RightCancelMonoid.mul_ne_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : RightCancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Ne (HMul.hMul a b) 1) (Or (Ne a 1) (Ne b 1))","decl":"@[to_additive]\nprotected theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"AddRightCancelMonoid.add_ne_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddRightCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Ne (HAdd.hAdd a b) 0) (Or (Ne a 0) (Ne b 0))","decl":"@[to_additive]\nprotected theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"eq_zero_of_add_right'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_right' (h : a * b = 1) : a = 1 := LeftCancelMonoid.eq_one_of_mul_right h\n\n"}
{"name":"eq_one_of_mul_right'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_right' (h : a * b = 1) : a = 1 := LeftCancelMonoid.eq_one_of_mul_right h\n\n"}
{"name":"eq_zero_of_add_left'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_left' (h : a * b = 1) : b = 1 := LeftCancelMonoid.eq_one_of_mul_left h\n\n"}
{"name":"eq_one_of_mul_left'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_left' (h : a * b = 1) : b = 1 := LeftCancelMonoid.eq_one_of_mul_left h\n\n"}
{"name":"mul_eq_one'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Eq (HMul.hMul a b) 1) (And (Eq a 1) (Eq b 1))","decl":"@[to_additive]\ntheorem mul_eq_one' : a * b = 1 ↔ a = 1 ∧ b = 1 := LeftCancelMonoid.mul_eq_one\n\n"}
{"name":"add_eq_zero'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[to_additive]\ntheorem mul_eq_one' : a * b = 1 ↔ a = 1 ∧ b = 1 := LeftCancelMonoid.mul_eq_one\n\n"}
{"name":"mul_ne_one'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CancelMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Ne (HMul.hMul a b) 1) (Or (Ne a 1) (Ne b 1))","decl":"@[to_additive]\ntheorem mul_ne_one' : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := LeftCancelMonoid.mul_ne_one\n\n"}
{"name":"add_ne_zero'","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCancelMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Ne (HAdd.hAdd a b) 0) (Or (Ne a 0) (Ne b 0))","decl":"@[to_additive]\ntheorem mul_ne_one' : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := LeftCancelMonoid.mul_ne_one\n\n"}
{"name":"divp_mul_eq_mul_divp","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : CommMonoid α\nx y : α\nu : Units α\n⊢ Eq (HMul.hMul (divp x u) y) (divp (HMul.hMul x y) u)","decl":"@[field_simps]\ntheorem divp_mul_eq_mul_divp (x y : α) (u : αˣ) : x /ₚ u * y = x * y /ₚ u := by\n  rw [divp, divp, mul_right_comm]\n\n-- Theoretically redundant as `field_simp` lemma.\n"}
{"name":"divp_eq_divp_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : CommMonoid α\nx y : α\nux uy : Units α\n⊢ Iff (Eq (divp x ux) (divp y uy)) (Eq (HMul.hMul x ↑uy) (HMul.hMul y ↑ux))","decl":"@[field_simps]\ntheorem divp_eq_divp_iff {x y : α} {ux uy : αˣ} : x /ₚ ux = y /ₚ uy ↔ x * uy = y * ux := by\n  rw [divp_eq_iff_mul_eq, divp_mul_eq_mul_divp, divp_eq_iff_mul_eq]\n\n-- Theoretically redundant as `field_simp` lemma.\n"}
{"name":"divp_mul_divp","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : CommMonoid α\nx y : α\nux uy : Units α\n⊢ Eq (HMul.hMul (divp x ux) (divp y uy)) (divp (HMul.hMul x y) (HMul.hMul ux uy))","decl":"@[field_simps]\ntheorem divp_mul_divp (x y : α) (ux uy : αˣ) : x /ₚ ux * (y /ₚ uy) = x * y /ₚ (ux * uy) := by\n  rw [divp_mul_eq_mul_divp, divp_assoc', divp_divp_eq_divp_mul]\n\n"}
{"name":"eq_one_of_mul_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CommMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by rwa [mul_comm]) h) 1\n\n"}
{"name":"eq_zero_of_add_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_right (h : a * b = 1) : a = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ (by rwa [mul_comm]) h) 1\n\n"}
{"name":"eq_zero_of_add_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_left (h : a * b = 1) : b = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ h <| by rwa [mul_comm]) 1\n\n"}
{"name":"eq_one_of_mul_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CommMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_left (h : a * b = 1) : b = 1 :=\n  congr_arg Units.inv <| Subsingleton.elim (Units.mk _ _ h <| by rwa [mul_comm]) 1\n\n"}
{"name":"mul_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CommMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Eq (HMul.hMul a b) 1) (And (Eq a 1) (Eq b 1))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨eq_one_of_mul_right h, eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"add_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_one : a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  ⟨fun h => ⟨eq_one_of_mul_right h, eq_one_of_mul_left h⟩, by\n    rintro ⟨rfl, rfl⟩\n    exact mul_one _⟩\n\n"}
{"name":"add_ne_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Subsingleton (AddUnits α)\na b : α\n⊢ Iff (Ne (HAdd.hAdd a b) 0) (Or (Ne a 0) (Ne b 0))","decl":"@[to_additive] theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"mul_ne_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝¹ : CommMonoid α\ninst✝ : Subsingleton (Units α)\na b : α\n⊢ Iff (Ne (HMul.hMul a b) 1) (Or (Ne a 1) (Ne b 1))","decl":"@[to_additive] theorem mul_ne_one : a * b ≠ 1 ↔ a ≠ 1 ∨ b ≠ 1 := by rw [not_iff_comm]; simp\n\n"}
{"name":"isUnit_of_subsingleton","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton M\na : M\n⊢ IsUnit a","decl":"@[to_additive (attr := nontriviality)]\ntheorem isUnit_of_subsingleton [Monoid M] [Subsingleton M] (a : M) : IsUnit a :=\n  ⟨⟨a, a, by subsingleton, by subsingleton⟩, rfl⟩\n\n"}
{"name":"isAddUnit_of_subsingleton","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\ninst✝ : Subsingleton M\na : M\n⊢ IsAddUnit a","decl":"@[to_additive (attr := nontriviality)]\ntheorem isUnit_of_subsingleton [Monoid M] [Subsingleton M] (a : M) : IsUnit a :=\n  ⟨⟨a, a, by subsingleton, by subsingleton⟩, rfl⟩\n\n"}
{"name":"instCanLiftAddUnitsValIsAddUnit","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ CanLift M (AddUnits M) AddUnits.val IsAddUnit","decl":"@[to_additive]\ninstance [Monoid M] : CanLift M Mˣ Units.val IsUnit :=\n  { prf := fun _ ↦ id }\n\n"}
{"name":"instCanLiftUnitsValIsUnit","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ CanLift M (Units M) Units.val IsUnit","decl":"@[to_additive]\ninstance [Monoid M] : CanLift M Mˣ Units.val IsUnit :=\n  { prf := fun _ ↦ id }\n\n"}
{"name":"units_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton (Units M)\nu : Units M\n⊢ Eq u 1","decl":"theorem units_eq_one [Subsingleton Mˣ] (u : Mˣ) : u = 1 := by subsingleton\n\n"}
{"name":"IsAddUnit.add_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b c : M\nh : IsAddUnit a\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_left_inj (h : IsUnit a) : b * a = c * a ↔ b = c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ u.mul_left_inj\n\n"}
{"name":"IsUnit.mul_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : IsUnit a\n⊢ Iff (Eq (HMul.hMul b a) (HMul.hMul c a)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_left_inj (h : IsUnit a) : b * a = c * a ↔ b = c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ u.mul_left_inj\n\n"}
{"name":"IsUnit.mul_right_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : IsUnit a\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_right_inj (h : IsUnit a) : a * b = a * c ↔ b = c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ u.mul_right_inj\n\n"}
{"name":"IsAddUnit.add_right_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b c : M\nh : IsAddUnit a\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_right_inj (h : IsUnit a) : a * b = a * c ↔ b = c :=\n  let ⟨u, hu⟩ := h\n  hu ▸ u.mul_right_inj\n\n"}
{"name":"IsUnit.mul_left_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : IsUnit a\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"@[to_additive]\nprotected theorem mul_left_cancel (h : IsUnit a) : a * b = a * c → b = c :=\n  h.mul_right_inj.1\n\n"}
{"name":"IsAddUnit.add_left_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b c : M\nh : IsAddUnit a\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"@[to_additive]\nprotected theorem mul_left_cancel (h : IsUnit a) : a * b = a * c → b = c :=\n  h.mul_right_inj.1\n\n"}
{"name":"IsAddUnit.add_right_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b c : M\nh : IsAddUnit b\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"@[to_additive]\nprotected theorem mul_right_cancel (h : IsUnit b) : a * b = c * b → a = c :=\n  h.mul_left_inj.1\n\n"}
{"name":"IsUnit.mul_right_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : IsUnit b\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"@[to_additive]\nprotected theorem mul_right_cancel (h : IsUnit b) : a * b = c * b → a = c :=\n  h.mul_left_inj.1\n\n"}
{"name":"IsAddUnit.add_right_injective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nh : IsAddUnit a\n⊢ Function.Injective fun x => HAdd.hAdd a x","decl":"@[to_additive]\nprotected theorem mul_right_injective (h : IsUnit a) : Injective (a * ·) :=\n  fun _ _ => h.mul_left_cancel\n\n"}
{"name":"IsUnit.mul_right_injective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nh : IsUnit a\n⊢ Function.Injective fun x => HMul.hMul a x","decl":"@[to_additive]\nprotected theorem mul_right_injective (h : IsUnit a) : Injective (a * ·) :=\n  fun _ _ => h.mul_left_cancel\n\n"}
{"name":"IsAddUnit.add_left_injective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nb : M\nh : IsAddUnit b\n⊢ Function.Injective fun x => HAdd.hAdd x b","decl":"@[to_additive]\nprotected theorem mul_left_injective (h : IsUnit b) : Injective (· * b) :=\n  fun _ _ => h.mul_right_cancel\n\n"}
{"name":"IsUnit.mul_left_injective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nb : M\nh : IsUnit b\n⊢ Function.Injective fun x => HMul.hMul x b","decl":"@[to_additive]\nprotected theorem mul_left_injective (h : IsUnit b) : Injective (· * b) :=\n  fun _ _ => h.mul_right_cancel\n\n"}
{"name":"IsAddUnit.isAddUnit_iff_addLeft_bijective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\n⊢ Iff (IsAddUnit a) (Function.Bijective fun x => HAdd.hAdd a x)","decl":"@[to_additive]\ntheorem isUnit_iff_mulLeft_bijective {a : M} :\n    IsUnit a ↔ Function.Bijective (a * ·) :=\n  ⟨fun h ↦ ⟨h.mul_right_injective, fun y ↦ ⟨h.unit⁻¹ * y, by simp [← mul_assoc]⟩⟩, fun h ↦\n    ⟨⟨a, _, (h.2 1).choose_spec, h.1\n      (by simpa [mul_assoc] using congr_arg (· * a) (h.2 1).choose_spec)⟩, rfl⟩⟩\n\n"}
{"name":"IsUnit.isUnit_iff_mulLeft_bijective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (IsUnit a) (Function.Bijective fun x => HMul.hMul a x)","decl":"@[to_additive]\ntheorem isUnit_iff_mulLeft_bijective {a : M} :\n    IsUnit a ↔ Function.Bijective (a * ·) :=\n  ⟨fun h ↦ ⟨h.mul_right_injective, fun y ↦ ⟨h.unit⁻¹ * y, by simp [← mul_assoc]⟩⟩, fun h ↦\n    ⟨⟨a, _, (h.2 1).choose_spec, h.1\n      (by simpa [mul_assoc] using congr_arg (· * a) (h.2 1).choose_spec)⟩, rfl⟩⟩\n\n"}
{"name":"IsUnit.isUnit_iff_mulRight_bijective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (IsUnit a) (Function.Bijective fun x => HMul.hMul x a)","decl":"@[to_additive]\ntheorem isUnit_iff_mulRight_bijective {a : M} :\n    IsUnit a ↔ Function.Bijective (· * a) :=\n  ⟨fun h ↦ ⟨h.mul_left_injective, fun y ↦ ⟨y * h.unit⁻¹, by simp [mul_assoc]⟩⟩,\n    fun h ↦ ⟨⟨a, _, h.1 (by simpa [mul_assoc] using congr_arg (a * ·) (h.2 1).choose_spec),\n      (h.2 1).choose_spec⟩, rfl⟩⟩\n\n"}
{"name":"IsAddUnit.isAddUnit_iff_addRight_bijective","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\n⊢ Iff (IsAddUnit a) (Function.Bijective fun x => HAdd.hAdd x a)","decl":"@[to_additive]\ntheorem isUnit_iff_mulRight_bijective {a : M} :\n    IsUnit a ↔ Function.Bijective (· * a) :=\n  ⟨fun h ↦ ⟨h.mul_left_injective, fun y ↦ ⟨y * h.unit⁻¹, by simp [mul_assoc]⟩⟩,\n    fun h ↦ ⟨⟨a, _, h.1 (by simpa [mul_assoc] using congr_arg (a * ·) (h.2 1).choose_spec),\n      (h.2 1).choose_spec⟩, rfl⟩⟩\n\n"}
{"name":"IsAddUnit.add_neg_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb : α\nh : IsAddUnit b\na : α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (Neg.neg b)) a","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_inv_cancel_right (h : IsUnit b) (a : α) : a * b * b⁻¹ = a :=\n  h.unit'.mul_inv_cancel_right _\n\n"}
{"name":"IsUnit.mul_inv_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb : α\nh : IsUnit b\na : α\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv b)) a","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_inv_cancel_right (h : IsUnit b) (a : α) : a * b * b⁻¹ = a :=\n  h.unit'.mul_inv_cancel_right _\n\n"}
{"name":"IsAddUnit.neg_add_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb : α\nh : IsAddUnit b\na : α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a (Neg.neg b)) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma inv_mul_cancel_right (h : IsUnit b) (a : α) : a * b⁻¹ * b = a :=\n  h.unit'.inv_mul_cancel_right _\n\n"}
{"name":"IsUnit.inv_mul_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb : α\nh : IsUnit b\na : α\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv b)) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma inv_mul_cancel_right (h : IsUnit b) (a : α) : a * b⁻¹ * b = a :=\n  h.unit'.inv_mul_cancel_right _\n\n"}
{"name":"IsAddUnit.eq_add_neg_iff_add_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit c\n⊢ Iff (Eq a (HAdd.hAdd b (Neg.neg c))) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive]\nprotected lemma eq_mul_inv_iff_mul_eq (h : IsUnit c) : a = b * c⁻¹ ↔ a * c = b :=\n  h.unit'.eq_mul_inv_iff_mul_eq\n\n"}
{"name":"IsUnit.eq_mul_inv_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit c\n⊢ Iff (Eq a (HMul.hMul b (Inv.inv c))) (Eq (HMul.hMul a c) b)","decl":"@[to_additive]\nprotected lemma eq_mul_inv_iff_mul_eq (h : IsUnit c) : a = b * c⁻¹ ↔ a * c = b :=\n  h.unit'.eq_mul_inv_iff_mul_eq\n\n"}
{"name":"IsAddUnit.eq_neg_add_iff_add_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit b\n⊢ Iff (Eq a (HAdd.hAdd (Neg.neg b) c)) (Eq (HAdd.hAdd b a) c)","decl":"@[to_additive]\nprotected lemma eq_inv_mul_iff_mul_eq (h : IsUnit b) : a = b⁻¹ * c ↔ b * a = c :=\n  h.unit'.eq_inv_mul_iff_mul_eq\n\n"}
{"name":"IsUnit.eq_inv_mul_iff_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit b\n⊢ Iff (Eq a (HMul.hMul (Inv.inv b) c)) (Eq (HMul.hMul b a) c)","decl":"@[to_additive]\nprotected lemma eq_inv_mul_iff_mul_eq (h : IsUnit b) : a = b⁻¹ * c ↔ b * a = c :=\n  h.unit'.eq_inv_mul_iff_mul_eq\n\n"}
{"name":"IsAddUnit.neg_add_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit a\n⊢ Iff (Eq (HAdd.hAdd (Neg.neg a) b) c) (Eq b (HAdd.hAdd a c))","decl":"@[to_additive]\nprotected lemma inv_mul_eq_iff_eq_mul (h : IsUnit a) : a⁻¹ * b = c ↔ b = a * c :=\n  h.unit'.inv_mul_eq_iff_eq_mul\n\n"}
{"name":"IsUnit.inv_mul_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit a\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) c) (Eq b (HMul.hMul a c))","decl":"@[to_additive]\nprotected lemma inv_mul_eq_iff_eq_mul (h : IsUnit a) : a⁻¹ * b = c ↔ b = a * c :=\n  h.unit'.inv_mul_eq_iff_eq_mul\n\n"}
{"name":"IsUnit.mul_inv_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit b\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) c) (Eq a (HMul.hMul c b))","decl":"@[to_additive]\nprotected lemma mul_inv_eq_iff_eq_mul (h : IsUnit b) : a * b⁻¹ = c ↔ a = c * b :=\n  h.unit'.mul_inv_eq_iff_eq_mul\n\n"}
{"name":"IsAddUnit.add_neg_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit b\n⊢ Iff (Eq (HAdd.hAdd a (Neg.neg b)) c) (Eq a (HAdd.hAdd c b))","decl":"@[to_additive]\nprotected lemma mul_inv_eq_iff_eq_mul (h : IsUnit b) : a * b⁻¹ = c ↔ a = c * b :=\n  h.unit'.mul_inv_eq_iff_eq_mul\n\n"}
{"name":"IsUnit.mul_inv_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit b\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) 1) (Eq a b)","decl":"@[to_additive]\nprotected lemma mul_inv_eq_one (h : IsUnit b) : a * b⁻¹ = 1 ↔ a = b :=\n  @Units.mul_inv_eq_one _ _ h.unit' _\n\n"}
{"name":"IsAddUnit.add_neg_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit b\n⊢ Iff (Eq (HAdd.hAdd a (Neg.neg b)) 0) (Eq a b)","decl":"@[to_additive]\nprotected lemma mul_inv_eq_one (h : IsUnit b) : a * b⁻¹ = 1 ↔ a = b :=\n  @Units.mul_inv_eq_one _ _ h.unit' _\n\n"}
{"name":"IsUnit.inv_mul_eq_one","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit a\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) 1) (Eq a b)","decl":"@[to_additive]\nprotected lemma inv_mul_eq_one (h : IsUnit a) : a⁻¹ * b = 1 ↔ a = b :=\n  @Units.inv_mul_eq_one _ _ h.unit' _\n\n"}
{"name":"IsAddUnit.neg_add_eq_zero","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit a\n⊢ Iff (Eq (HAdd.hAdd (Neg.neg a) b) 0) (Eq a b)","decl":"@[to_additive]\nprotected lemma inv_mul_eq_one (h : IsUnit a) : a⁻¹ * b = 1 ↔ a = b :=\n  @Units.inv_mul_eq_one _ _ h.unit' _\n\n"}
{"name":"IsAddUnit.add_eq_zero_iff_eq_neg","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit b\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq a (Neg.neg b))","decl":"@[to_additive]\nprotected lemma mul_eq_one_iff_eq_inv (h : IsUnit b) : a * b = 1 ↔ a = b⁻¹ :=\n  @Units.mul_eq_one_iff_eq_inv _ _ h.unit' _\n\n"}
{"name":"IsUnit.mul_eq_one_iff_eq_inv","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit b\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq a (Inv.inv b))","decl":"@[to_additive]\nprotected lemma mul_eq_one_iff_eq_inv (h : IsUnit b) : a * b = 1 ↔ a = b⁻¹ :=\n  @Units.mul_eq_one_iff_eq_inv _ _ h.unit' _\n\n"}
{"name":"IsAddUnit.add_eq_zero_iff_neg_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit a\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq (Neg.neg a) b)","decl":"@[to_additive]\nprotected lemma mul_eq_one_iff_inv_eq (h : IsUnit a) : a * b = 1 ↔ a⁻¹ = b :=\n  @Units.mul_eq_one_iff_inv_eq _ _ h.unit' _\n\n"}
{"name":"IsUnit.mul_eq_one_iff_inv_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit a\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq (Inv.inv a) b)","decl":"@[to_additive]\nprotected lemma mul_eq_one_iff_inv_eq (h : IsUnit a) : a * b = 1 ↔ a⁻¹ = b :=\n  @Units.mul_eq_one_iff_inv_eq _ _ h.unit' _\n\n"}
{"name":"IsAddUnit.sub_add_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb : α\nh : IsAddUnit b\na : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma div_mul_cancel (h : IsUnit b) (a : α) : a / b * b = a := by\n  rw [div_eq_mul_inv, h.inv_mul_cancel_right]\n\n"}
{"name":"IsUnit.div_mul_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb : α\nh : IsUnit b\na : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma div_mul_cancel (h : IsUnit b) (a : α) : a / b * b = a := by\n  rw [div_eq_mul_inv, h.inv_mul_cancel_right]\n\n"}
{"name":"IsAddUnit.add_sub_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb : α\nh : IsAddUnit b\na : α\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_div_cancel_right (h : IsUnit b) (a : α) : a * b / b = a := by\n  rw [div_eq_mul_inv, h.mul_inv_cancel_right]\n\n"}
{"name":"IsUnit.mul_div_cancel_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb : α\nh : IsUnit b\na : α\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"@[to_additive (attr := simp)]\nprotected lemma mul_div_cancel_right (h : IsUnit b) (a : α) : a * b / b = a := by\n  rw [div_eq_mul_inv, h.mul_inv_cancel_right]\n\n"}
{"name":"IsAddUnit.add_zero_sub_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ Eq (HAdd.hAdd a (HSub.hSub 0 a)) 0","decl":"@[to_additive]\nprotected lemma mul_one_div_cancel (h : IsUnit a) : a * (1 / a) = 1 := by simp [h]\n\n"}
{"name":"IsUnit.mul_one_div_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ Eq (HMul.hMul a (HDiv.hDiv 1 a)) 1","decl":"@[to_additive]\nprotected lemma mul_one_div_cancel (h : IsUnit a) : a * (1 / a) = 1 := by simp [h]\n\n"}
{"name":"IsAddUnit.zero_sub_add_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na : α\nh : IsAddUnit a\n⊢ Eq (HAdd.hAdd (HSub.hSub 0 a) a) 0","decl":"@[to_additive]\nprotected lemma one_div_mul_cancel (h : IsUnit a) : 1 / a * a = 1 := by simp [h]\n\n"}
{"name":"IsUnit.one_div_mul_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na : α\nh : IsUnit a\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 a) a) 1","decl":"@[to_additive]\nprotected lemma one_div_mul_cancel (h : IsUnit a) : 1 / a * a = 1 := by simp [h]\n\n"}
{"name":"IsUnit.div_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit c\n⊢ Iff (Eq (HDiv.hDiv a c) (HDiv.hDiv b c)) (Eq a b)","decl":"@[to_additive]\nprotected lemma div_left_inj (h : IsUnit c) : a / c = b / c ↔ a = b := by\n  simp only [div_eq_mul_inv]\n  exact Units.mul_left_inj h.inv.unit'\n\n"}
{"name":"IsAddUnit.sub_left_inj","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit c\n⊢ Iff (Eq (HSub.hSub a c) (HSub.hSub b c)) (Eq a b)","decl":"@[to_additive]\nprotected lemma div_left_inj (h : IsUnit c) : a / c = b / c ↔ a = b := by\n  simp only [div_eq_mul_inv]\n  exact Units.mul_left_inj h.inv.unit'\n\n"}
{"name":"IsAddUnit.sub_eq_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit b\n⊢ Iff (Eq (HSub.hSub a b) c) (Eq a (HAdd.hAdd c b))","decl":"@[to_additive]\nprotected lemma div_eq_iff (h : IsUnit b) : a / b = c ↔ a = c * b := by\n  rw [div_eq_mul_inv, h.mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"IsUnit.div_eq_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit b\n⊢ Iff (Eq (HDiv.hDiv a b) c) (Eq a (HMul.hMul c b))","decl":"@[to_additive]\nprotected lemma div_eq_iff (h : IsUnit b) : a / b = c ↔ a = c * b := by\n  rw [div_eq_mul_inv, h.mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"IsUnit.eq_div_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit c\n⊢ Iff (Eq a (HDiv.hDiv b c)) (Eq (HMul.hMul a c) b)","decl":"@[to_additive]\nprotected lemma eq_div_iff (h : IsUnit c) : a = b / c ↔ a * c = b := by\n  rw [div_eq_mul_inv, h.eq_mul_inv_iff_mul_eq]\n\n"}
{"name":"IsAddUnit.eq_sub_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit c\n⊢ Iff (Eq a (HSub.hSub b c)) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive]\nprotected lemma eq_div_iff (h : IsUnit c) : a = b / c ↔ a * c = b := by\n  rw [div_eq_mul_inv, h.eq_mul_inv_iff_mul_eq]\n\n"}
{"name":"IsAddUnit.sub_eq_of_eq_add","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit b\na✝ : Eq a (HAdd.hAdd c b)\n⊢ Eq (HSub.hSub a b) c","decl":"@[to_additive]\nprotected lemma div_eq_of_eq_mul (h : IsUnit b) : a = c * b → a / b = c :=\n  h.div_eq_iff.2\n\n"}
{"name":"IsUnit.div_eq_of_eq_mul","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit b\na✝ : Eq a (HMul.hMul c b)\n⊢ Eq (HDiv.hDiv a b) c","decl":"@[to_additive]\nprotected lemma div_eq_of_eq_mul (h : IsUnit b) : a = c * b → a / b = c :=\n  h.div_eq_iff.2\n\n"}
{"name":"IsUnit.eq_div_of_mul_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b c : α\nh : IsUnit c\na✝ : Eq (HMul.hMul a c) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"@[to_additive]\nprotected lemma eq_div_of_mul_eq (h : IsUnit c) : a * c = b → a = b / c :=\n  h.eq_div_iff.2\n\n"}
{"name":"IsAddUnit.eq_sub_of_add_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b c : α\nh : IsAddUnit c\na✝ : Eq (HAdd.hAdd a c) b\n⊢ Eq a (HSub.hSub b c)","decl":"@[to_additive]\nprotected lemma eq_div_of_mul_eq (h : IsUnit c) : a * c = b → a = b / c :=\n  h.eq_div_iff.2\n\n"}
{"name":"IsUnit.div_eq_one_iff_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit b\n⊢ Iff (Eq (HDiv.hDiv a b) 1) (Eq a b)","decl":"@[to_additive]\nprotected lemma div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 ↔ a = b :=\n  ⟨eq_of_div_eq_one, fun hab => hab.symm ▸ h.div_self⟩\n\n"}
{"name":"IsAddUnit.sub_eq_zero_iff_eq","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit b\n⊢ Iff (Eq (HSub.hSub a b) 0) (Eq a b)","decl":"@[to_additive]\nprotected lemma div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 ↔ a = b :=\n  ⟨eq_of_div_eq_one, fun hab => hab.symm ▸ h.div_self⟩\n\n"}
{"name":"IsUnit.div_mul_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\na b : α\nh : IsUnit b\n⊢ Eq (HDiv.hDiv b (HMul.hMul a b)) (HDiv.hDiv 1 a)","decl":"@[to_additive]\nprotected lemma div_mul_left (h : IsUnit b) : b / (a * b) = 1 / a := by\n  rw [h.div_mul_cancel_right, one_div]\n\n"}
{"name":"IsAddUnit.sub_add_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\na b : α\nh : IsAddUnit b\n⊢ Eq (HSub.hSub b (HAdd.hAdd a b)) (HSub.hSub 0 a)","decl":"@[to_additive]\nprotected lemma div_mul_left (h : IsUnit b) : b / (a * b) = 1 / a := by\n  rw [h.div_mul_cancel_right, one_div]\n\n"}
{"name":"IsAddUnit.add_add_sub","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionMonoid α\nb a : α\nh : IsAddUnit b\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (HSub.hSub 0 b)) a","decl":"@[to_additive]\nprotected lemma mul_mul_div (a : α) (h : IsUnit b) : a * b * (1 / b) = a := by simp [h]\n\n"}
{"name":"IsUnit.mul_mul_div","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionMonoid α\nb a : α\nh : IsUnit b\n⊢ Eq (HMul.hMul (HMul.hMul a b) (HDiv.hDiv 1 b)) a","decl":"@[to_additive]\nprotected lemma mul_mul_div (a : α) (h : IsUnit b) : a * b * (1 / b) = a := by simp [h]\n\n"}
{"name":"IsAddUnit.sub_add_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HSub.hSub a (HAdd.hAdd a b)) (HSub.hSub 0 b)","decl":"@[to_additive]\nprotected lemma div_mul_right (h : IsUnit a) (b : α) : a / (a * b) = 1 / b := by\n  rw [mul_comm, h.div_mul_left]\n\n"}
{"name":"IsUnit.div_mul_right","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HDiv.hDiv a (HMul.hMul a b)) (HDiv.hDiv 1 b)","decl":"@[to_additive]\nprotected lemma div_mul_right (h : IsUnit a) (b : α) : a / (a * b) = 1 / b := by\n  rw [mul_comm, h.div_mul_left]\n\n"}
{"name":"IsUnit.mul_div_cancel_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) a) b","decl":"@[to_additive]\nprotected lemma mul_div_cancel_left (h : IsUnit a) (b : α) : a * b / a = b := by\n  rw [mul_comm, h.mul_div_cancel_right]\n\n"}
{"name":"IsAddUnit.add_sub_cancel_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) a) b","decl":"@[to_additive]\nprotected lemma mul_div_cancel_left (h : IsUnit a) (b : α) : a * b / a = b := by\n  rw [mul_comm, h.mul_div_cancel_right]\n\n"}
{"name":"IsUnit.mul_div_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na : α\nh : IsUnit a\nb : α\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"@[to_additive]\nprotected lemma mul_div_cancel (h : IsUnit a) (b : α) : a * (b / a) = b := by\n  rw [mul_comm, h.div_mul_cancel]\n\n"}
{"name":"IsAddUnit.add_sub_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na : α\nh : IsAddUnit a\nb : α\n⊢ Eq (HAdd.hAdd a (HSub.hSub b a)) b","decl":"@[to_additive]\nprotected lemma mul_div_cancel (h : IsUnit a) (b : α) : a * (b / a) = b := by\n  rw [mul_comm, h.div_mul_cancel]\n\n"}
{"name":"IsUnit.mul_eq_mul_of_div_eq_div","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\nb d : α\nhb : IsUnit b\nhd : IsUnit d\na c : α\nh : Eq (HDiv.hDiv a b) (HDiv.hDiv c d)\n⊢ Eq (HMul.hMul a d) (HMul.hMul c b)","decl":"@[to_additive]\nprotected lemma mul_eq_mul_of_div_eq_div (hb : IsUnit b) (hd : IsUnit d)\n    (a c : α) (h : a / b = c / d) : a * d = c * b := by\n  rw [← mul_one a, ← hb.div_self, ← mul_comm_div, h, div_mul_eq_mul_div, hd.div_mul_cancel]\n\n"}
{"name":"IsAddUnit.add_eq_add_of_sub_eq_sub","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\nb d : α\nhb : IsAddUnit b\nhd : IsAddUnit d\na c : α\nh : Eq (HSub.hSub a b) (HSub.hSub c d)\n⊢ Eq (HAdd.hAdd a d) (HAdd.hAdd c b)","decl":"@[to_additive]\nprotected lemma mul_eq_mul_of_div_eq_div (hb : IsUnit b) (hd : IsUnit d)\n    (a c : α) (h : a / b = c / d) : a * d = c * b := by\n  rw [← mul_one a, ← hb.div_self, ← mul_comm_div, h, div_mul_eq_mul_div, hd.div_mul_cancel]\n\n"}
{"name":"IsUnit.div_eq_div_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na b c d : α\nhb : IsUnit b\nhd : IsUnit d\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HMul.hMul a d) (HMul.hMul c b))","decl":"@[to_additive]\nprotected lemma div_eq_div_iff (hb : IsUnit b) (hd : IsUnit d) :\n    a / b = c / d ↔ a * d = c * b := by\n  rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, mul_right_comm,\n    hd.div_mul_cancel]\n\n"}
{"name":"IsAddUnit.sub_eq_sub_iff","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na b c d : α\nhb : IsAddUnit b\nhd : IsAddUnit d\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub c d)) (Eq (HAdd.hAdd a d) (HAdd.hAdd c b))","decl":"@[to_additive]\nprotected lemma div_eq_div_iff (hb : IsUnit b) (hd : IsUnit d) :\n    a / b = c / d ↔ a * d = c * b := by\n  rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, mul_right_comm,\n    hd.div_mul_cancel]\n\n"}
{"name":"IsAddUnit.sub_sub_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na b : α\nh : IsAddUnit a\n⊢ Eq (HSub.hSub a (HSub.hSub a b)) b","decl":"@[to_additive]\nprotected lemma div_div_cancel (h : IsUnit a) : a / (a / b) = b := by\n  rw [div_div_eq_mul_div, h.mul_div_cancel_left]\n\n"}
{"name":"IsUnit.div_div_cancel","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na b : α\nh : IsUnit a\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a b)) b","decl":"@[to_additive]\nprotected lemma div_div_cancel (h : IsUnit a) : a / (a / b) = b := by\n  rw [div_div_eq_mul_div, h.mul_div_cancel_left]\n\n"}
{"name":"IsAddUnit.sub_sub_cancel_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : SubtractionCommMonoid α\na b : α\nh : IsAddUnit a\n⊢ Eq (HSub.hSub (HSub.hSub a b) a) (Neg.neg b)","decl":"@[to_additive]\nprotected lemma div_div_cancel_left (h : IsUnit a) : a / b / a = b⁻¹ := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_right_comm, h.mul_inv_cancel, one_mul]\n\n"}
{"name":"IsUnit.div_div_cancel_left","module":"Mathlib.Algebra.Group.Units.Basic","initialProofState":"α : Type u\ninst✝ : DivisionCommMonoid α\na b : α\nh : IsUnit a\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) a) (Inv.inv b)","decl":"@[to_additive]\nprotected lemma div_div_cancel_left (h : IsUnit a) : a / b / a = b⁻¹ := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_right_comm, h.mul_inv_cancel, one_mul]\n\n"}
