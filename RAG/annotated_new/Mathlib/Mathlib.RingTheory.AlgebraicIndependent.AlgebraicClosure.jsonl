{"name":"AlgebraicIndependent.extendScalars","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nx : ι → A\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : NoZeroDivisors S\nhx : AlgebraicIndependent R x\nalg : Algebra.IsAlgebraic R S\ninj : Function.Injective ⇑(algebraMap S A)\n⊢ AlgebraicIndependent S x","decl":"theorem extendScalars [alg : Algebra.IsAlgebraic R S]\n    (inj : Injective (algebraMap S A)) : AlgebraicIndependent S x := by\n  nontriviality S\n  have := inj.nontrivial\n  refine algebraicIndependent_of_finite_type' inj fun t fin ind i hi ↦ ?_\n  let Rt := adjoin R (x '' t)\n  let St := adjoin S (x '' t)\n  let _ : Algebra Rt St :=\n    (Rt.inclusion (T := St.restrictScalars R) <| adjoin_le <| by exact subset_adjoin).toAlgebra\n  have : IsScalarTower Rt St A := .of_algebraMap_eq fun ⟨y, _⟩ ↦ show y = y from rfl\n  have : NoZeroDivisors St := (Set.image_eq_range _ _ ▸ ind.aevalEquiv)\n    |>.symm.injective.noZeroDivisors _ (map_zero _) (map_mul _)\n  have : NoZeroDivisors Rt := (Subalgebra.inclusion_injective _).noZeroDivisors\n    (algebraMap Rt St) (map_zero _) (map_mul _)\n  have : Algebra.IsAlgebraic Rt St := ⟨fun ⟨y, hy⟩ ↦ by\n    rw [← isAlgebraic_algHom_iff (IsScalarTower.toAlgHom Rt St A) Subtype.val_injective]\n    show IsAlgebraic Rt y\n    exact adjoin_induction (fun _ h ↦ isAlgebraic_algebraMap (⟨_, subset_adjoin h⟩ : Rt))\n      (fun z ↦ ((alg.1 z).algHom (IsScalarTower.toAlgHom R S A)).extendScalars fun _ _ eq ↦ by\n        exact hx.algebraMap_injective congr($eq.1)) (fun _ _ _ _ ↦ .add) (fun _ _ _ _ ↦ .mul) hy⟩\n  show Transcendental St (x i)\n  exact (hx.transcendental_adjoin hi).extendScalars Subtype.val_injective\n\n"}
{"name":"AlgebraicIndependent.extendScalars_of_isSimpleRing","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nx : ι → A\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra S A\ninst✝³ : IsScalarTower R S A\ninst✝² : NoZeroDivisors S\nhx : AlgebraicIndependent R x\ninst✝¹ : Algebra.IsAlgebraic R S\ninst✝ : IsSimpleRing S\n⊢ AlgebraicIndependent S x","decl":"theorem extendScalars_of_isSimpleRing [Algebra.IsAlgebraic R S] [IsSimpleRing S] :\n    AlgebraicIndependent S x :=\n  hx.extendScalars <|\n    have := Module.nontrivial R S\n    have := hx.algebraMap_injective.nontrivial\n    RingHom.injective _\n\n"}
{"name":"AlgebraicIndependent.extendScalars_of_isIntegral","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nx : ι → A\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : NoZeroDivisors S\nhx : AlgebraicIndependent R x\ninst✝ : Algebra.IsIntegral R S\ninj : Function.Injective ⇑(algebraMap S A)\n⊢ AlgebraicIndependent S x","decl":"theorem extendScalars_of_isIntegral [Algebra.IsIntegral R S]\n    (inj : Injective (algebraMap S A)) : AlgebraicIndependent S x := by\n  nontriviality S\n  have := Module.nontrivial R S\n  exact hx.extendScalars inj\n\n"}
{"name":"AlgebraicIndependent.subalgebra","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_4\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\nhx : AlgebraicIndependent R x\nS : Subalgebra R A\ninst✝¹ : NoZeroDivisors A\ninst✝ : Algebra.IsAlgebraic R (Subtype fun x => Membership.mem S x)\n⊢ AlgebraicIndependent (Subtype fun x => Membership.mem S x) x","decl":"protected theorem subalgebra (S : Subalgebra R A) [NoZeroDivisors A] [Algebra.IsAlgebraic R S] :\n    AlgebraicIndependent S x :=\n  hx.extendScalars Subtype.val_injective\n\n"}
{"name":"AlgebraicIndependent.subalgebra_of_isIntegral","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_4\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\nhx : AlgebraicIndependent R x\nS : Subalgebra R A\ninst✝¹ : NoZeroDivisors A\ninst✝ : Algebra.IsIntegral R (Subtype fun x => Membership.mem S x)\n⊢ AlgebraicIndependent (Subtype fun x => Membership.mem S x) x","decl":"theorem subalgebra_of_isIntegral (S : Subalgebra R A) [NoZeroDivisors A] [Algebra.IsIntegral R S] :\n    AlgebraicIndependent S x :=\n  hx.extendScalars_of_isIntegral Subtype.val_injective\n\n"}
{"name":"AlgebraicIndependent.subalgebraAlgebraicClosure","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_4\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝¹ : IsDomain R\ninst✝ : NoZeroDivisors A\n⊢ AlgebraicIndependent (Subtype fun x => Membership.mem (Subalgebra.algebraicClosure R A) x) x","decl":"theorem subalgebraAlgebraicClosure [IsDomain R] [NoZeroDivisors A] :\n    AlgebraicIndependent (Subalgebra.algebraicClosure R A) x :=\n  hx.subalgebra _\n\n"}
{"name":"AlgebraicIndependent.integralClosure","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_4\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : NoZeroDivisors A\n⊢ AlgebraicIndependent (Subtype fun x => Membership.mem (integralClosure R A) x) x","decl":"protected theorem integralClosure [NoZeroDivisors A] :\n    AlgebraicIndependent (integralClosure R A) x :=\n  hx.subalgebra_of_isIntegral _\n\n"}
{"name":"AlgebraicIndependent.algebraicClosure","module":"Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure","initialProofState":"ι : Type u_1\nF : Type u_5\nE : Type u_6\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : ι → E\nhx : AlgebraicIndependent F x\n⊢ AlgebraicIndependent (Subtype fun x => Membership.mem (algebraicClosure F E) x) x","decl":"omit hx in\nprotected theorem algebraicClosure {F E : Type*} [Field F] [Field E] [Algebra F E] {x : ι → E}\n    (hx : AlgebraicIndependent F x) : AlgebraicIndependent (algebraicClosure F E) x :=\n  hx.extendScalars_of_isSimpleRing\n\n"}
