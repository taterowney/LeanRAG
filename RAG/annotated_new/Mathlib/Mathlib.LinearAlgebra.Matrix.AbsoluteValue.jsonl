{"name":"Matrix.det_le","module":"Mathlib.LinearAlgebra.Matrix.AbsoluteValue","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Nontrivial R\ninst✝² : LinearOrderedCommRing S\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n R\nabv : AbsoluteValue R S\nx : S\nhx : ∀ (i j : n), LE.le (abv (A i j)) x\n⊢ LE.le (abv A.det) (HSMul.hSMul (Fintype.card n).factorial (HPow.hPow x (Fintype.card n)))","decl":"theorem det_le {A : Matrix n n R} {abv : AbsoluteValue R S} {x : S} (hx : ∀ i j, abv (A i j) ≤ x) :\n    abv A.det ≤ Nat.factorial (Fintype.card n) • x ^ Fintype.card n :=\n  calc\n    abv A.det = abv (∑ σ : Perm n, Perm.sign σ • ∏ i, A (σ i) i) := congr_arg abv (det_apply _)\n    _ ≤ ∑ σ : Perm n, abv (Perm.sign σ • ∏ i, A (σ i) i) := abv.sum_le _ _\n    _ = ∑ σ : Perm n, ∏ i, abv (A (σ i) i) :=\n      (sum_congr rfl fun σ _ => by rw [abv.map_units_int_smul, abv.map_prod])\n    _ ≤ ∑ _σ : Perm n, ∏ _i : n, x :=\n      (sum_le_sum fun _ _ => prod_le_prod (fun _ _ => abv.nonneg _) fun _ _ => hx _ _)\n    _ = ∑ _σ : Perm n, x ^ Fintype.card n :=\n      (sum_congr rfl fun _ _ => by rw [prod_const, Finset.card_univ])\n    _ = Nat.factorial (Fintype.card n) • x ^ Fintype.card n := by\n      rw [sum_const, Finset.card_univ, Fintype.card_perm]\n\n"}
{"name":"Matrix.det_sum_le","module":"Mathlib.LinearAlgebra.Matrix.AbsoluteValue","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Nontrivial R\ninst✝² : LinearOrderedCommRing S\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nι : Type u_4\ns : Finset ι\nA : ι → Matrix n n R\nabv : AbsoluteValue R S\nx : S\nhx : ∀ (k : ι) (i j : n), LE.le (abv (A k i j)) x\n⊢ LE.le (abv (s.sum fun k => A k).det) (HSMul.hSMul (Fintype.card n).factorial (HPow.hPow (HSMul.hSMul s.card x) (Fintype.card n)))","decl":"theorem det_sum_le {ι : Type*} (s : Finset ι) {A : ι → Matrix n n R} {abv : AbsoluteValue R S}\n    {x : S} (hx : ∀ k i j, abv (A k i j) ≤ x) :\n    abv (det (∑ k ∈ s, A k)) ≤\n      Nat.factorial (Fintype.card n) • (#s• x) ^ Fintype.card n :=\n  det_le fun i j =>\n    calc\n      abv ((∑ k ∈ s, A k) i j) = abv (∑ k ∈ s, A k i j) := by simp only [sum_apply]\n      _ ≤ ∑ k ∈ s, abv (A k i j) := abv.sum_le _ _\n      _ ≤ ∑ _k ∈ s, x := sum_le_sum fun k _ => hx k i j\n      _ = #s • x := sum_const _\n\n"}
{"name":"Matrix.det_sum_smul_le","module":"Mathlib.LinearAlgebra.Matrix.AbsoluteValue","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Nontrivial R\ninst✝² : LinearOrderedCommRing S\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nι : Type u_4\ns : Finset ι\nc : ι → R\nA : ι → Matrix n n R\nabv : AbsoluteValue R S\nx : S\nhx : ∀ (k : ι) (i j : n), LE.le (abv (A k i j)) x\ny : S\nhy : ∀ (k : ι), LE.le (abv (c k)) y\n⊢ LE.le (abv (s.sum fun k => HSMul.hSMul (c k) (A k)).det) (HSMul.hSMul (Fintype.card n).factorial (HPow.hPow (HMul.hMul (HSMul.hSMul s.card y) x) (Fintype.card n)))","decl":"theorem det_sum_smul_le {ι : Type*} (s : Finset ι) {c : ι → R} {A : ι → Matrix n n R}\n    {abv : AbsoluteValue R S} {x : S} (hx : ∀ k i j, abv (A k i j) ≤ x) {y : S}\n    (hy : ∀ k, abv (c k) ≤ y) :\n    abv (det (∑ k ∈ s, c k • A k)) ≤\n      Nat.factorial (Fintype.card n) • (#s • y * x) ^ Fintype.card n := by\n  simpa only [smul_mul_assoc] using\n    det_sum_le s fun k i j =>\n      calc\n        abv (c k * A k i j) = abv (c k) * abv (A k i j) := abv.map_mul _ _\n        _ ≤ y * x := mul_le_mul (hy k) (hx k i j) (abv.nonneg _) ((abv.nonneg _).trans (hy k))\n\n"}
