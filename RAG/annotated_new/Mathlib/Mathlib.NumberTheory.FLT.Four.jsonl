{"name":"Fermat42.comm","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\n⊢ Iff (Fermat42 a b c) (Fermat42 b a c)","decl":"theorem comm {a b c : ℤ} : Fermat42 a b c ↔ Fermat42 b a c := by\n  delta Fermat42\n  rw [add_comm]\n  tauto\n\n"}
{"name":"Fermat42.mul","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c k : Int\nhk0 : Ne k 0\n⊢ Iff (Fermat42 a b c) (Fermat42 (HMul.hMul k a) (HMul.hMul k b) (HMul.hMul (HPow.hPow k 2) c))","decl":"theorem mul {a b c k : ℤ} (hk0 : k ≠ 0) :\n    Fermat42 a b c ↔ Fermat42 (k * a) (k * b) (k ^ 2 * c) := by\n  delta Fermat42\n  constructor\n  · intro f42\n    constructor\n    · exact mul_ne_zero hk0 f42.1\n    constructor\n    · exact mul_ne_zero hk0 f42.2.1\n    · have H : a ^ 4 + b ^ 4 = c ^ 2 := f42.2.2\n      linear_combination k ^ 4 * H\n  · intro f42\n    constructor\n    · exact right_ne_zero_of_mul f42.1\n    constructor\n    · exact right_ne_zero_of_mul f42.2.1\n    apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp\n    linear_combination f42.2.2\n\n"}
{"name":"Fermat42.ne_zero","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42 a b c\n⊢ Ne c 0","decl":"theorem ne_zero {a b c : ℤ} (h : Fermat42 a b c) : c ≠ 0 := by\n  apply ne_zero_pow two_ne_zero _; apply ne_of_gt\n  rw [← h.2.2, (by ring : a ^ 4 + b ^ 4 = (a ^ 2) ^ 2 + (b ^ 2) ^ 2)]\n  exact\n    add_pos (sq_pos_of_ne_zero (pow_ne_zero 2 h.1)) (sq_pos_of_ne_zero (pow_ne_zero 2 h.2.1))\n\n"}
{"name":"Fermat42.exists_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42 a b c\n⊢ Exists fun a0 => Exists fun b0 => Exists fun c0 => Fermat42.Minimal a0 b0 c0","decl":"/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem exists_minimal {a b c : ℤ} (h : Fermat42 a b c) : ∃ a0 b0 c0, Minimal a0 b0 c0 := by\n  classical\n  let S : Set ℕ := { n | ∃ s : ℤ × ℤ × ℤ, Fermat42 s.1 s.2.1 s.2.2 ∧ n = Int.natAbs s.2.2 }\n  have S_nonempty : S.Nonempty := by\n    use Int.natAbs c\n    rw [Set.mem_setOf_eq]\n    use ⟨a, ⟨b, c⟩⟩\n  let m : ℕ := Nat.find S_nonempty\n  have m_mem : m ∈ S := Nat.find_spec S_nonempty\n  rcases m_mem with ⟨s0, hs0, hs1⟩\n  use s0.1, s0.2.1, s0.2.2, hs0\n  intro a1 b1 c1 h1\n  rw [← hs1]\n  apply Nat.find_min'\n  use ⟨a1, ⟨b1, c1⟩⟩\n\n"}
{"name":"Fermat42.coprime_of_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42.Minimal a b c\n⊢ IsCoprime a b","decl":"/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem coprime_of_minimal {a b c : ℤ} (h : Minimal a b c) : IsCoprime a b := by\n  apply Int.isCoprime_iff_gcd_eq_one.mpr\n  by_contra hab\n  obtain ⟨p, hp, hpa, hpb⟩ := Nat.Prime.not_coprime_iff_dvd.mp hab\n  obtain ⟨a1, rfl⟩ := Int.natCast_dvd.mpr hpa\n  obtain ⟨b1, rfl⟩ := Int.natCast_dvd.mpr hpb\n  have hpc : (p : ℤ) ^ 2 ∣ c := by\n    rw [← Int.pow_dvd_pow_iff two_ne_zero, ← h.1.2.2]\n    apply Dvd.intro (a1 ^ 4 + b1 ^ 4)\n    ring\n  obtain ⟨c1, rfl⟩ := hpc\n  have hf : Fermat42 a1 b1 c1 :=\n    (Fermat42.mul (Int.natCast_ne_zero.mpr (Nat.Prime.ne_zero hp))).mpr h.1\n  apply Nat.le_lt_asymm (h.2 _ _ _ hf)\n  rw [Int.natAbs_mul, lt_mul_iff_one_lt_left, Int.natAbs_pow, Int.natAbs_ofNat]\n  · exact Nat.one_lt_pow two_ne_zero (Nat.Prime.one_lt hp)\n  · exact Nat.pos_of_ne_zero (Int.natAbs_ne_zero.2 (ne_zero hf))\n\n"}
{"name":"Fermat42.minimal_comm","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\na✝ : Fermat42.Minimal a b c\n⊢ Fermat42.Minimal b a c","decl":"/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem minimal_comm {a b c : ℤ} : Minimal a b c → Minimal b a c := fun ⟨h1, h2⟩ =>\n  ⟨Fermat42.comm.mp h1, h2⟩\n\n"}
{"name":"Fermat42.neg_of_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\na✝ : Fermat42.Minimal a b c\n⊢ Fermat42.Minimal a b (Neg.neg c)","decl":"/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem neg_of_minimal {a b c : ℤ} : Minimal a b c → Minimal a b (-c) := by\n  rintro ⟨⟨ha, hb, heq⟩, h2⟩\n  constructor\n  · apply And.intro ha (And.intro hb _)\n    rw [heq]\n    exact (neg_sq c).symm\n  rwa [Int.natAbs_neg c]\n\n"}
{"name":"Fermat42.exists_odd_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42 a b c\n⊢ Exists fun a0 => Exists fun b0 => Exists fun c0 => And (Fermat42.Minimal a0 b0 c0) (Eq (HMod.hMod a0 2) 1)","decl":"/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem exists_odd_minimal {a b c : ℤ} (h : Fermat42 a b c) :\n    ∃ a0 b0 c0, Minimal a0 b0 c0 ∧ a0 % 2 = 1 := by\n  obtain ⟨a0, b0, c0, hf⟩ := exists_minimal h\n  cases' Int.emod_two_eq_zero_or_one a0 with hap hap\n  · cases' Int.emod_two_eq_zero_or_one b0 with hbp hbp\n    · exfalso\n      have h1 : 2 ∣ (Int.gcd a0 b0 : ℤ) :=\n        Int.dvd_gcd (Int.dvd_of_emod_eq_zero hap) (Int.dvd_of_emod_eq_zero hbp)\n      rw [Int.isCoprime_iff_gcd_eq_one.mp (coprime_of_minimal hf)] at h1\n      revert h1\n      decide\n    · exact ⟨b0, ⟨a0, ⟨c0, minimal_comm hf, hbp⟩⟩⟩\n  exact ⟨a0, ⟨b0, ⟨c0, hf, hap⟩⟩⟩\n\n"}
{"name":"Fermat42.exists_pos_odd_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42 a b c\n⊢ Exists fun a0 => Exists fun b0 => Exists fun c0 => And (Fermat42.Minimal a0 b0 c0) (And (Eq (HMod.hMod a0 2) 1) (LT.lt 0 c0))","decl":"/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem exists_pos_odd_minimal {a b c : ℤ} (h : Fermat42 a b c) :\n    ∃ a0 b0 c0, Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 := by\n  obtain ⟨a0, b0, c0, hf, hc⟩ := exists_odd_minimal h\n  rcases lt_trichotomy 0 c0 with (h1 | h1 | h1)\n  · use a0, b0, c0\n  · exfalso\n    exact ne_zero hf.1 h1.symm\n  · use a0, b0, -c0, neg_of_minimal hf, hc\n    exact neg_pos.mpr h1\n\n"}
{"name":"Int.isCoprime_of_sq_sum","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"r s : Int\nh2 : IsCoprime s r\n⊢ IsCoprime (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2)) r","decl":"theorem Int.isCoprime_of_sq_sum {r s : ℤ} (h2 : IsCoprime s r) : IsCoprime (r ^ 2 + s ^ 2) r := by\n  rw [sq, sq]\n  exact (IsCoprime.mul_left h2 h2).mul_add_left_left r\n\n"}
{"name":"Int.coprime_of_sq_sum","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"r s : Int\nh2 : IsCoprime s r\n⊢ IsCoprime (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2)) r","decl":"@[deprecated (since := \"2025-01-23\")] alias Int.coprime_of_sq_sum := Int.isCoprime_of_sq_sum\n\n"}
{"name":"Int.isCoprime_of_sq_sum'","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"r s : Int\nh : IsCoprime r s\n⊢ IsCoprime (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2)) (HMul.hMul r s)","decl":"theorem Int.isCoprime_of_sq_sum' {r s : ℤ} (h : IsCoprime r s) :\n    IsCoprime (r ^ 2 + s ^ 2) (r * s) := by\n  apply IsCoprime.mul_right (Int.isCoprime_of_sq_sum (isCoprime_comm.mp h))\n  rw [add_comm]; apply Int.isCoprime_of_sq_sum h\n\n"}
{"name":"Int.coprime_of_sq_sum'","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"r s : Int\nh : IsCoprime r s\n⊢ IsCoprime (HAdd.hAdd (HPow.hPow r 2) (HPow.hPow s 2)) (HMul.hMul r s)","decl":"@[deprecated (since := \"2025-01-23\")] alias Int.coprime_of_sq_sum' := Int.isCoprime_of_sq_sum'\n\n"}
{"name":"Fermat42.not_minimal","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nh : Fermat42.Minimal a b c\nha2 : Eq (HMod.hMod a 2) 1\nhc : LT.lt 0 c\n⊢ False","decl":"theorem not_minimal {a b c : ℤ} (h : Minimal a b c) (ha2 : a % 2 = 1) (hc : 0 < c) : False := by\n  -- Use the fact that a ^ 2, b ^ 2, c form a pythagorean triple to obtain m and n such that\n  -- a ^ 2 = m ^ 2 - n ^ 2, b ^ 2 = 2 * m * n and c = m ^ 2 + n ^ 2\n  -- first the formula:\n  have ht : PythagoreanTriple (a ^ 2) (b ^ 2) c := by\n    delta PythagoreanTriple\n    linear_combination h.1.2.2\n  -- coprime requirement:\n  have h2 : Int.gcd (a ^ 2) (b ^ 2) = 1 :=\n    Int.isCoprime_iff_gcd_eq_one.mp (coprime_of_minimal h).pow\n  -- in order to reduce the possibilities we get from the classification of pythagorean triples\n  -- it helps if we know the parity of a ^ 2 (and the sign of c):\n  have ha22 : a ^ 2 % 2 = 1 := by\n    rw [sq, Int.mul_emod, ha2]\n    decide\n  obtain ⟨m, n, ht1, ht2, ht3, ht4, ht5, ht6⟩ := ht.coprime_classification' h2 ha22 hc\n  -- Now a, n, m form a pythagorean triple and so we can obtain r and s such that\n  -- a = r ^ 2 - s ^ 2, n = 2 * r * s and m = r ^ 2 + s ^ 2\n  -- formula:\n  have htt : PythagoreanTriple a n m := by\n    delta PythagoreanTriple\n    linear_combination ht1\n  -- a and n are coprime, because a ^ 2 = m ^ 2 - n ^ 2 and m and n are coprime.\n  have h3 : Int.gcd a n = 1 := by\n    apply Int.isCoprime_iff_gcd_eq_one.mp\n    apply @IsCoprime.of_mul_left_left _ _ _ a\n    rw [← sq, ht1, (by ring : m ^ 2 - n ^ 2 = m ^ 2 + -n * n)]\n    exact (Int.isCoprime_iff_gcd_eq_one.mpr ht4).pow_left.add_mul_right_left (-n)\n  -- m is positive because b is non-zero and b ^ 2 = 2 * m * n and we already have 0 ≤ m.\n  have hb20 : b ^ 2 ≠ 0 := mt pow_eq_zero h.1.2.1\n  have h4 : 0 < m := by\n    apply lt_of_le_of_ne ht6\n    rintro rfl\n    revert hb20\n    rw [ht2]\n    simp\n  obtain ⟨r, s, _, htt2, htt3, htt4, htt5, htt6⟩ := htt.coprime_classification' h3 ha2 h4\n  -- Now use the fact that (b / 2) ^ 2 = m * r * s, and m, r and s are pairwise coprime to obtain\n  -- i, j and k such that m = i ^ 2, r = j ^ 2 and s = k ^ 2.\n  -- m and r * s are coprime because m = r ^ 2 + s ^ 2 and r and s are coprime.\n  have hcp : Int.gcd m (r * s) = 1 := by\n    rw [htt3]\n    exact Int.isCoprime_iff_gcd_eq_one.mp\n      (Int.isCoprime_of_sq_sum' (Int.isCoprime_iff_gcd_eq_one.mpr htt4))\n  -- b is even because b ^ 2 = 2 * m * n.\n  have hb2 : 2 ∣ b := by\n    apply @Int.Prime.dvd_pow' _ 2 _ Nat.prime_two\n    rw [ht2, mul_assoc]\n    exact dvd_mul_right 2 (m * n)\n  cases' hb2 with b' hb2'\n  have hs : b' ^ 2 = m * (r * s) := by\n    apply (mul_right_inj' (by norm_num : (4 : ℤ) ≠ 0)).mp\n    linear_combination (-b - 2 * b') * hb2' + ht2 + 2 * m * htt2\n  have hrsz : r * s ≠ 0 := by\n    -- because b ^ 2 is not zero and (b / 2) ^ 2 = m * (r * s)\n    by_contra hrsz\n    revert hb20\n    rw [ht2, htt2, mul_assoc, @mul_assoc _ _ _ r s, hrsz]\n    simp\n  have h2b0 : b' ≠ 0 := by\n    apply ne_zero_pow two_ne_zero\n    rw [hs]\n    apply mul_ne_zero\n    · exact ne_of_gt h4\n    · exact hrsz\n  obtain ⟨i, hi⟩ := Int.sq_of_gcd_eq_one hcp hs.symm\n  -- use m is positive to exclude m = - i ^ 2\n  have hi' : ¬m = -i ^ 2 := by\n    by_contra h1\n    have hit : -i ^ 2 ≤ 0 := neg_nonpos.mpr (sq_nonneg i)\n    rw [← h1] at hit\n    apply absurd h4 (not_lt.mpr hit)\n  replace hi : m = i ^ 2 := Or.resolve_right hi hi'\n  rw [mul_comm] at hs\n  rw [Int.gcd_comm] at hcp\n  -- obtain d such that r * s = d ^ 2\n  obtain ⟨d, hd⟩ := Int.sq_of_gcd_eq_one hcp hs.symm\n  -- (b / 2) ^ 2 and m are positive so r * s is positive\n  have hd' : ¬r * s = -d ^ 2 := by\n    by_contra h1\n    rw [h1] at hs\n    have h2 : b' ^ 2 ≤ 0 := by\n      rw [hs, (by ring : -d ^ 2 * m = -(d ^ 2 * m))]\n      exact neg_nonpos.mpr ((mul_nonneg_iff_of_pos_right h4).mpr (sq_nonneg d))\n    have h2' : 0 ≤ b' ^ 2 := by apply sq_nonneg b'\n    exact absurd (lt_of_le_of_ne h2' (Ne.symm (pow_ne_zero _ h2b0))) (not_lt.mpr h2)\n  replace hd : r * s = d ^ 2 := Or.resolve_right hd hd'\n  -- r = +/- j ^ 2\n  obtain ⟨j, hj⟩ := Int.sq_of_gcd_eq_one htt4 hd\n  have hj0 : j ≠ 0 := by\n    intro h0\n    rw [h0, zero_pow two_ne_zero, neg_zero, or_self_iff] at hj\n    apply left_ne_zero_of_mul hrsz hj\n  rw [mul_comm] at hd\n  rw [Int.gcd_comm] at htt4\n  -- s = +/- k ^ 2\n  obtain ⟨k, hk⟩ := Int.sq_of_gcd_eq_one htt4 hd\n  have hk0 : k ≠ 0 := by\n    intro h0\n    rw [h0, zero_pow two_ne_zero, neg_zero, or_self_iff] at hk\n    apply right_ne_zero_of_mul hrsz hk\n  have hj2 : r ^ 2 = j ^ 4 := by\n    cases' hj with hjp hjp <;>\n      · rw [hjp]\n        ring\n  have hk2 : s ^ 2 = k ^ 4 := by\n    cases' hk with hkp hkp <;>\n      · rw [hkp]\n        ring\n  -- from m = r ^ 2 + s ^ 2 we now get a new solution to a ^ 4 + b ^ 4 = c ^ 2:\n  have hh : i ^ 2 = j ^ 4 + k ^ 4 := by rw [← hi, htt3, hj2, hk2]\n  have hn : n ≠ 0 := by\n    rw [ht2] at hb20\n    apply right_ne_zero_of_mul hb20\n  -- and it has a smaller c: from c = m ^ 2 + n ^ 2 we see that m is smaller than c, and i ^ 2 = m.\n  have hic : Int.natAbs i < Int.natAbs c := by\n    apply Int.ofNat_lt.mp\n    rw [← Int.eq_natAbs_of_zero_le (le_of_lt hc)]\n    apply gt_of_gt_of_ge _ (Int.natAbs_le_self_sq i)\n    rw [← hi, ht3]\n    apply gt_of_gt_of_ge _ (Int.le_self_sq m)\n    exact lt_add_of_pos_right (m ^ 2) (sq_pos_of_ne_zero hn)\n  have hic' : Int.natAbs c ≤ Int.natAbs i := by\n    apply h.2 j k i\n    exact ⟨hj0, hk0, hh.symm⟩\n  apply absurd (not_le_of_lt hic) (not_not.mpr hic')\n\n"}
{"name":"not_fermat_42","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"a b c : Int\nha : Ne a 0\nhb : Ne b 0\n⊢ Ne (HAdd.hAdd (HPow.hPow a 4) (HPow.hPow b 4)) (HPow.hPow c 2)","decl":"theorem not_fermat_42 {a b c : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) : a ^ 4 + b ^ 4 ≠ c ^ 2 := by\n  intro h\n  obtain ⟨a0, b0, c0, ⟨hf, h2, hp⟩⟩ :=\n    Fermat42.exists_pos_odd_minimal (And.intro ha (And.intro hb h))\n  apply Fermat42.not_minimal hf h2 hp\n\n"}
{"name":"fermatLastTheoremFour","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"⊢ FermatLastTheoremFor 4","decl":"/--\nFermat's Last Theorem for $n=4$: if `a b c : ℕ` are all non-zero\nthen `a ^ 4 + b ^ 4 ≠ c ^ 4`.\n-/\ntheorem fermatLastTheoremFour : FermatLastTheoremFor 4 := by\n  rw [fermatLastTheoremFor_iff_int]\n  intro a b c ha hb _ heq\n  apply @not_fermat_42 _ _ (c ^ 2) ha hb\n  rw [heq]; ring\n\n"}
{"name":"FermatLastTheorem.of_odd_primes","module":"Mathlib.NumberTheory.FLT.Four","initialProofState":"hprimes : ∀ (p : Nat), Nat.Prime p → Odd p → FermatLastTheoremFor p\n⊢ FermatLastTheorem","decl":"/--\nTo prove Fermat's Last Theorem, it suffices to prove it for odd prime exponents.\n-/\ntheorem FermatLastTheorem.of_odd_primes\n    (hprimes : ∀ p : ℕ, Nat.Prime p → Odd p → FermatLastTheoremFor p) : FermatLastTheorem := by\n  intro n h\n  obtain hdvd|⟨p, hpprime, hdvd, hpodd⟩ := Nat.four_dvd_or_exists_odd_prime_and_dvd_of_two_lt h <;>\n    apply FermatLastTheoremWith.mono hdvd\n  · exact fermatLastTheoremFour\n  · exact hprimes p hpprime hpodd\n"}
