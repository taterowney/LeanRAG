{"name":"Set.piecewise_eq_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : Zero M\ns : Set α\nf : α → M\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (s.piecewise f 0) (s.indicator f)","decl":"@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (· ∈ s)] : s.piecewise f 1 = s.mulIndicator f :=\n  funext fun _ => @if_congr _ _ _ _ (id _) _ _ _ _ Iff.rfl rfl rfl\n\n-- Porting note: needed unfold for mulIndicator\n"}
{"name":"Set.piecewise_eq_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : One M\ns : Set α\nf : α → M\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (s.piecewise f 1) (s.mulIndicator f)","decl":"@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (· ∈ s)] : s.piecewise f 1 = s.mulIndicator f :=\n  funext fun _ => @if_congr _ _ _ _ (id _) _ _ _ _ Iff.rfl rfl rfl\n\n-- Porting note: needed unfold for mulIndicator\n"}
{"name":"Set.indicator_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : Zero M\ns : Set α\nf : α → M\na : α\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq (s.indicator f a) (ite (Membership.mem s a) (f a) 0)","decl":"@[to_additive]\ntheorem mulIndicator_apply (s : Set α) (f : α → M) (a : α) [Decidable (a ∈ s)] :\n    mulIndicator s f a = if a ∈ s then f a else 1 := by\n  unfold mulIndicator\n  congr\n\n"}
{"name":"Set.mulIndicator_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : One M\ns : Set α\nf : α → M\na : α\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq (s.mulIndicator f a) (ite (Membership.mem s a) (f a) 1)","decl":"@[to_additive]\ntheorem mulIndicator_apply (s : Set α) (f : α → M) (a : α) [Decidable (a ∈ s)] :\n    mulIndicator s f a = if a ∈ s then f a else 1 := by\n  unfold mulIndicator\n  congr\n\n"}
{"name":"Set.mulIndicator_of_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\na : α\nh : Membership.mem s a\nf : α → M\n⊢ Eq (s.mulIndicator f a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a ∈ s) (f : α → M) : mulIndicator s f a = f a :=\n  if_pos h\n\n"}
{"name":"Set.indicator_of_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\na : α\nh : Membership.mem s a\nf : α → M\n⊢ Eq (s.indicator f a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a ∈ s) (f : α → M) : mulIndicator s f a = f a :=\n  if_pos h\n\n"}
{"name":"Set.mulIndicator_of_not_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\na : α\nh : Not (Membership.mem s a)\nf : α → M\n⊢ Eq (s.mulIndicator f a) 1","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a ∉ s) (f : α → M) : mulIndicator s f a = 1 :=\n  if_neg h\n\n"}
{"name":"Set.indicator_of_not_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\na : α\nh : Not (Membership.mem s a)\nf : α → M\n⊢ Eq (s.indicator f a) 0","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a ∉ s) (f : α → M) : mulIndicator s f a = 1 :=\n  if_neg h\n\n"}
{"name":"Set.indicator_eq_zero_or_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\n⊢ Or (Eq (s.indicator f a) 0) (Eq (s.indicator f a) (f a))","decl":"@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a = 1 ∨ mulIndicator s f a = f a := by\n  by_cases h : a ∈ s\n  · exact Or.inr (mulIndicator_of_mem h f)\n  · exact Or.inl (mulIndicator_of_not_mem h f)\n\n"}
{"name":"Set.mulIndicator_eq_one_or_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\na : α\n⊢ Or (Eq (s.mulIndicator f a) 1) (Eq (s.mulIndicator f a) (f a))","decl":"@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a = 1 ∨ mulIndicator s f a = f a := by\n  by_cases h : a ∈ s\n  · exact Or.inr (mulIndicator_of_mem h f)\n  · exact Or.inl (mulIndicator_of_not_mem h f)\n\n"}
{"name":"Set.mulIndicator_apply_eq_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Eq (s.mulIndicator f a) (f a)) (Not (Membership.mem s a) → Eq (f a) 1)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a ↔ a ∉ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n\n"}
{"name":"Set.indicator_apply_eq_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Eq (s.indicator f a) (f a)) (Not (Membership.mem s a) → Eq (f a) 0)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a ↔ a ∉ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n\n"}
{"name":"Set.indicator_eq_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.indicator f) f) (HasSubset.Subset (Function.support f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_self : s.mulIndicator f = f ↔ mulSupport f ⊆ s := by\n  simp only [funext_iff, subset_def, mem_mulSupport, mulIndicator_apply_eq_self, not_imp_comm]\n\n"}
{"name":"Set.mulIndicator_eq_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.mulIndicator f) f) (HasSubset.Subset (Function.mulSupport f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_self : s.mulIndicator f = f ↔ mulSupport f ⊆ s := by\n  simp only [funext_iff, subset_def, mem_mulSupport, mulIndicator_apply_eq_self, not_imp_comm]\n\n"}
{"name":"Set.indicator_eq_self_of_superset","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns t : Set α\nf : α → M\nh1 : Eq (s.indicator f) f\nh2 : HasSubset.Subset s t\n⊢ Eq (t.indicator f) f","decl":"@[to_additive]\ntheorem mulIndicator_eq_self_of_superset (h1 : s.mulIndicator f = f) (h2 : s ⊆ t) :\n    t.mulIndicator f = f := by\n  rw [mulIndicator_eq_self] at h1 ⊢\n  exact Subset.trans h1 h2\n\n"}
{"name":"Set.mulIndicator_eq_self_of_superset","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns t : Set α\nf : α → M\nh1 : Eq (s.mulIndicator f) f\nh2 : HasSubset.Subset s t\n⊢ Eq (t.mulIndicator f) f","decl":"@[to_additive]\ntheorem mulIndicator_eq_self_of_superset (h1 : s.mulIndicator f = f) (h2 : s ⊆ t) :\n    t.mulIndicator f = f := by\n  rw [mulIndicator_eq_self] at h1 ⊢\n  exact Subset.trans h1 h2\n\n"}
{"name":"Set.indicator_apply_eq_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Eq (s.indicator f a) 0) (Membership.mem s a → Eq (f a) 0)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_one : mulIndicator s f a = 1 ↔ a ∈ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_right_iff\n\n"}
{"name":"Set.mulIndicator_apply_eq_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Eq (s.mulIndicator f a) 1) (Membership.mem s a → Eq (f a) 1)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_one : mulIndicator s f a = 1 ↔ a ∈ s → f a = 1 :=\n  letI := Classical.dec (a ∈ s)\n  ite_eq_right_iff\n\n"}
{"name":"Set.indicator_eq_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.indicator f) fun x => 0) (Disjoint (Function.support f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one : (mulIndicator s f = fun _ => 1) ↔ Disjoint (mulSupport f) s := by\n  simp only [funext_iff, mulIndicator_apply_eq_one, Set.disjoint_left, mem_mulSupport,\n    not_imp_not]\n\n"}
{"name":"Set.mulIndicator_eq_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.mulIndicator f) fun x => 1) (Disjoint (Function.mulSupport f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one : (mulIndicator s f = fun _ => 1) ↔ Disjoint (mulSupport f) s := by\n  simp only [funext_iff, mulIndicator_apply_eq_one, Set.disjoint_left, mem_mulSupport,\n    not_imp_not]\n\n"}
{"name":"Set.indicator_eq_zero'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.indicator f) 0) (Disjoint (Function.support f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one' : mulIndicator s f = 1 ↔ Disjoint (mulSupport f) s :=\n  mulIndicator_eq_one\n\n"}
{"name":"Set.mulIndicator_eq_one'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Iff (Eq (s.mulIndicator f) 1) (Disjoint (Function.mulSupport f) s)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one' : mulIndicator s f = 1 ↔ Disjoint (mulSupport f) s :=\n  mulIndicator_eq_one\n\n"}
{"name":"Set.mulIndicator_apply_ne_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Ne (s.mulIndicator f a) 1) (Membership.mem (Inter.inter s (Function.mulSupport f)) a)","decl":"@[to_additive]\ntheorem mulIndicator_apply_ne_one {a : α} : s.mulIndicator f a ≠ 1 ↔ a ∈ s ∩ mulSupport f := by\n  simp only [Ne, mulIndicator_apply_eq_one, Classical.not_imp, mem_inter_iff, mem_mulSupport]\n\n"}
{"name":"Set.indicator_apply_ne_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\n⊢ Iff (Ne (s.indicator f a) 0) (Membership.mem (Inter.inter s (Function.support f)) a)","decl":"@[to_additive]\ntheorem mulIndicator_apply_ne_one {a : α} : s.mulIndicator f a ≠ 1 ↔ a ∈ s ∩ mulSupport f := by\n  simp only [Ne, mulIndicator_apply_eq_one, Classical.not_imp, mem_inter_iff, mem_mulSupport]\n\n"}
{"name":"Set.mulSupport_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Eq (Function.mulSupport (s.mulIndicator f)) (Inter.inter s (Function.mulSupport f))","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_mulIndicator :\n    Function.mulSupport (s.mulIndicator f) = s ∩ Function.mulSupport f :=\n  ext fun x => by simp [Function.mem_mulSupport, mulIndicator_apply_eq_one]\n\n"}
{"name":"Set.support_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Eq (Function.support (s.indicator f)) (Inter.inter s (Function.support f))","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_mulIndicator :\n    Function.mulSupport (s.mulIndicator f) = s ∩ Function.mulSupport f :=\n  ext fun x => by simp [Function.mem_mulSupport, mulIndicator_apply_eq_one]\n\n"}
{"name":"Set.mem_of_mulIndicator_ne_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\na : α\nh : Ne (s.mulIndicator f a) 1\n⊢ Membership.mem s a","decl":"/-- If a multiplicative indicator function is not equal to `1` at a point, then that point is in the\nset. -/\n@[to_additive\n      \"If an additive indicator function is not equal to `0` at a point, then that point is\n      in the set.\"]\ntheorem mem_of_mulIndicator_ne_one (h : mulIndicator s f a ≠ 1) : a ∈ s :=\n  not_imp_comm.1 (fun hn => mulIndicator_of_not_mem hn f) h\n\n"}
{"name":"Set.mem_of_indicator_ne_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\nh : Ne (s.indicator f a) 0\n⊢ Membership.mem s a","decl":"/-- If a multiplicative indicator function is not equal to `1` at a point, then that point is in the\nset. -/\n@[to_additive\n      \"If an additive indicator function is not equal to `0` at a point, then that point is\n      in the set.\"]\ntheorem mem_of_mulIndicator_ne_one (h : mulIndicator s f a ≠ 1) : a ∈ s :=\n  not_imp_comm.1 (fun hn => mulIndicator_of_not_mem hn f) h\n\n"}
{"name":"Set.eqOn_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Set.EqOn (s.indicator f) f s","decl":"/-- See `Set.eqOn_mulIndicator'` for the version with `sᶜ`. -/\n@[to_additive\n      \"See `Set.eqOn_indicator'` for the version with `sᶜ`\"]\ntheorem eqOn_mulIndicator : EqOn (mulIndicator s f) f s := fun _ hx => mulIndicator_of_mem hx f\n\n"}
{"name":"Set.eqOn_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Set.EqOn (s.mulIndicator f) f s","decl":"/-- See `Set.eqOn_mulIndicator'` for the version with `sᶜ`. -/\n@[to_additive\n      \"See `Set.eqOn_indicator'` for the version with `sᶜ`\"]\ntheorem eqOn_mulIndicator : EqOn (mulIndicator s f) f s := fun _ hx => mulIndicator_of_mem hx f\n\n"}
{"name":"Set.eqOn_mulIndicator'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Set.EqOn (s.mulIndicator f) 1 (HasCompl.compl s)","decl":"/-- See `Set.eqOn_mulIndicator` for the version with `s`. -/\n@[to_additive\n      \"See `Set.eqOn_indicator` for the version with `s`.\"]\ntheorem eqOn_mulIndicator' : EqOn (mulIndicator s f) 1 sᶜ :=\n  fun _ hx => mulIndicator_of_not_mem hx f\n\n"}
{"name":"Set.eqOn_indicator'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Set.EqOn (s.indicator f) 0 (HasCompl.compl s)","decl":"/-- See `Set.eqOn_mulIndicator` for the version with `s`. -/\n@[to_additive\n      \"See `Set.eqOn_indicator` for the version with `s`.\"]\ntheorem eqOn_mulIndicator' : EqOn (mulIndicator s f) 1 sᶜ :=\n  fun _ hx => mulIndicator_of_not_mem hx f\n\n"}
{"name":"Set.support_indicator_subset","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ HasSubset.Subset (Function.support (s.indicator f)) s","decl":"@[to_additive]\ntheorem mulSupport_mulIndicator_subset : mulSupport (s.mulIndicator f) ⊆ s := fun _ hx =>\n  hx.imp_symm fun h => mulIndicator_of_not_mem h f\n\n"}
{"name":"Set.mulSupport_mulIndicator_subset","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ HasSubset.Subset (Function.mulSupport (s.mulIndicator f)) s","decl":"@[to_additive]\ntheorem mulSupport_mulIndicator_subset : mulSupport (s.mulIndicator f) ⊆ s := fun _ hx =>\n  hx.imp_symm fun h => mulIndicator_of_not_mem h f\n\n"}
{"name":"Set.mulIndicator_mulSupport","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nf : α → M\n⊢ Eq ((Function.mulSupport f).mulIndicator f) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_mulSupport : mulIndicator (mulSupport f) f = f :=\n  mulIndicator_eq_self.2 Subset.rfl\n\n"}
{"name":"Set.indicator_support","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nf : α → M\n⊢ Eq ((Function.support f).indicator f) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_mulSupport : mulIndicator (mulSupport f) f = f :=\n  mulIndicator_eq_self.2 Subset.rfl\n\n"}
{"name":"Set.indicator_range_comp","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nι : Sort u_5\nf : ι → α\ng : α → M\n⊢ Eq (Function.comp ((Set.range f).indicator g) f) (Function.comp g f)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_range_comp {ι : Sort*} (f : ι → α) (g : α → M) :\n    mulIndicator (range f) g ∘ f = g ∘ f :=\n  letI := Classical.decPred (· ∈ range f)\n  piecewise_range_comp _ _ _\n\n"}
{"name":"Set.mulIndicator_range_comp","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nι : Sort u_5\nf : ι → α\ng : α → M\n⊢ Eq (Function.comp ((Set.range f).mulIndicator g) f) (Function.comp g f)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_range_comp {ι : Sort*} (f : ι → α) (g : α → M) :\n    mulIndicator (range f) g ∘ f = g ∘ f :=\n  letI := Classical.decPred (· ∈ range f)\n  piecewise_range_comp _ _ _\n\n"}
{"name":"Set.indicator_congr","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf g : α → M\nh : Set.EqOn f g s\n⊢ Eq (s.indicator f) (s.indicator g)","decl":"@[to_additive]\ntheorem mulIndicator_congr (h : EqOn f g s) : mulIndicator s f = mulIndicator s g :=\n  funext fun x => by\n    simp only [mulIndicator]\n    split_ifs with h_1\n    · exact h h_1\n    rfl\n\n"}
{"name":"Set.mulIndicator_congr","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf g : α → M\nh : Set.EqOn f g s\n⊢ Eq (s.mulIndicator f) (s.mulIndicator g)","decl":"@[to_additive]\ntheorem mulIndicator_congr (h : EqOn f g s) : mulIndicator s f = mulIndicator s g :=\n  funext fun x => by\n    simp only [mulIndicator]\n    split_ifs with h_1\n    · exact h h_1\n    rfl\n\n"}
{"name":"Set.indicator_univ","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nf : α → M\n⊢ Eq (Set.univ.indicator f) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_univ (f : α → M) : mulIndicator (univ : Set α) f = f :=\n  mulIndicator_eq_self.2 <| subset_univ _\n\n"}
{"name":"Set.mulIndicator_univ","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nf : α → M\n⊢ Eq (Set.univ.mulIndicator f) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_univ (f : α → M) : mulIndicator (univ : Set α) f = f :=\n  mulIndicator_eq_self.2 <| subset_univ _\n\n"}
{"name":"Set.indicator_empty","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nf : α → M\n⊢ Eq (EmptyCollection.emptyCollection.indicator f) fun x => 0","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_empty (f : α → M) : mulIndicator (∅ : Set α) f = fun _ => 1 :=\n  mulIndicator_eq_one.2 <| disjoint_empty _\n\n"}
{"name":"Set.mulIndicator_empty","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nf : α → M\n⊢ Eq (EmptyCollection.emptyCollection.mulIndicator f) fun x => 1","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_empty (f : α → M) : mulIndicator (∅ : Set α) f = fun _ => 1 :=\n  mulIndicator_eq_one.2 <| disjoint_empty _\n\n"}
{"name":"Set.mulIndicator_empty'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nf : α → M\n⊢ Eq (EmptyCollection.emptyCollection.mulIndicator f) 1","decl":"@[to_additive]\ntheorem mulIndicator_empty' (f : α → M) : mulIndicator (∅ : Set α) f = 1 :=\n  mulIndicator_empty f\n\n"}
{"name":"Set.indicator_empty'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nf : α → M\n⊢ Eq (EmptyCollection.emptyCollection.indicator f) 0","decl":"@[to_additive]\ntheorem mulIndicator_empty' (f : α → M) : mulIndicator (∅ : Set α) f = 1 :=\n  mulIndicator_empty f\n\n"}
{"name":"Set.mulIndicator_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\n⊢ Eq (s.mulIndicator fun x => 1) fun x => 1","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_one (s : Set α) : (mulIndicator s fun _ => (1 : M)) = fun _ => (1 : M) :=\n  mulIndicator_eq_one.2 <| by simp only [mulSupport_one, empty_disjoint]\n\n"}
{"name":"Set.indicator_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\n⊢ Eq (s.indicator fun x => 0) fun x => 0","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_one (s : Set α) : (mulIndicator s fun _ => (1 : M)) = fun _ => (1 : M) :=\n  mulIndicator_eq_one.2 <| by simp only [mulSupport_one, empty_disjoint]\n\n"}
{"name":"Set.indicator_zero'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\n⊢ Eq (s.indicator 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_one' {s : Set α} : s.mulIndicator (1 : α → M) = 1 :=\n  mulIndicator_one M s\n\n"}
{"name":"Set.mulIndicator_one'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\n⊢ Eq (s.mulIndicator 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_one' {s : Set α} : s.mulIndicator (1 : α → M) = 1 :=\n  mulIndicator_one M s\n\n"}
{"name":"Set.mulIndicator_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns t : Set α\nf : α → M\n⊢ Eq (s.mulIndicator (t.mulIndicator f)) ((Inter.inter s t).mulIndicator f)","decl":"@[to_additive]\ntheorem mulIndicator_mulIndicator (s t : Set α) (f : α → M) :\n    mulIndicator s (mulIndicator t f) = mulIndicator (s ∩ t) f :=\n  funext fun x => by\n    simp only [mulIndicator]\n    split_ifs <;> simp_all +contextual\n\n"}
{"name":"Set.indicator_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns t : Set α\nf : α → M\n⊢ Eq (s.indicator (t.indicator f)) ((Inter.inter s t).indicator f)","decl":"@[to_additive]\ntheorem mulIndicator_mulIndicator (s t : Set α) (f : α → M) :\n    mulIndicator s (mulIndicator t f) = mulIndicator (s ∩ t) f :=\n  funext fun x => by\n    simp only [mulIndicator]\n    split_ifs <;> simp_all +contextual\n\n"}
{"name":"Set.indicator_inter_support","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\n⊢ Eq ((Inter.inter s (Function.support f)).indicator f) (s.indicator f)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_inter_mulSupport (s : Set α) (f : α → M) :\n    mulIndicator (s ∩ mulSupport f) f = mulIndicator s f := by\n  rw [← mulIndicator_mulIndicator, mulIndicator_mulSupport]\n\n"}
{"name":"Set.mulIndicator_inter_mulSupport","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\n⊢ Eq ((Inter.inter s (Function.mulSupport f)).mulIndicator f) (s.mulIndicator f)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_inter_mulSupport (s : Set α) (f : α → M) :\n    mulIndicator (s ∩ mulSupport f) f = mulIndicator s f := by\n  rw [← mulIndicator_mulIndicator, mulIndicator_mulSupport]\n\n"}
{"name":"Set.comp_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\nh : M → β\nf : α → M\ns : Set α\nx : α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (h (s.indicator f x)) (s.piecewise (Function.comp h f) (Function.const α (h 0)) x)","decl":"@[to_additive]\ntheorem comp_mulIndicator (h : M → β) (f : α → M) {s : Set α} {x : α} [DecidablePred (· ∈ s)] :\n    h (s.mulIndicator f x) = s.piecewise (h ∘ f) (const α (h 1)) x := by\n  letI := Classical.decPred (· ∈ s)\n  convert s.apply_piecewise f (const α 1) (fun _ => h) (x := x) using 2\n\n"}
{"name":"Set.comp_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝¹ : One M\nh : M → β\nf : α → M\ns : Set α\nx : α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (h (s.mulIndicator f x)) (s.piecewise (Function.comp h f) (Function.const α (h 1)) x)","decl":"@[to_additive]\ntheorem comp_mulIndicator (h : M → β) (f : α → M) {s : Set α} {x : α} [DecidablePred (· ∈ s)] :\n    h (s.mulIndicator f x) = s.piecewise (h ∘ f) (const α (h 1)) x := by\n  letI := Classical.decPred (· ∈ s)\n  convert s.apply_piecewise f (const α 1) (fun _ => h) (x := x) using 2\n\n"}
{"name":"Set.indicator_comp_right","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : β → α\ng : α → M\nx : β\n⊢ Eq ((Set.preimage f s).indicator (Function.comp g f) x) (s.indicator g (f x))","decl":"@[to_additive]\ntheorem mulIndicator_comp_right {s : Set α} (f : β → α) {g : α → M} {x : β} :\n    mulIndicator (f ⁻¹' s) (g ∘ f) x = mulIndicator s g (f x) := by\n  simp only [mulIndicator, Function.comp]\n  split_ifs with h h' h'' <;> first | rfl | contradiction\n\n"}
{"name":"Set.mulIndicator_comp_right","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : β → α\ng : α → M\nx : β\n⊢ Eq ((Set.preimage f s).mulIndicator (Function.comp g f) x) (s.mulIndicator g (f x))","decl":"@[to_additive]\ntheorem mulIndicator_comp_right {s : Set α} (f : β → α) {g : α → M} {x : β} :\n    mulIndicator (f ⁻¹' s) (g ∘ f) x = mulIndicator s g (f x) := by\n  simp only [mulIndicator, Function.comp]\n  split_ifs with h h' h'' <;> first | rfl | contradiction\n\n"}
{"name":"Set.mulIndicator_image","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : β → M\ng : α → β\nhg : Function.Injective g\nx : α\n⊢ Eq ((Set.image g s).mulIndicator f (g x)) (s.mulIndicator (Function.comp f g) x)","decl":"@[to_additive]\ntheorem mulIndicator_image {s : Set α} {f : β → M} {g : α → β} (hg : Injective g) {x : α} :\n    mulIndicator (g '' s) f (g x) = mulIndicator s (f ∘ g) x := by\n  rw [← mulIndicator_comp_right, preimage_image_eq _ hg]\n\n"}
{"name":"Set.indicator_image","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : β → M\ng : α → β\nhg : Function.Injective g\nx : α\n⊢ Eq ((Set.image g s).indicator f (g x)) (s.indicator (Function.comp f g) x)","decl":"@[to_additive]\ntheorem mulIndicator_image {s : Set α} {f : β → M} {g : α → β} (hg : Injective g) {x : α} :\n    mulIndicator (g '' s) f (g x) = mulIndicator s (f ∘ g) x := by\n  rw [← mulIndicator_comp_right, preimage_image_eq _ hg]\n\n"}
{"name":"Set.mulIndicator_comp_of_one","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\ns : Set α\nf : α → M\ng : M → N\nhg : Eq (g 1) 1\n⊢ Eq (s.mulIndicator (Function.comp g f)) (Function.comp g (s.mulIndicator f))","decl":"@[to_additive]\ntheorem mulIndicator_comp_of_one {g : M → N} (hg : g 1 = 1) :\n    mulIndicator s (g ∘ f) = g ∘ mulIndicator s f := by\n  funext\n  simp only [mulIndicator]\n  split_ifs <;> simp [*]\n\n"}
{"name":"Set.indicator_comp_of_zero","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\ns : Set α\nf : α → M\ng : M → N\nhg : Eq (g 0) 0\n⊢ Eq (s.indicator (Function.comp g f)) (Function.comp g (s.indicator f))","decl":"@[to_additive]\ntheorem mulIndicator_comp_of_one {g : M → N} (hg : g 1 = 1) :\n    mulIndicator s (g ∘ f) = g ∘ mulIndicator s f := by\n  funext\n  simp only [mulIndicator]\n  split_ifs <;> simp [*]\n\n"}
{"name":"Set.comp_indicator_const","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹ : Zero M\ninst✝ : Zero N\ns : Set α\nc : M\nf : M → N\nhf : Eq (f 0) 0\n⊢ Eq (fun x => f (s.indicator (fun x => c) x)) (s.indicator fun x => f c)","decl":"@[to_additive]\ntheorem comp_mulIndicator_const (c : M) (f : M → N) (hf : f 1 = 1) :\n    (fun x => f (s.mulIndicator (fun _ => c) x)) = s.mulIndicator fun _ => f c :=\n  (mulIndicator_comp_of_one hf).symm\n\n"}
{"name":"Set.comp_mulIndicator_const","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹ : One M\ninst✝ : One N\ns : Set α\nc : M\nf : M → N\nhf : Eq (f 1) 1\n⊢ Eq (fun x => f (s.mulIndicator (fun x => c) x)) (s.mulIndicator fun x => f c)","decl":"@[to_additive]\ntheorem comp_mulIndicator_const (c : M) (f : M → N) (hf : f 1 = 1) :\n    (fun x => f (s.mulIndicator (fun _ => c) x)) = s.mulIndicator fun _ => f c :=\n  (mulIndicator_comp_of_one hf).symm\n\n"}
{"name":"Set.indicator_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\nB : Set M\n⊢ Eq (Set.preimage (s.indicator f) B) (s.ite (Set.preimage f B) (Set.preimage 0 B))","decl":"@[to_additive]\ntheorem mulIndicator_preimage (s : Set α) (f : α → M) (B : Set M) :\n    mulIndicator s f ⁻¹' B = s.ite (f ⁻¹' B) (1 ⁻¹' B) :=\n  letI := Classical.decPred (· ∈ s)\n  piecewise_preimage s f 1 B\n\n"}
{"name":"Set.mulIndicator_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\nB : Set M\n⊢ Eq (Set.preimage (s.mulIndicator f) B) (s.ite (Set.preimage f B) (Set.preimage 1 B))","decl":"@[to_additive]\ntheorem mulIndicator_preimage (s : Set α) (f : α → M) (B : Set M) :\n    mulIndicator s f ⁻¹' B = s.ite (f ⁻¹' B) (1 ⁻¹' B) :=\n  letI := Classical.decPred (· ∈ s)\n  piecewise_preimage s f 1 B\n\n"}
{"name":"Set.mulIndicator_one_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nt : Set α\ns : Set M\n⊢ Membership.mem (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection)) (Set.preimage (t.mulIndicator 1) s)","decl":"@[to_additive]\ntheorem mulIndicator_one_preimage (s : Set M) :\n    t.mulIndicator 1 ⁻¹' s ∈ ({Set.univ, ∅} : Set (Set α)) := by\n  classical\n    rw [mulIndicator_one', preimage_one]\n    split_ifs <;> simp\n\n"}
{"name":"Set.indicator_zero_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nt : Set α\ns : Set M\n⊢ Membership.mem (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection)) (Set.preimage (t.indicator 0) s)","decl":"@[to_additive]\ntheorem mulIndicator_one_preimage (s : Set M) :\n    t.mulIndicator 1 ⁻¹' s ∈ ({Set.univ, ∅} : Set (Set α)) := by\n  classical\n    rw [mulIndicator_one', preimage_one]\n    split_ifs <;> simp\n\n"}
{"name":"Set.indicator_const_preimage_eq_union","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : Zero M\nU : Set α\ns : Set M\na : M\ninst✝¹ : Decidable (Membership.mem s a)\ninst✝ : Decidable (Membership.mem s 0)\n⊢ Eq (Set.preimage (U.indicator fun x => a) s) (Union.union (ite (Membership.mem s a) U EmptyCollection.emptyCollection) (ite (Membership.mem s 0) (HasCompl.compl U) EmptyCollection.emptyCollection))","decl":"@[to_additive]\ntheorem mulIndicator_const_preimage_eq_union (U : Set α) (s : Set M) (a : M) [Decidable (a ∈ s)]\n    [Decidable ((1 : M) ∈ s)] : (U.mulIndicator fun _ => a) ⁻¹' s =\n      (if a ∈ s then U else ∅) ∪ if (1 : M) ∈ s then Uᶜ else ∅ := by\n  rw [mulIndicator_preimage, preimage_one, preimage_const]\n  split_ifs <;> simp [← compl_eq_univ_diff]\n\n"}
{"name":"Set.mulIndicator_const_preimage_eq_union","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝² : One M\nU : Set α\ns : Set M\na : M\ninst✝¹ : Decidable (Membership.mem s a)\ninst✝ : Decidable (Membership.mem s 1)\n⊢ Eq (Set.preimage (U.mulIndicator fun x => a) s) (Union.union (ite (Membership.mem s a) U EmptyCollection.emptyCollection) (ite (Membership.mem s 1) (HasCompl.compl U) EmptyCollection.emptyCollection))","decl":"@[to_additive]\ntheorem mulIndicator_const_preimage_eq_union (U : Set α) (s : Set M) (a : M) [Decidable (a ∈ s)]\n    [Decidable ((1 : M) ∈ s)] : (U.mulIndicator fun _ => a) ⁻¹' s =\n      (if a ∈ s then U else ∅) ∪ if (1 : M) ∈ s then Uᶜ else ∅ := by\n  rw [mulIndicator_preimage, preimage_one, preimage_const]\n  split_ifs <;> simp [← compl_eq_univ_diff]\n\n"}
{"name":"Set.indicator_const_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nU : Set α\ns : Set M\na : M\n⊢ Membership.mem (Insert.insert Set.univ (Insert.insert U (Insert.insert (HasCompl.compl U) (Singleton.singleton EmptyCollection.emptyCollection)))) (Set.preimage (U.indicator fun x => a) s)","decl":"@[to_additive]\ntheorem mulIndicator_const_preimage (U : Set α) (s : Set M) (a : M) :\n    (U.mulIndicator fun _ => a) ⁻¹' s ∈ ({Set.univ, U, Uᶜ, ∅} : Set (Set α)) := by\n  classical\n    rw [mulIndicator_const_preimage_eq_union]\n    split_ifs <;> simp\n\n"}
{"name":"Set.mulIndicator_const_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nU : Set α\ns : Set M\na : M\n⊢ Membership.mem (Insert.insert Set.univ (Insert.insert U (Insert.insert (HasCompl.compl U) (Singleton.singleton EmptyCollection.emptyCollection)))) (Set.preimage (U.mulIndicator fun x => a) s)","decl":"@[to_additive]\ntheorem mulIndicator_const_preimage (U : Set α) (s : Set M) (a : M) :\n    (U.mulIndicator fun _ => a) ⁻¹' s ∈ ({Set.univ, U, Uᶜ, ∅} : Set (Set α)) := by\n  classical\n    rw [mulIndicator_const_preimage_eq_union]\n    split_ifs <;> simp\n\n"}
{"name":"Set.indicator_one_preimage","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : One M\ninst✝ : Zero M\nU : Set α\ns : Set M\n⊢ Membership.mem (Insert.insert Set.univ (Insert.insert U (Insert.insert (HasCompl.compl U) (Singleton.singleton EmptyCollection.emptyCollection)))) (Set.preimage (U.indicator 1) s)","decl":"theorem indicator_one_preimage [Zero M] (U : Set α) (s : Set M) :\n    U.indicator 1 ⁻¹' s ∈ ({Set.univ, U, Uᶜ, ∅} : Set (Set α)) :=\n  indicator_const_preimage _ _ 1\n\n"}
{"name":"Set.indicator_preimage_of_not_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf : α → M\nt : Set M\nht : Not (Membership.mem t 0)\n⊢ Eq (Set.preimage (s.indicator f) t) (Inter.inter (Set.preimage f t) s)","decl":"@[to_additive]\ntheorem mulIndicator_preimage_of_not_mem (s : Set α) (f : α → M) {t : Set M} (ht : (1 : M) ∉ t) :\n    mulIndicator s f ⁻¹' t = f ⁻¹' t ∩ s := by\n  simp [mulIndicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]\n\n"}
{"name":"Set.mulIndicator_preimage_of_not_mem","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf : α → M\nt : Set M\nht : Not (Membership.mem t 1)\n⊢ Eq (Set.preimage (s.mulIndicator f) t) (Inter.inter (Set.preimage f t) s)","decl":"@[to_additive]\ntheorem mulIndicator_preimage_of_not_mem (s : Set α) (f : α → M) {t : Set M} (ht : (1 : M) ∉ t) :\n    mulIndicator s f ⁻¹' t = f ⁻¹' t ∩ s := by\n  simp [mulIndicator_preimage, Pi.one_def, Set.preimage_const_of_not_mem ht]\n\n"}
{"name":"Set.mem_range_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\nr : M\ns : Set α\nf : α → M\n⊢ Iff (Membership.mem (Set.range (s.mulIndicator f)) r) (Or (And (Eq r 1) (Ne s Set.univ)) (Membership.mem (Set.image f s) r))","decl":"@[to_additive]\ntheorem mem_range_mulIndicator {r : M} {s : Set α} {f : α → M} :\n    r ∈ range (mulIndicator s f) ↔ r = 1 ∧ s ≠ univ ∨ r ∈ f '' s := by\n  simp [mulIndicator, ite_eq_iff, exists_or, eq_univ_iff_forall, and_comm, or_comm,\n    @eq_comm _ r 1]\n\n"}
{"name":"Set.mem_range_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\nr : M\ns : Set α\nf : α → M\n⊢ Iff (Membership.mem (Set.range (s.indicator f)) r) (Or (And (Eq r 0) (Ne s Set.univ)) (Membership.mem (Set.image f s) r))","decl":"@[to_additive]\ntheorem mem_range_mulIndicator {r : M} {s : Set α} {f : α → M} :\n    r ∈ range (mulIndicator s f) ↔ r = 1 ∧ s ≠ univ ∨ r ∈ f '' s := by\n  simp [mulIndicator, ite_eq_iff, exists_or, eq_univ_iff_forall, and_comm, or_comm,\n    @eq_comm _ r 1]\n\n"}
{"name":"Set.indicator_rel_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : Zero M\ns : Set α\nf g : α → M\na : α\nr : M → M → Prop\nh1 : r 0 0\nha : Membership.mem s a → r (f a) (g a)\n⊢ r (s.indicator f a) (s.indicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_rel_mulIndicator {r : M → M → Prop} (h1 : r 1 1) (ha : a ∈ s → r (f a) (g a)) :\n    r (mulIndicator s f a) (mulIndicator s g a) := by\n  simp only [mulIndicator]\n  split_ifs with has\n  exacts [ha has, h1]\n\n"}
{"name":"Set.mulIndicator_rel_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : One M\ns : Set α\nf g : α → M\na : α\nr : M → M → Prop\nh1 : r 1 1\nha : Membership.mem s a → r (f a) (g a)\n⊢ r (s.mulIndicator f a) (s.mulIndicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_rel_mulIndicator {r : M → M → Prop} (h1 : r 1 1) (ha : a ∈ s → r (f a) (g a)) :\n    r (mulIndicator s f a) (mulIndicator s g a) := by\n  simp only [mulIndicator]\n  split_ifs with has\n  exacts [ha has, h1]\n\n"}
{"name":"Set.mulIndicator_union_mul_inter_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\nf : α → M\ns t : Set α\na : α\n⊢ Eq (HMul.hMul ((Union.union s t).mulIndicator f a) ((Inter.inter s t).mulIndicator f a)) (HMul.hMul (s.mulIndicator f a) (t.mulIndicator f a))","decl":"@[to_additive]\ntheorem mulIndicator_union_mul_inter_apply (f : α → M) (s t : Set α) (a : α) :\n    mulIndicator (s ∪ t) f a * mulIndicator (s ∩ t) f a\n      = mulIndicator s f a * mulIndicator t f a := by\n  by_cases hs : a ∈ s <;> by_cases ht : a ∈ t <;> simp [*]\n\n"}
{"name":"Set.indicator_union_add_inter_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\nf : α → M\ns t : Set α\na : α\n⊢ Eq (HAdd.hAdd ((Union.union s t).indicator f a) ((Inter.inter s t).indicator f a)) (HAdd.hAdd (s.indicator f a) (t.indicator f a))","decl":"@[to_additive]\ntheorem mulIndicator_union_mul_inter_apply (f : α → M) (s t : Set α) (a : α) :\n    mulIndicator (s ∪ t) f a * mulIndicator (s ∩ t) f a\n      = mulIndicator s f a * mulIndicator t f a := by\n  by_cases hs : a ∈ s <;> by_cases ht : a ∈ t <;> simp [*]\n\n"}
{"name":"Set.indicator_union_add_inter","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\nf : α → M\ns t : Set α\n⊢ Eq (HAdd.hAdd ((Union.union s t).indicator f) ((Inter.inter s t).indicator f)) (HAdd.hAdd (s.indicator f) (t.indicator f))","decl":"@[to_additive]\ntheorem mulIndicator_union_mul_inter (f : α → M) (s t : Set α) :\n    mulIndicator (s ∪ t) f * mulIndicator (s ∩ t) f = mulIndicator s f * mulIndicator t f :=\n  funext <| mulIndicator_union_mul_inter_apply f s t\n\n"}
{"name":"Set.mulIndicator_union_mul_inter","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\nf : α → M\ns t : Set α\n⊢ Eq (HMul.hMul ((Union.union s t).mulIndicator f) ((Inter.inter s t).mulIndicator f)) (HMul.hMul (s.mulIndicator f) (t.mulIndicator f))","decl":"@[to_additive]\ntheorem mulIndicator_union_mul_inter (f : α → M) (s t : Set α) :\n    mulIndicator (s ∪ t) f * mulIndicator (s ∩ t) f = mulIndicator s f * mulIndicator t f :=\n  funext <| mulIndicator_union_mul_inter_apply f s t\n\n"}
{"name":"Set.mulIndicator_union_of_not_mem_inter","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns t : Set α\na : α\nh : Not (Membership.mem (Inter.inter s t) a)\nf : α → M\n⊢ Eq ((Union.union s t).mulIndicator f a) (HMul.hMul (s.mulIndicator f a) (t.mulIndicator f a))","decl":"@[to_additive]\ntheorem mulIndicator_union_of_not_mem_inter (h : a ∉ s ∩ t) (f : α → M) :\n    mulIndicator (s ∪ t) f a = mulIndicator s f a * mulIndicator t f a := by\n  rw [← mulIndicator_union_mul_inter_apply f s t, mulIndicator_of_not_mem h, mul_one]\n\n"}
{"name":"Set.indicator_union_of_not_mem_inter","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns t : Set α\na : α\nh : Not (Membership.mem (Inter.inter s t) a)\nf : α → M\n⊢ Eq ((Union.union s t).indicator f a) (HAdd.hAdd (s.indicator f a) (t.indicator f a))","decl":"@[to_additive]\ntheorem mulIndicator_union_of_not_mem_inter (h : a ∉ s ∩ t) (f : α → M) :\n    mulIndicator (s ∪ t) f a = mulIndicator s f a * mulIndicator t f a := by\n  rw [← mulIndicator_union_mul_inter_apply f s t, mulIndicator_of_not_mem h, mul_one]\n\n"}
{"name":"Set.mulIndicator_union_of_disjoint","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns t : Set α\nh : Disjoint s t\nf : α → M\n⊢ Eq ((Union.union s t).mulIndicator f) fun a => HMul.hMul (s.mulIndicator f a) (t.mulIndicator f a)","decl":"@[to_additive]\ntheorem mulIndicator_union_of_disjoint (h : Disjoint s t) (f : α → M) :\n    mulIndicator (s ∪ t) f = fun a => mulIndicator s f a * mulIndicator t f a :=\n  funext fun _ => mulIndicator_union_of_not_mem_inter (fun ha => h.le_bot ha) _\n\n"}
{"name":"Set.indicator_union_of_disjoint","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns t : Set α\nh : Disjoint s t\nf : α → M\n⊢ Eq ((Union.union s t).indicator f) fun a => HAdd.hAdd (s.indicator f a) (t.indicator f a)","decl":"@[to_additive]\ntheorem mulIndicator_union_of_disjoint (h : Disjoint s t) (f : α → M) :\n    mulIndicator (s ∪ t) f = fun a => mulIndicator s f a * mulIndicator t f a :=\n  funext fun _ => mulIndicator_union_of_not_mem_inter (fun ha => h.le_bot ha) _\n\n"}
{"name":"Set.indicator_symmDiff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns t : Set α\nf : α → M\n⊢ Eq ((symmDiff s t).indicator f) (HAdd.hAdd ((SDiff.sdiff s t).indicator f) ((SDiff.sdiff t s).indicator f))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem mulIndicator_symmDiff (s t : Set α) (f : α → M) :\n    mulIndicator (s ∆ t) f = mulIndicator (s \\ t) f * mulIndicator (t \\ s) f :=\n  mulIndicator_union_of_disjoint (disjoint_sdiff_self_right.mono_left sdiff_le) _\n\n"}
{"name":"Set.mulIndicator_symmDiff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns t : Set α\nf : α → M\n⊢ Eq ((symmDiff s t).mulIndicator f) (HMul.hMul ((SDiff.sdiff s t).mulIndicator f) ((SDiff.sdiff t s).mulIndicator f))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem mulIndicator_symmDiff (s t : Set α) (f : α → M) :\n    mulIndicator (s ∆ t) f = mulIndicator (s \\ t) f * mulIndicator (t \\ s) f :=\n  mulIndicator_union_of_disjoint (disjoint_sdiff_self_right.mono_left sdiff_le) _\n\n"}
{"name":"Set.mulIndicator_mul","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf g : α → M\n⊢ Eq (s.mulIndicator fun a => HMul.hMul (f a) (g a)) fun a => HMul.hMul (s.mulIndicator f a) (s.mulIndicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_mul (s : Set α) (f g : α → M) :\n    (mulIndicator s fun a => f a * g a) = fun a => mulIndicator s f a * mulIndicator s g a := by\n  funext\n  simp only [mulIndicator]\n  split_ifs\n  · rfl\n  rw [mul_one]\n\n"}
{"name":"Set.indicator_add","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf g : α → M\n⊢ Eq (s.indicator fun a => HAdd.hAdd (f a) (g a)) fun a => HAdd.hAdd (s.indicator f a) (s.indicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_mul (s : Set α) (f g : α → M) :\n    (mulIndicator s fun a => f a * g a) = fun a => mulIndicator s f a * mulIndicator s g a := by\n  funext\n  simp only [mulIndicator]\n  split_ifs\n  · rfl\n  rw [mul_one]\n\n"}
{"name":"Set.indicator_add'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf g : α → M\n⊢ Eq (s.indicator (HAdd.hAdd f g)) (HAdd.hAdd (s.indicator f) (s.indicator g))","decl":"@[to_additive]\ntheorem mulIndicator_mul' (s : Set α) (f g : α → M) :\n    mulIndicator s (f * g) = mulIndicator s f * mulIndicator s g :=\n  mulIndicator_mul s f g\n\n"}
{"name":"Set.mulIndicator_mul'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf g : α → M\n⊢ Eq (s.mulIndicator (HMul.hMul f g)) (HMul.hMul (s.mulIndicator f) (s.mulIndicator g))","decl":"@[to_additive]\ntheorem mulIndicator_mul' (s : Set α) (f g : α → M) :\n    mulIndicator s (f * g) = mulIndicator s f * mulIndicator s g :=\n  mulIndicator_mul s f g\n\n"}
{"name":"Set.mulIndicator_compl_mul_self_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf : α → M\na : α\n⊢ Eq (HMul.hMul ((HasCompl.compl s).mulIndicator f a) (s.mulIndicator f a)) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator sᶜ f a * mulIndicator s f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n\n"}
{"name":"Set.indicator_compl_add_self_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf : α → M\na : α\n⊢ Eq (HAdd.hAdd ((HasCompl.compl s).indicator f a) (s.indicator f a)) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator sᶜ f a * mulIndicator s f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n\n"}
{"name":"Set.mulIndicator_compl_mul_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf : α → M\n⊢ Eq (HMul.hMul ((HasCompl.compl s).mulIndicator f) (s.mulIndicator f)) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self (s : Set α) (f : α → M) :\n    mulIndicator sᶜ f * mulIndicator s f = f :=\n  funext <| mulIndicator_compl_mul_self_apply s f\n\n"}
{"name":"Set.indicator_compl_add_self","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf : α → M\n⊢ Eq (HAdd.hAdd ((HasCompl.compl s).indicator f) (s.indicator f)) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self (s : Set α) (f : α → M) :\n    mulIndicator sᶜ f * mulIndicator s f = f :=\n  funext <| mulIndicator_compl_mul_self_apply s f\n\n"}
{"name":"Set.indicator_self_add_compl_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf : α → M\na : α\n⊢ Eq (HAdd.hAdd (s.indicator f a) ((HasCompl.compl s).indicator f a)) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a * mulIndicator sᶜ f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n\n"}
{"name":"Set.mulIndicator_self_mul_compl_apply","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf : α → M\na : α\n⊢ Eq (HMul.hMul (s.mulIndicator f a) ((HasCompl.compl s).mulIndicator f a)) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl_apply (s : Set α) (f : α → M) (a : α) :\n    mulIndicator s f a * mulIndicator sᶜ f a = f a :=\n  by_cases (fun ha : a ∈ s => by simp [ha]) fun ha => by simp [ha]\n\n"}
{"name":"Set.indicator_self_add_compl","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\ns : Set α\nf : α → M\n⊢ Eq (HAdd.hAdd (s.indicator f) ((HasCompl.compl s).indicator f)) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl (s : Set α) (f : α → M) :\n    mulIndicator s f * mulIndicator sᶜ f = f :=\n  funext <| mulIndicator_self_mul_compl_apply s f\n\n"}
{"name":"Set.mulIndicator_self_mul_compl","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\ns : Set α\nf : α → M\n⊢ Eq (HMul.hMul (s.mulIndicator f) ((HasCompl.compl s).mulIndicator f)) f","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl (s : Set α) (f : α → M) :\n    mulIndicator s f * mulIndicator sᶜ f = f :=\n  funext <| mulIndicator_self_mul_compl_apply s f\n\n"}
{"name":"Set.indicator_add_eq_left","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\nf g : α → M\nh : Disjoint (Function.support f) (Function.support g)\n⊢ Eq ((Function.support f).indicator (HAdd.hAdd f g)) f","decl":"@[to_additive]\ntheorem mulIndicator_mul_eq_left {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport f).mulIndicator (f * g) = f := by\n  refine (mulIndicator_congr fun x hx => ?_).trans mulIndicator_mulSupport\n  have : g x = 1 := nmem_mulSupport.1 (disjoint_left.1 h hx)\n  rw [Pi.mul_apply, this, mul_one]\n\n"}
{"name":"Set.mulIndicator_mul_eq_left","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\nf g : α → M\nh : Disjoint (Function.mulSupport f) (Function.mulSupport g)\n⊢ Eq ((Function.mulSupport f).mulIndicator (HMul.hMul f g)) f","decl":"@[to_additive]\ntheorem mulIndicator_mul_eq_left {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport f).mulIndicator (f * g) = f := by\n  refine (mulIndicator_congr fun x hx => ?_).trans mulIndicator_mulSupport\n  have : g x = 1 := nmem_mulSupport.1 (disjoint_left.1 h hx)\n  rw [Pi.mul_apply, this, mul_one]\n\n"}
{"name":"Set.mulIndicator_mul_eq_right","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : MulOneClass M\nf g : α → M\nh : Disjoint (Function.mulSupport f) (Function.mulSupport g)\n⊢ Eq ((Function.mulSupport g).mulIndicator (HMul.hMul f g)) g","decl":"@[to_additive]\ntheorem mulIndicator_mul_eq_right {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport g).mulIndicator (f * g) = g := by\n  refine (mulIndicator_congr fun x hx => ?_).trans mulIndicator_mulSupport\n  have : f x = 1 := nmem_mulSupport.1 (disjoint_right.1 h hx)\n  rw [Pi.mul_apply, this, one_mul]\n\n"}
{"name":"Set.indicator_add_eq_right","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝ : AddZeroClass M\nf g : α → M\nh : Disjoint (Function.support f) (Function.support g)\n⊢ Eq ((Function.support g).indicator (HAdd.hAdd f g)) g","decl":"@[to_additive]\ntheorem mulIndicator_mul_eq_right {f g : α → M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport g).mulIndicator (f * g) = g := by\n  refine (mulIndicator_congr fun x hx => ?_).trans mulIndicator_mulSupport\n  have : f x = 1 := nmem_mulSupport.1 (disjoint_right.1 h hx)\n  rw [Pi.mul_apply, this, one_mul]\n\n"}
{"name":"Set.indicator_add_compl_eq_piecewise","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : AddZeroClass M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nf g : α → M\n⊢ Eq (HAdd.hAdd (s.indicator f) ((HasCompl.compl s).indicator g)) (s.piecewise f g)","decl":"@[to_additive]\ntheorem mulIndicator_mul_compl_eq_piecewise [DecidablePred (· ∈ s)] (f g : α → M) :\n    s.mulIndicator f * sᶜ.mulIndicator g = s.piecewise f g := by\n  ext x\n  by_cases h : x ∈ s\n  · rw [piecewise_eq_of_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_mem h,\n      Set.mulIndicator_of_not_mem (Set.not_mem_compl_iff.2 h), mul_one]\n  · rw [piecewise_eq_of_not_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_not_mem h,\n      Set.mulIndicator_of_mem (Set.mem_compl h), one_mul]\n\n"}
{"name":"Set.mulIndicator_mul_compl_eq_piecewise","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_3\ninst✝¹ : MulOneClass M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nf g : α → M\n⊢ Eq (HMul.hMul (s.mulIndicator f) ((HasCompl.compl s).mulIndicator g)) (s.piecewise f g)","decl":"@[to_additive]\ntheorem mulIndicator_mul_compl_eq_piecewise [DecidablePred (· ∈ s)] (f g : α → M) :\n    s.mulIndicator f * sᶜ.mulIndicator g = s.piecewise f g := by\n  ext x\n  by_cases h : x ∈ s\n  · rw [piecewise_eq_of_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_mem h,\n      Set.mulIndicator_of_not_mem (Set.not_mem_compl_iff.2 h), mul_one]\n  · rw [piecewise_eq_of_not_mem _ _ _ h, Pi.mul_apply, Set.mulIndicator_of_not_mem h,\n      Set.mulIndicator_of_mem (Set.mem_compl h), one_mul]\n\n"}
{"name":"Set.indicator_neg'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf : α → G\n⊢ Eq (s.indicator (Neg.neg f)) (Neg.neg (s.indicator f))","decl":"@[to_additive]\ntheorem mulIndicator_inv' (s : Set α) (f : α → G) : mulIndicator s f⁻¹ = (mulIndicator s f)⁻¹ :=\n  (mulIndicatorHom G s).map_inv f\n\n"}
{"name":"Set.mulIndicator_inv'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf : α → G\n⊢ Eq (s.mulIndicator (Inv.inv f)) (Inv.inv (s.mulIndicator f))","decl":"@[to_additive]\ntheorem mulIndicator_inv' (s : Set α) (f : α → G) : mulIndicator s f⁻¹ = (mulIndicator s f)⁻¹ :=\n  (mulIndicatorHom G s).map_inv f\n\n"}
{"name":"Set.indicator_neg","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf : α → G\n⊢ Eq (s.indicator fun a => Neg.neg (f a)) fun a => Neg.neg (s.indicator f a)","decl":"@[to_additive]\ntheorem mulIndicator_inv (s : Set α) (f : α → G) :\n    (mulIndicator s fun a => (f a)⁻¹) = fun a => (mulIndicator s f a)⁻¹ :=\n  mulIndicator_inv' s f\n\n"}
{"name":"Set.mulIndicator_inv","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf : α → G\n⊢ Eq (s.mulIndicator fun a => Inv.inv (f a)) fun a => Inv.inv (s.mulIndicator f a)","decl":"@[to_additive]\ntheorem mulIndicator_inv (s : Set α) (f : α → G) :\n    (mulIndicator s fun a => (f a)⁻¹) = fun a => (mulIndicator s f a)⁻¹ :=\n  mulIndicator_inv' s f\n\n"}
{"name":"Set.indicator_sub","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf g : α → G\n⊢ Eq (s.indicator fun a => HSub.hSub (f a) (g a)) fun a => HSub.hSub (s.indicator f a) (s.indicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_div (s : Set α) (f g : α → G) :\n    (mulIndicator s fun a => f a / g a) = fun a => mulIndicator s f a / mulIndicator s g a :=\n  (mulIndicatorHom G s).map_div f g\n\n"}
{"name":"Set.mulIndicator_div","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf g : α → G\n⊢ Eq (s.mulIndicator fun a => HDiv.hDiv (f a) (g a)) fun a => HDiv.hDiv (s.mulIndicator f a) (s.mulIndicator g a)","decl":"@[to_additive]\ntheorem mulIndicator_div (s : Set α) (f g : α → G) :\n    (mulIndicator s fun a => f a / g a) = fun a => mulIndicator s f a / mulIndicator s g a :=\n  (mulIndicatorHom G s).map_div f g\n\n"}
{"name":"Set.mulIndicator_div'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf g : α → G\n⊢ Eq (s.mulIndicator (HDiv.hDiv f g)) (HDiv.hDiv (s.mulIndicator f) (s.mulIndicator g))","decl":"@[to_additive]\ntheorem mulIndicator_div' (s : Set α) (f g : α → G) :\n    mulIndicator s (f / g) = mulIndicator s f / mulIndicator s g :=\n  mulIndicator_div s f g\n\n"}
{"name":"Set.indicator_sub'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf g : α → G\n⊢ Eq (s.indicator (HSub.hSub f g)) (HSub.hSub (s.indicator f) (s.indicator g))","decl":"@[to_additive]\ntheorem mulIndicator_div' (s : Set α) (f g : α → G) :\n    mulIndicator s (f / g) = mulIndicator s f / mulIndicator s g :=\n  mulIndicator_div s f g\n\n"}
{"name":"Set.indicator_compl'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf : α → G\n⊢ Eq ((HasCompl.compl s).indicator f) (HAdd.hAdd f (Neg.neg (s.indicator f)))","decl":"@[to_additive indicator_compl']\ntheorem mulIndicator_compl (s : Set α) (f : α → G) :\n    mulIndicator sᶜ f = f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| s.mulIndicator_compl_mul_self f\n\n"}
{"name":"Set.mulIndicator_compl","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf : α → G\n⊢ Eq ((HasCompl.compl s).mulIndicator f) (HMul.hMul f (Inv.inv (s.mulIndicator f)))","decl":"@[to_additive indicator_compl']\ntheorem mulIndicator_compl (s : Set α) (f : α → G) :\n    mulIndicator sᶜ f = f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| s.mulIndicator_compl_mul_self f\n\n"}
{"name":"Set.mulIndicator_compl'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns : Set α\nf : α → G\n⊢ Eq ((HasCompl.compl s).mulIndicator f) (HDiv.hDiv f (s.mulIndicator f))","decl":"@[to_additive indicator_compl]\ntheorem mulIndicator_compl' (s : Set α) (f : α → G) :\n    mulIndicator sᶜ f = f / mulIndicator s f := by rw [div_eq_mul_inv, mulIndicator_compl]\n\n"}
{"name":"Set.indicator_compl","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns : Set α\nf : α → G\n⊢ Eq ((HasCompl.compl s).indicator f) (HSub.hSub f (s.indicator f))","decl":"@[to_additive indicator_compl]\ntheorem mulIndicator_compl' (s : Set α) (f : α → G) :\n    mulIndicator sᶜ f = f / mulIndicator s f := by rw [div_eq_mul_inv, mulIndicator_compl]\n\n"}
{"name":"Set.indicator_diff'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns t : Set α\nh : HasSubset.Subset s t\nf : α → G\n⊢ Eq ((SDiff.sdiff t s).indicator f) (HAdd.hAdd (t.indicator f) (Neg.neg (s.indicator f)))","decl":"@[to_additive indicator_diff']\ntheorem mulIndicator_diff (h : s ⊆ t) (f : α → G) :\n    mulIndicator (t \\ s) f = mulIndicator t f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| by\n    rw [Pi.mul_def, ← mulIndicator_union_of_disjoint, diff_union_self,\n      union_eq_self_of_subset_right h]\n    exact disjoint_sdiff_self_left\n\n"}
{"name":"Set.mulIndicator_diff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns t : Set α\nh : HasSubset.Subset s t\nf : α → G\n⊢ Eq ((SDiff.sdiff t s).mulIndicator f) (HMul.hMul (t.mulIndicator f) (Inv.inv (s.mulIndicator f)))","decl":"@[to_additive indicator_diff']\ntheorem mulIndicator_diff (h : s ⊆ t) (f : α → G) :\n    mulIndicator (t \\ s) f = mulIndicator t f * (mulIndicator s f)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| by\n    rw [Pi.mul_def, ← mulIndicator_union_of_disjoint, diff_union_self,\n      union_eq_self_of_subset_right h]\n    exact disjoint_sdiff_self_left\n\n"}
{"name":"Set.indicator_diff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : AddGroup G\ns t : Set α\nh : HasSubset.Subset s t\nf : α → G\n⊢ Eq ((SDiff.sdiff t s).indicator f) (HSub.hSub (t.indicator f) (s.indicator f))","decl":"@[to_additive indicator_diff]\ntheorem mulIndicator_diff' (h : s ⊆ t) (f : α → G) :\n    mulIndicator (t \\ s) f = mulIndicator t f / mulIndicator s f := by\n  rw [mulIndicator_diff h, div_eq_mul_inv]\n\n"}
{"name":"Set.mulIndicator_diff'","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝ : Group G\ns t : Set α\nh : HasSubset.Subset s t\nf : α → G\n⊢ Eq ((SDiff.sdiff t s).mulIndicator f) (HDiv.hDiv (t.mulIndicator f) (s.mulIndicator f))","decl":"@[to_additive indicator_diff]\ntheorem mulIndicator_diff' (h : s ⊆ t) (f : α → G) :\n    mulIndicator (t \\ s) f = mulIndicator t f / mulIndicator s f := by\n  rw [mulIndicator_diff h, div_eq_mul_inv]\n\n"}
{"name":"Set.apply_mulIndicator_symmDiff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nG : Type u_5\ninst✝ : Group G\ng : G → β\nhg : ∀ (x : G), Eq (g (Inv.inv x)) (g x)\ns t : Set α\nf : α → G\nx : α\n⊢ Eq (g ((symmDiff s t).mulIndicator f x)) (g (HDiv.hDiv (s.mulIndicator f x) (t.mulIndicator f x)))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem apply_mulIndicator_symmDiff {g : G → β} (hg : ∀ x, g x⁻¹ = g x)\n    (s t : Set α) (f : α → G) (x : α) :\n    g (mulIndicator (s ∆ t) f x) = g (mulIndicator s f x / mulIndicator t f x) := by\n  by_cases hs : x ∈ s <;> by_cases ht : x ∈ t <;> simp [mem_symmDiff, *]\n\n"}
{"name":"Set.apply_indicator_symmDiff","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nβ : Type u_2\nG : Type u_5\ninst✝ : AddGroup G\ng : G → β\nhg : ∀ (x : G), Eq (g (Neg.neg x)) (g x)\ns t : Set α\nf : α → G\nx : α\n⊢ Eq (g ((symmDiff s t).indicator f x)) (g (HSub.hSub (s.indicator f x) (t.indicator f x)))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem apply_mulIndicator_symmDiff {g : G → β} (hg : ∀ x, g x⁻¹ = g x)\n    (s t : Set α) (f : α → G) (x : α) :\n    g (mulIndicator (s ∆ t) f x) = g (mulIndicator s f x / mulIndicator t f x) := by\n  by_cases hs : x ∈ s <;> by_cases ht : x ∈ t <;> simp [mem_symmDiff, *]\n\n"}
{"name":"MonoidHom.map_mulIndicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\ns : Set α\ng : α → M\nx : α\n⊢ Eq (f (s.mulIndicator g x)) (s.mulIndicator (Function.comp (⇑f) g) x)","decl":"@[to_additive]\ntheorem MonoidHom.map_mulIndicator {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (s : Set α) (g : α → M) (x : α) : f (s.mulIndicator g x) = s.mulIndicator (f ∘ g) x := by\n  simp [Set.mulIndicator_comp_of_one]\n"}
{"name":"AddMonoidHom.map_indicator","module":"Mathlib.Algebra.Group.Indicator","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\ns : Set α\ng : α → M\nx : α\n⊢ Eq (f (s.indicator g x)) (s.indicator (Function.comp (⇑f) g) x)","decl":"@[to_additive]\ntheorem MonoidHom.map_mulIndicator {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (s : Set α) (g : α → M) (x : α) : f (s.mulIndicator g x) = s.mulIndicator (f ∘ g) x := by\n  simp [Set.mulIndicator_comp_of_one]\n"}
