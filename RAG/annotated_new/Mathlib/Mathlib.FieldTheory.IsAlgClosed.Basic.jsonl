{"name":"IsAlgClosed.splits","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝ : Field k\nself : IsAlgClosed k\np : Polynomial k\n⊢ Polynomial.Splits (RingHom.id k) p","decl":"/-- Typeclass for algebraically closed fields.\n\nTo show `Polynomial.Splits p f` for an arbitrary ring homomorphism `f`,\nsee `IsAlgClosed.splits_codomain` and `IsAlgClosed.splits_domain`.\n-/\n@[stacks 09GR \"The definition of `IsAlgClosed` in mathlib is 09GR (4)\"]\nclass IsAlgClosed : Prop where\n  splits : ∀ p : k[X], p.Splits <| RingHom.id k\n\n"}
{"name":"IsAlgClosed.splits_codomain","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝² : Field k\ninst✝¹ : IsAlgClosed k\ninst✝ : Field K\nf : RingHom K k\np : Polynomial K\n⊢ Polynomial.Splits f p","decl":"/-- Every polynomial splits in the field extension `f : K →+* k` if `k` is algebraically closed.\n\nSee also `IsAlgClosed.splits_domain` for the case where `K` is algebraically closed.\n-/\ntheorem IsAlgClosed.splits_codomain {k K : Type*} [Field k] [IsAlgClosed k] [Field K] {f : K →+* k}\n    (p : K[X]) : p.Splits f := by convert IsAlgClosed.splits (p.map f); simp [splits_map_iff]\n\n"}
{"name":"IsAlgClosed.splits_domain","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝² : Field k\ninst✝¹ : IsAlgClosed k\ninst✝ : Field K\nf : RingHom k K\np : Polynomial k\n⊢ Polynomial.Splits f p","decl":"/-- Every polynomial splits in the field extension `f : K →+* k` if `K` is algebraically closed.\n\nSee also `IsAlgClosed.splits_codomain` for the case where `k` is algebraically closed.\n-/\ntheorem IsAlgClosed.splits_domain {k K : Type*} [Field k] [IsAlgClosed k] [Field K] {f : k →+* K}\n    (p : k[X]) : p.Splits f :=\n  Polynomial.splits_of_splits_id _ <| IsAlgClosed.splits _\n\n"}
{"name":"IsAlgClosed.exists_root","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\np : Polynomial k\nhp : Ne p.degree 0\n⊢ Exists fun x => p.IsRoot x","decl":"/--\nIf `k` is algebraically closed, then every nonconstant polynomial has a root.\n-/\n@[stacks 09GR \"(4) ⟹ (3)\"]\ntheorem exists_root [IsAlgClosed k] (p : k[X]) (hp : p.degree ≠ 0) : ∃ x, IsRoot p x :=\n  exists_root_of_splits _ (IsAlgClosed.splits p) hp\n\n"}
{"name":"IsAlgClosed.exists_pow_nat_eq","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\nx : k\nn : Nat\nhn : LT.lt 0 n\n⊢ Exists fun z => Eq (HPow.hPow z n) x","decl":"theorem exists_pow_nat_eq [IsAlgClosed k] (x : k) {n : ℕ} (hn : 0 < n) : ∃ z, z ^ n = x := by\n  have : degree (X ^ n - C x) ≠ 0 := by\n    rw [degree_X_pow_sub_C hn x]\n    exact ne_of_gt (WithBot.coe_lt_coe.2 hn)\n  obtain ⟨z, hz⟩ := exists_root (X ^ n - C x) this\n  use z\n  simp only [eval_C, eval_X, eval_pow, eval_sub, IsRoot.def] at hz\n  exact sub_eq_zero.1 hz\n\n"}
{"name":"IsAlgClosed.exists_eq_mul_self","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\nx : k\n⊢ Exists fun z => Eq x (HMul.hMul z z)","decl":"theorem exists_eq_mul_self [IsAlgClosed k] (x : k) : ∃ z, x = z * z := by\n  rcases exists_pow_nat_eq x zero_lt_two with ⟨z, rfl⟩\n  exact ⟨z, sq z⟩\n\n"}
{"name":"IsAlgClosed.roots_eq_zero_iff","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\np : Polynomial k\n⊢ Iff (Eq p.roots 0) (Eq p (Polynomial.C (p.coeff 0)))","decl":"theorem roots_eq_zero_iff [IsAlgClosed k] {p : k[X]} :\n    p.roots = 0 ↔ p = Polynomial.C (p.coeff 0) := by\n  refine ⟨fun h => ?_, fun hp => by rw [hp, roots_C]⟩\n  rcases le_or_lt (degree p) 0 with hd | hd\n  · exact eq_C_of_degree_le_zero hd\n  · obtain ⟨z, hz⟩ := IsAlgClosed.exists_root p hd.ne'\n    rw [← mem_roots (ne_zero_of_degree_gt hd), h] at hz\n    simp at hz\n\n"}
{"name":"IsAlgClosed.exists_eval₂_eq_zero_of_injective","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝² : Field k\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsAlgClosed k\nf : RingHom R k\nhf : Function.Injective ⇑f\np : Polynomial R\nhp : Ne p.degree 0\n⊢ Exists fun x => Eq (Polynomial.eval₂ f x p) 0","decl":"theorem exists_eval₂_eq_zero_of_injective {R : Type*} [Ring R] [IsAlgClosed k] (f : R →+* k)\n    (hf : Function.Injective f) (p : R[X]) (hp : p.degree ≠ 0) : ∃ x, p.eval₂ f x = 0 :=\n  let ⟨x, hx⟩ := exists_root (p.map f) (by rwa [degree_map_eq_of_injective hf])\n  ⟨x, by rwa [eval₂_eq_eval_map, ← IsRoot]⟩\n\n"}
{"name":"IsAlgClosed.exists_eval₂_eq_zero","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝² : Field k\nR : Type u_1\ninst✝¹ : Field R\ninst✝ : IsAlgClosed k\nf : RingHom R k\np : Polynomial R\nhp : Ne p.degree 0\n⊢ Exists fun x => Eq (Polynomial.eval₂ f x p) 0","decl":"theorem exists_eval₂_eq_zero {R : Type*} [Field R] [IsAlgClosed k] (f : R →+* k) (p : R[X])\n    (hp : p.degree ≠ 0) : ∃ x, p.eval₂ f x = 0 :=\n  exists_eval₂_eq_zero_of_injective f f.injective p hp\n\n"}
{"name":"IsAlgClosed.exists_aeval_eq_zero_of_injective","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝³ : Field k\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsAlgClosed k\ninst✝ : Algebra R k\nhinj : Function.Injective ⇑(algebraMap R k)\np : Polynomial R\nhp : Ne p.degree 0\n⊢ Exists fun x => Eq ((Polynomial.aeval x) p) 0","decl":"theorem exists_aeval_eq_zero_of_injective {R : Type*} [CommRing R] [IsAlgClosed k] [Algebra R k]\n    (hinj : Function.Injective (algebraMap R k)) (p : R[X]) (hp : p.degree ≠ 0) :\n    ∃ x : k, aeval x p = 0 :=\n  exists_eval₂_eq_zero_of_injective (algebraMap R k) hinj p hp\n\n"}
{"name":"IsAlgClosed.exists_aeval_eq_zero","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝³ : Field k\nR : Type u_1\ninst✝² : Field R\ninst✝¹ : IsAlgClosed k\ninst✝ : Algebra R k\np : Polynomial R\nhp : Ne p.degree 0\n⊢ Exists fun x => Eq ((Polynomial.aeval x) p) 0","decl":"theorem exists_aeval_eq_zero {R : Type*} [Field R] [IsAlgClosed k] [Algebra R k] (p : R[X])\n    (hp : p.degree ≠ 0) : ∃ x : k, aeval x p = 0 :=\n  exists_eval₂_eq_zero (algebraMap R k) p hp\n\n\n"}
{"name":"IsAlgClosed.of_exists_root","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝ : Field k\nH : ∀ (p : Polynomial k), p.Monic → Irreducible p → Exists fun x => Eq (Polynomial.eval x p) 0\n⊢ IsAlgClosed k","decl":"/--\nIf every nonconstant polynomial over `k` has a root, then `k` is algebraically closed.\n-/\n@[stacks 09GR \"(3) ⟹ (4)\"]\ntheorem of_exists_root (H : ∀ p : k[X], p.Monic → Irreducible p → ∃ x, p.eval x = 0) :\n    IsAlgClosed k := by\n  refine ⟨fun p ↦ Or.inr ?_⟩\n  intro q hq _\n  have : Irreducible (q * C (leadingCoeff q)⁻¹) := by\n    classical\n    rw [← coe_normUnit_of_ne_zero hq.ne_zero]\n    exact (associated_normalize _).irreducible hq\n  obtain ⟨x, hx⟩ := H (q * C (leadingCoeff q)⁻¹) (monic_mul_leadingCoeff_inv hq.ne_zero) this\n  exact degree_mul_leadingCoeff_inv q hq.ne_zero ▸ degree_eq_one_of_irreducible_of_root this hx\n\n"}
{"name":"IsAlgClosed.of_ringEquiv","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝² : Field k\nk' : Type u\ninst✝¹ : Field k'\ne : RingEquiv k k'\ninst✝ : IsAlgClosed k\n⊢ IsAlgClosed k'","decl":"theorem of_ringEquiv (k' : Type u) [Field k'] (e : k ≃+* k')\n    [IsAlgClosed k] : IsAlgClosed k' := by\n  apply IsAlgClosed.of_exists_root\n  intro p hmp hp\n  have hpe : degree (p.map e.symm.toRingHom) ≠ 0 := by\n    rw [degree_map]\n    exact ne_of_gt (degree_pos_of_irreducible hp)\n  rcases IsAlgClosed.exists_root (k := k) (p.map e.symm.toRingHom) hpe with ⟨x, hx⟩\n  use e x\n  rw [IsRoot] at hx\n  apply e.symm.injective\n  rw [map_zero, ← hx]\n  clear hx hpe hp hmp\n  induction p using Polynomial.induction_on <;> simp_all\n\n"}
{"name":"IsAlgClosed.degree_eq_one_of_irreducible","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\np : Polynomial k\nhp : Irreducible p\n⊢ Eq p.degree 1","decl":"/--\nIf `k` is algebraically closed, then every irreducible polynomial over `k` is linear.\n-/\n@[stacks 09GR \"(4) ⟹ (2)\"]\ntheorem degree_eq_one_of_irreducible [IsAlgClosed k] {p : k[X]} (hp : Irreducible p) :\n    p.degree = 1 :=\n  degree_eq_one_of_irreducible_of_splits hp (IsAlgClosed.splits_codomain _)\n\n"}
{"name":"IsAlgClosed.algebraMap_surjective_of_isIntegral","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝⁴ : Field k\ninst✝³ : Ring K\ninst✝² : IsDomain K\nhk : IsAlgClosed k\ninst✝¹ : Algebra k K\ninst✝ : Algebra.IsIntegral k K\n⊢ Function.Surjective ⇑(algebraMap k K)","decl":"theorem algebraMap_surjective_of_isIntegral {k K : Type*} [Field k] [Ring K] [IsDomain K]\n    [hk : IsAlgClosed k] [Algebra k K] [Algebra.IsIntegral k K] :\n    Function.Surjective (algebraMap k K) := by\n  refine fun x => ⟨-(minpoly k x).coeff 0, ?_⟩\n  have hq : (minpoly k x).leadingCoeff = 1 := minpoly.monic (Algebra.IsIntegral.isIntegral x)\n  have h : (minpoly k x).degree = 1 := degree_eq_one_of_irreducible k (minpoly.irreducible\n    (Algebra.IsIntegral.isIntegral x))\n  have : aeval x (minpoly k x) = 0 := minpoly.aeval k x\n  rw [eq_X_add_C_of_degree_eq_one h, hq, C_1, one_mul, aeval_add, aeval_X, aeval_C,\n    add_eq_zero_iff_eq_neg] at this\n  exact (RingHom.map_neg (algebraMap k K) ((minpoly k x).coeff 0)).symm ▸ this.symm\n\n"}
{"name":"IsAlgClosed.algebraMap_surjective_of_isIntegral'","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\ninst✝ : IsAlgClosed k\nf : RingHom k K\nhf : f.IsIntegral\n⊢ Function.Surjective ⇑f","decl":"theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]\n    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f :=\n  let _ : Algebra k K := f.toAlgebra\n  have : Algebra.IsIntegral k K := ⟨hf⟩\n  algebraMap_surjective_of_isIntegral\n\n"}
{"name":"IntermediateField.eq_bot_of_isAlgClosed_of_isAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝⁴ : Field k\ninst✝³ : Field K\ninst✝² : IsAlgClosed k\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : Algebra.IsAlgebraic k (Subtype fun x => Membership.mem L x)\n⊢ Eq L Bot.bot","decl":"/-- If `k` is algebraically closed, `K / k` is a field extension, `L / k` is an intermediate field\nwhich is algebraic, then `L` is equal to `k`. A corollary of\n`IsAlgClosed.algebraMap_surjective_of_isAlgebraic`. -/\n@[stacks 09GQ \"The result is the definition of algebraically closedness in Stacks Project. \\\nThis statement is 09GR (4) ⟹ (1).\"]\ntheorem IntermediateField.eq_bot_of_isAlgClosed_of_isAlgebraic {k K : Type*} [Field k] [Field K]\n    [IsAlgClosed k] [Algebra k K] (L : IntermediateField k K) [Algebra.IsAlgebraic k L] :\n    L = ⊥ := bot_unique fun x hx ↦ by\n  obtain ⟨y, hy⟩ := IsAlgClosed.algebraMap_surjective_of_isIntegral (k := k) (⟨x, hx⟩ : L)\n  exact ⟨y, congr_arg (algebraMap L K) hy⟩\n\n"}
{"name":"Polynomial.isCoprime_iff_aeval_ne_zero_of_isAlgClosed","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝³ : Field k\nK : Type v\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : Algebra k K\np q : Polynomial k\n⊢ Iff (IsCoprime p q) (∀ (a : K), Or (Ne ((Polynomial.aeval a) p) 0) (Ne ((Polynomial.aeval a) q) 0))","decl":"lemma Polynomial.isCoprime_iff_aeval_ne_zero_of_isAlgClosed (K : Type v) [Field K] [IsAlgClosed K]\n    [Algebra k K] (p q : k[X]) : IsCoprime p q ↔ ∀ a : K, aeval a p ≠ 0 ∨ aeval a q ≠ 0 := by\n  refine ⟨fun h => aeval_ne_zero_of_isCoprime h, fun h => isCoprime_of_dvd _ _ ?_ fun x hu h0 => ?_⟩\n  · replace h := h 0\n    contrapose! h\n    rw [h.left, h.right, map_zero, and_self]\n  · rintro ⟨_, rfl⟩ ⟨_, rfl⟩\n    obtain ⟨a, ha : _ = _⟩ := IsAlgClosed.exists_root (x.map <| algebraMap k K) <| by\n      simpa only [degree_map] using (ne_of_lt <| degree_pos_of_ne_zero_of_nonunit h0 hu).symm\n    exact not_and_or.mpr (h a) (by simp_rw [map_mul, ← eval_map_algebraMap, ha, zero_mul, true_and])\n\n"}
{"name":"IsAlgClosure.isAlgClosed","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nK : Type v\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : NoZeroSMulDivisors R K\nself : IsAlgClosure R K\n⊢ IsAlgClosed K","decl":"/-- Typeclass for an extension being an algebraic closure. -/\n@[stacks 09GS]\nclass IsAlgClosure (R : Type u) (K : Type v) [CommRing R] [Field K] [Algebra R K]\n    [NoZeroSMulDivisors R K] : Prop where\n  isAlgClosed : IsAlgClosed K\n  isAlgebraic : Algebra.IsAlgebraic R K\n\n"}
{"name":"IsAlgClosure.isAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nK : Type v\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : NoZeroSMulDivisors R K\nself : IsAlgClosure R K\n⊢ Algebra.IsAlgebraic R K","decl":"/-- Typeclass for an extension being an algebraic closure. -/\n@[stacks 09GS]\nclass IsAlgClosure (R : Type u) (K : Type v) [CommRing R] [Field K] [Algebra R K]\n    [NoZeroSMulDivisors R K] : Prop where\n  isAlgClosed : IsAlgClosed K\n  isAlgebraic : Algebra.IsAlgebraic R K\n\n"}
{"name":"IsAlgClosure.alg_closed","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nK : Type v\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : NoZeroSMulDivisors R K\nself : IsAlgClosure R K\n⊢ IsAlgClosed K","decl":"@[deprecated (since := \"2024-08-31\")] alias IsAlgClosure.alg_closed := IsAlgClosure.isAlgClosed\n"}
{"name":"IsAlgClosure.algebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nK : Type v\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : NoZeroSMulDivisors R K\nself : IsAlgClosure R K\n⊢ Algebra.IsAlgebraic R K","decl":"@[deprecated (since := \"2024-08-31\")] alias IsAlgClosure.algebraic := IsAlgClosure.isAlgebraic\n\n"}
{"name":"isAlgClosure_iff","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra k K\n⊢ Iff (IsAlgClosure k K) (And (IsAlgClosed K) (Algebra.IsAlgebraic k K))","decl":"theorem isAlgClosure_iff (K : Type v) [Field K] [Algebra k K] :\n    IsAlgClosure k K ↔ IsAlgClosed K ∧ Algebra.IsAlgebraic k K :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h => ⟨h.1, h.2⟩⟩\n\n"}
{"name":"IsAlgClosure.normal","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝³ : Field R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsAlgClosure R K\n⊢ Normal R K","decl":"instance (priority := 100) IsAlgClosure.normal (R K : Type*) [Field R] [Field K] [Algebra R K]\n    [IsAlgClosure R K] : Normal R K where\n  toIsAlgebraic := IsAlgClosure.isAlgebraic\n  splits' _ := @IsAlgClosed.splits_codomain _ _ _ (IsAlgClosure.isAlgClosed R) _ _ _\n\n"}
{"name":"IsAlgClosure.separable","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : Field R\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsAlgClosure R K\ninst✝ : CharZero R\n⊢ Algebra.IsSeparable R K","decl":"instance (priority := 100) IsAlgClosure.separable (R K : Type*) [Field R] [Field K] [Algebra R K]\n    [IsAlgClosure R K] [CharZero R] : Algebra.IsSeparable R K :=\n  ⟨fun _ => (minpoly.irreducible (Algebra.IsIntegral.isIntegral _)).separable⟩\n\n"}
{"name":"IsAlgClosed.instIsAlgClosure","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : IsAlgClosed F\n⊢ IsAlgClosure F F","decl":"instance IsAlgClosed.instIsAlgClosure (F : Type*) [Field F] [IsAlgClosed F] : IsAlgClosure F F where\n  isAlgClosed := ‹_›\n  isAlgebraic := .of_finite F F\n\n"}
{"name":"IsAlgClosure.of_splits","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : Algebra.IsIntegral R K\ninst✝ : NoZeroSMulDivisors R K\nh : ∀ (p : Polynomial R), p.Monic → Irreducible p → Polynomial.Splits (algebraMap R K) p\n⊢ IsAlgClosure R K","decl":"theorem IsAlgClosure.of_splits {R K} [CommRing R] [IsDomain R] [Field K] [Algebra R K]\n    [Algebra.IsIntegral R K] [NoZeroSMulDivisors R K]\n    (h : ∀ p : R[X], p.Monic → Irreducible p → p.Splits (algebraMap R K)) : IsAlgClosure R K where\n  isAlgebraic := inferInstance\n  isAlgClosed := .of_exists_root _ fun _p _ p_irred ↦\n    have ⟨g, monic, irred, dvd⟩ := p_irred.exists_dvd_monic_irreducible_of_isIntegral (K := R)\n    exists_root_of_splits _ (splits_of_splits_of_dvd _ (map_monic_ne_zero monic)\n      ((splits_id_iff_splits _).mpr <| h g monic irred) dvd) <|\n        degree_ne_of_natDegree_ne p_irred.natDegree_pos.ne'\n\n"}
{"name":"IsAlgClosed.surjective_restrictDomain_of_isAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"K : Type u\ninst✝¹⁰ : Field K\nL : Type v\nM : Type w\ninst✝⁹ : Field L\ninst✝⁸ : Algebra K L\ninst✝⁷ : Field M\ninst✝⁶ : Algebra K M\ninst✝⁵ : IsAlgClosed M\nE : Type u_1\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower K L E\ninst✝ : Algebra.IsAlgebraic L E\n⊢ Function.Surjective fun φ => AlgHom.restrictDomain L φ","decl":"/-- If E/L/K is a tower of field extensions with E/L algebraic, and if M is an algebraically\n  closed extension of K, then any embedding of L/K into M/K extends to an embedding of E/K.\n  Known as the extension lemma in https://math.stackexchange.com/a/687914. -/\ntheorem surjective_restrictDomain_of_isAlgebraic {E : Type*}\n    [Field E] [Algebra K E] [Algebra L E] [IsScalarTower K L E] [Algebra.IsAlgebraic L E] :\n    Function.Surjective fun φ : E →ₐ[K] M ↦ φ.restrictDomain L :=\n  fun f ↦ IntermediateField.exists_algHom_of_splits'\n    (E := E) f fun s ↦ ⟨Algebra.IsIntegral.isIntegral s, IsAlgClosed.splits_codomain _⟩\n\n"}
{"name":"IsAlgClosed.surjective_comp_algebraMap_of_isAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"K : Type u\ninst✝¹⁰ : Field K\nL : Type v\nM : Type w\ninst✝⁹ : Field L\ninst✝⁸ : Algebra K L\ninst✝⁷ : Field M\ninst✝⁶ : Algebra K M\ninst✝⁵ : IsAlgClosed M\nE : Type u_1\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower K L E\ninst✝ : Algebra.IsAlgebraic L E\n⊢ Function.Surjective fun φ => AlgHom.restrictDomain L φ","decl":"@[deprecated (since := \"2024-11-15\")]\nalias surjective_comp_algebraMap_of_isAlgebraic := surjective_restrictDomain_of_isAlgebraic\n\n"}
{"name":"IsAlgClosed.lift_def","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"M : Type u_1\ninst✝⁸ : Field M\ninst✝⁷ : IsAlgClosed M\nR : Type u_2\ninst✝⁶ : CommRing R\nS : Type u_3\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain S\ninst✝³ : Algebra R S\ninst✝² : Algebra R M\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : NoZeroSMulDivisors R M\n⊢ Eq IsAlgClosed.lift\n    (letFun ⋯ fun this =>\n      letFun ⋯ fun this_1 =>\n        let f := IsAlgClosed.lift_aux (FractionRing R) (FractionRing S) M;\n        (AlgHom.restrictScalars R f).comp (AlgHom.restrictScalars R (Algebra.ofId S (FractionRing S))))","decl":"/-- A (random) homomorphism from an algebraic extension of R into an algebraically\n  closed extension of R. -/\n@[stacks 09GU]\nnoncomputable irreducible_def lift : S →ₐ[R] M := by\n  letI : IsDomain R := (NoZeroSMulDivisors.algebraMap_injective R S).isDomain _\n  letI := FractionRing.liftAlgebra R M\n  letI := FractionRing.liftAlgebra R (FractionRing S)\n  have := FractionRing.isScalarTower_liftAlgebra R M\n  have := FractionRing.isScalarTower_liftAlgebra R (FractionRing S)\n  let f : FractionRing S →ₐ[FractionRing R] M := lift_aux (FractionRing R) (FractionRing S) M\n  exact (f.restrictScalars R).comp ((Algebra.ofId S (FractionRing S)).restrictScalars R)\n\n"}
{"name":"IsAlgClosed.perfectRing","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝³ : Field k\np : Nat\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : CharP k p\ninst✝ : IsAlgClosed k\n⊢ PerfectRing k p","decl":"noncomputable instance (priority := 100) perfectRing (p : ℕ) [Fact p.Prime] [CharP k p]\n    [IsAlgClosed k] : PerfectRing k p :=\n  PerfectRing.ofSurjective k p fun _ => IsAlgClosed.exists_pow_nat_eq _ <| NeZero.pos p\n\n"}
{"name":"IsAlgClosed.perfectField","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\n⊢ PerfectField k","decl":"noncomputable instance (priority := 100) perfectField [IsAlgClosed k] : PerfectField k := by\n  obtain _ | ⟨p, _, _⟩ := CharP.exists' k\n  exacts [.ofCharZero, PerfectRing.toPerfectField k p]\n\n"}
{"name":"IsAlgClosed.instInfinite","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : IsAlgClosed K\n⊢ Infinite K","decl":"/-- Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` -/\ninstance (priority := 500) {K : Type*} [Field K] [IsAlgClosed K] : Infinite K := by\n  apply Infinite.of_not_fintype\n  intro hfin\n  set n := Fintype.card K\n  set f := (X : K[X]) ^ (n + 1) - 1\n  have hfsep : Separable f := separable_X_pow_sub_C 1 (by simp [n]) one_ne_zero\n  apply Nat.not_succ_le_self (Fintype.card K)\n  have hroot : n.succ = Fintype.card (f.rootSet K) := by\n    erw [card_rootSet_eq_natDegree hfsep (IsAlgClosed.splits_domain _), natDegree_X_pow_sub_C]\n  rw [hroot]\n  exact Fintype.card_le_of_injective _ Subtype.coe_injective\n\n"}
{"name":"IsAlgClosure.ofAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"K : Type u_1\nJ : Type u_2\nL : Type v\ninst✝⁷ : Field K\ninst✝⁶ : Field J\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K J\ninst✝³ : Algebra J L\ninst✝² : IsAlgClosure J L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower K J L\nhKJ : Algebra.IsAlgebraic K J\n⊢ IsAlgClosure K L","decl":"/-- If `J` is an algebraic extension of `K` and `L` is an algebraic closure of `J`, then it is\n  also an algebraic closure of `K`. -/\ntheorem ofAlgebraic [hKJ : Algebra.IsAlgebraic K J] : IsAlgClosure K L :=\n  ⟨IsAlgClosure.isAlgClosed J, hKJ.trans⟩\n\n"}
{"name":"IsAlgClosure.equivOfEquiv_comp_algebraMap","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nS : Type u_3\nL : Type v\nM : Type w\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Field L\ninst✝⁶ : Field M\ninst✝⁵ : Algebra R M\ninst✝⁴ : NoZeroSMulDivisors R M\ninst✝³ : IsAlgClosure R M\ninst✝² : Algebra S L\ninst✝¹ : NoZeroSMulDivisors S L\ninst✝ : IsAlgClosure S L\nhSR : RingEquiv S R\n⊢ Eq ((↑(IsAlgClosure.equivOfEquiv L M hSR)).comp (algebraMap S L)) ((algebraMap R M).comp ↑hSR)","decl":"@[simp]\ntheorem equivOfEquiv_comp_algebraMap (hSR : S ≃+* R) :\n    (↑(equivOfEquiv L M hSR) : L →+* M).comp (algebraMap S L) = (algebraMap R M).comp hSR :=\n  (equivOfEquivAux L M hSR).2\n\n"}
{"name":"IsAlgClosure.equivOfEquiv_algebraMap","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nS : Type u_3\nL : Type v\nM : Type w\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Field L\ninst✝⁶ : Field M\ninst✝⁵ : Algebra R M\ninst✝⁴ : NoZeroSMulDivisors R M\ninst✝³ : IsAlgClosure R M\ninst✝² : Algebra S L\ninst✝¹ : NoZeroSMulDivisors S L\ninst✝ : IsAlgClosure S L\nhSR : RingEquiv S R\ns : S\n⊢ Eq ((IsAlgClosure.equivOfEquiv L M hSR) ((algebraMap S L) s)) ((algebraMap R M) (hSR s))","decl":"@[simp]\ntheorem equivOfEquiv_algebraMap (hSR : S ≃+* R) (s : S) :\n    equivOfEquiv L M hSR (algebraMap S L s) = algebraMap R M (hSR s) :=\n  RingHom.ext_iff.1 (equivOfEquiv_comp_algebraMap L M hSR) s\n\n"}
{"name":"IsAlgClosure.equivOfEquiv_symm_algebraMap","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nS : Type u_3\nL : Type v\nM : Type w\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Field L\ninst✝⁶ : Field M\ninst✝⁵ : Algebra R M\ninst✝⁴ : NoZeroSMulDivisors R M\ninst✝³ : IsAlgClosure R M\ninst✝² : Algebra S L\ninst✝¹ : NoZeroSMulDivisors S L\ninst✝ : IsAlgClosure S L\nhSR : RingEquiv S R\nr : R\n⊢ Eq ((IsAlgClosure.equivOfEquiv L M hSR).symm ((algebraMap R M) r)) ((algebraMap S L) (hSR.symm r))","decl":"@[simp]\ntheorem equivOfEquiv_symm_algebraMap (hSR : S ≃+* R) (r : R) :\n    (equivOfEquiv L M hSR).symm (algebraMap R M r) = algebraMap S L (hSR.symm r) :=\n  (equivOfEquiv L M hSR).injective (by simp)\n\n"}
{"name":"IsAlgClosure.equivOfEquiv_symm_comp_algebraMap","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"R : Type u\nS : Type u_3\nL : Type v\nM : Type w\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Field L\ninst✝⁶ : Field M\ninst✝⁵ : Algebra R M\ninst✝⁴ : NoZeroSMulDivisors R M\ninst✝³ : IsAlgClosure R M\ninst✝² : Algebra S L\ninst✝¹ : NoZeroSMulDivisors S L\ninst✝ : IsAlgClosure S L\nhSR : RingEquiv S R\n⊢ Eq ((↑(IsAlgClosure.equivOfEquiv L M hSR).symm).comp (algebraMap R M)) ((algebraMap S L).comp ↑hSR.symm)","decl":"@[simp]\ntheorem equivOfEquiv_symm_comp_algebraMap (hSR : S ≃+* R) :\n    ((equivOfEquiv L M hSR).symm : M →+* L).comp (algebraMap R M) =\n      (algebraMap S L).comp hSR.symm :=\n  RingHom.ext_iff.2 (equivOfEquiv_symm_algebraMap L M hSR)\n\n"}
{"name":"Algebra.IsAlgebraic.range_eval_eq_rootSet_minpoly","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Field A\ninst✝³ : Algebra F K\ninst✝² : Algebra F A\ninst✝¹ : Algebra.IsAlgebraic F K\ninst✝ : IsAlgClosed A\nx : K\n⊢ Eq (Set.range fun ψ => ψ x) ((minpoly F x).rootSet A)","decl":"/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K/F` an algebraic extension\n  of fields. Then the images of `x` by the `F`-algebra morphisms from `K` to `A` are exactly\n  the roots in `A` of the minimal polynomial of `x` over `F`. -/\ntheorem Algebra.IsAlgebraic.range_eval_eq_rootSet_minpoly [IsAlgClosed A] (x : K) :\n    (Set.range fun ψ : K →ₐ[F] A ↦ ψ x) = (minpoly F x).rootSet A :=\n  range_eval_eq_rootSet_minpoly_of_splits A (fun _ ↦ IsAlgClosed.splits_codomain _) x\n\n"}
{"name":"IntermediateField.algHomEquivAlgHomOfSplits_symm_apply","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field A\ninst✝² : Algebra F K\ninst✝¹ : Algebra F A\ninst✝ : Algebra.IsAlgebraic F K\nL : IntermediateField F A\nhL : ∀ (x : K), Polynomial.Splits (algebraMap F (Subtype fun x => Membership.mem L x)) (minpoly F x)\nf : AlgHom F K A\n⊢ Eq ((IntermediateField.algHomEquivAlgHomOfSplits A L hL).symm f) (f.codRestrict L.toSubalgebra ⋯)","decl":"/-- All `F`-embeddings of a field `K` into another field `A` factor through any intermediate\nfield of `A/F` in which the minimal polynomial of elements of `K` splits. -/\n@[simps]\ndef IntermediateField.algHomEquivAlgHomOfSplits (L : IntermediateField F A)\n    (hL : ∀ x : K, (minpoly F x).Splits (algebraMap F L)) :\n    (K →ₐ[F] L) ≃ (K →ₐ[F] A) where\n  toFun := L.val.comp\n  invFun f := f.codRestrict _ fun x ↦\n    ((Algebra.IsIntegral.isIntegral x).map f).mem_intermediateField_of_minpoly_splits <| by\n      rw [minpoly.algHom_eq f f.injective]; exact hL x\n  left_inv _ := rfl\n  right_inv _ := by rfl\n\n"}
{"name":"IntermediateField.algHomEquivAlgHomOfSplits_apply","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field A\ninst✝² : Algebra F K\ninst✝¹ : Algebra F A\ninst✝ : Algebra.IsAlgebraic F K\nL : IntermediateField F A\nhL : ∀ (x : K), Polynomial.Splits (algebraMap F (Subtype fun x => Membership.mem L x)) (minpoly F x)\nφ₂ : AlgHom F K (Subtype fun x => Membership.mem L x)\n⊢ Eq ((IntermediateField.algHomEquivAlgHomOfSplits A L hL) φ₂) (L.val.comp φ₂)","decl":"/-- All `F`-embeddings of a field `K` into another field `A` factor through any intermediate\nfield of `A/F` in which the minimal polynomial of elements of `K` splits. -/\n@[simps]\ndef IntermediateField.algHomEquivAlgHomOfSplits (L : IntermediateField F A)\n    (hL : ∀ x : K, (minpoly F x).Splits (algebraMap F L)) :\n    (K →ₐ[F] L) ≃ (K →ₐ[F] A) where\n  toFun := L.val.comp\n  invFun f := f.codRestrict _ fun x ↦\n    ((Algebra.IsIntegral.isIntegral x).map f).mem_intermediateField_of_minpoly_splits <| by\n      rw [minpoly.algHom_eq f f.injective]; exact hL x\n  left_inv _ := rfl\n  right_inv _ := by rfl\n\n"}
{"name":"IntermediateField.algHomEquivAlgHomOfSplits_apply_apply","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field A\ninst✝² : Algebra F K\ninst✝¹ : Algebra F A\ninst✝ : Algebra.IsAlgebraic F K\nL : IntermediateField F A\nhL : ∀ (x : K), Polynomial.Splits (algebraMap F (Subtype fun x => Membership.mem L x)) (minpoly F x)\nf : AlgHom F K (Subtype fun x => Membership.mem L x)\nx : K\n⊢ Eq (((IntermediateField.algHomEquivAlgHomOfSplits A L hL) f) x) ((algebraMap (Subtype fun x => Membership.mem L x) A) (f x))","decl":"theorem IntermediateField.algHomEquivAlgHomOfSplits_apply_apply (L : IntermediateField F A)\n    (hL : ∀ x : K, (minpoly F x).Splits (algebraMap F L)) (f : K →ₐ[F] L) (x : K) :\n    algHomEquivAlgHomOfSplits A L hL f x = algebraMap L A (f x) := rfl\n\n"}
{"name":"Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits_apply_apply","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁹ : Field F\ninst✝⁸ : Field K\ninst✝⁷ : Field A\ninst✝⁶ : Algebra F K\ninst✝⁵ : Algebra F A\ninst✝⁴ : Algebra.IsAlgebraic F K\nL : Type u_4\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L A\ninst✝ : IsScalarTower F L A\nhL : ∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)\nf : AlgHom F K L\nx : K\n⊢ Eq (((Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits A L hL) f) x) ((algebraMap L A) (f x))","decl":"theorem Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits_apply_apply (L : Type*) [Field L]\n    [Algebra F L] [Algebra L A] [IsScalarTower F L A]\n    (hL : ∀ x : K, (minpoly F x).Splits (algebraMap F L)) (f : K →ₐ[F] L) (x : K) :\n    Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits A L hL f x = algebraMap L A (f x) := rfl\n\n"}
{"name":"Polynomial.isRoot_of_isRoot_iff_dvd_derivative_mul","module":"Mathlib.FieldTheory.IsAlgClosed.Basic","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : CharZero K\nf g : Polynomial K\nhf0 : Ne f 0\n⊢ Iff (∀ (x : K), f.IsRoot x → g.IsRoot x) (Dvd.dvd f (HMul.hMul (Polynomial.derivative f) g))","decl":"/-- Over an algebraically closed field of characteristic zero a necessary and sufficient condition\nfor the set of roots of a nonzero polynomial `f` to be a subset of the set of roots of `g` is that\n`f` divides `f.derivative * g`. Over an integral domain, this is a sufficient but not necessary\ncondition. See `isRoot_of_isRoot_of_dvd_derivative_mul` -/\ntheorem Polynomial.isRoot_of_isRoot_iff_dvd_derivative_mul {K : Type*} [Field K]\n    [IsAlgClosed K] [CharZero K] {f g : K[X]} (hf0 : f ≠ 0) :\n    (∀ x, IsRoot f x → IsRoot g x) ↔ f ∣ f.derivative * g := by\n  refine ⟨?_, isRoot_of_isRoot_of_dvd_derivative_mul hf0⟩\n  by_cases hg0 : g = 0\n  · simp [hg0]\n  by_cases hdf0 : derivative f = 0\n  · rw [eq_C_of_derivative_eq_zero hdf0]\n    simp only [eval_C, derivative_C, zero_mul, dvd_zero, implies_true]\n  have hdg :  f.derivative * g ≠ 0 := mul_ne_zero hdf0 hg0\n  classical rw [Splits.dvd_iff_roots_le_roots (IsAlgClosed.splits f) hf0 hdg, Multiset.le_iff_count]\n  simp only [count_roots, rootMultiplicity_mul hdg]\n  refine forall_imp fun a => ?_\n  by_cases haf : f.eval a = 0\n  · have h0 : 0 < f.rootMultiplicity a := (rootMultiplicity_pos hf0).2 haf\n    rw [derivative_rootMultiplicity_of_root haf]\n    intro h\n    calc rootMultiplicity a f\n        = rootMultiplicity a f - 1 + 1 := (Nat.sub_add_cancel (Nat.succ_le_iff.1 h0)).symm\n      _ ≤ rootMultiplicity a f - 1 + rootMultiplicity a g := add_le_add le_rfl (Nat.succ_le_iff.1\n        ((rootMultiplicity_pos hg0).2 (h haf)))\n  · simp [haf, rootMultiplicity_eq_zero haf]\n"}
