{"name":"CategoryTheory.Limits.HasStrictInitialObjects.out","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasStrictInitialObjects C\nI A : C\nf : Quiver.Hom A I\naâœ : CategoryTheory.Limits.IsInitial I\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- We say `C` has strict initial objects if every initial object is strict, ie given any morphism\n`f : A âŸ¶ I` where `I` is initial, then `f` is an isomorphism.\n\nStrictly speaking, this says that *any* initial object must be strict, rather than that strict\ninitial objects exist.\n-/\nclass HasStrictInitialObjects : Prop where\n  out : âˆ€ {I A : C} (f : A âŸ¶ I), IsInitial I â†’ IsIso f\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.isIso_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictInitialObjects C\nI : C\nhI : CategoryTheory.Limits.IsInitial I\nA : C\nf : Quiver.Hom A I\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem IsInitial.isIso_to (hI : IsInitial I) {A : C} (f : A âŸ¶ I) : IsIso f :=\n  HasStrictInitialObjects.out f hI\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.strict_hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictInitialObjects C\nI : C\nhI : CategoryTheory.Limits.IsInitial I\nA : C\nf g : Quiver.Hom A I\nâŠ¢ Eq f g","decl":"theorem IsInitial.strict_hom_ext (hI : IsInitial I) {A : C} (f g : A âŸ¶ I) : f = g := by\n  haveI := hI.isIso_to f\n  haveI := hI.isIso_to g\n  exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.subsingleton_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictInitialObjects C\nI : C\nhI : CategoryTheory.Limits.IsInitial I\nA : C\nâŠ¢ Subsingleton (Quiver.Hom A I)","decl":"theorem IsInitial.subsingleton_to (hI : IsInitial I) {A : C} : Subsingleton (A âŸ¶ I) :=\n  âŸ¨hI.strict_hom_extâŸ©\n\n"}
{"name":"CategoryTheory.Limits.initial_mono_of_strict_initial_objects","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictInitialObjects C\nâŠ¢ CategoryTheory.Limits.InitialMonoClass C","decl":"instance (priority := 100) initial_mono_of_strict_initial_objects : InitialMonoClass C where\n  isInitial_mono_from := fun _ hI => { right_cancellation := fun _ _ _ => hI.strict_hom_ext _ _ }\n\n"}
{"name":"CategoryTheory.Limits.mulIsInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\nI X : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct X I\nhI : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.Limits.mulIsInitial X hI).hom CategoryTheory.Limits.prod.snd","decl":"/-- If `I` is initial, then `X â¨¯ I` is isomorphic to it. -/\n@[simps! hom]\nnoncomputable def mulIsInitial (X : C) [HasBinaryProduct X I] (hI : IsInitial I) : X â¨¯ I â‰… I := by\n  have := hI.isIso_to (prod.snd : X â¨¯ I âŸ¶ I)\n  exact asIso prod.snd\n\n"}
{"name":"CategoryTheory.Limits.mulIsInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\nI X : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct X I\nhI : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.Limits.mulIsInitial X hI).inv (hI.to (CategoryTheory.Limits.prod X I))","decl":"@[simp]\ntheorem mulIsInitial_inv (X : C) [HasBinaryProduct X I] (hI : IsInitial I) :\n    (mulIsInitial X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.isInitialMul_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\nI X : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct I X\nhI : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.Limits.isInitialMul X hI).hom CategoryTheory.Limits.prod.fst","decl":"/-- If `I` is initial, then `I â¨¯ X` is isomorphic to it. -/\n@[simps! hom]\nnoncomputable def isInitialMul (X : C) [HasBinaryProduct I X] (hI : IsInitial I) : I â¨¯ X â‰… I := by\n   have := hI.isIso_to (prod.fst : I â¨¯ X âŸ¶ I)\n   exact asIso prod.fst\n\n"}
{"name":"CategoryTheory.Limits.isInitialMul_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\nI X : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct I X\nhI : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.Limits.isInitialMul X hI).inv (hI.to (CategoryTheory.Limits.prod I X))","decl":"@[simp]\ntheorem isInitialMul_inv (X : C) [HasBinaryProduct I X] (hI : IsInitial I) :\n    (isInitialMul X hI).inv = hI.to _ :=\n  hI.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.initial_isIso_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœ : CategoryTheory.Limits.HasInitial C\nA : C\nf : Quiver.Hom A (CategoryTheory.Limits.initial C)\nâŠ¢ CategoryTheory.IsIso f","decl":"instance initial_isIso_to {A : C} (f : A âŸ¶ âŠ¥_ C) : IsIso f :=\n  initialIsInitial.isIso_to _\n\n"}
{"name":"CategoryTheory.Limits.initial.strict_hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœ : CategoryTheory.Limits.HasInitial C\nA : C\nf g : Quiver.Hom A (CategoryTheory.Limits.initial C)\nâŠ¢ Iff (Eq f g) True","decl":"@[ext]\ntheorem initial.strict_hom_ext {A : C} (f g : A âŸ¶ âŠ¥_ C) : f = g :=\n  initialIsInitial.strict_hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.initial.strict_hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœ : CategoryTheory.Limits.HasInitial C\nA : C\nf g : Quiver.Hom A (CategoryTheory.Limits.initial C)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem initial.strict_hom_ext {A : C} (f g : A âŸ¶ âŠ¥_ C) : f = g :=\n  initialIsInitial.strict_hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.initial.subsingleton_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœ : CategoryTheory.Limits.HasInitial C\nA : C\nâŠ¢ Subsingleton (Quiver.Hom A (CategoryTheory.Limits.initial C))","decl":"theorem initial.subsingleton_to {A : C} : Subsingleton (A âŸ¶ âŠ¥_ C) :=\n  initialIsInitial.subsingleton_to\n\n"}
{"name":"CategoryTheory.Limits.mulInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct X (CategoryTheory.Limits.initial C)\nâŠ¢ Eq (CategoryTheory.Limits.mulInitial X).hom CategoryTheory.Limits.prod.snd","decl":"/-- The product of `X` with an initial object in a category with strict initial objects is itself\ninitial.\nThis is the generalisation of the fact that `X Ã— Empty â‰ƒ Empty` for types (or `n * 0 = 0`).\n-/\n@[simps! hom]\nnoncomputable def mulInitial (X : C) [HasBinaryProduct X (âŠ¥_ C)] : X â¨¯ âŠ¥_ C â‰… âŠ¥_ C :=\n  mulIsInitial _ initialIsInitial\n\n"}
{"name":"CategoryTheory.Limits.mulInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct X (CategoryTheory.Limits.initial C)\nâŠ¢ Eq (CategoryTheory.Limits.mulInitial X).inv (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.prod X (CategoryTheory.Limits.initial C)))","decl":"@[simp]\ntheorem mulInitial_inv (X : C) [HasBinaryProduct X (âŠ¥_ C)] : (mulInitial X).inv = initial.to _ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.Limits.initialMul_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.initial C) X\nâŠ¢ Eq (CategoryTheory.Limits.initialMul X).hom CategoryTheory.Limits.prod.fst","decl":"/-- The product of `X` with an initial object in a category with strict initial objects is itself\ninitial.\nThis is the generalisation of the fact that `Empty Ã— X â‰ƒ Empty` for types (or `0 * n = 0`).\n-/\n@[simps! hom]\nnoncomputable def initialMul (X : C) [HasBinaryProduct (âŠ¥_ C) X] : (âŠ¥_ C) â¨¯ X â‰… âŠ¥_ C :=\n  isInitialMul _ initialIsInitial\n\n"}
{"name":"CategoryTheory.Limits.initialMul_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasStrictInitialObjects C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\nX : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.initial C) X\nâŠ¢ Eq (CategoryTheory.Limits.initialMul X).inv (CategoryTheory.Limits.initial.to (CategoryTheory.Limits.prod (CategoryTheory.Limits.initial C) X))","decl":"@[simp]\ntheorem initialMul_inv (X : C) [HasBinaryProduct (âŠ¥_ C) X] : (initialMul X).inv = initial.to _ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.Limits.hasStrictInitialObjects_of_initial_is_strict","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasInitial C\nh : âˆ€ (A : C) (f : Quiver.Hom A (CategoryTheory.Limits.initial C)), CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.Limits.HasStrictInitialObjects C","decl":"/-- If `C` has an initial object such that every morphism *to* it is an isomorphism, then `C`\nhas strict initial objects. -/\ntheorem hasStrictInitialObjects_of_initial_is_strict [HasInitial C]\n    (h : âˆ€ (A) (f : A âŸ¶ âŠ¥_ C), IsIso f) : HasStrictInitialObjects C :=\n  { out := fun {I A} f hI =>\n      haveI := h A (f â‰« hI.to _)\n      âŸ¨âŸ¨hI.to _ â‰« inv (f â‰« hI.to (âŠ¥_ C)), by rw [â† assoc, IsIso.hom_inv_id], hI.hom_ext _ _âŸ©âŸ© }\n\n"}
{"name":"CategoryTheory.Limits.HasStrictTerminalObjects.out","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasStrictTerminalObjects C\nI A : C\nf : Quiver.Hom I A\naâœ : CategoryTheory.Limits.IsTerminal I\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- We say `C` has strict terminal objects if every terminal object is strict, ie given any morphism\n`f : I âŸ¶ A` where `I` is terminal, then `f` is an isomorphism.\n\nStrictly speaking, this says that *any* terminal object must be strict, rather than that strict\nterminal objects exist.\n-/\nclass HasStrictTerminalObjects : Prop where\n  out : âˆ€ {I A : C} (f : I âŸ¶ A), IsTerminal I â†’ IsIso f\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.isIso_from","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictTerminalObjects C\nI : C\nhI : CategoryTheory.Limits.IsTerminal I\nA : C\nf : Quiver.Hom I A\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem IsTerminal.isIso_from (hI : IsTerminal I) {A : C} (f : I âŸ¶ A) : IsIso f :=\n  HasStrictTerminalObjects.out f hI\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.strict_hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictTerminalObjects C\nI : C\nhI : CategoryTheory.Limits.IsTerminal I\nA : C\nf g : Quiver.Hom I A\nâŠ¢ Eq f g","decl":"theorem IsTerminal.strict_hom_ext (hI : IsTerminal I) {A : C} (f g : I âŸ¶ A) : f = g := by\n  haveI := hI.isIso_from f\n  haveI := hI.isIso_from g\n  exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.subsingleton_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasStrictTerminalObjects C\nI : C\nhI : CategoryTheory.Limits.IsTerminal I\nA : C\nâŠ¢ Subsingleton (Quiver.Hom I A)","decl":"theorem IsTerminal.subsingleton_to (hI : IsTerminal I) {A : C} : Subsingleton (I âŸ¶ A) :=\n  âŸ¨hI.strict_hom_extâŸ©\n\n"}
{"name":"CategoryTheory.Limits.limit_Ï€_isIso_of_is_strict_terminal","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasStrictTerminalObjects C\nJ : Type v\ninstâœÂ² : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ni : J\nH : (j : J) â†’ Ne j i â†’ CategoryTheory.Limits.IsTerminal (F.obj j)\ninstâœ : Subsingleton (Quiver.Hom i i)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.Ï€ F i)","decl":"/-- If all but one object in a diagram is strict terminal, then the limit is isomorphic to the\nsaid object via `limit.Ï€`. -/\ntheorem limit_Ï€_isIso_of_is_strict_terminal (F : J â¥¤ C) [HasLimit F] (i : J)\n    (H : âˆ€ (j) (_ : j â‰  i), IsTerminal (F.obj j)) [Subsingleton (i âŸ¶ i)] : IsIso (limit.Ï€ F i) := by\n  classical\n    refine âŸ¨âŸ¨limit.lift _ âŸ¨_, âŸ¨?_, ?_âŸ©âŸ©, ?_, ?_âŸ©âŸ©\n    Â· exact fun j =>\n        dite (j = i)\n          (fun h => eqToHom (by cases h; rfl))\n          fun h => (H _ h).from _\n    Â· intro j k f\n      split_ifs with h h_1 h_1\n      Â· cases h\n        cases h_1\n        obtain rfl : f = ğŸ™ _ := Subsingleton.elim _ _\n        simp\n      Â· cases h\n        erw [Category.comp_id]\n        haveI : IsIso (F.map f) := (H _ h_1).isIso_from _\n        rw [â† IsIso.comp_inv_eq]\n        apply (H _ h_1).hom_ext\n      Â· cases h_1\n        apply (H _ h).hom_ext\n      Â· apply (H _ h).hom_ext\n    Â· ext\n      rw [assoc, limit.lift_Ï€]\n      dsimp only\n      split_ifs with h\n      Â· cases h\n        rw [id_comp, eqToHom_refl]\n        exact comp_id _\n      Â· apply (H _ h).hom_ext\n    Â· rw [limit.lift_Ï€]\n      simp\n\n"}
{"name":"CategoryTheory.Limits.terminal_isIso_from","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictTerminalObjects C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nf : Quiver.Hom (CategoryTheory.Limits.terminal C) A\nâŠ¢ CategoryTheory.IsIso f","decl":"instance terminal_isIso_from {A : C} (f : âŠ¤_ C âŸ¶ A) : IsIso f :=\n  terminalIsTerminal.isIso_from _\n\n"}
{"name":"CategoryTheory.Limits.terminal.strict_hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictTerminalObjects C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nf g : Quiver.Hom (CategoryTheory.Limits.terminal C) A\nâŠ¢ Iff (Eq f g) True","decl":"@[ext]\ntheorem terminal.strict_hom_ext {A : C} (f g : âŠ¤_ C âŸ¶ A) : f = g :=\n  terminalIsTerminal.strict_hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.terminal.strict_hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictTerminalObjects C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nf g : Quiver.Hom (CategoryTheory.Limits.terminal C) A\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem terminal.strict_hom_ext {A : C} (f g : âŠ¤_ C âŸ¶ A) : f = g :=\n  terminalIsTerminal.strict_hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.terminal.subsingleton_to","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasStrictTerminalObjects C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nâŠ¢ Subsingleton (Quiver.Hom (CategoryTheory.Limits.terminal C) A)","decl":"theorem terminal.subsingleton_to {A : C} : Subsingleton (âŠ¤_ C âŸ¶ A) :=\n  terminalIsTerminal.subsingleton_to\n\n"}
{"name":"CategoryTheory.Limits.hasStrictTerminalObjects_of_terminal_is_strict","module":"Mathlib.CategoryTheory.Limits.Shapes.StrictInitial","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : C\nh : âˆ€ (A : C) (f : Quiver.Hom I A), CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.Limits.HasStrictTerminalObjects C","decl":"/-- If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. -/\ntheorem hasStrictTerminalObjects_of_terminal_is_strict (I : C) (h : âˆ€ (A) (f : I âŸ¶ A), IsIso f) :\n    HasStrictTerminalObjects C :=\n  { out := fun {I' A} f hI' =>\n      haveI := h A (hI'.from _ â‰« f)\n      âŸ¨âŸ¨inv (hI'.from I â‰« f) â‰« hI'.from I, hI'.hom_ext _ _, by rw [assoc, IsIso.inv_hom_id]âŸ©âŸ© }\n\n"}
