{"name":"CategoryTheory.Limits.IsBilimit.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nJ : Type\ninst✝ : Fintype J\nf : J → C\nb : CategoryTheory.Limits.Bicone f\ni : b.IsBilimit\n⊢ Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (b.π j) (b.ι j)) (CategoryTheory.CategoryStruct.id b.pt)","decl":"theorem IsBilimit.total {f : J → C} {b : Bicone f} (i : b.IsBilimit) :\n    ∑ j : J, b.π j ≫ b.ι j = 𝟙 b.pt :=\n  i.isLimit.hom_ext fun j => by\n    classical\n    cases j\n    simp [sum_comp, b.ι_π, comp_dite]\n\n"}
{"name":"CategoryTheory.Limits.hasBiproduct_of_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nJ : Type\ninst✝ : Fintype J\nf : J → C\nb : CategoryTheory.Limits.Bicone f\ntotal : Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (b.π j) (b.ι j)) (CategoryTheory.CategoryStruct.id b.pt)\n⊢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, we can construct a biproduct for `f : J → C` from\nany bicone `b` for `f` satisfying `total : ∑ j : J, b.π j ≫ b.ι j = 𝟙 b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n-/\ntheorem hasBiproduct_of_total {f : J → C} (b : Bicone f)\n    (total : ∑ j : J, b.π j ≫ b.ι j = 𝟙 b.pt) : HasBiproduct f :=\n  HasBiproduct.mk\n    { bicone := b\n      isBilimit := isBilimitOfTotal b total }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.of_hasProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Finite J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasProduct f\n⊢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, if the product over `f : J → C` exists,\n    then the biproduct over `f` exists. -/\ntheorem HasBiproduct.of_hasProduct (f : J → C) [HasProduct f] : HasBiproduct f := by\n  cases nonempty_fintype J\n  exact HasBiproduct.mk\n    { bicone := _\n      isBilimit := biconeIsBilimitOfLimitConeOfIsLimit (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.of_hasCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Finite J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\n⊢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, if the coproduct over `f : J → C` exists,\n    then the biproduct over `f` exists. -/\ntheorem HasBiproduct.of_hasCoproduct (f : J → C) [HasCoproduct f] : HasBiproduct f := by\n  cases nonempty_fintype J\n  exact HasBiproduct.mk\n    { bicone := _\n      isBilimit := biconeIsBilimitOfColimitCoconeOfIsColimit (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"/-- A preadditive category with finite products has finite biproducts. -/\ntheorem HasFiniteBiproducts.of_hasFiniteProducts [HasFiniteProducts C] : HasFiniteBiproducts C :=\n  ⟨fun _ => { has_biproduct := fun _ => HasBiproduct.of_hasProduct _ }⟩\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"/-- A preadditive category with finite coproducts has finite biproducts. -/\ntheorem HasFiniteBiproducts.of_hasFiniteCoproducts [HasFiniteCoproducts C] :\n    HasFiniteBiproducts C :=\n  ⟨fun _ => { has_biproduct := fun _ => HasBiproduct.of_hasCoproduct _ }⟩\n\n"}
{"name":"CategoryTheory.Limits.biproduct.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\n⊢ Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (CategoryTheory.Limits.biproduct.ι f j)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct f))","decl":"/-- In any preadditive category, any biproduct satisfies\n`∑ j : J, biproduct.π f j ≫ biproduct.ι f j = 𝟙 (⨁ f)`\n-/\n@[simp]\ntheorem biproduct.total : ∑ j : J, biproduct.π f j ≫ biproduct.ι f j = 𝟙 (⨁ f) :=\n  IsBilimit.total (biproduct.isBilimit _)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nT : C\ng : (j : J) → Quiver.Hom T (f j)\n⊢ Eq (CategoryTheory.Limits.biproduct.lift g) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (CategoryTheory.Limits.biproduct.ι f j))","decl":"theorem biproduct.lift_eq {T : C} {g : ∀ j, T ⟶ f j} :\n    biproduct.lift g = ∑ j, g j ≫ biproduct.ι f j := by\n  classical\n  ext j\n  simp only [sum_comp, biproduct.ι_π, comp_dite, biproduct.lift_π, Category.assoc, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, eqToHom_refl, Category.comp_id, if_true]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.desc_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nT : C\ng : (j : J) → Quiver.Hom (f j) T\n⊢ Eq (CategoryTheory.Limits.biproduct.desc g) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (g j))","decl":"theorem biproduct.desc_eq {T : C} {g : ∀ j, f j ⟶ T} :\n    biproduct.desc g = ∑ j, biproduct.π f j ≫ g j := by\n  classical\n  ext j\n  simp [comp_sum, biproduct.ι_π_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nT U : C\ng : (j : J) → Quiver.Hom T (f j)\nh : (j : J) → Quiver.Hom (f j) U\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift g) (CategoryTheory.Limits.biproduct.desc h)) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (h j))","decl":"@[reassoc]\ntheorem biproduct.lift_desc {T U : C} {g : ∀ j, T ⟶ f j} {h : ∀ j, f j ⟶ U} :\n    biproduct.lift g ≫ biproduct.desc h = ∑ j : J, g j ≫ h j := by\n  classical\n  simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.ι_π_assoc, comp_dite,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nT U : C\ng : (j : J) → Quiver.Hom T (f j)\nh✝ : (j : J) → Quiver.Hom (f j) U\nZ : C\nh : Quiver.Hom U Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc h✝) h)) (CategoryTheory.CategoryStruct.comp (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (h✝ j)) h)","decl":"@[reassoc]\ntheorem biproduct.lift_desc {T U : C} {g : ∀ j, T ⟶ f j} {h : ∀ j, f j ⟶ U} :\n    biproduct.lift g ≫ biproduct.desc h = ∑ j : J, g j ≫ h j := by\n  classical\n  simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.ι_π_assoc, comp_dite,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nJ : Type\ninst✝¹ : Fintype J\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf g : J → C\nh : (j : J) → Quiver.Hom (f j) (g j)\n⊢ Eq (CategoryTheory.Limits.biproduct.map h) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (CategoryTheory.CategoryStruct.comp (h j) (CategoryTheory.Limits.biproduct.ι g j)))","decl":"theorem biproduct.map_eq [HasFiniteBiproducts C] {f g : J → C} {h : ∀ j, f j ⟶ g j} :\n    biproduct.map h = ∑ j : J, biproduct.π f j ≫ h j ≫ biproduct.ι g j := by\n  classical\n  ext\n  simp [biproduct.ι_π, biproduct.ι_π_assoc, comp_sum, sum_comp, comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_matrix_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ : Type\ninst✝² : Fintype J\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nP : C\nx : (j : J) → Quiver.Hom P (f j)\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (x j) (m j k)) h)","decl":"@[reassoc]\ntheorem biproduct.lift_matrix {K : Type} [Finite K] [HasFiniteBiproducts C] {f : J → C} {g : K → C}\n    {P} (x : ∀ j, P ⟶ f j) (m : ∀ j k, f j ⟶ g k) :\n    biproduct.lift x ≫ biproduct.matrix m = biproduct.lift fun k => ∑ j, x j ≫ m j k := by\n  ext\n  simp [biproduct.lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_matrix","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ : Type\ninst✝² : Fintype J\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nP : C\nx : (j : J) → Quiver.Hom P (f j)\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift x) (CategoryTheory.Limits.biproduct.matrix m)) (CategoryTheory.Limits.biproduct.lift fun k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (x j) (m j k))","decl":"@[reassoc]\ntheorem biproduct.lift_matrix {K : Type} [Finite K] [HasFiniteBiproducts C] {f : J → C} {g : K → C}\n    {P} (x : ∀ j, P ⟶ f j) (m : ∀ j k, f j ⟶ g k) :\n    biproduct.lift x ≫ biproduct.matrix m = biproduct.lift fun k => ∑ j, x j ≫ m j k := by\n  ext\n  simp [biproduct.lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Fintype K\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nP : C\nx : (k : K) → Quiver.Hom (g k) P\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.desc x)) (CategoryTheory.Limits.biproduct.desc fun j => Finset.univ.sum fun k => CategoryTheory.CategoryStruct.comp (m j k) (x k))","decl":"@[reassoc]\ntheorem biproduct.matrix_desc [Fintype K] {f : J → C} {g : K → C}\n    (m : ∀ j k, f j ⟶ g k) {P} (x : ∀ k, g k ⟶ P) :\n    biproduct.matrix m ≫ biproduct.desc x = biproduct.desc fun j => ∑ k, m j k ≫ x k := by\n  ext\n  simp [lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Fintype K\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nP : C\nx : (k : K) → Quiver.Hom (g k) P\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc x) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => Finset.univ.sum fun k => CategoryTheory.CategoryStruct.comp (m j k) (x k)) h)","decl":"@[reassoc]\ntheorem biproduct.matrix_desc [Fintype K] {f : J → C} {g : K → C}\n    (m : ∀ j k, f j ⟶ g k) {P} (x : ∀ k, g k ⟶ P) :\n    biproduct.matrix m ≫ biproduct.desc x = biproduct.desc fun j => ∑ k, m j k ≫ x k := by\n  ext\n  simp [lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_map","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Finite K\nf : J → C\ng h : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nn : (k : K) → Quiver.Hom (g k) (h k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.map n)) (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j k) (n k))","decl":"@[reassoc]\ntheorem biproduct.matrix_map {f : J → C} {g : K → C} {h : K → C} (m : ∀ j k, f j ⟶ g k)\n    (n : ∀ k, g k ⟶ h k) :\n    biproduct.matrix m ≫ biproduct.map n = biproduct.matrix fun j k => m j k ≫ n k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_map_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Finite K\nf : J → C\ng h✝ : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nn : (k : K) → Quiver.Hom (g k) (h✝ k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct h✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j k) (n k)) h)","decl":"@[reassoc]\ntheorem biproduct.matrix_map {f : J → C} {g : K → C} {h : K → C} (m : ∀ j k, f j ⟶ g k)\n    (n : ∀ k, g k ⟶ h k) :\n    biproduct.matrix m ≫ biproduct.map n = biproduct.matrix fun j k => m j k ≫ n k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_matrix_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Finite K\nf g : J → C\nh✝ : K → C\nm : (k : J) → Quiver.Hom (f k) (g k)\nn : (j : J) → (k : K) → Quiver.Hom (g j) (h✝ k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct h✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j) (n j k)) h)","decl":"@[reassoc]\ntheorem biproduct.map_matrix {f : J → C} {g : J → C} {h : K → C} (m : ∀ k, f k ⟶ g k)\n    (n : ∀ j k, g j ⟶ h k) :\n    biproduct.map m ≫ biproduct.matrix n = biproduct.matrix fun j k => m j ≫ n j k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_matrix","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nJ K : Type\ninst✝² : Finite J\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Finite K\nf g : J → C\nh : K → C\nm : (k : J) → Quiver.Hom (f k) (g k)\nn : (j : J) → (k : K) → Quiver.Hom (g j) (h k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map m) (CategoryTheory.Limits.biproduct.matrix n)) (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j) (n j k))","decl":"@[reassoc]\ntheorem biproduct.map_matrix {f : J → C} {g : J → C} {h : K → C} (m : ∀ k, f k ⟶ g k)\n    (n : ∀ j k, g j ⟶ h k) :\n    biproduct.map m ≫ biproduct.matrix n = biproduct.matrix fun j k => m j ≫ n j k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.reindex_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nβ γ : Type\ninst✝² : Finite β\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp f ⇑ε)\n⊢ Eq (CategoryTheory.Limits.biproduct.reindex ε f).hom (CategoryTheory.Limits.biproduct.desc fun b => CategoryTheory.Limits.biproduct.ι f (ε b))","decl":"/-- Reindex a categorical biproduct via an equivalence of the index types. -/\n@[simps]\ndef biproduct.reindex {β γ : Type} [Finite β] (ε : β ≃ γ)\n    (f : γ → C) [HasBiproduct f] [HasBiproduct (f ∘ ε)] : ⨁ f ∘ ε ≅ ⨁ f where\n  hom := biproduct.desc fun b => biproduct.ι f (ε b)\n  inv := biproduct.lift fun b => biproduct.π f (ε b)\n  hom_inv_id := by\n    ext b b'\n    by_cases h : b' = b\n    · subst h; simp\n    · have : ε b' ≠ ε b := by simp [h]\n      simp [biproduct.ι_π_ne _ h, biproduct.ι_π_ne _ this]\n  inv_hom_id := by\n    classical\n    cases nonempty_fintype β\n    ext g g'\n    by_cases h : g' = g <;>\n      simp [Preadditive.sum_comp, Preadditive.comp_sum, biproduct.lift_desc,\n        biproduct.ι_π, biproduct.ι_π_assoc, comp_dite, Equiv.apply_eq_iff_eq_symm_apply,\n        Finset.sum_dite_eq' Finset.univ (ε.symm g') _, h]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.reindex_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nβ γ : Type\ninst✝² : Finite β\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp f ⇑ε)\n⊢ Eq (CategoryTheory.Limits.biproduct.reindex ε f).inv (CategoryTheory.Limits.biproduct.lift fun b => CategoryTheory.Limits.biproduct.π f (ε b))","decl":"/-- Reindex a categorical biproduct via an equivalence of the index types. -/\n@[simps]\ndef biproduct.reindex {β γ : Type} [Finite β] (ε : β ≃ γ)\n    (f : γ → C) [HasBiproduct f] [HasBiproduct (f ∘ ε)] : ⨁ f ∘ ε ≅ ⨁ f where\n  hom := biproduct.desc fun b => biproduct.ι f (ε b)\n  inv := biproduct.lift fun b => biproduct.π f (ε b)\n  hom_inv_id := by\n    ext b b'\n    by_cases h : b' = b\n    · subst h; simp\n    · have : ε b' ≠ ε b := by simp [h]\n      simp [biproduct.ι_π_ne _ h, biproduct.ι_π_ne _ this]\n  inv_hom_id := by\n    classical\n    cases nonempty_fintype β\n    ext g g'\n    by_cases h : g' = g <;>\n      simp [Preadditive.sum_comp, Preadditive.comp_sum, biproduct.lift_desc,\n        biproduct.ι_π, biproduct.ι_π_assoc, comp_dite, Equiv.apply_eq_iff_eq_symm_apply,\n        Finset.sum_dite_eq' Finset.univ (ε.symm g') _, h]\n\n"}
{"name":"CategoryTheory.Limits.IsBilimit.binary_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\ni : b.IsBilimit\n⊢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp b.fst b.inl) (CategoryTheory.CategoryStruct.comp b.snd b.inr)) (CategoryTheory.CategoryStruct.id b.pt)","decl":"theorem IsBilimit.binary_total {X Y : C} {b : BinaryBicone X Y} (i : b.IsBilimit) :\n    b.fst ≫ b.inl + b.snd ≫ b.inr = 𝟙 b.pt :=\n  i.isLimit.hom_ext fun j => by rcases j with ⟨⟨⟩⟩ <;> simp\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryBiproduct_of_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp b.fst b.inl) (CategoryTheory.CategoryStruct.comp b.snd b.inr)) (CategoryTheory.CategoryStruct.id b.pt)\n⊢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, we can construct a binary biproduct for `X Y : C` from\nany binary bicone `b` satisfying `total : b.fst ≫ b.inl + b.snd ≫ b.inr = 𝟙 b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n-/\ntheorem hasBinaryBiproduct_of_total {X Y : C} (b : BinaryBicone X Y)\n    (total : b.fst ≫ b.inl + b.snd ≫ b.inr = 𝟙 b.pt) : HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := b\n      isBilimit := isBinaryBilimitOfTotal b total }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).fst (t.π.app { as := CategoryTheory.Limits.WalkingPair.left })","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.π.app ⟨WalkingPair.left⟩\n  snd := t.π.app ⟨WalkingPair.right⟩\n  inl := ht.lift (BinaryFan.mk (𝟙 X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (𝟙 Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).inl (ht.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.π.app ⟨WalkingPair.left⟩\n  snd := t.π.app ⟨WalkingPair.right⟩\n  inl := ht.lift (BinaryFan.mk (𝟙 X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (𝟙 Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).inr (ht.lift (CategoryTheory.Limits.BinaryFan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.π.app ⟨WalkingPair.left⟩\n  snd := t.π.app ⟨WalkingPair.right⟩\n  inl := ht.lift (BinaryFan.mk (𝟙 X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (𝟙 Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).snd (t.π.app { as := CategoryTheory.Limits.WalkingPair.right })","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.π.app ⟨WalkingPair.left⟩\n  snd := t.π.app ⟨WalkingPair.right⟩\n  inl := ht.lift (BinaryFan.mk (𝟙 X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (𝟙 Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).pt t.pt","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.π.app ⟨WalkingPair.left⟩\n  snd := t.π.app ⟨WalkingPair.right⟩\n  inl := ht.lift (BinaryFan.mk (𝟙 X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (𝟙 Y))\n\n"}
{"name":"CategoryTheory.Limits.inl_of_isLimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsLimit t.toCone\n⊢ Eq t.inl (ht.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :\n    t.inl = ht.lift (BinaryFan.mk (𝟙 X) 0) := by\n  apply ht.uniq (BinaryFan.mk (𝟙 X) 0); rintro ⟨⟨⟩⟩ <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.inr_of_isLimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsLimit t.toCone\n⊢ Eq t.inr (ht.lift (CategoryTheory.Limits.BinaryFan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :\n    t.inr = ht.lift (BinaryFan.mk 0 (𝟙 Y)) := by\n  apply ht.uniq (BinaryFan.mk 0 (𝟙 Y)); rintro ⟨⟨⟩⟩ <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, if the product of `X` and `Y` exists, then the\n    binary biproduct of `X` and `Y` exists. -/\ntheorem HasBinaryBiproduct.of_hasBinaryProduct (X Y : C) [HasBinaryProduct X Y] :\n    HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := _\n      isBilimit := binaryBiconeIsBilimitOfLimitConeOfIsLimit (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- In a preadditive category, if all binary products exist, then all binary biproducts exist. -/\ntheorem HasBinaryBiproducts.of_hasBinaryProducts [HasBinaryProducts C] : HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryProduct X Y }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).inr (t.ι.app { as := CategoryTheory.Limits.WalkingPair.right })","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (𝟙 X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (𝟙 Y))\n  inl := t.ι.app ⟨WalkingPair.left⟩\n  inr := t.ι.app ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).inl (t.ι.app { as := CategoryTheory.Limits.WalkingPair.left })","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (𝟙 X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (𝟙 Y))\n  inl := t.ι.app ⟨WalkingPair.left⟩\n  inr := t.ι.app ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).pt t.pt","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (𝟙 X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (𝟙 Y))\n  inl := t.ι.app ⟨WalkingPair.left⟩\n  inr := t.ι.app ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).snd (ht.desc (CategoryTheory.Limits.BinaryCofan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (𝟙 X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (𝟙 Y))\n  inl := t.ι.app ⟨WalkingPair.left⟩\n  inr := t.ι.app ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).fst (ht.desc (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (𝟙 X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (𝟙 Y))\n  inl := t.ι.app ⟨WalkingPair.left⟩\n  inr := t.ι.app ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.fst_of_isColimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsColimit t.toCocone\n⊢ Eq t.fst (ht.desc (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :\n    t.fst = ht.desc (BinaryCofan.mk (𝟙 X) 0) := by\n  apply ht.uniq (BinaryCofan.mk (𝟙 X) 0)\n  rintro ⟨⟨⟩⟩ <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.snd_of_isColimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsColimit t.toCocone\n⊢ Eq t.snd (ht.desc (CategoryTheory.Limits.BinaryCofan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :\n    t.snd = ht.desc (BinaryCofan.mk 0 (𝟙 Y)) := by\n  apply ht.uniq (BinaryCofan.mk 0 (𝟙 Y))\n  rintro ⟨⟨⟩⟩ <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, if the coproduct of `X` and `Y` exists, then the\n    binary biproduct of `X` and `Y` exists. -/\ntheorem HasBinaryBiproduct.of_hasBinaryCoproduct (X Y : C) [HasBinaryCoproduct X Y] :\n    HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := _\n      isBilimit := binaryBiconeIsBilimitOfColimitCoconeOfIsColimit (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\n⊢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- In a preadditive category, if all binary coproducts exist, then all binary biproducts exist. -/\ntheorem HasBinaryBiproducts.of_hasBinaryCoproducts [HasBinaryCoproducts C] :\n    HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryCoproduct X Y }\n\n"}
{"name":"CategoryTheory.Limits.biprod.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.inr)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod X Y))","decl":"/-- In any preadditive category, any binary biproduct satisfies\n`biprod.fst ≫ biprod.inl + biprod.snd ≫ biprod.inr = 𝟙 (X ⊞ Y)`.\n-/\n@[simp]\ntheorem biprod.total : biprod.fst ≫ biprod.inl + biprod.snd ≫ biprod.inr = 𝟙 (X ⊞ Y) := by\n  ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\n⊢ Eq (CategoryTheory.Limits.biprod.lift f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr))","decl":"theorem biprod.lift_eq {T : C} {f : T ⟶ X} {g : T ⟶ Y} :\n    biprod.lift f g = f ≫ biprod.inl + g ≫ biprod.inr := by ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.desc_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\n⊢ Eq (CategoryTheory.Limits.biprod.desc f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd g))","decl":"theorem biprod.desc_eq {T : C} {f : X ⟶ T} {g : Y ⟶ T} :\n    biprod.desc f g = biprod.fst ≫ f + biprod.snd ≫ g := by ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT U : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nh✝ : Quiver.Hom X U\ni : Quiver.Hom Y U\nZ : C\nh : Quiver.Hom U Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc h✝ i) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_desc {T U : C} {f : T ⟶ X} {g : T ⟶ Y} {h : X ⟶ U} {i : Y ⟶ U} :\n    biprod.lift f g ≫ biprod.desc h i = f ≫ h + g ≫ i := by simp [biprod.lift_eq, biprod.desc_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT U : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nh : Quiver.Hom X U\ni : Quiver.Hom Y U\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc h i)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_desc {T U : C} {f : T ⟶ X} {g : T ⟶ Y} {h : X ⟶ U} {i : Y ⟶ U} :\n    biprod.lift f g ≫ biprod.desc h i = f ≫ h + g ≫ i := by simp [biprod.lift_eq, biprod.desc_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.Limits.biprod.map f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr)))","decl":"theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ⟶ Y} {g : X ⟶ Z} :\n    biprod.map f g = biprod.fst ≫ f ≫ biprod.inl + biprod.snd ≫ g ≫ biprod.inr := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).fst (CategoryTheory.retraction f)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ⟶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.π\n  inl := f\n  inr :=\n    let c' : CokernelCofork (𝟙 Y - (𝟙 Y - retraction f ≫ f)) :=\n      CokernelCofork.ofπ (Cofork.π c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofπ]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.π\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.π_desc_assoc, CokernelCofork.π_ofπ, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).inr\n    (let c' := CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.Limits.Cofork.π c) ⋯;\n    let i' := CategoryTheory.Limits.isCokernelEpiComp i (CategoryTheory.retraction f) ⋯;\n    let i'' := CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork i';\n    (CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork C ⋯ i'').section_)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ⟶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.π\n  inl := f\n  inr :=\n    let c' : CokernelCofork (𝟙 Y - (𝟙 Y - retraction f ≫ f)) :=\n      CokernelCofork.ofπ (Cofork.π c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofπ]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.π\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.π_desc_assoc, CokernelCofork.π_ofπ, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).inl f","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ⟶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.π\n  inl := f\n  inr :=\n    let c' : CokernelCofork (𝟙 Y - (𝟙 Y - retraction f ≫ f)) :=\n      CokernelCofork.ofπ (Cofork.π c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofπ]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.π\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.π_desc_assoc, CokernelCofork.π_ofπ, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).pt Y","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ⟶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.π\n  inl := f\n  inr :=\n    let c' : CokernelCofork (𝟙 Y - (𝟙 Y - retraction f ≫ f)) :=\n      CokernelCofork.ofπ (Cofork.π c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofπ]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.π\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.π_desc_assoc, CokernelCofork.π_ofπ, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).snd (CategoryTheory.Limits.Cofork.π c)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ⟶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.π\n  inl := f\n  inr :=\n    let c' : CokernelCofork (𝟙 Y - (𝟙 Y - retraction f ≫ f)) :=\n      CokernelCofork.ofπ (Cofork.π c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofπ]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.π\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.π_desc_assoc, CokernelCofork.π_ofπ, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).snd f","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ⟶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (𝟙 X - (𝟙 X - f ≫ section_ f)) := KernelFork.ofι (Fork.ι c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.ι\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_ι]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.ι\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_ι,\n        Fork.ι_ofι, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).inl (CategoryTheory.Limits.Fork.ι c)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ⟶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (𝟙 X - (𝟙 X - f ≫ section_ f)) := KernelFork.ofι (Fork.ι c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.ι\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_ι]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.ι\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_ι,\n        Fork.ι_ofι, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).fst\n    (let c' := CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Limits.Fork.ι c) ⋯;\n    let i' := CategoryTheory.Limits.isKernelCompMono i (CategoryTheory.section_ f) ⋯;\n    let i'' := CategoryTheory.Preadditive.isLimitForkOfKernelFork i';\n    (CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork C ⋯ i'').retraction)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ⟶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (𝟙 X - (𝟙 X - f ≫ section_ f)) := KernelFork.ofι (Fork.ι c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.ι\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_ι]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.ι\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_ι,\n        Fork.ι_ofι, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).pt X","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ⟶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (𝟙 X - (𝟙 X - f ≫ section_ f)) := KernelFork.ofι (Fork.ι c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.ι\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_ι]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.ι\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_ι,\n        Fork.ι_ofι, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).inr (CategoryTheory.section_ f)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ⟶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (𝟙 X - (𝟙 X - f ≫ section_ f)) := KernelFork.ofι (Fork.ι c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.ι\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_ι]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.ι\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_ι,\n        Fork.ι_ofι, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.biprod.add_eq_lift_id_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X X\n⊢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.biprod.desc f g))","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ntheorem biprod.add_eq_lift_id_desc [HasBinaryBiproduct X X] :\n    f + g = biprod.lift (𝟙 X) (𝟙 X) ≫ biprod.desc f g := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.add_eq_lift_desc_id","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Y\n⊢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ntheorem biprod.add_eq_lift_desc_id [HasBinaryBiproduct Y Y] :\n    f + g = biprod.lift f g ≫ biprod.desc (𝟙 Y) (𝟙 Y) := by simp\n\n"}
{"name":"CategoryTheory.Preadditive.ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx y : CategoryTheory.Preadditive C\n⊢ Iff (Eq x y) (Eq CategoryTheory.Preadditive.homGroup CategoryTheory.Preadditive.homGroup)","decl":"attribute [local ext] Preadditive\n\n"}
{"name":"CategoryTheory.Preadditive.ext","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx y : CategoryTheory.Preadditive C\nhomGroup : Eq CategoryTheory.Preadditive.homGroup CategoryTheory.Preadditive.homGroup\n⊢ Eq x y","decl":"attribute [local ext] Preadditive\n\n"}
{"name":"CategoryTheory.subsingleton_preadditive_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ Subsingleton (CategoryTheory.Preadditive C)","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ninstance subsingleton_preadditive_of_hasBinaryBiproducts {C : Type u} [Category.{v} C]\n    [HasZeroMorphisms C] [HasBinaryBiproducts C] : Subsingleton (Preadditive C) where\n  allEq := fun a b => by\n    apply Preadditive.ext; funext X Y; apply AddCommGroup.ext; funext f g\n    have h₁ := @biprod.add_eq_lift_id_desc _ _ a _ _ f g\n      (by convert (inferInstance : HasBinaryBiproduct X X); subsingleton)\n    have h₂ := @biprod.add_eq_lift_id_desc _ _ b _ _ f g\n      (by convert (inferInstance : HasBinaryBiproduct X X); subsingleton)\n    refine h₁.trans (Eq.trans ?_ h₂.symm)\n    congr! 2 <;> subsingleton\n\n"}
{"name":"CategoryTheory.Biprod.inl_ofComponents","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ : C\nf₁₁ : Quiver.Hom X₁ Y₁\nf₁₂ : Quiver.Hom X₁ Y₂\nf₂₁ : Quiver.Hom X₂ Y₁\nf₂₂ : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₁₁ CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp f₁₂ CategoryTheory.Limits.biprod.inr))","decl":"@[simp]\ntheorem Biprod.inl_ofComponents :\n    biprod.inl ≫ Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂ = f₁₁ ≫ biprod.inl + f₁₂ ≫ biprod.inr := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.inr_ofComponents","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ : C\nf₁₁ : Quiver.Hom X₁ Y₁\nf₁₂ : Quiver.Hom X₁ Y₂\nf₂₁ : Quiver.Hom X₂ Y₁\nf₂₂ : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₂₁ CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp f₂₂ CategoryTheory.Limits.biprod.inr))","decl":"@[simp]\ntheorem Biprod.inr_ofComponents :\n    biprod.inr ≫ Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂ = f₂₁ ≫ biprod.inl + f₂₂ ≫ biprod.inr := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ : C\nf₁₁ : Quiver.Hom X₁ Y₁\nf₁₂ : Quiver.Hom X₁ Y₂\nf₂₁ : Quiver.Hom X₂ Y₁\nf₂₂ : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂) CategoryTheory.Limits.biprod.fst) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f₁₁) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd f₂₁))","decl":"@[simp]\ntheorem Biprod.ofComponents_fst :\n    Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂ ≫ biprod.fst = biprod.fst ≫ f₁₁ + biprod.snd ≫ f₂₁ := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ : C\nf₁₁ : Quiver.Hom X₁ Y₁\nf₁₂ : Quiver.Hom X₁ Y₂\nf₂₁ : Quiver.Hom X₂ Y₁\nf₂₂ : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂) CategoryTheory.Limits.biprod.snd) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f₁₂) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd f₂₂))","decl":"@[simp]\ntheorem Biprod.ofComponents_snd :\n    Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂ ≫ biprod.snd = biprod.fst ≫ f₁₂ + biprod.snd ≫ f₂₂ := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ : C\nf : Quiver.Hom (CategoryTheory.Limits.biprod X₁ X₂) (CategoryTheory.Limits.biprod Y₁ Y₂)\n⊢ Eq (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd))) f","decl":"@[simp]\ntheorem Biprod.ofComponents_eq (f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂) :\n    Biprod.ofComponents (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)\n        (biprod.inr ≫ f ≫ biprod.fst) (biprod.inr ≫ f ≫ biprod.snd) =\n      f := by\n  ext <;>\n    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,\n      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,\n      comp_zero, biprod.inl_fst, Preadditive.add_comp]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_comp","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ Y₁ Y₂ Z₁ Z₂ : C\nf₁₁ : Quiver.Hom X₁ Y₁\nf₁₂ : Quiver.Hom X₁ Y₂\nf₂₁ : Quiver.Hom X₂ Y₁\nf₂₂ : Quiver.Hom X₂ Y₂\ng₁₁ : Quiver.Hom Y₁ Z₁\ng₁₂ : Quiver.Hom Y₁ Z₂\ng₂₁ : Quiver.Hom Y₂ Z₁\ng₂₂ : Quiver.Hom Y₂ Z₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂) (CategoryTheory.Biprod.ofComponents g₁₁ g₁₂ g₂₁ g₂₂)) (CategoryTheory.Biprod.ofComponents (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₁₁ g₁₁) (CategoryTheory.CategoryStruct.comp f₁₂ g₂₁)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₁₁ g₁₂) (CategoryTheory.CategoryStruct.comp f₁₂ g₂₂)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₂₁ g₁₁) (CategoryTheory.CategoryStruct.comp f₂₂ g₂₁)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f₂₁ g₁₂) (CategoryTheory.CategoryStruct.comp f₂₂ g₂₂)))","decl":"@[simp]\ntheorem Biprod.ofComponents_comp {X₁ X₂ Y₁ Y₂ Z₁ Z₂ : C} (f₁₁ : X₁ ⟶ Y₁) (f₁₂ : X₁ ⟶ Y₂)\n    (f₂₁ : X₂ ⟶ Y₁) (f₂₂ : X₂ ⟶ Y₂) (g₁₁ : Y₁ ⟶ Z₁) (g₁₂ : Y₁ ⟶ Z₂) (g₂₁ : Y₂ ⟶ Z₁)\n    (g₂₂ : Y₂ ⟶ Z₂) :\n    Biprod.ofComponents f₁₁ f₁₂ f₂₁ f₂₂ ≫ Biprod.ofComponents g₁₁ g₁₂ g₂₁ g₂₂ =\n      Biprod.ofComponents (f₁₁ ≫ g₁₁ + f₁₂ ≫ g₂₁) (f₁₁ ≫ g₁₂ + f₁₂ ≫ g₂₂) (f₂₁ ≫ g₁₁ + f₂₂ ≫ g₂₁)\n        (f₂₁ ≫ g₁₂ + f₂₂ ≫ g₂₂) := by\n  dsimp [Biprod.ofComponents]\n  ext <;>\n    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,\n      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,\n      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.Biprod.unipotentUpper_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ : C\nr : Quiver.Hom X₁ X₂\n⊢ Eq (CategoryTheory.Biprod.unipotentUpper r).inv (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id X₁) (Neg.neg r) 0 (CategoryTheory.CategoryStruct.id X₂))","decl":"/-- The unipotent upper triangular matrix\n```\n(1 r)\n(0 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentUpper {X₁ X₂ : C} (r : X₁ ⟶ X₂) : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂ where\n  hom := Biprod.ofComponents (𝟙 _) r 0 (𝟙 _)\n  inv := Biprod.ofComponents (𝟙 _) (-r) 0 (𝟙 _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentUpper_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ : C\nr : Quiver.Hom X₁ X₂\n⊢ Eq (CategoryTheory.Biprod.unipotentUpper r).hom (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id X₁) r 0 (CategoryTheory.CategoryStruct.id X₂))","decl":"/-- The unipotent upper triangular matrix\n```\n(1 r)\n(0 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentUpper {X₁ X₂ : C} (r : X₁ ⟶ X₂) : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂ where\n  hom := Biprod.ofComponents (𝟙 _) r 0 (𝟙 _)\n  inv := Biprod.ofComponents (𝟙 _) (-r) 0 (𝟙 _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentLower_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ : C\nr : Quiver.Hom X₂ X₁\n⊢ Eq (CategoryTheory.Biprod.unipotentLower r).hom (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id X₁) 0 r (CategoryTheory.CategoryStruct.id X₂))","decl":"/-- The unipotent lower triangular matrix\n```\n(1 0)\n(r 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentLower {X₁ X₂ : C} (r : X₂ ⟶ X₁) : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂ where\n  hom := Biprod.ofComponents (𝟙 _) 0 r (𝟙 _)\n  inv := Biprod.ofComponents (𝟙 _) 0 (-r) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentLower_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX₁ X₂ : C\nr : Quiver.Hom X₂ X₁\n⊢ Eq (CategoryTheory.Biprod.unipotentLower r).inv (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id X₁) 0 (Neg.neg r) (CategoryTheory.CategoryStruct.id X₂))","decl":"/-- The unipotent lower triangular matrix\n```\n(1 0)\n(r 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentLower {X₁ X₂ : C} (r : X₂ ⟶ X₁) : X₁ ⊞ X₂ ≅ X₁ ⊞ X₂ where\n  hom := Biprod.ofComponents (𝟙 _) 0 r (𝟙 _)\n  inv := Biprod.ofComponents (𝟙 _) 0 (-r) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Biprod.column_nonzero_of_iso","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom (CategoryTheory.Limits.biprod W X) (CategoryTheory.Limits.biprod Y Z)\ninst✝ : CategoryTheory.IsIso f\n⊢ Or (Eq (CategoryTheory.CategoryStruct.id W) 0) (Or (Ne (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) 0) (Ne (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd)) 0))","decl":"theorem Biprod.column_nonzero_of_iso {W X Y Z : C} (f : W ⊞ X ⟶ Y ⊞ Z) [IsIso f] :\n    𝟙 W = 0 ∨ biprod.inl ≫ f ≫ biprod.fst ≠ 0 ∨ biprod.inl ≫ f ≫ biprod.snd ≠ 0 := by\n  by_contra! h\n  rcases h with ⟨nz, a₁, a₂⟩\n  set x := biprod.inl ≫ f ≫ inv f ≫ biprod.fst\n  have h₁ : x = 𝟙 W := by simp [x]\n  have h₀ : x = 0 := by\n    dsimp [x]\n    rw [← Category.id_comp (inv f), Category.assoc, ← biprod.total]\n    conv_lhs =>\n      slice 2 3\n      rw [comp_add]\n    simp only [Category.assoc]\n    rw [comp_add_assoc, add_comp]\n    conv_lhs =>\n      congr\n      next => skip\n      slice 1 3\n      rw [a₂]\n    simp only [zero_comp, add_zero]\n    conv_lhs =>\n      slice 1 3\n      rw [a₁]\n    simp only [zero_comp]\n  exact nz (h₁.symm.trans h₀)\n\n"}
{"name":"CategoryTheory.Biproduct.column_nonzero_of_iso'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nσ τ : Type\ninst✝³ : Finite τ\nS : σ → C\ninst✝² : CategoryTheory.Limits.HasBiproduct S\nT : τ → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct T\ns : σ\nf : Quiver.Hom (CategoryTheory.Limits.biproduct S) (CategoryTheory.Limits.biproduct T)\ninst✝ : CategoryTheory.IsIso f\na✝ : ∀ (t : τ), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι S s) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.biproduct.π T t))) 0\n⊢ Eq (CategoryTheory.CategoryStruct.id (S s)) 0","decl":"theorem Biproduct.column_nonzero_of_iso' {σ τ : Type} [Finite τ] {S : σ → C} [HasBiproduct S]\n    {T : τ → C} [HasBiproduct T] (s : σ) (f : ⨁ S ⟶ ⨁ T) [IsIso f] :\n    (∀ t : τ, biproduct.ι S s ≫ f ≫ biproduct.π T t = 0) → 𝟙 (S s) = 0 := by\n  cases nonempty_fintype τ\n  intro z\n  have reassoced {t : τ} {W : C} (h : _ ⟶ W) :\n    biproduct.ι S s ≫ f ≫ biproduct.π T t ≫ h = 0 ≫ h := by\n    simp only [← Category.assoc]\n    apply eq_whisker\n    simp only [Category.assoc]\n    apply z\n  set x := biproduct.ι S s ≫ f ≫ inv f ≫ biproduct.π S s\n  have h₁ : x = 𝟙 (S s) := by simp [x]\n  have h₀ : x = 0 := by\n    dsimp [x]\n    rw [← Category.id_comp (inv f), Category.assoc, ← biproduct.total]\n    simp only [comp_sum_assoc]\n    conv_lhs =>\n      congr\n      congr\n      next => skip\n      intro j; simp only [reassoced]\n    simp\n  exact h₁.symm.trans h₀\n\n"}
{"name":"CategoryTheory.Limits.preservesProduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite products. -/\nlemma preservesProduct_of_preservesBiproduct {f : J → C} [PreservesBiproduct f F] :\n    PreservesLimit (Discrete.functor f) F where\n  preserves hc :=\n    ⟨IsLimit.ofIsoLimit\n        ((IsLimit.postcomposeInvEquiv (Discrete.compNatIsoDiscrete _ _) _).symm\n          (isBilimitOfPreserves F (biconeIsBilimitOfLimitConeOfIsLimit hc)).isLimit) <|\n      Cones.ext (Iso.refl _) (by rintro ⟨⟩; simp)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesProductsOfShape_of_preservesBiproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\ninst✝ : CategoryTheory.Limits.PreservesBiproductsOfShape J F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite products. -/\nlemma preservesProductsOfShape_of_preservesBiproductsOfShape [PreservesBiproductsOfShape J F] :\n    PreservesLimitsOfShape (Discrete J) F where\n  preservesLimit {_} := preservesLimit_of_iso_diagram _ Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_preservesProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F\n⊢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite products\n    preserves finite biproducts. -/\nlemma preservesBiproduct_of_preservesProduct {f : J → C} [PreservesLimit (Discrete.functor f) F] :\n    PreservesBiproduct f F where\n  preserves {b} hb :=\n    ⟨isBilimitOfIsLimit _ <|\n      IsLimit.ofIsoLimit\n          ((IsLimit.postcomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) (F.mapCone b.toCone)).symm\n            (isLimitOfPreserves F hb.isLimit)) <|\n        Cones.ext (Iso.refl _) (by rintro ⟨⟩; simp)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_mono_biproductComparison","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\ninst✝⁷ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁶ : CategoryTheory.Category.{v', u'} D\ninst✝⁵ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\nJ : Type\ninst✝³ : Fintype J\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst✝ : CategoryTheory.Mono (F.biproductComparison f)\n⊢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- If the (product-like) biproduct comparison for `F` and `f` is a monomorphism, then `F`\n    preserves the biproduct of `f`. For the converse, see `mapBiproduct`. -/\nlemma preservesBiproduct_of_mono_biproductComparison {f : J → C} [HasBiproduct f]\n    [HasBiproduct (F.obj ∘ f)] [Mono (biproductComparison F f)] : PreservesBiproduct f F := by\n  haveI : HasProduct fun b => F.obj (f b) := by\n    change HasProduct (F.obj ∘ f)\n    infer_instance\n  have that : piComparison F f =\n      (F.mapIso (biproduct.isoProduct f)).inv ≫\n        biproductComparison F f ≫ (biproduct.isoProduct _).hom := by\n    ext j\n    convert piComparison_comp_π F f j; simp [← Function.comp_def, ← Functor.map_comp]\n  haveI : IsIso (biproductComparison F f) := isIso_of_mono_of_isSplitEpi _\n  haveI : IsIso (piComparison F f) := by\n    rw [that]\n    infer_instance\n  haveI := PreservesProduct.of_iso_comparison F f\n  apply preservesBiproduct_of_preservesProduct\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_epi_biproductComparison'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\ninst✝⁷ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁶ : CategoryTheory.Category.{v', u'} D\ninst✝⁵ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\nJ : Type\ninst✝³ : Fintype J\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst✝ : CategoryTheory.Epi (F.biproductComparison' f)\n⊢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- If the (coproduct-like) biproduct comparison for `F` and `f` is an epimorphism, then `F`\n    preserves the biproduct of `F` and `f`. For the converse, see `mapBiproduct`. -/\nlemma preservesBiproduct_of_epi_biproductComparison' {f : J → C} [HasBiproduct f]\n    [HasBiproduct (F.obj ∘ f)] [Epi (biproductComparison' F f)] : PreservesBiproduct f F := by\n  haveI : Epi (splitEpiBiproductComparison F f).section_ := by simpa\n  haveI : IsIso (biproductComparison F f) :=\n    IsIso.of_epi_section' (splitEpiBiproductComparison F f)\n  apply preservesBiproduct_of_mono_biproductComparison\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F\n⊢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite products\n    preserves finite biproducts. -/\nlemma preservesBiproductsOfShape_of_preservesProductsOfShape\n    [PreservesLimitsOfShape (Discrete J) F] :\n    PreservesBiproductsOfShape J F where\n  preserves {_} := preservesBiproduct_of_preservesProduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesCoproduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite coproducts. -/\nlemma preservesCoproduct_of_preservesBiproduct {f : J → C} [PreservesBiproduct f F] :\n    PreservesColimit (Discrete.functor f) F where\n  preserves {c} hc :=\n    ⟨IsColimit.ofIsoColimit\n        ((IsColimit.precomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) _).symm\n          (isBilimitOfPreserves F (biconeIsBilimitOfColimitCoconeOfIsColimit hc)).isColimit) <|\n      Cocones.ext (Iso.refl _) (by rintro ⟨⟩; simp)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesCoproductsOfShape_of_preservesBiproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\ninst✝ : CategoryTheory.Limits.PreservesBiproductsOfShape J F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite coproducts. -/\nlemma preservesCoproductsOfShape_of_preservesBiproductsOfShape [PreservesBiproductsOfShape J F] :\n    PreservesColimitsOfShape (Discrete J) F where\n  preservesColimit {_} := preservesColimit_of_iso_diagram _ Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_preservesCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\nf : J → C\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F\n⊢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts\n    preserves finite biproducts. -/\nlemma preservesBiproduct_of_preservesCoproduct {f : J → C}\n    [PreservesColimit (Discrete.functor f) F] :\n    PreservesBiproduct f F where\n  preserves {b} hb :=\n    ⟨isBilimitOfIsColimit _ <|\n      IsColimit.ofIsoColimit\n          ((IsColimit.precomposeInvEquiv (Discrete.compNatIsoDiscrete _ _)\n                (F.mapCocone b.toCocone)).symm\n            (isColimitOfPreserves F hb.isColimit)) <|\n        Cocones.ext (Iso.refl _) (by rintro ⟨⟩; simp)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesCoproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type\ninst✝¹ : Fintype J\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F\n⊢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts\n    preserves finite biproducts. -/\nlemma preservesBiproductsOfShape_of_preservesCoproductsOfShape\n    [PreservesColimitsOfShape (Discrete J) F] : PreservesBiproductsOfShape J F where\n  preserves {_} := preservesBiproduct_of_preservesCoproduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryProduct_of_preservesBinaryBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nX Y : C\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary products. -/\nlemma preservesBinaryProduct_of_preservesBinaryBiproduct {X Y : C}\n    [PreservesBinaryBiproduct X Y F] :\n    PreservesLimit (pair X Y) F where\n  preserves {c} hc := ⟨IsLimit.ofIsoLimit\n        ((IsLimit.postcomposeInvEquiv (diagramIsoPair _) _).symm\n          (isBinaryBilimitOfPreserves F (binaryBiconeIsBilimitOfLimitConeOfIsLimit hc)).isLimit) <|\n      Cones.ext (by dsimp; rfl) fun j => by\n        rcases j with ⟨⟨⟩⟩ <;> simp⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryProducts_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproducts F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary products. -/\nlemma preservesBinaryProducts_of_preservesBinaryBiproducts [PreservesBinaryBiproducts F] :\n    PreservesLimitsOfShape (Discrete WalkingPair) F where\n  preservesLimit {_} := preservesLimit_of_iso_diagram _ (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBinaryProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nX Y : C\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary products\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBinaryProduct {X Y : C} [PreservesLimit (pair X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb := ⟨isBinaryBilimitOfIsLimit _ <| IsLimit.ofIsoLimit\n          ((IsLimit.postcomposeHomEquiv (diagramIsoPair _) (F.mapCone b.toCone)).symm\n            (isLimitOfPreserves F hb.isLimit)) <|\n        Cones.ext (by dsimp; rfl) fun j => by\n          rcases j with ⟨⟨⟩⟩ <;> simp⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_mono_biprodComparison","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\ninst✝⁶ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} D\ninst✝⁴ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst✝ : CategoryTheory.Mono (F.biprodComparison X Y)\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- If the (product-like) biproduct comparison for `F`, `X` and `Y` is a monomorphism, then\n    `F` preserves the biproduct of `X` and `Y`. For the converse, see `map_biprod`. -/\nlemma preservesBinaryBiproduct_of_mono_biprodComparison {X Y : C} [HasBinaryBiproduct X Y]\n    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Mono (biprodComparison F X Y)] :\n    PreservesBinaryBiproduct X Y F := by\n  have that :\n    prodComparison F X Y =\n      (F.mapIso (biprod.isoProd X Y)).inv ≫ biprodComparison F X Y ≫ (biprod.isoProd _ _).hom := by\n    ext <;> simp [← Functor.map_comp]\n  haveI : IsIso (biprodComparison F X Y) := isIso_of_mono_of_isSplitEpi _\n  haveI : IsIso (prodComparison F X Y) := by\n    rw [that]\n    infer_instance\n  haveI := PreservesLimitPair.of_iso_prod_comparison F X Y\n  apply preservesBinaryBiproduct_of_preservesBinaryProduct\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_epi_biprodComparison'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\ninst✝⁶ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} D\ninst✝⁴ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst✝ : CategoryTheory.Epi (F.biprodComparison' X Y)\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- If the (coproduct-like) biproduct comparison for `F`, `X` and `Y` is an epimorphism, then\n    `F` preserves the biproduct of `X` and `Y`. For the converse, see `mapBiprod`. -/\nlemma preservesBinaryBiproduct_of_epi_biprodComparison' {X Y : C} [HasBinaryBiproduct X Y]\n    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Epi (biprodComparison' F X Y)] :\n    PreservesBinaryBiproduct X Y F := by\n  haveI : Epi (splitEpiBiprodComparison F X Y).section_ := by simpa\n  haveI : IsIso (biprodComparison F X Y) :=\n    IsIso.of_epi_section' (splitEpiBiprodComparison F X Y)\n  apply preservesBinaryBiproduct_of_mono_biprodComparison\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBinaryProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary products\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBinaryProducts\n    [PreservesLimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F where\n  preserves {_} {_} := preservesBinaryBiproduct_of_preservesBinaryProduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryCoproduct_of_preservesBinaryBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nX Y : C\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary coproducts. -/\nlemma preservesBinaryCoproduct_of_preservesBinaryBiproduct {X Y : C}\n    [PreservesBinaryBiproduct X Y F] :\n    PreservesColimit (pair X Y) F where\n  preserves {c} hc :=\n    ⟨IsColimit.ofIsoColimit\n        ((IsColimit.precomposeHomEquiv (diagramIsoPair _) _).symm\n          (isBinaryBilimitOfPreserves F\n              (binaryBiconeIsBilimitOfColimitCoconeOfIsColimit hc)).isColimit) <|\n      Cocones.ext (by dsimp; rfl) fun j => by\n        rcases j with ⟨⟨⟩⟩ <;> simp⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryCoproducts_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproducts F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary coproducts. -/\nlemma preservesBinaryCoproducts_of_preservesBinaryBiproducts [PreservesBinaryBiproducts F] :\n    PreservesColimitsOfShape (Discrete WalkingPair) F where\n  preservesColimit {_} := preservesColimit_of_iso_diagram _ (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBinaryCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nX Y : C\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBinaryCoproduct {X Y : C}\n    [PreservesColimit (pair X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb :=\n    ⟨isBinaryBilimitOfIsColimit _ <|\n      IsColimit.ofIsoColimit\n          ((IsColimit.precomposeInvEquiv (diagramIsoPair _) (F.mapCocone b.toCocone)).symm\n            (isColimitOfPreserves F hb.isColimit)) <|\n        Cocones.ext (Iso.refl _) fun j => by\n          rcases j with ⟨⟨⟩⟩ <;> simp⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBinaryCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBinaryCoproducts\n    [PreservesColimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F where\n  preserves {_} {_} := preservesBinaryBiproduct_of_preservesBinaryCoproduct F\n\n"}
