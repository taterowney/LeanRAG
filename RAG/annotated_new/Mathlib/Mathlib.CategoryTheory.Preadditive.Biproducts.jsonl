{"name":"CategoryTheory.Limits.IsBilimit.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nb : CategoryTheory.Limits.Bicone f\ni : b.IsBilimit\nâŠ¢ Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (b.Ï€ j) (b.Î¹ j)) (CategoryTheory.CategoryStruct.id b.pt)","decl":"theorem IsBilimit.total {f : J â†’ C} {b : Bicone f} (i : b.IsBilimit) :\n    âˆ‘ j : J, b.Ï€ j â‰« b.Î¹ j = ğŸ™ b.pt :=\n  i.isLimit.hom_ext fun j => by\n    classical\n    cases j\n    simp [sum_comp, b.Î¹_Ï€, comp_dite]\n\n"}
{"name":"CategoryTheory.Limits.hasBiproduct_of_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nb : CategoryTheory.Limits.Bicone f\ntotal : Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (b.Ï€ j) (b.Î¹ j)) (CategoryTheory.CategoryStruct.id b.pt)\nâŠ¢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, we can construct a biproduct for `f : J â†’ C` from\nany bicone `b` for `f` satisfying `total : âˆ‘ j : J, b.Ï€ j â‰« b.Î¹ j = ğŸ™ b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n-/\ntheorem hasBiproduct_of_total {f : J â†’ C} (b : Bicone f)\n    (total : âˆ‘ j : J, b.Ï€ j â‰« b.Î¹ j = ğŸ™ b.pt) : HasBiproduct f :=\n  HasBiproduct.mk\n    { bicone := b\n      isBilimit := isBilimitOfTotal b total }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.of_hasProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Finite J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nâŠ¢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, if the product over `f : J â†’ C` exists,\n    then the biproduct over `f` exists. -/\ntheorem HasBiproduct.of_hasProduct (f : J â†’ C) [HasProduct f] : HasBiproduct f := by\n  cases nonempty_fintype J\n  exact HasBiproduct.mk\n    { bicone := _\n      isBilimit := biconeIsBilimitOfLimitConeOfIsLimit (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.of_hasCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Finite J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nâŠ¢ CategoryTheory.Limits.HasBiproduct f","decl":"/-- In a preadditive category, if the coproduct over `f : J â†’ C` exists,\n    then the biproduct over `f` exists. -/\ntheorem HasBiproduct.of_hasCoproduct (f : J â†’ C) [HasCoproduct f] : HasBiproduct f := by\n  cases nonempty_fintype J\n  exact HasBiproduct.mk\n    { bicone := _\n      isBilimit := biconeIsBilimitOfColimitCoconeOfIsColimit (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteProducts C\nâŠ¢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"/-- A preadditive category with finite products has finite biproducts. -/\ntheorem HasFiniteBiproducts.of_hasFiniteProducts [HasFiniteProducts C] : HasFiniteBiproducts C :=\n  âŸ¨fun _ => { has_biproduct := fun _ => HasBiproduct.of_hasProduct _ }âŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"/-- A preadditive category with finite coproducts has finite biproducts. -/\ntheorem HasFiniteBiproducts.of_hasFiniteCoproducts [HasFiniteCoproducts C] :\n    HasFiniteBiproducts C :=\n  âŸ¨fun _ => { has_biproduct := fun _ => HasBiproduct.of_hasCoproduct _ }âŸ©\n\n"}
{"name":"CategoryTheory.Limits.biproduct.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nâŠ¢ Eq (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (CategoryTheory.Limits.biproduct.Î¹ f j)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct f))","decl":"/-- In any preadditive category, any biproduct satisfies\n`âˆ‘ j : J, biproduct.Ï€ f j â‰« biproduct.Î¹ f j = ğŸ™ (â¨ f)`\n-/\n@[simp]\ntheorem biproduct.total : âˆ‘ j : J, biproduct.Ï€ f j â‰« biproduct.Î¹ f j = ğŸ™ (â¨ f) :=\n  IsBilimit.total (biproduct.isBilimit _)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nT : C\ng : (j : J) â†’ Quiver.Hom T (f j)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.lift g) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (CategoryTheory.Limits.biproduct.Î¹ f j))","decl":"theorem biproduct.lift_eq {T : C} {g : âˆ€ j, T âŸ¶ f j} :\n    biproduct.lift g = âˆ‘ j, g j â‰« biproduct.Î¹ f j := by\n  classical\n  ext j\n  simp only [sum_comp, biproduct.Î¹_Ï€, comp_dite, biproduct.lift_Ï€, Category.assoc, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, eqToHom_refl, Category.comp_id, if_true]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.desc_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nT : C\ng : (j : J) â†’ Quiver.Hom (f j) T\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.desc g) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (g j))","decl":"theorem biproduct.desc_eq {T : C} {g : âˆ€ j, f j âŸ¶ T} :\n    biproduct.desc g = âˆ‘ j, biproduct.Ï€ f j â‰« g j := by\n  classical\n  ext j\n  simp [comp_sum, biproduct.Î¹_Ï€_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nT U : C\ng : (j : J) â†’ Quiver.Hom T (f j)\nh : (j : J) â†’ Quiver.Hom (f j) U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift g) (CategoryTheory.Limits.biproduct.desc h)) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (h j))","decl":"@[reassoc]\ntheorem biproduct.lift_desc {T U : C} {g : âˆ€ j, T âŸ¶ f j} {h : âˆ€ j, f j âŸ¶ U} :\n    biproduct.lift g â‰« biproduct.desc h = âˆ‘ j : J, g j â‰« h j := by\n  classical\n  simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Î¹_Ï€_assoc, comp_dite,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nT U : C\ng : (j : J) â†’ Quiver.Hom T (f j)\nhâœ : (j : J) â†’ Quiver.Hom (f j) U\nZ : C\nh : Quiver.Hom U Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc hâœ) h)) (CategoryTheory.CategoryStruct.comp (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (g j) (hâœ j)) h)","decl":"@[reassoc]\ntheorem biproduct.lift_desc {T U : C} {g : âˆ€ j, T âŸ¶ f j} {h : âˆ€ j, f j âŸ¶ U} :\n    biproduct.lift g â‰« biproduct.desc h = âˆ‘ j : J, g j â‰« h j := by\n  classical\n  simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Î¹_Ï€_assoc, comp_dite,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ¹ : Fintype J\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf g : J â†’ C\nh : (j : J) â†’ Quiver.Hom (f j) (g j)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.map h) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (CategoryTheory.CategoryStruct.comp (h j) (CategoryTheory.Limits.biproduct.Î¹ g j)))","decl":"theorem biproduct.map_eq [HasFiniteBiproducts C] {f g : J â†’ C} {h : âˆ€ j, f j âŸ¶ g j} :\n    biproduct.map h = âˆ‘ j : J, biproduct.Ï€ f j â‰« h j â‰« biproduct.Î¹ g j := by\n  classical\n  ext\n  simp [biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc, comp_sum, sum_comp, comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_matrix_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ² : Fintype J\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nP : C\nx : (j : J) â†’ Quiver.Hom P (f j)\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (x j) (m j k)) h)","decl":"@[reassoc]\ntheorem biproduct.lift_matrix {K : Type} [Finite K] [HasFiniteBiproducts C] {f : J â†’ C} {g : K â†’ C}\n    {P} (x : âˆ€ j, P âŸ¶ f j) (m : âˆ€ j k, f j âŸ¶ g k) :\n    biproduct.lift x â‰« biproduct.matrix m = biproduct.lift fun k => âˆ‘ j, x j â‰« m j k := by\n  ext\n  simp [biproduct.lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_matrix","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ : Type\ninstâœÂ² : Fintype J\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nP : C\nx : (j : J) â†’ Quiver.Hom P (f j)\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift x) (CategoryTheory.Limits.biproduct.matrix m)) (CategoryTheory.Limits.biproduct.lift fun k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (x j) (m j k))","decl":"@[reassoc]\ntheorem biproduct.lift_matrix {K : Type} [Finite K] [HasFiniteBiproducts C] {f : J â†’ C} {g : K â†’ C}\n    {P} (x : âˆ€ j, P âŸ¶ f j) (m : âˆ€ j k, f j âŸ¶ g k) :\n    biproduct.lift x â‰« biproduct.matrix m = biproduct.lift fun k => âˆ‘ j, x j â‰« m j k := by\n  ext\n  simp [biproduct.lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Fintype K\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nP : C\nx : (k : K) â†’ Quiver.Hom (g k) P\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.desc x)) (CategoryTheory.Limits.biproduct.desc fun j => Finset.univ.sum fun k => CategoryTheory.CategoryStruct.comp (m j k) (x k))","decl":"@[reassoc]\ntheorem biproduct.matrix_desc [Fintype K] {f : J â†’ C} {g : K â†’ C}\n    (m : âˆ€ j k, f j âŸ¶ g k) {P} (x : âˆ€ k, g k âŸ¶ P) :\n    biproduct.matrix m â‰« biproduct.desc x = biproduct.desc fun j => âˆ‘ k, m j k â‰« x k := by\n  ext\n  simp [lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Fintype K\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nP : C\nx : (k : K) â†’ Quiver.Hom (g k) P\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc x) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => Finset.univ.sum fun k => CategoryTheory.CategoryStruct.comp (m j k) (x k)) h)","decl":"@[reassoc]\ntheorem biproduct.matrix_desc [Fintype K] {f : J â†’ C} {g : K â†’ C}\n    (m : âˆ€ j k, f j âŸ¶ g k) {P} (x : âˆ€ k, g k âŸ¶ P) :\n    biproduct.matrix m â‰« biproduct.desc x = biproduct.desc fun j => âˆ‘ k, m j k â‰« x k := by\n  ext\n  simp [lift_desc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_map","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Finite K\nf : J â†’ C\ng h : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nn : (k : K) â†’ Quiver.Hom (g k) (h k)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.map n)) (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j k) (n k))","decl":"@[reassoc]\ntheorem biproduct.matrix_map {f : J â†’ C} {g : K â†’ C} {h : K â†’ C} (m : âˆ€ j k, f j âŸ¶ g k)\n    (n : âˆ€ k, g k âŸ¶ h k) :\n    biproduct.matrix m â‰« biproduct.map n = biproduct.matrix fun j k => m j k â‰« n k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_map_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Finite K\nf : J â†’ C\ng hâœ : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nn : (k : K) â†’ Quiver.Hom (g k) (hâœ k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct hâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j k) (n k)) h)","decl":"@[reassoc]\ntheorem biproduct.matrix_map {f : J â†’ C} {g : K â†’ C} {h : K â†’ C} (m : âˆ€ j k, f j âŸ¶ g k)\n    (n : âˆ€ k, g k âŸ¶ h k) :\n    biproduct.matrix m â‰« biproduct.map n = biproduct.matrix fun j k => m j k â‰« n k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_matrix_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Finite K\nf g : J â†’ C\nhâœ : K â†’ C\nm : (k : J) â†’ Quiver.Hom (f k) (g k)\nn : (j : J) â†’ (k : K) â†’ Quiver.Hom (g j) (hâœ k)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct hâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j) (n j k)) h)","decl":"@[reassoc]\ntheorem biproduct.map_matrix {f : J â†’ C} {g : J â†’ C} {h : K â†’ C} (m : âˆ€ k, f k âŸ¶ g k)\n    (n : âˆ€ j k, g j âŸ¶ h k) :\n    biproduct.map m â‰« biproduct.matrix n = biproduct.matrix fun j k => m j â‰« n j k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_matrix","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nJ K : Type\ninstâœÂ² : Finite J\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Finite K\nf g : J â†’ C\nh : K â†’ C\nm : (k : J) â†’ Quiver.Hom (f k) (g k)\nn : (j : J) â†’ (k : K) â†’ Quiver.Hom (g j) (h k)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map m) (CategoryTheory.Limits.biproduct.matrix n)) (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.CategoryStruct.comp (m j) (n j k))","decl":"@[reassoc]\ntheorem biproduct.map_matrix {f : J â†’ C} {g : J â†’ C} {h : K â†’ C} (m : âˆ€ k, f k âŸ¶ g k)\n    (n : âˆ€ j k, g j âŸ¶ h k) :\n    biproduct.map m â‰« biproduct.matrix n = biproduct.matrix fun j k => m j â‰« n j k := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.reindex_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ² Î³ : Type\ninstâœÂ² : Finite Î²\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Function.comp f â‡‘Îµ)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.reindex Îµ f).hom (CategoryTheory.Limits.biproduct.desc fun b => CategoryTheory.Limits.biproduct.Î¹ f (Îµ b))","decl":"/-- Reindex a categorical biproduct via an equivalence of the index types. -/\n@[simps]\ndef biproduct.reindex {Î² Î³ : Type} [Finite Î²] (Îµ : Î² â‰ƒ Î³)\n    (f : Î³ â†’ C) [HasBiproduct f] [HasBiproduct (f âˆ˜ Îµ)] : â¨ f âˆ˜ Îµ â‰… â¨ f where\n  hom := biproduct.desc fun b => biproduct.Î¹ f (Îµ b)\n  inv := biproduct.lift fun b => biproduct.Ï€ f (Îµ b)\n  hom_inv_id := by\n    ext b b'\n    by_cases h : b' = b\n    Â· subst h; simp\n    Â· have : Îµ b' â‰  Îµ b := by simp [h]\n      simp [biproduct.Î¹_Ï€_ne _ h, biproduct.Î¹_Ï€_ne _ this]\n  inv_hom_id := by\n    classical\n    cases nonempty_fintype Î²\n    ext g g'\n    by_cases h : g' = g <;>\n      simp [Preadditive.sum_comp, Preadditive.comp_sum, biproduct.lift_desc,\n        biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc, comp_dite, Equiv.apply_eq_iff_eq_symm_apply,\n        Finset.sum_dite_eq' Finset.univ (Îµ.symm g') _, h]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.reindex_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ² Î³ : Type\ninstâœÂ² : Finite Î²\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Function.comp f â‡‘Îµ)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.reindex Îµ f).inv (CategoryTheory.Limits.biproduct.lift fun b => CategoryTheory.Limits.biproduct.Ï€ f (Îµ b))","decl":"/-- Reindex a categorical biproduct via an equivalence of the index types. -/\n@[simps]\ndef biproduct.reindex {Î² Î³ : Type} [Finite Î²] (Îµ : Î² â‰ƒ Î³)\n    (f : Î³ â†’ C) [HasBiproduct f] [HasBiproduct (f âˆ˜ Îµ)] : â¨ f âˆ˜ Îµ â‰… â¨ f where\n  hom := biproduct.desc fun b => biproduct.Î¹ f (Îµ b)\n  inv := biproduct.lift fun b => biproduct.Ï€ f (Îµ b)\n  hom_inv_id := by\n    ext b b'\n    by_cases h : b' = b\n    Â· subst h; simp\n    Â· have : Îµ b' â‰  Îµ b := by simp [h]\n      simp [biproduct.Î¹_Ï€_ne _ h, biproduct.Î¹_Ï€_ne _ this]\n  inv_hom_id := by\n    classical\n    cases nonempty_fintype Î²\n    ext g g'\n    by_cases h : g' = g <;>\n      simp [Preadditive.sum_comp, Preadditive.comp_sum, biproduct.lift_desc,\n        biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc, comp_dite, Equiv.apply_eq_iff_eq_symm_apply,\n        Finset.sum_dite_eq' Finset.univ (Îµ.symm g') _, h]\n\n"}
{"name":"CategoryTheory.Limits.IsBilimit.binary_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\ni : b.IsBilimit\nâŠ¢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp b.fst b.inl) (CategoryTheory.CategoryStruct.comp b.snd b.inr)) (CategoryTheory.CategoryStruct.id b.pt)","decl":"theorem IsBilimit.binary_total {X Y : C} {b : BinaryBicone X Y} (i : b.IsBilimit) :\n    b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.pt :=\n  i.isLimit.hom_ext fun j => by rcases j with âŸ¨âŸ¨âŸ©âŸ© <;> simp\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryBiproduct_of_total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp b.fst b.inl) (CategoryTheory.CategoryStruct.comp b.snd b.inr)) (CategoryTheory.CategoryStruct.id b.pt)\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, we can construct a binary biproduct for `X Y : C` from\nany binary bicone `b` satisfying `total : b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n-/\ntheorem hasBinaryBiproduct_of_total {X Y : C} (b : BinaryBicone X Y)\n    (total : b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.pt) : HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := b\n      isBilimit := isBinaryBilimitOfTotal b total }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).fst (t.Ï€.app { as := CategoryTheory.Limits.WalkingPair.left })","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.Ï€.app âŸ¨WalkingPair.leftâŸ©\n  snd := t.Ï€.app âŸ¨WalkingPair.rightâŸ©\n  inl := ht.lift (BinaryFan.mk (ğŸ™ X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (ğŸ™ Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).inl (ht.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.Ï€.app âŸ¨WalkingPair.leftâŸ©\n  snd := t.Ï€.app âŸ¨WalkingPair.rightâŸ©\n  inl := ht.lift (BinaryFan.mk (ğŸ™ X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (ğŸ™ Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).inr (ht.lift (CategoryTheory.Limits.BinaryFan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.Ï€.app âŸ¨WalkingPair.leftâŸ©\n  snd := t.Ï€.app âŸ¨WalkingPair.rightâŸ©\n  inl := ht.lift (BinaryFan.mk (ğŸ™ X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (ğŸ™ Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).snd (t.Ï€.app { as := CategoryTheory.Limits.WalkingPair.right })","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.Ï€.app âŸ¨WalkingPair.leftâŸ©\n  snd := t.Ï€.app âŸ¨WalkingPair.rightâŸ©\n  inl := ht.lift (BinaryFan.mk (ğŸ™ X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (ğŸ™ Y))\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofLimitCone_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofLimitCone ht).pt t.pt","decl":"/-- We can turn any limit cone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := t.Ï€.app âŸ¨WalkingPair.leftâŸ©\n  snd := t.Ï€.app âŸ¨WalkingPair.rightâŸ©\n  inl := ht.lift (BinaryFan.mk (ğŸ™ X) 0)\n  inr := ht.lift (BinaryFan.mk 0 (ğŸ™ Y))\n\n"}
{"name":"CategoryTheory.Limits.inl_of_isLimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsLimit t.toCone\nâŠ¢ Eq t.inl (ht.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :\n    t.inl = ht.lift (BinaryFan.mk (ğŸ™ X) 0) := by\n  apply ht.uniq (BinaryFan.mk (ğŸ™ X) 0); rintro âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.inr_of_isLimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsLimit t.toCone\nâŠ¢ Eq t.inr (ht.lift (CategoryTheory.Limits.BinaryFan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :\n    t.inr = ht.lift (BinaryFan.mk 0 (ğŸ™ Y)) := by\n  apply ht.uniq (BinaryFan.mk 0 (ğŸ™ Y)); rintro âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct X Y\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, if the product of `X` and `Y` exists, then the\n    binary biproduct of `X` and `Y` exists. -/\ntheorem HasBinaryBiproduct.of_hasBinaryProduct (X Y : C) [HasBinaryProduct X Y] :\n    HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := _\n      isBilimit := binaryBiconeIsBilimitOfLimitConeOfIsLimit (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- In a preadditive category, if all binary products exist, then all binary biproducts exist. -/\ntheorem HasBinaryBiproducts.of_hasBinaryProducts [HasBinaryProducts C] : HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryProduct X Y }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).inr (t.Î¹.app { as := CategoryTheory.Limits.WalkingPair.right })","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (ğŸ™ X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (ğŸ™ Y))\n  inl := t.Î¹.app âŸ¨WalkingPair.leftâŸ©\n  inr := t.Î¹.app âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).inl (t.Î¹.app { as := CategoryTheory.Limits.WalkingPair.left })","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (ğŸ™ X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (ğŸ™ Y))\n  inl := t.Î¹.app âŸ¨WalkingPair.leftâŸ©\n  inr := t.Î¹.app âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).pt t.pt","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (ğŸ™ X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (ğŸ™ Y))\n  inl := t.Î¹.app âŸ¨WalkingPair.leftâŸ©\n  inr := t.Î¹.app âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).snd (ht.desc (CategoryTheory.Limits.BinaryCofan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (ğŸ™ X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (ğŸ™ Y))\n  inl := t.Î¹.app âŸ¨WalkingPair.leftâŸ©\n  inr := t.Î¹.app âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.ofColimitCocone_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.pair X Y)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.ofColimitCocone ht).fst (ht.desc (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"/-- We can turn any colimit cocone over a pair into a bicone. -/\n@[simps]\ndef BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :\n    BinaryBicone X Y where\n  pt := t.pt\n  fst := ht.desc (BinaryCofan.mk (ğŸ™ X) 0)\n  snd := ht.desc (BinaryCofan.mk 0 (ğŸ™ Y))\n  inl := t.Î¹.app âŸ¨WalkingPair.leftâŸ©\n  inr := t.Î¹.app âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.fst_of_isColimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsColimit t.toCocone\nâŠ¢ Eq t.fst (ht.desc (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.id X) 0))","decl":"theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :\n    t.fst = ht.desc (BinaryCofan.mk (ğŸ™ X) 0) := by\n  apply ht.uniq (BinaryCofan.mk (ğŸ™ X) 0)\n  rintro âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.snd_of_isColimit","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nX Y : C\nt : CategoryTheory.Limits.BinaryBicone X Y\nht : CategoryTheory.Limits.IsColimit t.toCocone\nâŠ¢ Eq t.snd (ht.desc (CategoryTheory.Limits.BinaryCofan.mk 0 (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :\n    t.snd = ht.desc (BinaryCofan.mk 0 (ğŸ™ Y)) := by\n  apply ht.uniq (BinaryCofan.mk 0 (ğŸ™ Y))\n  rintro âŸ¨âŸ¨âŸ©âŸ© <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct X Y","decl":"/-- In a preadditive category, if the coproduct of `X` and `Y` exists, then the\n    binary biproduct of `X` and `Y` exists. -/\ntheorem HasBinaryBiproduct.of_hasBinaryCoproduct (X Y : C) [HasBinaryCoproduct X Y] :\n    HasBinaryBiproduct X Y :=\n  HasBinaryBiproduct.mk\n    { bicone := _\n      isBilimit := binaryBiconeIsBilimitOfColimitCoconeOfIsColimit (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproducts C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- In a preadditive category, if all binary coproducts exist, then all binary biproducts exist. -/\ntheorem HasBinaryBiproducts.of_hasBinaryCoproducts [HasBinaryCoproducts C] :\n    HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryCoproduct X Y }\n\n"}
{"name":"CategoryTheory.Limits.biprod.total","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.inr)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod X Y))","decl":"/-- In any preadditive category, any binary biproduct satisfies\n`biprod.fst â‰« biprod.inl + biprod.snd â‰« biprod.inr = ğŸ™ (X âŠ Y)`.\n-/\n@[simp]\ntheorem biprod.total : biprod.fst â‰« biprod.inl + biprod.snd â‰« biprod.inr = ğŸ™ (X âŠ Y) := by\n  ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nâŠ¢ Eq (CategoryTheory.Limits.biprod.lift f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr))","decl":"theorem biprod.lift_eq {T : C} {f : T âŸ¶ X} {g : T âŸ¶ Y} :\n    biprod.lift f g = f â‰« biprod.inl + g â‰« biprod.inr := by ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.desc_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\nâŠ¢ Eq (CategoryTheory.Limits.biprod.desc f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd g))","decl":"theorem biprod.desc_eq {T : C} {f : X âŸ¶ T} {g : Y âŸ¶ T} :\n    biprod.desc f g = biprod.fst â‰« f + biprod.snd â‰« g := by ext <;> simp [add_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_desc_assoc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT U : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nhâœ : Quiver.Hom X U\ni : Quiver.Hom Y U\nZ : C\nh : Quiver.Hom U Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc hâœ i) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f hâœ) (CategoryTheory.CategoryStruct.comp g i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_desc {T U : C} {f : T âŸ¶ X} {g : T âŸ¶ Y} {h : X âŸ¶ U} {i : Y âŸ¶ U} :\n    biprod.lift f g â‰« biprod.desc h i = f â‰« h + g â‰« i := by simp [biprod.lift_eq, biprod.desc_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nT U : C\nf : Quiver.Hom T X\ng : Quiver.Hom T Y\nh : Quiver.Hom X U\ni : Quiver.Hom Y U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc h i)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_desc {T U : C} {f : T âŸ¶ X} {g : T âŸ¶ Y} {h : X âŸ¶ U} {i : Y âŸ¶ U} :\n    biprod.lift f g â‰« biprod.desc h i = f â‰« h + g â‰« i := by simp [biprod.lift_eq, biprod.desc_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.Limits.biprod.map f g) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr)))","decl":"theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W âŸ¶ Y} {g : X âŸ¶ Z} :\n    biprod.map f g = biprod.fst â‰« f â‰« biprod.inl + biprod.snd â‰« g â‰« biprod.inr := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).fst (CategoryTheory.retraction f)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X âŸ¶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.Ï€\n  inl := f\n  inr :=\n    let c' : CokernelCofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=\n      CokernelCofork.ofÏ€ (Cofork.Ï€ c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofÏ€]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.Ï€\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.Ï€_desc_assoc, CokernelCofork.Ï€_ofÏ€, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).inr\n    (let c' := CategoryTheory.Limits.CokernelCofork.ofÏ€ (CategoryTheory.Limits.Cofork.Ï€ c) â‹¯;\n    let i' := CategoryTheory.Limits.isCokernelEpiComp i (CategoryTheory.retraction f) â‹¯;\n    let i'' := CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork i';\n    (CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork C â‹¯ i'').section_)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X âŸ¶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.Ï€\n  inl := f\n  inr :=\n    let c' : CokernelCofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=\n      CokernelCofork.ofÏ€ (Cofork.Ï€ c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofÏ€]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.Ï€\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.Ï€_desc_assoc, CokernelCofork.Ï€_ofÏ€, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).inl f","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X âŸ¶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.Ï€\n  inl := f\n  inr :=\n    let c' : CokernelCofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=\n      CokernelCofork.ofÏ€ (Cofork.Ï€ c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofÏ€]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.Ï€\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.Ï€_desc_assoc, CokernelCofork.Ï€_ofÏ€, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).pt Y","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X âŸ¶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.Ï€\n  inl := f\n  inr :=\n    let c' : CokernelCofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=\n      CokernelCofork.ofÏ€ (Cofork.Ï€ c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofÏ€]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.Ï€\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.Ï€_desc_assoc, CokernelCofork.Ï€_ofÏ€, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitMono f\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel i).snd (CategoryTheory.Limits.Cofork.Ï€ c)","decl":"/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and\nthe cokernel map as its `snd`.\nWe will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in\nfact already a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X âŸ¶ Y} [IsSplitMono f] {c : CokernelCofork f}\n    (i : IsColimit c) : BinaryBicone X c.pt where\n  pt := Y\n  fst := retraction f\n  snd := c.Ï€\n  inl := f\n  inr :=\n    let c' : CokernelCofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=\n      CokernelCofork.ofÏ€ (Cofork.Ï€ c) (by simp)\n    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)\n    let i'' := isColimitCoforkOfCokernelCofork i'\n    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_\n  inl_fst := by simp\n  inl_snd := by simp\n  inr_fst := by\n    dsimp only\n    rw [splitEpiOfIdempotentOfIsColimitCofork_section_,\n      isColimitCoforkOfCokernelCofork_desc, isCokernelEpiComp_desc]\n    dsimp only [cokernelCoforkOfCofork_ofÏ€]\n    letI := epi_of_isColimit_cofork i\n    apply zero_of_epi_comp c.Ï€\n    simp only [sub_comp, comp_sub, Category.comp_id, Category.assoc, IsSplitMono.id, sub_self,\n      Cofork.IsColimit.Ï€_desc_assoc, CokernelCofork.Ï€_ofÏ€, IsSplitMono.id_assoc]\n    apply sub_eq_zero_of_eq\n    apply Category.id_comp\n  inr_snd := by apply SplitEpi.id\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).snd f","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X âŸ¶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) := KernelFork.ofÎ¹ (Fork.Î¹ c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.Î¹\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_Î¹]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.Î¹\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_Î¹,\n        Fork.Î¹_ofÎ¹, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_inl","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).inl (CategoryTheory.Limits.Fork.Î¹ c)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X âŸ¶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) := KernelFork.ofÎ¹ (Fork.Î¹ c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.Î¹\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_Î¹]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.Î¹\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_Î¹,\n        Fork.Î¹_ofÎ¹, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).fst\n    (let c' := CategoryTheory.Limits.KernelFork.ofÎ¹ (CategoryTheory.Limits.Fork.Î¹ c) â‹¯;\n    let i' := CategoryTheory.Limits.isKernelCompMono i (CategoryTheory.section_ f) â‹¯;\n    let i'' := CategoryTheory.Preadditive.isLimitForkOfKernelFork i';\n    (CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork C â‹¯ i'').retraction)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X âŸ¶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) := KernelFork.ofÎ¹ (Fork.Î¹ c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.Î¹\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_Î¹]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.Î¹\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_Î¹,\n        Fork.Î¹_ofÎ¹, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_pt","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).pt X","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X âŸ¶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) := KernelFork.ofÎ¹ (Fork.Î¹ c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.Î¹\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_Î¹]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.Î¹\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_Î¹,\n        Fork.Î¹_ofÎ¹, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel_inr","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsSplitEpi f\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nâŠ¢ Eq (CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel i).inr (CategoryTheory.section_ f)","decl":"/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and\nthe kernel map as its `inl`.\nWe will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact\nalready a biproduct. -/\n@[simps]\ndef binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X âŸ¶ Y} [IsSplitEpi f] {c : KernelFork f}\n    (i : IsLimit c) : BinaryBicone c.pt Y :=\n  { pt := X\n    fst :=\n      let c' : KernelFork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) := KernelFork.ofÎ¹ (Fork.Î¹ c) (by simp)\n      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)\n      let i'' := isLimitForkOfKernelFork i'\n      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction\n    snd := f\n    inl := c.Î¹\n    inr := section_ f\n    inl_fst := by apply SplitMono.id\n    inl_snd := by simp\n    inr_fst := by\n      dsimp only\n      rw [splitMonoOfIdempotentOfIsLimitFork_retraction, isLimitForkOfKernelFork_lift,\n        isKernelCompMono_lift]\n      dsimp only [kernelForkOfFork_Î¹]\n      letI := mono_of_isLimit_fork i\n      apply zero_of_comp_mono c.Î¹\n      simp only [comp_sub, Category.comp_id, Category.assoc, sub_self, Fork.IsLimit.lift_Î¹,\n        Fork.Î¹_ofÎ¹, IsSplitEpi.id_assoc]\n    inr_snd := by simp }\n\n"}
{"name":"CategoryTheory.Limits.biprod.add_eq_lift_id_desc","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X X\nâŠ¢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.biprod.desc f g))","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ntheorem biprod.add_eq_lift_id_desc [HasBinaryBiproduct X X] :\n    f + g = biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« biprod.desc f g := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.add_eq_lift_desc_id","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Y\nâŠ¢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y)))","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ntheorem biprod.add_eq_lift_desc_id [HasBinaryBiproduct Y Y] :\n    f + g = biprod.lift f g â‰« biprod.desc (ğŸ™ Y) (ğŸ™ Y) := by simp\n\n"}
{"name":"CategoryTheory.Preadditive.ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nx y : CategoryTheory.Preadditive C\nâŠ¢ Iff (Eq x y) (Eq CategoryTheory.Preadditive.homGroup CategoryTheory.Preadditive.homGroup)","decl":"attribute [local ext] Preadditive\n\n"}
{"name":"CategoryTheory.Preadditive.ext","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nx y : CategoryTheory.Preadditive C\nhomGroup : Eq CategoryTheory.Preadditive.homGroup CategoryTheory.Preadditive.homGroup\nâŠ¢ Eq x y","decl":"attribute [local ext] Preadditive\n\n"}
{"name":"CategoryTheory.subsingleton_preadditive_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nâŠ¢ Subsingleton (CategoryTheory.Preadditive C)","decl":"/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/\ninstance subsingleton_preadditive_of_hasBinaryBiproducts {C : Type u} [Category.{v} C]\n    [HasZeroMorphisms C] [HasBinaryBiproducts C] : Subsingleton (Preadditive C) where\n  allEq := fun a b => by\n    apply Preadditive.ext; funext X Y; apply AddCommGroup.ext; funext f g\n    have hâ‚ := @biprod.add_eq_lift_id_desc _ _ a _ _ f g\n      (by convert (inferInstance : HasBinaryBiproduct X X); subsingleton)\n    have hâ‚‚ := @biprod.add_eq_lift_id_desc _ _ b _ _ f g\n      (by convert (inferInstance : HasBinaryBiproduct X X); subsingleton)\n    refine hâ‚.trans (Eq.trans ?_ hâ‚‚.symm)\n    congr! 2 <;> subsingleton\n\n"}
{"name":"CategoryTheory.Biprod.inl_ofComponents","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C\nfâ‚â‚ : Quiver.Hom Xâ‚ Yâ‚\nfâ‚â‚‚ : Quiver.Hom Xâ‚ Yâ‚‚\nfâ‚‚â‚ : Quiver.Hom Xâ‚‚ Yâ‚\nfâ‚‚â‚‚ : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚â‚ CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp fâ‚â‚‚ CategoryTheory.Limits.biprod.inr))","decl":"@[simp]\ntheorem Biprod.inl_ofComponents :\n    biprod.inl â‰« Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚ = fâ‚â‚ â‰« biprod.inl + fâ‚â‚‚ â‰« biprod.inr := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.inr_ofComponents","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C\nfâ‚â‚ : Quiver.Hom Xâ‚ Yâ‚\nfâ‚â‚‚ : Quiver.Hom Xâ‚ Yâ‚‚\nfâ‚‚â‚ : Quiver.Hom Xâ‚‚ Yâ‚\nfâ‚‚â‚‚ : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚‚â‚ CategoryTheory.Limits.biprod.inl) (CategoryTheory.CategoryStruct.comp fâ‚‚â‚‚ CategoryTheory.Limits.biprod.inr))","decl":"@[simp]\ntheorem Biprod.inr_ofComponents :\n    biprod.inr â‰« Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚ = fâ‚‚â‚ â‰« biprod.inl + fâ‚‚â‚‚ â‰« biprod.inr := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_fst","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C\nfâ‚â‚ : Quiver.Hom Xâ‚ Yâ‚\nfâ‚â‚‚ : Quiver.Hom Xâ‚ Yâ‚‚\nfâ‚‚â‚ : Quiver.Hom Xâ‚‚ Yâ‚\nfâ‚‚â‚‚ : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚) CategoryTheory.Limits.biprod.fst) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst fâ‚â‚) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd fâ‚‚â‚))","decl":"@[simp]\ntheorem Biprod.ofComponents_fst :\n    Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚ â‰« biprod.fst = biprod.fst â‰« fâ‚â‚ + biprod.snd â‰« fâ‚‚â‚ := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_snd","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C\nfâ‚â‚ : Quiver.Hom Xâ‚ Yâ‚\nfâ‚â‚‚ : Quiver.Hom Xâ‚ Yâ‚‚\nfâ‚‚â‚ : Quiver.Hom Xâ‚‚ Yâ‚\nfâ‚‚â‚‚ : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚) CategoryTheory.Limits.biprod.snd) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst fâ‚â‚‚) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd fâ‚‚â‚‚))","decl":"@[simp]\ntheorem Biprod.ofComponents_snd :\n    Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚ â‰« biprod.snd = biprod.fst â‰« fâ‚â‚‚ + biprod.snd â‰« fâ‚‚â‚‚ := by\n  simp [Biprod.ofComponents]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_eq","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ : C\nf : Quiver.Hom (CategoryTheory.Limits.biprod Xâ‚ Xâ‚‚) (CategoryTheory.Limits.biprod Yâ‚ Yâ‚‚)\nâŠ¢ Eq (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd))) f","decl":"@[simp]\ntheorem Biprod.ofComponents_eq (f : Xâ‚ âŠ Xâ‚‚ âŸ¶ Yâ‚ âŠ Yâ‚‚) :\n    Biprod.ofComponents (biprod.inl â‰« f â‰« biprod.fst) (biprod.inl â‰« f â‰« biprod.snd)\n        (biprod.inr â‰« f â‰« biprod.fst) (biprod.inr â‰« f â‰« biprod.snd) =\n      f := by\n  ext <;>\n    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,\n      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,\n      comp_zero, biprod.inl_fst, Preadditive.add_comp]\n\n"}
{"name":"CategoryTheory.Biprod.ofComponents_comp","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ Zâ‚ Zâ‚‚ : C\nfâ‚â‚ : Quiver.Hom Xâ‚ Yâ‚\nfâ‚â‚‚ : Quiver.Hom Xâ‚ Yâ‚‚\nfâ‚‚â‚ : Quiver.Hom Xâ‚‚ Yâ‚\nfâ‚‚â‚‚ : Quiver.Hom Xâ‚‚ Yâ‚‚\ngâ‚â‚ : Quiver.Hom Yâ‚ Zâ‚\ngâ‚â‚‚ : Quiver.Hom Yâ‚ Zâ‚‚\ngâ‚‚â‚ : Quiver.Hom Yâ‚‚ Zâ‚\ngâ‚‚â‚‚ : Quiver.Hom Yâ‚‚ Zâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚) (CategoryTheory.Biprod.ofComponents gâ‚â‚ gâ‚â‚‚ gâ‚‚â‚ gâ‚‚â‚‚)) (CategoryTheory.Biprod.ofComponents (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚â‚ gâ‚â‚) (CategoryTheory.CategoryStruct.comp fâ‚â‚‚ gâ‚‚â‚)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚â‚ gâ‚â‚‚) (CategoryTheory.CategoryStruct.comp fâ‚â‚‚ gâ‚‚â‚‚)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚‚â‚ gâ‚â‚) (CategoryTheory.CategoryStruct.comp fâ‚‚â‚‚ gâ‚‚â‚)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fâ‚‚â‚ gâ‚â‚‚) (CategoryTheory.CategoryStruct.comp fâ‚‚â‚‚ gâ‚‚â‚‚)))","decl":"@[simp]\ntheorem Biprod.ofComponents_comp {Xâ‚ Xâ‚‚ Yâ‚ Yâ‚‚ Zâ‚ Zâ‚‚ : C} (fâ‚â‚ : Xâ‚ âŸ¶ Yâ‚) (fâ‚â‚‚ : Xâ‚ âŸ¶ Yâ‚‚)\n    (fâ‚‚â‚ : Xâ‚‚ âŸ¶ Yâ‚) (fâ‚‚â‚‚ : Xâ‚‚ âŸ¶ Yâ‚‚) (gâ‚â‚ : Yâ‚ âŸ¶ Zâ‚) (gâ‚â‚‚ : Yâ‚ âŸ¶ Zâ‚‚) (gâ‚‚â‚ : Yâ‚‚ âŸ¶ Zâ‚)\n    (gâ‚‚â‚‚ : Yâ‚‚ âŸ¶ Zâ‚‚) :\n    Biprod.ofComponents fâ‚â‚ fâ‚â‚‚ fâ‚‚â‚ fâ‚‚â‚‚ â‰« Biprod.ofComponents gâ‚â‚ gâ‚â‚‚ gâ‚‚â‚ gâ‚‚â‚‚ =\n      Biprod.ofComponents (fâ‚â‚ â‰« gâ‚â‚ + fâ‚â‚‚ â‰« gâ‚‚â‚) (fâ‚â‚ â‰« gâ‚â‚‚ + fâ‚â‚‚ â‰« gâ‚‚â‚‚) (fâ‚‚â‚ â‰« gâ‚â‚ + fâ‚‚â‚‚ â‰« gâ‚‚â‚)\n        (fâ‚‚â‚ â‰« gâ‚â‚‚ + fâ‚‚â‚‚ â‰« gâ‚‚â‚‚) := by\n  dsimp [Biprod.ofComponents]\n  ext <;>\n    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,\n      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,\n      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.Biprod.unipotentUpper_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ : C\nr : Quiver.Hom Xâ‚ Xâ‚‚\nâŠ¢ Eq (CategoryTheory.Biprod.unipotentUpper r).inv (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id Xâ‚) (Neg.neg r) 0 (CategoryTheory.CategoryStruct.id Xâ‚‚))","decl":"/-- The unipotent upper triangular matrix\n```\n(1 r)\n(0 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentUpper {Xâ‚ Xâ‚‚ : C} (r : Xâ‚ âŸ¶ Xâ‚‚) : Xâ‚ âŠ Xâ‚‚ â‰… Xâ‚ âŠ Xâ‚‚ where\n  hom := Biprod.ofComponents (ğŸ™ _) r 0 (ğŸ™ _)\n  inv := Biprod.ofComponents (ğŸ™ _) (-r) 0 (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentUpper_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ : C\nr : Quiver.Hom Xâ‚ Xâ‚‚\nâŠ¢ Eq (CategoryTheory.Biprod.unipotentUpper r).hom (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id Xâ‚) r 0 (CategoryTheory.CategoryStruct.id Xâ‚‚))","decl":"/-- The unipotent upper triangular matrix\n```\n(1 r)\n(0 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentUpper {Xâ‚ Xâ‚‚ : C} (r : Xâ‚ âŸ¶ Xâ‚‚) : Xâ‚ âŠ Xâ‚‚ â‰… Xâ‚ âŠ Xâ‚‚ where\n  hom := Biprod.ofComponents (ğŸ™ _) r 0 (ğŸ™ _)\n  inv := Biprod.ofComponents (ğŸ™ _) (-r) 0 (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentLower_hom","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ : C\nr : Quiver.Hom Xâ‚‚ Xâ‚\nâŠ¢ Eq (CategoryTheory.Biprod.unipotentLower r).hom (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id Xâ‚) 0 r (CategoryTheory.CategoryStruct.id Xâ‚‚))","decl":"/-- The unipotent lower triangular matrix\n```\n(1 0)\n(r 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentLower {Xâ‚ Xâ‚‚ : C} (r : Xâ‚‚ âŸ¶ Xâ‚) : Xâ‚ âŠ Xâ‚‚ â‰… Xâ‚ âŠ Xâ‚‚ where\n  hom := Biprod.ofComponents (ğŸ™ _) 0 r (ğŸ™ _)\n  inv := Biprod.ofComponents (ğŸ™ _) 0 (-r) (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Biprod.unipotentLower_inv","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nXâ‚ Xâ‚‚ : C\nr : Quiver.Hom Xâ‚‚ Xâ‚\nâŠ¢ Eq (CategoryTheory.Biprod.unipotentLower r).inv (CategoryTheory.Biprod.ofComponents (CategoryTheory.CategoryStruct.id Xâ‚) 0 (Neg.neg r) (CategoryTheory.CategoryStruct.id Xâ‚‚))","decl":"/-- The unipotent lower triangular matrix\n```\n(1 0)\n(r 1)\n```\nas an isomorphism.\n-/\n@[simps]\ndef Biprod.unipotentLower {Xâ‚ Xâ‚‚ : C} (r : Xâ‚‚ âŸ¶ Xâ‚) : Xâ‚ âŠ Xâ‚‚ â‰… Xâ‚ âŠ Xâ‚‚ where\n  hom := Biprod.ofComponents (ğŸ™ _) 0 r (ğŸ™ _)\n  inv := Biprod.ofComponents (ğŸ™ _) 0 (-r) (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Biprod.column_nonzero_of_iso","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom (CategoryTheory.Limits.biprod W X) (CategoryTheory.Limits.biprod Y Z)\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ Or (Eq (CategoryTheory.CategoryStruct.id W) 0) (Or (Ne (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst)) 0) (Ne (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd)) 0))","decl":"theorem Biprod.column_nonzero_of_iso {W X Y Z : C} (f : W âŠ X âŸ¶ Y âŠ Z) [IsIso f] :\n    ğŸ™ W = 0 âˆ¨ biprod.inl â‰« f â‰« biprod.fst â‰  0 âˆ¨ biprod.inl â‰« f â‰« biprod.snd â‰  0 := by\n  by_contra! h\n  rcases h with âŸ¨nz, aâ‚, aâ‚‚âŸ©\n  set x := biprod.inl â‰« f â‰« inv f â‰« biprod.fst\n  have hâ‚ : x = ğŸ™ W := by simp [x]\n  have hâ‚€ : x = 0 := by\n    dsimp [x]\n    rw [â† Category.id_comp (inv f), Category.assoc, â† biprod.total]\n    conv_lhs =>\n      slice 2 3\n      rw [comp_add]\n    simp only [Category.assoc]\n    rw [comp_add_assoc, add_comp]\n    conv_lhs =>\n      congr\n      next => skip\n      slice 1 3\n      rw [aâ‚‚]\n    simp only [zero_comp, add_zero]\n    conv_lhs =>\n      slice 1 3\n      rw [aâ‚]\n    simp only [zero_comp]\n  exact nz (hâ‚.symm.trans hâ‚€)\n\n"}
{"name":"CategoryTheory.Biproduct.column_nonzero_of_iso'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nÏƒ Ï„ : Type\ninstâœÂ³ : Finite Ï„\nS : Ïƒ â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct S\nT : Ï„ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct T\ns : Ïƒ\nf : Quiver.Hom (CategoryTheory.Limits.biproduct S) (CategoryTheory.Limits.biproduct T)\ninstâœ : CategoryTheory.IsIso f\naâœ : âˆ€ (t : Ï„), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ S s) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.biproduct.Ï€ T t))) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id (S s)) 0","decl":"theorem Biproduct.column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]\n    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :\n    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0 := by\n  cases nonempty_fintype Ï„\n  intro z\n  have reassoced {t : Ï„} {W : C} (h : _ âŸ¶ W) :\n    biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t â‰« h = 0 â‰« h := by\n    simp only [â† Category.assoc]\n    apply eq_whisker\n    simp only [Category.assoc]\n    apply z\n  set x := biproduct.Î¹ S s â‰« f â‰« inv f â‰« biproduct.Ï€ S s\n  have hâ‚ : x = ğŸ™ (S s) := by simp [x]\n  have hâ‚€ : x = 0 := by\n    dsimp [x]\n    rw [â† Category.id_comp (inv f), Category.assoc, â† biproduct.total]\n    simp only [comp_sum_assoc]\n    conv_lhs =>\n      congr\n      congr\n      next => skip\n      intro j; simp only [reassoced]\n    simp\n  exact hâ‚.symm.trans hâ‚€\n\n"}
{"name":"CategoryTheory.Limits.preservesProduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.PreservesBiproduct f F\nâŠ¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite products. -/\nlemma preservesProduct_of_preservesBiproduct {f : J â†’ C} [PreservesBiproduct f F] :\n    PreservesLimit (Discrete.functor f) F where\n  preserves hc :=\n    âŸ¨IsLimit.ofIsoLimit\n        ((IsLimit.postcomposeInvEquiv (Discrete.compNatIsoDiscrete _ _) _).symm\n          (isBilimitOfPreserves F (biconeIsBilimitOfLimitConeOfIsLimit hc)).isLimit) <|\n      Cones.ext (Iso.refl _) (by rintro âŸ¨âŸ©; simp)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesProductsOfShape_of_preservesBiproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\ninstâœ : CategoryTheory.Limits.PreservesBiproductsOfShape J F\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite products. -/\nlemma preservesProductsOfShape_of_preservesBiproductsOfShape [PreservesBiproductsOfShape J F] :\n    PreservesLimitsOfShape (Discrete J) F where\n  preservesLimit {_} := preservesLimit_of_iso_diagram _ Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_preservesProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F\nâŠ¢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite products\n    preserves finite biproducts. -/\nlemma preservesBiproduct_of_preservesProduct {f : J â†’ C} [PreservesLimit (Discrete.functor f) F] :\n    PreservesBiproduct f F where\n  preserves {b} hb :=\n    âŸ¨isBilimitOfIsLimit _ <|\n      IsLimit.ofIsoLimit\n          ((IsLimit.postcomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) (F.mapCone b.toCone)).symm\n            (isLimitOfPreserves F hb.isLimit)) <|\n        Cones.ext (Iso.refl _) (by rintro âŸ¨âŸ©; simp)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_mono_biproductComparison","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ¶ : CategoryTheory.Category.{v', u'} D\ninstâœâµ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœâ´ : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ³ : Fintype J\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninstâœ : CategoryTheory.Mono (F.biproductComparison f)\nâŠ¢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- If the (product-like) biproduct comparison for `F` and `f` is a monomorphism, then `F`\n    preserves the biproduct of `f`. For the converse, see `mapBiproduct`. -/\nlemma preservesBiproduct_of_mono_biproductComparison {f : J â†’ C} [HasBiproduct f]\n    [HasBiproduct (F.obj âˆ˜ f)] [Mono (biproductComparison F f)] : PreservesBiproduct f F := by\n  haveI : HasProduct fun b => F.obj (f b) := by\n    change HasProduct (F.obj âˆ˜ f)\n    infer_instance\n  have that : piComparison F f =\n      (F.mapIso (biproduct.isoProduct f)).inv â‰«\n        biproductComparison F f â‰« (biproduct.isoProduct _).hom := by\n    ext j\n    convert piComparison_comp_Ï€ F f j; simp [â† Function.comp_def, â† Functor.map_comp]\n  haveI : IsIso (biproductComparison F f) := isIso_of_mono_of_isSplitEpi _\n  haveI : IsIso (piComparison F f) := by\n    rw [that]\n    infer_instance\n  haveI := PreservesProduct.of_iso_comparison F f\n  apply preservesBiproduct_of_preservesProduct\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_epi_biproductComparison'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ¶ : CategoryTheory.Category.{v', u'} D\ninstâœâµ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœâ´ : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ³ : Fintype J\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninstâœ : CategoryTheory.Epi (F.biproductComparison' f)\nâŠ¢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- If the (coproduct-like) biproduct comparison for `F` and `f` is an epimorphism, then `F`\n    preserves the biproduct of `F` and `f`. For the converse, see `mapBiproduct`. -/\nlemma preservesBiproduct_of_epi_biproductComparison' {f : J â†’ C} [HasBiproduct f]\n    [HasBiproduct (F.obj âˆ˜ f)] [Epi (biproductComparison' F f)] : PreservesBiproduct f F := by\n  haveI : Epi (splitEpiBiproductComparison F f).section_ := by simpa\n  haveI : IsIso (biproductComparison F f) :=\n    IsIso.of_epi_section' (splitEpiBiproductComparison F f)\n  apply preservesBiproduct_of_mono_biproductComparison\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F\nâŠ¢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite products\n    preserves finite biproducts. -/\nlemma preservesBiproductsOfShape_of_preservesProductsOfShape\n    [PreservesLimitsOfShape (Discrete J) F] :\n    PreservesBiproductsOfShape J F where\n  preserves {_} := preservesBiproduct_of_preservesProduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesCoproduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.PreservesBiproduct f F\nâŠ¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite coproducts. -/\nlemma preservesCoproduct_of_preservesBiproduct {f : J â†’ C} [PreservesBiproduct f F] :\n    PreservesColimit (Discrete.functor f) F where\n  preserves {c} hc :=\n    âŸ¨IsColimit.ofIsoColimit\n        ((IsColimit.precomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) _).symm\n          (isBilimitOfPreserves F (biconeIsBilimitOfColimitCoconeOfIsColimit hc)).isColimit) <|\n      Cocones.ext (Iso.refl _) (by rintro âŸ¨âŸ©; simp)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesCoproductsOfShape_of_preservesBiproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\ninstâœ : CategoryTheory.Limits.PreservesBiproductsOfShape J F\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts\n    preserves finite coproducts. -/\nlemma preservesCoproductsOfShape_of_preservesBiproductsOfShape [PreservesBiproductsOfShape J F] :\n    PreservesColimitsOfShape (Discrete J) F where\n  preservesColimit {_} := preservesColimit_of_iso_diagram _ Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproduct_of_preservesCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F\nâŠ¢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts\n    preserves finite biproducts. -/\nlemma preservesBiproduct_of_preservesCoproduct {f : J â†’ C}\n    [PreservesColimit (Discrete.functor f) F] :\n    PreservesBiproduct f F where\n  preserves {b} hb :=\n    âŸ¨isBilimitOfIsColimit _ <|\n      IsColimit.ofIsoColimit\n          ((IsColimit.precomposeInvEquiv (Discrete.compNatIsoDiscrete _ _)\n                (F.mapCocone b.toCocone)).symm\n            (isColimitOfPreserves F hb.isColimit)) <|\n        Cocones.ext (Iso.refl _) (by rintro âŸ¨âŸ©; simp)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesCoproductsOfShape","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} D\ninstâœÂ³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.PreservesZeroMorphisms\nJ : Type\ninstâœÂ¹ : Fintype J\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F\nâŠ¢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts\n    preserves finite biproducts. -/\nlemma preservesBiproductsOfShape_of_preservesCoproductsOfShape\n    [PreservesColimitsOfShape (Discrete J) F] : PreservesBiproductsOfShape J F where\n  preserves {_} := preservesBiproduct_of_preservesCoproduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryProduct_of_preservesBinaryBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\nX Y : C\ninstâœ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nâŠ¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary products. -/\nlemma preservesBinaryProduct_of_preservesBinaryBiproduct {X Y : C}\n    [PreservesBinaryBiproduct X Y F] :\n    PreservesLimit (pair X Y) F where\n  preserves {c} hc := âŸ¨IsLimit.ofIsoLimit\n        ((IsLimit.postcomposeInvEquiv (diagramIsoPair _) _).symm\n          (isBinaryBilimitOfPreserves F (binaryBiconeIsBilimitOfLimitConeOfIsLimit hc)).isLimit) <|\n      Cones.ext (by dsimp; rfl) fun j => by\n        rcases j with âŸ¨âŸ¨âŸ©âŸ© <;> simpâŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryProducts_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\ninstâœ : CategoryTheory.Limits.PreservesBinaryBiproducts F\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary products. -/\nlemma preservesBinaryProducts_of_preservesBinaryBiproducts [PreservesBinaryBiproducts F] :\n    PreservesLimitsOfShape (Discrete WalkingPair) F where\n  preservesLimit {_} := preservesLimit_of_iso_diagram _ (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBinaryProduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\nX Y : C\ninstâœ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) F\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary products\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBinaryProduct {X Y : C} [PreservesLimit (pair X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb := âŸ¨isBinaryBilimitOfIsLimit _ <| IsLimit.ofIsoLimit\n          ((IsLimit.postcomposeHomEquiv (diagramIsoPair _) (F.mapCone b.toCone)).symm\n            (isLimitOfPreserves F hb.isLimit)) <|\n        Cones.ext (by dsimp; rfl) fun j => by\n          rcases j with âŸ¨âŸ¨âŸ©âŸ© <;> simpâŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_mono_biprodComparison","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ· : CategoryTheory.Category.{v, u} C\ninstâœâ¶ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâµ : CategoryTheory.Category.{v', u'} D\ninstâœâ´ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.PreservesZeroMorphisms\nX Y : C\ninstâœÂ² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninstâœ : CategoryTheory.Mono (F.biprodComparison X Y)\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- If the (product-like) biproduct comparison for `F`, `X` and `Y` is a monomorphism, then\n    `F` preserves the biproduct of `X` and `Y`. For the converse, see `map_biprod`. -/\nlemma preservesBinaryBiproduct_of_mono_biprodComparison {X Y : C} [HasBinaryBiproduct X Y]\n    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Mono (biprodComparison F X Y)] :\n    PreservesBinaryBiproduct X Y F := by\n  have that :\n    prodComparison F X Y =\n      (F.mapIso (biprod.isoProd X Y)).inv â‰« biprodComparison F X Y â‰« (biprod.isoProd _ _).hom := by\n    ext <;> simp [â† Functor.map_comp]\n  haveI : IsIso (biprodComparison F X Y) := isIso_of_mono_of_isSplitEpi _\n  haveI : IsIso (prodComparison F X Y) := by\n    rw [that]\n    infer_instance\n  haveI := PreservesLimitPair.of_iso_prod_comparison F X Y\n  apply preservesBinaryBiproduct_of_preservesBinaryProduct\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_epi_biprodComparison'","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâ· : CategoryTheory.Category.{v, u} C\ninstâœâ¶ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœâµ : CategoryTheory.Category.{v', u'} D\ninstâœâ´ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.PreservesZeroMorphisms\nX Y : C\ninstâœÂ² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninstâœ : CategoryTheory.Epi (F.biprodComparison' X Y)\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- If the (coproduct-like) biproduct comparison for `F`, `X` and `Y` is an epimorphism, then\n    `F` preserves the biproduct of `X` and `Y`. For the converse, see `mapBiprod`. -/\nlemma preservesBinaryBiproduct_of_epi_biprodComparison' {X Y : C} [HasBinaryBiproduct X Y]\n    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Epi (biprodComparison' F X Y)] :\n    PreservesBinaryBiproduct X Y F := by\n  haveI : Epi (splitEpiBiprodComparison F X Y).section_ := by simpa\n  haveI : IsIso (biprodComparison F X Y) :=\n    IsIso.of_epi_section' (splitEpiBiprodComparison F X Y)\n  apply preservesBinaryBiproduct_of_mono_biprodComparison\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBinaryProducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary products\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBinaryProducts\n    [PreservesLimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F where\n  preserves {_} {_} := preservesBinaryBiproduct_of_preservesBinaryProduct F\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryCoproduct_of_preservesBinaryBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\nX Y : C\ninstâœ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nâŠ¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary coproducts. -/\nlemma preservesBinaryCoproduct_of_preservesBinaryBiproduct {X Y : C}\n    [PreservesBinaryBiproduct X Y F] :\n    PreservesColimit (pair X Y) F where\n  preserves {c} hc :=\n    âŸ¨IsColimit.ofIsoColimit\n        ((IsColimit.precomposeHomEquiv (diagramIsoPair _) _).symm\n          (isBinaryBilimitOfPreserves F\n              (binaryBiconeIsBilimitOfColimitCoconeOfIsColimit hc)).isColimit) <|\n      Cocones.ext (by dsimp; rfl) fun j => by\n        rcases j with âŸ¨âŸ¨âŸ©âŸ© <;> simpâŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryCoproducts_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\ninstâœ : CategoryTheory.Limits.PreservesBinaryBiproducts F\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts\n    preserves binary coproducts. -/\nlemma preservesBinaryCoproducts_of_preservesBinaryBiproducts [PreservesBinaryBiproducts F] :\n    PreservesColimitsOfShape (Discrete WalkingPair) F where\n  preservesColimit {_} := preservesColimit_of_iso_diagram _ (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBinaryCoproduct","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\nX Y : C\ninstâœ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) F\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBinaryCoproduct {X Y : C}\n    [PreservesColimit (pair X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb :=\n    âŸ¨isBinaryBilimitOfIsColimit _ <|\n      IsColimit.ofIsoColimit\n          ((IsColimit.precomposeInvEquiv (diagramIsoPair _) (F.mapCocone b.toCocone)).symm\n            (isColimitOfPreserves F hb.isColimit)) <|\n        Cocones.ext (Iso.refl _) fun j => by\n          rcases j with âŸ¨âŸ¨âŸ©âŸ© <;> simpâŸ©\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBinaryCoproducts","module":"Mathlib.CategoryTheory.Preadditive.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Preadditive C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.PreservesZeroMorphisms\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nâŠ¢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts\n    preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBinaryCoproducts\n    [PreservesColimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F where\n  preserves {_} {_} := preservesBinaryBiproduct_of_preservesBinaryCoproduct F\n\n"}
