{"name":"isLittleO_pow_pow_of_lt_left","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r‚ÇÅ r‚ÇÇ : Real\nh‚ÇÅ : LE.le 0 r‚ÇÅ\nh‚ÇÇ : LT.lt r‚ÇÅ r‚ÇÇ\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HPow.hPow r‚ÇÅ n) fun n => HPow.hPow r‚ÇÇ n","decl":"theorem isLittleO_pow_pow_of_lt_left {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r‚ÇÅ) (h‚ÇÇ : r‚ÇÅ < r‚ÇÇ) :\n    (fun n : ‚Ñï ‚Ü¶ r‚ÇÅ ^ n) =o[atTop] fun n ‚Ü¶ r‚ÇÇ ^ n :=\n  have H : 0 < r‚ÇÇ := h‚ÇÅ.trans_lt h‚ÇÇ\n  (isLittleO_of_tendsto fun _ hn ‚Ü¶ False.elim <| H.ne' <| pow_eq_zero hn) <|\n    (tendsto_pow_atTop_nhds_zero_of_lt_one\n      (div_nonneg h‚ÇÅ (h‚ÇÅ.trans h‚ÇÇ.le)) ((div_lt_one H).2 h‚ÇÇ)).congr fun _ ‚Ü¶ div_pow _ _ _\n\n"}
{"name":"isBigO_pow_pow_of_le_left","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r‚ÇÅ r‚ÇÇ : Real\nh‚ÇÅ : LE.le 0 r‚ÇÅ\nh‚ÇÇ : LE.le r‚ÇÅ r‚ÇÇ\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun n => HPow.hPow r‚ÇÅ n) fun n => HPow.hPow r‚ÇÇ n","decl":"theorem isBigO_pow_pow_of_le_left {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r‚ÇÅ) (h‚ÇÇ : r‚ÇÅ ‚â§ r‚ÇÇ) :\n    (fun n : ‚Ñï ‚Ü¶ r‚ÇÅ ^ n) =O[atTop] fun n ‚Ü¶ r‚ÇÇ ^ n :=\n  h‚ÇÇ.eq_or_lt.elim (fun h ‚Ü¶ h ‚ñ∏ isBigO_refl _ _) fun h ‚Ü¶ (isLittleO_pow_pow_of_lt_left h‚ÇÅ h).isBigO\n\n"}
{"name":"isLittleO_pow_pow_of_abs_lt_left","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r‚ÇÅ r‚ÇÇ : Real\nh : LT.lt (abs r‚ÇÅ) (abs r‚ÇÇ)\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HPow.hPow r‚ÇÅ n) fun n => HPow.hPow r‚ÇÇ n","decl":"theorem isLittleO_pow_pow_of_abs_lt_left {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h : |r‚ÇÅ| < |r‚ÇÇ|) :\n    (fun n : ‚Ñï ‚Ü¶ r‚ÇÅ ^ n) =o[atTop] fun n ‚Ü¶ r‚ÇÇ ^ n := by\n  refine (IsLittleO.of_norm_left ?_).of_norm_right\n  exact (isLittleO_pow_pow_of_lt_left (abs_nonneg r‚ÇÅ) h).congr (pow_abs r‚ÇÅ) (pow_abs r‚ÇÇ)\n\n"}
{"name":"TFAE_exists_lt_isLittleO_pow","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"f : Nat ‚Üí Real\nR : Real\n‚ä¢ (List.cons (Exists fun a => And (Membership.mem (Set.Ioo (Neg.neg R) R) a) (Asymptotics.IsLittleO Filter.atTop f fun x => HPow.hPow a x)) (List.cons (Exists fun a => And (Membership.mem (Set.Ioo 0 R) a) (Asymptotics.IsLittleO Filter.atTop f fun x => HPow.hPow a x)) (List.cons (Exists fun a => And (Membership.mem (Set.Ioo (Neg.neg R) R) a) (Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow a x)) (List.cons (Exists fun a => And (Membership.mem (Set.Ioo 0 R) a) (Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow a x)) (List.cons (Exists fun a => And (LT.lt a R) (Exists fun C => And (Or (LT.lt 0 C) (LT.lt 0 R)) (‚àÄ (n : Nat), LE.le (abs (f n)) (HMul.hMul C (HPow.hPow a n))))) (List.cons (Exists fun a => And (Membership.mem (Set.Ioo 0 R) a) (Exists fun C => And (GT.gt C 0) (‚àÄ (n : Nat), LE.le (abs (f n)) (HMul.hMul C (HPow.hPow a n))))) (List.cons (Exists fun a => And (LT.lt a R) (Filter.Eventually (fun n => LE.le (abs (f n)) (HPow.hPow a n)) Filter.atTop)) (List.cons (Exists fun a => And (Membership.mem (Set.Ioo 0 R) a) (Filter.Eventually (fun n => LE.le (abs (f n)) (HPow.hPow a n)) Filter.atTop)) List.nil)))))))).TFAE","decl":"open List in\n/-- Various statements equivalent to the fact that `f n` grows exponentially slower than `R ^ n`.\n\n* 0: $f n = o(a ^ n)$ for some $-R < a < R$;\n* 1: $f n = o(a ^ n)$ for some $0 < a < R$;\n* 2: $f n = O(a ^ n)$ for some $-R < a < R$;\n* 3: $f n = O(a ^ n)$ for some $0 < a < R$;\n* 4: there exist `a < R` and `C` such that one of `C` and `R` is positive and $|f n| ‚â§ Ca^n$\n     for all `n`;\n* 5: there exists `0 < a < R` and a positive `C` such that $|f n| ‚â§ Ca^n$ for all `n`;\n* 6: there exists `a < R` such that $|f n| ‚â§ a ^ n$ for sufficiently large `n`;\n* 7: there exists `0 < a < R` such that $|f n| ‚â§ a ^ n$ for sufficiently large `n`.\n\nNB: For backwards compatibility, if you add more items to the list, please append them at the end of\nthe list. -/\ntheorem TFAE_exists_lt_isLittleO_pow (f : ‚Ñï ‚Üí ‚Ñù) (R : ‚Ñù) :\n    TFAE\n      [‚àÉ a ‚àà Ioo (-R) R, f =o[atTop] (a ^ ¬∑), ‚àÉ a ‚àà Ioo 0 R, f =o[atTop] (a ^ ¬∑),\n        ‚àÉ a ‚àà Ioo (-R) R, f =O[atTop] (a ^ ¬∑), ‚àÉ a ‚àà Ioo 0 R, f =O[atTop] (a ^ ¬∑),\n        ‚àÉ a < R, ‚àÉ C : ‚Ñù, (0 < C ‚à® 0 < R) ‚àß ‚àÄ n, |f n| ‚â§ C * a ^ n,\n        ‚àÉ a ‚àà Ioo 0 R, ‚àÉ C > 0, ‚àÄ n, |f n| ‚â§ C * a ^ n, ‚àÉ a < R, ‚àÄ·∂† n in atTop, |f n| ‚â§ a ^ n,\n        ‚àÉ a ‚àà Ioo 0 R, ‚àÄ·∂† n in atTop, |f n| ‚â§ a ^ n] := by\n  have A : Ico 0 R ‚äÜ Ioo (-R) R :=\n    fun x hx ‚Ü¶ ‚ü®(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2‚ü©\n  have B : Ioo 0 R ‚äÜ Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A\n  -- First we prove that 1-4 are equivalent using 2 ‚Üí 3 ‚Üí 4, 1 ‚Üí 3, and 2 ‚Üí 1\n  tfae_have 1 ‚Üí 3 := fun ‚ü®a, ha, H‚ü© ‚Ü¶ ‚ü®a, ha, H.isBigO‚ü©\n  tfae_have 2 ‚Üí 1 := fun ‚ü®a, ha, H‚ü© ‚Ü¶ ‚ü®a, B ha, H‚ü©\n  tfae_have 3 ‚Üí 2\n  | ‚ü®a, ha, H‚ü© => by\n    rcases exists_between (abs_lt.2 ha) with ‚ü®b, hab, hbR‚ü©\n    exact ‚ü®b, ‚ü®(abs_nonneg a).trans_lt hab, hbR‚ü©,\n      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))‚ü©\n  tfae_have 2 ‚Üí 4 := fun ‚ü®a, ha, H‚ü© ‚Ü¶ ‚ü®a, ha, H.isBigO‚ü©\n  tfae_have 4 ‚Üí 3 := fun ‚ü®a, ha, H‚ü© ‚Ü¶ ‚ü®a, B ha, H‚ü©\n  -- Add 5 and 6 using 4 ‚Üí 6 ‚Üí 5 ‚Üí 3\n  tfae_have 4 ‚Üí 6\n  | ‚ü®a, ha, H‚ü© => by\n    rcases bound_of_isBigO_nat_atTop H with ‚ü®C, hC‚ÇÄ, hC‚ü©\n    refine ‚ü®a, ha, C, hC‚ÇÄ, fun n ‚Ü¶ ?_‚ü©\n    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')\n  tfae_have 6 ‚Üí 5 := fun ‚ü®a, ha, C, H‚ÇÄ, H‚ü© ‚Ü¶ ‚ü®a, ha.2, C, Or.inl H‚ÇÄ, H‚ü©\n  tfae_have 5 ‚Üí 3\n  | ‚ü®a, ha, C, h‚ÇÄ, H‚ü© => by\n    rcases sign_cases_of_C_mul_pow_nonneg fun n ‚Ü¶ (abs_nonneg _).trans (H n) with (rfl | ‚ü®hC‚ÇÄ, ha‚ÇÄ‚ü©)\n    ¬∑ obtain rfl : f = 0 := by\n        ext n\n        simpa using H n\n      simp only [lt_irrefl, false_or] at h‚ÇÄ\n      exact ‚ü®0, ‚ü®neg_lt_zero.2 h‚ÇÄ, h‚ÇÄ‚ü©, isBigO_zero _ _‚ü©\n    exact ‚ü®a, A ‚ü®ha‚ÇÄ, ha‚ü©,\n      isBigO_of_le' _ fun n ‚Ü¶ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hC‚ÇÄ.le‚ü©\n  -- Add 7 and 8 using 2 ‚Üí 8 ‚Üí 7 ‚Üí 3\n  tfae_have 2 ‚Üí 8\n  | ‚ü®a, ha, H‚ü© => by\n    refine ‚ü®a, ha, (H.def zero_lt_one).mono fun n hn ‚Ü¶ ?_‚ü©\n    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn\n  tfae_have 8 ‚Üí 7 := fun ‚ü®a, ha, H‚ü© ‚Ü¶ ‚ü®a, ha.2, H‚ü©\n  tfae_have 7 ‚Üí 3\n  | ‚ü®a, ha, H‚ü© => by\n    refine ‚ü®a, A ‚ü®?_, ha‚ü©, .of_norm_eventuallyLE H‚ü©\n    exact nonneg_of_eventually_pow_nonneg (H.mono fun n ‚Ü¶ (abs_nonneg _).trans)\n  tfae_finish\n\n"}
{"name":"isLittleO_pow_const_const_pow_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nk : Nat\nr : Real\nhr : LT.lt 1 r\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HPow.hPow (‚Üën) k) fun n => HPow.hPow r n","decl":"/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n ‚Üí ‚àû`. -/\ntheorem isLittleO_pow_const_const_pow_of_one_lt {R : Type*} [NormedRing R] (k : ‚Ñï) {r : ‚Ñù}\n    (hr : 1 < r) : (fun n ‚Ü¶ (n : R) ^ k : ‚Ñï ‚Üí R) =o[atTop] fun n ‚Ü¶ r ^ n := by\n  have : Tendsto (fun x : ‚Ñù ‚Ü¶ x ^ k) (ùìù[>] 1) (ùìù 1) :=\n    ((continuous_id.pow k).tendsto' (1 : ‚Ñù) 1 (one_pow _)).mono_left inf_le_left\n  obtain ‚ü®r' : ‚Ñù, hr' : r' ^ k < r, h1 : 1 < r'‚ü© :=\n    ((this.eventually (gt_mem_nhds hr)).and self_mem_nhdsWithin).exists\n  have h0 : 0 ‚â§ r' := zero_le_one.trans h1.le\n  suffices (fun n ‚Ü¶ (n : R) ^ k : ‚Ñï ‚Üí R) =O[atTop] fun n : ‚Ñï ‚Ü¶ (r' ^ k) ^ n from\n    this.trans_isLittleO (isLittleO_pow_pow_of_lt_left (pow_nonneg h0 _) hr')\n  conv in (r' ^ _) ^ _ => rw [‚Üê pow_mul, mul_comm, pow_mul]\n  suffices ‚àÄ n : ‚Ñï, ‚Äñ(n : R)‚Äñ ‚â§ (r' - 1)‚Åª¬π * ‚Äñ(1 : R)‚Äñ * ‚Äñr' ^ n‚Äñ from\n    (isBigO_of_le' _ this).pow _\n  intro n\n  rw [mul_right_comm]\n  refine n.norm_cast_le.trans (mul_le_mul_of_nonneg_right ?_ (norm_nonneg _))\n  simpa [_root_.div_eq_inv_mul, Real.norm_eq_abs, abs_of_nonneg h0] using n.cast_le_pow_div_sub h1\n\n"}
{"name":"isLittleO_coe_const_pow_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nr : Real\nhr : LT.lt 1 r\n‚ä¢ Asymptotics.IsLittleO Filter.atTop Nat.cast fun n => HPow.hPow r n","decl":"/-- For a real `r > 1` we have `n = o(r ^ n)` as `n ‚Üí ‚àû`. -/\ntheorem isLittleO_coe_const_pow_of_one_lt {R : Type*} [NormedRing R] {r : ‚Ñù} (hr : 1 < r) :\n    ((‚Üë) : ‚Ñï ‚Üí R) =o[atTop] fun n ‚Ü¶ r ^ n := by\n  simpa only [pow_one] using @isLittleO_pow_const_const_pow_of_one_lt R _ 1 _ hr\n\n"}
{"name":"isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nk : Nat\nr‚ÇÅ : R\nr‚ÇÇ : Real\nh : LT.lt (Norm.norm r‚ÇÅ) r‚ÇÇ\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HMul.hMul (HPow.hPow (‚Üën) k) (HPow.hPow r‚ÇÅ n)) fun n => HPow.hPow r‚ÇÇ n","decl":"/-- If `‚Äñr‚ÇÅ‚Äñ < r‚ÇÇ`, then for any natural `k` we have `n ^ k r‚ÇÅ ^ n = o (r‚ÇÇ ^ n)` as `n ‚Üí ‚àû`. -/\ntheorem isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type*} [NormedRing R] (k : ‚Ñï)\n    {r‚ÇÅ : R} {r‚ÇÇ : ‚Ñù} (h : ‚Äñr‚ÇÅ‚Äñ < r‚ÇÇ) :\n    (fun n ‚Ü¶ (n : R) ^ k * r‚ÇÅ ^ n : ‚Ñï ‚Üí R) =o[atTop] fun n ‚Ü¶ r‚ÇÇ ^ n := by\n  by_cases h0 : r‚ÇÅ = 0\n  ¬∑ refine (isLittleO_zero _ _).congr' (mem_atTop_sets.2 <| ‚ü®1, fun n hn ‚Ü¶ ?_‚ü©) EventuallyEq.rfl\n    simp [zero_pow (one_le_iff_ne_zero.1 hn), h0]\n  rw [‚Üê Ne, ‚Üê norm_pos_iff] at h0\n  have A : (fun n ‚Ü¶ (n : R) ^ k : ‚Ñï ‚Üí R) =o[atTop] fun n ‚Ü¶ (r‚ÇÇ / ‚Äñr‚ÇÅ‚Äñ) ^ n :=\n    isLittleO_pow_const_const_pow_of_one_lt k ((one_lt_div h0).2 h)\n  suffices (fun n ‚Ü¶ r‚ÇÅ ^ n) =O[atTop] fun n ‚Ü¶ ‚Äñr‚ÇÅ‚Äñ ^ n by\n    simpa [div_mul_cancel‚ÇÄ _ (pow_pos h0 _).ne', div_pow] using A.mul_isBigO this\n  exact .of_norm_eventuallyLE <| eventually_norm_pow_le r‚ÇÅ\n\n"}
{"name":"tendsto_pow_const_div_const_pow_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"k : Nat\nr : Real\nhr : LT.lt 1 r\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (HPow.hPow (‚Üën) k) (HPow.hPow r n)) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_const_div_const_pow_of_one_lt (k : ‚Ñï) {r : ‚Ñù} (hr : 1 < r) :\n    Tendsto (fun n ‚Ü¶ (n : ‚Ñù) ^ k / r ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) :=\n  (isLittleO_pow_const_const_pow_of_one_lt k hr).tendsto_div_nhds_zero\n\n"}
{"name":"tendsto_pow_const_mul_const_pow_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"k : Nat\nr : Real\nhr : LT.lt (abs r) 1\n‚ä¢ Filter.Tendsto (fun n => HMul.hMul (HPow.hPow (‚Üën) k) (HPow.hPow r n)) Filter.atTop (nhds 0)","decl":"/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ‚Ñï) {r : ‚Ñù} (hr : |r| < 1) :\n    Tendsto (fun n ‚Ü¶ (n : ‚Ñù) ^ k * r ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) := by\n  by_cases h0 : r = 0\n  ¬∑ exact tendsto_const_nhds.congr'\n      (mem_atTop_sets.2 ‚ü®1, fun n hn ‚Ü¶ by simp [zero_lt_one.trans_le hn |>.ne', h0]‚ü©)\n  have hr' : 1 < |r|‚Åª¬π := (one_lt_inv‚ÇÄ (abs_pos.2 h0)).2 hr\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'\n\n"}
{"name":"tendsto_const_div_pow","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nk : Nat\nhk : Ne k 0\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv r (HPow.hPow (‚Üën) k)) Filter.atTop (nhds 0)","decl":"/--For `k ‚â† 0` and a constant `r` the function `r / n ^ k` tends to zero. -/\nlemma tendsto_const_div_pow (r : ‚Ñù) (k : ‚Ñï) (hk : k ‚â† 0) :\n    Tendsto (fun n : ‚Ñï => r / n ^ k) atTop (ùìù 0) := by\n  simpa using Filter.Tendsto.const_div_atTop (tendsto_natCast_atTop_atTop (R := ‚Ñù).comp\n    (tendsto_pow_atTop hk) ) r\n\n"}
{"name":"tendsto_pow_const_mul_const_pow_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"k : Nat\nr : Real\nhr : LE.le 0 r\nh'r : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HMul.hMul (HPow.hPow (‚Üën) k) (HPow.hPow r n)) Filter.atTop (nhds 0)","decl":"/-- If `0 ‚â§ r < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`.\nThis is a specialized version of `tendsto_pow_const_mul_const_pow_of_abs_lt_one`, singled out\nfor ease of application. -/\ntheorem tendsto_pow_const_mul_const_pow_of_lt_one (k : ‚Ñï) {r : ‚Ñù} (hr : 0 ‚â§ r) (h'r : r < 1) :\n    Tendsto (fun n ‚Ü¶ (n : ‚Ñù) ^ k * r ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) :=\n  tendsto_pow_const_mul_const_pow_of_abs_lt_one k (abs_lt.2 ‚ü®neg_one_lt_zero.trans_le hr, h'r‚ü©)\n\n"}
{"name":"tendsto_self_mul_const_pow_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nhr : LT.lt (abs r) 1\n‚ä¢ Filter.Tendsto (fun n => HMul.hMul (‚Üën) (HPow.hPow r n)) Filter.atTop (nhds 0)","decl":"/-- If `|r| < 1`, then `n * r ^ n` tends to zero. -/\ntheorem tendsto_self_mul_const_pow_of_abs_lt_one {r : ‚Ñù} (hr : |r| < 1) :\n    Tendsto (fun n ‚Ü¶ n * r ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_abs_lt_one 1 hr\n\n"}
{"name":"tendsto_self_mul_const_pow_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nhr : LE.le 0 r\nh'r : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HMul.hMul (‚Üën) (HPow.hPow r n)) Filter.atTop (nhds 0)","decl":"/-- If `0 ‚â§ r < 1`, then `n * r ^ n` tends to zero. This is a specialized version of\n`tendsto_self_mul_const_pow_of_abs_lt_one`, singled out for ease of application. -/\ntheorem tendsto_self_mul_const_pow_of_lt_one {r : ‚Ñù} (hr : 0 ‚â§ r) (h'r : r < 1) :\n    Tendsto (fun n ‚Ü¶ n * r ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) := by\n  simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_lt_one 1 hr h'r\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow x n) Filter.atTop (nhds 0)","decl":"/-- In a normed ring, the powers of an element x with `‚Äñx‚Äñ < 1` tend to zero. -/\ntheorem tendsto_pow_atTop_nhds_zero_of_norm_lt_one {R : Type*} [NormedRing R] {x : R}\n    (h : ‚Äñx‚Äñ < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ x ^ n) atTop (ùìù 0) := by\n  apply squeeze_zero_norm' (eventually_norm_pow_le x)\n  exact tendsto_pow_atTop_nhds_zero_of_lt_one (norm_nonneg _) h\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nh : LT.lt (abs r) 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_atTop_nhds_zero_of_abs_lt_one {r : ‚Ñù} (h : |r| < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù 0) :=\n  tendsto_pow_atTop_nhds_zero_of_norm_lt_one h\n\n"}
{"name":"HasSummableGeomSeries.summable_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù : NormedRing K\nself : HasSummableGeomSeries K\nŒæ : K\na‚úù : LT.lt (Norm.norm Œæ) 1\n‚ä¢ Summable fun n => HPow.hPow Œæ n","decl":"/-- A normed ring has summable geometric series if, for all `Œæ` of norm `< 1`, the geometric series\n`‚àë Œæ ^ n` converges. This holds both in complete normed rings and in normed fields, providing a\nconvenient abstraction of these two classes to avoid repeating the same proofs. -/\nclass HasSummableGeomSeries (K : Type*) [NormedRing K] : Prop where\n  summable_geometric_of_norm_lt_one : ‚àÄ (Œæ : K), ‚ÄñŒæ‚Äñ < 1 ‚Üí Summable (fun n ‚Ü¶ Œæ ^ n)\n\n"}
{"name":"summable_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù¬π : NormedRing K\ninst‚úù : HasSummableGeomSeries K\nx : K\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Summable fun n => HPow.hPow x n","decl":"lemma summable_geometric_of_norm_lt_one {K : Type*} [NormedRing K] [HasSummableGeomSeries K]\n    {x : K} (h : ‚Äñx‚Äñ < 1) : Summable (fun n ‚Ü¶ x ^ n) :=\n  HasSummableGeomSeries.summable_geometric_of_norm_lt_one x h\n\n"}
{"name":"instHasSummableGeomSeriesOfCompleteSpace","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : CompleteSpace R\n‚ä¢ HasSummableGeomSeries R","decl":"instance {R : Type*} [NormedRing R] [CompleteSpace R] : HasSummableGeomSeries R := by\n  constructor\n  intro x hx\n  have h1 : Summable fun n : ‚Ñï ‚Ü¶ ‚Äñx‚Äñ ^ n := summable_geometric_of_lt_one (norm_nonneg _) hx\n  exact h1.of_norm_bounded_eventually_nat _ (eventually_norm_pow_le x)\n\n"}
{"name":"tsum_geometric_le_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ LE.le (Norm.norm (tsum fun n => HPow.hPow x n)) (HAdd.hAdd (HSub.hSub (Norm.norm 1) 1) (Inv.inv (HSub.hSub 1 (Norm.norm x))))","decl":"/-- Bound for the sum of a geometric series in a normed ring. This formula does not assume that the\nnormed ring satisfies the axiom `‚Äñ1‚Äñ = 1`. -/\ntheorem tsum_geometric_le_of_norm_lt_one (x : R) (h : ‚Äñx‚Äñ < 1) :\n    ‚Äñ‚àë' n : ‚Ñï, x ^ n‚Äñ ‚â§ ‚Äñ(1 : R)‚Äñ - 1 + (1 - ‚Äñx‚Äñ)‚Åª¬π := by\n  by_cases hx : Summable (fun n ‚Ü¶ x ^ n)\n  ¬∑ rw [tsum_eq_zero_add hx]\n    simp only [_root_.pow_zero]\n    refine le_trans (norm_add_le _ _) ?_\n    have : ‚Äñ‚àë' b : ‚Ñï, (fun n ‚Ü¶ x ^ (n + 1)) b‚Äñ ‚â§ (1 - ‚Äñx‚Äñ)‚Åª¬π - 1 := by\n      refine tsum_of_norm_bounded ?_ fun b ‚Ü¶ norm_pow_le' _ (Nat.succ_pos b)\n      convert (hasSum_nat_add_iff' 1).mpr (hasSum_geometric_of_lt_one (norm_nonneg x) h)\n      simp\n    linarith\n  ¬∑ simp [tsum_eq_zero_of_not_summable hx]\n    nontriviality R\n    have : 1 ‚â§ ‚Äñ(1 : R)‚Äñ := one_le_norm_one R\n    have : 0 ‚â§ (1 - ‚Äñx‚Äñ) ‚Åª¬π := inv_nonneg.2 (by linarith)\n    linarith\n\n"}
{"name":"geom_series_mul_neg","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (HMul.hMul (tsum fun i => HPow.hPow x i) (HSub.hSub 1 x)) 1","decl":"theorem geom_series_mul_neg (x : R) (h : ‚Äñx‚Äñ < 1) : (‚àë' i : ‚Ñï, x ^ i) * (1 - x) = 1 := by\n  have := (summable_geometric_of_norm_lt_one h).hasSum.mul_right (1 - x)\n  refine tendsto_nhds_unique this.tendsto_sum_nat ?_\n  have : Tendsto (fun n : ‚Ñï ‚Ü¶ 1 - x ^ n) atTop (ùìù 1) := by\n    simpa using tendsto_const_nhds.sub (tendsto_pow_atTop_nhds_zero_of_norm_lt_one h)\n  convert‚Üê this\n  rw [‚Üê geom_sum_mul_neg, Finset.sum_mul]\n\n"}
{"name":"mul_neg_geom_series","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (HMul.hMul (HSub.hSub 1 x) (tsum fun i => HPow.hPow x i)) 1","decl":"theorem mul_neg_geom_series (x : R) (h : ‚Äñx‚Äñ < 1) : (1 - x) * ‚àë' i : ‚Ñï, x ^ i = 1 := by\n  have := (summable_geometric_of_norm_lt_one h).hasSum.mul_left (1 - x)\n  refine tendsto_nhds_unique this.tendsto_sum_nat ?_\n  have : Tendsto (fun n : ‚Ñï ‚Ü¶ 1 - x ^ n) atTop (ùìù 1) := by\n    simpa using tendsto_const_nhds.sub (tendsto_pow_atTop_nhds_zero_of_norm_lt_one h)\n  convert‚Üê this\n  rw [‚Üê mul_neg_geom_sum, Finset.mul_sum]\n\n"}
{"name":"geom_series_succ","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (tsum fun i => HPow.hPow x (HAdd.hAdd i 1)) (HSub.hSub (tsum fun i => HPow.hPow x i) 1)","decl":"theorem geom_series_succ (x : R) (h : ‚Äñx‚Äñ < 1) : ‚àë' i : ‚Ñï, x ^ (i + 1) = ‚àë' i : ‚Ñï, x ^ i - 1 := by\n  rw [eq_sub_iff_add_eq, tsum_eq_zero_add (summable_geometric_of_norm_lt_one h),\n    pow_zero, add_comm]\n\n"}
{"name":"geom_series_mul_shift","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (HMul.hMul x (tsum fun i => HPow.hPow x i)) (tsum fun i => HPow.hPow x (HAdd.hAdd i 1))","decl":"theorem geom_series_mul_shift (x : R) (h : ‚Äñx‚Äñ < 1) :\n    x * ‚àë' i : ‚Ñï, x ^ i = ‚àë' i : ‚Ñï, x ^ (i + 1) := by\n  simp_rw [‚Üê (summable_geometric_of_norm_lt_one h).tsum_mul_left, ‚Üê _root_.pow_succ']\n\n"}
{"name":"geom_series_mul_one_add","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (HMul.hMul (HAdd.hAdd 1 x) (tsum fun i => HPow.hPow x i)) (HSub.hSub (HMul.hMul 2 (tsum fun i => HPow.hPow x i)) 1)","decl":"theorem geom_series_mul_one_add (x : R) (h : ‚Äñx‚Äñ < 1) :\n    (1 + x) * ‚àë' i : ‚Ñï, x ^ i = 2 * ‚àë' i : ‚Ñï, x ^ i - 1 := by\n  rw [add_mul, one_mul, geom_series_mul_shift x h, geom_series_succ x h, two_mul, add_sub_assoc]\n\n"}
{"name":"Units.val_oneSub","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nt : R\nh : LT.lt (Norm.norm t) 1\n‚ä¢ Eq (‚Üë(Units.oneSub t h)) (HSub.hSub 1 t)","decl":"/-- In a normed ring with summable geometric series, a perturbation of `1` by an element `t`\nof distance less than `1` from `1` is a unit.  Here we construct its `Units` structure. -/\n@[simps val]\ndef Units.oneSub (t : R) (h : ‚Äñt‚Äñ < 1) : RÀ£ where\n  val := 1 - t\n  inv := ‚àë' n : ‚Ñï, t ^ n\n  val_inv := mul_neg_geom_series t h\n  inv_val := geom_series_mul_neg t h\n\n"}
{"name":"geom_series_eq_inverse","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ Eq (tsum fun i => HPow.hPow x i) (Ring.inverse (HSub.hSub 1 x))","decl":"theorem geom_series_eq_inverse (x : R) (h : ‚Äñx‚Äñ < 1) :\n    ‚àë' i, x ^ i = Ring.inverse (1 - x) := by\n  change (Units.oneSub x h) ‚Åª¬π = Ring.inverse (1 - x)\n  rw [‚Üê Ring.inverse_unit]\n  rfl\n\n"}
{"name":"hasSum_geom_series_inverse","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ HasSum (fun i => HPow.hPow x i) (Ring.inverse (HSub.hSub 1 x))","decl":"theorem hasSum_geom_series_inverse (x : R) (h : ‚Äñx‚Äñ < 1) :\n    HasSum (fun i ‚Ü¶ x ^ i) (Ring.inverse (1 - x)) := by\n  convert (summable_geometric_of_norm_lt_one h).hasSum\n  exact (geom_series_eq_inverse x h).symm\n\n"}
{"name":"isUnit_one_sub_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ IsUnit (HSub.hSub 1 x)","decl":"lemma isUnit_one_sub_of_norm_lt_one {x : R} (h : ‚Äñx‚Äñ < 1) : IsUnit (1 - x) :=\n  ‚ü®Units.oneSub x h, rfl‚ü©\n\n"}
{"name":"hasSum_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù : NormedDivisionRing K\nŒæ : K\nh : LT.lt (Norm.norm Œæ) 1\n‚ä¢ HasSum (fun n => HPow.hPow Œæ n) (Inv.inv (HSub.hSub 1 Œæ))","decl":"theorem hasSum_geometric_of_norm_lt_one (h : ‚ÄñŒæ‚Äñ < 1) : HasSum (fun n : ‚Ñï ‚Ü¶ Œæ ^ n) (1 - Œæ)‚Åª¬π := by\n  have xi_ne_one : Œæ ‚â† 1 := by\n    contrapose! h\n    simp [h]\n  have A : Tendsto (fun n ‚Ü¶ (Œæ ^ n - 1) * (Œæ - 1)‚Åª¬π) atTop (ùìù ((0 - 1) * (Œæ - 1)‚Åª¬π)) :=\n    ((tendsto_pow_atTop_nhds_zero_of_norm_lt_one h).sub tendsto_const_nhds).mul tendsto_const_nhds\n  rw [hasSum_iff_tendsto_nat_of_summable_norm]\n  ¬∑ simpa [geom_sum_eq, xi_ne_one, neg_inv, div_eq_mul_inv] using A\n  ¬∑ simp [norm_pow, summable_geometric_of_lt_one (norm_nonneg _) h]\n\n"}
{"name":"instHasSummableGeomSeries","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù : NormedDivisionRing K\n‚ä¢ HasSummableGeomSeries K","decl":"instance : HasSummableGeomSeries K :=\n  ‚ü®fun _ h ‚Ü¶ (hasSum_geometric_of_norm_lt_one h).summable‚ü©\n\n"}
{"name":"tsum_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù : NormedDivisionRing K\nŒæ : K\nh : LT.lt (Norm.norm Œæ) 1\n‚ä¢ Eq (tsum fun n => HPow.hPow Œæ n) (Inv.inv (HSub.hSub 1 Œæ))","decl":"theorem tsum_geometric_of_norm_lt_one (h : ‚ÄñŒæ‚Äñ < 1) : ‚àë' n : ‚Ñï, Œæ ^ n = (1 - Œæ)‚Åª¬π :=\n  (hasSum_geometric_of_norm_lt_one h).tsum_eq\n\n"}
{"name":"hasSum_geometric_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nh : LT.lt (abs r) 1\n‚ä¢ HasSum (fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem hasSum_geometric_of_abs_lt_one {r : ‚Ñù} (h : |r| < 1) :\n    HasSum (fun n : ‚Ñï ‚Ü¶ r ^ n) (1 - r)‚Åª¬π :=\n  hasSum_geometric_of_norm_lt_one h\n\n"}
{"name":"summable_geometric_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nh : LT.lt (abs r) 1\n‚ä¢ Summable fun n => HPow.hPow r n","decl":"theorem summable_geometric_of_abs_lt_one {r : ‚Ñù} (h : |r| < 1) : Summable fun n : ‚Ñï ‚Ü¶ r ^ n :=\n  summable_geometric_of_norm_lt_one h\n\n"}
{"name":"tsum_geometric_of_abs_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"r : Real\nh : LT.lt (abs r) 1\n‚ä¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem tsum_geometric_of_abs_lt_one {r : ‚Ñù} (h : |r| < 1) : ‚àë' n : ‚Ñï, r ^ n = (1 - r)‚Åª¬π :=\n  tsum_geometric_of_norm_lt_one h\n\n"}
{"name":"summable_geometric_iff_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"K : Type u_2\ninst‚úù : NormedDivisionRing K\nŒæ : K\n‚ä¢ Iff (Summable fun n => HPow.hPow Œæ n) (LT.lt (Norm.norm Œæ) 1)","decl":"/-- A geometric series in a normed field is summable iff the norm of the common ratio is less than\none. -/\n@[simp]\ntheorem summable_geometric_iff_norm_lt_one : (Summable fun n : ‚Ñï ‚Ü¶ Œæ ^ n) ‚Üî ‚ÄñŒæ‚Äñ < 1 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, summable_geometric_of_norm_lt_one‚ü©\n  obtain ‚ü®k : ‚Ñï, hk : dist (Œæ ^ k) 0 < 1‚ü© :=\n    (h.tendsto_cofinite_zero.eventually (ball_mem_nhds _ zero_lt_one)).exists\n  simp only [norm_pow, dist_zero_right] at hk\n  rw [‚Üê one_pow k] at hk\n  exact lt_of_pow_lt_pow_left‚ÇÄ _ zero_le_one hk\n\n"}
{"name":"summable_norm_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\nu : Nat ‚Üí Nat\nhu : Asymptotics.IsBigO Filter.atTop (fun n => ‚Üë(u n)) fun n => ‚Üë(HPow.hPow n k)\n‚ä¢ Summable fun n => Norm.norm (HMul.hMul (‚Üë(u n)) (HPow.hPow r n))","decl":"theorem summable_norm_mul_geometric_of_norm_lt_one {k : ‚Ñï} {r : R}\n    (hr : ‚Äñr‚Äñ < 1) {u : ‚Ñï ‚Üí ‚Ñï} (hu : (fun n ‚Ü¶ (u n : ‚Ñù)) =O[atTop] (fun n ‚Ü¶ (‚Üë(n ^ k) : ‚Ñù))) :\n    Summable fun n : ‚Ñï ‚Ü¶ ‚Äñ(u n * r ^ n : R)‚Äñ := by\n  rcases exists_between hr with ‚ü®r', hrr', h‚ü©\n  rw [‚Üê norm_norm] at hrr'\n  apply summable_of_isBigO_nat (summable_geometric_of_lt_one ((norm_nonneg _).trans hrr'.le) h)\n  calc\n  fun n ‚Ü¶ ‚Äñ‚Üë(u n) * r ^ n‚Äñ\n  _ =O[atTop] fun n ‚Ü¶ u n * ‚Äñr‚Äñ ^ n := by\n      apply (IsBigOWith.of_bound (c := ‚Äñ(1 : R)‚Äñ) ?_).isBigO\n      filter_upwards [eventually_norm_pow_le r] with n hn\n      simp only [norm_norm, norm_mul, Real.norm_eq_abs, abs_cast, norm_pow, abs_norm]\n      apply (norm_mul_le _ _).trans\n      have : ‚Äñ(u n : R)‚Äñ * ‚Äñr ^ n‚Äñ ‚â§ (u n * ‚Äñ(1 : R)‚Äñ) * ‚Äñr‚Äñ ^ n := by\n        gcongr; exact norm_cast_le (u n)\n      exact this.trans (le_of_eq (by ring))\n  _ =O[atTop] fun n ‚Ü¶ ‚Üë(n ^ k) * ‚Äñr‚Äñ ^ n := hu.mul (isBigO_refl _ _)\n  _ =O[atTop] fun n ‚Ü¶ r' ^ n := by\n      simp only [cast_pow]\n      exact (isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt k hrr').isBigO\n\n"}
{"name":"summable_norm_pow_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Summable fun n => Norm.norm (HMul.hMul (HPow.hPow (‚Üën) k) (HPow.hPow r n))","decl":"theorem summable_norm_pow_mul_geometric_of_norm_lt_one (k : ‚Ñï) {r : R}\n    (hr : ‚Äñr‚Äñ < 1) : Summable fun n : ‚Ñï ‚Ü¶ ‚Äñ((n : R) ^ k * r ^ n : R)‚Äñ := by\n  simp only [‚Üê cast_pow]\n  exact summable_norm_mul_geometric_of_norm_lt_one (k := k) (u := fun n ‚Ü¶ n ^ k) hr\n    (isBigO_refl _ _)\n\n"}
{"name":"summable_norm_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù : NormedRing R\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Summable fun n => Norm.norm (HPow.hPow r n)","decl":"theorem summable_norm_geometric_of_norm_lt_one {r : R}\n    (hr : ‚Äñr‚Äñ < 1) : Summable fun n : ‚Ñï ‚Ü¶ ‚Äñ(r ^ n : R)‚Äñ := by\n  simpa using summable_norm_pow_mul_geometric_of_norm_lt_one 0 hr\n\n"}
{"name":"hasSum_choose_mul_geometric_of_norm_lt_one'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ HasSum (fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).choose k)) (HPow.hPow r n)) (HPow.hPow (Ring.inverse (HSub.hSub 1 r)) (HAdd.hAdd k 1))","decl":"lemma hasSum_choose_mul_geometric_of_norm_lt_one'\n    (k : ‚Ñï) {r : R} (hr : ‚Äñr‚Äñ < 1) :\n    HasSum (fun n ‚Ü¶ (n + k).choose k * r ^ n) (Ring.inverse (1 - r) ^ (k + 1)) := by\n  induction k with\n  | zero => simpa using hasSum_geom_series_inverse r hr\n  | succ k ih =>\n      have I1 : Summable (fun (n : ‚Ñï) ‚Ü¶ ‚Äñ(n + k).choose k * r ^ n‚Äñ) := by\n        apply summable_norm_mul_geometric_of_norm_lt_one (k := k) hr\n        apply isBigO_iff.2 ‚ü®2 ^ k, ?_‚ü©\n        filter_upwards [Ioi_mem_atTop k] with n (hn : k < n)\n        simp only [Real.norm_eq_abs, abs_cast, cast_pow, norm_pow]\n        norm_cast\n        calc (n + k).choose k\n          _ ‚â§ (2 * n).choose k := choose_le_choose k (by omega)\n          _ ‚â§ (2 * n) ^ k := Nat.choose_le_pow _ _\n          _ = 2 ^ k * n ^ k := Nat.mul_pow 2 n k\n      convert hasSum_sum_range_mul_of_summable_norm' I1 ih.summable\n        (summable_norm_geometric_of_norm_lt_one hr) (summable_geometric_of_norm_lt_one hr) with n\n      ¬∑ have : ‚àë i ‚àà Finset.range (n + 1), ‚Üë((i + k).choose k) * r ^ i * r ^ (n - i) =\n            ‚àë i ‚àà Finset.range (n + 1), ‚Üë((i + k).choose k) * r ^ n := by\n          apply Finset.sum_congr rfl (fun i hi ‚Ü¶ ?_)\n          simp only [Finset.mem_range] at hi\n          rw [mul_assoc, ‚Üê pow_add, show i + (n - i) = n by omega]\n        simp [this, ‚Üê sum_mul, ‚Üê Nat.cast_sum, sum_range_add_choose n k, add_assoc]\n      ¬∑ rw [ih.tsum_eq, (hasSum_geom_series_inverse r hr).tsum_eq, pow_succ]\n\n"}
{"name":"summable_choose_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Summable fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).choose k)) (HPow.hPow r n)","decl":"lemma summable_choose_mul_geometric_of_norm_lt_one (k : ‚Ñï) {r : R} (hr : ‚Äñr‚Äñ < 1) :\n    Summable (fun n ‚Ü¶ (n + k).choose k * r ^ n) :=\n  (hasSum_choose_mul_geometric_of_norm_lt_one' k hr).summable\n\n"}
{"name":"tsum_choose_mul_geometric_of_norm_lt_one'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Eq (tsum fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).choose k)) (HPow.hPow r n)) (HPow.hPow (Ring.inverse (HSub.hSub 1 r)) (HAdd.hAdd k 1))","decl":"lemma tsum_choose_mul_geometric_of_norm_lt_one' (k : ‚Ñï) {r : R} (hr : ‚Äñr‚Äñ < 1) :\n    ‚àë' n, (n + k).choose k * r ^ n = (Ring.inverse (1 - r)) ^ (k + 1) :=\n  (hasSum_choose_mul_geometric_of_norm_lt_one' k hr).tsum_eq\n\n"}
{"name":"hasSum_choose_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"ùïú : Type u_3\ninst‚úù : NormedDivisionRing ùïú\nk : Nat\nr : ùïú\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ HasSum (fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).choose k)) (HPow.hPow r n)) (HDiv.hDiv 1 (HPow.hPow (HSub.hSub 1 r) (HAdd.hAdd k 1)))","decl":"lemma hasSum_choose_mul_geometric_of_norm_lt_one\n    (k : ‚Ñï) {r : ùïú} (hr : ‚Äñr‚Äñ < 1) :\n    HasSum (fun n ‚Ü¶ (n + k).choose k * r ^ n) (1 / (1 - r) ^ (k + 1)) := by\n  convert hasSum_choose_mul_geometric_of_norm_lt_one' k hr\n  simp\n\n"}
{"name":"tsum_choose_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"ùïú : Type u_3\ninst‚úù : NormedDivisionRing ùïú\nk : Nat\nr : ùïú\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Eq (tsum fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).choose k)) (HPow.hPow r n)) (HDiv.hDiv 1 (HPow.hPow (HSub.hSub 1 r) (HAdd.hAdd k 1)))","decl":"lemma tsum_choose_mul_geometric_of_norm_lt_one (k : ‚Ñï) {r : ùïú} (hr : ‚Äñr‚Äñ < 1) :\n    ‚àë' n, (n + k).choose k * r ^ n = 1/ (1 - r) ^ (k + 1) :=\n  (hasSum_choose_mul_geometric_of_norm_lt_one k hr).tsum_eq\n\n"}
{"name":"summable_descFactorial_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Summable fun n => HMul.hMul (‚Üë((HAdd.hAdd n k).descFactorial k)) (HPow.hPow r n)","decl":"lemma summable_descFactorial_mul_geometric_of_norm_lt_one (k : ‚Ñï) {r : R} (hr : ‚Äñr‚Äñ < 1) :\n    Summable (fun n ‚Ü¶ (n + k).descFactorial k * r ^ n) := by\n  convert (summable_choose_mul_geometric_of_norm_lt_one k hr).mul_left (k.factorial : R)\n    using 2 with n\n  simp [‚Üê mul_assoc, descFactorial_eq_factorial_mul_choose (n + k) k]\n\n"}
{"name":"summable_pow_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nk : Nat\nr : R\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Summable fun n => HMul.hMul (HPow.hPow (‚Üën) k) (HPow.hPow r n)","decl":"open Polynomial in\ntheorem summable_pow_mul_geometric_of_norm_lt_one (k : ‚Ñï) {r : R} (hr : ‚Äñr‚Äñ < 1) :\n    Summable (fun n ‚Ü¶ (n : R) ^ k * r ^ n : ‚Ñï ‚Üí R) := by\n  refine Nat.strong_induction_on k fun k hk => ?_\n  obtain ‚ü®a, ha‚ü© : ‚àÉ (a : ‚Ñï ‚Üí ‚Ñï), ‚àÄ n, (n + k).descFactorial k\n      = n ^ k + ‚àë i ‚àà range k, a i * n ^ i := by\n    let P : Polynomial ‚Ñï := (ascPochhammer ‚Ñï k).comp (Polynomial.X + C 1)\n    refine ‚ü®fun i ‚Ü¶ P.coeff i, fun n ‚Ü¶ ?_‚ü©\n    have mP : Monic P := Monic.comp_X_add_C (monic_ascPochhammer ‚Ñï k) _\n    have dP : P.natDegree = k := by\n      simp only [P, natDegree_comp, ascPochhammer_natDegree, mul_one, natDegree_X_add_C]\n    have A : (n + k).descFactorial k = P.eval n := by\n      have : n + 1 + k - 1 = n + k := by omega\n      simp [P, ascPochhammer_nat_eq_descFactorial, this]\n    conv_lhs => rw [A, mP.as_sum, dP]\n    simp [eval_finset_sum]\n  have : Summable (fun n ‚Ü¶ (n + k).descFactorial k * r ^ n\n      - ‚àë i ‚àà range k, a i * n ^ (i : ‚Ñï) * r ^ n) := by\n    apply (summable_descFactorial_mul_geometric_of_norm_lt_one k hr).sub\n    apply summable_sum (fun i hi ‚Ü¶ ?_)\n    simp_rw [mul_assoc]\n    simp only [Finset.mem_range] at hi\n    exact (hk _ hi).mul_left _\n  convert this using 1\n  ext n\n  simp [ha n, add_mul, sum_mul]\n\n"}
{"name":"hasSum_coe_mul_geometric_of_norm_lt_one'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"R : Type u_2\ninst‚úù¬π : NormedRing R\ninst‚úù : HasSummableGeomSeries R\nx : R\nh : LT.lt (Norm.norm x) 1\n‚ä¢ HasSum (fun n => HMul.hMul (‚Üën) (HPow.hPow x n)) (HMul.hMul x (HPow.hPow (Ring.inverse (HSub.hSub 1 x)) 2))","decl":"/-- If `‚Äñr‚Äñ < 1`, then `‚àë' n : ‚Ñï, n * r ^ n = r / (1 - r) ^ 2`, `HasSum` version in a general ring\nwith summable geometric series. For a version in a field, using division instead of `Ring.inverse`,\nsee `hasSum_coe_mul_geometric_of_norm_lt_one`. -/\ntheorem hasSum_coe_mul_geometric_of_norm_lt_one'\n    {x : R} (h : ‚Äñx‚Äñ < 1) :\n    HasSum (fun n ‚Ü¶ n * x ^ n : ‚Ñï ‚Üí R) (x * (Ring.inverse (1 - x)) ^ 2) := by\n  have A : HasSum (fun (n : ‚Ñï) ‚Ü¶ (n + 1) * x ^ n) (Ring.inverse (1 - x) ^ 2) := by\n    convert hasSum_choose_mul_geometric_of_norm_lt_one' 1 h with n\n    simp\n  have B : HasSum (fun (n : ‚Ñï) ‚Ü¶ x ^ n) (Ring.inverse (1 - x)) := hasSum_geom_series_inverse x h\n  convert A.sub B using 1\n  ¬∑ ext n\n    simp [add_mul]\n  ¬∑ symm\n    calc Ring.inverse (1 - x) ^ 2 - Ring.inverse (1 - x)\n    _ = Ring.inverse (1 - x) ^ 2 - ((1 - x) * Ring.inverse (1 - x)) * Ring.inverse (1 - x) := by\n      simp [Ring.mul_inverse_cancel (1 - x) (isUnit_one_sub_of_norm_lt_one h)]\n    _ = x * Ring.inverse (1 - x) ^ 2 := by noncomm_ring\n\n"}
{"name":"tsum_coe_mul_geometric_of_norm_lt_one'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"ùïú : Type u_3\ninst‚úù : NormedDivisionRing ùïú\nr : ùïú\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Eq (tsum fun n => HMul.hMul (‚Üën) (HPow.hPow r n)) (HMul.hMul r (HPow.hPow (Ring.inverse (HSub.hSub 1 r)) 2))","decl":"/-- If `‚Äñr‚Äñ < 1`, then `‚àë' n : ‚Ñï, n * r ^ n = r / (1 - r) ^ 2`, version in a general ring with\nsummable geometric series. For a version in a field, using division instead of `Ring.inverse`,\nsee `tsum_coe_mul_geometric_of_norm_lt_one`. -/\ntheorem tsum_coe_mul_geometric_of_norm_lt_one'\n    {r : ùïú} (hr : ‚Äñr‚Äñ < 1) : (‚àë' n : ‚Ñï, n * r ^ n : ùïú) = r * Ring.inverse (1 - r) ^ 2 :=\n  (hasSum_coe_mul_geometric_of_norm_lt_one' hr).tsum_eq\n\n"}
{"name":"hasSum_coe_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"ùïú : Type u_3\ninst‚úù : NormedDivisionRing ùïú\nr : ùïú\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ HasSum (fun n => HMul.hMul (‚Üën) (HPow.hPow r n)) (HDiv.hDiv r (HPow.hPow (HSub.hSub 1 r) 2))","decl":"/-- If `‚Äñr‚Äñ < 1`, then `‚àë' n : ‚Ñï, n * r ^ n = r / (1 - r) ^ 2`, `HasSum` version. -/\ntheorem hasSum_coe_mul_geometric_of_norm_lt_one {r : ùïú} (hr : ‚Äñr‚Äñ < 1) :\n    HasSum (fun n ‚Ü¶ n * r ^ n : ‚Ñï ‚Üí ùïú) (r / (1 - r) ^ 2) := by\n  convert hasSum_coe_mul_geometric_of_norm_lt_one' hr using 1\n  simp [div_eq_mul_inv]\n\n"}
{"name":"tsum_coe_mul_geometric_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"ùïú : Type u_3\ninst‚úù : NormedDivisionRing ùïú\nr : ùïú\nhr : LT.lt (Norm.norm r) 1\n‚ä¢ Eq (tsum fun n => HMul.hMul (‚Üën) (HPow.hPow r n)) (HDiv.hDiv r (HPow.hPow (HSub.hSub 1 r) 2))","decl":"/-- If `‚Äñr‚Äñ < 1`, then `‚àë' n : ‚Ñï, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem tsum_coe_mul_geometric_of_norm_lt_one {r : ùïú} (hr : ‚Äñr‚Äñ < 1) :\n    (‚àë' n : ‚Ñï, n * r ^ n : ùïú) = r / (1 - r) ^ 2 :=\n  (hasSum_coe_mul_geometric_of_norm_lt_one hr).tsum_eq\n\n"}
{"name":"SeminormedAddCommGroup.cauchySeq_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nC r : Real\nhr : LT.lt r 1\nu : Nat ‚Üí Œ±\nh : ‚àÄ (n : Nat), LE.le (Norm.norm (HSub.hSub (u n) (u (HAdd.hAdd n 1)))) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq u","decl":"nonrec theorem SeminormedAddCommGroup.cauchySeq_of_le_geometric {C : ‚Ñù} {r : ‚Ñù} (hr : r < 1)\n    {u : ‚Ñï ‚Üí Œ±} (h : ‚àÄ n, ‚Äñu n - u (n + 1)‚Äñ ‚â§ C * r ^ n) : CauchySeq u :=\n  cauchySeq_of_le_geometric r C hr (by simpa [dist_eq_norm] using h)\n\n"}
{"name":"dist_partial_sum_le_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhf : ‚àÄ (n : Nat), LE.le (Norm.norm (f n)) (HMul.hMul C (HPow.hPow r n))\nn : Nat\n‚ä¢ LE.le (Dist.dist ((Finset.range n).sum fun i => f i) ((Finset.range (HAdd.hAdd n 1)).sum fun i => f i)) (HMul.hMul C (HPow.hPow r n))","decl":"theorem dist_partial_sum_le_of_le_geometric (hf : ‚àÄ n, ‚Äñf n‚Äñ ‚â§ C * r ^ n) (n : ‚Ñï) :\n    dist (‚àë i ‚àà range n, f i) (‚àë i ‚àà range (n + 1), f i) ‚â§ C * r ^ n := by\n  rw [sum_range_succ, dist_eq_norm, ‚Üê norm_neg, neg_sub, add_sub_cancel_left]\n  exact hf n\n\n"}
{"name":"cauchySeq_finset_of_geometric_bound","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhf : ‚àÄ (n : Nat), LE.le (Norm.norm (f n)) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq fun s => s.sum fun x => f x","decl":"/-- If `‚Äñf n‚Äñ ‚â§ C * r ^ n` for all `n : ‚Ñï` and some `r < 1`, then the partial sums of `f` form a\nCauchy sequence. This lemma does not assume `0 ‚â§ r` or `0 ‚â§ C`. -/\ntheorem cauchySeq_finset_of_geometric_bound (hr : r < 1) (hf : ‚àÄ n, ‚Äñf n‚Äñ ‚â§ C * r ^ n) :\n    CauchySeq fun s : Finset ‚Ñï ‚Ü¶ ‚àë x ‚àà s, f x :=\n  cauchySeq_finset_of_norm_bounded _\n    (aux_hasSum_of_le_geometric hr (dist_partial_sum_le_of_le_geometric hf)).summable hf\n\n"}
{"name":"norm_sub_le_of_geometric_bound_of_hasSum","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhf : ‚àÄ (n : Nat), LE.le (Norm.norm (f n)) (HMul.hMul C (HPow.hPow r n))\na : Œ±\nha : HasSum f a\nn : Nat\n‚ä¢ LE.le (Norm.norm (HSub.hSub ((Finset.range n).sum fun x => f x) a)) (HDiv.hDiv (HMul.hMul C (HPow.hPow r n)) (HSub.hSub 1 r))","decl":"/-- If `‚Äñf n‚Äñ ‚â§ C * r ^ n` for all `n : ‚Ñï` and some `r < 1`, then the partial sums of `f` are within\ndistance `C * r ^ n / (1 - r)` of the sum of the series. This lemma does not assume `0 ‚â§ r` or\n`0 ‚â§ C`. -/\ntheorem norm_sub_le_of_geometric_bound_of_hasSum (hr : r < 1) (hf : ‚àÄ n, ‚Äñf n‚Äñ ‚â§ C * r ^ n) {a : Œ±}\n    (ha : HasSum f a) (n : ‚Ñï) : ‚Äñ(‚àë x ‚àà Finset.range n, f x) - a‚Äñ ‚â§ C * r ^ n / (1 - r) := by\n  rw [‚Üê dist_eq_norm]\n  apply dist_le_of_le_geometric_of_tendsto r C hr (dist_partial_sum_le_of_le_geometric hf)\n  exact ha.tendsto_sum_nat\n\n"}
{"name":"dist_partial_sum","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nu : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Eq (Dist.dist ((Finset.range (HAdd.hAdd n 1)).sum fun k => u k) ((Finset.range n).sum fun k => u k)) (Norm.norm (u n))","decl":"@[simp]\ntheorem dist_partial_sum (u : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) :\n    dist (‚àë k ‚àà range (n + 1), u k) (‚àë k ‚àà range n, u k) = ‚Äñu n‚Äñ := by\n  simp [dist_eq_norm, sum_range_succ]\n\n"}
{"name":"dist_partial_sum'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nu : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Eq (Dist.dist ((Finset.range n).sum fun k => u k) ((Finset.range (HAdd.hAdd n 1)).sum fun k => u k)) (Norm.norm (u n))","decl":"@[simp]\ntheorem dist_partial_sum' (u : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) :\n    dist (‚àë k ‚àà range n, u k) (‚àë k ‚àà range (n + 1), u k) = ‚Äñu n‚Äñ := by\n  simp [dist_eq_norm', sum_range_succ]\n\n"}
{"name":"cauchy_series_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nC : Real\nu : Nat ‚Üí Œ±\nr : Real\nhr : LT.lt r 1\nh : ‚àÄ (n : Nat), LE.le (Norm.norm (u n)) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq fun n => (Finset.range n).sum fun k => u k","decl":"theorem cauchy_series_of_le_geometric {C : ‚Ñù} {u : ‚Ñï ‚Üí Œ±} {r : ‚Ñù} (hr : r < 1)\n    (h : ‚àÄ n, ‚Äñu n‚Äñ ‚â§ C * r ^ n) : CauchySeq fun n ‚Ü¶ ‚àë k ‚àà range n, u k :=\n  cauchySeq_of_le_geometric r C hr (by simp [h])\n\n"}
{"name":"NormedAddCommGroup.cauchy_series_of_le_geometric'","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nC : Real\nu : Nat ‚Üí Œ±\nr : Real\nhr : LT.lt r 1\nh : ‚àÄ (n : Nat), LE.le (Norm.norm (u n)) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => u k","decl":"theorem NormedAddCommGroup.cauchy_series_of_le_geometric' {C : ‚Ñù} {u : ‚Ñï ‚Üí Œ±} {r : ‚Ñù} (hr : r < 1)\n    (h : ‚àÄ n, ‚Äñu n‚Äñ ‚â§ C * r ^ n) : CauchySeq fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k :=\n  (cauchy_series_of_le_geometric hr h).comp_tendsto <| tendsto_add_atTop_nat 1\n\n"}
{"name":"NormedAddCommGroup.cauchy_series_of_le_geometric''","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nC : Real\nu : Nat ‚Üí Œ±\nN : Nat\nr : Real\nhr‚ÇÄ : LT.lt 0 r\nhr‚ÇÅ : LT.lt r 1\nh : ‚àÄ (n : Nat), GE.ge n N ‚Üí LE.le (Norm.norm (u n)) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq fun n => (Finset.range (HAdd.hAdd n 1)).sum fun k => u k","decl":"theorem NormedAddCommGroup.cauchy_series_of_le_geometric'' {C : ‚Ñù} {u : ‚Ñï ‚Üí Œ±} {N : ‚Ñï} {r : ‚Ñù}\n    (hr‚ÇÄ : 0 < r) (hr‚ÇÅ : r < 1) (h : ‚àÄ n ‚â• N, ‚Äñu n‚Äñ ‚â§ C * r ^ n) :\n    CauchySeq fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k := by\n  set v : ‚Ñï ‚Üí Œ± := fun n ‚Ü¶ if n < N then 0 else u n\n  have hC : 0 ‚â§ C :=\n    (mul_nonneg_iff_of_pos_right <| pow_pos hr‚ÇÄ N).mp ((norm_nonneg _).trans <| h N <| le_refl N)\n  have : ‚àÄ n ‚â• N, u n = v n := by\n    intro n hn\n    simp [v, hn, if_neg (not_lt.mpr hn)]\n  apply cauchySeq_sum_of_eventually_eq this\n    (NormedAddCommGroup.cauchy_series_of_le_geometric' hr‚ÇÅ _)\n  ¬∑ exact C\n  intro n\n  simp only [v]\n  split_ifs with H\n  ¬∑ rw [norm_zero]\n    exact mul_nonneg hC (pow_nonneg hr‚ÇÄ.le _)\n  ¬∑ push_neg at H\n    exact h _ H\n\n"}
{"name":"exists_norm_le_of_cauchySeq","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù : SeminormedAddCommGroup Œ±\nf : Nat ‚Üí Œ±\nh : CauchySeq fun n => (Finset.range n).sum fun k => f k\n‚ä¢ Exists fun C => ‚àÄ (n : Nat), LE.le (Norm.norm (f n)) C","decl":"/-- The term norms of any convergent series are bounded by a constant. -/\nlemma exists_norm_le_of_cauchySeq (h : CauchySeq fun n ‚Ü¶ ‚àë k ‚àà range n, f k) :\n    ‚àÉ C, ‚àÄ n, ‚Äñf n‚Äñ ‚â§ C := by\n  obtain ‚ü®b, ‚ü®_, key, _‚ü©‚ü© := cauchySeq_iff_le_tendsto_0.mp h\n  refine ‚ü®b 0, fun n ‚Ü¶ ?_‚ü©\n  simpa only [dist_partial_sum'] using key n (n + 1) 0 (_root_.zero_le _) (_root_.zero_le _)\n\n"}
{"name":"summable_of_ratio_norm_eventually_le","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup Œ±\ninst‚úù : CompleteSpace Œ±\nf : Nat ‚Üí Œ±\nr : Real\nhr‚ÇÅ : LT.lt r 1\nh : Filter.Eventually (fun n => LE.le (Norm.norm (f (HAdd.hAdd n 1))) (HMul.hMul r (Norm.norm (f n)))) Filter.atTop\n‚ä¢ Summable f","decl":"theorem summable_of_ratio_norm_eventually_le {Œ± : Type*} [SeminormedAddCommGroup Œ±]\n    [CompleteSpace Œ±] {f : ‚Ñï ‚Üí Œ±} {r : ‚Ñù} (hr‚ÇÅ : r < 1)\n    (h : ‚àÄ·∂† n in atTop, ‚Äñf (n + 1)‚Äñ ‚â§ r * ‚Äñf n‚Äñ) : Summable f := by\n  by_cases hr‚ÇÄ : 0 ‚â§ r\n  ¬∑ rw [eventually_atTop] at h\n    rcases h with ‚ü®N, hN‚ü©\n    rw [‚Üê @summable_nat_add_iff Œ± _ _ _ _ N]\n    refine .of_norm_bounded (fun n ‚Ü¶ ‚Äñf N‚Äñ * r ^ n)\n      (Summable.mul_left _ <| summable_geometric_of_lt_one hr‚ÇÄ hr‚ÇÅ) fun n ‚Ü¶ ?_\n    simp only\n    conv_rhs => rw [mul_comm, ‚Üê zero_add N]\n    refine le_geom (u := fun n ‚Ü¶ ‚Äñf (n + N)‚Äñ) hr‚ÇÄ n fun i _ ‚Ü¶ ?_\n    convert hN (i + N) (N.le_add_left i) using 3\n    ac_rfl\n  ¬∑ push_neg at hr‚ÇÄ\n    refine .of_norm_bounded_eventually_nat 0 summable_zero ?_\n    filter_upwards [h] with _ hn\n    by_contra! h\n    exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn <| mul_neg_of_neg_of_pos hr‚ÇÄ h)\n\n"}
{"name":"summable_of_ratio_test_tendsto_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : NormedAddCommGroup Œ±\ninst‚úù : CompleteSpace Œ±\nf : Nat ‚Üí Œ±\nl : Real\nhl‚ÇÅ : LT.lt l 1\nhf : Filter.Eventually (fun n => Ne (f n) 0) Filter.atTop\nh : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (f (HAdd.hAdd n 1))) (Norm.norm (f n))) Filter.atTop (nhds l)\n‚ä¢ Summable f","decl":"theorem summable_of_ratio_test_tendsto_lt_one {Œ± : Type*} [NormedAddCommGroup Œ±] [CompleteSpace Œ±]\n    {f : ‚Ñï ‚Üí Œ±} {l : ‚Ñù} (hl‚ÇÅ : l < 1) (hf : ‚àÄ·∂† n in atTop, f n ‚â† 0)\n    (h : Tendsto (fun n ‚Ü¶ ‚Äñf (n + 1)‚Äñ / ‚Äñf n‚Äñ) atTop (ùìù l)) : Summable f := by\n  rcases exists_between hl‚ÇÅ with ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü©\n  refine summable_of_ratio_norm_eventually_le hr‚ÇÅ ?_\n  filter_upwards [h.eventually_le_const hr‚ÇÄ, hf] with _ _ h‚ÇÅ\n  rwa [‚Üê div_le_iff‚ÇÄ (norm_pos_iff.mpr h‚ÇÅ)]\n\n"}
{"name":"not_summable_of_ratio_norm_eventually_ge","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedAddCommGroup Œ±\nf : Nat ‚Üí Œ±\nr : Real\nhr : LT.lt 1 r\nhf : Filter.Frequently (fun n => Ne (Norm.norm (f n)) 0) Filter.atTop\nh : Filter.Eventually (fun n => LE.le (HMul.hMul r (Norm.norm (f n))) (Norm.norm (f (HAdd.hAdd n 1)))) Filter.atTop\n‚ä¢ Not (Summable f)","decl":"theorem not_summable_of_ratio_norm_eventually_ge {Œ± : Type*} [SeminormedAddCommGroup Œ±] {f : ‚Ñï ‚Üí Œ±}\n    {r : ‚Ñù} (hr : 1 < r) (hf : ‚àÉ·∂† n in atTop, ‚Äñf n‚Äñ ‚â† 0)\n    (h : ‚àÄ·∂† n in atTop, r * ‚Äñf n‚Äñ ‚â§ ‚Äñf (n + 1)‚Äñ) : ¬¨Summable f := by\n  rw [eventually_atTop] at h\n  rcases h with ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü©\n  rw [frequently_atTop] at hf\n  rcases hf N‚ÇÄ with ‚ü®N, hNN‚ÇÄ : N‚ÇÄ ‚â§ N, hN‚ü©\n  rw [‚Üê @summable_nat_add_iff Œ± _ _ _ _ N]\n  refine mt Summable.tendsto_atTop_zero\n    fun h' ‚Ü¶ not_tendsto_atTop_of_tendsto_nhds (tendsto_norm_zero.comp h') ?_\n  convert tendsto_atTop_of_geom_le _ hr _\n  ¬∑ refine lt_of_le_of_ne (norm_nonneg _) ?_\n    intro h''\n    specialize hN‚ÇÄ N hNN‚ÇÄ\n    simp only [comp_apply, zero_add] at h''\n    exact hN h''.symm\n  ¬∑ intro i\n    dsimp only [comp_apply]\n    convert hN‚ÇÄ (i + N) (hNN‚ÇÄ.trans (N.le_add_left i)) using 3\n    ac_rfl\n\n"}
{"name":"not_summable_of_ratio_test_tendsto_gt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedAddCommGroup Œ±\nf : Nat ‚Üí Œ±\nl : Real\nhl : LT.lt 1 l\nh : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (f (HAdd.hAdd n 1))) (Norm.norm (f n))) Filter.atTop (nhds l)\n‚ä¢ Not (Summable f)","decl":"theorem not_summable_of_ratio_test_tendsto_gt_one {Œ± : Type*} [SeminormedAddCommGroup Œ±]\n    {f : ‚Ñï ‚Üí Œ±} {l : ‚Ñù} (hl : 1 < l) (h : Tendsto (fun n ‚Ü¶ ‚Äñf (n + 1)‚Äñ / ‚Äñf n‚Äñ) atTop (ùìù l)) :\n    ¬¨Summable f := by\n  have key : ‚àÄ·∂† n in atTop, ‚Äñf n‚Äñ ‚â† 0 := by\n    filter_upwards [h.eventually_const_le hl] with _ hn hc\n    rw [hc, _root_.div_zero] at hn\n    linarith\n  rcases exists_between hl with ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü©\n  refine not_summable_of_ratio_norm_eventually_ge hr‚ÇÄ key.frequently ?_\n  filter_upwards [h.eventually_const_le hr‚ÇÅ, key] with _ _ h‚ÇÅ\n  rwa [‚Üê le_div_iff‚ÇÄ (lt_of_le_of_ne (norm_nonneg _) h‚ÇÅ.symm)]\n\n"}
{"name":"summable_powerSeries_of_norm_lt","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : NormedDivisionRing Œ±\ninst‚úù : CompleteSpace Œ±\nf : Nat ‚Üí Œ±\nw z : Œ±\nh : CauchySeq fun n => (Finset.range n).sum fun i => HMul.hMul (f i) (HPow.hPow w i)\nhz : LT.lt (Norm.norm z) (Norm.norm w)\n‚ä¢ Summable fun n => HMul.hMul (f n) (HPow.hPow z n)","decl":"/-- If a power series converges at `w`, it converges absolutely at all `z` of smaller norm. -/\ntheorem summable_powerSeries_of_norm_lt {w z : Œ±}\n    (h : CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, f i * w ^ i) (hz : ‚Äñz‚Äñ < ‚Äñw‚Äñ) :\n    Summable fun n ‚Ü¶ f n * z ^ n := by\n  have hw : 0 < ‚Äñw‚Äñ := (norm_nonneg z).trans_lt hz\n  obtain ‚ü®C, hC‚ü© := exists_norm_le_of_cauchySeq h\n  rw [summable_iff_cauchySeq_finset]\n  refine cauchySeq_finset_of_geometric_bound (r := ‚Äñz‚Äñ / ‚Äñw‚Äñ) (C := C) ((div_lt_one hw).mpr hz)\n    (fun n ‚Ü¶ ?_)\n  rw [norm_mul, norm_pow, div_pow, ‚Üê mul_comm_div]\n  conv at hC => enter [n]; rw [norm_mul, norm_pow, ‚Üê _root_.le_div_iff‚ÇÄ (by positivity)]\n  exact mul_le_mul_of_nonneg_right (hC n) (pow_nonneg (norm_nonneg z) n)\n\n"}
{"name":"summable_powerSeries_of_norm_lt_one","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : NormedDivisionRing Œ±\ninst‚úù : CompleteSpace Œ±\nf : Nat ‚Üí Œ±\nz : Œ±\nh : CauchySeq fun n => (Finset.range n).sum fun i => f i\nhz : LT.lt (Norm.norm z) 1\n‚ä¢ Summable fun n => HMul.hMul (f n) (HPow.hPow z n)","decl":"/-- If a power series converges at 1, it converges absolutely at all `z` of smaller norm. -/\ntheorem summable_powerSeries_of_norm_lt_one {z : Œ±}\n    (h : CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, f i) (hz : ‚Äñz‚Äñ < 1) :\n    Summable fun n ‚Ü¶ f n * z ^ n :=\n  summable_powerSeries_of_norm_lt (w := 1) (by simp [h]) (by simp [hz])\n\n"}
{"name":"Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nb : Real\nf : Nat ‚Üí Real\nz : Nat ‚Üí E\nhfa : Monotone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\nhgb : ‚àÄ (n : Nat), LE.le (Norm.norm ((Finset.range n).sum fun i => z i)) b\n‚ä¢ CauchySeq fun n => (Finset.range n).sum fun i => HSMul.hSMul (f i) (z i)","decl":"/-- **Dirichlet's test** for monotone sequences. -/\ntheorem Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) (hgb : ‚àÄ n, ‚Äñ‚àë i ‚àà range n, z i‚Äñ ‚â§ b) :\n    CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, f i ‚Ä¢ z i := by\n  rw [‚Üê cauchySeq_shift 1]\n  simp_rw [Finset.sum_range_by_parts _ _ (Nat.succ _), sub_eq_add_neg, Nat.succ_sub_succ_eq_sub,\n    tsub_zero]\n  apply (NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded hf0\n    ‚ü®b, eventually_map.mpr <| Eventually.of_forall fun n ‚Ü¶ hgb <| n + 1‚ü©).cauchySeq.add\n  refine CauchySeq.neg ?_\n  refine cauchySeq_range_of_norm_bounded _ ?_\n    (fun n ‚Ü¶ ?_ : ‚àÄ n, ‚Äñ(f (n + 1) + -f n) ‚Ä¢ (Finset.range (n + 1)).sum z‚Äñ ‚â§ b * |f (n + 1) - f n|)\n  ¬∑ simp_rw [abs_of_nonneg (sub_nonneg_of_le (hfa (Nat.le_succ _))), ‚Üê mul_sum]\n    apply Real.uniformContinuous_const_mul.comp_cauchySeq\n    simp_rw [sum_range_sub, sub_eq_add_neg]\n    exact (Tendsto.cauchySeq hf0).add_const\n  ¬∑ rw [norm_smul, mul_comm]\n    exact mul_le_mul_of_nonneg_right (hgb _) (abs_nonneg _)\n\n"}
{"name":"Antitone.cauchySeq_series_mul_of_tendsto_zero_of_bounded","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nb : Real\nf : Nat ‚Üí Real\nz : Nat ‚Üí E\nhfa : Antitone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\nhzb : ‚àÄ (n : Nat), LE.le (Norm.norm ((Finset.range n).sum fun i => z i)) b\n‚ä¢ CauchySeq fun n => (Finset.range n).sum fun i => HSMul.hSMul (f i) (z i)","decl":"/-- **Dirichlet's test** for antitone sequences. -/\ntheorem Antitone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) (hzb : ‚àÄ n, ‚Äñ‚àë i ‚àà range n, z i‚Äñ ‚â§ b) :\n    CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, f i ‚Ä¢ z i := by\n  have hfa' : Monotone fun n ‚Ü¶ -f n := fun _ _ hab ‚Ü¶ neg_le_neg <| hfa hab\n  have hf0' : Tendsto (fun n ‚Ü¶ -f n) atTop (ùìù 0) := by\n    convert hf0.neg\n    norm_num\n  convert (hfa'.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0' hzb).neg\n  simp\n\n"}
{"name":"norm_sum_neg_one_pow_le","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"n : Nat\n‚ä¢ LE.le (Norm.norm ((Finset.range n).sum fun i => HPow.hPow (-1) i)) 1","decl":"theorem norm_sum_neg_one_pow_le (n : ‚Ñï) : ‚Äñ‚àë i ‚àà range n, (-1 : ‚Ñù) ^ i‚Äñ ‚â§ 1 := by\n  rw [neg_one_geom_sum]\n  split_ifs <;> norm_num\n\n"}
{"name":"Monotone.cauchySeq_alternating_series_of_tendsto_zero","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"f : Nat ‚Üí Real\nhfa : Monotone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\n‚ä¢ CauchySeq fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)","decl":"/-- The **alternating series test** for monotone sequences.\nSee also `Monotone.tendsto_alternating_series_of_tendsto_zero`. -/\ntheorem Monotone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) : CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i := by\n  simp_rw [mul_comm]\n  exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le\n\n"}
{"name":"Monotone.tendsto_alternating_series_of_tendsto_zero","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"f : Nat ‚Üí Real\nhfa : Monotone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\n‚ä¢ Exists fun l => Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)","decl":"/-- The **alternating series test** for monotone sequences. -/\ntheorem Monotone.tendsto_alternating_series_of_tendsto_zero (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) :\n    ‚àÉ l, Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l) :=\n  cauchySeq_tendsto_of_complete <| hfa.cauchySeq_alternating_series_of_tendsto_zero hf0\n\n"}
{"name":"Antitone.cauchySeq_alternating_series_of_tendsto_zero","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"f : Nat ‚Üí Real\nhfa : Antitone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\n‚ä¢ CauchySeq fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)","decl":"/-- The **alternating series test** for antitone sequences.\nSee also `Antitone.tendsto_alternating_series_of_tendsto_zero`. -/\ntheorem Antitone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) : CauchySeq fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i := by\n  simp_rw [mul_comm]\n  exact hfa.cauchySeq_series_mul_of_tendsto_zero_of_bounded hf0 norm_sum_neg_one_pow_le\n\n"}
{"name":"Antitone.tendsto_alternating_series_of_tendsto_zero","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"f : Nat ‚Üí Real\nhfa : Antitone f\nhf0 : Filter.Tendsto f Filter.atTop (nhds 0)\n‚ä¢ Exists fun l => Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)","decl":"/-- The **alternating series test** for antitone sequences. -/\ntheorem Antitone.tendsto_alternating_series_of_tendsto_zero (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (ùìù 0)) :\n    ‚àÉ l, Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l) :=\n  cauchySeq_tendsto_of_complete <| hfa.cauchySeq_alternating_series_of_tendsto_zero hf0\n\n"}
{"name":"Monotone.tendsto_le_alternating_series","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬≤ : OrderedRing E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : OrderClosedTopology E\nl : E\nf : Nat ‚Üí E\nhfl : Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)\nhfm : Monotone f\nk : Nat\n‚ä¢ LE.le l ((Finset.range (HMul.hMul 2 k)).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i))","decl":"/-- Partial sums of an alternating monotone series with an even number of terms provide\nupper bounds on the limit. -/\ntheorem Monotone.tendsto_le_alternating_series\n    (hfl : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l))\n    (hfm : Monotone f) (k : ‚Ñï) : l ‚â§ ‚àë i ‚àà range (2 * k), (-1) ^ i * f i := by\n  have ha : Antitone (fun n ‚Ü¶ ‚àë i ‚àà range (2 * n), (-1) ^ i * f i) := by\n    refine antitone_nat_of_succ_le (fun n ‚Ü¶ ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring, sum_range_succ, sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      ‚Üê sub_eq_add_neg, sub_le_iff_le_add]\n    gcongr\n    exact hfm (by omega)\n  exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n ‚Ü¶ by dsimp; omega) tendsto_id)) _\n\n"}
{"name":"Monotone.alternating_series_le_tendsto","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬≤ : OrderedRing E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : OrderClosedTopology E\nl : E\nf : Nat ‚Üí E\nhfl : Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)\nhfm : Monotone f\nk : Nat\n‚ä¢ LE.le ((Finset.range (HAdd.hAdd (HMul.hMul 2 k) 1)).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) l","decl":"/-- Partial sums of an alternating monotone series with an odd number of terms provide\nlower bounds on the limit. -/\ntheorem Monotone.alternating_series_le_tendsto\n    (hfl : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l))\n    (hfm : Monotone f) (k : ‚Ñï) : ‚àë i ‚àà range (2 * k + 1), (-1) ^ i * f i ‚â§ l := by\n  have hm : Monotone (fun n ‚Ü¶ ‚àë i ‚àà range (2 * n + 1), (-1) ^ i * f i) := by\n    refine monotone_nat_of_le_succ (fun n ‚Ü¶ ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring,\n      sum_range_succ _ (2 * n + 1 + 1), sum_range_succ _ (2 * n + 1)]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      ‚Üê sub_eq_add_neg, sub_add_eq_add_sub, le_sub_iff_add_le]\n    gcongr\n    exact hfm (by omega)\n  exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n ‚Ü¶ by dsimp; omega) tendsto_id)) _\n\n"}
{"name":"Antitone.alternating_series_le_tendsto","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬≤ : OrderedRing E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : OrderClosedTopology E\nl : E\nf : Nat ‚Üí E\nhfl : Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)\nhfa : Antitone f\nk : Nat\n‚ä¢ LE.le ((Finset.range (HMul.hMul 2 k)).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) l","decl":"/-- Partial sums of an alternating antitone series with an even number of terms provide\nlower bounds on the limit. -/\ntheorem Antitone.alternating_series_le_tendsto\n    (hfl : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l))\n    (hfa : Antitone f) (k : ‚Ñï) : ‚àë i ‚àà range (2 * k), (-1) ^ i * f i ‚â§ l := by\n  have hm : Monotone (fun n ‚Ü¶ ‚àë i ‚àà range (2 * n), (-1) ^ i * f i) := by\n    refine monotone_nat_of_le_succ (fun n ‚Ü¶ ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring, sum_range_succ, sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      ‚Üê sub_eq_add_neg, le_sub_iff_add_le]\n    gcongr\n    exact hfa (by omega)\n  exact hm.ge_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n ‚Ü¶ by dsimp; omega) tendsto_id)) _\n\n"}
{"name":"Antitone.tendsto_le_alternating_series","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"E : Type u_2\ninst‚úù¬≤ : OrderedRing E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : OrderClosedTopology E\nl : E\nf : Nat ‚Üí E\nhfl : Filter.Tendsto (fun n => (Finset.range n).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i)) Filter.atTop (nhds l)\nhfa : Antitone f\nk : Nat\n‚ä¢ LE.le l ((Finset.range (HAdd.hAdd (HMul.hMul 2 k) 1)).sum fun i => HMul.hMul (HPow.hPow (-1) i) (f i))","decl":"/-- Partial sums of an alternating antitone series with an odd number of terms provide\nupper bounds on the limit. -/\ntheorem Antitone.tendsto_le_alternating_series\n    (hfl : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, (-1) ^ i * f i) atTop (ùìù l))\n    (hfa : Antitone f) (k : ‚Ñï) : l ‚â§ ‚àë i ‚àà range (2 * k + 1), (-1) ^ i * f i := by\n  have ha : Antitone (fun n ‚Ü¶ ‚àë i ‚àà range (2 * n + 1), (-1) ^ i * f i) := by\n    refine antitone_nat_of_succ_le (fun n ‚Ü¶ ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring, sum_range_succ, sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      ‚Üê sub_eq_add_neg, sub_add_eq_add_sub, sub_le_iff_le_add]\n    gcongr\n    exact hfa (by omega)\n  exact ha.le_of_tendsto (hfl.comp (tendsto_atTop_mono (fun n ‚Ü¶ by dsimp; omega) tendsto_id)) _\n\n"}
{"name":"Real.summable_pow_div_factorial","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"x : Real\n‚ä¢ Summable fun n => HDiv.hDiv (HPow.hPow x n) ‚Üën.factorial","decl":"/-- The series `‚àë' n, x ^ n / n!` is summable of any `x : ‚Ñù`. See also `expSeries_div_summable`\nfor a version that also works in `‚ÑÇ`, and `NormedSpace.expSeries_summable'` for a version\nthat works in any normed algebra over `‚Ñù` or `‚ÑÇ`. -/\ntheorem Real.summable_pow_div_factorial (x : ‚Ñù) : Summable (fun n ‚Ü¶ x ^ n / n ! : ‚Ñï ‚Üí ‚Ñù) := by\n  -- We start with trivial estimates\n  have A : (0 : ‚Ñù) < ‚åä‚Äñx‚Äñ‚åã‚Çä + 1 := zero_lt_one.trans_le (by simp)\n  have B : ‚Äñx‚Äñ / (‚åä‚Äñx‚Äñ‚åã‚Çä + 1) < 1 := (div_lt_one A).2 (Nat.lt_floor_add_one _)\n  -- Then we apply the ratio test. The estimate works for `n ‚â• ‚åä‚Äñx‚Äñ‚åã‚Çä`.\n  suffices ‚àÄ n ‚â• ‚åä‚Äñx‚Äñ‚åã‚Çä, ‚Äñx ^ (n + 1) / (n + 1)!‚Äñ ‚â§ ‚Äñx‚Äñ / (‚åä‚Äñx‚Äñ‚åã‚Çä + 1) * ‚Äñx ^ n / ‚Üën !‚Äñ from\n    summable_of_ratio_norm_eventually_le B (eventually_atTop.2 ‚ü®‚åä‚Äñx‚Äñ‚åã‚Çä, this‚ü©)\n  -- Finally, we prove the upper estimate\n  intro n hn\n  calc\n    ‚Äñx ^ (n + 1) / (n + 1)!‚Äñ = ‚Äñx‚Äñ / (n + 1) * ‚Äñx ^ n / (n !)‚Äñ := by\n      rw [_root_.pow_succ', Nat.factorial_succ, Nat.cast_mul, ‚Üê _root_.div_mul_div_comm, norm_mul,\n        norm_div, Real.norm_natCast, Nat.cast_succ]\n    _ ‚â§ ‚Äñx‚Äñ / (‚åä‚Äñx‚Äñ‚åã‚Çä + 1) * ‚Äñx ^ n / (n !)‚Äñ := by gcongr\n\n"}
{"name":"Real.tendsto_pow_div_factorial_atTop","module":"Mathlib.Analysis.SpecificLimits.Normed","initialProofState":"x : Real\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (HPow.hPow x n) ‚Üën.factorial) Filter.atTop (nhds 0)","decl":"@[deprecated \"`Real.tendsto_pow_div_factorial_atTop` has been deprecated, use\n`FloorSemiring.tendsto_pow_div_factorial_atTop` instead\" (since := \"2024-10-05\")]\ntheorem Real.tendsto_pow_div_factorial_atTop (x : ‚Ñù) :\n    Tendsto (fun n ‚Ü¶ x ^ n / n ! : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) :=\n  (Real.summable_pow_div_factorial x).tendsto_atTop_zero\n"}
