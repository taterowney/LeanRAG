{"name":"CategoryTheory.Functor.Iteration.restrictionLT_obj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\nk : J\nhk : LT.lt k i\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.restrictionLT F hi).obj ‚ü®k, hk‚ü©) (F.obj ‚ü®k, ‚ãØ‚ü©)","decl":"@[simp]\nlemma restrictionLT_obj (k : J) (hk : k < i) :\n    (restrictionLT F hi).obj ‚ü®k, hk‚ü© = F.obj ‚ü®k, hk.le.trans hi‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.restrictionLT_map","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\nk‚ÇÅ k‚ÇÇ : ‚Üë(Set.Iio i)\nœÜ : Quiver.Hom k‚ÇÅ k‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.restrictionLT F hi).map œÜ) (F.map (CategoryTheory.homOfLE ‚ãØ))","decl":"@[simp]\nlemma restrictionLT_map {k‚ÇÅ k‚ÇÇ : Set.Iio i} (œÜ : k‚ÇÅ ‚ü∂ k‚ÇÇ) :\n    (restrictionLT F hi).map œÜ = F.map (homOfLE (by simpa using leOfHom œÜ)) := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.coconeOfLE_Œπ_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\nx‚úù : ‚Üë(Set.Iio i)\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.coconeOfLE F hi).Œπ.app x‚úù) (CategoryTheory.Functor.Iteration.coconeOfLE.match_1 (fun x => Quiver.Hom ((CategoryTheory.Functor.Iteration.restrictionLT F hi).obj x) (((CategoryTheory.Functor.const ‚Üë(Set.Iio i)).obj (F.obj ‚ü®i, hi‚ü©)).obj x)) x‚úù fun k hk => F.map (CategoryTheory.homOfLE ‚ãØ))","decl":"/-- Given `F : Set.Iic j ‚•§ C`, `i : J` such that `hi : i ‚â§ j`, this is the\ncocone consisting of all maps `F.obj ‚ü®k, hk‚ü© ‚ü∂ F.obj ‚ü®i, hi‚ü©` for `k : J` such that `k < i`. -/\n@[simps]\ndef coconeOfLE : Cocone (restrictionLT F hi) where\n  pt := F.obj ‚ü®i, hi‚ü©\n  Œπ :=\n    { app := fun ‚ü®k, hk‚ü© => F.map (homOfLE (by simpa using hk.le))\n      naturality := fun ‚ü®k‚ÇÅ, hk‚ÇÅ‚ü© ‚ü®k‚ÇÇ, hk‚ÇÇ‚ü© _ => by\n        simp [comp_id, ‚Üê Functor.map_comp, homOfLE_comp] }\n\n"}
{"name":"CategoryTheory.Functor.Iteration.coconeOfLE_pt","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.coconeOfLE F hi).pt (F.obj ‚ü®i, hi‚ü©)","decl":"/-- Given `F : Set.Iic j ‚•§ C`, `i : J` such that `hi : i ‚â§ j`, this is the\ncocone consisting of all maps `F.obj ‚ü®k, hk‚ü© ‚ü∂ F.obj ‚ü®i, hi‚ü©` for `k : J` such that `k < i`. -/\n@[simps]\ndef coconeOfLE : Cocone (restrictionLT F hi) where\n  pt := F.obj ‚ü®i, hi‚ü©\n  Œπ :=\n    { app := fun ‚ü®k, hk‚ü© => F.map (homOfLE (by simpa using hk.le))\n      naturality := fun ‚ü®k‚ÇÅ, hk‚ÇÅ‚ü© ‚ü®k‚ÇÇ, hk‚ÇÇ‚ü© _ => by\n        simp [comp_id, ‚Üê Functor.map_comp, homOfLE_comp] }\n\n"}
{"name":"CategoryTheory.Functor.Iteration.restrictionLE_obj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\nk : J\nhk : LE.le k i\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.restrictionLE F hi).obj ‚ü®k, hk‚ü©) (F.obj ‚ü®k, ‚ãØ‚ü©)","decl":"@[simp]\nlemma restrictionLE_obj (k : J) (hk : k ‚â§ i) :\n    (restrictionLE F hi).obj ‚ü®k, hk‚ü© = F.obj ‚ü®k, hk.trans hi‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.restrictionLE_map","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nJ : Type u\ninst‚úù : Preorder J\nj : J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) C\ni : J\nhi : LE.le i j\nk‚ÇÅ k‚ÇÇ : ‚Üë(Set.Iic i)\nœÜ : Quiver.Hom k‚ÇÅ k‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.restrictionLE F hi).map œÜ) (F.map (CategoryTheory.homOfLE ‚ãØ))","decl":"@[simp]\nlemma restrictionLE_map {k‚ÇÅ k‚ÇÇ : Set.Iic i} (œÜ : k‚ÇÅ ‚ü∂ k‚ÇÇ) :\n    (restrictionLE F hi).map œÜ = F.map (homOfLE (by simpa using leOfHom œÜ)) := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\nj : J\nF‚úù : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nisoZero‚úù : CategoryTheory.Iso (F‚úù.obj ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.Functor.id C)\nisoSucc‚úù : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí CategoryTheory.Iso (F‚úù.obj ‚ü®Order.succ i, ‚ãØ‚ü©) ((F‚úù.obj ‚ü®i, ‚ãØ‚ü©).comp Œ¶)\nmapSucc'_eq‚úù : ‚àÄ (i : J) (hi : LT.lt i j), Eq (CategoryTheory.Functor.Iteration.mapSucc' F‚úù i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (F‚úù.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (isoSucc‚úù i hi).inv)\nisColimit‚úù : (i : J) ‚Üí Order.IsSuccLimit i ‚Üí (hij : LE.le i j) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Functor.Iteration.coconeOfLE F‚úù hij)\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nisoZero : CategoryTheory.Iso (F.obj ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.Functor.id C)\nisoSucc : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí CategoryTheory.Iso (F.obj ‚ü®Order.succ i, ‚ãØ‚ü©) ((F.obj ‚ü®i, ‚ãØ‚ü©).comp Œ¶)\nmapSucc'_eq : ‚àÄ (i : J) (hi : LT.lt i j), Eq (CategoryTheory.Functor.Iteration.mapSucc' F i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (F.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (isoSucc i hi).inv)\nisColimit : (i : J) ‚Üí Order.IsSuccLimit i ‚Üí (hij : LE.le i j) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Functor.Iteration.coconeOfLE F hij)\n‚ä¢ Eq (Eq { F := F‚úù, isoZero := isoZero‚úù, isoSucc := isoSucc‚úù, mapSucc'_eq := mapSucc'_eq‚úù, isColimit := isColimit‚úù } { F := F, isoZero := isoZero, isoSucc := isoSucc, mapSucc'_eq := mapSucc'_eq, isColimit := isColimit }) (And (Eq F‚úù F) (And (HEq isoZero‚úù isoZero) (And (HEq isoSucc‚úù isoSucc) (HEq isColimit‚úù isColimit))))","decl":"/-- The category of `j`th iterations of a functor `Œ¶` equipped with a natural\ntransformation `Œµ : ùü≠ C ‚ü∂ Œ¶`. An object consists of the data of all iterations\nof `Œ¶` for `i : J` such that `i ‚â§ j` (this is the field `F`). Such objects are\nequipped with data and properties which characterizes the iterations up to a unique\nisomorphism for the three types of elements: `‚ä•`, successors, limit elements. -/\nstructure Iteration [Preorder J] [OrderBot J] [SuccOrder J] (j : J) where\n  /-- The data of all `i`th iterations for `i : J` such that `i ‚â§ j`. -/\n  F : Set.Iic j ‚•§ C ‚•§ C\n  /-- The zeroth iteration is the identity functor. -/\n  isoZero : F.obj ‚ü®‚ä•, bot_le‚ü© ‚âÖ ùü≠ C\n  /-- The iteration on a successor element is obtained by composition of\n  the previous iteration with `Œ¶`. -/\n  isoSucc (i : J) (hi : i < j) : F.obj ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© ‚âÖ F.obj ‚ü®i, hi.le‚ü© ‚ãô Œ¶\n  /-- The natural map from an iteration to its successor is induced by `Œµ`. -/\n  mapSucc'_eq (i : J) (hi : i < j) :\n    Iteration.mapSucc' F i hi = whiskerLeft _ Œµ ‚â´ (isoSucc i hi).inv\n  /-- If `i` is a limit element, the `i`th iteration is the colimit\n  of `k`th iterations for `k < i`. -/\n  isColimit (i : J) (hi : Order.IsSuccLimit i) (hij : i ‚â§ j) :\n    IsColimit (Iteration.coconeOfLE F hij)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\nj : J\nF‚úù : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nisoZero‚úù : CategoryTheory.Iso (F‚úù.obj ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.Functor.id C)\nisoSucc‚úù : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí CategoryTheory.Iso (F‚úù.obj ‚ü®Order.succ i, ‚ãØ‚ü©) ((F‚úù.obj ‚ü®i, ‚ãØ‚ü©).comp Œ¶)\nmapSucc'_eq‚úù : ‚àÄ (i : J) (hi : LT.lt i j), Eq (CategoryTheory.Functor.Iteration.mapSucc' F‚úù i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (F‚úù.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (isoSucc‚úù i hi).inv)\nisColimit‚úù : (i : J) ‚Üí Order.IsSuccLimit i ‚Üí (hij : LE.le i j) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Functor.Iteration.coconeOfLE F‚úù hij)\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nisoZero : CategoryTheory.Iso (F.obj ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.Functor.id C)\nisoSucc : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí CategoryTheory.Iso (F.obj ‚ü®Order.succ i, ‚ãØ‚ü©) ((F.obj ‚ü®i, ‚ãØ‚ü©).comp Œ¶)\nmapSucc'_eq : ‚àÄ (i : J) (hi : LT.lt i j), Eq (CategoryTheory.Functor.Iteration.mapSucc' F i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (F.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (isoSucc i hi).inv)\nisColimit : (i : J) ‚Üí Order.IsSuccLimit i ‚Üí (hij : LE.le i j) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Functor.Iteration.coconeOfLE F hij)\nx‚úù : Eq { F := F‚úù, isoZero := isoZero‚úù, isoSucc := isoSucc‚úù, mapSucc'_eq := mapSucc'_eq‚úù, isColimit := isColimit‚úù } { F := F, isoZero := isoZero, isoSucc := isoSucc, mapSucc'_eq := mapSucc'_eq, isColimit := isColimit }\n‚ä¢ And (Eq F‚úù F) (And (HEq isoZero‚úù isoZero) (And (HEq isoSucc‚úù isoSucc) (HEq isColimit‚úù isColimit)))","decl":"/-- The category of `j`th iterations of a functor `Œ¶` equipped with a natural\ntransformation `Œµ : ùü≠ C ‚ü∂ Œ¶`. An object consists of the data of all iterations\nof `Œ¶` for `i : J` such that `i ‚â§ j` (this is the field `F`). Such objects are\nequipped with data and properties which characterizes the iterations up to a unique\nisomorphism for the three types of elements: `‚ä•`, successors, limit elements. -/\nstructure Iteration [Preorder J] [OrderBot J] [SuccOrder J] (j : J) where\n  /-- The data of all `i`th iterations for `i : J` such that `i ‚â§ j`. -/\n  F : Set.Iic j ‚•§ C ‚•§ C\n  /-- The zeroth iteration is the identity functor. -/\n  isoZero : F.obj ‚ü®‚ä•, bot_le‚ü© ‚âÖ ùü≠ C\n  /-- The iteration on a successor element is obtained by composition of\n  the previous iteration with `Œ¶`. -/\n  isoSucc (i : J) (hi : i < j) : F.obj ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© ‚âÖ F.obj ‚ü®i, hi.le‚ü© ‚ãô Œ¶\n  /-- The natural map from an iteration to its successor is induced by `Œµ`. -/\n  mapSucc'_eq (i : J) (hi : i < j) :\n    Iteration.mapSucc' F i hi = whiskerLeft _ Œµ ‚â´ (isoSucc i hi).inv\n  /-- If `i` is a limit element, the `i`th iteration is the colimit\n  of `k`th iterations for `k < i`. -/\n  isColimit (i : J) (hi : Order.IsSuccLimit i) (hij : i ‚â§ j) :\n    IsColimit (Iteration.coconeOfLE F hij)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù‚Å¥ : Preorder J\ninst‚úù¬≥ : OrderBot J\ninst‚úù¬≤ : SuccOrder J\nj : J\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf J\nF : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nisoZero : CategoryTheory.Iso (F.obj ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.Functor.id C)\nisoSucc : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí CategoryTheory.Iso (F.obj ‚ü®Order.succ i, ‚ãØ‚ü©) ((F.obj ‚ü®i, ‚ãØ‚ü©).comp Œ¶)\nmapSucc'_eq : ‚àÄ (i : J) (hi : LT.lt i j), Eq (CategoryTheory.Functor.Iteration.mapSucc' F i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (F.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (isoSucc i hi).inv)\nisColimit : (i : J) ‚Üí Order.IsSuccLimit i ‚Üí (hij : LE.le i j) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Functor.Iteration.coconeOfLE F hij)\n‚ä¢ Eq (SizeOf.sizeOf { F := F, isoZero := isoZero, isoSucc := isoSucc, mapSucc'_eq := mapSucc'_eq, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf F)) (SizeOf.sizeOf isoZero))","decl":"/-- The category of `j`th iterations of a functor `Œ¶` equipped with a natural\ntransformation `Œµ : ùü≠ C ‚ü∂ Œ¶`. An object consists of the data of all iterations\nof `Œ¶` for `i : J` such that `i ‚â§ j` (this is the field `F`). Such objects are\nequipped with data and properties which characterizes the iterations up to a unique\nisomorphism for the three types of elements: `‚ä•`, successors, limit elements. -/\nstructure Iteration [Preorder J] [OrderBot J] [SuccOrder J] (j : J) where\n  /-- The data of all `i`th iterations for `i : J` such that `i ‚â§ j`. -/\n  F : Set.Iic j ‚•§ C ‚•§ C\n  /-- The zeroth iteration is the identity functor. -/\n  isoZero : F.obj ‚ü®‚ä•, bot_le‚ü© ‚âÖ ùü≠ C\n  /-- The iteration on a successor element is obtained by composition of\n  the previous iteration with `Œ¶`. -/\n  isoSucc (i : J) (hi : i < j) : F.obj ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© ‚âÖ F.obj ‚ü®i, hi.le‚ü© ‚ãô Œ¶\n  /-- The natural map from an iteration to its successor is induced by `Œµ`. -/\n  mapSucc'_eq (i : J) (hi : i < j) :\n    Iteration.mapSucc' F i hi = whiskerLeft _ Œµ ‚â´ (isoSucc i hi).inv\n  /-- If `i` is a limit element, the `i`th iteration is the colimit\n  of `k`th iterations for `k < i`. -/\n  isColimit (i : J) (hi : Order.IsSuccLimit i) (hij : i ‚â§ j) :\n    IsColimit (Iteration.coconeOfLE F hij)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.mapSucc'_eq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\nj : J\nself : CategoryTheory.Functor.Iteration Œµ j\ni : J\nhi : LT.lt i j\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.mapSucc' self.F i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (self.F.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (self.isoSucc i hi).inv)","decl":"/-- The category of `j`th iterations of a functor `Œ¶` equipped with a natural\ntransformation `Œµ : ùü≠ C ‚ü∂ Œ¶`. An object consists of the data of all iterations\nof `Œ¶` for `i : J` such that `i ‚â§ j` (this is the field `F`). Such objects are\nequipped with data and properties which characterizes the iterations up to a unique\nisomorphism for the three types of elements: `‚ä•`, successors, limit elements. -/\nstructure Iteration [Preorder J] [OrderBot J] [SuccOrder J] (j : J) where\n  /-- The data of all `i`th iterations for `i : J` such that `i ‚â§ j`. -/\n  F : Set.Iic j ‚•§ C ‚•§ C\n  /-- The zeroth iteration is the identity functor. -/\n  isoZero : F.obj ‚ü®‚ä•, bot_le‚ü© ‚âÖ ùü≠ C\n  /-- The iteration on a successor element is obtained by composition of\n  the previous iteration with `Œ¶`. -/\n  isoSucc (i : J) (hi : i < j) : F.obj ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© ‚âÖ F.obj ‚ü®i, hi.le‚ü© ‚ãô Œ¶\n  /-- The natural map from an iteration to its successor is induced by `Œµ`. -/\n  mapSucc'_eq (i : J) (hi : i < j) :\n    Iteration.mapSucc' F i hi = whiskerLeft _ Œµ ‚â´ (isoSucc i hi).inv\n  /-- If `i` is a limit element, the `i`th iteration is the colimit\n  of `k`th iterations for `k < i`. -/\n  isColimit (i : J) (hi : Order.IsSuccLimit i) (hij : i ‚â§ j) :\n    IsColimit (Iteration.coconeOfLE F hij)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.mapSucc_eq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter : CategoryTheory.Functor.Iteration Œµ j\ni : J\nhi : LT.lt i j\n‚ä¢ Eq (iter.mapSucc i hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (iter.F.obj ‚ü®i, ‚ãØ‚ü©) Œµ) (iter.isoSucc i hi).inv)","decl":"lemma mapSucc_eq (i : J) (hi : i < j) :\n    iter.mapSucc i hi = whiskerLeft _ Œµ ‚â´ (iter.isoSucc i hi).inv :=\n  iter.mapSucc'_eq _ hi\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nself : iter‚ÇÅ.Hom iter‚ÇÇ\n‚ä¢ Eq (self.natTrans.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)","decl":"/-- A morphism between two objects `iter‚ÇÅ` and `iter‚ÇÇ` in the\ncategory `Œ¶.Iteration Œµ j` of `j`th iterations of a functor `Œ¶`\nequipped with a natural transformation `Œµ : ùü≠ C ‚ü∂ Œ¶` consists of a natural\ntransformation `natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` which is compatible with the\nisomorphisms `isoZero` and `isoSucc`. -/\nstructure Hom where\n  /-- A natural transformation `iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` -/\n  natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F\n  natTrans_app_zero :\n    natTrans.app ‚ü®‚ä•, bot_le‚ü© = iter‚ÇÅ.isoZero.hom ‚â´ iter‚ÇÇ.isoZero.inv := by aesop_cat\n  natTrans_app_succ (i : J) (hi : i < j) :\n    natTrans.app ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© = (iter‚ÇÅ.isoSucc i hi).hom ‚â´\n      whiskerRight (natTrans.app ‚ü®i, hi.le‚ü©) _ ‚â´ (iter‚ÇÇ.isoSucc i hi).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nnatTrans‚úù : Quiver.Hom iter‚ÇÅ.F iter‚ÇÇ.F\nnatTrans_app_zero‚úù : autoParam (Eq (natTrans‚úù.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)) _auto‚úù\nnatTrans_app_succ‚úù : autoParam (‚àÄ (i : J) (hi : LT.lt i j), Eq (natTrans‚úù.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (natTrans‚úù.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))) _auto‚úù\nnatTrans : Quiver.Hom iter‚ÇÅ.F iter‚ÇÇ.F\nnatTrans_app_zero : autoParam (Eq (natTrans.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)) _auto‚úù\nnatTrans_app_succ : autoParam (‚àÄ (i : J) (hi : LT.lt i j), Eq (natTrans.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (natTrans.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))) _auto‚úù\n‚ä¢ Eq (Eq { natTrans := natTrans‚úù, natTrans_app_zero := natTrans_app_zero‚úù, natTrans_app_succ := natTrans_app_succ‚úù } { natTrans := natTrans, natTrans_app_zero := natTrans_app_zero, natTrans_app_succ := natTrans_app_succ }) (Eq natTrans‚úù natTrans)","decl":"/-- A morphism between two objects `iter‚ÇÅ` and `iter‚ÇÇ` in the\ncategory `Œ¶.Iteration Œµ j` of `j`th iterations of a functor `Œ¶`\nequipped with a natural transformation `Œµ : ùü≠ C ‚ü∂ Œ¶` consists of a natural\ntransformation `natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` which is compatible with the\nisomorphisms `isoZero` and `isoSucc`. -/\nstructure Hom where\n  /-- A natural transformation `iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` -/\n  natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F\n  natTrans_app_zero :\n    natTrans.app ‚ü®‚ä•, bot_le‚ü© = iter‚ÇÅ.isoZero.hom ‚â´ iter‚ÇÇ.isoZero.inv := by aesop_cat\n  natTrans_app_succ (i : J) (hi : i < j) :\n    natTrans.app ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© = (iter‚ÇÅ.isoSucc i hi).hom ‚â´\n      whiskerRight (natTrans.app ‚ü®i, hi.le‚ü©) _ ‚â´ (iter‚ÇÇ.isoSucc i hi).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù‚Å¥ : Preorder J\ninst‚úù¬≥ : OrderBot J\ninst‚úù¬≤ : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf J\nnatTrans : Quiver.Hom iter‚ÇÅ.F iter‚ÇÇ.F\nnatTrans_app_zero : autoParam (Eq (natTrans.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)) _auto‚úù\nnatTrans_app_succ : autoParam (‚àÄ (i : J) (hi : LT.lt i j), Eq (natTrans.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (natTrans.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { natTrans := natTrans, natTrans_app_zero := natTrans_app_zero, natTrans_app_succ := natTrans_app_succ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf natTrans)) (SizeOf.sizeOf natTrans_app_zero))","decl":"/-- A morphism between two objects `iter‚ÇÅ` and `iter‚ÇÇ` in the\ncategory `Œ¶.Iteration Œµ j` of `j`th iterations of a functor `Œ¶`\nequipped with a natural transformation `Œµ : ùü≠ C ‚ü∂ Œ¶` consists of a natural\ntransformation `natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` which is compatible with the\nisomorphisms `isoZero` and `isoSucc`. -/\nstructure Hom where\n  /-- A natural transformation `iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` -/\n  natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F\n  natTrans_app_zero :\n    natTrans.app ‚ü®‚ä•, bot_le‚ü© = iter‚ÇÅ.isoZero.hom ‚â´ iter‚ÇÇ.isoZero.inv := by aesop_cat\n  natTrans_app_succ (i : J) (hi : i < j) :\n    natTrans.app ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© = (iter‚ÇÅ.isoSucc i hi).hom ‚â´\n      whiskerRight (natTrans.app ‚ü®i, hi.le‚ü©) _ ‚â´ (iter‚ÇÇ.isoSucc i hi).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nnatTrans‚úù : Quiver.Hom iter‚ÇÅ.F iter‚ÇÇ.F\nnatTrans_app_zero‚úù : autoParam (Eq (natTrans‚úù.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)) _auto‚úù\nnatTrans_app_succ‚úù : autoParam (‚àÄ (i : J) (hi : LT.lt i j), Eq (natTrans‚úù.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (natTrans‚úù.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))) _auto‚úù\nnatTrans : Quiver.Hom iter‚ÇÅ.F iter‚ÇÇ.F\nnatTrans_app_zero : autoParam (Eq (natTrans.app ‚ü®Bot.bot, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom iter‚ÇÇ.isoZero.inv)) _auto‚úù\nnatTrans_app_succ : autoParam (‚àÄ (i : J) (hi : LT.lt i j), Eq (natTrans.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (natTrans.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))) _auto‚úù\nx‚úù : Eq { natTrans := natTrans‚úù, natTrans_app_zero := natTrans_app_zero‚úù, natTrans_app_succ := natTrans_app_succ‚úù } { natTrans := natTrans, natTrans_app_zero := natTrans_app_zero, natTrans_app_succ := natTrans_app_succ }\n‚ä¢ Eq natTrans‚úù natTrans","decl":"/-- A morphism between two objects `iter‚ÇÅ` and `iter‚ÇÇ` in the\ncategory `Œ¶.Iteration Œµ j` of `j`th iterations of a functor `Œ¶`\nequipped with a natural transformation `Œµ : ùü≠ C ‚ü∂ Œ¶` consists of a natural\ntransformation `natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` which is compatible with the\nisomorphisms `isoZero` and `isoSucc`. -/\nstructure Hom where\n  /-- A natural transformation `iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` -/\n  natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F\n  natTrans_app_zero :\n    natTrans.app ‚ü®‚ä•, bot_le‚ü© = iter‚ÇÅ.isoZero.hom ‚â´ iter‚ÇÇ.isoZero.inv := by aesop_cat\n  natTrans_app_succ (i : J) (hi : i < j) :\n    natTrans.app ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© = (iter‚ÇÅ.isoSucc i hi).hom ‚â´\n      whiskerRight (natTrans.app ‚ü®i, hi.le‚ü©) _ ‚â´ (iter‚ÇÇ.isoSucc i hi).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.natTrans_app_succ","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nself : iter‚ÇÅ.Hom iter‚ÇÇ\ni : J\nhi : LT.lt i j\n‚ä¢ Eq (self.natTrans.app ‚ü®Order.succ i, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i hi).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (self.natTrans.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i hi).inv))","decl":"/-- A morphism between two objects `iter‚ÇÅ` and `iter‚ÇÇ` in the\ncategory `Œ¶.Iteration Œµ j` of `j`th iterations of a functor `Œ¶`\nequipped with a natural transformation `Œµ : ùü≠ C ‚ü∂ Œ¶` consists of a natural\ntransformation `natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` which is compatible with the\nisomorphisms `isoZero` and `isoSucc`. -/\nstructure Hom where\n  /-- A natural transformation `iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F` -/\n  natTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F\n  natTrans_app_zero :\n    natTrans.app ‚ü®‚ä•, bot_le‚ü© = iter‚ÇÅ.isoZero.hom ‚â´ iter‚ÇÇ.isoZero.inv := by aesop_cat\n  natTrans_app_succ (i : J) (hi : i < j) :\n    natTrans.app ‚ü®Order.succ i, Order.succ_le_of_lt hi‚ü© = (iter‚ÇÅ.isoSucc i hi).hom ‚â´\n      whiskerRight (natTrans.app ‚ü®i, hi.le‚ü©) _ ‚â´ (iter‚ÇÇ.isoSucc i hi).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.natTrans_app_zero_assoc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nself : iter‚ÇÅ.Hom iter‚ÇÇ\nZ : CategoryTheory.Functor C C\nh : Quiver.Hom (iter‚ÇÇ.F.obj ‚ü®Bot.bot, ‚ãØ‚ü©) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.natTrans.app ‚ü®Bot.bot, ‚ãØ‚ü©) h) (CategoryTheory.CategoryStruct.comp iter‚ÇÅ.isoZero.hom (CategoryTheory.CategoryStruct.comp iter‚ÇÇ.isoZero.inv h))","decl":"attribute [simp, reassoc] natTrans_app_zero\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.id_natTrans","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.Hom.id iter‚ÇÅ).natTrans (CategoryTheory.CategoryStruct.id iter‚ÇÅ.F)","decl":"/-- The identity morphism in the category `Œ¶.Iteration Œµ j`. -/\n@[simps]\ndef id : Hom iter‚ÇÅ iter‚ÇÅ where\n  natTrans := ùüô _\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.ext'","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nf g : iter‚ÇÅ.Hom iter‚ÇÇ\nh : Eq f.natTrans g.natTrans\n‚ä¢ Eq f g","decl":"lemma ext' {f g : Hom iter‚ÇÅ iter‚ÇÇ} (h : f.natTrans = g.natTrans) : f = g := by\n  cases f\n  cases g\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.ext'_iff","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nf g : iter‚ÇÅ.Hom iter‚ÇÇ\n‚ä¢ Iff (Eq f g) (Eq f.natTrans g.natTrans)","decl":"attribute [local ext] ext'\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.comp_natTrans","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ iter‚ÇÉ : CategoryTheory.Functor.Iteration Œµ j\nf : iter‚ÇÅ.Hom iter‚ÇÇ\ng : iter‚ÇÇ.Hom iter‚ÇÉ\n‚ä¢ Eq (f.comp g).natTrans (CategoryTheory.CategoryStruct.comp f.natTrans g.natTrans)","decl":"/-- The composition of morphisms in the category `Iteration Œµ j`. -/\n@[simps]\ndef comp {iter‚ÇÉ : Iteration Œµ j} (f : Hom iter‚ÇÅ iter‚ÇÇ) (g : Hom iter‚ÇÇ iter‚ÇÉ) :\n    Hom iter‚ÇÅ iter‚ÇÉ where\n  natTrans := f.natTrans ‚â´ g.natTrans\n  natTrans_app_succ i hi := by simp [natTrans_app_succ _ _ hi]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.instSubsingletonHomOfWellFoundedLT","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u_2\nj : J\ninst‚úù¬≥ : PartialOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : WellFoundedLT J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Subsingleton (Quiver.Hom iter‚ÇÅ iter‚ÇÇ)","decl":"instance {J} {j : J} [PartialOrder J] [OrderBot J] [WellFoundedLT J] [SuccOrder J]\n    {iter‚ÇÅ iter‚ÇÇ : Iteration Œµ j} :\n    Subsingleton (iter‚ÇÅ ‚ü∂ iter‚ÇÇ) where\n  allEq f g := by\n    apply ext'\n    suffices ‚àÄ i hi, f.natTrans.app ‚ü®i, hi‚ü© = g.natTrans.app ‚ü®i, hi‚ü© by\n      ext ‚ü®i, hi‚ü© : 2\n      apply this\n    intro i\n    induction i using SuccOrder.limitRecOn with\n    | hm j H =>\n      obtain rfl := H.eq_bot\n      simp [natTrans_app_zero]\n    | hs j H IH =>\n      intro hj\n      simp [Hom.natTrans_app_succ, IH, (Order.lt_succ_of_not_isMax H).trans_le hj]\n    | hl j H IH =>\n      refine fun hj ‚Ü¶ (iter‚ÇÅ.isColimit j H hj).hom_ext ?_\n      rintro ‚ü®k, hk‚ü©\n      simp [IH k hk]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.natTrans_id","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id iter‚ÇÅ).natTrans (CategoryTheory.CategoryStruct.id iter‚ÇÅ.F)","decl":"@[simp]\nlemma natTrans_id : Hom.natTrans (ùüô iter‚ÇÅ) = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.natTrans_comp_assoc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ iter‚ÇÉ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\nœà : Quiver.Hom iter‚ÇÇ iter‚ÇÉ\nZ : CategoryTheory.Functor (‚Üë(Set.Iic j)) (CategoryTheory.Functor C C)\nh : Quiver.Hom iter‚ÇÉ.F Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp œÜ œà).natTrans h) (CategoryTheory.CategoryStruct.comp œÜ.natTrans (CategoryTheory.CategoryStruct.comp œà.natTrans h))","decl":"@[simp, reassoc]\nlemma natTrans_comp {iter‚ÇÉ : Iteration Œµ j} (œÜ : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) (œà : iter‚ÇÇ ‚ü∂ iter‚ÇÉ) :\n    (œÜ ‚â´ œà).natTrans = œÜ.natTrans ‚â´ œà.natTrans := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.natTrans_comp","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ iter‚ÇÉ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\nœà : Quiver.Hom iter‚ÇÇ iter‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ œà).natTrans (CategoryTheory.CategoryStruct.comp œÜ.natTrans œà.natTrans)","decl":"@[simp, reassoc]\nlemma natTrans_comp {iter‚ÇÉ : Iteration Œµ j} (œÜ : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) (œà : iter‚ÇÇ ‚ü∂ iter‚ÇÉ) :\n    (œÜ ‚â´ œà).natTrans = œÜ.natTrans ‚â´ œà.natTrans := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.natTrans_naturality_assoc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\ni‚ÇÅ i‚ÇÇ : J\nh‚úù : LE.le i‚ÇÅ i‚ÇÇ\nh' : LE.le i‚ÇÇ j\nZ : CategoryTheory.Functor C C\nh : Quiver.Hom (iter‚ÇÇ.F.obj ‚ü®i‚ÇÇ, h'‚ü©) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.F.map (CategoryTheory.homOfLE h‚úù)) (CategoryTheory.CategoryStruct.comp (œÜ.natTrans.app ‚ü®i‚ÇÇ, h'‚ü©) h)) (CategoryTheory.CategoryStruct.comp (œÜ.natTrans.app ‚ü®i‚ÇÅ, ‚ãØ‚ü©) (CategoryTheory.CategoryStruct.comp (iter‚ÇÇ.F.map (CategoryTheory.homOfLE h‚úù)) h))","decl":"@[reassoc]\nlemma natTrans_naturality (œÜ : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) (i‚ÇÅ i‚ÇÇ : J) (h : i‚ÇÅ ‚â§ i‚ÇÇ) (h' : i‚ÇÇ ‚â§ j) :\n    iter‚ÇÅ.F.map (by exact homOfLE h) ‚â´ œÜ.natTrans.app ‚ü®i‚ÇÇ, h'‚ü© =\n      œÜ.natTrans.app ‚ü®i‚ÇÅ, h.trans h'‚ü© ‚â´ iter‚ÇÇ.F.map (by exact homOfLE h) := by\n  apply œÜ.natTrans.naturality\n\n"}
{"name":"CategoryTheory.Functor.Iteration.natTrans_naturality","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\ni‚ÇÅ i‚ÇÇ : J\nh : LE.le i‚ÇÅ i‚ÇÇ\nh' : LE.le i‚ÇÇ j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.F.map (CategoryTheory.homOfLE h)) (œÜ.natTrans.app ‚ü®i‚ÇÇ, h'‚ü©)) (CategoryTheory.CategoryStruct.comp (œÜ.natTrans.app ‚ü®i‚ÇÅ, ‚ãØ‚ü©) (iter‚ÇÇ.F.map (CategoryTheory.homOfLE h)))","decl":"@[reassoc]\nlemma natTrans_naturality (œÜ : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) (i‚ÇÅ i‚ÇÇ : J) (h : i‚ÇÅ ‚â§ i‚ÇÇ) (h' : i‚ÇÇ ‚â§ j) :\n    iter‚ÇÅ.F.map (by exact homOfLE h) ‚â´ œÜ.natTrans.app ‚ü®i‚ÇÇ, h'‚ü© =\n      œÜ.natTrans.app ‚ü®i‚ÇÅ, h.trans h'‚ü© ‚â´ iter‚ÇÇ.F.map (by exact homOfLE h) := by\n  apply œÜ.natTrans.naturality\n\n"}
{"name":"CategoryTheory.Functor.Iteration.eval_obj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\nhi : LE.le i j\niter : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.eval Œµ hi).obj iter) (iter.F.obj ‚ü®i, hi‚ü©)","decl":"variable (Œµ) in\n/-- The evaluation functor `Iteration Œµ j ‚•§ C ‚•§ C` at `i : J` when `i ‚â§ j`. -/\n@[simps]\ndef eval {i : J} (hi : i ‚â§ j) : Iteration Œµ j ‚•§ C ‚•§ C where\n  obj iter := iter.F.obj ‚ü®i, hi‚ü©\n  map œÜ := œÜ.natTrans.app _\n\n"}
{"name":"CategoryTheory.Functor.Iteration.eval_map","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\nhi : LE.le i j\nX‚úù Y‚úù : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.eval Œµ hi).map œÜ) (œÜ.natTrans.app ‚ü®i, hi‚ü©)","decl":"variable (Œµ) in\n/-- The evaluation functor `Iteration Œµ j ‚•§ C ‚•§ C` at `i : J` when `i ‚â§ j`. -/\n@[simps]\ndef eval {i : J} (hi : i ‚â§ j) : Iteration Œµ j ‚•§ C ‚•§ C where\n  obj iter := iter.F.obj ‚ü®i, hi‚ü©\n  map œÜ := œÜ.natTrans.app _\n\n"}
{"name":"CategoryTheory.Functor.Iteration.trunc_isoZero","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter : CategoryTheory.Functor.Iteration Œµ j\ni : J\nhi : LE.le i j\n‚ä¢ Eq (iter.trunc hi).isoZero iter.isoZero","decl":"/-- Given `iter : Iteration Œµ j` and `i : J` such that `i ‚â§ j`, this is the\ninduced element in `Iteration Œµ i`. -/\n@[simps F isoZero isoSucc]\ndef trunc (iter : Iteration Œµ j) {i : J} (hi : i ‚â§ j) : Iteration Œµ i where\n  F := restrictionLE iter.F hi\n  isoZero := iter.isoZero\n  isoSucc k hk := iter.isoSucc k (lt_of_lt_of_le hk hi)\n  mapSucc'_eq k hk := iter.mapSucc'_eq k (lt_of_lt_of_le hk hi)\n  isColimit k hk' hk := iter.isColimit k hk' (hk.trans hi)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.trunc_F","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter : CategoryTheory.Functor.Iteration Œµ j\ni : J\nhi : LE.le i j\n‚ä¢ Eq (iter.trunc hi).F (CategoryTheory.Functor.Iteration.restrictionLE iter.F hi)","decl":"/-- Given `iter : Iteration Œµ j` and `i : J` such that `i ‚â§ j`, this is the\ninduced element in `Iteration Œµ i`. -/\n@[simps F isoZero isoSucc]\ndef trunc (iter : Iteration Œµ j) {i : J} (hi : i ‚â§ j) : Iteration Œµ i where\n  F := restrictionLE iter.F hi\n  isoZero := iter.isoZero\n  isoSucc k hk := iter.isoSucc k (lt_of_lt_of_le hk hi)\n  mapSucc'_eq k hk := iter.mapSucc'_eq k (lt_of_lt_of_le hk hi)\n  isColimit k hk' hk := iter.isColimit k hk' (hk.trans hi)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.trunc_isoSucc","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter : CategoryTheory.Functor.Iteration Œµ j\ni : J\nhi : LE.le i j\nk : J\nhk : LT.lt k i\n‚ä¢ Eq ((iter.trunc hi).isoSucc k hk) (iter.isoSucc k ‚ãØ)","decl":"/-- Given `iter : Iteration Œµ j` and `i : J` such that `i ‚â§ j`, this is the\ninduced element in `Iteration Œµ i`. -/\n@[simps F isoZero isoSucc]\ndef trunc (iter : Iteration Œµ j) {i : J} (hi : i ‚â§ j) : Iteration Œµ i where\n  F := restrictionLE iter.F hi\n  isoZero := iter.isoZero\n  isoSucc k hk := iter.isoSucc k (lt_of_lt_of_le hk hi)\n  mapSucc'_eq k hk := iter.mapSucc'_eq k (lt_of_lt_of_le hk hi)\n  isColimit k hk' hk := iter.isColimit k hk' (hk.trans hi)\n\n"}
{"name":"CategoryTheory.Functor.Iteration.truncFunctor_obj","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\nhi : LE.le i j\niter : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.truncFunctor Œµ hi).obj iter) (iter.trunc hi)","decl":"variable (Œµ) in\n/-- The truncation functor `Iteration Œµ j ‚•§ Iteration Œµ i` when `i ‚â§ j`. -/\n@[simps obj]\ndef truncFunctor {i : J} (hi : i ‚â§ j) : Iteration Œµ j ‚•§ Iteration Œµ i where\n  obj iter := iter.trunc hi\n  map {iter‚ÇÅ iter‚ÇÇ} œÜ :=\n    { natTrans := whiskerLeft _ œÜ.natTrans\n      natTrans_app_succ := fun k hk => œÜ.natTrans_app_succ k (lt_of_lt_of_le hk hi) }\n\n"}
{"name":"CategoryTheory.Functor.Iteration.truncFunctor_map_natTrans_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≤ : Preorder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\ni : J\nhi : LE.le i j\nk : J\nhk : LE.le k i\n‚ä¢ Eq (((CategoryTheory.Functor.Iteration.truncFunctor Œµ hi).map œÜ).natTrans.app ‚ü®k, hk‚ü©) (œÜ.natTrans.app ‚ü®k, ‚ãØ‚ü©)","decl":"@[simp]\nlemma truncFunctor_map_natTrans_app\n    (œÜ : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) {i : J} (hi : i ‚â§ j) (k : J) (hk : k ‚â§ i) :\n    ((truncFunctor Œµ hi).map œÜ).natTrans.app ‚ü®k, hk‚ü© =\n      œÜ.natTrans.app ‚ü®k, hk.trans hi‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.congr_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\nj : J\ninst‚úù¬≥ : PartialOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : SuccOrder J\ninst‚úù : WellFoundedLT J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ œÜ' : Quiver.Hom iter‚ÇÅ iter‚ÇÇ\ni : J\nhi : LE.le i j\n‚ä¢ Eq (œÜ.natTrans.app ‚ü®i, hi‚ü©) (œÜ'.natTrans.app ‚ü®i, hi‚ü©)","decl":"lemma congr_app (œÜ œÜ' : iter‚ÇÅ ‚ü∂ iter‚ÇÇ) (i : J) (hi : i ‚â§ j) :\n    œÜ.natTrans.app ‚ü®i, hi‚ü© = œÜ'.natTrans.app ‚ü®i, hi‚ü© := by\n  obtain rfl := Subsingleton.elim œÜ œÜ'\n  rfl\n\n"}
