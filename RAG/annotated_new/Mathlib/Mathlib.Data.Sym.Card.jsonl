{"name":"Sym.card_sym_fin_eq_multichoose","module":"Mathlib.Data.Sym.Card","initialProofState":"n k : Nat\n⊢ Eq (Fintype.card (Sym (Fin n) k)) (n.multichoose k)","decl":"theorem card_sym_fin_eq_multichoose : ∀ n k : ℕ, card (Sym (Fin n) k) = multichoose n k\n  | n, 0 => by simp\n  | 0, k + 1 => by rw [multichoose_zero_succ]; exact card_eq_zero\n  | 1, k + 1 => by simp\n  | n + 2, k + 1 => by\n    rw [multichoose_succ_succ, ← card_sym_fin_eq_multichoose (n + 1) (k + 1),\n      ← card_sym_fin_eq_multichoose (n + 2) k, add_comm (Fintype.card _), ← card_sum]\n    refine Fintype.card_congr (Equiv.symm ?_)\n    apply (Sym.e1.symm.sumCongr Sym.e2.symm).trans\n    apply Equiv.sumCompl\n\n"}
{"name":"Sym.card_sym_eq_multichoose","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_2\nk : Nat\ninst✝¹ : Fintype α\ninst✝ : Fintype (Sym α k)\n⊢ Eq (Fintype.card (Sym α k)) ((Fintype.card α).multichoose k)","decl":"/-- For any fintype `α` of cardinality `n`, `card (Sym α k) = multichoose (card α) k`. -/\ntheorem card_sym_eq_multichoose (α : Type*) (k : ℕ) [Fintype α] [Fintype (Sym α k)] :\n    card (Sym α k) = multichoose (card α) k := by\n  rw [← card_sym_fin_eq_multichoose]\n  -- FIXME: Without the `Fintype` namespace, why does it complain about `Finset.card_congr` being\n  -- deprecated?\n  exact Fintype.card_congr (equivCongr (equivFin α))\n\n"}
{"name":"Sym.card_sym_eq_choose","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\nk : Nat\ninst✝ : Fintype (Sym α k)\n⊢ Eq (Fintype.card (Sym α k)) ((HSub.hSub (HAdd.hAdd (Fintype.card α) k) 1).choose k)","decl":"/-- The *stars and bars* lemma: the cardinality of `Sym α k` is equal to\n`Nat.choose (card α + k - 1) k`. -/\ntheorem card_sym_eq_choose {α : Type*} [Fintype α] (k : ℕ) [Fintype (Sym α k)] :\n    card (Sym α k) = (card α + k - 1).choose k := by\n  rw [card_sym_eq_multichoose, Nat.multichoose_eq]\n\n"}
{"name":"Sym2.card_image_diag","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.image Sym2.mk s.diag).card s.card","decl":"/-- The `diag` of `s : Finset α` is sent on a finset of `Sym2 α` of card `#s`. -/\ntheorem card_image_diag (s : Finset α) : #(s.diag.image Sym2.mk) = #s := by\n  rw [card_image_of_injOn, diag_card]\n  rintro ⟨x₀, x₁⟩ hx _ _ h\n  cases Sym2.eq.1 h\n  · rfl\n  · simp only [mem_coe, mem_diag] at hx\n    rw [hx.2]\n\n"}
{"name":"Sym2.two_mul_card_image_offDiag","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (HMul.hMul 2 (Finset.image Sym2.mk s.offDiag).card) s.offDiag.card","decl":"lemma two_mul_card_image_offDiag (s : Finset α) : 2 * #(s.offDiag.image Sym2.mk) = #s.offDiag := by\n  rw [card_eq_sum_card_image (Sym2.mk : α × α → _), sum_const_nat (Sym2.ind _), mul_comm]\n  rintro x y hxy\n  simp_rw [mem_image, mem_offDiag] at hxy\n  obtain ⟨a, ⟨ha₁, ha₂, ha⟩, h⟩ := hxy\n  replace h := Sym2.eq.1 h\n  obtain ⟨hx, hy, hxy⟩ : x ∈ s ∧ y ∈ s ∧ x ≠ y := by\n    cases h <;> refine ⟨‹_›, ‹_›, ?_⟩ <;> [exact ha; exact ha.symm]\n  have hxy' : y ≠ x := hxy.symm\n  have : {z ∈ s.offDiag | Sym2.mk z = s(x, y)} = {(x, y), (y, x)} := by\n    ext ⟨x₁, y₁⟩\n    rw [mem_filter, mem_insert, mem_singleton, Sym2.eq_iff, Prod.mk.inj_iff, Prod.mk.inj_iff,\n      and_iff_right_iff_imp]\n    -- `hxy'` is used in `exact`\n    rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> rw [mem_offDiag] <;> exact ⟨‹_›, ‹_›, ‹_›⟩\n  rw [this, card_insert_of_not_mem, card_singleton]\n  simp only [not_and, Prod.mk.inj_iff, mem_singleton]\n  exact fun _ => hxy'\n\n"}
{"name":"Sym2.card_image_offDiag","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.image Sym2.mk s.offDiag).card (s.card.choose 2)","decl":"/-- The `offDiag` of `s : Finset α` is sent on a finset of `Sym2 α` of card `#s.offDiag / 2`.\nThis is because every element `s(x, y)` of `Sym2 α` not on the diagonal comes from exactly two\npairs: `(x, y)` and `(y, x)`. -/\ntheorem card_image_offDiag (s : Finset α) : #(s.offDiag.image Sym2.mk) = (#s).choose 2 := by\n  rw [Nat.choose_two_right, Nat.mul_sub_left_distrib, mul_one, ← offDiag_card,\n    Nat.div_eq_of_eq_mul_right Nat.zero_lt_two (two_mul_card_image_offDiag s).symm]\n\n"}
{"name":"Sym2.card_subtype_diag","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Subtype fun a => a.IsDiag)) (Fintype.card α)","decl":"theorem card_subtype_diag [Fintype α] : card { a : Sym2 α // a.IsDiag } = card α := by\n  convert card_image_diag (univ : Finset α)\n  rw [← filter_image_mk_isDiag, Fintype.card_of_subtype]\n  rintro x\n  rw [mem_filter, univ_product_univ, mem_image]\n  obtain ⟨a, ha⟩ := Quot.exists_rep x\n  exact and_iff_right ⟨a, mem_univ _, ha⟩\n\n"}
{"name":"Sym2.card_subtype_not_diag","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Subtype fun a => Not a.IsDiag)) ((Fintype.card α).choose 2)","decl":"theorem card_subtype_not_diag [Fintype α] :\n    card { a : Sym2 α // ¬a.IsDiag } = (card α).choose 2 := by\n  convert card_image_offDiag (univ : Finset α)\n  rw [← filter_image_mk_not_isDiag, Fintype.card_of_subtype]\n  rintro x\n  rw [mem_filter, univ_product_univ, mem_image]\n  obtain ⟨a, ha⟩ := Quot.exists_rep x\n  exact and_iff_right ⟨a, mem_univ _, ha⟩\n\n"}
{"name":"Sym2.card","module":"Mathlib.Data.Sym.Card","initialProofState":"α : Type u_2\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Sym2 α)) ((HAdd.hAdd (Fintype.card α) 1).choose 2)","decl":"/-- Type **stars and bars** for the case `n = 2`. -/\nprotected theorem card {α} [Fintype α] : card (Sym2 α) = Nat.choose (card α + 1) 2 :=\n  Finset.card_sym2 _\n\n"}
