{"name":"Archimedean.arch","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\nself : Archimedean α\nx y : α\na✝ : LT.lt 0 y\n⊢ Exists fun n => LE.le x (HSMul.hSMul n y)","decl":"/-- An ordered additive commutative monoid is called `Archimedean` if for any two elements `x`, `y`\nsuch that `0 < y`, there exists a natural number `n` such that `x ≤ n • y`. -/\nclass Archimedean (α) [OrderedAddCommMonoid α] : Prop where\n  /-- For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\n  such that `x ≤ n • y`. -/\n  arch : ∀ (x : α) {y : α}, 0 < y → ∃ n : ℕ, x ≤ n • y\n\n"}
{"name":"MulArchimedean.arch","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\nself : MulArchimedean α\nx y : α\na✝ : LT.lt 1 y\n⊢ Exists fun n => LE.le x (HPow.hPow y n)","decl":"/-- An ordered commutative monoid is called `MulArchimedean` if for any two elements `x`, `y`\nsuch that `1 < y`, there exists a natural number `n` such that `x ≤ y ^ n`. -/\n@[to_additive Archimedean]\nclass MulArchimedean (α) [OrderedCommMonoid α] : Prop where\n  /-- For any two elements `x`, `y` such that `1 < y`, there exists a natural number `n`\n  such that `x ≤ y ^ n`. -/\n  arch : ∀ (x : α) {y : α}, 1 < y → ∃ n : ℕ, x ≤ y ^ n\n\n"}
{"name":"OrderDual.instMulArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedCommGroup α\ninst✝ : MulArchimedean α\n⊢ MulArchimedean (OrderDual α)","decl":"@[to_additive]\ninstance OrderDual.instMulArchimedean [OrderedCommGroup α] [MulArchimedean α] :\n    MulArchimedean αᵒᵈ :=\n  ⟨fun x y hy =>\n    let ⟨n, hn⟩ := MulArchimedean.arch (ofDual x)⁻¹ (inv_lt_one_iff_one_lt.2 hy)\n    ⟨n, by rwa [inv_pow, inv_le_inv_iff] at hn⟩⟩\n\n"}
{"name":"OrderDual.instAddArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : Archimedean α\n⊢ Archimedean (OrderDual α)","decl":"@[to_additive]\ninstance OrderDual.instMulArchimedean [OrderedCommGroup α] [MulArchimedean α] :\n    MulArchimedean αᵒᵈ :=\n  ⟨fun x y hy =>\n    let ⟨n, hn⟩ := MulArchimedean.arch (ofDual x)⁻¹ (inv_lt_one_iff_one_lt.2 hy)\n    ⟨n, by rwa [inv_pow, inv_le_inv_iff] at hn⟩⟩\n\n"}
{"name":"Additive.instArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedCommGroup α\ninst✝ : MulArchimedean α\n⊢ Archimedean (Additive α)","decl":"instance Additive.instArchimedean [OrderedCommGroup α] [MulArchimedean α] :\n    Archimedean (Additive α) :=\n  ⟨fun x _ hy ↦ MulArchimedean.arch x.toMul hy⟩\n\n"}
{"name":"Multiplicative.instMulArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : Archimedean α\n⊢ MulArchimedean (Multiplicative α)","decl":"instance Multiplicative.instMulArchimedean [OrderedAddCommGroup α] [Archimedean α] :\n    MulArchimedean (Multiplicative α) :=\n  ⟨fun x _ hy ↦ Archimedean.arch x.toAdd hy⟩\n\n"}
{"name":"exists_lt_nsmul","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"M : Type u_2\ninst✝² : OrderedAddCommMonoid M\ninst✝¹ : Archimedean M\ninst✝ : AddLeftStrictMono M\na : M\nha : LT.lt 0 a\nb : M\n⊢ Exists fun n => LT.lt b (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem exists_lt_pow [OrderedCommMonoid M] [MulArchimedean M]\n    [MulLeftStrictMono M] {a : M} (ha : 1 < a) (b : M) :\n    ∃ n : ℕ, b < a ^ n :=\n  let ⟨k, hk⟩ := MulArchimedean.arch b ha\n  ⟨k + 1, hk.trans_lt <| pow_lt_pow_right' ha k.lt_succ_self⟩\n\n"}
{"name":"exists_lt_pow","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"M : Type u_2\ninst✝² : OrderedCommMonoid M\ninst✝¹ : MulArchimedean M\ninst✝ : MulLeftStrictMono M\na : M\nha : LT.lt 1 a\nb : M\n⊢ Exists fun n => LT.lt b (HPow.hPow a n)","decl":"@[to_additive]\ntheorem exists_lt_pow [OrderedCommMonoid M] [MulArchimedean M]\n    [MulLeftStrictMono M] {a : M} (ha : 1 < a) (b : M) :\n    ∃ n : ℕ, b < a ^ n :=\n  let ⟨k, hk⟩ := MulArchimedean.arch b ha\n  ⟨k + 1, hk.trans_lt <| pow_lt_pow_right' ha k.lt_succ_self⟩\n\n"}
{"name":"existsUnique_zpow_near_of_one_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\ng : α\n⊢ ExistsUnique fun k => And (LE.le (HPow.hPow a k) g) (LT.lt g (HPow.hPow a (HAdd.hAdd k 1)))","decl":"/-- An archimedean decidable linearly ordered `CommGroup` has a version of the floor: for\n`a > 1`, any `g` in the group lies between some two consecutive powers of `a`. -/\n@[to_additive \"An archimedean decidable linearly ordered `AddCommGroup` has a version of the floor:\nfor `a > 0`, any `g` in the group lies between some two consecutive multiples of `a`. -/\"]\ntheorem existsUnique_zpow_near_of_one_lt {a : α} (ha : 1 < a) (g : α) :\n    ∃! k : ℤ, a ^ k ≤ g ∧ g < a ^ (k + 1) := by\n  let s : Set ℤ := { n : ℤ | a ^ n ≤ g }\n  obtain ⟨k, hk : g⁻¹ ≤ a ^ k⟩ := MulArchimedean.arch g⁻¹ ha\n  have h_ne : s.Nonempty := ⟨-k, by simpa [s] using inv_le_inv' hk⟩\n  obtain ⟨k, hk⟩ := MulArchimedean.arch g ha\n  have h_bdd : ∀ n ∈ s, n ≤ (k : ℤ) := by\n    intro n hn\n    apply (zpow_le_zpow_iff_right ha).mp\n    rw [← zpow_natCast] at hk\n    exact le_trans hn hk\n  obtain ⟨m, hm, hm'⟩ := Int.exists_greatest_of_bdd ⟨k, h_bdd⟩ h_ne\n  have hm'' : g < a ^ (m + 1) := by\n    contrapose! hm'\n    exact ⟨m + 1, hm', lt_add_one _⟩\n  refine ⟨m, ⟨hm, hm''⟩, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_⟩\n  rw [← zpow_lt_zpow_iff_right ha]\n  exact lt_of_le_of_lt hm hn.2\n\n"}
{"name":"existsUnique_zsmul_near_of_pos","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\ng : α\n⊢ ExistsUnique fun k => And (LE.le (HSMul.hSMul k a) g) (LT.lt g (HSMul.hSMul (HAdd.hAdd k 1) a))","decl":"/-- An archimedean decidable linearly ordered `CommGroup` has a version of the floor: for\n`a > 1`, any `g` in the group lies between some two consecutive powers of `a`. -/\n@[to_additive \"An archimedean decidable linearly ordered `AddCommGroup` has a version of the floor:\nfor `a > 0`, any `g` in the group lies between some two consecutive multiples of `a`. -/\"]\ntheorem existsUnique_zpow_near_of_one_lt {a : α} (ha : 1 < a) (g : α) :\n    ∃! k : ℤ, a ^ k ≤ g ∧ g < a ^ (k + 1) := by\n  let s : Set ℤ := { n : ℤ | a ^ n ≤ g }\n  obtain ⟨k, hk : g⁻¹ ≤ a ^ k⟩ := MulArchimedean.arch g⁻¹ ha\n  have h_ne : s.Nonempty := ⟨-k, by simpa [s] using inv_le_inv' hk⟩\n  obtain ⟨k, hk⟩ := MulArchimedean.arch g ha\n  have h_bdd : ∀ n ∈ s, n ≤ (k : ℤ) := by\n    intro n hn\n    apply (zpow_le_zpow_iff_right ha).mp\n    rw [← zpow_natCast] at hk\n    exact le_trans hn hk\n  obtain ⟨m, hm, hm'⟩ := Int.exists_greatest_of_bdd ⟨k, h_bdd⟩ h_ne\n  have hm'' : g < a ^ (m + 1) := by\n    contrapose! hm'\n    exact ⟨m + 1, hm', lt_add_one _⟩\n  refine ⟨m, ⟨hm, hm''⟩, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_⟩\n  rw [← zpow_lt_zpow_iff_right ha]\n  exact lt_of_le_of_lt hm hn.2\n\n"}
{"name":"existsUnique_zsmul_near_of_pos'","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\ng : α\n⊢ ExistsUnique fun k => And (LE.le 0 (HSub.hSub g (HSMul.hSMul k a))) (LT.lt (HSub.hSub g (HSMul.hSMul k a)) a)","decl":"@[to_additive]\ntheorem existsUnique_zpow_near_of_one_lt' {a : α} (ha : 1 < a) (g : α) :\n    ∃! k : ℤ, 1 ≤ g / a ^ k ∧ g / a ^ k < a := by\n  simpa only [one_le_div', zpow_add_one, div_lt_iff_lt_mul'] using\n    existsUnique_zpow_near_of_one_lt ha g\n\n"}
{"name":"existsUnique_zpow_near_of_one_lt'","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\ng : α\n⊢ ExistsUnique fun k => And (LE.le 1 (HDiv.hDiv g (HPow.hPow a k))) (LT.lt (HDiv.hDiv g (HPow.hPow a k)) a)","decl":"@[to_additive]\ntheorem existsUnique_zpow_near_of_one_lt' {a : α} (ha : 1 < a) (g : α) :\n    ∃! k : ℤ, 1 ≤ g / a ^ k ∧ g / a ^ k < a := by\n  simpa only [one_le_div', zpow_add_one, div_lt_iff_lt_mul'] using\n    existsUnique_zpow_near_of_one_lt ha g\n\n"}
{"name":"existsUnique_sub_zsmul_mem_Ico","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ico c (HAdd.hAdd c a)) (HSub.hSub b (HSMul.hSMul m a))","decl":"@[to_additive]\ntheorem existsUnique_div_zpow_mem_Ico {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b / a ^ m ∈ Set.Ico c (c * a) := by\n  simpa only [mem_Ico, le_div_iff_mul_le, one_mul, mul_comm c, div_lt_iff_lt_mul, mul_assoc] using\n    existsUnique_zpow_near_of_one_lt' ha (b / c)\n\n"}
{"name":"existsUnique_div_zpow_mem_Ico","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ico c (HMul.hMul c a)) (HDiv.hDiv b (HPow.hPow a m))","decl":"@[to_additive]\ntheorem existsUnique_div_zpow_mem_Ico {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b / a ^ m ∈ Set.Ico c (c * a) := by\n  simpa only [mem_Ico, le_div_iff_mul_le, one_mul, mul_comm c, div_lt_iff_lt_mul, mul_assoc] using\n    existsUnique_zpow_near_of_one_lt' ha (b / c)\n\n"}
{"name":"existsUnique_mul_zpow_mem_Ico","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ico c (HMul.hMul c a)) (HMul.hMul b (HPow.hPow a m))","decl":"@[to_additive]\ntheorem existsUnique_mul_zpow_mem_Ico {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b * a ^ m ∈ Set.Ico c (c * a) :=\n  (Equiv.neg ℤ).bijective.existsUnique_iff.2 <| by\n    simpa only [Equiv.neg_apply, mem_Ico, zpow_neg, ← div_eq_mul_inv, le_div_iff_mul_le, one_mul,\n      mul_comm c, div_lt_iff_lt_mul, mul_assoc] using existsUnique_zpow_near_of_one_lt' ha (b / c)\n\n"}
{"name":"existsUnique_add_zsmul_mem_Ico","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ico c (HAdd.hAdd c a)) (HAdd.hAdd b (HSMul.hSMul m a))","decl":"@[to_additive]\ntheorem existsUnique_mul_zpow_mem_Ico {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b * a ^ m ∈ Set.Ico c (c * a) :=\n  (Equiv.neg ℤ).bijective.existsUnique_iff.2 <| by\n    simpa only [Equiv.neg_apply, mem_Ico, zpow_neg, ← div_eq_mul_inv, le_div_iff_mul_le, one_mul,\n      mul_comm c, div_lt_iff_lt_mul, mul_assoc] using existsUnique_zpow_near_of_one_lt' ha (b / c)\n\n"}
{"name":"existsUnique_add_zsmul_mem_Ioc","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ioc c (HAdd.hAdd c a)) (HAdd.hAdd b (HSMul.hSMul m a))","decl":"@[to_additive]\ntheorem existsUnique_add_zpow_mem_Ioc {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b * a ^ m ∈ Set.Ioc c (c * a) :=\n  (Equiv.addRight (1 : ℤ)).bijective.existsUnique_iff.2 <| by\n    simpa only [zpow_add_one, div_lt_iff_lt_mul', le_div_iff_mul_le', ← mul_assoc, and_comm,\n      mem_Ioc, Equiv.coe_addRight, mul_le_mul_iff_right] using\n      existsUnique_zpow_near_of_one_lt ha (c / b)\n\n"}
{"name":"existsUnique_add_zpow_mem_Ioc","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ioc c (HMul.hMul c a)) (HMul.hMul b (HPow.hPow a m))","decl":"@[to_additive]\ntheorem existsUnique_add_zpow_mem_Ioc {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b * a ^ m ∈ Set.Ioc c (c * a) :=\n  (Equiv.addRight (1 : ℤ)).bijective.existsUnique_iff.2 <| by\n    simpa only [zpow_add_one, div_lt_iff_lt_mul', le_div_iff_mul_le', ← mul_assoc, and_comm,\n      mem_Ioc, Equiv.coe_addRight, mul_le_mul_iff_right] using\n      existsUnique_zpow_near_of_one_lt ha (c / b)\n\n"}
{"name":"existsUnique_sub_zpow_mem_Ioc","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : MulArchimedean α\na : α\nha : LT.lt 1 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ioc c (HMul.hMul c a)) (HDiv.hDiv b (HPow.hPow a m))","decl":"@[to_additive]\ntheorem existsUnique_sub_zpow_mem_Ioc {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b / a ^ m ∈ Set.Ioc c (c * a) :=\n  (Equiv.neg ℤ).bijective.existsUnique_iff.2 <| by\n    simpa only [Equiv.neg_apply, zpow_neg, div_inv_eq_mul] using\n      existsUnique_add_zpow_mem_Ioc ha b c\n\n"}
{"name":"existsUnique_sub_zsmul_mem_Ioc","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\na : α\nha : LT.lt 0 a\nb c : α\n⊢ ExistsUnique fun m => Membership.mem (Set.Ioc c (HAdd.hAdd c a)) (HSub.hSub b (HSMul.hSMul m a))","decl":"@[to_additive]\ntheorem existsUnique_sub_zpow_mem_Ioc {a : α} (ha : 1 < a) (b c : α) :\n    ∃! m : ℤ, b / a ^ m ∈ Set.Ioc c (c * a) :=\n  (Equiv.neg ℤ).bijective.existsUnique_iff.2 <| by\n    simpa only [Equiv.neg_apply, zpow_neg, div_inv_eq_mul] using\n      existsUnique_add_zpow_mem_Ioc ha b c\n\n"}
{"name":"exists_nat_ge","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedSemiring α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun n => LE.le x ↑n","decl":"theorem exists_nat_ge [OrderedSemiring α] [Archimedean α] (x : α) : ∃ n : ℕ, x ≤ n := by\n  nontriviality α\n  exact (Archimedean.arch x one_pos).imp fun n h => by rwa [← nsmul_one]\n\n"}
{"name":"instIsDirectedLeOfArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedSemiring α\ninst✝ : Archimedean α\n⊢ IsDirected α fun x1 x2 => LE.le x1 x2","decl":"instance (priority := 100) [OrderedSemiring α] [Archimedean α] : IsDirected α (· ≤ ·) :=\n  ⟨fun x y ↦\n    let ⟨m, hm⟩ := exists_nat_ge x; let ⟨n, hn⟩ := exists_nat_ge y\n    let ⟨k, hmk, hnk⟩ := exists_ge_ge m n\n    ⟨k, hm.trans <| Nat.mono_cast hmk, hn.trans <| Nat.mono_cast hnk⟩⟩\n\n"}
{"name":"exists_nat_gt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : StrictOrderedSemiring α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun n => LT.lt x ↑n","decl":"lemma exists_nat_gt (x : α) : ∃ n : ℕ, x < n :=\n  (exists_lt_nsmul zero_lt_one x).imp fun n hn ↦ by rwa [← nsmul_one]\n\n"}
{"name":"add_one_pow_unbounded_of_pos","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : StrictOrderedSemiring α\ninst✝ : Archimedean α\ny x : α\nhy : LT.lt 0 y\n⊢ Exists fun n => LT.lt x (HPow.hPow (HAdd.hAdd y 1) n)","decl":"theorem add_one_pow_unbounded_of_pos (x : α) (hy : 0 < y) : ∃ n : ℕ, x < (y + 1) ^ n :=\n  have : 0 ≤ 1 + y := add_nonneg zero_le_one hy.le\n  (Archimedean.arch x hy).imp fun n h ↦\n    calc\n      x ≤ n • y := h\n      _ = n * y := nsmul_eq_mul _ _\n      _ < 1 + n * y := lt_one_add _\n      _ ≤ (1 + y) ^ n :=\n        one_add_mul_le_pow' (mul_nonneg hy.le hy.le) (mul_nonneg this this)\n          (add_nonneg zero_le_two hy.le) _\n      _ = (y + 1) ^ n := by rw [add_comm]\n\n"}
{"name":"pow_unbounded_of_one_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : StrictOrderedSemiring α\ninst✝¹ : Archimedean α\ny : α\ninst✝ : ExistsAddOfLE α\nx : α\nhy1 : LT.lt 1 y\n⊢ Exists fun n => LT.lt x (HPow.hPow y n)","decl":"lemma pow_unbounded_of_one_lt [ExistsAddOfLE α] (x : α) (hy1 : 1 < y) : ∃ n : ℕ, x < y ^ n := by\n  obtain ⟨z, hz, rfl⟩ := exists_pos_add_of_lt' hy1\n  rw [add_comm]\n  exact add_one_pow_unbounded_of_pos _ hz\n\n"}
{"name":"exists_int_ge","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"R : Type u_3\ninst✝¹ : OrderedRing R\ninst✝ : Archimedean R\nx : R\n⊢ Exists fun n => LE.le x ↑n","decl":"theorem exists_int_ge (x : R) : ∃ n : ℤ, x ≤ n := let ⟨n, h⟩ := exists_nat_ge x; ⟨n, mod_cast h⟩\n\n"}
{"name":"exists_int_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"R : Type u_3\ninst✝¹ : OrderedRing R\ninst✝ : Archimedean R\nx : R\n⊢ Exists fun n => LE.le (↑n) x","decl":"theorem exists_int_le (x : R) : ∃ n : ℤ, n ≤ x :=\n  let ⟨n, h⟩ := exists_int_ge (-x); ⟨-n, by simpa [neg_le] using h⟩\n\n"}
{"name":"instIsDirectedGe","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"R : Type u_3\ninst✝¹ : OrderedRing R\ninst✝ : Archimedean R\n⊢ IsDirected R fun x1 x2 => GE.ge x1 x2","decl":"instance (priority := 100) : IsDirected R (· ≥ ·) where\n  directed a b :=\n    let ⟨m, hm⟩ := exists_int_le a; let ⟨n, hn⟩ := exists_int_le b\n    ⟨(min m n : ℤ), le_trans (Int.cast_mono <| min_le_left _ _) hm,\n      le_trans (Int.cast_mono <| min_le_right _ _) hn⟩\n\n"}
{"name":"exists_int_gt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : StrictOrderedRing α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun n => LT.lt x ↑n","decl":"theorem exists_int_gt (x : α) : ∃ n : ℤ, x < n :=\n  let ⟨n, h⟩ := exists_nat_gt x\n  ⟨n, by rwa [Int.cast_natCast]⟩\n\n"}
{"name":"exists_int_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : StrictOrderedRing α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun n => LT.lt (↑n) x","decl":"theorem exists_int_lt (x : α) : ∃ n : ℤ, (n : α) < x :=\n  let ⟨n, h⟩ := exists_int_gt (-x)\n  ⟨-n, by rw [Int.cast_neg]; exact neg_lt.1 h⟩\n\n"}
{"name":"exists_floor","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : StrictOrderedRing α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun fl => ∀ (z : Int), Iff (LE.le z fl) (LE.le (↑z) x)","decl":"theorem exists_floor (x : α) : ∃ fl : ℤ, ∀ z : ℤ, z ≤ fl ↔ (z : α) ≤ x := by\n  haveI := Classical.propDecidable\n  have : ∃ ub : ℤ, (ub : α) ≤ x ∧ ∀ z : ℤ, (z : α) ≤ x → z ≤ ub :=\n    Int.exists_greatest_of_bdd\n      (let ⟨n, hn⟩ := exists_int_gt x\n      ⟨n, fun z h' => Int.cast_le.1 <| le_trans h' <| le_of_lt hn⟩)\n      (let ⟨n, hn⟩ := exists_int_lt x\n      ⟨n, le_of_lt hn⟩)\n  refine this.imp fun fl h z => ?_\n  cases' h with h₁ h₂\n  exact ⟨fun h => le_trans (Int.cast_le.2 h) h₁, h₂ z⟩\n\n"}
{"name":"exists_nat_pow_near","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : Archimedean α\ninst✝ : ExistsAddOfLE α\nx y : α\nhx : LE.le 1 x\nhy : LT.lt 1 y\n⊢ Exists fun n => And (LE.le (HPow.hPow y n) x) (LT.lt x (HPow.hPow y (HAdd.hAdd n 1)))","decl":"/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem exists_nat_pow_near (hx : 1 ≤ x) (hy : 1 < y) : ∃ n : ℕ, y ^ n ≤ x ∧ x < y ^ (n + 1) := by\n  have h : ∃ n : ℕ, x < y ^ n := pow_unbounded_of_one_lt _ hy\n  classical exact\n      let n := Nat.find h\n      have hn : x < y ^ n := Nat.find_spec h\n      have hnp : 0 < n :=\n        pos_iff_ne_zero.2 fun hn0 => by rw [hn0, pow_zero] at hn; exact not_le_of_gt hn hx\n      have hnsp : Nat.pred n + 1 = n := Nat.succ_pred_eq_of_pos hnp\n      have hltn : Nat.pred n < n := Nat.pred_lt (ne_of_gt hnp)\n      ⟨Nat.pred n, le_of_not_lt (Nat.find_min h hltn), by rwa [hnsp]⟩\n\n"}
{"name":"exists_nat_one_div_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedSemifield α\ninst✝ : Archimedean α\nε : α\nhε : LT.lt 0 ε\n⊢ Exists fun n => LT.lt (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1)) ε","decl":"lemma exists_nat_one_div_lt (hε : 0 < ε) : ∃ n : ℕ, 1 / (n + 1 : α) < ε := by\n  cases' exists_nat_gt (1 / ε) with n hn\n  use n\n  rw [div_lt_iff₀, ← div_lt_iff₀' hε]\n  · apply hn.trans\n    simp [zero_lt_one]\n  · exact n.cast_add_one_pos\n\n"}
{"name":"exists_mem_Ico_zpow","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\nx y : α\ninst✝ : ExistsAddOfLE α\nhx : LT.lt 0 x\nhy : LT.lt 1 y\n⊢ Exists fun n => Membership.mem (Set.Ico (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"/-- Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ioc_zpow`,\nbut with ≤ and < the other way around. -/\ntheorem exists_mem_Ico_zpow (hx : 0 < x) (hy : 1 < y) : ∃ n : ℤ, x ∈ Ico (y ^ n) (y ^ (n + 1)) := by\n  classical exact\n      let ⟨N, hN⟩ := pow_unbounded_of_one_lt x⁻¹ hy\n      have he : ∃ m : ℤ, y ^ m ≤ x :=\n        ⟨-N,\n          le_of_lt\n            (by\n              rw [zpow_neg y ↑N, zpow_natCast]\n              exact (inv_lt_comm₀ hx (lt_trans (inv_pos.2 hx) hN)).1 hN)⟩\n      let ⟨M, hM⟩ := pow_unbounded_of_one_lt x hy\n      have hb : ∃ b : ℤ, ∀ m, y ^ m ≤ x → m ≤ b :=\n        ⟨M, fun m hm =>\n          le_of_not_lt fun hlt =>\n            not_lt_of_ge (zpow_le_zpow_right₀ hy.le hlt.le)\n              (lt_of_le_of_lt hm (by rwa [← zpow_natCast] at hM))⟩\n      let ⟨n, hn₁, hn₂⟩ := Int.exists_greatest_of_bdd hb he\n      ⟨n, hn₁, lt_of_not_ge fun hge => not_le_of_gt (Int.lt_succ _) (hn₂ _ hge)⟩\n\n"}
{"name":"exists_mem_Ioc_zpow","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\nx y : α\ninst✝ : ExistsAddOfLE α\nhx : LT.lt 0 x\nhy : LT.lt 1 y\n⊢ Exists fun n => Membership.mem (Set.Ioc (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"/-- Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ico_zpow`,\nbut with ≤ and < the other way around. -/\ntheorem exists_mem_Ioc_zpow (hx : 0 < x) (hy : 1 < y) : ∃ n : ℤ, x ∈ Ioc (y ^ n) (y ^ (n + 1)) :=\n  let ⟨m, hle, hlt⟩ := exists_mem_Ico_zpow (inv_pos.2 hx) hy\n  have hyp : 0 < y := lt_trans zero_lt_one hy\n  ⟨-(m + 1), by rwa [zpow_neg, inv_lt_comm₀ (zpow_pos hyp _) hx], by\n    rwa [neg_add, neg_add_cancel_right, zpow_neg, le_inv_comm₀ hx (zpow_pos hyp _)]⟩\n\n"}
{"name":"exists_pow_lt_of_lt_one","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\nx y : α\ninst✝ : ExistsAddOfLE α\nhx : LT.lt 0 x\nhy : LT.lt y 1\n⊢ Exists fun n => LT.lt (HPow.hPow y n) x","decl":"/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem exists_pow_lt_of_lt_one (hx : 0 < x) (hy : y < 1) : ∃ n : ℕ, y ^ n < x := by\n  by_cases y_pos : y ≤ 0\n  · use 1\n    simp only [pow_one]\n    exact y_pos.trans_lt hx\n  rw [not_le] at y_pos\n  rcases pow_unbounded_of_one_lt x⁻¹ ((one_lt_inv₀ y_pos).2 hy) with ⟨q, hq⟩\n  exact ⟨q, by rwa [inv_pow, inv_lt_inv₀ hx (pow_pos y_pos _)] at hq⟩\n\n"}
{"name":"exists_nat_pow_near_of_lt_one","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\nx y : α\ninst✝ : ExistsAddOfLE α\nxpos : LT.lt 0 x\nhx : LE.le x 1\nypos : LT.lt 0 y\nhy : LT.lt y 1\n⊢ Exists fun n => And (LT.lt (HPow.hPow y (HAdd.hAdd n 1)) x) (LE.le x (HPow.hPow y n))","decl":"/-- Given `x` and `y` between `0` and `1`, `x` is between two successive powers of `y`.\nThis is the same as `exists_nat_pow_near`, but for elements between `0` and `1` -/\ntheorem exists_nat_pow_near_of_lt_one (xpos : 0 < x) (hx : x ≤ 1) (ypos : 0 < y) (hy : y < 1) :\n    ∃ n : ℕ, y ^ (n + 1) < x ∧ x ≤ y ^ n := by\n  rcases exists_nat_pow_near (one_le_inv_iff₀.2 ⟨xpos, hx⟩) (one_lt_inv_iff₀.2 ⟨ypos, hy⟩) with\n    ⟨n, hn, h'n⟩\n  refine ⟨n, ?_, ?_⟩\n  · rwa [inv_pow, inv_lt_inv₀ xpos (pow_pos ypos _)] at h'n\n  · rwa [inv_pow, inv_le_inv₀ (pow_pos ypos _) xpos] at hn\n\n"}
{"name":"exists_pow_btwn_of_lt_mul","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\ninst✝ : ExistsAddOfLE α\na b c : α\nh : LT.lt a (HMul.hMul b c)\nhb₀ : LT.lt 0 b\nhb₁ : LE.le b 1\nhc₀ : LT.lt 0 c\nhc₁ : LT.lt c 1\n⊢ Exists fun n => And (LT.lt a (HPow.hPow c n)) (LT.lt (HPow.hPow c n) b)","decl":"/-- If `a < b * c`, `0 < b ≤ 1` and `0 < c < 1`, then there is a power `c ^ n` with `n : ℕ`\nstrictly between `a` and `b`. -/\nlemma exists_pow_btwn_of_lt_mul {a b c : α} (h : a < b * c) (hb₀ : 0 < b) (hb₁ : b ≤ 1)\n    (hc₀ : 0 < c) (hc₁ : c < 1) :\n    ∃ n : ℕ, a < c ^ n ∧ c ^ n < b := by\n  have := exists_pow_lt_of_lt_one hb₀ hc₁\n  refine ⟨Nat.find this, h.trans_le ?_, Nat.find_spec this⟩\n  by_contra! H\n  have hn : Nat.find this ≠ 0 := by\n    intro hf\n    simp only [hf, pow_zero] at H\n    exact (H.trans <| Left.mul_lt_of_le_of_lt_one_of_pos hb₁ hc₁ hb₀).false\n  rw [(Nat.succ_pred_eq_of_ne_zero hn).symm, pow_succ, mul_lt_mul_right hc₀] at H\n  exact Nat.find_min this (Nat.sub_one_lt hn) H\n\n"}
{"name":"exists_zpow_btwn_of_lt_mul","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : Archimedean α\ninst✝ : ExistsAddOfLE α\na b c : α\nh : LT.lt a (HMul.hMul b c)\nhb₀ : LT.lt 0 b\nhc₀ : LT.lt 0 c\nhc₁ : LT.lt c 1\n⊢ Exists fun n => And (LT.lt a (HPow.hPow c n)) (LT.lt (HPow.hPow c n) b)","decl":"/-- If `a < b * c`, `b` is positive and `0 < c < 1`, then there is a power `c ^ n` with `n : ℤ`\nstrictly between `a` and `b`. -/\nlemma exists_zpow_btwn_of_lt_mul {a b c : α} (h : a < b * c) (hb₀ : 0 < b) (hc₀ : 0 < c)\n    (hc₁ : c < 1) :\n    ∃ n : ℤ, a < c ^ n ∧ c ^ n < b := by\n  rcases le_or_lt a 0 with ha | ha\n  · obtain ⟨n, hn⟩ := exists_pow_lt_of_lt_one hb₀ hc₁\n    exact ⟨n, ha.trans_lt (zpow_pos hc₀ _), mod_cast hn⟩\n  · rcases le_or_lt b 1 with hb₁ | hb₁\n    · obtain ⟨n, hn⟩ := exists_pow_btwn_of_lt_mul h hb₀ hb₁ hc₀ hc₁\n      exact ⟨n, mod_cast hn⟩\n    · rcases lt_or_le a 1 with ha₁ | ha₁\n      · refine ⟨0, ?_⟩\n        rw [zpow_zero]\n        exact ⟨ha₁, hb₁⟩\n      · have : b⁻¹ < a⁻¹ * c := by rwa [lt_inv_mul_iff₀' ha, inv_mul_lt_iff₀ hb₀]\n        obtain ⟨n, hn₁, hn₂⟩ :=\n          exists_pow_btwn_of_lt_mul this (inv_pos_of_pos ha) (inv_le_one_of_one_le₀ ha₁) hc₀ hc₁\n        refine ⟨-n, ?_, ?_⟩\n        · rwa [lt_inv_comm₀ (pow_pos hc₀ n) ha, ← zpow_natCast, ← zpow_neg] at hn₂\n        · rwa [inv_lt_comm₀ hb₀ (pow_pos hc₀ n), ← zpow_natCast, ← zpow_neg] at hn₁\n\n"}
{"name":"archimedean_iff_nat_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun n => LT.lt x ↑n)","decl":"theorem archimedean_iff_nat_lt : Archimedean α ↔ ∀ x : α, ∃ n : ℕ, x < n :=\n  ⟨@exists_nat_gt α _, fun H =>\n    ⟨fun x y y0 =>\n      (H (x / y)).imp fun n h => le_of_lt <| by rwa [div_lt_iff₀ y0, ← nsmul_eq_mul] at h⟩⟩\n\n"}
{"name":"archimedean_iff_nat_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun n => LE.le x ↑n)","decl":"theorem archimedean_iff_nat_le : Archimedean α ↔ ∀ x : α, ∃ n : ℕ, x ≤ n :=\n  archimedean_iff_nat_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Nat.cast_lt.2 (lt_add_one _))⟩⟩\n\n"}
{"name":"archimedean_iff_int_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun n => LT.lt x ↑n)","decl":"theorem archimedean_iff_int_lt : Archimedean α ↔ ∀ x : α, ∃ n : ℤ, x < n :=\n  ⟨@exists_int_gt α _, by\n    rw [archimedean_iff_nat_lt]\n    intro h x\n    obtain ⟨n, h⟩ := h x\n    refine ⟨n.toNat, h.trans_le ?_⟩\n    exact mod_cast Int.self_le_toNat _⟩\n\n"}
{"name":"archimedean_iff_int_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun n => LE.le x ↑n)","decl":"theorem archimedean_iff_int_le : Archimedean α ↔ ∀ x : α, ∃ n : ℤ, x ≤ n :=\n  archimedean_iff_int_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Int.cast_lt.2 (lt_add_one _))⟩⟩\n\n"}
{"name":"archimedean_iff_rat_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun q => LT.lt x ↑q)","decl":"theorem archimedean_iff_rat_lt : Archimedean α ↔ ∀ x : α, ∃ q : ℚ, x < q where\n  mp _ x :=\n    let ⟨n, h⟩ := exists_nat_gt x\n    ⟨n, by rwa [Rat.cast_natCast]⟩\n  mpr H := archimedean_iff_nat_lt.2 fun x ↦\n    let ⟨q, h⟩ := H x; ⟨⌈q⌉₊, lt_of_lt_of_le h <| mod_cast Nat.le_ceil _⟩\n\n"}
{"name":"archimedean_iff_rat_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\n⊢ Iff (Archimedean α) (∀ (x : α), Exists fun q => LE.le x ↑q)","decl":"theorem archimedean_iff_rat_le : Archimedean α ↔ ∀ x : α, ∃ q : ℚ, x ≤ q :=\n  archimedean_iff_rat_lt.trans\n    ⟨fun H x => (H x).imp fun _ => le_of_lt, fun H x =>\n      let ⟨n, h⟩ := H x\n      ⟨n + 1, lt_of_le_of_lt h (Rat.cast_lt.2 (lt_add_one _))⟩⟩\n\n"}
{"name":"instArchimedeanRat","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"⊢ Archimedean Rat","decl":"instance : Archimedean ℚ :=\n  archimedean_iff_rat_le.2 fun q => ⟨q, by rw [Rat.cast_id]⟩\n\n"}
{"name":"exists_rat_gt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun q => LT.lt x ↑q","decl":"theorem exists_rat_gt (x : α) : ∃ q : ℚ, x < q := archimedean_iff_rat_lt.mp ‹_› _\n\n"}
{"name":"exists_rat_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx : α\n⊢ Exists fun q => LT.lt (↑q) x","decl":"theorem exists_rat_lt (x : α) : ∃ q : ℚ, (q : α) < x :=\n  let ⟨n, h⟩ := exists_int_lt x\n  ⟨n, by rwa [Rat.cast_intCast]⟩\n\n"}
{"name":"exists_rat_btwn","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\nh : LT.lt x y\n⊢ Exists fun q => And (LT.lt x ↑q) (LT.lt (↑q) y)","decl":"theorem exists_rat_btwn {x y : α} (h : x < y) : ∃ q : ℚ, x < q ∧ (q : α) < y := by\n  cases' exists_nat_gt (y - x)⁻¹ with n nh\n  cases' exists_floor (x * n) with z zh\n  refine ⟨(z + 1 : ℤ) / n, ?_⟩\n  have n0' := (inv_pos.2 (sub_pos.2 h)).trans nh\n  have n0 := Nat.cast_pos.1 n0'\n  rw [Rat.cast_div_of_ne_zero, Rat.cast_natCast, Rat.cast_intCast, div_lt_iff₀ n0']\n  · refine ⟨(lt_div_iff₀ n0').2 <| (lt_iff_lt_of_le_iff_le (zh _)).1 (lt_add_one _), ?_⟩\n    rw [Int.cast_add, Int.cast_one]\n    refine lt_of_le_of_lt (add_le_add_right ((zh _).1 le_rfl) _) ?_\n    rwa [← lt_sub_iff_add_lt', ← sub_mul, ← div_lt_iff₀' (sub_pos.2 h), one_div]\n  · rw [Rat.den_intCast, Nat.cast_one]\n    exact one_ne_zero\n  · intro H\n    rw [Rat.num_natCast, Int.cast_natCast, Nat.cast_eq_zero] at H\n    subst H\n    cases n0\n\n"}
{"name":"exists_pow_btwn","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nn : Nat\nhn : Ne n 0\nx y : α\nh : LT.lt x y\nhy : LT.lt 0 y\n⊢ Exists fun q => And (LT.lt 0 q) (And (LT.lt x (HPow.hPow q n)) (LT.lt (HPow.hPow q n) y))","decl":"theorem exists_pow_btwn {n : ℕ} (hn : n ≠ 0) {x y : α} (h : x < y) (hy : 0 < y) :\n    ∃ q : α, 0 < q ∧ x < q ^ n ∧ q ^ n < y := by\n  have ⟨δ, δ_pos, cont⟩ := uniform_continuous_npow_on_bounded (max 1 y)\n    (sub_pos.mpr <| max_lt_iff.mpr ⟨h, hy⟩) n\n  have ex : ∃ m : ℕ, y ≤ (m * δ) ^ n := by\n    have ⟨m, hm⟩ := exists_nat_ge (y / δ + 1 / δ)\n    refine ⟨m, le_trans ?_ (le_self_pow₀ ?_ hn)⟩ <;> rw [← div_le_iff₀ δ_pos]\n    · exact (lt_add_of_pos_right _ <| by positivity).le.trans hm\n    · exact (le_add_of_nonneg_left <| by positivity).trans hm\n  let m := Nat.find ex\n  have m_pos : 0 < m := (Nat.find_pos _).mpr <| by simpa [zero_pow hn] using hy\n  let q := m.pred * δ\n  have qny : q ^ n < y := lt_of_not_le (Nat.find_min ex <| Nat.pred_lt m_pos.ne')\n  have q1y : |q| < max 1 y := (abs_eq_self.mpr <| by positivity).trans_lt <| lt_max_iff.mpr\n    (or_iff_not_imp_left.mpr fun q1 ↦ (le_self_pow₀ (le_of_not_lt q1) hn).trans_lt qny)\n  have xqn : max x 0 < q ^ n :=\n    calc _ = y - (y - max x 0) := by rw [sub_sub_cancel]\n      _ ≤ (m * δ) ^ n - (y - max x 0) := sub_le_sub_right (Nat.find_spec ex) _\n      _ < (m * δ) ^ n - ((m * δ) ^ n - q ^ n) := by\n        refine sub_lt_sub_left ((le_abs_self _).trans_lt <| cont _ _ q1y.le ?_) _\n        rw [← Nat.succ_pred_eq_of_pos m_pos, Nat.cast_succ, ← sub_mul,\n          add_sub_cancel_left, one_mul, abs_eq_self.mpr (by positivity)]\n      _ = q ^ n := sub_sub_cancel ..\n  exact ⟨q, lt_of_le_of_ne (by positivity) fun q0 ↦\n    (le_sup_right.trans_lt xqn).ne <| q0 ▸ (zero_pow hn).symm, le_sup_left.trans_lt xqn, qny⟩\n\n"}
{"name":"exists_rat_pow_btwn_rat","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nn : Nat\nhn : Ne n 0\nx y : α\nh : LT.lt x y\nhy : LT.lt 0 y\n⊢ Exists fun q => And (LT.lt 0 q) (And (LT.lt x (HPow.hPow q n)) (LT.lt (HPow.hPow q n) y))","decl":"@[deprecated (since := \"2024-12-26\")] alias exists_rat_pow_btwn_rat := exists_pow_btwn\n\n"}
{"name":"exists_rat_pow_btwn","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nn : Nat\nhn : Ne n 0\nx y : α\nh : LT.lt x y\nhy : LT.lt 0 y\n⊢ Exists fun q => And (LT.lt 0 q) (And (LT.lt x (HPow.hPow (↑q) n)) (LT.lt (HPow.hPow (↑q) n) y))","decl":"/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem exists_rat_pow_btwn {n : ℕ} (hn : n ≠ 0) {x y : α} (h : x < y) (hy : 0 < y) :\n    ∃ q : ℚ, 0 < q ∧ x < (q : α) ^ n ∧ (q : α) ^ n < y := by\n  obtain ⟨q₂, hx₂, hy₂⟩ := exists_rat_btwn (max_lt h hy)\n  obtain ⟨q₁, hx₁, hq₁₂⟩ := exists_rat_btwn hx₂\n  have : (0 : α) < q₂ := (le_max_right _ _).trans_lt hx₂\n  norm_cast at hq₁₂ this\n  obtain ⟨q, hq, hq₁, hq₂⟩ := exists_pow_btwn hn hq₁₂ this\n  refine ⟨q, hq, (le_max_left _ _).trans_lt <| hx₁.trans ?_, hy₂.trans' ?_⟩ <;> assumption_mod_cast\n\n"}
{"name":"le_of_forall_rat_lt_imp_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\nh : ∀ (q : Rat), LT.lt (↑q) x → LE.le (↑q) y\n⊢ LE.le x y","decl":"theorem le_of_forall_rat_lt_imp_le (h : ∀ q : ℚ, (q : α) < x → (q : α) ≤ y) : x ≤ y :=\n  le_of_not_lt fun hyx =>\n    let ⟨_, hy, hx⟩ := exists_rat_btwn hyx\n    hy.not_le <| h _ hx\n\n"}
{"name":"le_of_forall_lt_rat_imp_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\nh : ∀ (q : Rat), LT.lt y ↑q → LE.le x ↑q\n⊢ LE.le x y","decl":"theorem le_of_forall_lt_rat_imp_le (h : ∀ q : ℚ, y < q → x ≤ q) : x ≤ y :=\n  le_of_not_lt fun hyx =>\n    let ⟨_, hy, hx⟩ := exists_rat_btwn hyx\n    hx.not_le <| h _ hy\n\n"}
{"name":"le_iff_forall_rat_lt_imp_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\n⊢ Iff (LE.le x y) (∀ (q : Rat), LT.lt (↑q) x → LE.le (↑q) y)","decl":"theorem le_iff_forall_rat_lt_imp_le : x ≤ y ↔ ∀ q : ℚ, (q : α) < x → (q : α) ≤ y :=\n  ⟨fun hxy _ hqx ↦ hqx.le.trans hxy, le_of_forall_rat_lt_imp_le⟩\n\n"}
{"name":"le_iff_forall_lt_rat_imp_le","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\n⊢ Iff (LE.le x y) (∀ (q : Rat), LT.lt y ↑q → LE.le x ↑q)","decl":"theorem le_iff_forall_lt_rat_imp_le : x ≤ y ↔ ∀ q : ℚ, y < q → x ≤ q :=\n  ⟨fun hxy _ hqx ↦ hxy.trans hqx.le, le_of_forall_lt_rat_imp_le⟩\n\n"}
{"name":"eq_of_forall_rat_lt_iff_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\nh : ∀ (q : Rat), Iff (LT.lt (↑q) x) (LT.lt (↑q) y)\n⊢ Eq x y","decl":"theorem eq_of_forall_rat_lt_iff_lt (h : ∀ q : ℚ, (q : α) < x ↔ (q : α) < y) : x = y :=\n  (le_of_forall_rat_lt_imp_le fun q hq => ((h q).1 hq).le).antisymm <|\n    le_of_forall_rat_lt_imp_le fun q hq => ((h q).2 hq).le\n\n"}
{"name":"eq_of_forall_lt_rat_iff_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx y : α\nh : ∀ (q : Rat), Iff (LT.lt x ↑q) (LT.lt y ↑q)\n⊢ Eq x y","decl":"theorem eq_of_forall_lt_rat_iff_lt (h : ∀ q : ℚ, x < q ↔ y < q) : x = y :=\n  (le_of_forall_lt_rat_imp_le fun q hq => ((h q).2 hq).le).antisymm <|\n    le_of_forall_lt_rat_imp_le fun q hq => ((h q).1 hq).le\n\n"}
{"name":"exists_pos_rat_lt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nx : α\nx0 : LT.lt 0 x\n⊢ Exists fun q => And (LT.lt 0 q) (LT.lt (↑q) x)","decl":"theorem exists_pos_rat_lt {x : α} (x0 : 0 < x) : ∃ q : ℚ, 0 < q ∧ (q : α) < x := by\n  simpa only [Rat.cast_pos] using exists_rat_btwn x0\n\n"}
{"name":"exists_rat_near","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nε x : α\nε0 : LT.lt 0 ε\n⊢ Exists fun q => LT.lt (abs (HSub.hSub x ↑q)) ε","decl":"theorem exists_rat_near (x : α) (ε0 : 0 < ε) : ∃ q : ℚ, |x - q| < ε :=\n  let ⟨q, h₁, h₂⟩ :=\n    exists_rat_btwn <| ((sub_lt_self_iff x).2 ε0).trans ((lt_add_iff_pos_left x).2 ε0)\n  ⟨q, abs_sub_lt_iff.2 ⟨sub_lt_comm.1 h₁, sub_lt_iff_lt_add.2 h₂⟩⟩\n\n"}
{"name":"instArchimedeanNat","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"⊢ Archimedean Nat","decl":"instance : Archimedean ℕ :=\n  ⟨fun n m m0 => ⟨n, by\n    rw [← mul_one n, smul_eq_mul, mul_assoc, one_mul m]\n    exact Nat.mul_le_mul_left n (by omega)⟩⟩\n\n"}
{"name":"instArchimedeanInt","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"⊢ Archimedean Int","decl":"instance : Archimedean ℤ :=\n  ⟨fun n m m0 =>\n    ⟨n.toNat,\n      le_trans (Int.self_le_toNat _) <| by\n        simpa only [nsmul_eq_mul, zero_add, mul_one] using\n          mul_le_mul_of_nonneg_left (Int.add_one_le_iff.2 m0) (Int.ofNat_zero_le n.toNat)⟩⟩\n\n"}
{"name":"Nonneg.instArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : Archimedean α\n⊢ Archimedean (Subtype fun x => LE.le 0 x)","decl":"instance Nonneg.instArchimedean [OrderedAddCommMonoid α] [Archimedean α] :\n    Archimedean { x : α // 0 ≤ x } :=\n  ⟨fun x y hy =>\n    let ⟨n, hr⟩ := Archimedean.arch (x : α) (hy : (0 : α) < y)\n    ⟨n, show (x : α) ≤ (n • y : { x : α // 0 ≤ x }) by simp [*, -nsmul_eq_mul, nsmul_coe]⟩⟩\n\n"}
{"name":"Nonneg.instMulArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_1\ninst✝² : StrictOrderedCommSemiring α\ninst✝¹ : Archimedean α\ninst✝ : ExistsAddOfLE α\n⊢ MulArchimedean (Subtype fun x => LE.le 0 x)","decl":"instance Nonneg.instMulArchimedean [StrictOrderedCommSemiring α] [Archimedean α] [ExistsAddOfLE α] :\n    MulArchimedean { x : α // 0 ≤ x } :=\n  ⟨fun x _ hy ↦ (pow_unbounded_of_one_lt x hy).imp fun _ h ↦ h.le⟩\n\n"}
{"name":"instArchimedeanNNRat","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"⊢ Archimedean NNRat","decl":"instance : Archimedean NNRat := Nonneg.instArchimedean\n"}
{"name":"instMulArchimedeanNNRat","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"⊢ MulArchimedean NNRat","decl":"instance : MulArchimedean NNRat := Nonneg.instMulArchimedean\n\n"}
{"name":"FloorRing.archimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_3\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\n⊢ Archimedean α","decl":"/-- A linear ordered field that is a floor ring is archimedean. -/\ninstance (priority := 100) FloorRing.archimedean (α) [LinearOrderedField α] [FloorRing α] :\n    Archimedean α := by\n  rw [archimedean_iff_int_le]\n  exact fun x => ⟨⌈x⌉, Int.le_ceil x⟩\n\n"}
{"name":"Units.instMulArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_3\ninst✝¹ : OrderedCommMonoid α\ninst✝ : MulArchimedean α\n⊢ MulArchimedean (Units α)","decl":"@[to_additive]\ninstance Units.instMulArchimedean (α) [OrderedCommMonoid α] [MulArchimedean α] :\n    MulArchimedean αˣ :=\n  ⟨fun x {_} h ↦ MulArchimedean.arch x.val h⟩\n"}
{"name":"AddUnits.instAddArchimedean","module":"Mathlib.Algebra.Order.Archimedean.Basic","initialProofState":"α : Type u_3\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : Archimedean α\n⊢ Archimedean (AddUnits α)","decl":"@[to_additive]\ninstance Units.instMulArchimedean (α) [OrderedCommMonoid α] [MulArchimedean α] :\n    MulArchimedean αˣ :=\n  ⟨fun x {_} h ↦ MulArchimedean.arch x.val h⟩\n"}
