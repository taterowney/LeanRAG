{"name":"Con.congr_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\nh : Eq c d\na : M\n⊢ Eq ((Con.congr h) ↑a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem congr_mk {c d : Con M} (h : c = d) (a : M) :\n    Con.congr h (a : c.Quotient) = (a : d.Quotient) := rfl\n\n"}
{"name":"AddCon.congr_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\nh : Eq c d\na : M\n⊢ Eq ((AddCon.congr h) ↑a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem congr_mk {c d : Con M} (h : c = d) (a : M) :\n    Con.congr h (a : c.Quotient) = (a : d.Quotient) := rfl\n\n"}
{"name":"Con.le_comap_conGen","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : M → N\nH : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nrel : N → N → Prop\n⊢ LE.le (conGen fun x y => rel (f x) (f y)) (Con.comap f H (conGen rel))","decl":"@[to_additive]\ntheorem le_comap_conGen {M N : Type*} [Mul M] [Mul N] (f : M → N)\n    (H : ∀ (x y : M), f (x * y) = f x * f y) (rel : N → N → Prop) :\n    conGen (fun x y ↦ rel (f x) (f y)) ≤ Con.comap f H (conGen rel) := by\n  intro x y h\n  simp only [Con.comap_rel]\n  exact .rec (fun x y h ↦ .of (f x) (f y) h) (fun x ↦ .refl (f x))\n    (fun _ h ↦ .symm h) (fun _ _ h1 h2 ↦ h1.trans h2) (fun {w x y z} _ _ h1 h2 ↦\n    (congrArg (fun a ↦ conGen rel a (f (x * z))) (H w y)).mpr\n    (((congrArg (fun a ↦ conGen rel (f w * f y) a) (H x z))).mpr\n    (.mul h1 h2))) h\n\n"}
{"name":"AddCon.le_comap_conGen","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : M → N\nH : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nrel : N → N → Prop\n⊢ LE.le (addConGen fun x y => rel (f x) (f y)) (AddCon.comap f H (addConGen rel))","decl":"@[to_additive]\ntheorem le_comap_conGen {M N : Type*} [Mul M] [Mul N] (f : M → N)\n    (H : ∀ (x y : M), f (x * y) = f x * f y) (rel : N → N → Prop) :\n    conGen (fun x y ↦ rel (f x) (f y)) ≤ Con.comap f H (conGen rel) := by\n  intro x y h\n  simp only [Con.comap_rel]\n  exact .rec (fun x y h ↦ .of (f x) (f y) h) (fun x ↦ .refl (f x))\n    (fun _ h ↦ .symm h) (fun _ _ h1 h2 ↦ h1.trans h2) (fun {w x y z} _ _ h1 h2 ↦\n    (congrArg (fun a ↦ conGen rel a (f (x * z))) (H w y)).mpr\n    (((congrArg (fun a ↦ conGen rel (f w * f y) a) (H x z))).mpr\n    (.mul h1 h2))) h\n\n"}
{"name":"AddCon.comap_conGen_equiv","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nrel : N → N → Prop\n⊢ Eq (AddCon.comap ⇑f ⋯ (addConGen rel)) (addConGen fun x y => rel (f x) (f y))","decl":"@[to_additive]\ntheorem comap_conGen_equiv {M N : Type*} [Mul M] [Mul N] (f : MulEquiv M N) (rel : N → N → Prop) :\n    Con.comap f (map_mul f) (conGen rel) = conGen (fun x y ↦ rel (f x) (f y)) := by\n  apply le_antisymm _ (le_comap_conGen f (map_mul f) rel)\n  intro a b h\n  simp only [Con.comap_rel] at h\n  have H : ∀ n1 n2, (conGen rel) n1 n2 → ∀ a b, f a = n1 → f b = n2 →\n      (conGen fun x y ↦ rel (f x) (f y)) a b := by\n    intro n1 n2 h\n    induction h with\n    | of x y h =>\n      intro _ _ fa fb\n      apply ConGen.Rel.of\n      rwa [fa, fb]\n    | refl x =>\n      intro _ _ fc fd\n      rw [f.injective (fc.trans fd.symm)]\n      exact ConGen.Rel.refl _\n    | symm _ h => exact fun a b fs fb ↦ ConGen.Rel.symm (h b a fb fs)\n    | trans _ _ ih ih1 =>\n      exact fun a b fa fb ↦ Exists.casesOn (f.surjective _) fun c' hc' ↦\n      ConGen.Rel.trans (ih a c' fa hc') (ih1 c' b hc' fb)\n    | mul _ _ ih ih1 =>\n      rename_i w x y z _ _\n      intro a b fa fb\n      rw [← f.eq_symm_apply, map_mul] at fa fb\n      rw [fa, fb]\n      exact ConGen.Rel.mul (ih (f.symm w) (f.symm x) (by simp) (by simp))\n        (ih1 (f.symm y) (f.symm z) (by simp) (by simp))\n  exact H (f a) (f b) h a b (refl _) (refl _)\n\n"}
{"name":"Con.comap_conGen_equiv","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nrel : N → N → Prop\n⊢ Eq (Con.comap ⇑f ⋯ (conGen rel)) (conGen fun x y => rel (f x) (f y))","decl":"@[to_additive]\ntheorem comap_conGen_equiv {M N : Type*} [Mul M] [Mul N] (f : MulEquiv M N) (rel : N → N → Prop) :\n    Con.comap f (map_mul f) (conGen rel) = conGen (fun x y ↦ rel (f x) (f y)) := by\n  apply le_antisymm _ (le_comap_conGen f (map_mul f) rel)\n  intro a b h\n  simp only [Con.comap_rel] at h\n  have H : ∀ n1 n2, (conGen rel) n1 n2 → ∀ a b, f a = n1 → f b = n2 →\n      (conGen fun x y ↦ rel (f x) (f y)) a b := by\n    intro n1 n2 h\n    induction h with\n    | of x y h =>\n      intro _ _ fa fb\n      apply ConGen.Rel.of\n      rwa [fa, fb]\n    | refl x =>\n      intro _ _ fc fd\n      rw [f.injective (fc.trans fd.symm)]\n      exact ConGen.Rel.refl _\n    | symm _ h => exact fun a b fs fb ↦ ConGen.Rel.symm (h b a fb fs)\n    | trans _ _ ih ih1 =>\n      exact fun a b fa fb ↦ Exists.casesOn (f.surjective _) fun c' hc' ↦\n      ConGen.Rel.trans (ih a c' fa hc') (ih1 c' b hc' fb)\n    | mul _ _ ih ih1 =>\n      rename_i w x y z _ _\n      intro a b fa fb\n      rw [← f.eq_symm_apply, map_mul] at fa fb\n      rw [fa, fb]\n      exact ConGen.Rel.mul (ih (f.symm w) (f.symm x) (by simp) (by simp))\n        (ih1 (f.symm y) (f.symm z) (by simp) (by simp))\n  exact H (f a) (f b) h a b (refl _) (refl _)\n\n"}
{"name":"Con.comap_conGen_of_bijective","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : M → N\nhf : Function.Bijective f\nH : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nrel : N → N → Prop\n⊢ Eq (Con.comap f H (conGen rel)) (conGen fun x y => rel (f x) (f y))","decl":"@[to_additive]\ntheorem comap_conGen_of_bijective {M N : Type*} [Mul M] [Mul N] (f : M → N)\n    (hf : Function.Bijective f) (H : ∀ (x y : M), f (x * y) = f x * f y) (rel : N → N → Prop) :\n    Con.comap f H (conGen rel) = conGen (fun x y ↦ rel (f x) (f y)) :=\n  comap_conGen_equiv (MulEquiv.ofBijective (MulHom.mk f H) hf) rel\n\n"}
{"name":"AddCon.comap_conGen_of_bijective","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : M → N\nhf : Function.Bijective f\nH : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nrel : N → N → Prop\n⊢ Eq (AddCon.comap f H (addConGen rel)) (addConGen fun x y => rel (f x) (f y))","decl":"@[to_additive]\ntheorem comap_conGen_of_bijective {M N : Type*} [Mul M] [Mul N] (f : M → N)\n    (hf : Function.Bijective f) (H : ∀ (x y : M), f (x * y) = f x * f y) (rel : N → N → Prop) :\n    Con.comap f H (conGen rel) = conGen (fun x y ↦ rel (f x) (f y)) :=\n  comap_conGen_equiv (MulEquiv.ofBijective (MulHom.mk f H) hf) rel\n\n"}
{"name":"Con.mem_coe","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nc : Con M\nx y : M\n⊢ Iff (Membership.mem ↑c { fst := x, snd := y }) (Membership.mem c { fst := x, snd := y })","decl":"@[to_additive]\ntheorem mem_coe {c : Con M} {x y} : (x, y) ∈ (↑c : Submonoid (M × M)) ↔ (x, y) ∈ c :=\n  Iff.rfl\n\n"}
{"name":"AddCon.mem_coe","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nc : AddCon M\nx y : M\n⊢ Iff (Membership.mem ↑c { fst := x, snd := y }) (Membership.mem c { fst := x, snd := y })","decl":"@[to_additive]\ntheorem mem_coe {c : Con M} {x y} : (x, y) ∈ (↑c : Submonoid (M × M)) ↔ (x, y) ∈ c :=\n  Iff.rfl\n\n"}
{"name":"Con.to_submonoid_inj","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nc d : Con M\nH : Eq ↑c ↑d\n⊢ Eq c d","decl":"@[to_additive]\ntheorem to_submonoid_inj (c d : Con M) (H : (c : Submonoid (M × M)) = d) : c = d :=\n  ext fun x y => show (x, y) ∈ c.submonoid ↔ (x, y) ∈ d from H ▸ Iff.rfl\n\n"}
{"name":"AddCon.to_addSubmonoid_inj","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nc d : AddCon M\nH : Eq ↑c ↑d\n⊢ Eq c d","decl":"@[to_additive]\ntheorem to_submonoid_inj (c d : Con M) (H : (c : Submonoid (M × M)) = d) : c = d :=\n  ext fun x y => show (x, y) ∈ c.submonoid ↔ (x, y) ∈ d from H ▸ Iff.rfl\n\n"}
{"name":"Con.le_iff","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nc d : Con M\n⊢ Iff (LE.le c d) (LE.le ↑c ↑d)","decl":"@[to_additive]\ntheorem le_iff {c d : Con M} : c ≤ d ↔ (c : Submonoid (M × M)) ≤ d :=\n  ⟨fun h _ H => h H, fun h x y hc => h <| show (x, y) ∈ c from hc⟩\n\n"}
{"name":"AddCon.le_iff","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nc d : AddCon M\n⊢ Iff (LE.le c d) (LE.le ↑c ↑d)","decl":"@[to_additive]\ntheorem le_iff {c d : Con M} : c ≤ d ↔ (c : Submonoid (M × M)) ≤ d :=\n  ⟨fun h _ H => h H, fun h x y hc => h <| show (x, y) ∈ c from hc⟩\n\n"}
{"name":"Con.mrange_mk'","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nc : Con M\n⊢ Eq (MonoidHom.mrange c.mk') Top.top","decl":"@[to_additive (attr := simp)]\n-- Porting note: removed dot notation\ntheorem mrange_mk' : MonoidHom.mrange c.mk' = ⊤ :=\n  MonoidHom.mrange_eq_top.2 mk'_surjective\n\n"}
{"name":"AddCon.mrange_mk'","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nc : AddCon M\n⊢ Eq (AddMonoidHom.mrange c.mk') Top.top","decl":"@[to_additive (attr := simp)]\n-- Porting note: removed dot notation\ntheorem mrange_mk' : MonoidHom.mrange c.mk' = ⊤ :=\n  MonoidHom.mrange_eq_top.2 mk'_surjective\n\n"}
{"name":"Con.lift_range","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass P\nc : Con M\nf : MonoidHom M P\nH : LE.le c (Con.ker f)\n⊢ Eq (MonoidHom.mrange (c.lift f H)) (MonoidHom.mrange f)","decl":"/-- Given a congruence relation `c` on a monoid and a homomorphism `f` constant on `c`'s\n    equivalence classes, `f` has the same image as the homomorphism that `f` induces on the\n    quotient. -/\n@[to_additive \"Given an additive congruence relation `c` on an `AddMonoid` and a homomorphism `f`\nconstant on `c`'s equivalence classes, `f` has the same image as the homomorphism that `f` induces\non the quotient.\"]\ntheorem lift_range (H : c ≤ ker f) : MonoidHom.mrange (c.lift f H) = MonoidHom.mrange f :=\n  Submonoid.ext fun x => ⟨by rintro ⟨⟨y⟩, hy⟩; exact ⟨y, hy⟩, fun ⟨y, hy⟩ => ⟨↑y, hy⟩⟩\n\n"}
{"name":"AddCon.lift_range","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass P\nc : AddCon M\nf : AddMonoidHom M P\nH : LE.le c (AddCon.ker f)\n⊢ Eq (AddMonoidHom.mrange (c.lift f H)) (AddMonoidHom.mrange f)","decl":"/-- Given a congruence relation `c` on a monoid and a homomorphism `f` constant on `c`'s\n    equivalence classes, `f` has the same image as the homomorphism that `f` induces on the\n    quotient. -/\n@[to_additive \"Given an additive congruence relation `c` on an `AddMonoid` and a homomorphism `f`\nconstant on `c`'s equivalence classes, `f` has the same image as the homomorphism that `f` induces\non the quotient.\"]\ntheorem lift_range (H : c ≤ ker f) : MonoidHom.mrange (c.lift f H) = MonoidHom.mrange f :=\n  Submonoid.ext fun x => ⟨by rintro ⟨⟨y⟩, hy⟩; exact ⟨y, hy⟩, fun ⟨y, hy⟩ => ⟨↑y, hy⟩⟩\n\n"}
{"name":"Con.kerLift_range_eq","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass P\nf : MonoidHom M P\n⊢ Eq (MonoidHom.mrange (Con.kerLift f)) (MonoidHom.mrange f)","decl":"/-- Given a monoid homomorphism `f`, the induced homomorphism on the quotient by `f`'s kernel has\n    the same image as `f`. -/\n@[to_additive (attr := simp) \"Given an `AddMonoid` homomorphism `f`, the induced homomorphism\non the quotient by `f`'s kernel has the same image as `f`.\"]\ntheorem kerLift_range_eq : MonoidHom.mrange (kerLift f) = MonoidHom.mrange f :=\n  lift_range fun _ _ => id\n\n"}
{"name":"AddCon.kerLift_range_eq","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass P\nf : AddMonoidHom M P\n⊢ Eq (AddMonoidHom.mrange (AddCon.kerLift f)) (AddMonoidHom.mrange f)","decl":"/-- Given a monoid homomorphism `f`, the induced homomorphism on the quotient by `f`'s kernel has\n    the same image as `f`. -/\n@[to_additive (attr := simp) \"Given an `AddMonoid` homomorphism `f`, the induced homomorphism\non the quotient by `f`'s kernel has the same image as `f`.\"]\ntheorem kerLift_range_eq : MonoidHom.mrange (kerLift f) = MonoidHom.mrange f :=\n  lift_range fun _ _ => id\n\n"}
{"name":"AddCon.quotientKerEquivOfRightInverse_symm_apply","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass P\nf : AddMonoidHom M P\ng : P → M\nhf : Function.RightInverse g ⇑f\na✝ : P\n⊢ Eq ((AddCon.quotientKerEquivOfRightInverse f g hf).symm a✝) (Function.comp AddCon.toQuotient g a✝)","decl":"/-- The first isomorphism theorem for monoids in the case of a homomorphism with right inverse. -/\n@[to_additive (attr := simps)\n  \"The first isomorphism theorem for `AddMonoid`s in the case of a homomorphism\n  with right inverse.\"]\ndef quotientKerEquivOfRightInverse (f : M →* P) (g : P → M) (hf : Function.RightInverse g f) :\n    (ker f).Quotient ≃* P :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := (↑) ∘ g\n    left_inv := fun x => kerLift_injective _ (by rw [Function.comp_apply, kerLift_mk, hf])\n    right_inv := fun x => by (conv_rhs => rw [← hf x]); rfl }\n\n"}
{"name":"Con.quotientKerEquivOfRightInverse_apply","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass P\nf : MonoidHom M P\ng : P → M\nhf : Function.RightInverse g ⇑f\na : (Con.ker f).Quotient\n⊢ Eq ((Con.quotientKerEquivOfRightInverse f g hf) a) ((Con.kerLift f) a)","decl":"/-- The first isomorphism theorem for monoids in the case of a homomorphism with right inverse. -/\n@[to_additive (attr := simps)\n  \"The first isomorphism theorem for `AddMonoid`s in the case of a homomorphism\n  with right inverse.\"]\ndef quotientKerEquivOfRightInverse (f : M →* P) (g : P → M) (hf : Function.RightInverse g f) :\n    (ker f).Quotient ≃* P :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := (↑) ∘ g\n    left_inv := fun x => kerLift_injective _ (by rw [Function.comp_apply, kerLift_mk, hf])\n    right_inv := fun x => by (conv_rhs => rw [← hf x]); rfl }\n\n"}
{"name":"Con.quotientKerEquivOfRightInverse_symm_apply","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass P\nf : MonoidHom M P\ng : P → M\nhf : Function.RightInverse g ⇑f\na✝ : P\n⊢ Eq ((Con.quotientKerEquivOfRightInverse f g hf).symm a✝) (Function.comp Con.toQuotient g a✝)","decl":"/-- The first isomorphism theorem for monoids in the case of a homomorphism with right inverse. -/\n@[to_additive (attr := simps)\n  \"The first isomorphism theorem for `AddMonoid`s in the case of a homomorphism\n  with right inverse.\"]\ndef quotientKerEquivOfRightInverse (f : M →* P) (g : P → M) (hf : Function.RightInverse g f) :\n    (ker f).Quotient ≃* P :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := (↑) ∘ g\n    left_inv := fun x => kerLift_injective _ (by rw [Function.comp_apply, kerLift_mk, hf])\n    right_inv := fun x => by (conv_rhs => rw [← hf x]); rfl }\n\n"}
{"name":"AddCon.quotientKerEquivOfRightInverse_apply","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nP : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass P\nf : AddMonoidHom M P\ng : P → M\nhf : Function.RightInverse g ⇑f\na : (AddCon.ker f).Quotient\n⊢ Eq ((AddCon.quotientKerEquivOfRightInverse f g hf) a) ((AddCon.kerLift f) a)","decl":"/-- The first isomorphism theorem for monoids in the case of a homomorphism with right inverse. -/\n@[to_additive (attr := simps)\n  \"The first isomorphism theorem for `AddMonoid`s in the case of a homomorphism\n  with right inverse.\"]\ndef quotientKerEquivOfRightInverse (f : M →* P) (g : P → M) (hf : Function.RightInverse g f) :\n    (ker f).Quotient ≃* P :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := (↑) ∘ g\n    left_inv := fun x => kerLift_injective _ (by rw [Function.comp_apply, kerLift_mk, hf])\n    right_inv := fun x => by (conv_rhs => rw [← hf x]); rfl }\n\n"}
{"name":"AddCon.comapQuotientEquivOfSurj_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nc : AddCon M\nf : AddMonoidHom N M\nhf : Function.Surjective ⇑f\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj f hf) ↑x) ↑(f x)","decl":"@[to_additive (attr := simp)]\nlemma comapQuotientEquivOfSurj_mk (c : Con M) {f : N →* M} (hf : Function.Surjective f) (x : N) :\n    comapQuotientEquivOfSurj c f hf x = f x := rfl\n\n"}
{"name":"Con.comapQuotientEquivOfSurj_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nc : Con M\nf : MonoidHom N M\nhf : Function.Surjective ⇑f\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj f hf) ↑x) ↑(f x)","decl":"@[to_additive (attr := simp)]\nlemma comapQuotientEquivOfSurj_mk (c : Con M) {f : N →* M} (hf : Function.Surjective f) (x : N) :\n    comapQuotientEquivOfSurj c f hf x = f x := rfl\n\n"}
{"name":"AddCon.comapQuotientEquivOfSurj_symm_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nc : AddCon M\nf : AddMonoidHom N M\nhf : Function.Surjective ⇑f\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj f hf).symm ↑(f x)) ↑x","decl":"@[to_additive (attr := simp)]\nlemma comapQuotientEquivOfSurj_symm_mk (c : Con M) {f : N →* M} (hf) (x : N) :\n    (comapQuotientEquivOfSurj c f hf).symm (f x) = x :=\n  (MulEquiv.symm_apply_eq (c.comapQuotientEquivOfSurj f hf)).mpr rfl\n\n"}
{"name":"Con.comapQuotientEquivOfSurj_symm_mk","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nc : Con M\nf : MonoidHom N M\nhf : Function.Surjective ⇑f\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj f hf).symm ↑(f x)) ↑x","decl":"@[to_additive (attr := simp)]\nlemma comapQuotientEquivOfSurj_symm_mk (c : Con M) {f : N →* M} (hf) (x : N) :\n    (comapQuotientEquivOfSurj c f hf).symm (f x) = x :=\n  (MulEquiv.symm_apply_eq (c.comapQuotientEquivOfSurj f hf)).mpr rfl\n\n"}
{"name":"Con.comapQuotientEquivOfSurj_symm_mk'","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nc : Con M\nf : MulEquiv N M\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj ↑f ⋯).symm (Quotient.mk c.toSetoid (f x))) ↑x","decl":"/-- This version infers the surjectivity of the function from a MulEquiv function -/\n@[to_additive (attr := simp) \"This version infers the surjectivity of the function from a\nMulEquiv function\"]\nlemma comapQuotientEquivOfSurj_symm_mk' (c : Con M) (f : N ≃* M) (x : N) :\n    ((@MulEquiv.symm (Con.Quotient (comap ⇑f _ c)) _ _ _\n      (comapQuotientEquivOfSurj c (f : N →* M) f.surjective)) ⟦f x⟧) = ↑x :=\n  (MulEquiv.symm_apply_eq (@comapQuotientEquivOfSurj M N _ _ c f _)).mpr rfl\n\n"}
{"name":"AddCon.comapQuotientEquivOfSurj_symm_mk'","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nc : AddCon M\nf : AddEquiv N M\nx : N\n⊢ Eq ((c.comapQuotientEquivOfSurj ↑f ⋯).symm (Quotient.mk c.toSetoid (f x))) ↑x","decl":"/-- This version infers the surjectivity of the function from a MulEquiv function -/\n@[to_additive (attr := simp) \"This version infers the surjectivity of the function from a\nMulEquiv function\"]\nlemma comapQuotientEquivOfSurj_symm_mk' (c : Con M) (f : N ≃* M) (x : N) :\n    ((@MulEquiv.symm (Con.Quotient (comap ⇑f _ c)) _ _ _\n      (comapQuotientEquivOfSurj c (f : N →* M) f.surjective)) ⟦f x⟧) = ↑x :=\n  (MulEquiv.symm_apply_eq (@comapQuotientEquivOfSurj M N _ _ c f _)).mpr rfl\n\n"}
{"name":"Con.smul","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"α : Type u_4\nM : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : SMul α M\ninst✝ : IsScalarTower α M M\nc : Con M\na : α\nw x : M\nh : c w x\n⊢ c (HSMul.hSMul a w) (HSMul.hSMul a x)","decl":"@[to_additive]\ntheorem smul {α M : Type*} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M) (a : α)\n    {w x : M} (h : c w x) : c (a • w) (a • x) := by\n  simpa only [smul_one_mul] using c.mul (c.refl' (a • (1 : M) : M)) h\n\n"}
{"name":"AddCon.vadd","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"α : Type u_4\nM : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : VAdd α M\ninst✝ : VAddAssocClass α M M\nc : AddCon M\na : α\nw x : M\nh : c w x\n⊢ c (HVAdd.hVAdd a w) (HVAdd.hVAdd a x)","decl":"@[to_additive]\ntheorem smul {α M : Type*} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M) (a : α)\n    {w x : M} (h : c w x) : c (a • w) (a • x) := by\n  simpa only [smul_one_mul] using c.mul (c.refl' (a • (1 : M) : M)) h\n\n"}
{"name":"AddCon.coe_vadd","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"α : Type u_4\nM : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : VAdd α M\ninst✝ : VAddAssocClass α M M\nc : AddCon M\na : α\nx : M\n⊢ Eq (↑(HVAdd.hVAdd a x)) (HVAdd.hVAdd a ↑x)","decl":"@[to_additive]\ntheorem coe_smul {α M : Type*} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M)\n    (a : α) (x : M) : (↑(a • x) : c.Quotient) = a • (x : c.Quotient) :=\n  rfl\n\n"}
{"name":"Con.coe_smul","module":"Mathlib.GroupTheory.Congruence.Basic","initialProofState":"α : Type u_4\nM : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : SMul α M\ninst✝ : IsScalarTower α M M\nc : Con M\na : α\nx : M\n⊢ Eq (↑(HSMul.hSMul a x)) (HSMul.hSMul a ↑x)","decl":"@[to_additive]\ntheorem coe_smul {α M : Type*} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M)\n    (a : α) (x : M) : (↑(a • x) : c.Quotient) = a • (x : c.Quotient) :=\n  rfl\n\n"}
