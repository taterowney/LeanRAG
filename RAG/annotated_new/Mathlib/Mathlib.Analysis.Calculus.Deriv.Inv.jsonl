{"name":"hasStrictDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nhx : Ne x 0\n⊢ HasStrictDerivAt Inv.inv (Neg.neg (Inv.inv (HPow.hPow x 2))) x","decl":"theorem hasStrictDerivAt_inv (hx : x ≠ 0) : HasStrictDerivAt Inv.inv (-(x ^ 2)⁻¹) x := by\n  suffices\n    (fun p : 𝕜 × 𝕜 => (p.1 - p.2) * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p =>\n      (p.1 - p.2) * 1 by\n    refine .of_isLittleO <| this.congr' ?_ (Eventually.of_forall fun _ => mul_one _)\n    refine Eventually.mono ((isOpen_ne.prod isOpen_ne).mem_nhds ⟨hx, hx⟩) ?_\n    rintro ⟨y, z⟩ ⟨hy, hz⟩\n    simp only [mem_setOf_eq] at hy hz\n    -- hy : y ≠ 0, hz : z ≠ 0\n    field_simp [hx, hy, hz]\n    ring\n  refine (isBigO_refl (fun p : 𝕜 × 𝕜 => p.1 - p.2) _).mul_isLittleO ((isLittleO_one_iff 𝕜).2 ?_)\n  rw [← sub_self (x * x)⁻¹]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).inv₀ <| mul_ne_zero hx hx)\n\n"}
{"name":"hasDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nx_ne_zero : Ne x 0\n⊢ HasDerivAt (fun y => Inv.inv y) (Neg.neg (Inv.inv (HPow.hPow x 2))) x","decl":"theorem hasDerivAt_inv (x_ne_zero : x ≠ 0) : HasDerivAt (fun y => y⁻¹) (-(x ^ 2)⁻¹) x :=\n  (hasStrictDerivAt_inv x_ne_zero).hasDerivAt\n\n"}
{"name":"hasDerivWithinAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nx_ne_zero : Ne x 0\ns : Set 𝕜\n⊢ HasDerivWithinAt (fun x => Inv.inv x) (Neg.neg (Inv.inv (HPow.hPow x 2))) s x","decl":"theorem hasDerivWithinAt_inv (x_ne_zero : x ≠ 0) (s : Set 𝕜) :\n    HasDerivWithinAt (fun x => x⁻¹) (-(x ^ 2)⁻¹) s x :=\n  (hasDerivAt_inv x_ne_zero).hasDerivWithinAt\n\n"}
{"name":"differentiableAt_inv_iff","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => Inv.inv x) x) (Ne x 0)","decl":"theorem differentiableAt_inv_iff : DifferentiableAt 𝕜 (fun x => x⁻¹) x ↔ x ≠ 0 :=\n  ⟨fun H => NormedField.continuousAt_inv.1 H.continuousAt, fun H =>\n    (hasDerivAt_inv H).differentiableAt⟩\n\n"}
{"name":"deriv_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Eq (deriv (fun x => Inv.inv x) x) (Neg.neg (Inv.inv (HPow.hPow x 2)))","decl":"theorem deriv_inv : deriv (fun x => x⁻¹) x = -(x ^ 2)⁻¹ := by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  · simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv_iff.1 (not_not.2 rfl))]\n  · exact (hasDerivAt_inv hne).deriv\n\n"}
{"name":"deriv_inv'","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Eq (deriv fun x => Inv.inv x) fun x => Neg.neg (Inv.inv (HPow.hPow x 2))","decl":"@[simp]\ntheorem deriv_inv' : (deriv fun x : 𝕜 => x⁻¹) = fun x => -(x ^ 2)⁻¹ :=\n  funext fun _ => deriv_inv\n\n"}
{"name":"derivWithin_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nx_ne_zero : Ne x 0\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (derivWithin (fun x => Inv.inv x) s x) (Neg.neg (Inv.inv (HPow.hPow x 2)))","decl":"theorem derivWithin_inv (x_ne_zero : x ≠ 0) (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    derivWithin (fun x => x⁻¹) s x = -(x ^ 2)⁻¹ := by\n  rw [DifferentiableAt.derivWithin (differentiableAt_inv x_ne_zero) hxs]\n  exact deriv_inv\n\n"}
{"name":"hasFDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nx_ne_zero : Ne x 0\n⊢ HasFDerivAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) x","decl":"theorem hasFDerivAt_inv (x_ne_zero : x ≠ 0) :\n    HasFDerivAt (fun x => x⁻¹) (smulRight (1 : 𝕜 →L[𝕜] 𝕜) (-(x ^ 2)⁻¹) : 𝕜 →L[𝕜] 𝕜) x :=\n  hasDerivAt_inv x_ne_zero\n\n"}
{"name":"hasStrictFDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nx_ne_zero : Ne x 0\n⊢ HasStrictFDerivAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) x","decl":"theorem hasStrictFDerivAt_inv (x_ne_zero : x ≠ 0) :\n    HasStrictFDerivAt (fun x => x⁻¹) (smulRight (1 : 𝕜 →L[𝕜] 𝕜) (-(x ^ 2)⁻¹) : 𝕜 →L[𝕜] 𝕜) x :=\n  hasStrictDerivAt_inv x_ne_zero\n\n"}
{"name":"hasFDerivWithinAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nx_ne_zero : Ne x 0\n⊢ HasFDerivWithinAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) s x","decl":"theorem hasFDerivWithinAt_inv (x_ne_zero : x ≠ 0) :\n    HasFDerivWithinAt (fun x => x⁻¹) (smulRight (1 : 𝕜 →L[𝕜] 𝕜) (-(x ^ 2)⁻¹) : 𝕜 →L[𝕜] 𝕜) s x :=\n  (hasFDerivAt_inv x_ne_zero).hasFDerivWithinAt\n\n"}
{"name":"fderiv_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Eq (fderiv 𝕜 (fun x => Inv.inv x) x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2))))","decl":"theorem fderiv_inv : fderiv 𝕜 (fun x => x⁻¹) x = smulRight (1 : 𝕜 →L[𝕜] 𝕜) (-(x ^ 2)⁻¹) := by\n  rw [← deriv_fderiv, deriv_inv]\n\n"}
{"name":"fderivWithin_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nx_ne_zero : Ne x 0\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x => Inv.inv x) s x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2))))","decl":"theorem fderivWithin_inv (x_ne_zero : x ≠ 0) (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x => x⁻¹) s x = smulRight (1 : 𝕜 →L[𝕜] 𝕜) (-(x ^ 2)⁻¹) := by\n  rw [DifferentiableAt.fderivWithin (differentiableAt_inv x_ne_zero) hxs]\n  exact fderiv_inv\n\n"}
{"name":"HasDerivWithinAt.inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nc : 𝕜 → 𝕜\nc' : 𝕜\nhc : HasDerivWithinAt c c' s x\nhx : Ne (c x) 0\n⊢ HasDerivWithinAt (fun y => Inv.inv (c y)) (HDiv.hDiv (Neg.neg c') (HPow.hPow (c x) 2)) s x","decl":"theorem HasDerivWithinAt.inv (hc : HasDerivWithinAt c c' s x) (hx : c x ≠ 0) :\n    HasDerivWithinAt (fun y => (c y)⁻¹) (-c' / c x ^ 2) s x := by\n  convert (hasDerivAt_inv hx).comp_hasDerivWithinAt x hc using 1\n  field_simp\n\n"}
{"name":"HasDerivAt.inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nc : 𝕜 → 𝕜\nc' : 𝕜\nhc : HasDerivAt c c' x\nhx : Ne (c x) 0\n⊢ HasDerivAt (fun y => Inv.inv (c y)) (HDiv.hDiv (Neg.neg c') (HPow.hPow (c x) 2)) x","decl":"theorem HasDerivAt.inv (hc : HasDerivAt c c' x) (hx : c x ≠ 0) :\n    HasDerivAt (fun y => (c y)⁻¹) (-c' / c x ^ 2) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.inv hx\n\n"}
{"name":"derivWithin_inv'","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nc : 𝕜 → 𝕜\nhc : DifferentiableWithinAt 𝕜 c s x\nhx : Ne (c x) 0\n⊢ Eq (derivWithin (fun x => Inv.inv (c x)) s x) (HDiv.hDiv (Neg.neg (derivWithin c s x)) (HPow.hPow (c x) 2))","decl":"theorem derivWithin_inv' (hc : DifferentiableWithinAt 𝕜 c s x) (hx : c x ≠ 0) :\n    derivWithin (fun x => (c x)⁻¹) s x = -derivWithin c s x / c x ^ 2 := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.inv hx).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_inv''","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nc : 𝕜 → 𝕜\nhc : DifferentiableAt 𝕜 c x\nhx : Ne (c x) 0\n⊢ Eq (deriv (fun x => Inv.inv (c x)) x) (HDiv.hDiv (Neg.neg (deriv c x)) (HPow.hPow (c x) 2))","decl":"@[simp]\ntheorem deriv_inv'' (hc : DifferentiableAt 𝕜 c x) (hx : c x ≠ 0) :\n    deriv (fun x => (c x)⁻¹) x = -deriv c x / c x ^ 2 :=\n  (hc.hasDerivAt.inv hx).deriv\n\n"}
{"name":"HasDerivWithinAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nc' d' : 𝕜'\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\nhx : Ne (d x) 0\n⊢ HasDerivWithinAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) s x","decl":"theorem HasDerivWithinAt.div (hc : HasDerivWithinAt c c' s x) (hd : HasDerivWithinAt d d' s x)\n    (hx : d x ≠ 0) :\n    HasDerivWithinAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) s x := by\n  convert hc.mul ((hasDerivAt_inv hx).comp_hasDerivWithinAt x hd) using 1\n  · simp only [div_eq_mul_inv, (· ∘ ·)]\n  · field_simp\n    ring\n\n"}
{"name":"HasStrictDerivAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nc' d' : 𝕜'\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\nhx : Ne (d x) 0\n⊢ HasStrictDerivAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) x","decl":"theorem HasStrictDerivAt.div (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x)\n    (hx : d x ≠ 0) : HasStrictDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x := by\n  convert hc.mul ((hasStrictDerivAt_inv hx).comp x hd) using 1\n  · simp only [div_eq_mul_inv, (· ∘ ·)]\n  · field_simp\n    ring\n\n"}
{"name":"HasDerivAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nc' d' : 𝕜'\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\nhx : Ne (d x) 0\n⊢ HasDerivAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) x","decl":"theorem HasDerivAt.div (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) (hx : d x ≠ 0) :\n    HasDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.div hd hx\n\n"}
{"name":"DifferentiableWithinAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\nhx : Ne (d x) 0\n⊢ DifferentiableWithinAt 𝕜 (fun x => HDiv.hDiv (c x) (d x)) s x","decl":"theorem DifferentiableWithinAt.div (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) (hx : d x ≠ 0) :\n    DifferentiableWithinAt 𝕜 (fun x => c x / d x) s x :=\n  (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\nhx : Ne (d x) 0\n⊢ DifferentiableAt 𝕜 (fun x => HDiv.hDiv (c x) (d x)) x","decl":"@[simp]\ntheorem DifferentiableAt.div (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x)\n    (hx : d x ≠ 0) : DifferentiableAt 𝕜 (fun x => c x / d x) x :=\n  (hc.hasDerivAt.div hd.hasDerivAt hx).differentiableAt\n\n"}
{"name":"DifferentiableOn.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\ns : Set 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : DifferentiableOn 𝕜 c s\nhd : DifferentiableOn 𝕜 d s\nhx : ∀ (x : 𝕜), Membership.mem s x → Ne (d x) 0\n⊢ DifferentiableOn 𝕜 (fun x => HDiv.hDiv (c x) (d x)) s","decl":"theorem DifferentiableOn.div (hc : DifferentiableOn 𝕜 c s) (hd : DifferentiableOn 𝕜 d s)\n    (hx : ∀ x ∈ s, d x ≠ 0) : DifferentiableOn 𝕜 (fun x => c x / d x) s := fun x h =>\n  (hc x h).div (hd x h) (hx x h)\n\n"}
{"name":"Differentiable.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : Differentiable 𝕜 c\nhd : Differentiable 𝕜 d\nhx : ∀ (x : 𝕜), Ne (d x) 0\n⊢ Differentiable 𝕜 fun x => HDiv.hDiv (c x) (d x)","decl":"@[simp]\ntheorem Differentiable.div (hc : Differentiable 𝕜 c) (hd : Differentiable 𝕜 d) (hx : ∀ x, d x ≠ 0) :\n    Differentiable 𝕜 fun x => c x / d x := fun x => (hc x).div (hd x) (hx x)\n\n"}
{"name":"derivWithin_div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\nhx : Ne (d x) 0\n⊢ Eq (derivWithin (fun x => HDiv.hDiv (c x) (d x)) s x) (HDiv.hDiv (HSub.hSub (HMul.hMul (derivWithin c s x) (d x)) (HMul.hMul (c x) (derivWithin d s x))) (HPow.hPow (d x) 2))","decl":"theorem derivWithin_div (hc : DifferentiableWithinAt 𝕜 c s x) (hd : DifferentiableWithinAt 𝕜 d s x)\n    (hx : d x ≠ 0) :\n    derivWithin (fun x => c x / d x) s x =\n      (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2 := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc d : 𝕜 → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\nhx : Ne (d x) 0\n⊢ Eq (deriv (fun x => HDiv.hDiv (c x) (d x)) x) (HDiv.hDiv (HSub.hSub (HMul.hMul (deriv c x) (d x)) (HMul.hMul (c x) (deriv d x))) (HPow.hPow (d x) 2))","decl":"@[simp]\ntheorem deriv_div (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) (hx : d x ≠ 0) :\n    deriv (fun x => c x / d x) x = (deriv c x * d x - c x * deriv d x) / d x ^ 2 :=\n  (hc.hasDerivAt.div hd.hasDerivAt hx).deriv\n\n"}
