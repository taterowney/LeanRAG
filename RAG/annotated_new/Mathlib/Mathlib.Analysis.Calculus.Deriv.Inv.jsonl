{"name":"hasStrictDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nhx : Ne x 0\nâŠ¢ HasStrictDerivAt Inv.inv (Neg.neg (Inv.inv (HPow.hPow x 2))) x","decl":"theorem hasStrictDerivAt_inv (hx : x â‰  0) : HasStrictDerivAt Inv.inv (-(x ^ 2)â»Â¹) x := by\n  suffices\n    (fun p : ğ•œ Ã— ğ•œ => (p.1 - p.2) * ((x * x)â»Â¹ - (p.1 * p.2)â»Â¹)) =o[ğ“ (x, x)] fun p =>\n      (p.1 - p.2) * 1 by\n    refine .of_isLittleO <| this.congr' ?_ (Eventually.of_forall fun _ => mul_one _)\n    refine Eventually.mono ((isOpen_ne.prod isOpen_ne).mem_nhds âŸ¨hx, hxâŸ©) ?_\n    rintro âŸ¨y, zâŸ© âŸ¨hy, hzâŸ©\n    simp only [mem_setOf_eq] at hy hz\n    -- hy : y â‰  0, hz : z â‰  0\n    field_simp [hx, hy, hz]\n    ring\n  refine (isBigO_refl (fun p : ğ•œ Ã— ğ•œ => p.1 - p.2) _).mul_isLittleO ((isLittleO_one_iff ğ•œ).2 ?_)\n  rw [â† sub_self (x * x)â»Â¹]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).invâ‚€ <| mul_ne_zero hx hx)\n\n"}
{"name":"hasDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nx_ne_zero : Ne x 0\nâŠ¢ HasDerivAt (fun y => Inv.inv y) (Neg.neg (Inv.inv (HPow.hPow x 2))) x","decl":"theorem hasDerivAt_inv (x_ne_zero : x â‰  0) : HasDerivAt (fun y => yâ»Â¹) (-(x ^ 2)â»Â¹) x :=\n  (hasStrictDerivAt_inv x_ne_zero).hasDerivAt\n\n"}
{"name":"hasDerivWithinAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nx_ne_zero : Ne x 0\ns : Set ğ•œ\nâŠ¢ HasDerivWithinAt (fun x => Inv.inv x) (Neg.neg (Inv.inv (HPow.hPow x 2))) s x","decl":"theorem hasDerivWithinAt_inv (x_ne_zero : x â‰  0) (s : Set ğ•œ) :\n    HasDerivWithinAt (fun x => xâ»Â¹) (-(x ^ 2)â»Â¹) s x :=\n  (hasDerivAt_inv x_ne_zero).hasDerivWithinAt\n\n"}
{"name":"differentiableAt_inv_iff","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Iff (DifferentiableAt ğ•œ (fun x => Inv.inv x) x) (Ne x 0)","decl":"theorem differentiableAt_inv_iff : DifferentiableAt ğ•œ (fun x => xâ»Â¹) x â†” x â‰  0 :=\n  âŸ¨fun H => NormedField.continuousAt_inv.1 H.continuousAt, fun H =>\n    (hasDerivAt_inv H).differentiableAtâŸ©\n\n"}
{"name":"deriv_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Eq (deriv (fun x => Inv.inv x) x) (Neg.neg (Inv.inv (HPow.hPow x 2)))","decl":"theorem deriv_inv : deriv (fun x => xâ»Â¹) x = -(x ^ 2)â»Â¹ := by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  Â· simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv_iff.1 (not_not.2 rfl))]\n  Â· exact (hasDerivAt_inv hne).deriv\n\n"}
{"name":"deriv_inv'","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ Eq (deriv fun x => Inv.inv x) fun x => Neg.neg (Inv.inv (HPow.hPow x 2))","decl":"@[simp]\ntheorem deriv_inv' : (deriv fun x : ğ•œ => xâ»Â¹) = fun x => -(x ^ 2)â»Â¹ :=\n  funext fun _ => deriv_inv\n\n"}
{"name":"derivWithin_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nx_ne_zero : Ne x 0\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (derivWithin (fun x => Inv.inv x) s x) (Neg.neg (Inv.inv (HPow.hPow x 2)))","decl":"theorem derivWithin_inv (x_ne_zero : x â‰  0) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    derivWithin (fun x => xâ»Â¹) s x = -(x ^ 2)â»Â¹ := by\n  rw [DifferentiableAt.derivWithin (differentiableAt_inv x_ne_zero) hxs]\n  exact deriv_inv\n\n"}
{"name":"hasFDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nx_ne_zero : Ne x 0\nâŠ¢ HasFDerivAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) x","decl":"theorem hasFDerivAt_inv (x_ne_zero : x â‰  0) :\n    HasFDerivAt (fun x => xâ»Â¹) (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) : ğ•œ â†’L[ğ•œ] ğ•œ) x :=\n  hasDerivAt_inv x_ne_zero\n\n"}
{"name":"hasStrictFDerivAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nx_ne_zero : Ne x 0\nâŠ¢ HasStrictFDerivAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) x","decl":"theorem hasStrictFDerivAt_inv (x_ne_zero : x â‰  0) :\n    HasStrictFDerivAt (fun x => xâ»Â¹) (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) : ğ•œ â†’L[ğ•œ] ğ•œ) x :=\n  hasStrictDerivAt_inv x_ne_zero\n\n"}
{"name":"hasFDerivWithinAt_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nx_ne_zero : Ne x 0\nâŠ¢ HasFDerivWithinAt (fun x => Inv.inv x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2)))) s x","decl":"theorem hasFDerivWithinAt_inv (x_ne_zero : x â‰  0) :\n    HasFDerivWithinAt (fun x => xâ»Â¹) (smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) : ğ•œ â†’L[ğ•œ] ğ•œ) s x :=\n  (hasFDerivAt_inv x_ne_zero).hasFDerivWithinAt\n\n"}
{"name":"fderiv_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Eq (fderiv ğ•œ (fun x => Inv.inv x) x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2))))","decl":"theorem fderiv_inv : fderiv ğ•œ (fun x => xâ»Â¹) x = smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) := by\n  rw [â† deriv_fderiv, deriv_inv]\n\n"}
{"name":"fderivWithin_inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nx_ne_zero : Ne x 0\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => Inv.inv x) s x) (ContinuousLinearMap.smulRight 1 (Neg.neg (Inv.inv (HPow.hPow x 2))))","decl":"theorem fderivWithin_inv (x_ne_zero : x â‰  0) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x => xâ»Â¹) s x = smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) (-(x ^ 2)â»Â¹) := by\n  rw [DifferentiableAt.fderivWithin (differentiableAt_inv x_ne_zero) hxs]\n  exact fderiv_inv\n\n"}
{"name":"HasDerivWithinAt.inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nc : ğ•œ â†’ ğ•œ\nc' : ğ•œ\nhc : HasDerivWithinAt c c' s x\nhx : Ne (c x) 0\nâŠ¢ HasDerivWithinAt (fun y => Inv.inv (c y)) (HDiv.hDiv (Neg.neg c') (HPow.hPow (c x) 2)) s x","decl":"theorem HasDerivWithinAt.inv (hc : HasDerivWithinAt c c' s x) (hx : c x â‰  0) :\n    HasDerivWithinAt (fun y => (c y)â»Â¹) (-c' / c x ^ 2) s x := by\n  convert (hasDerivAt_inv hx).comp_hasDerivWithinAt x hc using 1\n  field_simp\n\n"}
{"name":"HasDerivAt.inv","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nc : ğ•œ â†’ ğ•œ\nc' : ğ•œ\nhc : HasDerivAt c c' x\nhx : Ne (c x) 0\nâŠ¢ HasDerivAt (fun y => Inv.inv (c y)) (HDiv.hDiv (Neg.neg c') (HPow.hPow (c x) 2)) x","decl":"theorem HasDerivAt.inv (hc : HasDerivAt c c' x) (hx : c x â‰  0) :\n    HasDerivAt (fun y => (c y)â»Â¹) (-c' / c x ^ 2) x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.inv hx\n\n"}
{"name":"derivWithin_inv'","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nc : ğ•œ â†’ ğ•œ\nhc : DifferentiableWithinAt ğ•œ c s x\nhx : Ne (c x) 0\nâŠ¢ Eq (derivWithin (fun x => Inv.inv (c x)) s x) (HDiv.hDiv (Neg.neg (derivWithin c s x)) (HPow.hPow (c x) 2))","decl":"theorem derivWithin_inv' (hc : DifferentiableWithinAt ğ•œ c s x) (hx : c x â‰  0) :\n    derivWithin (fun x => (c x)â»Â¹) s x = -derivWithin c s x / c x ^ 2 := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.inv hx).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_inv''","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nc : ğ•œ â†’ ğ•œ\nhc : DifferentiableAt ğ•œ c x\nhx : Ne (c x) 0\nâŠ¢ Eq (deriv (fun x => Inv.inv (c x)) x) (HDiv.hDiv (Neg.neg (deriv c x)) (HPow.hPow (c x) 2))","decl":"@[simp]\ntheorem deriv_inv'' (hc : DifferentiableAt ğ•œ c x) (hx : c x â‰  0) :\n    deriv (fun x => (c x)â»Â¹) x = -deriv c x / c x ^ 2 :=\n  (hc.hasDerivAt.inv hx).deriv\n\n"}
{"name":"HasDerivWithinAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nc' d' : ğ•œ'\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\nhx : Ne (d x) 0\nâŠ¢ HasDerivWithinAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) s x","decl":"theorem HasDerivWithinAt.div (hc : HasDerivWithinAt c c' s x) (hd : HasDerivWithinAt d d' s x)\n    (hx : d x â‰  0) :\n    HasDerivWithinAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) s x := by\n  convert hc.mul ((hasDerivAt_inv hx).comp_hasDerivWithinAt x hd) using 1\n  Â· simp only [div_eq_mul_inv, (Â· âˆ˜ Â·)]\n  Â· field_simp\n    ring\n\n"}
{"name":"HasStrictDerivAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nc' d' : ğ•œ'\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\nhx : Ne (d x) 0\nâŠ¢ HasStrictDerivAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) x","decl":"theorem HasStrictDerivAt.div (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x)\n    (hx : d x â‰  0) : HasStrictDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x := by\n  convert hc.mul ((hasStrictDerivAt_inv hx).comp x hd) using 1\n  Â· simp only [div_eq_mul_inv, (Â· âˆ˜ Â·)]\n  Â· field_simp\n    ring\n\n"}
{"name":"HasDerivAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nc' d' : ğ•œ'\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\nhx : Ne (d x) 0\nâŠ¢ HasDerivAt (fun y => HDiv.hDiv (c y) (d y)) (HDiv.hDiv (HSub.hSub (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) (HPow.hPow (d x) 2)) x","decl":"theorem HasDerivAt.div (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) (hx : d x â‰  0) :\n    HasDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.div hd hx\n\n"}
{"name":"DifferentiableWithinAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nhx : Ne (d x) 0\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => HDiv.hDiv (c x) (d x)) s x","decl":"theorem DifferentiableWithinAt.div (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) (hx : d x â‰  0) :\n    DifferentiableWithinAt ğ•œ (fun x => c x / d x) s x :=\n  (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nhx : Ne (d x) 0\nâŠ¢ DifferentiableAt ğ•œ (fun x => HDiv.hDiv (c x) (d x)) x","decl":"@[simp]\ntheorem DifferentiableAt.div (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x)\n    (hx : d x â‰  0) : DifferentiableAt ğ•œ (fun x => c x / d x) x :=\n  (hc.hasDerivAt.div hd.hasDerivAt hx).differentiableAt\n\n"}
{"name":"DifferentiableOn.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : DifferentiableOn ğ•œ c s\nhd : DifferentiableOn ğ•œ d s\nhx : âˆ€ (x : ğ•œ), Membership.mem s x â†’ Ne (d x) 0\nâŠ¢ DifferentiableOn ğ•œ (fun x => HDiv.hDiv (c x) (d x)) s","decl":"theorem DifferentiableOn.div (hc : DifferentiableOn ğ•œ c s) (hd : DifferentiableOn ğ•œ d s)\n    (hx : âˆ€ x âˆˆ s, d x â‰  0) : DifferentiableOn ğ•œ (fun x => c x / d x) s := fun x h =>\n  (hc x h).div (hd x h) (hx x h)\n\n"}
{"name":"Differentiable.div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : Differentiable ğ•œ c\nhd : Differentiable ğ•œ d\nhx : âˆ€ (x : ğ•œ), Ne (d x) 0\nâŠ¢ Differentiable ğ•œ fun x => HDiv.hDiv (c x) (d x)","decl":"@[simp]\ntheorem Differentiable.div (hc : Differentiable ğ•œ c) (hd : Differentiable ğ•œ d) (hx : âˆ€ x, d x â‰  0) :\n    Differentiable ğ•œ fun x => c x / d x := fun x => (hc x).div (hd x) (hx x)\n\n"}
{"name":"derivWithin_div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nhx : Ne (d x) 0\nâŠ¢ Eq (derivWithin (fun x => HDiv.hDiv (c x) (d x)) s x) (HDiv.hDiv (HSub.hSub (HMul.hMul (derivWithin c s x) (d x)) (HMul.hMul (c x) (derivWithin d s x))) (HPow.hPow (d x) 2))","decl":"theorem derivWithin_div (hc : DifferentiableWithinAt ğ•œ c s x) (hd : DifferentiableWithinAt ğ•œ d s x)\n    (hx : d x â‰  0) :\n    derivWithin (fun x => c x / d x) s x =\n      (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2 := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_div","module":"Mathlib.Analysis.Calculus.Deriv.Inv","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc d : ğ•œ â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nhx : Ne (d x) 0\nâŠ¢ Eq (deriv (fun x => HDiv.hDiv (c x) (d x)) x) (HDiv.hDiv (HSub.hSub (HMul.hMul (deriv c x) (d x)) (HMul.hMul (c x) (deriv d x))) (HPow.hPow (d x) 2))","decl":"@[simp]\ntheorem deriv_div (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) (hx : d x â‰  0) :\n    deriv (fun x => c x / d x) x = (deriv c x * d x - c x * deriv d x) / d x ^ 2 :=\n  (hc.hasDerivAt.div hd.hasDerivAt hx).deriv\n\n"}
