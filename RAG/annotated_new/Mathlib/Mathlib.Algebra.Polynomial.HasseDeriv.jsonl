{"name":"Polynomial.hasseDeriv_apply","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.hasseDeriv k) f) (f.sum fun i r => (Polynomial.monomial (HSub.hSub i k)) (HMul.hMul (↑(i.choose k)) r))","decl":"theorem hasseDeriv_apply :\n    hasseDeriv k f = f.sum fun i r => monomial (i - k) (↑(i.choose k) * r) := by\n  dsimp [hasseDeriv]\n  congr; ext; congr\n  apply nsmul_eq_mul\n\n"}
{"name":"Polynomial.hasseDeriv_coeff","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nf : Polynomial R\nn : Nat\n⊢ Eq (((Polynomial.hasseDeriv k) f).coeff n) (HMul.hMul (↑((HAdd.hAdd n k).choose k)) (f.coeff (HAdd.hAdd n k)))","decl":"theorem hasseDeriv_coeff (n : ℕ) :\n    (hasseDeriv k f).coeff n = (n + k).choose k * f.coeff (n + k) := by\n  rw [hasseDeriv_apply, coeff_sum, sum_def, Finset.sum_eq_single (n + k), coeff_monomial]\n  · simp only [if_true, add_tsub_cancel_right, eq_self_iff_true]\n  · intro i _hi hink\n    rw [coeff_monomial]\n    by_cases hik : i < k\n    · simp only [Nat.choose_eq_zero_of_lt hik, ite_self, Nat.cast_zero, zero_mul]\n    · push_neg at hik\n      rw [if_neg]\n      contrapose! hink\n      exact (tsub_eq_iff_eq_add_of_le hik).mp hink\n  · intro h\n    simp only [not_mem_support_iff.mp h, monomial_zero_right, mul_zero, coeff_zero]\n\n"}
{"name":"Polynomial.hasseDeriv_zero'","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq ((Polynomial.hasseDeriv 0) f) f","decl":"theorem hasseDeriv_zero' : hasseDeriv 0 f = f := by\n  simp only [hasseDeriv_apply, tsub_zero, Nat.choose_zero_right, Nat.cast_one, one_mul,\n    sum_monomial_eq]\n\n"}
{"name":"Polynomial.hasseDeriv_zero","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.hasseDeriv 0) LinearMap.id","decl":"@[simp]\ntheorem hasseDeriv_zero : @hasseDeriv R _ 0 = LinearMap.id :=\n  LinearMap.ext <| hasseDeriv_zero'\n\n"}
{"name":"Polynomial.hasseDeriv_eq_zero_of_lt_natDegree","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nh : LT.lt p.natDegree n\n⊢ Eq ((Polynomial.hasseDeriv n) p) 0","decl":"theorem hasseDeriv_eq_zero_of_lt_natDegree (p : R[X]) (n : ℕ) (h : p.natDegree < n) :\n    hasseDeriv n p = 0 := by\n  rw [hasseDeriv_apply, sum_def]\n  refine Finset.sum_eq_zero fun x hx => ?_\n  simp [Nat.choose_eq_zero_of_lt ((le_natDegree_of_mem_supp _ hx).trans_lt h)]\n\n"}
{"name":"Polynomial.hasseDeriv_one'","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq ((Polynomial.hasseDeriv 1) f) (Polynomial.derivative f)","decl":"theorem hasseDeriv_one' : hasseDeriv 1 f = derivative f := by\n  simp only [hasseDeriv_apply, derivative_apply, ← C_mul_X_pow_eq_monomial, Nat.choose_one_right,\n    (Nat.cast_commute _ _).eq]\n\n"}
{"name":"Polynomial.hasseDeriv_one","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.hasseDeriv 1) Polynomial.derivative","decl":"@[simp]\ntheorem hasseDeriv_one : @hasseDeriv R _ 1 = derivative :=\n  LinearMap.ext <| hasseDeriv_one'\n\n"}
{"name":"Polynomial.hasseDeriv_monomial","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk n : Nat\nr : R\n⊢ Eq ((Polynomial.hasseDeriv k) ((Polynomial.monomial n) r)) ((Polynomial.monomial (HSub.hSub n k)) (HMul.hMul (↑(n.choose k)) r))","decl":"@[simp]\ntheorem hasseDeriv_monomial (n : ℕ) (r : R) :\n    hasseDeriv k (monomial n r) = monomial (n - k) (↑(n.choose k) * r) := by\n  ext i\n  simp only [hasseDeriv_coeff, coeff_monomial]\n  by_cases hnik : n = i + k\n  · rw [if_pos hnik, if_pos, ← hnik]\n    apply tsub_eq_of_eq_add_rev\n    rwa [add_comm]\n  · rw [if_neg hnik, mul_zero]\n    by_cases hkn : k ≤ n\n    · rw [← tsub_eq_iff_eq_add_of_le hkn] at hnik\n      rw [if_neg hnik]\n    · push_neg at hkn\n      rw [Nat.choose_eq_zero_of_lt hkn, Nat.cast_zero, zero_mul, ite_self]\n\n"}
{"name":"Polynomial.hasseDeriv_C","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nr : R\nhk : LT.lt 0 k\n⊢ Eq ((Polynomial.hasseDeriv k) (Polynomial.C r)) 0","decl":"theorem hasseDeriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0 := by\n  rw [← monomial_zero_left, hasseDeriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero,\n    zero_mul, monomial_zero_right]\n\n"}
{"name":"Polynomial.hasseDeriv_apply_one","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nhk : LT.lt 0 k\n⊢ Eq ((Polynomial.hasseDeriv k) 1) 0","decl":"theorem hasseDeriv_apply_one (hk : 0 < k) : hasseDeriv k (1 : R[X]) = 0 := by\n  rw [← C_1, hasseDeriv_C k _ hk]\n\n"}
{"name":"Polynomial.hasseDeriv_X","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nhk : LT.lt 1 k\n⊢ Eq ((Polynomial.hasseDeriv k) Polynomial.X) 0","decl":"theorem hasseDeriv_X (hk : 1 < k) : hasseDeriv k (X : R[X]) = 0 := by\n  rw [← monomial_one_one_eq_X, hasseDeriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero,\n    zero_mul, monomial_zero_right]\n\n"}
{"name":"Polynomial.factorial_smul_hasseDeriv","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\n⊢ Eq (⇑(HSMul.hSMul k.factorial (Polynomial.hasseDeriv k))) (Nat.iterate (⇑Polynomial.derivative) k)","decl":"theorem factorial_smul_hasseDeriv : ⇑(k ! • @hasseDeriv R _ k) = (@derivative R _)^[k] := by\n  induction' k with k ih\n  · rw [hasseDeriv_zero, factorial_zero, iterate_zero, one_smul, LinearMap.id_coe]\n  ext f n : 2\n  rw [iterate_succ_apply', ← ih]\n  simp only [LinearMap.smul_apply, coeff_smul, LinearMap.map_smul_of_tower, coeff_derivative,\n    hasseDeriv_coeff, ← @choose_symm_add _ k]\n  simp only [nsmul_eq_mul, factorial_succ, mul_assoc, succ_eq_add_one, ← add_assoc,\n    add_right_comm n 1 k, ← cast_succ]\n  rw [← (cast_commute (n + 1) (f.coeff (n + k + 1))).eq]\n  simp only [← mul_assoc]\n  norm_cast\n  congr 2\n  rw [mul_comm (k+1) _, mul_assoc, mul_assoc]\n  congr 1\n  have : n + k + 1 = n + (k + 1) := by apply add_assoc\n  rw [← choose_symm_of_eq_add this, choose_succ_right_eq, mul_comm]\n  congr\n  rw [add_assoc, add_tsub_cancel_left]\n\n"}
{"name":"Polynomial.hasseDeriv_comp","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk l : Nat\n⊢ Eq ((Polynomial.hasseDeriv k).comp (Polynomial.hasseDeriv l)) (HSMul.hSMul ((HAdd.hAdd k l).choose k) (Polynomial.hasseDeriv (HAdd.hAdd k l)))","decl":"theorem hasseDeriv_comp (k l : ℕ) :\n    (@hasseDeriv R _ k).comp (hasseDeriv l) = (k + l).choose k • hasseDeriv (k + l) := by\n  ext i : 2\n  simp only [LinearMap.smul_apply, comp_apply, LinearMap.coe_comp, smul_monomial, hasseDeriv_apply,\n    mul_one, monomial_eq_zero_iff, sum_monomial_index, mul_zero, ←\n    tsub_add_eq_tsub_tsub, add_comm l k]\n  rw_mod_cast [nsmul_eq_mul]\n  rw [← Nat.cast_mul]\n  congr 2\n  by_cases hikl : i < k + l\n  · rw [choose_eq_zero_of_lt hikl, mul_zero]\n    by_cases hil : i < l\n    · rw [choose_eq_zero_of_lt hil, mul_zero]\n    · push_neg at hil\n      rw [← tsub_lt_iff_right hil] at hikl\n      rw [choose_eq_zero_of_lt hikl, zero_mul]\n  push_neg at hikl\n  apply @cast_injective ℚ\n  have h1 : l ≤ i := le_of_add_le_right hikl\n  have h2 : k ≤ i - l := le_tsub_of_add_le_right hikl\n  have h3 : k ≤ k + l := le_self_add\n  push_cast\n  rw [cast_choose ℚ h1, cast_choose ℚ h2, cast_choose ℚ h3, cast_choose ℚ hikl]\n  rw [show i - (k + l) = i - l - k by rw [add_comm]; apply tsub_add_eq_tsub_tsub]\n  simp only [add_tsub_cancel_left]\n  field_simp; ring\n\n"}
{"name":"Polynomial.natDegree_hasseDeriv_le","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ LE.le ((Polynomial.hasseDeriv n) p).natDegree (HSub.hSub p.natDegree n)","decl":"theorem natDegree_hasseDeriv_le (p : R[X]) (n : ℕ) :\n    natDegree (hasseDeriv n p) ≤ natDegree p - n := by\n  classical\n    rw [hasseDeriv_apply, sum_def]\n    refine (natDegree_sum_le _ _).trans ?_\n    simp_rw [Function.comp, natDegree_monomial]\n    rw [Finset.fold_ite, Finset.fold_const]\n    · simp only [ite_self, max_eq_right, zero_le', Finset.fold_max_le, true_and, and_imp,\n        tsub_le_iff_right, mem_support_iff, Ne, Finset.mem_filter]\n      intro x hx hx'\n      have hxp : x ≤ p.natDegree := le_natDegree_of_ne_zero hx\n      have hxn : n ≤ x := by\n        contrapose! hx'\n        simp [Nat.choose_eq_zero_of_lt hx']\n      rwa [tsub_add_cancel_of_le (hxn.trans hxp)]\n    · simp\n\n"}
{"name":"Polynomial.natDegree_hasseDeriv","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : NoZeroSMulDivisors Nat R\np : Polynomial R\nn : Nat\n⊢ Eq ((Polynomial.hasseDeriv n) p).natDegree (HSub.hSub p.natDegree n)","decl":"theorem natDegree_hasseDeriv [NoZeroSMulDivisors ℕ R] (p : R[X]) (n : ℕ) :\n    natDegree (hasseDeriv n p) = natDegree p - n := by\n  cases' lt_or_le p.natDegree n with hn hn\n  · simpa [hasseDeriv_eq_zero_of_lt_natDegree, hn] using (tsub_eq_zero_of_le hn.le).symm\n  · refine map_natDegree_eq_sub ?_ ?_\n    · exact fun h => hasseDeriv_eq_zero_of_lt_natDegree _ _\n    · classical\n        simp only [ite_eq_right_iff, Ne, natDegree_monomial, hasseDeriv_monomial]\n        intro k c c0 hh\n        -- this is where we use the `smul_eq_zero` from `NoZeroSMulDivisors`\n        rw [← nsmul_eq_mul, smul_eq_zero, Nat.choose_eq_zero_iff] at hh\n        exact (tsub_eq_zero_of_le (Or.resolve_right hh c0).le).symm\n\n"}
{"name":"Polynomial.hasseDeriv_mul","module":"Mathlib.Algebra.Polynomial.HasseDeriv","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk : Nat\nf g : Polynomial R\n⊢ Eq ((Polynomial.hasseDeriv k) (HMul.hMul f g)) ((Finset.HasAntidiagonal.antidiagonal k).sum fun ij => HMul.hMul ((Polynomial.hasseDeriv ij.1) f) ((Polynomial.hasseDeriv ij.2) g))","decl":"theorem hasseDeriv_mul (f g : R[X]) :\n    hasseDeriv k (f * g) = ∑ ij ∈ antidiagonal k, hasseDeriv ij.1 f * hasseDeriv ij.2 g := by\n  let D k := (@hasseDeriv R _ k).toAddMonoidHom\n  let Φ := @AddMonoidHom.mul R[X] _\n  show\n    (compHom (D k)).comp Φ f g =\n      ∑ ij ∈ antidiagonal k, ((compHom.comp ((compHom Φ) (D ij.1))).flip (D ij.2) f) g\n  simp only [← finset_sum_apply]\n  congr 2\n  clear f g\n  ext m r n s : 4\n  simp only [Φ, D, finset_sum_apply, coe_mulLeft, coe_comp, flip_apply, Function.comp_apply,\n             hasseDeriv_monomial, LinearMap.toAddMonoidHom_coe, compHom_apply_apply,\n             coe_mul, monomial_mul_monomial]\n  have aux :\n    ∀ x : ℕ × ℕ,\n      x ∈ antidiagonal k →\n        monomial (m - x.1 + (n - x.2)) (↑(m.choose x.1) * r * (↑(n.choose x.2) * s)) =\n          monomial (m + n - k) (↑(m.choose x.1) * ↑(n.choose x.2) * (r * s)) := by\n    intro x hx\n    rw [mem_antidiagonal] at hx\n    subst hx\n    by_cases hm : m < x.1\n    · simp only [Nat.choose_eq_zero_of_lt hm, Nat.cast_zero, zero_mul,\n                 monomial_zero_right]\n    by_cases hn : n < x.2\n    · simp only [Nat.choose_eq_zero_of_lt hn, Nat.cast_zero, zero_mul,\n                 mul_zero, monomial_zero_right]\n    push_neg at hm hn\n    rw [tsub_add_eq_add_tsub hm, ← add_tsub_assoc_of_le hn, ← tsub_add_eq_tsub_tsub,\n      add_comm x.2 x.1, mul_assoc, ← mul_assoc r, ← (Nat.cast_commute _ r).eq, mul_assoc, mul_assoc]\n  rw [Finset.sum_congr rfl aux]\n  rw [← map_sum, ← Finset.sum_mul]\n  congr\n  rw_mod_cast [← Nat.add_choose_eq]\n\n"}
