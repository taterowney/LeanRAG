{"name":"LieModule.IsTrivial.trivial","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"L : Type v\nM : Type w\ninst✝¹ : Bracket L M\ninst✝ : Zero M\nself : LieModule.IsTrivial L M\nx : L\nm : M\n⊢ Eq (Bracket.bracket x m) 0","decl":"/-- A Lie (ring) module is trivial iff all brackets vanish. -/\nclass LieModule.IsTrivial (L : Type v) (M : Type w) [Bracket L M] [Zero M] : Prop where\n  trivial : ∀ (x : L) (m : M), ⁅x, m⁆ = 0\n\n"}
{"name":"trivial_lie_zero","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"L : Type v\nM : Type w\ninst✝² : Bracket L M\ninst✝¹ : Zero M\ninst✝ : LieModule.IsTrivial L M\nx : L\nm : M\n⊢ Eq (Bracket.bracket x m) 0","decl":"@[simp]\ntheorem trivial_lie_zero (L : Type v) (M : Type w) [Bracket L M] [Zero M] [LieModule.IsTrivial L M]\n    (x : L) (m : M) : ⁅x, m⁆ = 0 :=\n  LieModule.IsTrivial.trivial x m\n\n"}
{"name":"LieModule.instIsTrivialOfSubsingleton","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"L : Type u_1\nM : Type u_2\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : Subsingleton L\n⊢ LieModule.IsTrivial L M","decl":"instance LieModule.instIsTrivialOfSubsingleton {L M : Type*}\n    [LieRing L] [AddCommGroup M] [LieRingModule L M] [Subsingleton L] : LieModule.IsTrivial L M :=\n  ⟨fun x m ↦ by rw [Subsingleton.eq_zero x, zero_lie]⟩\n\n"}
{"name":"LieModule.instIsTrivialOfSubsingleton'","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"L : Type u_1\nM : Type u_2\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : Subsingleton M\n⊢ LieModule.IsTrivial L M","decl":"instance LieModule.instIsTrivialOfSubsingleton' {L M : Type*}\n    [LieRing L] [AddCommGroup M] [LieRingModule L M] [Subsingleton M] : LieModule.IsTrivial L M :=\n  ⟨fun x m ↦ by simp_rw [Subsingleton.eq_zero m, lie_zero]⟩\n\n"}
{"name":"LieIdeal.isLieAbelian_of_trivial","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nh : LieModule.IsTrivial L (Subtype fun x => Membership.mem I x)\n⊢ IsLieAbelian (Subtype fun x => Membership.mem I x)","decl":"instance LieIdeal.isLieAbelian_of_trivial (R : Type u) (L : Type v) [CommRing R] [LieRing L]\n    [LieAlgebra R L] (I : LieIdeal R L) [h : LieModule.IsTrivial L I] : IsLieAbelian I where\n  trivial x y := by apply h.trivial\n\n"}
{"name":"Function.Injective.isLieAbelian","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh₁ : Function.Injective ⇑f\nx✝ : IsLieAbelian L₂\n⊢ IsLieAbelian L₁","decl":"theorem Function.Injective.isLieAbelian {R : Type u} {L₁ : Type v} {L₂ : Type w} [CommRing R]\n    [LieRing L₁] [LieRing L₂] [LieAlgebra R L₁] [LieAlgebra R L₂] {f : L₁ →ₗ⁅R⁆ L₂}\n    (h₁ : Function.Injective f) (_ : IsLieAbelian L₂) : IsLieAbelian L₁ :=\n  { trivial := fun x y => h₁ <|\n      calc\n        f ⁅x, y⁆ = ⁅f x, f y⁆ := LieHom.map_lie f x y\n        _ = 0 := trivial_lie_zero _ _ _ _\n        _ = f 0 := f.map_zero.symm}\n\n"}
{"name":"Function.Surjective.isLieAbelian","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh₁ : Function.Surjective ⇑f\nh₂ : IsLieAbelian L₁\n⊢ IsLieAbelian L₂","decl":"theorem Function.Surjective.isLieAbelian {R : Type u} {L₁ : Type v} {L₂ : Type w} [CommRing R]\n    [LieRing L₁] [LieRing L₂] [LieAlgebra R L₁] [LieAlgebra R L₂] {f : L₁ →ₗ⁅R⁆ L₂}\n    (h₁ : Function.Surjective f) (h₂ : IsLieAbelian L₁) : IsLieAbelian L₂ :=\n  { trivial := fun x y => by\n      obtain ⟨u, rfl⟩ := h₁ x\n      obtain ⟨v, rfl⟩ := h₁ y\n      rw [← LieHom.map_lie, trivial_lie_zero, LieHom.map_zero] }\n\n"}
{"name":"lie_abelian_iff_equiv_lie_abelian","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L₁ L₂\n⊢ Iff (IsLieAbelian L₁) (IsLieAbelian L₂)","decl":"theorem lie_abelian_iff_equiv_lie_abelian {R : Type u} {L₁ : Type v} {L₂ : Type w} [CommRing R]\n    [LieRing L₁] [LieRing L₂] [LieAlgebra R L₁] [LieAlgebra R L₂] (e : L₁ ≃ₗ⁅R⁆ L₂) :\n    IsLieAbelian L₁ ↔ IsLieAbelian L₂ :=\n  ⟨e.symm.injective.isLieAbelian, e.injective.isLieAbelian⟩\n\n"}
{"name":"commutative_ring_iff_abelian_lie_ring","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"A : Type v\ninst✝ : Ring A\n⊢ Iff (Std.Commutative fun x1 x2 => HMul.hMul x1 x2) (IsLieAbelian A)","decl":"theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :\n    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by\n  have h₁ : Std.Commutative (α := A) (· * ·) ↔ ∀ a b : A, a * b = b * a :=\n    ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  have h₂ : IsLieAbelian A ↔ ∀ a b : A, ⁅a, b⁆ = 0 := ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  simp only [h₁, h₂, LieRing.of_associative_ring_bracket, sub_eq_zero]\n\n"}
{"name":"LieModule.mem_ker","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\n⊢ Iff (Membership.mem (LieModule.ker R L M) x) (∀ (m : M), Eq (Bracket.bracket x m) 0)","decl":"@[simp]\nprotected theorem mem_ker (x : L) : x ∈ LieModule.ker R L M ↔ ∀ m : M, ⁅x, m⁆ = 0 := by\n  simp only [LieModule.ker, LieHom.mem_ker, LinearMap.ext_iff, LinearMap.zero_apply,\n    toEnd_apply_apply]\n\n"}
{"name":"LieModule.mem_maxTrivSubmodule","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nm : M\n⊢ Iff (Membership.mem (LieModule.maxTrivSubmodule R L M) m) (∀ (x : L), Eq (Bracket.bracket x m) 0)","decl":"@[simp]\ntheorem mem_maxTrivSubmodule (m : M) : m ∈ maxTrivSubmodule R L M ↔ ∀ x : L, ⁅x, m⁆ = 0 :=\n  Iff.rfl\n\n"}
{"name":"LieModule.instIsTrivialSubtypeMemLieSubmoduleMaxTrivSubmodule","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ LieModule.IsTrivial L (Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L M) x)","decl":"instance : IsTrivial L (maxTrivSubmodule R L M) where trivial x m := Subtype.ext (m.property x)\n\n"}
{"name":"LieModule.ideal_oper_maxTrivSubmodule_eq_bot","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nI : LieIdeal R L\n⊢ Eq (Bracket.bracket I (LieModule.maxTrivSubmodule R L M)) Bot.bot","decl":"@[simp]\ntheorem ideal_oper_maxTrivSubmodule_eq_bot (I : LieIdeal R L) :\n    ⁅I, maxTrivSubmodule R L M⁆ = ⊥ := by\n  rw [← LieSubmodule.toSubmodule_inj, LieSubmodule.lieIdeal_oper_eq_linear_span,\n    LieSubmodule.bot_toSubmodule, Submodule.span_eq_bot]\n  rintro m ⟨⟨x, hx⟩, ⟨⟨m, hm⟩, rfl⟩⟩\n  exact hm x\n\n"}
{"name":"LieModule.le_max_triv_iff_bracket_eq_bot","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\n⊢ Iff (LE.le N (LieModule.maxTrivSubmodule R L M)) (Eq (Bracket.bracket Top.top N) Bot.bot)","decl":"theorem le_max_triv_iff_bracket_eq_bot {N : LieSubmodule R L M} :\n    N ≤ maxTrivSubmodule R L M ↔ ⁅(⊤ : LieIdeal R L), N⁆ = ⊥ := by\n  refine ⟨fun h => ?_, fun h m hm => ?_⟩\n  · rw [← le_bot_iff, ← ideal_oper_maxTrivSubmodule_eq_bot R L M ⊤]\n    exact LieSubmodule.mono_lie_right ⊤ h\n  · rw [mem_maxTrivSubmodule]\n    rw [LieSubmodule.lie_eq_bot_iff] at h\n    exact fun x => h x (LieSubmodule.mem_top x) m hm\n\n"}
{"name":"LieModule.trivial_iff_le_maximal_trivial","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\n⊢ Iff (LieModule.IsTrivial L (Subtype fun x => Membership.mem N x)) (LE.le N (LieModule.maxTrivSubmodule R L M))","decl":"theorem trivial_iff_le_maximal_trivial (N : LieSubmodule R L M) :\n    IsTrivial L N ↔ N ≤ maxTrivSubmodule R L M :=\n  ⟨fun h m hm x => IsTrivial.casesOn h fun h => Subtype.ext_iff.mp (h x ⟨m, hm⟩), fun h =>\n    { trivial := fun x m => Subtype.ext (h m.2 x) }⟩\n\n"}
{"name":"LieModule.isTrivial_iff_max_triv_eq_top","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsTrivial L M) (Eq (LieModule.maxTrivSubmodule R L M) Top.top)","decl":"theorem isTrivial_iff_max_triv_eq_top : IsTrivial L M ↔ maxTrivSubmodule R L M = ⊤ := by\n  constructor\n  · rintro ⟨h⟩; ext; simp only [mem_maxTrivSubmodule, h, forall_const, LieSubmodule.mem_top]\n  · intro h; constructor; intro x m; revert x\n    rw [← mem_maxTrivSubmodule R L M, h]; exact LieSubmodule.mem_top m\n\n"}
{"name":"LieModule.coe_maxTrivHom_apply","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : LieModuleHom R L M N\nm : Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L M) x\n⊢ Eq (↑((LieModule.maxTrivHom f) m)) (f ↑m)","decl":"@[norm_cast, simp]\ntheorem coe_maxTrivHom_apply (f : M →ₗ⁅R,L⁆ N) (m : maxTrivSubmodule R L M) :\n    (maxTrivHom f m : N) = f m :=\n  rfl\n\n"}
{"name":"LieModule.coe_maxTrivEquiv_apply","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\ne : LieModuleEquiv R L M N\nm : Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L M) x\n⊢ Eq (↑((LieModule.maxTrivEquiv e) m)) (e ↑m)","decl":"@[norm_cast, simp]\ntheorem coe_maxTrivEquiv_apply (e : M ≃ₗ⁅R,L⁆ N) (m : maxTrivSubmodule R L M) :\n    (maxTrivEquiv e m : N) = e ↑m :=\n  rfl\n\n"}
{"name":"LieModule.maxTrivEquiv_of_refl_eq_refl","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq (LieModule.maxTrivEquiv LieModuleEquiv.refl) LieModuleEquiv.refl","decl":"@[simp]\ntheorem maxTrivEquiv_of_refl_eq_refl :\n    maxTrivEquiv (LieModuleEquiv.refl : M ≃ₗ⁅R,L⁆ M) = LieModuleEquiv.refl := by\n  ext; simp only [coe_maxTrivEquiv_apply, LieModuleEquiv.refl_apply]\n\n"}
{"name":"LieModule.maxTrivEquiv_of_equiv_symm_eq_symm","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\ne : LieModuleEquiv R L M N\n⊢ Eq (LieModule.maxTrivEquiv e).symm (LieModule.maxTrivEquiv e.symm)","decl":"@[simp]\ntheorem maxTrivEquiv_of_equiv_symm_eq_symm (e : M ≃ₗ⁅R,L⁆ N) :\n    (maxTrivEquiv e).symm = maxTrivEquiv e.symm :=\n  rfl\n\n"}
{"name":"LieModule.coe_maxTrivLinearMapEquivLieModuleHom","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L (LinearMap (RingHom.id R) M N)) x\n⊢ Eq ⇑(LieModule.maxTrivLinearMapEquivLieModuleHom f) ⇑↑f","decl":"@[simp]\ntheorem coe_maxTrivLinearMapEquivLieModuleHom (f : maxTrivSubmodule R L (M →ₗ[R] N)) :\n    (maxTrivLinearMapEquivLieModuleHom (M := M) (N := N) f : M → N) = f := by ext; rfl\n\n"}
{"name":"LieModule.coe_maxTrivLinearMapEquivLieModuleHom_symm","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : LieModuleHom R L M N\n⊢ Eq ⇑↑(LieModule.maxTrivLinearMapEquivLieModuleHom.symm f) ⇑f","decl":"@[simp]\ntheorem coe_maxTrivLinearMapEquivLieModuleHom_symm (f : M →ₗ⁅R,L⁆ N) :\n    (maxTrivLinearMapEquivLieModuleHom (M := M) (N := N) |>.symm f : M → N) = f :=\n  rfl\n\n"}
{"name":"LieModule.toLinearMap_maxTrivLinearMapEquivLieModuleHom","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L (LinearMap (RingHom.id R) M N)) x\n⊢ Eq ↑(LieModule.maxTrivLinearMapEquivLieModuleHom f) ↑f","decl":"@[simp]\ntheorem toLinearMap_maxTrivLinearMapEquivLieModuleHom (f : maxTrivSubmodule R L (M →ₗ[R] N)) :\n    (maxTrivLinearMapEquivLieModuleHom (M := M) (N := N) f : M →ₗ[R] N) = (f : M →ₗ[R] N) := by\n  ext; rfl\n\n"}
{"name":"LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L (LinearMap (RingHom.id R) M N)) x\n⊢ Eq ↑(LieModule.maxTrivLinearMapEquivLieModuleHom f) ↑f","decl":"@[deprecated (since := \"2024-12-30\")]\nalias coe_linearMap_maxTrivLinearMapEquivLieModuleHom :=\n  toLinearMap_maxTrivLinearMapEquivLieModuleHom\n\n"}
{"name":"LieModule.toLinearMap_maxTrivLinearMapEquivLieModuleHom_symm","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : LieModuleHom R L M N\n⊢ Eq ↑(LieModule.maxTrivLinearMapEquivLieModuleHom.symm f) ↑f","decl":"@[simp]\ntheorem toLinearMap_maxTrivLinearMapEquivLieModuleHom_symm (f : M →ₗ⁅R,L⁆ N) :\n    (maxTrivLinearMapEquivLieModuleHom (M := M) (N := N) |>.symm f : M →ₗ[R] N) = (f : M →ₗ[R] N) :=\n  rfl\n\n"}
{"name":"LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom_symm","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nf : LieModuleHom R L M N\n⊢ Eq ↑(LieModule.maxTrivLinearMapEquivLieModuleHom.symm f) ↑f","decl":"@[deprecated (since := \"2024-12-30\")]\nalias coe_linearMap_maxTrivLinearMapEquivLieModuleHom_symm :=\n  toLinearMap_maxTrivLinearMapEquivLieModuleHom_symm\n\n"}
{"name":"LieAlgebra.instIsLieAbelianSubtypeMemLieSubmoduleCenter","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.center R L) x)","decl":"instance : IsLieAbelian (center R L) :=\n  inferInstance\n\n"}
{"name":"LieAlgebra.ad_ker_eq_self_module_ker","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieAlgebra.ad R L).ker (LieModule.ker R L L)","decl":"@[simp]\ntheorem ad_ker_eq_self_module_ker : (ad R L).ker = LieModule.ker R L L :=\n  rfl\n\n"}
{"name":"LieAlgebra.self_module_ker_eq_center","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieModule.ker R L L) (LieAlgebra.center R L)","decl":"@[simp]\ntheorem self_module_ker_eq_center : LieModule.ker R L L = center R L := by\n  ext y\n  simp only [LieModule.mem_maxTrivSubmodule, LieModule.mem_ker, ← lie_skew _ y, neg_eq_zero]\n\n"}
{"name":"LieAlgebra.abelian_of_le_center","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nh : LE.le I (LieAlgebra.center R L)\n⊢ IsLieAbelian (Subtype fun x => Membership.mem I x)","decl":"theorem abelian_of_le_center (I : LieIdeal R L) (h : I ≤ center R L) : IsLieAbelian I :=\n  haveI : LieModule.IsTrivial L I := (LieModule.trivial_iff_le_maximal_trivial R L L I).mpr h\n  LieIdeal.isLieAbelian_of_trivial R L I\n\n"}
{"name":"LieAlgebra.isLieAbelian_iff_center_eq_top","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Iff (IsLieAbelian L) (Eq (LieAlgebra.center R L) Top.top)","decl":"theorem isLieAbelian_iff_center_eq_top : IsLieAbelian L ↔ center R L = ⊤ :=\n  LieModule.isTrivial_iff_max_triv_eq_top R L L\n\n"}
{"name":"LieModule.commute_toEnd_of_mem_center_left","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nhx : Membership.mem (LieAlgebra.center R L) x\ny : L\n⊢ Commute ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y)","decl":"lemma commute_toEnd_of_mem_center_left :\n    Commute (toEnd R L M x) (toEnd R L M y) := by\n  rw [Commute.symm_iff, commute_iff_lie_eq, ← LieHom.map_lie, hx y, LieHom.map_zero]\n\n"}
{"name":"LieModule.commute_toEnd_of_mem_center_right","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nhx : Membership.mem (LieAlgebra.center R L) x\ny : L\n⊢ Commute ((LieModule.toEnd R L M) y) ((LieModule.toEnd R L M) x)","decl":"lemma commute_toEnd_of_mem_center_right :\n    Commute (toEnd R L M y) (toEnd R L M x) :=\n  (LieModule.commute_toEnd_of_mem_center_left M hx y).symm\n\n"}
{"name":"LieSubmodule.trivial_lie_oper_zero","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\nI : LieIdeal R L\ninst✝ : LieModule.IsTrivial L M\n⊢ Eq (Bracket.bracket I N) Bot.bot","decl":"@[simp]\ntheorem LieSubmodule.trivial_lie_oper_zero [LieModule.IsTrivial L M] : ⁅I, N⁆ = ⊥ := by\n  suffices ⁅I, N⁆ ≤ ⊥ from le_bot_iff.mp this\n  rw [lieIdeal_oper_eq_span, LieSubmodule.lieSpan_le]\n  rintro m ⟨x, n, h⟩; rw [trivial_lie_zero] at h; simp [← h]\n\n"}
{"name":"LieSubmodule.lie_abelian_iff_lie_self_eq_bot","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Iff (IsLieAbelian (Subtype fun x => Membership.mem I x)) (Eq (Bracket.bracket I I) Bot.bot)","decl":"theorem LieSubmodule.lie_abelian_iff_lie_self_eq_bot : IsLieAbelian I ↔ ⁅I, I⁆ = ⊥ := by\n  simp only [_root_.eq_bot_iff, lieIdeal_oper_eq_span, LieSubmodule.lieSpan_le,\n    LieSubmodule.bot_coe, Set.subset_singleton_iff, Set.mem_setOf_eq, exists_imp]\n  refine\n    ⟨fun h z x y hz =>\n      hz.symm.trans\n        (((I : LieSubalgebra R L).coe_bracket x y).symm.trans\n          ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))),\n      fun h => ⟨fun x y => ((I : LieSubalgebra R L).coe_zero_iff_zero _).mp (h _ x y rfl)⟩⟩\n\n"}
{"name":"lie_eq_self_of_isAtom_of_ne_bot","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nI : LieIdeal R L\nhN : IsAtom N\nh : Ne (Bracket.bracket I N) Bot.bot\n⊢ Eq (Bracket.bracket I N) N","decl":"variable {I N} in\nlemma lie_eq_self_of_isAtom_of_ne_bot (hN : IsAtom N) (h : ⁅I, N⁆ ≠ ⊥) : ⁅I, N⁆ = N :=\n  (hN.le_iff_eq h).mp <| LieSubmodule.lie_le_right N I\n\n-- TODO: introduce typeclass for perfect Lie algebras and use it here in the conclusion\n"}
{"name":"lie_eq_self_of_isAtom_of_nonabelian","module":"Mathlib.Algebra.Lie.Abelian","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nhI : IsAtom I\nh : Not (IsLieAbelian (Subtype fun x => Membership.mem I x))\n⊢ Eq (Bracket.bracket I I) I","decl":"lemma lie_eq_self_of_isAtom_of_nonabelian {R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]\n    (I : LieIdeal R L) (hI : IsAtom I) (h : ¬IsLieAbelian I) :\n    ⁅I, I⁆ = I :=\n  lie_eq_self_of_isAtom_of_ne_bot hI <| not_imp_not.mpr (lie_abelian_iff_lie_self_eq_bot I).mpr h\n\n"}
