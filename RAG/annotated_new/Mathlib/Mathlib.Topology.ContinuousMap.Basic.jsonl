{"name":"map_continuousAt","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : FunLike F α β\ninst✝ : ContinuousMapClass F α β\nf : F\na : α\n⊢ ContinuousAt (⇑f) a","decl":"theorem map_continuousAt (f : F) (a : α) : ContinuousAt f a :=\n  (map_continuous f).continuousAt\n\n"}
{"name":"map_continuousWithinAt","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : FunLike F α β\ninst✝ : ContinuousMapClass F α β\nf : F\ns : Set α\na : α\n⊢ ContinuousWithinAt (⇑f) s a","decl":"theorem map_continuousWithinAt (f : F) (s : Set α) (a : α) : ContinuousWithinAt f s a :=\n  (map_continuous f).continuousWithinAt\n\n"}
{"name":"ContinuousMap.continuousAt","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\nx : α\n⊢ ContinuousAt (⇑f) x","decl":"/-- Deprecated. Use `map_continuousAt` instead. -/\nprotected theorem continuousAt (f : C(α, β)) (x : α) : ContinuousAt f x :=\n  map_continuousAt f x\n\n"}
{"name":"ContinuousMap.map_specializes","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\nx y : α\nh : Specializes x y\n⊢ Specializes (f x) (f y)","decl":"theorem map_specializes (f : C(α, β)) {x y : α} (h : x ⤳ y) : f x ⤳ f y :=\n  h.map f.2\n\n"}
{"name":"ContinuousMap.equivFnOfDiscrete_symm_apply_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : DiscreteTopology α\nf : α → β\na✝ : α\n⊢ Eq (((ContinuousMap.equivFnOfDiscrete α β).symm f) a✝) (f a✝)","decl":"/--\nThe continuous functions from `α` to `β` are the same as the plain functions when `α` is discrete.\n-/\n@[simps]\ndef equivFnOfDiscrete [DiscreteTopology α] : C(α, β) ≃ (α → β) :=\n  ⟨fun f => f,\n    fun f => ⟨f, continuous_of_discreteTopology⟩,\n    fun _ => by ext; rfl,\n    fun _ => by ext; rfl⟩\n\n"}
{"name":"ContinuousMap.equivFnOfDiscrete_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : DiscreteTopology α\nf : ContinuousMap α β\na : α\n⊢ Eq ((ContinuousMap.equivFnOfDiscrete α β) f a) (f a)","decl":"/--\nThe continuous functions from `α` to `β` are the same as the plain functions when `α` is discrete.\n-/\n@[simps]\ndef equivFnOfDiscrete [DiscreteTopology α] : C(α, β) ≃ (α → β) :=\n  ⟨fun f => f,\n    fun f => ⟨f, continuous_of_discreteTopology⟩,\n    fun _ => by ext; rfl,\n    fun _ => by ext; rfl⟩\n\n"}
{"name":"ContinuousMap.coe_id","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Eq (⇑(ContinuousMap.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(ContinuousMap.id α) = id :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_const","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nb : β\n⊢ Eq (⇑(ContinuousMap.const α b)) (Function.const α b)","decl":"@[simp]\ntheorem coe_const (b : β) : ⇑(const α b) = Function.const α b :=\n  rfl\n\n"}
{"name":"ContinuousMap.constPi_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\n⊢ Eq ⇑(ContinuousMap.constPi α) fun b => Function.const α b","decl":"/-- `Function.const α b` as a bundled continuous function of `b`. -/\n@[simps (config := .asFn)]\ndef constPi : C(β, α → β) where\n  toFun b := Function.const α b\n\n"}
{"name":"ContinuousMap.id_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\na : α\n⊢ Eq ((ContinuousMap.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : ContinuousMap.id α a = a :=\n  rfl\n\n"}
{"name":"ContinuousMap.const_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nb : β\na : α\n⊢ Eq ((ContinuousMap.const α b) a) b","decl":"@[simp]\ntheorem const_apply (b : β) (a : α) : const α b a = b :=\n  rfl\n\n"}
{"name":"ContinuousMap.coe_comp","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap β γ\ng : ContinuousMap α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : C(β, γ)) (g : C(α, β)) : ⇑(comp f g) = f ∘ g :=\n  rfl\n\n"}
{"name":"ContinuousMap.comp_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap β γ\ng : ContinuousMap α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : C(β, γ)) (g : C(α, β)) (a : α) : comp f g a = f (g a) :=\n  rfl\n\n"}
{"name":"ContinuousMap.comp_assoc","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\nf : ContinuousMap γ δ\ng : ContinuousMap β γ\nh : ContinuousMap α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : C(γ, δ)) (g : C(β, γ)) (h : C(α, β)) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"ContinuousMap.id_comp","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\n⊢ Eq ((ContinuousMap.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : C(α, β)) : (ContinuousMap.id _).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousMap.comp_id","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\n⊢ Eq (f.comp (ContinuousMap.id α)) f","decl":"@[simp]\ntheorem comp_id (f : C(α, β)) : f.comp (ContinuousMap.id _) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousMap.const_comp","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nc : γ\nf : ContinuousMap α β\n⊢ Eq ((ContinuousMap.const β c).comp f) (ContinuousMap.const α c)","decl":"@[simp]\ntheorem const_comp (c : γ) (f : C(α, β)) : (const β c).comp f = const α c :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousMap.comp_const","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap β γ\nb : β\n⊢ Eq (f.comp (ContinuousMap.const α b)) (ContinuousMap.const α (f b))","decl":"@[simp]\ntheorem comp_const (f : C(β, γ)) (b : β) : f.comp (const α b) = const α (f b) :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousMap.cancel_right","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf₁ f₂ : ContinuousMap β γ\ng : ContinuousMap α β\nhg : Function.Surjective ⇑g\n⊢ Iff (Eq (f₁.comp g) (f₂.comp g)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_right {f₁ f₂ : C(β, γ)} {g : C(α, β)} (hg : Surjective g) :\n    f₁.comp g = f₂.comp g ↔ f₁ = f₂ :=\n  ⟨fun h => ext <| hg.forall.2 <| DFunLike.ext_iff.1 h, congr_arg (ContinuousMap.comp · g)⟩\n\n"}
{"name":"ContinuousMap.cancel_left","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap β γ\ng₁ g₂ : ContinuousMap α β\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (f.comp g₁) (f.comp g₂)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_left {f : C(β, γ)} {g₁ g₂ : C(α, β)} (hf : Injective f) :\n    f.comp g₁ = f.comp g₂ ↔ g₁ = g₂ :=\n  ⟨fun h => ext fun a => hf <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"ContinuousMap.instNontrivialOfNonempty","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Nonempty α\ninst✝ : Nontrivial β\n⊢ Nontrivial (ContinuousMap α β)","decl":"instance [Nonempty α] [Nontrivial β] : Nontrivial C(α, β) :=\n  ⟨let ⟨b₁, b₂, hb⟩ := exists_pair_ne β\n  ⟨const _ b₁, const _ b₂, fun h => hb <| DFunLike.congr_fun h <| Classical.arbitrary α⟩⟩\n\n"}
{"name":"ContinuousMap.fst_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ Eq (⇑ContinuousMap.fst) Prod.fst","decl":"/-- `Prod.fst : (x, y) ↦ x` as a bundled continuous map. -/\n@[simps (config := .asFn)]\ndef fst : C(α × β, α) where\n  toFun := Prod.fst\n\n"}
{"name":"ContinuousMap.snd_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ Eq (⇑ContinuousMap.snd) Prod.snd","decl":"/-- `Prod.snd : (x, y) ↦ y` as a bundled continuous map. -/\n@[simps (config := .asFn)]\ndef snd : C(α × β, β) where\n  toFun := Prod.snd\n\n"}
{"name":"ContinuousMap.prodMap_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝³ : TopologicalSpace α₁\ninst✝² : TopologicalSpace α₂\ninst✝¹ : TopologicalSpace β₁\ninst✝ : TopologicalSpace β₂\nf : ContinuousMap α₁ α₂\ng : ContinuousMap β₁ β₂\na✝ : Prod α₁ β₁\n⊢ Eq ((f.prodMap g) a✝) (Prod.map (⇑f) (⇑g) a✝)","decl":"/-- Given two continuous maps `f` and `g`, this is the continuous map `(x, y) ↦ (f x, g y)`. -/\n@[simps]\ndef prodMap (f : C(α₁, α₂)) (g : C(β₁, β₂)) : C(α₁ × β₁, α₂ × β₂) where\n  toFun := Prod.map f g\n\n"}
{"name":"ContinuousMap.prod_eval","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝¹ : TopologicalSpace β₁\ninst✝ : TopologicalSpace β₂\nf : ContinuousMap α β₁\ng : ContinuousMap α β₂\na : α\n⊢ Eq ((f.prodMk g) a) { fst := f a, snd := g a }","decl":"@[simp]\ntheorem prod_eval (f : C(α, β₁)) (g : C(α, β₂)) (a : α) : (prodMk f g) a = (f a, g a) :=\n  rfl\n\n"}
{"name":"ContinuousMap.prodSwap_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nx : Prod α β\n⊢ Eq (ContinuousMap.prodSwap x) { fst := x.2, snd := x.1 }","decl":"/-- `Prod.swap` bundled as a `ContinuousMap`. -/\n@[simps!]\ndef prodSwap : C(α × β, β × α) := .prodMk .snd .fst\n\n"}
{"name":"ContinuousMap.sigmaMk_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nX : I → Type u_7\ninst✝ : (i : I) → TopologicalSpace (X i)\ni : I\nsnd : X i\n⊢ Eq ((ContinuousMap.sigmaMk i) snd) ⟨i, snd⟩","decl":"/-- `Sigma.mk i` as a bundled continuous map. -/\n@[simps apply]\ndef sigmaMk (i : I) : C(X i, Σ i, X i) where\n  toFun := Sigma.mk i\n\n"}
{"name":"ContinuousMap.sigma_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : (i : I) → ContinuousMap (X i) A\nig : Sigma fun i => X i\n⊢ Eq ((ContinuousMap.sigma f) ig) ((f ig.fst) ig.snd)","decl":"/--\nTo give a continuous map out of a disjoint union, it suffices to give a continuous map out of\neach term. This is `Sigma.uncurry` for continuous maps.\n-/\n@[simps]\ndef sigma (f : ∀ i, C(X i, A)) : C((Σ i, X i), A) where\n  toFun ig := f ig.fst ig.snd\n\n"}
{"name":"ContinuousMap.sigmaEquiv_symm_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : ContinuousMap (Sigma fun i => X i) A\ni : I\n⊢ Eq ((ContinuousMap.sigmaEquiv A X).symm f i) (f.comp (ContinuousMap.sigmaMk i))","decl":"variable (A X) in\n/--\nGiving a continuous map out of a disjoint union is the same as giving a continuous map out of\neach term. This is a version of `Equiv.piCurry` for continuous maps.\n-/\n@[simps]\ndef sigmaEquiv : (∀ i, C(X i, A)) ≃ C((Σ i, X i), A) where\n  toFun := sigma\n  invFun f i := f.comp (sigmaMk i)\n  left_inv := by intro; ext; simp\n  right_inv := by intro; ext; simp\n\n"}
{"name":"ContinuousMap.sigmaEquiv_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : (i : I) → ContinuousMap (X i) A\n⊢ Eq ((ContinuousMap.sigmaEquiv A X) f) (ContinuousMap.sigma f)","decl":"variable (A X) in\n/--\nGiving a continuous map out of a disjoint union is the same as giving a continuous map out of\neach term. This is a version of `Equiv.piCurry` for continuous maps.\n-/\n@[simps]\ndef sigmaEquiv : (∀ i, C(X i, A)) ≃ C((Σ i, X i), A) where\n  toFun := sigma\n  invFun f i := f.comp (sigmaMk i)\n  left_inv := by intro; ext; simp\n  right_inv := by intro; ext; simp\n\n"}
{"name":"ContinuousMap.pi_eval","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : (i : I) → ContinuousMap A (X i)\na : A\n⊢ Eq ((ContinuousMap.pi f) a) fun i => (f i) a","decl":"@[simp]\ntheorem pi_eval (f : ∀ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=\n  rfl\n\n"}
{"name":"ContinuousMap.eval_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nX : I → Type u_7\ninst✝ : (i : I) → TopologicalSpace (X i)\ni : I\n⊢ Eq (⇑(ContinuousMap.eval i)) (Function.eval i)","decl":"/-- Evaluation at point as a bundled continuous map. -/\n@[simps (config := .asFn)]\ndef eval (i : I) : C(∀ j, X j, X i) where\n  toFun := Function.eval i\n\n"}
{"name":"ContinuousMap.piEquiv_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : (i : I) → ContinuousMap A (X i)\n⊢ Eq ((ContinuousMap.piEquiv A X) f) (ContinuousMap.pi f)","decl":"variable (A X) in\n/--\nGiving a continuous map out of a disjoint union is the same as giving a continuous map out of\neach term\n-/\n@[simps]\ndef piEquiv : (∀ i, C(A, X i)) ≃ C(A, ∀ i, X i) where\n  toFun := pi\n  invFun f i := (eval i).comp f\n  left_inv := by intro; ext; simp [pi]\n  right_inv := by intro; ext; simp [pi]\n\n"}
{"name":"ContinuousMap.piEquiv_symm_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nA : Type u_6\nX : I → Type u_7\ninst✝¹ : TopologicalSpace A\ninst✝ : (i : I) → TopologicalSpace (X i)\nf : ContinuousMap A ((i : I) → X i)\ni : I\n⊢ Eq ((ContinuousMap.piEquiv A X).symm f i) ((ContinuousMap.eval i).comp f)","decl":"variable (A X) in\n/--\nGiving a continuous map out of a disjoint union is the same as giving a continuous map out of\neach term\n-/\n@[simps]\ndef piEquiv : (∀ i, C(A, X i)) ≃ C(A, ∀ i, X i) where\n  toFun := pi\n  invFun f i := (eval i).comp f\n  left_inv := by intro; ext; simp [pi]\n  right_inv := by intro; ext; simp [pi]\n\n"}
{"name":"ContinuousMap.piMap_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"I : Type u_5\nX : I → Type u_7\nY : I → Type u_8\ninst✝¹ : (i : I) → TopologicalSpace (X i)\ninst✝ : (i : I) → TopologicalSpace (Y i)\nf : (i : I) → ContinuousMap (X i) (Y i)\na : (i : I) → X i\ni : I\n⊢ Eq ((ContinuousMap.piMap f) a i) ((f i) (a i))","decl":"/-- Combine a collection of bundled continuous maps `C(X i, Y i)` into a bundled continuous map\n`C(∀ i, X i, ∀ i, Y i)`. -/\n@[simps!]\ndef piMap (f : ∀ i, C(X i, Y i)) : C((i : I) → X i, (i : I) → Y i) :=\n  .pi fun i ↦ (f i).comp (eval i)\n\n"}
{"name":"ContinuousMap.coe_restrict","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nf : ContinuousMap α β\n⊢ Eq (⇑(ContinuousMap.restrict s f)) (Function.comp (⇑f) Subtype.val)","decl":"@[simp]\ntheorem coe_restrict (f : C(α, β)) : ⇑(f.restrict s) = f ∘ ((↑) : s → α) :=\n  rfl\n\n"}
{"name":"ContinuousMap.restrict_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\ns : Set α\nx : ↑s\n⊢ Eq ((ContinuousMap.restrict s f) x) (f ↑x)","decl":"@[simp]\ntheorem restrict_apply (f : C(α, β)) (s : Set α) (x : s) : f.restrict s x = f x :=\n  rfl\n\n"}
{"name":"ContinuousMap.restrict_apply_mk","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\ns : Set α\nx : α\nhx : Membership.mem s x\n⊢ Eq ((ContinuousMap.restrict s f) ⟨x, hx⟩) (f x)","decl":"@[simp]\ntheorem restrict_apply_mk (f : C(α, β)) (s : Set α) (x : α) (hx : x ∈ s) :\n    f.restrict s ⟨x, hx⟩ = f x :=\n  rfl\n\n"}
{"name":"ContinuousMap.injective_restrict","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : T2Space β\ns : Set α\nhs : Dense s\n⊢ Function.Injective (ContinuousMap.restrict s)","decl":"theorem injective_restrict [T2Space β] {s : Set α} (hs : Dense s) :\n    Injective (restrict s : C(α, β) → C(s, β)) := fun f g h ↦\n  DFunLike.ext' <| (map_continuous f).ext_on hs (map_continuous g) <|\n    Set.restrict_eq_restrict_iff.1 <| congr_arg DFunLike.coe h\n\n"}
{"name":"ContinuousMap.restrictPreimage_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\ns : Set β\na✝ : ↑(Set.preimage (⇑f) s)\n⊢ Eq ((f.restrictPreimage s) a✝) (s.restrictPreimage (⇑f) a✝)","decl":"/-- The restriction of a continuous map to the preimage of a set. -/\n@[simps]\ndef restrictPreimage (f : C(α, β)) (s : Set β) : C(f ⁻¹' s, s) :=\n  ⟨s.restrictPreimage f, continuous_iff_continuousAt.mpr fun _ ↦\n    (map_continuousAt f _).restrictPreimage⟩\n\n"}
{"name":"ContinuousMap.liftCover_coe","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nι : Type u_5\nS : ι → Set α\nφ : (i : ι) → ContinuousMap (↑(S i)) β\nhφ : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq ((φ i) ⟨x, hxi⟩) ((φ j) ⟨x, hxj⟩)\nhS : ∀ (x : α), Exists fun i => Membership.mem (nhds x) (S i)\ni : ι\nx : ↑(S i)\n⊢ Eq ((ContinuousMap.liftCover S φ hφ hS) ↑x) ((φ i) x)","decl":"@[simp]\ntheorem liftCover_coe {i : ι} (x : S i) : liftCover S φ hφ hS x = φ i x := by\n  rw [liftCover, coe_mk, Set.liftCover_coe _]\n\n"}
{"name":"ContinuousMap.liftCover_restrict","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nι : Type u_5\nS : ι → Set α\nφ : (i : ι) → ContinuousMap (↑(S i)) β\nhφ : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq ((φ i) ⟨x, hxi⟩) ((φ j) ⟨x, hxj⟩)\nhS : ∀ (x : α), Exists fun i => Membership.mem (nhds x) (S i)\ni : ι\n⊢ Eq (ContinuousMap.restrict (S i) (ContinuousMap.liftCover S φ hφ hS)) (φ i)","decl":"@[simp]\ntheorem liftCover_restrict {i : ι} : (liftCover S φ hφ hS).restrict (S i) = φ i := by\n  ext\n  simp only [coe_restrict, Function.comp_apply, liftCover_coe]\n\n"}
{"name":"ContinuousMap.liftCover_coe'","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nA : Set (Set α)\nF : (s : Set α) → Membership.mem A s → ContinuousMap (↑s) β\nhF : ∀ (s : Set α) (hs : Membership.mem A s) (t : Set α) (ht : Membership.mem A t) (x : α) (hxi : Membership.mem s x) (hxj : Membership.mem t x), Eq ((F s hs) ⟨x, hxi⟩) ((F t ht) ⟨x, hxj⟩)\nhA : ∀ (x : α), Exists fun i => And (Membership.mem A i) (Membership.mem (nhds x) i)\ns : Set α\nhs : Membership.mem A s\nx : ↑s\n⊢ Eq ((ContinuousMap.liftCover' A F hF hA) ↑x) ((F s hs) x)","decl":"@[simp]\ntheorem liftCover_coe' {s : Set α} {hs : s ∈ A} (x : s) : liftCover' A F hF hA x = F s hs x :=\n  let x' : ((↑) : A → Set α) ⟨s, hs⟩ := x\n  by delta liftCover'; exact liftCover_coe x'\n\n-- Porting note: porting program suggested `ext <| liftCover_coe'`\n"}
{"name":"ContinuousMap.liftCover_restrict'","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nA : Set (Set α)\nF : (s : Set α) → Membership.mem A s → ContinuousMap (↑s) β\nhF : ∀ (s : Set α) (hs : Membership.mem A s) (t : Set α) (ht : Membership.mem A t) (x : α) (hxi : Membership.mem s x) (hxj : Membership.mem t x), Eq ((F s hs) ⟨x, hxi⟩) ((F t ht) ⟨x, hxj⟩)\nhA : ∀ (x : α), Exists fun i => And (Membership.mem A i) (Membership.mem (nhds x) i)\ns : Set α\nhs : Membership.mem A s\n⊢ Eq (ContinuousMap.restrict s (ContinuousMap.liftCover' A F hF hA)) (F s hs)","decl":"@[simp]\ntheorem liftCover_restrict' {s : Set α} {hs : s ∈ A} :\n    (liftCover' A F hF hA).restrict s = F s hs := ext <| liftCover_coe' (hF := hF) (hA := hA)\n\n"}
{"name":"Function.RightInverse.homeomorph_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nf' : ContinuousMap Y X\nhf : Function.RightInverse ⇑f' ⇑f\na : Quotient (Setoid.ker ⇑f)\n⊢ Eq (hf.homeomorph a) (a.liftOn' ⇑f ⋯)","decl":"/-- `Setoid.quotientKerEquivOfRightInverse` as a homeomorphism. -/\n@[simps!]\ndef Function.RightInverse.homeomorph {f' : C(Y, X)} (hf : Function.RightInverse f' f) :\n    Quotient (Setoid.ker f) ≃ₜ Y where\n  toEquiv := Setoid.quotientKerEquivOfRightInverse _ _ hf\n  continuous_toFun := isQuotientMap_quot_mk.continuous_iff.mpr (map_continuous f)\n  continuous_invFun := continuous_quotient_mk'.comp (map_continuous f')\n\n"}
{"name":"Function.RightInverse.homeomorph_symm_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nf' : ContinuousMap Y X\nhf : Function.RightInverse ⇑f' ⇑f\nb : Y\n⊢ Eq (hf.homeomorph.symm b) (Quotient.mk'' (f' b))","decl":"/-- `Setoid.quotientKerEquivOfRightInverse` as a homeomorphism. -/\n@[simps!]\ndef Function.RightInverse.homeomorph {f' : C(Y, X)} (hf : Function.RightInverse f' f) :\n    Quotient (Setoid.ker f) ≃ₜ Y where\n  toEquiv := Setoid.quotientKerEquivOfRightInverse _ _ hf\n  continuous_toFun := isQuotientMap_quot_mk.continuous_iff.mpr (map_continuous f)\n  continuous_invFun := continuous_quotient_mk'.comp (map_continuous f')\n\n"}
{"name":"Topology.IsQuotientMap.homeomorph_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\na : Quotient (Setoid.ker ⇑f)\n⊢ Eq (hf.homeomorph a) (a.liftOn' ⇑f ⋯)","decl":"/--\nThe homeomorphism from the quotient of a quotient map to its codomain. This is\n`Setoid.quotientKerEquivOfSurjective` as a homeomorphism.\n-/\n@[simps!]\nnoncomputable def homeomorph (hf : IsQuotientMap f) : Quotient (Setoid.ker f) ≃ₜ Y where\n  toEquiv := Setoid.quotientKerEquivOfSurjective _ hf.surjective\n  continuous_toFun := isQuotientMap_quot_mk.continuous_iff.mpr hf.continuous\n  continuous_invFun := by\n    rw [hf.continuous_iff]\n    convert continuous_quotient_mk'\n    ext\n    simp only [Equiv.invFun_as_coe, Function.comp_apply,\n      (Setoid.quotientKerEquivOfSurjective f hf.surjective).symm_apply_eq]\n    rfl\n\n"}
{"name":"Topology.IsQuotientMap.homeomorph_symm_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\nb : Y\n⊢ Eq (hf.homeomorph.symm b) (Quotient.mk'' (Function.surjInv ⋯ b))","decl":"/--\nThe homeomorphism from the quotient of a quotient map to its codomain. This is\n`Setoid.quotientKerEquivOfSurjective` as a homeomorphism.\n-/\n@[simps!]\nnoncomputable def homeomorph (hf : IsQuotientMap f) : Quotient (Setoid.ker f) ≃ₜ Y where\n  toEquiv := Setoid.quotientKerEquivOfSurjective _ hf.surjective\n  continuous_toFun := isQuotientMap_quot_mk.continuous_iff.mpr hf.continuous\n  continuous_invFun := by\n    rw [hf.continuous_iff]\n    convert continuous_quotient_mk'\n    ext\n    simp only [Equiv.invFun_as_coe, Function.comp_apply,\n      (Setoid.quotientKerEquivOfSurjective f hf.surjective).symm_apply_eq]\n    rfl\n\n"}
{"name":"Topology.IsQuotientMap.lift_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\ng : ContinuousMap X Z\nh : Function.FactorsThrough ⇑g ⇑f\na✝ : Y\n⊢ Eq ((hf.lift g h) a✝) (Function.comp (fun i => i.liftOn' ⇑g ⋯) (⇑hf.homeomorph.symm) a✝)","decl":"/-- Descend a continuous map, which is constant on the fibres, along a quotient map. -/\n@[simps]\nnoncomputable def lift : C(Y, Z) where\n  toFun := ((fun i ↦ Quotient.liftOn' i g (fun _ _ (hab : f _ = f _) ↦ h hab)) :\n    Quotient (Setoid.ker f) → Z) ∘ hf.homeomorph.symm\n  continuous_toFun := Continuous.comp (continuous_quot_lift _ g.2) (Homeomorph.continuous _)\n\n"}
{"name":"Topology.IsQuotientMap.lift_comp","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\ng : ContinuousMap X Z\nh : Function.FactorsThrough ⇑g ⇑f\n⊢ Eq ((hf.lift g h).comp f) g","decl":"/--\nThe obvious triangle induced by `IsQuotientMap.lift` commutes:\n```\n     g\n  X --→ Z\n  |   ↗\nf |  / hf.lift g h\n  v /\n  Y\n```\n-/\n@[simp]\ntheorem lift_comp : (hf.lift g h).comp f = g := by\n  ext\n  simpa using h (Function.rightInverse_surjInv _ _)\n\n"}
{"name":"Topology.IsQuotientMap.liftEquiv_symm_apply_coe","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\ng : ContinuousMap Y Z\n⊢ Eq (↑(hf.liftEquiv.symm g)) (g.comp f)","decl":"/-- `IsQuotientMap.lift` as an equivalence. -/\n@[simps]\nnoncomputable def liftEquiv : { g : C(X, Z) // Function.FactorsThrough g f} ≃ C(Y, Z) where\n  toFun g := hf.lift g g.prop\n  invFun g := ⟨g.comp f, fun _ _ h ↦ by simp only [ContinuousMap.comp_apply]; rw [h]⟩\n  left_inv := by intro; simp\n  right_inv := by\n    intro g\n    ext a\n    simpa using congrArg g (Function.rightInverse_surjInv hf.surjective a)\n\n"}
{"name":"Topology.IsQuotientMap.liftEquiv_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : ContinuousMap X Y\nhf : Topology.IsQuotientMap ⇑f\ng : Subtype fun g => Function.FactorsThrough ⇑g ⇑f\n⊢ Eq (hf.liftEquiv g) (hf.lift ↑g ⋯)","decl":"/-- `IsQuotientMap.lift` as an equivalence. -/\n@[simps]\nnoncomputable def liftEquiv : { g : C(X, Z) // Function.FactorsThrough g f} ≃ C(Y, Z) where\n  toFun g := hf.lift g g.prop\n  invFun g := ⟨g.comp f, fun _ _ h ↦ by simp only [ContinuousMap.comp_apply]; rw [h]⟩\n  left_inv := by intro; simp\n  right_inv := by\n    intro g\n    ext a\n    simpa using congrArg g (Function.rightInverse_surjInv hf.surjective a)\n\n"}
{"name":"Homeomorph.instContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ ContinuousMapClass (Homeomorph α β) α β","decl":"instance instContinuousMapClass : ContinuousMapClass (α ≃ₜ β) α β where\n  map_continuous f := f.continuous_toFun\n\n"}
{"name":"Homeomorph.toContinuousMap_apply","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : Homeomorph α β\na : α\n⊢ Eq (e.toContinuousMap a) (e a)","decl":"/-- The forward direction of a homeomorphism, as a bundled continuous map. -/\n@[simps, deprecated _root_.toContinuousMap (since := \"2024-10-12\")]\nprotected def toContinuousMap (e : α ≃ₜ β) : C(α, β) :=\n  ⟨e, e.continuous_toFun⟩\n\n"}
{"name":"Homeomorph.coe_refl","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Eq (↑(Homeomorph.refl α)) (ContinuousMap.id α)","decl":"@[simp]\ntheorem coe_refl : (Homeomorph.refl α : C(α, α)) = ContinuousMap.id α :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_trans","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : Homeomorph α β\ng : Homeomorph β γ\n⊢ Eq (↑(f.trans g)) ((↑g).comp ↑f)","decl":"@[simp]\ntheorem coe_trans : (f.trans g : C(α, γ)) = (g : C(β, γ)).comp f :=\n  rfl\n\n"}
{"name":"Homeomorph.symm_comp_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : Homeomorph α β\n⊢ Eq ((↑f.symm).comp ↑f) (ContinuousMap.id α)","decl":"/-- Left inverse to a continuous map from a homeomorphism, mirroring `Equiv.symm_comp_self`. -/\n@[simp]\ntheorem symm_comp_toContinuousMap :\n    (f.symm : C(β, α)).comp (f : C(α, β)) = ContinuousMap.id α := by\n  rw [← coe_trans, self_trans_symm, coe_refl]\n\n"}
{"name":"Homeomorph.toContinuousMap_comp_symm","module":"Mathlib.Topology.ContinuousMap.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : Homeomorph α β\n⊢ Eq ((↑f).comp ↑f.symm) (ContinuousMap.id β)","decl":"/-- Right inverse to a continuous map from a homeomorphism, mirroring `Equiv.self_comp_symm`. -/\n@[simp]\ntheorem toContinuousMap_comp_symm :\n    (f : C(α, β)).comp (f.symm : C(β, α)) = ContinuousMap.id β := by\n  rw [← coe_trans, symm_trans_self, coe_refl]\n\n"}
