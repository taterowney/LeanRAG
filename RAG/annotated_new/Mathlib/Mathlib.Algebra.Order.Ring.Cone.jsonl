{"name":"RingConeClass.toSubmonoidClass","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"S : Type u_1\nR : outParam (Type u_2)\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nself : RingConeClass S R\n⊢ SubmonoidClass S R","decl":"/-- `RingConeClass S R` says that `S` is a type of cones in `R`. -/\nclass RingConeClass (S : Type*) (R : outParam Type*) [Ring R] [SetLike S R]\n    extends AddGroupConeClass S R, SubsemiringClass S R : Prop\n\n"}
{"name":"RingConeClass.toSubsemiringClass","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"S : Type u_1\nR : outParam (Type u_2)\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nself : RingConeClass S R\n⊢ SubsemiringClass S R","decl":"/-- `RingConeClass S R` says that `S` is a type of cones in `R`. -/\nclass RingConeClass (S : Type*) (R : outParam Type*) [Ring R] [SetLike S R]\n    extends AddGroupConeClass S R, SubsemiringClass S R : Prop\n\n"}
{"name":"RingConeClass.toAddGroupConeClass","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"S : Type u_1\nR : outParam (Type u_2)\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nself : RingConeClass S R\n⊢ AddGroupConeClass S R","decl":"/-- `RingConeClass S R` says that `S` is a type of cones in `R`. -/\nclass RingConeClass (S : Type*) (R : outParam Type*) [Ring R] [SetLike S R]\n    extends AddGroupConeClass S R, SubsemiringClass S R : Prop\n\n"}
{"name":"RingCone.eq_zero_of_mem_of_neg_mem'","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"R : Type u_1\ninst✝ : Ring R\nself : RingCone R\na : R\na✝¹ : Membership.mem self.carrier a\na✝ : Membership.mem self.carrier (Neg.neg a)\n⊢ Eq a 0","decl":"/-- A (positive) cone in a ring is a subsemiring that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the ring into a partially ordered ring. -/\nstructure RingCone (R : Type*) [Ring R] extends Subsemiring R, AddGroupCone R\n\n"}
{"name":"RingCone.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : SizeOf R\ntoSubsemiring : Subsemiring R\neq_zero_of_mem_of_neg_mem' : ∀ {a : R}, Membership.mem toSubsemiring.carrier a → Membership.mem toSubsemiring.carrier (Neg.neg a) → Eq a 0\n⊢ Eq (SizeOf.sizeOf { toSubsemiring := toSubsemiring, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubsemiring))","decl":"/-- A (positive) cone in a ring is a subsemiring that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the ring into a partially ordered ring. -/\nstructure RingCone (R : Type*) [Ring R] extends Subsemiring R, AddGroupCone R\n\n"}
{"name":"RingCone.mk.inj","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"R : Type u_1\ninst✝ : Ring R\ntoSubsemiring✝ : Subsemiring R\neq_zero_of_mem_of_neg_mem'✝ : ∀ {a : R}, Membership.mem toSubsemiring✝.carrier a → Membership.mem toSubsemiring✝.carrier (Neg.neg a) → Eq a 0\ntoSubsemiring : Subsemiring R\neq_zero_of_mem_of_neg_mem' : ∀ {a : R}, Membership.mem toSubsemiring.carrier a → Membership.mem toSubsemiring.carrier (Neg.neg a) → Eq a 0\nx✝ : Eq { toSubsemiring := toSubsemiring✝, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem'✝ } { toSubsemiring := toSubsemiring, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }\n⊢ Eq toSubsemiring✝ toSubsemiring","decl":"/-- A (positive) cone in a ring is a subsemiring that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the ring into a partially ordered ring. -/\nstructure RingCone (R : Type*) [Ring R] extends Subsemiring R, AddGroupCone R\n\n"}
{"name":"RingCone.mk.injEq","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"R : Type u_1\ninst✝ : Ring R\ntoSubsemiring✝ : Subsemiring R\neq_zero_of_mem_of_neg_mem'✝ : ∀ {a : R}, Membership.mem toSubsemiring✝.carrier a → Membership.mem toSubsemiring✝.carrier (Neg.neg a) → Eq a 0\ntoSubsemiring : Subsemiring R\neq_zero_of_mem_of_neg_mem' : ∀ {a : R}, Membership.mem toSubsemiring.carrier a → Membership.mem toSubsemiring.carrier (Neg.neg a) → Eq a 0\n⊢ Eq (Eq { toSubsemiring := toSubsemiring✝, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem'✝ } { toSubsemiring := toSubsemiring, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }) (Eq toSubsemiring✝ toSubsemiring)","decl":"/-- A (positive) cone in a ring is a subsemiring that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the ring into a partially ordered ring. -/\nstructure RingCone (R : Type*) [Ring R] extends Subsemiring R, AddGroupCone R\n\n"}
{"name":"RingCone.instRingConeClass","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ RingConeClass (RingCone R) R","decl":"instance RingCone.instRingConeClass (R : Type*) [Ring R] :\n    RingConeClass (RingCone R) R where\n  add_mem {C} := C.add_mem'\n  zero_mem {C} := C.zero_mem'\n  mul_mem {C} := C.mul_mem'\n  one_mem {C} := C.one_mem'\n  eq_zero_of_mem_of_neg_mem {C} := C.eq_zero_of_mem_of_neg_mem'\n\n"}
{"name":"RingCone.nonneg_toSubsemiring","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"T : Type u_1\ninst✝ : OrderedRing T\n⊢ Eq (RingCone.nonneg T).toSubsemiring (Subsemiring.nonneg T)","decl":"@[simp] lemma nonneg_toSubsemiring : (nonneg T).toSubsemiring = .nonneg T := rfl\n"}
{"name":"RingCone.nonneg_toAddGroupCone","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"T : Type u_1\ninst✝ : OrderedRing T\n⊢ Eq (RingCone.nonneg T).toAddGroupCone (AddGroupCone.nonneg T)","decl":"@[simp] lemma nonneg_toAddGroupCone : (nonneg T).toAddGroupCone = .nonneg T := rfl\n"}
{"name":"RingCone.mem_nonneg","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"T : Type u_1\ninst✝ : OrderedRing T\na : T\n⊢ Iff (Membership.mem (RingCone.nonneg T) a) (LE.le 0 a)","decl":"@[simp] lemma mem_nonneg : a ∈ nonneg T ↔ 0 ≤ a := Iff.rfl\n"}
{"name":"RingCone.coe_nonneg","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"T : Type u_1\ninst✝ : OrderedRing T\n⊢ Eq (↑(RingCone.nonneg T)) (setOf fun x => LE.le 0 x)","decl":"@[simp, norm_cast] lemma coe_nonneg : nonneg T = {x : T | 0 ≤ x} := rfl\n\n"}
{"name":"RingCone.nonneg.isMaxCone","module":"Mathlib.Algebra.Order.Ring.Cone","initialProofState":"T : Type u_2\ninst✝ : LinearOrderedRing T\n⊢ IsMaxCone (RingCone.nonneg T)","decl":"instance nonneg.isMaxCone {T : Type*} [LinearOrderedRing T] : IsMaxCone (nonneg T) where\n  mem_or_neg_mem := mem_or_neg_mem (C := AddGroupCone.nonneg T)\n\n"}
