{"name":"WittVector.mk'.sizeOf_spec","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : SizeOf R\ncoeff : Nat ‚Üí R\n‚ä¢ Eq (SizeOf.sizeOf { coeff := coeff }) 1","decl":"/-- `WittVector p R` is the ring of `p`-typical Witt vectors over the commutative ring `R`,\nwhere `p` is a prime number.\n\nIf `p` is invertible in `R`, this ring is isomorphic to `‚Ñï ‚Üí R` (the product of `‚Ñï` copies of `R`).\nIf `R` is a ring of characteristic `p`, then `WittVector p R` is a ring of characteristic `0`.\nThe canonical example is `WittVector p (ZMod p)`,\nwhich is isomorphic to the `p`-adic integers `‚Ñ§_[p]`. -/\nstructure WittVector (p : ‚Ñï) (R : Type*) where mk' ::\n  /-- `x.coeff n` is the `n`th coefficient of the Witt vector `x`.\n\n  This concept does not have a standard name in the literature.\n  -/\n  coeff : ‚Ñï ‚Üí R\n\n-- Porting note: added to make the `p` argument explicit\n"}
{"name":"WittVector.mk'.injEq","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\ncoeff‚úù coeff : Nat ‚Üí R\n‚ä¢ Eq (Eq { coeff := coeff‚úù } { coeff := coeff }) (Eq coeff‚úù coeff)","decl":"/-- `WittVector p R` is the ring of `p`-typical Witt vectors over the commutative ring `R`,\nwhere `p` is a prime number.\n\nIf `p` is invertible in `R`, this ring is isomorphic to `‚Ñï ‚Üí R` (the product of `‚Ñï` copies of `R`).\nIf `R` is a ring of characteristic `p`, then `WittVector p R` is a ring of characteristic `0`.\nThe canonical example is `WittVector p (ZMod p)`,\nwhich is isomorphic to the `p`-adic integers `‚Ñ§_[p]`. -/\nstructure WittVector (p : ‚Ñï) (R : Type*) where mk' ::\n  /-- `x.coeff n` is the `n`th coefficient of the Witt vector `x`.\n\n  This concept does not have a standard name in the literature.\n  -/\n  coeff : ‚Ñï ‚Üí R\n\n-- Porting note: added to make the `p` argument explicit\n"}
{"name":"WittVector.mk'.inj","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\ncoeff‚úù coeff : Nat ‚Üí R\nx‚úù : Eq { coeff := coeff‚úù } { coeff := coeff }\n‚ä¢ Eq coeff‚úù coeff","decl":"/-- `WittVector p R` is the ring of `p`-typical Witt vectors over the commutative ring `R`,\nwhere `p` is a prime number.\n\nIf `p` is invertible in `R`, this ring is isomorphic to `‚Ñï ‚Üí R` (the product of `‚Ñï` copies of `R`).\nIf `R` is a ring of characteristic `p`, then `WittVector p R` is a ring of characteristic `0`.\nThe canonical example is `WittVector p (ZMod p)`,\nwhich is isomorphic to the `p`-adic integers `‚Ñ§_[p]`. -/\nstructure WittVector (p : ‚Ñï) (R : Type*) where mk' ::\n  /-- `x.coeff n` is the `n`th coefficient of the Witt vector `x`.\n\n  This concept does not have a standard name in the literature.\n  -/\n  coeff : ‚Ñï ‚Üí R\n\n-- Porting note: added to make the `p` argument explicit\n"}
{"name":"WittVector.ext","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nx y : WittVector p R\nh : ‚àÄ (n : Nat), Eq (x.coeff n) (y.coeff n)\n‚ä¢ Eq x y","decl":"@[ext]\ntheorem ext {x y : ùïé R} (h : ‚àÄ n, x.coeff n = y.coeff n) : x = y := by\n  cases x\n  cases y\n  simp only at h\n  simp [funext_iff, h]\n\n"}
{"name":"WittVector.ext_iff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nx y : WittVector p R\n‚ä¢ Iff (Eq x y) (‚àÄ (n : Nat), Eq (x.coeff n) (y.coeff n))","decl":"@[ext]\ntheorem ext {x y : ùïé R} (h : ‚àÄ n, x.coeff n = y.coeff n) : x = y := by\n  cases x\n  cases y\n  simp only at h\n  simp [funext_iff, h]\n\n"}
{"name":"WittVector.coeff_mk","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nx : Nat ‚Üí R\n‚ä¢ Eq (WittVector.mk p x).coeff x","decl":"theorem coeff_mk (x : ‚Ñï ‚Üí R) : (mk p x).coeff = x :=\n  rfl\n\n/- These instances are not needed for the rest of the development,\nbut it is interesting to establish early on that `WittVector p` is a lawful functor. -/\n"}
{"name":"WittVector.instLawfulFunctor","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\n‚ä¢ LawfulFunctor (WittVector p)","decl":"instance : LawfulFunctor (WittVector p) where\n  map_const := rfl\n  -- Porting note: no longer needs to deconstruct `v` to conclude `{coeff := v.coeff} = v`\n  id_map _ := rfl\n  comp_map _ _ _ := rfl\n\n"}
{"name":"WittVector.wittZero_eq_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (WittVector.wittZero p n) 0","decl":"@[simp]\ntheorem wittZero_eq_zero (n : ‚Ñï) : wittZero p n = 0 := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittZero, wittStructureRat, bind‚ÇÅ, aeval_zero', constantCoeff_xInTermsOfW, map_zero,\n    map_wittStructureInt]\n\n"}
{"name":"WittVector.wittOne_zero_eq_one","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq (WittVector.wittOne p 0) 1","decl":"@[simp]\ntheorem wittOne_zero_eq_one : wittOne p 0 = 1 := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittOne, wittStructureRat, xInTermsOfW_zero, map_one, bind‚ÇÅ_X_right,\n    map_wittStructureInt]\n\n"}
{"name":"WittVector.wittOne_pos_eq_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Eq (WittVector.wittOne p n) 0","decl":"@[simp]\ntheorem wittOne_pos_eq_zero (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittOne, wittStructureRat, RingHom.map_zero, map_one, RingHom.map_one,\n    map_wittStructureInt]\n  induction n using Nat.strong_induction_on with | h n IH => ?_\n  rw [xInTermsOfW_eq]\n  simp only [map_mul, map_sub, map_sum, map_pow, bind‚ÇÅ_X_right,\n    bind‚ÇÅ_C_right]\n  rw [sub_mul, one_mul]\n  rw [Finset.sum_eq_single 0]\n  ¬∑ simp only [invOf_eq_inv, one_mul, inv_pow, tsub_zero, RingHom.map_one, pow_zero]\n    simp only [one_pow, one_mul, xInTermsOfW_zero, sub_self, bind‚ÇÅ_X_right]\n  ¬∑ intro i hin hi0\n    rw [Finset.mem_range] at hin\n    rw [IH _ hin (Nat.pos_of_ne_zero hi0), zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero]\n  ¬∑ rw [Finset.mem_range]; intro; contradiction\n\n"}
{"name":"WittVector.wittAdd_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq (WittVector.wittAdd p 0) (HAdd.hAdd (MvPolynomial.X { fst := 0, snd := 0 }) (MvPolynomial.X { fst := 1, snd := 0 }))","decl":"@[simp]\ntheorem wittAdd_zero : wittAdd p 0 = X (0, 0) + X (1, 0) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittAdd, wittStructureRat, map_add, rename_X, xInTermsOfW_zero, map_X,\n    wittPolynomial_zero, bind‚ÇÅ_X_right, map_wittStructureInt]\n\n"}
{"name":"WittVector.wittSub_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq (WittVector.wittSub p 0) (HSub.hSub (MvPolynomial.X { fst := 0, snd := 0 }) (MvPolynomial.X { fst := 1, snd := 0 }))","decl":"@[simp]\ntheorem wittSub_zero : wittSub p 0 = X (0, 0) - X (1, 0) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittSub, wittStructureRat, map_sub, rename_X, xInTermsOfW_zero, map_X,\n    wittPolynomial_zero, bind‚ÇÅ_X_right, map_wittStructureInt]\n\n"}
{"name":"WittVector.wittMul_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq (WittVector.wittMul p 0) (HMul.hMul (MvPolynomial.X { fst := 0, snd := 0 }) (MvPolynomial.X { fst := 1, snd := 0 }))","decl":"@[simp]\ntheorem wittMul_zero : wittMul p 0 = X (0, 0) * X (1, 0) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittMul, wittStructureRat, rename_X, xInTermsOfW_zero, map_X, wittPolynomial_zero,\n    map_mul, bind‚ÇÅ_X_right, map_wittStructureInt]\n\n"}
{"name":"WittVector.wittNeg_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq (WittVector.wittNeg p 0) (Neg.neg (MvPolynomial.X { fst := 0, snd := 0 }))","decl":"@[simp]\ntheorem wittNeg_zero : wittNeg p 0 = -X (0, 0) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [wittNeg, wittStructureRat, rename_X, xInTermsOfW_zero, map_X, wittPolynomial_zero,\n    map_neg, bind‚ÇÅ_X_right, map_wittStructureInt]\n\n"}
{"name":"WittVector.constantCoeff_wittAdd","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittAdd p n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittAdd (n : ‚Ñï) : constantCoeff (wittAdd p n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [add_zero, RingHom.map_add, constantCoeff_X]\n\n"}
{"name":"WittVector.constantCoeff_wittSub","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittSub p n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittSub (n : ‚Ñï) : constantCoeff (wittSub p n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [sub_zero, RingHom.map_sub, constantCoeff_X]\n\n"}
{"name":"WittVector.constantCoeff_wittMul","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittMul p n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittMul (n : ‚Ñï) : constantCoeff (wittMul p n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [mul_zero, RingHom.map_mul, constantCoeff_X]\n\n"}
{"name":"WittVector.constantCoeff_wittNeg","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittNeg p n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittNeg (n : ‚Ñï) : constantCoeff (wittNeg p n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [neg_zero, RingHom.map_neg, constantCoeff_X]\n\n"}
{"name":"WittVector.constantCoeff_wittNSMul","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm n : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittNSMul p m n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittNSMul (m : ‚Ñï) (n : ‚Ñï) : constantCoeff (wittNSMul p m n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [smul_zero, map_nsmul, constantCoeff_X]\n\n"}
{"name":"WittVector.constantCoeff_wittZSMul","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : Int\nn : Nat\n‚ä¢ Eq (MvPolynomial.constantCoeff (WittVector.wittZSMul p z n)) 0","decl":"@[simp]\ntheorem constantCoeff_wittZSMul (z : ‚Ñ§) (n : ‚Ñï) : constantCoeff (wittZSMul p z n) = 0 := by\n  apply constantCoeff_wittStructureInt p _ _ n\n  simp only [smul_zero, map_zsmul, constantCoeff_X]\n\n"}
{"name":"WittVector.zero_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nn : Nat\n‚ä¢ Eq (WittVector.coeff 0 n) 0","decl":"@[simp]\ntheorem zero_coeff (n : ‚Ñï) : (0 : ùïé R).coeff n = 0 :=\n  show (aeval _ (wittZero p n) : R) = 0 by simp only [wittZero_eq_zero, map_zero]\n\n"}
{"name":"WittVector.one_coeff_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\n‚ä¢ Eq (WittVector.coeff 1 0) 1","decl":"@[simp]\ntheorem one_coeff_zero : (1 : ùïé R).coeff 0 = 1 :=\n  show (aeval _ (wittOne p 0) : R) = 1 by simp only [wittOne_zero_eq_one, map_one]\n\n"}
{"name":"WittVector.one_coeff_eq_of_pos","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Eq (WittVector.coeff 1 n) 0","decl":"@[simp]\ntheorem one_coeff_eq_of_pos (n : ‚Ñï) (hn : 0 < n) : coeff (1 : ùïé R) n = 0 :=\n  show (aeval _ (wittOne p n) : R) = 0 by simp only [hn, wittOne_pos_eq_zero, map_zero]\n\n"}
{"name":"WittVector.v2_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p' : Nat\nR' : Type u_2\nx y : WittVector p' R'\ni : Fin 2\n‚ä¢ Eq (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty) i).coeff (Matrix.vecCons x.coeff (Matrix.vecCons y.coeff Matrix.vecEmpty) i)","decl":"@[simp]\ntheorem v2_coeff {p' R'} (x y : WittVector p' R') (i : Fin 2) :\n    (![x, y] i).coeff = ![x.coeff, y.coeff] i := by fin_cases i <;> simp\n\n-- Porting note: the lemmas below needed `coeff_mk` added to the `simp` calls\n\n"}
{"name":"WittVector.add_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx y : WittVector p R\nn : Nat\n‚ä¢ Eq ((HAdd.hAdd x y).coeff n) (WittVector.peval (WittVector.wittAdd p n) (Matrix.vecCons x.coeff (Matrix.vecCons y.coeff Matrix.vecEmpty)))","decl":"theorem add_coeff (x y : ùïé R) (n : ‚Ñï) :\n    (x + y).coeff n = peval (wittAdd p n) ![x.coeff, y.coeff] := by\n  simp [(¬∑ + ¬∑), Add.add, eval, coeff_mk]\n\n"}
{"name":"WittVector.sub_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx y : WittVector p R\nn : Nat\n‚ä¢ Eq ((HSub.hSub x y).coeff n) (WittVector.peval (WittVector.wittSub p n) (Matrix.vecCons x.coeff (Matrix.vecCons y.coeff Matrix.vecEmpty)))","decl":"theorem sub_coeff (x y : ùïé R) (n : ‚Ñï) :\n    (x - y).coeff n = peval (wittSub p n) ![x.coeff, y.coeff] := by\n  simp [(¬∑ - ¬∑), Sub.sub, eval, coeff_mk]\n\n"}
{"name":"WittVector.mul_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx y : WittVector p R\nn : Nat\n‚ä¢ Eq ((HMul.hMul x y).coeff n) (WittVector.peval (WittVector.wittMul p n) (Matrix.vecCons x.coeff (Matrix.vecCons y.coeff Matrix.vecEmpty)))","decl":"theorem mul_coeff (x y : ùïé R) (n : ‚Ñï) :\n    (x * y).coeff n = peval (wittMul p n) ![x.coeff, y.coeff] := by\n  simp [(¬∑ * ¬∑), Mul.mul, eval, coeff_mk]\n\n"}
{"name":"WittVector.neg_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((Neg.neg x).coeff n) (WittVector.peval (WittVector.wittNeg p n) (Matrix.vecCons x.coeff Matrix.vecEmpty))","decl":"theorem neg_coeff (x : ùïé R) (n : ‚Ñï) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] := by\n  simp [Neg.neg, eval, Matrix.cons_fin_one, coeff_mk]\n\n"}
{"name":"WittVector.nsmul_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nm : Nat\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((HSMul.hSMul m x).coeff n) (WittVector.peval (WittVector.wittNSMul p m n) (Matrix.vecCons x.coeff Matrix.vecEmpty))","decl":"theorem nsmul_coeff (m : ‚Ñï) (x : ùïé R) (n : ‚Ñï) :\n    (m ‚Ä¢ x).coeff n = peval (wittNSMul p m n) ![x.coeff] := by\n  simp [(¬∑ ‚Ä¢ ¬∑), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]\n\n"}
{"name":"WittVector.zsmul_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nm : Int\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((HSMul.hSMul m x).coeff n) (WittVector.peval (WittVector.wittZSMul p m n) (Matrix.vecCons x.coeff Matrix.vecEmpty))","decl":"theorem zsmul_coeff (m : ‚Ñ§) (x : ùïé R) (n : ‚Ñï) :\n    (m ‚Ä¢ x).coeff n = peval (wittZSMul p m n) ![x.coeff] := by\n  simp [(¬∑ ‚Ä¢ ¬∑), SMul.smul, eval, Matrix.cons_fin_one, coeff_mk]\n\n"}
{"name":"WittVector.pow_coeff","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nm : Nat\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((HPow.hPow x m).coeff n) (WittVector.peval (WittVector.wittPow p m n) (Matrix.vecCons x.coeff Matrix.vecEmpty))","decl":"theorem pow_coeff (m : ‚Ñï) (x : ùïé R) (n : ‚Ñï) :\n    (x ^ m).coeff n = peval (wittPow p m n) ![x.coeff] := by\n  simp [(¬∑ ^ ¬∑), Pow.pow, eval, Matrix.cons_fin_one, coeff_mk]\n\n"}
{"name":"WittVector.add_coeff_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx y : WittVector p R\n‚ä¢ Eq ((HAdd.hAdd x y).coeff 0) (HAdd.hAdd (x.coeff 0) (y.coeff 0))","decl":"theorem add_coeff_zero (x y : ùïé R) : (x + y).coeff 0 = x.coeff 0 + y.coeff 0 := by\n  simp [add_coeff, peval, Function.uncurry]\n\n"}
{"name":"WittVector.mul_coeff_zero","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx y : WittVector p R\n‚ä¢ Eq ((HMul.hMul x y).coeff 0) (HMul.hMul (x.coeff 0) (y.coeff 0))","decl":"theorem mul_coeff_zero (x y : ùïé R) : (x * y).coeff 0 = x.coeff 0 * y.coeff 0 := by\n  simp [mul_coeff, peval, Function.uncurry]\n\n"}
{"name":"WittVector.wittAdd_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittAdd p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittAdd_vars (n : ‚Ñï) : (wittAdd p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittSub_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittSub p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittSub_vars (n : ‚Ñï) : (wittSub p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittMul_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittMul p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittMul_vars (n : ‚Ñï) : (wittMul p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittNeg_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittNeg p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittNeg_vars (n : ‚Ñï) : (wittNeg p n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittNSMul_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm n : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittNSMul p m n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittNSMul_vars (m : ‚Ñï) (n : ‚Ñï) :\n    (wittNSMul p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittZSMul_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Int\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittZSMul p m n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittZSMul_vars (m : ‚Ñ§) (n : ‚Ñï) :\n    (wittZSMul p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
{"name":"WittVector.wittPow_vars","module":"Mathlib.RingTheory.WittVector.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm n : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittPow p m n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittPow_vars (m : ‚Ñï) (n : ‚Ñï) : (wittPow p m n).vars ‚äÜ Finset.univ √óÀ¢ Finset.range (n + 1) :=\n  wittStructureInt_vars _ _ _\n\n"}
