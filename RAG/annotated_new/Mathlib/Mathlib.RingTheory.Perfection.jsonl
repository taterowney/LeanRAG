{"name":"Perfection.charP","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ CharP (Ring.Perfection R p) p","decl":"instance charP : CharP (Ring.Perfection R p) p :=\n  CharP.subsemiring (ℕ → R) p (Ring.perfectionSubsemiring R p)\n\n"}
{"name":"Perfection.ext","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf g : Ring.Perfection R p\nh : ∀ (n : Nat), Eq ((Perfection.coeff R p n) f) ((Perfection.coeff R p n) g)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : Ring.Perfection R p} (h : ∀ n, coeff R p n f = coeff R p n g) : f = g :=\n  Subtype.eq <| funext h\n\n"}
{"name":"Perfection.ext_iff","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf g : Ring.Perfection R p\n⊢ Iff (Eq f g) (∀ (n : Nat), Eq ((Perfection.coeff R p n) f) ((Perfection.coeff R p n) g))","decl":"@[ext]\ntheorem ext {f g : Ring.Perfection R p} (h : ∀ n, coeff R p n f = coeff R p n g) : f = g :=\n  Subtype.eq <| funext h\n\n"}
{"name":"Perfection.coeff_mk","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Nat → R\nhf : ∀ (n : Nat), Eq (HPow.hPow (f (HAdd.hAdd n 1)) p) (f n)\nn : Nat\n⊢ Eq ((Perfection.coeff R p n) ⟨f, hf⟩) (f n)","decl":"@[simp]\ntheorem coeff_mk (f : ℕ → R) (hf) (n : ℕ) : coeff R p n ⟨f, hf⟩ = f n := rfl\n\n"}
{"name":"Perfection.coeff_pthRoot","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq ((Perfection.coeff R p n) ((Perfection.pthRoot R p) f)) ((Perfection.coeff R p (HAdd.hAdd n 1)) f)","decl":"theorem coeff_pthRoot (f : Ring.Perfection R p) (n : ℕ) :\n    coeff R p n (pthRoot R p f) = coeff R p (n + 1) f := rfl\n\n"}
{"name":"Perfection.coeff_pow_p","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq ((Perfection.coeff R p (HAdd.hAdd n 1)) (HPow.hPow f p)) ((Perfection.coeff R p n) f)","decl":"theorem coeff_pow_p (f : Ring.Perfection R p) (n : ℕ) :\n    coeff R p (n + 1) (f ^ p) = coeff R p n f := by rw [RingHom.map_pow]; exact f.2 n\n\n"}
{"name":"Perfection.coeff_pow_p'","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq (HPow.hPow ((Perfection.coeff R p (HAdd.hAdd n 1)) f) p) ((Perfection.coeff R p n) f)","decl":"theorem coeff_pow_p' (f : Ring.Perfection R p) (n : ℕ) : coeff R p (n + 1) f ^ p = coeff R p n f :=\n  f.2 n\n\n"}
{"name":"Perfection.coeff_frobenius","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq ((Perfection.coeff R p (HAdd.hAdd n 1)) ((frobenius (Ring.Perfection R p) p) f)) ((Perfection.coeff R p n) f)","decl":"theorem coeff_frobenius (f : Ring.Perfection R p) (n : ℕ) :\n    coeff R p (n + 1) (frobenius _ p f) = coeff R p n f := by apply coeff_pow_p f n\n\n-- `coeff_pow_p f n` also works but is slow!\n"}
{"name":"Perfection.coeff_iterate_frobenius","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn m : Nat\n⊢ Eq ((Perfection.coeff R p (HAdd.hAdd n m)) (Nat.iterate (⇑(frobenius (Ring.Perfection R p) p)) m f)) ((Perfection.coeff R p n) f)","decl":"theorem coeff_iterate_frobenius (f : Ring.Perfection R p) (n m : ℕ) :\n    coeff R p (n + m) ((frobenius _ p)^[m] f) = coeff R p n f :=\n  Nat.recOn m rfl fun m ih => by erw [Function.iterate_succ_apply', coeff_frobenius, ih]\n\n"}
{"name":"Perfection.coeff_iterate_frobenius'","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn m : Nat\nhmn : LE.le m n\n⊢ Eq ((Perfection.coeff R p n) (Nat.iterate (⇑(frobenius (Ring.Perfection R p) p)) m f)) ((Perfection.coeff R p (HSub.hSub n m)) f)","decl":"theorem coeff_iterate_frobenius' (f : Ring.Perfection R p) (n m : ℕ) (hmn : m ≤ n) :\n    coeff R p n ((frobenius _ p)^[m] f) = coeff R p (n - m) f :=\n  Eq.symm <| (coeff_iterate_frobenius _ _ m).symm.trans <| (tsub_add_cancel_of_le hmn).symm ▸ rfl\n\n"}
{"name":"Perfection.pthRoot_frobenius","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq ((Perfection.pthRoot R p).comp (frobenius (Ring.Perfection R p) p)) (RingHom.id (Ring.Perfection R p))","decl":"theorem pthRoot_frobenius : (pthRoot R p).comp (frobenius _ p) = RingHom.id _ :=\n  RingHom.ext fun x =>\n    ext fun n => by rw [RingHom.comp_apply, RingHom.id_apply, coeff_pthRoot, coeff_frobenius]\n\n"}
{"name":"Perfection.frobenius_pthRoot","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq ((frobenius (Ring.Perfection R p) p).comp (Perfection.pthRoot R p)) (RingHom.id (Ring.Perfection R p))","decl":"theorem frobenius_pthRoot : (frobenius _ p).comp (pthRoot R p) = RingHom.id _ :=\n  RingHom.ext fun x =>\n    ext fun n => by\n      rw [RingHom.comp_apply, RingHom.id_apply, RingHom.map_frobenius, coeff_pthRoot,\n        ← @RingHom.map_frobenius (Ring.Perfection R p) _ R, coeff_frobenius]\n\n"}
{"name":"Perfection.coeff_add_ne_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nn : Nat\nhfn : Ne ((Perfection.coeff R p n) f) 0\nk : Nat\n⊢ Ne ((Perfection.coeff R p (HAdd.hAdd n k)) f) 0","decl":"theorem coeff_add_ne_zero {f : Ring.Perfection R p} {n : ℕ} (hfn : coeff R p n f ≠ 0) (k : ℕ) :\n    coeff R p (n + k) f ≠ 0 :=\n  Nat.recOn k hfn fun k ih h => ih <| by\n    erw [← coeff_pow_p, RingHom.map_pow, h, zero_pow hp.1.ne_zero]\n\n"}
{"name":"Perfection.coeff_ne_zero_of_le","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nf : Ring.Perfection R p\nm n : Nat\nhfm : Ne ((Perfection.coeff R p m) f) 0\nhmn : LE.le m n\n⊢ Ne ((Perfection.coeff R p n) f) 0","decl":"theorem coeff_ne_zero_of_le {f : Ring.Perfection R p} {m n : ℕ} (hfm : coeff R p m f ≠ 0)\n    (hmn : m ≤ n) : coeff R p n f ≠ 0 :=\n  let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hmn\n  hk.symm ▸ coeff_add_ne_zero hfm k\n\n"}
{"name":"Perfection.perfectRing","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝¹ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ PerfectRing (Ring.Perfection R p) p","decl":"instance perfectRing : PerfectRing (Ring.Perfection R p) p where\n  bijective_frobenius := Function.bijective_iff_has_inverse.mpr\n    ⟨pthRoot R p,\n     DFunLike.congr_fun <| @frobenius_pthRoot R _ p _ _,\n     DFunLike.congr_fun <| @pthRoot_frobenius R _ p _ _⟩\n\n"}
{"name":"Perfection.lift_apply_apply_coe","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\ninst✝² : PerfectRing R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nf : RingHom R S\nr : R\nn : Nat\n⊢ Eq (↑(((Perfection.lift p R S) f) r) n) (f (Nat.iterate (⇑↑(frobeniusEquiv R p).symm) n r))","decl":"/-- Given rings `R` and `S` of characteristic `p`, with `R` being perfect,\nany homomorphism `R →+* S` can be lifted to a homomorphism `R →+* Perfection S p`. -/\n@[simps]\nnoncomputable def lift (R : Type u₁) [CommSemiring R] [CharP R p] [PerfectRing R p]\n    (S : Type u₂) [CommSemiring S] [CharP S p] : (R →+* S) ≃ (R →+* Ring.Perfection S p) where\n  toFun f :=\n    { toFun := fun r => ⟨fun n => f (((frobeniusEquiv R p).symm : R →+* R)^[n] r),\n        fun n => by erw [← f.map_pow, Function.iterate_succ_apply', frobeniusEquiv_symm_pow_p]⟩\n      map_one' := ext fun _ => (congr_arg f <| iterate_map_one _ _).trans f.map_one\n      map_mul' := fun _ _ =>\n        ext fun _ => (congr_arg f <| iterate_map_mul _ _ _ _).trans <| f.map_mul _ _\n      map_zero' := ext fun _ => (congr_arg f <| iterate_map_zero _ _).trans f.map_zero\n      map_add' := fun _ _ =>\n        ext fun _ => (congr_arg f <| iterate_map_add _ _ _ _).trans <| f.map_add _ _ }\n  invFun := RingHom.comp <| coeff S p 0\n  left_inv _ := RingHom.ext fun _ => rfl\n  right_inv f := RingHom.ext fun r => ext fun n =>\n    show coeff S p 0 (f (((frobeniusEquiv R p).symm)^[n] r)) = coeff S p n (f r) by\n      rw [← coeff_iterate_frobenius _ 0 n, zero_add, ← RingHom.map_iterate_frobenius,\n        Function.RightInverse.iterate (frobenius_apply_frobeniusEquiv_symm R p) n]\n\n"}
{"name":"Perfection.lift_symm_apply","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\ninst✝² : PerfectRing R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nf : RingHom R (Ring.Perfection S p)\n⊢ Eq ((Perfection.lift p R S).symm f) ((Perfection.coeff S p 0).comp f)","decl":"/-- Given rings `R` and `S` of characteristic `p`, with `R` being perfect,\nany homomorphism `R →+* S` can be lifted to a homomorphism `R →+* Perfection S p`. -/\n@[simps]\nnoncomputable def lift (R : Type u₁) [CommSemiring R] [CharP R p] [PerfectRing R p]\n    (S : Type u₂) [CommSemiring S] [CharP S p] : (R →+* S) ≃ (R →+* Ring.Perfection S p) where\n  toFun f :=\n    { toFun := fun r => ⟨fun n => f (((frobeniusEquiv R p).symm : R →+* R)^[n] r),\n        fun n => by erw [← f.map_pow, Function.iterate_succ_apply', frobeniusEquiv_symm_pow_p]⟩\n      map_one' := ext fun _ => (congr_arg f <| iterate_map_one _ _).trans f.map_one\n      map_mul' := fun _ _ =>\n        ext fun _ => (congr_arg f <| iterate_map_mul _ _ _ _).trans <| f.map_mul _ _\n      map_zero' := ext fun _ => (congr_arg f <| iterate_map_zero _ _).trans f.map_zero\n      map_add' := fun _ _ =>\n        ext fun _ => (congr_arg f <| iterate_map_add _ _ _ _).trans <| f.map_add _ _ }\n  invFun := RingHom.comp <| coeff S p 0\n  left_inv _ := RingHom.ext fun _ => rfl\n  right_inv f := RingHom.ext fun r => ext fun n =>\n    show coeff S p 0 (f (((frobeniusEquiv R p).symm)^[n] r)) = coeff S p n (f r) by\n      rw [← coeff_iterate_frobenius _ 0 n, zero_add, ← RingHom.map_iterate_frobenius,\n        Function.RightInverse.iterate (frobenius_apply_frobeniusEquiv_symm R p) n]\n\n"}
{"name":"Perfection.hom_ext","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\ninst✝² : PerfectRing R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nf g : RingHom R (Ring.Perfection S p)\nhfg : ∀ (x : R), Eq ((Perfection.coeff S p 0) (f x)) ((Perfection.coeff S p 0) (g x))\n⊢ Eq f g","decl":"theorem hom_ext {R : Type u₁} [CommSemiring R] [CharP R p] [PerfectRing R p] {S : Type u₂}\n    [CommSemiring S] [CharP S p] {f g : R →+* Ring.Perfection S p}\n    (hfg : ∀ x, coeff S p 0 (f x) = coeff S p 0 (g x)) : f = g :=\n  (lift p R S).symm.injective <| RingHom.ext hfg\n\n"}
{"name":"Perfection.map_apply_coe","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝³ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝² : CharP R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nφ : RingHom R S\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq (↑((Perfection.map p φ) f) n) (φ ((Perfection.coeff R p n) f))","decl":"/-- A ring homomorphism `R →+* S` induces `Perfection R p →+* Perfection S p`. -/\n@[simps]\ndef map (φ : R →+* S) : Ring.Perfection R p →+* Ring.Perfection S p where\n  toFun f := ⟨fun n => φ (coeff R p n f), fun n => by rw [← φ.map_pow, coeff_pow_p']⟩\n  map_one' := Subtype.eq <| funext fun _ => φ.map_one\n  map_mul' _ _ := Subtype.eq <| funext fun _ => φ.map_mul _ _\n  map_zero' := Subtype.eq <| funext fun _ => φ.map_zero\n  map_add' _ _ := Subtype.eq <| funext fun _ => φ.map_add _ _\n\n"}
{"name":"Perfection.coeff_map","module":"Mathlib.RingTheory.Perfection","initialProofState":"R : Type u₁\ninst✝³ : CommSemiring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝² : CharP R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nφ : RingHom R S\nf : Ring.Perfection R p\nn : Nat\n⊢ Eq ((Perfection.coeff S p n) ((Perfection.map p φ) f)) (φ ((Perfection.coeff R p n) f))","decl":"theorem coeff_map (φ : R →+* S) (f : Ring.Perfection R p) (n : ℕ) :\n    coeff S p n (map p φ f) = φ (coeff R p n f) := rfl\n\n"}
{"name":"PerfectionMap.surjective","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₂\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nself : PerfectionMap p π\nf : Nat → R\na✝ : ∀ (n : Nat), Eq (HPow.hPow (f (HAdd.hAdd n 1)) p) (f n)\n⊢ Exists fun x => ∀ (n : Nat), Eq (π (Nat.iterate (⇑(frobeniusEquiv P p).symm) n x)) (f n)","decl":"/-- A perfection map to a ring of characteristic `p` is a map that is isomorphic\nto its perfection. -/\nstructure PerfectionMap (p : ℕ) [Fact p.Prime] {R : Type u₁} [CommSemiring R] [CharP R p]\n    {P : Type u₂} [CommSemiring P] [CharP P p] [PerfectRing P p] (π : P →+* R) : Prop where\n  injective : ∀ ⦃x y : P⦄,\n    (∀ n, π (((frobeniusEquiv P p).symm)^[n] x) = π (((frobeniusEquiv P p).symm)^[n] y)) → x = y\n  surjective : ∀ f : ℕ → R, (∀ n, f (n + 1) ^ p = f n) → ∃ x : P, ∀ n,\n    π (((frobeniusEquiv P p).symm)^[n] x) = f n\n\n"}
{"name":"PerfectionMap.injective","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₂\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nself : PerfectionMap p π\nx y : P\na✝ : ∀ (n : Nat), Eq (π (Nat.iterate (⇑(frobeniusEquiv P p).symm) n x)) (π (Nat.iterate (⇑(frobeniusEquiv P p).symm) n y))\n⊢ Eq x y","decl":"/-- A perfection map to a ring of characteristic `p` is a map that is isomorphic\nto its perfection. -/\nstructure PerfectionMap (p : ℕ) [Fact p.Prime] {R : Type u₁} [CommSemiring R] [CharP R p]\n    {P : Type u₂} [CommSemiring P] [CharP P p] [PerfectRing P p] (π : P →+* R) : Prop where\n  injective : ∀ ⦃x y : P⦄,\n    (∀ n, π (((frobeniusEquiv P p).symm)^[n] x) = π (((frobeniusEquiv P p).symm)^[n] y)) → x = y\n  surjective : ∀ f : ℕ → R, (∀ n, f (n + 1) ^ p = f n) → ∃ x : P, ∀ n,\n    π (((frobeniusEquiv P p).symm)^[n] x) = f n\n\n"}
{"name":"PerfectionMap.mk'","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nf : RingHom P R\ng : RingEquiv P (Ring.Perfection R p)\nhfg : Eq ((Perfection.lift p P R) f) ↑g\n⊢ PerfectionMap p f","decl":"/-- Create a `PerfectionMap` from an isomorphism to the perfection. -/\n@[simps]\ntheorem mk' {f : P →+* R} (g : P ≃+* Ring.Perfection R p) (hfg : Perfection.lift p P R f = g) :\n    PerfectionMap p f :=\n  { injective := fun x y hxy =>\n      g.injective <|\n        (RingHom.ext_iff.1 hfg x).symm.trans <|\n          Eq.symm <| (RingHom.ext_iff.1 hfg y).symm.trans <| Perfection.ext fun n => (hxy n).symm\n    surjective := fun y hy =>\n      let ⟨x, hx⟩ := g.surjective ⟨y, hy⟩\n      ⟨x, fun n =>\n        show Perfection.coeff R p n (Perfection.lift p P R f x) = Perfection.coeff R p n ⟨y, hy⟩ by\n          simp [hfg, hx]⟩ }\n\n"}
{"name":"PerfectionMap.of","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝² : Fact (Nat.Prime p)\nR : Type u₁\ninst✝¹ : CommSemiring R\ninst✝ : CharP R p\n⊢ PerfectionMap p (Perfection.coeff R p 0)","decl":"/-- The canonical perfection map from the perfection of a ring. -/\ntheorem of : PerfectionMap p (Perfection.coeff R p 0) :=\n  mk' (RingEquiv.refl _) <| (Equiv.apply_eq_iff_eq_symm_apply _).2 rfl\n\n"}
{"name":"PerfectionMap.id","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝³ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝² : CommSemiring R\ninst✝¹ : CharP R p\ninst✝ : PerfectRing R p\n⊢ PerfectionMap p (RingHom.id R)","decl":"/-- For a perfect ring, it itself is the perfection. -/\ntheorem id [PerfectRing R p] : PerfectionMap p (RingHom.id R) :=\n  { injective := fun _ _ hxy => hxy 0\n    surjective := fun f hf =>\n      ⟨f 0, fun n =>\n        show ((frobeniusEquiv R p).symm)^[n] (f 0) = f n from\n          Nat.recOn n rfl fun n ih => injective_pow_p R p <| by\n            rw [Function.iterate_succ_apply', frobeniusEquiv_symm_pow_p, ih, hf]⟩ }\n\n"}
{"name":"PerfectionMap.equiv_apply","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nm : PerfectionMap p π\nx : P\n⊢ Eq (m.equiv x) (((Perfection.lift p P R) π) x)","decl":"theorem equiv_apply {π : P →+* R} (m : PerfectionMap p π) (x : P) :\n    m.equiv x = Perfection.lift p P R π x := rfl\n\n"}
{"name":"PerfectionMap.comp_equiv","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nm : PerfectionMap p π\nx : P\n⊢ Eq ((Perfection.coeff R p 0) (m.equiv x)) (π x)","decl":"theorem comp_equiv {π : P →+* R} (m : PerfectionMap p π) (x : P) :\n    Perfection.coeff R p 0 (m.equiv x) = π x := rfl\n\n"}
{"name":"PerfectionMap.comp_equiv'","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nm : PerfectionMap p π\n⊢ Eq ((Perfection.coeff R p 0).comp ↑m.equiv) π","decl":"theorem comp_equiv' {π : P →+* R} (m : PerfectionMap p π) :\n    (Perfection.coeff R p 0).comp ↑m.equiv = π :=\n  RingHom.ext fun _ => rfl\n\n"}
{"name":"PerfectionMap.comp_symm_equiv","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nm : PerfectionMap p π\nf : Ring.Perfection R p\n⊢ Eq (π (m.equiv.symm f)) ((Perfection.coeff R p 0) f)","decl":"theorem comp_symm_equiv {π : P →+* R} (m : PerfectionMap p π) (f : Ring.Perfection R p) :\n    π (m.equiv.symm f) = Perfection.coeff R p 0 f :=\n  (m.comp_equiv _).symm.trans <| congr_arg _ <| m.equiv.apply_symm_apply f\n\n"}
{"name":"PerfectionMap.comp_symm_equiv'","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁵ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁴ : CommSemiring R\ninst✝³ : CharP R p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P R\nm : PerfectionMap p π\n⊢ Eq (π.comp ↑m.equiv.symm) (Perfection.coeff R p 0)","decl":"theorem comp_symm_equiv' {π : P →+* R} (m : PerfectionMap p π) :\n    π.comp ↑m.equiv.symm = Perfection.coeff R p 0 :=\n  RingHom.ext m.comp_symm_equiv\n\n"}
{"name":"PerfectionMap.lift_symm_apply","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁸ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CharP R p\ninst✝⁵ : PerfectRing R p\nS : Type u₂\ninst✝⁴ : CommSemiring S\ninst✝³ : CharP S p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P S\nm : PerfectionMap p π\nf : RingHom R P\n⊢ Eq ((PerfectionMap.lift p R S P π m).symm f) (π.comp f)","decl":"/-- Given rings `R` and `S` of characteristic `p`, with `R` being perfect,\nany homomorphism `R →+* S` can be lifted to a homomorphism `R →+* P`,\nwhere `P` is any perfection of `S`. -/\n@[simps]\nnoncomputable def lift [PerfectRing R p] (S : Type u₂) [CommSemiring S] [CharP S p] (P : Type u₃)\n    [CommSemiring P] [CharP P p] [PerfectRing P p] (π : P →+* S) (m : PerfectionMap p π) :\n    (R →+* S) ≃ (R →+* P) where\n  toFun f := RingHom.comp ↑m.equiv.symm <| Perfection.lift p R S f\n  invFun f := π.comp f\n  left_inv f := by\n    simp_rw [← RingHom.comp_assoc, comp_symm_equiv']\n    exact (Perfection.lift p R S).symm_apply_apply f\n  right_inv f := by\n    exact RingHom.ext fun x => m.equiv.injective <| (m.equiv.apply_symm_apply _).trans\n      <| show Perfection.lift p R S (π.comp f) x = RingHom.comp (↑m.equiv) f x from\n        RingHom.ext_iff.1 (by rw [Equiv.apply_eq_iff_eq_symm_apply]; rfl) _\n\n"}
{"name":"PerfectionMap.lift_apply","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁸ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CharP R p\ninst✝⁵ : PerfectRing R p\nS : Type u₂\ninst✝⁴ : CommSemiring S\ninst✝³ : CharP S p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P S\nm : PerfectionMap p π\nf : RingHom R S\n⊢ Eq ((PerfectionMap.lift p R S P π m) f) ((↑m.equiv.symm).comp ((Perfection.lift p R S) f))","decl":"/-- Given rings `R` and `S` of characteristic `p`, with `R` being perfect,\nany homomorphism `R →+* S` can be lifted to a homomorphism `R →+* P`,\nwhere `P` is any perfection of `S`. -/\n@[simps]\nnoncomputable def lift [PerfectRing R p] (S : Type u₂) [CommSemiring S] [CharP S p] (P : Type u₃)\n    [CommSemiring P] [CharP P p] [PerfectRing P p] (π : P →+* S) (m : PerfectionMap p π) :\n    (R →+* S) ≃ (R →+* P) where\n  toFun f := RingHom.comp ↑m.equiv.symm <| Perfection.lift p R S f\n  invFun f := π.comp f\n  left_inv f := by\n    simp_rw [← RingHom.comp_assoc, comp_symm_equiv']\n    exact (Perfection.lift p R S).symm_apply_apply f\n  right_inv f := by\n    exact RingHom.ext fun x => m.equiv.injective <| (m.equiv.apply_symm_apply _).trans\n      <| show Perfection.lift p R S (π.comp f) x = RingHom.comp (↑m.equiv) f x from\n        RingHom.ext_iff.1 (by rw [Equiv.apply_eq_iff_eq_symm_apply]; rfl) _\n\n"}
{"name":"PerfectionMap.hom_ext","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁸ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CharP R p\ninst✝⁵ : PerfectRing R p\nS : Type u₂\ninst✝⁴ : CommSemiring S\ninst✝³ : CharP S p\nP : Type u₃\ninst✝² : CommSemiring P\ninst✝¹ : CharP P p\ninst✝ : PerfectRing P p\nπ : RingHom P S\nm : PerfectionMap p π\nf g : RingHom R P\nhfg : ∀ (x : R), Eq (π (f x)) (π (g x))\n⊢ Eq f g","decl":"theorem hom_ext [PerfectRing R p] {S : Type u₂} [CommSemiring S] [CharP S p] {P : Type u₃}\n    [CommSemiring P] [CharP P p] [PerfectRing P p] (π : P →+* S) (m : PerfectionMap p π)\n    {f g : R →+* P} (hfg : ∀ x, π (f x) = π (g x)) : f = g :=\n  (lift p R S P π m).symm.injective <| RingHom.ext hfg\n\n"}
{"name":"PerfectionMap.comp_map","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝¹⁰ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CharP R p\nP : Type u₃\ninst✝⁷ : CommSemiring P\ninst✝⁶ : CharP P p\ninst✝⁵ : PerfectRing P p\nS : Type u₂\ninst✝⁴ : CommSemiring S\ninst✝³ : CharP S p\nQ : Type u₄\ninst✝² : CommSemiring Q\ninst✝¹ : CharP Q p\ninst✝ : PerfectRing Q p\nπ : RingHom P R\nm : PerfectionMap p π\nσ : RingHom Q S\nn : PerfectionMap p σ\nφ : RingHom R S\n⊢ Eq (σ.comp (PerfectionMap.map p m n φ)) (φ.comp π)","decl":"theorem comp_map {π : P →+* R} (m : PerfectionMap p π) {σ : Q →+* S} (n : PerfectionMap p σ)\n    (φ : R →+* S) : σ.comp (map p m n φ) = φ.comp π :=\n  (lift p P S Q σ n).symm_apply_apply _\n\n"}
{"name":"PerfectionMap.map_map","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝¹⁰ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CharP R p\nP : Type u₃\ninst✝⁷ : CommSemiring P\ninst✝⁶ : CharP P p\ninst✝⁵ : PerfectRing P p\nS : Type u₂\ninst✝⁴ : CommSemiring S\ninst✝³ : CharP S p\nQ : Type u₄\ninst✝² : CommSemiring Q\ninst✝¹ : CharP Q p\ninst✝ : PerfectRing Q p\nπ : RingHom P R\nm : PerfectionMap p π\nσ : RingHom Q S\nn : PerfectionMap p σ\nφ : RingHom R S\nx : P\n⊢ Eq (σ ((PerfectionMap.map p m n φ) x)) (φ (π x))","decl":"theorem map_map {π : P →+* R} (m : PerfectionMap p π) {σ : Q →+* S} (n : PerfectionMap p σ)\n    (φ : R →+* S) (x : P) : σ (map p m n φ x) = φ (π x) :=\n  RingHom.ext_iff.1 (comp_map p m n φ) x\n\n"}
{"name":"PerfectionMap.map_eq_map","module":"Mathlib.RingTheory.Perfection","initialProofState":"p : Nat\ninst✝⁴ : Fact (Nat.Prime p)\nR : Type u₁\ninst✝³ : CommSemiring R\ninst✝² : CharP R p\nS : Type u₂\ninst✝¹ : CommSemiring S\ninst✝ : CharP S p\nφ : RingHom R S\n⊢ Eq (PerfectionMap.map p ⋯ ⋯ φ) (Perfection.map p φ)","decl":"theorem map_eq_map (φ : R →+* S) : map p (of p R) (of p S) φ = Perfection.map p φ :=\n  hom_ext _ (of p S) fun f => by rw [map_map, Perfection.coeff_map]\n\n"}
{"name":"ModP.charP","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝³ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝² : CommRing O\ninst✝¹ : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhvp : Fact (Ne (v ↑p) 1)\n⊢ CharP (ModP K v O hv p) p","decl":"instance charP [Fact p.Prime] [hvp : Fact (v p ≠ 1)] : CharP (ModP K v O hv p) p :=\n  CharP.quotient O p <| mt hv.one_of_isUnit <| (map_natCast (algebraMap O K) p).symm ▸ hvp.1\n\n"}
{"name":"ModP.instNontrivialOfPrimeOfFactNeNNRealCoeValuationCastOfNat","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝³ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝² : CommRing O\ninst✝¹ : Algebra O K\nhv : v.Integers O\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\n⊢ Nontrivial (ModP K v O hv p)","decl":"instance [hp : Fact p.Prime] [Fact (v p ≠ 1)] : Nontrivial (ModP K v O hv p) :=\n  CharP.nontrivial_of_char_ne_one hp.1.ne_one\n\n"}
{"name":"ModP.preVal_mk","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx : O\nhx : Ne ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton ↑p))) x) 0\n⊢ Eq (ModP.preVal K v O hv p ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton ↑p))) x)) (v ((algebraMap O K) x))","decl":"theorem preVal_mk {x : O} (hx : (Ideal.Quotient.mk _ x : ModP K v O hv p) ≠ 0) :\n    preVal K v O hv p (Ideal.Quotient.mk _ x) = v (algebraMap O K x) := by\n  obtain ⟨r, hr⟩ : ∃ (a : O), a * (p : O) = (Quotient.mk'' x).out - x :=\n    Ideal.mem_span_singleton'.1 <| Ideal.Quotient.eq.1 <| Quotient.sound' <| Quotient.mk_out' _\n  refine (if_neg hx).trans (v.map_eq_of_sub_lt <| lt_of_not_le ?_)\n  erw [← RingHom.map_sub, ← hr, hv.le_iff_dvd]\n  exact fun hprx =>\n    hx (Ideal.Quotient.eq_zero_iff_mem.2 <| Ideal.mem_span_singleton.2 <| dvd_of_mul_left_dvd hprx)\n\n"}
{"name":"ModP.preVal_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\n⊢ Eq (ModP.preVal K v O hv p 0) 0","decl":"theorem preVal_zero : preVal K v O hv p 0 = 0 :=\n  if_pos rfl\n\n"}
{"name":"ModP.preVal_mul","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx y : ModP K v O hv p\nhxy0 : Ne (HMul.hMul x y) 0\n⊢ Eq (ModP.preVal K v O hv p (HMul.hMul x y)) (HMul.hMul (ModP.preVal K v O hv p x) (ModP.preVal K v O hv p y))","decl":"theorem preVal_mul {x y : ModP K v O hv p} (hxy0 : x * y ≠ 0) :\n    preVal K v O hv p (x * y) = preVal K v O hv p x * preVal K v O hv p y := by\n  have hx0 : x ≠ 0 := mt (by rintro rfl; rw [zero_mul]) hxy0\n  have hy0 : y ≠ 0 := mt (by rintro rfl; rw [mul_zero]) hxy0\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← map_mul (Ideal.Quotient.mk (Ideal.span {↑p})) r s] at hxy0 ⊢\n  rw [preVal_mk hx0, preVal_mk hy0, preVal_mk hxy0, RingHom.map_mul, v.map_mul]\n\n"}
{"name":"ModP.preVal_add","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx y : ModP K v O hv p\n⊢ LE.le (ModP.preVal K v O hv p (HAdd.hAdd x y)) (Max.max (ModP.preVal K v O hv p x) (ModP.preVal K v O hv p y))","decl":"theorem preVal_add (x y : ModP K v O hv p) :\n    preVal K v O hv p (x + y) ≤ max (preVal K v O hv p x) (preVal K v O hv p y) := by\n  by_cases hx0 : x = 0\n  · rw [hx0, zero_add]; exact le_max_right _ _\n  by_cases hy0 : y = 0\n  · rw [hy0, add_zero]; exact le_max_left _ _\n  by_cases hxy0 : x + y = 0\n  · rw [hxy0, preVal_zero]; exact zero_le _\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  rw [← map_add (Ideal.Quotient.mk (Ideal.span {↑p})) r s] at hxy0 ⊢\n  rw [preVal_mk hx0, preVal_mk hy0, preVal_mk hxy0, RingHom.map_add]; exact v.map_add _ _\n\n"}
{"name":"ModP.v_p_lt_preVal","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx : ModP K v O hv p\n⊢ Iff (LT.lt (v ↑p) (ModP.preVal K v O hv p x)) (Ne x 0)","decl":"theorem v_p_lt_preVal {x : ModP K v O hv p} : v p < preVal K v O hv p x ↔ x ≠ 0 := by\n  refine ⟨fun h hx => by rw [hx, preVal_zero] at h; exact not_lt_zero' h,\n    fun h => lt_of_not_le fun hp => h ?_⟩\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  rw [preVal_mk h, ← map_natCast (algebraMap O K) p, hv.le_iff_dvd] at hp\n  rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]; exact hp\n\n"}
{"name":"ModP.preVal_eq_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx : ModP K v O hv p\n⊢ Iff (Eq (ModP.preVal K v O hv p x) 0) (Eq x 0)","decl":"theorem preVal_eq_zero {x : ModP K v O hv p} : preVal K v O hv p x = 0 ↔ x = 0 :=\n  ⟨fun hvx =>\n    by_contradiction fun hx0 : x ≠ 0 => by\n      rw [← v_p_lt_preVal, hvx] at hx0\n      exact not_lt_zero' hx0,\n    fun hx => hx.symm ▸ preVal_zero⟩\n\n"}
{"name":"ModP.v_p_lt_val","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nx : O\n⊢ Iff (LT.lt (v ↑p) (v ((algebraMap O K) x))) (Ne ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton ↑p))) x) 0)","decl":"theorem v_p_lt_val {x : O} :\n    v p < v (algebraMap O K x) ↔ (Ideal.Quotient.mk _ x : ModP K v O hv p) ≠ 0 := by\n  rw [lt_iff_not_le, not_iff_not, ← map_natCast (algebraMap O K) p, hv.le_iff_dvd,\n    Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]\n\n"}
{"name":"ModP.mul_ne_zero_of_pow_p_ne_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝² : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝¹ : CommRing O\ninst✝ : Algebra O K\nhv : v.Integers O\np : Nat\nhp : Fact (Nat.Prime p)\nx y : ModP K v O hv p\nhx : Ne (HPow.hPow x p) 0\nhy : Ne (HPow.hPow y p) 0\n⊢ Ne (HMul.hMul x y) 0","decl":"theorem mul_ne_zero_of_pow_p_ne_zero {x y : ModP K v O hv p} (hx : x ^ p ≠ 0) (hy : y ^ p ≠ 0) :\n    x * y ≠ 0 := by\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective x\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective y\n  have h1p : (0 : ℝ) < 1 / p := one_div_pos.2 (Nat.cast_pos.2 hp.1.pos)\n  rw [← (Ideal.Quotient.mk (Ideal.span {(p : O)})).map_mul]\n  rw [← (Ideal.Quotient.mk (Ideal.span {(p : O)})).map_pow] at hx hy\n  rw [← v_p_lt_val hv] at hx hy ⊢\n  rw [RingHom.map_pow, v.map_pow, ← rpow_lt_rpow_iff h1p, ← rpow_natCast, ← rpow_mul,\n    mul_one_div_cancel (Nat.cast_ne_zero.2 hp.1.ne_zero : (p : ℝ) ≠ 0), rpow_one] at hx hy\n  rw [RingHom.map_mul, v.map_mul]; refine lt_of_le_of_lt ?_ (mul_lt_mul'' hx hy zero_le' zero_le')\n  by_cases hvp : v p = 0\n  · rw [hvp]; exact zero_le _\n  replace hvp := zero_lt_iff.2 hvp\n  conv_lhs => rw [← rpow_one (v p)]\n  rw [← rpow_add (ne_of_gt hvp)]\n  refine rpow_le_rpow_of_exponent_ge hvp (map_natCast (algebraMap O K) p ▸ hv.2 _) ?_\n  rw [← add_div, div_le_one (Nat.cast_pos.2 hp.1.pos : 0 < (p : ℝ))]; exact mod_cast hp.1.two_le\n\n"}
{"name":"PreTilt.instCharP","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\n⊢ CharP (PreTilt K v O hv p) p","decl":"instance : CharP (PreTilt K v O hv p) p :=\n  Perfection.charP (ModP K v O hv p) p\n\n"}
{"name":"PreTilt.coeff_nat_find_add_ne_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\nf : PreTilt K v O hv p\nh : Exists fun n => Ne ((Perfection.coeff (ModP K v O hv p) p n) f) 0\nk : Nat\n⊢ Ne ((Perfection.coeff (ModP K v O hv p) p (HAdd.hAdd (Nat.find h) k)) f) 0","decl":"open scoped Classical in\ntheorem coeff_nat_find_add_ne_zero {f : PreTilt K v O hv p} {h : ∃ n, coeff _ _ n f ≠ 0} (k : ℕ) :\n    coeff _ _ (Nat.find h + k) f ≠ 0 :=\n  coeff_add_ne_zero (Nat.find_spec h) k\n\n"}
{"name":"PreTilt.valAux_eq","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\nf : PreTilt K v O hv p\nn : Nat\nhfn : Ne ((Perfection.coeff (ModP K v O hv p) p n) f) 0\n⊢ Eq (PreTilt.valAux K v O hv p f) (HPow.hPow (ModP.preVal K v O hv p ((Perfection.coeff (ModP K v O hv p) p n) f)) (HPow.hPow p n))","decl":"theorem valAux_eq {f : PreTilt K v O hv p} {n : ℕ} (hfn : coeff _ _ n f ≠ 0) :\n    valAux K v O hv p f = ModP.preVal K v O hv p (coeff _ _ n f) ^ p ^ n := by\n  have h : ∃ n, coeff _ _ n f ≠ 0 := ⟨n, hfn⟩\n  rw [valAux, dif_pos h]\n  classical\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le (Nat.find_min' h hfn)\n  induction' k with k ih\n  · rfl\n  obtain ⟨x, hx⟩ := Ideal.Quotient.mk_surjective (coeff (ModP K v O hv p) p (Nat.find h + k + 1) f)\n  have h1 : (Ideal.Quotient.mk _ x : ModP K v O hv p) ≠ 0 := hx.symm ▸ hfn\n  have h2 : (Ideal.Quotient.mk _ (x ^ p) : ModP K v O hv p) ≠ 0 := by\n    erw [RingHom.map_pow, hx, ← RingHom.map_pow, coeff_pow_p]\n    exact coeff_nat_find_add_ne_zero k\n  erw [ih (coeff_nat_find_add_ne_zero k), ← hx, ← coeff_pow_p, RingHom.map_pow, ← hx,\n    ← RingHom.map_pow, ModP.preVal_mk h1, ModP.preVal_mk h2, RingHom.map_pow, v.map_pow, ← pow_mul,\n    pow_succ']\n  rfl\n\n"}
{"name":"PreTilt.valAux_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\n⊢ Eq (PreTilt.valAux K v O hv p 0) 0","decl":"theorem valAux_zero : valAux K v O hv p 0 = 0 :=\n  dif_neg fun ⟨_, hn⟩ => hn rfl\n\n"}
{"name":"PreTilt.valAux_one","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\n⊢ Eq (PreTilt.valAux K v O hv p 1) 1","decl":"theorem valAux_one : valAux K v O hv p 1 = 1 :=\n  (valAux_eq <| show coeff (ModP K v O hv p) p 0 1 ≠ 0 from one_ne_zero).trans <| by\n    rw [pow_zero, pow_one, RingHom.map_one, ← (Ideal.Quotient.mk _).map_one, ModP.preVal_mk,\n      RingHom.map_one, v.map_one]\n    change (1 : ModP K v O hv p) ≠ 0\n    exact one_ne_zero\n\n"}
{"name":"PreTilt.valAux_mul","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\nf g : PreTilt K v O hv p\n⊢ Eq (PreTilt.valAux K v O hv p (HMul.hMul f g)) (HMul.hMul (PreTilt.valAux K v O hv p f) (PreTilt.valAux K v O hv p g))","decl":"theorem valAux_mul (f g : PreTilt K v O hv p) :\n    valAux K v O hv p (f * g) = valAux K v O hv p f * valAux K v O hv p g := by\n  by_cases hf : f = 0\n  · rw [hf, zero_mul, valAux_zero, zero_mul]\n  by_cases hg : g = 0\n  · rw [hg, mul_zero, valAux_zero, mul_zero]\n  obtain ⟨m, hm⟩ : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf <| Perfection.ext h\n  obtain ⟨n, hn⟩ : ∃ n, coeff _ _ n g ≠ 0 := not_forall.1 fun h => hg <| Perfection.ext h\n  replace hm := coeff_ne_zero_of_le hm (le_max_left m n)\n  replace hn := coeff_ne_zero_of_le hn (le_max_right m n)\n  have hfg : coeff _ _ (max m n + 1) (f * g) ≠ 0 := by\n    rw [RingHom.map_mul]\n    refine ModP.mul_ne_zero_of_pow_p_ne_zero ?_ ?_\n    · rw [← RingHom.map_pow, coeff_pow_p f]; assumption\n    · rw [← RingHom.map_pow, coeff_pow_p g]; assumption\n  rw [valAux_eq (coeff_add_ne_zero hm 1), valAux_eq (coeff_add_ne_zero hn 1), valAux_eq hfg]\n  rw [RingHom.map_mul] at hfg ⊢; rw [ModP.preVal_mul hfg, mul_pow]\n\n"}
{"name":"PreTilt.valAux_add","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\nf g : PreTilt K v O hv p\n⊢ LE.le (PreTilt.valAux K v O hv p (HAdd.hAdd f g)) (Max.max (PreTilt.valAux K v O hv p f) (PreTilt.valAux K v O hv p g))","decl":"theorem valAux_add (f g : PreTilt K v O hv p) :\n    valAux K v O hv p (f + g) ≤ max (valAux K v O hv p f) (valAux K v O hv p g) := by\n  by_cases hf : f = 0\n  · rw [hf, zero_add, valAux_zero, max_eq_right]; exact zero_le _\n  by_cases hg : g = 0\n  · rw [hg, add_zero, valAux_zero, max_eq_left]; exact zero_le _\n  by_cases hfg : f + g = 0\n  · rw [hfg, valAux_zero]; exact zero_le _\n  replace hf : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf <| Perfection.ext h\n  replace hg : ∃ n, coeff _ _ n g ≠ 0 := not_forall.1 fun h => hg <| Perfection.ext h\n  replace hfg : ∃ n, coeff _ _ n (f + g) ≠ 0 := not_forall.1 fun h => hfg <| Perfection.ext h\n  obtain ⟨m, hm⟩ := hf; obtain ⟨n, hn⟩ := hg; obtain ⟨k, hk⟩ := hfg\n  replace hm := coeff_ne_zero_of_le hm (le_trans (le_max_left m n) (le_max_left _ k))\n  replace hn := coeff_ne_zero_of_le hn (le_trans (le_max_right m n) (le_max_left _ k))\n  replace hk := coeff_ne_zero_of_le hk (le_max_right (max m n) k)\n  rw [valAux_eq hm, valAux_eq hn, valAux_eq hk, RingHom.map_add]\n  cases' le_max_iff.1\n      (ModP.preVal_add (coeff _ _ (max (max m n) k) f) (coeff _ _ (max (max m n) k) g)) with h h\n  · exact le_max_of_le_left (pow_le_pow_left' h _)\n  · exact le_max_of_le_right (pow_le_pow_left' h _)\n\n"}
{"name":"PreTilt.map_eq_zero","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝⁴ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝³ : CommRing O\ninst✝² : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Ne (v ↑p) 1)\nf : PreTilt K v O hv p\n⊢ Iff (Eq ((PreTilt.val K v O hv p) f) 0) (Eq f 0)","decl":"theorem map_eq_zero {f : PreTilt K v O hv p} : val K v O hv p f = 0 ↔ f = 0 := by\n  by_cases hf0 : f = 0\n  · rw [hf0]; exact iff_of_true (Valuation.map_zero _) rfl\n  obtain ⟨n, hn⟩ : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 fun h => hf0 <| Perfection.ext h\n  show valAux K v O hv p f = 0 ↔ f = 0; refine iff_of_false (fun hvf => hn ?_) hf0\n  rw [valAux_eq hn] at hvf; replace hvf := pow_eq_zero hvf; rwa [ModP.preVal_eq_zero] at hvf\n\n"}
{"name":"PreTilt.instIsDomain","module":"Mathlib.RingTheory.Perfection","initialProofState":"K : Type u₁\ninst✝³ : Field K\nv : Valuation K NNReal\nO : Type u₂\ninst✝² : CommRing O\ninst✝¹ : Algebra O K\nhv : v.Integers O\np : Nat\ninst✝ : Fact (Ne (v ↑p) 1)\nhp : Fact (Nat.Prime p)\n⊢ IsDomain (PreTilt K v O hv p)","decl":"instance [hp : Fact p.Prime] : IsDomain (PreTilt K v O hv p) := by\n  haveI : Nontrivial (PreTilt K v O hv p) := ⟨(CharP.nontrivial_of_char_ne_one hp.1.ne_one).1⟩\n  haveI : NoZeroDivisors (PreTilt K v O hv p) :=\n    ⟨fun hfg => by\n      simp_rw [← map_eq_zero] at hfg ⊢; contrapose! hfg; rw [Valuation.map_mul]\n      exact mul_ne_zero hfg.1 hfg.2⟩\n  exact NoZeroDivisors.to_isDomain _\n\n"}
