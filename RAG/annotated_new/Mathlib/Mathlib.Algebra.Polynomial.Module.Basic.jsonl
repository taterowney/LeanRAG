{"name":"PolynomialModule.zero_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\n⊢ Eq (0 i) 0","decl":"theorem zero_apply (i : ℕ) : (0 : PolynomialModule R M) i = 0 :=\n  Finsupp.zero_apply\n\n"}
{"name":"PolynomialModule.add_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ng₁ g₂ : PolynomialModule R M\na : Nat\n⊢ Eq ((HAdd.hAdd g₁ g₂) a) (HAdd.hAdd (g₁ a) (g₂ a))","decl":"theorem add_apply (g₁ g₂ : PolynomialModule R M) (a : ℕ) : (g₁ + g₂) a = g₁ a + g₂ a :=\n  Finsupp.add_apply g₁ g₂ a\n\n"}
{"name":"PolynomialModule.single_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nm : M\nn : Nat\n⊢ Eq (((PolynomialModule.single R i) m) n) (ite (Eq i n) m 0)","decl":"theorem single_apply (i : ℕ) (m : M) (n : ℕ) : single R i m n = ite (i = n) m 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"PolynomialModule.lsingle_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nm : M\nn : Nat\n⊢ Eq (((PolynomialModule.lsingle R i) m) n) (ite (Eq i n) m 0)","decl":"theorem lsingle_apply (i : ℕ) (m : M) (n : ℕ) : lsingle R i m n = ite (i = n) m 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"PolynomialModule.single_smul","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nr : R\nm : M\n⊢ Eq ((PolynomialModule.single R i) (HSMul.hSMul r m)) (HSMul.hSMul r ((PolynomialModule.single R i) m))","decl":"theorem single_smul (i : ℕ) (r : R) (m : M) : single R i (r • m) = r • single R i m :=\n  (lsingle R i).map_smul r m\n\n"}
{"name":"PolynomialModule.induction_linear","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nP : PolynomialModule R M → Prop\nf : PolynomialModule R M\nh0 : P 0\nhadd : ∀ (f g : PolynomialModule R M), P f → P g → P (HAdd.hAdd f g)\nhsingle : ∀ (a : Nat) (b : M), P ((PolynomialModule.single R a) b)\n⊢ P f","decl":"theorem induction_linear {P : PolynomialModule R M → Prop} (f : PolynomialModule R M) (h0 : P 0)\n    (hadd : ∀ f g, P f → P g → P (f + g)) (hsingle : ∀ a b, P (single R a b)) : P f :=\n  Finsupp.induction_linear f h0 hadd hsingle\n\n"}
{"name":"PolynomialModule.smul_def","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Polynomial R\nm : PolynomialModule R M\n⊢ Eq (HSMul.hSMul f m) (((Polynomial.aeval (Finsupp.lmapDomain M R Nat.succ)) f) m)","decl":"lemma smul_def (f : R[X]) (m : PolynomialModule R M) :\n    f • m = aeval (Finsupp.lmapDomain M R Nat.succ) f m := by\n  rfl\n\n"}
{"name":"PolynomialModule.instIsScalarTower","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Type u_3\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\nM : Type u\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\n⊢ IsScalarTower S R (PolynomialModule R M)","decl":"instance (M : Type u) [AddCommGroup M] [Module R M] [Module S M] [IsScalarTower S R M] :\n    IsScalarTower S R (PolynomialModule R M) :=\n  Finsupp.isScalarTower _ _\n\n"}
{"name":"PolynomialModule.isScalarTower'","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nS : Type u_3\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\nM : Type u\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\n⊢ IsScalarTower S (Polynomial R) (PolynomialModule R M)","decl":"instance isScalarTower' (M : Type u) [AddCommGroup M] [Module R M] [Module S M]\n    [IsScalarTower S R M] : IsScalarTower S R[X] (PolynomialModule R M) := by\n  haveI : IsScalarTower R R[X] (PolynomialModule R M) :=\n    inferInstanceAs <| IsScalarTower R R[X] <| Module.AEval' <| Finsupp.lmapDomain M R Nat.succ\n  constructor\n  intro x y z\n  rw [← @IsScalarTower.algebraMap_smul S R, ← @IsScalarTower.algebraMap_smul S R, smul_assoc]\n\n"}
{"name":"PolynomialModule.monomial_smul_single","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nr : R\nj : Nat\nm : M\n⊢ Eq (HSMul.hSMul ((Polynomial.monomial i) r) ((PolynomialModule.single R j) m)) ((PolynomialModule.single R (HAdd.hAdd i j)) (HSMul.hSMul r m))","decl":"@[simp]\ntheorem monomial_smul_single (i : ℕ) (r : R) (j : ℕ) (m : M) :\n    monomial i r • single R j m = single R (i + j) (r • m) := by\n  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,\n    Module.algebraMap_end_apply, smul_def]\n  induction i generalizing r j m with\n  | zero =>\n    rw [Function.iterate_zero, zero_add]\n    exact Finsupp.smul_single r j m\n  | succ n hn =>\n    rw [Function.iterate_succ, Function.comp_apply, add_assoc, ← hn]\n    congr 2\n    rw [Nat.one_add]\n    exact Finsupp.mapDomain_single\n\n"}
{"name":"PolynomialModule.monomial_smul_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nr : R\ng : PolynomialModule R M\nn : Nat\n⊢ Eq ((HSMul.hSMul ((Polynomial.monomial i) r) g) n) (ite (LE.le i n) (HSMul.hSMul r (g (HSub.hSub n i))) 0)","decl":"@[simp]\ntheorem monomial_smul_apply (i : ℕ) (r : R) (g : PolynomialModule R M) (n : ℕ) :\n    (monomial i r • g) n = ite (i ≤ n) (r • g (n - i)) 0 := by\n  induction' g using PolynomialModule.induction_linear with p q hp hq\n  · simp only [smul_zero, zero_apply, ite_self]\n  · simp only [smul_add, add_apply, hp, hq]\n    split_ifs\n    exacts [rfl, zero_add 0]\n  · rw [monomial_smul_single, single_apply, single_apply, smul_ite, smul_zero, ← ite_and]\n    congr\n    rw [eq_iff_iff]\n    constructor\n    · rintro rfl\n      simp\n    · rintro ⟨e, rfl⟩\n      rw [add_comm, tsub_add_cancel_of_le e]\n\n"}
{"name":"PolynomialModule.smul_single_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nf : Polynomial R\nm : M\nn : Nat\n⊢ Eq ((HSMul.hSMul f ((PolynomialModule.single R i) m)) n) (ite (LE.le i n) (HSMul.hSMul (f.coeff (HSub.hSub n i)) m) 0)","decl":"@[simp]\ntheorem smul_single_apply (i : ℕ) (f : R[X]) (m : M) (n : ℕ) :\n    (f • single R i m) n = ite (i ≤ n) (f.coeff (n - i) • m) 0 := by\n  induction' f using Polynomial.induction_on' with p q hp hq\n  · rw [add_smul, Finsupp.add_apply, hp, hq, coeff_add, add_smul]\n    split_ifs\n    exacts [rfl, zero_add 0]\n  · rw [monomial_smul_single, single_apply, coeff_monomial, ite_smul, zero_smul]\n    by_cases h : i ≤ n\n    · simp_rw [eq_tsub_iff_add_eq_of_le h, if_pos h]\n    · rw [if_neg h, if_neg]\n      omega\n\n"}
{"name":"PolynomialModule.smul_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Polynomial R\ng : PolynomialModule R M\nn : Nat\n⊢ Eq ((HSMul.hSMul f g) n) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => HSMul.hSMul (f.coeff x.1) (g x.2))","decl":"theorem smul_apply (f : R[X]) (g : PolynomialModule R M) (n : ℕ) :\n    (f • g) n = ∑ x ∈ Finset.antidiagonal n, f.coeff x.1 • g x.2 := by\n  induction' f using Polynomial.induction_on' with p q hp hq f_n f_a\n  · rw [add_smul, Finsupp.add_apply, hp, hq, ← Finset.sum_add_distrib]\n    congr\n    ext\n    rw [coeff_add, add_smul]\n  · rw [Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => (monomial f_n f_a).coeff i • g j,\n      monomial_smul_apply]\n    simp_rw [Polynomial.coeff_monomial, ← Finset.mem_range_succ_iff]\n    rw [← Finset.sum_ite_eq (Finset.range (Nat.succ n)) f_n (fun x => f_a • g (n - x))]\n    congr\n    ext x\n    split_ifs\n    exacts [rfl, (zero_smul R _).symm]\n\n"}
{"name":"PolynomialModule.equivPolynomialSelf_apply_eq","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : PolynomialModule R R\n⊢ Eq (PolynomialModule.equivPolynomialSelf p) (PolynomialModule.equivPolynomial p)","decl":"@[simp]\nlemma equivPolynomialSelf_apply_eq (p : PolynomialModule R R) :\n    equivPolynomialSelf p = equivPolynomial p := rfl\n\n"}
{"name":"PolynomialModule.equivPolynomial_single","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_4\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nn : Nat\nx : S\n⊢ Eq (PolynomialModule.equivPolynomial ((PolynomialModule.single R n) x)) ((Polynomial.monomial n) x)","decl":"@[simp]\nlemma equivPolynomial_single {S : Type*} [CommRing S] [Algebra R S] (n : ℕ) (x : S) :\n    equivPolynomial (single R n x) = monomial n x := rfl\n\n"}
{"name":"PolynomialModule.map_single","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nR' : Type u_4\nM' : Type u_5\ninst✝³ : CommRing R'\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R' M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ni : Nat\nm : M\n⊢ Eq ((PolynomialModule.map R' f) ((PolynomialModule.single R i) m)) ((PolynomialModule.single R' i) (f m))","decl":"@[simp]\ntheorem map_single (f : M →ₗ[R] M') (i : ℕ) (m : M) : map R' f (single R i m) = single R' i (f m) :=\n  Finsupp.mapRange_single (hf := f.map_zero)\n\n"}
{"name":"PolynomialModule.map_smul","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nR' : Type u_4\nM' : Type u_5\ninst✝⁵ : CommRing R'\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R' M'\ninst✝² : Module R M'\ninst✝¹ : Algebra R R'\ninst✝ : IsScalarTower R R' M'\nf : LinearMap (RingHom.id R) M M'\np : Polynomial R\nq : PolynomialModule R M\n⊢ Eq ((PolynomialModule.map R' f) (HSMul.hSMul p q)) (HSMul.hSMul (Polynomial.map (algebraMap R R') p) ((PolynomialModule.map R' f) q))","decl":"theorem map_smul (f : M →ₗ[R] M') (p : R[X]) (q : PolynomialModule R M) :\n    map R' f (p • q) = p.map (algebraMap R R') • map R' f q := by\n  apply induction_linear q\n  · rw [smul_zero, map_zero, smul_zero]\n  · intro f g e₁ e₂\n    rw [smul_add, map_add, e₁, e₂, map_add, smul_add]\n  intro i m\n  induction p using Polynomial.induction_on' with\n  | h_add _ _ e₁ e₂ => rw [add_smul, map_add, e₁, e₂, Polynomial.map_add, add_smul]\n  | h_monomial => rw [monomial_smul_single, map_single, Polynomial.map_monomial, map_single,\n      monomial_smul_single, f.map_smul, algebraMap_smul]\n\n"}
{"name":"PolynomialModule.eval_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\np : PolynomialModule R M\n⊢ Eq ((PolynomialModule.eval r) p) (Finsupp.sum p fun i m => HSMul.hSMul (HPow.hPow r i) m)","decl":"/-- Evaluate a polynomial `p : PolynomialModule R M` at `r : R`. -/\n@[simps! (config := .lemmasOnly)]\ndef eval (r : R) : PolynomialModule R M →ₗ[R] M where\n  toFun p := p.sum fun i m => r ^ i • m\n  map_add' _ _ := Finsupp.sum_add_index' (fun _ => smul_zero _) fun _ _ _ => smul_add _ _ _\n  map_smul' s m := by\n    refine (Finsupp.sum_smul_index' ?_).trans ?_\n    · exact fun i => smul_zero _\n    · simp_rw [RingHom.id_apply, Finsupp.smul_sum]\n      congr\n      ext i c\n      rw [smul_comm]\n\n"}
{"name":"PolynomialModule.eval_single","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\ni : Nat\nm : M\n⊢ Eq ((PolynomialModule.eval r) ((PolynomialModule.single R i) m)) (HSMul.hSMul (HPow.hPow r i) m)","decl":"@[simp]\ntheorem eval_single (r : R) (i : ℕ) (m : M) : eval r (single R i m) = r ^ i • m :=\n  Finsupp.sum_single_index (smul_zero _)\n\n"}
{"name":"PolynomialModule.eval_lsingle","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\ni : Nat\nm : M\n⊢ Eq ((PolynomialModule.eval r) ((PolynomialModule.lsingle R i) m)) (HSMul.hSMul (HPow.hPow r i) m)","decl":"@[simp]\ntheorem eval_lsingle (r : R) (i : ℕ) (m : M) : eval r (lsingle R i m) = r ^ i • m :=\n  eval_single r i m\n\n"}
{"name":"PolynomialModule.eval_smul","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Polynomial R\nq : PolynomialModule R M\nr : R\n⊢ Eq ((PolynomialModule.eval r) (HSMul.hSMul p q)) (HSMul.hSMul (Polynomial.eval r p) ((PolynomialModule.eval r) q))","decl":"theorem eval_smul (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (p • q) = p.eval r • eval r q := by\n  apply induction_linear q\n  · rw [smul_zero, map_zero, smul_zero]\n  · intro f g e₁ e₂\n    rw [smul_add, map_add, e₁, e₂, map_add, smul_add]\n  intro i m\n  induction p using Polynomial.induction_on' with\n  | h_add _ _ e₁ e₂ => rw [add_smul, map_add, Polynomial.eval_add, e₁, e₂, add_smul]\n  | h_monomial => simp only [monomial_smul_single, Polynomial.eval_monomial, eval_single]; module\n\n"}
{"name":"PolynomialModule.eval_map","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nR' : Type u_4\nM' : Type u_5\ninst✝⁵ : CommRing R'\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R' M'\ninst✝² : Module R M'\ninst✝¹ : Algebra R R'\ninst✝ : IsScalarTower R R' M'\nf : LinearMap (RingHom.id R) M M'\nq : PolynomialModule R M\nr : R\n⊢ Eq ((PolynomialModule.eval ((algebraMap R R') r)) ((PolynomialModule.map R' f) q)) (f ((PolynomialModule.eval r) q))","decl":"@[simp]\ntheorem eval_map (f : M →ₗ[R] M') (q : PolynomialModule R M) (r : R) :\n    eval (algebraMap R R' r) (map R' f q) = f (eval r q) := by\n  apply induction_linear q\n  · simp_rw [map_zero]\n  · intro f g e₁ e₂\n    simp_rw [map_add, e₁, e₂]\n  · intro i m\n    simp only [map_single, eval_single, f.map_smul]\n    module\n\n"}
{"name":"PolynomialModule.eval_map'","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nq : PolynomialModule R M\nr : R\n⊢ Eq ((PolynomialModule.eval r) ((PolynomialModule.map R f) q)) (f ((PolynomialModule.eval r) q))","decl":"@[simp]\ntheorem eval_map' (f : M →ₗ[R] M) (q : PolynomialModule R M) (r : R) :\n    eval r (map R f q) = f (eval r q) :=\n  eval_map R f q r\n\n"}
{"name":"PolynomialModule.aeval_equivPolynomial","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_6\ninst✝¹ : CommRing S\ninst✝ : Algebra S R\nf : PolynomialModule S S\nx : R\n⊢ Eq ((Polynomial.aeval x) (PolynomialModule.equivPolynomial f)) ((PolynomialModule.eval x) ((PolynomialModule.map R (Algebra.linearMap S R)) f))","decl":"@[simp]\nlemma aeval_equivPolynomial {S : Type*} [CommRing S] [Algebra S R]\n    (f : PolynomialModule S S) (x : R) :\n    aeval x (equivPolynomial f) = eval x (map R (Algebra.linearMap S R) f) := by\n  apply induction_linear f\n  · simp\n  · intro f g e₁ e₂\n    simp_rw [map_add, e₁, e₂]\n  · intro i m\n    rw [equivPolynomial_single, aeval_monomial, mul_comm, map_single,\n      Algebra.linearMap_apply, eval_single, smul_eq_mul]\n\n"}
{"name":"PolynomialModule.comp_apply","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Polynomial R\na✝ : PolynomialModule R M\n⊢ Eq ((PolynomialModule.comp p) a✝) ((PolynomialModule.eval p) ((PolynomialModule.map (Polynomial R) (PolynomialModule.lsingle R 0)) a✝))","decl":"/-- `comp p q` is the composition of `p : R[X]` and `q : M[X]` as `q(p(x))`. -/\n@[simps!]\nnoncomputable def comp (p : R[X]) : PolynomialModule R M →ₗ[R] PolynomialModule R M :=\n  LinearMap.comp ((eval p).restrictScalars R) (map R[X] (lsingle R 0))\n\n"}
{"name":"PolynomialModule.comp_single","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Polynomial R\ni : Nat\nm : M\n⊢ Eq ((PolynomialModule.comp p) ((PolynomialModule.single R i) m)) (HSMul.hSMul (HPow.hPow p i) ((PolynomialModule.single R 0) m))","decl":"theorem comp_single (p : R[X]) (i : ℕ) (m : M) : comp p (single R i m) = p ^ i • single R 0 m := by\n  rw [comp_apply, map_single, eval_single]\n  rfl\n\n"}
{"name":"PolynomialModule.comp_eval","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Polynomial R\nq : PolynomialModule R M\nr : R\n⊢ Eq ((PolynomialModule.eval r) ((PolynomialModule.comp p) q)) ((PolynomialModule.eval (Polynomial.eval r p)) q)","decl":"theorem comp_eval (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (comp p q) = eval (p.eval r) q := by\n  rw [← LinearMap.comp_apply]\n  apply induction_linear q\n  · simp_rw [map_zero]\n  · intro _ _ e₁ e₂\n    simp_rw [map_add, e₁, e₂]\n  · intro i m\n    rw [LinearMap.comp_apply, comp_single, eval_single, eval_smul, eval_single, eval_pow]\n    module\n\n"}
{"name":"PolynomialModule.comp_smul","module":"Mathlib.Algebra.Polynomial.Module.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Polynomial R\nq : PolynomialModule R M\n⊢ Eq ((PolynomialModule.comp p) (HSMul.hSMul p' q)) (HSMul.hSMul (p'.comp p) ((PolynomialModule.comp p) q))","decl":"theorem comp_smul (p p' : R[X]) (q : PolynomialModule R M) :\n    comp p (p' • q) = p'.comp p • comp p q := by\n  rw [comp_apply, map_smul, eval_smul, Polynomial.comp, Polynomial.eval_map, comp_apply]\n  rfl\n\n"}
