{"name":"CategoryTheory.Groupoid.vertexGroup_mul","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc : C\nx y : Quiver.Hom c c\n‚ä¢ Eq (HMul.hMul x y) (CategoryTheory.CategoryStruct.comp x y)","decl":"/-- The vertex group at `c`. -/\n@[simps mul one inv]\ninstance vertexGroup (c : C) : Group (c ‚ü∂ c) where\n  mul := fun x y : c ‚ü∂ c => x ‚â´ y\n  mul_assoc := Category.assoc\n  one := ùüô c\n  one_mul := Category.id_comp\n  mul_one := Category.comp_id\n  inv := Groupoid.inv\n  inv_mul_cancel := inv_comp\n\n-- dsimp loops when applying this lemma to its LHS,\n-- probably https://github.com/leanprover/lean4/pull/2867\n"}
{"name":"CategoryTheory.Groupoid.vertexGroup_inv","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc : C\na‚úù : Quiver.Hom c c\n‚ä¢ Eq (Inv.inv a‚úù) (CategoryTheory.Groupoid.inv a‚úù)","decl":"/-- The vertex group at `c`. -/\n@[simps mul one inv]\ninstance vertexGroup (c : C) : Group (c ‚ü∂ c) where\n  mul := fun x y : c ‚ü∂ c => x ‚â´ y\n  mul_assoc := Category.assoc\n  one := ùüô c\n  one_mul := Category.id_comp\n  mul_one := Category.comp_id\n  inv := Groupoid.inv\n  inv_mul_cancel := inv_comp\n\n-- dsimp loops when applying this lemma to its LHS,\n-- probably https://github.com/leanprover/lean4/pull/2867\n"}
{"name":"CategoryTheory.Groupoid.vertexGroup_one","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc : C\n‚ä¢ Eq 1 (CategoryTheory.CategoryStruct.id c)","decl":"/-- The vertex group at `c`. -/\n@[simps mul one inv]\ninstance vertexGroup (c : C) : Group (c ‚ü∂ c) where\n  mul := fun x y : c ‚ü∂ c => x ‚â´ y\n  mul_assoc := Category.assoc\n  one := ùüô c\n  one_mul := Category.id_comp\n  mul_one := Category.comp_id\n  inv := Groupoid.inv\n  inv_mul_cancel := inv_comp\n\n-- dsimp loops when applying this lemma to its LHS,\n-- probably https://github.com/leanprover/lean4/pull/2867\n"}
{"name":"CategoryTheory.Groupoid.vertexGroup.inv_eq_inv","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc : C\nŒ≥ : Quiver.Hom c c\n‚ä¢ Eq (Inv.inv Œ≥) (CategoryTheory.inv Œ≥)","decl":"/-- The inverse in the group is equal to the inverse given by `CategoryTheory.inv`. -/\ntheorem vertexGroup.inv_eq_inv (c : C) (Œ≥ : c ‚ü∂ c) : Œ≥‚Åª¬π = CategoryTheory.inv Œ≥ :=\n  Groupoid.inv_eq_inv Œ≥\n\n"}
{"name":"CategoryTheory.Groupoid.vertexGroupIsomOfMap_symm_apply","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\nŒ¥ : Quiver.Hom d d\n‚ä¢ Eq ((CategoryTheory.Groupoid.vertexGroupIsomOfMap f).symm Œ¥) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp Œ¥ (CategoryTheory.Groupoid.inv f)))","decl":"/-- An arrow in the groupoid defines, by conjugation, an isomorphism of groups between\nits endpoints.\n-/\n@[simps]\ndef vertexGroupIsomOfMap {c d : C} (f : c ‚ü∂ d) : (c ‚ü∂ c) ‚âÉ* (d ‚ü∂ d) where\n  toFun Œ≥ := inv f ‚â´ Œ≥ ‚â´ f\n  invFun Œ¥ := f ‚â´ Œ¥ ‚â´ inv f\n  left_inv Œ≥ := by\n    simp_rw [Category.assoc, comp_inv, Category.comp_id, ‚Üê Category.assoc, comp_inv,\n      Category.id_comp]\n  right_inv Œ¥ := by\n    simp_rw [Category.assoc, inv_comp, ‚Üê Category.assoc, inv_comp, Category.id_comp,\n      Category.comp_id]\n  map_mul' Œ≥‚ÇÅ Œ≥‚ÇÇ := by\n    simp only [vertexGroup_mul, inv_eq_inv, Category.assoc, IsIso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Groupoid.vertexGroupIsomOfMap_apply","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\nŒ≥ : Quiver.Hom c c\n‚ä¢ Eq ((CategoryTheory.Groupoid.vertexGroupIsomOfMap f) Œ≥) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv f) (CategoryTheory.CategoryStruct.comp Œ≥ f))","decl":"/-- An arrow in the groupoid defines, by conjugation, an isomorphism of groups between\nits endpoints.\n-/\n@[simps]\ndef vertexGroupIsomOfMap {c d : C} (f : c ‚ü∂ d) : (c ‚ü∂ c) ‚âÉ* (d ‚ü∂ d) where\n  toFun Œ≥ := inv f ‚â´ Œ≥ ‚â´ f\n  invFun Œ¥ := f ‚â´ Œ¥ ‚â´ inv f\n  left_inv Œ≥ := by\n    simp_rw [Category.assoc, comp_inv, Category.comp_id, ‚Üê Category.assoc, comp_inv,\n      Category.id_comp]\n  right_inv Œ¥ := by\n    simp_rw [Category.assoc, inv_comp, ‚Üê Category.assoc, inv_comp, Category.id_comp,\n      Category.comp_id]\n  map_mul' Œ≥‚ÇÅ Œ≥‚ÇÇ := by\n    simp only [vertexGroup_mul, inv_eq_inv, Category.assoc, IsIso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Groupoid.CategoryTheory.Functor.mapVertexGroup_apply","module":"Mathlib.CategoryTheory.Groupoid.VertexGroup","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type v\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nc : C\na‚úù : Quiver.Hom c c\n‚ä¢ Eq ((CategoryTheory.Groupoid.CategoryTheory.Functor.mapVertexGroup œÜ c) a‚úù) (œÜ.map a‚úù)","decl":"/-- A functor defines a morphism of vertex group. -/\n@[simps]\ndef CategoryTheory.Functor.mapVertexGroup {D : Type v} [Groupoid D] (œÜ : C ‚•§ D) (c : C) :\n    (c ‚ü∂ c) ‚Üí* (œÜ.obj c ‚ü∂ œÜ.obj c) where\n  toFun := œÜ.map\n  map_one' := œÜ.map_id c\n  map_mul' := œÜ.map_comp\n\n"}
