{"name":"MeasureTheory.pdf.IsUniform.aemeasurable","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhns : Ne (μ s) 0\nhnt : Ne (μ s) Top.top\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ AEMeasurable X ℙ","decl":"theorem aemeasurable {X : Ω → E} {s : Set E} (hns : μ s ≠ 0) (hnt : μ s ≠ ∞)\n    (hu : IsUniform X s ℙ μ) : AEMeasurable X ℙ := by\n  dsimp [IsUniform, ProbabilityTheory.cond] at hu\n  by_contra h\n  rw [map_of_not_aemeasurable h] at hu\n  apply zero_ne_one' ℝ≥0∞\n  calc\n    0 = (0 : Measure E) Set.univ := rfl\n    _ = _ := by rw [hu, smul_apply, restrict_apply MeasurableSet.univ,\n      Set.univ_inter, smul_eq_mul, ENNReal.inv_mul_cancel hns hnt]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.absolutelyContinuous","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ (MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ","decl":"theorem absolutelyContinuous {X : Ω → E} {s : Set E} (hu : IsUniform X s ℙ μ) : map X ℙ ≪ μ := by\n  rw [hu]; exact ProbabilityTheory.cond_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.measure_preimage","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhns : Ne (μ s) 0\nhnt : Ne (μ s) Top.top\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\nA : Set E\nhA : MeasurableSet A\n⊢ Eq (ℙ (Set.preimage X A)) (HDiv.hDiv (μ (Inter.inter s A)) (μ s))","decl":"theorem measure_preimage {X : Ω → E} {s : Set E} (hns : μ s ≠ 0) (hnt : μ s ≠ ∞)\n    (hu : IsUniform X s ℙ μ) {A : Set E} (hA : MeasurableSet A) :\n    ℙ (X ⁻¹' A) = μ (s ∩ A) / μ s := by\n  rwa [← map_apply_of_aemeasurable (hu.aemeasurable hns hnt) hA, hu, ProbabilityTheory.cond_apply',\n    ENNReal.div_eq_inv_mul]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.isProbabilityMeasure","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhns : Ne (μ s) 0\nhnt : Ne (μ s) Top.top\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ MeasureTheory.IsProbabilityMeasure ℙ","decl":"theorem isProbabilityMeasure {X : Ω → E} {s : Set E} (hns : μ s ≠ 0) (hnt : μ s ≠ ∞)\n    (hu : IsUniform X s ℙ μ) : IsProbabilityMeasure ℙ :=\n  ⟨by\n    have : X ⁻¹' Set.univ = Set.univ := Set.preimage_univ\n    rw [← this, hu.measure_preimage hns hnt MeasurableSet.univ, Set.inter_univ,\n      ENNReal.div_self hns hnt]⟩\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.toMeasurable_iff","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\n⊢ Iff (MeasureTheory.pdf.IsUniform X (MeasureTheory.toMeasurable μ s) ℙ μ) (MeasureTheory.pdf.IsUniform X s ℙ μ)","decl":"theorem toMeasurable_iff {X : Ω → E} {s : Set E} :\n    IsUniform X (toMeasurable μ s) ℙ μ ↔ IsUniform X s ℙ μ := by\n  unfold IsUniform\n  rw [ProbabilityTheory.cond_toMeasurable_eq]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.toMeasurable","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ MeasureTheory.pdf.IsUniform X (MeasureTheory.toMeasurable μ s) ℙ μ","decl":"protected theorem toMeasurable {X : Ω → E} {s : Set E} (hu : IsUniform X s ℙ μ) :\n    IsUniform X (toMeasurable μ s) ℙ μ := by\n  unfold IsUniform at *\n  rwa [ProbabilityTheory.cond_toMeasurable_eq]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.hasPDF","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhns : Ne (μ s) 0\nhnt : Ne (μ s) Top.top\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ MeasureTheory.HasPDF X ℙ μ","decl":"theorem hasPDF {X : Ω → E} {s : Set E} (hns : μ s ≠ 0) (hnt : μ s ≠ ∞)\n    (hu : IsUniform X s ℙ μ) : HasPDF X ℙ μ := by\n  let t := toMeasurable μ s\n  apply hasPDF_of_map_eq_withDensity (hu.aemeasurable hns hnt) (t.indicator ((μ t)⁻¹ • 1)) <|\n    (measurable_one.aemeasurable.const_smul (μ t)⁻¹).indicator (measurableSet_toMeasurable μ s)\n  rw [hu, withDensity_indicator (measurableSet_toMeasurable μ s), withDensity_smul _ measurable_one,\n    withDensity_one, restrict_toMeasurable hnt, measure_toMeasurable, ProbabilityTheory.cond]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.pdf_eq_zero_of_measure_eq_zero_or_top","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\nhμs : Or (Eq (μ s) 0) (Eq (μ s) Top.top)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) 0","decl":"theorem pdf_eq_zero_of_measure_eq_zero_or_top {X : Ω → E} {s : Set E}\n    (hu : IsUniform X s ℙ μ) (hμs : μ s = 0 ∨ μ s = ∞) : pdf X ℙ μ =ᵐ[μ] 0 := by\n  rcases hμs with H|H\n  · simp only [IsUniform, ProbabilityTheory.cond, H, ENNReal.inv_zero, restrict_eq_zero.mpr H,\n    smul_zero] at hu\n    simp [pdf, hu]\n  · simp only [IsUniform, ProbabilityTheory.cond, H, ENNReal.inv_top, zero_smul] at hu\n    simp [pdf, hu]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.pdf_eq","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhms : MeasurableSet s\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) (s.indicator (HSMul.hSMul (Inv.inv (μ s)) 1))","decl":"theorem pdf_eq {X : Ω → E} {s : Set E} (hms : MeasurableSet s)\n    (hu : IsUniform X s ℙ μ) : pdf X ℙ μ =ᵐ[μ] s.indicator ((μ s)⁻¹ • (1 : E → ℝ≥0∞)) := by\n  by_cases hnt : μ s = ∞\n  · simp [pdf_eq_zero_of_measure_eq_zero_or_top hu (Or.inr hnt), hnt]\n  by_cases hns : μ s = 0\n  · filter_upwards [measure_zero_iff_ae_nmem.mp hns,\n      pdf_eq_zero_of_measure_eq_zero_or_top hu (Or.inl hns)] with x hx h'x\n    simp [hx, h'x, hns]\n  have : HasPDF X ℙ μ := hasPDF hns hnt hu\n  have : IsProbabilityMeasure ℙ := isProbabilityMeasure hns hnt hu\n  apply (eq_of_map_eq_withDensity _ _).mp\n  · rw [hu, withDensity_indicator hms, withDensity_smul _ measurable_one, withDensity_one,\n      ProbabilityTheory.cond]\n  · exact (measurable_one.aemeasurable.const_smul (μ s)⁻¹).indicator hms\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.pdf_toReal_ae_eq","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhms : MeasurableSet s\nhX : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => (MeasureTheory.pdf X ℙ μ x).toReal) fun x => (s.indicator (HSMul.hSMul (Inv.inv (μ s)) 1) x).toReal","decl":"theorem pdf_toReal_ae_eq {X : Ω → E} {s : Set E} (hms : MeasurableSet s)\n    (hX : IsUniform X s ℙ μ) :\n    (fun x => (pdf X ℙ μ x).toReal) =ᵐ[μ] fun x =>\n      (s.indicator ((μ s)⁻¹ • (1 : E → ℝ≥0∞)) x).toReal :=\n  Filter.EventuallyEq.fun_comp (pdf_eq hms hX) ENNReal.toReal\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.mul_pdf_integrable","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"Ω : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ns : Set Real\nhcs : IsCompact s\nhuX : MeasureTheory.pdf.IsUniform X s ℙ MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.Integrable (fun x => HMul.hMul x (MeasureTheory.pdf X ℙ MeasureTheory.MeasureSpace.volume x).toReal) MeasureTheory.MeasureSpace.volume","decl":"theorem mul_pdf_integrable (hcs : IsCompact s) (huX : IsUniform X s ℙ) :\n    Integrable fun x : ℝ => x * (pdf X ℙ volume x).toReal := by\n  by_cases hnt : volume s = 0 ∨ volume s = ∞\n  · have I : Integrable (fun x ↦ x * ENNReal.toReal (0)) := by simp\n    apply I.congr\n    filter_upwards [pdf_eq_zero_of_measure_eq_zero_or_top huX hnt] with x hx\n    simp [hx]\n  simp only [not_or] at hnt\n  have : IsProbabilityMeasure ℙ := isProbabilityMeasure hnt.1 hnt.2 huX\n  constructor\n  · exact aestronglyMeasurable_id.mul\n      (measurable_pdf X ℙ).aemeasurable.ennreal_toReal.aestronglyMeasurable\n  refine hasFiniteIntegral_mul (pdf_eq hcs.measurableSet huX) ?_\n  set ind := (volume s)⁻¹ • (1 : ℝ → ℝ≥0∞)\n  have : ∀ x, ‖x‖ₑ * s.indicator ind x = s.indicator (fun x => ‖x‖ₑ * ind x) x := fun x =>\n    (s.indicator_mul_right (fun x => ↑‖x‖₊) ind).symm\n  simp only [ind, this, lintegral_indicator hcs.measurableSet, mul_one, Algebra.id.smul_eq_mul,\n    Pi.one_apply, Pi.smul_apply]\n  rw [lintegral_mul_const _ measurable_enorm]\n  exact ENNReal.mul_ne_top (setLIntegral_lt_top_of_isCompact hnt.2 hcs continuous_nnnorm).ne\n    (ENNReal.inv_lt_top.2 (pos_iff_ne_zero.mpr hnt.1)).ne\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.integral_eq","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"Ω : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ns : Set Real\nhuX : MeasureTheory.pdf.IsUniform X s ℙ MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral ℙ fun x => X x) (HMul.hMul (Inv.inv (MeasureTheory.MeasureSpace.volume s)).toReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => x))","decl":"/-- A real uniform random variable `X` with support `s` has expectation\n`(λ s)⁻¹ * ∫ x in s, x ∂λ` where `λ` is the Lebesgue measure. -/\ntheorem integral_eq (huX : IsUniform X s ℙ) :\n    ∫ x, X x ∂ℙ = (volume s)⁻¹.toReal * ∫ x in s, x := by\n  rw [← smul_eq_mul, ← integral_smul_measure]\n  dsimp only [IsUniform, ProbabilityTheory.cond] at huX\n  rw [← huX]\n  by_cases hX : AEMeasurable X ℙ\n  · exact (integral_map hX aestronglyMeasurable_id).symm\n  · rw [map_of_not_aemeasurable hX, integral_zero_measure, integral_non_aestronglyMeasurable]\n    rwa [aestronglyMeasurable_iff_aemeasurable]\n\n"}
{"name":"MeasureTheory.pdf.IsUniform.cond","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ns : Set E\n⊢ MeasureTheory.pdf.IsUniform id s (ProbabilityTheory.cond μ s) μ","decl":"lemma IsUniform.cond {s : Set E} :\n    IsUniform (id : E → E) s (ProbabilityTheory.cond μ s) μ := by\n  unfold IsUniform\n  rw [Measure.map_id]\n\n"}
{"name":"MeasureTheory.pdf.uniformPDF_eq_pdf","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nΩ : Type u_2\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → E\ns : Set E\nhs : MeasurableSet s\nhu : MeasureTheory.pdf.IsUniform X s ℙ μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => MeasureTheory.pdf.uniformPDF s x μ) (MeasureTheory.pdf X ℙ μ)","decl":"/-- Check that indeed any uniform random variable has the uniformPDF. -/\nlemma uniformPDF_eq_pdf {s : Set E} (hs : MeasurableSet s) (hu : pdf.IsUniform X s ℙ μ) :\n    (fun x ↦ uniformPDF s x μ) =ᵐ[μ] pdf X ℙ μ := by\n  unfold uniformPDF\n  exact Filter.EventuallyEq.trans (pdf.IsUniform.pdf_eq hs hu).symm (ae_eq_refl _)\n\n"}
{"name":"MeasureTheory.pdf.uniformPDF_ite","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"E : Type u_1\ninst✝ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ns : Set E\nx : E\n⊢ Eq (MeasureTheory.pdf.uniformPDF s x μ) (ite (Membership.mem s x) (Inv.inv (μ s)) 0)","decl":"open scoped Classical in\n/-- Alternative way of writing the uniformPDF. -/\nlemma uniformPDF_ite {s : Set E} {x : E} :\n    uniformPDF s x μ = if x ∈ s then (μ s)⁻¹ else 0 := by\n  unfold uniformPDF\n  unfold Set.indicator\n  simp only [Pi.smul_apply, Pi.one_apply, smul_eq_mul, mul_one]\n\n"}
{"name":"PMF.uniformOfFinset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\na : α\n⊢ Eq ((PMF.uniformOfFinset s hs) a) (ite (Membership.mem s a) (Inv.inv ↑s.card) 0)","decl":"open scoped Classical in\n@[simp]\ntheorem uniformOfFinset_apply (a : α) :\n    uniformOfFinset s hs a = if a ∈ s then (s.card : ℝ≥0∞)⁻¹ else 0 :=\n  rfl\n\n"}
{"name":"PMF.uniformOfFinset_apply_of_mem","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\na : α\nha : Membership.mem s a\n⊢ Eq ((PMF.uniformOfFinset s hs) a) (Inv.inv ↑s.card)","decl":"theorem uniformOfFinset_apply_of_mem (ha : a ∈ s) : uniformOfFinset s hs a = (s.card : ℝ≥0∞)⁻¹ := by\n  simp [ha]\n\n"}
{"name":"PMF.uniformOfFinset_apply_of_not_mem","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\na : α\nha : Not (Membership.mem s a)\n⊢ Eq ((PMF.uniformOfFinset s hs) a) 0","decl":"theorem uniformOfFinset_apply_of_not_mem (ha : a ∉ s) : uniformOfFinset s hs a = 0 := by simp [ha]\n\n"}
{"name":"PMF.support_uniformOfFinset","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (PMF.uniformOfFinset s hs).support ↑s","decl":"@[simp]\ntheorem support_uniformOfFinset : (uniformOfFinset s hs).support = s :=\n  Set.ext\n    (by\n      let ⟨a, ha⟩ := hs\n      simp [mem_support_iff, Finset.ne_empty_of_mem ha])\n\n"}
{"name":"PMF.mem_support_uniformOfFinset_iff","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\na : α\n⊢ Iff (Membership.mem (PMF.uniformOfFinset s hs).support a) (Membership.mem s a)","decl":"theorem mem_support_uniformOfFinset_iff (a : α) : a ∈ (uniformOfFinset s hs).support ↔ a ∈ s := by\n  simp\n\n"}
{"name":"PMF.toOuterMeasure_uniformOfFinset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\nt : Set α\n⊢ Eq ((PMF.uniformOfFinset s hs).toOuterMeasure t) (HDiv.hDiv ↑(Finset.filter (fun x => Membership.mem t x) s).card ↑s.card)","decl":"open scoped Classical in\n@[simp]\ntheorem toOuterMeasure_uniformOfFinset_apply :\n    (uniformOfFinset s hs).toOuterMeasure t = (s.filter (· ∈ t)).card / s.card :=\n  calc\n    (uniformOfFinset s hs).toOuterMeasure t = ∑' x, if x ∈ t then uniformOfFinset s hs x else 0 :=\n      toOuterMeasure_apply (uniformOfFinset s hs) t\n    _ = ∑' x, if x ∈ s ∧ x ∈ t then (s.card : ℝ≥0∞)⁻¹ else 0 :=\n      (tsum_congr fun x => by simp_rw [uniformOfFinset_apply, ← ite_and, and_comm])\n    _ = ∑ x ∈ s.filter (· ∈ t), if x ∈ s ∧ x ∈ t then (s.card : ℝ≥0∞)⁻¹ else 0 :=\n      (tsum_eq_sum fun _ hx => if_neg fun h => hx (Finset.mem_filter.2 h))\n    _ = ∑ _x ∈ s.filter (· ∈ t), (s.card : ℝ≥0∞)⁻¹ :=\n      (Finset.sum_congr rfl fun x hx => by\n        let this : x ∈ s ∧ x ∈ t := by simpa using hx\n        simp only [this, and_self_iff, if_true])\n    _ = (s.filter (· ∈ t)).card / s.card := by\n        simp only [div_eq_mul_inv, Finset.sum_const, nsmul_eq_mul]\n\n"}
{"name":"PMF.toMeasure_uniformOfFinset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\nt : Set α\ninst✝ : MeasurableSpace α\nht : MeasurableSet t\n⊢ Eq ((PMF.uniformOfFinset s hs).toMeasure t) (HDiv.hDiv ↑(Finset.filter (fun x => Membership.mem t x) s).card ↑s.card)","decl":"open scoped Classical in\n@[simp]\ntheorem toMeasure_uniformOfFinset_apply [MeasurableSpace α] (ht : MeasurableSet t) :\n    (uniformOfFinset s hs).toMeasure t = (s.filter (· ∈ t)).card / s.card :=\n  (toMeasure_apply_eq_toOuterMeasure_apply _ t ht).trans (toOuterMeasure_uniformOfFinset_apply hs t)\n\n"}
{"name":"PMF.uniformOfFintype_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\na : α\n⊢ Eq ((PMF.uniformOfFintype α) a) (Inv.inv ↑(Fintype.card α))","decl":"@[simp]\ntheorem uniformOfFintype_apply (a : α) : uniformOfFintype α a = (Fintype.card α : ℝ≥0∞)⁻¹ := by\n  simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]\n\n"}
{"name":"PMF.support_uniformOfFintype","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\n⊢ Eq (PMF.uniformOfFintype α).support Top.top","decl":"@[simp]\ntheorem support_uniformOfFintype (α : Type*) [Fintype α] [Nonempty α] :\n    (uniformOfFintype α).support = ⊤ :=\n  Set.ext fun x => by simp [mem_support_iff]\n\n"}
{"name":"PMF.mem_support_uniformOfFintype","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\na : α\n⊢ Membership.mem (PMF.uniformOfFintype α).support a","decl":"theorem mem_support_uniformOfFintype (a : α) : a ∈ (uniformOfFintype α).support := by simp\n\n"}
{"name":"PMF.toOuterMeasure_uniformOfFintype_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\ns : Set α\n⊢ Eq ((PMF.uniformOfFintype α).toOuterMeasure s) (HDiv.hDiv ↑(Fintype.card ↑s) ↑(Fintype.card α))","decl":"open scoped Classical in\ntheorem toOuterMeasure_uniformOfFintype_apply :\n    (uniformOfFintype α).toOuterMeasure s = Fintype.card s / Fintype.card α := by\n  rw [uniformOfFintype, toOuterMeasure_uniformOfFinset_apply,Fintype.card_ofFinset]\n  rfl\n\n"}
{"name":"PMF.toMeasure_uniformOfFintype_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : Nonempty α\ns : Set α\ninst✝ : MeasurableSpace α\nhs : MeasurableSet s\n⊢ Eq ((PMF.uniformOfFintype α).toMeasure s) (HDiv.hDiv ↑(Fintype.card ↑s) ↑(Fintype.card α))","decl":"open scoped Classical in\ntheorem toMeasure_uniformOfFintype_apply [MeasurableSpace α] (hs : MeasurableSet s) :\n    (uniformOfFintype α).toMeasure s = Fintype.card s / Fintype.card α := by\n  simp [uniformOfFintype, hs]\n\n"}
{"name":"PMF.ofMultiset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\na : α\n⊢ Eq ((PMF.ofMultiset s hs) a) (HDiv.hDiv ↑(Multiset.count a s) ↑s.card)","decl":"open scoped Classical in\n@[simp]\ntheorem ofMultiset_apply (a : α) : ofMultiset s hs a = s.count a / (Multiset.card s) :=\n  rfl\n\n"}
{"name":"PMF.support_ofMultiset","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\n⊢ Eq (PMF.ofMultiset s hs).support ↑s.toFinset","decl":"open scoped Classical in\n@[simp]\ntheorem support_ofMultiset : (ofMultiset s hs).support = s.toFinset :=\n  Set.ext (by simp [mem_support_iff, hs])\n\n"}
{"name":"PMF.mem_support_ofMultiset_iff","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\na : α\n⊢ Iff (Membership.mem (PMF.ofMultiset s hs).support a) (Membership.mem s.toFinset a)","decl":"open scoped Classical in\ntheorem mem_support_ofMultiset_iff (a : α) : a ∈ (ofMultiset s hs).support ↔ a ∈ s.toFinset := by\n  simp\n\n"}
{"name":"PMF.ofMultiset_apply_of_not_mem","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\na : α\nha : Not (Membership.mem s a)\n⊢ Eq ((PMF.ofMultiset s hs) a) 0","decl":"theorem ofMultiset_apply_of_not_mem {a : α} (ha : a ∉ s) : ofMultiset s hs a = 0 := by\n  simpa only [ofMultiset_apply, ENNReal.div_eq_zero_iff, Nat.cast_eq_zero, Multiset.count_eq_zero,\n    ENNReal.natCast_ne_top, or_false] using ha\n\n"}
{"name":"PMF.toOuterMeasure_ofMultiset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\nt : Set α\n⊢ Eq ((PMF.ofMultiset s hs).toOuterMeasure t) (HDiv.hDiv (tsum fun x => ↑(Multiset.count x (Multiset.filter (fun x => Membership.mem t x) s))) ↑s.card)","decl":"open scoped Classical in\n@[simp]\ntheorem toOuterMeasure_ofMultiset_apply :\n    (ofMultiset s hs).toOuterMeasure t =\n      (∑' x, (s.filter (· ∈ t)).count x : ℝ≥0∞) / (Multiset.card s) := by\n  simp_rw [div_eq_mul_inv, ← ENNReal.tsum_mul_right, toOuterMeasure_apply]\n  refine tsum_congr fun x => ?_\n  by_cases hx : x ∈ t <;> simp [Set.indicator, hx, div_eq_mul_inv]\n\n"}
{"name":"PMF.toMeasure_ofMultiset_apply","module":"Mathlib.Probability.Distributions.Uniform","initialProofState":"α : Type u_1\ns : Multiset α\nhs : Ne s 0\nt : Set α\ninst✝ : MeasurableSpace α\nht : MeasurableSet t\n⊢ Eq ((PMF.ofMultiset s hs).toMeasure t) (HDiv.hDiv (tsum fun x => ↑(Multiset.count x (Multiset.filter (fun x => Membership.mem t x) s))) ↑s.card)","decl":"open scoped Classical in\n@[simp]\ntheorem toMeasure_ofMultiset_apply [MeasurableSpace α] (ht : MeasurableSet t) :\n    (ofMultiset s hs).toMeasure t = (∑' x, (s.filter (· ∈ t)).count x : ℝ≥0∞) / (Multiset.card s) :=\n  (toMeasure_apply_eq_toOuterMeasure_apply _ t ht).trans (toOuterMeasure_ofMultiset_apply hs t)\n\n"}
