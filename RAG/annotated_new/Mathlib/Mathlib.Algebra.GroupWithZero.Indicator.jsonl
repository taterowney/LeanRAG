{"name":"Set.indicator_mul","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ns : Set ι\nf g : ι → M₀\n⊢ Eq (s.indicator fun i => HMul.hMul (f i) (g i)) fun i => HMul.hMul (s.indicator f i) (s.indicator g i)","decl":"lemma indicator_mul (s : Set ι) (f g : ι → M₀) :\n    indicator s (fun i ↦ f i * g i) = fun i ↦ indicator s f i * indicator s g i := by\n  funext\n  simp only [indicator]\n  split_ifs\n  · rfl\n  rw [mul_zero]\n\n"}
{"name":"Set.indicator_mul_left","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ni : ι\ns : Set ι\nf g : ι → M₀\n⊢ Eq (s.indicator (fun j => HMul.hMul (f j) (g j)) i) (HMul.hMul (s.indicator f i) (g i))","decl":"lemma indicator_mul_left (s : Set ι) (f g : ι → M₀) :\n    indicator s (fun j ↦ f j * g j) i = indicator s f i * g i := by\n  simp only [indicator]\n  split_ifs\n  · rfl\n  · rw [zero_mul]\n\n"}
{"name":"Set.indicator_mul_right","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ni : ι\ns : Set ι\nf g : ι → M₀\n⊢ Eq (s.indicator (fun j => HMul.hMul (f j) (g j)) i) (HMul.hMul (f i) (s.indicator g i))","decl":"lemma indicator_mul_right (s : Set ι) (f g : ι → M₀) :\n    indicator s (fun j ↦ f j * g j) i = f i * indicator s g i := by\n  simp only [indicator]\n  split_ifs\n  · rfl\n  · rw [mul_zero]\n\n"}
{"name":"Set.indicator_mul_const","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ns : Set ι\nf : ι → M₀\na : M₀\ni : ι\n⊢ Eq (s.indicator (fun x => HMul.hMul (f x) a) i) (HMul.hMul (s.indicator f i) a)","decl":"lemma indicator_mul_const (s : Set ι) (f : ι → M₀) (a : M₀) (i : ι) :\n    s.indicator (f · * a) i = s.indicator f i * a := by rw [indicator_mul_left]\n\n"}
{"name":"Set.indicator_const_mul","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ns : Set ι\nf : ι → M₀\na : M₀\ni : ι\n⊢ Eq (s.indicator (fun x => HMul.hMul a (f x)) i) (HMul.hMul a (s.indicator f i))","decl":"lemma indicator_const_mul (s : Set ι) (f : ι → M₀) (a : M₀) (i : ι) :\n    s.indicator (a * f ·) i = a * s.indicator f i := by rw [indicator_mul_right]\n\n"}
{"name":"Set.inter_indicator_mul","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\ns t : Set ι\nf g : ι → M₀\ni : ι\n⊢ Eq ((Inter.inter s t).indicator (fun j => HMul.hMul (f j) (g j)) i) (HMul.hMul (s.indicator f i) (t.indicator g i))","decl":"lemma inter_indicator_mul (f g : ι → M₀) (i : ι) :\n    (s ∩ t).indicator (fun j ↦ f j * g j) i = s.indicator f i * t.indicator g i := by\n  rw [← Set.indicator_indicator]\n  simp_rw [indicator]\n  split_ifs <;> simp\n\n"}
{"name":"Set.inter_indicator_one","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroOneClass M₀\ns t : Set ι\n⊢ Eq ((Inter.inter s t).indicator 1) (HMul.hMul (s.indicator 1) (t.indicator 1))","decl":"lemma inter_indicator_one : (s ∩ t).indicator (1 : ι → M₀) = s.indicator 1 * t.indicator 1 :=\n  funext fun _ ↦ by simp only [← inter_indicator_mul, Pi.mul_apply, Pi.one_apply, one_mul]; congr\n\n"}
{"name":"Set.indicator_prod_one","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nκ : Type u_2\nM₀ : Type u_4\ninst✝ : MulZeroOneClass M₀\ns : Set ι\ni : ι\nt : Set κ\nj : κ\n⊢ Eq ((SProd.sprod s t).indicator 1 { fst := i, snd := j }) (HMul.hMul (s.indicator 1 i) (t.indicator 1 j))","decl":"lemma indicator_prod_one {t : Set κ} {j : κ} :\n    (s ×ˢ t).indicator (1 : ι × κ → M₀) (i, j) = s.indicator 1 i * t.indicator 1 j := by\n  simp_rw [indicator, mem_prod_eq]\n  split_ifs with h₀ <;> simp only [Pi.one_apply, mul_one, mul_zero] <;> tauto\n\n"}
{"name":"Set.indicator_eq_zero_iff_not_mem","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MulZeroOneClass M₀\ns : Set ι\ni : ι\ninst✝ : Nontrivial M₀\n⊢ Iff (Eq (s.indicator 1 i) 0) (Not (Membership.mem s i))","decl":"lemma indicator_eq_zero_iff_not_mem : indicator s 1 i = (0 : M₀) ↔ i ∉ s := by\n  classical simp [indicator_apply, imp_false]\n\n"}
{"name":"Set.indicator_eq_one_iff_mem","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MulZeroOneClass M₀\ns : Set ι\ni : ι\ninst✝ : Nontrivial M₀\n⊢ Iff (Eq (s.indicator 1 i) 1) (Membership.mem s i)","decl":"lemma indicator_eq_one_iff_mem : indicator s 1 i = (1 : M₀) ↔ i ∈ s := by\n  classical simp [indicator_apply, imp_false]\n\n"}
{"name":"Set.indicator_one_inj","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MulZeroOneClass M₀\ns t : Set ι\ninst✝ : Nontrivial M₀\nh : Eq (s.indicator 1) (t.indicator 1)\n⊢ Eq s t","decl":"lemma indicator_one_inj (h : indicator s (1 : ι → M₀) = indicator t 1) : s = t := by\n  ext; simp_rw [← indicator_eq_one_iff_mem M₀, h]\n\n"}
{"name":"Function.support_one","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : NeZero 1\n⊢ Eq (Function.support 1) Set.univ","decl":"@[simp] lemma support_one : support (1 : ι → R) = univ := support_const one_ne_zero\n\n"}
{"name":"Function.mulSupport_zero","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : NeZero 1\n⊢ Eq (Function.mulSupport 0) Set.univ","decl":"@[simp] lemma mulSupport_zero : mulSupport (0 : ι → R) = univ := mulSupport_const zero_ne_one\n\n"}
{"name":"Function.support_mul_subset_left","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\nf g : ι → M₀\n⊢ HasSubset.Subset (Function.support fun x => HMul.hMul (f x) (g x)) (Function.support f)","decl":"lemma support_mul_subset_left (f g : ι → M₀) : support (fun x ↦ f x * g x) ⊆ support f :=\n  fun x hfg hf ↦ hfg <| by simp only [hf, zero_mul]\n\n--@[simp] Porting note: removing simp, bad lemma LHS not in normal form\n"}
{"name":"Function.support_mul_subset_right","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : MulZeroClass M₀\nf g : ι → M₀\n⊢ HasSubset.Subset (Function.support fun x => HMul.hMul (f x) (g x)) (Function.support g)","decl":"lemma support_mul_subset_right (f g : ι → M₀) : support (fun x ↦ f x * g x) ⊆ support g :=\n  fun x hfg hg => hfg <| by simp only [hg, mul_zero]\n\n"}
{"name":"Function.support_mul","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\nf g : ι → M₀\n⊢ Eq (Function.support fun x => HMul.hMul (f x) (g x)) (Inter.inter (Function.support f) (Function.support g))","decl":"@[simp] lemma support_mul (f g : ι → M₀) : support (fun x ↦ f x * g x) = support f ∩ support g :=\n  ext fun x ↦ by simp [not_or]\n\n"}
{"name":"Function.support_mul'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\nf g : ι → M₀\n⊢ Eq (Function.support (HMul.hMul f g)) (Inter.inter (Function.support f) (Function.support g))","decl":"@[simp] lemma support_mul' (f g : ι → M₀) : support (f * g) = support f ∩ support g :=\n  support_mul _ _\n\n"}
{"name":"Function.support_pow","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MonoidWithZero M₀\ninst✝ : NoZeroDivisors M₀\nn : Nat\nf : ι → M₀\nhn : Ne n 0\n⊢ Eq (Function.support fun a => HPow.hPow (f a) n) (Function.support f)","decl":"@[simp] lemma support_pow (f : ι → M₀) (hn : n ≠ 0) : support (fun a ↦ f a ^ n) = support f := by\n  ext; exact (pow_eq_zero_iff hn).not\n\n"}
{"name":"Function.support_pow'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : MonoidWithZero M₀\ninst✝ : NoZeroDivisors M₀\nn : Nat\nf : ι → M₀\nhn : Ne n 0\n⊢ Eq (Function.support (HPow.hPow f n)) (Function.support f)","decl":"@[simp] lemma support_pow' (f : ι → M₀) (hn : n ≠ 0) : support (f ^ n) = support f :=\n  support_pow _ hn\n\n"}
{"name":"Function.support_inv","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nG₀ : Type u_3\ninst✝ : GroupWithZero G₀\nf : ι → G₀\n⊢ Eq (Function.support fun a => Inv.inv (f a)) (Function.support f)","decl":"@[simp] lemma support_inv (f : ι → G₀) : support (fun a ↦ (f a)⁻¹) = support f :=\n  Set.ext fun _ ↦ not_congr inv_eq_zero\n\n"}
{"name":"Function.support_inv'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nG₀ : Type u_3\ninst✝ : GroupWithZero G₀\nf : ι → G₀\n⊢ Eq (Function.support (Inv.inv f)) (Function.support f)","decl":"@[simp] lemma support_inv' (f : ι → G₀) : support f⁻¹ = support f := support_inv _\n\n"}
{"name":"Function.support_div","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nG₀ : Type u_3\ninst✝ : GroupWithZero G₀\nf g : ι → G₀\n⊢ Eq (Function.support fun a => HDiv.hDiv (f a) (g a)) (Inter.inter (Function.support f) (Function.support g))","decl":"@[simp] lemma support_div (f g : ι → G₀) : support (fun a ↦ f a / g a) = support f ∩ support g := by\n  simp [div_eq_mul_inv]\n\n"}
{"name":"Function.support_div'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nG₀ : Type u_3\ninst✝ : GroupWithZero G₀\nf g : ι → G₀\n⊢ Eq (Function.support (HDiv.hDiv f g)) (Inter.inter (Function.support f) (Function.support g))","decl":"@[simp] lemma support_div' (f g : ι → G₀) : support (f / g) = support f ∩ support g :=\n  support_div _ _\n\n"}
{"name":"Function.mulSupport_one_add","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddLeftCancelMonoid R\nf : ι → R\n⊢ Eq (Function.mulSupport fun x => HAdd.hAdd 1 (f x)) (Function.support f)","decl":"lemma mulSupport_one_add [AddLeftCancelMonoid R] (f : ι → R) :\n    mulSupport (fun x ↦ 1 + f x) = support f :=\n  Set.ext fun _ ↦ not_congr add_right_eq_self\n\n"}
{"name":"Function.mulSupport_one_add'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddLeftCancelMonoid R\nf : ι → R\n⊢ Eq (Function.mulSupport (HAdd.hAdd 1 f)) (Function.support f)","decl":"lemma mulSupport_one_add' [AddLeftCancelMonoid R] (f : ι → R) : mulSupport (1 + f) = support f :=\n  mulSupport_one_add f\n\n"}
{"name":"Function.mulSupport_add_one","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddRightCancelMonoid R\nf : ι → R\n⊢ Eq (Function.mulSupport fun x => HAdd.hAdd (f x) 1) (Function.support f)","decl":"lemma mulSupport_add_one [AddRightCancelMonoid R] (f : ι → R) :\n    mulSupport (fun x ↦ f x + 1) = support f := Set.ext fun _ ↦ not_congr add_left_eq_self\n\n"}
{"name":"Function.mulSupport_add_one'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddRightCancelMonoid R\nf : ι → R\n⊢ Eq (Function.mulSupport (HAdd.hAdd f 1)) (Function.support f)","decl":"lemma mulSupport_add_one' [AddRightCancelMonoid R] (f : ι → R) : mulSupport (f + 1) = support f :=\n  mulSupport_add_one f\n\n"}
{"name":"Function.mulSupport_one_sub'","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddGroup R\nf : ι → R\n⊢ Eq (Function.mulSupport (HSub.hSub 1 f)) (Function.support f)","decl":"lemma mulSupport_one_sub' [AddGroup R] (f : ι → R) : mulSupport (1 - f) = support f := by\n  rw [sub_eq_add_neg, mulSupport_one_add', support_neg']\n\n"}
{"name":"Function.mulSupport_one_sub","module":"Mathlib.Algebra.GroupWithZero.Indicator","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝¹ : One R\ninst✝ : AddGroup R\nf : ι → R\n⊢ Eq (Function.mulSupport fun x => HSub.hSub 1 (f x)) (Function.support f)","decl":"lemma mulSupport_one_sub [AddGroup R] (f : ι → R) :\n    mulSupport (fun x ↦ 1 - f x) = support f := mulSupport_one_sub' f\n\n"}
