{"name":"Lat.coe_of","module":"Mathlib.Order.Category.Lat","initialProofState":"α : Type u_1\ninst✝ : Lattice α\n⊢ Eq (↑(Lat.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [Lattice α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"Lat.Iso.mk_inv_toSupHom_toFun","module":"Mathlib.Order.Category.Lat","initialProofState":"α β : Lat\ne : OrderIso ↑α ↑β\na : ↑β\n⊢ Eq ((Lat.Iso.mk e).inv.toSupHom a) (e.symm a)","decl":"/-- Constructs an isomorphism of lattices from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : Lat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : LatticeHom _ _)\n  inv := (e.symm : LatticeHom _ _)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _\n\n"}
{"name":"Lat.Iso.mk_hom_toSupHom_toFun","module":"Mathlib.Order.Category.Lat","initialProofState":"α β : Lat\ne : OrderIso ↑α ↑β\na : ↑α\n⊢ Eq ((Lat.Iso.mk e).hom.toSupHom a) (e a)","decl":"/-- Constructs an isomorphism of lattices from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : Lat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : LatticeHom _ _)\n  inv := (e.symm : LatticeHom _ _)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _\n\n"}
{"name":"Lat.dual_map","module":"Mathlib.Order.Category.Lat","initialProofState":"X✝ Y✝ : Lat\na : LatticeHom ↑X✝ ↑Y✝\n⊢ Eq (Lat.dual.map a) (LatticeHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : Lat ⥤ Lat where\n  obj X := of Xᵒᵈ\n  map := LatticeHom.dual\n\n"}
{"name":"Lat.dual_obj","module":"Mathlib.Order.Category.Lat","initialProofState":"X : Lat\n⊢ Eq (Lat.dual.obj X) (Lat.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : Lat ⥤ Lat where\n  obj X := of Xᵒᵈ\n  map := LatticeHom.dual\n\n"}
{"name":"Lat.dualEquiv_inverse","module":"Mathlib.Order.Category.Lat","initialProofState":"⊢ Eq Lat.dualEquiv.inverse Lat.dual","decl":"/-- The equivalence between `Lat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : Lat ≌ Lat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"Lat.dualEquiv_functor","module":"Mathlib.Order.Category.Lat","initialProofState":"⊢ Eq Lat.dualEquiv.functor Lat.dual","decl":"/-- The equivalence between `Lat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : Lat ≌ Lat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"Lat_dual_comp_forget_to_partOrd","module":"Mathlib.Order.Category.Lat","initialProofState":"⊢ Eq (Lat.dual.comp (CategoryTheory.forget₂ Lat PartOrd)) ((CategoryTheory.forget₂ Lat PartOrd).comp PartOrd.dual)","decl":"theorem Lat_dual_comp_forget_to_partOrd :\n    Lat.dual ⋙ forget₂ Lat PartOrd = forget₂ Lat PartOrd ⋙ PartOrd.dual :=\n  rfl\n"}
