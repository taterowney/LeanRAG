{"name":"MeasureTheory.Egorov.mem_notConvergentSeq_iff","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\ninst‚úù¬π : MetricSpace Œ≤\nn : Nat\nj : Œπ\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œπ\nx : Œ±\n‚ä¢ Iff (Membership.mem (MeasureTheory.Egorov.notConvergentSeq f g n j) x) (Exists fun k => And (GE.ge k j) (LT.lt (HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1)) (Dist.dist (f k x) (g x))))","decl":"theorem mem_notConvergentSeq_iff [Preorder Œπ] {x : Œ±} :\n    x ‚àà notConvergentSeq f g n j ‚Üî ‚àÉ k ‚â• j, 1 / (n + 1 : ‚Ñù) < dist (f k x) (g x) := by\n  simp_rw [notConvergentSeq, Set.mem_iUnion, exists_prop, mem_setOf]\n\n"}
{"name":"MeasureTheory.Egorov.notConvergentSeq_antitone","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\ninst‚úù¬π : MetricSpace Œ≤\nn : Nat\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œπ\n‚ä¢ Antitone (MeasureTheory.Egorov.notConvergentSeq f g n)","decl":"theorem notConvergentSeq_antitone [Preorder Œπ] : Antitone (notConvergentSeq f g n) :=\n  fun _ _ hjk => Set.iUnion‚ÇÇ_mono' fun l hl => ‚ü®l, le_trans hjk hl, Set.Subset.rfl‚ü©\n\n"}
{"name":"MeasureTheory.Egorov.measure_inter_notConvergentSeq_eq_zero","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬π : SemilatticeSup Œπ\ninst‚úù : Nonempty Œπ\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nn : Nat\n‚ä¢ Eq (Œº (Inter.inter s (Set.iInter fun j => MeasureTheory.Egorov.notConvergentSeq f g n j))) 0","decl":"theorem measure_inter_notConvergentSeq_eq_zero [SemilatticeSup Œπ] [Nonempty Œπ]\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) (n : ‚Ñï) :\n    Œº (s ‚à© ‚ãÇ j, notConvergentSeq f g n j) = 0 := by\n  simp_rw [Metric.tendsto_atTop, ae_iff] at hfg\n  rw [‚Üê nonpos_iff_eq_zero, ‚Üê hfg]\n  refine measure_mono fun x => ?_\n  simp only [Set.mem_inter_iff, Set.mem_iInter, mem_notConvergentSeq_iff]\n  push_neg\n  rintro ‚ü®hmem, hx‚ü©\n  refine ‚ü®hmem, 1 / (n + 1 : ‚Ñù), Nat.one_div_pos_of_nat, fun N => ?_‚ü©\n  obtain ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü© := hx N\n  exact ‚ü®n, hn‚ÇÅ, hn‚ÇÇ.le‚ü©\n\n"}
{"name":"MeasureTheory.Egorov.notConvergentSeq_measurableSet","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : MetricSpace Œ≤\nn : Nat\nj : Œπ\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬π : Preorder Œπ\ninst‚úù : Countable Œπ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\n‚ä¢ MeasurableSet (MeasureTheory.Egorov.notConvergentSeq f g n j)","decl":"theorem notConvergentSeq_measurableSet [Preorder Œπ] [Countable Œπ]\n    (hf : ‚àÄ n, StronglyMeasurable[m] (f n)) (hg : StronglyMeasurable g) :\n    MeasurableSet (notConvergentSeq f g n j) :=\n  MeasurableSet.iUnion fun k =>\n    MeasurableSet.iUnion fun _ =>\n      StronglyMeasurable.measurableSet_lt stronglyMeasurable_const <| (hf k).dist hg\n\n"}
{"name":"MeasureTheory.Egorov.measure_notConvergentSeq_tendsto_zero","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≤ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬π : SemilatticeSup Œπ\ninst‚úù : Countable Œπ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nn : Nat\n‚ä¢ Filter.Tendsto (fun j => Œº (Inter.inter s (MeasureTheory.Egorov.notConvergentSeq f g n j))) Filter.atTop (nhds 0)","decl":"theorem measure_notConvergentSeq_tendsto_zero [SemilatticeSup Œπ] [Countable Œπ]\n    (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)\n    (hs : Œº s ‚â† ‚àû) (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) (n : ‚Ñï) :\n    Tendsto (fun j => Œº (s ‚à© notConvergentSeq f g n j)) atTop (ùìù 0) := by\n  cases' isEmpty_or_nonempty Œπ with h h\n  ¬∑ have : (fun j => Œº (s ‚à© notConvergentSeq f g n j)) = fun j => 0 := by\n      simp only [eq_iff_true_of_subsingleton]\n    rw [this]\n    exact tendsto_const_nhds\n  rw [‚Üê measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]\n  refine tendsto_measure_iInter_atTop\n    (fun n ‚Ü¶ (hsm.inter <| notConvergentSeq_measurableSet hf hg).nullMeasurableSet)\n    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)\n    ‚ü®h.some, ne_top_of_le_ne_top hs (measure_mono Set.inter_subset_left)‚ü©\n\n"}
{"name":"MeasureTheory.Egorov.exists_notConvergentSeq_lt","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nn : Nat\n‚ä¢ Exists fun j => LE.le (Œº (Inter.inter s (MeasureTheory.Egorov.notConvergentSeq f g n j))) (ENNReal.ofReal (HMul.hMul Œµ (HPow.hPow (Inv.inv 2) n)))","decl":"theorem exists_notConvergentSeq_lt (hŒµ : 0 < Œµ) (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) (n : ‚Ñï) :\n    ‚àÉ j : Œπ, Œº (s ‚à© notConvergentSeq f g n j) ‚â§ ENNReal.ofReal (Œµ * 2‚Åª¬π ^ n) := by\n  have ‚ü®N, hN‚ü© := (ENNReal.tendsto_atTop ENNReal.zero_ne_top).1\n    (measure_notConvergentSeq_tendsto_zero hf hg hsm hs hfg n) (ENNReal.ofReal (Œµ * 2‚Åª¬π ^ n)) (by\n      rw [gt_iff_lt, ENNReal.ofReal_pos]\n      exact mul_pos hŒµ (pow_pos (by norm_num) n))\n  rw [zero_add] at hN\n  exact ‚ü®N, (hN N le_rfl).2‚ü©\n\n"}
{"name":"MeasureTheory.Egorov.notConvergentSeqLTIndex_spec","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nn : Nat\n‚ä¢ LE.le (Œº (Inter.inter s (MeasureTheory.Egorov.notConvergentSeq f g n (MeasureTheory.Egorov.notConvergentSeqLTIndex hŒµ hf hg hsm hs hfg n)))) (ENNReal.ofReal (HMul.hMul Œµ (HPow.hPow (Inv.inv 2) n)))","decl":"theorem notConvergentSeqLTIndex_spec (hŒµ : 0 < Œµ) (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) (n : ‚Ñï) :\n    Œº (s ‚à© notConvergentSeq f g n (notConvergentSeqLTIndex hŒµ hf hg hsm hs hfg n)) ‚â§\n      ENNReal.ofReal (Œµ * 2‚Åª¬π ^ n) :=\n  Classical.choose_spec <| exists_notConvergentSeq_lt hŒµ hf hg hsm hs hfg n\n\n"}
{"name":"MeasureTheory.Egorov.iUnionNotConvergentSeq_measurableSet","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ MeasurableSet (MeasureTheory.Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg)","decl":"theorem iUnionNotConvergentSeq_measurableSet (hŒµ : 0 < Œµ) (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    MeasurableSet <| iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg :=\n  MeasurableSet.iUnion fun _ => hsm.inter <| notConvergentSeq_measurableSet hf hg\n\n"}
{"name":"MeasureTheory.Egorov.measure_iUnionNotConvergentSeq","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Œº (MeasureTheory.Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg)) (ENNReal.ofReal Œµ)","decl":"theorem measure_iUnionNotConvergentSeq (hŒµ : 0 < Œµ) (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    Œº (iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg) ‚â§ ENNReal.ofReal Œµ := by\n  refine le_trans (measure_iUnion_le _) (le_trans\n    (ENNReal.tsum_le_tsum <| notConvergentSeqLTIndex_spec (half_pos hŒµ) hf hg hsm hs hfg) ?_)\n  simp_rw [ENNReal.ofReal_mul (half_pos hŒµ).le]\n  rw [ENNReal.tsum_mul_left, ‚Üê ENNReal.ofReal_tsum_of_nonneg, inv_eq_one_div, tsum_geometric_two,\n    ‚Üê ENNReal.ofReal_mul (half_pos hŒµ).le, div_mul_cancel‚ÇÄ Œµ two_ne_zero]\n  ¬∑ intro n; positivity\n  ¬∑ rw [inv_eq_one_div]\n    exact summable_geometric_two\n\n"}
{"name":"MeasureTheory.Egorov.iUnionNotConvergentSeq_subset","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ HasSubset.Subset (MeasureTheory.Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg) s","decl":"theorem iUnionNotConvergentSeq_subset (hŒµ : 0 < Œµ) (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg ‚äÜ s := by\n  rw [iUnionNotConvergentSeq, ‚Üê Set.inter_iUnion]\n  exact Set.inter_subset_left\n\n"}
{"name":"MeasureTheory.Egorov.tendstoUniformlyOn_diff_iUnionNotConvergentSeq","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nŒµ : Real\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nhŒµ : LT.lt 0 Œµ\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ TendstoUniformlyOn f g Filter.atTop (SDiff.sdiff s (MeasureTheory.Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg))","decl":"theorem tendstoUniformlyOn_diff_iUnionNotConvergentSeq (hŒµ : 0 < Œµ)\n    (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)\n    (hs : Œº s ‚â† ‚àû) (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    TendstoUniformlyOn f g atTop (s \\ Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg) := by\n  rw [Metric.tendstoUniformlyOn_iff]\n  intro Œ¥ hŒ¥\n  obtain ‚ü®N, hN‚ü© := exists_nat_one_div_lt hŒ¥\n  rw [eventually_atTop]\n  refine ‚ü®Egorov.notConvergentSeqLTIndex (half_pos hŒµ) hf hg hsm hs hfg N, fun n hn x hx => ?_‚ü©\n  simp only [Set.mem_diff, Egorov.iUnionNotConvergentSeq, not_exists, Set.mem_iUnion,\n    Set.mem_inter_iff, not_and, exists_and_left] at hx\n  obtain ‚ü®hxs, hx‚ü© := hx\n  specialize hx hxs N\n  rw [Egorov.mem_notConvergentSeq_iff] at hx\n  push_neg at hx\n  rw [dist_comm]\n  exact lt_of_le_of_lt (hx n hn) hN\n\n"}
{"name":"MeasureTheory.tendstoUniformlyOn_of_ae_tendsto","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù¬≥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : SemilatticeSup Œπ\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : Countable Œπ\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhsm : MeasurableSet s\nhs : Ne (Œº s) Top.top\nhfg : Filter.Eventually (fun x => Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And (MeasurableSet t) (And (LE.le (Œº t) (ENNReal.ofReal Œµ)) (TendstoUniformlyOn f g Filter.atTop (SDiff.sdiff s t))))","decl":"/-- **Egorov's theorem**: If `f : Œπ ‚Üí Œ± ‚Üí Œ≤` is a sequence of strongly measurable functions that\nconverges to `g : Œ± ‚Üí Œ≤` almost everywhere on a measurable set `s` of finite measure,\nthen for all `Œµ > 0`, there exists a subset `t ‚äÜ s` such that `Œº t ‚â§ Œµ` and `f` converges to `g`\nuniformly on `s \\ t`. We require the index type `Œπ` to be countable, and usually `Œπ = ‚Ñï`.\n\nIn other words, a sequence of almost everywhere convergent functions converges uniformly except on\nan arbitrarily small set. -/\ntheorem tendstoUniformlyOn_of_ae_tendsto (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hsm : MeasurableSet s) (hs : Œº s ‚â† ‚àû)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí Tendsto (fun n => f n x) atTop (ùìù (g x))) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ t ‚äÜ s, MeasurableSet t ‚àß Œº t ‚â§ ENNReal.ofReal Œµ ‚àß TendstoUniformlyOn f g atTop (s \\ t) :=\n  ‚ü®Egorov.iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg,\n    Egorov.iUnionNotConvergentSeq_subset hŒµ hf hg hsm hs hfg,\n    Egorov.iUnionNotConvergentSeq_measurableSet hŒµ hf hg hsm hs hfg,\n    Egorov.measure_iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg,\n    Egorov.tendstoUniformlyOn_diff_iUnionNotConvergentSeq hŒµ hf hg hsm hs hfg‚ü©\n\n"}
{"name":"MeasureTheory.tendstoUniformlyOn_of_ae_tendsto'","module":"Mathlib.MeasureTheory.Function.Egorov","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\ninst‚úù‚Å¥ : MetricSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : SemilatticeSup Œπ\ninst‚úù¬≤ : Nonempty Œπ\ninst‚úù¬π : Countable Œπ\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhf : ‚àÄ (n : Œπ), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhfg : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun t => And (MeasurableSet t) (And (LE.le (Œº t) (ENNReal.ofReal Œµ)) (TendstoUniformlyOn f g Filter.atTop (HasCompl.compl t)))","decl":"/-- Egorov's theorem for finite measure spaces. -/\ntheorem tendstoUniformlyOn_of_ae_tendsto' [IsFiniteMeasure Œº] (hf : ‚àÄ n, StronglyMeasurable (f n))\n    (hg : StronglyMeasurable g) (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) :\n    ‚àÉ t, MeasurableSet t ‚àß Œº t ‚â§ ENNReal.ofReal Œµ ‚àß TendstoUniformlyOn f g atTop t·∂ú := by\n  have ‚ü®t, _, ht, htendsto‚ü© := tendstoUniformlyOn_of_ae_tendsto hf hg MeasurableSet.univ\n    (measure_ne_top Œº Set.univ) (by filter_upwards [hfg] with _ htendsto _ using htendsto) hŒµ\n  refine ‚ü®_, ht, ?_‚ü©\n  rwa [Set.compl_eq_univ_diff]\n\n"}
