{"name":"Submodule.bot_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (↑Bot.bot) (Singleton.singleton 0)","decl":"@[simp]\ntheorem bot_coe : ((⊥ : Submodule R M) : Set M) = {0} :=\n  rfl\n\n"}
{"name":"Submodule.bot_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Bot.bot.toAddSubmonoid Bot.bot","decl":"@[simp]\ntheorem bot_toAddSubmonoid : (⊥ : Submodule R M).toAddSubmonoid = ⊥ :=\n  rfl\n\n"}
{"name":"Submodule.bot_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq Bot.bot.toAddSubgroup Bot.bot","decl":"@[simp]\nlemma bot_toAddSubgroup {R M} [Ring R] [AddCommGroup M] [Module R M] :\n    (⊥ : Submodule R M).toAddSubgroup = ⊥ := rfl\n\n"}
{"name":"Submodule.mem_bot","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"variable (R) in\n@[simp]\ntheorem mem_bot {x : M} : x ∈ (⊥ : Submodule R M) ↔ x = 0 :=\n  Set.mem_singleton_iff\n\n"}
{"name":"Submodule.eq_bot_iff","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Eq p Bot.bot) (∀ (x : M), Membership.mem p x → Eq x 0)","decl":"protected theorem eq_bot_iff (p : Submodule R M) : p = ⊥ ↔ ∀ x ∈ p, x = (0 : M) :=\n  ⟨fun h ↦ h.symm ▸ fun _ hx ↦ (mem_bot R).mp hx,\n    fun h ↦ eq_bot_iff.mpr fun x hx ↦ (mem_bot R).mpr (h x hx)⟩\n\n"}
{"name":"Submodule.bot_ext_iff","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : Subtype fun x => Membership.mem Bot.bot x\n⊢ Iff (Eq x y) True","decl":"@[ext high]\nprotected theorem bot_ext (x y : (⊥ : Submodule R M)) : x = y := by\n  rcases x with ⟨x, xm⟩; rcases y with ⟨y, ym⟩; congr\n  rw [(Submodule.eq_bot_iff _).mp rfl x xm]\n  rw [(Submodule.eq_bot_iff _).mp rfl y ym]\n\n"}
{"name":"Submodule.bot_ext","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : Subtype fun x => Membership.mem Bot.bot x\n⊢ Eq x y","decl":"@[ext high]\nprotected theorem bot_ext (x y : (⊥ : Submodule R M)) : x = y := by\n  rcases x with ⟨x, xm⟩; rcases y with ⟨y, ym⟩; congr\n  rw [(Submodule.eq_bot_iff _).mp rfl x xm]\n  rw [(Submodule.eq_bot_iff _).mp rfl y ym]\n\n"}
{"name":"Submodule.ne_bot_iff","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Ne p Bot.bot) (Exists fun x => And (Membership.mem p x) (Ne x 0))","decl":"protected theorem ne_bot_iff (p : Submodule R M) : p ≠ ⊥ ↔ ∃ x ∈ p, x ≠ (0 : M) := by\n  simp only [ne_eq, p.eq_bot_iff, not_forall, exists_prop]\n\n"}
{"name":"Submodule.nonzero_mem_of_bot_lt","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nbot_lt : LT.lt Bot.bot p\n⊢ Exists fun a => Ne a 0","decl":"theorem nonzero_mem_of_bot_lt {p : Submodule R M} (bot_lt : ⊥ < p) : ∃ a : p, a ≠ 0 :=\n  let ⟨b, hb₁, hb₂⟩ := p.ne_bot_iff.mp bot_lt.ne'\n  ⟨⟨b, hb₁⟩, hb₂ ∘ congr_arg Subtype.val⟩\n\n"}
{"name":"Submodule.exists_mem_ne_zero_of_ne_bot","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nh : Ne p Bot.bot\n⊢ Exists fun b => And (Membership.mem p b) (Ne b 0)","decl":"theorem exists_mem_ne_zero_of_ne_bot {p : Submodule R M} (h : p ≠ ⊥) : ∃ b : M, b ∈ p ∧ b ≠ 0 :=\n  let ⟨b, hb₁, hb₂⟩ := p.ne_bot_iff.mp h\n  ⟨b, hb₁, hb₂⟩\n\n-- FIXME: we default PUnit to PUnit.{1} here without the explicit universe annotation\n"}
{"name":"Submodule.botEquivPUnit_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx✝ : PUnit.{v + 1}\n⊢ Eq (Submodule.botEquivPUnit.symm x✝) 0","decl":"/-- The bottom submodule is linearly equivalent to punit as an `R`-module. -/\n@[simps]\ndef botEquivPUnit : (⊥ : Submodule R M) ≃ₗ[R] PUnit.{v+1} where\n  toFun _ := PUnit.unit\n  invFun _ := 0\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := rfl\n\n"}
{"name":"Submodule.botEquivPUnit_apply","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx✝ : Subtype fun x => Membership.mem Bot.bot x\n⊢ Eq (Submodule.botEquivPUnit x✝) PUnit.unit","decl":"/-- The bottom submodule is linearly equivalent to punit as an `R`-module. -/\n@[simps]\ndef botEquivPUnit : (⊥ : Submodule R M) ≃ₗ[R] PUnit.{v+1} where\n  toFun _ := PUnit.unit\n  invFun _ := 0\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := rfl\n\n"}
{"name":"Submodule.subsingleton_iff_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Subsingleton (Subtype fun x => Membership.mem p x)) (Eq p Bot.bot)","decl":"theorem subsingleton_iff_eq_bot : Subsingleton p ↔ p = ⊥ := by\n  rw [subsingleton_iff, Submodule.eq_bot_iff]\n  refine ⟨fun h x hx ↦ by simpa using h ⟨x, hx⟩ ⟨0, p.zero_mem⟩,\n    fun h ⟨x, hx⟩ ⟨y, hy⟩ ↦ by simp [h x hx, h y hy]⟩\n\n"}
{"name":"Submodule.eq_bot_of_subsingleton","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\np : Submodule R M\ninst✝ : Subsingleton (Subtype fun x => Membership.mem p x)\n⊢ Eq p Bot.bot","decl":"theorem eq_bot_of_subsingleton [Subsingleton p] : p = ⊥ :=\n  subsingleton_iff_eq_bot.mp inferInstance\n\n"}
{"name":"Submodule.nontrivial_iff_ne_bot","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem p x)) (Ne p Bot.bot)","decl":"theorem nontrivial_iff_ne_bot : Nontrivial p ↔ p ≠ ⊥ := by\n  rw [iff_not_comm, not_nontrivial_iff_subsingleton, subsingleton_iff_eq_bot]\n\n"}
{"name":"Submodule.top_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem top_coe : ((⊤ : Submodule R M) : Set M) = Set.univ :=\n  rfl\n\n"}
{"name":"Submodule.top_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Top.top.toAddSubmonoid Top.top","decl":"@[simp]\ntheorem top_toAddSubmonoid : (⊤ : Submodule R M).toAddSubmonoid = ⊤ :=\n  rfl\n\n"}
{"name":"Submodule.top_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq Top.top.toAddSubgroup Top.top","decl":"@[simp]\nlemma top_toAddSubgroup {R M} [Ring R] [AddCommGroup M] [Module R M] :\n    (⊤ : Submodule R M).toAddSubgroup = ⊤ := rfl\n\n"}
{"name":"Submodule.mem_top","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top {x : M} : x ∈ (⊤ : Submodule R M) :=\n  trivial\n\n"}
{"name":"Submodule.eq_top_iff'","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Eq p Top.top) (∀ (x : M), Membership.mem p x)","decl":"theorem eq_top_iff' {p : Submodule R M} : p = ⊤ ↔ ∀ x, x ∈ p :=\n  eq_top_iff.trans ⟨fun h _ ↦ h trivial, fun h x _ ↦ h x⟩\n\n"}
{"name":"Submodule.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (↑(Submodule.topEquiv.symm x)) x","decl":"/-- The top submodule is linearly equivalent to the module.\n\nThis is the module version of `AddSubmonoid.topEquiv`. -/\n@[simps]\ndef topEquiv : (⊤ : Submodule R M) ≃ₗ[R] M where\n  toFun x := x\n  invFun x := ⟨x, mem_top⟩\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Submodule.topEquiv_apply","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Submodule.topEquiv x) ↑x","decl":"/-- The top submodule is linearly equivalent to the module.\n\nThis is the module version of `AddSubmonoid.topEquiv`. -/\n@[simps]\ndef topEquiv : (⊤ : Submodule R M) ≃ₗ[R] M where\n  toFun x := x\n  invFun x := ⟨x, mem_top⟩\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Submodule.inf_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Eq (↑(Min.min p q)) (Inter.inter ↑p ↑q)","decl":"@[simp]\ntheorem inf_coe : ↑(p ⊓ q) = (p ∩ q : Set M) :=\n  rfl\n\n"}
{"name":"Submodule.mem_inf","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nx : M\n⊢ Iff (Membership.mem (Min.min p q) x) (And (Membership.mem p x) (Membership.mem q x))","decl":"@[simp]\ntheorem mem_inf {p q : Submodule R M} {x : M} : x ∈ p ⊓ q ↔ x ∈ p ∧ x ∈ q :=\n  Iff.rfl\n\n"}
{"name":"Submodule.sInf_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nP : Set (Submodule R M)\n⊢ Eq (↑(InfSet.sInf P)) (Set.iInter fun p => Set.iInter fun h => ↑p)","decl":"@[simp]\ntheorem sInf_coe (P : Set (Submodule R M)) : (↑(sInf P) : Set M) = ⋂ p ∈ P, ↑p :=\n  rfl\n\n"}
{"name":"Submodule.finset_inf_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\ns : Finset ι\np : ι → Submodule R M\n⊢ Eq (↑(s.inf p)) (Set.iInter fun i => Set.iInter fun h => ↑(p i))","decl":"@[simp]\ntheorem finset_inf_coe {ι} (s : Finset ι) (p : ι → Submodule R M) :\n    (↑(s.inf p) : Set M) = ⋂ i ∈ s, ↑(p i) := by\n  letI := Classical.decEq ι\n  refine s.induction_on ?_ fun i s _ ih ↦ ?_\n  · simp\n  · rw [Finset.inf_insert, inf_coe, ih]\n    simp\n\n"}
{"name":"Submodule.iInf_coe","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_4\np : ι → Submodule R M\n⊢ Eq (↑(iInf fun i => p i)) (Set.iInter fun i => ↑(p i))","decl":"@[simp]\ntheorem iInf_coe {ι} (p : ι → Submodule R M) : (↑(⨅ i, p i) : Set M) = ⋂ i, ↑(p i) := by\n  rw [iInf, sInf_coe]; simp only [Set.mem_range, Set.iInter_exists, Set.iInter_iInter_eq']\n\n"}
{"name":"Submodule.mem_sInf","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set (Submodule R M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Submodule R M), Membership.mem S p → Membership.mem p x)","decl":"@[simp]\ntheorem mem_sInf {S : Set (Submodule R M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Submodule.mem_iInf","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_4\np : ι → Submodule R M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => p i) x) (∀ (i : ι), Membership.mem (p i) x)","decl":"@[simp]\ntheorem mem_iInf {ι} (p : ι → Submodule R M) {x} : (x ∈ ⨅ i, p i) ↔ ∀ i, x ∈ p i := by\n  rw [← SetLike.mem_coe, iInf_coe, Set.mem_iInter]; rfl\n\n"}
{"name":"Submodule.mem_finset_inf","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\ns : Finset ι\np : ι → Submodule R M\nx : M\n⊢ Iff (Membership.mem (s.inf p) x) (∀ (i : ι), Membership.mem s i → Membership.mem (p i) x)","decl":"@[simp]\ntheorem mem_finset_inf {ι} {s : Finset ι} {p : ι → Submodule R M} {x : M} :\n    x ∈ s.inf p ↔ ∀ i ∈ s, x ∈ p i := by\n  simp only [← SetLike.mem_coe, finset_inf_coe, Set.mem_iInter]\n\n"}
{"name":"Submodule.inf_iInf","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type u_4\ninst✝ : Nonempty ι\np : ι → Submodule R M\nq : Submodule R M\n⊢ Eq (Min.min q (iInf fun i => p i)) (iInf fun i => Min.min q (p i))","decl":"lemma inf_iInf {ι : Type*} [Nonempty ι] {p : ι → Submodule R M} (q : Submodule R M) :\n    q ⊓ ⨅ i, p i = ⨅ i, q ⊓ p i :=\n  SetLike.coe_injective <| by simpa only [inf_coe, iInf_coe] using Set.inter_iInter _ _\n\n"}
{"name":"Submodule.mem_sup_left","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS T : Submodule R M\nx : M\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"theorem mem_sup_left {S T : Submodule R M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T := by\n  have : S ≤ S ⊔ T := le_sup_left\n  rw [LE.le] at this\n  exact this\n\n"}
{"name":"Submodule.mem_sup_right","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS T : Submodule R M\nx : M\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"theorem mem_sup_right {S T : Submodule R M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T := by\n  have : T ≤ S ⊔ T := le_sup_right\n  rw [LE.le] at this\n  exact this\n\n"}
{"name":"Submodule.add_mem_sup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS T : Submodule R M\ns t : M\nhs : Membership.mem S s\nht : Membership.mem T t\n⊢ Membership.mem (Max.max S T) (HAdd.hAdd s t)","decl":"theorem add_mem_sup {S T : Submodule R M} {s t : M} (hs : s ∈ S) (ht : t ∈ T) : s + t ∈ S ⊔ T :=\n  add_mem (mem_sup_left hs) (mem_sup_right ht)\n\n"}
{"name":"Submodule.sub_mem_sup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R' : Type u_4\nM' : Type u_5\ninst✝² : Ring R'\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R' M'\nS T : Submodule R' M'\ns t : M'\nhs : Membership.mem S s\nht : Membership.mem T t\n⊢ Membership.mem (Max.max S T) (HSub.hSub s t)","decl":"theorem sub_mem_sup {R' M' : Type*} [Ring R'] [AddCommGroup M'] [Module R' M']\n    {S T : Submodule R' M'} {s t : M'} (hs : s ∈ S) (ht : t ∈ T) : s - t ∈ S ⊔ T := by\n  rw [sub_eq_add_neg]\n  exact add_mem_sup hs (neg_mem ht)\n\n"}
{"name":"Submodule.mem_iSup_of_mem","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_4\nb : M\np : ι → Submodule R M\ni : ι\nh : Membership.mem (p i) b\n⊢ Membership.mem (iSup fun i => p i) b","decl":"theorem mem_iSup_of_mem {ι : Sort*} {b : M} {p : ι → Submodule R M} (i : ι) (h : b ∈ p i) :\n    b ∈ ⨆ i, p i :=\n  (le_iSup p i) h\n\n"}
{"name":"Submodule.sum_mem_iSup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type u_4\ninst✝ : Fintype ι\nf : ι → M\np : ι → Submodule R M\nh : ∀ (i : ι), Membership.mem (p i) (f i)\n⊢ Membership.mem (iSup fun i => p i) (Finset.univ.sum fun i => f i)","decl":"theorem sum_mem_iSup {ι : Type*} [Fintype ι] {f : ι → M} {p : ι → Submodule R M}\n    (h : ∀ i, f i ∈ p i) : (∑ i, f i) ∈ ⨆ i, p i :=\n  sum_mem fun i _ ↦ mem_iSup_of_mem i (h i)\n\n"}
{"name":"Submodule.sum_mem_biSup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\ns : Finset ι\nf : ι → M\np : ι → Submodule R M\nh : ∀ (i : ι), Membership.mem s i → Membership.mem (p i) (f i)\n⊢ Membership.mem (iSup fun i => iSup fun h => p i) (s.sum fun i => f i)","decl":"theorem sum_mem_biSup {ι : Type*} {s : Finset ι} {f : ι → M} {p : ι → Submodule R M}\n    (h : ∀ i ∈ s, f i ∈ p i) : (∑ i ∈ s, f i) ∈ ⨆ i ∈ s, p i :=\n  sum_mem fun i hi ↦ mem_iSup_of_mem i <| mem_iSup_of_mem hi (h i hi)\n\n"}
{"name":"Submodule.mem_sSup_of_mem","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set (Submodule R M)\ns : Submodule R M\nhs : Membership.mem S s\nx : M\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"theorem mem_sSup_of_mem {S : Set (Submodule R M)} {s : Submodule R M} (hs : s ∈ S) :\n    ∀ {x : M}, x ∈ s → x ∈ sSup S := by\n  have := le_sSup hs\n  rw [LE.le] at this\n  exact this\n\n"}
{"name":"Submodule.toAddSubmonoid_sSup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set (Submodule R M)\n⊢ Eq (SupSet.sSup s).toAddSubmonoid (SupSet.sSup (Set.image Submodule.toAddSubmonoid s))","decl":"@[simp]\ntheorem toAddSubmonoid_sSup (s : Set (Submodule R M)) :\n    (sSup s).toAddSubmonoid = sSup (toAddSubmonoid '' s) := by\n  let p : Submodule R M :=\n    { toAddSubmonoid := sSup (toAddSubmonoid '' s)\n      smul_mem' := fun t {m} h ↦ by\n        simp_rw [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup, sSup_eq_iSup'] at h ⊢\n        refine AddSubmonoid.iSup_induction' _\n          (C := fun x _ ↦ t • x ∈ ⨆ p : toAddSubmonoid '' s, (p : AddSubmonoid M)) ?_ ?_\n          (fun x y _ _ ↦ ?_) h\n        · rintro ⟨-, ⟨p : Submodule R M, hp : p ∈ s, rfl⟩⟩ x (hx : x ∈ p)\n          suffices p.toAddSubmonoid ≤ ⨆ q : toAddSubmonoid '' s, (q : AddSubmonoid M) by\n            exact this (smul_mem p t hx)\n          apply le_sSup\n          rw [Subtype.range_coe_subtype]\n          exact ⟨p, hp, rfl⟩\n        · simpa only [smul_zero] using zero_mem _\n        · simp_rw [smul_add]; exact add_mem }\n  refine le_antisymm (?_ : sSup s ≤ p) ?_\n  · exact sSup_le fun q hq ↦ le_sSup <| Set.mem_image_of_mem toAddSubmonoid hq\n  · exact sSup_le fun _ ⟨q, hq, hq'⟩ ↦ hq'.symm ▸ le_sSup hq\n\n"}
{"name":"Submodule.subsingleton_iff","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Subsingleton (Submodule R M)) (Subsingleton M)","decl":"@[simp]\ntheorem subsingleton_iff : Subsingleton (Submodule R M) ↔ Subsingleton M :=\n  have h : Subsingleton (Submodule R M) ↔ Subsingleton (AddSubmonoid M) := by\n    rw [← subsingleton_iff_bot_eq_top, ← subsingleton_iff_bot_eq_top, ← toAddSubmonoid_inj,\n      bot_toAddSubmonoid, top_toAddSubmonoid]\n  h.trans AddSubmonoid.subsingleton_iff\n\n"}
{"name":"Submodule.nontrivial_iff","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Nontrivial (Submodule R M)) (Nontrivial M)","decl":"@[simp]\ntheorem nontrivial_iff : Nontrivial (Submodule R M) ↔ Nontrivial M :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans <| subsingleton_iff R).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"Submodule.instNontrivial","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\n⊢ Nontrivial (Submodule R M)","decl":"instance [Nontrivial M] : Nontrivial (Submodule R M) :=\n  (nontrivial_iff R).mpr ‹_›\n\n"}
{"name":"Submodule.disjoint_def","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Iff (Disjoint p p') (∀ (x : M), Membership.mem p x → Membership.mem p' x → Eq x 0)","decl":"theorem disjoint_def {p p' : Submodule R M} : Disjoint p p' ↔ ∀ x ∈ p, x ∈ p' → x = (0 : M) :=\n  disjoint_iff_inf_le.trans <| show (∀ x, x ∈ p ∧ x ∈ p' → x ∈ ({0} : Set M)) ↔ _ by simp\n\n"}
{"name":"Submodule.disjoint_def'","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Iff (Disjoint p p') (∀ (x : M), Membership.mem p x → ∀ (y : M), Membership.mem p' y → Eq x y → Eq x 0)","decl":"theorem disjoint_def' {p p' : Submodule R M} :\n    Disjoint p p' ↔ ∀ x ∈ p, ∀ y ∈ p', x = y → x = (0 : M) :=\n  disjoint_def.trans\n    ⟨fun h x hx _ hy hxy ↦ h x hx <| hxy.symm ▸ hy, fun h x hx hx' ↦ h _ hx x hx' rfl⟩\n\n"}
{"name":"Submodule.eq_zero_of_coe_mem_of_disjoint","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nhpq : Disjoint p q\na : Subtype fun x => Membership.mem p x\nha : Membership.mem q ↑a\n⊢ Eq a 0","decl":"theorem eq_zero_of_coe_mem_of_disjoint (hpq : Disjoint p q) {a : p} (ha : (a : M) ∈ q) : a = 0 :=\n  mod_cast disjoint_def.mp hpq a (coe_mem a) ha\n\n"}
{"name":"Submodule.mem_right_iff_eq_zero_of_disjoint","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : Disjoint p p'\nx : Subtype fun x => Membership.mem p x\n⊢ Iff (Membership.mem p' ↑x) (Eq x 0)","decl":"theorem mem_right_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p} :\n    (x : M) ∈ p' ↔ x = 0 :=\n  ⟨fun hx => coe_eq_zero.1 <| disjoint_def.1 h x x.2 hx, fun h => h.symm ▸ p'.zero_mem⟩\n\n"}
{"name":"Submodule.mem_left_iff_eq_zero_of_disjoint","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : Disjoint p p'\nx : Subtype fun x => Membership.mem p' x\n⊢ Iff (Membership.mem p ↑x) (Eq x 0)","decl":"theorem mem_left_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p'} :\n    (x : M) ∈ p ↔ x = 0 :=\n  ⟨fun hx => coe_eq_zero.1 <| disjoint_def.1 h x hx x.2, fun h => h.symm ▸ p.zero_mem⟩\n\n"}
{"name":"AddSubmonoid.toNatSubmodule_symm","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\n⊢ Eq (⇑AddSubmonoid.toNatSubmodule.symm) Submodule.toAddSubmonoid","decl":"@[simp]\ntheorem AddSubmonoid.toNatSubmodule_symm :\n    ⇑(AddSubmonoid.toNatSubmodule.symm : _ ≃o AddSubmonoid M) = Submodule.toAddSubmonoid :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_toNatSubmodule","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ Eq ↑(AddSubmonoid.toNatSubmodule S) ↑S","decl":"@[simp]\ntheorem AddSubmonoid.coe_toNatSubmodule (S : AddSubmonoid M) :\n    (AddSubmonoid.toNatSubmodule S : Set M) = S :=\n  rfl\n\n"}
{"name":"AddSubmonoid.toNatSubmodule_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ Eq (AddSubmonoid.toNatSubmodule S).toAddSubmonoid S","decl":"@[simp]\ntheorem AddSubmonoid.toNatSubmodule_toAddSubmonoid (S : AddSubmonoid M) :\n    S.toNatSubmodule.toAddSubmonoid = S :=\n  AddSubmonoid.toNatSubmodule.symm_apply_apply S\n\n"}
{"name":"Submodule.toAddSubmonoid_toNatSubmodule","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nS : Submodule Nat M\n⊢ Eq (AddSubmonoid.toNatSubmodule S.toAddSubmonoid) S","decl":"@[simp]\ntheorem Submodule.toAddSubmonoid_toNatSubmodule (S : Submodule ℕ M) :\n    AddSubmonoid.toNatSubmodule S.toAddSubmonoid = S :=\n  AddSubmonoid.toNatSubmodule.apply_symm_apply S\n\n"}
{"name":"AddSubgroup.toIntSubmodule_symm","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\n⊢ Eq (⇑AddSubgroup.toIntSubmodule.symm) Submodule.toAddSubgroup","decl":"@[simp]\ntheorem AddSubgroup.toIntSubmodule_symm :\n    ⇑(AddSubgroup.toIntSubmodule.symm : _ ≃o AddSubgroup M) = Submodule.toAddSubgroup :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_toIntSubmodule","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\nS : AddSubgroup M\n⊢ Eq ↑(AddSubgroup.toIntSubmodule S) ↑S","decl":"@[simp]\ntheorem AddSubgroup.coe_toIntSubmodule (S : AddSubgroup M) :\n    (AddSubgroup.toIntSubmodule S : Set M) = S :=\n  rfl\n\n"}
{"name":"AddSubgroup.toIntSubmodule_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\nS : AddSubgroup M\n⊢ Eq (AddSubgroup.toIntSubmodule S).toAddSubgroup S","decl":"@[simp]\ntheorem AddSubgroup.toIntSubmodule_toAddSubgroup (S : AddSubgroup M) :\n    S.toIntSubmodule.toAddSubgroup = S :=\n  AddSubgroup.toIntSubmodule.symm_apply_apply S\n\n"}
{"name":"Submodule.toAddSubgroup_toIntSubmodule","module":"Mathlib.Algebra.Module.Submodule.Lattice","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\nS : Submodule Int M\n⊢ Eq (AddSubgroup.toIntSubmodule S.toAddSubgroup) S","decl":"@[simp]\ntheorem Submodule.toAddSubgroup_toIntSubmodule (S : Submodule ℤ M) :\n    AddSubgroup.toIntSubmodule S.toAddSubgroup = S :=\n  AddSubgroup.toIntSubmodule.apply_symm_apply S\n\n"}
