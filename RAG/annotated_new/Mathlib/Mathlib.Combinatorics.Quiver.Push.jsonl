{"name":"Quiver.instNonemptyPush","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u_1\nW : Type u_2\nσ : V → W\nh : Nonempty W\n⊢ Nonempty (Quiver.Push σ)","decl":"instance [h : Nonempty W] : Nonempty (Push σ) :=\n  h\n\n"}
{"name":"Quiver.PushQuiver.arrow.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u\ninst✝² : Quiver V\nW : Type u₂\nσ : V → W\ninst✝¹ : SizeOf V\ninst✝ : SizeOf W\nX Y : V\nf : Quiver.Hom X Y\n⊢ Eq (SizeOf.sizeOf (Quiver.PushQuiver.arrow f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf Y)) (SizeOf.sizeOf f))","decl":"/-- The quiver structure obtained by pushing arrows of `V` along the map `σ : V → W` -/\ninductive PushQuiver {V : Type u} [Quiver.{v} V] {W : Type u₂} (σ : V → W) : W → W → Type max u u₂ v\n  | arrow {X Y : V} (f : X ⟶ Y) : PushQuiver σ (σ X) (σ Y)\n\n"}
{"name":"Quiver.PushQuiver.arrow.inj","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u\ninst✝ : Quiver V\nW : Type u₂\nσ : V → W\nX Y : V\nf✝ f : Quiver.Hom X Y\nx✝ : Eq (Quiver.PushQuiver.arrow f✝) (Quiver.PushQuiver.arrow f)\n⊢ Eq f✝ f","decl":"/-- The quiver structure obtained by pushing arrows of `V` along the map `σ : V → W` -/\ninductive PushQuiver {V : Type u} [Quiver.{v} V] {W : Type u₂} (σ : V → W) : W → W → Type max u u₂ v\n  | arrow {X Y : V} (f : X ⟶ Y) : PushQuiver σ (σ X) (σ Y)\n\n"}
{"name":"Quiver.PushQuiver.arrow.injEq","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u\ninst✝ : Quiver V\nW : Type u₂\nσ : V → W\nX Y : V\nf✝ f : Quiver.Hom X Y\n⊢ Eq (Eq (Quiver.PushQuiver.arrow f✝) (Quiver.PushQuiver.arrow f)) (Eq f✝ f)","decl":"/-- The quiver structure obtained by pushing arrows of `V` along the map `σ : V → W` -/\ninductive PushQuiver {V : Type u} [Quiver.{v} V] {W : Type u₂} (σ : V → W) : W → W → Type max u u₂ v\n  | arrow {X Y : V} (f : X ⟶ Y) : PushQuiver σ (σ X) (σ Y)\n\n"}
{"name":"Quiver.Push.of_obj","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u_1\ninst✝ : Quiver V\nW : Type u_2\nσ : V → W\n⊢ Eq (Quiver.Push.of σ).obj σ","decl":"@[simp]\ntheorem of_obj : (of σ).obj = σ :=\n  rfl\n\n"}
{"name":"Quiver.Push.lift_obj","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u_1\ninst✝¹ : Quiver V\nW : Type u_2\nσ : V → W\nW' : Type u_3\ninst✝ : Quiver W'\nφ : Prefunctor V W'\nτ : W → W'\nh : ∀ (x : V), Eq (φ.obj x) (τ (σ x))\n⊢ Eq (Quiver.Push.lift σ φ τ h).obj τ","decl":"theorem lift_obj : (lift σ φ τ h).obj = τ :=\n  rfl\n\n"}
{"name":"Quiver.Push.lift_comp","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u_1\ninst✝¹ : Quiver V\nW : Type u_2\nσ : V → W\nW' : Type u_3\ninst✝ : Quiver W'\nφ : Prefunctor V W'\nτ : W → W'\nh : ∀ (x : V), Eq (φ.obj x) (τ (σ x))\n⊢ Eq ((Quiver.Push.of σ).comp (Quiver.Push.lift σ φ τ h)) φ","decl":"theorem lift_comp : (of σ ⋙q lift σ φ τ h) = φ := by\n  fapply Prefunctor.ext\n  · rintro X\n    simp only [Prefunctor.comp_obj]\n    apply Eq.symm\n    exact h X\n  · rintro X Y f\n    simp only [Prefunctor.comp_map]\n    apply eq_of_heq\n    iterate 2 apply (cast_heq _ _).trans\n    apply HEq.symm\n    apply (eqRec_heq _ _).trans\n    have : ∀ {α γ} {β : α → γ → Sort _} {a a'} (p : a = a') g (b : β a g), HEq (p ▸ b) b := by\n      intros\n      subst_vars\n      rfl\n    apply this\n\n"}
{"name":"Quiver.Push.lift_unique","module":"Mathlib.Combinatorics.Quiver.Push","initialProofState":"V : Type u_1\ninst✝¹ : Quiver V\nW : Type u_2\nσ : V → W\nW' : Type u_3\ninst✝ : Quiver W'\nφ : Prefunctor V W'\nτ : W → W'\nh : ∀ (x : V), Eq (φ.obj x) (τ (σ x))\nΦ : Prefunctor (Quiver.Push σ) W'\nΦ₀ : Eq Φ.obj τ\nΦcomp : Eq ((Quiver.Push.of σ).comp Φ) φ\n⊢ Eq Φ (Quiver.Push.lift σ φ τ h)","decl":"theorem lift_unique (Φ : Push σ ⥤q W') (Φ₀ : Φ.obj = τ) (Φcomp : (of σ ⋙q Φ) = φ) :\n    Φ = lift σ φ τ h := by\n  dsimp only [of, lift]\n  fapply Prefunctor.ext\n  · intro X\n    simp only\n    rw [Φ₀]\n  · rintro _ _ ⟨⟩\n    subst_vars\n    simp only [Prefunctor.comp_map, cast_eq]\n    rfl\n\n"}
