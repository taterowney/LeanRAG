{"name":"CategoryTheory.Adjunction.CommShift.compatibilityCounit_of_compatibilityUnit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na : A\ne‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ\n‚ä¢ CategoryTheory.Adjunction.CommShift.CompatibilityCounit adj e‚ÇÅ e‚ÇÇ","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a` in `A` and commutation isomorphisms\n`e‚ÇÅ : shiftFunctor C a ‚ãô F ‚âÖ F ‚ãô shiftFunctor D a` and\n`e‚ÇÇ : shiftFunctor D a ‚ãô G ‚âÖ G ‚ãô shiftFunctor C a`, compatibility of `e‚ÇÅ` and `e‚ÇÇ` with the\nunit of the adjunction `adj` implies compatibility with the counit of `adj`.\n-/\nlemma compatibilityCounit_of_compatibilityUnit (h : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ) :\n    CompatibilityCounit adj e‚ÇÅ e‚ÇÇ := by\n  intro Y\n  have eq := h (G.obj Y)\n  simp only [‚Üê cancel_mono (e‚ÇÇ.inv.app _ ‚â´ G.map (e‚ÇÅ.inv.app _)),\n    assoc, Iso.hom_inv_id_app_assoc, comp_id, ‚Üê Functor.map_comp,\n    Iso.hom_inv_id_app, Functor.comp_obj, Functor.map_id] at eq\n  apply (adj.homEquiv _ _).injective\n  dsimp\n  rw [adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp, adj.unit_naturality_assoc, ‚Üê eq]\n  simp only [assoc, ‚Üê Functor.map_comp, Iso.inv_hom_id_app_assoc]\n  erw [‚Üê e‚ÇÇ.inv.naturality]\n  dsimp\n  simp only [right_triangle_components, ‚Üê Functor.map_comp_assoc, Functor.map_id, id_comp,\n    Iso.hom_inv_id_app, Functor.comp_obj]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_right","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na : A\ne‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ\nY : D\n‚ä¢ Eq (e‚ÇÇ.inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map (e‚ÇÅ.hom.app (G.obj Y))) (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)))))","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a` in `A` and commutation isomorphisms\n`e‚ÇÅ : shiftFunctor C a ‚ãô F ‚âÖ F ‚ãô shiftFunctor D a` and\n`e‚ÇÇ : shiftFunctor D a ‚ãô G ‚âÖ G ‚ãô shiftFunctor C a`, if `e‚ÇÅ` and `e‚ÇÇ` are compatible with the\nunit of the adjunction `adj`, then we get a formula for `e‚ÇÇ.inv` in terms of `e‚ÇÅ`.\n-/\nlemma compatibilityUnit_right (h : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ) (Y : D) :\n    e‚ÇÇ.inv.app Y = adj.unit.app _ ‚â´ G.map (e‚ÇÅ.hom.app _) ‚â´ G.map ((adj.counit.app _)‚ü¶a‚üß') := by\n  have := h (G.obj Y)\n  rw [‚Üê cancel_mono (e‚ÇÇ.inv.app _), assoc, assoc, Iso.hom_inv_id_app] at this\n  erw [comp_id] at this\n  rw [‚Üê assoc, ‚Üê this, assoc]; erw [‚Üê e‚ÇÇ.inv.naturality]\n  rw [‚Üê cancel_mono (e‚ÇÇ.hom.app _)]\n  simp only [Functor.comp_obj, Iso.inv_hom_id_app, Functor.id_obj, Functor.comp_map, assoc, comp_id,\n    ‚Üê (shiftFunctor C a).map_comp, right_triangle_components, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityCounit_left","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na : A\ne‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityCounit adj e‚ÇÅ e‚ÇÇ\nX : C\n‚ä¢ Eq (e‚ÇÅ.hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map (e‚ÇÇ.inv.app (F.obj X))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X)))))","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a` in `A` and commutation isomorphisms\n`e‚ÇÅ : shiftFunctor C a ‚ãô F ‚âÖ F ‚ãô shiftFunctor D a` and\n`e‚ÇÇ : shiftFunctor D a ‚ãô G ‚âÖ G ‚ãô shiftFunctor C a`, if `e‚ÇÅ` and `e‚ÇÇ` are compatible with the\ncounit of the adjunction `adj`, then we get a formula for `e‚ÇÅ.hom` in terms of `e‚ÇÇ`.\n-/\nlemma compatibilityCounit_left (h : CompatibilityCounit adj e‚ÇÅ e‚ÇÇ) (X : C) :\n    e‚ÇÅ.hom.app X = F.map ((adj.unit.app X)‚ü¶a‚üß') ‚â´ F.map (e‚ÇÇ.inv.app _) ‚â´ adj.counit.app _ := by\n  have := h (F.obj X)\n  rw [‚Üê cancel_epi (F.map (e‚ÇÇ.inv.app _)), ‚Üê assoc, ‚Üê F.map_comp, Iso.inv_hom_id_app, F.map_id,\n    id_comp] at this\n  rw [this]\n  erw [e‚ÇÅ.hom.naturality_assoc]\n  rw [Functor.comp_map, ‚Üê Functor.map_comp, left_triangle_components]\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_unique_right","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na : A\ne‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne‚ÇÇ e‚ÇÇ' : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ'\n‚ä¢ Eq e‚ÇÇ e‚ÇÇ'","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a` in `A` and commutation isomorphisms\n`e‚ÇÅ : shiftFunctor C a ‚ãô F ‚âÖ F ‚ãô shiftFunctor D a` and\n`e‚ÇÇ : shiftFunctor D a ‚ãô G ‚âÖ G ‚ãô shiftFunctor C a`, if `e‚ÇÅ` and `e‚ÇÇ` are compatible with the\nunit of the adjunction `adj`, then `e‚ÇÅ` uniquely determines `e‚ÇÇ`.\n-/\nlemma compatibilityUnit_unique_right (h : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ)\n    (h' : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ') : e‚ÇÇ = e‚ÇÇ' := by\n  rw [‚Üê Iso.symm_eq_iff]\n  ext\n  rw [Iso.symm_hom, Iso.symm_hom, compatibilityUnit_right adj e‚ÇÅ e‚ÇÇ h,\n    compatibilityUnit_right adj e‚ÇÅ e‚ÇÇ' h']\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_unique_left","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na : A\ne‚ÇÅ e‚ÇÅ' : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ' e‚ÇÇ\n‚ä¢ Eq e‚ÇÅ e‚ÇÅ'","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a` in `A` and commutation isomorphisms\n`e‚ÇÅ : shiftFunctor C a ‚ãô F ‚âÖ F ‚ãô shiftFunctor D a` and\n`e‚ÇÇ : shiftFunctor D a ‚ãô G ‚âÖ G ‚ãô shiftFunctor C a`, if `e‚ÇÅ` and `e‚ÇÇ` are compatible with the\nunit of the adjunction `adj`, then `e‚ÇÇ` uniquely determines `e‚ÇÅ`.\n-/\nlemma compatibilityUnit_unique_left (h : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ)\n    (h' : CompatibilityUnit adj e‚ÇÅ' e‚ÇÇ) : e‚ÇÅ = e‚ÇÅ' := by\n  ext\n  rw [compatibilityCounit_left adj e‚ÇÅ e‚ÇÇ (compatibilityCounit_of_compatibilityUnit adj _ _ h),\n    compatibilityCounit_left adj e‚ÇÅ' e‚ÇÇ (compatibilityCounit_of_compatibilityUnit adj _ _ h')]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_isoZero","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\n‚ä¢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Functor.CommShift.isoZero F A) (CategoryTheory.Functor.CommShift.isoZero G A)","decl":"/--\nThe isomorphisms `Functor.CommShift.isoZero F` and `Functor.CommShift.isoZero G` are\ncompatible with the unit of an adjunction `F ‚ä£ G`.\n-/\nlemma compatibilityUnit_isoZero : CompatibilityUnit adj (Functor.CommShift.isoZero F A)\n    (Functor.CommShift.isoZero G A) := by\n  intro\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.CommShift.isoZero_hom_app,\n    Functor.map_comp, assoc, unit_naturality_assoc,\n    ‚Üê cancel_mono ((shiftFunctorZero C A).hom.app _), ‚Üê G.map_comp_assoc, Iso.inv_hom_id_app,\n    Functor.id_obj, Functor.map_id, id_comp, NatTrans.naturality, Functor.id_map, assoc, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_isoAdd","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.HasShift D A\na b : A\ne‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\nf‚ÇÅ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\ne‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nf‚ÇÇ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D b).comp G) (G.comp (CategoryTheory.shiftFunctor C b))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e‚ÇÅ e‚ÇÇ\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj f‚ÇÅ f‚ÇÇ\n‚ä¢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Functor.CommShift.isoAdd e‚ÇÅ f‚ÇÅ) (CategoryTheory.Functor.CommShift.isoAdd e‚ÇÇ f‚ÇÇ)","decl":"/-- Given an adjunction `adj : F ‚ä£ G`, `a, b` in `A` and commutation isomorphisms\nbetween shifts by `a` (resp. `b`) and `F` and `G`, if these commutation isomorphisms are\ncompatible with the unit of `adj`, then so are the commutation isomorphisms between shifts\nby `a + b` and `F` and `G` constructed by `Functor.CommShift.isoAdd`.\n-/\nlemma compatibilityUnit_isoAdd (h : CompatibilityUnit adj e‚ÇÅ e‚ÇÇ)\n    (h' : CompatibilityUnit adj f‚ÇÅ f‚ÇÇ) :\n    CompatibilityUnit adj (Functor.CommShift.isoAdd e‚ÇÅ f‚ÇÅ) (Functor.CommShift.isoAdd e‚ÇÇ f‚ÇÇ) := by\n  intro X\n  have := h' (X‚ü¶a‚üß)\n  simp only [‚Üê cancel_mono (f‚ÇÇ.inv.app _), assoc, Iso.hom_inv_id_app,\n    Functor.id_obj, Functor.comp_obj, comp_id] at this\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.CommShift.isoAdd_hom_app,\n    Functor.map_comp, assoc, unit_naturality_assoc]\n  slice_rhs 5 6 => rw [‚Üê G.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n  erw [f‚ÇÇ.hom.naturality_assoc]\n  rw [‚Üê reassoc_of% this, ‚Üê cancel_mono ((shiftFunctorAdd C a b).hom.app _),\n    assoc, assoc, assoc, assoc, assoc, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  dsimp\n  rw [‚Üê (shiftFunctor C b).map_comp_assoc, ‚Üê (shiftFunctor C b).map_comp_assoc,\n    assoc, ‚Üê h X, NatTrans.naturality]\n  dsimp\n  rw [comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.commShift_counit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Å¥ : AddMonoid A\ninst‚úù¬≥ : CategoryTheory.HasShift C A\ninst‚úù¬≤ : CategoryTheory.HasShift D A\ninst‚úù¬π : F.CommShift A\ninst‚úù : G.CommShift A\nself : adj.CommShift A\n‚ä¢ CategoryTheory.NatTrans.CommShift adj.counit A","decl":"/--\nThe property for `CommShift` structures on `F` and `G` to be compatible with an\nadjunction `F ‚ä£ G`.\n-/\nclass CommShift : Prop where\n  commShift_unit : NatTrans.CommShift adj.unit A := by infer_instance\n  commShift_counit : NatTrans.CommShift adj.counit A := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.commShift_unit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Å¥ : AddMonoid A\ninst‚úù¬≥ : CategoryTheory.HasShift C A\ninst‚úù¬≤ : CategoryTheory.HasShift D A\ninst‚úù¬π : F.CommShift A\ninst‚úù : G.CommShift A\nself : adj.CommShift A\n‚ä¢ CategoryTheory.NatTrans.CommShift adj.unit A","decl":"/--\nThe property for `CommShift` structures on `F` and `G` to be compatible with an\nadjunction `F ‚ä£ G`.\n-/\nclass CommShift : Prop where\n  commShift_unit : NatTrans.CommShift adj.unit A := by infer_instance\n  commShift_counit : NatTrans.CommShift adj.counit A := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_commShiftIso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (((F.comp G).commShiftIso a).hom.app X)) ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))","decl":"@[reassoc (attr := simp)]\nlemma unit_app_commShiftIso_hom_app [adj.CommShift A] (a : A) (X : C) :\n    adj.unit.app (X‚ü¶a‚üß) ‚â´ ((F ‚ãô G).commShiftIso a).hom.app X = (adj.unit.app X)‚ü¶a‚üß' := by\n  simpa using (NatTrans.shift_app_comm adj.unit a X).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_commShiftIso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj (F.obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (((F.comp G).commShiftIso a).hom.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) h)","decl":"@[reassoc (attr := simp)]\nlemma unit_app_commShiftIso_hom_app [adj.CommShift A] (a : A) (X : C) :\n    adj.unit.app (X‚ü¶a‚üß) ‚â´ ((F ‚ãô G).commShiftIso a).hom.app X = (adj.unit.app X)‚ü¶a‚üß' := by\n  simpa using (NatTrans.shift_app_comm adj.unit a X).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_shift_commShiftIso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (((F.comp G).commShiftIso a).inv.app X)) (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"@[reassoc (attr := simp)]\nlemma unit_app_shift_commShiftIso_inv_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)‚ü¶a‚üß' ‚â´ ((F ‚ãô G).commShiftIso a).inv.app X = adj.unit.app (X‚ü¶a‚üß) := by\n  simp [‚Üê cancel_mono (((F ‚ãô G).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_shift_commShiftIso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom (G.obj (F.obj ((CategoryTheory.shiftFunctor C a).obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (CategoryTheory.CategoryStruct.comp (((F.comp G).commShiftIso a).inv.app X) h)) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) h)","decl":"@[reassoc (attr := simp)]\nlemma unit_app_shift_commShiftIso_inv_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)‚ü¶a‚üß' ‚â´ ((F ‚ãô G).commShiftIso a).inv.app X = adj.unit.app (X‚ü¶a‚üß) := by\n  simp [‚Üê cancel_mono (((F ‚ãô G).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_hom_app_counit_app_shift","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).hom.app Y) ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_app_counit_app_shift [adj.CommShift A] (a : A) (Y : D) :\n    ((G ‚ãô F).commShiftIso a).hom.app Y ‚â´ (adj.counit.app Y)‚ü¶a‚üß' = adj.counit.app (Y‚ü¶a‚üß) := by\n  simpa using (NatTrans.shift_app_comm adj.counit a Y)\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_hom_app_counit_app_shift_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).hom.app Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h)) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_app_counit_app_shift [adj.CommShift A] (a : A) (Y : D) :\n    ((G ‚ãô F).commShiftIso a).hom.app Y ‚â´ (adj.counit.app Y)‚ü¶a‚üß' = adj.counit.app (Y‚ü¶a‚üß) := by\n  simpa using (NatTrans.shift_app_comm adj.counit a Y)\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_inv_app_counit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).inv.app Y) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))) ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_app_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    ((G ‚ãô F).commShiftIso a).inv.app Y ‚â´ adj.counit.app (Y‚ü¶a‚üß) = (adj.counit.app Y)‚ü¶a‚üß' := by\n  simp [‚Üê cancel_epi (((G ‚ãô F).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_inv_app_counit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_app_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    ((G ‚ãô F).commShiftIso a).inv.app Y ‚â´ adj.counit.app (Y‚ü¶a‚üß) = (adj.counit.app Y)‚ü¶a‚üß' := by\n  simp [‚Üê cancel_epi (((G ‚ãô F).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.mk'","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Å¥ : AddMonoid A\ninst‚úù¬≥ : CategoryTheory.HasShift C A\ninst‚úù¬≤ : CategoryTheory.HasShift D A\ninst‚úù¬π : F.CommShift A\ninst‚úù : G.CommShift A\nh : CategoryTheory.NatTrans.CommShift adj.unit A\n‚ä¢ adj.CommShift A","decl":"/-- Constructor for `Adjunction.CommShift`. -/\nlemma mk' (h : NatTrans.CommShift adj.unit A) :\n    adj.CommShift A where\n  commShift_counit := ‚ü®fun a ‚Ü¶ by\n    ext\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app,\n      Functor.commShiftIso_comp_hom_app, whiskerRight_app, assoc, whiskerLeft_app,\n      Functor.commShiftIso_id_hom_app, comp_id]\n    refine (compatibilityCounit_of_compatibilityUnit adj _ _ (fun X ‚Ü¶ ?_) _).symm\n    simpa only [NatTrans.comp_app,\n      Functor.commShiftIso_id_hom_app, whiskerRight_app, id_comp,\n      Functor.commShiftIso_comp_hom_app] using congr_app (h.shift_comm a) X‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.instId","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_3\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\n‚ä¢ CategoryTheory.Adjunction.id.CommShift A","decl":"/-- The identity adjunction is compatible with the trivial `CommShift` structure on the\nidentity functor.\n-/\ninstance instId : (Adjunction.id (C := C)).CommShift A where\n  commShift_counit :=\n    inferInstanceAs (NatTrans.CommShift (ùü≠ C).leftUnitor.hom A)\n  commShift_unit :=\n    inferInstanceAs (NatTrans.CommShift (ùü≠ C).leftUnitor.inv A)\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.instComp","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π‚Å∞ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Åπ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Å∏ : AddMonoid A\ninst‚úù‚Å∑ : CategoryTheory.HasShift C A\ninst‚úù‚Å∂ : CategoryTheory.HasShift D A\ninst‚úù‚Åµ : F.CommShift A\ninst‚úù‚Å¥ : G.CommShift A\nE : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} E\nF' : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E D\nadj' : CategoryTheory.Adjunction F' G'\ninst‚úù¬≤ : CategoryTheory.HasShift E A\ninst‚úù¬π : F'.CommShift A\ninst‚úù : G'.CommShift A\n‚ä¢ (adj.comp adj').CommShift A","decl":"/-- Compatibility of `Adjunction.Commshift` with the composition of adjunctions.\n-/\ninstance instComp : (adj.comp adj').CommShift A where\n  commShift_counit := by\n    rw [comp_counit]\n    infer_instance\n  commShift_unit := by\n    rw [comp_unit]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.shift_unit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) ((G.commShiftIso a).hom.app (F.obj X))))","decl":"@[reassoc]\nlemma shift_unit_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)‚ü¶a‚üß' =\n      adj.unit.app (X‚ü¶a‚üß) ‚â´\n        G.map ((F.commShiftIso a).hom.app X) ‚â´\n          (G.commShiftIso a).hom.app (F.obj X) := by\n  simpa [Functor.commShiftIso_comp_hom_app] using NatTrans.shift_app_comm adj.unit a X\n\n"}
{"name":"CategoryTheory.Adjunction.shift_unit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj (F.obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) h) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso a).hom.app (F.obj X)) h)))","decl":"@[reassoc]\nlemma shift_unit_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)‚ü¶a‚üß' =\n      adj.unit.app (X‚ü¶a‚üß) ‚â´\n        G.map ((F.commShiftIso a).hom.app X) ‚â´\n          (G.commShiftIso a).hom.app (F.obj X) := by\n  simpa [Functor.commShiftIso_comp_hom_app] using NatTrans.shift_app_comm adj.unit a X\n\n"}
{"name":"CategoryTheory.Adjunction.shift_counit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (F.map ((G.commShiftIso a).inv.app Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)))","decl":"@[reassoc]\nlemma shift_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    (adj.counit.app Y)‚ü¶a‚üß' =\n      (F.commShiftIso a).inv.app (G.obj Y) ‚â´ F.map ((G.commShiftIso a).inv.app Y) ‚â´\n        adj.counit.app (Y‚ü¶a‚üß) := by\n  have eq := NatTrans.shift_app_comm adj.counit a Y\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.commShiftIso_comp_hom_app, assoc,\n    Functor.commShiftIso_id_hom_app, comp_id] at eq\n  simp only [‚Üê eq, Functor.comp_obj, Functor.id_obj, ‚Üê F.map_comp_assoc, Iso.inv_hom_id_app,\n    F.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.shift_counit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : F.CommShift A\ninst‚úù¬π : G.CommShift A\ninst‚úù : adj.CommShift A\na : A\nY : D\n‚ä¢ Eq ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (F.map ((G.commShiftIso a).inv.app Y)) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))))","decl":"@[reassoc]\nlemma shift_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    (adj.counit.app Y)‚ü¶a‚üß' =\n      (F.commShiftIso a).inv.app (G.obj Y) ‚â´ F.map ((G.commShiftIso a).inv.app Y) ‚â´\n        adj.counit.app (Y‚ü¶a‚üß) := by\n  have eq := NatTrans.shift_app_comm adj.counit a Y\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.commShiftIso_comp_hom_app, assoc,\n    Functor.commShiftIso_id_hom_app, comp_id] at eq\n  simp only [‚Üê eq, Functor.comp_obj, Functor.id_obj, ‚Üê F.map_comp_assoc, Iso.inv_hom_id_app,\n    F.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd b a) 0\ninst‚úù : F.CommShift A\nX : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C b a h).inv.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app ((CategoryTheory.shiftFunctor C b).obj (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((F.commShiftIso b).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctor D b).map (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj X))))) ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b ‚ãØ).hom.app X)))))))","decl":"@[reassoc]\nlemma iso_hom_app (X : D) :\n    (iso adj a).hom.app X =\n      (shiftFunctorCompIsoId C b a h).inv.app (G.obj ((shiftFunctor D a).obj X)) ‚â´\n        (adj.unit.app ((shiftFunctor C b).obj (G.obj ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n          (G.map ((F.commShiftIso b).hom.app (G.obj ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n            (G.map ((shiftFunctor D b).map (adj.counit.app ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n              (G.map ((shiftFunctorCompIsoId D a b\n                (by rw [‚Üê add_left_inj a, add_assoc, h, zero_add, add_zero])).hom.app X))‚ü¶a‚üß' := by\n  obtain rfl : b = -a := by rw [‚Üê add_left_inj a, h, neg_add_cancel]\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh‚úù : Eq (HAdd.hAdd b a) 0\ninst‚úù : F.CommShift A\nX : D\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).hom.app X) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C b a h‚úù).inv.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app ((CategoryTheory.shiftFunctor C b).obj (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((F.commShiftIso b).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctor D b).map (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b ‚ãØ).hom.app X))) h)))))","decl":"@[reassoc]\nlemma iso_hom_app (X : D) :\n    (iso adj a).hom.app X =\n      (shiftFunctorCompIsoId C b a h).inv.app (G.obj ((shiftFunctor D a).obj X)) ‚â´\n        (adj.unit.app ((shiftFunctor C b).obj (G.obj ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n          (G.map ((F.commShiftIso b).hom.app (G.obj ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n            (G.map ((shiftFunctor D b).map (adj.counit.app ((shiftFunctor D a).obj X))))‚ü¶a‚üß' ‚â´\n              (G.map ((shiftFunctorCompIsoId D a b\n                (by rw [‚Üê add_left_inj a, add_assoc, h, zero_add, add_zero])).hom.app X))‚ü¶a‚üß' := by\n  obtain rfl : b = -a := by rw [‚Üê add_left_inj a, h, neg_add_cancel]\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh‚úù : Eq (HAdd.hAdd b a) 0\ninst‚úù : F.CommShift A\nY : D\nZ : C\nh : Quiver.Hom (G.obj ((CategoryTheory.shiftFunctor D a).obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).inv.app Y) h) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctorCompIsoId D b a h‚úù).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctorCompIsoId D a b ‚ãØ).hom.app (F.obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))) h)))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : D) :\n    (iso adj a).inv.app Y =\n      adj.unit.app ((shiftFunctor C a).obj (G.obj Y)) ‚â´\n          G.map ((shiftFunctorCompIsoId D b a h).inv.app\n              (F.obj ((shiftFunctor C a).obj (G.obj Y)))) ‚â´\n            G.map ((shiftFunctor D a).map ((shiftFunctor D b).map\n                ((F.commShiftIso a).hom.app (G.obj Y)))) ‚â´\n              G.map ((shiftFunctor D a).map ((shiftFunctorCompIsoId D a b\n                  (by rw [eq_neg_of_add_eq_zero_left h, add_neg_cancel])).hom.app\n                    (F.obj (G.obj Y)))) ‚â´\n                G.map ((shiftFunctor D a).map (adj.counit.app Y)) := by\n  obtain rfl : b = -a := by rw [‚Üê add_left_inj a, h, neg_add_cancel]\n  simp only [iso, iso', shiftEquiv', Equiv.toFun_as_coe, conjugateIsoEquiv_apply_inv,\n    conjugateEquiv_apply_app, Functor.comp_obj, comp_unit_app, Functor.id_obj,\n    Equivalence.toAdjunction_unit, Equivalence.Equivalence_mk'_unit, Iso.symm_hom, Functor.comp_map,\n    comp_counit_app, Equivalence.toAdjunction_counit, Equivalence.Equivalence_mk'_counit,\n    Functor.map_shiftFunctorCompIsoId_hom_app, assoc, Functor.map_comp]\n  slice_lhs 3 4 => rw [‚Üê Functor.map_comp, ‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd b a) 0\ninst‚úù : F.CommShift A\nY : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctorCompIsoId D b a h).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctorCompIsoId D a b ‚ãØ).hom.app (F.obj (G.obj Y))))) (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)))))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : D) :\n    (iso adj a).inv.app Y =\n      adj.unit.app ((shiftFunctor C a).obj (G.obj Y)) ‚â´\n          G.map ((shiftFunctorCompIsoId D b a h).inv.app\n              (F.obj ((shiftFunctor C a).obj (G.obj Y)))) ‚â´\n            G.map ((shiftFunctor D a).map ((shiftFunctor D b).map\n                ((F.commShiftIso a).hom.app (G.obj Y)))) ‚â´\n              G.map ((shiftFunctor D a).map ((shiftFunctorCompIsoId D a b\n                  (by rw [eq_neg_of_add_eq_zero_left h, add_neg_cancel])).hom.app\n                    (F.obj (G.obj Y)))) ‚â´\n                G.map ((shiftFunctor D a).map (adj.counit.app Y)) := by\n  obtain rfl : b = -a := by rw [‚Üê add_left_inj a, h, neg_add_cancel]\n  simp only [iso, iso', shiftEquiv', Equiv.toFun_as_coe, conjugateIsoEquiv_apply_inv,\n    conjugateEquiv_apply_app, Functor.comp_obj, comp_unit_app, Functor.id_obj,\n    Equivalence.toAdjunction_unit, Equivalence.Equivalence_mk'_unit, Iso.symm_hom, Functor.comp_map,\n    comp_counit_app, Equivalence.toAdjunction_counit, Equivalence.Equivalence_mk'_counit,\n    Functor.map_shiftFunctorCompIsoId_hom_app, assoc, Functor.map_comp]\n  slice_lhs 3 4 => rw [‚Üê Functor.map_comp, ‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.compatibilityUnit_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : F.CommShift A\na : A\n‚ä¢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (F.commShiftIso a) (CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a)","decl":"/--\nThe commutation isomorphisms of `Adjunction.RightAdjointCommShift.iso` are compatible with\nthe unit of the adjunction.\n-/\nlemma compatibilityUnit_iso (a : A) :\n    CommShift.CompatibilityUnit adj (F.commShiftIso a) (iso adj a) := by\n  intro\n  rw [‚Üê cancel_mono ((RightAdjointCommShift.iso adj a).inv.app _), assoc, assoc,\n    Iso.hom_inv_id_app, RightAdjointCommShift.iso_inv_app adj _ _ (neg_add_cancel a)]\n  apply (adj.homEquiv _ _).symm.injective\n  dsimp\n  simp only [comp_id, homEquiv_counit, Functor.map_comp, assoc, counit_naturality,\n    counit_naturality_assoc, left_triangle_components_assoc]\n  erw [‚Üê NatTrans.naturality_assoc]\n  dsimp\n  rw [shift_shiftFunctorCompIsoId_hom_app, Iso.inv_hom_id_app_assoc,\n    Functor.commShiftIso_hom_naturality_assoc, ‚Üê Functor.map_comp,\n    left_triangle_components, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointCommShift_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : F.CommShift A\na : A\n‚ä¢ Eq (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a)","decl":"open RightAdjointCommShift in\n/--\nGiven an adjunction `F ‚ä£ G` and a `CommShift` structure on `F`, this constructs\nthe unique compatible `CommShift` structure on `G`.\n-/\n@[simps]\nnoncomputable def rightAdjointCommShift [F.CommShift A] : G.CommShift A where\n  iso a := iso adj a\n  zero := by\n    refine CommShift.compatibilityUnit_unique_right adj (F.commShiftIso 0) _ _\n      (compatibilityUnit_iso adj 0) ?_\n    rw [F.commShiftIso_zero]\n    exact CommShift.compatibilityUnit_isoZero adj\n  add a b := by\n    refine CommShift.compatibilityUnit_unique_right adj (F.commShiftIso (a + b)) _ _\n      (compatibilityUnit_iso adj (a + b)) ?_\n    rw [F.commShiftIso_add]\n    exact CommShift.compatibilityUnit_isoAdd adj _ _ _ _\n      (compatibilityUnit_iso adj a) (compatibilityUnit_iso adj b)\n\n"}
{"name":"CategoryTheory.Adjunction.commShift_of_leftAdjoint","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : F.CommShift A\n‚ä¢ adj.CommShift A","decl":"lemma commShift_of_leftAdjoint [F.CommShift A] :\n    letI := adj.rightAdjointCommShift A\n    adj.CommShift A := by\n  letI := adj.rightAdjointCommShift A\n  refine CommShift.mk' _ _ ‚ü®fun a ‚Ü¶ ?_‚ü©\n  ext X\n  dsimp\n  simpa only [Functor.commShiftIso_id_hom_app, Functor.comp_obj, Functor.id_obj, id_comp,\n    Functor.commShiftIso_comp_hom_app] using RightAdjointCommShift.compatibilityUnit_iso adj a X\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh‚úù : Eq (HAdd.hAdd a b) 0\ninst‚úù : G.CommShift A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).hom.app X) h) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b h‚úù).inv.app (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map ((G.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C b a ‚ãØ).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))) h)))))","decl":"@[reassoc]\nlemma iso_hom_app (X : C) :\n    (iso adj a).hom.app X = F.map ((adj.unit.app X)‚ü¶a‚üß') ‚â´\n      F.map (G.map (((shiftFunctorCompIsoId D a b h).inv.app (F.obj X)))‚ü¶a‚üß') ‚â´\n        F.map (((G.commShiftIso b).hom.app ((F.obj X)‚ü¶a‚üß))‚ü¶a‚üß') ‚â´\n          F.map ((shiftFunctorCompIsoId C b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (G.obj ((F.obj X)‚ü¶a‚üß))) ‚â´ adj.counit.app ((F.obj X)‚ü¶a‚üß) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd a b) 0\ninst‚úù : G.CommShift A\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b h).inv.app (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map ((G.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C b a ‚ãØ).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X)))))))","decl":"@[reassoc]\nlemma iso_hom_app (X : C) :\n    (iso adj a).hom.app X = F.map ((adj.unit.app X)‚ü¶a‚üß') ‚â´\n      F.map (G.map (((shiftFunctorCompIsoId D a b h).inv.app (F.obj X)))‚ü¶a‚üß') ‚â´\n        F.map (((G.commShiftIso b).hom.app ((F.obj X)‚ü¶a‚üß))‚ü¶a‚üß') ‚â´\n          F.map ((shiftFunctorCompIsoId C b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (G.obj ((F.obj X)‚ü¶a‚üß))) ‚â´ adj.counit.app ((F.obj X)‚ü¶a‚üß) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd a b) 0\ninst‚úù : G.CommShift A\nY : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).inv.app Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).inv.app Y))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctor C b).map (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((G.commShiftIso b).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app ((CategoryTheory.shiftFunctor D b).obj (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) ((CategoryTheory.shiftFunctorCompIsoId D b a ‚ãØ).hom.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)))))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : C) :\n    (iso adj a).inv.app Y = (F.map ((shiftFunctorCompIsoId C a b h).inv.app Y))‚ü¶a‚üß' ‚â´\n      (F.map ((adj.unit.app (Y‚ü¶a‚üß))‚ü¶b‚üß'))‚ü¶a‚üß' ‚â´ (F.map ((G.commShiftIso b).inv.app\n        (F.obj (Y‚ü¶a‚üß))))‚ü¶a‚üß' ‚â´ (adj.counit.app ((F.obj (Y‚ü¶a‚üß))‚ü¶b‚üß))‚ü¶a‚üß' ‚â´\n          (shiftFunctorCompIsoId D b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (F.obj (Y‚ü¶a‚üß)) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\na b : A\nh‚úù : Eq (HAdd.hAdd a b) 0\ninst‚úù : G.CommShift A\nY : C\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).inv.app Y) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h‚úù).inv.app Y))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctor C b).map (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((G.commShiftIso b).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app ((CategoryTheory.shiftFunctor D b).obj (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D b a ‚ãØ).hom.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))) h)))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : C) :\n    (iso adj a).inv.app Y = (F.map ((shiftFunctorCompIsoId C a b h).inv.app Y))‚ü¶a‚üß' ‚â´\n      (F.map ((adj.unit.app (Y‚ü¶a‚üß))‚ü¶b‚üß'))‚ü¶a‚üß' ‚â´ (F.map ((G.commShiftIso b).inv.app\n        (F.obj (Y‚ü¶a‚üß))))‚ü¶a‚üß' ‚â´ (adj.counit.app ((F.obj (Y‚ü¶a‚üß))‚ü¶b‚üß))‚ü¶a‚üß' ‚â´\n          (shiftFunctorCompIsoId D b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (F.obj (Y‚ü¶a‚üß)) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.compatibilityUnit_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : G.CommShift A\na : A\n‚ä¢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a) (G.commShiftIso a)","decl":"/--\nThe commutation isomorphisms of `Adjunction.LeftAdjointCommShift.iso` are compatible with\nthe unit of the adjunction.\n-/\nlemma compatibilityUnit_iso (a : A) :\n    CommShift.CompatibilityUnit adj (iso adj a) (G.commShiftIso a) := by\n  intro\n  rw [LeftAdjointCommShift.iso_hom_app adj _ _ (add_neg_cancel a)]\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.map_shiftFunctorCompIsoId_inv_app,\n    Functor.map_comp, assoc, unit_naturality_assoc, right_triangle_components_assoc]\n  slice_rhs 4 5 => rw [‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp]\n  rw [shift_shiftFunctorCompIsoId_inv_app, ‚Üê Functor.comp_map,\n    (shiftFunctorCompIsoId C _ _ (neg_add_cancel a)).hom.naturality_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointCommShift_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : G.CommShift A\na : A\n‚ä¢ Eq (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a)","decl":"open LeftAdjointCommShift in\n/--\nGiven an adjunction `F ‚ä£ G` and a `CommShift` structure on `G`, this constructs\nthe unique compatible `CommShift` structure on `F`.\n-/\n@[simps]\nnoncomputable def leftAdjointCommShift [G.CommShift A] : F.CommShift A where\n  iso a := iso adj a\n  zero := by\n    refine CommShift.compatibilityUnit_unique_left adj _ _ (G.commShiftIso 0)\n      (compatibilityUnit_iso adj 0) ?_\n    rw [G.commShiftIso_zero]\n    exact CommShift.compatibilityUnit_isoZero adj\n  add a b := by\n    refine CommShift.compatibilityUnit_unique_left adj _ _ (G.commShiftIso (a + b))\n      (compatibilityUnit_iso adj (a + b)) ?_\n    rw [G.commShiftIso_add]\n    exact CommShift.compatibilityUnit_isoAdd adj _ _ _ _\n      (compatibilityUnit_iso adj a) (compatibilityUnit_iso adj b)\n\n"}
{"name":"CategoryTheory.Adjunction.commShift_of_rightAdjoint","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : G.CommShift A\n‚ä¢ adj.CommShift A","decl":"lemma commShift_of_rightAdjoint [G.CommShift A] :\n    letI := adj.leftAdjointCommShift A\n    adj.CommShift A := by\n  letI := adj.leftAdjointCommShift A\n  refine CommShift.mk' _ _ ‚ü®fun a ‚Ü¶ ?_‚ü©\n  ext X\n  dsimp\n  simpa only [Functor.commShiftIso_id_hom_app, Functor.comp_obj, Functor.id_obj, id_comp,\n    Functor.commShiftIso_comp_hom_app] using LeftAdjointCommShift.compatibilityUnit_iso adj a X\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instCommShiftHomFunctorUnitIso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : E.functor.CommShift A\ninst‚úù¬π : E.inverse.CommShift A\ninst‚úù : E.CommShift A\n‚ä¢ CategoryTheory.NatTrans.CommShift E.unitIso.hom A","decl":"instance [E.CommShift A] : NatTrans.CommShift E.unitIso.hom A :=\n  inferInstanceAs (NatTrans.CommShift E.toAdjunction.unit A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instCommShiftHomFunctorCounitIso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : E.functor.CommShift A\ninst‚úù¬π : E.inverse.CommShift A\ninst‚úù : E.CommShift A\n‚ä¢ CategoryTheory.NatTrans.CommShift E.counitIso.hom A","decl":"instance [E.CommShift A] : NatTrans.CommShift E.counitIso.hom A :=\n  inferInstanceAs (NatTrans.CommShift E.toAdjunction.counit A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.mk'","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Å¥ : AddMonoid A\ninst‚úù¬≥ : CategoryTheory.HasShift C A\ninst‚úù¬≤ : CategoryTheory.HasShift D A\ninst‚úù¬π : E.functor.CommShift A\ninst‚úù : E.inverse.CommShift A\nh : CategoryTheory.NatTrans.CommShift E.unitIso.hom A\n‚ä¢ E.CommShift A","decl":"/-- Constructor for `Equivalence.CommShift`. -/\nlemma mk' (h : NatTrans.CommShift E.unitIso.hom A) :\n    E.CommShift A where\n  commShift_unit := h\n  commShift_counit := (Adjunction.CommShift.mk' E.toAdjunction A h).commShift_counit\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instRefl","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_3\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\n‚ä¢ CategoryTheory.Equivalence.refl.CommShift A","decl":"/--\nThe identity equivalence is compatible with shifts.\n-/\ninstance : (Equivalence.refl (C := C)).CommShift A := by\n  dsimp [Equivalence.CommShift, refl_toAdjunction]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instSymm","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Åµ : AddMonoid A\ninst‚úù‚Å¥ : CategoryTheory.HasShift C A\ninst‚úù¬≥ : CategoryTheory.HasShift D A\ninst‚úù¬≤ : E.functor.CommShift A\ninst‚úù¬π : E.inverse.CommShift A\ninst‚úù : E.CommShift A\n‚ä¢ E.symm.CommShift A","decl":"/--\nIf an equivalence `E : C ‚âå D` is compatible with shifts, so is `E.symm`.\n-/\ninstance [E.CommShift A] : E.symm.CommShift A :=\n  mk' E.symm A (inferInstanceAs (NatTrans.CommShift E.counitIso.inv A))\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.mk''","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Å¥ : AddMonoid A\ninst‚úù¬≥ : CategoryTheory.HasShift C A\ninst‚úù¬≤ : CategoryTheory.HasShift D A\ninst‚úù¬π : E.functor.CommShift A\ninst‚úù : E.inverse.CommShift A\nh : CategoryTheory.NatTrans.CommShift E.counitIso.hom A\n‚ä¢ E.CommShift A","decl":"/-- Constructor for `Equivalence.CommShift`. -/\nlemma mk'' (h : NatTrans.CommShift E.counitIso.hom A) :\n    E.CommShift A :=\n  have := mk' E.symm A (inferInstanceAs (NatTrans.CommShift E.counitIso.inv A))\n  inferInstanceAs (E.symm.symm.CommShift A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instTrans","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π‚Å∞ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Åπ : CategoryTheory.Category.{u_7, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù‚Å∏ : AddMonoid A\ninst‚úù‚Å∑ : CategoryTheory.HasShift C A\ninst‚úù‚Å∂ : CategoryTheory.HasShift D A\ninst‚úù‚Åµ : E.functor.CommShift A\ninst‚úù‚Å¥ : E.inverse.CommShift A\nF : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} F\ninst‚úù¬≤ : CategoryTheory.HasShift F A\nE' : CategoryTheory.Equivalence D F\ninst‚úù¬π : E'.functor.CommShift A\ninst‚úù : E'.inverse.CommShift A\n‚ä¢ (E.trans E').CommShift A","decl":"/--\nIf equivalences `E : C ‚âå D` and `E' : D ‚âå F` are compatible with shifts, so is `E.trans E'`.\n-/\ninstance : (E.trans E').CommShift A :=\n  inferInstanceAs ((E.toAdjunction.comp E'.toAdjunction).CommShift A)\n\n"}
{"name":"CategoryTheory.Equivalence.commShift_of_functor","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : E.functor.CommShift A\n‚ä¢ E.CommShift A","decl":"lemma commShift_of_functor [E.functor.CommShift A] :\n    letI := E.commShiftInverse A\n    E.CommShift A := by\n  letI := E.commShiftInverse A\n  exact CommShift.mk' _ _ (E.toAdjunction.commShift_of_leftAdjoint A).commShift_unit\n\n"}
{"name":"CategoryTheory.Equivalence.commShift_of_inverse","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst‚úù¬≥ : AddGroup A\ninst‚úù¬≤ : CategoryTheory.HasShift C A\ninst‚úù¬π : CategoryTheory.HasShift D A\ninst‚úù : E.inverse.CommShift A\n‚ä¢ E.CommShift A","decl":"lemma commShift_of_inverse [E.inverse.CommShift A] :\n    letI := E.commShiftFunctor A\n    E.CommShift A := by\n  letI := E.commShiftFunctor A\n  have := E.symm.commShift_of_functor A\n  exact inferInstanceAs (E.symm.symm.CommShift A)\n\n"}
