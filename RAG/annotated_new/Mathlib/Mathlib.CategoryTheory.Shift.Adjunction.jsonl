{"name":"CategoryTheory.Adjunction.CommShift.compatibilityCounit_of_compatibilityUnit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂\n⊢ CategoryTheory.Adjunction.CommShift.CompatibilityCounit adj e₁ e₂","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a` in `A` and commutation isomorphisms\n`e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` and\n`e₂ : shiftFunctor D a ⋙ G ≅ G ⋙ shiftFunctor C a`, compatibility of `e₁` and `e₂` with the\nunit of the adjunction `adj` implies compatibility with the counit of `adj`.\n-/\nlemma compatibilityCounit_of_compatibilityUnit (h : CompatibilityUnit adj e₁ e₂) :\n    CompatibilityCounit adj e₁ e₂ := by\n  intro Y\n  have eq := h (G.obj Y)\n  simp only [← cancel_mono (e₂.inv.app _ ≫ G.map (e₁.inv.app _)),\n    assoc, Iso.hom_inv_id_app_assoc, comp_id, ← Functor.map_comp,\n    Iso.hom_inv_id_app, Functor.comp_obj, Functor.map_id] at eq\n  apply (adj.homEquiv _ _).injective\n  dsimp\n  rw [adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp, adj.unit_naturality_assoc, ← eq]\n  simp only [assoc, ← Functor.map_comp, Iso.inv_hom_id_app_assoc]\n  erw [← e₂.inv.naturality]\n  dsimp\n  simp only [right_triangle_components, ← Functor.map_comp_assoc, Functor.map_id, id_comp,\n    Iso.hom_inv_id_app, Functor.comp_obj]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_right","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂\nY : D\n⊢ Eq (e₂.inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map (e₁.hom.app (G.obj Y))) (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)))))","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a` in `A` and commutation isomorphisms\n`e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` and\n`e₂ : shiftFunctor D a ⋙ G ≅ G ⋙ shiftFunctor C a`, if `e₁` and `e₂` are compatible with the\nunit of the adjunction `adj`, then we get a formula for `e₂.inv` in terms of `e₁`.\n-/\nlemma compatibilityUnit_right (h : CompatibilityUnit adj e₁ e₂) (Y : D) :\n    e₂.inv.app Y = adj.unit.app _ ≫ G.map (e₁.hom.app _) ≫ G.map ((adj.counit.app _)⟦a⟧') := by\n  have := h (G.obj Y)\n  rw [← cancel_mono (e₂.inv.app _), assoc, assoc, Iso.hom_inv_id_app] at this\n  erw [comp_id] at this\n  rw [← assoc, ← this, assoc]; erw [← e₂.inv.naturality]\n  rw [← cancel_mono (e₂.hom.app _)]\n  simp only [Functor.comp_obj, Iso.inv_hom_id_app, Functor.id_obj, Functor.comp_map, assoc, comp_id,\n    ← (shiftFunctor C a).map_comp, right_triangle_components, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityCounit_left","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityCounit adj e₁ e₂\nX : C\n⊢ Eq (e₁.hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map (e₂.inv.app (F.obj X))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X)))))","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a` in `A` and commutation isomorphisms\n`e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` and\n`e₂ : shiftFunctor D a ⋙ G ≅ G ⋙ shiftFunctor C a`, if `e₁` and `e₂` are compatible with the\ncounit of the adjunction `adj`, then we get a formula for `e₁.hom` in terms of `e₂`.\n-/\nlemma compatibilityCounit_left (h : CompatibilityCounit adj e₁ e₂) (X : C) :\n    e₁.hom.app X = F.map ((adj.unit.app X)⟦a⟧') ≫ F.map (e₂.inv.app _) ≫ adj.counit.app _ := by\n  have := h (F.obj X)\n  rw [← cancel_epi (F.map (e₂.inv.app _)), ← assoc, ← F.map_comp, Iso.inv_hom_id_app, F.map_id,\n    id_comp] at this\n  rw [this]\n  erw [e₁.hom.naturality_assoc]\n  rw [Functor.comp_map, ← Functor.map_comp, left_triangle_components]\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_unique_right","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ e₂' : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂'\n⊢ Eq e₂ e₂'","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a` in `A` and commutation isomorphisms\n`e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` and\n`e₂ : shiftFunctor D a ⋙ G ≅ G ⋙ shiftFunctor C a`, if `e₁` and `e₂` are compatible with the\nunit of the adjunction `adj`, then `e₁` uniquely determines `e₂`.\n-/\nlemma compatibilityUnit_unique_right (h : CompatibilityUnit adj e₁ e₂)\n    (h' : CompatibilityUnit adj e₁ e₂') : e₂ = e₂' := by\n  rw [← Iso.symm_eq_iff]\n  ext\n  rw [Iso.symm_hom, Iso.symm_hom, compatibilityUnit_right adj e₁ e₂ h,\n    compatibilityUnit_right adj e₁ e₂' h']\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_unique_left","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\ne₁ e₁' : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁' e₂\n⊢ Eq e₁ e₁'","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a` in `A` and commutation isomorphisms\n`e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` and\n`e₂ : shiftFunctor D a ⋙ G ≅ G ⋙ shiftFunctor C a`, if `e₁` and `e₂` are compatible with the\nunit of the adjunction `adj`, then `e₂` uniquely determines `e₁`.\n-/\nlemma compatibilityUnit_unique_left (h : CompatibilityUnit adj e₁ e₂)\n    (h' : CompatibilityUnit adj e₁' e₂) : e₁ = e₁' := by\n  ext\n  rw [compatibilityCounit_left adj e₁ e₂ (compatibilityCounit_of_compatibilityUnit adj _ _ h),\n    compatibilityCounit_left adj e₁' e₂ (compatibilityCounit_of_compatibilityUnit adj _ _ h')]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_isoZero","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\n⊢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Functor.CommShift.isoZero F A) (CategoryTheory.Functor.CommShift.isoZero G A)","decl":"/--\nThe isomorphisms `Functor.CommShift.isoZero F` and `Functor.CommShift.isoZero G` are\ncompatible with the unit of an adjunction `F ⊣ G`.\n-/\nlemma compatibilityUnit_isoZero : CompatibilityUnit adj (Functor.CommShift.isoZero F A)\n    (Functor.CommShift.isoZero G A) := by\n  intro\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.CommShift.isoZero_hom_app,\n    Functor.map_comp, assoc, unit_naturality_assoc,\n    ← cancel_mono ((shiftFunctorZero C A).hom.app _), ← G.map_comp_assoc, Iso.inv_hom_id_app,\n    Functor.id_obj, Functor.map_id, id_comp, NatTrans.naturality, Functor.id_map, assoc, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.compatibilityUnit_isoAdd","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na b : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\nf₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D a).comp G) (G.comp (CategoryTheory.shiftFunctor C a))\nf₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor D b).comp G) (G.comp (CategoryTheory.shiftFunctor C b))\nh : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj e₁ e₂\nh' : CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj f₁ f₂\n⊢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Functor.CommShift.isoAdd e₁ f₁) (CategoryTheory.Functor.CommShift.isoAdd e₂ f₂)","decl":"/-- Given an adjunction `adj : F ⊣ G`, `a, b` in `A` and commutation isomorphisms\nbetween shifts by `a` (resp. `b`) and `F` and `G`, if these commutation isomorphisms are\ncompatible with the unit of `adj`, then so are the commutation isomorphisms between shifts\nby `a + b` and `F` and `G` constructed by `Functor.CommShift.isoAdd`.\n-/\nlemma compatibilityUnit_isoAdd (h : CompatibilityUnit adj e₁ e₂)\n    (h' : CompatibilityUnit adj f₁ f₂) :\n    CompatibilityUnit adj (Functor.CommShift.isoAdd e₁ f₁) (Functor.CommShift.isoAdd e₂ f₂) := by\n  intro X\n  have := h' (X⟦a⟧)\n  simp only [← cancel_mono (f₂.inv.app _), assoc, Iso.hom_inv_id_app,\n    Functor.id_obj, Functor.comp_obj, comp_id] at this\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.CommShift.isoAdd_hom_app,\n    Functor.map_comp, assoc, unit_naturality_assoc]\n  slice_rhs 5 6 => rw [← G.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n  erw [f₂.hom.naturality_assoc]\n  rw [← reassoc_of% this, ← cancel_mono ((shiftFunctorAdd C a b).hom.app _),\n    assoc, assoc, assoc, assoc, assoc, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  dsimp\n  rw [← (shiftFunctor C b).map_comp_assoc, ← (shiftFunctor C b).map_comp_assoc,\n    assoc, ← h X, NatTrans.naturality]\n  dsimp\n  rw [comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.commShift_counit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\nself : adj.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift adj.counit A","decl":"/--\nThe property for `CommShift` structures on `F` and `G` to be compatible with an\nadjunction `F ⊣ G`.\n-/\nclass CommShift : Prop where\n  commShift_unit : NatTrans.CommShift adj.unit A := by infer_instance\n  commShift_counit : NatTrans.CommShift adj.counit A := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.commShift_unit","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\nself : adj.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift adj.unit A","decl":"/--\nThe property for `CommShift` structures on `F` and `G` to be compatible with an\nadjunction `F ⊣ G`.\n-/\nclass CommShift : Prop where\n  commShift_unit : NatTrans.CommShift adj.unit A := by infer_instance\n  commShift_counit : NatTrans.CommShift adj.counit A := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_commShiftIso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (((F.comp G).commShiftIso a).hom.app X)) ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))","decl":"@[reassoc (attr := simp)]\nlemma unit_app_commShiftIso_hom_app [adj.CommShift A] (a : A) (X : C) :\n    adj.unit.app (X⟦a⟧) ≫ ((F ⋙ G).commShiftIso a).hom.app X = (adj.unit.app X)⟦a⟧' := by\n  simpa using (NatTrans.shift_app_comm adj.unit a X).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_commShiftIso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj (F.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (((F.comp G).commShiftIso a).hom.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) h)","decl":"@[reassoc (attr := simp)]\nlemma unit_app_commShiftIso_hom_app [adj.CommShift A] (a : A) (X : C) :\n    adj.unit.app (X⟦a⟧) ≫ ((F ⋙ G).commShiftIso a).hom.app X = (adj.unit.app X)⟦a⟧' := by\n  simpa using (NatTrans.shift_app_comm adj.unit a X).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_shift_commShiftIso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (((F.comp G).commShiftIso a).inv.app X)) (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"@[reassoc (attr := simp)]\nlemma unit_app_shift_commShiftIso_inv_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)⟦a⟧' ≫ ((F ⋙ G).commShiftIso a).inv.app X = adj.unit.app (X⟦a⟧) := by\n  simp [← cancel_mono (((F ⋙ G).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_shift_commShiftIso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom (G.obj (F.obj ((CategoryTheory.shiftFunctor C a).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (CategoryTheory.CategoryStruct.comp (((F.comp G).commShiftIso a).inv.app X) h)) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) h)","decl":"@[reassoc (attr := simp)]\nlemma unit_app_shift_commShiftIso_inv_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)⟦a⟧' ≫ ((F ⋙ G).commShiftIso a).inv.app X = adj.unit.app (X⟦a⟧) := by\n  simp [← cancel_mono (((F ⋙ G).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_hom_app_counit_app_shift","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).hom.app Y) ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_app_counit_app_shift [adj.CommShift A] (a : A) (Y : D) :\n    ((G ⋙ F).commShiftIso a).hom.app Y ≫ (adj.counit.app Y)⟦a⟧' = adj.counit.app (Y⟦a⟧) := by\n  simpa using (NatTrans.shift_app_comm adj.counit a Y)\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_hom_app_counit_app_shift_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).hom.app Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h)) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_app_counit_app_shift [adj.CommShift A] (a : A) (Y : D) :\n    ((G ⋙ F).commShiftIso a).hom.app Y ≫ (adj.counit.app Y)⟦a⟧' = adj.counit.app (Y⟦a⟧) := by\n  simpa using (NatTrans.shift_app_comm adj.counit a Y)\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_inv_app_counit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).inv.app Y) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))) ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_app_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    ((G ⋙ F).commShiftIso a).inv.app Y ≫ adj.counit.app (Y⟦a⟧) = (adj.counit.app Y)⟦a⟧' := by\n  simp [← cancel_epi (((G ⋙ F).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftIso_inv_app_counit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((G.comp F).commShiftIso a).inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h)","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_app_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    ((G ⋙ F).commShiftIso a).inv.app Y ≫ adj.counit.app (Y⟦a⟧) = (adj.counit.app Y)⟦a⟧' := by\n  simp [← cancel_epi (((G ⋙ F).commShiftIso _).hom.app _)]\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.mk'","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\nh : CategoryTheory.NatTrans.CommShift adj.unit A\n⊢ adj.CommShift A","decl":"/-- Constructor for `Adjunction.CommShift`. -/\nlemma mk' (h : NatTrans.CommShift adj.unit A) :\n    adj.CommShift A where\n  commShift_counit := ⟨fun a ↦ by\n    ext\n    simp only [Functor.comp_obj, Functor.id_obj, NatTrans.comp_app,\n      Functor.commShiftIso_comp_hom_app, whiskerRight_app, assoc, whiskerLeft_app,\n      Functor.commShiftIso_id_hom_app, comp_id]\n    refine (compatibilityCounit_of_compatibilityUnit adj _ _ (fun X ↦ ?_) _).symm\n    simpa only [NatTrans.comp_app,\n      Functor.commShiftIso_id_hom_app, whiskerRight_app, id_comp,\n      Functor.commShiftIso_comp_hom_app] using congr_app (h.shift_comm a) X⟩\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.instId","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\n⊢ CategoryTheory.Adjunction.id.CommShift A","decl":"/-- The identity adjunction is compatible with the trivial `CommShift` structure on the\nidentity functor.\n-/\ninstance instId : (Adjunction.id (C := C)).CommShift A where\n  commShift_counit :=\n    inferInstanceAs (NatTrans.CommShift (𝟭 C).leftUnitor.hom A)\n  commShift_unit :=\n    inferInstanceAs (NatTrans.CommShift (𝟭 C).leftUnitor.inv A)\n\n"}
{"name":"CategoryTheory.Adjunction.CommShift.instComp","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁸ : AddMonoid A\ninst✝⁷ : CategoryTheory.HasShift C A\ninst✝⁶ : CategoryTheory.HasShift D A\ninst✝⁵ : F.CommShift A\ninst✝⁴ : G.CommShift A\nE : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_4} E\nF' : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E D\nadj' : CategoryTheory.Adjunction F' G'\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : F'.CommShift A\ninst✝ : G'.CommShift A\n⊢ (adj.comp adj').CommShift A","decl":"/-- Compatibility of `Adjunction.Commshift` with the composition of adjunctions.\n-/\ninstance instComp : (adj.comp adj').CommShift A where\n  commShift_counit := by\n    rw [comp_counit]\n    infer_instance\n  commShift_unit := by\n    rw [comp_unit]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.shift_unit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) ((G.commShiftIso a).hom.app (F.obj X))))","decl":"@[reassoc]\nlemma shift_unit_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)⟦a⟧' =\n      adj.unit.app (X⟦a⟧) ≫\n        G.map ((F.commShiftIso a).hom.app X) ≫\n          (G.commShiftIso a).hom.app (F.obj X) := by\n  simpa [Functor.commShiftIso_comp_hom_app] using NatTrans.shift_app_comm adj.unit a X\n\n"}
{"name":"CategoryTheory.Adjunction.shift_unit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj (F.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X)) h) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso a).hom.app (F.obj X)) h)))","decl":"@[reassoc]\nlemma shift_unit_app [adj.CommShift A] (a : A) (X : C) :\n    (adj.unit.app X)⟦a⟧' =\n      adj.unit.app (X⟦a⟧) ≫\n        G.map ((F.commShiftIso a).hom.app X) ≫\n          (G.commShiftIso a).hom.app (F.obj X) := by\n  simpa [Functor.commShiftIso_comp_hom_app] using NatTrans.shift_app_comm adj.unit a X\n\n"}
{"name":"CategoryTheory.Adjunction.shift_counit_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY Z : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) h) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (F.map ((G.commShiftIso a).inv.app Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y)) h)))","decl":"@[reassoc]\nlemma shift_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    (adj.counit.app Y)⟦a⟧' =\n      (F.commShiftIso a).inv.app (G.obj Y) ≫ F.map ((G.commShiftIso a).inv.app Y) ≫\n        adj.counit.app (Y⟦a⟧) := by\n  have eq := NatTrans.shift_app_comm adj.counit a Y\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.commShiftIso_comp_hom_app, assoc,\n    Functor.commShiftIso_id_hom_app, comp_id] at eq\n  simp only [← eq, Functor.comp_obj, Functor.id_obj, ← F.map_comp_assoc, Iso.inv_hom_id_app,\n    F.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.shift_counit_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : adj.CommShift A\na : A\nY : D\n⊢ Eq ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (F.map ((G.commShiftIso a).inv.app Y)) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj Y))))","decl":"@[reassoc]\nlemma shift_counit_app [adj.CommShift A] (a : A) (Y : D) :\n    (adj.counit.app Y)⟦a⟧' =\n      (F.commShiftIso a).inv.app (G.obj Y) ≫ F.map ((G.commShiftIso a).inv.app Y) ≫\n        adj.counit.app (Y⟦a⟧) := by\n  have eq := NatTrans.shift_app_comm adj.counit a Y\n  simp only [Functor.comp_obj, Functor.id_obj, Functor.commShiftIso_comp_hom_app, assoc,\n    Functor.commShiftIso_id_hom_app, comp_id] at eq\n  simp only [← eq, Functor.comp_obj, Functor.id_obj, ← F.map_comp_assoc, Iso.inv_hom_id_app,\n    F.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd b a) 0\ninst✝ : F.CommShift A\nX : D\n⊢ Eq ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C b a h).inv.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app ((CategoryTheory.shiftFunctor C b).obj (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((F.commShiftIso b).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctor D b).map (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj X))))) ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b ⋯).hom.app X)))))))","decl":"@[reassoc]\nlemma iso_hom_app (X : D) :\n    (iso adj a).hom.app X =\n      (shiftFunctorCompIsoId C b a h).inv.app (G.obj ((shiftFunctor D a).obj X)) ≫\n        (adj.unit.app ((shiftFunctor C b).obj (G.obj ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n          (G.map ((F.commShiftIso b).hom.app (G.obj ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n            (G.map ((shiftFunctor D b).map (adj.counit.app ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n              (G.map ((shiftFunctorCompIsoId D a b\n                (by rw [← add_left_inj a, add_assoc, h, zero_add, add_zero])).hom.app X))⟦a⟧' := by\n  obtain rfl : b = -a := by rw [← add_left_inj a, h, neg_add_cancel]\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh✝ : Eq (HAdd.hAdd b a) 0\ninst✝ : F.CommShift A\nX : D\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a).obj (G.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).hom.app X) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C b a h✝).inv.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (adj.unit.app ((CategoryTheory.shiftFunctor C b).obj (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((F.commShiftIso b).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctor D b).map (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj X))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b ⋯).hom.app X))) h)))))","decl":"@[reassoc]\nlemma iso_hom_app (X : D) :\n    (iso adj a).hom.app X =\n      (shiftFunctorCompIsoId C b a h).inv.app (G.obj ((shiftFunctor D a).obj X)) ≫\n        (adj.unit.app ((shiftFunctor C b).obj (G.obj ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n          (G.map ((F.commShiftIso b).hom.app (G.obj ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n            (G.map ((shiftFunctor D b).map (adj.counit.app ((shiftFunctor D a).obj X))))⟦a⟧' ≫\n              (G.map ((shiftFunctorCompIsoId D a b\n                (by rw [← add_left_inj a, add_assoc, h, zero_add, add_zero])).hom.app X))⟦a⟧' := by\n  obtain rfl : b = -a := by rw [← add_left_inj a, h, neg_add_cancel]\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh✝ : Eq (HAdd.hAdd b a) 0\ninst✝ : F.CommShift A\nY : D\nZ : C\nh : Quiver.Hom (G.obj ((CategoryTheory.shiftFunctor D a).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).inv.app Y) h) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctorCompIsoId D b a h✝).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctorCompIsoId D a b ⋯).hom.app (F.obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y))) h)))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : D) :\n    (iso adj a).inv.app Y =\n      adj.unit.app ((shiftFunctor C a).obj (G.obj Y)) ≫\n          G.map ((shiftFunctorCompIsoId D b a h).inv.app\n              (F.obj ((shiftFunctor C a).obj (G.obj Y)))) ≫\n            G.map ((shiftFunctor D a).map ((shiftFunctor D b).map\n                ((F.commShiftIso a).hom.app (G.obj Y)))) ≫\n              G.map ((shiftFunctor D a).map ((shiftFunctorCompIsoId D a b\n                  (by rw [eq_neg_of_add_eq_zero_left h, add_neg_cancel])).hom.app\n                    (F.obj (G.obj Y)))) ≫\n                G.map ((shiftFunctor D a).map (adj.counit.app Y)) := by\n  obtain rfl : b = -a := by rw [← add_left_inj a, h, neg_add_cancel]\n  simp only [iso, iso', shiftEquiv', Equiv.toFun_as_coe, conjugateIsoEquiv_apply_inv,\n    conjugateEquiv_apply_app, Functor.comp_obj, comp_unit_app, Functor.id_obj,\n    Equivalence.toAdjunction_unit, Equivalence.Equivalence_mk'_unit, Iso.symm_hom, Functor.comp_map,\n    comp_counit_app, Equivalence.toAdjunction_counit, Equivalence.Equivalence_mk'_counit,\n    Functor.map_shiftFunctorCompIsoId_hom_app, assoc, Functor.map_comp]\n  slice_lhs 3 4 => rw [← Functor.map_comp, ← Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd b a) 0\ninst✝ : F.CommShift A\nY : D\n⊢ Eq ((CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a).inv.app Y) (CategoryTheory.CategoryStruct.comp (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctorCompIsoId D b a h).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app (G.obj Y))))) (CategoryTheory.CategoryStruct.comp (G.map ((CategoryTheory.shiftFunctor D a).map ((CategoryTheory.shiftFunctorCompIsoId D a b ⋯).hom.app (F.obj (G.obj Y))))) (G.map ((CategoryTheory.shiftFunctor D a).map (adj.counit.app Y)))))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : D) :\n    (iso adj a).inv.app Y =\n      adj.unit.app ((shiftFunctor C a).obj (G.obj Y)) ≫\n          G.map ((shiftFunctorCompIsoId D b a h).inv.app\n              (F.obj ((shiftFunctor C a).obj (G.obj Y)))) ≫\n            G.map ((shiftFunctor D a).map ((shiftFunctor D b).map\n                ((F.commShiftIso a).hom.app (G.obj Y)))) ≫\n              G.map ((shiftFunctor D a).map ((shiftFunctorCompIsoId D a b\n                  (by rw [eq_neg_of_add_eq_zero_left h, add_neg_cancel])).hom.app\n                    (F.obj (G.obj Y)))) ≫\n                G.map ((shiftFunctor D a).map (adj.counit.app Y)) := by\n  obtain rfl : b = -a := by rw [← add_left_inj a, h, neg_add_cancel]\n  simp only [iso, iso', shiftEquiv', Equiv.toFun_as_coe, conjugateIsoEquiv_apply_inv,\n    conjugateEquiv_apply_app, Functor.comp_obj, comp_unit_app, Functor.id_obj,\n    Equivalence.toAdjunction_unit, Equivalence.Equivalence_mk'_unit, Iso.symm_hom, Functor.comp_map,\n    comp_counit_app, Equivalence.toAdjunction_counit, Equivalence.Equivalence_mk'_counit,\n    Functor.map_shiftFunctorCompIsoId_hom_app, assoc, Functor.map_comp]\n  slice_lhs 3 4 => rw [← Functor.map_comp, ← Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp, assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.RightAdjointCommShift.compatibilityUnit_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\na : A\n⊢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (F.commShiftIso a) (CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a)","decl":"/--\nThe commutation isomorphisms of `Adjunction.RightAdjointCommShift.iso` are compatible with\nthe unit of the adjunction.\n-/\nlemma compatibilityUnit_iso (a : A) :\n    CommShift.CompatibilityUnit adj (F.commShiftIso a) (iso adj a) := by\n  intro\n  rw [← cancel_mono ((RightAdjointCommShift.iso adj a).inv.app _), assoc, assoc,\n    Iso.hom_inv_id_app, RightAdjointCommShift.iso_inv_app adj _ _ (neg_add_cancel a)]\n  apply (adj.homEquiv _ _).symm.injective\n  dsimp\n  simp only [comp_id, homEquiv_counit, Functor.map_comp, assoc, counit_naturality,\n    counit_naturality_assoc, left_triangle_components_assoc]\n  erw [← NatTrans.naturality_assoc]\n  dsimp\n  rw [shift_shiftFunctorCompIsoId_hom_app, Iso.inv_hom_id_app_assoc,\n    Functor.commShiftIso_hom_naturality_assoc, ← Functor.map_comp,\n    left_triangle_components, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointCommShift_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\na : A\n⊢ Eq (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Adjunction.RightAdjointCommShift.iso adj a)","decl":"open RightAdjointCommShift in\n/--\nGiven an adjunction `F ⊣ G` and a `CommShift` structure on `F`, this constructs\nthe unique compatible `CommShift` structure on `G`.\n-/\n@[simps]\nnoncomputable def rightAdjointCommShift [F.CommShift A] : G.CommShift A where\n  iso a := iso adj a\n  zero := by\n    refine CommShift.compatibilityUnit_unique_right adj (F.commShiftIso 0) _ _\n      (compatibilityUnit_iso adj 0) ?_\n    rw [F.commShiftIso_zero]\n    exact CommShift.compatibilityUnit_isoZero adj\n  add a b := by\n    refine CommShift.compatibilityUnit_unique_right adj (F.commShiftIso (a + b)) _ _\n      (compatibilityUnit_iso adj (a + b)) ?_\n    rw [F.commShiftIso_add]\n    exact CommShift.compatibilityUnit_isoAdd adj _ _ _ _\n      (compatibilityUnit_iso adj a) (compatibilityUnit_iso adj b)\n\n"}
{"name":"CategoryTheory.Adjunction.commShift_of_leftAdjoint","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\n⊢ adj.CommShift A","decl":"lemma commShift_of_leftAdjoint [F.CommShift A] :\n    letI := adj.rightAdjointCommShift A\n    adj.CommShift A := by\n  letI := adj.rightAdjointCommShift A\n  refine CommShift.mk' _ _ ⟨fun a ↦ ?_⟩\n  ext X\n  dsimp\n  simpa only [Functor.commShiftIso_id_hom_app, Functor.comp_obj, Functor.id_obj, id_comp,\n    Functor.commShiftIso_comp_hom_app] using RightAdjointCommShift.compatibilityUnit_iso adj a X\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh✝ : Eq (HAdd.hAdd a b) 0\ninst✝ : G.CommShift A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).hom.app X) h) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b h✝).inv.app (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map ((G.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C b a ⋯).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))) h)))))","decl":"@[reassoc]\nlemma iso_hom_app (X : C) :\n    (iso adj a).hom.app X = F.map ((adj.unit.app X)⟦a⟧') ≫\n      F.map (G.map (((shiftFunctorCompIsoId D a b h).inv.app (F.obj X)))⟦a⟧') ≫\n        F.map (((G.commShiftIso b).hom.app ((F.obj X)⟦a⟧))⟦a⟧') ≫\n          F.map ((shiftFunctorCompIsoId C b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (G.obj ((F.obj X)⟦a⟧))) ≫ adj.counit.app ((F.obj X)⟦a⟧) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd a b) 0\ninst✝ : G.CommShift A\nX : C\n⊢ Eq ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (adj.unit.app X))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map (G.map ((CategoryTheory.shiftFunctorCompIsoId D a b h).inv.app (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map ((G.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C b a ⋯).hom.app (G.obj ((CategoryTheory.shiftFunctor D a).obj (F.obj X))))) (adj.counit.app ((CategoryTheory.shiftFunctor D a).obj (F.obj X)))))))","decl":"@[reassoc]\nlemma iso_hom_app (X : C) :\n    (iso adj a).hom.app X = F.map ((adj.unit.app X)⟦a⟧') ≫\n      F.map (G.map (((shiftFunctorCompIsoId D a b h).inv.app (F.obj X)))⟦a⟧') ≫\n        F.map (((G.commShiftIso b).hom.app ((F.obj X)⟦a⟧))⟦a⟧') ≫\n          F.map ((shiftFunctorCompIsoId C b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (G.obj ((F.obj X)⟦a⟧))) ≫ adj.counit.app ((F.obj X)⟦a⟧) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh : Eq (HAdd.hAdd a b) 0\ninst✝ : G.CommShift A\nY : C\n⊢ Eq ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).inv.app Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).inv.app Y))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctor C b).map (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((G.commShiftIso b).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app ((CategoryTheory.shiftFunctor D b).obj (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) ((CategoryTheory.shiftFunctorCompIsoId D b a ⋯).hom.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)))))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : C) :\n    (iso adj a).inv.app Y = (F.map ((shiftFunctorCompIsoId C a b h).inv.app Y))⟦a⟧' ≫\n      (F.map ((adj.unit.app (Y⟦a⟧))⟦b⟧'))⟦a⟧' ≫ (F.map ((G.commShiftIso b).inv.app\n        (F.obj (Y⟦a⟧))))⟦a⟧' ≫ (adj.counit.app ((F.obj (Y⟦a⟧))⟦b⟧))⟦a⟧' ≫\n          (shiftFunctorCompIsoId D b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (F.obj (Y⟦a⟧)) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.iso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\na b : A\nh✝ : Eq (HAdd.hAdd a b) 0\ninst✝ : G.CommShift A\nY : C\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a).inv.app Y) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h✝).inv.app Y))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((CategoryTheory.shiftFunctor C b).map (adj.unit.app ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map ((G.commShiftIso b).inv.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (adj.counit.app ((CategoryTheory.shiftFunctor D b).obj (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D b a ⋯).hom.app (F.obj ((CategoryTheory.shiftFunctor C a).obj Y))) h)))))","decl":"@[reassoc]\nlemma iso_inv_app (Y : C) :\n    (iso adj a).inv.app Y = (F.map ((shiftFunctorCompIsoId C a b h).inv.app Y))⟦a⟧' ≫\n      (F.map ((adj.unit.app (Y⟦a⟧))⟦b⟧'))⟦a⟧' ≫ (F.map ((G.commShiftIso b).inv.app\n        (F.obj (Y⟦a⟧))))⟦a⟧' ≫ (adj.counit.app ((F.obj (Y⟦a⟧))⟦b⟧))⟦a⟧' ≫\n          (shiftFunctorCompIsoId D b a (by simp [eq_neg_of_add_eq_zero_left h])).hom.app\n            (F.obj (Y⟦a⟧)) := by\n  obtain rfl : b = -a := eq_neg_of_add_eq_zero_right h\n  simp [iso, iso', shiftEquiv']\n\n"}
{"name":"CategoryTheory.Adjunction.LeftAdjointCommShift.compatibilityUnit_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : G.CommShift A\na : A\n⊢ CategoryTheory.Adjunction.CommShift.CompatibilityUnit adj (CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a) (G.commShiftIso a)","decl":"/--\nThe commutation isomorphisms of `Adjunction.LeftAdjointCommShift.iso` are compatible with\nthe unit of the adjunction.\n-/\nlemma compatibilityUnit_iso (a : A) :\n    CommShift.CompatibilityUnit adj (iso adj a) (G.commShiftIso a) := by\n  intro\n  rw [LeftAdjointCommShift.iso_hom_app adj _ _ (add_neg_cancel a)]\n  simp only [Functor.id_obj, Functor.comp_obj, Functor.map_shiftFunctorCompIsoId_inv_app,\n    Functor.map_comp, assoc, unit_naturality_assoc, right_triangle_components_assoc]\n  slice_rhs 4 5 => rw [← Functor.map_comp, Iso.inv_hom_id_app]\n  simp only [Functor.comp_obj, Functor.map_id, id_comp]\n  rw [shift_shiftFunctorCompIsoId_inv_app, ← Functor.comp_map,\n    (shiftFunctorCompIsoId C _ _ (neg_add_cancel a)).hom.naturality_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointCommShift_iso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : G.CommShift A\na : A\n⊢ Eq (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Adjunction.LeftAdjointCommShift.iso adj a)","decl":"open LeftAdjointCommShift in\n/--\nGiven an adjunction `F ⊣ G` and a `CommShift` structure on `G`, this constructs\nthe unique compatible `CommShift` structure on `F`.\n-/\n@[simps]\nnoncomputable def leftAdjointCommShift [G.CommShift A] : F.CommShift A where\n  iso a := iso adj a\n  zero := by\n    refine CommShift.compatibilityUnit_unique_left adj _ _ (G.commShiftIso 0)\n      (compatibilityUnit_iso adj 0) ?_\n    rw [G.commShiftIso_zero]\n    exact CommShift.compatibilityUnit_isoZero adj\n  add a b := by\n    refine CommShift.compatibilityUnit_unique_left adj _ _ (G.commShiftIso (a + b))\n      (compatibilityUnit_iso adj (a + b)) ?_\n    rw [G.commShiftIso_add]\n    exact CommShift.compatibilityUnit_isoAdd adj _ _ _ _\n      (compatibilityUnit_iso adj a) (compatibilityUnit_iso adj b)\n\n"}
{"name":"CategoryTheory.Adjunction.commShift_of_rightAdjoint","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : G.CommShift A\n⊢ adj.CommShift A","decl":"lemma commShift_of_rightAdjoint [G.CommShift A] :\n    letI := adj.leftAdjointCommShift A\n    adj.CommShift A := by\n  letI := adj.leftAdjointCommShift A\n  refine CommShift.mk' _ _ ⟨fun a ↦ ?_⟩\n  ext X\n  dsimp\n  simpa only [Functor.commShiftIso_id_hom_app, Functor.comp_obj, Functor.id_obj, id_comp,\n    Functor.commShiftIso_comp_hom_app] using LeftAdjointCommShift.compatibilityUnit_iso adj a X\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instCommShiftHomFunctorUnitIso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : E.functor.CommShift A\ninst✝¹ : E.inverse.CommShift A\ninst✝ : E.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift E.unitIso.hom A","decl":"instance [E.CommShift A] : NatTrans.CommShift E.unitIso.hom A :=\n  inferInstanceAs (NatTrans.CommShift E.toAdjunction.unit A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instCommShiftHomFunctorCounitIso","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : E.functor.CommShift A\ninst✝¹ : E.inverse.CommShift A\ninst✝ : E.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift E.counitIso.hom A","decl":"instance [E.CommShift A] : NatTrans.CommShift E.counitIso.hom A :=\n  inferInstanceAs (NatTrans.CommShift E.toAdjunction.counit A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.mk'","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : E.functor.CommShift A\ninst✝ : E.inverse.CommShift A\nh : CategoryTheory.NatTrans.CommShift E.unitIso.hom A\n⊢ E.CommShift A","decl":"/-- Constructor for `Equivalence.CommShift`. -/\nlemma mk' (h : NatTrans.CommShift E.unitIso.hom A) :\n    E.CommShift A where\n  commShift_unit := h\n  commShift_counit := (Adjunction.CommShift.mk' E.toAdjunction A h).commShift_counit\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instRefl","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\n⊢ CategoryTheory.Equivalence.refl.CommShift A","decl":"/--\nThe identity equivalence is compatible with shifts.\n-/\ninstance : (Equivalence.refl (C := C)).CommShift A := by\n  dsimp [Equivalence.CommShift, refl_toAdjunction]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instSymm","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : E.functor.CommShift A\ninst✝¹ : E.inverse.CommShift A\ninst✝ : E.CommShift A\n⊢ E.symm.CommShift A","decl":"/--\nIf an equivalence `E : C ≌ D` is compatible with shifts, so is `E.symm`.\n-/\ninstance [E.CommShift A] : E.symm.CommShift A :=\n  mk' E.symm A (inferInstanceAs (NatTrans.CommShift E.counitIso.inv A))\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.mk''","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : E.functor.CommShift A\ninst✝ : E.inverse.CommShift A\nh : CategoryTheory.NatTrans.CommShift E.counitIso.hom A\n⊢ E.CommShift A","decl":"/-- Constructor for `Equivalence.CommShift`. -/\nlemma mk'' (h : NatTrans.CommShift E.counitIso.hom A) :\n    E.CommShift A :=\n  have := mk' E.symm A (inferInstanceAs (NatTrans.CommShift E.counitIso.inv A))\n  inferInstanceAs (E.symm.symm.CommShift A)\n\n"}
{"name":"CategoryTheory.Equivalence.CommShift.instTrans","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_7, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝⁸ : AddMonoid A\ninst✝⁷ : CategoryTheory.HasShift C A\ninst✝⁶ : CategoryTheory.HasShift D A\ninst✝⁵ : E.functor.CommShift A\ninst✝⁴ : E.inverse.CommShift A\nF : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_4} F\ninst✝² : CategoryTheory.HasShift F A\nE' : CategoryTheory.Equivalence D F\ninst✝¹ : E'.functor.CommShift A\ninst✝ : E'.inverse.CommShift A\n⊢ (E.trans E').CommShift A","decl":"/--\nIf equivalences `E : C ≌ D` and `E' : D ≌ F` are compatible with shifts, so is `E.trans E'`.\n-/\ninstance : (E.trans E').CommShift A :=\n  inferInstanceAs ((E.toAdjunction.comp E'.toAdjunction).CommShift A)\n\n"}
{"name":"CategoryTheory.Equivalence.commShift_of_functor","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : E.functor.CommShift A\n⊢ E.CommShift A","decl":"lemma commShift_of_functor [E.functor.CommShift A] :\n    letI := E.commShiftInverse A\n    E.CommShift A := by\n  letI := E.commShiftInverse A\n  exact CommShift.mk' _ _ (E.toAdjunction.commShift_of_leftAdjoint A).commShift_unit\n\n"}
{"name":"CategoryTheory.Equivalence.commShift_of_inverse","module":"Mathlib.CategoryTheory.Shift.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\nE : CategoryTheory.Equivalence C D\nA : Type u_3\ninst✝³ : AddGroup A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : E.inverse.CommShift A\n⊢ E.CommShift A","decl":"lemma commShift_of_inverse [E.inverse.CommShift A] :\n    letI := E.commShiftFunctor A\n    E.CommShift A := by\n  letI := E.commShiftFunctor A\n  have := E.symm.commShift_of_functor A\n  exact inferInstanceAs (E.symm.symm.CommShift A)\n\n"}
