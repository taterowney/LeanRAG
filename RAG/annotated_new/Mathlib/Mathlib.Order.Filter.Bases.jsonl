{"name":"FilterBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_6\nself : FilterBasis Î±\nâŠ¢ self.sets.Nonempty","decl":"/-- A filter basis `B` on a type `Î±` is a nonempty collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (Î± : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set Î±)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y\n\n"}
{"name":"FilterBasis.inter_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_6\nself : FilterBasis Î±\nx y : Set Î±\naâœÂ¹ : Membership.mem self.sets x\naâœ : Membership.mem self.sets y\nâŠ¢ Exists fun z => And (Membership.mem self.sets z) (HasSubset.Subset z (Inter.inter x y))","decl":"/-- A filter basis `B` on a type `Î±` is a nonempty collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (Î± : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set Î±)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y\n\n"}
{"name":"FilterBasis.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_6\ninstâœ : SizeOf Î±\nsets : Set (Set Î±)\nnonempty : sets.Nonempty\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\nâŠ¢ Eq (SizeOf.sizeOf { sets := sets, nonempty := nonempty, inter_sets := inter_sets }) (HAdd.hAdd 1 (SizeOf.sizeOf nonempty))","decl":"/-- A filter basis `B` on a type `Î±` is a nonempty collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (Î± : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set Î±)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y\n\n"}
{"name":"FilterBasis.mk.inj","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_6\nsetsâœ : Set (Set Î±)\nnonemptyâœ : setsâœ.Nonempty\ninter_setsâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ Membership.mem setsâœ y â†’ Exists fun z => And (Membership.mem setsâœ z) (HasSubset.Subset z (Inter.inter x y))\nsets : Set (Set Î±)\nnonempty : sets.Nonempty\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\nxâœ : Eq { sets := setsâœ, nonempty := nonemptyâœ, inter_sets := inter_setsâœ } { sets := sets, nonempty := nonempty, inter_sets := inter_sets }\nâŠ¢ Eq setsâœ sets","decl":"/-- A filter basis `B` on a type `Î±` is a nonempty collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (Î± : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set Î±)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y\n\n"}
{"name":"FilterBasis.mk.injEq","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_6\nsetsâœ : Set (Set Î±)\nnonemptyâœ : setsâœ.Nonempty\ninter_setsâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ Membership.mem setsâœ y â†’ Exists fun z => And (Membership.mem setsâœ z) (HasSubset.Subset z (Inter.inter x y))\nsets : Set (Set Î±)\nnonempty : sets.Nonempty\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\nâŠ¢ Eq (Eq { sets := setsâœ, nonempty := nonemptyâœ, inter_sets := inter_setsâœ } { sets := sets, nonempty := nonempty, inter_sets := inter_sets }) (Eq setsâœ sets)","decl":"/-- A filter basis `B` on a type `Î±` is a nonempty collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (Î± : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set Î±)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y\n\n"}
{"name":"FilterBasis.nonempty_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nâŠ¢ Nonempty â†‘B.sets","decl":"instance FilterBasis.nonempty_sets (B : FilterBasis Î±) : Nonempty B.sets :=\n  B.nonempty.to_subtype\n\n-- Porting note: this instance was reducible but it doesn't work the same way in Lean 4\n"}
{"name":"FilterBasis.mem_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set Î±\nB : FilterBasis Î±\nâŠ¢ Iff (Membership.mem B.sets s) (Membership.mem B s)","decl":"@[simp] theorem FilterBasis.mem_sets {s : Set Î±} {B : FilterBasis Î±} : s âˆˆ B.sets â†” s âˆˆ B := Iff.rfl\n\n-- For illustration purposes, the filter basis defining `(atTop : Filter â„•)`\n"}
{"name":"Filter.IsBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : Filter.IsBasis p s\nâŠ¢ Exists fun i => p i","decl":"/-- `IsBasis p s` means the image of `s` bounded by `p` is a filter basis. -/\nstructure Filter.IsBasis (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) : Prop where\n  /-- There exists at least one `i` that satisfies `p`. -/\n  nonempty : âˆƒ i, p i\n  /-- `s` is directed downwards on `i` such that `p i`. -/\n  inter : âˆ€ {i j}, p i â†’ p j â†’ âˆƒ k, p k âˆ§ s k âŠ† s i âˆ© s j\n\n"}
{"name":"Filter.IsBasis.inter","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : Filter.IsBasis p s\ni j : Î¹\naâœÂ¹ : p i\naâœ : p j\nâŠ¢ Exists fun k => And (p k) (HasSubset.Subset (s k) (Inter.inter (s i) (s j)))","decl":"/-- `IsBasis p s` means the image of `s` bounded by `p` is a filter basis. -/\nstructure Filter.IsBasis (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) : Prop where\n  /-- There exists at least one `i` that satisfies `p`. -/\n  nonempty : âˆƒ i, p i\n  /-- `s` is directed downwards on `i` such that `p i`. -/\n  inter : âˆ€ {i j}, p i â†’ p j â†’ âˆƒ k, p k âˆ§ s k âŠ† s i âˆ© s j\n\n"}
{"name":"Filter.IsBasis.mem_filterBasis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : Filter.IsBasis p s\nU : Set Î±\nâŠ¢ Iff (Membership.mem h.filterBasis U) (Exists fun i => And (p i) (Eq (s i) U))","decl":"theorem mem_filterBasis_iff {U : Set Î±} : U âˆˆ h.filterBasis â†” âˆƒ i, p i âˆ§ s i = U :=\n  Iff.rfl\n\n"}
{"name":"FilterBasis.mem_filter_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nU : Set Î±\nâŠ¢ Iff (Membership.mem B.filter U) (Exists fun s => And (Membership.mem B s) (HasSubset.Subset s U))","decl":"theorem mem_filter_iff (B : FilterBasis Î±) {U : Set Î±} : U âˆˆ B.filter â†” âˆƒ s âˆˆ B, s âŠ† U :=\n  Iff.rfl\n\n"}
{"name":"FilterBasis.mem_filter_of_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nU : Set Î±\naâœ : Membership.mem B U\nâŠ¢ Membership.mem B.filter U","decl":"theorem mem_filter_of_mem (B : FilterBasis Î±) {U : Set Î±} : U âˆˆ B â†’ U âˆˆ B.filter := fun U_in =>\n  âŸ¨U, U_in, Subset.refl _âŸ©\n\n"}
{"name":"FilterBasis.eq_iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nâŠ¢ Eq B.filter (iInf fun s => Filter.principal â†‘s)","decl":"theorem eq_iInf_principal (B : FilterBasis Î±) : B.filter = â¨… s : B.sets, ð“Ÿ s := by\n  have : Directed (Â· â‰¥ Â·) fun s : B.sets => ð“Ÿ (s : Set Î±) := by\n    rintro âŸ¨U, U_inâŸ© âŸ¨V, V_inâŸ©\n    rcases B.inter_sets U_in V_in with âŸ¨W, W_in, W_subâŸ©\n    use âŸ¨W, W_inâŸ©\n    simp only [le_principal_iff, mem_principal, Subtype.coe_mk]\n    exact subset_inter_iff.mp W_sub\n  ext U\n  simp [mem_filter_iff, mem_iInf_of_directed this]\n\n"}
{"name":"FilterBasis.generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nâŠ¢ Eq (Filter.generate B.sets) B.filter","decl":"protected theorem generate (B : FilterBasis Î±) : generate B.sets = B.filter := by\n  apply le_antisymm\n  Â· intro U U_in\n    rcases B.mem_filter_iff.mp U_in with âŸ¨V, V_in, hâŸ©\n    exact GenerateSets.superset (GenerateSets.basic V_in) h\n  Â· rw [le_generate_iff]\n    apply mem_filter_of_mem\n\n"}
{"name":"Filter.IsBasis.mem_filter_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : Filter.IsBasis p s\nU : Set Î±\nâŠ¢ Iff (Membership.mem h.filter U) (Exists fun i => And (p i) (HasSubset.Subset (s i) U))","decl":"protected theorem mem_filter_iff (h : IsBasis p s) {U : Set Î±} :\n    U âˆˆ h.filter â†” âˆƒ i, p i âˆ§ s i âŠ† U := by\n  simp only [IsBasis.filter, FilterBasis.mem_filter_iff, mem_filterBasis_iff,\n    exists_exists_and_eq_and]\n\n"}
{"name":"Filter.IsBasis.filter_eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : Filter.IsBasis p s\nâŠ¢ Eq h.filter (Filter.generate (setOf fun U => Exists fun i => And (p i) (Eq (s i) U)))","decl":"theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | âˆƒ i, p i âˆ§ s i = U } := by\n  rw [IsBasis.filter, â† h.filterBasis.generate, IsBasis.filterBasis]\n\n"}
{"name":"Filter.HasBasis.mem_iff'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : l.HasBasis p s\nt : Set Î±\nâŠ¢ Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"/-- We say that a filter `l` has a basis `s : Î¹ â†’ Set Î±` bounded by `p : Î¹ â†’ Prop`,\nif `t âˆˆ l` if and only if `t` includes `s i` for some `i` such that `p i`. -/\nstructure HasBasis (l : Filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) : Prop where\n  /-- A set `t` belongs to a filter `l` iff it includes an element of the basis. -/\n  mem_iff' : âˆ€ t : Set Î±, t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t\n\n"}
{"name":"Filter.hasBasis_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set (Set Î±)\nâŠ¢ (Filter.generate s).HasBasis (fun t => And t.Finite (HasSubset.Subset t s)) fun t => t.sInter","decl":"theorem hasBasis_generate (s : Set (Set Î±)) :\n    (generate s).HasBasis (fun t => Set.Finite t âˆ§ t âŠ† s) fun t => â‹‚â‚€ t :=\n  âŸ¨fun U => by simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]âŸ©\n\n"}
{"name":"Filter.FilterBasis.ofSets_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set (Set Î±)\nâŠ¢ Eq (Filter.FilterBasis.ofSets s).sets (Set.image Set.sInter (setOf fun t => And t.Finite (HasSubset.Subset t s)))","decl":"lemma FilterBasis.ofSets_sets (s : Set (Set Î±)) :\n    (FilterBasis.ofSets s).sets = sInter '' { t | Set.Finite t âˆ§ t âŠ† s } :=\n  rfl\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.mem_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\nhl : l.HasBasis p s\nâŠ¢ Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"/-- Definition of `HasBasis` unfolded with implicit set argument. -/\ntheorem HasBasis.mem_iff (hl : l.HasBasis p s) : t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t :=\n  hl.mem_iff' t\n\n"}
{"name":"Filter.HasBasis.eq_of_same_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p s\nâŠ¢ Eq l l'","decl":"theorem HasBasis.eq_of_same_basis (hl : l.HasBasis p s) (hl' : l'.HasBasis p s) : l = l' := by\n  ext t\n  rw [hl.mem_iff, hl'.mem_iff]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.hasBasis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nâŠ¢ Iff (l.HasBasis p s) (âˆ€ (t : Set Î±), Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t)))","decl":"theorem hasBasis_iff : l.HasBasis p s â†” âˆ€ t, t âˆˆ l â†” âˆƒ i, p i âˆ§ s i âŠ† t :=\n  âŸ¨fun âŸ¨hâŸ© => h, fun h => âŸ¨hâŸ©âŸ©\n\n"}
{"name":"Filter.HasBasis.ex_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Exists fun i => p i","decl":"theorem HasBasis.ex_mem (h : l.HasBasis p s) : âˆƒ i, p i :=\n  (h.mem_iff.mp univ_mem).imp fun _ => And.left\n\n"}
{"name":"Filter.HasBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Nonempty Î¹","decl":"protected theorem HasBasis.nonempty (h : l.HasBasis p s) : Nonempty Î¹ :=\n  nonempty_of_exists h.ex_mem\n\n"}
{"name":"Filter.IsBasis.hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : Filter.IsBasis p s\nâŠ¢ h.filter.HasBasis p s","decl":"protected theorem IsBasis.hasBasis (h : IsBasis p s) : HasBasis h.filter p s :=\n  âŸ¨fun t => by simp only [h.mem_filter_iff, exists_prop]âŸ©\n\n"}
{"name":"Filter.HasBasis.mem_of_superset","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\ni : Î¹\nhl : l.HasBasis p s\nhi : p i\nht : HasSubset.Subset (s i) t\nâŠ¢ Membership.mem l t","decl":"protected theorem HasBasis.mem_of_superset (hl : l.HasBasis p s) (hi : p i) (ht : s i âŠ† t) :\n    t âˆˆ l :=\n  hl.mem_iff.2 âŸ¨i, hi, htâŸ©\n\n"}
{"name":"Filter.HasBasis.mem_of_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\ni : Î¹\nhl : l.HasBasis p s\nhi : p i\nâŠ¢ Membership.mem l (s i)","decl":"theorem HasBasis.mem_of_mem (hl : l.HasBasis p s) (hi : p i) : s i âˆˆ l :=\n  hl.mem_of_superset hi Subset.rfl\n\n"}
{"name":"Filter.HasBasis.property_index","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\nh : l.HasBasis p s\nht : Membership.mem l t\nâŠ¢ p â†‘(h.index t ht)","decl":"theorem HasBasis.property_index (h : l.HasBasis p s) (ht : t âˆˆ l) : p (h.index t ht) :=\n  (h.index t ht).2\n\n"}
{"name":"Filter.HasBasis.set_index_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\nh : l.HasBasis p s\nht : Membership.mem l t\nâŠ¢ Membership.mem l (s â†‘(h.index t ht))","decl":"theorem HasBasis.set_index_mem (h : l.HasBasis p s) (ht : t âˆˆ l) : s (h.index t ht) âˆˆ l :=\n  h.mem_of_mem <| h.property_index _\n\n"}
{"name":"Filter.HasBasis.set_index_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\nh : l.HasBasis p s\nht : Membership.mem l t\nâŠ¢ HasSubset.Subset (s â†‘(h.index t ht)) t","decl":"theorem HasBasis.set_index_subset (h : l.HasBasis p s) (ht : t âˆˆ l) : s (h.index t ht) âŠ† t :=\n  (h.mem_iff.1 ht).choose_spec.2\n\n"}
{"name":"Filter.HasBasis.isBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Filter.IsBasis p s","decl":"theorem HasBasis.isBasis (h : l.HasBasis p s) : IsBasis p s where\n  nonempty := h.ex_mem\n  inter hi hj := by\n    simpa only [h.mem_iff] using inter_mem (h.mem_of_mem hi) (h.mem_of_mem hj)\n\n"}
{"name":"Filter.HasBasis.filter_eq","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Eq â‹¯.filter l","decl":"theorem HasBasis.filter_eq (h : l.HasBasis p s) : h.isBasis.filter = l := by\n  ext U\n  simp [h.mem_iff, IsBasis.mem_filter_iff]\n\n"}
{"name":"Filter.HasBasis.eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Eq l (Filter.generate (setOf fun U => Exists fun i => And (p i) (Eq (s i) U)))","decl":"theorem HasBasis.eq_generate (h : l.HasBasis p s) : l = generate { U | âˆƒ i, p i âˆ§ s i = U } := by\n  rw [â† h.isBasis.filter_eq_generate, h.filter_eq]\n\n"}
{"name":"Filter.generate_eq_generate_inter","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set (Set Î±)\nâŠ¢ Eq (Filter.generate s) (Filter.generate (Set.image Set.sInter (setOf fun t => And t.Finite (HasSubset.Subset t s))))","decl":"theorem generate_eq_generate_inter (s : Set (Set Î±)) :\n    generate s = generate (sInter '' { t | Set.Finite t âˆ§ t âŠ† s }) := by\n  rw [â† FilterBasis.ofSets_sets, FilterBasis.generate, â† (hasBasis_generate s).filter_eq]; rfl\n\n"}
{"name":"Filter.ofSets_filter_eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set (Set Î±)\nâŠ¢ Eq (Filter.FilterBasis.ofSets s).filter (Filter.generate s)","decl":"theorem ofSets_filter_eq_generate (s : Set (Set Î±)) :\n    (FilterBasis.ofSets s).filter = generate s := by\n  rw [â† (FilterBasis.ofSets s).generate, FilterBasis.ofSets_sets, â† generate_eq_generate_inter]\n\n"}
{"name":"FilterBasis.hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nB : FilterBasis Î±\nâŠ¢ B.filter.HasBasis (fun s => Membership.mem B s) id","decl":"protected theorem _root_.FilterBasis.hasBasis (B : FilterBasis Î±) :\n    HasBasis B.filter (fun s : Set Î± => s âˆˆ B) id :=\n  âŸ¨fun _ => B.mem_filter_iffâŸ©\n\n"}
{"name":"Filter.HasBasis.to_hasBasis'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nh : âˆ€ (i : Î¹), p i â†’ Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : âˆ€ (i' : Î¹'), p' i' â†’ Membership.mem l (s' i')\nâŠ¢ l.HasBasis p' s'","decl":"theorem HasBasis.to_hasBasis' (hl : l.HasBasis p s) (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i)\n    (h' : âˆ€ i', p' i' â†’ s' i' âˆˆ l) : l.HasBasis p' s' := by\n  refine âŸ¨fun t => âŸ¨fun ht => ?_, fun âŸ¨i', hi', htâŸ© => mem_of_superset (h' i' hi') htâŸ©âŸ©\n  rcases hl.mem_iff.1 ht with âŸ¨i, hi, htâŸ©\n  rcases h i hi with âŸ¨i', hi', hs'sâŸ©\n  exact âŸ¨i', hi', hs's.trans htâŸ©\n\n"}
{"name":"Filter.HasBasis.to_hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nh : âˆ€ (i : Î¹), p i â†’ Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : âˆ€ (i' : Î¹'), p' i' â†’ Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i'))\nâŠ¢ l.HasBasis p' s'","decl":"theorem HasBasis.to_hasBasis (hl : l.HasBasis p s) (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i)\n    (h' : âˆ€ i', p' i' â†’ âˆƒ i, p i âˆ§ s i âŠ† s' i') : l.HasBasis p' s' :=\n  hl.to_hasBasis' h fun i' hi' =>\n    let âŸ¨i, hi, hss'âŸ© := h' i' hi'\n    hl.mem_iff.2 âŸ¨i, hi, hss'âŸ©\n\n"}
{"name":"Filter.HasBasis.congr","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\np' : Î¹ â†’ Prop\ns' : Î¹ â†’ Set Î±\nhp : âˆ€ (i : Î¹), Iff (p i) (p' i)\nhs : âˆ€ (i : Î¹), p i â†’ Eq (s i) (s' i)\nâŠ¢ l.HasBasis p' s'","decl":"protected lemma HasBasis.congr (hl : l.HasBasis p s) {p' s'} (hp : âˆ€ i, p i â†” p' i)\n    (hs : âˆ€ i, p i â†’ s i = s' i) : l.HasBasis p' s' :=\n  âŸ¨fun t â†¦ by simp only [hl.mem_iff, â† hp]; exact exists_congr fun i â†¦\n    and_congr_right fun hi â†¦ hs i hi â–¸ Iff.rflâŸ©\n\n"}
{"name":"Filter.HasBasis.to_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nt : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), p i â†’ HasSubset.Subset (t i) (s i)\nht : âˆ€ (i : Î¹), p i â†’ Membership.mem l (t i)\nâŠ¢ l.HasBasis p t","decl":"theorem HasBasis.to_subset (hl : l.HasBasis p s) {t : Î¹ â†’ Set Î±} (h : âˆ€ i, p i â†’ t i âŠ† s i)\n    (ht : âˆ€ i, p i â†’ t i âˆˆ l) : l.HasBasis p t :=\n  hl.to_hasBasis' (fun i hi => âŸ¨i, hi, h i hiâŸ©) ht\n\n"}
{"name":"Filter.HasBasis.eventually_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => q x) l) (Exists fun i => And (p i) (âˆ€ â¦ƒx : Î±â¦„, Membership.mem (s i) x â†’ q x))","decl":"theorem HasBasis.eventually_iff (hl : l.HasBasis p s) {q : Î± â†’ Prop} :\n    (âˆ€á¶  x in l, q x) â†” âˆƒ i, p i âˆ§ âˆ€ â¦ƒxâ¦„, x âˆˆ s i â†’ q x := by simpa using hl.mem_iff\n\n"}
{"name":"Filter.HasBasis.frequently_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => q x) l) (âˆ€ (i : Î¹), p i â†’ Exists fun x => And (Membership.mem (s i) x) (q x))","decl":"theorem HasBasis.frequently_iff (hl : l.HasBasis p s) {q : Î± â†’ Prop} :\n    (âˆƒá¶  x in l, q x) â†” âˆ€ i, p i â†’ âˆƒ x âˆˆ s i, q x := by\n  simp only [Filter.Frequently, hl.eventually_iff]; push_neg; rfl\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.exists_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nP : Set Î± â†’ Prop\nmono : âˆ€ â¦ƒs t : Set Î±â¦„, HasSubset.Subset s t â†’ P t â†’ P s\nâŠ¢ Iff (Exists fun s => And (Membership.mem l s) (P s)) (Exists fun i => And (p i) (P (s i)))","decl":"theorem HasBasis.exists_iff (hl : l.HasBasis p s) {P : Set Î± â†’ Prop}\n    (mono : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ P t â†’ P s) : (âˆƒ s âˆˆ l, P s) â†” âˆƒ i, p i âˆ§ P (s i) :=\n  âŸ¨fun âŸ¨_s, hs, hPâŸ© =>\n    let âŸ¨i, hi, hisâŸ© := hl.mem_iff.1 hs\n    âŸ¨i, hi, mono his hPâŸ©,\n    fun âŸ¨i, hi, hPâŸ© => âŸ¨s i, hl.mem_of_mem hi, hPâŸ©âŸ©\n\n"}
{"name":"Filter.HasBasis.forall_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nP : Set Î± â†’ Prop\nmono : âˆ€ â¦ƒs t : Set Î±â¦„, HasSubset.Subset s t â†’ P s â†’ P t\nâŠ¢ Iff (âˆ€ (s : Set Î±), Membership.mem l s â†’ P s) (âˆ€ (i : Î¹), p i â†’ P (s i))","decl":"theorem HasBasis.forall_iff (hl : l.HasBasis p s) {P : Set Î± â†’ Prop}\n    (mono : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ P s â†’ P t) : (âˆ€ s âˆˆ l, P s) â†” âˆ€ i, p i â†’ P (s i) :=\n  âŸ¨fun H i hi => H (s i) <| hl.mem_of_mem hi, fun H _s hs =>\n    let âŸ¨i, hi, hisâŸ© := hl.mem_iff.1 hs\n    mono his (H i hi)âŸ©\n\n"}
{"name":"Filter.HasBasis.neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nâŠ¢ Iff l.NeBot (âˆ€ {i : Î¹}, p i â†’ (s i).Nonempty)","decl":"protected theorem HasBasis.neBot_iff (hl : l.HasBasis p s) :\n    NeBot l â†” âˆ€ {i}, p i â†’ (s i).Nonempty :=\n  forall_mem_nonempty_iff_neBot.symm.trans <| hl.forall_iff fun _ _ => Nonempty.mono\n\n"}
{"name":"Filter.HasBasis.eq_bot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nâŠ¢ Iff (Eq l Bot.bot) (Exists fun i => And (p i) (Eq (s i) EmptyCollection.emptyCollection))","decl":"theorem HasBasis.eq_bot_iff (hl : l.HasBasis p s) : l = âŠ¥ â†” âˆƒ i, p i âˆ§ s i = âˆ… :=\n  not_iff_not.1 <| neBot_iff.symm.trans <|\n    hl.neBot_iff.trans <| by simp only [not_exists, not_and, nonempty_iff_ne_empty]\n\n"}
{"name":"Filter.generate_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns : Set (Set Î±)\nâŠ¢ Iff (Filter.generate s).NeBot (âˆ€ (t : Set (Set Î±)), HasSubset.Subset t s â†’ t.Finite â†’ t.sInter.Nonempty)","decl":"theorem generate_neBot_iff {s : Set (Set Î±)} :\n    NeBot (generate s) â†” âˆ€ t, t âŠ† s â†’ t.Finite â†’ (â‹‚â‚€ t).Nonempty :=\n  (hasBasis_generate s).neBot_iff.trans <| by simp only [â† and_imp, and_comm]\n\n"}
{"name":"Filter.basis_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl : Filter Î±\nâŠ¢ l.HasBasis (fun s => Membership.mem l s) id","decl":"theorem basis_sets (l : Filter Î±) : l.HasBasis (fun s : Set Î± => s âˆˆ l) id :=\n  âŸ¨fun _ => exists_mem_subset_iff.symmâŸ©\n\n"}
{"name":"Filter.asBasis_filter","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Eq f.asBasis.filter f","decl":"theorem asBasis_filter (f : Filter Î±) : f.asBasis.filter = f :=\n  Filter.ext fun _ => exists_mem_subset_iff\n\n"}
{"name":"Filter.hasBasis_self","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl : Filter Î±\nP : Set Î± â†’ Prop\nâŠ¢ Iff (l.HasBasis (fun s => And (Membership.mem l s) (P s)) id) (âˆ€ (t : Set Î±), Membership.mem l t â†’ Exists fun r => And (Membership.mem l r) (And (P r) (HasSubset.Subset r t)))","decl":"theorem hasBasis_self {l : Filter Î±} {P : Set Î± â†’ Prop} :\n    HasBasis l (fun s => s âˆˆ l âˆ§ P s) id â†” âˆ€ t âˆˆ l, âˆƒ r âˆˆ l, P r âˆ§ r âŠ† t := by\n  simp only [hasBasis_iff, id, and_assoc]\n  exact forall_congr' fun s =>\n    âŸ¨fun h => h.1, fun h => âŸ¨h, fun âŸ¨t, hl, _, htsâŸ© => mem_of_superset hl htsâŸ©âŸ©\n\n"}
{"name":"Filter.HasBasis.comp_surjective","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\ng : Î¹' â†’ Î¹\nhg : Function.Surjective g\nâŠ¢ l.HasBasis (Function.comp p g) (Function.comp s g)","decl":"theorem HasBasis.comp_surjective (h : l.HasBasis p s) {g : Î¹' â†’ Î¹} (hg : Function.Surjective g) :\n    l.HasBasis (p âˆ˜ g) (s âˆ˜ g) :=\n  âŸ¨fun _ => h.mem_iff.trans hg.existsâŸ©\n\n"}
{"name":"Filter.HasBasis.comp_equiv","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\ne : Equiv Î¹' Î¹\nâŠ¢ l.HasBasis (Function.comp p â‡‘e) (Function.comp s â‡‘e)","decl":"theorem HasBasis.comp_equiv (h : l.HasBasis p s) (e : Î¹' â‰ƒ Î¹) : l.HasBasis (p âˆ˜ e) (s âˆ˜ e) :=\n  h.comp_surjective e.surjective\n\n"}
{"name":"Filter.HasBasis.to_image_id'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ l.HasBasis (fun t => Exists fun i => And (p i) (Eq (s i) t)) id","decl":"theorem HasBasis.to_image_id' (h : l.HasBasis p s) : l.HasBasis (fun t â†¦ âˆƒ i, p i âˆ§ s i = t) id :=\n  âŸ¨fun _ â†¦ by simp [h.mem_iff]âŸ©\n\n"}
{"name":"Filter.HasBasis.to_image_id","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl : Filter Î±\nÎ¹ : Type u_6\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ l.HasBasis (fun x => Membership.mem (Set.image s (setOf fun i => p i)) x) id","decl":"theorem HasBasis.to_image_id {Î¹ : Type*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : l.HasBasis p s) :\n    l.HasBasis (Â· âˆˆ s '' {i | p i}) id :=\n  h.to_image_id'\n\n"}
{"name":"Filter.HasBasis.restrict","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nq : Î¹ â†’ Prop\nhq : âˆ€ (i : Î¹), p i â†’ Exists fun j => And (p j) (And (q j) (HasSubset.Subset (s j) (s i)))\nâŠ¢ l.HasBasis (fun i => And (p i) (q i)) s","decl":"/-- If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that\n`p j âˆ§ q j`, then `{s j | p j âˆ§ q j}` is a basis of `l`. -/\ntheorem HasBasis.restrict (h : l.HasBasis p s) {q : Î¹ â†’ Prop}\n    (hq : âˆ€ i, p i â†’ âˆƒ j, p j âˆ§ q j âˆ§ s j âŠ† s i) : l.HasBasis (fun i => p i âˆ§ q i) s := by\n  refine âŸ¨fun t => âŸ¨fun ht => ?_, fun âŸ¨i, hpi, htiâŸ© => h.mem_iff.2 âŸ¨i, hpi.1, htiâŸ©âŸ©âŸ©\n  rcases h.mem_iff.1 ht with âŸ¨i, hpi, htiâŸ©\n  rcases hq i hpi with âŸ¨j, hpj, hqj, hjiâŸ©\n  exact âŸ¨j, âŸ¨hpj, hqjâŸ©, hji.trans htiâŸ©\n\n"}
{"name":"Filter.HasBasis.restrict_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nV : Set Î±\nhV : Membership.mem l V\nâŠ¢ l.HasBasis (fun i => And (p i) (HasSubset.Subset (s i) V)) s","decl":"/-- If `{s i | p i}` is a basis of a filter `l` and `V âˆˆ l`, then `{s i | p i âˆ§ s i âŠ† V}`\nis a basis of `l`. -/\ntheorem HasBasis.restrict_subset (h : l.HasBasis p s) {V : Set Î±} (hV : V âˆˆ l) :\n    l.HasBasis (fun i => p i âˆ§ s i âŠ† V) s :=\n  h.restrict fun _i hi => (h.mem_iff.1 (inter_mem hV (h.mem_of_mem hi))).imp fun _j hj =>\n    âŸ¨hj.1, subset_inter_iff.1 hj.2âŸ©\n\n"}
{"name":"Filter.HasBasis.hasBasis_self_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Set Î± â†’ Prop\nh : l.HasBasis (fun s => And (Membership.mem l s) (p s)) id\nV : Set Î±\nhV : Membership.mem l V\nâŠ¢ l.HasBasis (fun s => And (Membership.mem l s) (And (p s) (HasSubset.Subset s V))) id","decl":"theorem HasBasis.hasBasis_self_subset {p : Set Î± â†’ Prop} (h : l.HasBasis (fun s => s âˆˆ l âˆ§ p s) id)\n    {V : Set Î±} (hV : V âˆˆ l) : l.HasBasis (fun s => s âˆˆ l âˆ§ p s âˆ§ s âŠ† V) id := by\n  simpa only [and_assoc] using h.restrict_subset hV\n\n"}
{"name":"Filter.HasBasis.ge_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹' : Sort u_5\nl l' : Filter Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl' : l'.HasBasis p' s'\nâŠ¢ Iff (LE.le l l') (âˆ€ (i' : Î¹'), p' i' â†’ Membership.mem l (s' i'))","decl":"theorem HasBasis.ge_iff (hl' : l'.HasBasis p' s') : l â‰¤ l' â†” âˆ€ i', p' i' â†’ s' i' âˆˆ l :=\n  âŸ¨fun h _i' hi' => h <| hl'.mem_of_mem hi', fun h _s hs =>\n    let âŸ¨_i', hi', hsâŸ© := hl'.mem_iff.1 hs\n    mem_of_superset (h _ hi') hsâŸ©\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.le_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nâŠ¢ Iff (LE.le l l') (âˆ€ (t : Set Î±), Membership.mem l' t â†’ Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"theorem HasBasis.le_iff (hl : l.HasBasis p s) : l â‰¤ l' â†” âˆ€ t âˆˆ l', âˆƒ i, p i âˆ§ s i âŠ† t := by\n  simp only [le_def, hl.mem_iff]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.le_basis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ Iff (LE.le l l') (âˆ€ (i' : Î¹'), p' i' â†’ Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i')))","decl":"theorem HasBasis.le_basis_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    l â‰¤ l' â†” âˆ€ i', p' i' â†’ âˆƒ i, p i âˆ§ s i âŠ† s' i' := by\n  simp only [hl'.ge_iff, hl.mem_iff]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.ext","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nh : âˆ€ (i : Î¹), p i â†’ Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : âˆ€ (i' : Î¹'), p' i' â†’ Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i'))\nâŠ¢ Eq l l'","decl":"theorem HasBasis.ext (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s')\n    (h : âˆ€ i, p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i) (h' : âˆ€ i', p' i' â†’ âˆƒ i, p i âˆ§ s i âŠ† s' i') :\n    l = l' := by\n  apply le_antisymm\n  Â· rw [hl.le_basis_iff hl']\n    simpa using h'\n  Â· rw [hl'.le_basis_iff hl]\n    simpa using h\n\n"}
{"name":"Filter.HasBasis.inf'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ (Min.min l l').HasBasis (fun i => And (p i.fst) (p' i.snd)) fun i => Inter.inter (s i.fst) (s' i.snd)","decl":"theorem HasBasis.inf' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l âŠ“ l').HasBasis (fun i : PProd Î¹ Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆ© s' i.2 :=\n  âŸ¨by\n    intro t\n    constructor\n    Â· simp only [mem_inf_iff, hl.mem_iff, hl'.mem_iff]\n      rintro âŸ¨t, âŸ¨i, hi, htâŸ©, t', âŸ¨i', hi', ht'âŸ©, rflâŸ©\n      exact âŸ¨âŸ¨i, i'âŸ©, âŸ¨hi, hi'âŸ©, inter_subset_inter ht ht'âŸ©\n    Â· rintro âŸ¨âŸ¨i, i'âŸ©, âŸ¨hi, hi'âŸ©, HâŸ©\n      exact mem_inf_of_inter (hl.mem_of_mem hi) (hl'.mem_of_mem hi') HâŸ©\n\n"}
{"name":"Filter.HasBasis.inf","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl l' : Filter Î±\nÎ¹ : Type u_6\nÎ¹' : Type u_7\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ (Min.min l l').HasBasis (fun i => And (p i.1) (p' i.2)) fun i => Inter.inter (s i.1) (s' i.2)","decl":"theorem HasBasis.inf {Î¹ Î¹' : Type*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop}\n    {s' : Î¹' â†’ Set Î±} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l âŠ“ l').HasBasis (fun i : Î¹ Ã— Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆ© s' i.2 :=\n  (hl.inf' hl').comp_equiv Equiv.pprodEquivProd.symm\n\n"}
{"name":"Filter.hasBasis_iInf'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Î¹ â†’ Type u_7\nl : Î¹ â†’ Filter Î±\np : (i : Î¹) â†’ Î¹' i â†’ Prop\ns : (i : Î¹) â†’ Î¹' i â†’ Set Î±\nhl : âˆ€ (i : Î¹), (l i).HasBasis (p i) (s i)\nâŠ¢ (iInf fun i => l i).HasBasis (fun If => And If.1.Finite (âˆ€ (i : Î¹), Membership.mem If.1 i â†’ p i (If.2 i))) fun If => Set.iInter fun i => Set.iInter fun h => s i (If.2 i)","decl":"theorem hasBasis_iInf' {Î¹ : Type*} {Î¹' : Î¹ â†’ Type*} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop}\n    {s : âˆ€ i, Î¹' i â†’ Set Î±} (hl : âˆ€ i, (l i).HasBasis (p i) (s i)) :\n    (â¨… i, l i).HasBasis (fun If : Set Î¹ Ã— âˆ€ i, Î¹' i => If.1.Finite âˆ§ âˆ€ i âˆˆ If.1, p i (If.2 i))\n      fun If : Set Î¹ Ã— âˆ€ i, Î¹' i => â‹‚ i âˆˆ If.1, s i (If.2 i) :=\n  âŸ¨by\n    intro t\n    constructor\n    Â· simp only [mem_iInf', (hl _).mem_iff]\n      rintro âŸ¨I, hI, V, hV, -, rfl, -âŸ©\n      choose u hu using hV\n      exact âŸ¨âŸ¨I, uâŸ©, âŸ¨hI, fun i _ => (hu i).1âŸ©, iInterâ‚‚_mono fun i _ => (hu i).2âŸ©\n    Â· rintro âŸ¨âŸ¨I, fâŸ©, âŸ¨hIâ‚, hIâ‚‚âŸ©, hsubâŸ©\n      refine mem_of_superset ?_ hsub\n      exact (biInter_mem hIâ‚).mpr fun i hi => mem_iInf_of_mem i <| (hl i).mem_of_mem <| hIâ‚‚ _ hiâŸ©\n\n"}
{"name":"Filter.hasBasis_iInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Î¹ â†’ Type u_7\nl : Î¹ â†’ Filter Î±\np : (i : Î¹) â†’ Î¹' i â†’ Prop\ns : (i : Î¹) â†’ Î¹' i â†’ Set Î±\nhl : âˆ€ (i : Î¹), (l i).HasBasis (p i) (s i)\nâŠ¢ (iInf fun i => l i).HasBasis (fun If => And If.fst.Finite (âˆ€ (i : â†‘If.fst), p (â†‘i) (If.snd i))) fun If => Set.iInter fun i => s (â†‘i) (If.snd i)","decl":"theorem hasBasis_iInf {Î¹ : Type*} {Î¹' : Î¹ â†’ Type*} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop}\n    {s : âˆ€ i, Î¹' i â†’ Set Î±} (hl : âˆ€ i, (l i).HasBasis (p i) (s i)) :\n    (â¨… i, l i).HasBasis\n      (fun If : Î£ I : Set Î¹, âˆ€ i : I, Î¹' i => If.1.Finite âˆ§ âˆ€ i : If.1, p i (If.2 i)) fun If =>\n      â‹‚ i : If.1, s i (If.2 i) := by\n  refine âŸ¨fun t => âŸ¨fun ht => ?_, ?_âŸ©âŸ©\n  Â· rcases (hasBasis_iInf' hl).mem_iff.mp ht with âŸ¨âŸ¨I, fâŸ©, âŸ¨hI, hfâŸ©, hsubâŸ©\n    exact âŸ¨âŸ¨I, fun i => f iâŸ©, âŸ¨hI, Subtype.forall.mpr hfâŸ©, trans (iInter_subtype _ _) hsubâŸ©\n  Â· rintro âŸ¨âŸ¨I, fâŸ©, âŸ¨hI, hfâŸ©, hsubâŸ©\n    refine mem_of_superset ?_ hsub\n    cases hI.nonempty_fintype\n    exact iInter_mem.2 fun i => mem_iInf_of_mem â†‘i <| (hl i).mem_of_mem <| hf _\n\n"}
{"name":"Filter.hasBasis_iInf_of_directed'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Î¹ â†’ Type u_7\ninstâœ : Nonempty Î¹\nl : Î¹ â†’ Filter Î±\ns : (i : Î¹) â†’ Î¹' i â†’ Set Î±\np : (i : Î¹) â†’ Î¹' i â†’ Prop\nhl : âˆ€ (i : Î¹), (l i).HasBasis (p i) (s i)\nh : Directed (fun x1 x2 => GE.ge x1 x2) l\nâŠ¢ (iInf fun i => l i).HasBasis (fun ii' => p ii'.fst ii'.snd) fun ii' => s ii'.fst ii'.snd","decl":"theorem hasBasis_iInf_of_directed' {Î¹ : Type*} {Î¹' : Î¹ â†’ Sort _} [Nonempty Î¹] {l : Î¹ â†’ Filter Î±}\n    (s : âˆ€ i, Î¹' i â†’ Set Î±) (p : âˆ€ i, Î¹' i â†’ Prop) (hl : âˆ€ i, (l i).HasBasis (p i) (s i))\n    (h : Directed (Â· â‰¥ Â·) l) :\n    (â¨… i, l i).HasBasis (fun ii' : Î£i, Î¹' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by\n  refine âŸ¨fun t => ?_âŸ©\n  rw [mem_iInf_of_directed h, Sigma.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n\n"}
{"name":"Filter.hasBasis_iInf_of_directed","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Type u_7\ninstâœ : Nonempty Î¹\nl : Î¹ â†’ Filter Î±\ns : Î¹ â†’ Î¹' â†’ Set Î±\np : Î¹ â†’ Î¹' â†’ Prop\nhl : âˆ€ (i : Î¹), (l i).HasBasis (p i) (s i)\nh : Directed (fun x1 x2 => GE.ge x1 x2) l\nâŠ¢ (iInf fun i => l i).HasBasis (fun ii' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2","decl":"theorem hasBasis_iInf_of_directed {Î¹ : Type*} {Î¹' : Sort _} [Nonempty Î¹] {l : Î¹ â†’ Filter Î±}\n    (s : Î¹ â†’ Î¹' â†’ Set Î±) (p : Î¹ â†’ Î¹' â†’ Prop) (hl : âˆ€ i, (l i).HasBasis (p i) (s i))\n    (h : Directed (Â· â‰¥ Â·) l) :\n    (â¨… i, l i).HasBasis (fun ii' : Î¹ Ã— Î¹' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by\n  refine âŸ¨fun t => ?_âŸ©\n  rw [mem_iInf_of_directed h, Prod.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n\n"}
{"name":"Filter.hasBasis_biInf_of_directed'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Î¹ â†’ Type u_7\ndom : Set Î¹\nhdom : dom.Nonempty\nl : Î¹ â†’ Filter Î±\ns : (i : Î¹) â†’ Î¹' i â†’ Set Î±\np : (i : Î¹) â†’ Î¹' i â†’ Prop\nhl : âˆ€ (i : Î¹), Membership.mem dom i â†’ (l i).HasBasis (p i) (s i)\nh : DirectedOn (Order.Preimage l GE.ge) dom\nâŠ¢ (iInf fun i => iInf fun h => l i).HasBasis (fun ii' => And (Membership.mem dom ii'.fst) (p ii'.fst ii'.snd)) fun ii' => s ii'.fst ii'.snd","decl":"theorem hasBasis_biInf_of_directed' {Î¹ : Type*} {Î¹' : Î¹ â†’ Sort _} {dom : Set Î¹}\n    (hdom : dom.Nonempty) {l : Î¹ â†’ Filter Î±} (s : âˆ€ i, Î¹' i â†’ Set Î±) (p : âˆ€ i, Î¹' i â†’ Prop)\n    (hl : âˆ€ i âˆˆ dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l â»Â¹'o GE.ge) dom) :\n    (â¨… i âˆˆ dom, l i).HasBasis (fun ii' : Î£i, Î¹' i => ii'.1 âˆˆ dom âˆ§ p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2 := by\n  refine âŸ¨fun t => ?_âŸ©\n  rw [mem_biInf_of_directed h hdom, Sigma.exists]\n  refine exists_congr fun i => âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨hi, htiâŸ©\n    rcases (hl i hi).mem_iff.mp hti with âŸ¨b, hb, hbtâŸ©\n    exact âŸ¨b, âŸ¨hi, hbâŸ©, hbtâŸ©\n  Â· rintro âŸ¨b, âŸ¨hi, hbâŸ©, hibtâŸ©\n    exact âŸ¨hi, (hl i hi).mem_iff.mpr âŸ¨b, hb, hibtâŸ©âŸ©\n\n"}
{"name":"Filter.hasBasis_biInf_of_directed","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\nÎ¹' : Type u_7\ndom : Set Î¹\nhdom : dom.Nonempty\nl : Î¹ â†’ Filter Î±\ns : Î¹ â†’ Î¹' â†’ Set Î±\np : Î¹ â†’ Î¹' â†’ Prop\nhl : âˆ€ (i : Î¹), Membership.mem dom i â†’ (l i).HasBasis (p i) (s i)\nh : DirectedOn (Order.Preimage l GE.ge) dom\nâŠ¢ (iInf fun i => iInf fun h => l i).HasBasis (fun ii' => And (Membership.mem dom ii'.1) (p ii'.1 ii'.2)) fun ii' => s ii'.1 ii'.2","decl":"theorem hasBasis_biInf_of_directed {Î¹ : Type*} {Î¹' : Sort _} {dom : Set Î¹} (hdom : dom.Nonempty)\n    {l : Î¹ â†’ Filter Î±} (s : Î¹ â†’ Î¹' â†’ Set Î±) (p : Î¹ â†’ Î¹' â†’ Prop)\n    (hl : âˆ€ i âˆˆ dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l â»Â¹'o GE.ge) dom) :\n    (â¨… i âˆˆ dom, l i).HasBasis (fun ii' : Î¹ Ã— Î¹' => ii'.1 âˆˆ dom âˆ§ p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2 := by\n  refine âŸ¨fun t => ?_âŸ©\n  rw [mem_biInf_of_directed h hdom, Prod.exists]\n  refine exists_congr fun i => âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨hi, htiâŸ©\n    rcases (hl i hi).mem_iff.mp hti with âŸ¨b, hb, hbtâŸ©\n    exact âŸ¨b, âŸ¨hi, hbâŸ©, hbtâŸ©\n  Â· rintro âŸ¨b, âŸ¨hi, hbâŸ©, hibtâŸ©\n    exact âŸ¨hi, (hl i hi).mem_iff.mpr âŸ¨b, hb, hibtâŸ©âŸ©\n\n"}
{"name":"Filter.hasBasis_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nt : Set Î±\nâŠ¢ (Filter.principal t).HasBasis (fun x => True) fun x => t","decl":"theorem hasBasis_principal (t : Set Î±) : (ð“Ÿ t).HasBasis (fun _ : Unit => True) fun _ => t :=\n  âŸ¨fun U => by simpâŸ©\n\n"}
{"name":"Filter.hasBasis_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nx : Î±\nâŠ¢ (Pure.pure x).HasBasis (fun x => True) fun x_1 => Singleton.singleton x","decl":"theorem hasBasis_pure (x : Î±) :\n    (pure x : Filter Î±).HasBasis (fun _ : Unit => True) fun _ => {x} := by\n  simp only [â† principal_singleton, hasBasis_principal]\n\n"}
{"name":"Filter.HasBasis.sup'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ (Max.max l l').HasBasis (fun i => And (p i.fst) (p' i.snd)) fun i => Union.union (s i.fst) (s' i.snd)","decl":"theorem HasBasis.sup' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l âŠ” l').HasBasis (fun i : PProd Î¹ Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆª s' i.2 :=\n  âŸ¨by\n    intro t\n    simp_rw [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff,\n       â† exists_and_right, â† exists_and_left]\n    simp only [and_assoc, and_left_comm]âŸ©\n\n"}
{"name":"Filter.HasBasis.sup","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl l' : Filter Î±\nÎ¹ : Type u_6\nÎ¹' : Type u_7\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ (Max.max l l').HasBasis (fun i => And (p i.1) (p' i.2)) fun i => Union.union (s i.1) (s' i.2)","decl":"theorem HasBasis.sup {Î¹ Î¹' : Type*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {p' : Î¹' â†’ Prop}\n    {s' : Î¹' â†’ Set Î±} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l âŠ” l').HasBasis (fun i : Î¹ Ã— Î¹' => p i.1 âˆ§ p' i.2) fun i => s i.1 âˆª s' i.2 :=\n  (hl.sup' hl').comp_equiv Equiv.pprodEquivProd.symm\n\n"}
{"name":"Filter.hasBasis_iSup","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_6\nÎ¹' : Î¹ â†’ Type u_7\nl : Î¹ â†’ Filter Î±\np : (i : Î¹) â†’ Î¹' i â†’ Prop\ns : (i : Î¹) â†’ Î¹' i â†’ Set Î±\nhl : âˆ€ (i : Î¹), (l i).HasBasis (p i) (s i)\nâŠ¢ (iSup fun i => l i).HasBasis (fun f => âˆ€ (i : Î¹), p i (f i)) fun f => Set.iUnion fun i => s i (f i)","decl":"theorem hasBasis_iSup {Î¹ : Sort*} {Î¹' : Î¹ â†’ Type*} {l : Î¹ â†’ Filter Î±} {p : âˆ€ i, Î¹' i â†’ Prop}\n    {s : âˆ€ i, Î¹' i â†’ Set Î±} (hl : âˆ€ i, (l i).HasBasis (p i) (s i)) :\n    (â¨† i, l i).HasBasis (fun f : âˆ€ i, Î¹' i => âˆ€ i, p i (f i)) fun f : âˆ€ i, Î¹' i => â‹ƒ i, s i (f i) :=\n  hasBasis_iff.mpr fun t => by\n    simp only [hasBasis_iff, (hl _).mem_iff, Classical.skolem, forall_and, iUnion_subset_iff,\n      mem_iSup]\n\n"}
{"name":"Filter.HasBasis.sup_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nt : Set Î±\nâŠ¢ (Max.max l (Filter.principal t)).HasBasis p fun i => Union.union (s i) t","decl":"theorem HasBasis.sup_principal (hl : l.HasBasis p s) (t : Set Î±) :\n    (l âŠ” ð“Ÿ t).HasBasis p fun i => s i âˆª t :=\n  âŸ¨fun u => by\n    simp only [(hl.sup' (hasBasis_principal t)).mem_iff, PProd.exists, exists_prop, and_true,\n      Unique.exists_iff]âŸ©\n\n"}
{"name":"Filter.HasBasis.sup_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nx : Î±\nâŠ¢ (Max.max l (Pure.pure x)).HasBasis p fun i => Union.union (s i) (Singleton.singleton x)","decl":"theorem HasBasis.sup_pure (hl : l.HasBasis p s) (x : Î±) :\n    (l âŠ” pure x).HasBasis p fun i => s i âˆª {x} := by\n  simp only [â† principal_singleton, hl.sup_principal]\n\n"}
{"name":"Filter.HasBasis.inf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\ns' : Set Î±\nâŠ¢ (Min.min l (Filter.principal s')).HasBasis p fun i => Inter.inter (s i) s'","decl":"theorem HasBasis.inf_principal (hl : l.HasBasis p s) (s' : Set Î±) :\n    (l âŠ“ ð“Ÿ s').HasBasis p fun i => s i âˆ© s' :=\n  âŸ¨fun t => by\n    simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_setOf_eq, mem_inter_iff, and_imp]âŸ©\n\n"}
{"name":"Filter.HasBasis.principal_inf","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\ns' : Set Î±\nâŠ¢ (Min.min (Filter.principal s') l).HasBasis p fun i => Inter.inter s' (s i)","decl":"theorem HasBasis.principal_inf (hl : l.HasBasis p s) (s' : Set Î±) :\n    (ð“Ÿ s' âŠ“ l).HasBasis p fun i => s' âˆ© s i := by\n  simpa only [inf_comm, inter_comm] using hl.inf_principal s'\n\n"}
{"name":"Filter.HasBasis.inf_basis_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ Iff (Min.min l l').NeBot (âˆ€ â¦ƒi : Î¹â¦„, p i â†’ âˆ€ â¦ƒi' : Î¹'â¦„, p' i' â†’ (Inter.inter (s i) (s' i')).Nonempty)","decl":"theorem HasBasis.inf_basis_neBot_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    NeBot (l âŠ“ l') â†” âˆ€ â¦ƒiâ¦„, p i â†’ âˆ€ â¦ƒi'â¦„, p' i' â†’ (s i âˆ© s' i').Nonempty :=\n  (hl.inf' hl').neBot_iff.trans <| by simp [@forall_swap _ Î¹']\n\n"}
{"name":"Filter.HasBasis.inf_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nâŠ¢ Iff (Min.min l l').NeBot (âˆ€ â¦ƒi : Î¹â¦„, p i â†’ âˆ€ â¦ƒs' : Set Î±â¦„, Membership.mem l' s' â†’ (Inter.inter (s i) s').Nonempty)","decl":"theorem HasBasis.inf_neBot_iff (hl : l.HasBasis p s) :\n    NeBot (l âŠ“ l') â†” âˆ€ â¦ƒiâ¦„, p i â†’ âˆ€ â¦ƒs'â¦„, s' âˆˆ l' â†’ (s i âˆ© s').Nonempty :=\n  hl.inf_basis_neBot_iff l'.basis_sets\n\n"}
{"name":"Filter.HasBasis.inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhl : l.HasBasis p s\nt : Set Î±\nâŠ¢ Iff (Min.min l (Filter.principal t)).NeBot (âˆ€ â¦ƒi : Î¹â¦„, p i â†’ (Inter.inter (s i) t).Nonempty)","decl":"theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set Î±} :\n    NeBot (l âŠ“ ð“Ÿ t) â†” âˆ€ â¦ƒiâ¦„, p i â†’ (s i âˆ© t).Nonempty :=\n  (hl.inf_principal t).neBot_iff\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ Iff (Disjoint l l') (Exists fun i => And (p i) (Exists fun i' => And (p' i') (Disjoint (s i) (s' i'))))","decl":"theorem HasBasis.disjoint_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    Disjoint l l' â†” âˆƒ i, p i âˆ§ âˆƒ i', p' i' âˆ§ Disjoint (s i) (s' i') :=\n  not_iff_not.mp <| by simp only [_root_.disjoint_iff, â† Ne.eq_def, â† neBot_iff, inf_eq_inter,\n    hl.inf_basis_neBot_iff hl', not_exists, not_and, bot_eq_empty, â† nonempty_iff_ne_empty]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Disjoint.exists_mem_filter_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\nh : Disjoint l l'\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nâŠ¢ Exists fun i => And (p i) (Exists fun i' => And (p' i') (Disjoint (s i) (s' i')))","decl":"theorem _root_.Disjoint.exists_mem_filter_basis (h : Disjoint l l') (hl : l.HasBasis p s)\n    (hl' : l'.HasBasis p' s') : âˆƒ i, p i âˆ§ âˆƒ i', p' i' âˆ§ Disjoint (s i) (s' i') :=\n  (hl.disjoint_iff hl').1 h\n\n"}
{"name":"Pairwise.exists_mem_filter_basis_of_disjoint","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nI : Type u_7\ninstâœ : Finite I\nl : I â†’ Filter Î±\nÎ¹ : I â†’ Sort u_6\np : (i : I) â†’ Î¹ i â†’ Prop\ns : (i : I) â†’ Î¹ i â†’ Set Î±\nhd : Pairwise (Function.onFun Disjoint l)\nh : âˆ€ (i : I), (l i).HasBasis (p i) (s i)\nâŠ¢ Exists fun ind => And (âˆ€ (i : I), p i (ind i)) (Pairwise (Function.onFun Disjoint fun i => s i (ind i)))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem _root_.Pairwise.exists_mem_filter_basis_of_disjoint {I} [Finite I] {l : I â†’ Filter Î±}\n    {Î¹ : I â†’ Sort*} {p : âˆ€ i, Î¹ i â†’ Prop} {s : âˆ€ i, Î¹ i â†’ Set Î±} (hd : Pairwise (Disjoint on l))\n    (h : âˆ€ i, (l i).HasBasis (p i) (s i)) :\n    âˆƒ ind : âˆ€ i, Î¹ i, (âˆ€ i, p i (ind i)) âˆ§ Pairwise (Disjoint on fun i => s i (ind i)) := by\n  rcases hd.exists_mem_filter_of_disjoint with âŸ¨t, htl, hdâŸ©\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact âŸ¨ind, hp, hd.mono fun i j hij => hij.mono (ht _) (ht _)âŸ©\n\n"}
{"name":"Set.PairwiseDisjoint.exists_mem_filter_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nI : Type u_6\nl : I â†’ Filter Î±\nÎ¹ : I â†’ Sort u_7\np : (i : I) â†’ Î¹ i â†’ Prop\ns : (i : I) â†’ Î¹ i â†’ Set Î±\nS : Set I\nhd : S.PairwiseDisjoint l\nhS : S.Finite\nh : âˆ€ (i : I), (l i).HasBasis (p i) (s i)\nâŠ¢ Exists fun ind => And (âˆ€ (i : I), p i (ind i)) (S.PairwiseDisjoint fun i => s i (ind i))","decl":"theorem _root_.Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type*} {l : I â†’ Filter Î±}\n    {Î¹ : I â†’ Sort*} {p : âˆ€ i, Î¹ i â†’ Prop} {s : âˆ€ i, Î¹ i â†’ Set Î±} {S : Set I}\n    (hd : S.PairwiseDisjoint l) (hS : S.Finite) (h : âˆ€ i, (l i).HasBasis (p i) (s i)) :\n    âˆƒ ind : âˆ€ i, Î¹ i, (âˆ€ i, p i (ind i)) âˆ§ S.PairwiseDisjoint fun i => s i (ind i) := by\n  rcases hd.exists_mem_filter hS with âŸ¨t, htl, hdâŸ©\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact âŸ¨ind, hp, hd.mono htâŸ©\n\n"}
{"name":"Filter.inf_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl l' : Filter Î±\nâŠ¢ Iff (Min.min l l').NeBot (âˆ€ â¦ƒs : Set Î±â¦„, Membership.mem l s â†’ âˆ€ â¦ƒs' : Set Î±â¦„, Membership.mem l' s' â†’ (Inter.inter s s').Nonempty)","decl":"theorem inf_neBot_iff :\n    NeBot (l âŠ“ l') â†” âˆ€ â¦ƒs : Set Î±â¦„, s âˆˆ l â†’ âˆ€ â¦ƒs'â¦„, s' âˆˆ l' â†’ (s âˆ© s').Nonempty :=\n  l.basis_sets.inf_neBot_iff\n\n"}
{"name":"Filter.inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nl : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Min.min l (Filter.principal s)).NeBot (âˆ€ (U : Set Î±), Membership.mem l U â†’ (Inter.inter U s).Nonempty)","decl":"theorem inf_principal_neBot_iff {s : Set Î±} : NeBot (l âŠ“ ð“Ÿ s) â†” âˆ€ U âˆˆ l, (U âˆ© s).Nonempty :=\n  l.basis_sets.inf_principal_neBot_iff\n\n"}
{"name":"Filter.mem_iff_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem f s) (Eq (Min.min f (Filter.principal (HasCompl.compl s))) Bot.bot)","decl":"theorem mem_iff_inf_principal_compl {f : Filter Î±} {s : Set Î±} : s âˆˆ f â†” f âŠ“ ð“Ÿ sá¶œ = âŠ¥ := by\n  refine not_iff_not.1 ((inf_principal_neBot_iff.trans ?_).symm.trans neBot_iff)\n  exact\n    âŸ¨fun h hs => by simpa [Set.not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht htsâŸ©\n\n"}
{"name":"Filter.not_mem_iff_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Not (Membership.mem f s)) (Min.min f (Filter.principal (HasCompl.compl s))).NeBot","decl":"theorem not_mem_iff_inf_principal_compl {f : Filter Î±} {s : Set Î±} : s âˆ‰ f â†” NeBot (f âŠ“ ð“Ÿ sá¶œ) :=\n  (not_congr mem_iff_inf_principal_compl).trans neBot_iff.symm\n\n"}
{"name":"Filter.disjoint_principal_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Disjoint f (Filter.principal s)) (Membership.mem f (HasCompl.compl s))","decl":"@[simp]\ntheorem disjoint_principal_right {f : Filter Î±} {s : Set Î±} : Disjoint f (ð“Ÿ s) â†” sá¶œ âˆˆ f := by\n  rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]\n\n"}
{"name":"Filter.disjoint_principal_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Disjoint (Filter.principal s) f) (Membership.mem f (HasCompl.compl s))","decl":"@[simp]\ntheorem disjoint_principal_left {f : Filter Î±} {s : Set Î±} : Disjoint (ð“Ÿ s) f â†” sá¶œ âˆˆ f := by\n  rw [disjoint_comm, disjoint_principal_right]\n\n"}
{"name":"Filter.disjoint_principal_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Iff (Disjoint (Filter.principal s) (Filter.principal t)) (Disjoint s t)","decl":"@[simp 1100] -- Porting note: higher priority for linter\ntheorem disjoint_principal_principal {s t : Set Î±} : Disjoint (ð“Ÿ s) (ð“Ÿ t) â†” Disjoint s t := by\n  rw [â† subset_compl_iff_disjoint_left, disjoint_principal_left, mem_principal]\n\n"}
{"name":"Disjoint.filter_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\ns t : Set Î±\naâœ : Disjoint s t\nâŠ¢ Disjoint (Filter.principal s) (Filter.principal t)","decl":"alias âŸ¨_, _root_.Disjoint.filter_principalâŸ© := disjoint_principal_principal\n\n"}
{"name":"Filter.disjoint_pure_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nx y : Î±\nâŠ¢ Iff (Disjoint (Pure.pure x) (Pure.pure y)) (Ne x y)","decl":"@[simp]\ntheorem disjoint_pure_pure {x y : Î±} : Disjoint (pure x : Filter Î±) (pure y) â†” x â‰  y := by\n  simp only [â† principal_singleton, disjoint_principal_principal, disjoint_singleton]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Iff (Disjoint l l') (Exists fun i => And (p i) (Membership.mem l' (HasCompl.compl (s i))))","decl":"theorem HasBasis.disjoint_iff_left (h : l.HasBasis p s) :\n    Disjoint l l' â†” âˆƒ i, p i âˆ§ (s i)á¶œ âˆˆ l' := by\n  simp only [h.disjoint_iff l'.basis_sets, id, â† disjoint_principal_left,\n    (hasBasis_principal _).disjoint_iff l'.basis_sets, true_and, Unique.exists_iff]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Iff (Disjoint l' l) (Exists fun i => And (p i) (Membership.mem l' (HasCompl.compl (s i))))","decl":"theorem HasBasis.disjoint_iff_right (h : l.HasBasis p s) :\n    Disjoint l' l â†” âˆƒ i, p i âˆ§ (s i)á¶œ âˆˆ l' :=\n  disjoint_comm.trans h.disjoint_iff_left\n\n"}
{"name":"Filter.le_iff_forall_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nâŠ¢ Iff (LE.le f g) (âˆ€ (V : Set Î±), Membership.mem g V â†’ Eq (Min.min f (Filter.principal (HasCompl.compl V))) Bot.bot)","decl":"theorem le_iff_forall_inf_principal_compl {f g : Filter Î±} : f â‰¤ g â†” âˆ€ V âˆˆ g, f âŠ“ ð“Ÿ Vá¶œ = âŠ¥ :=\n  forallâ‚‚_congr fun _ _ => mem_iff_inf_principal_compl\n\n"}
{"name":"Filter.inf_neBot_iff_frequently_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nâŠ¢ Iff (Min.min f g).NeBot (âˆ€ {p : Î± â†’ Prop}, Filter.Eventually (fun x => p x) f â†’ Filter.Frequently (fun x => p x) g)","decl":"theorem inf_neBot_iff_frequently_left {f g : Filter Î±} :\n    NeBot (f âŠ“ g) â†” âˆ€ {p : Î± â†’ Prop}, (âˆ€á¶  x in f, p x) â†’ âˆƒá¶  x in g, p x := by\n  simp only [inf_neBot_iff, frequently_iff, and_comm]; rfl\n\n"}
{"name":"Filter.inf_neBot_iff_frequently_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nâŠ¢ Iff (Min.min f g).NeBot (âˆ€ {p : Î± â†’ Prop}, Filter.Eventually (fun x => p x) g â†’ Filter.Frequently (fun x => p x) f)","decl":"theorem inf_neBot_iff_frequently_right {f g : Filter Î±} :\n    NeBot (f âŠ“ g) â†” âˆ€ {p : Î± â†’ Prop}, (âˆ€á¶  x in g, p x) â†’ âˆƒá¶  x in f, p x := by\n  rw [inf_comm]\n  exact inf_neBot_iff_frequently_left\n\n"}
{"name":"Filter.HasBasis.eq_biInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Eq l (iInf fun i => iInf fun x => Filter.principal (s i))","decl":"theorem HasBasis.eq_biInf (h : l.HasBasis p s) : l = â¨… (i) (_ : p i), ð“Ÿ (s i) :=\n  eq_biInf_of_mem_iff_exists_mem fun {_} => by simp only [h.mem_iff, mem_principal, exists_prop]\n\n"}
{"name":"Filter.HasBasis.eq_iInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\ns : Î¹ â†’ Set Î±\nh : l.HasBasis (fun x => True) s\nâŠ¢ Eq l (iInf fun i => Filter.principal (s i))","decl":"theorem HasBasis.eq_iInf (h : l.HasBasis (fun _ => True) s) : l = â¨… i, ð“Ÿ (s i) := by\n  simpa only [iInf_true] using h.eq_biInf\n\n"}
{"name":"Filter.hasBasis_iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\ns : Î¹ â†’ Set Î±\nh : Directed (fun x1 x2 => GE.ge x1 x2) s\ninstâœ : Nonempty Î¹\nâŠ¢ (iInf fun i => Filter.principal (s i)).HasBasis (fun x => True) s","decl":"theorem hasBasis_iInf_principal {s : Î¹ â†’ Set Î±} (h : Directed (Â· â‰¥ Â·) s) [Nonempty Î¹] :\n    (â¨… i, ð“Ÿ (s i)).HasBasis (fun _ => True) s :=\n  âŸ¨fun t => by\n    simpa only [true_and] using mem_iInf_of_directed (h.mono_comp _ monotone_principal.dual) tâŸ©\n\n"}
{"name":"Filter.hasBasis_iInf_principal_finite","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\ns : Î¹ â†’ Set Î±\nâŠ¢ (iInf fun i => Filter.principal (s i)).HasBasis (fun t => t.Finite) fun t => Set.iInter fun i => Set.iInter fun h => s i","decl":"/-- If `s : Î¹ â†’ Set Î±` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `â¨… i, ð“Ÿ (s i)`. -/\ntheorem hasBasis_iInf_principal_finite {Î¹ : Type*} (s : Î¹ â†’ Set Î±) :\n    (â¨… i, ð“Ÿ (s i)).HasBasis (fun t : Set Î¹ => t.Finite) fun t => â‹‚ i âˆˆ t, s i := by\n  refine âŸ¨fun U => (mem_iInf_finite _).trans ?_âŸ©\n  simp only [iInf_principal_finset, mem_iUnion, mem_principal, exists_prop,\n    exists_finite_iff_finset, Finset.set_biInter_coe]\n\n"}
{"name":"Filter.hasBasis_biInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Î² â†’ Set Î±\nS : Set Î²\nh : DirectedOn (Order.Preimage s fun x1 x2 => GE.ge x1 x2) S\nne : S.Nonempty\nâŠ¢ (iInf fun i => iInf fun h => Filter.principal (s i)).HasBasis (fun i => Membership.mem S i) s","decl":"theorem hasBasis_biInf_principal {s : Î² â†’ Set Î±} {S : Set Î²} (h : DirectedOn (s â»Â¹'o (Â· â‰¥ Â·)) S)\n    (ne : S.Nonempty) : (â¨… i âˆˆ S, ð“Ÿ (s i)).HasBasis (fun i => i âˆˆ S) s :=\n  âŸ¨fun t => by\n    refine mem_biInf_of_directed ?_ ne\n    rw [directedOn_iff_directed, â† directed_comp] at h âŠ¢\n    refine h.mono_comp _ ?_\n    exact fun _ _ => principal_mono.2âŸ©\n\n"}
{"name":"Filter.hasBasis_biInf_principal'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_6\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), p i â†’ âˆ€ (j : Î¹), p j â†’ Exists fun k => And (p k) (And (HasSubset.Subset (s k) (s i)) (HasSubset.Subset (s k) (s j)))\nne : Exists fun i => p i\nâŠ¢ (iInf fun i => iInf fun x => Filter.principal (s i)).HasBasis p s","decl":"theorem hasBasis_biInf_principal' {Î¹ : Type*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, p i â†’ âˆ€ j, p j â†’ âˆƒ k, p k âˆ§ s k âŠ† s i âˆ§ s k âŠ† s j) (ne : âˆƒ i, p i) :\n    (â¨… (i) (_ : p i), ð“Ÿ (s i)).HasBasis p s :=\n  Filter.hasBasis_biInf_principal h ne\n\n"}
{"name":"Filter.HasBasis.map","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nf : Î± â†’ Î²\nhl : l.HasBasis p s\nâŠ¢ (Filter.map f l).HasBasis p fun i => Set.image f (s i)","decl":"theorem HasBasis.map (f : Î± â†’ Î²) (hl : l.HasBasis p s) : (l.map f).HasBasis p fun i => f '' s i :=\n  âŸ¨fun t => by simp only [mem_map, image_subset_iff, hl.mem_iff, preimage]âŸ©\n\n"}
{"name":"Filter.HasBasis.comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nf : Î² â†’ Î±\nhl : l.HasBasis p s\nâŠ¢ (Filter.comap f l).HasBasis p fun i => Set.preimage f (s i)","decl":"theorem HasBasis.comap (f : Î² â†’ Î±) (hl : l.HasBasis p s) :\n    (l.comap f).HasBasis p fun i => f â»Â¹' s i :=\n  âŸ¨fun t => by\n    simp only [mem_comap', hl.mem_iff]\n    refine exists_congr (fun i => Iff.rfl.and ?_)\n    exact âŸ¨fun h x hx => h hx rfl, fun h y hy x hx => h <| by rwa [mem_preimage, hx]âŸ©âŸ©\n\n"}
{"name":"Filter.comap_hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nl : Filter Î²\nâŠ¢ (Filter.comap f l).HasBasis (fun s => Membership.mem l s) fun s => Set.preimage f s","decl":"theorem comap_hasBasis (f : Î± â†’ Î²) (l : Filter Î²) :\n    HasBasis (comap f l) (fun s : Set Î² => s âˆˆ l) fun s => f â»Â¹' s :=\n  âŸ¨fun _ => mem_comapâŸ©\n\n"}
{"name":"Filter.HasBasis.forall_mem_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nx : Î±\nâŠ¢ Iff (âˆ€ (t : Set Î±), Membership.mem l t â†’ Membership.mem t x) (âˆ€ (i : Î¹), p i â†’ Membership.mem (s i) x)","decl":"theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : Î±} :\n    (âˆ€ t âˆˆ l, x âˆˆ t) â†” âˆ€ i, p i â†’ x âˆˆ s i := by\n  simp only [h.mem_iff, exists_imp, and_imp]\n  exact âŸ¨fun h i hi => h (s i) i hi Subset.rfl, fun h t i hi ht => ht (h i hi)âŸ©\n\n"}
{"name":"Filter.HasBasis.biInf_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\ninstâœ : CompleteLattice Î²\nf : Set Î± â†’ Î²\nh : l.HasBasis p s\nhf : Monotone f\nâŠ¢ Eq (iInf fun t => iInf fun h => f t) (iInf fun i => iInf fun x => f (s i))","decl":"protected theorem HasBasis.biInf_mem [CompleteLattice Î²] {f : Set Î± â†’ Î²} (h : HasBasis l p s)\n    (hf : Monotone f) : â¨… t âˆˆ l, f t = â¨… (i) (_ : p i), f (s i) :=\n  le_antisymm (le_iInfâ‚‚ fun i hi => iInfâ‚‚_le (s i) (h.mem_of_mem hi)) <|\n    le_iInfâ‚‚ fun _t ht =>\n      let âŸ¨i, hpi, hiâŸ© := h.mem_iff.1 ht\n      iInfâ‚‚_le_of_le i hpi (hf hi)\n\n"}
{"name":"Filter.HasBasis.biInter_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nf : Set Î± â†’ Set Î²\nh : l.HasBasis p s\nhf : Monotone f\nâŠ¢ Eq (Set.iInter fun t => Set.iInter fun h => f t) (Set.iInter fun i => Set.iInter fun x => f (s i))","decl":"protected theorem HasBasis.biInter_mem {f : Set Î± â†’ Set Î²} (h : HasBasis l p s) (hf : Monotone f) :\n    â‹‚ t âˆˆ l, f t = â‹‚ (i) (_ : p i), f (s i) :=\n  h.biInf_mem hf\n\n"}
{"name":"Filter.HasBasis.ker","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ Eq l.ker (Set.iInter fun i => Set.iInter fun x => s i)","decl":"protected theorem HasBasis.ker (h : HasBasis l p s) : l.ker = â‹‚ (i) (_ : p i), s i :=\n  sInter_eq_biInter.trans <| h.biInter_mem monotone_id\n\n"}
{"name":"Filter.IsAntitoneBasis.toIsBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\ns'' : Î¹'' â†’ Set Î±\nself : Filter.IsAntitoneBasis s''\nâŠ¢ Filter.IsBasis (fun x => True) s''","decl":"/-- `IsAntitoneBasis s` means the image of `s` is a filter basis such that `s` is decreasing. -/\nstructure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s''\n\n"}
{"name":"Filter.IsAntitoneBasis.antitone","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\ns'' : Î¹'' â†’ Set Î±\nself : Filter.IsAntitoneBasis s''\nâŠ¢ Antitone s''","decl":"/-- `IsAntitoneBasis s` means the image of `s` is a filter basis such that `s` is decreasing. -/\nstructure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s''\n\n"}
{"name":"Filter.HasAntitoneBasis.antitone","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\nl : Filter Î±\ns : Î¹'' â†’ Set Î±\nself : l.HasAntitoneBasis s\nâŠ¢ Antitone s","decl":"/-- We say that a filter `l` has an antitone basis `s : Î¹ â†’ Set Î±`, if `t âˆˆ l` if and only if `t`\nincludes `s i` for some `i`, and `s` is decreasing. -/\nstructure HasAntitoneBasis (l : Filter Î±) (s : Î¹'' â†’ Set Î±)\n    extends HasBasis l (fun _ => True) s : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s\n\n"}
{"name":"Filter.HasAntitoneBasis.toHasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\nl : Filter Î±\ns : Î¹'' â†’ Set Î±\nself : l.HasAntitoneBasis s\nâŠ¢ l.HasBasis (fun x => True) s","decl":"/-- We say that a filter `l` has an antitone basis `s : Î¹ â†’ Set Î±`, if `t âˆˆ l` if and only if `t`\nincludes `s i` for some `i`, and `s` is decreasing. -/\nstructure HasAntitoneBasis (l : Filter Î±) (s : Î¹'' â†’ Set Î±)\n    extends HasBasis l (fun _ => True) s : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s\n\n"}
{"name":"Filter.HasAntitoneBasis.map","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\nl : Filter Î±\ns : Î¹'' â†’ Set Î±\nhf : l.HasAntitoneBasis s\nm : Î± â†’ Î²\nâŠ¢ (Filter.map m l).HasAntitoneBasis fun x => Set.image m (s x)","decl":"protected theorem HasAntitoneBasis.map {l : Filter Î±} {s : Î¹'' â†’ Set Î±}\n    (hf : HasAntitoneBasis l s) (m : Î± â†’ Î²) : HasAntitoneBasis (map m l) (m '' s Â·) :=\n  âŸ¨HasBasis.map _ hf.toHasBasis, fun _ _ h => image_subset _ <| hf.2 hâŸ©\n\n"}
{"name":"Filter.HasAntitoneBasis.comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹'' : Type u_6\ninstâœ : Preorder Î¹''\nl : Filter Î±\ns : Î¹'' â†’ Set Î±\nhf : l.HasAntitoneBasis s\nm : Î² â†’ Î±\nâŠ¢ (Filter.comap m l).HasAntitoneBasis fun x => Set.preimage m (s x)","decl":"protected theorem HasAntitoneBasis.comap {l : Filter Î±} {s : Î¹'' â†’ Set Î±}\n    (hf : HasAntitoneBasis l s) (m : Î² â†’ Î±) : HasAntitoneBasis (comap m l) (m â»Â¹' s Â·) :=\n  âŸ¨hf.1.comap _, fun _ _ h â†¦ preimage_mono (hf.2 h)âŸ©\n\n"}
{"name":"Filter.HasAntitoneBasis.iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_7\ninstâœÂ² : Preorder Î¹\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : IsDirected Î¹ fun x1 x2 => LE.le x1 x2\ns : Î¹ â†’ Set Î±\nhs : Antitone s\nâŠ¢ (iInf fun i => Filter.principal (s i)).HasAntitoneBasis s","decl":"lemma HasAntitoneBasis.iInf_principal {Î¹ : Type*} [Preorder Î¹] [Nonempty Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)]\n    {s : Î¹ â†’ Set Î±} (hs : Antitone s) : (â¨… i, ð“Ÿ (s i)).HasAntitoneBasis s :=\n  âŸ¨hasBasis_iInf_principal hs.directed_ge, hsâŸ©\n\n"}
{"name":"Filter.HasBasis.tendsto_left_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\nf : Î± â†’ Î²\nhla : la.HasBasis pa sa\nâŠ¢ Iff (Filter.Tendsto f la lb) (âˆ€ (t : Set Î²), Membership.mem lb t â†’ Exists fun i => And (pa i) (Set.MapsTo f (sa i) t))","decl":"theorem HasBasis.tendsto_left_iff (hla : la.HasBasis pa sa) :\n    Tendsto f la lb â†” âˆ€ t âˆˆ lb, âˆƒ i, pa i âˆ§ MapsTo f (sa i) t := by\n  simp only [Tendsto, (hla.map f).le_iff, image_subset_iff]\n  rfl\n\n"}
{"name":"Filter.HasBasis.tendsto_right_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹' : Sort u_5\nla : Filter Î±\nlb : Filter Î²\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nf : Î± â†’ Î²\nhlb : lb.HasBasis pb sb\nâŠ¢ Iff (Filter.Tendsto f la lb) (âˆ€ (i : Î¹'), pb i â†’ Filter.Eventually (fun x => Membership.mem (sb i) (f x)) la)","decl":"theorem HasBasis.tendsto_right_iff (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb â†” âˆ€ i, pb i â†’ âˆ€á¶  x in la, f x âˆˆ sb i := by\n  simp only [Tendsto, hlb.ge_iff, mem_map', Filter.Eventually]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.tendsto_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nf : Î± â†’ Î²\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nâŠ¢ Iff (Filter.Tendsto f la lb) (âˆ€ (ib : Î¹'), pb ib â†’ Exists fun ia => And (pa ia) (âˆ€ (x : Î±), Membership.mem (sa ia) x â†’ Membership.mem (sb ib) (f x)))","decl":"theorem HasBasis.tendsto_iff (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb â†” âˆ€ ib, pb ib â†’ âˆƒ ia, pa ia âˆ§ âˆ€ x âˆˆ sa ia, f x âˆˆ sb ib := by\n  simp [hlb.tendsto_right_iff, hla.eventually_iff]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.Tendsto.basis_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\nf : Î± â†’ Î²\nH : Filter.Tendsto f la lb\nhla : la.HasBasis pa sa\nt : Set Î²\naâœ : Membership.mem lb t\nâŠ¢ Exists fun i => And (pa i) (Set.MapsTo f (sa i) t)","decl":"theorem Tendsto.basis_left (H : Tendsto f la lb) (hla : la.HasBasis pa sa) :\n    âˆ€ t âˆˆ lb, âˆƒ i, pa i âˆ§ MapsTo f (sa i) t :=\n  hla.tendsto_left_iff.1 H\n\n"}
{"name":"Filter.Tendsto.basis_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹' : Sort u_5\nla : Filter Î±\nlb : Filter Î²\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nf : Î± â†’ Î²\nH : Filter.Tendsto f la lb\nhlb : lb.HasBasis pb sb\ni : Î¹'\naâœ : pb i\nâŠ¢ Filter.Eventually (fun x => Membership.mem (sb i) (f x)) la","decl":"theorem Tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.HasBasis pb sb) :\n    âˆ€ i, pb i â†’ âˆ€á¶  x in la, f x âˆˆ sb i :=\n  hlb.tendsto_right_iff.1 H\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`.\n"}
{"name":"Filter.Tendsto.basis_both","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nf : Î± â†’ Î²\nH : Filter.Tendsto f la lb\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nib : Î¹'\naâœ : pb ib\nâŠ¢ Exists fun ia => And (pa ia) (Set.MapsTo f (sa ia) (sb ib))","decl":"theorem Tendsto.basis_both (H : Tendsto f la lb) (hla : la.HasBasis pa sa)\n    (hlb : lb.HasBasis pb sb) :\n    âˆ€ ib, pb ib â†’ âˆƒ ia, pa ia âˆ§ MapsTo f (sa ia) (sb ib) :=\n  (hla.tendsto_iff hlb).1 H\n\n"}
{"name":"Filter.HasBasis.prod_pprod","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nâŠ¢ (SProd.sprod la lb).HasBasis (fun i => And (pa i.fst) (pb i.snd)) fun i => SProd.sprod (sa i.fst) (sb i.snd)","decl":"theorem HasBasis.prod_pprod (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la Ã—Ë¢ lb).HasBasis (fun i : PProd Î¹ Î¹' => pa i.1 âˆ§ pb i.2) fun i => sa i.1 Ã—Ë¢ sb i.2 :=\n  (hla.comap Prod.fst).inf' (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.HasBasis.prod","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nÎ¹ : Type u_6\nÎ¹' : Type u_7\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nâŠ¢ (SProd.sprod la lb).HasBasis (fun i => And (pa i.1) (pb i.2)) fun i => SProd.sprod (sa i.1) (sb i.2)","decl":"theorem HasBasis.prod {Î¹ Î¹' : Type*} {pa : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±} {pb : Î¹' â†’ Prop}\n    {sb : Î¹' â†’ Set Î²} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la Ã—Ë¢ lb).HasBasis (fun i : Î¹ Ã— Î¹' => pa i.1 âˆ§ pb i.2) fun i => sa i.1 Ã—Ë¢ sb i.2 :=\n  (hla.comap Prod.fst).inf (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.HasBasis.prod_same_index","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nla : Filter Î±\nsa : Î¹ â†’ Set Î±\nlb : Filter Î²\np : Î¹ â†’ Prop\nsb : Î¹ â†’ Set Î²\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nh_dir : âˆ€ {i j : Î¹}, p i â†’ p j â†’ Exists fun k => And (p k) (And (HasSubset.Subset (sa k) (sa i)) (HasSubset.Subset (sb k) (sb j)))\nâŠ¢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index {p : Î¹ â†’ Prop} {sb : Î¹ â†’ Set Î²} (hla : la.HasBasis p sa)\n    (hlb : lb.HasBasis p sb) (h_dir : âˆ€ {i j}, p i â†’ p j â†’ âˆƒ k, p k âˆ§ sa k âŠ† sa i âˆ§ sb k âŠ† sb j) :\n    (la Ã—Ë¢ lb).HasBasis p fun i => sa i Ã—Ë¢ sb i := by\n  simp only [hasBasis_iff, (hla.prod_pprod hlb).mem_iff]\n  refine fun t => âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨âŸ¨i, jâŸ©, âŸ¨hi, hjâŸ©, hsub : sa i Ã—Ë¢ sb j âŠ† tâŸ©\n    rcases h_dir hi hj with âŸ¨k, hk, ki, kjâŸ©\n    exact âŸ¨k, hk, (Set.prod_mono ki kj).trans hsubâŸ©\n  Â· rintro âŸ¨i, hi, hâŸ©\n    exact âŸ¨âŸ¨i, iâŸ©, âŸ¨hi, hiâŸ©, hâŸ©\n\n"}
{"name":"Filter.HasBasis.prod_same_index_mono","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nÎ¹ : Type u_6\ninstâœ : LinearOrder Î¹\np : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nsb : Î¹ â†’ Set Î²\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nhsa : MonotoneOn sa (setOf fun i => p i)\nhsb : MonotoneOn sb (setOf fun i => p i)\nâŠ¢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index_mono {Î¹ : Type*} [LinearOrder Î¹] {p : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±}\n    {sb : Î¹ â†’ Set Î²} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : MonotoneOn sa { i | p i }) (hsb : MonotoneOn sb { i | p i }) :\n    (la Ã—Ë¢ lb).HasBasis p fun i => sa i Ã—Ë¢ sb i :=\n  hla.prod_same_index hlb fun {i j} hi hj =>\n    have : p (min i j) := min_rec' _ hi hj\n    âŸ¨min i j, this, hsa this hi <| min_le_left _ _, hsb this hj <| min_le_right _ _âŸ©\n\n"}
{"name":"Filter.HasBasis.prod_same_index_anti","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nÎ¹ : Type u_6\ninstâœ : LinearOrder Î¹\np : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nsb : Î¹ â†’ Set Î²\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nhsa : AntitoneOn sa (setOf fun i => p i)\nhsb : AntitoneOn sb (setOf fun i => p i)\nâŠ¢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index_anti {Î¹ : Type*} [LinearOrder Î¹] {p : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±}\n    {sb : Î¹ â†’ Set Î²} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : AntitoneOn sa { i | p i }) (hsb : AntitoneOn sb { i | p i }) :\n    (la Ã—Ë¢ lb).HasBasis p fun i => sa i Ã—Ë¢ sb i :=\n  @HasBasis.prod_same_index_mono _ _ _ _ Î¹áµ’áµˆ _ _ _ _ hla hlb hsa.dual_left hsb.dual_left\n\n"}
{"name":"Filter.HasBasis.prod_self","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_4\nla : Filter Î±\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\nhl : la.HasBasis pa sa\nâŠ¢ (SProd.sprod la la).HasBasis pa fun i => SProd.sprod (sa i) (sa i)","decl":"theorem HasBasis.prod_self (hl : la.HasBasis pa sa) :\n    (la Ã—Ë¢ la).HasBasis pa fun i => sa i Ã—Ë¢ sa i :=\n  hl.prod_same_index hl fun {i j} hi hj => by\n    simpa only [exists_prop, subset_inter_iff] using\n      hl.mem_iff.1 (inter_mem (hl.mem_of_mem hi) (hl.mem_of_mem hj))\n\n"}
{"name":"Filter.mem_prod_self_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nla : Filter Î±\ns : Set (Prod Î± Î±)\nâŠ¢ Iff (Membership.mem (SProd.sprod la la) s) (Exists fun t => And (Membership.mem la t) (HasSubset.Subset (SProd.sprod t t) s))","decl":"theorem mem_prod_self_iff {s} : s âˆˆ la Ã—Ë¢ la â†” âˆƒ t âˆˆ la, t Ã—Ë¢ t âŠ† s :=\n  la.basis_sets.prod_self.mem_iff\n\n"}
{"name":"Filter.eventually_prod_self_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nla : Filter Î±\nr : Î± â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => r x.1 x.2) (SProd.sprod la la)) (Exists fun t => And (Membership.mem la t) (âˆ€ (x : Î±), Membership.mem t x â†’ âˆ€ (y : Î±), Membership.mem t y â†’ r x y))","decl":"lemma eventually_prod_self_iff {r : Î± â†’ Î± â†’ Prop} :\n    (âˆ€á¶  x in la Ã—Ë¢ la, r x.1 x.2) â†” âˆƒ t âˆˆ la, âˆ€ x âˆˆ t, âˆ€ y âˆˆ t, r x y :=\n  mem_prod_self_iff.trans <| by simp only [prod_subset_iff, mem_setOf_eq]\n\n"}
{"name":"Filter.eventually_prod_self_iff'","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nla : Filter Î±\nr : Prod Î± Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => r x) (SProd.sprod la la)) (Exists fun t => And (Membership.mem la t) (âˆ€ (x : Î±), Membership.mem t x â†’ âˆ€ (y : Î±), Membership.mem t y â†’ r { fst := x, snd := y }))","decl":"/-- A version of `eventually_prod_self_iff` that is more suitable for forward rewriting. -/\nlemma eventually_prod_self_iff' {r : Î± Ã— Î± â†’ Prop} :\n    (âˆ€á¶  x in la Ã—Ë¢ la, r x) â†” âˆƒ t âˆˆ la, âˆ€ x âˆˆ t, âˆ€ y âˆˆ t, r (x, y) :=\n  Iff.symm eventually_prod_self_iff.symm\n\n"}
{"name":"Filter.HasAntitoneBasis.prod","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_6\ninstâœ : LinearOrder Î¹\nf : Filter Î±\ng : Filter Î²\ns : Î¹ â†’ Set Î±\nt : Î¹ â†’ Set Î²\nhf : f.HasAntitoneBasis s\nhg : g.HasAntitoneBasis t\nâŠ¢ (SProd.sprod f g).HasAntitoneBasis fun n => SProd.sprod (s n) (t n)","decl":"theorem HasAntitoneBasis.prod {Î¹ : Type*} [LinearOrder Î¹] {f : Filter Î±} {g : Filter Î²}\n    {s : Î¹ â†’ Set Î±} {t : Î¹ â†’ Set Î²} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (f Ã—Ë¢ g) fun n => s n Ã—Ë¢ t n :=\n  âŸ¨hf.1.prod_same_index_anti hg.1 (hf.2.antitoneOn _) (hg.2.antitoneOn _), hf.2.set_prod hg.2âŸ©\n\n"}
{"name":"Filter.HasBasis.coprod","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nÎ¹ : Type u_6\nÎ¹' : Type u_7\npa : Î¹ â†’ Prop\nsa : Î¹ â†’ Set Î±\npb : Î¹' â†’ Prop\nsb : Î¹' â†’ Set Î²\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nâŠ¢ (la.coprod lb).HasBasis (fun i => And (pa i.1) (pb i.2)) fun i => Union.union (Set.preimage Prod.fst (sa i.1)) (Set.preimage Prod.snd (sb i.2))","decl":"theorem HasBasis.coprod {Î¹ Î¹' : Type*} {pa : Î¹ â†’ Prop} {sa : Î¹ â†’ Set Î±} {pb : Î¹' â†’ Prop}\n    {sb : Î¹' â†’ Set Î²} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la.coprod lb).HasBasis (fun i : Î¹ Ã— Î¹' => pa i.1 âˆ§ pb i.2) fun i =>\n      Prod.fst â»Â¹' sa i.1 âˆª Prod.snd â»Â¹' sb i.2 :=\n  (hla.comap Prod.fst).sup (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.map_sigma_mk_comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÏ€ : Î± â†’ Type u_6\nÏ€' : Î² â†’ Type u_7\nf : Î± â†’ Î²\nhf : Function.Injective f\ng : (a : Î±) â†’ Ï€ a â†’ Ï€' (f a)\na : Î±\nl : Filter (Ï€' (f a))\nâŠ¢ Eq (Filter.map (Sigma.mk a) (Filter.comap (g a) l)) (Filter.comap (Sigma.map f g) (Filter.map (Sigma.mk (f a)) l))","decl":"theorem map_sigma_mk_comap {Ï€ : Î± â†’ Type*} {Ï€' : Î² â†’ Type*} {f : Î± â†’ Î²}\n    (hf : Function.Injective f) (g : âˆ€ a, Ï€ a â†’ Ï€' (f a)) (a : Î±) (l : Filter (Ï€' (f a))) :\n    map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l) := by\n  refine (((basis_sets _).comap _).map _).eq_of_same_basis ?_\n  convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)\n  apply image_sigmaMk_preimage_sigmaMap hf\n\n"}
