{"name":"FilterBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_6\nself : FilterBasis α\n⊢ self.sets.Nonempty","decl":"/-- A filter basis `B` on a type `α` is a nonempty collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (α : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set α)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y\n\n"}
{"name":"FilterBasis.inter_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_6\nself : FilterBasis α\nx y : Set α\na✝¹ : Membership.mem self.sets x\na✝ : Membership.mem self.sets y\n⊢ Exists fun z => And (Membership.mem self.sets z) (HasSubset.Subset z (Inter.inter x y))","decl":"/-- A filter basis `B` on a type `α` is a nonempty collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (α : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set α)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y\n\n"}
{"name":"FilterBasis.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_6\ninst✝ : SizeOf α\nsets : Set (Set α)\nnonempty : sets.Nonempty\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\n⊢ Eq (SizeOf.sizeOf { sets := sets, nonempty := nonempty, inter_sets := inter_sets }) (HAdd.hAdd 1 (SizeOf.sizeOf nonempty))","decl":"/-- A filter basis `B` on a type `α` is a nonempty collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (α : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set α)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y\n\n"}
{"name":"FilterBasis.mk.inj","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_6\nsets✝ : Set (Set α)\nnonempty✝ : sets✝.Nonempty\ninter_sets✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → Membership.mem sets✝ y → Exists fun z => And (Membership.mem sets✝ z) (HasSubset.Subset z (Inter.inter x y))\nsets : Set (Set α)\nnonempty : sets.Nonempty\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\nx✝ : Eq { sets := sets✝, nonempty := nonempty✝, inter_sets := inter_sets✝ } { sets := sets, nonempty := nonempty, inter_sets := inter_sets }\n⊢ Eq sets✝ sets","decl":"/-- A filter basis `B` on a type `α` is a nonempty collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (α : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set α)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y\n\n"}
{"name":"FilterBasis.mk.injEq","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_6\nsets✝ : Set (Set α)\nnonempty✝ : sets✝.Nonempty\ninter_sets✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → Membership.mem sets✝ y → Exists fun z => And (Membership.mem sets✝ z) (HasSubset.Subset z (Inter.inter x y))\nsets : Set (Set α)\nnonempty : sets.Nonempty\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Exists fun z => And (Membership.mem sets z) (HasSubset.Subset z (Inter.inter x y))\n⊢ Eq (Eq { sets := sets✝, nonempty := nonempty✝, inter_sets := inter_sets✝ } { sets := sets, nonempty := nonempty, inter_sets := inter_sets }) (Eq sets✝ sets)","decl":"/-- A filter basis `B` on a type `α` is a nonempty collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure FilterBasis (α : Type*) where\n  /-- Sets of a filter basis. -/\n  sets : Set (Set α)\n  /-- The set of filter basis sets is nonempty. -/\n  nonempty : sets.Nonempty\n  /-- The set of filter basis sets is directed downwards. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → ∃ z ∈ sets, z ⊆ x ∩ y\n\n"}
{"name":"FilterBasis.nonempty_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\n⊢ Nonempty ↑B.sets","decl":"instance FilterBasis.nonempty_sets (B : FilterBasis α) : Nonempty B.sets :=\n  B.nonempty.to_subtype\n\n-- Porting note: this instance was reducible but it doesn't work the same way in Lean 4\n"}
{"name":"FilterBasis.mem_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set α\nB : FilterBasis α\n⊢ Iff (Membership.mem B.sets s) (Membership.mem B s)","decl":"@[simp] theorem FilterBasis.mem_sets {s : Set α} {B : FilterBasis α} : s ∈ B.sets ↔ s ∈ B := Iff.rfl\n\n-- For illustration purposes, the filter basis defining `(atTop : Filter ℕ)`\n"}
{"name":"Filter.IsBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nself : Filter.IsBasis p s\n⊢ Exists fun i => p i","decl":"/-- `IsBasis p s` means the image of `s` bounded by `p` is a filter basis. -/\nstructure Filter.IsBasis (p : ι → Prop) (s : ι → Set α) : Prop where\n  /-- There exists at least one `i` that satisfies `p`. -/\n  nonempty : ∃ i, p i\n  /-- `s` is directed downwards on `i` such that `p i`. -/\n  inter : ∀ {i j}, p i → p j → ∃ k, p k ∧ s k ⊆ s i ∩ s j\n\n"}
{"name":"Filter.IsBasis.inter","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nself : Filter.IsBasis p s\ni j : ι\na✝¹ : p i\na✝ : p j\n⊢ Exists fun k => And (p k) (HasSubset.Subset (s k) (Inter.inter (s i) (s j)))","decl":"/-- `IsBasis p s` means the image of `s` bounded by `p` is a filter basis. -/\nstructure Filter.IsBasis (p : ι → Prop) (s : ι → Set α) : Prop where\n  /-- There exists at least one `i` that satisfies `p`. -/\n  nonempty : ∃ i, p i\n  /-- `s` is directed downwards on `i` such that `p i`. -/\n  inter : ∀ {i j}, p i → p j → ∃ k, p k ∧ s k ⊆ s i ∩ s j\n\n"}
{"name":"Filter.IsBasis.mem_filterBasis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nh : Filter.IsBasis p s\nU : Set α\n⊢ Iff (Membership.mem h.filterBasis U) (Exists fun i => And (p i) (Eq (s i) U))","decl":"theorem mem_filterBasis_iff {U : Set α} : U ∈ h.filterBasis ↔ ∃ i, p i ∧ s i = U :=\n  Iff.rfl\n\n"}
{"name":"FilterBasis.mem_filter_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\nU : Set α\n⊢ Iff (Membership.mem B.filter U) (Exists fun s => And (Membership.mem B s) (HasSubset.Subset s U))","decl":"theorem mem_filter_iff (B : FilterBasis α) {U : Set α} : U ∈ B.filter ↔ ∃ s ∈ B, s ⊆ U :=\n  Iff.rfl\n\n"}
{"name":"FilterBasis.mem_filter_of_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\nU : Set α\na✝ : Membership.mem B U\n⊢ Membership.mem B.filter U","decl":"theorem mem_filter_of_mem (B : FilterBasis α) {U : Set α} : U ∈ B → U ∈ B.filter := fun U_in =>\n  ⟨U, U_in, Subset.refl _⟩\n\n"}
{"name":"FilterBasis.eq_iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\n⊢ Eq B.filter (iInf fun s => Filter.principal ↑s)","decl":"theorem eq_iInf_principal (B : FilterBasis α) : B.filter = ⨅ s : B.sets, 𝓟 s := by\n  have : Directed (· ≥ ·) fun s : B.sets => 𝓟 (s : Set α) := by\n    rintro ⟨U, U_in⟩ ⟨V, V_in⟩\n    rcases B.inter_sets U_in V_in with ⟨W, W_in, W_sub⟩\n    use ⟨W, W_in⟩\n    simp only [le_principal_iff, mem_principal, Subtype.coe_mk]\n    exact subset_inter_iff.mp W_sub\n  ext U\n  simp [mem_filter_iff, mem_iInf_of_directed this]\n\n"}
{"name":"FilterBasis.generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\n⊢ Eq (Filter.generate B.sets) B.filter","decl":"protected theorem generate (B : FilterBasis α) : generate B.sets = B.filter := by\n  apply le_antisymm\n  · intro U U_in\n    rcases B.mem_filter_iff.mp U_in with ⟨V, V_in, h⟩\n    exact GenerateSets.superset (GenerateSets.basic V_in) h\n  · rw [le_generate_iff]\n    apply mem_filter_of_mem\n\n"}
{"name":"Filter.IsBasis.mem_filter_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nh : Filter.IsBasis p s\nU : Set α\n⊢ Iff (Membership.mem h.filter U) (Exists fun i => And (p i) (HasSubset.Subset (s i) U))","decl":"protected theorem mem_filter_iff (h : IsBasis p s) {U : Set α} :\n    U ∈ h.filter ↔ ∃ i, p i ∧ s i ⊆ U := by\n  simp only [IsBasis.filter, FilterBasis.mem_filter_iff, mem_filterBasis_iff,\n    exists_exists_and_eq_and]\n\n"}
{"name":"Filter.IsBasis.filter_eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nh : Filter.IsBasis p s\n⊢ Eq h.filter (Filter.generate (setOf fun U => Exists fun i => And (p i) (Eq (s i) U)))","decl":"theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | ∃ i, p i ∧ s i = U } := by\n  rw [IsBasis.filter, ← h.filterBasis.generate, IsBasis.filterBasis]\n\n"}
{"name":"Filter.HasBasis.mem_iff'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nself : l.HasBasis p s\nt : Set α\n⊢ Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"/-- We say that a filter `l` has a basis `s : ι → Set α` bounded by `p : ι → Prop`,\nif `t ∈ l` if and only if `t` includes `s i` for some `i` such that `p i`. -/\nstructure HasBasis (l : Filter α) (p : ι → Prop) (s : ι → Set α) : Prop where\n  /-- A set `t` belongs to a filter `l` iff it includes an element of the basis. -/\n  mem_iff' : ∀ t : Set α, t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t\n\n"}
{"name":"Filter.hasBasis_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ (Filter.generate s).HasBasis (fun t => And t.Finite (HasSubset.Subset t s)) fun t => t.sInter","decl":"theorem hasBasis_generate (s : Set (Set α)) :\n    (generate s).HasBasis (fun t => Set.Finite t ∧ t ⊆ s) fun t => ⋂₀ t :=\n  ⟨fun U => by simp only [mem_generate_iff, exists_prop, and_assoc, and_left_comm]⟩\n\n"}
{"name":"Filter.FilterBasis.ofSets_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq (Filter.FilterBasis.ofSets s).sets (Set.image Set.sInter (setOf fun t => And t.Finite (HasSubset.Subset t s)))","decl":"lemma FilterBasis.ofSets_sets (s : Set (Set α)) :\n    (FilterBasis.ofSets s).sets = sInter '' { t | Set.Finite t ∧ t ⊆ s } :=\n  rfl\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.mem_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nt : Set α\nhl : l.HasBasis p s\n⊢ Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"/-- Definition of `HasBasis` unfolded with implicit set argument. -/\ntheorem HasBasis.mem_iff (hl : l.HasBasis p s) : t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t :=\n  hl.mem_iff' t\n\n"}
{"name":"Filter.HasBasis.eq_of_same_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p s\n⊢ Eq l l'","decl":"theorem HasBasis.eq_of_same_basis (hl : l.HasBasis p s) (hl' : l'.HasBasis p s) : l = l' := by\n  ext t\n  rw [hl.mem_iff, hl'.mem_iff]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.hasBasis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\n⊢ Iff (l.HasBasis p s) (∀ (t : Set α), Iff (Membership.mem l t) (Exists fun i => And (p i) (HasSubset.Subset (s i) t)))","decl":"theorem hasBasis_iff : l.HasBasis p s ↔ ∀ t, t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t :=\n  ⟨fun ⟨h⟩ => h, fun h => ⟨h⟩⟩\n\n"}
{"name":"Filter.HasBasis.ex_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Exists fun i => p i","decl":"theorem HasBasis.ex_mem (h : l.HasBasis p s) : ∃ i, p i :=\n  (h.mem_iff.mp univ_mem).imp fun _ => And.left\n\n"}
{"name":"Filter.HasBasis.nonempty","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Nonempty ι","decl":"protected theorem HasBasis.nonempty (h : l.HasBasis p s) : Nonempty ι :=\n  nonempty_of_exists h.ex_mem\n\n"}
{"name":"Filter.IsBasis.hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nh : Filter.IsBasis p s\n⊢ h.filter.HasBasis p s","decl":"protected theorem IsBasis.hasBasis (h : IsBasis p s) : HasBasis h.filter p s :=\n  ⟨fun t => by simp only [h.mem_filter_iff, exists_prop]⟩\n\n"}
{"name":"Filter.HasBasis.mem_of_superset","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nt : Set α\ni : ι\nhl : l.HasBasis p s\nhi : p i\nht : HasSubset.Subset (s i) t\n⊢ Membership.mem l t","decl":"protected theorem HasBasis.mem_of_superset (hl : l.HasBasis p s) (hi : p i) (ht : s i ⊆ t) :\n    t ∈ l :=\n  hl.mem_iff.2 ⟨i, hi, ht⟩\n\n"}
{"name":"Filter.HasBasis.mem_of_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\ni : ι\nhl : l.HasBasis p s\nhi : p i\n⊢ Membership.mem l (s i)","decl":"theorem HasBasis.mem_of_mem (hl : l.HasBasis p s) (hi : p i) : s i ∈ l :=\n  hl.mem_of_superset hi Subset.rfl\n\n"}
{"name":"Filter.HasBasis.property_index","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nt : Set α\nh : l.HasBasis p s\nht : Membership.mem l t\n⊢ p ↑(h.index t ht)","decl":"theorem HasBasis.property_index (h : l.HasBasis p s) (ht : t ∈ l) : p (h.index t ht) :=\n  (h.index t ht).2\n\n"}
{"name":"Filter.HasBasis.set_index_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nt : Set α\nh : l.HasBasis p s\nht : Membership.mem l t\n⊢ Membership.mem l (s ↑(h.index t ht))","decl":"theorem HasBasis.set_index_mem (h : l.HasBasis p s) (ht : t ∈ l) : s (h.index t ht) ∈ l :=\n  h.mem_of_mem <| h.property_index _\n\n"}
{"name":"Filter.HasBasis.set_index_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nt : Set α\nh : l.HasBasis p s\nht : Membership.mem l t\n⊢ HasSubset.Subset (s ↑(h.index t ht)) t","decl":"theorem HasBasis.set_index_subset (h : l.HasBasis p s) (ht : t ∈ l) : s (h.index t ht) ⊆ t :=\n  (h.mem_iff.1 ht).choose_spec.2\n\n"}
{"name":"Filter.HasBasis.isBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Filter.IsBasis p s","decl":"theorem HasBasis.isBasis (h : l.HasBasis p s) : IsBasis p s where\n  nonempty := h.ex_mem\n  inter hi hj := by\n    simpa only [h.mem_iff] using inter_mem (h.mem_of_mem hi) (h.mem_of_mem hj)\n\n"}
{"name":"Filter.HasBasis.filter_eq","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Eq ⋯.filter l","decl":"theorem HasBasis.filter_eq (h : l.HasBasis p s) : h.isBasis.filter = l := by\n  ext U\n  simp [h.mem_iff, IsBasis.mem_filter_iff]\n\n"}
{"name":"Filter.HasBasis.eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Eq l (Filter.generate (setOf fun U => Exists fun i => And (p i) (Eq (s i) U)))","decl":"theorem HasBasis.eq_generate (h : l.HasBasis p s) : l = generate { U | ∃ i, p i ∧ s i = U } := by\n  rw [← h.isBasis.filter_eq_generate, h.filter_eq]\n\n"}
{"name":"Filter.generate_eq_generate_inter","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq (Filter.generate s) (Filter.generate (Set.image Set.sInter (setOf fun t => And t.Finite (HasSubset.Subset t s))))","decl":"theorem generate_eq_generate_inter (s : Set (Set α)) :\n    generate s = generate (sInter '' { t | Set.Finite t ∧ t ⊆ s }) := by\n  rw [← FilterBasis.ofSets_sets, FilterBasis.generate, ← (hasBasis_generate s).filter_eq]; rfl\n\n"}
{"name":"Filter.ofSets_filter_eq_generate","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq (Filter.FilterBasis.ofSets s).filter (Filter.generate s)","decl":"theorem ofSets_filter_eq_generate (s : Set (Set α)) :\n    (FilterBasis.ofSets s).filter = generate s := by\n  rw [← (FilterBasis.ofSets s).generate, FilterBasis.ofSets_sets, ← generate_eq_generate_inter]\n\n"}
{"name":"FilterBasis.hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nB : FilterBasis α\n⊢ B.filter.HasBasis (fun s => Membership.mem B s) id","decl":"protected theorem _root_.FilterBasis.hasBasis (B : FilterBasis α) :\n    HasBasis B.filter (fun s : Set α => s ∈ B) id :=\n  ⟨fun _ => B.mem_filter_iff⟩\n\n"}
{"name":"Filter.HasBasis.to_hasBasis'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nh : ∀ (i : ι), p i → Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : ∀ (i' : ι'), p' i' → Membership.mem l (s' i')\n⊢ l.HasBasis p' s'","decl":"theorem HasBasis.to_hasBasis' (hl : l.HasBasis p s) (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i)\n    (h' : ∀ i', p' i' → s' i' ∈ l) : l.HasBasis p' s' := by\n  refine ⟨fun t => ⟨fun ht => ?_, fun ⟨i', hi', ht⟩ => mem_of_superset (h' i' hi') ht⟩⟩\n  rcases hl.mem_iff.1 ht with ⟨i, hi, ht⟩\n  rcases h i hi with ⟨i', hi', hs's⟩\n  exact ⟨i', hi', hs's.trans ht⟩\n\n"}
{"name":"Filter.HasBasis.to_hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nh : ∀ (i : ι), p i → Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : ∀ (i' : ι'), p' i' → Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i'))\n⊢ l.HasBasis p' s'","decl":"theorem HasBasis.to_hasBasis (hl : l.HasBasis p s) (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i)\n    (h' : ∀ i', p' i' → ∃ i, p i ∧ s i ⊆ s' i') : l.HasBasis p' s' :=\n  hl.to_hasBasis' h fun i' hi' =>\n    let ⟨i, hi, hss'⟩ := h' i' hi'\n    hl.mem_iff.2 ⟨i, hi, hss'⟩\n\n"}
{"name":"Filter.HasBasis.congr","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\np' : ι → Prop\ns' : ι → Set α\nhp : ∀ (i : ι), Iff (p i) (p' i)\nhs : ∀ (i : ι), p i → Eq (s i) (s' i)\n⊢ l.HasBasis p' s'","decl":"protected lemma HasBasis.congr (hl : l.HasBasis p s) {p' s'} (hp : ∀ i, p i ↔ p' i)\n    (hs : ∀ i, p i → s i = s' i) : l.HasBasis p' s' :=\n  ⟨fun t ↦ by simp only [hl.mem_iff, ← hp]; exact exists_congr fun i ↦\n    and_congr_right fun hi ↦ hs i hi ▸ Iff.rfl⟩\n\n"}
{"name":"Filter.HasBasis.to_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nt : ι → Set α\nh : ∀ (i : ι), p i → HasSubset.Subset (t i) (s i)\nht : ∀ (i : ι), p i → Membership.mem l (t i)\n⊢ l.HasBasis p t","decl":"theorem HasBasis.to_subset (hl : l.HasBasis p s) {t : ι → Set α} (h : ∀ i, p i → t i ⊆ s i)\n    (ht : ∀ i, p i → t i ∈ l) : l.HasBasis p t :=\n  hl.to_hasBasis' (fun i hi => ⟨i, hi, h i hi⟩) ht\n\n"}
{"name":"Filter.HasBasis.eventually_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nq : α → Prop\n⊢ Iff (Filter.Eventually (fun x => q x) l) (Exists fun i => And (p i) (∀ ⦃x : α⦄, Membership.mem (s i) x → q x))","decl":"theorem HasBasis.eventually_iff (hl : l.HasBasis p s) {q : α → Prop} :\n    (∀ᶠ x in l, q x) ↔ ∃ i, p i ∧ ∀ ⦃x⦄, x ∈ s i → q x := by simpa using hl.mem_iff\n\n"}
{"name":"Filter.HasBasis.frequently_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nq : α → Prop\n⊢ Iff (Filter.Frequently (fun x => q x) l) (∀ (i : ι), p i → Exists fun x => And (Membership.mem (s i) x) (q x))","decl":"theorem HasBasis.frequently_iff (hl : l.HasBasis p s) {q : α → Prop} :\n    (∃ᶠ x in l, q x) ↔ ∀ i, p i → ∃ x ∈ s i, q x := by\n  simp only [Filter.Frequently, hl.eventually_iff]; push_neg; rfl\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.exists_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nP : Set α → Prop\nmono : ∀ ⦃s t : Set α⦄, HasSubset.Subset s t → P t → P s\n⊢ Iff (Exists fun s => And (Membership.mem l s) (P s)) (Exists fun i => And (p i) (P (s i)))","decl":"theorem HasBasis.exists_iff (hl : l.HasBasis p s) {P : Set α → Prop}\n    (mono : ∀ ⦃s t⦄, s ⊆ t → P t → P s) : (∃ s ∈ l, P s) ↔ ∃ i, p i ∧ P (s i) :=\n  ⟨fun ⟨_s, hs, hP⟩ =>\n    let ⟨i, hi, his⟩ := hl.mem_iff.1 hs\n    ⟨i, hi, mono his hP⟩,\n    fun ⟨i, hi, hP⟩ => ⟨s i, hl.mem_of_mem hi, hP⟩⟩\n\n"}
{"name":"Filter.HasBasis.forall_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nP : Set α → Prop\nmono : ∀ ⦃s t : Set α⦄, HasSubset.Subset s t → P s → P t\n⊢ Iff (∀ (s : Set α), Membership.mem l s → P s) (∀ (i : ι), p i → P (s i))","decl":"theorem HasBasis.forall_iff (hl : l.HasBasis p s) {P : Set α → Prop}\n    (mono : ∀ ⦃s t⦄, s ⊆ t → P s → P t) : (∀ s ∈ l, P s) ↔ ∀ i, p i → P (s i) :=\n  ⟨fun H i hi => H (s i) <| hl.mem_of_mem hi, fun H _s hs =>\n    let ⟨i, hi, his⟩ := hl.mem_iff.1 hs\n    mono his (H i hi)⟩\n\n"}
{"name":"Filter.HasBasis.neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\n⊢ Iff l.NeBot (∀ {i : ι}, p i → (s i).Nonempty)","decl":"protected theorem HasBasis.neBot_iff (hl : l.HasBasis p s) :\n    NeBot l ↔ ∀ {i}, p i → (s i).Nonempty :=\n  forall_mem_nonempty_iff_neBot.symm.trans <| hl.forall_iff fun _ _ => Nonempty.mono\n\n"}
{"name":"Filter.HasBasis.eq_bot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\n⊢ Iff (Eq l Bot.bot) (Exists fun i => And (p i) (Eq (s i) EmptyCollection.emptyCollection))","decl":"theorem HasBasis.eq_bot_iff (hl : l.HasBasis p s) : l = ⊥ ↔ ∃ i, p i ∧ s i = ∅ :=\n  not_iff_not.1 <| neBot_iff.symm.trans <|\n    hl.neBot_iff.trans <| by simp only [not_exists, not_and, nonempty_iff_ne_empty]\n\n"}
{"name":"Filter.generate_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Iff (Filter.generate s).NeBot (∀ (t : Set (Set α)), HasSubset.Subset t s → t.Finite → t.sInter.Nonempty)","decl":"theorem generate_neBot_iff {s : Set (Set α)} :\n    NeBot (generate s) ↔ ∀ t, t ⊆ s → t.Finite → (⋂₀ t).Nonempty :=\n  (hasBasis_generate s).neBot_iff.trans <| by simp only [← and_imp, and_comm]\n\n"}
{"name":"Filter.basis_sets","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl : Filter α\n⊢ l.HasBasis (fun s => Membership.mem l s) id","decl":"theorem basis_sets (l : Filter α) : l.HasBasis (fun s : Set α => s ∈ l) id :=\n  ⟨fun _ => exists_mem_subset_iff.symm⟩\n\n"}
{"name":"Filter.asBasis_filter","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Eq f.asBasis.filter f","decl":"theorem asBasis_filter (f : Filter α) : f.asBasis.filter = f :=\n  Filter.ext fun _ => exists_mem_subset_iff\n\n"}
{"name":"Filter.hasBasis_self","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl : Filter α\nP : Set α → Prop\n⊢ Iff (l.HasBasis (fun s => And (Membership.mem l s) (P s)) id) (∀ (t : Set α), Membership.mem l t → Exists fun r => And (Membership.mem l r) (And (P r) (HasSubset.Subset r t)))","decl":"theorem hasBasis_self {l : Filter α} {P : Set α → Prop} :\n    HasBasis l (fun s => s ∈ l ∧ P s) id ↔ ∀ t ∈ l, ∃ r ∈ l, P r ∧ r ⊆ t := by\n  simp only [hasBasis_iff, id, and_assoc]\n  exact forall_congr' fun s =>\n    ⟨fun h => h.1, fun h => ⟨h, fun ⟨t, hl, _, hts⟩ => mem_of_superset hl hts⟩⟩\n\n"}
{"name":"Filter.HasBasis.comp_surjective","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\ng : ι' → ι\nhg : Function.Surjective g\n⊢ l.HasBasis (Function.comp p g) (Function.comp s g)","decl":"theorem HasBasis.comp_surjective (h : l.HasBasis p s) {g : ι' → ι} (hg : Function.Surjective g) :\n    l.HasBasis (p ∘ g) (s ∘ g) :=\n  ⟨fun _ => h.mem_iff.trans hg.exists⟩\n\n"}
{"name":"Filter.HasBasis.comp_equiv","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\ne : Equiv ι' ι\n⊢ l.HasBasis (Function.comp p ⇑e) (Function.comp s ⇑e)","decl":"theorem HasBasis.comp_equiv (h : l.HasBasis p s) (e : ι' ≃ ι) : l.HasBasis (p ∘ e) (s ∘ e) :=\n  h.comp_surjective e.surjective\n\n"}
{"name":"Filter.HasBasis.to_image_id'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ l.HasBasis (fun t => Exists fun i => And (p i) (Eq (s i) t)) id","decl":"theorem HasBasis.to_image_id' (h : l.HasBasis p s) : l.HasBasis (fun t ↦ ∃ i, p i ∧ s i = t) id :=\n  ⟨fun _ ↦ by simp [h.mem_iff]⟩\n\n"}
{"name":"Filter.HasBasis.to_image_id","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_6\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ l.HasBasis (fun x => Membership.mem (Set.image s (setOf fun i => p i)) x) id","decl":"theorem HasBasis.to_image_id {ι : Type*} {p : ι → Prop} {s : ι → Set α} (h : l.HasBasis p s) :\n    l.HasBasis (· ∈ s '' {i | p i}) id :=\n  h.to_image_id'\n\n"}
{"name":"Filter.HasBasis.restrict","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\nq : ι → Prop\nhq : ∀ (i : ι), p i → Exists fun j => And (p j) (And (q j) (HasSubset.Subset (s j) (s i)))\n⊢ l.HasBasis (fun i => And (p i) (q i)) s","decl":"/-- If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that\n`p j ∧ q j`, then `{s j | p j ∧ q j}` is a basis of `l`. -/\ntheorem HasBasis.restrict (h : l.HasBasis p s) {q : ι → Prop}\n    (hq : ∀ i, p i → ∃ j, p j ∧ q j ∧ s j ⊆ s i) : l.HasBasis (fun i => p i ∧ q i) s := by\n  refine ⟨fun t => ⟨fun ht => ?_, fun ⟨i, hpi, hti⟩ => h.mem_iff.2 ⟨i, hpi.1, hti⟩⟩⟩\n  rcases h.mem_iff.1 ht with ⟨i, hpi, hti⟩\n  rcases hq i hpi with ⟨j, hpj, hqj, hji⟩\n  exact ⟨j, ⟨hpj, hqj⟩, hji.trans hti⟩\n\n"}
{"name":"Filter.HasBasis.restrict_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\nV : Set α\nhV : Membership.mem l V\n⊢ l.HasBasis (fun i => And (p i) (HasSubset.Subset (s i) V)) s","decl":"/-- If `{s i | p i}` is a basis of a filter `l` and `V ∈ l`, then `{s i | p i ∧ s i ⊆ V}`\nis a basis of `l`. -/\ntheorem HasBasis.restrict_subset (h : l.HasBasis p s) {V : Set α} (hV : V ∈ l) :\n    l.HasBasis (fun i => p i ∧ s i ⊆ V) s :=\n  h.restrict fun _i hi => (h.mem_iff.1 (inter_mem hV (h.mem_of_mem hi))).imp fun _j hj =>\n    ⟨hj.1, subset_inter_iff.1 hj.2⟩\n\n"}
{"name":"Filter.HasBasis.hasBasis_self_subset","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl : Filter α\np : Set α → Prop\nh : l.HasBasis (fun s => And (Membership.mem l s) (p s)) id\nV : Set α\nhV : Membership.mem l V\n⊢ l.HasBasis (fun s => And (Membership.mem l s) (And (p s) (HasSubset.Subset s V))) id","decl":"theorem HasBasis.hasBasis_self_subset {p : Set α → Prop} (h : l.HasBasis (fun s => s ∈ l ∧ p s) id)\n    {V : Set α} (hV : V ∈ l) : l.HasBasis (fun s => s ∈ l ∧ p s ∧ s ⊆ V) id := by\n  simpa only [and_assoc] using h.restrict_subset hV\n\n"}
{"name":"Filter.HasBasis.ge_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι' : Sort u_5\nl l' : Filter α\np' : ι' → Prop\ns' : ι' → Set α\nhl' : l'.HasBasis p' s'\n⊢ Iff (LE.le l l') (∀ (i' : ι'), p' i' → Membership.mem l (s' i'))","decl":"theorem HasBasis.ge_iff (hl' : l'.HasBasis p' s') : l ≤ l' ↔ ∀ i', p' i' → s' i' ∈ l :=\n  ⟨fun h _i' hi' => h <| hl'.mem_of_mem hi', fun h _s hs =>\n    let ⟨_i', hi', hs⟩ := hl'.mem_iff.1 hs\n    mem_of_superset (h _ hi') hs⟩\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.le_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\n⊢ Iff (LE.le l l') (∀ (t : Set α), Membership.mem l' t → Exists fun i => And (p i) (HasSubset.Subset (s i) t))","decl":"theorem HasBasis.le_iff (hl : l.HasBasis p s) : l ≤ l' ↔ ∀ t ∈ l', ∃ i, p i ∧ s i ⊆ t := by\n  simp only [le_def, hl.mem_iff]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.le_basis_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ Iff (LE.le l l') (∀ (i' : ι'), p' i' → Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i')))","decl":"theorem HasBasis.le_basis_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    l ≤ l' ↔ ∀ i', p' i' → ∃ i, p i ∧ s i ⊆ s' i' := by\n  simp only [hl'.ge_iff, hl.mem_iff]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.ext","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\nh : ∀ (i : ι), p i → Exists fun i' => And (p' i') (HasSubset.Subset (s' i') (s i))\nh' : ∀ (i' : ι'), p' i' → Exists fun i => And (p i) (HasSubset.Subset (s i) (s' i'))\n⊢ Eq l l'","decl":"theorem HasBasis.ext (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s')\n    (h : ∀ i, p i → ∃ i', p' i' ∧ s' i' ⊆ s i) (h' : ∀ i', p' i' → ∃ i, p i ∧ s i ⊆ s' i') :\n    l = l' := by\n  apply le_antisymm\n  · rw [hl.le_basis_iff hl']\n    simpa using h'\n  · rw [hl'.le_basis_iff hl]\n    simpa using h\n\n"}
{"name":"Filter.HasBasis.inf'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ (Min.min l l').HasBasis (fun i => And (p i.fst) (p' i.snd)) fun i => Inter.inter (s i.fst) (s' i.snd)","decl":"theorem HasBasis.inf' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l ⊓ l').HasBasis (fun i : PProd ι ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∩ s' i.2 :=\n  ⟨by\n    intro t\n    constructor\n    · simp only [mem_inf_iff, hl.mem_iff, hl'.mem_iff]\n      rintro ⟨t, ⟨i, hi, ht⟩, t', ⟨i', hi', ht'⟩, rfl⟩\n      exact ⟨⟨i, i'⟩, ⟨hi, hi'⟩, inter_subset_inter ht ht'⟩\n    · rintro ⟨⟨i, i'⟩, ⟨hi, hi'⟩, H⟩\n      exact mem_inf_of_inter (hl.mem_of_mem hi) (hl'.mem_of_mem hi') H⟩\n\n"}
{"name":"Filter.HasBasis.inf","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl l' : Filter α\nι : Type u_6\nι' : Type u_7\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ (Min.min l l').HasBasis (fun i => And (p i.1) (p' i.2)) fun i => Inter.inter (s i.1) (s' i.2)","decl":"theorem HasBasis.inf {ι ι' : Type*} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n    {s' : ι' → Set α} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l ⊓ l').HasBasis (fun i : ι × ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∩ s' i.2 :=\n  (hl.inf' hl').comp_equiv Equiv.pprodEquivProd.symm\n\n"}
{"name":"Filter.hasBasis_iInf'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : ι → Type u_7\nl : ι → Filter α\np : (i : ι) → ι' i → Prop\ns : (i : ι) → ι' i → Set α\nhl : ∀ (i : ι), (l i).HasBasis (p i) (s i)\n⊢ (iInf fun i => l i).HasBasis (fun If => And If.1.Finite (∀ (i : ι), Membership.mem If.1 i → p i (If.2 i))) fun If => Set.iInter fun i => Set.iInter fun h => s i (If.2 i)","decl":"theorem hasBasis_iInf' {ι : Type*} {ι' : ι → Type*} {l : ι → Filter α} {p : ∀ i, ι' i → Prop}\n    {s : ∀ i, ι' i → Set α} (hl : ∀ i, (l i).HasBasis (p i) (s i)) :\n    (⨅ i, l i).HasBasis (fun If : Set ι × ∀ i, ι' i => If.1.Finite ∧ ∀ i ∈ If.1, p i (If.2 i))\n      fun If : Set ι × ∀ i, ι' i => ⋂ i ∈ If.1, s i (If.2 i) :=\n  ⟨by\n    intro t\n    constructor\n    · simp only [mem_iInf', (hl _).mem_iff]\n      rintro ⟨I, hI, V, hV, -, rfl, -⟩\n      choose u hu using hV\n      exact ⟨⟨I, u⟩, ⟨hI, fun i _ => (hu i).1⟩, iInter₂_mono fun i _ => (hu i).2⟩\n    · rintro ⟨⟨I, f⟩, ⟨hI₁, hI₂⟩, hsub⟩\n      refine mem_of_superset ?_ hsub\n      exact (biInter_mem hI₁).mpr fun i hi => mem_iInf_of_mem i <| (hl i).mem_of_mem <| hI₂ _ hi⟩\n\n"}
{"name":"Filter.hasBasis_iInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : ι → Type u_7\nl : ι → Filter α\np : (i : ι) → ι' i → Prop\ns : (i : ι) → ι' i → Set α\nhl : ∀ (i : ι), (l i).HasBasis (p i) (s i)\n⊢ (iInf fun i => l i).HasBasis (fun If => And If.fst.Finite (∀ (i : ↑If.fst), p (↑i) (If.snd i))) fun If => Set.iInter fun i => s (↑i) (If.snd i)","decl":"theorem hasBasis_iInf {ι : Type*} {ι' : ι → Type*} {l : ι → Filter α} {p : ∀ i, ι' i → Prop}\n    {s : ∀ i, ι' i → Set α} (hl : ∀ i, (l i).HasBasis (p i) (s i)) :\n    (⨅ i, l i).HasBasis\n      (fun If : Σ I : Set ι, ∀ i : I, ι' i => If.1.Finite ∧ ∀ i : If.1, p i (If.2 i)) fun If =>\n      ⋂ i : If.1, s i (If.2 i) := by\n  refine ⟨fun t => ⟨fun ht => ?_, ?_⟩⟩\n  · rcases (hasBasis_iInf' hl).mem_iff.mp ht with ⟨⟨I, f⟩, ⟨hI, hf⟩, hsub⟩\n    exact ⟨⟨I, fun i => f i⟩, ⟨hI, Subtype.forall.mpr hf⟩, trans (iInter_subtype _ _) hsub⟩\n  · rintro ⟨⟨I, f⟩, ⟨hI, hf⟩, hsub⟩\n    refine mem_of_superset ?_ hsub\n    cases hI.nonempty_fintype\n    exact iInter_mem.2 fun i => mem_iInf_of_mem ↑i <| (hl i).mem_of_mem <| hf _\n\n"}
{"name":"Filter.hasBasis_iInf_of_directed'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : ι → Type u_7\ninst✝ : Nonempty ι\nl : ι → Filter α\ns : (i : ι) → ι' i → Set α\np : (i : ι) → ι' i → Prop\nhl : ∀ (i : ι), (l i).HasBasis (p i) (s i)\nh : Directed (fun x1 x2 => GE.ge x1 x2) l\n⊢ (iInf fun i => l i).HasBasis (fun ii' => p ii'.fst ii'.snd) fun ii' => s ii'.fst ii'.snd","decl":"theorem hasBasis_iInf_of_directed' {ι : Type*} {ι' : ι → Sort _} [Nonempty ι] {l : ι → Filter α}\n    (s : ∀ i, ι' i → Set α) (p : ∀ i, ι' i → Prop) (hl : ∀ i, (l i).HasBasis (p i) (s i))\n    (h : Directed (· ≥ ·) l) :\n    (⨅ i, l i).HasBasis (fun ii' : Σi, ι' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by\n  refine ⟨fun t => ?_⟩\n  rw [mem_iInf_of_directed h, Sigma.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n\n"}
{"name":"Filter.hasBasis_iInf_of_directed","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : Type u_7\ninst✝ : Nonempty ι\nl : ι → Filter α\ns : ι → ι' → Set α\np : ι → ι' → Prop\nhl : ∀ (i : ι), (l i).HasBasis (p i) (s i)\nh : Directed (fun x1 x2 => GE.ge x1 x2) l\n⊢ (iInf fun i => l i).HasBasis (fun ii' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2","decl":"theorem hasBasis_iInf_of_directed {ι : Type*} {ι' : Sort _} [Nonempty ι] {l : ι → Filter α}\n    (s : ι → ι' → Set α) (p : ι → ι' → Prop) (hl : ∀ i, (l i).HasBasis (p i) (s i))\n    (h : Directed (· ≥ ·) l) :\n    (⨅ i, l i).HasBasis (fun ii' : ι × ι' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2 := by\n  refine ⟨fun t => ?_⟩\n  rw [mem_iInf_of_directed h, Prod.exists]\n  exact exists_congr fun i => (hl i).mem_iff\n\n"}
{"name":"Filter.hasBasis_biInf_of_directed'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : ι → Type u_7\ndom : Set ι\nhdom : dom.Nonempty\nl : ι → Filter α\ns : (i : ι) → ι' i → Set α\np : (i : ι) → ι' i → Prop\nhl : ∀ (i : ι), Membership.mem dom i → (l i).HasBasis (p i) (s i)\nh : DirectedOn (Order.Preimage l GE.ge) dom\n⊢ (iInf fun i => iInf fun h => l i).HasBasis (fun ii' => And (Membership.mem dom ii'.fst) (p ii'.fst ii'.snd)) fun ii' => s ii'.fst ii'.snd","decl":"theorem hasBasis_biInf_of_directed' {ι : Type*} {ι' : ι → Sort _} {dom : Set ι}\n    (hdom : dom.Nonempty) {l : ι → Filter α} (s : ∀ i, ι' i → Set α) (p : ∀ i, ι' i → Prop)\n    (hl : ∀ i ∈ dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l ⁻¹'o GE.ge) dom) :\n    (⨅ i ∈ dom, l i).HasBasis (fun ii' : Σi, ι' i => ii'.1 ∈ dom ∧ p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2 := by\n  refine ⟨fun t => ?_⟩\n  rw [mem_biInf_of_directed h hdom, Sigma.exists]\n  refine exists_congr fun i => ⟨?_, ?_⟩\n  · rintro ⟨hi, hti⟩\n    rcases (hl i hi).mem_iff.mp hti with ⟨b, hb, hbt⟩\n    exact ⟨b, ⟨hi, hb⟩, hbt⟩\n  · rintro ⟨b, ⟨hi, hb⟩, hibt⟩\n    exact ⟨hi, (hl i hi).mem_iff.mpr ⟨b, hb, hibt⟩⟩\n\n"}
{"name":"Filter.hasBasis_biInf_of_directed","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\nι' : Type u_7\ndom : Set ι\nhdom : dom.Nonempty\nl : ι → Filter α\ns : ι → ι' → Set α\np : ι → ι' → Prop\nhl : ∀ (i : ι), Membership.mem dom i → (l i).HasBasis (p i) (s i)\nh : DirectedOn (Order.Preimage l GE.ge) dom\n⊢ (iInf fun i => iInf fun h => l i).HasBasis (fun ii' => And (Membership.mem dom ii'.1) (p ii'.1 ii'.2)) fun ii' => s ii'.1 ii'.2","decl":"theorem hasBasis_biInf_of_directed {ι : Type*} {ι' : Sort _} {dom : Set ι} (hdom : dom.Nonempty)\n    {l : ι → Filter α} (s : ι → ι' → Set α) (p : ι → ι' → Prop)\n    (hl : ∀ i ∈ dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l ⁻¹'o GE.ge) dom) :\n    (⨅ i ∈ dom, l i).HasBasis (fun ii' : ι × ι' => ii'.1 ∈ dom ∧ p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2 := by\n  refine ⟨fun t => ?_⟩\n  rw [mem_biInf_of_directed h hdom, Prod.exists]\n  refine exists_congr fun i => ⟨?_, ?_⟩\n  · rintro ⟨hi, hti⟩\n    rcases (hl i hi).mem_iff.mp hti with ⟨b, hb, hbt⟩\n    exact ⟨b, ⟨hi, hb⟩, hbt⟩\n  · rintro ⟨b, ⟨hi, hb⟩, hibt⟩\n    exact ⟨hi, (hl i hi).mem_iff.mpr ⟨b, hb, hibt⟩⟩\n\n"}
{"name":"Filter.hasBasis_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nt : Set α\n⊢ (Filter.principal t).HasBasis (fun x => True) fun x => t","decl":"theorem hasBasis_principal (t : Set α) : (𝓟 t).HasBasis (fun _ : Unit => True) fun _ => t :=\n  ⟨fun U => by simp⟩\n\n"}
{"name":"Filter.hasBasis_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nx : α\n⊢ (Pure.pure x).HasBasis (fun x => True) fun x_1 => Singleton.singleton x","decl":"theorem hasBasis_pure (x : α) :\n    (pure x : Filter α).HasBasis (fun _ : Unit => True) fun _ => {x} := by\n  simp only [← principal_singleton, hasBasis_principal]\n\n"}
{"name":"Filter.HasBasis.sup'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ (Max.max l l').HasBasis (fun i => And (p i.fst) (p' i.snd)) fun i => Union.union (s i.fst) (s' i.snd)","decl":"theorem HasBasis.sup' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l ⊔ l').HasBasis (fun i : PProd ι ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∪ s' i.2 :=\n  ⟨by\n    intro t\n    simp_rw [mem_sup, hl.mem_iff, hl'.mem_iff, PProd.exists, union_subset_iff,\n       ← exists_and_right, ← exists_and_left]\n    simp only [and_assoc, and_left_comm]⟩\n\n"}
{"name":"Filter.HasBasis.sup","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl l' : Filter α\nι : Type u_6\nι' : Type u_7\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ (Max.max l l').HasBasis (fun i => And (p i.1) (p' i.2)) fun i => Union.union (s i.1) (s' i.2)","decl":"theorem HasBasis.sup {ι ι' : Type*} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n    {s' : ι' → Set α} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l ⊔ l').HasBasis (fun i : ι × ι' => p i.1 ∧ p' i.2) fun i => s i.1 ∪ s' i.2 :=\n  (hl.sup' hl').comp_equiv Equiv.pprodEquivProd.symm\n\n"}
{"name":"Filter.hasBasis_iSup","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_6\nι' : ι → Type u_7\nl : ι → Filter α\np : (i : ι) → ι' i → Prop\ns : (i : ι) → ι' i → Set α\nhl : ∀ (i : ι), (l i).HasBasis (p i) (s i)\n⊢ (iSup fun i => l i).HasBasis (fun f => ∀ (i : ι), p i (f i)) fun f => Set.iUnion fun i => s i (f i)","decl":"theorem hasBasis_iSup {ι : Sort*} {ι' : ι → Type*} {l : ι → Filter α} {p : ∀ i, ι' i → Prop}\n    {s : ∀ i, ι' i → Set α} (hl : ∀ i, (l i).HasBasis (p i) (s i)) :\n    (⨆ i, l i).HasBasis (fun f : ∀ i, ι' i => ∀ i, p i (f i)) fun f : ∀ i, ι' i => ⋃ i, s i (f i) :=\n  hasBasis_iff.mpr fun t => by\n    simp only [hasBasis_iff, (hl _).mem_iff, Classical.skolem, forall_and, iUnion_subset_iff,\n      mem_iSup]\n\n"}
{"name":"Filter.HasBasis.sup_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nt : Set α\n⊢ (Max.max l (Filter.principal t)).HasBasis p fun i => Union.union (s i) t","decl":"theorem HasBasis.sup_principal (hl : l.HasBasis p s) (t : Set α) :\n    (l ⊔ 𝓟 t).HasBasis p fun i => s i ∪ t :=\n  ⟨fun u => by\n    simp only [(hl.sup' (hasBasis_principal t)).mem_iff, PProd.exists, exists_prop, and_true,\n      Unique.exists_iff]⟩\n\n"}
{"name":"Filter.HasBasis.sup_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nx : α\n⊢ (Max.max l (Pure.pure x)).HasBasis p fun i => Union.union (s i) (Singleton.singleton x)","decl":"theorem HasBasis.sup_pure (hl : l.HasBasis p s) (x : α) :\n    (l ⊔ pure x).HasBasis p fun i => s i ∪ {x} := by\n  simp only [← principal_singleton, hl.sup_principal]\n\n"}
{"name":"Filter.HasBasis.inf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\ns' : Set α\n⊢ (Min.min l (Filter.principal s')).HasBasis p fun i => Inter.inter (s i) s'","decl":"theorem HasBasis.inf_principal (hl : l.HasBasis p s) (s' : Set α) :\n    (l ⊓ 𝓟 s').HasBasis p fun i => s i ∩ s' :=\n  ⟨fun t => by\n    simp only [mem_inf_principal, hl.mem_iff, subset_def, mem_setOf_eq, mem_inter_iff, and_imp]⟩\n\n"}
{"name":"Filter.HasBasis.principal_inf","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\ns' : Set α\n⊢ (Min.min (Filter.principal s') l).HasBasis p fun i => Inter.inter s' (s i)","decl":"theorem HasBasis.principal_inf (hl : l.HasBasis p s) (s' : Set α) :\n    (𝓟 s' ⊓ l).HasBasis p fun i => s' ∩ s i := by\n  simpa only [inf_comm, inter_comm] using hl.inf_principal s'\n\n"}
{"name":"Filter.HasBasis.inf_basis_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ Iff (Min.min l l').NeBot (∀ ⦃i : ι⦄, p i → ∀ ⦃i' : ι'⦄, p' i' → (Inter.inter (s i) (s' i')).Nonempty)","decl":"theorem HasBasis.inf_basis_neBot_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    NeBot (l ⊓ l') ↔ ∀ ⦃i⦄, p i → ∀ ⦃i'⦄, p' i' → (s i ∩ s' i').Nonempty :=\n  (hl.inf' hl').neBot_iff.trans <| by simp [@forall_swap _ ι']\n\n"}
{"name":"Filter.HasBasis.inf_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\n⊢ Iff (Min.min l l').NeBot (∀ ⦃i : ι⦄, p i → ∀ ⦃s' : Set α⦄, Membership.mem l' s' → (Inter.inter (s i) s').Nonempty)","decl":"theorem HasBasis.inf_neBot_iff (hl : l.HasBasis p s) :\n    NeBot (l ⊓ l') ↔ ∀ ⦃i⦄, p i → ∀ ⦃s'⦄, s' ∈ l' → (s i ∩ s').Nonempty :=\n  hl.inf_basis_neBot_iff l'.basis_sets\n\n"}
{"name":"Filter.HasBasis.inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nhl : l.HasBasis p s\nt : Set α\n⊢ Iff (Min.min l (Filter.principal t)).NeBot (∀ ⦃i : ι⦄, p i → (Inter.inter (s i) t).Nonempty)","decl":"theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set α} :\n    NeBot (l ⊓ 𝓟 t) ↔ ∀ ⦃i⦄, p i → (s i ∩ t).Nonempty :=\n  (hl.inf_principal t).neBot_iff\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ Iff (Disjoint l l') (Exists fun i => And (p i) (Exists fun i' => And (p' i') (Disjoint (s i) (s' i'))))","decl":"theorem HasBasis.disjoint_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    Disjoint l l' ↔ ∃ i, p i ∧ ∃ i', p' i' ∧ Disjoint (s i) (s' i') :=\n  not_iff_not.mp <| by simp only [_root_.disjoint_iff, ← Ne.eq_def, ← neBot_iff, inf_eq_inter,\n    hl.inf_basis_neBot_iff hl', not_exists, not_and, bot_eq_empty, ← nonempty_iff_ne_empty]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Disjoint.exists_mem_filter_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\np' : ι' → Prop\ns' : ι' → Set α\nh : Disjoint l l'\nhl : l.HasBasis p s\nhl' : l'.HasBasis p' s'\n⊢ Exists fun i => And (p i) (Exists fun i' => And (p' i') (Disjoint (s i) (s' i')))","decl":"theorem _root_.Disjoint.exists_mem_filter_basis (h : Disjoint l l') (hl : l.HasBasis p s)\n    (hl' : l'.HasBasis p' s') : ∃ i, p i ∧ ∃ i', p' i' ∧ Disjoint (s i) (s' i') :=\n  (hl.disjoint_iff hl').1 h\n\n"}
{"name":"Pairwise.exists_mem_filter_basis_of_disjoint","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nI : Type u_7\ninst✝ : Finite I\nl : I → Filter α\nι : I → Sort u_6\np : (i : I) → ι i → Prop\ns : (i : I) → ι i → Set α\nhd : Pairwise (Function.onFun Disjoint l)\nh : ∀ (i : I), (l i).HasBasis (p i) (s i)\n⊢ Exists fun ind => And (∀ (i : I), p i (ind i)) (Pairwise (Function.onFun Disjoint fun i => s i (ind i)))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem _root_.Pairwise.exists_mem_filter_basis_of_disjoint {I} [Finite I] {l : I → Filter α}\n    {ι : I → Sort*} {p : ∀ i, ι i → Prop} {s : ∀ i, ι i → Set α} (hd : Pairwise (Disjoint on l))\n    (h : ∀ i, (l i).HasBasis (p i) (s i)) :\n    ∃ ind : ∀ i, ι i, (∀ i, p i (ind i)) ∧ Pairwise (Disjoint on fun i => s i (ind i)) := by\n  rcases hd.exists_mem_filter_of_disjoint with ⟨t, htl, hd⟩\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact ⟨ind, hp, hd.mono fun i j hij => hij.mono (ht _) (ht _)⟩\n\n"}
{"name":"Set.PairwiseDisjoint.exists_mem_filter_basis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nI : Type u_6\nl : I → Filter α\nι : I → Sort u_7\np : (i : I) → ι i → Prop\ns : (i : I) → ι i → Set α\nS : Set I\nhd : S.PairwiseDisjoint l\nhS : S.Finite\nh : ∀ (i : I), (l i).HasBasis (p i) (s i)\n⊢ Exists fun ind => And (∀ (i : I), p i (ind i)) (S.PairwiseDisjoint fun i => s i (ind i))","decl":"theorem _root_.Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type*} {l : I → Filter α}\n    {ι : I → Sort*} {p : ∀ i, ι i → Prop} {s : ∀ i, ι i → Set α} {S : Set I}\n    (hd : S.PairwiseDisjoint l) (hS : S.Finite) (h : ∀ i, (l i).HasBasis (p i) (s i)) :\n    ∃ ind : ∀ i, ι i, (∀ i, p i (ind i)) ∧ S.PairwiseDisjoint fun i => s i (ind i) := by\n  rcases hd.exists_mem_filter hS with ⟨t, htl, hd⟩\n  choose ind hp ht using fun i => (h i).mem_iff.1 (htl i)\n  exact ⟨ind, hp, hd.mono ht⟩\n\n"}
{"name":"Filter.inf_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl l' : Filter α\n⊢ Iff (Min.min l l').NeBot (∀ ⦃s : Set α⦄, Membership.mem l s → ∀ ⦃s' : Set α⦄, Membership.mem l' s' → (Inter.inter s s').Nonempty)","decl":"theorem inf_neBot_iff :\n    NeBot (l ⊓ l') ↔ ∀ ⦃s : Set α⦄, s ∈ l → ∀ ⦃s'⦄, s' ∈ l' → (s ∩ s').Nonempty :=\n  l.basis_sets.inf_neBot_iff\n\n"}
{"name":"Filter.inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nl : Filter α\ns : Set α\n⊢ Iff (Min.min l (Filter.principal s)).NeBot (∀ (U : Set α), Membership.mem l U → (Inter.inter U s).Nonempty)","decl":"theorem inf_principal_neBot_iff {s : Set α} : NeBot (l ⊓ 𝓟 s) ↔ ∀ U ∈ l, (U ∩ s).Nonempty :=\n  l.basis_sets.inf_principal_neBot_iff\n\n"}
{"name":"Filter.mem_iff_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\n⊢ Iff (Membership.mem f s) (Eq (Min.min f (Filter.principal (HasCompl.compl s))) Bot.bot)","decl":"theorem mem_iff_inf_principal_compl {f : Filter α} {s : Set α} : s ∈ f ↔ f ⊓ 𝓟 sᶜ = ⊥ := by\n  refine not_iff_not.1 ((inf_principal_neBot_iff.trans ?_).symm.trans neBot_iff)\n  exact\n    ⟨fun h hs => by simpa [Set.not_nonempty_empty] using h s hs, fun hs t ht =>\n      inter_compl_nonempty_iff.2 fun hts => hs <| mem_of_superset ht hts⟩\n\n"}
{"name":"Filter.not_mem_iff_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\n⊢ Iff (Not (Membership.mem f s)) (Min.min f (Filter.principal (HasCompl.compl s))).NeBot","decl":"theorem not_mem_iff_inf_principal_compl {f : Filter α} {s : Set α} : s ∉ f ↔ NeBot (f ⊓ 𝓟 sᶜ) :=\n  (not_congr mem_iff_inf_principal_compl).trans neBot_iff.symm\n\n"}
{"name":"Filter.disjoint_principal_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\n⊢ Iff (Disjoint f (Filter.principal s)) (Membership.mem f (HasCompl.compl s))","decl":"@[simp]\ntheorem disjoint_principal_right {f : Filter α} {s : Set α} : Disjoint f (𝓟 s) ↔ sᶜ ∈ f := by\n  rw [mem_iff_inf_principal_compl, compl_compl, disjoint_iff]\n\n"}
{"name":"Filter.disjoint_principal_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\n⊢ Iff (Disjoint (Filter.principal s) f) (Membership.mem f (HasCompl.compl s))","decl":"@[simp]\ntheorem disjoint_principal_left {f : Filter α} {s : Set α} : Disjoint (𝓟 s) f ↔ sᶜ ∈ f := by\n  rw [disjoint_comm, disjoint_principal_right]\n\n"}
{"name":"Filter.disjoint_principal_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (Disjoint (Filter.principal s) (Filter.principal t)) (Disjoint s t)","decl":"@[simp 1100] -- Porting note: higher priority for linter\ntheorem disjoint_principal_principal {s t : Set α} : Disjoint (𝓟 s) (𝓟 t) ↔ Disjoint s t := by\n  rw [← subset_compl_iff_disjoint_left, disjoint_principal_left, mem_principal]\n\n"}
{"name":"Disjoint.filter_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\ns t : Set α\na✝ : Disjoint s t\n⊢ Disjoint (Filter.principal s) (Filter.principal t)","decl":"alias ⟨_, _root_.Disjoint.filter_principal⟩ := disjoint_principal_principal\n\n"}
{"name":"Filter.disjoint_pure_pure","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nx y : α\n⊢ Iff (Disjoint (Pure.pure x) (Pure.pure y)) (Ne x y)","decl":"@[simp]\ntheorem disjoint_pure_pure {x y : α} : Disjoint (pure x : Filter α) (pure y) ↔ x ≠ y := by\n  simp only [← principal_singleton, disjoint_principal_principal, disjoint_singleton]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Iff (Disjoint l l') (Exists fun i => And (p i) (Membership.mem l' (HasCompl.compl (s i))))","decl":"theorem HasBasis.disjoint_iff_left (h : l.HasBasis p s) :\n    Disjoint l l' ↔ ∃ i, p i ∧ (s i)ᶜ ∈ l' := by\n  simp only [h.disjoint_iff l'.basis_sets, id, ← disjoint_principal_left,\n    (hasBasis_principal _).disjoint_iff l'.basis_sets, true_and, Unique.exists_iff]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.disjoint_iff_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl l' : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Iff (Disjoint l' l) (Exists fun i => And (p i) (Membership.mem l' (HasCompl.compl (s i))))","decl":"theorem HasBasis.disjoint_iff_right (h : l.HasBasis p s) :\n    Disjoint l' l ↔ ∃ i, p i ∧ (s i)ᶜ ∈ l' :=\n  disjoint_comm.trans h.disjoint_iff_left\n\n"}
{"name":"Filter.le_iff_forall_inf_principal_compl","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf g : Filter α\n⊢ Iff (LE.le f g) (∀ (V : Set α), Membership.mem g V → Eq (Min.min f (Filter.principal (HasCompl.compl V))) Bot.bot)","decl":"theorem le_iff_forall_inf_principal_compl {f g : Filter α} : f ≤ g ↔ ∀ V ∈ g, f ⊓ 𝓟 Vᶜ = ⊥ :=\n  forall₂_congr fun _ _ => mem_iff_inf_principal_compl\n\n"}
{"name":"Filter.inf_neBot_iff_frequently_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf g : Filter α\n⊢ Iff (Min.min f g).NeBot (∀ {p : α → Prop}, Filter.Eventually (fun x => p x) f → Filter.Frequently (fun x => p x) g)","decl":"theorem inf_neBot_iff_frequently_left {f g : Filter α} :\n    NeBot (f ⊓ g) ↔ ∀ {p : α → Prop}, (∀ᶠ x in f, p x) → ∃ᶠ x in g, p x := by\n  simp only [inf_neBot_iff, frequently_iff, and_comm]; rfl\n\n"}
{"name":"Filter.inf_neBot_iff_frequently_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nf g : Filter α\n⊢ Iff (Min.min f g).NeBot (∀ {p : α → Prop}, Filter.Eventually (fun x => p x) g → Filter.Frequently (fun x => p x) f)","decl":"theorem inf_neBot_iff_frequently_right {f g : Filter α} :\n    NeBot (f ⊓ g) ↔ ∀ {p : α → Prop}, (∀ᶠ x in g, p x) → ∃ᶠ x in f, p x := by\n  rw [inf_comm]\n  exact inf_neBot_iff_frequently_left\n\n"}
{"name":"Filter.HasBasis.eq_biInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Eq l (iInf fun i => iInf fun x => Filter.principal (s i))","decl":"theorem HasBasis.eq_biInf (h : l.HasBasis p s) : l = ⨅ (i) (_ : p i), 𝓟 (s i) :=\n  eq_biInf_of_mem_iff_exists_mem fun {_} => by simp only [h.mem_iff, mem_principal, exists_prop]\n\n"}
{"name":"Filter.HasBasis.eq_iInf","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\ns : ι → Set α\nh : l.HasBasis (fun x => True) s\n⊢ Eq l (iInf fun i => Filter.principal (s i))","decl":"theorem HasBasis.eq_iInf (h : l.HasBasis (fun _ => True) s) : l = ⨅ i, 𝓟 (s i) := by\n  simpa only [iInf_true] using h.eq_biInf\n\n"}
{"name":"Filter.hasBasis_iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\ns : ι → Set α\nh : Directed (fun x1 x2 => GE.ge x1 x2) s\ninst✝ : Nonempty ι\n⊢ (iInf fun i => Filter.principal (s i)).HasBasis (fun x => True) s","decl":"theorem hasBasis_iInf_principal {s : ι → Set α} (h : Directed (· ≥ ·) s) [Nonempty ι] :\n    (⨅ i, 𝓟 (s i)).HasBasis (fun _ => True) s :=\n  ⟨fun t => by\n    simpa only [true_and] using mem_iInf_of_directed (h.mono_comp _ monotone_principal.dual) t⟩\n\n"}
{"name":"Filter.hasBasis_iInf_principal_finite","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\ns : ι → Set α\n⊢ (iInf fun i => Filter.principal (s i)).HasBasis (fun t => t.Finite) fun t => Set.iInter fun i => Set.iInter fun h => s i","decl":"/-- If `s : ι → Set α` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `⨅ i, 𝓟 (s i)`. -/\ntheorem hasBasis_iInf_principal_finite {ι : Type*} (s : ι → Set α) :\n    (⨅ i, 𝓟 (s i)).HasBasis (fun t : Set ι => t.Finite) fun t => ⋂ i ∈ t, s i := by\n  refine ⟨fun U => (mem_iInf_finite _).trans ?_⟩\n  simp only [iInf_principal_finset, mem_iUnion, mem_principal, exists_prop,\n    exists_finite_iff_finset, Finset.set_biInter_coe]\n\n"}
{"name":"Filter.hasBasis_biInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\ns : β → Set α\nS : Set β\nh : DirectedOn (Order.Preimage s fun x1 x2 => GE.ge x1 x2) S\nne : S.Nonempty\n⊢ (iInf fun i => iInf fun h => Filter.principal (s i)).HasBasis (fun i => Membership.mem S i) s","decl":"theorem hasBasis_biInf_principal {s : β → Set α} {S : Set β} (h : DirectedOn (s ⁻¹'o (· ≥ ·)) S)\n    (ne : S.Nonempty) : (⨅ i ∈ S, 𝓟 (s i)).HasBasis (fun i => i ∈ S) s :=\n  ⟨fun t => by\n    refine mem_biInf_of_directed ?_ ne\n    rw [directedOn_iff_directed, ← directed_comp] at h ⊢\n    refine h.mono_comp _ ?_\n    exact fun _ _ => principal_mono.2⟩\n\n"}
{"name":"Filter.hasBasis_biInf_principal'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_6\np : ι → Prop\ns : ι → Set α\nh : ∀ (i : ι), p i → ∀ (j : ι), p j → Exists fun k => And (p k) (And (HasSubset.Subset (s k) (s i)) (HasSubset.Subset (s k) (s j)))\nne : Exists fun i => p i\n⊢ (iInf fun i => iInf fun x => Filter.principal (s i)).HasBasis p s","decl":"theorem hasBasis_biInf_principal' {ι : Type*} {p : ι → Prop} {s : ι → Set α}\n    (h : ∀ i, p i → ∀ j, p j → ∃ k, p k ∧ s k ⊆ s i ∧ s k ⊆ s j) (ne : ∃ i, p i) :\n    (⨅ (i) (_ : p i), 𝓟 (s i)).HasBasis p s :=\n  Filter.hasBasis_biInf_principal h ne\n\n"}
{"name":"Filter.HasBasis.map","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nf : α → β\nhl : l.HasBasis p s\n⊢ (Filter.map f l).HasBasis p fun i => Set.image f (s i)","decl":"theorem HasBasis.map (f : α → β) (hl : l.HasBasis p s) : (l.map f).HasBasis p fun i => f '' s i :=\n  ⟨fun t => by simp only [mem_map, image_subset_iff, hl.mem_iff, preimage]⟩\n\n"}
{"name":"Filter.HasBasis.comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nf : β → α\nhl : l.HasBasis p s\n⊢ (Filter.comap f l).HasBasis p fun i => Set.preimage f (s i)","decl":"theorem HasBasis.comap (f : β → α) (hl : l.HasBasis p s) :\n    (l.comap f).HasBasis p fun i => f ⁻¹' s i :=\n  ⟨fun t => by\n    simp only [mem_comap', hl.mem_iff]\n    refine exists_congr (fun i => Iff.rfl.and ?_)\n    exact ⟨fun h x hx => h hx rfl, fun h y hy x hx => h <| by rwa [mem_preimage, hx]⟩⟩\n\n"}
{"name":"Filter.comap_hasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Filter β\n⊢ (Filter.comap f l).HasBasis (fun s => Membership.mem l s) fun s => Set.preimage f s","decl":"theorem comap_hasBasis (f : α → β) (l : Filter β) :\n    HasBasis (comap f l) (fun s : Set β => s ∈ l) fun s => f ⁻¹' s :=\n  ⟨fun _ => mem_comap⟩\n\n"}
{"name":"Filter.HasBasis.forall_mem_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\nx : α\n⊢ Iff (∀ (t : Set α), Membership.mem l t → Membership.mem t x) (∀ (i : ι), p i → Membership.mem (s i) x)","decl":"theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : α} :\n    (∀ t ∈ l, x ∈ t) ↔ ∀ i, p i → x ∈ s i := by\n  simp only [h.mem_iff, exists_imp, and_imp]\n  exact ⟨fun h i hi => h (s i) i hi Subset.rfl, fun h t i hi ht => ht (h i hi)⟩\n\n"}
{"name":"Filter.HasBasis.biInf_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\ninst✝ : CompleteLattice β\nf : Set α → β\nh : l.HasBasis p s\nhf : Monotone f\n⊢ Eq (iInf fun t => iInf fun h => f t) (iInf fun i => iInf fun x => f (s i))","decl":"protected theorem HasBasis.biInf_mem [CompleteLattice β] {f : Set α → β} (h : HasBasis l p s)\n    (hf : Monotone f) : ⨅ t ∈ l, f t = ⨅ (i) (_ : p i), f (s i) :=\n  le_antisymm (le_iInf₂ fun i hi => iInf₂_le (s i) (h.mem_of_mem hi)) <|\n    le_iInf₂ fun _t ht =>\n      let ⟨i, hpi, hi⟩ := h.mem_iff.1 ht\n      iInf₂_le_of_le i hpi (hf hi)\n\n"}
{"name":"Filter.HasBasis.biInter_mem","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nf : Set α → Set β\nh : l.HasBasis p s\nhf : Monotone f\n⊢ Eq (Set.iInter fun t => Set.iInter fun h => f t) (Set.iInter fun i => Set.iInter fun x => f (s i))","decl":"protected theorem HasBasis.biInter_mem {f : Set α → Set β} (h : HasBasis l p s) (hf : Monotone f) :\n    ⋂ t ∈ l, f t = ⋂ (i) (_ : p i), f (s i) :=\n  h.biInf_mem hf\n\n"}
{"name":"Filter.HasBasis.ker","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Eq l.ker (Set.iInter fun i => Set.iInter fun x => s i)","decl":"protected theorem HasBasis.ker (h : HasBasis l p s) : l.ker = ⋂ (i) (_ : p i), s i :=\n  sInter_eq_biInter.trans <| h.biInter_mem monotone_id\n\n"}
{"name":"Filter.IsAntitoneBasis.toIsBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι'' : Type u_6\ninst✝ : Preorder ι''\ns'' : ι'' → Set α\nself : Filter.IsAntitoneBasis s''\n⊢ Filter.IsBasis (fun x => True) s''","decl":"/-- `IsAntitoneBasis s` means the image of `s` is a filter basis such that `s` is decreasing. -/\nstructure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s''\n\n"}
{"name":"Filter.IsAntitoneBasis.antitone","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι'' : Type u_6\ninst✝ : Preorder ι''\ns'' : ι'' → Set α\nself : Filter.IsAntitoneBasis s''\n⊢ Antitone s''","decl":"/-- `IsAntitoneBasis s` means the image of `s` is a filter basis such that `s` is decreasing. -/\nstructure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s''\n\n"}
{"name":"Filter.HasAntitoneBasis.antitone","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι'' : Type u_6\ninst✝ : Preorder ι''\nl : Filter α\ns : ι'' → Set α\nself : l.HasAntitoneBasis s\n⊢ Antitone s","decl":"/-- We say that a filter `l` has an antitone basis `s : ι → Set α`, if `t ∈ l` if and only if `t`\nincludes `s i` for some `i`, and `s` is decreasing. -/\nstructure HasAntitoneBasis (l : Filter α) (s : ι'' → Set α)\n    extends HasBasis l (fun _ => True) s : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s\n\n"}
{"name":"Filter.HasAntitoneBasis.toHasBasis","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι'' : Type u_6\ninst✝ : Preorder ι''\nl : Filter α\ns : ι'' → Set α\nself : l.HasAntitoneBasis s\n⊢ l.HasBasis (fun x => True) s","decl":"/-- We say that a filter `l` has an antitone basis `s : ι → Set α`, if `t ∈ l` if and only if `t`\nincludes `s i` for some `i`, and `s` is decreasing. -/\nstructure HasAntitoneBasis (l : Filter α) (s : ι'' → Set α)\n    extends HasBasis l (fun _ => True) s : Prop where\n  /-- The sequence of sets is antitone. -/\n  protected antitone : Antitone s\n\n"}
{"name":"Filter.HasAntitoneBasis.map","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι'' : Type u_6\ninst✝ : Preorder ι''\nl : Filter α\ns : ι'' → Set α\nhf : l.HasAntitoneBasis s\nm : α → β\n⊢ (Filter.map m l).HasAntitoneBasis fun x => Set.image m (s x)","decl":"protected theorem HasAntitoneBasis.map {l : Filter α} {s : ι'' → Set α}\n    (hf : HasAntitoneBasis l s) (m : α → β) : HasAntitoneBasis (map m l) (m '' s ·) :=\n  ⟨HasBasis.map _ hf.toHasBasis, fun _ _ h => image_subset _ <| hf.2 h⟩\n\n"}
{"name":"Filter.HasAntitoneBasis.comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι'' : Type u_6\ninst✝ : Preorder ι''\nl : Filter α\ns : ι'' → Set α\nhf : l.HasAntitoneBasis s\nm : β → α\n⊢ (Filter.comap m l).HasAntitoneBasis fun x => Set.preimage m (s x)","decl":"protected theorem HasAntitoneBasis.comap {l : Filter α} {s : ι'' → Set α}\n    (hf : HasAntitoneBasis l s) (m : β → α) : HasAntitoneBasis (comap m l) (m ⁻¹' s ·) :=\n  ⟨hf.1.comap _, fun _ _ h ↦ preimage_mono (hf.2 h)⟩\n\n"}
{"name":"Filter.HasAntitoneBasis.iInf_principal","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Type u_7\ninst✝² : Preorder ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ns : ι → Set α\nhs : Antitone s\n⊢ (iInf fun i => Filter.principal (s i)).HasAntitoneBasis s","decl":"lemma HasAntitoneBasis.iInf_principal {ι : Type*} [Preorder ι] [Nonempty ι] [IsDirected ι (· ≤ ·)]\n    {s : ι → Set α} (hs : Antitone s) : (⨅ i, 𝓟 (s i)).HasAntitoneBasis s :=\n  ⟨hasBasis_iInf_principal hs.directed_ge, hs⟩\n\n"}
{"name":"Filter.HasBasis.tendsto_left_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nlb : Filter β\nf : α → β\nhla : la.HasBasis pa sa\n⊢ Iff (Filter.Tendsto f la lb) (∀ (t : Set β), Membership.mem lb t → Exists fun i => And (pa i) (Set.MapsTo f (sa i) t))","decl":"theorem HasBasis.tendsto_left_iff (hla : la.HasBasis pa sa) :\n    Tendsto f la lb ↔ ∀ t ∈ lb, ∃ i, pa i ∧ MapsTo f (sa i) t := by\n  simp only [Tendsto, (hla.map f).le_iff, image_subset_iff]\n  rfl\n\n"}
{"name":"Filter.HasBasis.tendsto_right_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι' : Sort u_5\nla : Filter α\nlb : Filter β\npb : ι' → Prop\nsb : ι' → Set β\nf : α → β\nhlb : lb.HasBasis pb sb\n⊢ Iff (Filter.Tendsto f la lb) (∀ (i : ι'), pb i → Filter.Eventually (fun x => Membership.mem (sb i) (f x)) la)","decl":"theorem HasBasis.tendsto_right_iff (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb ↔ ∀ i, pb i → ∀ᶠ x in la, f x ∈ sb i := by\n  simp only [Tendsto, hlb.ge_iff, mem_map', Filter.Eventually]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.HasBasis.tendsto_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nι' : Sort u_5\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nlb : Filter β\npb : ι' → Prop\nsb : ι' → Set β\nf : α → β\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\n⊢ Iff (Filter.Tendsto f la lb) (∀ (ib : ι'), pb ib → Exists fun ia => And (pa ia) (∀ (x : α), Membership.mem (sa ia) x → Membership.mem (sb ib) (f x)))","decl":"theorem HasBasis.tendsto_iff (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb ↔ ∀ ib, pb ib → ∃ ia, pa ia ∧ ∀ x ∈ sa ia, f x ∈ sb ib := by\n  simp [hlb.tendsto_right_iff, hla.eventually_iff]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.Tendsto.basis_left","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nlb : Filter β\nf : α → β\nH : Filter.Tendsto f la lb\nhla : la.HasBasis pa sa\nt : Set β\na✝ : Membership.mem lb t\n⊢ Exists fun i => And (pa i) (Set.MapsTo f (sa i) t)","decl":"theorem Tendsto.basis_left (H : Tendsto f la lb) (hla : la.HasBasis pa sa) :\n    ∀ t ∈ lb, ∃ i, pa i ∧ MapsTo f (sa i) t :=\n  hla.tendsto_left_iff.1 H\n\n"}
{"name":"Filter.Tendsto.basis_right","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι' : Sort u_5\nla : Filter α\nlb : Filter β\npb : ι' → Prop\nsb : ι' → Set β\nf : α → β\nH : Filter.Tendsto f la lb\nhlb : lb.HasBasis pb sb\ni : ι'\na✝ : pb i\n⊢ Filter.Eventually (fun x => Membership.mem (sb i) (f x)) la","decl":"theorem Tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.HasBasis pb sb) :\n    ∀ i, pb i → ∀ᶠ x in la, f x ∈ sb i :=\n  hlb.tendsto_right_iff.1 H\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`.\n"}
{"name":"Filter.Tendsto.basis_both","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nι' : Sort u_5\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nlb : Filter β\npb : ι' → Prop\nsb : ι' → Set β\nf : α → β\nH : Filter.Tendsto f la lb\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\nib : ι'\na✝ : pb ib\n⊢ Exists fun ia => And (pa ia) (Set.MapsTo f (sa ia) (sb ib))","decl":"theorem Tendsto.basis_both (H : Tendsto f la lb) (hla : la.HasBasis pa sa)\n    (hlb : lb.HasBasis pb sb) :\n    ∀ ib, pb ib → ∃ ia, pa ia ∧ MapsTo f (sa ia) (sb ib) :=\n  (hla.tendsto_iff hlb).1 H\n\n"}
{"name":"Filter.HasBasis.prod_pprod","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nι' : Sort u_5\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nlb : Filter β\npb : ι' → Prop\nsb : ι' → Set β\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\n⊢ (SProd.sprod la lb).HasBasis (fun i => And (pa i.fst) (pb i.snd)) fun i => SProd.sprod (sa i.fst) (sb i.snd)","decl":"theorem HasBasis.prod_pprod (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la ×ˢ lb).HasBasis (fun i : PProd ι ι' => pa i.1 ∧ pb i.2) fun i => sa i.1 ×ˢ sb i.2 :=\n  (hla.comap Prod.fst).inf' (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.HasBasis.prod","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\nι : Type u_6\nι' : Type u_7\npa : ι → Prop\nsa : ι → Set α\npb : ι' → Prop\nsb : ι' → Set β\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\n⊢ (SProd.sprod la lb).HasBasis (fun i => And (pa i.1) (pb i.2)) fun i => SProd.sprod (sa i.1) (sb i.2)","decl":"theorem HasBasis.prod {ι ι' : Type*} {pa : ι → Prop} {sa : ι → Set α} {pb : ι' → Prop}\n    {sb : ι' → Set β} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la ×ˢ lb).HasBasis (fun i : ι × ι' => pa i.1 ∧ pb i.2) fun i => sa i.1 ×ˢ sb i.2 :=\n  (hla.comap Prod.fst).inf (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.HasBasis.prod_same_index","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nla : Filter α\nsa : ι → Set α\nlb : Filter β\np : ι → Prop\nsb : ι → Set β\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nh_dir : ∀ {i j : ι}, p i → p j → Exists fun k => And (p k) (And (HasSubset.Subset (sa k) (sa i)) (HasSubset.Subset (sb k) (sb j)))\n⊢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index {p : ι → Prop} {sb : ι → Set β} (hla : la.HasBasis p sa)\n    (hlb : lb.HasBasis p sb) (h_dir : ∀ {i j}, p i → p j → ∃ k, p k ∧ sa k ⊆ sa i ∧ sb k ⊆ sb j) :\n    (la ×ˢ lb).HasBasis p fun i => sa i ×ˢ sb i := by\n  simp only [hasBasis_iff, (hla.prod_pprod hlb).mem_iff]\n  refine fun t => ⟨?_, ?_⟩\n  · rintro ⟨⟨i, j⟩, ⟨hi, hj⟩, hsub : sa i ×ˢ sb j ⊆ t⟩\n    rcases h_dir hi hj with ⟨k, hk, ki, kj⟩\n    exact ⟨k, hk, (Set.prod_mono ki kj).trans hsub⟩\n  · rintro ⟨i, hi, h⟩\n    exact ⟨⟨i, i⟩, ⟨hi, hi⟩, h⟩\n\n"}
{"name":"Filter.HasBasis.prod_same_index_mono","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\nι : Type u_6\ninst✝ : LinearOrder ι\np : ι → Prop\nsa : ι → Set α\nsb : ι → Set β\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nhsa : MonotoneOn sa (setOf fun i => p i)\nhsb : MonotoneOn sb (setOf fun i => p i)\n⊢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index_mono {ι : Type*} [LinearOrder ι] {p : ι → Prop} {sa : ι → Set α}\n    {sb : ι → Set β} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : MonotoneOn sa { i | p i }) (hsb : MonotoneOn sb { i | p i }) :\n    (la ×ˢ lb).HasBasis p fun i => sa i ×ˢ sb i :=\n  hla.prod_same_index hlb fun {i j} hi hj =>\n    have : p (min i j) := min_rec' _ hi hj\n    ⟨min i j, this, hsa this hi <| min_le_left _ _, hsb this hj <| min_le_right _ _⟩\n\n"}
{"name":"Filter.HasBasis.prod_same_index_anti","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\nι : Type u_6\ninst✝ : LinearOrder ι\np : ι → Prop\nsa : ι → Set α\nsb : ι → Set β\nhla : la.HasBasis p sa\nhlb : lb.HasBasis p sb\nhsa : AntitoneOn sa (setOf fun i => p i)\nhsb : AntitoneOn sb (setOf fun i => p i)\n⊢ (SProd.sprod la lb).HasBasis p fun i => SProd.sprod (sa i) (sb i)","decl":"theorem HasBasis.prod_same_index_anti {ι : Type*} [LinearOrder ι] {p : ι → Prop} {sa : ι → Set α}\n    {sb : ι → Set β} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : AntitoneOn sa { i | p i }) (hsb : AntitoneOn sb { i | p i }) :\n    (la ×ˢ lb).HasBasis p fun i => sa i ×ˢ sb i :=\n  @HasBasis.prod_same_index_mono _ _ _ _ ιᵒᵈ _ _ _ _ hla hlb hsa.dual_left hsb.dual_left\n\n"}
{"name":"Filter.HasBasis.prod_self","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nι : Sort u_4\nla : Filter α\npa : ι → Prop\nsa : ι → Set α\nhl : la.HasBasis pa sa\n⊢ (SProd.sprod la la).HasBasis pa fun i => SProd.sprod (sa i) (sa i)","decl":"theorem HasBasis.prod_self (hl : la.HasBasis pa sa) :\n    (la ×ˢ la).HasBasis pa fun i => sa i ×ˢ sa i :=\n  hl.prod_same_index hl fun {i j} hi hj => by\n    simpa only [exists_prop, subset_inter_iff] using\n      hl.mem_iff.1 (inter_mem (hl.mem_of_mem hi) (hl.mem_of_mem hj))\n\n"}
{"name":"Filter.mem_prod_self_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nla : Filter α\ns : Set (Prod α α)\n⊢ Iff (Membership.mem (SProd.sprod la la) s) (Exists fun t => And (Membership.mem la t) (HasSubset.Subset (SProd.sprod t t) s))","decl":"theorem mem_prod_self_iff {s} : s ∈ la ×ˢ la ↔ ∃ t ∈ la, t ×ˢ t ⊆ s :=\n  la.basis_sets.prod_self.mem_iff\n\n"}
{"name":"Filter.eventually_prod_self_iff","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nla : Filter α\nr : α → α → Prop\n⊢ Iff (Filter.Eventually (fun x => r x.1 x.2) (SProd.sprod la la)) (Exists fun t => And (Membership.mem la t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → r x y))","decl":"lemma eventually_prod_self_iff {r : α → α → Prop} :\n    (∀ᶠ x in la ×ˢ la, r x.1 x.2) ↔ ∃ t ∈ la, ∀ x ∈ t, ∀ y ∈ t, r x y :=\n  mem_prod_self_iff.trans <| by simp only [prod_subset_iff, mem_setOf_eq]\n\n"}
{"name":"Filter.eventually_prod_self_iff'","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nla : Filter α\nr : Prod α α → Prop\n⊢ Iff (Filter.Eventually (fun x => r x) (SProd.sprod la la)) (Exists fun t => And (Membership.mem la t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → r { fst := x, snd := y }))","decl":"/-- A version of `eventually_prod_self_iff` that is more suitable for forward rewriting. -/\nlemma eventually_prod_self_iff' {r : α × α → Prop} :\n    (∀ᶠ x in la ×ˢ la, r x) ↔ ∃ t ∈ la, ∀ x ∈ t, ∀ y ∈ t, r (x, y) :=\n  Iff.symm eventually_prod_self_iff.symm\n\n"}
{"name":"Filter.HasAntitoneBasis.prod","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_6\ninst✝ : LinearOrder ι\nf : Filter α\ng : Filter β\ns : ι → Set α\nt : ι → Set β\nhf : f.HasAntitoneBasis s\nhg : g.HasAntitoneBasis t\n⊢ (SProd.sprod f g).HasAntitoneBasis fun n => SProd.sprod (s n) (t n)","decl":"theorem HasAntitoneBasis.prod {ι : Type*} [LinearOrder ι] {f : Filter α} {g : Filter β}\n    {s : ι → Set α} {t : ι → Set β} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (f ×ˢ g) fun n => s n ×ˢ t n :=\n  ⟨hf.1.prod_same_index_anti hg.1 (hf.2.antitoneOn _) (hg.2.antitoneOn _), hf.2.set_prod hg.2⟩\n\n"}
{"name":"Filter.HasBasis.coprod","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\nι : Type u_6\nι' : Type u_7\npa : ι → Prop\nsa : ι → Set α\npb : ι' → Prop\nsb : ι' → Set β\nhla : la.HasBasis pa sa\nhlb : lb.HasBasis pb sb\n⊢ (la.coprod lb).HasBasis (fun i => And (pa i.1) (pb i.2)) fun i => Union.union (Set.preimage Prod.fst (sa i.1)) (Set.preimage Prod.snd (sb i.2))","decl":"theorem HasBasis.coprod {ι ι' : Type*} {pa : ι → Prop} {sa : ι → Set α} {pb : ι' → Prop}\n    {sb : ι' → Set β} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la.coprod lb).HasBasis (fun i : ι × ι' => pa i.1 ∧ pb i.2) fun i =>\n      Prod.fst ⁻¹' sa i.1 ∪ Prod.snd ⁻¹' sb i.2 :=\n  (hla.comap Prod.fst).sup (hlb.comap Prod.snd)\n\n"}
{"name":"Filter.map_sigma_mk_comap","module":"Mathlib.Order.Filter.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nπ : α → Type u_6\nπ' : β → Type u_7\nf : α → β\nhf : Function.Injective f\ng : (a : α) → π a → π' (f a)\na : α\nl : Filter (π' (f a))\n⊢ Eq (Filter.map (Sigma.mk a) (Filter.comap (g a) l)) (Filter.comap (Sigma.map f g) (Filter.map (Sigma.mk (f a)) l))","decl":"theorem map_sigma_mk_comap {π : α → Type*} {π' : β → Type*} {f : α → β}\n    (hf : Function.Injective f) (g : ∀ a, π a → π' (f a)) (a : α) (l : Filter (π' (f a))) :\n    map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l) := by\n  refine (((basis_sets _).comap _).map _).eq_of_same_basis ?_\n  convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)\n  apply image_sigmaMk_preimage_sigmaMap hf\n\n"}
