{"name":"IsPrimitiveRoot.autToPow_injective","module":"Mathlib.NumberTheory.Cyclotomic.Gal","initialProofState":"n : PNat\nK : Type u_1\ninst✝⁴ : Field K\nL : Type u_2\nμ : L\ninst✝³ : CommRing L\ninst✝² : IsDomain L\nhμ : IsPrimitiveRoot μ ↑n\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\n⊢ Function.Injective ⇑(IsPrimitiveRoot.autToPow K hμ)","decl":"/-- `IsPrimitiveRoot.autToPow` is injective in the case that it's considered over a cyclotomic\nfield extension. -/\ntheorem autToPow_injective : Function.Injective <| hμ.autToPow K := by\n  intro f g hfg\n  apply_fun Units.val at hfg\n  simp only [IsPrimitiveRoot.coe_autToPow_apply] at hfg\n  generalize_proofs hn₀ hf' hg' at hfg\n  have hf := hf'.choose_spec\n  have hg := hg'.choose_spec\n  generalize_proofs hζ at hf hg\n  suffices f (hμ.toRootsOfUnity : Lˣ) = g (hμ.toRootsOfUnity : Lˣ) by\n    apply AlgEquiv.coe_algHom_injective\n    apply (hμ.powerBasis K).algHom_ext\n    exact this\n  rw [ZMod.eq_iff_modEq_nat] at hfg\n  refine (hf.trans ?_).trans hg.symm\n  rw [← rootsOfUnity.coe_pow _ hf'.choose, ← rootsOfUnity.coe_pow _ hg'.choose]\n  congr 2\n  rw [pow_eq_pow_iff_modEq]\n  convert hfg\n  -- Porting note: was `{occs := occurrences.pos [2]}` (for the second rewrite)\n  conv => enter [2]; rw [hμ.eq_orderOf, ← hμ.val_toRootsOfUnity_coe]\n  rw [orderOf_units, Subgroup.orderOf_coe]\n\n"}
{"name":"IsCyclotomicExtension.autEquivPow_apply","module":"Mathlib.NumberTheory.Cyclotomic.Gal","initialProofState":"n : PNat\nK : Type u_1\ninst✝⁴ : Field K\nL : Type u_2\ninst✝³ : CommRing L\ninst✝² : IsDomain L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\nh : Irreducible (Polynomial.cyclotomic (↑n) K)\na✝ : AlgEquiv K L L\n⊢ Eq ((IsCyclotomicExtension.autEquivPow L h) a✝) ((↑(IsPrimitiveRoot.autToPow K ⋯)).toFun a✝)","decl":"/-- The `MulEquiv` that takes an automorphism `f` to the element `k : (ZMod n)ˣ` such that\n  `f μ = μ ^ k` for any root of unity `μ`. A strengthening of `IsPrimitiveRoot.autToPow`. -/\n@[simps]\nnoncomputable def autEquivPow (h : Irreducible (cyclotomic n K)) : (L ≃ₐ[K] L) ≃* (ZMod n)ˣ :=\n  let hζ := zeta_spec n K L\n  let hμ t := hζ.pow_of_coprime _ (ZMod.val_coe_unit_coprime t)\n  { (zeta_spec n K L).autToPow K with\n    invFun := fun t =>\n      (hζ.powerBasis K).equivOfMinpoly ((hμ t).powerBasis K)\n        (by\n          haveI := IsCyclotomicExtension.neZero' n K L\n          simp only [IsPrimitiveRoot.powerBasis_gen]\n          have hr :=\n            IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible\n              ((zeta_spec n K L).pow_of_coprime _ (ZMod.val_coe_unit_coprime t)) h\n          exact ((zeta_spec n K L).minpoly_eq_cyclotomic_of_irreducible h).symm.trans hr)\n    left_inv := fun f => by\n      simp only [MonoidHom.toFun_eq_coe]\n      apply AlgEquiv.coe_algHom_injective\n      apply (hζ.powerBasis K).algHom_ext\n-- Porting note: the proof is slightly different because of coercions.\n      simp only [AlgHom.coe_coe]\n      rw [PowerBasis.equivOfMinpoly_gen]\n      simp only [IsPrimitiveRoot.powerBasis_gen, IsPrimitiveRoot.autToPow_spec]\n    right_inv := fun x => by\n      simp only [MonoidHom.toFun_eq_coe]\n      generalize_proofs _ _ h\n      have key := hζ.autToPow_spec K ((hζ.powerBasis K).equivOfMinpoly ((hμ x).powerBasis K) h)\n      have := (hζ.powerBasis K).equivOfMinpoly_gen ((hμ x).powerBasis K) h\n      rw [hζ.powerBasis_gen K] at this\n      rw [this, IsPrimitiveRoot.powerBasis_gen] at key\n-- Porting note: was `rw ← hζ.coe_to_roots_of_unity_coe at key {occs := occurrences.pos [1, 5]}`.\n      conv at key =>\n        congr; congr\n        rw [← hζ.val_toRootsOfUnity_coe]\n        rfl; rfl\n        rw [← hζ.val_toRootsOfUnity_coe]\n      simp only [← rootsOfUnity.coe_pow] at key\n      replace key := rootsOfUnity.coe_injective key\n      rw [pow_eq_pow_iff_modEq, ← Subgroup.orderOf_coe, ← orderOf_units, hζ.val_toRootsOfUnity_coe,\n        ← (zeta_spec n K L).eq_orderOf, ← ZMod.eq_iff_modEq_nat] at key\n      simp only [ZMod.natCast_val, ZMod.cast_id', id] at key\n      exact Units.ext key }\n\n"}
{"name":"IsCyclotomicExtension.autEquivPow_symm_apply","module":"Mathlib.NumberTheory.Cyclotomic.Gal","initialProofState":"n : PNat\nK : Type u_1\ninst✝⁴ : Field K\nL : Type u_2\ninst✝³ : CommRing L\ninst✝² : IsDomain L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\nh : Irreducible (Polynomial.cyclotomic (↑n) K)\nt : Units (ZMod ↑n)\n⊢ Eq ((IsCyclotomicExtension.autEquivPow L h).symm t) ((IsPrimitiveRoot.powerBasis K ⋯).equivOfMinpoly (IsPrimitiveRoot.powerBasis K ⋯) ⋯)","decl":"/-- The `MulEquiv` that takes an automorphism `f` to the element `k : (ZMod n)ˣ` such that\n  `f μ = μ ^ k` for any root of unity `μ`. A strengthening of `IsPrimitiveRoot.autToPow`. -/\n@[simps]\nnoncomputable def autEquivPow (h : Irreducible (cyclotomic n K)) : (L ≃ₐ[K] L) ≃* (ZMod n)ˣ :=\n  let hζ := zeta_spec n K L\n  let hμ t := hζ.pow_of_coprime _ (ZMod.val_coe_unit_coprime t)\n  { (zeta_spec n K L).autToPow K with\n    invFun := fun t =>\n      (hζ.powerBasis K).equivOfMinpoly ((hμ t).powerBasis K)\n        (by\n          haveI := IsCyclotomicExtension.neZero' n K L\n          simp only [IsPrimitiveRoot.powerBasis_gen]\n          have hr :=\n            IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible\n              ((zeta_spec n K L).pow_of_coprime _ (ZMod.val_coe_unit_coprime t)) h\n          exact ((zeta_spec n K L).minpoly_eq_cyclotomic_of_irreducible h).symm.trans hr)\n    left_inv := fun f => by\n      simp only [MonoidHom.toFun_eq_coe]\n      apply AlgEquiv.coe_algHom_injective\n      apply (hζ.powerBasis K).algHom_ext\n-- Porting note: the proof is slightly different because of coercions.\n      simp only [AlgHom.coe_coe]\n      rw [PowerBasis.equivOfMinpoly_gen]\n      simp only [IsPrimitiveRoot.powerBasis_gen, IsPrimitiveRoot.autToPow_spec]\n    right_inv := fun x => by\n      simp only [MonoidHom.toFun_eq_coe]\n      generalize_proofs _ _ h\n      have key := hζ.autToPow_spec K ((hζ.powerBasis K).equivOfMinpoly ((hμ x).powerBasis K) h)\n      have := (hζ.powerBasis K).equivOfMinpoly_gen ((hμ x).powerBasis K) h\n      rw [hζ.powerBasis_gen K] at this\n      rw [this, IsPrimitiveRoot.powerBasis_gen] at key\n-- Porting note: was `rw ← hζ.coe_to_roots_of_unity_coe at key {occs := occurrences.pos [1, 5]}`.\n      conv at key =>\n        congr; congr\n        rw [← hζ.val_toRootsOfUnity_coe]\n        rfl; rfl\n        rw [← hζ.val_toRootsOfUnity_coe]\n      simp only [← rootsOfUnity.coe_pow] at key\n      replace key := rootsOfUnity.coe_injective key\n      rw [pow_eq_pow_iff_modEq, ← Subgroup.orderOf_coe, ← orderOf_units, hζ.val_toRootsOfUnity_coe,\n        ← (zeta_spec n K L).eq_orderOf, ← ZMod.eq_iff_modEq_nat] at key\n      simp only [ZMod.natCast_val, ZMod.cast_id', id] at key\n      exact Units.ext key }\n\n"}
{"name":"IsCyclotomicExtension.fromZetaAut_spec","module":"Mathlib.NumberTheory.Cyclotomic.Gal","initialProofState":"n : PNat\nK : Type u_1\ninst✝⁴ : Field K\nL : Type u_2\nμ : L\ninst✝³ : CommRing L\ninst✝² : IsDomain L\nhμ : IsPrimitiveRoot μ ↑n\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\nh : Irreducible (Polynomial.cyclotomic (↑n) K)\n⊢ Eq ((IsCyclotomicExtension.fromZetaAut hμ h) (IsCyclotomicExtension.zeta n K L)) μ","decl":"theorem fromZetaAut_spec : fromZetaAut hμ h (zeta n K L) = μ := by\n  simp_rw [fromZetaAut, autEquivPow_symm_apply]\n  generalize_proofs hζ h _ hμ _\n  nth_rewrite 4 [← hζ.powerBasis_gen K]\n  rw [PowerBasis.equivOfMinpoly_gen, hμ.powerBasis_gen K]\n  convert h.choose_spec.2\n  exact ZMod.val_cast_of_lt h.choose_spec.1\n\n"}
