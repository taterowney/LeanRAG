{"name":"DistribLattice.mem_ideal_sup_principal","module":"Mathlib.Order.PrimeSeparator","initialProofState":"α : Type u_1\ninst✝¹ : DistribLattice α\ninst✝ : BoundedOrder α\na b : α\nJ : Order.Ideal α\n⊢ Iff (Membership.mem (Max.max J (Order.Ideal.principal a)) b) (Exists fun j => And (Membership.mem J j) (LE.le b (Max.max j a)))","decl":"lemma mem_ideal_sup_principal (a b : α) (J : Ideal α) : b ∈ J ⊔ principal a ↔ ∃ j ∈ J, b ≤ j ⊔ a :=\n  ⟨fun ⟨j, ⟨jJ, _, ha', bja'⟩⟩ => ⟨j, jJ, le_trans bja' (sup_le_sup_left ha' j)⟩,\n    fun ⟨j, hj, hbja⟩ => ⟨j, hj, a, le_refl a, hbja⟩⟩\n\n"}
{"name":"DistribLattice.prime_ideal_of_disjoint_filter_ideal","module":"Mathlib.Order.PrimeSeparator","initialProofState":"α : Type u_1\ninst✝¹ : DistribLattice α\ninst✝ : BoundedOrder α\nF : Order.PFilter α\nI : Order.Ideal α\nhFI : Disjoint ↑F ↑I\n⊢ Exists fun J => And J.IsPrime (And (LE.le I J) (Disjoint ↑F ↑J))","decl":"theorem prime_ideal_of_disjoint_filter_ideal (hFI : Disjoint (F : Set α) (I : Set α)) :\n    ∃ J : Ideal α, (IsPrime J) ∧ I ≤ J ∧ Disjoint (F : Set α) J := by\n\n  -- Let S be the set of ideals containing I and disjoint from F.\n  set S : Set (Set α) := { J : Set α | IsIdeal J ∧ I ≤ J ∧ Disjoint (F : Set α) J }\n\n  -- Then I is in S...\n  have IinS : ↑I ∈ S := by\n    refine ⟨Order.Ideal.isIdeal I, by trivial⟩\n\n  -- ...and S contains upper bounds for any non-empty chains.\n  have chainub : ∀ c ⊆ S, IsChain (· ⊆ ·) c → c.Nonempty → ∃ ub ∈ S, ∀ s ∈ c, s ⊆ ub := by\n    intros c hcS hcC hcNe\n    use sUnion c\n    refine ⟨?_, fun s hs ↦ le_sSup hs⟩\n    simp only [le_eq_subset, mem_setOf_eq, disjoint_sUnion_right, S]\n    let ⟨J, hJ⟩ := hcNe\n    refine ⟨Order.isIdeal_sUnion_of_isChain (fun _ hJ ↦ (hcS hJ).1) hcC hcNe,\n            ⟨le_trans (hcS hJ).2.1 (le_sSup hJ), fun J hJ ↦ (hcS hJ).2.2⟩⟩\n\n  -- Thus, by Zorn's lemma, we can pick a maximal ideal J in S.\n  obtain ⟨Jset, _, hmax⟩ := zorn_subset_nonempty S chainub I IinS\n  obtain ⟨Jidl, IJ, JF⟩ := hmax.prop\n  set J := IsIdeal.toIdeal Jidl\n  use J\n  have IJ' : I ≤ J := IJ\n\n  clear chainub IinS\n\n  -- By construction, J contains I and is disjoint from F. It remains to prove that J is prime.\n  refine ⟨?_, ⟨IJ, JF⟩⟩\n\n  -- First note that J is proper: ⊤ ∈ F so ⊤ ∉ J because F and J are disjoint.\n  have Jpr : IsProper J := isProper_of_not_mem (Set.disjoint_left.1 JF F.top_mem)\n\n  -- Suppose that a₁ ∉ J, a₂ ∉ J. We need to prove that a₁ ⊔ a₂ ∉ J.\n  rw [isPrime_iff_mem_or_mem]\n  intros a₁ a₂\n  contrapose!\n  intro ⟨ha₁, ha₂⟩\n\n  -- Consider the ideals J₁, J₂ generated by J ∪ {a₁} and J ∪ {a₂}, respectively.\n  let J₁ := J ⊔ principal a₁\n  let J₂ := J ⊔ principal a₂\n\n  -- For each i, Jᵢ is an ideal that contains aᵢ, and is not equal to J.\n\n  have a₁J₁ : a₁ ∈ J₁ := mem_of_subset_of_mem (le_sup_right : _ ≤ J ⊔ _) mem_principal_self\n  have a₂J₂ : a₂ ∈ J₂ := mem_of_subset_of_mem (le_sup_right : _ ≤ J ⊔ _) mem_principal_self\n  have J₁J : ↑J₁ ≠ Jset := ne_of_mem_of_not_mem' a₁J₁ ha₁\n  have J₂J : ↑J₂ ≠ Jset := ne_of_mem_of_not_mem' a₂J₂ ha₂\n\n  -- Therefore, since J is maximal, we must have Jᵢ ∉ S.\n  have J₁S : ↑J₁ ∉ S := fun h => J₁J (hmax.eq_of_le h (le_sup_left : J ≤ J₁)).symm\n  have J₂S : ↑J₂ ∉ S := fun h => J₂J (hmax.eq_of_le h (le_sup_left : J ≤ J₂)).symm\n\n  -- Since Jᵢ is an ideal that contains I, we have that Jᵢ is not disjoint from F.\n  have J₁F : ¬ (Disjoint (F : Set α) J₁) := by\n    intro hdis\n    apply J₁S\n    simp only [le_eq_subset, mem_setOf_eq, SetLike.coe_subset_coe, S]\n    exact ⟨J₁.isIdeal, le_trans IJ' le_sup_left, hdis⟩\n\n  have J₂F : ¬ (Disjoint (F : Set α) J₂) := by\n    intro hdis\n    apply J₂S\n    simp only [le_eq_subset, mem_setOf_eq, SetLike.coe_subset_coe, S]\n    exact ⟨J₂.isIdeal, le_trans IJ' le_sup_left, hdis⟩\n\n  -- Thus, pick cᵢ ∈ F ∩ Jᵢ.\n  let ⟨c₁, ⟨c₁F, c₁J₁⟩⟩ := Set.not_disjoint_iff.1 J₁F\n  let ⟨c₂, ⟨c₂F, c₂J₂⟩⟩ := Set.not_disjoint_iff.1 J₂F\n\n  -- Using the definition of Jᵢ, we can pick bᵢ ∈ J such that cᵢ ≤ bᵢ ⊔ aᵢ.\n  let ⟨b₁, ⟨b₁J, cba₁⟩⟩ := (mem_ideal_sup_principal a₁ c₁ J).1 c₁J₁\n  let ⟨b₂, ⟨b₂J, cba₂⟩⟩ := (mem_ideal_sup_principal a₂ c₂ J).1 c₂J₂\n\n  -- Since J is an ideal, we have b := b₁ ⊔ b₂ ∈ J.\n  let b := b₁ ⊔ b₂\n  have bJ : b ∈ J := sup_mem b₁J b₂J\n\n  -- We now prove a key inequality, using crucially that the lattice is distributive.\n  have ineq : c₁ ⊓ c₂ ≤ b ⊔ (a₁ ⊓ a₂) :=\n  calc\n    c₁ ⊓ c₂ ≤ (b₁ ⊔ a₁) ⊓ (b₂ ⊔ a₂) := inf_le_inf cba₁ cba₂\n    _       ≤ (b  ⊔ a₁) ⊓ (b  ⊔ a₂) := by\n      apply inf_le_inf <;> apply sup_le_sup_right; exact le_sup_left; exact le_sup_right\n    _       = b ⊔ (a₁ ⊓ a₂) := (sup_inf_left b a₁ a₂).symm\n\n  -- Note that c₁ ⊓ c₂ ∈ F, since c₁ and c₂ are both in F and F is a filter.\n  -- Since F is an upper set, it now follows that b ⊔ (a₁ ⊓ a₂) ∈ F.\n  have ba₁a₂F : b ⊔ (a₁ ⊓ a₂) ∈ F := PFilter.mem_of_le ineq (PFilter.inf_mem c₁F c₂F)\n\n  -- Now, if we would have a₁ ⊓ a₂ ∈ J, then, since J is an ideal and b ∈ J, we would also get\n  -- b ⊔ (a₁ ⊓ a₂) ∈ J. But this contradicts that J is disjoint from F.\n  contrapose! JF with ha₁a₂\n  rw [Set.not_disjoint_iff]\n  use b ⊔ (a₁ ⊓ a₂)\n  exact ⟨ba₁a₂F, sup_mem bJ ha₁a₂⟩\n\n-- TODO: Define prime filters in Mathlib so that the following corollary can be stated and proved.\n-- theorem prime_filter_of_disjoint_filter_ideal (hFI : Disjoint (F : Set α) (I : Set α)) :\n--     ∃ G : PFilter α, (IsPrime G) ∧ F ≤ G ∧ Disjoint (G : Set α) I := by sorry\n\n"}
