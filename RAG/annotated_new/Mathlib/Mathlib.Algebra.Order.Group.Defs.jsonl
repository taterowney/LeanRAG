{"name":"OrderedAddCommGroup.add_le_add_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : OrderedAddCommGroup α\na b : α\na✝ : LE.le a b\nc : α\n⊢ LE.le (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"/-- An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone. -/\nclass OrderedAddCommGroup (α : Type u) extends AddCommGroup α, PartialOrder α where\n  /-- Addition is monotone in an ordered additive commutative group. -/\n  protected add_le_add_left : ∀ a b : α, a ≤ b → ∀ c : α, c + a ≤ c + b\n\n"}
{"name":"OrderedCommGroup.mul_le_mul_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : OrderedCommGroup α\na b : α\na✝ : LE.le a b\nc : α\n⊢ LE.le (HMul.hMul c a) (HMul.hMul c b)","decl":"/-- An ordered commutative group is a commutative group\nwith a partial order in which multiplication is strictly monotone. -/\nclass OrderedCommGroup (α : Type u) extends CommGroup α, PartialOrder α where\n  /-- Multiplication is monotone in an ordered commutative group. -/\n  protected mul_le_mul_left : ∀ a b : α, a ≤ b → ∀ c : α, c * a ≤ c * b\n\n"}
{"name":"OrderedAddCommGroup.toAddLeftMono","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\n⊢ AddLeftMono α","decl":"@[to_additive]\ninstance OrderedCommGroup.toMulLeftMono (α : Type u) [OrderedCommGroup α] :\n    MulLeftMono α where\n      elim a b c bc := OrderedCommGroup.mul_le_mul_left b c bc a\n\n-- See note [lower instance priority]\n"}
{"name":"OrderedCommGroup.toMulLeftMono","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\n⊢ MulLeftMono α","decl":"@[to_additive]\ninstance OrderedCommGroup.toMulLeftMono (α : Type u) [OrderedCommGroup α] :\n    MulLeftMono α where\n      elim a b c bc := OrderedCommGroup.mul_le_mul_left b c bc a\n\n-- See note [lower instance priority]\n"}
{"name":"OrderedCommGroup.toMulLeftReflectLE","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\n⊢ MulLeftReflectLE α","decl":"/-- A choice-free shortcut instance. -/\n@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.toMulLeftReflectLE (α : Type u) [OrderedCommGroup α] :\n    MulLeftReflectLE α where\n      elim a b c bc := by simpa using mul_le_mul_left' bc a⁻¹\n\n-- Porting note: this instance is not used,\n-- and causes timeouts after https://github.com/leanprover/lean4/pull/2210.\n-- See further explanation on `OrderedCommGroup.toMulLeftReflectLE`.\n"}
{"name":"OrderedAddCommGroup.toAddLeftReflectLE","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\n⊢ AddLeftReflectLE α","decl":"/-- A choice-free shortcut instance. -/\n@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.toMulLeftReflectLE (α : Type u) [OrderedCommGroup α] :\n    MulLeftReflectLE α where\n      elim a b c bc := by simpa using mul_le_mul_left' bc a⁻¹\n\n-- Porting note: this instance is not used,\n-- and causes timeouts after https://github.com/leanprover/lean4/pull/2210.\n-- See further explanation on `OrderedCommGroup.toMulLeftReflectLE`.\n"}
{"name":"OrderedCommGroup.toMulRightReflectLE","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\n⊢ MulRightReflectLE α","decl":"/-- A choice-free shortcut instance. -/\n@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.toMulRightReflectLE (α : Type u) [OrderedCommGroup α] :\n    MulRightReflectLE α where\n      elim a b c bc := by simpa using mul_le_mul_right' bc a⁻¹\n\n"}
{"name":"OrderedAddCommGroup.toAddRightReflectLE","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\n⊢ AddRightReflectLE α","decl":"/-- A choice-free shortcut instance. -/\n@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.toMulRightReflectLE (α : Type u) [OrderedCommGroup α] :\n    MulRightReflectLE α where\n      elim a b c bc := by simpa using mul_le_mul_right' bc a⁻¹\n\n"}
{"name":"OrderedCommGroup.mul_lt_mul_left'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LT α\ninst✝ : MulLeftStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HMul.hMul a b) (HMul.hMul a c)","decl":"alias OrderedCommGroup.mul_lt_mul_left' := mul_lt_mul_left'\n\n"}
{"name":"OrderedAddCommGroup.add_lt_add_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddLeftStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"attribute [to_additive OrderedAddCommGroup.add_lt_add_left] OrderedCommGroup.mul_lt_mul_left'\n\n"}
{"name":"OrderedCommGroup.le_of_mul_le_mul_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : MulLeftReflectLE α\na b c : α\nbc : LE.le (HMul.hMul a b) (HMul.hMul a c)\n⊢ LE.le b c","decl":"alias OrderedCommGroup.le_of_mul_le_mul_left := le_of_mul_le_mul_left'\n\n"}
{"name":"OrderedAddCommGroup.le_of_add_le_add_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\na b c : α\nbc : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"attribute [to_additive] OrderedCommGroup.le_of_mul_le_mul_left\n\n"}
{"name":"OrderedCommGroup.lt_of_mul_lt_mul_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LT α\ninst✝ : MulLeftReflectLT α\na b c : α\nbc : LT.lt (HMul.hMul a b) (HMul.hMul a c)\n⊢ LT.lt b c","decl":"alias OrderedCommGroup.lt_of_mul_lt_mul_left := lt_of_mul_lt_mul_left'\n\n"}
{"name":"OrderedAddCommGroup.lt_of_add_lt_add_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddLeftReflectLT α\na b c : α\nbc : LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LT.lt b c","decl":"attribute [to_additive] OrderedCommGroup.lt_of_mul_lt_mul_left\n\n\n"}
{"name":"LinearOrderedAddCommGroup.max_def","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedAddCommGroup α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"/-- A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone. -/\nclass LinearOrderedAddCommGroup (α : Type u) extends OrderedAddCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedAddCommGroup.min_def","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedAddCommGroup α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"/-- A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone. -/\nclass LinearOrderedAddCommGroup (α : Type u) extends OrderedAddCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedAddCommGroup.le_total","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedAddCommGroup α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"/-- A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone. -/\nclass LinearOrderedAddCommGroup (α : Type u) extends OrderedAddCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedAddCommGroup α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"/-- A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone. -/\nclass LinearOrderedAddCommGroup (α : Type u) extends OrderedAddCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedCommGroup.max_def","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedCommGroup α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"/-- A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone. -/\n@[to_additive]\nclass LinearOrderedCommGroup (α : Type u) extends OrderedCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedCommGroup.min_def","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedCommGroup α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"/-- A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone. -/\n@[to_additive]\nclass LinearOrderedCommGroup (α : Type u) extends OrderedCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedCommGroup.le_total","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedCommGroup α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"/-- A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone. -/\n@[to_additive]\nclass LinearOrderedCommGroup (α : Type u) extends OrderedCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedCommGroup.compare_eq_compareOfLessAndEq","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\nself : LinearOrderedCommGroup α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"/-- A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone. -/\n@[to_additive]\nclass LinearOrderedCommGroup (α : Type u) extends OrderedCommGroup α, LinearOrder α\n\n"}
{"name":"LinearOrderedCommGroup.mul_lt_mul_left'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na b : α\nh : LT.lt a b\nc : α\n⊢ LT.lt (HMul.hMul c a) (HMul.hMul c b)","decl":"@[to_additive LinearOrderedAddCommGroup.add_lt_add_left]\ntheorem LinearOrderedCommGroup.mul_lt_mul_left' (a b : α) (h : a < b) (c : α) : c * a < c * b :=\n  _root_.mul_lt_mul_left' h c\n\n"}
{"name":"LinearOrderedAddCommGroup.add_lt_add_left","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na b : α\nh : LT.lt a b\nc : α\n⊢ LT.lt (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"@[to_additive LinearOrderedAddCommGroup.add_lt_add_left]\ntheorem LinearOrderedCommGroup.mul_lt_mul_left' (a b : α) (h : a < b) (c : α) : c * a < c * b :=\n  _root_.mul_lt_mul_left' h c\n\n"}
{"name":"eq_zero_of_neg_eq","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na : α\nh : Eq (Neg.neg a) a\n⊢ Eq a 0","decl":"@[to_additive eq_zero_of_neg_eq]\ntheorem eq_one_of_inv_eq' (h : a⁻¹ = a) : a = 1 :=\n  match lt_trichotomy a 1 with\n  | Or.inl h₁ =>\n    have : 1 < a := h ▸ one_lt_inv_of_inv h₁\n    absurd h₁ this.asymm\n  | Or.inr (Or.inl h₁) => h₁\n  | Or.inr (Or.inr h₁) =>\n    have : a < 1 := h ▸ inv_lt_one'.mpr h₁\n    absurd h₁ this.asymm\n\n"}
{"name":"eq_one_of_inv_eq'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na : α\nh : Eq (Inv.inv a) a\n⊢ Eq a 1","decl":"@[to_additive eq_zero_of_neg_eq]\ntheorem eq_one_of_inv_eq' (h : a⁻¹ = a) : a = 1 :=\n  match lt_trichotomy a 1 with\n  | Or.inl h₁ =>\n    have : 1 < a := h ▸ one_lt_inv_of_inv h₁\n    absurd h₁ this.asymm\n  | Or.inr (Or.inl h₁) => h₁\n  | Or.inr (Or.inr h₁) =>\n    have : a < 1 := h ▸ inv_lt_one'.mpr h₁\n    absurd h₁ this.asymm\n\n"}
{"name":"exists_zero_lt","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Nontrivial α\n⊢ Exists fun a => LT.lt 0 a","decl":"@[to_additive exists_zero_lt]\ntheorem exists_one_lt' [Nontrivial α] : ∃ a : α, 1 < a := by\n  obtain ⟨y, hy⟩ := Decidable.exists_ne (1 : α)\n  obtain h|h := hy.lt_or_lt\n  · exact ⟨y⁻¹, one_lt_inv'.mpr h⟩\n  · exact ⟨y, h⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"exists_one_lt'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : Nontrivial α\n⊢ Exists fun a => LT.lt 1 a","decl":"@[to_additive exists_zero_lt]\ntheorem exists_one_lt' [Nontrivial α] : ∃ a : α, 1 < a := by\n  obtain ⟨y, hy⟩ := Decidable.exists_ne (1 : α)\n  obtain h|h := hy.lt_or_lt\n  · exact ⟨y⁻¹, one_lt_inv'.mpr h⟩\n  · exact ⟨y, h⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroup.to_noMaxOrder","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : Nontrivial α\n⊢ NoMaxOrder α","decl":"@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMaxOrder [Nontrivial α] : NoMaxOrder α :=\n  ⟨by\n    obtain ⟨y, hy⟩ : ∃ a : α, 1 < a := exists_one_lt'\n    exact fun a => ⟨a * y, lt_mul_of_one_lt_right' a hy⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"LinearOrderedAddCommGroup.to_noMaxOrder","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Nontrivial α\n⊢ NoMaxOrder α","decl":"@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMaxOrder [Nontrivial α] : NoMaxOrder α :=\n  ⟨by\n    obtain ⟨y, hy⟩ : ∃ a : α, 1 < a := exists_one_lt'\n    exact fun a => ⟨a * y, lt_mul_of_one_lt_right' a hy⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroup.to_noMinOrder","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommGroup α\ninst✝ : Nontrivial α\n⊢ NoMinOrder α","decl":"@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMinOrder [Nontrivial α] : NoMinOrder α :=\n  ⟨by\n    obtain ⟨y, hy⟩ : ∃ a : α, 1 < a := exists_one_lt'\n    exact fun a => ⟨a / y, (div_lt_self_iff a).mpr hy⟩⟩\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedAddCommGroup.to_noMinOrder","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Nontrivial α\n⊢ NoMinOrder α","decl":"@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMinOrder [Nontrivial α] : NoMinOrder α :=\n  ⟨by\n    obtain ⟨y, hy⟩ : ∃ a : α, 1 < a := exists_one_lt'\n    exact fun a => ⟨a / y, (div_lt_self_iff a).mpr hy⟩⟩\n\n-- See note [lower instance priority]\n"}
{"name":"neg_le_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na : α\n⊢ Iff (LE.le (Neg.neg a) a) (LE.le 0 a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self_iff : a⁻¹ ≤ a ↔ 1 ≤ a := by simp [inv_le_iff_one_le_mul']\n\n"}
{"name":"inv_le_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na : α\n⊢ Iff (LE.le (Inv.inv a) a) (LE.le 1 a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_le_self_iff : a⁻¹ ≤ a ↔ 1 ≤ a := by simp [inv_le_iff_one_le_mul']\n\n"}
{"name":"neg_lt_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na : α\n⊢ Iff (LT.lt (Neg.neg a) a) (LT.lt 0 a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_lt_self_iff : a⁻¹ < a ↔ 1 < a := by simp [inv_lt_iff_one_lt_mul]\n\n"}
{"name":"inv_lt_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na : α\n⊢ Iff (LT.lt (Inv.inv a) a) (LT.lt 1 a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_lt_self_iff : a⁻¹ < a ↔ 1 < a := by simp [inv_lt_iff_one_lt_mul]\n\n"}
{"name":"le_neg_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na : α\n⊢ Iff (LE.le a (Neg.neg a)) (LE.le a 0)","decl":"@[to_additive (attr := simp)]\ntheorem le_inv_self_iff : a ≤ a⁻¹ ↔ a ≤ 1 := by simp [← not_iff_not]\n\n"}
{"name":"le_inv_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na : α\n⊢ Iff (LE.le a (Inv.inv a)) (LE.le a 1)","decl":"@[to_additive (attr := simp)]\ntheorem le_inv_self_iff : a ≤ a⁻¹ ↔ a ≤ 1 := by simp [← not_iff_not]\n\n"}
{"name":"lt_inv_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedCommGroup α\na : α\n⊢ Iff (LT.lt a (Inv.inv a)) (LT.lt a 1)","decl":"@[to_additive (attr := simp)]\ntheorem lt_inv_self_iff : a < a⁻¹ ↔ a < 1 := by simp [← not_iff_not]\n\n"}
{"name":"lt_neg_self_iff","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : LinearOrderedAddCommGroup α\na : α\n⊢ Iff (LT.lt a (Neg.neg a)) (LT.lt a 0)","decl":"@[to_additive (attr := simp)]\ntheorem lt_inv_self_iff : a < a⁻¹ ↔ a < 1 := by simp [← not_iff_not]\n\n"}
{"name":"inv_le_inv'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\na b : α\na✝ : LE.le a b\n⊢ LE.le (Inv.inv b) (Inv.inv a)","decl":"@[to_additive (attr := gcongr) neg_le_neg]\ntheorem inv_le_inv' : a ≤ b → b⁻¹ ≤ a⁻¹ :=\n  inv_le_inv_iff.mpr\n\n"}
{"name":"neg_le_neg","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\na b : α\na✝ : LE.le a b\n⊢ LE.le (Neg.neg b) (Neg.neg a)","decl":"@[to_additive (attr := gcongr) neg_le_neg]\ntheorem inv_le_inv' : a ≤ b → b⁻¹ ≤ a⁻¹ :=\n  inv_le_inv_iff.mpr\n\n"}
{"name":"neg_lt_neg","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\na b : α\na✝ : LT.lt a b\n⊢ LT.lt (Neg.neg b) (Neg.neg a)","decl":"@[to_additive (attr := gcongr) neg_lt_neg]\ntheorem inv_lt_inv' : a < b → b⁻¹ < a⁻¹ :=\n  inv_lt_inv_iff.mpr\n\n--  The additive version is also a `linarith` lemma.\n"}
{"name":"inv_lt_inv'","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\na b : α\na✝ : LT.lt a b\n⊢ LT.lt (Inv.inv b) (Inv.inv a)","decl":"@[to_additive (attr := gcongr) neg_lt_neg]\ntheorem inv_lt_inv' : a < b → b⁻¹ < a⁻¹ :=\n  inv_lt_inv_iff.mpr\n\n--  The additive version is also a `linarith` lemma.\n"}
{"name":"inv_lt_one_of_one_lt","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\na : α\na✝ : LT.lt 1 a\n⊢ LT.lt (Inv.inv a) 1","decl":"@[to_additive]\ntheorem inv_lt_one_of_one_lt : 1 < a → a⁻¹ < 1 :=\n  inv_lt_one_iff_one_lt.mpr\n\n--  The additive version is also a `linarith` lemma.\n"}
{"name":"neg_neg_of_pos","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\na : α\na✝ : LT.lt 0 a\n⊢ LT.lt (Neg.neg a) 0","decl":"@[to_additive]\ntheorem inv_lt_one_of_one_lt : 1 < a → a⁻¹ < 1 :=\n  inv_lt_one_iff_one_lt.mpr\n\n--  The additive version is also a `linarith` lemma.\n"}
{"name":"inv_le_one_of_one_le","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\na : α\na✝ : LE.le 1 a\n⊢ LE.le (Inv.inv a) 1","decl":"@[to_additive]\ntheorem inv_le_one_of_one_le : 1 ≤ a → a⁻¹ ≤ 1 :=\n  inv_le_one'.mpr\n\n"}
{"name":"neg_nonpos_of_nonneg","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\na : α\na✝ : LE.le 0 a\n⊢ LE.le (Neg.neg a) 0","decl":"@[to_additive]\ntheorem inv_le_one_of_one_le : 1 ≤ a → a⁻¹ ≤ 1 :=\n  inv_le_one'.mpr\n\n"}
{"name":"one_le_inv_of_le_one","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedCommGroup α\na : α\na✝ : LE.le a 1\n⊢ LE.le 1 (Inv.inv a)","decl":"@[to_additive neg_nonneg_of_nonpos]\ntheorem one_le_inv_of_le_one : a ≤ 1 → 1 ≤ a⁻¹ :=\n  one_le_inv'.mpr\n\n"}
{"name":"neg_nonneg_of_nonpos","module":"Mathlib.Algebra.Order.Group.Defs","initialProofState":"α : Type u\ninst✝ : OrderedAddCommGroup α\na : α\na✝ : LE.le a 0\n⊢ LE.le 0 (Neg.neg a)","decl":"@[to_additive neg_nonneg_of_nonpos]\ntheorem one_le_inv_of_le_one : a ≤ 1 → 1 ≤ a⁻¹ :=\n  one_le_inv'.mpr\n\n"}
