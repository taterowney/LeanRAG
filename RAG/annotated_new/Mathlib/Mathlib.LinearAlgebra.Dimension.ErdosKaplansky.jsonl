{"name":"max_aleph0_card_le_rank_fun_nat","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ LE.le (Max.max Cardinal.aleph0 (Cardinal.mk K)) (Module.rank K (Nat → K))","decl":"/-- Key lemma towards the Erdős-Kaplansky theorem from https://mathoverflow.net/a/168624 -/\ntheorem max_aleph0_card_le_rank_fun_nat : max ℵ₀ #K ≤ Module.rank K (ℕ → K) := by\n  have aleph0_le : ℵ₀ ≤ Module.rank K (ℕ → K) := (rank_finsupp_self K ℕ).symm.trans_le\n    (Finsupp.lcoeFun.rank_le_of_injective <| by exact DFunLike.coe_injective)\n  refine max_le aleph0_le ?_\n  obtain card_K | card_K := le_or_lt #K ℵ₀\n  · exact card_K.trans aleph0_le\n  by_contra!\n  obtain ⟨⟨ιK, bK⟩⟩ := Module.Free.exists_basis (R := K) (M := ℕ → K)\n  let L := Subfield.closure (Set.range (fun i : ιK × ℕ ↦ bK i.1 i.2))\n  have hLK : #L < #K := by\n    refine (Subfield.cardinalMk_closure_le_max _).trans_lt\n      (max_lt_iff.mpr ⟨mk_range_le.trans_lt ?_, card_K⟩)\n    rwa [mk_prod, ← aleph0, lift_uzero, bK.mk_eq_rank'', mul_aleph0_eq aleph0_le]\n  letI := Module.compHom K (RingHom.op L.subtype)\n  obtain ⟨⟨ιL, bL⟩⟩ := Module.Free.exists_basis (R := Lᵐᵒᵖ) (M := K)\n  have card_ιL : ℵ₀ ≤ #ιL := by\n    contrapose! hLK\n    haveI := @Fintype.ofFinite _ (lt_aleph0_iff_finite.mp hLK)\n    rw [bL.repr.toEquiv.cardinal_eq, mk_finsupp_of_fintype,\n        ← MulOpposite.opEquiv.cardinal_eq] at card_K ⊢\n    apply power_nat_le\n    contrapose! card_K\n    exact (power_lt_aleph0 card_K <| nat_lt_aleph0 _).le\n  obtain ⟨e⟩ := lift_mk_le'.mp (card_ιL.trans_eq (lift_uzero #ιL).symm)\n  have rep_e := bK.linearCombination_repr (bL ∘ e)\n  rw [Finsupp.linearCombination_apply, Finsupp.sum] at rep_e\n  set c := bK.repr (bL ∘ e)\n  set s := c.support\n  let f i (j : s) : L := ⟨bK j i, Subfield.subset_closure ⟨(j, i), rfl⟩⟩\n  have : ¬LinearIndependent Lᵐᵒᵖ f := fun h ↦ by\n    have := h.cardinal_lift_le_rank\n    rw [lift_uzero, (LinearEquiv.piCongrRight fun _ ↦ MulOpposite.opLinearEquiv Lᵐᵒᵖ).rank_eq,\n        rank_fun'] at this\n    exact (nat_lt_aleph0 _).not_le this\n  obtain ⟨t, g, eq0, i, hi, hgi⟩ := not_linearIndependent_iff.mp this\n  refine hgi (linearIndependent_iff'.mp (bL.linearIndependent.comp e e.injective) t g ?_ i hi)\n  clear_value c s\n  simp_rw [← rep_e, Finset.sum_apply, Pi.smul_apply, Finset.smul_sum]\n  rw [Finset.sum_comm]\n  refine Finset.sum_eq_zero fun i hi ↦ ?_\n  replace eq0 := congr_arg L.subtype (congr_fun eq0 ⟨i, hi⟩)\n  rw [Finset.sum_apply, map_sum] at eq0\n  have : SMulCommClass Lᵐᵒᵖ K K := ⟨fun _ _ _ ↦ mul_assoc _ _ _⟩\n  simp_rw [smul_comm _ (c i), ← Finset.smul_sum]\n  erw [eq0, smul_zero]\n\n"}
{"name":"rank_fun_infinite","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nι : Type v\nhι : Infinite ι\n⊢ Eq (Module.rank K (ι → K)) (Cardinal.mk (ι → K))","decl":"open Function in\ntheorem rank_fun_infinite {ι : Type v} [hι : Infinite ι] : Module.rank K (ι → K) = #(ι → K) := by\n  obtain ⟨⟨ιK, bK⟩⟩ := Module.Free.exists_basis (R := K) (M := ι → K)\n  obtain ⟨e⟩ := lift_mk_le'.mp ((aleph0_le_mk_iff.mpr hι).trans_eq (lift_uzero #ι).symm)\n  have := LinearMap.lift_rank_le_of_injective _ <|\n    LinearMap.funLeft_injective_of_surjective K K _ (invFun_surjective e.injective)\n  rw [lift_umax.{u,v}, lift_id'.{u,v}] at this\n  have key := (lift_le.{v}.mpr <| max_aleph0_card_le_rank_fun_nat K).trans this\n  rw [lift_max, lift_aleph0, max_le_iff] at key\n  haveI : Infinite ιK := by\n    rw [← aleph0_le_mk_iff, bK.mk_eq_rank'']; exact key.1\n  rw [bK.repr.toEquiv.cardinal_eq, mk_finsupp_lift_of_infinite,\n      lift_umax.{u,v}, lift_id'.{u,v}, bK.mk_eq_rank'', eq_comm, max_eq_left]\n  exact key.2\n\n"}
{"name":"rank_dual_eq_card_dual_of_aleph0_le_rank'","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\ninst✝² : DivisionRing K\nV : Type u_1\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ Eq (Module.rank (MulOpposite K) (LinearMap (RingHom.id K) V K)) (Cardinal.mk (LinearMap (RingHom.id K) V K))","decl":"/-- The **Erdős-Kaplansky Theorem**: the dual of an infinite-dimensional vector space\n  over a division ring has dimension equal to its cardinality. -/\ntheorem rank_dual_eq_card_dual_of_aleph0_le_rank' {V : Type*} [AddCommGroup V] [Module K V]\n    (h : ℵ₀ ≤ Module.rank K V) : Module.rank Kᵐᵒᵖ (V →ₗ[K] K) = #(V →ₗ[K] K) := by\n  obtain ⟨⟨ι, b⟩⟩ := Module.Free.exists_basis (R := K) (M := V)\n  rw [← b.mk_eq_rank'', aleph0_le_mk_iff] at h\n  have e := (b.constr Kᵐᵒᵖ (M' := K)).symm.trans\n    (LinearEquiv.piCongrRight fun _ ↦ MulOpposite.opLinearEquiv Kᵐᵒᵖ)\n  rw [e.rank_eq, e.toEquiv.cardinal_eq]\n  apply rank_fun_infinite\n\n"}
{"name":"rank_dual_eq_card_dual_of_aleph0_le_rank","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ Eq (Module.rank K (LinearMap (RingHom.id K) V K)) (Cardinal.mk (LinearMap (RingHom.id K) V K))","decl":"/-- The **Erdős-Kaplansky Theorem** over a field. -/\ntheorem rank_dual_eq_card_dual_of_aleph0_le_rank {K V} [Field K] [AddCommGroup V] [Module K V]\n    (h : ℵ₀ ≤ Module.rank K V) : Module.rank K (V →ₗ[K] K) = #(V →ₗ[K] K) := by\n  obtain ⟨⟨ι, b⟩⟩ := Module.Free.exists_basis (R := K) (M := V)\n  rw [← b.mk_eq_rank'', aleph0_le_mk_iff] at h\n  have e := (b.constr K (M' := K)).symm\n  rw [e.rank_eq, e.toEquiv.cardinal_eq]\n  apply rank_fun_infinite\n\n"}
{"name":"lift_rank_lt_rank_dual'","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\ninst✝² : DivisionRing K\nV : Type v\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ LT.lt (Cardinal.lift.{u, v} (Module.rank K V)) (Module.rank (MulOpposite K) (LinearMap (RingHom.id K) V K))","decl":"theorem lift_rank_lt_rank_dual' {V : Type v} [AddCommGroup V] [Module K V]\n    (h : ℵ₀ ≤ Module.rank K V) :\n    Cardinal.lift.{u} (Module.rank K V) < Module.rank Kᵐᵒᵖ (V →ₗ[K] K) := by\n  obtain ⟨⟨ι, b⟩⟩ := Module.Free.exists_basis (R := K) (M := V)\n  rw [← b.mk_eq_rank'', rank_dual_eq_card_dual_of_aleph0_le_rank' h,\n      ← (b.constr ℕ (M' := K)).toEquiv.cardinal_eq, mk_arrow]\n  apply cantor'\n  erw [nat_lt_lift_iff, one_lt_iff_nontrivial]\n  infer_instance\n\n"}
{"name":"lift_rank_lt_rank_dual","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ LT.lt (Cardinal.lift.{u, v} (Module.rank K V)) (Module.rank K (LinearMap (RingHom.id K) V K))","decl":"theorem lift_rank_lt_rank_dual {K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V]\n    (h : ℵ₀ ≤ Module.rank K V) :\n    Cardinal.lift.{u} (Module.rank K V) < Module.rank K (V →ₗ[K] K) := by\n  rw [rank_dual_eq_card_dual_of_aleph0_le_rank h, ← rank_dual_eq_card_dual_of_aleph0_le_rank' h]\n  exact lift_rank_lt_rank_dual' h\n\n"}
{"name":"rank_lt_rank_dual'","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K : Type u\ninst✝² : DivisionRing K\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ LT.lt (Module.rank K V) (Module.rank (MulOpposite K) (LinearMap (RingHom.id K) V K))","decl":"theorem rank_lt_rank_dual' {V : Type u} [AddCommGroup V] [Module K V] (h : ℵ₀ ≤ Module.rank K V) :\n    Module.rank K V < Module.rank Kᵐᵒᵖ (V →ₗ[K] K) := by\n  convert lift_rank_lt_rank_dual' h; rw [lift_id]\n\n"}
{"name":"rank_lt_rank_dual","module":"Mathlib.LinearAlgebra.Dimension.ErdosKaplansky","initialProofState":"K V : Type u\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LE.le Cardinal.aleph0 (Module.rank K V)\n⊢ LT.lt (Module.rank K V) (Module.rank K (LinearMap (RingHom.id K) V K))","decl":"theorem rank_lt_rank_dual {K V : Type u} [Field K] [AddCommGroup V] [Module K V]\n    (h : ℵ₀ ≤ Module.rank K V) : Module.rank K V < Module.rank K (V →ₗ[K] K) := by\n  convert lift_rank_lt_rank_dual h; rw [lift_id]\n\n"}
