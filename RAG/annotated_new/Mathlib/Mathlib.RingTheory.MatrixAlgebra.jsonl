{"name":"MatrixEquivTensor.toFunBilinear_apply","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nn : Type w\na : A\nm : Matrix n n R\n⊢ Eq (((MatrixEquivTensor.toFunBilinear R A n) a) m) (HSMul.hSMul a (m.map ⇑(algebraMap R A)))","decl":"@[simp]\ntheorem toFunBilinear_apply (a : A) (m : Matrix n n R) :\n    toFunBilinear R A n a m = a • m.map (algebraMap R A) :=\n  rfl\n\n"}
{"name":"MatrixEquivTensor.toFunAlgHom_apply","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\na : A\nm : Matrix n n R\n⊢ Eq ((MatrixEquivTensor.toFunAlgHom R A n) (TensorProduct.tmul R a m)) (HSMul.hSMul a (m.map ⇑(algebraMap R A)))","decl":"@[simp]\ntheorem toFunAlgHom_apply (a : A) (m : Matrix n n R) :\n    toFunAlgHom R A n (a ⊗ₜ m) = a • m.map (algebraMap R A) := rfl\n\n"}
{"name":"MatrixEquivTensor.invFun_zero","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (MatrixEquivTensor.invFun R A n 0) 0","decl":"@[simp]\ntheorem invFun_zero : invFun R A n 0 = 0 := by simp [invFun]\n\n"}
{"name":"MatrixEquivTensor.invFun_add","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM N : Matrix n n A\n⊢ Eq (MatrixEquivTensor.invFun R A n (HAdd.hAdd M N)) (HAdd.hAdd (MatrixEquivTensor.invFun R A n M) (MatrixEquivTensor.invFun R A n N))","decl":"@[simp]\ntheorem invFun_add (M N : Matrix n n A) :\n    invFun R A n (M + N) = invFun R A n M + invFun R A n N := by\n  simp [invFun, add_tmul, Finset.sum_add_distrib]\n\n"}
{"name":"MatrixEquivTensor.invFun_smul","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\na : A\nM : Matrix n n A\n⊢ Eq (MatrixEquivTensor.invFun R A n (HSMul.hSMul a M)) (HMul.hMul (TensorProduct.tmul R a 1) (MatrixEquivTensor.invFun R A n M))","decl":"@[simp]\ntheorem invFun_smul (a : A) (M : Matrix n n A) :\n    invFun R A n (a • M) = a ⊗ₜ 1 * invFun R A n M := by\n  simp [invFun, Finset.mul_sum]\n\n"}
{"name":"MatrixEquivTensor.invFun_algebraMap","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (MatrixEquivTensor.invFun R A n (M.map ⇑(algebraMap R A))) (TensorProduct.tmul R 1 M)","decl":"@[simp]\ntheorem invFun_algebraMap (M : Matrix n n R) : invFun R A n (M.map (algebraMap R A)) = 1 ⊗ₜ M := by\n  dsimp [invFun]\n  simp only [Algebra.algebraMap_eq_smul_one, smul_tmul, ← tmul_sum, mul_boole]\n  congr\n  conv_rhs => rw [matrix_eq_sum_stdBasisMatrix M]\n  convert Finset.sum_product (β := Matrix n n R) ..; simp\n\n"}
{"name":"MatrixEquivTensor.right_inv","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n A\n⊢ Eq ((MatrixEquivTensor.toFunAlgHom R A n) (MatrixEquivTensor.invFun R A n M)) M","decl":"theorem right_inv (M : Matrix n n A) : (toFunAlgHom R A n) (invFun R A n M) = M := by\n  simp only [invFun, map_sum, toFunAlgHom_apply]\n  convert Finset.sum_product (β := Matrix n n A) ..\n  conv_lhs => rw [matrix_eq_sum_stdBasisMatrix M]\n  refine Finset.sum_congr rfl fun i _ => Finset.sum_congr rfl fun j _ => Matrix.ext fun a b => ?_\n  dsimp [stdBasisMatrix]\n  split_ifs <;> aesop\n\n"}
{"name":"MatrixEquivTensor.left_inv","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : TensorProduct R A (Matrix n n R)\n⊢ Eq (MatrixEquivTensor.invFun R A n ((MatrixEquivTensor.toFunAlgHom R A n) M)) M","decl":"theorem left_inv (M : A ⊗[R] Matrix n n R) : invFun R A n (toFunAlgHom R A n M) = M := by\n  induction M with\n  | zero => simp\n  | tmul a m => simp\n  | add x y hx hy =>\n    rw [map_add]\n    conv_rhs => rw [← hx, ← hy, ← invFun_add]\n\n"}
{"name":"matrixEquivTensor_apply","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n A\n⊢ Eq ((matrixEquivTensor R A n) M) (Finset.univ.sum fun p => TensorProduct.tmul R (M p.1 p.2) (Matrix.stdBasisMatrix p.1 p.2 1))","decl":"@[simp]\ntheorem matrixEquivTensor_apply (M : Matrix n n A) :\n    matrixEquivTensor R A n M = ∑ p : n × n, M p.1 p.2 ⊗ₜ stdBasisMatrix p.1 p.2 1 :=\n  rfl\n\n-- Porting note: short circuiting simplifier from simplifying left hand side\n"}
{"name":"matrixEquivTensor_apply_stdBasisMatrix","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\ni j : n\nx : A\n⊢ Eq ((matrixEquivTensor R A n) (Matrix.stdBasisMatrix i j x)) (TensorProduct.tmul R x (Matrix.stdBasisMatrix i j 1))","decl":"@[simp (high)]\ntheorem matrixEquivTensor_apply_stdBasisMatrix (i j : n) (x : A) :\n    matrixEquivTensor R A n (stdBasisMatrix i j x) = x ⊗ₜ stdBasisMatrix i j 1 := by\n  have t : ∀ p : n × n, i = p.1 ∧ j = p.2 ↔ p = (i, j) := by aesop\n  simp [ite_tmul, t, stdBasisMatrix]\n\n"}
{"name":"matrixEquivTensor_apply_std_basis","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\ni j : n\nx : A\n⊢ Eq ((matrixEquivTensor R A n) (Matrix.stdBasisMatrix i j x)) (TensorProduct.tmul R x (Matrix.stdBasisMatrix i j 1))","decl":"@[deprecated (since := \"2024-08-11\")] alias matrixEquivTensor_apply_std_basis :=\n  matrixEquivTensor_apply_stdBasisMatrix\n\n"}
{"name":"matrixEquivTensor_apply_symm","module":"Mathlib.RingTheory.MatrixAlgebra","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nn : Type w\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\na : A\nM : Matrix n n R\n⊢ Eq ((matrixEquivTensor R A n).symm (TensorProduct.tmul R a M)) (M.map fun x => HMul.hMul a ((algebraMap R A) x))","decl":"@[simp]\ntheorem matrixEquivTensor_apply_symm (a : A) (M : Matrix n n R) :\n    (matrixEquivTensor R A n).symm (a ⊗ₜ M) = M.map fun x => a * algebraMap R A x :=\n  rfl\n"}
