{"name":"MeasureTheory.Measure.withDensity_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nh : μ.AbsolutelyContinuous ν\n⊢ Eq (ν.withDensity (μ.rnDeriv ν)) μ","decl":"theorem withDensity_rnDeriv_eq (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] (h : μ ≪ ν) :\n    ν.withDensity (rnDeriv μ ν) = μ := by\n  suffices μ.singularPart ν = 0 by\n    conv_rhs => rw [haveLebesgueDecomposition_add μ ν, this, zero_add]\n  suffices μ.singularPart ν Set.univ = 0 by simpa using this\n  have h_sing := mutuallySingular_singularPart μ ν\n  rw [← measure_add_measure_compl h_sing.measurableSet_nullSet]\n  simp only [MutuallySingular.measure_nullSet, zero_add]\n  refine le_antisymm ?_ (zero_le _)\n  refine (singularPart_le μ ν ?_ ).trans_eq ?_\n  exact h h_sing.measure_compl_nullSet\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_iff_withDensity_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Iff (μ.AbsolutelyContinuous ν) (Eq (ν.withDensity (μ.rnDeriv ν)) μ)","decl":"/-- **The Radon-Nikodym theorem**: Given two measures `μ` and `ν`, if\n`HaveLebesgueDecomposition μ ν`, then `μ` is absolutely continuous to `ν` if and only if\n`ν.withDensity (rnDeriv μ ν) = μ`. -/\ntheorem absolutelyContinuous_iff_withDensity_rnDeriv_eq\n    [HaveLebesgueDecomposition μ ν] : μ ≪ ν ↔ ν.withDensity (rnDeriv μ ν) = μ :=\n  ⟨withDensity_rnDeriv_eq μ ν, fun h => h ▸ withDensity_absolutelyContinuous _ _⟩\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_pos","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Filter.Eventually (fun x => LT.lt 0 (μ.rnDeriv ν x)) (MeasureTheory.ae μ)","decl":"lemma rnDeriv_pos [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :\n    ∀ᵐ x ∂μ, 0 < μ.rnDeriv ν x := by\n  rw [← Measure.withDensity_rnDeriv_eq _ _  hμν,\n    ae_withDensity_iff (Measure.measurable_rnDeriv _ _), Measure.withDensity_rnDeriv_eq _ _  hμν]\n  exact ae_of_all _ (fun x hx ↦ lt_of_le_of_ne (zero_le _) hx.symm)\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_pos'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : ν.HaveLebesgueDecomposition μ\ninst✝ : MeasureTheory.SigmaFinite μ\nhμν : μ.AbsolutelyContinuous ν\n⊢ Filter.Eventually (fun x => LT.lt 0 (ν.rnDeriv μ x)) (MeasureTheory.ae μ)","decl":"lemma rnDeriv_pos' [HaveLebesgueDecomposition ν μ] [SigmaFinite μ] (hμν : μ ≪ ν) :\n    ∀ᵐ x ∂μ, 0 < ν.rnDeriv μ x := by\n  refine (absolutelyContinuous_withDensity_rnDeriv hμν).ae_le ?_\n  filter_upwards [Measure.rnDeriv_pos (withDensity_absolutelyContinuous μ (ν.rnDeriv μ)),\n    (withDensity_absolutelyContinuous μ (ν.rnDeriv μ)).ae_le\n    (Measure.rnDeriv_withDensity μ (Measure.measurable_rnDeriv ν μ))] with x hx hx2\n  rwa [← hx2]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_withDensity_rnDeriv_left","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae ν).EventuallyEq (((ν.withDensity (μ.rnDeriv ν)).withDensity f).rnDeriv ν) ((μ.withDensity f).rnDeriv ν)","decl":"/-- Auxiliary lemma for `rnDeriv_withDensity_left`. -/\nlemma rnDeriv_withDensity_withDensity_rnDeriv_left (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]\n    (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    ((ν.withDensity (μ.rnDeriv ν)).withDensity f).rnDeriv ν =ᵐ[ν] (μ.withDensity f).rnDeriv ν := by\n  conv_rhs => rw [μ.haveLebesgueDecomposition_add ν, add_comm, withDensity_add_measure]\n  have : SigmaFinite ((μ.singularPart ν).withDensity f) :=\n    SigmaFinite.withDensity_of_ne_top (ae_mono (Measure.singularPart_le _ _) hf_ne_top)\n  have : SigmaFinite ((ν.withDensity (μ.rnDeriv ν)).withDensity f) :=\n    SigmaFinite.withDensity_of_ne_top (ae_mono (Measure.withDensity_rnDeriv_le _ _) hf_ne_top)\n  exact (rnDeriv_add_of_mutuallySingular _ _ _ (mutuallySingular_singularPart μ ν).withDensity).symm\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_withDensity_rnDeriv_right","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhf : AEMeasurable f ν\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae ν)\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae ν)\n⊢ (MeasureTheory.ae ν).EventuallyEq ((ν.withDensity (μ.rnDeriv ν)).rnDeriv (ν.withDensity f)) (μ.rnDeriv (ν.withDensity f))","decl":"/-- Auxiliary lemma for `rnDeriv_withDensity_right`. -/\nlemma rnDeriv_withDensity_withDensity_rnDeriv_right (μ ν : Measure α) [SigmaFinite μ]\n    [SigmaFinite ν] (hf : AEMeasurable f ν) (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0)\n    (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :\n    (ν.withDensity (μ.rnDeriv ν)).rnDeriv (ν.withDensity f) =ᵐ[ν] μ.rnDeriv (ν.withDensity f) := by\n  conv_rhs => rw [μ.haveLebesgueDecomposition_add ν, add_comm]\n  have hν_ac : ν ≪ ν.withDensity f := withDensity_absolutelyContinuous' hf hf_ne_zero\n  refine hν_ac.ae_eq ?_\n  have : SigmaFinite (ν.withDensity f) := SigmaFinite.withDensity_of_ne_top hf_ne_top\n  refine (rnDeriv_add_of_mutuallySingular _ _ _ ?_).symm\n  exact ((mutuallySingular_singularPart μ ν).symm.withDensity).symm\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_left_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : AEMeasurable f ν\n⊢ (MeasureTheory.ae ν).EventuallyEq ((μ.withDensity f).rnDeriv ν) fun x => HMul.hMul (f x) (μ.rnDeriv ν x)","decl":"lemma rnDeriv_withDensity_left_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]\n    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν) :\n    (μ.withDensity f).rnDeriv ν =ᵐ[ν] fun x ↦ f x * μ.rnDeriv ν x := by\n  refine (Measure.eq_rnDeriv₀ ?_ Measure.MutuallySingular.zero_left ?_).symm\n  · exact hf.mul (Measure.measurable_rnDeriv _ _).aemeasurable\n  · ext1 s hs\n    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]\n    conv_lhs => rw [← Measure.withDensity_rnDeriv_eq _ _ hμν]\n    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ _ _ _ hs]\n    · congr with x\n      rw [mul_comm]\n      simp only [Pi.mul_apply]\n    · refine ae_restrict_of_ae ?_\n      exact Measure.rnDeriv_lt_top _ _\n    · exact (Measure.measurable_rnDeriv _ _).aemeasurable\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_left","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhfν : AEMeasurable f ν\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae ν).EventuallyEq ((μ.withDensity f).rnDeriv ν) fun x => HMul.hMul (f x) (μ.rnDeriv ν x)","decl":"lemma rnDeriv_withDensity_left {μ ν : Measure α} [SigmaFinite μ] [SigmaFinite ν]\n    (hfν : AEMeasurable f ν) (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    (μ.withDensity f).rnDeriv ν =ᵐ[ν] fun x ↦ f x * μ.rnDeriv ν x := by\n  let μ' := ν.withDensity (μ.rnDeriv ν)\n  have hμ'ν : μ' ≪ ν := withDensity_absolutelyContinuous _ _\n  have h := rnDeriv_withDensity_left_of_absolutelyContinuous hμ'ν hfν\n  have h1 : μ'.rnDeriv ν =ᵐ[ν] μ.rnDeriv ν :=\n    Measure.rnDeriv_withDensity _ (Measure.measurable_rnDeriv _ _)\n  have h2 : (μ'.withDensity f).rnDeriv ν =ᵐ[ν] (μ.withDensity f).rnDeriv ν := by\n    exact rnDeriv_withDensity_withDensity_rnDeriv_left μ ν hf_ne_top\n  filter_upwards [h, h1, h2] with x hx hx1 hx2\n  rw [← hx2, hx, hx1]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_right_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : AEMeasurable f ν\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae ν)\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae ν)\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (ν.withDensity f)) fun x => HMul.hMul (Inv.inv (f x)) (μ.rnDeriv ν x)","decl":"/-- Auxiliary lemma for `rnDeriv_withDensity_right`. -/\nlemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α}\n    [HaveLebesgueDecomposition μ ν] [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)\n    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :\n    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x := by\n  have : SigmaFinite (ν.withDensity f) := SigmaFinite.withDensity_of_ne_top hf_ne_top\n  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_\n  refine (Measure.eq_rnDeriv₀ (ν := ν.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm\n  · exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul\n      (Measure.measurable_rnDeriv _ _).aemeasurable\n  · ext1 s hs\n    conv_lhs => rw [← Measure.withDensity_rnDeriv_eq _ _ hμν]\n    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]\n    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ _ _ _ hs]\n    · simp only [Pi.mul_apply]\n      have : (fun a ↦ f a * ((f a)⁻¹ * μ.rnDeriv ν a)) =ᵐ[ν] μ.rnDeriv ν := by\n        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2\n        simp [← mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]\n      rw [lintegral_congr_ae (ae_restrict_of_ae this)]\n    · refine ae_restrict_of_ae ?_\n      filter_upwards [hf_ne_top] with x hx using hx.lt_top\n    · exact hf.restrict\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_right","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhf : AEMeasurable f ν\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae ν)\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae ν)\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (ν.withDensity f)) fun x => HMul.hMul (Inv.inv (f x)) (μ.rnDeriv ν x)","decl":"lemma rnDeriv_withDensity_right (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]\n    (hf : AEMeasurable f ν) (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :\n    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x := by\n  let μ' := ν.withDensity (μ.rnDeriv ν)\n  have h₁ : μ'.rnDeriv (ν.withDensity f) =ᵐ[ν] μ.rnDeriv (ν.withDensity f) :=\n    rnDeriv_withDensity_withDensity_rnDeriv_right μ ν hf hf_ne_zero hf_ne_top\n  have h₂ : μ.rnDeriv ν =ᵐ[ν] μ'.rnDeriv ν :=\n    (Measure.rnDeriv_withDensity _ (Measure.measurable_rnDeriv _ _)).symm\n  have hμ' := rnDeriv_withDensity_right_of_absolutelyContinuous\n    (withDensity_absolutelyContinuous ν (μ.rnDeriv ν)) hf hf_ne_zero hf_ne_top\n  filter_upwards [h₁, h₂, hμ'] with x hx₁ hx₂ hx_eq\n  rw [← hx₁, hx₂, hx_eq]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_eq_zero_of_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν'\ninst✝ : MeasureTheory.SigmaFinite ν'\nh : μ.MutuallySingular ν\nhνν' : ν.AbsolutelyContinuous ν'\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv ν') 0","decl":"lemma rnDeriv_eq_zero_of_mutuallySingular {ν' : Measure α} [HaveLebesgueDecomposition μ ν']\n    [SigmaFinite ν'] (h : μ ⟂ₘ ν) (hνν' : ν ≪ ν') :\n    μ.rnDeriv ν' =ᵐ[ν] 0 := by\n  let t := h.nullSet\n  have ht : MeasurableSet t := h.measurableSet_nullSet\n  refine ae_of_ae_restrict_of_ae_restrict_compl t ?_ (by simp [t])\n  change μ.rnDeriv ν' =ᵐ[ν.restrict t] 0\n  have : μ.rnDeriv ν' =ᵐ[ν.restrict t] (μ.restrict t).rnDeriv ν' := by\n    have h : (μ.restrict t).rnDeriv ν' =ᵐ[ν] t.indicator (μ.rnDeriv ν') :=\n      hνν'.ae_le (rnDeriv_restrict μ ν' ht)\n    rw [Filter.EventuallyEq, ae_restrict_iff' ht]\n    filter_upwards [h] with x hx hxt\n    rw [hx, Set.indicator_of_mem hxt]\n  refine this.trans ?_\n  simp only [t, MutuallySingular.restrict_nullSet]\n  suffices (0 : Measure α).rnDeriv ν' =ᵐ[ν'] 0 by\n    have h_ac' : ν.restrict t ≪ ν' := restrict_le_self.absolutelyContinuous.trans hνν'\n    exact h_ac'.ae_le this\n  exact rnDeriv_zero _\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\ninst✝² : μ.HaveLebesgueDecomposition ν\ninst✝¹ : μ.HaveLebesgueDecomposition (HAdd.hAdd ν ν')\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhνν' : ν.MutuallySingular ν'\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (HAdd.hAdd ν ν')) (μ.rnDeriv ν)","decl":"/-- Auxiliary lemma for `rnDeriv_add_right_of_mutuallySingular`. -/\nlemma rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular {ν' : Measure α}\n    [HaveLebesgueDecomposition μ ν] [HaveLebesgueDecomposition μ (ν + ν')] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hνν' : ν ⟂ₘ ν') :\n    μ.rnDeriv (ν + ν') =ᵐ[ν] μ.rnDeriv ν := by\n  let t := hνν'.nullSet\n  have ht : MeasurableSet t := hνν'.measurableSet_nullSet\n  refine ae_of_ae_restrict_of_ae_restrict_compl t (by simp [t]) ?_\n  change μ.rnDeriv (ν + ν') =ᵐ[ν.restrict tᶜ] μ.rnDeriv ν\n  rw [← withDensity_eq_iff_of_sigmaFinite (μ := ν.restrict tᶜ)\n    (Measure.measurable_rnDeriv _ _).aemeasurable (Measure.measurable_rnDeriv _ _).aemeasurable]\n  have : (ν.restrict tᶜ).withDensity (μ.rnDeriv (ν + ν'))\n      = ((ν + ν').restrict tᶜ).withDensity (μ.rnDeriv (ν + ν')) := by simp [t]\n  rw [this, ← restrict_withDensity ht.compl, ← restrict_withDensity ht.compl,\n      Measure.withDensity_rnDeriv_eq _ _ (hμν.add_right ν'), Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add_right_of_mutuallySingular'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite ν'\nhμν' : μ.MutuallySingular ν'\nhνν' : ν.MutuallySingular ν'\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (HAdd.hAdd ν ν')) (μ.rnDeriv ν)","decl":"/-- Auxiliary lemma for `rnDeriv_add_right_of_mutuallySingular`. -/\nlemma rnDeriv_add_right_of_mutuallySingular' {ν' : Measure α}\n    [SigmaFinite μ] [SigmaFinite ν] [SigmaFinite ν']\n    (hμν' : μ ⟂ₘ ν') (hνν' : ν ⟂ₘ ν') :\n    μ.rnDeriv (ν + ν') =ᵐ[ν] μ.rnDeriv ν := by\n  have h_ac : ν ≪ ν + ν' := Measure.AbsolutelyContinuous.rfl.add_right _\n  rw [haveLebesgueDecomposition_add μ ν]\n  have h₁ := rnDeriv_add' (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν)) (ν + ν')\n  have h₂ := rnDeriv_add' (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν)) ν\n  refine (Filter.EventuallyEq.trans (h_ac.ae_le h₁) ?_).trans h₂.symm\n  have h₃ := rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular\n    (withDensity_absolutelyContinuous ν (μ.rnDeriv ν)) hνν'\n  have h₄ : (μ.singularPart ν).rnDeriv (ν + ν') =ᵐ[ν] 0 := by\n    refine h_ac.ae_eq ?_\n    simp only [rnDeriv_eq_zero, MutuallySingular.add_right_iff]\n    exact ⟨mutuallySingular_singularPart μ ν, hμν'.singularPart ν⟩\n  have h₅ : (μ.singularPart ν).rnDeriv ν =ᵐ[ν] 0 := rnDeriv_singularPart μ ν\n  filter_upwards [h₃, h₄, h₅] with x hx₃ hx₄ hx₅\n  simp only [Pi.add_apply]\n  rw [hx₃, hx₄, hx₅]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add_right_of_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite ν'\nhνν' : ν.MutuallySingular ν'\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (HAdd.hAdd ν ν')) (μ.rnDeriv ν)","decl":"lemma rnDeriv_add_right_of_mutuallySingular {ν' : Measure α}\n    [SigmaFinite μ] [SigmaFinite ν] [SigmaFinite ν'] (hνν' : ν ⟂ₘ ν') :\n    μ.rnDeriv (ν + ν') =ᵐ[ν] μ.rnDeriv ν := by\n  have h_ac : ν ≪ ν + ν' := Measure.AbsolutelyContinuous.rfl.add_right _\n  rw [haveLebesgueDecomposition_add μ ν']\n  have h₁ := rnDeriv_add' (μ.singularPart ν') (ν'.withDensity (μ.rnDeriv ν')) (ν + ν')\n  have h₂ := rnDeriv_add' (μ.singularPart ν') (ν'.withDensity (μ.rnDeriv ν')) ν\n  refine (Filter.EventuallyEq.trans (h_ac.ae_le h₁) ?_).trans h₂.symm\n  have h₃ := rnDeriv_add_right_of_mutuallySingular' (?_ : μ.singularPart ν' ⟂ₘ ν') hνν'\n  · have h₄ : (ν'.withDensity (rnDeriv μ ν')).rnDeriv (ν + ν') =ᵐ[ν] 0 := by\n      refine rnDeriv_eq_zero_of_mutuallySingular ?_ h_ac\n      exact hνν'.symm.withDensity\n    have h₅ : (ν'.withDensity (rnDeriv μ ν')).rnDeriv ν =ᵐ[ν] 0 := by\n      rw [rnDeriv_eq_zero]\n      exact hνν'.symm.withDensity\n    filter_upwards [h₃, h₄, h₅] with x hx₃ hx₄ hx₅\n    rw [Pi.add_apply, Pi.add_apply, hx₃, hx₄, hx₅]\n  exact mutuallySingular_singularPart μ ν'\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (μ.rnDeriv (μ.withDensity (ν.rnDeriv μ))) (μ.rnDeriv ν)","decl":"lemma rnDeriv_withDensity_rnDeriv [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    μ.rnDeriv (μ.withDensity (ν.rnDeriv μ)) =ᵐ[μ] μ.rnDeriv ν := by\n  conv_rhs => rw [ν.haveLebesgueDecomposition_add μ, add_comm]\n  refine (absolutelyContinuous_withDensity_rnDeriv hμν).ae_eq ?_\n  exact (rnDeriv_add_right_of_mutuallySingular\n    (Measure.mutuallySingular_singularPart ν μ).symm.withDensity).symm\n\n"}
{"name":"MeasureTheory.Measure.inv_rnDeriv_aux","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝² : μ.HaveLebesgueDecomposition ν\ninst✝¹ : ν.HaveLebesgueDecomposition μ\ninst✝ : MeasureTheory.SigmaFinite μ\nhμν : μ.AbsolutelyContinuous ν\nhνμ : ν.AbsolutelyContinuous μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (Inv.inv (μ.rnDeriv ν)) (ν.rnDeriv μ)","decl":"/-- Auxiliary lemma for `inv_rnDeriv`. -/\nlemma inv_rnDeriv_aux [HaveLebesgueDecomposition μ ν] [HaveLebesgueDecomposition ν μ]\n    [SigmaFinite μ] (hμν : μ ≪ ν) (hνμ : ν ≪ μ) :\n    (μ.rnDeriv ν)⁻¹ =ᵐ[μ] ν.rnDeriv μ := by\n  suffices μ.withDensity (μ.rnDeriv ν)⁻¹ = μ.withDensity (ν.rnDeriv μ) by\n    calc (μ.rnDeriv ν)⁻¹ =ᵐ[μ] (μ.withDensity (μ.rnDeriv ν)⁻¹).rnDeriv μ :=\n          (rnDeriv_withDensity _ (measurable_rnDeriv _ _).inv).symm\n    _ = (μ.withDensity (ν.rnDeriv μ)).rnDeriv μ := by rw [this]\n    _ =ᵐ[μ] ν.rnDeriv μ := rnDeriv_withDensity _ (measurable_rnDeriv _ _)\n  rw [withDensity_rnDeriv_eq _ _ hνμ, ← withDensity_rnDeriv_eq _ _ hμν]\n  conv in ((ν.withDensity (μ.rnDeriv ν)).rnDeriv ν)⁻¹ => rw [withDensity_rnDeriv_eq _ _ hμν]\n  change (ν.withDensity (μ.rnDeriv ν)).withDensity (fun x ↦ (μ.rnDeriv ν x)⁻¹) = ν\n  rw [withDensity_inv_same (measurable_rnDeriv _ _)\n    (by filter_upwards [hνμ.ae_le (rnDeriv_pos hμν)] with x hx using hx.ne')\n    (rnDeriv_ne_top _ _)]\n\n"}
{"name":"MeasureTheory.Measure.inv_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (Inv.inv (μ.rnDeriv ν)) (ν.rnDeriv μ)","decl":"lemma inv_rnDeriv [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    (μ.rnDeriv ν)⁻¹ =ᵐ[μ] ν.rnDeriv μ := by\n  suffices (μ.rnDeriv ν)⁻¹ =ᵐ[μ] (μ.rnDeriv (μ.withDensity (ν.rnDeriv μ)))⁻¹\n      ∧ ν.rnDeriv μ =ᵐ[μ] (μ.withDensity (ν.rnDeriv μ)).rnDeriv μ by\n    refine (this.1.trans (Filter.EventuallyEq.trans ?_ this.2.symm))\n    exact Measure.inv_rnDeriv_aux (absolutelyContinuous_withDensity_rnDeriv hμν)\n      (withDensity_absolutelyContinuous _ _)\n  constructor\n  · filter_upwards [rnDeriv_withDensity_rnDeriv hμν] with x hx\n    simp only [Pi.inv_apply, inv_inj]\n    exact hx.symm\n  · exact (Measure.rnDeriv_withDensity μ (Measure.measurable_rnDeriv ν μ)).symm\n\n"}
{"name":"MeasureTheory.Measure.inv_rnDeriv'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (Inv.inv (ν.rnDeriv μ)) (μ.rnDeriv ν)","decl":"lemma inv_rnDeriv' [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    (ν.rnDeriv μ)⁻¹ =ᵐ[μ] μ.rnDeriv ν := by\n  filter_upwards [inv_rnDeriv hμν] with x hx; simp only [Pi.inv_apply, ← hx, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_rnDeriv_le","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (MeasureTheory.lintegral (ν.restrict s) fun x => μ.rnDeriv ν x) (μ s)","decl":"lemma setLIntegral_rnDeriv_le (s : Set α) :\n    ∫⁻ x in s, μ.rnDeriv ν x ∂ν ≤ μ s :=\n  (withDensity_apply_le _ _).trans (Measure.le_iff'.1 (withDensity_rnDeriv_le μ ν) s)\n\n"}
{"name":"MeasureTheory.Measure.lintegral_rnDeriv_le","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ LE.le (MeasureTheory.lintegral ν fun x => μ.rnDeriv ν x) (μ Set.univ)","decl":"lemma lintegral_rnDeriv_le : ∫⁻ x, μ.rnDeriv ν x ∂ν ≤ μ Set.univ :=\n  (setLIntegral_univ _).symm ▸ Measure.setLIntegral_rnDeriv_le Set.univ\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_rnDeriv'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral (ν.restrict s) fun x => μ.rnDeriv ν x) (μ s)","decl":"lemma setLIntegral_rnDeriv' [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) {s : Set α}\n    (hs : MeasurableSet s) :\n    ∫⁻ x in s, μ.rnDeriv ν x ∂ν = μ s := by\n  rw [← withDensity_apply _ hs, Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SFinite ν\nhμν : μ.AbsolutelyContinuous ν\ns : Set α\n⊢ Eq (MeasureTheory.lintegral (ν.restrict s) fun x => μ.rnDeriv ν x) (μ s)","decl":"lemma setLIntegral_rnDeriv [HaveLebesgueDecomposition μ ν] [SFinite ν]\n    (hμν : μ ≪ ν) (s : Set α) :\n    ∫⁻ x in s, μ.rnDeriv ν x ∂ν = μ s := by\n  rw [← withDensity_apply' _ s, Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.lintegral_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Eq (MeasureTheory.lintegral ν fun x => μ.rnDeriv ν x) (μ Set.univ)","decl":"lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :\n    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ := by\n  rw [← setLIntegral_univ, setLIntegral_rnDeriv' hμν MeasurableSet.univ]\n\n"}
{"name":"MeasureTheory.Measure.integrableOn_toReal_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nhμs : Ne (μ s) Top.top\n⊢ MeasureTheory.IntegrableOn (fun x => (μ.rnDeriv ν x).toReal) s ν","decl":"lemma integrableOn_toReal_rnDeriv {s : Set α} (hμs : μ s ≠ ∞) :\n    IntegrableOn (fun x ↦ (μ.rnDeriv ν x).toReal) s ν := by\n  refine integrable_toReal_of_lintegral_ne_top (Measure.measurable_rnDeriv _ _).aemeasurable ?_\n  exact ((setLIntegral_rnDeriv_le _).trans_lt hμs.lt_top).ne\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_toReal_rnDeriv_eq_withDensity'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (ν.restrict s) fun x => (μ.rnDeriv ν x).toReal) ((ν.withDensity (μ.rnDeriv ν)) s).toReal","decl":"lemma setIntegral_toReal_rnDeriv_eq_withDensity' [SigmaFinite μ]\n    {s : Set α} (hs : MeasurableSet s) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν = (ν.withDensity (μ.rnDeriv ν) s).toReal := by\n  rw [integral_toReal (Measure.measurable_rnDeriv _ _).aemeasurable]\n  · rw [ENNReal.toReal_eq_toReal_iff, ← withDensity_apply _ hs]\n    simp\n  · exact ae_restrict_of_ae (Measure.rnDeriv_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_toReal_rnDeriv_eq_withDensity","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SFinite ν\ns : Set α\n⊢ Eq (MeasureTheory.integral (ν.restrict s) fun x => (μ.rnDeriv ν x).toReal) ((ν.withDensity (μ.rnDeriv ν)) s).toReal","decl":"lemma setIntegral_toReal_rnDeriv_eq_withDensity [SigmaFinite μ] [SFinite ν] (s : Set α) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν = (ν.withDensity (μ.rnDeriv ν) s).toReal := by\n  rw [integral_toReal (Measure.measurable_rnDeriv _ _).aemeasurable]\n  · rw [ENNReal.toReal_eq_toReal_iff, ← withDensity_apply' _ s]\n    simp\n  · exact ae_restrict_of_ae (Measure.rnDeriv_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_toReal_rnDeriv_le","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set α\nhμs : Ne (μ s) Top.top\n⊢ LE.le (MeasureTheory.integral (ν.restrict s) fun x => (μ.rnDeriv ν x).toReal) (μ s).toReal","decl":"lemma setIntegral_toReal_rnDeriv_le [SigmaFinite μ] {s : Set α} (hμs : μ s ≠ ∞) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν ≤ (μ s).toReal := by\n  set t := toMeasurable μ s with ht\n  have ht_m : MeasurableSet t := measurableSet_toMeasurable μ s\n  have hμt : μ t ≠ ∞ := by rwa [ht, measure_toMeasurable s]\n  calc ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν\n    ≤ ∫ x in t, (μ.rnDeriv ν x).toReal ∂ν := by\n        refine setIntegral_mono_set ?_ ?_ (HasSubset.Subset.eventuallyLE (subset_toMeasurable _ _))\n        · exact integrableOn_toReal_rnDeriv hμt\n        · exact ae_of_all _ (by simp)\n  _ = (withDensity ν (rnDeriv μ ν) t).toReal := setIntegral_toReal_rnDeriv_eq_withDensity' ht_m\n  _ ≤ (μ t).toReal := by\n        gcongr\n        · exact hμt\n        · apply withDensity_rnDeriv_le\n  _ = (μ s).toReal := by rw [measure_toMeasurable s]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_toReal_rnDeriv'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (ν.restrict s) fun x => (μ.rnDeriv ν x).toReal) (μ s).toReal","decl":"lemma setIntegral_toReal_rnDeriv' [SigmaFinite μ] [HaveLebesgueDecomposition μ ν]\n    (hμν : μ ≪ ν) {s : Set α} (hs : MeasurableSet s) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν = (μ s).toReal := by\n  rw [setIntegral_toReal_rnDeriv_eq_withDensity' hs, Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_toReal_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\ns : Set α\n⊢ Eq (MeasureTheory.integral (ν.restrict s) fun x => (μ.rnDeriv ν x).toReal) (μ s).toReal","decl":"lemma setIntegral_toReal_rnDeriv [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) (s : Set α) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal ∂ν = (μ s).toReal := by\n  rw [setIntegral_toReal_rnDeriv_eq_withDensity s, Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.integral_toReal_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Eq (MeasureTheory.integral ν fun x => (μ.rnDeriv ν x).toReal) (μ Set.univ).toReal","decl":"lemma integral_toReal_rnDeriv [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    ∫ x, (μ.rnDeriv ν x).toReal ∂ν = (μ Set.univ).toReal := by\n  rw [← setIntegral_univ, setIntegral_toReal_rnDeriv hμν Set.univ]\n\n"}
{"name":"MeasureTheory.Measure.integral_toReal_rnDeriv'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Eq (MeasureTheory.integral ν fun x => (μ.rnDeriv ν x).toReal) (HSub.hSub (μ Set.univ).toReal ((μ.singularPart ν) Set.univ).toReal)","decl":"lemma integral_toReal_rnDeriv' [IsFiniteMeasure μ] [SigmaFinite ν] :\n    ∫ x, (μ.rnDeriv ν x).toReal ∂ν = (μ Set.univ).toReal - (μ.singularPart ν Set.univ).toReal := by\n  rw [← ENNReal.toReal_sub_of_le (μ.singularPart_le ν Set.univ) (measure_ne_top _ _),\n    ← Measure.sub_apply .univ (Measure.singularPart_le μ ν), Measure.measure_sub_singularPart,\n    ← Measure.setIntegral_toReal_rnDeriv_eq_withDensity, setIntegral_univ]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_mul_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν κ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite κ\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae κ).EventuallyEq (HMul.hMul (μ.rnDeriv ν) (ν.rnDeriv κ)) (μ.rnDeriv κ)","decl":"lemma rnDeriv_mul_rnDeriv {κ : Measure α} [SigmaFinite μ] [SigmaFinite ν] [SigmaFinite κ]\n    (hμν : μ ≪ ν) :\n    μ.rnDeriv ν * ν.rnDeriv κ =ᵐ[κ] μ.rnDeriv κ := by\n  refine (rnDeriv_withDensity_left ?_ ?_).symm.trans ?_\n  · exact (Measure.measurable_rnDeriv _ _).aemeasurable\n  · exact rnDeriv_ne_top _ _\n  · rw [Measure.withDensity_rnDeriv_eq _ _ hμν]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_mul_rnDeriv'","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν κ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite κ\nhνκ : ν.AbsolutelyContinuous κ\n⊢ (MeasureTheory.ae ν).EventuallyEq (HMul.hMul (μ.rnDeriv ν) (ν.rnDeriv κ)) (μ.rnDeriv κ)","decl":"lemma rnDeriv_mul_rnDeriv' {κ : Measure α} [SigmaFinite μ] [SigmaFinite ν] [SigmaFinite κ]\n    (hνκ : ν ≪ κ) :\n    μ.rnDeriv ν * ν.rnDeriv κ =ᵐ[ν] μ.rnDeriv κ := by\n  obtain ⟨h_meas, h_sing, hμν⟩ := Measure.haveLebesgueDecomposition_spec μ ν\n  filter_upwards [hνκ <| Measure.rnDeriv_add' (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν)) κ,\n    hνκ <| Measure.rnDeriv_withDensity_left_of_absolutelyContinuous hνκ h_meas.aemeasurable,\n    Measure.rnDeriv_eq_zero_of_mutuallySingular h_sing hνκ] with x hx1 hx2 hx3\n  nth_rw 2 [hμν]\n  rw [hx1, Pi.add_apply, hx2, Pi.mul_apply, hx3, Pi.zero_apply, zero_add]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_le_one_of_le","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nhμν : LE.le μ ν\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ (MeasureTheory.ae ν).EventuallyLE (μ.rnDeriv ν) 1","decl":"lemma rnDeriv_le_one_of_le (hμν : μ ≤ ν) [SigmaFinite ν] : μ.rnDeriv ν ≤ᵐ[ν] 1 := by\n  refine ae_le_of_forall_setLIntegral_le_of_sigmaFinite (μ.measurable_rnDeriv ν) fun s _ _ ↦ ?_\n  simp only [Pi.one_apply, MeasureTheory.setLIntegral_one]\n  exact (Measure.setLIntegral_rnDeriv_le s).trans (hμν s)\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_le_one_iff_le","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Iff ((MeasureTheory.ae ν).EventuallyLE (μ.rnDeriv ν) 1) (LE.le μ ν)","decl":"lemma rnDeriv_le_one_iff_le [HaveLebesgueDecomposition μ ν] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    μ.rnDeriv ν ≤ᵐ[ν] 1 ↔ μ ≤ ν := by\n  refine ⟨fun h s ↦ ?_, fun h ↦ rnDeriv_le_one_of_le h⟩\n  rw [← withDensity_rnDeriv_eq _ _ hμν, withDensity_apply', ← setLIntegral_one]\n  exact setLIntegral_mono_ae aemeasurable_const (h.mono fun _ hh _ ↦ hh)\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_eq_one_iff_eq","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ Iff ((MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv ν) 1) (Eq μ ν)","decl":"lemma rnDeriv_eq_one_iff_eq [HaveLebesgueDecomposition μ ν] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    μ.rnDeriv ν =ᵐ[ν] 1 ↔ μ = ν := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h ▸ ν.rnDeriv_self⟩\n  rw [← withDensity_rnDeriv_eq _ _ hμν, withDensity_congr_ae h, withDensity_one]\n\n"}
{"name":"MeasurableEmbedding.rnDeriv_map_aux","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nmβ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nhμν : μ.AbsolutelyContinuous ν\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => (MeasureTheory.Measure.map f μ).rnDeriv (MeasureTheory.Measure.map f ν) (f x)) (μ.rnDeriv ν)","decl":"lemma _root_.MeasurableEmbedding.rnDeriv_map_aux (hf : MeasurableEmbedding f)\n    (hμν : μ ≪ ν) [SigmaFinite μ] [SigmaFinite ν] :\n    (fun x ↦ (μ.map f).rnDeriv (ν.map f) (f x)) =ᵐ[ν] μ.rnDeriv ν := by\n  refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite ?_ ?_ (fun s _ _ ↦ ?_)\n  · exact (Measure.measurable_rnDeriv _ _).comp hf.measurable\n  · exact Measure.measurable_rnDeriv _ _\n  rw [← hf.lintegral_map, Measure.setLIntegral_rnDeriv hμν]\n  have hs_eq : s = f ⁻¹' (f '' s) := by rw [hf.injective.preimage_image]\n  have : SigmaFinite (ν.map f) := hf.sigmaFinite_map\n  rw [hs_eq, ← hf.restrict_map, Measure.setLIntegral_rnDeriv (hf.absolutelyContinuous_map hμν),\n    hf.map_apply]\n\n"}
{"name":"MeasurableEmbedding.rnDeriv_map","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => (MeasureTheory.Measure.map f μ).rnDeriv (MeasureTheory.Measure.map f ν) (f x)) (μ.rnDeriv ν)","decl":"lemma _root_.MeasurableEmbedding.rnDeriv_map (hf : MeasurableEmbedding f)\n    (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    (fun x ↦ (μ.map f).rnDeriv (ν.map f) (f x)) =ᵐ[ν] μ.rnDeriv ν := by\n  rw [μ.haveLebesgueDecomposition_add ν, Measure.map_add _ _ hf.measurable]\n  have : SigmaFinite (map f ν) := hf.sigmaFinite_map\n  have : SigmaFinite (map f (μ.singularPart ν)) := hf.sigmaFinite_map\n  have : SigmaFinite (map f (ν.withDensity (μ.rnDeriv ν))) := hf.sigmaFinite_map\n  have h_add := Measure.rnDeriv_add' ((μ.singularPart ν).map f)\n    ((ν.withDensity (μ.rnDeriv ν)).map f) (ν.map f)\n  rw [Filter.EventuallyEq, hf.ae_map_iff, ← Filter.EventuallyEq] at h_add\n  refine h_add.trans ((Measure.rnDeriv_add' _ _ _).trans ?_).symm\n  refine Filter.EventuallyEq.add ?_ ?_\n  · refine (Measure.rnDeriv_singularPart μ ν).trans ?_\n    symm\n    suffices (fun x ↦ ((μ.singularPart ν).map f).rnDeriv (ν.map f) x) =ᵐ[ν.map f] 0 by\n      rw [Filter.EventuallyEq, hf.ae_map_iff] at this\n      exact this\n    refine Measure.rnDeriv_eq_zero_of_mutuallySingular ?_ Measure.AbsolutelyContinuous.rfl\n    exact hf.mutuallySingular_map (μ.mutuallySingular_singularPart ν)\n  · exact (hf.rnDeriv_map_aux (withDensity_absolutelyContinuous _ _)).symm\n\n"}
{"name":"MeasurableEmbedding.map_withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Eq (MeasureTheory.Measure.map f (ν.withDensity (μ.rnDeriv ν))) ((MeasureTheory.Measure.map f ν).withDensity ((MeasureTheory.Measure.map f μ).rnDeriv (MeasureTheory.Measure.map f ν)))","decl":"lemma _root_.MeasurableEmbedding.map_withDensity_rnDeriv (hf : MeasurableEmbedding f)\n    (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    (ν.withDensity (μ.rnDeriv ν)).map f = (ν.map f).withDensity ((μ.map f).rnDeriv (ν.map f)) := by\n  ext s hs\n  rw [hf.map_apply, withDensity_apply _ (hf.measurable hs), withDensity_apply _ hs,\n    setLIntegral_map hs (Measure.measurable_rnDeriv _ _) hf.measurable]\n  refine setLIntegral_congr_fun (hf.measurable hs) ?_\n  filter_upwards [hf.rnDeriv_map μ ν] with a ha _ using ha.symm\n\n"}
{"name":"MeasurableEmbedding.singularPart_map","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ Eq ((MeasureTheory.Measure.map f μ).singularPart (MeasureTheory.Measure.map f ν)) (MeasureTheory.Measure.map f (μ.singularPart ν))","decl":"lemma _root_.MeasurableEmbedding.singularPart_map (hf : MeasurableEmbedding f)\n    (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] :\n    (μ.map f).singularPart (ν.map f) = (μ.singularPart ν).map f := by\n  have h_add : μ.map f = (μ.singularPart ν).map f\n      + (ν.map f).withDensity ((μ.map f).rnDeriv (ν.map f)) := by\n    conv_lhs => rw [μ.haveLebesgueDecomposition_add ν]\n    rw [Measure.map_add _ _ hf.measurable, ← hf.map_withDensity_rnDeriv μ ν]\n  refine (Measure.eq_singularPart (Measure.measurable_rnDeriv _ _) ?_ h_add).symm\n  exact hf.mutuallySingular_map (μ.mutuallySingular_singularPart ν)\n\n"}
{"name":"MeasureTheory.SignedMeasure.withDensityᵥ_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nh : MeasureTheory.VectorMeasure.AbsolutelyContinuous s μ.toENNRealVectorMeasure\n⊢ Eq (μ.withDensityᵥ (s.rnDeriv μ)) s","decl":"theorem withDensityᵥ_rnDeriv_eq (s : SignedMeasure α) (μ : Measure α) [SigmaFinite μ]\n    (h : s ≪ᵥ μ.toENNRealVectorMeasure) : μ.withDensityᵥ (s.rnDeriv μ) = s := by\n  rw [absolutelyContinuous_ennreal_iff, (_ : μ.toENNRealVectorMeasure.ennrealToMeasure = μ),\n    totalVariation_absolutelyContinuous_iff] at h\n  · ext1 i hi\n    rw [withDensityᵥ_apply (integrable_rnDeriv _ _) hi, rnDeriv_def, integral_sub,\n      setIntegral_toReal_rnDeriv h.1 i, setIntegral_toReal_rnDeriv h.2 i]\n    · conv_rhs => rw [← s.toSignedMeasure_toJordanDecomposition]\n      erw [VectorMeasure.sub_apply]\n      rw [toSignedMeasure_apply_measurable hi, toSignedMeasure_apply_measurable hi]\n    all_goals\n      rw [← integrableOn_univ]\n      refine IntegrableOn.restrict ?_ MeasurableSet.univ\n      refine ⟨?_, hasFiniteIntegral_toReal_of_lintegral_ne_top ?_⟩\n      · apply Measurable.aestronglyMeasurable (by fun_prop)\n      · rw [setLIntegral_univ]\n        exact (lintegral_rnDeriv_lt_top _ _).ne\n  · exact equivMeasure.right_inv μ\n\n"}
{"name":"MeasureTheory.SignedMeasure.absolutelyContinuous_iff_withDensityᵥ_rnDeriv_eq","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Iff (MeasureTheory.VectorMeasure.AbsolutelyContinuous s μ.toENNRealVectorMeasure) (Eq (μ.withDensityᵥ (s.rnDeriv μ)) s)","decl":"/-- The Radon-Nikodym theorem for signed measures. -/\ntheorem absolutelyContinuous_iff_withDensityᵥ_rnDeriv_eq (s : SignedMeasure α) (μ : Measure α)\n    [SigmaFinite μ] : s ≪ᵥ μ.toENNRealVectorMeasure ↔ μ.withDensityᵥ (s.rnDeriv μ) = s :=\n  ⟨withDensityᵥ_rnDeriv_eq s μ, fun h => h ▸ withDensityᵥ_absolutelyContinuous _ _⟩\n\n"}
{"name":"MeasureTheory.lintegral_rnDeriv_mul","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\nf : α → ENNReal\nhf : AEMeasurable f ν\n⊢ Eq (MeasureTheory.lintegral ν fun x => HMul.hMul (μ.rnDeriv ν x) (f x)) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem lintegral_rnDeriv_mul [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f ν) : ∫⁻ x, μ.rnDeriv ν x * f x ∂ν = ∫⁻ x, f x ∂μ := by\n  nth_rw 2 [← withDensity_rnDeriv_eq μ ν hμν]\n  rw [lintegral_withDensity_eq_lintegral_mul₀ (measurable_rnDeriv μ ν).aemeasurable hf]\n  simp only [Pi.mul_apply]\n\n"}
{"name":"MeasureTheory.setLIntegral_rnDeriv_mul","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\nf : α → ENNReal\nhf : AEMeasurable f ν\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral (ν.restrict s) fun x => HMul.hMul (μ.rnDeriv ν x) (f x)) (MeasureTheory.lintegral (μ.restrict s) fun x => f x)","decl":"lemma setLIntegral_rnDeriv_mul [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f ν) {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ x in s, μ.rnDeriv ν x * f x ∂ν = ∫⁻ x in s, f x ∂μ := by\n  nth_rw 2 [← Measure.withDensity_rnDeriv_eq μ ν hμν]\n  rw [setLIntegral_withDensity_eq_lintegral_mul₀ (measurable_rnDeriv μ ν).aemeasurable hf hs]\n  simp only [Pi.mul_apply]\n\n"}
{"name":"MeasureTheory.integrable_rnDeriv_smul_iff","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → E\nhμν : μ.AbsolutelyContinuous ν\n⊢ Iff (MeasureTheory.Integrable (fun x => HSMul.hSMul (μ.rnDeriv ν x).toReal (f x)) ν) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_rnDeriv_smul_iff (hμν : μ ≪ ν) :\n    Integrable (fun x ↦ (μ.rnDeriv ν x).toReal • f x) ν ↔ Integrable f μ := by\n  nth_rw 2 [← withDensity_rnDeriv_eq μ ν hμν]\n  rw [← integrable_withDensity_iff_integrable_smul' (E := E)\n    (measurable_rnDeriv μ ν) (rnDeriv_lt_top μ ν)]\n\n"}
{"name":"MeasureTheory.withDensityᵥ_rnDeriv_smul","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → E\nhμν : μ.AbsolutelyContinuous ν\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (ν.withDensityᵥ fun x => HSMul.hSMul (μ.rnDeriv ν x).toReal (f x)) (μ.withDensityᵥ f)","decl":"theorem withDensityᵥ_rnDeriv_smul (hμν : μ ≪ ν) (hf : Integrable f μ) :\n    ν.withDensityᵥ (fun x ↦ (rnDeriv μ ν x).toReal • f x) = μ.withDensityᵥ f := by\n  rw [withDensityᵥ_smul_eq_withDensityᵥ_withDensity' (measurable_rnDeriv μ ν).aemeasurable\n    (rnDeriv_lt_top μ ν) ((integrable_rnDeriv_smul_iff hμν).mpr hf), withDensity_rnDeriv_eq μ ν hμν]\n\n"}
{"name":"MeasureTheory.integral_rnDeriv_smul","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → E\nhμν : μ.AbsolutelyContinuous ν\n⊢ Eq (MeasureTheory.integral ν fun x => HSMul.hSMul (μ.rnDeriv ν x).toReal (f x)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_rnDeriv_smul (hμν : μ ≪ ν) :\n    ∫ x, (μ.rnDeriv ν x).toReal • f x ∂ν = ∫ x, f x ∂μ := by\n  by_cases hf : Integrable f μ\n  · rw [← setIntegral_univ, ← withDensityᵥ_apply ((integrable_rnDeriv_smul_iff hμν).mpr hf) .univ,\n      ← setIntegral_univ, ← withDensityᵥ_apply hf .univ, withDensityᵥ_rnDeriv_smul hμν hf]\n  · rw [integral_undef hf, integral_undef]\n    contrapose! hf\n    exact (integrable_rnDeriv_smul_iff hμν).mp hf\n\n"}
{"name":"MeasureTheory.setIntegral_rnDeriv_smul","module":"Mathlib.MeasureTheory.Decomposition.RadonNikodym","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → E\nhμν : μ.AbsolutelyContinuous ν\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (ν.restrict s) fun x => HSMul.hSMul (μ.rnDeriv ν x).toReal (f x)) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"lemma setIntegral_rnDeriv_smul (hμν : μ ≪ ν) {s : Set α} (hs : MeasurableSet s) :\n    ∫ x in s, (μ.rnDeriv ν x).toReal • f x ∂ν = ∫ x in s, f x ∂μ := by\n  simp_rw [← integral_indicator hs, Set.indicator_smul, integral_rnDeriv_smul hμν]\n\n"}
