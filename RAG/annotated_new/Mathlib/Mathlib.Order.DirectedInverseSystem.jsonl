{"name":"DirectedSystem.map_self","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝ : Preorder ι\nF : ι → Type u_4\nf : ⦃i j : ι⦄ → LE.le i j → F i → F j\nself : DirectedSystem F f\ni : ι\nx : F i\n⊢ Eq (f ⋯ x) x","decl":"variable (F) in\n/-- A directed system is a functor from a category (directed poset) to another category. -/\nclass DirectedSystem (f : ∀ ⦃i j⦄, i ≤ j → F i → F j) : Prop where\n  map_self ⦃i⦄ (x : F i) : f le_rfl x = x\n  map_map ⦃k j i⦄ (hij : i ≤ j) (hjk : j ≤ k) (x : F i) : f hjk (f hij x) = f (hij.trans hjk) x\n\n"}
{"name":"DirectedSystem.map_map","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝ : Preorder ι\nF : ι → Type u_4\nf : ⦃i j : ι⦄ → LE.le i j → F i → F j\nself : DirectedSystem F f\nk j i : ι\nhij : LE.le i j\nhjk : LE.le j k\nx : F i\n⊢ Eq (f hjk (f hij x)) (f ⋯ x)","decl":"variable (F) in\n/-- A directed system is a functor from a category (directed poset) to another category. -/\nclass DirectedSystem (f : ∀ ⦃i j⦄, i ≤ j → F i → F j) : Prop where\n  map_self ⦃i⦄ (x : F i) : f le_rfl x = x\n  map_map ⦃k j i⦄ (hij : i ≤ j) (hjk : j ≤ k) (x : F i) : f hjk (f hij x) = f (hij.trans hjk) x\n\n"}
{"name":"DirectedSystem.map_self'","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni : ι\nx : F i\n⊢ Eq ((f i i ⋯) x) x","decl":"/-- A copy of `DirectedSystem.map_self` specialized to FunLike, as otherwise the\n`fun i j h ↦ f i j h` can confuse the simplifier. -/\ntheorem DirectedSystem.map_self' ⦃i⦄ (x) : f i i le_rfl x = x :=\n  DirectedSystem.map_self (f := (f · · ·)) x\n\n"}
{"name":"DirectedSystem.map_map'","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni j k : ι\nhij : LE.le i j\nhjk : LE.le j k\nx : F i\n⊢ Eq ((f j k hjk) ((f i j hij) x)) ((f i k ⋯) x)","decl":"/-- A copy of `DirectedSystem.map_map` specialized to FunLike, as otherwise the\n`fun i j h ↦ f i j h` can confuse the simplifier. -/\ntheorem DirectedSystem.map_map' ⦃i j k⦄ (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (hij.trans hjk) x :=\n  DirectedSystem.map_map (f := (f · · ·)) hij hjk x\n\n"}
{"name":"DirectLimit.r_of_le","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nx : Sigma fun i => F i\ni : ι\nh : LE.le x.fst i\n⊢ (DirectLimit.setoid f) x ⟨i, (f x.fst i h) x.snd⟩","decl":"theorem r_of_le (x : Σ i, F i) (i : ι) (h : x.1 ≤ i) : (setoid f).r x ⟨i, f _ _ h x.2⟩ :=\n  ⟨i, h, le_rfl, (map_map' _ _ _ _).symm⟩\n\n"}
{"name":"DirectLimit.eq_of_le","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nx : Sigma fun i => F i\ni : ι\nh : LE.le x.fst i\n⊢ Eq (Quotient.mk (DirectLimit.setoid f) x) (Quotient.mk (DirectLimit.setoid f) ⟨i, (f x.fst i h) x.snd⟩)","decl":"variable {f} in\ntheorem eq_of_le (x : Σ i, F i) (i : ι) (h : x.1 ≤ i) :\n    (⟦x⟧ : DirectLimit F f) = ⟦⟨i, f _ _ h x.2⟩⟧ :=\n  Quotient.sound (r_of_le _ x i h)\n\n"}
{"name":"DirectLimit.induction","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : DirectLimit F f → Prop\nih : ∀ (i : ι) (x : F i), C (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)\nx : DirectLimit F f\n⊢ C x","decl":"@[elab_as_elim] protected theorem induction {C : DirectLimit F f → Prop}\n    (ih : ∀ i x, C ⟦⟨i, x⟩⟧) (x : DirectLimit F f) : C x :=\n  Quotient.ind (fun _ ↦ ih _ _) x\n\n"}
{"name":"DirectLimit.exists_eq_mk","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nz : DirectLimit F f\n⊢ Exists fun i => Exists fun x => Eq z (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)","decl":"theorem exists_eq_mk (z : DirectLimit F f) : ∃ i x, z = ⟦⟨i, x⟩⟧ := by rcases z; exact ⟨_, _, rfl⟩\n\n"}
{"name":"DirectLimit.exists_eq_mk₂","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nz w : DirectLimit F f\n⊢ Exists fun i => Exists fun x => Exists fun y => And (Eq z (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Eq w (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩))","decl":"theorem exists_eq_mk₂ (z w : DirectLimit F f) : ∃ i x y, z = ⟦⟨i, x⟩⟧ ∧ w = ⟦⟨i, y⟩⟧ :=\n  z.inductionOn₂ w fun x y ↦\n    have ⟨i, hxi, hyi⟩ := exists_ge_ge x.1 y.1\n    ⟨i, _, _, eq_of_le x i hxi, eq_of_le y i hyi⟩\n\n"}
{"name":"DirectLimit.exists_eq_mk₃","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nw u v : DirectLimit F f\n⊢ Exists fun i => Exists fun x => Exists fun y => Exists fun z => And (Eq w (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (And (Eq u (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Eq v (Quotient.mk (DirectLimit.setoid f) ⟨i, z⟩)))","decl":"theorem exists_eq_mk₃ (w u v : DirectLimit F f) :\n    ∃ i x y z, w = ⟦⟨i, x⟩⟧ ∧ u = ⟦⟨i, y⟩⟧ ∧ v = ⟦⟨i, z⟩⟧ :=\n  w.inductionOn₃ u v fun x y z ↦\n    have ⟨i, hxi, hyi, hzi⟩ := directed_of₃ (· ≤ ·) x.1 y.1 z.1\n    ⟨i, _, _, _, eq_of_le x i hxi, eq_of_le y i hyi, eq_of_le z i hzi⟩\n\n"}
{"name":"DirectLimit.induction₂","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : DirectLimit F f → DirectLimit F f → Prop\nih : ∀ (i : ι) (x y : F i), C (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)\nx y : DirectLimit F f\n⊢ C x y","decl":"@[elab_as_elim] protected theorem induction₂ {C : DirectLimit F f → DirectLimit F f → Prop}\n    (ih : ∀ i x y, C ⟦⟨i, x⟩⟧ ⟦⟨i, y⟩⟧) (x y : DirectLimit F f) : C x y := by\n  obtain ⟨_, _, _, rfl, rfl⟩ := exists_eq_mk₂ f x y; apply ih\n\n"}
{"name":"DirectLimit.induction₃","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : DirectLimit F f → DirectLimit F f → DirectLimit F f → Prop\nih : ∀ (i : ι) (x y z : F i), C (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, z⟩)\nx y z : DirectLimit F f\n⊢ C x y z","decl":"@[elab_as_elim] protected theorem induction₃\n    {C : DirectLimit F f → DirectLimit F f → DirectLimit F f → Prop}\n    (ih : ∀ i x y z, C ⟦⟨i, x⟩⟧ ⟦⟨i, y⟩⟧ ⟦⟨i, z⟩⟧) (x y z : DirectLimit F f) : C x y z := by\n  obtain ⟨_, _, _, _, rfl, rfl, rfl⟩ := exists_eq_mk₃ f x y z; apply ih\n\n"}
{"name":"DirectLimit.mk_injective","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝¹ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nh : ∀ (i j : ι) (hij : LE.le i j), Function.Injective ⇑(f i j hij)\ni : ι\n⊢ Function.Injective fun x => Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩","decl":"theorem mk_injective (h : ∀ i j hij, Function.Injective (f i j hij)) (i) :\n    Function.Injective fun x ↦ (⟦⟨i, x⟩⟧ : DirectLimit F f) :=\n  fun _ _ eq ↦ have ⟨_, _, _, eq⟩ := Quotient.eq.mp eq; h _ _ _ eq\n\n"}
{"name":"DirectLimit.map₀_def","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝⁴ : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝³ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝² : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty ι\nih : (i : ι) → F i\ncompat : ∀ (i j : ι) (h : LE.le i j), Eq ((f i j h) (ih i)) (ih j)\ni : ι\n⊢ Eq (DirectLimit.map₀ f ih) (Quotient.mk (DirectLimit.setoid f) ⟨i, ih i⟩)","decl":"theorem map₀_def (compat : ∀ i j h, f i j h (ih i) = ih j) (i) : map₀ f ih = ⟦⟨i, ih i⟩⟧ :=\n  have ⟨j, hcj, hij⟩ := exists_ge_ge (Classical.arbitrary ι) i\n  Quotient.sound ⟨j, hcj, hij, (compat ..).trans (compat ..).symm⟩\n\n"}
{"name":"DirectLimit.lift₂_def₂","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝⁵ : Preorder ι\nF₁ : ι → Type u_2\nF₂ : ι → Type u_3\nT₁ : ⦃i j : ι⦄ → LE.le i j → Sort u_6\nf₁ : (i j : ι) → (h : LE.le i j) → T₁ h\ninst✝⁴ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T₁ h) (F₁ i) (F₁ j)\ninst✝³ : DirectedSystem F₁ fun x1 x2 x3 => ⇑(f₁ x1 x2 x3)\nT₂ : ⦃i j : ι⦄ → LE.le i j → Sort u_7\nf₂ : (i j : ι) → (h : LE.le i j) → T₂ h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T₂ h) (F₂ i) (F₂ j)\ninst✝¹ : DirectedSystem F₂ fun x1 x2 x3 => ⇑(f₂ x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : Sort u_9\nih : (i : ι) → F₁ i → F₂ i → C\ncompat : ∀ (i j : ι) (h : LE.le i j) (x : F₁ i) (y : F₂ i), Eq (ih i x y) (ih j ((f₁ i j h) x) ((f₂ i j h) y))\nx : Sigma fun i => F₁ i\ny : Sigma fun i => F₂ i\ni : ι\nhxi : LE.le x.fst i\nhyi : LE.le y.fst i\n⊢ Eq (DirectLimit.lift₂ f₁ f₂ ih compat (Quotient.mk (DirectLimit.setoid f₁) x) (Quotient.mk (DirectLimit.setoid f₂) y)) (ih i ((f₁ x.fst i hxi) x.snd) ((f₂ y.fst i hyi) y.snd))","decl":"theorem lift₂_def₂ (x : Σ i, F₁ i) (y : Σ i, F₂ i) (i) (hxi : x.1 ≤ i) (hyi : y.1 ≤ i) :\n    DirectLimit.lift₂ f₁ f₂ ih compat ⟦x⟧ ⟦y⟧ = ih i (f₁ _ _ hxi x.2) (f₂ _ _ hyi y.2) :=\n  (lift₂Aux _ _ _ compat _ _).2 ..\n\n"}
{"name":"DirectLimit.lift₂_def","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝⁵ : Preorder ι\nF₁ : ι → Type u_2\nF₂ : ι → Type u_3\nT₁ : ⦃i j : ι⦄ → LE.le i j → Sort u_6\nf₁ : (i j : ι) → (h : LE.le i j) → T₁ h\ninst✝⁴ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T₁ h) (F₁ i) (F₁ j)\ninst✝³ : DirectedSystem F₁ fun x1 x2 x3 => ⇑(f₁ x1 x2 x3)\nT₂ : ⦃i j : ι⦄ → LE.le i j → Sort u_7\nf₂ : (i j : ι) → (h : LE.le i j) → T₂ h\ninst✝² : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T₂ h) (F₂ i) (F₂ j)\ninst✝¹ : DirectedSystem F₂ fun x1 x2 x3 => ⇑(f₂ x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : Sort u_9\nih : (i : ι) → F₁ i → F₂ i → C\ncompat : ∀ (i j : ι) (h : LE.le i j) (x : F₁ i) (y : F₂ i), Eq (ih i x y) (ih j ((f₁ i j h) x) ((f₂ i j h) y))\ni : ι\nx : F₁ i\ny : F₂ i\n⊢ Eq (DirectLimit.lift₂ f₁ f₂ ih compat (Quotient.mk (DirectLimit.setoid f₁) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f₂) ⟨i, y⟩)) (ih i x y)","decl":"theorem lift₂_def (i x y) : DirectLimit.lift₂ f₁ f₂ ih compat ⟦⟨i, x⟩⟧ ⟦⟨i, y⟩⟧ = ih i x y := by\n  rw [lift₂_def₂ _ _ _ _ _ _ i le_rfl le_rfl, map_self', map_self']\n\n"}
{"name":"InverseSystem.map_map","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝ : Preorder ι\nF : ι → Type u_4\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\nself : InverseSystem f\nk j i : ι\nhkj : LE.le k j\nhji : LE.le j i\nx : F i\n⊢ Eq (f hkj (f hji x)) (f ⋯ x)","decl":"/-- A inverse system indexed by a preorder is a contravariant functor from the preorder\nto another category. It is dual to `DirectedSystem`. -/\nclass InverseSystem : Prop where\n  map_self ⦃i⦄ (x : F i) : f le_rfl x = x\n  map_map ⦃k j i⦄ (hkj : k ≤ j) (hji : j ≤ i) (x : F i) : f hkj (f hji x) = f (hkj.trans hji) x\n\n"}
{"name":"InverseSystem.map_self","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝ : Preorder ι\nF : ι → Type u_4\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\nself : InverseSystem f\ni : ι\nx : F i\n⊢ Eq (f ⋯ x) x","decl":"/-- A inverse system indexed by a preorder is a contravariant functor from the preorder\nto another category. It is dual to `DirectedSystem`. -/\nclass InverseSystem : Prop where\n  map_self ⦃i⦄ (x : F i) : f le_rfl x = x\n  map_map ⦃k j i⦄ (hkj : k ≤ j) (hji : j ≤ i) (x : F i) : f hkj (f hji x) = f (hkj.trans hji) x\n\n"}
{"name":"InverseSystem.piLTProj_intro","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_1\ninst✝ : Preorder ι\nX : ι → Type u_5\ni j : ι\nh : LE.le i j\nl : ↑(Set.Iio j)\nf : InverseSystem.piLT X j\nhl : LT.lt (↑l) i\n⊢ Eq (f l) (InverseSystem.piLTProj h f ⟨↑l, hl⟩)","decl":"theorem piLTProj_intro {l : Iio j} {f : piLT X j} (hl : l < i) :\n    f l = piLTProj h f ⟨l, hl⟩ := rfl\n\n"}
{"name":"InverseSystem.piLTLim_apply","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\ninst✝ : LinearOrder ι\nX : ι → Type u_7\ni : ι\nhi : Order.IsSuccPrelimit i\nf : InverseSystem.piLT X i\n⊢ Eq ((InverseSystem.piLTLim hi) f) ⟨fun j => InverseSystem.piLTProj ⋯ f, ⋯⟩","decl":"/-- If `i` is a limit in a well-ordered type indexing a family of types,\nthen `piLT X i` is the limit of all `piLT X j` for `j < i`. -/\n@[simps apply] noncomputable def piLTLim : piLT X i ≃ limit (piLTProj (X := X)) i where\n  toFun f := ⟨fun j ↦ piLTProj j.2.le f, fun _ _ _ ↦ rfl⟩\n  invFun f l := let k := hi.mid l.2; f.1 ⟨k, k.2.2⟩ ⟨l, k.2.1⟩\n  left_inv f := rfl\n  right_inv f := by\n    ext j l\n    set k := hi.mid (l.2.trans j.2)\n    obtain le | le := le_total j ⟨k, k.2.2⟩\n    exacts [congr_fun (f.2 le) l, (congr_fun (f.2 le) ⟨l, _⟩).symm]\n\n"}
{"name":"InverseSystem.piLTLim_symm_apply","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\ninst✝ : LinearOrder ι\nX : ι → Type u_7\ni : ι\nhi : Order.IsSuccPrelimit i\nf : ↑(InverseSystem.limit InverseSystem.piLTProj i)\nk l : ↑(Set.Iio i)\nhl : LT.lt ↑l ↑k\n⊢ Eq ((InverseSystem.piLTLim hi).symm f l) (↑f k ⟨↑l, hl⟩)","decl":"theorem piLTLim_symm_apply {f} (k : Iio i) {l : Iio i} (hl : l.1 < k.1) :\n    (piLTLim (X := X) hi).symm f l = f.1 k ⟨l, hl⟩ := by\n  conv_rhs => rw [← (piLTLim hi).right_inv f]\n  rfl\n\n"}
{"name":"InverseSystem.piSplitLE_eq","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nX : ι → Type u_8\ni : ι\ninst✝¹ : PartialOrder ι\ninst✝ : DecidableEq ι\nf : Prod (InverseSystem.piLT X i) (X i)\n⊢ Eq (InverseSystem.piSplitLE f ⟨i, ⋯⟩) f.2","decl":"@[simp] theorem piSplitLE_eq {f : piLT X i × X i} :\n    piSplitLE f ⟨i, le_rfl⟩ = f.2 := by simp [piSplitLE]\n\n"}
{"name":"InverseSystem.piSplitLE_lt","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nX : ι → Type u_8\ni : ι\ninst✝¹ : PartialOrder ι\ninst✝ : DecidableEq ι\nf : Prod (InverseSystem.piLT X i) (X i)\nj : ι\nhj : LT.lt j i\n⊢ Eq (InverseSystem.piSplitLE f ⟨j, ⋯⟩) (f.1 ⟨j, hj⟩)","decl":"theorem piSplitLE_lt {f : piLT X i × X i} {j} (hj : j < i) :\n    piSplitLE f ⟨j, hj.le⟩ = f.1 ⟨j, hj⟩ := dif_neg hj.ne\n\n"}
{"name":"InverseSystem.piEquivSucc_self","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ni : ι\ninst✝¹ : LinearOrder ι\ninst✝ : SuccOrder ι\nequiv : (j : ↑(Set.Iic i)) → Equiv (F ↑j) (InverseSystem.piLT X ↑j)\ne : Equiv (F (Order.succ i)) (Prod (F i) (X i))\nhi : Not (IsMax i)\nx : F ↑⟨Order.succ i, ⋯⟩\n⊢ Eq ((InverseSystem.piEquivSucc equiv e hi ⟨Order.succ i, ⋯⟩) x ⟨i, ⋯⟩) (e x).2","decl":"theorem piEquivSucc_self {x} :\n    piEquivSucc equiv e hi ⟨_, le_rfl⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (e x).2 := by\n  simp [piEquivSucc]\n\n"}
{"name":"InverseSystem.isNatEquiv_piEquivSucc","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ni : ι\ninst✝² : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝¹ : SuccOrder ι\nequiv : (j : ↑(Set.Iic i)) → Equiv (F ↑j) (InverseSystem.piLT X ↑j)\ne : Equiv (F (Order.succ i)) (Prod (F i) (X i))\nhi : Not (IsMax i)\ninst✝ : InverseSystem f\nH : ∀ (x : F (Order.succ i)), Eq (e x).1 (f ⋯ x)\nnat : InverseSystem.IsNatEquiv f equiv\n⊢ InverseSystem.IsNatEquiv f (InverseSystem.piEquivSucc equiv e hi)","decl":"theorem isNatEquiv_piEquivSucc [InverseSystem f] (H : ∀ x, (e x).1 = f (le_succ i) x)\n    (nat : IsNatEquiv f equiv) : IsNatEquiv f (piEquivSucc equiv e hi) := fun j k hj hk h x ↦ by\n  have lt_succ {j} := (lt_succ_iff_of_not_isMax (b := j) hi).mpr\n  obtain rfl | hj := le_succ_iff_eq_or_le.mp hj\n  · obtain rfl | hk := le_succ_iff_eq_or_le.mp hk\n    · simp [InverseSystem.map_self]\n    · funext l\n      rw [piEquivSucc, piSplitLE_lt (lt_succ hk),\n        ← InverseSystem.map_map (f := f) hk (le_succ i), ← H, piLTProj, nat le_rfl]\n      simp [piSplitLE_lt (l.2.trans_le hk)]\n  · rw [piEquivSucc, piSplitLE_lt (h.trans_lt <| lt_succ hj), nat hj, piSplitLE_lt (lt_succ hj)]\n\n"}
{"name":"InverseSystem.invLimEquiv_apply_coe","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ni : ι\ninst✝ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\nequiv : (j : ↑(Set.Iio i)) → Equiv (F ↑j) (InverseSystem.piLT X ↑j)\nt : ↑(InverseSystem.limit f i)\nl✝ : ↑(Set.Iio i)\nl : ↑(Set.Iio ↑l✝)\n⊢ Eq (↑(InverseSystem.invLimEquiv t) l✝ l) ((equiv l✝) (↑t l✝) l)","decl":"/-- A natural family of bijections below a limit ordinal\ninduces a bijection at the limit ordinal. -/\n@[simps] def invLimEquiv : limit f i ≃ limit (piLTProj (X := X)) i where\n  toFun t := ⟨fun l ↦ equiv l (t.1 l), fun _ _ h ↦ Eq.symm <| by simp_rw [← t.2 h]; apply nat⟩\n  invFun t := ⟨fun l ↦ (equiv l).symm (t.1 l),\n    fun _ _ h ↦ (Equiv.eq_symm_apply _).mpr <| by rw [nat, ← t.2 h]; simp⟩\n  left_inv t := by ext; apply Equiv.left_inv\n  right_inv t := by ext1; ext1; apply Equiv.right_inv\n\n"}
{"name":"InverseSystem.invLimEquiv_symm_apply_coe","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ni : ι\ninst✝ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\nequiv : (j : ↑(Set.Iio i)) → Equiv (F ↑j) (InverseSystem.piLT X ↑j)\nt : ↑(InverseSystem.limit InverseSystem.piLTProj i)\nl : ↑(Set.Iio i)\n⊢ Eq (↑(InverseSystem.invLimEquiv.symm t) l) ((equiv l).symm (↑t l))","decl":"/-- A natural family of bijections below a limit ordinal\ninduces a bijection at the limit ordinal. -/\n@[simps] def invLimEquiv : limit f i ≃ limit (piLTProj (X := X)) i where\n  toFun t := ⟨fun l ↦ equiv l (t.1 l), fun _ _ h ↦ Eq.symm <| by simp_rw [← t.2 h]; apply nat⟩\n  invFun t := ⟨fun l ↦ (equiv l).symm (t.1 l),\n    fun _ _ h ↦ (Equiv.eq_symm_apply _).mpr <| by rw [nat, ← t.2 h]; simp⟩\n  left_inv t := by ext; apply Equiv.left_inv\n  right_inv t := by ext1; ext1; apply Equiv.right_inv\n\n"}
{"name":"InverseSystem.PEquivOn.nat","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nself : InverseSystem.PEquivOn f equivSucc s\n⊢ InverseSystem.IsNatEquiv f self.equiv","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.ext","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nx y : InverseSystem.PEquivOn f equivSucc s\nequiv : Eq x.equiv y.equiv\n⊢ Eq x y","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.compat","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nself : InverseSystem.PEquivOn f equivSucc s\ni : ι\nhsi : Membership.mem s (Order.succ i)\nhi : Not (IsMax i)\nx : F ↑⟨Order.succ i, hsi⟩\n⊢ Eq ((self.equiv ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.ext_iff","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nx y : InverseSystem.PEquivOn f equivSucc s\n⊢ Iff (Eq x y) (Eq x.equiv y.equiv)","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.mk.sizeOf_spec","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝⁵ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝⁴ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\ninst✝³ : SizeOf ι\ninst✝² : (a : ι) → SizeOf (F a)\ninst✝¹ : (a : ι) → SizeOf (X a)\ninst✝ : (a : ι) → SizeOf (s a)\nequiv : (i : ↑s) → Equiv (F ↑i) (InverseSystem.piLT X ↑i)\nnat : InverseSystem.IsNatEquiv f equiv\ncompat : ∀ {i : ι} (hsi : Membership.mem s (Order.succ i)) (hi : Not (IsMax i)) (x : F ↑⟨Order.succ i, hsi⟩), Eq ((equiv ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2\n⊢ Eq (SizeOf.sizeOf { equiv := equiv, nat := nat, compat := compat }) 1","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.mk.injEq","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nequiv✝ : (i : ↑s) → Equiv (F ↑i) (InverseSystem.piLT X ↑i)\nnat✝ : InverseSystem.IsNatEquiv f equiv✝\ncompat✝ : ∀ {i : ι} (hsi : Membership.mem s (Order.succ i)) (hi : Not (IsMax i)) (x : F ↑⟨Order.succ i, hsi⟩), Eq ((equiv✝ ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2\nequiv : (i : ↑s) → Equiv (F ↑i) (InverseSystem.piLT X ↑i)\nnat : InverseSystem.IsNatEquiv f equiv\ncompat : ∀ {i : ι} (hsi : Membership.mem s (Order.succ i)) (hi : Not (IsMax i)) (x : F ↑⟨Order.succ i, hsi⟩), Eq ((equiv ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2\n⊢ Eq (Eq { equiv := equiv✝, nat := nat✝, compat := compat✝ } { equiv := equiv, nat := nat, compat := compat }) (Eq equiv✝ equiv)","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.mk.inj","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\nequiv✝ : (i : ↑s) → Equiv (F ↑i) (InverseSystem.piLT X ↑i)\nnat✝ : InverseSystem.IsNatEquiv f equiv✝\ncompat✝ : ∀ {i : ι} (hsi : Membership.mem s (Order.succ i)) (hi : Not (IsMax i)) (x : F ↑⟨Order.succ i, hsi⟩), Eq ((equiv✝ ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2\nequiv : (i : ↑s) → Equiv (F ↑i) (InverseSystem.piLT X ↑i)\nnat : InverseSystem.IsNatEquiv f equiv\ncompat : ∀ {i : ι} (hsi : Membership.mem s (Order.succ i)) (hi : Not (IsMax i)) (x : F ↑⟨Order.succ i, hsi⟩), Eq ((equiv ⟨Order.succ i, hsi⟩) x ⟨i, ⋯⟩) ((equivSucc hi) x).2\nx✝ : Eq { equiv := equiv✝, nat := nat✝, compat := compat✝ } { equiv := equiv, nat := nat, compat := compat }\n⊢ Eq equiv✝ equiv","decl":"/-- A natural partial family of bijections to `piLT` satisfying a compatibility condition. -/\n@[ext] structure PEquivOn (s : Set ι) where\n  /-- A partial family of bijections between `F` and `piLT X` defined on some set in `ι`. -/\n  equiv (i : s) : F i ≃ piLT X i\n  /-- It is a natural family of bijections. -/\n  nat : IsNatEquiv f equiv\n  /-- It is compatible with a family of bijections relating `F i⁺` to `F i`. -/\n  compat {i} (hsi : (i⁺ : ι) ∈ s) (hi : ¬IsMax i) (x) :\n    equiv ⟨i⁺, hsi⟩ x ⟨i, lt_succ_of_not_isMax hi⟩ = (equivSucc hi x).2\n\n"}
{"name":"InverseSystem.PEquivOn.restrict_equiv","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝¹ : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns t : Set ι\ne : InverseSystem.PEquivOn f equivSucc t\nh : HasSubset.Subset s t\ni : ↑s\n⊢ Eq ((e.restrict h).equiv i) (e.equiv ⟨↑i, ⋯⟩)","decl":"/-- Restrict a partial family of bijections to a smaller set. -/\n@[simps] def PEquivOn.restrict (e : PEquivOn f equivSucc t) (h : s ⊆ t) :\n    PEquivOn f equivSucc s where\n  equiv i := e.equiv ⟨i, h i.2⟩\n  nat _ _ _ _ := e.nat _ _\n  compat _ := e.compat _\n\n"}
{"name":"InverseSystem.unique_pEquivOn","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝² : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝¹ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns : Set ι\ninst✝ : WellFoundedLT ι\nhs : IsLowerSet s\ne₁ e₂ : InverseSystem.PEquivOn f equivSucc s\n⊢ Eq e₁ e₂","decl":"theorem unique_pEquivOn (hs : IsLowerSet s) {e₁ e₂ : PEquivOn f equivSucc s} : e₁ = e₂ := by\n  obtain ⟨e₁, nat₁, compat₁⟩ := e₁\n  obtain ⟨e₂, nat₂, compat₂⟩ := e₂\n  ext1; ext1 i; dsimp only\n  refine SuccOrder.prelimitRecOn i.1 (C := fun i ↦ ∀ h : i ∈ s, e₁ ⟨i, h⟩ = e₂ ⟨i, h⟩)\n    (fun i nmax ih hi ↦ ?_) (fun i lim ih hi ↦ ?_) i.2\n  · ext x ⟨j, hj⟩\n    obtain rfl | hj := ((lt_succ_iff_of_not_isMax nmax).mp hj).eq_or_lt\n    · exact (compat₁ _ nmax x).trans (compat₂ _ nmax x).symm\n    have hi : i ∈ s := hs (le_succ i) hi\n    rw [piLTProj_intro (f := e₁ _ x) (le_succ i) (by exact hj),\n        ← nat₁ _ hi (by exact le_succ i), ih, nat₂ _ hi (by exact le_succ i)]\n  · ext x j\n    have ⟨k, hjk, hki⟩ := lim.mid j.2\n    have hk : k ∈ s := hs hki.le hi\n    rw [piLTProj_intro (f := e₁ _ x) hki.le hjk, piLTProj_intro (f := e₂ _ x) hki.le hjk,\n      ← nat₁ _ hk, ← nat₂ _ hk, ih _ hki]\n\n"}
{"name":"InverseSystem.pEquivOn_apply_eq","module":"Mathlib.Order.DirectedInverseSystem","initialProofState":"ι : Type u_6\nF : ι → Type u_7\nX : ι → Type u_8\ninst✝² : LinearOrder ι\nf : ⦃i j : ι⦄ → LE.le i j → F j → F i\ninst✝¹ : SuccOrder ι\nequivSucc : ⦃i : ι⦄ → Not (IsMax i) → Equiv (F (Order.succ i)) (Prod (F i) (X i))\ns t : Set ι\ninst✝ : WellFoundedLT ι\nh : IsLowerSet (Inter.inter s t)\ne₁ : InverseSystem.PEquivOn f equivSucc s\ne₂ : InverseSystem.PEquivOn f equivSucc t\ni : ι\nhis : Membership.mem s i\nhit : Membership.mem t i\n⊢ Eq (e₁.equiv ⟨i, his⟩) (e₂.equiv ⟨i, hit⟩)","decl":"theorem pEquivOn_apply_eq (h : IsLowerSet (s ∩ t))\n    {e₁ : PEquivOn f equivSucc s} {e₂ : PEquivOn f equivSucc t} {i} {his : i ∈ s} {hit : i ∈ t} :\n    e₁.equiv ⟨i, his⟩ = e₂.equiv ⟨i, hit⟩ :=\n  show (e₁.restrict inter_subset_left).equiv ⟨i, his, hit⟩ =\n       (e₂.restrict inter_subset_right).equiv ⟨i, his, hit⟩ from\n  congr_fun (congr_arg _ <| unique_pEquivOn h) _\n\n"}
