{"name":"CategoryTheory.GrothendieckTopology.transitive'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\nx‚úù : Membership.mem (self.sieves X) S\nR : CategoryTheory.Sieve X\na‚úù : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (self.sieves Y) (CategoryTheory.Sieve.pullback f R)\n‚ä¢ Membership.mem (self.sieves X) R","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_mem'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ Membership.mem (self.sieves X) Top.top","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsieves‚úù : (X : C) ‚Üí Set (CategoryTheory.Sieve X)\ntop_mem'‚úù : ‚àÄ (X : C), Membership.mem (sieves‚úù X) Top.top\npullback_stable'‚úù : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Quiver.Hom Y X), Membership.mem (sieves‚úù X) S ‚Üí Membership.mem (sieves‚úù Y) (CategoryTheory.Sieve.pullback f S)\ntransitive'‚úù : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ, Membership.mem (sieves‚úù X) S ‚Üí ‚àÄ (R : CategoryTheory.Sieve X), (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (sieves‚úù Y) (CategoryTheory.Sieve.pullback f R)) ‚Üí Membership.mem (sieves‚úù X) R\nsieves : (X : C) ‚Üí Set (CategoryTheory.Sieve X)\ntop_mem' : ‚àÄ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Quiver.Hom Y X), Membership.mem (sieves X) S ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ, Membership.mem (sieves X) S ‚Üí ‚àÄ (R : CategoryTheory.Sieve X), (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) ‚Üí Membership.mem (sieves X) R\n‚ä¢ Eq (Eq { sieves := sieves‚úù, top_mem' := top_mem'‚úù, pullback_stable' := pullback_stable'‚úù, transitive' := transitive'‚úù } { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }) (Eq sieves‚úù sieves)","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_stable'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\na‚úù : Membership.mem (self.sieves X) S\n‚ä¢ Membership.mem (self.sieves Y) (CategoryTheory.Sieve.pullback f S)","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nsieves‚úù : (X : C) ‚Üí Set (CategoryTheory.Sieve X)\ntop_mem'‚úù : ‚àÄ (X : C), Membership.mem (sieves‚úù X) Top.top\npullback_stable'‚úù : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Quiver.Hom Y X), Membership.mem (sieves‚úù X) S ‚Üí Membership.mem (sieves‚úù Y) (CategoryTheory.Sieve.pullback f S)\ntransitive'‚úù : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ, Membership.mem (sieves‚úù X) S ‚Üí ‚àÄ (R : CategoryTheory.Sieve X), (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (sieves‚úù Y) (CategoryTheory.Sieve.pullback f R)) ‚Üí Membership.mem (sieves‚úù X) R\nsieves : (X : C) ‚Üí Set (CategoryTheory.Sieve X)\ntop_mem' : ‚àÄ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Quiver.Hom Y X), Membership.mem (sieves X) S ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ, Membership.mem (sieves X) S ‚Üí ‚àÄ (R : CategoryTheory.Sieve X), (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) ‚Üí Membership.mem (sieves X) R\nx‚úù : Eq { sieves := sieves‚úù, top_mem' := top_mem'‚úù, pullback_stable' := pullback_stable'‚úù, transitive' := transitive'‚úù } { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }\n‚ä¢ Eq sieves‚úù sieves","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : SizeOf C\nsieves : (X : C) ‚Üí Set (CategoryTheory.Sieve X)\ntop_mem' : ‚àÄ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Quiver.Hom Y X), Membership.mem (sieves X) S ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ, Membership.mem (sieves X) S ‚Üí ‚àÄ (R : CategoryTheory.Sieve X), (‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) ‚Üí Membership.mem (sieves X) R\n‚ä¢ Eq (SizeOf.sizeOf { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }) 1","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ‚àà J X` then its pullback along any `h : Y ‚ü∂ X` is in `J Y`.\n3. If `S ‚àà J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ‚ü∂ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ‚àà J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ‚àÄ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : Sieve X‚¶Ñ (_ : S ‚àà sieves X) (R : Sieve X),\n      (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ‚ÇÅ J‚ÇÇ : CategoryTheory.GrothendieckTopology C\n‚ä¢ Iff (Eq J‚ÇÅ J‚ÇÇ) (Eq ‚áëJ‚ÇÅ ‚áëJ‚ÇÇ)","decl":"/-- An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n-/\n@[ext]\ntheorem ext {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} (h : (J‚ÇÅ : ‚àÄ X : C, Set (Sieve X)) = J‚ÇÇ) : J‚ÇÅ = J‚ÇÇ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ‚ÇÅ J‚ÇÇ : CategoryTheory.GrothendieckTopology C\nh : Eq ‚áëJ‚ÇÅ ‚áëJ‚ÇÇ\n‚ä¢ Eq J‚ÇÅ J‚ÇÇ","decl":"/-- An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n-/\n@[ext]\ntheorem ext {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} (h : (J‚ÇÅ : ‚àÄ X : C, Set (Sieve X)) = J‚ÇÇ) : J‚ÇÅ = J‚ÇÇ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mem_sieves_iff_coe","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ Iff (Membership.mem (J.sieves X) S) (Membership.mem (J X) S)","decl":"@[simp]\ntheorem mem_sieves_iff_coe : S ‚àà J.sieves X ‚Üî S ‚àà J X :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_mem","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ Membership.mem (J X) Top.top","decl":"/-- Also known as the maximality axiom. -/\n@[simp]\ntheorem top_mem (X : C) : ‚ä§ ‚àà J X :=\n  J.top_mem' X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_stable","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nhS : Membership.mem (J X) S\n‚ä¢ Membership.mem (J Y) (CategoryTheory.Sieve.pullback f S)","decl":"/-- Also known as the stability axiom. -/\n@[simp]\ntheorem pullback_stable (f : Y ‚ü∂ X) (hS : S ‚àà J X) : S.pullback f ‚àà J Y :=\n  J.pullback_stable' f hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_mem_iff_of_isIso","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\ni : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso i\nS : CategoryTheory.Sieve Y\n‚ä¢ Iff (Membership.mem (J X) (CategoryTheory.Sieve.pullback i S)) (Membership.mem (J Y) S)","decl":"variable {J} in\n@[simp]\nlemma pullback_mem_iff_of_isIso {i : X ‚ü∂ Y} [IsIso i] {S : Sieve Y} :\n    S.pullback i ‚àà J _ ‚Üî S ‚àà J _ := by\n  refine ‚ü®fun H ‚Ü¶ ?_, J.pullback_stable i‚ü©\n  convert J.pullback_stable (inv i) H\n  rw [‚Üê Sieve.pullback_comp, IsIso.inv_hom_id, Sieve.pullback_id]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.transitive","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nhS : Membership.mem (J X) S\nR : CategoryTheory.Sieve X\nh : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ, S.arrows f ‚Üí Membership.mem (J Y) (CategoryTheory.Sieve.pullback f R)\n‚ä¢ Membership.mem (J X) R","decl":"theorem transitive (hS : S ‚àà J X) (R : Sieve X) (h : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà J Y) :\n    R ‚àà J X :=\n  J.transitive' hS R h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covering_of_eq_top","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\na‚úù : Eq S Top.top\n‚ä¢ Membership.mem (J X) S","decl":"theorem covering_of_eq_top : S = ‚ä§ ‚Üí S ‚àà J X := fun h => h.symm ‚ñ∏ J.top_mem X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.superset_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nHss : LE.le S R\nsjx : Membership.mem (J X) S\n‚ä¢ Membership.mem (J X) R","decl":"/-- If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.\n\nSee also discussion after [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z5 \"(2)\"]\ntheorem superset_covering (Hss : S ‚â§ R) (sjx : S ‚àà J X) : R ‚àà J X := by\n  apply J.transitive sjx R fun Y f hf => _\n  intros Y f hf\n  apply covering_of_eq_top\n  rw [‚Üê top_le_iff, ‚Üê S.pullback_eq_top_of_mem hf]\n  apply Sieve.pullback_monotone _ Hss\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.intersection_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nrj : Membership.mem (J X) R\nsj : Membership.mem (J X) S\n‚ä¢ Membership.mem (J X) (Min.min R S)","decl":"/-- The intersection of two covering sieves is covering.\n\nSee also [MM92] Chapter III, Section 2, Definition 1 (iv). -/\n@[stacks 00Z5 \"(1)\"]\ntheorem intersection_covering (rj : R ‚àà J X) (sj : S ‚àà J X) : R ‚äì S ‚àà J X := by\n  apply J.transitive rj _ fun Y f Hf => _\n  intros Y f hf\n  rw [Sieve.pullback_inter, R.pullback_eq_top_of_mem hf]\n  simp [sj]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.intersection_covering_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ Iff (Membership.mem (J X) (Min.min R S)) (And (Membership.mem (J X) R) (Membership.mem (J X) S))","decl":"@[simp]\ntheorem intersection_covering_iff : R ‚äì S ‚àà J X ‚Üî R ‚àà J X ‚àß S ‚àà J X :=\n  ‚ü®fun h => ‚ü®J.superset_covering inf_le_left h, J.superset_covering inf_le_right h‚ü©, fun t =>\n    intersection_covering _ t.1 t.2‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bind_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S.arrows f ‚Üí CategoryTheory.Sieve Y\nhS : Membership.mem (J X) S\nhR : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Quiver.Hom Y X‚¶Ñ (H : S.arrows f), Membership.mem (J Y) (R H)\n‚ä¢ Membership.mem (J X) (CategoryTheory.Sieve.bind S.arrows R)","decl":"theorem bind_covering {S : Sieve X} {R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Sieve Y} (hS : S ‚àà J X)\n    (hR : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (H : S f), R H ‚àà J Y) : Sieve.bind S R ‚àà J X :=\n  J.transitive hS _ fun _ f hf => superset_covering J (Sieve.le_pullback_bind S R f hf) (hR hf)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covers_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n‚ä¢ Iff (J.Covers S f) (Membership.mem (J Y) (CategoryTheory.Sieve.pullback f S))","decl":"theorem covers_iff (S : Sieve X) (f : Y ‚ü∂ X) : J.Covers S f ‚Üî S.pullback f ‚àà J Y :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covering_iff_covers_id","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem (J X) S) (J.Covers S (CategoryTheory.CategoryStruct.id X))","decl":"theorem covering_iff_covers_id (S : Sieve X) : S ‚àà J X ‚Üî J.Covers S (ùüô X) := by simp [covers_iff]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_max","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nhf : S.arrows f\n‚ä¢ J.Covers S f","decl":"/-- The maximality axiom in 'arrow' form: Any arrow `f` in `S` is covered by `S`. -/\ntheorem arrow_max (f : Y ‚ü∂ X) (S : Sieve X) (hf : S f) : J.Covers S f := by\n  rw [Covers, (Sieve.pullback_eq_top_iff_mem f).1 hf]\n  apply J.top_mem\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_stable","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nh : J.Covers S f\nZ : C\ng : Quiver.Hom Z Y\n‚ä¢ J.Covers S (CategoryTheory.CategoryStruct.comp g f)","decl":"/-- The stability axiom in 'arrow' form: If `S` covers `f` then `S` covers `g ‚â´ f` for any `g`. -/\ntheorem arrow_stable (f : Y ‚ü∂ X) (S : Sieve X) (h : J.Covers S f) {Z : C} (g : Z ‚ü∂ Y) :\n    J.Covers S (g ‚â´ f) := by\n  rw [covers_iff] at h ‚ä¢\n  simp [h, Sieve.pullback_comp]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_trans","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\nh : J.Covers S f\na‚úù : ‚àÄ {Z : C} (g : Quiver.Hom Z X), S.arrows g ‚Üí J.Covers R g\n‚ä¢ J.Covers R f","decl":"/-- The transitivity axiom in 'arrow' form: If `S` covers `f` and every arrow in `S` is covered by\n`R`, then `R` covers `f`.\n-/\ntheorem arrow_trans (f : Y ‚ü∂ X) (S R : Sieve X) (h : J.Covers S f) :\n    (‚àÄ {Z : C} (g : Z ‚ü∂ X), S g ‚Üí J.Covers R g) ‚Üí J.Covers R f := by\n  intro k\n  apply J.transitive h\n  intro Z g hg\n  rw [‚Üê Sieve.pullback_comp]\n  apply k (g ‚â´ f) hg\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_intersect","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\nhS : J.Covers S f\nhR : J.Covers R f\n‚ä¢ J.Covers (Min.min S R) f","decl":"theorem arrow_intersect (f : Y ‚ü∂ X) (S R : Sieve X) (hS : J.Covers S f) (hR : J.Covers R f) :\n    J.Covers (S ‚äì R) f := by simpa [covers_iff] using And.intro hS hR\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.trivial_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem ((CategoryTheory.GrothendieckTopology.trivial C) X) S) (Eq S Top.top)","decl":"theorem trivial_covering : S ‚àà trivial C X ‚Üî S = ‚ä§ :=\n  Set.mem_singleton_iff\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.le_def","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ‚ÇÅ J‚ÇÇ : CategoryTheory.GrothendieckTopology C\n‚ä¢ Iff (LE.le J‚ÇÅ J‚ÇÇ) (LE.le ‚áëJ‚ÇÅ ‚áëJ‚ÇÇ)","decl":"theorem le_def {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} : J‚ÇÅ ‚â§ J‚ÇÇ ‚Üî (J‚ÇÅ : ‚àÄ X : C, Set (Sieve X)) ‚â§ J‚ÇÇ :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mem_sInf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ns : Set (CategoryTheory.GrothendieckTopology C)\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem ((InfSet.sInf s) X) S) (‚àÄ (t : CategoryTheory.GrothendieckTopology C), Membership.mem s t ‚Üí Membership.mem (t X) S)","decl":"lemma mem_sInf (s : Set (GrothendieckTopology C)) {X : C} (S : Sieve X) :\n    S ‚àà sInf s X ‚Üî ‚àÄ t ‚àà s, S ‚àà t X := by\n  show S ‚àà sInf (sieves '' s) X ‚Üî _\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isGLB_sInf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ns : Set (CategoryTheory.GrothendieckTopology C)\n‚ä¢ IsGLB s (InfSet.sInf s)","decl":"@[stacks 00Z7]\ntheorem isGLB_sInf (s : Set (GrothendieckTopology C)) : IsGLB s (sInf s) := by\n  refine @IsGLB.of_image _ _ _ _ sieves ?_ _ _ ?_\n  ¬∑ rfl\n  ¬∑ exact _root_.isGLB_sInf _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.trivial_eq_bot","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq (CategoryTheory.GrothendieckTopology.trivial C) Bot.bot","decl":"@[simp]\ntheorem trivial_eq_bot : trivial C = ‚ä• :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.discrete_eq_top","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq (CategoryTheory.GrothendieckTopology.discrete C) Top.top","decl":"@[simp]\ntheorem discrete_eq_top : discrete C = ‚ä§ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bot_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem (Bot.bot X) S) (Eq S Top.top)","decl":"@[simp]\ntheorem bot_covering : S ‚àà (‚ä• : GrothendieckTopology C) X ‚Üî S = ‚ä§ :=\n  trivial_covering\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Membership.mem (Top.top X) S","decl":"@[simp]\ntheorem top_covering : S ‚àà (‚ä§ : GrothendieckTopology C) X :=\n  ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bot_covers","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n‚ä¢ Iff (Bot.bot.Covers S f) (S.arrows f)","decl":"theorem bot_covers (S : Sieve X) (f : Y ‚ü∂ X) : (‚ä• : GrothendieckTopology C).Covers S f ‚Üî S f := by\n  rw [covers_iff, bot_covering, ‚Üê Sieve.pullback_eq_top_iff_mem]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_covers","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n‚ä¢ Top.top.Covers S f","decl":"@[simp]\ntheorem top_covers (S : Sieve X) (f : Y ‚ü∂ X) : (‚ä§ : GrothendieckTopology C).Covers S f := by\n  simp [covers_iff]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.dense_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem (CategoryTheory.GrothendieckTopology.dense X) S) (‚àÄ {Y : C} (f : Quiver.Hom Y X), Exists fun Z => Exists fun g => S.arrows (CategoryTheory.CategoryStruct.comp g f))","decl":"theorem dense_covering : S ‚àà dense X ‚Üî ‚àÄ {Y} (f : Y ‚ü∂ X), ‚àÉ (Z : _) (g : Z ‚ü∂ Y), S (g ‚â´ f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.right_ore_of_pullbacks","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ CategoryTheory.GrothendieckTopology.RightOreCondition C","decl":"theorem right_ore_of_pullbacks [Limits.HasPullbacks C] : RightOreCondition C := fun _ _ =>\n  ‚ü®_, _, _, Limits.pullback.condition‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\n‚ä¢ Membership.mem (J X) ‚ÜëS","decl":"theorem condition (S : J.Cover X) : (S : Sieve X) ‚àà J X := S.2\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nh : ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Quiver.Hom Y X), Iff ((‚ÜëS).arrows f) ((‚ÜëT).arrows f)\n‚ä¢ Eq S T","decl":"@[ext]\ntheorem ext (S T : J.Cover X) (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üî T f) : S = T :=\n  Subtype.ext <| Sieve.ext h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\n‚ä¢ Iff (Eq S T) (‚àÄ ‚¶ÉY : C‚¶Ñ (f : Quiver.Hom Y X), Iff ((‚ÜëS).arrows f) ((‚ÜëT).arrows f))","decl":"@[ext]\ntheorem ext (S T : J.Cover X) (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üî T f) : S = T :=\n  Subtype.ext <| Sieve.ext h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Arrow\n‚ä¢ Iff (Eq x y) (And (Eq x.Y y.Y) (HEq x.f y.f))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Arrow\nY : Eq x.Y y.Y\nf : HEq x.f y.f\n‚ä¢ Eq x y","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\ninst‚úù : SizeOf C\nY : C\nf : Quiver.Hom Y X\nhf : (‚ÜëS).arrows f\n‚ä¢ Eq (SizeOf.sizeOf { Y := Y, f := f, hf := hf }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Y)) (SizeOf.sizeOf f)) (SizeOf.sizeOf hf))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nY‚úù : C\nf‚úù : Quiver.Hom Y‚úù X\nhf‚úù : (‚ÜëS).arrows f‚úù\nY : C\nf : Quiver.Hom Y X\nhf : (‚ÜëS).arrows f\n‚ä¢ Eq (Eq { Y := Y‚úù, f := f‚úù, hf := hf‚úù } { Y := Y, f := f, hf := hf }) (And (Eq Y‚úù Y) (HEq f‚úù f))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nY‚úù : C\nf‚úù : Quiver.Hom Y‚úù X\nhf‚úù : (‚ÜëS).arrows f‚úù\nY : C\nf : Quiver.Hom Y X\nhf : (‚ÜëS).arrows f\nx‚úù : Eq { Y := Y‚úù, f := f‚úù, hf := hf‚úù } { Y := Y, f := f, hf := hf }\n‚ä¢ And (Eq Y‚úù Y) (HEq f‚úù f)","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.hf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nself : S.Arrow\n‚ä¢ (‚ÜëS).arrows self.f","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ‚ü∂ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nZ‚úù : C\ng‚ÇÅ‚úù : Quiver.Hom Z‚úù I‚ÇÅ.Y\ng‚ÇÇ‚úù : Quiver.Hom Z‚úù I‚ÇÇ.Y\nw‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp g‚ÇÅ‚úù I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp g‚ÇÇ‚úù I‚ÇÇ.f)) _auto‚úù\nZ : C\ng‚ÇÅ : Quiver.Hom Z I‚ÇÅ.Y\ng‚ÇÇ : Quiver.Hom Z I‚ÇÇ.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g‚ÇÅ I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp g‚ÇÇ I‚ÇÇ.f)) _auto‚úù\n‚ä¢ Eq (Eq { Z := Z‚úù, g‚ÇÅ := g‚ÇÅ‚úù, g‚ÇÇ := g‚ÇÇ‚úù, w := w‚úù } { Z := Z, g‚ÇÅ := g‚ÇÅ, g‚ÇÇ := g‚ÇÇ, w := w }) (And (Eq Z‚úù Z) (And (HEq g‚ÇÅ‚úù g‚ÇÅ) (HEq g‚ÇÇ‚úù g‚ÇÇ)))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nZ‚úù : C\ng‚ÇÅ‚úù : Quiver.Hom Z‚úù I‚ÇÅ.Y\ng‚ÇÇ‚úù : Quiver.Hom Z‚úù I‚ÇÇ.Y\nw‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp g‚ÇÅ‚úù I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp g‚ÇÇ‚úù I‚ÇÇ.f)) _auto‚úù\nZ : C\ng‚ÇÅ : Quiver.Hom Z I‚ÇÅ.Y\ng‚ÇÇ : Quiver.Hom Z I‚ÇÇ.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g‚ÇÅ I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp g‚ÇÇ I‚ÇÇ.f)) _auto‚úù\nx‚úù : Eq { Z := Z‚úù, g‚ÇÅ := g‚ÇÅ‚úù, g‚ÇÇ := g‚ÇÇ‚úù, w := w‚úù } { Z := Z, g‚ÇÅ := g‚ÇÅ, g‚ÇÇ := g‚ÇÇ, w := w }\n‚ä¢ And (Eq Z‚úù Z) (And (HEq g‚ÇÅ‚úù g‚ÇÅ) (HEq g‚ÇÇ‚úù g‚ÇÇ))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.w","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nself : I‚ÇÅ.Relation I‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.g‚ÇÅ I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp self.g‚ÇÇ I‚ÇÇ.f)","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nx y : I‚ÇÅ.Relation I‚ÇÇ\n‚ä¢ Iff (Eq x y) (And (Eq x.Z y.Z) (And (HEq x.g‚ÇÅ y.g‚ÇÅ) (HEq x.g‚ÇÇ y.g‚ÇÇ)))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nx y : I‚ÇÅ.Relation I‚ÇÇ\nZ : Eq x.Z y.Z\ng‚ÇÅ : HEq x.g‚ÇÅ y.g‚ÇÅ\ng‚ÇÇ : HEq x.g‚ÇÇ y.g‚ÇÇ\n‚ä¢ Eq x y","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\ninst‚úù : SizeOf C\nZ : C\ng‚ÇÅ : Quiver.Hom Z I‚ÇÅ.Y\ng‚ÇÇ : Quiver.Hom Z I‚ÇÇ.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g‚ÇÅ I‚ÇÅ.f) (CategoryTheory.CategoryStruct.comp g‚ÇÇ I‚ÇÇ.f)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { Z := Z, g‚ÇÅ := g‚ÇÅ, g‚ÇÇ := g‚ÇÇ, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf g‚ÇÅ)) (SizeOf.sizeOf g‚ÇÇ)) (SizeOf.sizeOf w))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I‚ÇÅ I‚ÇÇ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g‚ÇÅ : Z ‚ü∂ I‚ÇÅ.Y\n  /-- The second arrow defining the relation. -/\n  g‚ÇÇ : Z ‚ü∂ I‚ÇÇ.Y\n  /-- The relation itself. -/\n  w : g‚ÇÅ ‚â´ I‚ÇÅ.f = g‚ÇÇ ‚â´ I‚ÇÇ.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.w_assoc","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nself : I‚ÇÅ.Relation I‚ÇÇ\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.g‚ÇÅ (CategoryTheory.CategoryStruct.comp I‚ÇÅ.f h)) (CategoryTheory.CategoryStruct.comp self.g‚ÇÇ (CategoryTheory.CategoryStruct.comp I‚ÇÇ.f h))","decl":"attribute [reassoc] Arrow.Relation.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precomp_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n‚ä¢ Eq (I.precomp g).Y Z","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ‚ü∂ I.Y`, this is the arrow in `S.Arrow`\ncorresponding to `g ‚â´ I.f`. -/\n@[simps]\ndef Arrow.precomp {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ‚ü∂ I.Y) : S.Arrow :=\n  ‚ü®Z, g ‚â´ I.f, S.1.downward_closed I.hf g‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precomp_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n‚ä¢ Eq (I.precomp g).f (CategoryTheory.CategoryStruct.comp g I.f)","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ‚ü∂ I.Y`, this is the arrow in `S.Arrow`\ncorresponding to `g ‚â´ I.f`. -/\n@[simps]\ndef Arrow.precomp {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ‚ü∂ I.Y) : S.Arrow :=\n  ‚ü®Z, g ‚â´ I.f, S.1.downward_closed I.hf g‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_Z","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n‚ä¢ Eq (I.precompRelation g).Z (I.precomp g).Y","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ‚ü∂ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ‚ü∂ I.Y) :\n    (I.precomp g).Relation I where\n  g‚ÇÅ := ùüô _\n  g‚ÇÇ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_g‚ÇÅ","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n‚ä¢ Eq (I.precompRelation g).g‚ÇÅ (CategoryTheory.CategoryStruct.id (I.precomp g).Y)","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ‚ü∂ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ‚ü∂ I.Y) :\n    (I.precomp g).Relation I where\n  g‚ÇÅ := ùüô _\n  g‚ÇÇ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_g‚ÇÇ","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n‚ä¢ Eq (I.precompRelation g).g‚ÇÇ g","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ‚ü∂ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ‚ü∂ I.Y) :\n    (I.precomp g).Relation I where\n  g‚ÇÅ := ùüô _\n  g‚ÇÇ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.map_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI : S.Arrow\nf : Quiver.Hom S T\n‚ä¢ Eq (I.map f).Y I.Y","decl":"/-- Map an `Arrow` along a refinement `S ‚ü∂ T`. -/\n@[simps]\ndef Arrow.map {S T : J.Cover X} (I : S.Arrow) (f : S ‚ü∂ T) : T.Arrow :=\n  ‚ü®I.Y, I.f, f.le _ I.hf‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.map_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI : S.Arrow\nf : Quiver.Hom S T\n‚ä¢ Eq (I.map f).f I.f","decl":"/-- Map an `Arrow` along a refinement `S ‚ü∂ T`. -/\n@[simps]\ndef Arrow.map {S T : J.Cover X} (I : S.Arrow) (f : S ‚ü∂ T) : T.Arrow :=\n  ‚ü®I.Y, I.f, f.le _ I.hf‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_g‚ÇÇ","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nr : I‚ÇÅ.Relation I‚ÇÇ\nf : Quiver.Hom S T\n‚ä¢ Eq (r.map f).g‚ÇÇ r.g‚ÇÇ","decl":"/-- Map an `Arrow.Relation` along a refinement `S ‚ü∂ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I‚ÇÅ I‚ÇÇ : S.Arrow}\n    (r : I‚ÇÅ.Relation I‚ÇÇ) (f : S ‚ü∂ T) : (I‚ÇÅ.map f).Relation (I‚ÇÇ.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_g‚ÇÅ","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nr : I‚ÇÅ.Relation I‚ÇÇ\nf : Quiver.Hom S T\n‚ä¢ Eq (r.map f).g‚ÇÅ r.g‚ÇÅ","decl":"/-- Map an `Arrow.Relation` along a refinement `S ‚ü∂ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I‚ÇÅ I‚ÇÇ : S.Arrow}\n    (r : I‚ÇÅ.Relation I‚ÇÇ) (f : S ‚ü∂ T) : (I‚ÇÅ.map f).Relation (I‚ÇÇ.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_Z","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI‚ÇÅ I‚ÇÇ : S.Arrow\nr : I‚ÇÅ.Relation I‚ÇÇ\nf : Quiver.Hom S T\n‚ä¢ Eq (r.map f).Z r.Z","decl":"/-- Map an `Arrow.Relation` along a refinement `S ‚ü∂ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I‚ÇÅ I‚ÇÇ : S.Arrow}\n    (r : I‚ÇÅ.Relation I‚ÇÇ) (f : S ‚ü∂ T) : (I‚ÇÅ.map f).Relation (I‚ÇÇ.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.base_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\nI : (S.pullback f).Arrow\n‚ä¢ Eq I.base.f (CategoryTheory.CategoryStruct.comp I.f f)","decl":"/-- An arrow of `S.pullback f` gives rise to an arrow of `S`. -/\n@[simps]\ndef Arrow.base {f : Y ‚ü∂ X} {S : J.Cover X} (I : (S.pullback f).Arrow) : S.Arrow :=\n  ‚ü®I.Y, I.f ‚â´ f, I.hf‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.base_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\nI : (S.pullback f).Arrow\n‚ä¢ Eq I.base.Y I.Y","decl":"/-- An arrow of `S.pullback f` gives rise to an arrow of `S`. -/\n@[simps]\ndef Arrow.base {f : Y ‚ü∂ X} {S : J.Cover X} (I : (S.pullback f).Arrow) : S.Arrow :=\n  ‚ü®I.Y, I.f ‚â´ f, I.hf‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.coe_pullback","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nZ : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nS : J.Cover X\n‚ä¢ Iff ((‚Üë(S.pullback f)).arrows g) ((‚ÜëS).arrows (CategoryTheory.CategoryStruct.comp g f))","decl":"@[simp]\ntheorem coe_pullback {Z : C} (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (S : J.Cover X) :\n    (S.pullback f) g ‚Üî S (g ‚â´ f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.from_middle_condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) ‚Üí J.Cover I.Y\nI : (S.bind T).Arrow\n‚ä¢ (‚ÜëS).arrows I.fromMiddleHom","decl":"theorem Arrow.from_middle_condition {X : C} {S : J.Cover X} {T : ‚àÄ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : S I.fromMiddleHom :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.to_middle_condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) ‚Üí J.Cover I.Y\nI : (S.bind T).Arrow\n‚ä¢ (‚Üë(T I.fromMiddle)).arrows I.toMiddleHom","decl":"theorem Arrow.to_middle_condition {X : C} {S : J.Cover X} {T : ‚àÄ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : (T I.fromMiddle) I.toMiddleHom :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose_spec.1\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.middle_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) ‚Üí J.Cover I.Y\nI : (S.bind T).Arrow\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp I.toMiddleHom I.fromMiddleHom) I.f","decl":"theorem Arrow.middle_spec {X : C} {S : J.Cover X} {T : ‚àÄ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : I.toMiddleHom ‚â´ I.fromMiddleHom = I.f :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Relation\n‚ä¢ Iff (Eq x y) (And (Eq x.fst y.fst) (And (Eq x.snd y.snd) (HEq x.r y.r)))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\ninst‚úù : SizeOf C\nfst snd : S.Arrow\nr : fst.Relation snd\n‚ä¢ Eq (SizeOf.sizeOf { fst := fst, snd := snd, r := r }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf fst)) (SizeOf.sizeOf snd)) (SizeOf.sizeOf r))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Relation\nfst : Eq x.fst y.fst\nsnd : Eq x.snd y.snd\nr : HEq x.r y.r\n‚ä¢ Eq x y","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst‚úù snd‚úù : S.Arrow\nr‚úù : fst‚úù.Relation snd‚úù\nfst snd : S.Arrow\nr : fst.Relation snd\nx‚úù : Eq { fst := fst‚úù, snd := snd‚úù, r := r‚úù } { fst := fst, snd := snd, r := r }\n‚ä¢ And (Eq fst‚úù fst) (And (Eq snd‚úù snd) (HEq r‚úù r))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst‚úù snd‚úù : S.Arrow\nr‚úù : fst‚úù.Relation snd‚úù\nfst snd : S.Arrow\nr : fst.Relation snd\n‚ä¢ Eq (Eq { fst := fst‚úù, snd := snd‚úù, r := r‚úù } { fst := fst, snd := snd, r := r }) (And (Eq fst‚úù fst) (And (Eq snd‚úù snd) (HEq r‚úù r)))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_fst","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n‚ä¢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).fst fst","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I‚ÇÅ.Relation I‚ÇÇ` with `I‚ÇÅ I‚ÇÇ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_r","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n‚ä¢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).r r","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I‚ÇÅ.Relation I‚ÇÇ` with `I‚ÇÅ I‚ÇÇ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_snd","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n‚ä¢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).snd snd","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I‚ÇÅ.Relation I‚ÇÇ` with `I‚ÇÅ I‚ÇÇ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_sndTo","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n‚ä¢ Eq ((S.index P).sndTo I) I.snd","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_snd","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n‚ä¢ Eq ((S.index P).snd I) (P.map I.r.g‚ÇÇ.op)","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_fst","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n‚ä¢ Eq ((S.index P).fst I) (P.map I.r.g‚ÇÅ.op)","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_R","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (S.index P).R S.Relation","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_L","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (S.index P).L S.Arrow","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_left","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Arrow\n‚ä¢ Eq ((S.index P).left I) (P.obj { unop := I.Y })","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_fstTo","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n‚ä¢ Eq ((S.index P).fstTo I) I.fst","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_right","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n‚ä¢ Eq ((S.index P).right I) (P.obj { unop := I.r.Z })","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D] (S : J.Cover X) (P : C·µí·µñ ‚•§ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g‚ÇÅ.op\n  snd I := P.map I.r.g‚ÇÇ.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_obj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\n‚ä¢ Eq ((J.pullback f).obj S) (S.pullback f)","decl":"/-- Pull back a cover along a morphism. -/\n@[simps obj]\ndef pullback (f : Y ‚ü∂ X) : J.Cover X ‚•§ J.Cover Y where\n  obj S := S.pullback f\n  map f := (Sieve.pullback_monotone _ f.le).hom\n\n"}
