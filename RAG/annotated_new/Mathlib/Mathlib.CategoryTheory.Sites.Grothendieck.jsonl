{"name":"CategoryTheory.GrothendieckTopology.transitive'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\nx✝ : Membership.mem (self.sieves X) S\nR : CategoryTheory.Sieve X\na✝ : ∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (self.sieves Y) (CategoryTheory.Sieve.pullback f R)\n⊢ Membership.mem (self.sieves X) R","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_mem'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX : C\n⊢ Membership.mem (self.sieves X) Top.top","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsieves✝ : (X : C) → Set (CategoryTheory.Sieve X)\ntop_mem'✝ : ∀ (X : C), Membership.mem (sieves✝ X) Top.top\npullback_stable'✝ : ∀ ⦃X Y : C⦄ ⦃S : CategoryTheory.Sieve X⦄ (f : Quiver.Hom Y X), Membership.mem (sieves✝ X) S → Membership.mem (sieves✝ Y) (CategoryTheory.Sieve.pullback f S)\ntransitive'✝ : ∀ ⦃X : C⦄ ⦃S : CategoryTheory.Sieve X⦄, Membership.mem (sieves✝ X) S → ∀ (R : CategoryTheory.Sieve X), (∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (sieves✝ Y) (CategoryTheory.Sieve.pullback f R)) → Membership.mem (sieves✝ X) R\nsieves : (X : C) → Set (CategoryTheory.Sieve X)\ntop_mem' : ∀ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : CategoryTheory.Sieve X⦄ (f : Quiver.Hom Y X), Membership.mem (sieves X) S → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ∀ ⦃X : C⦄ ⦃S : CategoryTheory.Sieve X⦄, Membership.mem (sieves X) S → ∀ (R : CategoryTheory.Sieve X), (∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) → Membership.mem (sieves X) R\n⊢ Eq (Eq { sieves := sieves✝, top_mem' := top_mem'✝, pullback_stable' := pullback_stable'✝, transitive' := transitive'✝ } { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }) (Eq sieves✝ sieves)","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_stable'","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.GrothendieckTopology C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\na✝ : Membership.mem (self.sieves X) S\n⊢ Membership.mem (self.sieves Y) (CategoryTheory.Sieve.pullback f S)","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsieves✝ : (X : C) → Set (CategoryTheory.Sieve X)\ntop_mem'✝ : ∀ (X : C), Membership.mem (sieves✝ X) Top.top\npullback_stable'✝ : ∀ ⦃X Y : C⦄ ⦃S : CategoryTheory.Sieve X⦄ (f : Quiver.Hom Y X), Membership.mem (sieves✝ X) S → Membership.mem (sieves✝ Y) (CategoryTheory.Sieve.pullback f S)\ntransitive'✝ : ∀ ⦃X : C⦄ ⦃S : CategoryTheory.Sieve X⦄, Membership.mem (sieves✝ X) S → ∀ (R : CategoryTheory.Sieve X), (∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (sieves✝ Y) (CategoryTheory.Sieve.pullback f R)) → Membership.mem (sieves✝ X) R\nsieves : (X : C) → Set (CategoryTheory.Sieve X)\ntop_mem' : ∀ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : CategoryTheory.Sieve X⦄ (f : Quiver.Hom Y X), Membership.mem (sieves X) S → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ∀ ⦃X : C⦄ ⦃S : CategoryTheory.Sieve X⦄, Membership.mem (sieves X) S → ∀ (R : CategoryTheory.Sieve X), (∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) → Membership.mem (sieves X) R\nx✝ : Eq { sieves := sieves✝, top_mem' := top_mem'✝, pullback_stable' := pullback_stable'✝, transitive' := transitive'✝ } { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }\n⊢ Eq sieves✝ sieves","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : SizeOf C\nsieves : (X : C) → Set (CategoryTheory.Sieve X)\ntop_mem' : ∀ (X : C), Membership.mem (sieves X) Top.top\npullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : CategoryTheory.Sieve X⦄ (f : Quiver.Hom Y X), Membership.mem (sieves X) S → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f S)\ntransitive' : ∀ ⦃X : C⦄ ⦃S : CategoryTheory.Sieve X⦄, Membership.mem (sieves X) S → ∀ (R : CategoryTheory.Sieve X), (∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (sieves Y) (CategoryTheory.Sieve.pullback f R)) → Membership.mem (sieves X) R\n⊢ Eq (SizeOf.sizeOf { sieves := sieves, top_mem' := top_mem', pullback_stable' := pullback_stable', transitive' := transitive' }) 1","decl":"/-- The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying\nthree axioms:\n1. For every object `X`, the maximal sieve is in `J X`.\n2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`.\n3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow\n   `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.\n\nA sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.\n\nSee also [nlab] or [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z4]\nstructure GrothendieckTopology where\n  /-- A Grothendieck topology on `C` consists of a set of sieves for each object `X`,\n    which satisfy some axioms. -/\n  sieves : ∀ X : C, Set (Sieve X)\n  /-- The sieves associated to each object must contain the top sieve.\n    Use `GrothendieckTopology.top_mem`. -/\n  top_mem' : ∀ X, ⊤ ∈ sieves X\n  /-- Stability under pullback. Use `GrothendieckTopology.pullback_stable`. -/\n  pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : Sieve X⦄ (f : Y ⟶ X), S ∈ sieves X → S.pullback f ∈ sieves Y\n  /-- Transitivity of sieves in a Grothendieck topology.\n    Use `GrothendieckTopology.transitive`. -/\n  transitive' :\n    ∀ ⦃X⦄ ⦃S : Sieve X⦄ (_ : S ∈ sieves X) (R : Sieve X),\n      (∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ sieves Y) → R ∈ sieves X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ J₂ : CategoryTheory.GrothendieckTopology C\n⊢ Iff (Eq J₁ J₂) (Eq ⇑J₁ ⇑J₂)","decl":"/-- An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n-/\n@[ext]\ntheorem ext {J₁ J₂ : GrothendieckTopology C} (h : (J₁ : ∀ X : C, Set (Sieve X)) = J₂) : J₁ = J₂ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ J₂ : CategoryTheory.GrothendieckTopology C\nh : Eq ⇑J₁ ⇑J₂\n⊢ Eq J₁ J₂","decl":"/-- An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n-/\n@[ext]\ntheorem ext {J₁ J₂ : GrothendieckTopology C} (h : (J₁ : ∀ X : C, Set (Sieve X)) = J₂) : J₁ = J₂ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mem_sieves_iff_coe","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\n⊢ Iff (Membership.mem (J.sieves X) S) (Membership.mem (J X) S)","decl":"@[simp]\ntheorem mem_sieves_iff_coe : S ∈ J.sieves X ↔ S ∈ J X :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_mem","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n⊢ Membership.mem (J X) Top.top","decl":"/-- Also known as the maximality axiom. -/\n@[simp]\ntheorem top_mem (X : C) : ⊤ ∈ J X :=\n  J.top_mem' X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_stable","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nhS : Membership.mem (J X) S\n⊢ Membership.mem (J Y) (CategoryTheory.Sieve.pullback f S)","decl":"/-- Also known as the stability axiom. -/\n@[simp]\ntheorem pullback_stable (f : Y ⟶ X) (hS : S ∈ J X) : S.pullback f ∈ J Y :=\n  J.pullback_stable' f hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_mem_iff_of_isIso","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\ni : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso i\nS : CategoryTheory.Sieve Y\n⊢ Iff (Membership.mem (J X) (CategoryTheory.Sieve.pullback i S)) (Membership.mem (J Y) S)","decl":"variable {J} in\n@[simp]\nlemma pullback_mem_iff_of_isIso {i : X ⟶ Y} [IsIso i] {S : Sieve Y} :\n    S.pullback i ∈ J _ ↔ S ∈ J _ := by\n  refine ⟨fun H ↦ ?_, J.pullback_stable i⟩\n  convert J.pullback_stable (inv i) H\n  rw [← Sieve.pullback_comp, IsIso.inv_hom_id, Sieve.pullback_id]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.transitive","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nhS : Membership.mem (J X) S\nR : CategoryTheory.Sieve X\nh : ∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, S.arrows f → Membership.mem (J Y) (CategoryTheory.Sieve.pullback f R)\n⊢ Membership.mem (J X) R","decl":"theorem transitive (hS : S ∈ J X) (R : Sieve X) (h : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → R.pullback f ∈ J Y) :\n    R ∈ J X :=\n  J.transitive' hS R h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covering_of_eq_top","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\na✝ : Eq S Top.top\n⊢ Membership.mem (J X) S","decl":"theorem covering_of_eq_top : S = ⊤ → S ∈ J X := fun h => h.symm ▸ J.top_mem X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.superset_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nHss : LE.le S R\nsjx : Membership.mem (J X) S\n⊢ Membership.mem (J X) R","decl":"/-- If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.\n\nSee also discussion after [MM92] Chapter III, Section 2, Definition 1. -/\n@[stacks 00Z5 \"(2)\"]\ntheorem superset_covering (Hss : S ≤ R) (sjx : S ∈ J X) : R ∈ J X := by\n  apply J.transitive sjx R fun Y f hf => _\n  intros Y f hf\n  apply covering_of_eq_top\n  rw [← top_le_iff, ← S.pullback_eq_top_of_mem hf]\n  apply Sieve.pullback_monotone _ Hss\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.intersection_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\nrj : Membership.mem (J X) R\nsj : Membership.mem (J X) S\n⊢ Membership.mem (J X) (Min.min R S)","decl":"/-- The intersection of two covering sieves is covering.\n\nSee also [MM92] Chapter III, Section 2, Definition 1 (iv). -/\n@[stacks 00Z5 \"(1)\"]\ntheorem intersection_covering (rj : R ∈ J X) (sj : S ∈ J X) : R ⊓ S ∈ J X := by\n  apply J.transitive rj _ fun Y f Hf => _\n  intros Y f hf\n  rw [Sieve.pullback_inter, R.pullback_eq_top_of_mem hf]\n  simp [sj]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.intersection_covering_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS R : CategoryTheory.Sieve X\nJ : CategoryTheory.GrothendieckTopology C\n⊢ Iff (Membership.mem (J X) (Min.min R S)) (And (Membership.mem (J X) R) (Membership.mem (J X) S))","decl":"@[simp]\ntheorem intersection_covering_iff : R ⊓ S ∈ J X ↔ R ∈ J X ∧ S ∈ J X :=\n  ⟨fun h => ⟨J.superset_covering inf_le_left h, J.superset_covering inf_le_right h⟩, fun t =>\n    intersection_covering _ t.1 t.2⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bind_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S.arrows f → CategoryTheory.Sieve Y\nhS : Membership.mem (J X) S\nhR : ∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄ (H : S.arrows f), Membership.mem (J Y) (R H)\n⊢ Membership.mem (J X) (CategoryTheory.Sieve.bind S.arrows R)","decl":"theorem bind_covering {S : Sieve X} {R : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → Sieve Y} (hS : S ∈ J X)\n    (hR : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (H : S f), R H ∈ J Y) : Sieve.bind S R ∈ J X :=\n  J.transitive hS _ fun _ f hf => superset_covering J (Sieve.le_pullback_bind S R f hf) (hR hf)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covers_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n⊢ Iff (J.Covers S f) (Membership.mem (J Y) (CategoryTheory.Sieve.pullback f S))","decl":"theorem covers_iff (S : Sieve X) (f : Y ⟶ X) : J.Covers S f ↔ S.pullback f ∈ J Y :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covering_iff_covers_id","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem (J X) S) (J.Covers S (CategoryTheory.CategoryStruct.id X))","decl":"theorem covering_iff_covers_id (S : Sieve X) : S ∈ J X ↔ J.Covers S (𝟙 X) := by simp [covers_iff]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_max","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nhf : S.arrows f\n⊢ J.Covers S f","decl":"/-- The maximality axiom in 'arrow' form: Any arrow `f` in `S` is covered by `S`. -/\ntheorem arrow_max (f : Y ⟶ X) (S : Sieve X) (hf : S f) : J.Covers S f := by\n  rw [Covers, (Sieve.pullback_eq_top_iff_mem f).1 hf]\n  apply J.top_mem\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_stable","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nh : J.Covers S f\nZ : C\ng : Quiver.Hom Z Y\n⊢ J.Covers S (CategoryTheory.CategoryStruct.comp g f)","decl":"/-- The stability axiom in 'arrow' form: If `S` covers `f` then `S` covers `g ≫ f` for any `g`. -/\ntheorem arrow_stable (f : Y ⟶ X) (S : Sieve X) (h : J.Covers S f) {Z : C} (g : Z ⟶ Y) :\n    J.Covers S (g ≫ f) := by\n  rw [covers_iff] at h ⊢\n  simp [h, Sieve.pullback_comp]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_trans","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\nh : J.Covers S f\na✝ : ∀ {Z : C} (g : Quiver.Hom Z X), S.arrows g → J.Covers R g\n⊢ J.Covers R f","decl":"/-- The transitivity axiom in 'arrow' form: If `S` covers `f` and every arrow in `S` is covered by\n`R`, then `R` covers `f`.\n-/\ntheorem arrow_trans (f : Y ⟶ X) (S R : Sieve X) (h : J.Covers S f) :\n    (∀ {Z : C} (g : Z ⟶ X), S g → J.Covers R g) → J.Covers R f := by\n  intro k\n  apply J.transitive h\n  intro Z g hg\n  rw [← Sieve.pullback_comp]\n  apply k (g ≫ f) hg\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.arrow_intersect","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\nhS : J.Covers S f\nhR : J.Covers R f\n⊢ J.Covers (Min.min S R) f","decl":"theorem arrow_intersect (f : Y ⟶ X) (S R : Sieve X) (hS : J.Covers S f) (hR : J.Covers R f) :\n    J.Covers (S ⊓ R) f := by simpa [covers_iff] using And.intro hS hR\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.trivial_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((CategoryTheory.GrothendieckTopology.trivial C) X) S) (Eq S Top.top)","decl":"theorem trivial_covering : S ∈ trivial C X ↔ S = ⊤ :=\n  Set.mem_singleton_iff\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.le_def","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ J₂ : CategoryTheory.GrothendieckTopology C\n⊢ Iff (LE.le J₁ J₂) (LE.le ⇑J₁ ⇑J₂)","decl":"theorem le_def {J₁ J₂ : GrothendieckTopology C} : J₁ ≤ J₂ ↔ (J₁ : ∀ X : C, Set (Sieve X)) ≤ J₂ :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mem_sInf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\ns : Set (CategoryTheory.GrothendieckTopology C)\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((InfSet.sInf s) X) S) (∀ (t : CategoryTheory.GrothendieckTopology C), Membership.mem s t → Membership.mem (t X) S)","decl":"lemma mem_sInf (s : Set (GrothendieckTopology C)) {X : C} (S : Sieve X) :\n    S ∈ sInf s X ↔ ∀ t ∈ s, S ∈ t X := by\n  show S ∈ sInf (sieves '' s) X ↔ _\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isGLB_sInf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\ns : Set (CategoryTheory.GrothendieckTopology C)\n⊢ IsGLB s (InfSet.sInf s)","decl":"@[stacks 00Z7]\ntheorem isGLB_sInf (s : Set (GrothendieckTopology C)) : IsGLB s (sInf s) := by\n  refine @IsGLB.of_image _ _ _ _ sieves ?_ _ _ ?_\n  · rfl\n  · exact _root_.isGLB_sInf _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.trivial_eq_bot","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.GrothendieckTopology.trivial C) Bot.bot","decl":"@[simp]\ntheorem trivial_eq_bot : trivial C = ⊥ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.discrete_eq_top","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.GrothendieckTopology.discrete C) Top.top","decl":"@[simp]\ntheorem discrete_eq_top : discrete C = ⊤ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bot_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem (Bot.bot X) S) (Eq S Top.top)","decl":"@[simp]\ntheorem bot_covering : S ∈ (⊥ : GrothendieckTopology C) X ↔ S = ⊤ :=\n  trivial_covering\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Membership.mem (Top.top X) S","decl":"@[simp]\ntheorem top_covering : S ∈ (⊤ : GrothendieckTopology C) X :=\n  ⟨⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.bot_covers","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n⊢ Iff (Bot.bot.Covers S f) (S.arrows f)","decl":"theorem bot_covers (S : Sieve X) (f : Y ⟶ X) : (⊥ : GrothendieckTopology C).Covers S f ↔ S f := by\n  rw [covers_iff, bot_covering, ← Sieve.pullback_eq_top_iff_mem]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.top_covers","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n⊢ Top.top.Covers S f","decl":"@[simp]\ntheorem top_covers (S : Sieve X) (f : Y ⟶ X) : (⊤ : GrothendieckTopology C).Covers S f := by\n  simp [covers_iff]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.dense_covering","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem (CategoryTheory.GrothendieckTopology.dense X) S) (∀ {Y : C} (f : Quiver.Hom Y X), Exists fun Z => Exists fun g => S.arrows (CategoryTheory.CategoryStruct.comp g f))","decl":"theorem dense_covering : S ∈ dense X ↔ ∀ {Y} (f : Y ⟶ X), ∃ (Z : _) (g : Z ⟶ Y), S (g ≫ f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.right_ore_of_pullbacks","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.GrothendieckTopology.RightOreCondition C","decl":"theorem right_ore_of_pullbacks [Limits.HasPullbacks C] : RightOreCondition C := fun _ _ =>\n  ⟨_, _, _, Limits.pullback.condition⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\n⊢ Membership.mem (J X) ↑S","decl":"theorem condition (S : J.Cover X) : (S : Sieve X) ∈ J X := S.2\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nh : ∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), Iff ((↑S).arrows f) ((↑T).arrows f)\n⊢ Eq S T","decl":"@[ext]\ntheorem ext (S T : J.Cover X) (h : ∀ ⦃Y⦄ (f : Y ⟶ X), S f ↔ T f) : S = T :=\n  Subtype.ext <| Sieve.ext h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\n⊢ Iff (Eq S T) (∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), Iff ((↑S).arrows f) ((↑T).arrows f))","decl":"@[ext]\ntheorem ext (S T : J.Cover X) (h : ∀ ⦃Y⦄ (f : Y ⟶ X), S f ↔ T f) : S = T :=\n  Subtype.ext <| Sieve.ext h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Arrow\n⊢ Iff (Eq x y) (And (Eq x.Y y.Y) (HEq x.f y.f))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Arrow\nY : Eq x.Y y.Y\nf : HEq x.f y.f\n⊢ Eq x y","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\ninst✝ : SizeOf C\nY : C\nf : Quiver.Hom Y X\nhf : (↑S).arrows f\n⊢ Eq (SizeOf.sizeOf { Y := Y, f := f, hf := hf }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Y)) (SizeOf.sizeOf f)) (SizeOf.sizeOf hf))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nY✝ : C\nf✝ : Quiver.Hom Y✝ X\nhf✝ : (↑S).arrows f✝\nY : C\nf : Quiver.Hom Y X\nhf : (↑S).arrows f\n⊢ Eq (Eq { Y := Y✝, f := f✝, hf := hf✝ } { Y := Y, f := f, hf := hf }) (And (Eq Y✝ Y) (HEq f✝ f))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nY✝ : C\nf✝ : Quiver.Hom Y✝ X\nhf✝ : (↑S).arrows f✝\nY : C\nf : Quiver.Hom Y X\nhf : (↑S).arrows f\nx✝ : Eq { Y := Y✝, f := f✝, hf := hf✝ } { Y := Y, f := f, hf := hf }\n⊢ And (Eq Y✝ Y) (HEq f✝ f)","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.hf","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nself : S.Arrow\n⊢ (↑S).arrows self.f","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Arrow (S : J.Cover X) where\n  /-- The source of the arrow. -/\n  Y : C\n  /-- The arrow itself. -/\n  f : Y ⟶ X\n  /-- The given arrow is contained in the given sieve. -/\n  hf : S f\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nZ✝ : C\ng₁✝ : Quiver.Hom Z✝ I₁.Y\ng₂✝ : Quiver.Hom Z✝ I₂.Y\nw✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp g₁✝ I₁.f) (CategoryTheory.CategoryStruct.comp g₂✝ I₂.f)) _auto✝\nZ : C\ng₁ : Quiver.Hom Z I₁.Y\ng₂ : Quiver.Hom Z I₂.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g₁ I₁.f) (CategoryTheory.CategoryStruct.comp g₂ I₂.f)) _auto✝\n⊢ Eq (Eq { Z := Z✝, g₁ := g₁✝, g₂ := g₂✝, w := w✝ } { Z := Z, g₁ := g₁, g₂ := g₂, w := w }) (And (Eq Z✝ Z) (And (HEq g₁✝ g₁) (HEq g₂✝ g₂)))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nZ✝ : C\ng₁✝ : Quiver.Hom Z✝ I₁.Y\ng₂✝ : Quiver.Hom Z✝ I₂.Y\nw✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp g₁✝ I₁.f) (CategoryTheory.CategoryStruct.comp g₂✝ I₂.f)) _auto✝\nZ : C\ng₁ : Quiver.Hom Z I₁.Y\ng₂ : Quiver.Hom Z I₂.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g₁ I₁.f) (CategoryTheory.CategoryStruct.comp g₂ I₂.f)) _auto✝\nx✝ : Eq { Z := Z✝, g₁ := g₁✝, g₂ := g₂✝, w := w✝ } { Z := Z, g₁ := g₁, g₂ := g₂, w := w }\n⊢ And (Eq Z✝ Z) (And (HEq g₁✝ g₁) (HEq g₂✝ g₂))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.w","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nself : I₁.Relation I₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.g₁ I₁.f) (CategoryTheory.CategoryStruct.comp self.g₂ I₂.f)","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nx y : I₁.Relation I₂\n⊢ Iff (Eq x y) (And (Eq x.Z y.Z) (And (HEq x.g₁ y.g₁) (HEq x.g₂ y.g₂)))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nx y : I₁.Relation I₂\nZ : Eq x.Z y.Z\ng₁ : HEq x.g₁ y.g₁\ng₂ : HEq x.g₂ y.g₂\n⊢ Eq x y","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\ninst✝ : SizeOf C\nZ : C\ng₁ : Quiver.Hom Z I₁.Y\ng₂ : Quiver.Hom Z I₂.Y\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp g₁ I₁.f) (CategoryTheory.CategoryStruct.comp g₂ I₂.f)) _auto✝\n⊢ Eq (SizeOf.sizeOf { Z := Z, g₁ := g₁, g₂ := g₂, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf g₁)) (SizeOf.sizeOf g₂)) (SizeOf.sizeOf w))","decl":"/-- Relation between two elements in `S.arrow`, the data of which\ninvolves a commutative square. -/\n@[ext]\nstructure Arrow.Relation {S : J.Cover X} (I₁ I₂ : S.Arrow) where\n  /-- The source of the arrows defining the relation. -/\n  Z : C\n  /-- The first arrow defining the relation. -/\n  g₁ : Z ⟶ I₁.Y\n  /-- The second arrow defining the relation. -/\n  g₂ : Z ⟶ I₂.Y\n  /-- The relation itself. -/\n  w : g₁ ≫ I₁.f = g₂ ≫ I₂.f := by aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.w_assoc","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI₁ I₂ : S.Arrow\nself : I₁.Relation I₂\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.g₁ (CategoryTheory.CategoryStruct.comp I₁.f h)) (CategoryTheory.CategoryStruct.comp self.g₂ (CategoryTheory.CategoryStruct.comp I₂.f h))","decl":"attribute [reassoc] Arrow.Relation.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precomp_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n⊢ Eq (I.precomp g).Y Z","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ⟶ I.Y`, this is the arrow in `S.Arrow`\ncorresponding to `g ≫ I.f`. -/\n@[simps]\ndef Arrow.precomp {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ⟶ I.Y) : S.Arrow :=\n  ⟨Z, g ≫ I.f, S.1.downward_closed I.hf g⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precomp_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n⊢ Eq (I.precomp g).f (CategoryTheory.CategoryStruct.comp g I.f)","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ⟶ I.Y`, this is the arrow in `S.Arrow`\ncorresponding to `g ≫ I.f`. -/\n@[simps]\ndef Arrow.precomp {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ⟶ I.Y) : S.Arrow :=\n  ⟨Z, g ≫ I.f, S.1.downward_closed I.hf g⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_Z","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n⊢ Eq (I.precompRelation g).Z (I.precomp g).Y","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ⟶ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ⟶ I.Y) :\n    (I.precomp g).Relation I where\n  g₁ := 𝟙 _\n  g₂ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_g₁","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n⊢ Eq (I.precompRelation g).g₁ (CategoryTheory.CategoryStruct.id (I.precomp g).Y)","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ⟶ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ⟶ I.Y) :\n    (I.precomp g).Relation I where\n  g₁ := 𝟙 _\n  g₂ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.precompRelation_g₂","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nI : S.Arrow\nZ : C\ng : Quiver.Hom Z I.Y\n⊢ Eq (I.precompRelation g).g₂ g","decl":"/-- Given `I : S.Arrow` and a morphism `g : Z ⟶ I.Y`, this is the obvious relation\nfrom `I.precomp g` to `I`. -/\n@[simps]\ndef Arrow.precompRelation {S : J.Cover X} (I : S.Arrow) {Z : C} (g : Z ⟶ I.Y) :\n    (I.precomp g).Relation I where\n  g₁ := 𝟙 _\n  g₂ := g\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.map_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI : S.Arrow\nf : Quiver.Hom S T\n⊢ Eq (I.map f).Y I.Y","decl":"/-- Map an `Arrow` along a refinement `S ⟶ T`. -/\n@[simps]\ndef Arrow.map {S T : J.Cover X} (I : S.Arrow) (f : S ⟶ T) : T.Arrow :=\n  ⟨I.Y, I.f, f.le _ I.hf⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.map_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI : S.Arrow\nf : Quiver.Hom S T\n⊢ Eq (I.map f).f I.f","decl":"/-- Map an `Arrow` along a refinement `S ⟶ T`. -/\n@[simps]\ndef Arrow.map {S T : J.Cover X} (I : S.Arrow) (f : S ⟶ T) : T.Arrow :=\n  ⟨I.Y, I.f, f.le _ I.hf⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_g₂","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI₁ I₂ : S.Arrow\nr : I₁.Relation I₂\nf : Quiver.Hom S T\n⊢ Eq (r.map f).g₂ r.g₂","decl":"/-- Map an `Arrow.Relation` along a refinement `S ⟶ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I₁ I₂ : S.Arrow}\n    (r : I₁.Relation I₂) (f : S ⟶ T) : (I₁.map f).Relation (I₂.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_g₁","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI₁ I₂ : S.Arrow\nr : I₁.Relation I₂\nf : Quiver.Hom S T\n⊢ Eq (r.map f).g₁ r.g₁","decl":"/-- Map an `Arrow.Relation` along a refinement `S ⟶ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I₁ I₂ : S.Arrow}\n    (r : I₁.Relation I₂) (f : S ⟶ T) : (I₁.map f).Relation (I₂.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.map_Z","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS T : J.Cover X\nI₁ I₂ : S.Arrow\nr : I₁.Relation I₂\nf : Quiver.Hom S T\n⊢ Eq (r.map f).Z r.Z","decl":"/-- Map an `Arrow.Relation` along a refinement `S ⟶ T`. -/\n@[simps]\ndef Arrow.Relation.map {S T : J.Cover X} {I₁ I₂ : S.Arrow}\n    (r : I₁.Relation I₂) (f : S ⟶ T) : (I₁.map f).Relation (I₂.map f) where\n  w := r.w\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.base_f","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\nI : (S.pullback f).Arrow\n⊢ Eq I.base.f (CategoryTheory.CategoryStruct.comp I.f f)","decl":"/-- An arrow of `S.pullback f` gives rise to an arrow of `S`. -/\n@[simps]\ndef Arrow.base {f : Y ⟶ X} {S : J.Cover X} (I : (S.pullback f).Arrow) : S.Arrow :=\n  ⟨I.Y, I.f ≫ f, I.hf⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.base_Y","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\nI : (S.pullback f).Arrow\n⊢ Eq I.base.Y I.Y","decl":"/-- An arrow of `S.pullback f` gives rise to an arrow of `S`. -/\n@[simps]\ndef Arrow.base {f : Y ⟶ X} {S : J.Cover X} (I : (S.pullback f).Arrow) : S.Arrow :=\n  ⟨I.Y, I.f ≫ f, I.hf⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.coe_pullback","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nZ : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nS : J.Cover X\n⊢ Iff ((↑(S.pullback f)).arrows g) ((↑S).arrows (CategoryTheory.CategoryStruct.comp g f))","decl":"@[simp]\ntheorem coe_pullback {Z : C} (f : Y ⟶ X) (g : Z ⟶ Y) (S : J.Cover X) :\n    (S.pullback f) g ↔ S (g ≫ f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.from_middle_condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) → J.Cover I.Y\nI : (S.bind T).Arrow\n⊢ (↑S).arrows I.fromMiddleHom","decl":"theorem Arrow.from_middle_condition {X : C} {S : J.Cover X} {T : ∀ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : S I.fromMiddleHom :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.to_middle_condition","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) → J.Cover I.Y\nI : (S.bind T).Arrow\n⊢ (↑(T I.fromMiddle)).arrows I.toMiddleHom","decl":"theorem Arrow.to_middle_condition {X : C} {S : J.Cover X} {T : ∀ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : (T I.fromMiddle) I.toMiddleHom :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose_spec.1\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.middle_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nS : J.Cover X\nT : (I : S.Arrow) → J.Cover I.Y\nI : (S.bind T).Arrow\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.toMiddleHom I.fromMiddleHom) I.f","decl":"theorem Arrow.middle_spec {X : C} {S : J.Cover X} {T : ∀ I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : I.toMiddleHom ≫ I.fromMiddleHom = I.f :=\n  I.hf.choose_spec.choose_spec.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.ext_iff","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Relation\n⊢ Iff (Eq x y) (And (Eq x.fst y.fst) (And (Eq x.snd y.snd) (HEq x.r y.r)))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\ninst✝ : SizeOf C\nfst snd : S.Arrow\nr : fst.Relation snd\n⊢ Eq (SizeOf.sizeOf { fst := fst, snd := snd, r := r }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf fst)) (SizeOf.sizeOf snd)) (SizeOf.sizeOf r))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.ext","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nx y : S.Relation\nfst : Eq x.fst y.fst\nsnd : Eq x.snd y.snd\nr : HEq x.r y.r\n⊢ Eq x y","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.inj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst✝ snd✝ : S.Arrow\nr✝ : fst✝.Relation snd✝\nfst snd : S.Arrow\nr : fst.Relation snd\nx✝ : Eq { fst := fst✝, snd := snd✝, r := r✝ } { fst := fst, snd := snd, r := r }\n⊢ And (Eq fst✝ fst) (And (Eq snd✝ snd) (HEq r✝ r))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst✝ snd✝ : S.Arrow\nr✝ : fst✝.Relation snd✝\nfst snd : S.Arrow\nr : fst.Relation snd\n⊢ Eq (Eq { fst := fst✝, snd := snd✝, r := r✝ } { fst := fst, snd := snd, r := r }) (And (Eq fst✝ fst) (And (Eq snd✝ snd) (HEq r✝ r)))","decl":"/-- An auxiliary structure, used to define `S.index`. -/\n@[ext]\nstructure Relation (S : J.Cover X) where\n  /-- The first arrow. -/\n  fst : S.Arrow\n  /-- The second arrow. -/\n  snd : S.Arrow\n  /-- The relation between the two arrows. -/\n  r : fst.Relation snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_fst","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n⊢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).fst fst","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I₁.Relation I₂` with `I₁ I₂ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_r","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n⊢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).r r","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I₁.Relation I₂` with `I₁ I₂ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.Relation.mk'_snd","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nS : J.Cover X\nfst snd : S.Arrow\nr : fst.Relation snd\n⊢ Eq (CategoryTheory.GrothendieckTopology.Cover.Relation.mk' r).snd snd","decl":"/-- Constructor for `Cover.Relation` which takes as an input\n`r : I₁.Relation I₂` with `I₁ I₂ : S.Arrow`. -/\n@[simps]\ndef Relation.mk' {S : J.Cover X} {fst snd : S.Arrow} (r : fst.Relation snd) :\n    S.Relation where\n  r := r\n\n-- This is used extensively in `Plus.lean`, etc.\n-- We place this definition here as it will be used in `Sheaf.lean` as well.\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_sndTo","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n⊢ Eq ((S.index P).sndTo I) I.snd","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_snd","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n⊢ Eq ((S.index P).snd I) (P.map I.r.g₂.op)","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_fst","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n⊢ Eq ((S.index P).fst I) (P.map I.r.g₁.op)","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_R","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq (S.index P).R S.Relation","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_L","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq (S.index P).L S.Arrow","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_left","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Arrow\n⊢ Eq ((S.index P).left I) (P.obj { unop := I.Y })","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_fstTo","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n⊢ Eq ((S.index P).fstTo I) I.fst","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.index_right","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nS : J.Cover X\nP : CategoryTheory.Functor (Opposite C) D\nI : S.Relation\n⊢ Eq ((S.index P).right I) (P.obj { unop := I.r.Z })","decl":"/-- To every `S : J.Cover X` and presheaf `P`, associate a `MulticospanIndex`. -/\n@[simps]\ndef index {D : Type u₁} [Category.{v₁} D] (S : J.Cover X) (P : Cᵒᵖ ⥤ D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.r.Z)\n  fst I := P.map I.r.g₁.op\n  snd I := P.map I.r.g₂.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_obj","module":"Mathlib.CategoryTheory.Sites.Grothendieck","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nJ : CategoryTheory.GrothendieckTopology C\nf : Quiver.Hom Y X\nS : J.Cover X\n⊢ Eq ((J.pullback f).obj S) (S.pullback f)","decl":"/-- Pull back a cover along a morphism. -/\n@[simps obj]\ndef pullback (f : Y ⟶ X) : J.Cover X ⥤ J.Cover Y where\n  obj S := S.pullback f\n  map f := (Sieve.pullback_monotone _ f.le).hom\n\n"}
