{"name":"GaussianFourier.norm_cexp_neg_mul_sq_add_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nc T : Real\n‚ä¢ Eq (Norm.norm (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (HAdd.hAdd (‚ÜëT) (HMul.hMul (‚Üëc) Complex.I)) 2)))) (Real.exp (Neg.neg (HSub.hSub (HSub.hSub (HMul.hMul b.re (HPow.hPow T 2)) (HMul.hMul (HMul.hMul (HMul.hMul 2 b.im) c) T)) (HMul.hMul b.re (HPow.hPow c 2)))))","decl":"/-- Explicit formula for the norm of the Gaussian function along the vertical\nedges. -/\ntheorem norm_cexp_neg_mul_sq_add_mul_I (b : ‚ÑÇ) (c T : ‚Ñù) :\n    ‚Äñcexp (-b * (T + c * I) ^ 2)‚Äñ = exp (-(b.re * T ^ 2 - 2 * b.im * c * T - b.re * c ^ 2)) := by\n  rw [Complex.norm_eq_abs, Complex.abs_exp, neg_mul, neg_re, ‚Üê re_add_im b]\n  simp only [sq, re_add_im, mul_re, mul_im, add_re, add_im, ofReal_re, ofReal_im, I_re, I_im]\n  ring_nf\n\n"}
{"name":"GaussianFourier.norm_cexp_neg_mul_sq_add_mul_I'","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : Ne b.re 0\nc T : Real\n‚ä¢ Eq (Norm.norm (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (HAdd.hAdd (‚ÜëT) (HMul.hMul (‚Üëc) Complex.I)) 2)))) (Real.exp (Neg.neg (HSub.hSub (HMul.hMul b.re (HPow.hPow (HSub.hSub T (HDiv.hDiv (HMul.hMul b.im c) b.re)) 2)) (HMul.hMul (HPow.hPow c 2) (HAdd.hAdd (HDiv.hDiv (HPow.hPow b.im 2) b.re) b.re)))))","decl":"theorem norm_cexp_neg_mul_sq_add_mul_I' (hb : b.re ‚â† 0) (c T : ‚Ñù) :\n    ‚Äñcexp (-b * (T + c * I) ^ 2)‚Äñ =\n      exp (-(b.re * (T - b.im * c / b.re) ^ 2 - c ^ 2 * (b.im ^ 2 / b.re + b.re))) := by\n  have :\n    b.re * T ^ 2 - 2 * b.im * c * T - b.re * c ^ 2 =\n      b.re * (T - b.im * c / b.re) ^ 2 - c ^ 2 * (b.im ^ 2 / b.re + b.re) := by\n    field_simp; ring\n  rw [norm_cexp_neg_mul_sq_add_mul_I, this]\n\n"}
{"name":"GaussianFourier.verticalIntegral_norm_le","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc T : Real\nhT : LE.le 0 T\n‚ä¢ LE.le (Norm.norm (GaussianFourier.verticalIntegral b c T)) (HMul.hMul (HMul.hMul 2 (abs c)) (Real.exp (Neg.neg (HSub.hSub (HSub.hSub (HMul.hMul b.re (HPow.hPow T 2)) (HMul.hMul (HMul.hMul (HMul.hMul 2 (abs b.im)) (abs c)) T)) (HMul.hMul b.re (HPow.hPow c 2))))))","decl":"theorem verticalIntegral_norm_le (hb : 0 < b.re) (c : ‚Ñù) {T : ‚Ñù} (hT : 0 ‚â§ T) :\n    ‚ÄñverticalIntegral b c T‚Äñ ‚â§\n      (2 : ‚Ñù) * |c| * exp (-(b.re * T ^ 2 - (2 : ‚Ñù) * |b.im| * |c| * T - b.re * c ^ 2)) := by\n  -- first get uniform bound for integrand\n  have vert_norm_bound :\n    ‚àÄ {T : ‚Ñù},\n      0 ‚â§ T ‚Üí\n        ‚àÄ {c y : ‚Ñù},\n          |y| ‚â§ |c| ‚Üí\n            ‚Äñcexp (-b * (T + y * I) ^ 2)‚Äñ ‚â§\n              exp (-(b.re * T ^ 2 - (2 : ‚Ñù) * |b.im| * |c| * T - b.re * c ^ 2)) := by\n    intro T hT c y hy\n    rw [norm_cexp_neg_mul_sq_add_mul_I b]\n    gcongr exp (- (_ - ?_ * _ - _ * ?_))\n    ¬∑ (conv_lhs => rw [mul_assoc]); (conv_rhs => rw [mul_assoc])\n      gcongr _ * ?_\n      refine (le_abs_self _).trans ?_\n      rw [abs_mul]\n      gcongr\n    ¬∑ rwa [sq_le_sq]\n  -- now main proof\n  apply (intervalIntegral.norm_integral_le_of_norm_le_const _).trans\n  ¬∑ rw [sub_zero]\n    conv_lhs => simp only [mul_comm _ |c|]\n    conv_rhs =>\n      conv =>\n        congr\n        rw [mul_comm]\n      rw [mul_assoc]\n  ¬∑ intro y hy\n    have absy : |y| ‚â§ |c| := by\n      rcases le_or_lt 0 c with (h | h)\n      ¬∑ rw [uIoc_of_le h] at hy\n        rw [abs_of_nonneg h, abs_of_pos hy.1]\n        exact hy.2\n      ¬∑ rw [uIoc_of_ge h.le] at hy\n        rw [abs_of_neg h, abs_of_nonpos hy.2, neg_le_neg_iff]\n        exact hy.1.le\n    rw [norm_mul, Complex.norm_eq_abs, abs_I, one_mul, two_mul]\n    refine (norm_sub_le _ _).trans (add_le_add (vert_norm_bound hT absy) ?_)\n    rw [‚Üê abs_neg y] at absy\n    simpa only [neg_mul, ofReal_neg] using vert_norm_bound hT absy\n\n"}
{"name":"GaussianFourier.tendsto_verticalIntegral","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc : Real\n‚ä¢ Filter.Tendsto (GaussianFourier.verticalIntegral b c) Filter.atTop (nhds 0)","decl":"theorem tendsto_verticalIntegral (hb : 0 < b.re) (c : ‚Ñù) :\n    Tendsto (verticalIntegral b c) atTop (ùìù 0) := by\n  -- complete proof using squeeze theorem:\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  refine\n    tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds ?_\n      (Eventually.of_forall fun _ => norm_nonneg _)\n      ((eventually_ge_atTop (0 : ‚Ñù)).mp\n        (Eventually.of_forall fun T hT => verticalIntegral_norm_le hb c hT))\n  rw [(by ring : 0 = 2 * |c| * 0)]\n  refine (tendsto_exp_atBot.comp (tendsto_neg_atTop_atBot.comp ?_)).const_mul _\n  apply tendsto_atTop_add_const_right\n  simp_rw [sq, ‚Üê mul_assoc, ‚Üê sub_mul]\n  refine Tendsto.atTop_mul_atTop (tendsto_atTop_add_const_right _ _ ?_) tendsto_id\n  exact (tendsto_const_mul_atTop_of_pos hb).mpr tendsto_id\n\n"}
{"name":"GaussianFourier.integrable_cexp_neg_mul_sq_add_real_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc : Real\n‚ä¢ MeasureTheory.Integrable (fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (HAdd.hAdd (‚Üëx) (HMul.hMul (‚Üëc) Complex.I)) 2))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_cexp_neg_mul_sq_add_real_mul_I (hb : 0 < b.re) (c : ‚Ñù) :\n    Integrable fun x : ‚Ñù => cexp (-b * (x + c * I) ^ 2) := by\n  refine\n    ‚ü®(Complex.continuous_exp.comp\n          (continuous_const.mul\n            ((continuous_ofReal.add continuous_const).pow 2))).aestronglyMeasurable,\n      ?_‚ü©\n  rw [‚Üê hasFiniteIntegral_norm_iff]\n  simp_rw [norm_cexp_neg_mul_sq_add_mul_I' hb.ne', neg_sub _ (c ^ 2 * _),\n    sub_eq_add_neg _ (b.re * _), Real.exp_add]\n  suffices Integrable fun x : ‚Ñù => exp (-(b.re * x ^ 2)) by\n    exact (Integrable.comp_sub_right this (b.im * c / b.re)).hasFiniteIntegral.const_mul _\n  simp_rw [‚Üê neg_mul]\n  apply integrable_exp_neg_mul_sq hb\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_mul_sq_add_real_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc : Real\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (HAdd.hAdd (‚Üëx) (HMul.hMul (‚Üëc) Complex.I)) 2))) (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (1 / 2))","decl":"theorem integral_cexp_neg_mul_sq_add_real_mul_I (hb : 0 < b.re) (c : ‚Ñù) :\n    ‚à´ x : ‚Ñù, cexp (-b * (x + c * I) ^ 2) = (œÄ / b) ^ (1 / 2 : ‚ÑÇ) := by\n  refine\n    tendsto_nhds_unique\n      (intervalIntegral_tendsto_integral (integrable_cexp_neg_mul_sq_add_real_mul_I hb c)\n        tendsto_neg_atTop_atBot tendsto_id)\n      ?_\n  set I‚ÇÅ := fun T => ‚à´ x : ‚Ñù in -T..T, cexp (-b * (x + c * I) ^ 2) with HI‚ÇÅ\n  let I‚ÇÇ := fun T : ‚Ñù => ‚à´ x : ‚Ñù in -T..T, cexp (-b * (x : ‚ÑÇ) ^ 2)\n  let I‚ÇÑ := fun T : ‚Ñù => ‚à´ y : ‚Ñù in (0 : ‚Ñù)..c, cexp (-b * (T + y * I) ^ 2)\n  let I‚ÇÖ := fun T : ‚Ñù => ‚à´ y : ‚Ñù in (0 : ‚Ñù)..c, cexp (-b * (-T + y * I) ^ 2)\n  have C : ‚àÄ T : ‚Ñù, I‚ÇÇ T - I‚ÇÅ T + I * I‚ÇÑ T - I * I‚ÇÖ T = 0 := by\n    intro T\n    have :=\n      integral_boundary_rect_eq_zero_of_differentiableOn (fun z => cexp (-b * z ^ 2)) (-T)\n        (T + c * I)\n        (by\n          refine Differentiable.differentiableOn (Differentiable.const_mul ?_ _).cexp\n          exact differentiable_pow 2)\n    simpa only [neg_im, ofReal_im, neg_zero, ofReal_zero, zero_mul, add_zero, neg_re,\n      ofReal_re, add_re, mul_re, I_re, mul_zero, I_im, tsub_zero, add_im, mul_im,\n      mul_one, zero_add, Algebra.id.smul_eq_mul, ofReal_neg] using this\n  simp_rw [id, ‚Üê HI‚ÇÅ]\n  have : I‚ÇÅ = fun T : ‚Ñù => I‚ÇÇ T + verticalIntegral b c T := by\n    ext1 T\n    specialize C T\n    rw [sub_eq_zero] at C\n    unfold verticalIntegral\n    rw [integral_const_mul, intervalIntegral.integral_sub]\n    ¬∑ simp_rw [(fun a b => by rw [sq]; ring_nf : ‚àÄ a b : ‚ÑÇ, (a - b * I) ^ 2 = (-a + b * I) ^ 2)]\n      change I‚ÇÅ T = I‚ÇÇ T + I * (I‚ÇÑ T - I‚ÇÖ T)\n      rw [mul_sub, ‚Üê C]\n      abel\n    all_goals apply Continuous.intervalIntegrable; continuity\n  rw [this, ‚Üê add_zero ((œÄ / b : ‚ÑÇ) ^ (1 / 2 : ‚ÑÇ)), ‚Üê integral_gaussian_complex hb]\n  refine Tendsto.add ?_ (tendsto_verticalIntegral hb c)\n  exact\n    intervalIntegral_tendsto_integral (integrable_cexp_neg_mul_sq hb) tendsto_neg_atTop_atBot\n      tendsto_id\n\n"}
{"name":"integral_cexp_quadratic","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt b.re 0\nc d : Complex\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Complex.exp (HAdd.hAdd (HAdd.hAdd (HMul.hMul b (HPow.hPow (‚Üëx) 2)) (HMul.hMul c ‚Üëx)) d)) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) (Neg.neg b)) (1 / 2)) (Complex.exp (HSub.hSub d (HDiv.hDiv (HPow.hPow c 2) (HMul.hMul 4 b)))))","decl":"theorem _root_.integral_cexp_quadratic (hb : b.re < 0) (c d : ‚ÑÇ) :\n    ‚à´ x : ‚Ñù, cexp (b * x ^ 2 + c * x + d) = (œÄ / -b) ^ (1 / 2 : ‚ÑÇ) * cexp (d - c^2 / (4 * b)) := by\n  have hb' : b ‚â† 0 := by contrapose! hb; rw [hb, zero_re]\n  have h (x : ‚Ñù) : cexp (b * x ^ 2 + c * x + d) =\n      cexp (- -b * (x + c / (2 * b)) ^ 2) * cexp (d - c ^ 2 / (4 * b)) := by\n    simp_rw [‚Üê Complex.exp_add]\n    congr 1\n    field_simp\n    ring_nf\n  simp_rw [h, integral_mul_right]\n  rw [‚Üê re_add_im (c / (2 * b))]\n  simp_rw [‚Üê add_assoc, ‚Üê ofReal_add]\n  rw [integral_add_right_eq_self fun a : ‚Ñù ‚Ü¶ cexp (- -b * (‚Üëa + ‚Üë(c / (2 * b)).im * I) ^ 2),\n    integral_cexp_neg_mul_sq_add_real_mul_I ((neg_re b).symm ‚ñ∏ (neg_pos.mpr hb))]\n\n"}
{"name":"integrable_cexp_quadratic'","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt b.re 0\nc d : Complex\n‚ä¢ MeasureTheory.Integrable (fun x => Complex.exp (HAdd.hAdd (HAdd.hAdd (HMul.hMul b (HPow.hPow (‚Üëx) 2)) (HMul.hMul c ‚Üëx)) d)) MeasureTheory.MeasureSpace.volume","decl":"lemma _root_.integrable_cexp_quadratic' (hb : b.re < 0) (c d : ‚ÑÇ) :\n    Integrable (fun (x : ‚Ñù) ‚Ü¶ cexp (b * x ^ 2 + c * x + d)) := by\n  have hb' : b ‚â† 0 := by contrapose! hb; rw [hb, zero_re]\n  by_contra H\n  simpa [hb', pi_ne_zero, Complex.exp_ne_zero, integral_undef H]\n    using integral_cexp_quadratic hb c d\n\n"}
{"name":"integrable_cexp_quadratic","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc d : Complex\n‚ä¢ MeasureTheory.Integrable (fun x => Complex.exp (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2)) (HMul.hMul c ‚Üëx)) d)) MeasureTheory.MeasureSpace.volume","decl":"lemma _root_.integrable_cexp_quadratic (hb : 0 < b.re) (c d : ‚ÑÇ) :\n    Integrable (fun (x : ‚Ñù) ‚Ü¶ cexp (-b * x ^ 2 + c * x + d)) := by\n  have : (-b).re < 0 := by simpa using hb\n  exact integrable_cexp_quadratic' this c d\n\n"}
{"name":"fourierIntegral_gaussian","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nt : Complex\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul Complex.I t) ‚Üëx)) (Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üëx) 2)))) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (1 / 2)) (Complex.exp (HDiv.hDiv (Neg.neg (HPow.hPow t 2)) (HMul.hMul 4 b))))","decl":"theorem _root_.fourierIntegral_gaussian (hb : 0 < b.re) (t : ‚ÑÇ) :\n    ‚à´ x : ‚Ñù, cexp (I * t * x) * cexp (-b * x ^ 2) =\n    (œÄ / b) ^ (1 / 2 : ‚ÑÇ) * cexp (-t ^ 2 / (4 * b)) := by\n  conv => enter [1, 2, x]; rw [‚Üê Complex.exp_add, add_comm, ‚Üê add_zero (-b * x ^ 2 + I * t * x)]\n  rw [integral_cexp_quadratic (show (-b).re < 0 by rwa [neg_re, neg_lt_zero]), neg_neg, zero_sub,\n    mul_neg, div_neg, neg_neg, mul_pow, I_sq, neg_one_mul, mul_comm]\n\n"}
{"name":"fourierIntegral_gaussian_pi'","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\nc : Complex\n‚ä¢ Eq (Real.fourierIntegral fun x => Complex.exp (HAdd.hAdd (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) b) (HPow.hPow (‚Üëx) 2)) (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) c) ‚Üëx))) fun t => HMul.hMul (HDiv.hDiv 1 (HPow.hPow b (1 / 2))) (Complex.exp (HMul.hMul (HDiv.hDiv (Neg.neg ‚ÜëReal.pi) b) (HPow.hPow (HAdd.hAdd (‚Üët) (HMul.hMul Complex.I c)) 2)))","decl":"theorem _root_.fourierIntegral_gaussian_pi' (hb : 0 < b.re) (c : ‚ÑÇ) :\n    (ùìï fun x : ‚Ñù => cexp (-œÄ * b * x ^ 2 + 2 * œÄ * c * x)) = fun t : ‚Ñù =>\n    1 / b ^ (1 / 2 : ‚ÑÇ) * cexp (-œÄ / b * (t + I * c) ^ 2) := by\n  haveI : b ‚â† 0 := by contrapose! hb; rw [hb, zero_re]\n  have h : (-‚ÜëœÄ * b).re < 0 := by\n    simpa only [neg_mul, neg_re, re_ofReal_mul, neg_lt_zero] using mul_pos pi_pos hb\n  ext1 t\n  simp_rw [fourierIntegral_real_eq_integral_exp_smul, smul_eq_mul, ‚Üê Complex.exp_add, ‚Üê add_assoc]\n  have (x : ‚Ñù) : ‚Üë(-2 * œÄ * x * t) * I + -œÄ * b * x ^ 2 + 2 * œÄ * c * x =\n    -œÄ * b * x ^ 2 + (-2 * œÄ * I * t + 2 * œÄ * c) * x + 0 := by push_cast; ring\n  simp_rw [this, integral_cexp_quadratic h, neg_mul, neg_neg]\n  congr 2\n  ¬∑ rw [‚Üê div_div, div_self <| ofReal_ne_zero.mpr pi_ne_zero, one_div, inv_cpow, ‚Üê one_div]\n    rw [Ne, arg_eq_pi_iff, not_and_or, not_lt]\n    exact Or.inl hb.le\n  ¬∑ field_simp [ofReal_ne_zero.mpr pi_ne_zero]\n    ring_nf\n    simp only [I_sq]\n    ring\n\n"}
{"name":"fourierIntegral_gaussian_pi","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nhb : LT.lt 0 b.re\n‚ä¢ Eq (Real.fourierIntegral fun x => Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) b) (HPow.hPow (‚Üëx) 2))) fun t => HMul.hMul (HDiv.hDiv 1 (HPow.hPow b (1 / 2))) (Complex.exp (HMul.hMul (HDiv.hDiv (Neg.neg ‚ÜëReal.pi) b) (HPow.hPow (‚Üët) 2)))","decl":"theorem _root_.fourierIntegral_gaussian_pi (hb : 0 < b.re) :\n    (ùìï fun (x : ‚Ñù) ‚Ü¶ cexp (-œÄ * b * x ^ 2)) =\n    fun t : ‚Ñù ‚Ü¶ 1 / b ^ (1 / 2 : ‚ÑÇ) * cexp (-œÄ / b * t ^ 2) := by\n  simpa only [mul_zero, zero_mul, add_zero] using fourierIntegral_gaussian_pi' hb 0\n\n"}
{"name":"GaussianFourier.integrable_cexp_neg_sum_mul_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"Œπ : Type u_2\ninst‚úù : Fintype Œπ\nb : Œπ ‚Üí Complex\nhb : ‚àÄ (i : Œπ), LT.lt 0 (b i).re\nc : Œπ ‚Üí Complex\n‚ä¢ MeasureTheory.Integrable (fun v => Complex.exp (HAdd.hAdd (Neg.neg (Finset.univ.sum fun i => HMul.hMul (b i) (HPow.hPow (‚Üë(v i)) 2))) (Finset.univ.sum fun i => HMul.hMul (c i) ‚Üë(v i)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_cexp_neg_sum_mul_add {Œπ : Type*} [Fintype Œπ] {b : Œπ ‚Üí ‚ÑÇ}\n    (hb : ‚àÄ i, 0 < (b i).re) (c : Œπ ‚Üí ‚ÑÇ) :\n    Integrable (fun (v : Œπ ‚Üí ‚Ñù) ‚Ü¶ cexp (- ‚àë i, b i * (v i : ‚ÑÇ) ^ 2 + ‚àë i, c i * v i)) := by\n  simp_rw [‚Üê Finset.sum_neg_distrib, ‚Üê Finset.sum_add_distrib, Complex.exp_sum, ‚Üê neg_mul]\n  apply Integrable.fintype_prod (f := fun i (v : ‚Ñù) ‚Ü¶ cexp (-b i * v^2 + c i * v)) (fun i ‚Ü¶ ?_)\n  convert integrable_cexp_quadratic (hb i) (c i) 0 using 3 with x\n  simp only [add_zero]\n\n"}
{"name":"GaussianFourier.integrable_cexp_neg_mul_sum_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nŒπ : Type u_2\ninst‚úù : Fintype Œπ\nhb : LT.lt 0 b.re\nc : Œπ ‚Üí Complex\n‚ä¢ MeasureTheory.Integrable (fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (Finset.univ.sum fun i => HPow.hPow (‚Üë(v i)) 2)) (Finset.univ.sum fun i => HMul.hMul (c i) ‚Üë(v i)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_cexp_neg_mul_sum_add {Œπ : Type*} [Fintype Œπ] (hb : 0 < b.re) (c : Œπ ‚Üí ‚ÑÇ) :\n    Integrable (fun (v : Œπ ‚Üí ‚Ñù) ‚Ü¶ cexp (- b * ‚àë i, (v i : ‚ÑÇ) ^ 2 + ‚àë i, c i * v i)) := by\n  simp_rw [neg_mul, Finset.mul_sum]\n  exact integrable_cexp_neg_sum_mul_add (fun _ ‚Ü¶ hb) c\n\n"}
{"name":"GaussianFourier.integrable_cexp_neg_mul_sq_norm_add_of_euclideanSpace","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nŒπ : Type u_2\ninst‚úù : Fintype Œπ\nhb : LT.lt 0 b.re\nc : Complex\nw : EuclideanSpace Real Œπ\n‚ä¢ MeasureTheory.Integrable (fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2)) (HMul.hMul c ‚Üë(Inner.inner w v)))) MeasureTheory.MeasureSpace.volume","decl":"theorem integrable_cexp_neg_mul_sq_norm_add_of_euclideanSpace\n    {Œπ : Type*} [Fintype Œπ] (hb : 0 < b.re) (c : ‚ÑÇ) (w : EuclideanSpace ‚Ñù Œπ) :\n    Integrable (fun (v : EuclideanSpace ‚Ñù Œπ) ‚Ü¶ cexp (- b * ‚Äñv‚Äñ^2 + c * ‚ü™w, v‚ü´)) := by\n  have := EuclideanSpace.volume_preserving_measurableEquiv Œπ\n  rw [‚Üê MeasurePreserving.integrable_comp_emb this.symm (MeasurableEquiv.measurableEmbedding _)]\n  simp only [neg_mul, Function.comp_def]\n  convert integrable_cexp_neg_mul_sum_add hb (fun i ‚Ü¶ c * w i) using 3 with v\n  simp only [EuclideanSpace.measurableEquiv, MeasurableEquiv.symm_mk, MeasurableEquiv.coe_mk,\n    EuclideanSpace.norm_eq, WithLp.equiv_symm_pi_apply, Real.norm_eq_abs, sq_abs, PiLp.inner_apply,\n    RCLike.inner_apply, conj_trivial, ofReal_sum, ofReal_mul, Finset.mul_sum, neg_mul,\n    Finset.sum_neg_distrib, mul_assoc, add_left_inj, neg_inj]\n  norm_cast\n  rw [sq_sqrt]\n  ¬∑ simp [Finset.mul_sum]\n  ¬∑ exact Finset.sum_nonneg (fun i _hi ‚Ü¶ by positivity)\n\n"}
{"name":"GaussianFourier.integrable_cexp_neg_mul_sq_norm_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nV : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nhb : LT.lt 0 b.re\nc : Complex\nw : V\n‚ä¢ MeasureTheory.Integrable (fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2)) (HMul.hMul c ‚Üë(Inner.inner w v)))) MeasureTheory.MeasureSpace.volume","decl":"/-- In a real inner product space, the complex exponential of minus the square of the norm plus\na scalar product is integrable. Useful when discussing the Fourier transform of a Gaussian. -/\ntheorem integrable_cexp_neg_mul_sq_norm_add (hb : 0 < b.re) (c : ‚ÑÇ) (w : V) :\n    Integrable (fun (v : V) ‚Ü¶ cexp (-b * ‚Äñv‚Äñ^2 + c * ‚ü™w, v‚ü´)) := by\n  let e := (stdOrthonormalBasis ‚Ñù V).repr.symm\n  rw [‚Üê e.measurePreserving.integrable_comp_emb e.toHomeomorph.measurableEmbedding]\n  convert integrable_cexp_neg_mul_sq_norm_add_of_euclideanSpace\n    hb c (e.symm w) with v\n  simp only [neg_mul, Function.comp_apply, LinearIsometryEquiv.norm_map,\n    LinearIsometryEquiv.symm_symm, conj_trivial, ofReal_sum,\n    ofReal_mul, LinearIsometryEquiv.inner_map_eq_flip]\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_sum_mul_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"Œπ : Type u_2\ninst‚úù : Fintype Œπ\nb : Œπ ‚Üí Complex\nhb : ‚àÄ (i : Œπ), LT.lt 0 (b i).re\nc : Œπ ‚Üí Complex\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Complex.exp (HAdd.hAdd (Neg.neg (Finset.univ.sum fun i => HMul.hMul (b i) (HPow.hPow (‚Üë(v i)) 2))) (Finset.univ.sum fun i => HMul.hMul (c i) ‚Üë(v i)))) (Finset.univ.prod fun i => HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) (b i)) (1 / 2)) (Complex.exp (HDiv.hDiv (HPow.hPow (c i) 2) (HMul.hMul 4 (b i)))))","decl":"theorem integral_cexp_neg_sum_mul_add {Œπ : Type*} [Fintype Œπ] {b : Œπ ‚Üí ‚ÑÇ}\n    (hb : ‚àÄ i, 0 < (b i).re) (c : Œπ ‚Üí ‚ÑÇ) :\n    ‚à´ v : Œπ ‚Üí ‚Ñù, cexp (- ‚àë i, b i * (v i : ‚ÑÇ) ^ 2 + ‚àë i, c i * v i)\n      = ‚àè i, (œÄ / b i) ^ (1 / 2 : ‚ÑÇ) * cexp (c i ^ 2 / (4 * b i)) := by\n  simp_rw [‚Üê Finset.sum_neg_distrib, ‚Üê Finset.sum_add_distrib, Complex.exp_sum, ‚Üê neg_mul]\n  rw [integral_fintype_prod_eq_prod (f := fun i (v : ‚Ñù) ‚Ü¶ cexp (-b i * v ^ 2 + c i * v))]\n  congr with i\n  have : (-b i).re < 0 := by simpa using hb i\n  convert integral_cexp_quadratic this (c i) 0 using 1 <;> simp [div_neg]\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_mul_sum_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nŒπ : Type u_2\ninst‚úù : Fintype Œπ\nhb : LT.lt 0 b.re\nc : Œπ ‚Üí Complex\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (Finset.univ.sum fun i => HPow.hPow (‚Üë(v i)) 2)) (Finset.univ.sum fun i => HMul.hMul (c i) ‚Üë(v i)))) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Fintype.card Œπ)) 2)) (Complex.exp (HDiv.hDiv (Finset.univ.sum fun i => HPow.hPow (c i) 2) (HMul.hMul 4 b))))","decl":"theorem integral_cexp_neg_mul_sum_add {Œπ : Type*} [Fintype Œπ] (hb : 0 < b.re) (c : Œπ ‚Üí ‚ÑÇ) :\n    ‚à´ v : Œπ ‚Üí ‚Ñù, cexp (- b * ‚àë i, (v i : ‚ÑÇ) ^ 2 + ‚àë i, c i * v i)\n      = (œÄ / b) ^ (Fintype.card Œπ / 2 : ‚ÑÇ) * cexp ((‚àë i, c i ^ 2) / (4 * b)) := by\n  simp_rw [neg_mul, Finset.mul_sum, integral_cexp_neg_sum_mul_add (fun _ ‚Ü¶ hb) c, one_div,\n    Finset.prod_mul_distrib, Finset.prod_const, ‚Üê cpow_nat_mul, ‚Üê Complex.exp_sum, Fintype.card,\n    Finset.sum_div, div_eq_mul_inv]\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_mul_sq_norm_add_of_euclideanSpace","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nŒπ : Type u_2\ninst‚úù : Fintype Œπ\nhb : LT.lt 0 b.re\nc : Complex\nw : EuclideanSpace Real Œπ\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2)) (HMul.hMul c ‚Üë(Inner.inner w v)))) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Fintype.card Œπ)) 2)) (Complex.exp (HDiv.hDiv (HMul.hMul (HPow.hPow c 2) (HPow.hPow (‚Üë(Norm.norm w)) 2)) (HMul.hMul 4 b))))","decl":"theorem integral_cexp_neg_mul_sq_norm_add_of_euclideanSpace\n    {Œπ : Type*} [Fintype Œπ] (hb : 0 < b.re) (c : ‚ÑÇ) (w : EuclideanSpace ‚Ñù Œπ) :\n    ‚à´ v : EuclideanSpace ‚Ñù Œπ, cexp (- b * ‚Äñv‚Äñ^2 + c * ‚ü™w, v‚ü´) =\n      (œÄ / b) ^ (Fintype.card Œπ / 2 : ‚ÑÇ) * cexp (c ^ 2 * ‚Äñw‚Äñ^2 / (4 * b)) := by\n  have := (EuclideanSpace.volume_preserving_measurableEquiv Œπ).symm\n  rw [‚Üê this.integral_comp (MeasurableEquiv.measurableEmbedding _)]\n  simp only [neg_mul, Function.comp_def]\n  convert integral_cexp_neg_mul_sum_add hb (fun i ‚Ü¶ c * w i) using 5 with _x y\n  ¬∑ simp only [EuclideanSpace.measurableEquiv, MeasurableEquiv.symm_mk, MeasurableEquiv.coe_mk,\n      EuclideanSpace.norm_eq, WithLp.equiv_symm_pi_apply, Real.norm_eq_abs, sq_abs, neg_mul,\n      neg_inj, mul_eq_mul_left_iff]\n    norm_cast\n    left\n    rw [sq_sqrt]\n    exact Finset.sum_nonneg (fun i _hi ‚Ü¶ by positivity)\n  ¬∑ simp [PiLp.inner_apply, EuclideanSpace.measurableEquiv, Finset.mul_sum, mul_assoc]\n  ¬∑ simp only [EuclideanSpace.norm_eq, Real.norm_eq_abs, sq_abs, mul_pow, ‚Üê Finset.mul_sum]\n    congr\n    norm_cast\n    rw [sq_sqrt]\n    exact Finset.sum_nonneg (fun i _hi ‚Ü¶ by positivity)\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_mul_sq_norm_add","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nV : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nhb : LT.lt 0 b.re\nc : Complex\nw : V\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2)) (HMul.hMul c ‚Üë(Inner.inner w v)))) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Module.finrank Real V)) 2)) (Complex.exp (HDiv.hDiv (HMul.hMul (HPow.hPow c 2) (HPow.hPow (‚Üë(Norm.norm w)) 2)) (HMul.hMul 4 b))))","decl":"theorem integral_cexp_neg_mul_sq_norm_add\n    (hb : 0 < b.re) (c : ‚ÑÇ) (w : V) :\n    ‚à´ v : V, cexp (- b * ‚Äñv‚Äñ^2 + c * ‚ü™w, v‚ü´) =\n      (œÄ / b) ^ (Module.finrank ‚Ñù V / 2 : ‚ÑÇ) * cexp (c ^ 2 * ‚Äñw‚Äñ^2 / (4 * b)) := by\n  let e := (stdOrthonormalBasis ‚Ñù V).repr.symm\n  rw [‚Üê e.measurePreserving.integral_comp e.toHomeomorph.measurableEmbedding]\n  convert integral_cexp_neg_mul_sq_norm_add_of_euclideanSpace\n    hb c (e.symm w) <;> simp [LinearIsometryEquiv.inner_map_eq_flip]\n\n"}
{"name":"GaussianFourier.integral_cexp_neg_mul_sq_norm","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nV : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nhb : LT.lt 0 b.re\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2))) (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Module.finrank Real V)) 2))","decl":"theorem integral_cexp_neg_mul_sq_norm (hb : 0 < b.re) :\n    ‚à´ v : V, cexp (- b * ‚Äñv‚Äñ^2) = (œÄ / b) ^ (Module.finrank ‚Ñù V / 2 : ‚ÑÇ) := by\n  simpa using integral_cexp_neg_mul_sq_norm_add hb 0 (0 : V)\n\n"}
{"name":"GaussianFourier.integral_rexp_neg_mul_sq_norm","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"V : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nb : Real\nhb : LT.lt 0 b\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => Real.exp (HMul.hMul (Neg.neg b) (HPow.hPow (Norm.norm v) 2))) (HPow.hPow (HDiv.hDiv Real.pi b) (HDiv.hDiv (‚Üë(Module.finrank Real V)) 2))","decl":"theorem integral_rexp_neg_mul_sq_norm {b : ‚Ñù} (hb : 0 < b) :\n    ‚à´ v : V, rexp (- b * ‚Äñv‚Äñ^2) = (œÄ / b) ^ (Module.finrank ‚Ñù V / 2 : ‚Ñù) := by\n  rw [‚Üê ofReal_inj]\n  convert integral_cexp_neg_mul_sq_norm (show 0 < (b : ‚ÑÇ).re from hb) (V := V)\n  ¬∑ change ofRealLI (‚à´ (v : V), rexp (-b * ‚Äñv‚Äñ ^ 2)) = ‚à´ (v : V), cexp (-‚Üëb * ‚Üë‚Äñv‚Äñ ^ 2)\n    rw [‚Üê ofRealLI.integral_comp_comm]\n    simp [ofRealLI]\n  ¬∑ rw [‚Üê ofReal_div, ofReal_cpow (by positivity)]\n    simp\n\n"}
{"name":"fourierIntegral_gaussian_innerProductSpace'","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nV : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nhb : LT.lt 0 b.re\nx w : V\n‚ä¢ Eq (Real.fourierIntegral (fun v => Complex.exp (HAdd.hAdd (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2)) (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üë(Inner.inner x v)))) w) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Module.finrank Real V)) 2)) (Complex.exp (HDiv.hDiv (HMul.hMul (Neg.neg (HPow.hPow (‚ÜëReal.pi) 2)) (HPow.hPow (‚Üë(Norm.norm (HSub.hSub x w))) 2)) b)))","decl":"theorem _root_.fourierIntegral_gaussian_innerProductSpace' (hb : 0 < b.re) (x w : V) :\n    ùìï (fun v ‚Ü¶ cexp (- b * ‚Äñv‚Äñ^2 + 2 * œÄ * Complex.I * ‚ü™x, v‚ü´)) w =\n      (œÄ / b) ^ (Module.finrank ‚Ñù V / 2 : ‚ÑÇ) * cexp (-œÄ ^ 2 * ‚Äñx - w‚Äñ ^ 2 / b) := by\n  simp only [neg_mul, fourierIntegral_eq', ofReal_neg, ofReal_mul, ofReal_ofNat,\n    smul_eq_mul, ‚Üê Complex.exp_add, real_inner_comm w]\n  convert integral_cexp_neg_mul_sq_norm_add hb (2 * œÄ * Complex.I) (x - w) using 3 with v\n  ¬∑ congr 1\n    simp [inner_sub_left]\n    ring\n  ¬∑ have : b ‚â† 0 := by contrapose! hb; rw [hb, zero_re]\n    field_simp [mul_pow]\n    ring\n\n"}
{"name":"fourierIntegral_gaussian_innerProductSpace","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform","initialProofState":"b : Complex\nV : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : FiniteDimensional Real V\ninst‚úù¬π : MeasurableSpace V\ninst‚úù : BorelSpace V\nhb : LT.lt 0 b.re\nw : V\n‚ä¢ Eq (Real.fourierIntegral (fun v => Complex.exp (HMul.hMul (Neg.neg b) (HPow.hPow (‚Üë(Norm.norm v)) 2))) w) (HMul.hMul (HPow.hPow (HDiv.hDiv (‚ÜëReal.pi) b) (HDiv.hDiv (‚Üë(Module.finrank Real V)) 2)) (Complex.exp (HDiv.hDiv (HMul.hMul (Neg.neg (HPow.hPow (‚ÜëReal.pi) 2)) (HPow.hPow (‚Üë(Norm.norm w)) 2)) b)))","decl":"theorem _root_.fourierIntegral_gaussian_innerProductSpace (hb : 0 < b.re) (w : V) :\n    ùìï (fun v ‚Ü¶ cexp (- b * ‚Äñv‚Äñ^2)) w =\n      (œÄ / b) ^ (Module.finrank ‚Ñù V / 2 : ‚ÑÇ) * cexp (-œÄ ^ 2 * ‚Äñw‚Äñ^2 / b) := by\n  simpa using fourierIntegral_gaussian_innerProductSpace' hb 0 w\n\n"}
