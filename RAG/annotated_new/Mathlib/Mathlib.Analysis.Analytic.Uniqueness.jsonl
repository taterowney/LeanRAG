{"name":"Asymptotics.IsBigO.continuousMultilinearMap_apply_eq_zero","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\np : ContinuousMultilinearMap ùïú (fun i => E) F\nh : Asymptotics.IsBigO (nhds 0) (fun y => p fun x => y) fun y => HPow.hPow (Norm.norm y) (HAdd.hAdd n 1)\ny : E\n‚ä¢ Eq (p fun x => y) 0","decl":"theorem Asymptotics.IsBigO.continuousMultilinearMap_apply_eq_zero {n : ‚Ñï} {p : E[√ón]‚ÜíL[ùïú] F}\n    (h : (fun y => p fun _ => y) =O[ùìù 0] fun y => ‚Äñy‚Äñ ^ (n + 1)) (y : E) : (p fun _ => y) = 0 := by\n  obtain ‚ü®c, c_pos, hc‚ü© := h.exists_pos\n  obtain ‚ü®t, ht, t_open, z_mem‚ü© := eventually_nhds_iff.mp (isBigOWith_iff.mp hc)\n  obtain ‚ü®Œ¥, Œ¥_pos, Œ¥Œµ‚ü© := (Metric.isOpen_iff.mp t_open) 0 z_mem\n  clear h hc z_mem\n  cases' n with n\n  ¬∑ exact norm_eq_zero.mp (by\n      -- Porting note: the symmetric difference of the `simpa only` sets:\n      -- added `zero_add, pow_one`\n      -- removed `zero_pow, Ne.def, Nat.one_ne_zero, not_false_iff`\n      simpa only [fin0_apply_norm, norm_eq_zero, norm_zero, zero_add, pow_one,\n        mul_zero, norm_le_zero_iff] using ht 0 (Œ¥Œµ (Metric.mem_ball_self Œ¥_pos)))\n  ¬∑ refine Or.elim (Classical.em (y = 0))\n      (fun hy => by simpa only [hy] using p.map_zero) fun hy => ?_\n    replace hy := norm_pos_iff.mpr hy\n    refine norm_eq_zero.mp (le_antisymm (le_of_forall_pos_le_add fun Œµ Œµ_pos => ?_) (norm_nonneg _))\n    have h‚ÇÄ := _root_.mul_pos c_pos (pow_pos hy (n.succ + 1))\n    obtain ‚ü®k, k_pos, k_norm‚ü© := NormedField.exists_norm_lt ùïú\n      (lt_min (mul_pos Œ¥_pos (inv_pos.mpr hy)) (mul_pos Œµ_pos (inv_pos.mpr h‚ÇÄ)))\n    have h‚ÇÅ : ‚Äñk ‚Ä¢ y‚Äñ < Œ¥ := by\n      rw [norm_smul]\n      exact inv_mul_cancel_right‚ÇÄ hy.ne.symm Œ¥ ‚ñ∏\n        mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_left _ _)) hy\n    have h‚ÇÇ :=\n      calc\n        ‚Äñp fun _ => k ‚Ä¢ y‚Äñ ‚â§ c * ‚Äñk ‚Ä¢ y‚Äñ ^ (n.succ + 1) := by\n          -- Porting note: now Lean wants `_root_.`\n          simpa only [norm_pow, _root_.norm_norm] using ht (k ‚Ä¢ y) (Œ¥Œµ (mem_ball_zero_iff.mpr h‚ÇÅ))\n          --simpa only [norm_pow, norm_norm] using ht (k ‚Ä¢ y) (Œ¥Œµ (mem_ball_zero_iff.mpr h‚ÇÅ))\n        _ = ‚Äñk‚Äñ ^ n.succ * (‚Äñk‚Äñ * (c * ‚Äñy‚Äñ ^ (n.succ + 1))) := by\n          -- Porting note: added `Nat.succ_eq_add_one` since otherwise `ring` does not conclude.\n          simp only [norm_smul, mul_pow, Nat.succ_eq_add_one]\n          -- Porting note: removed `rw [pow_succ]`, since it now becomes superfluous.\n          ring\n    have h‚ÇÉ : ‚Äñk‚Äñ * (c * ‚Äñy‚Äñ ^ (n.succ + 1)) < Œµ :=\n      inv_mul_cancel_right‚ÇÄ h‚ÇÄ.ne.symm Œµ ‚ñ∏\n        mul_lt_mul_of_pos_right (lt_of_lt_of_le k_norm (min_le_right _ _)) h‚ÇÄ\n    calc\n      ‚Äñp fun _ => y‚Äñ = ‚Äñk‚Åª¬π ^ n.succ‚Äñ * ‚Äñp fun _ => k ‚Ä¢ y‚Äñ := by\n        simpa only [inv_smul_smul‚ÇÄ (norm_pos_iff.mp k_pos), norm_smul, Finset.prod_const,\n          Finset.card_fin] using\n          congr_arg norm (p.map_smul_univ (fun _ : Fin n.succ => k‚Åª¬π) fun _ : Fin n.succ => k ‚Ä¢ y)\n      _ ‚â§ ‚Äñk‚Åª¬π ^ n.succ‚Äñ * (‚Äñk‚Äñ ^ n.succ * (‚Äñk‚Äñ * (c * ‚Äñy‚Äñ ^ (n.succ + 1)))) := by gcongr\n      _ = ‚Äñ(k‚Åª¬π * k) ^ n.succ‚Äñ * (‚Äñk‚Äñ * (c * ‚Äñy‚Äñ ^ (n.succ + 1))) := by\n        rw [‚Üê mul_assoc]\n        simp [norm_mul, mul_pow]\n      _ ‚â§ 0 + Œµ := by\n        rw [inv_mul_cancel‚ÇÄ (norm_pos_iff.mp k_pos)]\n        simpa using h‚ÇÉ.le\n\n"}
{"name":"HasFPowerSeriesAt.apply_eq_zero","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nx : E\nh : HasFPowerSeriesAt 0 p x\nn : Nat\ny : E\n‚ä¢ Eq ((p n) fun x => y) 0","decl":"/-- If a formal multilinear series `p` represents the zero function at `x : E`, then the\nterms `p n (fun i ‚Ü¶ y)` appearing in the sum are zero for any `n : ‚Ñï`, `y : E`. -/\ntheorem HasFPowerSeriesAt.apply_eq_zero {p : FormalMultilinearSeries ùïú E F} {x : E}\n    (h : HasFPowerSeriesAt 0 p x) (n : ‚Ñï) : ‚àÄ y : E, (p n fun _ => y) = 0 := by\n  refine Nat.strong_induction_on n fun k hk => ?_\n  have psum_eq : p.partialSum (k + 1) = fun y => p k fun _ => y := by\n    funext z\n    refine Finset.sum_eq_single _ (fun b hb hnb => ?_) fun hn => ?_\n    ¬∑ have := Finset.mem_range_succ_iff.mp hb\n      simp only [hk b (this.lt_of_ne hnb), Pi.zero_apply]\n    ¬∑ exact False.elim (hn (Finset.mem_range.mpr (lt_add_one k)))\n  replace h := h.isBigO_sub_partialSum_pow k.succ\n  simp only [psum_eq, zero_sub, Pi.zero_apply, Asymptotics.isBigO_neg_left] at h\n  exact h.continuousMultilinearMap_apply_eq_zero\n\n"}
{"name":"HasFPowerSeriesAt.eq_zero","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\np : FormalMultilinearSeries ùïú ùïú E\nx : ùïú\nh : HasFPowerSeriesAt 0 p x\n‚ä¢ Eq p 0","decl":"/-- A one-dimensional formal multilinear series representing the zero function is zero. -/\ntheorem HasFPowerSeriesAt.eq_zero {p : FormalMultilinearSeries ùïú ùïú E} {x : ùïú}\n    (h : HasFPowerSeriesAt 0 p x) : p = 0 := by\n  ext n x\n  rw [‚Üê mkPiRing_apply_one_eq_self (p n)]\n  simp [h.apply_eq_zero n 1]\n\n"}
{"name":"HasFPowerSeriesAt.eq_formalMultilinearSeries","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\np‚ÇÅ p‚ÇÇ : FormalMultilinearSeries ùïú ùïú E\nf : ùïú ‚Üí E\nx : ùïú\nh‚ÇÅ : HasFPowerSeriesAt f p‚ÇÅ x\nh‚ÇÇ : HasFPowerSeriesAt f p‚ÇÇ x\n‚ä¢ Eq p‚ÇÅ p‚ÇÇ","decl":"/-- One-dimensional formal multilinear series representing the same function are equal. -/\ntheorem HasFPowerSeriesAt.eq_formalMultilinearSeries {p‚ÇÅ p‚ÇÇ : FormalMultilinearSeries ùïú ùïú E}\n    {f : ùïú ‚Üí E} {x : ùïú} (h‚ÇÅ : HasFPowerSeriesAt f p‚ÇÅ x) (h‚ÇÇ : HasFPowerSeriesAt f p‚ÇÇ x) : p‚ÇÅ = p‚ÇÇ :=\n  sub_eq_zero.mp (HasFPowerSeriesAt.eq_zero (x := x) (by simpa only [sub_self] using h‚ÇÅ.sub h‚ÇÇ))\n\n"}
{"name":"HasFPowerSeriesAt.eq_formalMultilinearSeries_of_eventually","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\np q : FormalMultilinearSeries ùïú ùïú E\nf g : ùïú ‚Üí E\nx : ùïú\nhp : HasFPowerSeriesAt f p x\nhq : HasFPowerSeriesAt g q x\nheq : Filter.Eventually (fun z => Eq (f z) (g z)) (nhds x)\n‚ä¢ Eq p q","decl":"theorem HasFPowerSeriesAt.eq_formalMultilinearSeries_of_eventually\n    {p q : FormalMultilinearSeries ùïú ùïú E} {f g : ùïú ‚Üí E} {x : ùïú} (hp : HasFPowerSeriesAt f p x)\n    (hq : HasFPowerSeriesAt g q x) (heq : ‚àÄ·∂† z in ùìù x, f z = g z) : p = q :=\n  (hp.congr heq).eq_formalMultilinearSeries hq\n\n"}
{"name":"HasFPowerSeriesAt.eq_zero_of_eventually","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\np : FormalMultilinearSeries ùïú ùïú E\nf : ùïú ‚Üí E\nx : ùïú\nhp : HasFPowerSeriesAt f p x\nhf : (nhds x).EventuallyEq f 0\n‚ä¢ Eq p 0","decl":"/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem HasFPowerSeriesAt.eq_zero_of_eventually {p : FormalMultilinearSeries ùïú ùïú E} {f : ùïú ‚Üí E}\n    {x : ùïú} (hp : HasFPowerSeriesAt f p x) (hf : f =·∂†[ùìù x] 0) : p = 0 :=\n  (hp.congr hf).eq_zero\n\n"}
{"name":"HasFPowerSeriesOnBall.exchange_radius","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\np‚ÇÅ p‚ÇÇ : FormalMultilinearSeries ùïú ùïú E\nf : ùïú ‚Üí E\nr‚ÇÅ r‚ÇÇ : ENNReal\nx : ùïú\nh‚ÇÅ : HasFPowerSeriesOnBall f p‚ÇÅ x r‚ÇÅ\nh‚ÇÇ : HasFPowerSeriesOnBall f p‚ÇÇ x r‚ÇÇ\n‚ä¢ HasFPowerSeriesOnBall f p‚ÇÅ x r‚ÇÇ","decl":"/-- If a function `f : ùïú ‚Üí E` has two power series representations at `x`, then the given radii in\nwhich convergence is guaranteed may be interchanged. This can be useful when the formal multilinear\nseries in one representation has a particularly nice form, but the other has a larger radius. -/\ntheorem HasFPowerSeriesOnBall.exchange_radius {p‚ÇÅ p‚ÇÇ : FormalMultilinearSeries ùïú ùïú E} {f : ùïú ‚Üí E}\n    {r‚ÇÅ r‚ÇÇ : ‚Ñù‚â•0‚àû} {x : ùïú} (h‚ÇÅ : HasFPowerSeriesOnBall f p‚ÇÅ x r‚ÇÅ)\n    (h‚ÇÇ : HasFPowerSeriesOnBall f p‚ÇÇ x r‚ÇÇ) : HasFPowerSeriesOnBall f p‚ÇÅ x r‚ÇÇ :=\n  h‚ÇÇ.hasFPowerSeriesAt.eq_formalMultilinearSeries h‚ÇÅ.hasFPowerSeriesAt ‚ñ∏ h‚ÇÇ\n\n"}
{"name":"HasFPowerSeriesOnBall.r_eq_top_of_exists","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nf : ùïú ‚Üí E\nr : ENNReal\nx : ùïú\np : FormalMultilinearSeries ùïú ùïú E\nh : HasFPowerSeriesOnBall f p x r\nh' : ‚àÄ (r' : NNReal), LT.lt 0 r' ‚Üí Exists fun p' => HasFPowerSeriesOnBall f p' x ‚Üër'\n‚ä¢ HasFPowerSeriesOnBall f p x Top.top","decl":"/-- If a function `f : ùïú ‚Üí E` has power series representation `p` on a ball of some radius and for\neach positive radius it has some power series representation, then `p` converges to `f` on the whole\n`ùïú`. -/\ntheorem HasFPowerSeriesOnBall.r_eq_top_of_exists {f : ùïú ‚Üí E} {r : ‚Ñù‚â•0‚àû} {x : ùïú}\n    {p : FormalMultilinearSeries ùïú ùïú E} (h : HasFPowerSeriesOnBall f p x r)\n    (h' : ‚àÄ (r' : ‚Ñù‚â•0) (_ : 0 < r'), ‚àÉ p' : FormalMultilinearSeries ùïú ùïú E,\n      HasFPowerSeriesOnBall f p' x r') :\n    HasFPowerSeriesOnBall f p x ‚àû :=\n  { r_le := ENNReal.le_of_forall_pos_nnreal_lt fun r hr _ =>\n      let ‚ü®_, hp'‚ü© := h' r hr\n      (h.exchange_radius hp').r_le\n    r_pos := ENNReal.coe_lt_top\n    hasSum := fun {y} _ =>\n      let ‚ü®r', hr'‚ü© := exists_gt ‚Äñy‚Äñ‚Çä\n      let ‚ü®_, hp'‚ü© := h' r' hr'.ne_bot.bot_lt\n      (h.exchange_radius hp').hasSum <| mem_emetric_ball_zero_iff.mpr (ENNReal.coe_lt_coe.2 hr') }\n\n"}
{"name":"AnalyticOnNhd.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nU : Set E\nhf : AnalyticOnNhd ùïú f U\nhU : IsPreconnected U\nz‚ÇÄ : E\nh‚ÇÄ : Membership.mem U z‚ÇÄ\nhfz‚ÇÄ : (nhds z‚ÇÄ).EventuallyEq f 0\n‚ä¢ Set.EqOn f 0 U","decl":"/-- If an analytic function vanishes around a point, then it is uniformly zero along\na connected set. Superseded by `eqOn_zero_of_preconnected_of_locally_zero` which does not assume\ncompleteness of the target space. -/\ntheorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E ‚Üí F} {U : Set E}\n    (hf : AnalyticOnNhd ùïú f U) (hU : IsPreconnected U)\n    {z‚ÇÄ : E} (h‚ÇÄ : z‚ÇÄ ‚àà U) (hfz‚ÇÄ : f =·∂†[ùìù z‚ÇÄ] 0) :\n    EqOn f 0 U := by\n  /- Let `u` be the set of points around which `f` vanishes. It is clearly open. We have to show\n    that its limit points in `U` still belong to it, from which the inclusion `U ‚äÜ u` will follow\n    by connectedness. -/\n  let u := {x | f =·∂†[ùìù x] 0}\n  suffices main : closure u ‚à© U ‚äÜ u by\n    have Uu : U ‚äÜ u :=\n      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ‚ü®z‚ÇÄ, h‚ÇÄ, hfz‚ÇÄ‚ü© main\n    intro z hz\n    simpa using mem_of_mem_nhds (Uu hz)\n  /- Take a limit point `x`, then a ball `B (x, r)` on which it has a power series expansion, and\n    then `y ‚àà B (x, r/2) ‚à© u`. Then `f` has a power series expansion on `B (y, r/2)` as it is\n    contained in `B (x, r)`. All the coefficients in this series expansion vanish, as `f` is zero\n    on a neighborhood of `y`. Therefore, `f` is zero on `B (y, r/2)`. As this ball contains `x`,\n    it follows that `f` vanishes on a neighborhood of `x`, proving the claim. -/\n  rintro x ‚ü®xu, xU‚ü©\n  rcases hf x xU with ‚ü®p, r, hp‚ü©\n  obtain ‚ü®y, yu, hxy‚ü© : ‚àÉ y ‚àà u, edist x y < r / 2 :=\n    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')\n  let q := p.changeOrigin (y - x)\n  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by\n    have A : (‚Äñy - x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r / 2 := by rwa [edist_comm, edist_eq_enorm_sub] at hxy\n    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)\n    simp only [add_sub_cancel] at this\n    apply this.mono (ENNReal.half_pos hp.r_pos.ne')\n    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top\n    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)\n    exact ENNReal.add_halves _\n  have M : EMetric.ball y (r / 2) ‚àà ùìù x := EMetric.isOpen_ball.mem_nhds hxy\n  filter_upwards [M] with z hz\n  have A : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz\n  have B : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) 0 := by\n    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu\n    convert hasSum_zero (Œ± := F) using 2\n    ext n\n    exact this.apply_eq_zero n _\n  exact HasSum.unique A B\n\n"}
{"name":"AnalyticOnNhd.eqOn_zero_of_preconnected_of_eventuallyEq_zero","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nf : E ‚Üí F\nU : Set E\nhf : AnalyticOnNhd ùïú f U\nhU : IsPreconnected U\nz‚ÇÄ : E\nh‚ÇÄ : Membership.mem U z‚ÇÄ\nhfz‚ÇÄ : (nhds z‚ÇÄ).EventuallyEq f 0\n‚ä¢ Set.EqOn f 0 U","decl":"/-- The *identity principle* for analytic functions: If an analytic function vanishes in a whole\nneighborhood of a point `z‚ÇÄ`, then it is uniformly zero along a connected set. For a one-dimensional\nversion assuming only that the function vanishes at some points arbitrarily close to `z‚ÇÄ`, see\n`eqOn_zero_of_preconnected_of_frequently_eq_zero`. -/\ntheorem eqOn_zero_of_preconnected_of_eventuallyEq_zero {f : E ‚Üí F} {U : Set E}\n    (hf : AnalyticOnNhd ùïú f U) (hU : IsPreconnected U)\n    {z‚ÇÄ : E} (h‚ÇÄ : z‚ÇÄ ‚àà U) (hfz‚ÇÄ : f =·∂†[ùìù z‚ÇÄ] 0) :\n    EqOn f 0 U := by\n  let F' := UniformSpace.Completion F\n  set e : F ‚ÜíL[ùïú] F' := UniformSpace.Completion.toComplL\n  have : AnalyticOnNhd ùïú (e ‚àò f) U := fun x hx => (e.analyticAt _).comp (hf x hx)\n  have A : EqOn (e ‚àò f) 0 U := by\n    apply eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux this hU h‚ÇÄ\n    filter_upwards [hfz‚ÇÄ] with x hx\n    simp only [hx, Function.comp_apply, Pi.zero_apply, map_zero]\n  intro z hz\n  have : e (f z) = e 0 := by simpa only using A hz\n  exact UniformSpace.Completion.coe_injective F this\n\n"}
{"name":"AnalyticOnNhd.eqOn_of_preconnected_of_eventuallyEq","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nf g : E ‚Üí F\nU : Set E\nhf : AnalyticOnNhd ùïú f U\nhg : AnalyticOnNhd ùïú g U\nhU : IsPreconnected U\nz‚ÇÄ : E\nh‚ÇÄ : Membership.mem U z‚ÇÄ\nhfg : (nhds z‚ÇÄ).EventuallyEq f g\n‚ä¢ Set.EqOn f g U","decl":"/-- The *identity principle* for analytic functions: If two analytic functions coincide in a whole\nneighborhood of a point `z‚ÇÄ`, then they coincide globally along a connected set.\nFor a one-dimensional version assuming only that the functions coincide at some points\narbitrarily close to `z‚ÇÄ`, see `eqOn_of_preconnected_of_frequently_eq`. -/\ntheorem eqOn_of_preconnected_of_eventuallyEq {f g : E ‚Üí F} {U : Set E} (hf : AnalyticOnNhd ùïú f U)\n    (hg : AnalyticOnNhd ùïú g U) (hU : IsPreconnected U) {z‚ÇÄ : E} (h‚ÇÄ : z‚ÇÄ ‚àà U) (hfg : f =·∂†[ùìù z‚ÇÄ] g) :\n    EqOn f g U := by\n  have hfg' : f - g =·∂†[ùìù z‚ÇÄ] 0 := hfg.mono fun z h => by simp [h]\n  simpa [sub_eq_zero] using fun z hz =>\n    (hf.sub hg).eqOn_zero_of_preconnected_of_eventuallyEq_zero hU h‚ÇÄ hfg' hz\n\n"}
{"name":"AnalyticOnNhd.eq_of_eventuallyEq","module":"Mathlib.Analysis.Analytic.Uniqueness","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\nf g : E ‚Üí F\ninst‚úù : PreconnectedSpace E\nhf : AnalyticOnNhd ùïú f Set.univ\nhg : AnalyticOnNhd ùïú g Set.univ\nz‚ÇÄ : E\nhfg : (nhds z‚ÇÄ).EventuallyEq f g\n‚ä¢ Eq f g","decl":"/-- The *identity principle* for analytic functions: If two analytic functions on a normed space\ncoincide in a neighborhood of a point `z‚ÇÄ`, then they coincide everywhere.\nFor a one-dimensional version assuming only that the functions coincide at some points\narbitrarily close to `z‚ÇÄ`, see `eq_of_frequently_eq`. -/\ntheorem eq_of_eventuallyEq {f g : E ‚Üí F} [PreconnectedSpace E] (hf : AnalyticOnNhd ùïú f univ)\n    (hg : AnalyticOnNhd ùïú g univ) {z‚ÇÄ : E} (hfg : f =·∂†[ùìù z‚ÇÄ] g) : f = g :=\n  funext fun x =>\n    eqOn_of_preconnected_of_eventuallyEq hf hg isPreconnected_univ (mem_univ z‚ÇÄ) hfg (mem_univ x)\n\n"}
