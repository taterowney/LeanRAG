{"name":"Complex.cderiv_eq_deriv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU : Set Complex\nz : Complex\nr : Real\nf : Complex → E\ninst✝ : CompleteSpace E\nhU : IsOpen U\nhf : DifferentiableOn Complex f U\nhr : LT.lt 0 r\nhzr : HasSubset.Subset (Metric.closedBall z r) U\n⊢ Eq (Complex.cderiv r f z) (deriv f z)","decl":"theorem cderiv_eq_deriv [CompleteSpace E] (hU : IsOpen U) (hf : DifferentiableOn ℂ f U) (hr : 0 < r)\n    (hzr : closedBall z r ⊆ U) : cderiv r f z = deriv f z :=\n  two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable hU hzr hf (mem_ball_self hr)\n\n"}
{"name":"Complex.norm_cderiv_le","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nz : Complex\nM r : Real\nf : Complex → E\nhr : LT.lt 0 r\nhf : ∀ (w : Complex), Membership.mem (Metric.sphere z r) w → LE.le (Norm.norm (f w)) M\n⊢ LE.le (Norm.norm (Complex.cderiv r f z)) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_le (hr : 0 < r) (hf : ∀ w ∈ sphere z r, ‖f w‖ ≤ M) :\n    ‖cderiv r f z‖ ≤ M / r := by\n  have hM : 0 ≤ M := by\n    obtain ⟨w, hw⟩ : (sphere z r).Nonempty := NormedSpace.sphere_nonempty.mpr hr.le\n    exact (norm_nonneg _).trans (hf w hw)\n  have h1 : ∀ w ∈ sphere z r, ‖((w - z) ^ 2)⁻¹ • f w‖ ≤ M / r ^ 2 := by\n    intro w hw\n    simp only [mem_sphere_iff_norm, norm_eq_abs] at hw\n    simp only [norm_smul, inv_mul_eq_div, hw, norm_eq_abs, map_inv₀, Complex.abs_pow]\n    exact div_le_div₀ hM (hf w hw) (sq_pos_of_pos hr) le_rfl\n  have h2 := circleIntegral.norm_integral_le_of_norm_le_const hr.le h1\n  simp only [cderiv, norm_smul]\n  refine (mul_le_mul le_rfl h2 (norm_nonneg _) (norm_nonneg _)).trans (le_of_eq ?_)\n  field_simp [_root_.abs_of_nonneg Real.pi_pos.le]\n  ring\n\n"}
{"name":"Complex.cderiv_sub","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nz : Complex\nr : Real\nf g : Complex → E\nhr : LT.lt 0 r\nhf : ContinuousOn f (Metric.sphere z r)\nhg : ContinuousOn g (Metric.sphere z r)\n⊢ Eq (Complex.cderiv r (HSub.hSub f g) z) (HSub.hSub (Complex.cderiv r f z) (Complex.cderiv r g z))","decl":"theorem cderiv_sub (hr : 0 < r) (hf : ContinuousOn f (sphere z r))\n    (hg : ContinuousOn g (sphere z r)) : cderiv r (f - g) z = cderiv r f z - cderiv r g z := by\n  have h1 : ContinuousOn (fun w : ℂ => ((w - z) ^ 2)⁻¹) (sphere z r) := by\n    refine ((continuous_id'.sub continuous_const).pow 2).continuousOn.inv₀ fun w hw h => hr.ne ?_\n    rwa [mem_sphere_iff_norm, sq_eq_zero_iff.mp h, norm_zero] at hw\n  simp_rw [cderiv, ← smul_sub]\n  congr 1\n  simpa only [Pi.sub_apply, smul_sub] using\n    circleIntegral.integral_sub ((h1.smul hf).circleIntegrable hr.le)\n      ((h1.smul hg).circleIntegrable hr.le)\n\n"}
{"name":"Complex.norm_cderiv_lt","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nz : Complex\nM r : Real\nf : Complex → E\nhr : LT.lt 0 r\nhfM : ∀ (w : Complex), Membership.mem (Metric.sphere z r) w → LT.lt (Norm.norm (f w)) M\nhf : ContinuousOn f (Metric.sphere z r)\n⊢ LT.lt (Norm.norm (Complex.cderiv r f z)) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_lt (hr : 0 < r) (hfM : ∀ w ∈ sphere z r, ‖f w‖ < M)\n    (hf : ContinuousOn f (sphere z r)) : ‖cderiv r f z‖ < M / r := by\n  obtain ⟨L, hL1, hL2⟩ : ∃ L < M, ∀ w ∈ sphere z r, ‖f w‖ ≤ L := by\n    have e1 : (sphere z r).Nonempty := NormedSpace.sphere_nonempty.mpr hr.le\n    have e2 : ContinuousOn (fun w => ‖f w‖) (sphere z r) := continuous_norm.comp_continuousOn hf\n    obtain ⟨x, hx, hx'⟩ := (isCompact_sphere z r).exists_isMaxOn e1 e2\n    exact ⟨‖f x‖, hfM x hx, hx'⟩\n  exact (norm_cderiv_le hr hL2).trans_lt ((div_lt_div_iff_of_pos_right hr).mpr hL1)\n\n"}
{"name":"Complex.norm_cderiv_sub_lt","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nz : Complex\nM r : Real\nf g : Complex → E\nhr : LT.lt 0 r\nhfg : ∀ (w : Complex), Membership.mem (Metric.sphere z r) w → LT.lt (Norm.norm (HSub.hSub (f w) (g w))) M\nhf : ContinuousOn f (Metric.sphere z r)\nhg : ContinuousOn g (Metric.sphere z r)\n⊢ LT.lt (Norm.norm (HSub.hSub (Complex.cderiv r f z) (Complex.cderiv r g z))) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_sub_lt (hr : 0 < r) (hfg : ∀ w ∈ sphere z r, ‖f w - g w‖ < M)\n    (hf : ContinuousOn f (sphere z r)) (hg : ContinuousOn g (sphere z r)) :\n    ‖cderiv r f z - cderiv r g z‖ < M / r :=\n  cderiv_sub hr hf hg ▸ norm_cderiv_lt hr hfg (hf.sub hg)\n\n"}
{"name":"TendstoUniformlyOn.cderiv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nK : Set Complex\nδ : Real\nφ : Filter ι\nF : ι → Complex → E\nf : Complex → E\nhF : TendstoUniformlyOn F f φ (Metric.cthickening δ K)\nhδ : LT.lt 0 δ\nhFn : Filter.Eventually (fun n => ContinuousOn (F n) (Metric.cthickening δ K)) φ\n⊢ TendstoUniformlyOn (Function.comp (Complex.cderiv δ) F) (Complex.cderiv δ f) φ K","decl":"theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f φ (cthickening δ K))\n    (hδ : 0 < δ) (hFn : ∀ᶠ n in φ, ContinuousOn (F n) (cthickening δ K)) :\n    TendstoUniformlyOn (cderiv δ ∘ F) (cderiv δ f) φ K := by\n  rcases φ.eq_or_neBot with rfl | hne\n  · simp only [TendstoUniformlyOn, eventually_bot, imp_true_iff]\n  have e1 : ContinuousOn f (cthickening δ K) := TendstoUniformlyOn.continuousOn hF hFn\n  rw [tendstoUniformlyOn_iff] at hF ⊢\n  rintro ε hε\n  filter_upwards [hF (ε * δ) (mul_pos hε hδ), hFn] with n h h' z hz\n  simp_rw [dist_eq_norm] at h ⊢\n  have e2 : ∀ w ∈ sphere z δ, ‖f w - F n w‖ < ε * δ := fun w hw1 =>\n    h w (closedBall_subset_cthickening hz δ (sphere_subset_closedBall hw1))\n  have e3 := sphere_subset_closedBall.trans (closedBall_subset_cthickening hz δ)\n  have hf : ContinuousOn f (sphere z δ) :=\n    e1.mono (sphere_subset_closedBall.trans (closedBall_subset_cthickening hz δ))\n  simpa only [mul_div_cancel_right₀ _ hδ.ne.symm] using norm_cderiv_sub_lt hδ e2 hf (h'.mono e3)\n\n"}
{"name":"Complex.tendstoUniformlyOn_deriv_of_cthickening_subset","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU K : Set Complex\nφ : Filter ι\nF : ι → Complex → E\nf : Complex → E\ninst✝ : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f φ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) φ\nδ : Real\nhδ : LT.lt 0 δ\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset (Metric.cthickening δ K) U\n⊢ TendstoUniformlyOn (Function.comp deriv F) (Complex.cderiv δ f) φ K","decl":"theorem tendstoUniformlyOn_deriv_of_cthickening_subset (hf : TendstoLocallyUniformlyOn F f φ U)\n    (hF : ∀ᶠ n in φ, DifferentiableOn ℂ (F n) U) {δ : ℝ} (hδ : 0 < δ) (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : cthickening δ K ⊆ U) :\n    TendstoUniformlyOn (deriv ∘ F) (cderiv δ f) φ K := by\n  have h1 : ∀ᶠ n in φ, ContinuousOn (F n) (cthickening δ K) := by\n    filter_upwards [hF] with n h using h.continuousOn.mono hKU\n  have h2 : IsCompact (cthickening δ K) := hK.cthickening\n  have h3 : TendstoUniformlyOn F f φ (cthickening δ K) :=\n    (tendstoLocallyUniformlyOn_iff_forall_isCompact hU).mp hf (cthickening δ K) hKU h2\n  apply (h3.cderiv hδ h1).congr\n  filter_upwards [hF] with n h z hz\n  exact cderiv_eq_deriv hU h hδ ((closedBall_subset_cthickening hz δ).trans hKU)\n\n"}
{"name":"Complex.exists_cthickening_tendstoUniformlyOn","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU K : Set Complex\nφ : Filter ι\nF : ι → Complex → E\nf : Complex → E\ninst✝ : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f φ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) φ\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n⊢ Exists fun δ => And (GT.gt δ 0) (And (HasSubset.Subset (Metric.cthickening δ K) U) (TendstoUniformlyOn (Function.comp deriv F) (Complex.cderiv δ f) φ K))","decl":"theorem exists_cthickening_tendstoUniformlyOn (hf : TendstoLocallyUniformlyOn F f φ U)\n    (hF : ∀ᶠ n in φ, DifferentiableOn ℂ (F n) U) (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) :\n    ∃ δ > 0, cthickening δ K ⊆ U ∧ TendstoUniformlyOn (deriv ∘ F) (cderiv δ f) φ K := by\n  obtain ⟨δ, hδ, hKδ⟩ := hK.exists_cthickening_subset_open hU hKU\n  exact ⟨δ, hδ, hKδ, tendstoUniformlyOn_deriv_of_cthickening_subset hf hF hδ hK hU hKδ⟩\n\n"}
{"name":"TendstoLocallyUniformlyOn.differentiableOn","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nU : Set Complex\nφ : Filter ι\nF : ι → Complex → E\nf : Complex → E\ninst✝¹ : CompleteSpace E\ninst✝ : φ.NeBot\nhf : TendstoLocallyUniformlyOn F f φ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) φ\nhU : IsOpen U\n⊢ DifferentiableOn Complex f U","decl":"/-- A locally uniform limit of holomorphic functions on an open domain of the complex plane is\nholomorphic (the derivatives converge locally uniformly to that of the limit, which is proved\nas `TendstoLocallyUniformlyOn.deriv`). -/\ntheorem _root_.TendstoLocallyUniformlyOn.differentiableOn [φ.NeBot]\n    (hf : TendstoLocallyUniformlyOn F f φ U) (hF : ∀ᶠ n in φ, DifferentiableOn ℂ (F n) U)\n    (hU : IsOpen U) : DifferentiableOn ℂ f U := by\n  rintro x hx\n  obtain ⟨K, ⟨hKx, hK⟩, hKU⟩ := (compact_basis_nhds x).mem_iff.mp (hU.mem_nhds hx)\n  obtain ⟨δ, _, _, h1⟩ := exists_cthickening_tendstoUniformlyOn hf hF hK hU hKU\n  have h2 : interior K ⊆ U := interior_subset.trans hKU\n  have h3 : ∀ᶠ n in φ, DifferentiableOn ℂ (F n) (interior K) := by\n    filter_upwards [hF] with n h using h.mono h2\n  have h4 : TendstoLocallyUniformlyOn F f φ (interior K) := hf.mono h2\n  have h5 : TendstoLocallyUniformlyOn (deriv ∘ F) (cderiv δ f) φ (interior K) :=\n    h1.tendstoLocallyUniformlyOn.mono interior_subset\n  have h6 : ∀ x ∈ interior K, HasDerivAt f (cderiv δ f x) x := fun x h =>\n    hasDerivAt_of_tendsto_locally_uniformly_on' isOpen_interior h5 h3 (fun _ => h4.tendsto_at) h\n  have h7 : DifferentiableOn ℂ f (interior K) := fun x hx =>\n    (h6 x hx).differentiableAt.differentiableWithinAt\n  exact (h7.differentiableAt (interior_mem_nhds.mpr hKx)).differentiableWithinAt\n\n"}
{"name":"TendstoLocallyUniformlyOn.deriv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU : Set Complex\nφ : Filter ι\nF : ι → Complex → E\nf : Complex → E\ninst✝ : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f φ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) φ\nhU : IsOpen U\n⊢ TendstoLocallyUniformlyOn (Function.comp deriv F) (deriv f) φ U","decl":"theorem _root_.TendstoLocallyUniformlyOn.deriv (hf : TendstoLocallyUniformlyOn F f φ U)\n    (hF : ∀ᶠ n in φ, DifferentiableOn ℂ (F n) U) (hU : IsOpen U) :\n    TendstoLocallyUniformlyOn (deriv ∘ F) (deriv f) φ U := by\n  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hU]\n  rcases φ.eq_or_neBot with rfl | hne\n  · simp only [TendstoUniformlyOn, eventually_bot, imp_true_iff]\n  rintro K hKU hK\n  obtain ⟨δ, hδ, hK4, h⟩ := exists_cthickening_tendstoUniformlyOn hf hF hK hU hKU\n  refine h.congr_right fun z hz => cderiv_eq_deriv hU (hf.differentiableOn hF hU) hδ ?_\n  exact (closedBall_subset_cthickening hz δ).trans hK4\n\n"}
{"name":"Complex.differentiableOn_tsum_of_summable_norm","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU : Set Complex\nF : ι → Complex → E\ninst✝ : CompleteSpace E\nu : ι → Real\nhu : Summable u\nhf : ∀ (i : ι), DifferentiableOn Complex (F i) U\nhU : IsOpen U\nhF_le : ∀ (i : ι) (w : Complex), Membership.mem U w → LE.le (Norm.norm (F i w)) (u i)\n⊢ DifferentiableOn Complex (fun w => tsum fun i => F i w) U","decl":"/-- If the terms in the sum `∑' (i : ι), F i` are uniformly bounded on `U` by a\nsummable function, and each term in the sum is differentiable on `U`, then so is the sum. -/\ntheorem differentiableOn_tsum_of_summable_norm {u : ι → ℝ} (hu : Summable u)\n    (hf : ∀ i : ι, DifferentiableOn ℂ (F i) U) (hU : IsOpen U)\n    (hF_le : ∀ (i : ι) (w : ℂ), w ∈ U → ‖F i w‖ ≤ u i) :\n    DifferentiableOn ℂ (fun w : ℂ => ∑' i : ι, F i w) U := by\n  classical\n  have hc := (tendstoUniformlyOn_tsum hu hF_le).tendstoLocallyUniformlyOn\n  refine hc.differentiableOn (Eventually.of_forall fun s => ?_) hU\n  exact DifferentiableOn.sum fun i _ => hf i\n\n"}
{"name":"Complex.hasSum_deriv_of_summable_norm","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\nU : Set Complex\nz : Complex\nF : ι → Complex → E\ninst✝ : CompleteSpace E\nu : ι → Real\nhu : Summable u\nhf : ∀ (i : ι), DifferentiableOn Complex (F i) U\nhU : IsOpen U\nhF_le : ∀ (i : ι) (w : Complex), Membership.mem U w → LE.le (Norm.norm (F i w)) (u i)\nhz : Membership.mem U z\n⊢ HasSum (fun i => deriv (F i) z) (deriv (fun w => tsum fun i => F i w) z)","decl":"/-- If the terms in the sum `∑' (i : ι), F i` are uniformly bounded on `U` by a\nsummable function, then the sum of `deriv F i` at a point in `U` is the derivative of the\nsum. -/\ntheorem hasSum_deriv_of_summable_norm {u : ι → ℝ} (hu : Summable u)\n    (hf : ∀ i : ι, DifferentiableOn ℂ (F i) U) (hU : IsOpen U)\n    (hF_le : ∀ (i : ι) (w : ℂ), w ∈ U → ‖F i w‖ ≤ u i) (hz : z ∈ U) :\n    HasSum (fun i : ι => deriv (F i) z) (deriv (fun w : ℂ => ∑' i : ι, F i w) z) := by\n  rw [HasSum]\n  have hc := (tendstoUniformlyOn_tsum hu hF_le).tendstoLocallyUniformlyOn\n  convert (hc.deriv (Eventually.of_forall fun s =>\n    DifferentiableOn.sum fun i _ => hf i) hU).tendsto_at hz using 1\n  ext1 s\n  exact (deriv_sum fun i _ => (hf i).differentiableAt (hU.mem_nhds hz)).symm\n\n"}
{"name":"Complex.logDeriv_tendsto","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"ι : Type u_3\np : Filter ι\nf : ι → Complex → Complex\ng : Complex → Complex\ns : Set Complex\nhs : IsOpen s\nx : ↑s\nhF : TendstoLocallyUniformlyOn f g p s\nhf : Filter.Eventually (fun n => DifferentiableOn Complex (f n) s) p\nhg : Ne (g ↑x) 0\n⊢ Filter.Tendsto (fun n => logDeriv (f n) ↑x) p (nhds (logDeriv g ↑x))","decl":"/-- The logarithmic derivative of a sequence of functions converging locally uniformly to a\nfunction is the logarithmic derivative of the limit function. -/\ntheorem logDeriv_tendsto {ι : Type*} {p : Filter ι} (f : ι → ℂ → ℂ) (g : ℂ → ℂ)\n    {s : Set ℂ} (hs : IsOpen s) (x : s) (hF : TendstoLocallyUniformlyOn f g p s)\n    (hf : ∀ᶠ n : ι in p, DifferentiableOn ℂ (f n) s) (hg : g x ≠ 0) :\n    Tendsto (fun n : ι => logDeriv (f n) x) p (𝓝 ((logDeriv g) x)) := by\n  simp_rw [logDeriv]\n  apply Tendsto.div ((hF.deriv hf hs).tendsto_at x.2) (hF.tendsto_at x.2) hg\n\n"}
