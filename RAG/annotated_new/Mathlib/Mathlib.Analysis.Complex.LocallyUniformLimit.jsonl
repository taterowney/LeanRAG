{"name":"Complex.cderiv_eq_deriv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU : Set Complex\nz : Complex\nr : Real\nf : Complex ‚Üí E\ninst‚úù : CompleteSpace E\nhU : IsOpen U\nhf : DifferentiableOn Complex f U\nhr : LT.lt 0 r\nhzr : HasSubset.Subset (Metric.closedBall z r) U\n‚ä¢ Eq (Complex.cderiv r f z) (deriv f z)","decl":"theorem cderiv_eq_deriv [CompleteSpace E] (hU : IsOpen U) (hf : DifferentiableOn ‚ÑÇ f U) (hr : 0 < r)\n    (hzr : closedBall z r ‚äÜ U) : cderiv r f z = deriv f z :=\n  two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable hU hzr hf (mem_ball_self hr)\n\n"}
{"name":"Complex.norm_cderiv_le","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nz : Complex\nM r : Real\nf : Complex ‚Üí E\nhr : LT.lt 0 r\nhf : ‚àÄ (w : Complex), Membership.mem (Metric.sphere z r) w ‚Üí LE.le (Norm.norm (f w)) M\n‚ä¢ LE.le (Norm.norm (Complex.cderiv r f z)) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_le (hr : 0 < r) (hf : ‚àÄ w ‚àà sphere z r, ‚Äñf w‚Äñ ‚â§ M) :\n    ‚Äñcderiv r f z‚Äñ ‚â§ M / r := by\n  have hM : 0 ‚â§ M := by\n    obtain ‚ü®w, hw‚ü© : (sphere z r).Nonempty := NormedSpace.sphere_nonempty.mpr hr.le\n    exact (norm_nonneg _).trans (hf w hw)\n  have h1 : ‚àÄ w ‚àà sphere z r, ‚Äñ((w - z) ^ 2)‚Åª¬π ‚Ä¢ f w‚Äñ ‚â§ M / r ^ 2 := by\n    intro w hw\n    simp only [mem_sphere_iff_norm, norm_eq_abs] at hw\n    simp only [norm_smul, inv_mul_eq_div, hw, norm_eq_abs, map_inv‚ÇÄ, Complex.abs_pow]\n    exact div_le_div‚ÇÄ hM (hf w hw) (sq_pos_of_pos hr) le_rfl\n  have h2 := circleIntegral.norm_integral_le_of_norm_le_const hr.le h1\n  simp only [cderiv, norm_smul]\n  refine (mul_le_mul le_rfl h2 (norm_nonneg _) (norm_nonneg _)).trans (le_of_eq ?_)\n  field_simp [_root_.abs_of_nonneg Real.pi_pos.le]\n  ring\n\n"}
{"name":"Complex.cderiv_sub","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nz : Complex\nr : Real\nf g : Complex ‚Üí E\nhr : LT.lt 0 r\nhf : ContinuousOn f (Metric.sphere z r)\nhg : ContinuousOn g (Metric.sphere z r)\n‚ä¢ Eq (Complex.cderiv r (HSub.hSub f g) z) (HSub.hSub (Complex.cderiv r f z) (Complex.cderiv r g z))","decl":"theorem cderiv_sub (hr : 0 < r) (hf : ContinuousOn f (sphere z r))\n    (hg : ContinuousOn g (sphere z r)) : cderiv r (f - g) z = cderiv r f z - cderiv r g z := by\n  have h1 : ContinuousOn (fun w : ‚ÑÇ => ((w - z) ^ 2)‚Åª¬π) (sphere z r) := by\n    refine ((continuous_id'.sub continuous_const).pow 2).continuousOn.inv‚ÇÄ fun w hw h => hr.ne ?_\n    rwa [mem_sphere_iff_norm, sq_eq_zero_iff.mp h, norm_zero] at hw\n  simp_rw [cderiv, ‚Üê smul_sub]\n  congr 1\n  simpa only [Pi.sub_apply, smul_sub] using\n    circleIntegral.integral_sub ((h1.smul hf).circleIntegrable hr.le)\n      ((h1.smul hg).circleIntegrable hr.le)\n\n"}
{"name":"Complex.norm_cderiv_lt","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nz : Complex\nM r : Real\nf : Complex ‚Üí E\nhr : LT.lt 0 r\nhfM : ‚àÄ (w : Complex), Membership.mem (Metric.sphere z r) w ‚Üí LT.lt (Norm.norm (f w)) M\nhf : ContinuousOn f (Metric.sphere z r)\n‚ä¢ LT.lt (Norm.norm (Complex.cderiv r f z)) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_lt (hr : 0 < r) (hfM : ‚àÄ w ‚àà sphere z r, ‚Äñf w‚Äñ < M)\n    (hf : ContinuousOn f (sphere z r)) : ‚Äñcderiv r f z‚Äñ < M / r := by\n  obtain ‚ü®L, hL1, hL2‚ü© : ‚àÉ L < M, ‚àÄ w ‚àà sphere z r, ‚Äñf w‚Äñ ‚â§ L := by\n    have e1 : (sphere z r).Nonempty := NormedSpace.sphere_nonempty.mpr hr.le\n    have e2 : ContinuousOn (fun w => ‚Äñf w‚Äñ) (sphere z r) := continuous_norm.comp_continuousOn hf\n    obtain ‚ü®x, hx, hx'‚ü© := (isCompact_sphere z r).exists_isMaxOn e1 e2\n    exact ‚ü®‚Äñf x‚Äñ, hfM x hx, hx'‚ü©\n  exact (norm_cderiv_le hr hL2).trans_lt ((div_lt_div_iff_of_pos_right hr).mpr hL1)\n\n"}
{"name":"Complex.norm_cderiv_sub_lt","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nz : Complex\nM r : Real\nf g : Complex ‚Üí E\nhr : LT.lt 0 r\nhfg : ‚àÄ (w : Complex), Membership.mem (Metric.sphere z r) w ‚Üí LT.lt (Norm.norm (HSub.hSub (f w) (g w))) M\nhf : ContinuousOn f (Metric.sphere z r)\nhg : ContinuousOn g (Metric.sphere z r)\n‚ä¢ LT.lt (Norm.norm (HSub.hSub (Complex.cderiv r f z) (Complex.cderiv r g z))) (HDiv.hDiv M r)","decl":"theorem norm_cderiv_sub_lt (hr : 0 < r) (hfg : ‚àÄ w ‚àà sphere z r, ‚Äñf w - g w‚Äñ < M)\n    (hf : ContinuousOn f (sphere z r)) (hg : ContinuousOn g (sphere z r)) :\n    ‚Äñcderiv r f z - cderiv r g z‚Äñ < M / r :=\n  cderiv_sub hr hf hg ‚ñ∏ norm_cderiv_lt hr hfg (hf.sub hg)\n\n"}
{"name":"TendstoUniformlyOn.cderiv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nK : Set Complex\nŒ¥ : Real\nœÜ : Filter Œπ\nF : Œπ ‚Üí Complex ‚Üí E\nf : Complex ‚Üí E\nhF : TendstoUniformlyOn F f œÜ (Metric.cthickening Œ¥ K)\nhŒ¥ : LT.lt 0 Œ¥\nhFn : Filter.Eventually (fun n => ContinuousOn (F n) (Metric.cthickening Œ¥ K)) œÜ\n‚ä¢ TendstoUniformlyOn (Function.comp (Complex.cderiv Œ¥) F) (Complex.cderiv Œ¥ f) œÜ K","decl":"theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f œÜ (cthickening Œ¥ K))\n    (hŒ¥ : 0 < Œ¥) (hFn : ‚àÄ·∂† n in œÜ, ContinuousOn (F n) (cthickening Œ¥ K)) :\n    TendstoUniformlyOn (cderiv Œ¥ ‚àò F) (cderiv Œ¥ f) œÜ K := by\n  rcases œÜ.eq_or_neBot with rfl | hne\n  ¬∑ simp only [TendstoUniformlyOn, eventually_bot, imp_true_iff]\n  have e1 : ContinuousOn f (cthickening Œ¥ K) := TendstoUniformlyOn.continuousOn hF hFn\n  rw [tendstoUniformlyOn_iff] at hF ‚ä¢\n  rintro Œµ hŒµ\n  filter_upwards [hF (Œµ * Œ¥) (mul_pos hŒµ hŒ¥), hFn] with n h h' z hz\n  simp_rw [dist_eq_norm] at h ‚ä¢\n  have e2 : ‚àÄ w ‚àà sphere z Œ¥, ‚Äñf w - F n w‚Äñ < Œµ * Œ¥ := fun w hw1 =>\n    h w (closedBall_subset_cthickening hz Œ¥ (sphere_subset_closedBall hw1))\n  have e3 := sphere_subset_closedBall.trans (closedBall_subset_cthickening hz Œ¥)\n  have hf : ContinuousOn f (sphere z Œ¥) :=\n    e1.mono (sphere_subset_closedBall.trans (closedBall_subset_cthickening hz Œ¥))\n  simpa only [mul_div_cancel_right‚ÇÄ _ hŒ¥.ne.symm] using norm_cderiv_sub_lt hŒ¥ e2 hf (h'.mono e3)\n\n"}
{"name":"Complex.tendstoUniformlyOn_deriv_of_cthickening_subset","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU K : Set Complex\nœÜ : Filter Œπ\nF : Œπ ‚Üí Complex ‚Üí E\nf : Complex ‚Üí E\ninst‚úù : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f œÜ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) œÜ\nŒ¥ : Real\nhŒ¥ : LT.lt 0 Œ¥\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset (Metric.cthickening Œ¥ K) U\n‚ä¢ TendstoUniformlyOn (Function.comp deriv F) (Complex.cderiv Œ¥ f) œÜ K","decl":"theorem tendstoUniformlyOn_deriv_of_cthickening_subset (hf : TendstoLocallyUniformlyOn F f œÜ U)\n    (hF : ‚àÄ·∂† n in œÜ, DifferentiableOn ‚ÑÇ (F n) U) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : cthickening Œ¥ K ‚äÜ U) :\n    TendstoUniformlyOn (deriv ‚àò F) (cderiv Œ¥ f) œÜ K := by\n  have h1 : ‚àÄ·∂† n in œÜ, ContinuousOn (F n) (cthickening Œ¥ K) := by\n    filter_upwards [hF] with n h using h.continuousOn.mono hKU\n  have h2 : IsCompact (cthickening Œ¥ K) := hK.cthickening\n  have h3 : TendstoUniformlyOn F f œÜ (cthickening Œ¥ K) :=\n    (tendstoLocallyUniformlyOn_iff_forall_isCompact hU).mp hf (cthickening Œ¥ K) hKU h2\n  apply (h3.cderiv hŒ¥ h1).congr\n  filter_upwards [hF] with n h z hz\n  exact cderiv_eq_deriv hU h hŒ¥ ((closedBall_subset_cthickening hz Œ¥).trans hKU)\n\n"}
{"name":"Complex.exists_cthickening_tendstoUniformlyOn","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU K : Set Complex\nœÜ : Filter Œπ\nF : Œπ ‚Üí Complex ‚Üí E\nf : Complex ‚Üí E\ninst‚úù : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f œÜ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) œÜ\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n‚ä¢ Exists fun Œ¥ => And (GT.gt Œ¥ 0) (And (HasSubset.Subset (Metric.cthickening Œ¥ K) U) (TendstoUniformlyOn (Function.comp deriv F) (Complex.cderiv Œ¥ f) œÜ K))","decl":"theorem exists_cthickening_tendstoUniformlyOn (hf : TendstoLocallyUniformlyOn F f œÜ U)\n    (hF : ‚àÄ·∂† n in œÜ, DifferentiableOn ‚ÑÇ (F n) U) (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U) :\n    ‚àÉ Œ¥ > 0, cthickening Œ¥ K ‚äÜ U ‚àß TendstoUniformlyOn (deriv ‚àò F) (cderiv Œ¥ f) œÜ K := by\n  obtain ‚ü®Œ¥, hŒ¥, hKŒ¥‚ü© := hK.exists_cthickening_subset_open hU hKU\n  exact ‚ü®Œ¥, hŒ¥, hKŒ¥, tendstoUniformlyOn_deriv_of_cthickening_subset hf hF hŒ¥ hK hU hKŒ¥‚ü©\n\n"}
{"name":"TendstoLocallyUniformlyOn.differentiableOn","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nU : Set Complex\nœÜ : Filter Œπ\nF : Œπ ‚Üí Complex ‚Üí E\nf : Complex ‚Üí E\ninst‚úù¬π : CompleteSpace E\ninst‚úù : œÜ.NeBot\nhf : TendstoLocallyUniformlyOn F f œÜ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) œÜ\nhU : IsOpen U\n‚ä¢ DifferentiableOn Complex f U","decl":"/-- A locally uniform limit of holomorphic functions on an open domain of the complex plane is\nholomorphic (the derivatives converge locally uniformly to that of the limit, which is proved\nas `TendstoLocallyUniformlyOn.deriv`). -/\ntheorem _root_.TendstoLocallyUniformlyOn.differentiableOn [œÜ.NeBot]\n    (hf : TendstoLocallyUniformlyOn F f œÜ U) (hF : ‚àÄ·∂† n in œÜ, DifferentiableOn ‚ÑÇ (F n) U)\n    (hU : IsOpen U) : DifferentiableOn ‚ÑÇ f U := by\n  rintro x hx\n  obtain ‚ü®K, ‚ü®hKx, hK‚ü©, hKU‚ü© := (compact_basis_nhds x).mem_iff.mp (hU.mem_nhds hx)\n  obtain ‚ü®Œ¥, _, _, h1‚ü© := exists_cthickening_tendstoUniformlyOn hf hF hK hU hKU\n  have h2 : interior K ‚äÜ U := interior_subset.trans hKU\n  have h3 : ‚àÄ·∂† n in œÜ, DifferentiableOn ‚ÑÇ (F n) (interior K) := by\n    filter_upwards [hF] with n h using h.mono h2\n  have h4 : TendstoLocallyUniformlyOn F f œÜ (interior K) := hf.mono h2\n  have h5 : TendstoLocallyUniformlyOn (deriv ‚àò F) (cderiv Œ¥ f) œÜ (interior K) :=\n    h1.tendstoLocallyUniformlyOn.mono interior_subset\n  have h6 : ‚àÄ x ‚àà interior K, HasDerivAt f (cderiv Œ¥ f x) x := fun x h =>\n    hasDerivAt_of_tendsto_locally_uniformly_on' isOpen_interior h5 h3 (fun _ => h4.tendsto_at) h\n  have h7 : DifferentiableOn ‚ÑÇ f (interior K) := fun x hx =>\n    (h6 x hx).differentiableAt.differentiableWithinAt\n  exact (h7.differentiableAt (interior_mem_nhds.mpr hKx)).differentiableWithinAt\n\n"}
{"name":"TendstoLocallyUniformlyOn.deriv","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU : Set Complex\nœÜ : Filter Œπ\nF : Œπ ‚Üí Complex ‚Üí E\nf : Complex ‚Üí E\ninst‚úù : CompleteSpace E\nhf : TendstoLocallyUniformlyOn F f œÜ U\nhF : Filter.Eventually (fun n => DifferentiableOn Complex (F n) U) œÜ\nhU : IsOpen U\n‚ä¢ TendstoLocallyUniformlyOn (Function.comp deriv F) (deriv f) œÜ U","decl":"theorem _root_.TendstoLocallyUniformlyOn.deriv (hf : TendstoLocallyUniformlyOn F f œÜ U)\n    (hF : ‚àÄ·∂† n in œÜ, DifferentiableOn ‚ÑÇ (F n) U) (hU : IsOpen U) :\n    TendstoLocallyUniformlyOn (deriv ‚àò F) (deriv f) œÜ U := by\n  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hU]\n  rcases œÜ.eq_or_neBot with rfl | hne\n  ¬∑ simp only [TendstoUniformlyOn, eventually_bot, imp_true_iff]\n  rintro K hKU hK\n  obtain ‚ü®Œ¥, hŒ¥, hK4, h‚ü© := exists_cthickening_tendstoUniformlyOn hf hF hK hU hKU\n  refine h.congr_right fun z hz => cderiv_eq_deriv hU (hf.differentiableOn hF hU) hŒ¥ ?_\n  exact (closedBall_subset_cthickening hz Œ¥).trans hK4\n\n"}
{"name":"Complex.differentiableOn_tsum_of_summable_norm","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU : Set Complex\nF : Œπ ‚Üí Complex ‚Üí E\ninst‚úù : CompleteSpace E\nu : Œπ ‚Üí Real\nhu : Summable u\nhf : ‚àÄ (i : Œπ), DifferentiableOn Complex (F i) U\nhU : IsOpen U\nhF_le : ‚àÄ (i : Œπ) (w : Complex), Membership.mem U w ‚Üí LE.le (Norm.norm (F i w)) (u i)\n‚ä¢ DifferentiableOn Complex (fun w => tsum fun i => F i w) U","decl":"/-- If the terms in the sum `‚àë' (i : Œπ), F i` are uniformly bounded on `U` by a\nsummable function, and each term in the sum is differentiable on `U`, then so is the sum. -/\ntheorem differentiableOn_tsum_of_summable_norm {u : Œπ ‚Üí ‚Ñù} (hu : Summable u)\n    (hf : ‚àÄ i : Œπ, DifferentiableOn ‚ÑÇ (F i) U) (hU : IsOpen U)\n    (hF_le : ‚àÄ (i : Œπ) (w : ‚ÑÇ), w ‚àà U ‚Üí ‚ÄñF i w‚Äñ ‚â§ u i) :\n    DifferentiableOn ‚ÑÇ (fun w : ‚ÑÇ => ‚àë' i : Œπ, F i w) U := by\n  classical\n  have hc := (tendstoUniformlyOn_tsum hu hF_le).tendstoLocallyUniformlyOn\n  refine hc.differentiableOn (Eventually.of_forall fun s => ?_) hU\n  exact DifferentiableOn.sum fun i _ => hf i\n\n"}
{"name":"Complex.hasSum_deriv_of_summable_norm","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"E : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Complex E\nU : Set Complex\nz : Complex\nF : Œπ ‚Üí Complex ‚Üí E\ninst‚úù : CompleteSpace E\nu : Œπ ‚Üí Real\nhu : Summable u\nhf : ‚àÄ (i : Œπ), DifferentiableOn Complex (F i) U\nhU : IsOpen U\nhF_le : ‚àÄ (i : Œπ) (w : Complex), Membership.mem U w ‚Üí LE.le (Norm.norm (F i w)) (u i)\nhz : Membership.mem U z\n‚ä¢ HasSum (fun i => deriv (F i) z) (deriv (fun w => tsum fun i => F i w) z)","decl":"/-- If the terms in the sum `‚àë' (i : Œπ), F i` are uniformly bounded on `U` by a\nsummable function, then the sum of `deriv F i` at a point in `U` is the derivative of the\nsum. -/\ntheorem hasSum_deriv_of_summable_norm {u : Œπ ‚Üí ‚Ñù} (hu : Summable u)\n    (hf : ‚àÄ i : Œπ, DifferentiableOn ‚ÑÇ (F i) U) (hU : IsOpen U)\n    (hF_le : ‚àÄ (i : Œπ) (w : ‚ÑÇ), w ‚àà U ‚Üí ‚ÄñF i w‚Äñ ‚â§ u i) (hz : z ‚àà U) :\n    HasSum (fun i : Œπ => deriv (F i) z) (deriv (fun w : ‚ÑÇ => ‚àë' i : Œπ, F i w) z) := by\n  rw [HasSum]\n  have hc := (tendstoUniformlyOn_tsum hu hF_le).tendstoLocallyUniformlyOn\n  convert (hc.deriv (Eventually.of_forall fun s =>\n    DifferentiableOn.sum fun i _ => hf i) hU).tendsto_at hz using 1\n  ext1 s\n  exact (deriv_sum fun i _ => (hf i).differentiableAt (hU.mem_nhds hz)).symm\n\n"}
{"name":"Complex.logDeriv_tendsto","module":"Mathlib.Analysis.Complex.LocallyUniformLimit","initialProofState":"Œπ : Type u_3\np : Filter Œπ\nf : Œπ ‚Üí Complex ‚Üí Complex\ng : Complex ‚Üí Complex\ns : Set Complex\nhs : IsOpen s\nx : ‚Üës\nhF : TendstoLocallyUniformlyOn f g p s\nhf : Filter.Eventually (fun n => DifferentiableOn Complex (f n) s) p\nhg : Ne (g ‚Üëx) 0\n‚ä¢ Filter.Tendsto (fun n => logDeriv (f n) ‚Üëx) p (nhds (logDeriv g ‚Üëx))","decl":"/-- The logarithmic derivative of a sequence of functions converging locally uniformly to a\nfunction is the logarithmic derivative of the limit function. -/\ntheorem logDeriv_tendsto {Œπ : Type*} {p : Filter Œπ} (f : Œπ ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) (g : ‚ÑÇ ‚Üí ‚ÑÇ)\n    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : s) (hF : TendstoLocallyUniformlyOn f g p s)\n    (hf : ‚àÄ·∂† n : Œπ in p, DifferentiableOn ‚ÑÇ (f n) s) (hg : g x ‚â† 0) :\n    Tendsto (fun n : Œπ => logDeriv (f n) x) p (ùìù ((logDeriv g) x)) := by\n  simp_rw [logDeriv]\n  apply Tendsto.div ((hF.deriv hf hs).tendsto_at x.2) (hF.tendsto_at x.2) hg\n\n"}
