{"name":"tendsto_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun n => Inv.inv ‚Üën) Filter.atTop (nhds 0)","decl":"theorem tendsto_inverse_atTop_nhds_zero_nat : Tendsto (fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù)‚Åª¬π) atTop (ùìù 0) :=\n  tendsto_inv_atTop_zero.comp tendsto_natCast_atTop_atTop\n\n"}
{"name":"tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : Real\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv C ‚Üën) Filter.atTop (nhds 0)","decl":"theorem tendsto_const_div_atTop_nhds_zero_nat (C : ‚Ñù) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ C / n) atTop (ùìù 0) := by\n  simpa only [mul_zero] using tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"tendsto_one_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv 1 ‚Üën) Filter.atTop (nhds 0)","decl":"theorem tendsto_one_div_atTop_nhds_zero_nat : Tendsto (fun n : ‚Ñï ‚Ü¶ 1/(n : ‚Ñù)) atTop (ùìù 0) :=\n  tendsto_const_div_atTop_nhds_zero_nat 1\n\n"}
{"name":"NNReal.tendsto_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun n => Inv.inv ‚Üën) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_inverse_atTop_nhds_zero_nat :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù‚â•0)‚Åª¬π) atTop (ùìù 0) := by\n  rw [‚Üê NNReal.tendsto_coe]\n  exact _root_.tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"NNReal.tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : NNReal\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv C ‚Üën) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_const_div_atTop_nhds_zero_nat (C : ‚Ñù‚â•0) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ C / n) atTop (ùìù 0) := by\n  simpa using tendsto_const_nhds.mul NNReal.tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"EReal.tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : EReal\nh : Ne C Bot.bot\nh' : Ne C Top.top\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv C ‚Üën) Filter.atTop (nhds 0)","decl":"theorem EReal.tendsto_const_div_atTop_nhds_zero_nat {C : EReal} (h : C ‚â† ‚ä•) (h' : C ‚â† ‚ä§) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ C / n) atTop (ùìù 0) := by\n  have : (fun n : ‚Ñï ‚Ü¶ C / n) = fun n : ‚Ñï ‚Ü¶ ((C.toReal / n : ‚Ñù) : EReal) := by\n    ext n\n    nth_rw 1 [‚Üê coe_toReal h' h, ‚Üê coe_coe_eq_natCast n, ‚Üê coe_div C.toReal n]\n  rw [this, ‚Üê coe_zero, tendsto_coe]\n  exact _root_.tendsto_const_div_atTop_nhds_zero_nat C.toReal\n\n"}
{"name":"tendsto_one_div_add_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1)) Filter.atTop (nhds 0)","decl":"theorem tendsto_one_div_add_atTop_nhds_zero_nat :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ 1 / ((n : ‚Ñù) + 1)) atTop (ùìù 0) :=\n  suffices Tendsto (fun n : ‚Ñï ‚Ü¶ 1 / (‚Üë(n + 1) : ‚Ñù)) atTop (ùìù 0) by simpa\n  (tendsto_add_atTop_iff_nat 1).2 (_root_.tendsto_const_div_atTop_nhds_zero_nat 1)\n\n"}
{"name":"NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù¬≥ : Semiring ùïú\ninst‚úù¬≤ : Algebra NNReal ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : ContinuousSMul NNReal ùïú\n‚ä¢ Filter.Tendsto (Function.comp ‚áë(algebraMap NNReal ùïú) fun n => Inv.inv ‚Üën) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat (ùïú : Type*) [Semiring ùïú]\n    [Algebra ‚Ñù‚â•0 ùïú] [TopologicalSpace ùïú] [ContinuousSMul ‚Ñù‚â•0 ùïú] :\n    Tendsto (algebraMap ‚Ñù‚â•0 ùïú ‚àò fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù‚â•0)‚Åª¬π) atTop (ùìù 0) := by\n  convert (continuous_algebraMap ‚Ñù‚â•0 ùïú).continuousAt.tendsto.comp\n    tendsto_inverse_atTop_nhds_zero_nat\n  rw [map_zero]\n\n"}
{"name":"tendsto_algebraMap_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù¬≥ : Semiring ùïú\ninst‚úù¬≤ : Algebra Real ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : ContinuousSMul Real ùïú\n‚ä¢ Filter.Tendsto (Function.comp ‚áë(algebraMap Real ùïú) fun n => Inv.inv ‚Üën) Filter.atTop (nhds 0)","decl":"theorem tendsto_algebraMap_inverse_atTop_nhds_zero_nat (ùïú : Type*) [Semiring ùïú] [Algebra ‚Ñù ùïú]\n    [TopologicalSpace ùïú] [ContinuousSMul ‚Ñù ùïú] :\n    Tendsto (algebraMap ‚Ñù ùïú ‚àò fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù)‚Åª¬π) atTop (ùìù 0) :=\n  NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat ùïú\n\n"}
{"name":"tendsto_natCast_div_add_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù‚Åµ : DivisionRing ùïú\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : CharZero ùïú\ninst‚úù¬≤ : Algebra Real ùïú\ninst‚úù¬π : ContinuousSMul Real ùïú\ninst‚úù : TopologicalDivisionRing ùïú\nx : ùïú\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üën) (HAdd.hAdd (‚Üën) x)) Filter.atTop (nhds 1)","decl":"/-- The limit of `n / (n + x)` is 1, for any constant `x` (valid in `‚Ñù` or any topological division\nalgebra over `‚Ñù`, e.g., `‚ÑÇ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `‚Ñö`, `‚Ñù` and `‚ÑÇ`. -/\ntheorem tendsto_natCast_div_add_atTop {ùïú : Type*} [DivisionRing ùïú] [TopologicalSpace ùïú]\n    [CharZero ùïú] [Algebra ‚Ñù ùïú] [ContinuousSMul ‚Ñù ùïú] [TopologicalDivisionRing ùïú] (x : ùïú) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ (n : ùïú) / (n + x)) atTop (ùìù 1) := by\n  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn ‚Ü¶ _)) _\n  ¬∑ exact fun n : ‚Ñï ‚Ü¶ 1 / (1 + x / n)\n  ¬∑ field_simp [Nat.cast_ne_zero.mpr hn]\n  ¬∑ have : ùìù (1 : ùïú) = ùìù (1 / (1 + x * (0 : ùïú))) := by\n      rw [mul_zero, add_zero, div_one]\n    rw [this]\n    refine tendsto_const_nhds.div (tendsto_const_nhds.add ?_) (by simp)\n    simp_rw [div_eq_mul_inv]\n    refine tendsto_const_nhds.mul ?_\n    have := ((continuous_algebraMap ‚Ñù ùïú).tendsto _).comp tendsto_inverse_atTop_nhds_zero_nat\n    rw [map_zero, Filter.tendsto_atTop'] at this\n    refine Iff.mpr tendsto_atTop' ?_\n    intros\n    simp_all only [comp_apply, map_inv‚ÇÄ, map_natCast]\n\n"}
{"name":"tendsto_mod_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Nat\nhm : LT.lt 0 m\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv ‚Üë(HMod.hMod n m) ‚Üën) Filter.atTop (nhds 0)","decl":"/-- For any positive `m : ‚Ñï`, `((n % m : ‚Ñï) : ‚Ñù) / (n : ‚Ñù)` tends to `0` as `n` tends to `‚àû`. -/\ntheorem tendsto_mod_div_atTop_nhds_zero_nat {m : ‚Ñï} (hm : 0 < m) :\n    Tendsto (fun n : ‚Ñï => ((n % m : ‚Ñï) : ‚Ñù) / (n : ‚Ñù)) atTop (ùìù 0) := by\n  have h0 : ‚àÄ·∂† n : ‚Ñï in atTop, 0 ‚â§ (fun n : ‚Ñï => ((n % m : ‚Ñï) : ‚Ñù)) n := by aesop\n  exact tendsto_bdd_div_atTop_nhds_zero h0\n    (.of_forall (fun n ‚Ü¶  cast_le.mpr (mod_lt n hm).le)) tendsto_natCast_atTop_atTop\n\n"}
{"name":"Filter.EventuallyEq.div_mul_cancel","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\nG : Type u_5\ninst‚úù : GroupWithZero G\nf g : Œ± ‚Üí G\nl : Filter Œ±\nhg : Filter.Tendsto g l (Filter.principal (HasCompl.compl (Singleton.singleton 0)))\n‚ä¢ l.EventuallyEq (fun x => HMul.hMul (HDiv.hDiv (f x) (g x)) (g x)) fun x => f x","decl":"theorem Filter.EventuallyEq.div_mul_cancel {Œ± G : Type*} [GroupWithZero G] {f g : Œ± ‚Üí G}\n    {l : Filter Œ±} (hg : Tendsto g l (ùìü {0}·∂ú)) : (fun x ‚Ü¶ f x / g x * g x) =·∂†[l] fun x ‚Ü¶ f x := by\n  filter_upwards [hg.le_comap <| preimage_mem_comap (m := g) (mem_principal_self {0}·∂ú)] with x hx\n  aesop\n\n"}
{"name":"Filter.EventuallyEq.div_mul_cancel_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\nK : Type u_5\ninst‚úù : LinearOrderedSemifield K\nf g : Œ± ‚Üí K\nl : Filter Œ±\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ l.EventuallyEq (fun x => HMul.hMul (HDiv.hDiv (f x) (g x)) (g x)) fun x => f x","decl":"/-- If `g` tends to `‚àû`, then eventually for all `x` we have `(f x / g x) * g x = f x`. -/\ntheorem Filter.EventuallyEq.div_mul_cancel_atTop {Œ± K : Type*} [LinearOrderedSemifield K]\n    {f g : Œ± ‚Üí K} {l : Filter Œ±} (hg : Tendsto g l atTop) :\n    (fun x ‚Ü¶ f x / g x * g x) =·∂†[l] fun x ‚Ü¶ f x :=\n  div_mul_cancel <| hg.mono_right <| le_principal_iff.mpr <|\n    mem_of_superset (Ioi_mem_atTop 0) <| by simp\n\n"}
{"name":"Tendsto.num","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\nK : Type u_5\ninst‚úù¬≤ : LinearOrderedField K\ninst‚úù¬π : TopologicalSpace K\ninst‚úù : OrderTopology K\nf g : Œ± ‚Üí K\nl : Filter Œ±\nhg : Filter.Tendsto g l Filter.atTop\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\n‚ä¢ Filter.Tendsto f l Filter.atTop","decl":"/-- If when `x` tends to `‚àû`, `g` tends to `‚àû` and `f x / g x` tends to a positive\n  constant, then `f` tends to `‚àû`. -/\ntheorem Tendsto.num {Œ± K : Type*} [LinearOrderedField K] [TopologicalSpace K] [OrderTopology K]\n    {f g : Œ± ‚Üí K} {l : Filter Œ±} (hg : Tendsto g l atTop) {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ùìù a)) :\n    Tendsto f l atTop :=\n  Tendsto.congr' (EventuallyEq.div_mul_cancel_atTop hg) (Tendsto.mul_atTop ha hlim hg)\n\n"}
{"name":"Tendsto.den","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\nK : Type u_5\ninst‚úù¬≥ : LinearOrderedField K\ninst‚úù¬≤ : TopologicalSpace K\ninst‚úù¬π : OrderTopology K\ninst‚úù : ContinuousInv K\nf g : Œ± ‚Üí K\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atTop\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\n‚ä¢ Filter.Tendsto g l Filter.atTop","decl":"/-- If when `x` tends to `‚àû`, `g` tends to `‚àû` and `f x / g x` tends to a positive\n  constant, then `f` tends to `‚àû`. -/\ntheorem Tendsto.den {Œ± K : Type*} [LinearOrderedField K] [TopologicalSpace K] [OrderTopology K]\n    [ContinuousInv K] {f g : Œ± ‚Üí K} {l : Filter Œ±} (hf : Tendsto f l atTop) {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ùìù a)) :\n    Tendsto g l atTop := by\n  have hlim' : Tendsto (fun x => g x / f x) l (ùìù a‚Åª¬π) := by\n    simp_rw [‚Üê inv_div (f _)]\n    exact Filter.Tendsto.inv (f := fun x => f x / g x) hlim\n  apply Tendsto.congr' (EventuallyEq.div_mul_cancel_atTop hf)\n    (Tendsto.mul_atTop (inv_pos_of_pos ha) hlim' hf)\n\n"}
{"name":"Tendsto.num_atTop_iff_den_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\nK : Type u_5\ninst‚úù¬≥ : LinearOrderedField K\ninst‚úù¬≤ : TopologicalSpace K\ninst‚úù¬π : OrderTopology K\ninst‚úù : ContinuousInv K\nf g : Œ± ‚Üí K\nl : Filter Œ±\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\n‚ä¢ Iff (Filter.Tendsto f l Filter.atTop) (Filter.Tendsto g l Filter.atTop)","decl":"/-- If when `x` tends to `‚àû`, `f x / g x` tends to a positive constant, then `f` tends to `‚àû` if\n  and only if `g` tends to `‚àû`. -/\ntheorem Tendsto.num_atTop_iff_den_atTop {Œ± K : Type*} [LinearOrderedField K] [TopologicalSpace K]\n    [OrderTopology K] [ContinuousInv K] {f g : Œ± ‚Üí K} {l : Filter Œ±} {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ùìù a)) :\n    Tendsto f l atTop ‚Üî Tendsto g l atTop :=\n  ‚ü®fun hf ‚Ü¶ Tendsto.den hf ha hlim, fun hg ‚Ü¶ Tendsto.num hg ha hlim‚ü©\n\n"}
{"name":"tendsto_add_one_pow_atTop_atTop_of_pos","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrderedSemiring Œ±\ninst‚úù : Archimedean Œ±\nr : Œ±\nh : LT.lt 0 r\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow (HAdd.hAdd r 1) n) Filter.atTop Filter.atTop","decl":"theorem tendsto_add_one_pow_atTop_atTop_of_pos [LinearOrderedSemiring Œ±] [Archimedean Œ±] {r : Œ±}\n    (h : 0 < r) : Tendsto (fun n : ‚Ñï ‚Ü¶ (r + 1) ^ n) atTop atTop :=\n  tendsto_atTop_atTop_of_monotone' (pow_right_mono‚ÇÄ <| le_add_of_nonneg_left h.le) <|\n    not_bddAbove_iff.2 fun _ ‚Ü¶ Set.exists_range_iff.2 <| add_one_pow_unbounded_of_pos _ h\n\n"}
{"name":"tendsto_pow_atTop_atTop_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrderedRing Œ±\ninst‚úù : Archimedean Œ±\nr : Œ±\nh : LT.lt 1 r\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop Filter.atTop","decl":"theorem tendsto_pow_atTop_atTop_of_one_lt [LinearOrderedRing Œ±] [Archimedean Œ±] {r : Œ±}\n    (h : 1 < r) : Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop atTop :=\n  sub_add_cancel r 1 ‚ñ∏ tendsto_add_one_pow_atTop_atTop_of_pos (sub_pos.2 h)\n\n"}
{"name":"Nat.tendsto_pow_atTop_atTop_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Nat\nh : LT.lt 1 m\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow m n) Filter.atTop Filter.atTop","decl":"theorem Nat.tendsto_pow_atTop_atTop_of_one_lt {m : ‚Ñï} (h : 1 < m) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ m ^ n) atTop atTop :=\n  tsub_add_cancel_of_le (le_of_lt h) ‚ñ∏ tendsto_add_one_pow_atTop_atTop_of_pos (tsub_pos_of_lt h)\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù¬≥ : LinearOrderedField ùïú\ninst‚úù¬≤ : Archimedean ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : OrderTopology ùïú\nr : ùïú\nh‚ÇÅ : LE.le 0 r\nh‚ÇÇ : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_atTop_nhds_zero_of_lt_one {ùïú : Type*} [LinearOrderedField ùïú] [Archimedean ùïú]\n    [TopologicalSpace ùïú] [OrderTopology ùïú] {r : ùïú} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù 0) :=\n  h‚ÇÅ.eq_or_lt.elim\n    (fun hr ‚Ü¶ (tendsto_add_atTop_iff_nat 1).mp <| by\n      simp [_root_.pow_succ, ‚Üê hr, tendsto_const_nhds])\n    (fun hr ‚Ü¶\n      have := (one_lt_inv‚ÇÄ hr).2 h‚ÇÇ |> tendsto_pow_atTop_atTop_of_one_lt\n      (tendsto_inv_atTop_zero.comp this).congr fun n ‚Ü¶ by simp)\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù¬≥ : LinearOrderedField ùïú\ninst‚úù¬≤ : Archimedean ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : OrderTopology ùïú\nr : ùïú\n‚ä¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt (abs r) 1)","decl":"@[simp] theorem tendsto_pow_atTop_nhds_zero_iff {ùïú : Type*} [LinearOrderedField ùïú] [Archimedean ùïú]\n    [TopologicalSpace ùïú] [OrderTopology ùïú] {r : ùïú} :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù 0) ‚Üî |r| < 1 := by\n  rw [tendsto_zero_iff_abs_tendsto_zero]\n  refine ‚ü®fun h ‚Ü¶ by_contra (fun hr_le ‚Ü¶ ?_), fun h ‚Ü¶ ?_‚ü©\n  ¬∑ by_cases hr : 1 = |r|\n    ¬∑ replace h : Tendsto (fun n : ‚Ñï ‚Ü¶ |r|^n) atTop (ùìù 0) := by simpa only [‚Üê abs_pow, h]\n      simp only [hr.symm, one_pow] at h\n      exact zero_ne_one <| tendsto_nhds_unique h tendsto_const_nhds\n    ¬∑ apply @not_tendsto_nhds_of_tendsto_atTop ùïú ‚Ñï _ _ _ _ atTop _ (fun n ‚Ü¶ |r| ^ n) _ 0 _\n      ¬∑ refine (pow_right_strictMono‚ÇÄ <| lt_of_le_of_ne (le_of_not_lt hr_le)\n          hr).monotone.tendsto_atTop_atTop (fun b ‚Ü¶ ?_)\n        obtain ‚ü®n, hn‚ü© := (pow_unbounded_of_one_lt b (lt_of_le_of_ne (le_of_not_lt hr_le) hr))\n        exact ‚ü®n, le_of_lt hn‚ü©\n      ¬∑ simpa only [‚Üê abs_pow]\n  ¬∑ simpa only [‚Üê abs_pow] using (tendsto_pow_atTop_nhds_zero_of_lt_one (abs_nonneg r)) h\n\n"}
{"name":"tendsto_pow_atTop_nhdsWithin_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ùïú : Type u_4\ninst‚úù¬≥ : LinearOrderedField ùïú\ninst‚úù¬≤ : Archimedean ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : OrderTopology ùïú\nr : ùïú\nh‚ÇÅ : LT.lt 0 r\nh‚ÇÇ : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem tendsto_pow_atTop_nhdsWithin_zero_of_lt_one {ùïú : Type*} [LinearOrderedField ùïú]\n    [Archimedean ùïú] [TopologicalSpace ùïú] [OrderTopology ùïú] {r : ùïú} (h‚ÇÅ : 0 < r) (h‚ÇÇ : r < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù[>] 0) :=\n  tendsto_inf.2\n    ‚ü®tendsto_pow_atTop_nhds_zero_of_lt_one h‚ÇÅ.le h‚ÇÇ,\n      tendsto_principal.2 <| Eventually.of_forall fun _ ‚Ü¶ pow_pos h‚ÇÅ _‚ü©\n\n"}
{"name":"uniformity_basis_dist_pow_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\ninst‚úù : PseudoMetricSpace Œ±\nr : Real\nh‚ÇÄ : LT.lt 0 r\nh‚ÇÅ : LT.lt r 1\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun k => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HPow.hPow r k)","decl":"theorem uniformity_basis_dist_pow_of_lt_one {Œ± : Type*} [PseudoMetricSpace Œ±] {r : ‚Ñù} (h‚ÇÄ : 0 < r)\n    (h‚ÇÅ : r < 1) :\n    (uniformity Œ±).HasBasis (fun _ : ‚Ñï ‚Ü¶ True) fun k ‚Ü¶ { p : Œ± √ó Œ± | dist p.1 p.2 < r ^ k } :=\n  Metric.mk_uniformity_basis (fun _ _ ‚Ü¶ pow_pos h‚ÇÄ _) fun _ Œµ0 ‚Ü¶\n    (exists_pow_lt_of_lt_one Œµ0 h‚ÇÅ).imp fun _ hk ‚Ü¶ ‚ü®trivial, hk.le‚ü©\n\n"}
{"name":"geom_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat ‚Üí Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nhn : LT.lt 0 n\nh : ‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (HMul.hMul c (u k)) (u (HAdd.hAdd k 1))\n‚ä¢ LT.lt (HMul.hMul (HPow.hPow c n) (u 0)) (u n)","decl":"theorem geom_lt {u : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hc : 0 ‚â§ c) {n : ‚Ñï} (hn : 0 < n)\n    (h : ‚àÄ k < n, c * u k < u (k + 1)) : c ^ n * u 0 < u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h\n  ¬∑ simp\n  ¬∑ simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"geom_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat ‚Üí Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nh : ‚àÄ (k : Nat), LT.lt k n ‚Üí LE.le (HMul.hMul c (u k)) (u (HAdd.hAdd k 1))\n‚ä¢ LE.le (HMul.hMul (HPow.hPow c n) (u 0)) (u n)","decl":"theorem geom_le {u : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hc : 0 ‚â§ c) (n : ‚Ñï) (h : ‚àÄ k < n, c * u k ‚â§ u (k + 1)) :\n    c ^ n * u 0 ‚â§ u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"lt_geom","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat ‚Üí Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nhn : LT.lt 0 n\nh : ‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (u (HAdd.hAdd k 1)) (HMul.hMul c (u k))\n‚ä¢ LT.lt (u n) (HMul.hMul (HPow.hPow c n) (u 0))","decl":"theorem lt_geom {u : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hc : 0 ‚â§ c) {n : ‚Ñï} (hn : 0 < n)\n    (h : ‚àÄ k < n, u (k + 1) < c * u k) : u n < c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _\n  ¬∑ simp\n  ¬∑ simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"le_geom","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat ‚Üí Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nh : ‚àÄ (k : Nat), LT.lt k n ‚Üí LE.le (u (HAdd.hAdd k 1)) (HMul.hMul c (u k))\n‚ä¢ LE.le (u n) (HMul.hMul (HPow.hPow c n) (u 0))","decl":"theorem le_geom {u : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hc : 0 ‚â§ c) (n : ‚Ñï) (h : ‚àÄ k < n, u (k + 1) ‚â§ c * u k) :\n    u n ‚â§ c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"tendsto_atTop_of_geom_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"v : Nat ‚Üí Real\nc : Real\nh‚ÇÄ : LT.lt 0 (v 0)\nhc : LT.lt 1 c\nhu : ‚àÄ (n : Nat), LE.le (HMul.hMul c (v n)) (v (HAdd.hAdd n 1))\n‚ä¢ Filter.Tendsto v Filter.atTop Filter.atTop","decl":"/-- If a sequence `v` of real numbers satisfies `k * v n ‚â§ v (n+1)` with `1 < k`,\nthen it goes to +‚àû. -/\ntheorem tendsto_atTop_of_geom_le {v : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (h‚ÇÄ : 0 < v 0) (hc : 1 < c)\n    (hu : ‚àÄ n, c * v n ‚â§ v (n + 1)) : Tendsto v atTop atTop :=\n  (tendsto_atTop_mono fun n ‚Ü¶ geom_le (zero_le_one.trans hc.le) n fun k _ ‚Ü¶ hu k) <|\n    (tendsto_pow_atTop_atTop_of_one_lt hc).atTop_mul_const h‚ÇÄ\n\n"}
{"name":"NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one {r : ‚Ñù‚â•0} (hr : r < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù 0) :=\n  NNReal.tendsto_coe.1 <| by\n    simp only [NNReal.coe_pow, NNReal.coe_zero,\n      _root_.tendsto_pow_atTop_nhds_zero_of_lt_one r.coe_nonneg hr]\n\n"}
{"name":"NNReal.tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\n‚ä¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt r 1)","decl":"@[simp]\nprotected theorem NNReal.tendsto_pow_atTop_nhds_zero_iff {r : ‚Ñù‚â•0} :\n    Tendsto (fun n : ‚Ñï => r ^ n) atTop (ùìù 0) ‚Üî r < 1 :=\n  ‚ü®fun h => by simpa [coe_pow, coe_zero, abs_eq, coe_lt_one, val_eq_coe] using\n    tendsto_pow_atTop_nhds_zero_iff.mp <| tendsto_coe.mpr h, tendsto_pow_atTop_nhds_zero_of_lt_one‚ü©\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nhr : LT.lt r 1\n‚ä¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one {r : ‚Ñù‚â•0‚àû} (hr : r < 1) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ r ^ n) atTop (ùìù 0) := by\n  rcases ENNReal.lt_iff_exists_coe.1 hr with ‚ü®r, rfl, hr'‚ü©\n  rw [‚Üê ENNReal.coe_zero]\n  norm_cast at *\n  apply NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one hr\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\n‚ä¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt r 1)","decl":"@[simp]\nprotected theorem ENNReal.tendsto_pow_atTop_nhds_zero_iff {r : ‚Ñù‚â•0‚àû} :\n    Tendsto (fun n : ‚Ñï => r ^ n) atTop (ùìù 0) ‚Üî r < 1 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, tendsto_pow_atTop_nhds_zero_of_lt_one‚ü©\n  lift r to NNReal\n  ¬∑ refine fun hr ‚Ü¶ top_ne_zero (tendsto_nhds_unique (EventuallyEq.tendsto ?_) (hr ‚ñ∏ h))\n    exact eventually_atTop.mpr ‚ü®1, fun _ hn ‚Ü¶ pow_eq_top_iff.mpr ‚ü®rfl, Nat.pos_iff_ne_zero.mp hn‚ü©‚ü©\n  rw [‚Üê coe_zero] at h\n  norm_cast at h ‚ä¢\n  exact NNReal.tendsto_pow_atTop_nhds_zero_iff.mp h\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_top_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\n‚ä¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds Top.top)) (LT.lt 1 r)","decl":"@[simp]\nprotected theorem ENNReal.tendsto_pow_atTop_nhds_top_iff {r : ‚Ñù‚â•0‚àû} :\n    Tendsto (fun n ‚Ü¶ r^n) atTop (ùìù ‚àû) ‚Üî 1 < r := by\n  refine ‚ü®?_, ?_‚ü©\n  ¬∑ contrapose!\n    intro r_le_one h_tends\n    specialize h_tends (Ioi_mem_nhds one_lt_top)\n    simp only [Filter.mem_map, mem_atTop_sets, ge_iff_le, Set.mem_preimage, Set.mem_Ioi] at h_tends\n    obtain ‚ü®n, hn‚ü© := h_tends\n    exact lt_irrefl _ <| lt_of_lt_of_le (hn n le_rfl) <| pow_le_one‚ÇÄ (zero_le _) r_le_one\n  ¬∑ intro r_gt_one\n    have obs := @Tendsto.inv ‚Ñù‚â•0‚àû ‚Ñï _ _ _ (fun n ‚Ü¶ (r‚Åª¬π)^n) atTop 0\n    simp only [ENNReal.tendsto_pow_atTop_nhds_zero_iff, inv_zero] at obs\n    simpa [‚Üê ENNReal.inv_pow] using obs <| ENNReal.inv_lt_one.mpr r_gt_one\n\n"}
{"name":"ENNReal.eq_zero_of_le_mul_pow","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"x r : ENNReal\nŒµ : NNReal\nhr : LT.lt r 1\nh : ‚àÄ (n : Nat), LE.le x (HMul.hMul (‚ÜëŒµ) (HPow.hPow r n))\n‚ä¢ Eq x 0","decl":"lemma ENNReal.eq_zero_of_le_mul_pow {x r : ‚Ñù‚â•0‚àû} {Œµ : ‚Ñù‚â•0} (hr : r < 1)\n    (h : ‚àÄ n : ‚Ñï, x ‚â§ Œµ * r ^ n) : x = 0 := by\n  rw [‚Üê nonpos_iff_eq_zero]\n  refine ge_of_tendsto' (f := fun (n : ‚Ñï) ‚Ü¶ Œµ * r ^ n) (x := atTop) ?_ h\n  rw [‚Üê mul_zero (M‚ÇÄ := ‚Ñù‚â•0‚àû) (a := Œµ)]\n  exact Tendsto.const_mul (tendsto_pow_atTop_nhds_zero_of_lt_one hr) (Or.inr coe_ne_top)\n\n"}
{"name":"hasSum_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nh‚ÇÅ : LE.le 0 r\nh‚ÇÇ : LT.lt r 1\n‚ä¢ HasSum (fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem hasSum_geometric_of_lt_one {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) :\n    HasSum (fun n : ‚Ñï ‚Ü¶ r ^ n) (1 - r)‚Åª¬π :=\n  have : r ‚â† 1 := ne_of_lt h‚ÇÇ\n  have : Tendsto (fun n ‚Ü¶ (r ^ n - 1) * (r - 1)‚Åª¬π) atTop (ùìù ((0 - 1) * (r - 1)‚Åª¬π)) :=\n    ((tendsto_pow_atTop_nhds_zero_of_lt_one h‚ÇÅ h‚ÇÇ).sub tendsto_const_nhds).mul tendsto_const_nhds\n  (hasSum_iff_tendsto_nat_of_nonneg (pow_nonneg h‚ÇÅ) _).mpr <| by\n    simp_all [neg_inv, geom_sum_eq, div_eq_mul_inv]\n\n"}
{"name":"summable_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nh‚ÇÅ : LE.le 0 r\nh‚ÇÇ : LT.lt r 1\n‚ä¢ Summable fun n => HPow.hPow r n","decl":"theorem summable_geometric_of_lt_one {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) :\n    Summable fun n : ‚Ñï ‚Ü¶ r ^ n :=\n  ‚ü®_, hasSum_geometric_of_lt_one h‚ÇÅ h‚ÇÇ‚ü©\n\n\n"}
{"name":"tsum_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nh‚ÇÅ : LE.le 0 r\nh‚ÇÇ : LT.lt r 1\n‚ä¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem tsum_geometric_of_lt_one {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) : ‚àë' n : ‚Ñï, r ^ n = (1 - r)‚Åª¬π :=\n  (hasSum_geometric_of_lt_one h‚ÇÅ h‚ÇÇ).tsum_eq\n\n"}
{"name":"hasSum_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ HasSum (fun n => HPow.hPow (1 / 2) n) 2","decl":"theorem hasSum_geometric_two : HasSum (fun n : ‚Ñï ‚Ü¶ ((1 : ‚Ñù) / 2) ^ n) 2 := by\n  convert hasSum_geometric_of_lt_one _ _ <;> norm_num\n\n"}
{"name":"summable_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Summable fun n => HPow.hPow (1 / 2) n","decl":"theorem summable_geometric_two : Summable fun n : ‚Ñï ‚Ü¶ ((1 : ‚Ñù) / 2) ^ n :=\n  ‚ü®_, hasSum_geometric_two‚ü©\n\n"}
{"name":"summable_geometric_two_encode","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œπ : Type u_4\ninst‚úù : Encodable Œπ\n‚ä¢ Summable fun i => HPow.hPow (1 / 2) (Encodable.encode i)","decl":"theorem summable_geometric_two_encode {Œπ : Type*} [Encodable Œπ] :\n    Summable fun i : Œπ ‚Ü¶ (1 / 2 : ‚Ñù) ^ Encodable.encode i :=\n  summable_geometric_two.comp_injective Encodable.encode_injective\n\n"}
{"name":"tsum_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Eq (tsum fun n => HPow.hPow (1 / 2) n) 2","decl":"theorem tsum_geometric_two : (‚àë' n : ‚Ñï, ((1 : ‚Ñù) / 2) ^ n) = 2 :=\n  hasSum_geometric_two.tsum_eq\n\n"}
{"name":"sum_geometric_two_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\n‚ä¢ LE.le ((Finset.range n).sum fun i => HPow.hPow (1 / 2) i) 2","decl":"theorem sum_geometric_two_le (n : ‚Ñï) : (‚àë i ‚àà range n, (1 / (2 : ‚Ñù)) ^ i) ‚â§ 2 := by\n  have : ‚àÄ i, 0 ‚â§ (1 / (2 : ‚Ñù)) ^ i := by\n    intro i\n    apply pow_nonneg\n    norm_num\n  convert sum_le_tsum (range n) (fun i _ ‚Ü¶ this i) summable_geometric_two\n  exact tsum_geometric_two.symm\n\n"}
{"name":"tsum_geometric_inv_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Eq (tsum fun n => HPow.hPow (Inv.inv 2) n) 2","decl":"theorem tsum_geometric_inv_two : (‚àë' n : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ n) = 2 :=\n  (inv_eq_one_div (2 : ‚Ñù)).symm ‚ñ∏ tsum_geometric_two\n\n"}
{"name":"tsum_geometric_inv_two_ge","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (tsum fun i => ite (LE.le n i) (HPow.hPow (Inv.inv 2) i) 0) (HMul.hMul 2 (HPow.hPow (Inv.inv 2) n))","decl":"/-- The sum of `2‚Åª¬π ^ i` for `n ‚â§ i` equals `2 * 2‚Åª¬π ^ n`. -/\ntheorem tsum_geometric_inv_two_ge (n : ‚Ñï) :\n    (‚àë' i, ite (n ‚â§ i) ((2 : ‚Ñù)‚Åª¬π ^ i) 0) = 2 * 2‚Åª¬π ^ n := by\n  have A : Summable fun i : ‚Ñï ‚Ü¶ ite (n ‚â§ i) ((2‚Åª¬π : ‚Ñù) ^ i) 0 := by\n    simpa only [‚Üê piecewise_eq_indicator, one_div]\n      using summable_geometric_two.indicator {i | n ‚â§ i}\n  have B : ((Finset.range n).sum fun i : ‚Ñï ‚Ü¶ ite (n ‚â§ i) ((2‚Åª¬π : ‚Ñù) ^ i) 0) = 0 :=\n    Finset.sum_eq_zero fun i hi ‚Ü¶\n      ite_eq_right_iff.2 fun h ‚Ü¶ (lt_irrefl _ ((Finset.mem_range.1 hi).trans_le h)).elim\n  simp only [‚Üê _root_.sum_add_tsum_nat_add n A, B, if_true, zero_add, zero_le',\n    le_add_iff_nonneg_left, pow_add, _root_.tsum_mul_right, tsum_geometric_inv_two]\n\n"}
{"name":"hasSum_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\n‚ä¢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)) a","decl":"theorem hasSum_geometric_two' (a : ‚Ñù) : HasSum (fun n : ‚Ñï ‚Ü¶ a / 2 / 2 ^ n) a := by\n  convert HasSum.mul_left (a / 2)\n      (hasSum_geometric_of_lt_one (le_of_lt one_half_pos) one_half_lt_one) using 1\n  ¬∑ funext n\n    simp only [one_div, inv_pow]\n    rfl\n  ¬∑ norm_num\n\n"}
{"name":"summable_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\n‚ä¢ Summable fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)","decl":"theorem summable_geometric_two' (a : ‚Ñù) : Summable fun n : ‚Ñï ‚Ü¶ a / 2 / 2 ^ n :=\n  ‚ü®a, hasSum_geometric_two' a‚ü©\n\n"}
{"name":"tsum_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\n‚ä¢ Eq (tsum fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)) a","decl":"theorem tsum_geometric_two' (a : ‚Ñù) : ‚àë' n : ‚Ñï, a / 2 / 2 ^ n = a :=\n  (hasSum_geometric_two' a).tsum_eq\n\n"}
{"name":"NNReal.hasSum_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\n‚ä¢ HasSum (fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"/-- **Sum of a Geometric Series** -/\ntheorem NNReal.hasSum_geometric {r : ‚Ñù‚â•0} (hr : r < 1) : HasSum (fun n : ‚Ñï ‚Ü¶ r ^ n) (1 - r)‚Åª¬π := by\n  apply NNReal.hasSum_coe.1\n  push_cast\n  rw [NNReal.coe_sub (le_of_lt hr)]\n  exact hasSum_geometric_of_lt_one r.coe_nonneg hr\n\n"}
{"name":"NNReal.summable_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\n‚ä¢ Summable fun n => HPow.hPow r n","decl":"theorem NNReal.summable_geometric {r : ‚Ñù‚â•0} (hr : r < 1) : Summable fun n : ‚Ñï ‚Ü¶ r ^ n :=\n  ‚ü®_, NNReal.hasSum_geometric hr‚ü©\n\n"}
{"name":"tsum_geometric_nnreal","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\n‚ä¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem tsum_geometric_nnreal {r : ‚Ñù‚â•0} (hr : r < 1) : ‚àë' n : ‚Ñï, r ^ n = (1 - r)‚Åª¬π :=\n  (NNReal.hasSum_geometric hr).tsum_eq\n\n"}
{"name":"ENNReal.tsum_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\n‚ä¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"/-- The series `pow r` converges to `(1-r)‚Åª¬π`. For `r < 1` the RHS is a finite number,\nand for `1 ‚â§ r` the RHS equals `‚àû`. -/\n@[simp]\ntheorem ENNReal.tsum_geometric (r : ‚Ñù‚â•0‚àû) : ‚àë' n : ‚Ñï, r ^ n = (1 - r)‚Åª¬π := by\n  cases' lt_or_le r 1 with hr hr\n  ¬∑ rcases ENNReal.lt_iff_exists_coe.1 hr with ‚ü®r, rfl, hr'‚ü©\n    norm_cast at *\n    convert ENNReal.tsum_coe_eq (NNReal.hasSum_geometric hr)\n    rw [ENNReal.coe_inv <| ne_of_gt <| tsub_pos_iff_lt.2 hr, coe_sub, coe_one]\n  ¬∑ rw [tsub_eq_zero_iff_le.mpr hr, ENNReal.inv_zero, ENNReal.tsum_eq_iSup_nat, iSup_eq_top]\n    refine fun a ha ‚Ü¶\n      (ENNReal.exists_nat_gt (lt_top_iff_ne_top.1 ha)).imp fun n hn ‚Ü¶ lt_of_lt_of_le hn ?_\n    calc\n      (n : ‚Ñù‚â•0‚àû) = ‚àë i ‚àà range n, 1 := by rw [sum_const, nsmul_one, card_range]\n      _ ‚â§ ‚àë i ‚àà range n, r ^ i := by gcongr; apply one_le_pow‚ÇÄ hr\n\n"}
{"name":"ENNReal.tsum_geometric_add_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\n‚ä¢ Eq (tsum fun n => HPow.hPow r (HAdd.hAdd n 1)) (HMul.hMul r (Inv.inv (HSub.hSub 1 r)))","decl":"theorem ENNReal.tsum_geometric_add_one (r : ‚Ñù‚â•0‚àû) : ‚àë' n : ‚Ñï, r ^ (n + 1) = r * (1 - r)‚Åª¬π := by\n  simp only [_root_.pow_succ', ENNReal.tsum_mul_left, ENNReal.tsum_geometric]\n\n"}
{"name":"cauchySeq_of_edist_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nr C : ENNReal\nhr : LT.lt r 1\nhC : Ne C Top.top\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq f","decl":"include hr hC hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `C ‚â† ‚àû`, `r < 1`,\nthen `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_geometric : CauchySeq f := by\n  refine cauchySeq_of_edist_le_of_tsum_ne_top _ hu ?_\n  rw [ENNReal.tsum_mul_left, ENNReal.tsum_geometric]\n  refine ENNReal.mul_ne_top hC (ENNReal.inv_ne_top.2 ?_)\n  exact (tsub_pos_iff_lt.2 hr).ne'\n\n"}
{"name":"edist_le_of_edist_le_geometric_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nr C : ENNReal\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\n‚ä¢ LE.le (EDist.edist (f n) a) (HDiv.hDiv (HMul.hMul C (HPow.hPow r n)) (HSub.hSub 1 r))","decl":"include hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/\ntheorem edist_le_of_edist_le_geometric_of_tendsto {a : Œ±} (ha : Tendsto f atTop (ùìù a)) (n : ‚Ñï) :\n    edist (f n) a ‚â§ C * r ^ n / (1 - r) := by\n  convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _\n  simp only [pow_add, ENNReal.tsum_mul_left, ENNReal.tsum_geometric, div_eq_mul_inv, mul_assoc]\n\n"}
{"name":"edist_le_of_edist_le_geometric_of_tendsto‚ÇÄ","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nr C : ENNReal\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\n‚ä¢ LE.le (EDist.edist (f 0) a) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"include hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/\ntheorem edist_le_of_edist_le_geometric_of_tendsto‚ÇÄ {a : Œ±} (ha : Tendsto f atTop (ùìù a)) :\n    edist (f 0) a ‚â§ C / (1 - r) := by\n  simpa only [_root_.pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0\n\n"}
{"name":"cauchySeq_of_edist_le_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nC : ENNReal\nhC : Ne C Top.top\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\n‚ä¢ CauchySeq f","decl":"include hC hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_geometric_two : CauchySeq f := by\n  simp only [div_eq_mul_inv, ENNReal.inv_pow] at hu\n  refine cauchySeq_of_edist_le_geometric 2‚Åª¬π C ?_ hC hu\n  simp [ENNReal.one_lt_two]\n\n"}
{"name":"edist_le_of_edist_le_geometric_two_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nC : ENNReal\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\n‚ä¢ LE.le (EDist.edist (f n) a) (HDiv.hDiv (HMul.hMul 2 C) (HPow.hPow 2 n))","decl":"include hu ha in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f n` to the limit of `f` is bounded above by `2 * C * 2^-n`. -/\ntheorem edist_le_of_edist_le_geometric_two_of_tendsto (n : ‚Ñï) : edist (f n) a ‚â§ 2 * C / 2 ^ n := by\n  simp only [div_eq_mul_inv, ENNReal.inv_pow] at *\n  rw [mul_assoc, mul_comm]\n  convert edist_le_of_edist_le_geometric_of_tendsto 2‚Åª¬π C hu ha n using 1\n  rw [ENNReal.one_sub_inv_two, div_eq_mul_inv, inv_inv]\n\n"}
{"name":"edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\nC : ENNReal\nf : Nat ‚Üí Œ±\nhu : ‚àÄ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\n‚ä¢ LE.le (EDist.edist (f 0) a) (HMul.hMul 2 C)","decl":"include hu ha in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `2 * C`. -/\ntheorem edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ : edist (f 0) a ‚â§ 2 * C := by\n  simpa only [_root_.pow_zero, div_eq_mul_inv, inv_one, mul_one] using\n    edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0\n\n"}
{"name":"aux_hasSum_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhu : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ HasSum (fun n => HMul.hMul C (HPow.hPow r n)) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence. -/\ntheorem aux_hasSum_of_le_geometric : HasSum (fun n : ‚Ñï ‚Ü¶ C * r ^ n) (C / (1 - r)) := by\n  rcases sign_cases_of_C_mul_pow_nonneg fun n ‚Ü¶ dist_nonneg.trans (hu n) with (rfl | ‚ü®_, r‚ÇÄ‚ü©)\n  ¬∑ simp [hasSum_zero]\n  ¬∑ refine HasSum.mul_left C ?_\n    simpa using hasSum_geometric_of_lt_one r‚ÇÄ hr\n\n"}
{"name":"cauchySeq_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhu : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\n‚ä¢ CauchySeq f","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence.\nNote that this lemma does not assume `0 ‚â§ C` or `0 ‚â§ r`. -/\ntheorem cauchySeq_of_le_geometric : CauchySeq f :=\n  cauchySeq_of_dist_le_of_summable _ hu ‚ü®_, aux_hasSum_of_le_geometric hr hu‚ü©\n\n"}
{"name":"dist_le_of_le_geometric_of_tendsto‚ÇÄ","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhu : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\n‚ä¢ LE.le (Dist.dist (f 0) a) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/\ntheorem dist_le_of_le_geometric_of_tendsto‚ÇÄ {a : Œ±} (ha : Tendsto f atTop (ùìù a)) :\n    dist (f 0) a ‚â§ C / (1 - r) :=\n  (aux_hasSum_of_le_geometric hr hu).tsum_eq ‚ñ∏\n    dist_le_tsum_of_dist_le_of_tendsto‚ÇÄ _ hu ‚ü®_, aux_hasSum_of_le_geometric hr hu‚ü© ha\n\n"}
{"name":"dist_le_of_le_geometric_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nr C : Real\nf : Nat ‚Üí Œ±\nhr : LT.lt r 1\nhu : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\n‚ä¢ LE.le (Dist.dist (f n) a) (HDiv.hDiv (HMul.hMul C (HPow.hPow r n)) (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/\ntheorem dist_le_of_le_geometric_of_tendsto {a : Œ±} (ha : Tendsto f atTop (ùìù a)) (n : ‚Ñï) :\n    dist (f n) a ‚â§ C * r ^ n / (1 - r) := by\n  have := aux_hasSum_of_le_geometric hr hu\n  convert dist_le_tsum_of_dist_le_of_tendsto _ hu ‚ü®_, this‚ü© ha n\n  simp only [pow_add, mul_left_comm C, mul_div_right_comm]\n  rw [mul_comm]\n  exact (this.mul_left _).tsum_eq.symm\n\n"}
{"name":"cauchySeq_of_le_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nC : Real\nf : Nat ‚Üí Œ±\nhu‚ÇÇ : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\n‚ä¢ CauchySeq f","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_le_geometric_two : CauchySeq f :=\n  cauchySeq_of_dist_le_of_summable _ hu‚ÇÇ <| ‚ü®_, hasSum_geometric_two' C‚ü©\n\n"}
{"name":"dist_le_of_le_geometric_two_of_tendsto‚ÇÄ","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nC : Real\nf : Nat ‚Üí Œ±\nhu‚ÇÇ : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\n‚ä¢ LE.le (Dist.dist (f 0) a) C","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C`. -/\ntheorem dist_le_of_le_geometric_two_of_tendsto‚ÇÄ {a : Œ±} (ha : Tendsto f atTop (ùìù a)) :\n    dist (f 0) a ‚â§ C :=\n  tsum_geometric_two' C ‚ñ∏ dist_le_tsum_of_dist_le_of_tendsto‚ÇÄ _ hu‚ÇÇ (summable_geometric_two' C) ha\n\n"}
{"name":"dist_le_of_le_geometric_two_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoMetricSpace Œ±\nC : Real\nf : Nat ‚Üí Œ±\nhu‚ÇÇ : ‚àÄ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\na : Œ±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\n‚ä¢ LE.le (Dist.dist (f n) a) (HDiv.hDiv C (HPow.hPow 2 n))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C / 2^n`. -/\ntheorem dist_le_of_le_geometric_two_of_tendsto {a : Œ±} (ha : Tendsto f atTop (ùìù a)) (n : ‚Ñï) :\n    dist (f n) a ‚â§ C / 2 ^ n := by\n  convert dist_le_tsum_of_dist_le_of_tendsto _ hu‚ÇÇ (summable_geometric_two' C) ha n\n  simp only [add_comm n, pow_add, ‚Üê div_div]\n  symm\n  exact ((hasSum_geometric_two' C).div_const _).tsum_eq\n\n"}
{"name":"summable_one_div_pow_of_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Real\nf : Nat ‚Üí Nat\nhm : LT.lt 1 m\nfi : ‚àÄ (i : Nat), LE.le i (f i)\n‚ä¢ Summable fun i => HDiv.hDiv 1 (HPow.hPow m (f i))","decl":"/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem summable_one_div_pow_of_le {m : ‚Ñù} {f : ‚Ñï ‚Üí ‚Ñï} (hm : 1 < m) (fi : ‚àÄ i, i ‚â§ f i) :\n    Summable fun i ‚Ü¶ 1 / m ^ f i := by\n  refine .of_nonneg_of_le (fun a ‚Ü¶ by positivity) (fun a ‚Ü¶ ?_)\n      (summable_geometric_of_lt_one (one_div_nonneg.mpr (zero_le_one.trans hm.le))\n        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))\n  rw [div_pow, one_pow]\n  refine (one_div_le_one_div ?_ ?_).mpr (pow_right_mono‚ÇÄ hm.le (fi a)) <;>\n    exact pow_pos (zero_lt_one.trans hm) _\n\n"}
{"name":"Set.Countable.exists_pos_hasSum_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œπ : Type u_4\ns : Set Œπ\nhs : s.Countable\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œµ' => And (‚àÄ (i : Œπ), LT.lt 0 (Œµ' i)) (Exists fun c => And (HasSum (fun i => Œµ' ‚Üëi) c) (LE.le c Œµ))","decl":"theorem Set.Countable.exists_pos_hasSum_le {Œπ : Type*} {s : Set Œπ} (hs : s.Countable) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) : ‚àÉ Œµ' : Œπ ‚Üí ‚Ñù, (‚àÄ i, 0 < Œµ' i) ‚àß ‚àÉ c, HasSum (fun i : s ‚Ü¶ Œµ' i) c ‚àß c ‚â§ Œµ := by\n  classical\n  haveI := hs.toEncodable\n  rcases posSumOfEncodable hŒµ s with ‚ü®f, hf0, ‚ü®c, hfc, hcŒµ‚ü©‚ü©\n  refine ‚ü®fun i ‚Ü¶ if h : i ‚àà s then f ‚ü®i, h‚ü© else 1, fun i ‚Ü¶ ?_, ‚ü®c, ?_, hcŒµ‚ü©‚ü©\n  ¬∑ conv_rhs => simp\n    split_ifs\n    exacts [hf0 _, zero_lt_one]\n  ¬∑ simpa only [Subtype.coe_prop, dif_pos, Subtype.coe_eta]\n\n"}
{"name":"Set.Countable.exists_pos_forall_sum_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œπ : Type u_4\ns : Set Œπ\nhs : s.Countable\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œµ' => And (‚àÄ (i : Œπ), LT.lt 0 (Œµ' i)) (‚àÄ (t : Finset Œπ), HasSubset.Subset (‚Üët) s ‚Üí LE.le (t.sum fun i => Œµ' i) Œµ)","decl":"theorem Set.Countable.exists_pos_forall_sum_le {Œπ : Type*} {s : Set Œπ} (hs : s.Countable) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) : ‚àÉ Œµ' : Œπ ‚Üí ‚Ñù,\n    (‚àÄ i, 0 < Œµ' i) ‚àß ‚àÄ t : Finset Œπ, ‚Üët ‚äÜ s ‚Üí ‚àë i ‚àà t, Œµ' i ‚â§ Œµ := by\n  classical\n  rcases hs.exists_pos_hasSum_le hŒµ with ‚ü®Œµ', hpos, c, hŒµ'c, hcŒµ‚ü©\n  refine ‚ü®Œµ', hpos, fun t ht ‚Ü¶ ?_‚ü©\n  rw [‚Üê sum_subtype_of_mem _ ht]\n  refine (sum_le_hasSum _ ?_ hŒµ'c).trans hcŒµ\n  exact fun _ _ ‚Ü¶ (hpos _).le\n\n"}
{"name":"NNReal.exists_pos_sum_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œµ : NNReal\nhŒµ : Ne Œµ 0\nŒπ : Type u_4\ninst‚úù : Countable Œπ\n‚ä¢ Exists fun Œµ' => And (‚àÄ (i : Œπ), LT.lt 0 (Œµ' i)) (Exists fun c => And (HasSum Œµ' c) (LT.lt c Œµ))","decl":"theorem exists_pos_sum_of_countable {Œµ : ‚Ñù‚â•0} (hŒµ : Œµ ‚â† 0) (Œπ) [Countable Œπ] :\n    ‚àÉ Œµ' : Œπ ‚Üí ‚Ñù‚â•0, (‚àÄ i, 0 < Œµ' i) ‚àß ‚àÉ c, HasSum Œµ' c ‚àß c < Œµ := by\n  cases nonempty_encodable Œπ\n  obtain ‚ü®a, a0, aŒµ‚ü© := exists_between (pos_iff_ne_zero.2 hŒµ)\n  obtain ‚ü®Œµ', hŒµ', c, hc, hcŒµ‚ü© := posSumOfEncodable a0 Œπ\n  exact\n    ‚ü®fun i ‚Ü¶ ‚ü®Œµ' i, (hŒµ' i).le‚ü©, fun i ‚Ü¶ NNReal.coe_lt_coe.1 <| hŒµ' i,\n      ‚ü®c, hasSum_le (fun i ‚Ü¶ (hŒµ' i).le) hasSum_zero hc‚ü©, NNReal.hasSum_coe.1 hc,\n      aŒµ.trans_le' <| NNReal.coe_le_coe.1 hcŒµ‚ü©\n\n"}
{"name":"ENNReal.exists_pos_sum_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œµ : ENNReal\nhŒµ : Ne Œµ 0\nŒπ : Type u_4\ninst‚úù : Countable Œπ\n‚ä¢ Exists fun Œµ' => And (‚àÄ (i : Œπ), LT.lt 0 (Œµ' i)) (LT.lt (tsum fun i => ‚Üë(Œµ' i)) Œµ)","decl":"theorem exists_pos_sum_of_countable {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) (Œπ) [Countable Œπ] :\n    ‚àÉ Œµ' : Œπ ‚Üí ‚Ñù‚â•0, (‚àÄ i, 0 < Œµ' i) ‚àß (‚àë' i, (Œµ' i : ‚Ñù‚â•0‚àû)) < Œµ := by\n  rcases exists_between (pos_iff_ne_zero.2 hŒµ) with ‚ü®r, h0r, hrŒµ‚ü©\n  rcases lt_iff_exists_coe.1 hrŒµ with ‚ü®x, rfl, _‚ü©\n  rcases NNReal.exists_pos_sum_of_countable (coe_pos.1 h0r).ne' Œπ with ‚ü®Œµ', hp, c, hc, hcr‚ü©\n  exact ‚ü®Œµ', hp, (ENNReal.tsum_coe_eq hc).symm ‚ñ∏ lt_trans (coe_lt_coe.2 hcr) hrŒµ‚ü©\n\n"}
{"name":"ENNReal.exists_pos_sum_of_countable'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œµ : ENNReal\nhŒµ : Ne Œµ 0\nŒπ : Type u_4\ninst‚úù : Countable Œπ\n‚ä¢ Exists fun Œµ' => And (‚àÄ (i : Œπ), LT.lt 0 (Œµ' i)) (LT.lt (tsum fun i => Œµ' i) Œµ)","decl":"theorem exists_pos_sum_of_countable' {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) (Œπ) [Countable Œπ] :\n    ‚àÉ Œµ' : Œπ ‚Üí ‚Ñù‚â•0‚àû, (‚àÄ i, 0 < Œµ' i) ‚àß ‚àë' i, Œµ' i < Œµ :=\n  let ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© := exists_pos_sum_of_countable hŒµ Œπ\n  ‚ü®fun i ‚Ü¶ Œ¥ i, fun i ‚Ü¶ ENNReal.coe_pos.2 (Œ¥pos i), hŒ¥‚ü©\n\n"}
{"name":"ENNReal.exists_pos_tsum_mul_lt_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œµ : ENNReal\nhŒµ : Ne Œµ 0\nŒπ : Type u_4\ninst‚úù : Countable Œπ\nw : Œπ ‚Üí ENNReal\nhw : ‚àÄ (i : Œπ), Ne (w i) Top.top\n‚ä¢ Exists fun Œ¥ => And (‚àÄ (i : Œπ), LT.lt 0 (Œ¥ i)) (LT.lt (tsum fun i => HMul.hMul (w i) ‚Üë(Œ¥ i)) Œµ)","decl":"theorem exists_pos_tsum_mul_lt_of_countable {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) {Œπ} [Countable Œπ] (w : Œπ ‚Üí ‚Ñù‚â•0‚àû)\n    (hw : ‚àÄ i, w i ‚â† ‚àû) : ‚àÉ Œ¥ : Œπ ‚Üí ‚Ñù‚â•0, (‚àÄ i, 0 < Œ¥ i) ‚àß (‚àë' i, (w i * Œ¥ i : ‚Ñù‚â•0‚àû)) < Œµ := by\n  lift w to Œπ ‚Üí ‚Ñù‚â•0 using hw\n  rcases exists_pos_sum_of_countable hŒµ Œπ with ‚ü®Œ¥', Hpos, Hsum‚ü©\n  have : ‚àÄ i, 0 < max 1 (w i) := fun i ‚Ü¶ zero_lt_one.trans_le (le_max_left _ _)\n  refine ‚ü®fun i ‚Ü¶ Œ¥' i / max 1 (w i), fun i ‚Ü¶ div_pos (Hpos _) (this i), ?_‚ü©\n  refine lt_of_le_of_lt (ENNReal.tsum_le_tsum fun i ‚Ü¶ ?_) Hsum\n  rw [coe_div (this i).ne']\n  refine mul_le_of_le_div' (mul_le_mul_left' (ENNReal.inv_le_inv.2 ?_) _)\n  exact coe_le_coe.2 (le_max_right _ _)\n\n"}
{"name":"factorial_tendsto_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto Nat.factorial Filter.atTop Filter.atTop","decl":"theorem factorial_tendsto_atTop : Tendsto Nat.factorial atTop atTop :=\n  tendsto_atTop_atTop_of_monotone (fun _ _ ‚Ü¶ Nat.factorial_le) fun n ‚Ü¶ ‚ü®n, n.self_le_factorial‚ü©\n\n"}
{"name":"tendsto_factorial_div_pow_self_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üën.factorial) (HPow.hPow (‚Üën) n)) Filter.atTop (nhds 0)","decl":"theorem tendsto_factorial_div_pow_self_atTop :\n    Tendsto (fun n ‚Ü¶ n ! / (n : ‚Ñù) ^ n : ‚Ñï ‚Üí ‚Ñù) atTop (ùìù 0) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n    (tendsto_const_div_atTop_nhds_zero_nat 1)\n    (Eventually.of_forall fun n ‚Ü¶\n      div_nonneg (mod_cast n.factorial_pos.le)\n        (pow_nonneg (mod_cast n.zero_le) _))\n    (by\n      refine (eventually_gt_atTop 0).mono fun n hn ‚Ü¶ ?_\n      rcases Nat.exists_eq_succ_of_ne_zero hn.ne.symm with ‚ü®k, rfl‚ü©\n      rw [‚Üê prod_range_add_one_eq_factorial, pow_eq_prod_const, div_eq_mul_inv, ‚Üê inv_eq_one_div,\n        prod_natCast, Nat.cast_succ, ‚Üê Finset.prod_inv_distrib, ‚Üê prod_mul_distrib,\n        Finset.prod_range_succ']\n      simp only [prod_range_succ', one_mul, Nat.cast_add, zero_add, Nat.cast_one]\n      refine\n            mul_le_of_le_one_left (inv_nonneg.mpr <| mod_cast hn.le) (prod_le_one ?_ ?_) <;>\n          intro x hx <;>\n        rw [Finset.mem_range] at hx\n      ¬∑ positivity\n      ¬∑ refine (div_le_one <| mod_cast hn).mpr ?_\n        norm_cast\n        omega)\n\n"}
{"name":"tendsto_nat_floor_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\ninst‚úù¬π : LinearOrderedSemiring Œ±\ninst‚úù : FloorSemiring Œ±\n‚ä¢ Filter.Tendsto (fun x => Nat.floor x) Filter.atTop Filter.atTop","decl":"theorem tendsto_nat_floor_atTop {Œ± : Type*} [LinearOrderedSemiring Œ±] [FloorSemiring Œ±] :\n    Tendsto (fun x : Œ± ‚Ü¶ ‚åäx‚åã‚Çä) atTop atTop :=\n  Nat.floor_mono.tendsto_atTop_atTop fun x ‚Ü¶ ‚ü®max 0 (x + 1), by simp [Nat.le_floor_iff]‚ü©\n\n"}
{"name":"tendsto_nat_ceil_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\ninst‚úù¬π : LinearOrderedSemiring Œ±\ninst‚úù : FloorSemiring Œ±\n‚ä¢ Filter.Tendsto (fun x => Nat.ceil x) Filter.atTop Filter.atTop","decl":"lemma tendsto_nat_ceil_atTop {Œ± : Type*} [LinearOrderedSemiring Œ±] [FloorSemiring Œ±] :\n    Tendsto (fun x : Œ± ‚Ü¶ ‚åàx‚åâ‚Çä) atTop atTop := by\n  refine Nat.ceil_mono.tendsto_atTop_atTop (fun x ‚Ü¶ ‚ü®x, ?_‚ü©)\n  simp only [Nat.ceil_natCast, le_refl]\n\n"}
{"name":"tendsto_nat_floor_mul_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Œ± : Type u_4\ninst‚úù¬≤ : LinearOrderedSemifield Œ±\ninst‚úù¬π : FloorSemiring Œ±\ninst‚úù : Archimedean Œ±\na : Œ±\nha : LT.lt 0 a\n‚ä¢ Filter.Tendsto (fun x => Nat.floor (HMul.hMul a ‚Üëx)) Filter.atTop Filter.atTop","decl":"lemma tendsto_nat_floor_mul_atTop {Œ± : Type _} [LinearOrderedSemifield Œ±] [FloorSemiring Œ±]\n    [Archimedean Œ±] (a : Œ±) (ha : 0 < a) : Tendsto (fun (x : ‚Ñï) => ‚åäa * x‚åã‚Çä) atTop atTop :=\n  Tendsto.comp tendsto_nat_floor_atTop\n    <| Tendsto.const_mul_atTop ha tendsto_natCast_atTop_atTop\n\n"}
{"name":"tendsto_nat_floor_mul_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninst‚úù¬≥ : TopologicalSpace R\ninst‚úù¬≤ : LinearOrderedField R\ninst‚úù¬π : OrderTopology R\ninst‚úù : FloorRing R\na : R\nha : LE.le 0 a\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (‚Üë(Nat.floor (HMul.hMul a x))) x) Filter.atTop (nhds a)","decl":"theorem tendsto_nat_floor_mul_div_atTop {a : R} (ha : 0 ‚â§ a) :\n    Tendsto (fun x ‚Ü¶ (‚åäa * x‚åã‚Çä : R) / x) atTop (ùìù a) := by\n  have A : Tendsto (fun x : R ‚Ü¶ a - x‚Åª¬π) atTop (ùìù (a - 0)) :=\n    tendsto_const_nhds.sub tendsto_inv_atTop_zero\n  rw [sub_zero] at A\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' A tendsto_const_nhds\n  ¬∑ refine eventually_atTop.2 ‚ü®1, fun x hx ‚Ü¶ ?_‚ü©\n    simp only [le_div_iff‚ÇÄ (zero_lt_one.trans_le hx), _root_.sub_mul,\n      inv_mul_cancel‚ÇÄ (zero_lt_one.trans_le hx).ne']\n    have := Nat.lt_floor_add_one (a * x)\n    linarith\n  ¬∑ refine eventually_atTop.2 ‚ü®1, fun x hx ‚Ü¶ ?_‚ü©\n    rw [div_le_iff‚ÇÄ (zero_lt_one.trans_le hx)]\n    simp [Nat.floor_le (mul_nonneg ha (zero_le_one.trans hx))]\n\n"}
{"name":"tendsto_nat_floor_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninst‚úù¬≥ : TopologicalSpace R\ninst‚úù¬≤ : LinearOrderedField R\ninst‚úù¬π : OrderTopology R\ninst‚úù : FloorRing R\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (‚Üë(Nat.floor x)) x) Filter.atTop (nhds 1)","decl":"theorem tendsto_nat_floor_div_atTop : Tendsto (fun x ‚Ü¶ (‚åäx‚åã‚Çä : R) / x) atTop (ùìù 1) := by\n  simpa using tendsto_nat_floor_mul_div_atTop (zero_le_one' R)\n\n"}
{"name":"tendsto_nat_ceil_mul_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninst‚úù¬≥ : TopologicalSpace R\ninst‚úù¬≤ : LinearOrderedField R\ninst‚úù¬π : OrderTopology R\ninst‚úù : FloorRing R\na : R\nha : LE.le 0 a\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (‚Üë(Nat.ceil (HMul.hMul a x))) x) Filter.atTop (nhds a)","decl":"theorem tendsto_nat_ceil_mul_div_atTop {a : R} (ha : 0 ‚â§ a) :\n    Tendsto (fun x ‚Ü¶ (‚åàa * x‚åâ‚Çä : R) / x) atTop (ùìù a) := by\n  have A : Tendsto (fun x : R ‚Ü¶ a + x‚Åª¬π) atTop (ùìù (a + 0)) :=\n    tendsto_const_nhds.add tendsto_inv_atTop_zero\n  rw [add_zero] at A\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds A\n  ¬∑ refine eventually_atTop.2 ‚ü®1, fun x hx ‚Ü¶ ?_‚ü©\n    rw [le_div_iff‚ÇÄ (zero_lt_one.trans_le hx)]\n    exact Nat.le_ceil _\n  ¬∑ refine eventually_atTop.2 ‚ü®1, fun x hx ‚Ü¶ ?_‚ü©\n    simp [div_le_iff‚ÇÄ (zero_lt_one.trans_le hx), inv_mul_cancel‚ÇÄ (zero_lt_one.trans_le hx).ne',\n      (Nat.ceil_lt_add_one (mul_nonneg ha (zero_le_one.trans hx))).le, add_mul]\n\n"}
{"name":"tendsto_nat_ceil_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninst‚úù¬≥ : TopologicalSpace R\ninst‚úù¬≤ : LinearOrderedField R\ninst‚úù¬π : OrderTopology R\ninst‚úù : FloorRing R\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (‚Üë(Nat.ceil x)) x) Filter.atTop (nhds 1)","decl":"theorem tendsto_nat_ceil_div_atTop : Tendsto (fun x ‚Ü¶ (‚åàx‚åâ‚Çä : R) / x) atTop (ùìù 1) := by\n  simpa using tendsto_nat_ceil_mul_div_atTop (zero_le_one' R)\n\n"}
{"name":"Nat.tendsto_div_const_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv x n) Filter.atTop Filter.atTop","decl":"lemma Nat.tendsto_div_const_atTop {n : ‚Ñï} (hn : n ‚â† 0) : Tendsto (¬∑ / n) atTop atTop := by\n  rw [Tendsto, map_div_atTop_eq_nat n hn.bot_lt]\n\n"}
