{"name":"tendsto_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto (fun n => Inv.inv â†‘n) Filter.atTop (nhds 0)","decl":"theorem tendsto_inverse_atTop_nhds_zero_nat : Tendsto (fun n : â„• â†¦ (n : â„)â»Â¹) atTop (ğ“ 0) :=\n  tendsto_inv_atTop_zero.comp tendsto_natCast_atTop_atTop\n\n"}
{"name":"tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : Real\nâŠ¢ Filter.Tendsto (fun n => HDiv.hDiv C â†‘n) Filter.atTop (nhds 0)","decl":"theorem tendsto_const_div_atTop_nhds_zero_nat (C : â„) :\n    Tendsto (fun n : â„• â†¦ C / n) atTop (ğ“ 0) := by\n  simpa only [mul_zero] using tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"tendsto_one_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto (fun n => HDiv.hDiv 1 â†‘n) Filter.atTop (nhds 0)","decl":"theorem tendsto_one_div_atTop_nhds_zero_nat : Tendsto (fun n : â„• â†¦ 1/(n : â„)) atTop (ğ“ 0) :=\n  tendsto_const_div_atTop_nhds_zero_nat 1\n\n"}
{"name":"NNReal.tendsto_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto (fun n => Inv.inv â†‘n) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_inverse_atTop_nhds_zero_nat :\n    Tendsto (fun n : â„• â†¦ (n : â„â‰¥0)â»Â¹) atTop (ğ“ 0) := by\n  rw [â† NNReal.tendsto_coe]\n  exact _root_.tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"NNReal.tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : NNReal\nâŠ¢ Filter.Tendsto (fun n => HDiv.hDiv C â†‘n) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_const_div_atTop_nhds_zero_nat (C : â„â‰¥0) :\n    Tendsto (fun n : â„• â†¦ C / n) atTop (ğ“ 0) := by\n  simpa using tendsto_const_nhds.mul NNReal.tendsto_inverse_atTop_nhds_zero_nat\n\n"}
{"name":"EReal.tendsto_const_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"C : EReal\nh : Ne C Bot.bot\nh' : Ne C Top.top\nâŠ¢ Filter.Tendsto (fun n => HDiv.hDiv C â†‘n) Filter.atTop (nhds 0)","decl":"theorem EReal.tendsto_const_div_atTop_nhds_zero_nat {C : EReal} (h : C â‰  âŠ¥) (h' : C â‰  âŠ¤) :\n    Tendsto (fun n : â„• â†¦ C / n) atTop (ğ“ 0) := by\n  have : (fun n : â„• â†¦ C / n) = fun n : â„• â†¦ ((C.toReal / n : â„) : EReal) := by\n    ext n\n    nth_rw 1 [â† coe_toReal h' h, â† coe_coe_eq_natCast n, â† coe_div C.toReal n]\n  rw [this, â† coe_zero, tendsto_coe]\n  exact _root_.tendsto_const_div_atTop_nhds_zero_nat C.toReal\n\n"}
{"name":"tendsto_one_div_add_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto (fun n => HDiv.hDiv 1 (HAdd.hAdd (â†‘n) 1)) Filter.atTop (nhds 0)","decl":"theorem tendsto_one_div_add_atTop_nhds_zero_nat :\n    Tendsto (fun n : â„• â†¦ 1 / ((n : â„) + 1)) atTop (ğ“ 0) :=\n  suffices Tendsto (fun n : â„• â†¦ 1 / (â†‘(n + 1) : â„)) atTop (ğ“ 0) by simpa\n  (tendsto_add_atTop_iff_nat 1).2 (_root_.tendsto_const_div_atTop_nhds_zero_nat 1)\n\n"}
{"name":"NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœÂ³ : Semiring ğ•œ\ninstâœÂ² : Algebra NNReal ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : ContinuousSMul NNReal ğ•œ\nâŠ¢ Filter.Tendsto (Function.comp â‡‘(algebraMap NNReal ğ•œ) fun n => Inv.inv â†‘n) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat (ğ•œ : Type*) [Semiring ğ•œ]\n    [Algebra â„â‰¥0 ğ•œ] [TopologicalSpace ğ•œ] [ContinuousSMul â„â‰¥0 ğ•œ] :\n    Tendsto (algebraMap â„â‰¥0 ğ•œ âˆ˜ fun n : â„• â†¦ (n : â„â‰¥0)â»Â¹) atTop (ğ“ 0) := by\n  convert (continuous_algebraMap â„â‰¥0 ğ•œ).continuousAt.tendsto.comp\n    tendsto_inverse_atTop_nhds_zero_nat\n  rw [map_zero]\n\n"}
{"name":"tendsto_algebraMap_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœÂ³ : Semiring ğ•œ\ninstâœÂ² : Algebra Real ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : ContinuousSMul Real ğ•œ\nâŠ¢ Filter.Tendsto (Function.comp â‡‘(algebraMap Real ğ•œ) fun n => Inv.inv â†‘n) Filter.atTop (nhds 0)","decl":"theorem tendsto_algebraMap_inverse_atTop_nhds_zero_nat (ğ•œ : Type*) [Semiring ğ•œ] [Algebra â„ ğ•œ]\n    [TopologicalSpace ğ•œ] [ContinuousSMul â„ ğ•œ] :\n    Tendsto (algebraMap â„ ğ•œ âˆ˜ fun n : â„• â†¦ (n : â„)â»Â¹) atTop (ğ“ 0) :=\n  NNReal.tendsto_algebraMap_inverse_atTop_nhds_zero_nat ğ•œ\n\n"}
{"name":"tendsto_natCast_div_add_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœâµ : DivisionRing ğ•œ\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : CharZero ğ•œ\ninstâœÂ² : Algebra Real ğ•œ\ninstâœÂ¹ : ContinuousSMul Real ğ•œ\ninstâœ : TopologicalDivisionRing ğ•œ\nx : ğ•œ\nâŠ¢ Filter.Tendsto (fun n => HDiv.hDiv (â†‘n) (HAdd.hAdd (â†‘n) x)) Filter.atTop (nhds 1)","decl":"/-- The limit of `n / (n + x)` is 1, for any constant `x` (valid in `â„` or any topological division\nalgebra over `â„`, e.g., `â„‚`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `â„š`, `â„` and `â„‚`. -/\ntheorem tendsto_natCast_div_add_atTop {ğ•œ : Type*} [DivisionRing ğ•œ] [TopologicalSpace ğ•œ]\n    [CharZero ğ•œ] [Algebra â„ ğ•œ] [ContinuousSMul â„ ğ•œ] [TopologicalDivisionRing ğ•œ] (x : ğ•œ) :\n    Tendsto (fun n : â„• â†¦ (n : ğ•œ) / (n + x)) atTop (ğ“ 1) := by\n  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn â†¦ _)) _\n  Â· exact fun n : â„• â†¦ 1 / (1 + x / n)\n  Â· field_simp [Nat.cast_ne_zero.mpr hn]\n  Â· have : ğ“ (1 : ğ•œ) = ğ“ (1 / (1 + x * (0 : ğ•œ))) := by\n      rw [mul_zero, add_zero, div_one]\n    rw [this]\n    refine tendsto_const_nhds.div (tendsto_const_nhds.add ?_) (by simp)\n    simp_rw [div_eq_mul_inv]\n    refine tendsto_const_nhds.mul ?_\n    have := ((continuous_algebraMap â„ ğ•œ).tendsto _).comp tendsto_inverse_atTop_nhds_zero_nat\n    rw [map_zero, Filter.tendsto_atTop'] at this\n    refine Iff.mpr tendsto_atTop' ?_\n    intros\n    simp_all only [comp_apply, map_invâ‚€, map_natCast]\n\n"}
{"name":"tendsto_mod_div_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Nat\nhm : LT.lt 0 m\nâŠ¢ Filter.Tendsto (fun n => HDiv.hDiv â†‘(HMod.hMod n m) â†‘n) Filter.atTop (nhds 0)","decl":"/-- For any positive `m : â„•`, `((n % m : â„•) : â„) / (n : â„)` tends to `0` as `n` tends to `âˆ`. -/\ntheorem tendsto_mod_div_atTop_nhds_zero_nat {m : â„•} (hm : 0 < m) :\n    Tendsto (fun n : â„• => ((n % m : â„•) : â„) / (n : â„)) atTop (ğ“ 0) := by\n  have h0 : âˆ€á¶  n : â„• in atTop, 0 â‰¤ (fun n : â„• => ((n % m : â„•) : â„)) n := by aesop\n  exact tendsto_bdd_div_atTop_nhds_zero h0\n    (.of_forall (fun n â†¦  cast_le.mpr (mod_lt n hm).le)) tendsto_natCast_atTop_atTop\n\n"}
{"name":"Filter.EventuallyEq.div_mul_cancel","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\nG : Type u_5\ninstâœ : GroupWithZero G\nf g : Î± â†’ G\nl : Filter Î±\nhg : Filter.Tendsto g l (Filter.principal (HasCompl.compl (Singleton.singleton 0)))\nâŠ¢ l.EventuallyEq (fun x => HMul.hMul (HDiv.hDiv (f x) (g x)) (g x)) fun x => f x","decl":"theorem Filter.EventuallyEq.div_mul_cancel {Î± G : Type*} [GroupWithZero G] {f g : Î± â†’ G}\n    {l : Filter Î±} (hg : Tendsto g l (ğ“Ÿ {0}á¶œ)) : (fun x â†¦ f x / g x * g x) =á¶ [l] fun x â†¦ f x := by\n  filter_upwards [hg.le_comap <| preimage_mem_comap (m := g) (mem_principal_self {0}á¶œ)] with x hx\n  aesop\n\n"}
{"name":"Filter.EventuallyEq.div_mul_cancel_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\nK : Type u_5\ninstâœ : LinearOrderedSemifield K\nf g : Î± â†’ K\nl : Filter Î±\nhg : Filter.Tendsto g l Filter.atTop\nâŠ¢ l.EventuallyEq (fun x => HMul.hMul (HDiv.hDiv (f x) (g x)) (g x)) fun x => f x","decl":"/-- If `g` tends to `âˆ`, then eventually for all `x` we have `(f x / g x) * g x = f x`. -/\ntheorem Filter.EventuallyEq.div_mul_cancel_atTop {Î± K : Type*} [LinearOrderedSemifield K]\n    {f g : Î± â†’ K} {l : Filter Î±} (hg : Tendsto g l atTop) :\n    (fun x â†¦ f x / g x * g x) =á¶ [l] fun x â†¦ f x :=\n  div_mul_cancel <| hg.mono_right <| le_principal_iff.mpr <|\n    mem_of_superset (Ioi_mem_atTop 0) <| by simp\n\n"}
{"name":"Tendsto.num","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\nK : Type u_5\ninstâœÂ² : LinearOrderedField K\ninstâœÂ¹ : TopologicalSpace K\ninstâœ : OrderTopology K\nf g : Î± â†’ K\nl : Filter Î±\nhg : Filter.Tendsto g l Filter.atTop\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\nâŠ¢ Filter.Tendsto f l Filter.atTop","decl":"/-- If when `x` tends to `âˆ`, `g` tends to `âˆ` and `f x / g x` tends to a positive\n  constant, then `f` tends to `âˆ`. -/\ntheorem Tendsto.num {Î± K : Type*} [LinearOrderedField K] [TopologicalSpace K] [OrderTopology K]\n    {f g : Î± â†’ K} {l : Filter Î±} (hg : Tendsto g l atTop) {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ğ“ a)) :\n    Tendsto f l atTop :=\n  Tendsto.congr' (EventuallyEq.div_mul_cancel_atTop hg) (Tendsto.mul_atTop ha hlim hg)\n\n"}
{"name":"Tendsto.den","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\nK : Type u_5\ninstâœÂ³ : LinearOrderedField K\ninstâœÂ² : TopologicalSpace K\ninstâœÂ¹ : OrderTopology K\ninstâœ : ContinuousInv K\nf g : Î± â†’ K\nl : Filter Î±\nhf : Filter.Tendsto f l Filter.atTop\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\nâŠ¢ Filter.Tendsto g l Filter.atTop","decl":"/-- If when `x` tends to `âˆ`, `g` tends to `âˆ` and `f x / g x` tends to a positive\n  constant, then `f` tends to `âˆ`. -/\ntheorem Tendsto.den {Î± K : Type*} [LinearOrderedField K] [TopologicalSpace K] [OrderTopology K]\n    [ContinuousInv K] {f g : Î± â†’ K} {l : Filter Î±} (hf : Tendsto f l atTop) {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ğ“ a)) :\n    Tendsto g l atTop := by\n  have hlim' : Tendsto (fun x => g x / f x) l (ğ“ aâ»Â¹) := by\n    simp_rw [â† inv_div (f _)]\n    exact Filter.Tendsto.inv (f := fun x => f x / g x) hlim\n  apply Tendsto.congr' (EventuallyEq.div_mul_cancel_atTop hf)\n    (Tendsto.mul_atTop (inv_pos_of_pos ha) hlim' hf)\n\n"}
{"name":"Tendsto.num_atTop_iff_den_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\nK : Type u_5\ninstâœÂ³ : LinearOrderedField K\ninstâœÂ² : TopologicalSpace K\ninstâœÂ¹ : OrderTopology K\ninstâœ : ContinuousInv K\nf g : Î± â†’ K\nl : Filter Î±\na : K\nha : LT.lt 0 a\nhlim : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds a)\nâŠ¢ Iff (Filter.Tendsto f l Filter.atTop) (Filter.Tendsto g l Filter.atTop)","decl":"/-- If when `x` tends to `âˆ`, `f x / g x` tends to a positive constant, then `f` tends to `âˆ` if\n  and only if `g` tends to `âˆ`. -/\ntheorem Tendsto.num_atTop_iff_den_atTop {Î± K : Type*} [LinearOrderedField K] [TopologicalSpace K]\n    [OrderTopology K] [ContinuousInv K] {f g : Î± â†’ K} {l : Filter Î±} {a : K} (ha : 0 < a)\n    (hlim : Tendsto (fun x => f x / g x) l (ğ“ a)) :\n    Tendsto f l atTop â†” Tendsto g l atTop :=\n  âŸ¨fun hf â†¦ Tendsto.den hf ha hlim, fun hg â†¦ Tendsto.num hg ha hlimâŸ©\n\n"}
{"name":"tendsto_add_one_pow_atTop_atTop_of_pos","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : LinearOrderedSemiring Î±\ninstâœ : Archimedean Î±\nr : Î±\nh : LT.lt 0 r\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow (HAdd.hAdd r 1) n) Filter.atTop Filter.atTop","decl":"theorem tendsto_add_one_pow_atTop_atTop_of_pos [LinearOrderedSemiring Î±] [Archimedean Î±] {r : Î±}\n    (h : 0 < r) : Tendsto (fun n : â„• â†¦ (r + 1) ^ n) atTop atTop :=\n  tendsto_atTop_atTop_of_monotone' (pow_right_monoâ‚€ <| le_add_of_nonneg_left h.le) <|\n    not_bddAbove_iff.2 fun _ â†¦ Set.exists_range_iff.2 <| add_one_pow_unbounded_of_pos _ h\n\n"}
{"name":"tendsto_pow_atTop_atTop_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : LinearOrderedRing Î±\ninstâœ : Archimedean Î±\nr : Î±\nh : LT.lt 1 r\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop Filter.atTop","decl":"theorem tendsto_pow_atTop_atTop_of_one_lt [LinearOrderedRing Î±] [Archimedean Î±] {r : Î±}\n    (h : 1 < r) : Tendsto (fun n : â„• â†¦ r ^ n) atTop atTop :=\n  sub_add_cancel r 1 â–¸ tendsto_add_one_pow_atTop_atTop_of_pos (sub_pos.2 h)\n\n"}
{"name":"Nat.tendsto_pow_atTop_atTop_of_one_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Nat\nh : LT.lt 1 m\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow m n) Filter.atTop Filter.atTop","decl":"theorem Nat.tendsto_pow_atTop_atTop_of_one_lt {m : â„•} (h : 1 < m) :\n    Tendsto (fun n : â„• â†¦ m ^ n) atTop atTop :=\n  tsub_add_cancel_of_le (le_of_lt h) â–¸ tendsto_add_one_pow_atTop_atTop_of_pos (tsub_pos_of_lt h)\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nr : ğ•œ\nhâ‚ : LE.le 0 r\nhâ‚‚ : LT.lt r 1\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_atTop_nhds_zero_of_lt_one {ğ•œ : Type*} [LinearOrderedField ğ•œ] [Archimedean ğ•œ]\n    [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {r : ğ•œ} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :\n    Tendsto (fun n : â„• â†¦ r ^ n) atTop (ğ“ 0) :=\n  hâ‚.eq_or_lt.elim\n    (fun hr â†¦ (tendsto_add_atTop_iff_nat 1).mp <| by\n      simp [_root_.pow_succ, â† hr, tendsto_const_nhds])\n    (fun hr â†¦\n      have := (one_lt_invâ‚€ hr).2 hâ‚‚ |> tendsto_pow_atTop_atTop_of_one_lt\n      (tendsto_inv_atTop_zero.comp this).congr fun n â†¦ by simp)\n\n"}
{"name":"tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nr : ğ•œ\nâŠ¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt (abs r) 1)","decl":"@[simp] theorem tendsto_pow_atTop_nhds_zero_iff {ğ•œ : Type*} [LinearOrderedField ğ•œ] [Archimedean ğ•œ]\n    [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {r : ğ•œ} :\n    Tendsto (fun n : â„• â†¦ r ^ n) atTop (ğ“ 0) â†” |r| < 1 := by\n  rw [tendsto_zero_iff_abs_tendsto_zero]\n  refine âŸ¨fun h â†¦ by_contra (fun hr_le â†¦ ?_), fun h â†¦ ?_âŸ©\n  Â· by_cases hr : 1 = |r|\n    Â· replace h : Tendsto (fun n : â„• â†¦ |r|^n) atTop (ğ“ 0) := by simpa only [â† abs_pow, h]\n      simp only [hr.symm, one_pow] at h\n      exact zero_ne_one <| tendsto_nhds_unique h tendsto_const_nhds\n    Â· apply @not_tendsto_nhds_of_tendsto_atTop ğ•œ â„• _ _ _ _ atTop _ (fun n â†¦ |r| ^ n) _ 0 _\n      Â· refine (pow_right_strictMonoâ‚€ <| lt_of_le_of_ne (le_of_not_lt hr_le)\n          hr).monotone.tendsto_atTop_atTop (fun b â†¦ ?_)\n        obtain âŸ¨n, hnâŸ© := (pow_unbounded_of_one_lt b (lt_of_le_of_ne (le_of_not_lt hr_le) hr))\n        exact âŸ¨n, le_of_lt hnâŸ©\n      Â· simpa only [â† abs_pow]\n  Â· simpa only [â† abs_pow] using (tendsto_pow_atTop_nhds_zero_of_lt_one (abs_nonneg r)) h\n\n"}
{"name":"tendsto_pow_atTop_nhdsWithin_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nr : ğ•œ\nhâ‚ : LT.lt 0 r\nhâ‚‚ : LT.lt r 1\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem tendsto_pow_atTop_nhdsWithin_zero_of_lt_one {ğ•œ : Type*} [LinearOrderedField ğ•œ]\n    [Archimedean ğ•œ] [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {r : ğ•œ} (hâ‚ : 0 < r) (hâ‚‚ : r < 1) :\n    Tendsto (fun n : â„• â†¦ r ^ n) atTop (ğ“[>] 0) :=\n  tendsto_inf.2\n    âŸ¨tendsto_pow_atTop_nhds_zero_of_lt_one hâ‚.le hâ‚‚,\n      tendsto_principal.2 <| Eventually.of_forall fun _ â†¦ pow_pos hâ‚ _âŸ©\n\n"}
{"name":"uniformity_basis_dist_pow_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\ninstâœ : PseudoMetricSpace Î±\nr : Real\nhâ‚€ : LT.lt 0 r\nhâ‚ : LT.lt r 1\nâŠ¢ (uniformity Î±).HasBasis (fun x => True) fun k => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HPow.hPow r k)","decl":"theorem uniformity_basis_dist_pow_of_lt_one {Î± : Type*} [PseudoMetricSpace Î±] {r : â„} (hâ‚€ : 0 < r)\n    (hâ‚ : r < 1) :\n    (uniformity Î±).HasBasis (fun _ : â„• â†¦ True) fun k â†¦ { p : Î± Ã— Î± | dist p.1 p.2 < r ^ k } :=\n  Metric.mk_uniformity_basis (fun _ _ â†¦ pow_pos hâ‚€ _) fun _ Îµ0 â†¦\n    (exists_pow_lt_of_lt_one Îµ0 hâ‚).imp fun _ hk â†¦ âŸ¨trivial, hk.leâŸ©\n\n"}
{"name":"geom_lt","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat â†’ Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nhn : LT.lt 0 n\nh : âˆ€ (k : Nat), LT.lt k n â†’ LT.lt (HMul.hMul c (u k)) (u (HAdd.hAdd k 1))\nâŠ¢ LT.lt (HMul.hMul (HPow.hPow c n) (u 0)) (u n)","decl":"theorem geom_lt {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) {n : â„•} (hn : 0 < n)\n    (h : âˆ€ k < n, c * u k < u (k + 1)) : c ^ n * u 0 < u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h\n  Â· simp\n  Â· simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"geom_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat â†’ Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nh : âˆ€ (k : Nat), LT.lt k n â†’ LE.le (HMul.hMul c (u k)) (u (HAdd.hAdd k 1))\nâŠ¢ LE.le (HMul.hMul (HPow.hPow c n) (u 0)) (u n)","decl":"theorem geom_le {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) (n : â„•) (h : âˆ€ k < n, c * u k â‰¤ u (k + 1)) :\n    c ^ n * u 0 â‰¤ u n := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"lt_geom","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat â†’ Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nhn : LT.lt 0 n\nh : âˆ€ (k : Nat), LT.lt k n â†’ LT.lt (u (HAdd.hAdd k 1)) (HMul.hMul c (u k))\nâŠ¢ LT.lt (u n) (HMul.hMul (HPow.hPow c n) (u 0))","decl":"theorem lt_geom {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) {n : â„•} (hn : 0 < n)\n    (h : âˆ€ k < n, u (k + 1) < c * u k) : u n < c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _\n  Â· simp\n  Â· simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"le_geom","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"u : Nat â†’ Real\nc : Real\nhc : LE.le 0 c\nn : Nat\nh : âˆ€ (k : Nat), LT.lt k n â†’ LE.le (u (HAdd.hAdd k 1)) (HMul.hMul c (u k))\nâŠ¢ LE.le (u n) (HMul.hMul (HPow.hPow c n) (u 0))","decl":"theorem le_geom {u : â„• â†’ â„} {c : â„} (hc : 0 â‰¤ c) (n : â„•) (h : âˆ€ k < n, u (k + 1) â‰¤ c * u k) :\n    u n â‰¤ c ^ n * u 0 := by\n  apply (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _ <;>\n    simp [_root_.pow_succ', mul_assoc, le_refl]\n\n"}
{"name":"tendsto_atTop_of_geom_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"v : Nat â†’ Real\nc : Real\nhâ‚€ : LT.lt 0 (v 0)\nhc : LT.lt 1 c\nhu : âˆ€ (n : Nat), LE.le (HMul.hMul c (v n)) (v (HAdd.hAdd n 1))\nâŠ¢ Filter.Tendsto v Filter.atTop Filter.atTop","decl":"/-- If a sequence `v` of real numbers satisfies `k * v n â‰¤ v (n+1)` with `1 < k`,\nthen it goes to +âˆ. -/\ntheorem tendsto_atTop_of_geom_le {v : â„• â†’ â„} {c : â„} (hâ‚€ : 0 < v 0) (hc : 1 < c)\n    (hu : âˆ€ n, c * v n â‰¤ v (n + 1)) : Tendsto v atTop atTop :=\n  (tendsto_atTop_mono fun n â†¦ geom_le (zero_le_one.trans hc.le) n fun k _ â†¦ hu k) <|\n    (tendsto_pow_atTop_atTop_of_one_lt hc).atTop_mul_const hâ‚€\n\n"}
{"name":"NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one {r : â„â‰¥0} (hr : r < 1) :\n    Tendsto (fun n : â„• â†¦ r ^ n) atTop (ğ“ 0) :=\n  NNReal.tendsto_coe.1 <| by\n    simp only [NNReal.coe_pow, NNReal.coe_zero,\n      _root_.tendsto_pow_atTop_nhds_zero_of_lt_one r.coe_nonneg hr]\n\n"}
{"name":"NNReal.tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nâŠ¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt r 1)","decl":"@[simp]\nprotected theorem NNReal.tendsto_pow_atTop_nhds_zero_iff {r : â„â‰¥0} :\n    Tendsto (fun n : â„• => r ^ n) atTop (ğ“ 0) â†” r < 1 :=\n  âŸ¨fun h => by simpa [coe_pow, coe_zero, abs_eq, coe_lt_one, val_eq_coe] using\n    tendsto_pow_atTop_nhds_zero_iff.mp <| tendsto_coe.mpr h, tendsto_pow_atTop_nhds_zero_of_lt_oneâŸ©\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nhr : LT.lt r 1\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)","decl":"theorem ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one {r : â„â‰¥0âˆ} (hr : r < 1) :\n    Tendsto (fun n : â„• â†¦ r ^ n) atTop (ğ“ 0) := by\n  rcases ENNReal.lt_iff_exists_coe.1 hr with âŸ¨r, rfl, hr'âŸ©\n  rw [â† ENNReal.coe_zero]\n  norm_cast at *\n  apply NNReal.tendsto_pow_atTop_nhds_zero_of_lt_one hr\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_zero_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nâŠ¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds 0)) (LT.lt r 1)","decl":"@[simp]\nprotected theorem ENNReal.tendsto_pow_atTop_nhds_zero_iff {r : â„â‰¥0âˆ} :\n    Tendsto (fun n : â„• => r ^ n) atTop (ğ“ 0) â†” r < 1 := by\n  refine âŸ¨fun h â†¦ ?_, tendsto_pow_atTop_nhds_zero_of_lt_oneâŸ©\n  lift r to NNReal\n  Â· refine fun hr â†¦ top_ne_zero (tendsto_nhds_unique (EventuallyEq.tendsto ?_) (hr â–¸ h))\n    exact eventually_atTop.mpr âŸ¨1, fun _ hn â†¦ pow_eq_top_iff.mpr âŸ¨rfl, Nat.pos_iff_ne_zero.mp hnâŸ©âŸ©\n  rw [â† coe_zero] at h\n  norm_cast at h âŠ¢\n  exact NNReal.tendsto_pow_atTop_nhds_zero_iff.mp h\n\n"}
{"name":"ENNReal.tendsto_pow_atTop_nhds_top_iff","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nâŠ¢ Iff (Filter.Tendsto (fun n => HPow.hPow r n) Filter.atTop (nhds Top.top)) (LT.lt 1 r)","decl":"@[simp]\nprotected theorem ENNReal.tendsto_pow_atTop_nhds_top_iff {r : â„â‰¥0âˆ} :\n    Tendsto (fun n â†¦ r^n) atTop (ğ“ âˆ) â†” 1 < r := by\n  refine âŸ¨?_, ?_âŸ©\n  Â· contrapose!\n    intro r_le_one h_tends\n    specialize h_tends (Ioi_mem_nhds one_lt_top)\n    simp only [Filter.mem_map, mem_atTop_sets, ge_iff_le, Set.mem_preimage, Set.mem_Ioi] at h_tends\n    obtain âŸ¨n, hnâŸ© := h_tends\n    exact lt_irrefl _ <| lt_of_lt_of_le (hn n le_rfl) <| pow_le_oneâ‚€ (zero_le _) r_le_one\n  Â· intro r_gt_one\n    have obs := @Tendsto.inv â„â‰¥0âˆ â„• _ _ _ (fun n â†¦ (râ»Â¹)^n) atTop 0\n    simp only [ENNReal.tendsto_pow_atTop_nhds_zero_iff, inv_zero] at obs\n    simpa [â† ENNReal.inv_pow] using obs <| ENNReal.inv_lt_one.mpr r_gt_one\n\n"}
{"name":"ENNReal.eq_zero_of_le_mul_pow","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"x r : ENNReal\nÎµ : NNReal\nhr : LT.lt r 1\nh : âˆ€ (n : Nat), LE.le x (HMul.hMul (â†‘Îµ) (HPow.hPow r n))\nâŠ¢ Eq x 0","decl":"lemma ENNReal.eq_zero_of_le_mul_pow {x r : â„â‰¥0âˆ} {Îµ : â„â‰¥0} (hr : r < 1)\n    (h : âˆ€ n : â„•, x â‰¤ Îµ * r ^ n) : x = 0 := by\n  rw [â† nonpos_iff_eq_zero]\n  refine ge_of_tendsto' (f := fun (n : â„•) â†¦ Îµ * r ^ n) (x := atTop) ?_ h\n  rw [â† mul_zero (Mâ‚€ := â„â‰¥0âˆ) (a := Îµ)]\n  exact Tendsto.const_mul (tendsto_pow_atTop_nhds_zero_of_lt_one hr) (Or.inr coe_ne_top)\n\n"}
{"name":"hasSum_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nhâ‚ : LE.le 0 r\nhâ‚‚ : LT.lt r 1\nâŠ¢ HasSum (fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem hasSum_geometric_of_lt_one {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :\n    HasSum (fun n : â„• â†¦ r ^ n) (1 - r)â»Â¹ :=\n  have : r â‰  1 := ne_of_lt hâ‚‚\n  have : Tendsto (fun n â†¦ (r ^ n - 1) * (r - 1)â»Â¹) atTop (ğ“ ((0 - 1) * (r - 1)â»Â¹)) :=\n    ((tendsto_pow_atTop_nhds_zero_of_lt_one hâ‚ hâ‚‚).sub tendsto_const_nhds).mul tendsto_const_nhds\n  (hasSum_iff_tendsto_nat_of_nonneg (pow_nonneg hâ‚) _).mpr <| by\n    simp_all [neg_inv, geom_sum_eq, div_eq_mul_inv]\n\n"}
{"name":"summable_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nhâ‚ : LE.le 0 r\nhâ‚‚ : LT.lt r 1\nâŠ¢ Summable fun n => HPow.hPow r n","decl":"theorem summable_geometric_of_lt_one {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) :\n    Summable fun n : â„• â†¦ r ^ n :=\n  âŸ¨_, hasSum_geometric_of_lt_one hâ‚ hâ‚‚âŸ©\n\n\n"}
{"name":"tsum_geometric_of_lt_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : Real\nhâ‚ : LE.le 0 r\nhâ‚‚ : LT.lt r 1\nâŠ¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem tsum_geometric_of_lt_one {r : â„} (hâ‚ : 0 â‰¤ r) (hâ‚‚ : r < 1) : âˆ‘' n : â„•, r ^ n = (1 - r)â»Â¹ :=\n  (hasSum_geometric_of_lt_one hâ‚ hâ‚‚).tsum_eq\n\n"}
{"name":"hasSum_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ HasSum (fun n => HPow.hPow (1 / 2) n) 2","decl":"theorem hasSum_geometric_two : HasSum (fun n : â„• â†¦ ((1 : â„) / 2) ^ n) 2 := by\n  convert hasSum_geometric_of_lt_one _ _ <;> norm_num\n\n"}
{"name":"summable_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Summable fun n => HPow.hPow (1 / 2) n","decl":"theorem summable_geometric_two : Summable fun n : â„• â†¦ ((1 : â„) / 2) ^ n :=\n  âŸ¨_, hasSum_geometric_twoâŸ©\n\n"}
{"name":"summable_geometric_two_encode","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î¹ : Type u_4\ninstâœ : Encodable Î¹\nâŠ¢ Summable fun i => HPow.hPow (1 / 2) (Encodable.encode i)","decl":"theorem summable_geometric_two_encode {Î¹ : Type*} [Encodable Î¹] :\n    Summable fun i : Î¹ â†¦ (1 / 2 : â„) ^ Encodable.encode i :=\n  summable_geometric_two.comp_injective Encodable.encode_injective\n\n"}
{"name":"tsum_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Eq (tsum fun n => HPow.hPow (1 / 2) n) 2","decl":"theorem tsum_geometric_two : (âˆ‘' n : â„•, ((1 : â„) / 2) ^ n) = 2 :=\n  hasSum_geometric_two.tsum_eq\n\n"}
{"name":"sum_geometric_two_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\nâŠ¢ LE.le ((Finset.range n).sum fun i => HPow.hPow (1 / 2) i) 2","decl":"theorem sum_geometric_two_le (n : â„•) : (âˆ‘ i âˆˆ range n, (1 / (2 : â„)) ^ i) â‰¤ 2 := by\n  have : âˆ€ i, 0 â‰¤ (1 / (2 : â„)) ^ i := by\n    intro i\n    apply pow_nonneg\n    norm_num\n  convert sum_le_tsum (range n) (fun i _ â†¦ this i) summable_geometric_two\n  exact tsum_geometric_two.symm\n\n"}
{"name":"tsum_geometric_inv_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Eq (tsum fun n => HPow.hPow (Inv.inv 2) n) 2","decl":"theorem tsum_geometric_inv_two : (âˆ‘' n : â„•, (2 : â„)â»Â¹ ^ n) = 2 :=\n  (inv_eq_one_div (2 : â„)).symm â–¸ tsum_geometric_two\n\n"}
{"name":"tsum_geometric_inv_two_ge","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\nâŠ¢ Eq (tsum fun i => ite (LE.le n i) (HPow.hPow (Inv.inv 2) i) 0) (HMul.hMul 2 (HPow.hPow (Inv.inv 2) n))","decl":"/-- The sum of `2â»Â¹ ^ i` for `n â‰¤ i` equals `2 * 2â»Â¹ ^ n`. -/\ntheorem tsum_geometric_inv_two_ge (n : â„•) :\n    (âˆ‘' i, ite (n â‰¤ i) ((2 : â„)â»Â¹ ^ i) 0) = 2 * 2â»Â¹ ^ n := by\n  have A : Summable fun i : â„• â†¦ ite (n â‰¤ i) ((2â»Â¹ : â„) ^ i) 0 := by\n    simpa only [â† piecewise_eq_indicator, one_div]\n      using summable_geometric_two.indicator {i | n â‰¤ i}\n  have B : ((Finset.range n).sum fun i : â„• â†¦ ite (n â‰¤ i) ((2â»Â¹ : â„) ^ i) 0) = 0 :=\n    Finset.sum_eq_zero fun i hi â†¦\n      ite_eq_right_iff.2 fun h â†¦ (lt_irrefl _ ((Finset.mem_range.1 hi).trans_le h)).elim\n  simp only [â† _root_.sum_add_tsum_nat_add n A, B, if_true, zero_add, zero_le',\n    le_add_iff_nonneg_left, pow_add, _root_.tsum_mul_right, tsum_geometric_inv_two]\n\n"}
{"name":"hasSum_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\nâŠ¢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)) a","decl":"theorem hasSum_geometric_two' (a : â„) : HasSum (fun n : â„• â†¦ a / 2 / 2 ^ n) a := by\n  convert HasSum.mul_left (a / 2)\n      (hasSum_geometric_of_lt_one (le_of_lt one_half_pos) one_half_lt_one) using 1\n  Â· funext n\n    simp only [one_div, inv_pow]\n    rfl\n  Â· norm_num\n\n"}
{"name":"summable_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\nâŠ¢ Summable fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)","decl":"theorem summable_geometric_two' (a : â„) : Summable fun n : â„• â†¦ a / 2 / 2 ^ n :=\n  âŸ¨a, hasSum_geometric_two' aâŸ©\n\n"}
{"name":"tsum_geometric_two'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"a : Real\nâŠ¢ Eq (tsum fun n => HDiv.hDiv (HDiv.hDiv a 2) (HPow.hPow 2 n)) a","decl":"theorem tsum_geometric_two' (a : â„) : âˆ‘' n : â„•, a / 2 / 2 ^ n = a :=\n  (hasSum_geometric_two' a).tsum_eq\n\n"}
{"name":"NNReal.hasSum_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\nâŠ¢ HasSum (fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"/-- **Sum of a Geometric Series** -/\ntheorem NNReal.hasSum_geometric {r : â„â‰¥0} (hr : r < 1) : HasSum (fun n : â„• â†¦ r ^ n) (1 - r)â»Â¹ := by\n  apply NNReal.hasSum_coe.1\n  push_cast\n  rw [NNReal.coe_sub (le_of_lt hr)]\n  exact hasSum_geometric_of_lt_one r.coe_nonneg hr\n\n"}
{"name":"NNReal.summable_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\nâŠ¢ Summable fun n => HPow.hPow r n","decl":"theorem NNReal.summable_geometric {r : â„â‰¥0} (hr : r < 1) : Summable fun n : â„• â†¦ r ^ n :=\n  âŸ¨_, NNReal.hasSum_geometric hrâŸ©\n\n"}
{"name":"tsum_geometric_nnreal","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : NNReal\nhr : LT.lt r 1\nâŠ¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"theorem tsum_geometric_nnreal {r : â„â‰¥0} (hr : r < 1) : âˆ‘' n : â„•, r ^ n = (1 - r)â»Â¹ :=\n  (NNReal.hasSum_geometric hr).tsum_eq\n\n"}
{"name":"ENNReal.tsum_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nâŠ¢ Eq (tsum fun n => HPow.hPow r n) (Inv.inv (HSub.hSub 1 r))","decl":"/-- The series `pow r` converges to `(1-r)â»Â¹`. For `r < 1` the RHS is a finite number,\nand for `1 â‰¤ r` the RHS equals `âˆ`. -/\n@[simp]\ntheorem ENNReal.tsum_geometric (r : â„â‰¥0âˆ) : âˆ‘' n : â„•, r ^ n = (1 - r)â»Â¹ := by\n  cases' lt_or_le r 1 with hr hr\n  Â· rcases ENNReal.lt_iff_exists_coe.1 hr with âŸ¨r, rfl, hr'âŸ©\n    norm_cast at *\n    convert ENNReal.tsum_coe_eq (NNReal.hasSum_geometric hr)\n    rw [ENNReal.coe_inv <| ne_of_gt <| tsub_pos_iff_lt.2 hr, coe_sub, coe_one]\n  Â· rw [tsub_eq_zero_iff_le.mpr hr, ENNReal.inv_zero, ENNReal.tsum_eq_iSup_nat, iSup_eq_top]\n    refine fun a ha â†¦\n      (ENNReal.exists_nat_gt (lt_top_iff_ne_top.1 ha)).imp fun n hn â†¦ lt_of_lt_of_le hn ?_\n    calc\n      (n : â„â‰¥0âˆ) = âˆ‘ i âˆˆ range n, 1 := by rw [sum_const, nsmul_one, card_range]\n      _ â‰¤ âˆ‘ i âˆˆ range n, r ^ i := by gcongr; apply one_le_powâ‚€ hr\n\n"}
{"name":"ENNReal.tsum_geometric_add_one","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"r : ENNReal\nâŠ¢ Eq (tsum fun n => HPow.hPow r (HAdd.hAdd n 1)) (HMul.hMul r (Inv.inv (HSub.hSub 1 r)))","decl":"theorem ENNReal.tsum_geometric_add_one (r : â„â‰¥0âˆ) : âˆ‘' n : â„•, r ^ (n + 1) = r * (1 - r)â»Â¹ := by\n  simp only [_root_.pow_succ', ENNReal.tsum_mul_left, ENNReal.tsum_geometric]\n\n"}
{"name":"cauchySeq_of_edist_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nr C : ENNReal\nhr : LT.lt r 1\nhC : Ne C Top.top\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\nâŠ¢ CauchySeq f","decl":"include hr hC hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `C â‰  âˆ`, `r < 1`,\nthen `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_geometric : CauchySeq f := by\n  refine cauchySeq_of_edist_le_of_tsum_ne_top _ hu ?_\n  rw [ENNReal.tsum_mul_left, ENNReal.tsum_geometric]\n  refine ENNReal.mul_ne_top hC (ENNReal.inv_ne_top.2 ?_)\n  exact (tsub_pos_iff_lt.2 hr).ne'\n\n"}
{"name":"edist_le_of_edist_le_geometric_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nr C : ENNReal\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\nâŠ¢ LE.le (EDist.edist (f n) a) (HDiv.hDiv (HMul.hMul C (HPow.hPow r n)) (HSub.hSub 1 r))","decl":"include hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/\ntheorem edist_le_of_edist_le_geometric_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :\n    edist (f n) a â‰¤ C * r ^ n / (1 - r) := by\n  convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _\n  simp only [pow_add, ENNReal.tsum_mul_left, ENNReal.tsum_geometric, div_eq_mul_inv, mul_assoc]\n\n"}
{"name":"edist_le_of_edist_le_geometric_of_tendstoâ‚€","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nr C : ENNReal\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nâŠ¢ LE.le (EDist.edist (f 0) a) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"include hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/\ntheorem edist_le_of_edist_le_geometric_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :\n    edist (f 0) a â‰¤ C / (1 - r) := by\n  simpa only [_root_.pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0\n\n"}
{"name":"cauchySeq_of_edist_le_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nC : ENNReal\nhC : Ne C Top.top\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\nâŠ¢ CauchySeq f","decl":"include hC hu in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_geometric_two : CauchySeq f := by\n  simp only [div_eq_mul_inv, ENNReal.inv_pow] at hu\n  refine cauchySeq_of_edist_le_geometric 2â»Â¹ C ?_ hC hu\n  simp [ENNReal.one_lt_two]\n\n"}
{"name":"edist_le_of_edist_le_geometric_two_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nC : ENNReal\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\nâŠ¢ LE.le (EDist.edist (f n) a) (HDiv.hDiv (HMul.hMul 2 C) (HPow.hPow 2 n))","decl":"include hu ha in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f n` to the limit of `f` is bounded above by `2 * C * 2^-n`. -/\ntheorem edist_le_of_edist_le_geometric_two_of_tendsto (n : â„•) : edist (f n) a â‰¤ 2 * C / 2 ^ n := by\n  simp only [div_eq_mul_inv, ENNReal.inv_pow] at *\n  rw [mul_assoc, mul_comm]\n  convert edist_le_of_edist_le_geometric_of_tendsto 2â»Â¹ C hu ha n using 1\n  rw [ENNReal.one_sub_inv_two, div_eq_mul_inv, inv_inv]\n\n"}
{"name":"edist_le_of_edist_le_geometric_two_of_tendstoâ‚€","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nC : ENNReal\nf : Nat â†’ Î±\nhu : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv C (HPow.hPow 2 n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nâŠ¢ LE.le (EDist.edist (f 0) a) (HMul.hMul 2 C)","decl":"include hu ha in\n/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `2 * C`. -/\ntheorem edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ : edist (f 0) a â‰¤ 2 * C := by\n  simpa only [_root_.pow_zero, div_eq_mul_inv, inv_one, mul_one] using\n    edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0\n\n"}
{"name":"aux_hasSum_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nr C : Real\nf : Nat â†’ Î±\nhr : LT.lt r 1\nhu : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\nâŠ¢ HasSum (fun n => HMul.hMul C (HPow.hPow r n)) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence. -/\ntheorem aux_hasSum_of_le_geometric : HasSum (fun n : â„• â†¦ C * r ^ n) (C / (1 - r)) := by\n  rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ dist_nonneg.trans (hu n) with (rfl | âŸ¨_, râ‚€âŸ©)\n  Â· simp [hasSum_zero]\n  Â· refine HasSum.mul_left C ?_\n    simpa using hasSum_geometric_of_lt_one râ‚€ hr\n\n"}
{"name":"cauchySeq_of_le_geometric","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nr C : Real\nf : Nat â†’ Î±\nhr : LT.lt r 1\nhu : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\nâŠ¢ CauchySeq f","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence.\nNote that this lemma does not assume `0 â‰¤ C` or `0 â‰¤ r`. -/\ntheorem cauchySeq_of_le_geometric : CauchySeq f :=\n  cauchySeq_of_dist_le_of_summable _ hu âŸ¨_, aux_hasSum_of_le_geometric hr huâŸ©\n\n"}
{"name":"dist_le_of_le_geometric_of_tendstoâ‚€","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nr C : Real\nf : Nat â†’ Î±\nhr : LT.lt r 1\nhu : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nâŠ¢ LE.le (Dist.dist (f 0) a) (HDiv.hDiv C (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/\ntheorem dist_le_of_le_geometric_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :\n    dist (f 0) a â‰¤ C / (1 - r) :=\n  (aux_hasSum_of_le_geometric hr hu).tsum_eq â–¸\n    dist_le_tsum_of_dist_le_of_tendstoâ‚€ _ hu âŸ¨_, aux_hasSum_of_le_geometric hr huâŸ© ha\n\n"}
{"name":"dist_le_of_le_geometric_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nr C : Real\nf : Nat â†’ Î±\nhr : LT.lt r 1\nhu : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HMul.hMul C (HPow.hPow r n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\nâŠ¢ LE.le (Dist.dist (f n) a) (HDiv.hDiv (HMul.hMul C (HPow.hPow r n)) (HSub.hSub 1 r))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/\ntheorem dist_le_of_le_geometric_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :\n    dist (f n) a â‰¤ C * r ^ n / (1 - r) := by\n  have := aux_hasSum_of_le_geometric hr hu\n  convert dist_le_tsum_of_dist_le_of_tendsto _ hu âŸ¨_, thisâŸ© ha n\n  simp only [pow_add, mul_left_comm C, mul_div_right_comm]\n  rw [mul_comm]\n  exact (this.mul_left _).tsum_eq.symm\n\n"}
{"name":"cauchySeq_of_le_geometric_two","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nC : Real\nf : Nat â†’ Î±\nhuâ‚‚ : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\nâŠ¢ CauchySeq f","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem cauchySeq_of_le_geometric_two : CauchySeq f :=\n  cauchySeq_of_dist_le_of_summable _ huâ‚‚ <| âŸ¨_, hasSum_geometric_two' CâŸ©\n\n"}
{"name":"dist_le_of_le_geometric_two_of_tendstoâ‚€","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nC : Real\nf : Nat â†’ Î±\nhuâ‚‚ : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nâŠ¢ LE.le (Dist.dist (f 0) a) C","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C`. -/\ntheorem dist_le_of_le_geometric_two_of_tendstoâ‚€ {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :\n    dist (f 0) a â‰¤ C :=\n  tsum_geometric_two' C â–¸ dist_le_tsum_of_dist_le_of_tendstoâ‚€ _ huâ‚‚ (summable_geometric_two' C) ha\n\n"}
{"name":"dist_le_of_le_geometric_two_of_tendsto","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_1\ninstâœ : PseudoMetricSpace Î±\nC : Real\nf : Nat â†’ Î±\nhuâ‚‚ : âˆ€ (n : Nat), LE.le (Dist.dist (f n) (f (HAdd.hAdd n 1))) (HDiv.hDiv (HDiv.hDiv C 2) (HPow.hPow 2 n))\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\nâŠ¢ LE.le (Dist.dist (f n) a) (HDiv.hDiv C (HPow.hPow 2 n))","decl":"/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C / 2^n`. -/\ntheorem dist_le_of_le_geometric_two_of_tendsto {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :\n    dist (f n) a â‰¤ C / 2 ^ n := by\n  convert dist_le_tsum_of_dist_le_of_tendsto _ huâ‚‚ (summable_geometric_two' C) ha n\n  simp only [add_comm n, pow_add, â† div_div]\n  symm\n  exact ((hasSum_geometric_two' C).div_const _).tsum_eq\n\n"}
{"name":"summable_one_div_pow_of_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"m : Real\nf : Nat â†’ Nat\nhm : LT.lt 1 m\nfi : âˆ€ (i : Nat), LE.le i (f i)\nâŠ¢ Summable fun i => HDiv.hDiv 1 (HPow.hPow m (f i))","decl":"/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem summable_one_div_pow_of_le {m : â„} {f : â„• â†’ â„•} (hm : 1 < m) (fi : âˆ€ i, i â‰¤ f i) :\n    Summable fun i â†¦ 1 / m ^ f i := by\n  refine .of_nonneg_of_le (fun a â†¦ by positivity) (fun a â†¦ ?_)\n      (summable_geometric_of_lt_one (one_div_nonneg.mpr (zero_le_one.trans hm.le))\n        ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))\n  rw [div_pow, one_pow]\n  refine (one_div_le_one_div ?_ ?_).mpr (pow_right_monoâ‚€ hm.le (fi a)) <;>\n    exact pow_pos (zero_lt_one.trans hm) _\n\n"}
{"name":"Set.Countable.exists_pos_hasSum_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î¹ : Type u_4\ns : Set Î¹\nhs : s.Countable\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Exists fun Îµ' => And (âˆ€ (i : Î¹), LT.lt 0 (Îµ' i)) (Exists fun c => And (HasSum (fun i => Îµ' â†‘i) c) (LE.le c Îµ))","decl":"theorem Set.Countable.exists_pos_hasSum_le {Î¹ : Type*} {s : Set Î¹} (hs : s.Countable) {Îµ : â„}\n    (hÎµ : 0 < Îµ) : âˆƒ Îµ' : Î¹ â†’ â„, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆƒ c, HasSum (fun i : s â†¦ Îµ' i) c âˆ§ c â‰¤ Îµ := by\n  classical\n  haveI := hs.toEncodable\n  rcases posSumOfEncodable hÎµ s with âŸ¨f, hf0, âŸ¨c, hfc, hcÎµâŸ©âŸ©\n  refine âŸ¨fun i â†¦ if h : i âˆˆ s then f âŸ¨i, hâŸ© else 1, fun i â†¦ ?_, âŸ¨c, ?_, hcÎµâŸ©âŸ©\n  Â· conv_rhs => simp\n    split_ifs\n    exacts [hf0 _, zero_lt_one]\n  Â· simpa only [Subtype.coe_prop, dif_pos, Subtype.coe_eta]\n\n"}
{"name":"Set.Countable.exists_pos_forall_sum_le","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î¹ : Type u_4\ns : Set Î¹\nhs : s.Countable\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Exists fun Îµ' => And (âˆ€ (i : Î¹), LT.lt 0 (Îµ' i)) (âˆ€ (t : Finset Î¹), HasSubset.Subset (â†‘t) s â†’ LE.le (t.sum fun i => Îµ' i) Îµ)","decl":"theorem Set.Countable.exists_pos_forall_sum_le {Î¹ : Type*} {s : Set Î¹} (hs : s.Countable) {Îµ : â„}\n    (hÎµ : 0 < Îµ) : âˆƒ Îµ' : Î¹ â†’ â„,\n    (âˆ€ i, 0 < Îµ' i) âˆ§ âˆ€ t : Finset Î¹, â†‘t âŠ† s â†’ âˆ‘ i âˆˆ t, Îµ' i â‰¤ Îµ := by\n  classical\n  rcases hs.exists_pos_hasSum_le hÎµ with âŸ¨Îµ', hpos, c, hÎµ'c, hcÎµâŸ©\n  refine âŸ¨Îµ', hpos, fun t ht â†¦ ?_âŸ©\n  rw [â† sum_subtype_of_mem _ ht]\n  refine (sum_le_hasSum _ ?_ hÎµ'c).trans hcÎµ\n  exact fun _ _ â†¦ (hpos _).le\n\n"}
{"name":"NNReal.exists_pos_sum_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Îµ : NNReal\nhÎµ : Ne Îµ 0\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nâŠ¢ Exists fun Îµ' => And (âˆ€ (i : Î¹), LT.lt 0 (Îµ' i)) (Exists fun c => And (HasSum Îµ' c) (LT.lt c Îµ))","decl":"theorem exists_pos_sum_of_countable {Îµ : â„â‰¥0} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :\n    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆƒ c, HasSum Îµ' c âˆ§ c < Îµ := by\n  cases nonempty_encodable Î¹\n  obtain âŸ¨a, a0, aÎµâŸ© := exists_between (pos_iff_ne_zero.2 hÎµ)\n  obtain âŸ¨Îµ', hÎµ', c, hc, hcÎµâŸ© := posSumOfEncodable a0 Î¹\n  exact\n    âŸ¨fun i â†¦ âŸ¨Îµ' i, (hÎµ' i).leâŸ©, fun i â†¦ NNReal.coe_lt_coe.1 <| hÎµ' i,\n      âŸ¨c, hasSum_le (fun i â†¦ (hÎµ' i).le) hasSum_zero hcâŸ©, NNReal.hasSum_coe.1 hc,\n      aÎµ.trans_le' <| NNReal.coe_le_coe.1 hcÎµâŸ©\n\n"}
{"name":"ENNReal.exists_pos_sum_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Îµ : ENNReal\nhÎµ : Ne Îµ 0\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nâŠ¢ Exists fun Îµ' => And (âˆ€ (i : Î¹), LT.lt 0 (Îµ' i)) (LT.lt (tsum fun i => â†‘(Îµ' i)) Îµ)","decl":"theorem exists_pos_sum_of_countable {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :\n    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Îµ' i) âˆ§ (âˆ‘' i, (Îµ' i : â„â‰¥0âˆ)) < Îµ := by\n  rcases exists_between (pos_iff_ne_zero.2 hÎµ) with âŸ¨r, h0r, hrÎµâŸ©\n  rcases lt_iff_exists_coe.1 hrÎµ with âŸ¨x, rfl, _âŸ©\n  rcases NNReal.exists_pos_sum_of_countable (coe_pos.1 h0r).ne' Î¹ with âŸ¨Îµ', hp, c, hc, hcrâŸ©\n  exact âŸ¨Îµ', hp, (ENNReal.tsum_coe_eq hc).symm â–¸ lt_trans (coe_lt_coe.2 hcr) hrÎµâŸ©\n\n"}
{"name":"ENNReal.exists_pos_sum_of_countable'","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Îµ : ENNReal\nhÎµ : Ne Îµ 0\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nâŠ¢ Exists fun Îµ' => And (âˆ€ (i : Î¹), LT.lt 0 (Îµ' i)) (LT.lt (tsum fun i => Îµ' i) Îµ)","decl":"theorem exists_pos_sum_of_countable' {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (Î¹) [Countable Î¹] :\n    âˆƒ Îµ' : Î¹ â†’ â„â‰¥0âˆ, (âˆ€ i, 0 < Îµ' i) âˆ§ âˆ‘' i, Îµ' i < Îµ :=\n  let âŸ¨Î´, Î´pos, hÎ´âŸ© := exists_pos_sum_of_countable hÎµ Î¹\n  âŸ¨fun i â†¦ Î´ i, fun i â†¦ ENNReal.coe_pos.2 (Î´pos i), hÎ´âŸ©\n\n"}
{"name":"ENNReal.exists_pos_tsum_mul_lt_of_countable","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Îµ : ENNReal\nhÎµ : Ne Îµ 0\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nw : Î¹ â†’ ENNReal\nhw : âˆ€ (i : Î¹), Ne (w i) Top.top\nâŠ¢ Exists fun Î´ => And (âˆ€ (i : Î¹), LT.lt 0 (Î´ i)) (LT.lt (tsum fun i => HMul.hMul (w i) â†‘(Î´ i)) Îµ)","decl":"theorem exists_pos_tsum_mul_lt_of_countable {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) {Î¹} [Countable Î¹] (w : Î¹ â†’ â„â‰¥0âˆ)\n    (hw : âˆ€ i, w i â‰  âˆ) : âˆƒ Î´ : Î¹ â†’ â„â‰¥0, (âˆ€ i, 0 < Î´ i) âˆ§ (âˆ‘' i, (w i * Î´ i : â„â‰¥0âˆ)) < Îµ := by\n  lift w to Î¹ â†’ â„â‰¥0 using hw\n  rcases exists_pos_sum_of_countable hÎµ Î¹ with âŸ¨Î´', Hpos, HsumâŸ©\n  have : âˆ€ i, 0 < max 1 (w i) := fun i â†¦ zero_lt_one.trans_le (le_max_left _ _)\n  refine âŸ¨fun i â†¦ Î´' i / max 1 (w i), fun i â†¦ div_pos (Hpos _) (this i), ?_âŸ©\n  refine lt_of_le_of_lt (ENNReal.tsum_le_tsum fun i â†¦ ?_) Hsum\n  rw [coe_div (this i).ne']\n  refine mul_le_of_le_div' (mul_le_mul_left' (ENNReal.inv_le_inv.2 ?_) _)\n  exact coe_le_coe.2 (le_max_right _ _)\n\n"}
{"name":"factorial_tendsto_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto Nat.factorial Filter.atTop Filter.atTop","decl":"theorem factorial_tendsto_atTop : Tendsto Nat.factorial atTop atTop :=\n  tendsto_atTop_atTop_of_monotone (fun _ _ â†¦ Nat.factorial_le) fun n â†¦ âŸ¨n, n.self_le_factorialâŸ©\n\n"}
{"name":"tendsto_factorial_div_pow_self_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"âŠ¢ Filter.Tendsto (fun n => HDiv.hDiv (â†‘n.factorial) (HPow.hPow (â†‘n) n)) Filter.atTop (nhds 0)","decl":"theorem tendsto_factorial_div_pow_self_atTop :\n    Tendsto (fun n â†¦ n ! / (n : â„) ^ n : â„• â†’ â„) atTop (ğ“ 0) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n    (tendsto_const_div_atTop_nhds_zero_nat 1)\n    (Eventually.of_forall fun n â†¦\n      div_nonneg (mod_cast n.factorial_pos.le)\n        (pow_nonneg (mod_cast n.zero_le) _))\n    (by\n      refine (eventually_gt_atTop 0).mono fun n hn â†¦ ?_\n      rcases Nat.exists_eq_succ_of_ne_zero hn.ne.symm with âŸ¨k, rflâŸ©\n      rw [â† prod_range_add_one_eq_factorial, pow_eq_prod_const, div_eq_mul_inv, â† inv_eq_one_div,\n        prod_natCast, Nat.cast_succ, â† Finset.prod_inv_distrib, â† prod_mul_distrib,\n        Finset.prod_range_succ']\n      simp only [prod_range_succ', one_mul, Nat.cast_add, zero_add, Nat.cast_one]\n      refine\n            mul_le_of_le_one_left (inv_nonneg.mpr <| mod_cast hn.le) (prod_le_one ?_ ?_) <;>\n          intro x hx <;>\n        rw [Finset.mem_range] at hx\n      Â· positivity\n      Â· refine (div_le_one <| mod_cast hn).mpr ?_\n        norm_cast\n        omega)\n\n"}
{"name":"tendsto_nat_floor_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\ninstâœÂ¹ : LinearOrderedSemiring Î±\ninstâœ : FloorSemiring Î±\nâŠ¢ Filter.Tendsto (fun x => Nat.floor x) Filter.atTop Filter.atTop","decl":"theorem tendsto_nat_floor_atTop {Î± : Type*} [LinearOrderedSemiring Î±] [FloorSemiring Î±] :\n    Tendsto (fun x : Î± â†¦ âŒŠxâŒ‹â‚Š) atTop atTop :=\n  Nat.floor_mono.tendsto_atTop_atTop fun x â†¦ âŸ¨max 0 (x + 1), by simp [Nat.le_floor_iff]âŸ©\n\n"}
{"name":"tendsto_nat_ceil_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\ninstâœÂ¹ : LinearOrderedSemiring Î±\ninstâœ : FloorSemiring Î±\nâŠ¢ Filter.Tendsto (fun x => Nat.ceil x) Filter.atTop Filter.atTop","decl":"lemma tendsto_nat_ceil_atTop {Î± : Type*} [LinearOrderedSemiring Î±] [FloorSemiring Î±] :\n    Tendsto (fun x : Î± â†¦ âŒˆxâŒ‰â‚Š) atTop atTop := by\n  refine Nat.ceil_mono.tendsto_atTop_atTop (fun x â†¦ âŸ¨x, ?_âŸ©)\n  simp only [Nat.ceil_natCast, le_refl]\n\n"}
{"name":"tendsto_nat_floor_mul_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"Î± : Type u_4\ninstâœÂ² : LinearOrderedSemifield Î±\ninstâœÂ¹ : FloorSemiring Î±\ninstâœ : Archimedean Î±\na : Î±\nha : LT.lt 0 a\nâŠ¢ Filter.Tendsto (fun x => Nat.floor (HMul.hMul a â†‘x)) Filter.atTop Filter.atTop","decl":"lemma tendsto_nat_floor_mul_atTop {Î± : Type _} [LinearOrderedSemifield Î±] [FloorSemiring Î±]\n    [Archimedean Î±] (a : Î±) (ha : 0 < a) : Tendsto (fun (x : â„•) => âŒŠa * xâŒ‹â‚Š) atTop atTop :=\n  Tendsto.comp tendsto_nat_floor_atTop\n    <| Tendsto.const_mul_atTop ha tendsto_natCast_atTop_atTop\n\n"}
{"name":"tendsto_nat_floor_mul_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\na : R\nha : LE.le 0 a\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (â†‘(Nat.floor (HMul.hMul a x))) x) Filter.atTop (nhds a)","decl":"theorem tendsto_nat_floor_mul_div_atTop {a : R} (ha : 0 â‰¤ a) :\n    Tendsto (fun x â†¦ (âŒŠa * xâŒ‹â‚Š : R) / x) atTop (ğ“ a) := by\n  have A : Tendsto (fun x : R â†¦ a - xâ»Â¹) atTop (ğ“ (a - 0)) :=\n    tendsto_const_nhds.sub tendsto_inv_atTop_zero\n  rw [sub_zero] at A\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' A tendsto_const_nhds\n  Â· refine eventually_atTop.2 âŸ¨1, fun x hx â†¦ ?_âŸ©\n    simp only [le_div_iffâ‚€ (zero_lt_one.trans_le hx), _root_.sub_mul,\n      inv_mul_cancelâ‚€ (zero_lt_one.trans_le hx).ne']\n    have := Nat.lt_floor_add_one (a * x)\n    linarith\n  Â· refine eventually_atTop.2 âŸ¨1, fun x hx â†¦ ?_âŸ©\n    rw [div_le_iffâ‚€ (zero_lt_one.trans_le hx)]\n    simp [Nat.floor_le (mul_nonneg ha (zero_le_one.trans hx))]\n\n"}
{"name":"tendsto_nat_floor_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (â†‘(Nat.floor x)) x) Filter.atTop (nhds 1)","decl":"theorem tendsto_nat_floor_div_atTop : Tendsto (fun x â†¦ (âŒŠxâŒ‹â‚Š : R) / x) atTop (ğ“ 1) := by\n  simpa using tendsto_nat_floor_mul_div_atTop (zero_le_one' R)\n\n"}
{"name":"tendsto_nat_ceil_mul_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\na : R\nha : LE.le 0 a\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (â†‘(Nat.ceil (HMul.hMul a x))) x) Filter.atTop (nhds a)","decl":"theorem tendsto_nat_ceil_mul_div_atTop {a : R} (ha : 0 â‰¤ a) :\n    Tendsto (fun x â†¦ (âŒˆa * xâŒ‰â‚Š : R) / x) atTop (ğ“ a) := by\n  have A : Tendsto (fun x : R â†¦ a + xâ»Â¹) atTop (ğ“ (a + 0)) :=\n    tendsto_const_nhds.add tendsto_inv_atTop_zero\n  rw [add_zero] at A\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds A\n  Â· refine eventually_atTop.2 âŸ¨1, fun x hx â†¦ ?_âŸ©\n    rw [le_div_iffâ‚€ (zero_lt_one.trans_le hx)]\n    exact Nat.le_ceil _\n  Â· refine eventually_atTop.2 âŸ¨1, fun x hx â†¦ ?_âŸ©\n    simp [div_le_iffâ‚€ (zero_lt_one.trans_le hx), inv_mul_cancelâ‚€ (zero_lt_one.trans_le hx).ne',\n      (Nat.ceil_lt_add_one (mul_nonneg ha (zero_le_one.trans hx))).le, add_mul]\n\n"}
{"name":"tendsto_nat_ceil_div_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"R : Type u_4\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : LinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (â†‘(Nat.ceil x)) x) Filter.atTop (nhds 1)","decl":"theorem tendsto_nat_ceil_div_atTop : Tendsto (fun x â†¦ (âŒˆxâŒ‰â‚Š : R) / x) atTop (ğ“ 1) := by\n  simpa using tendsto_nat_ceil_mul_div_atTop (zero_le_one' R)\n\n"}
{"name":"Nat.tendsto_div_const_atTop","module":"Mathlib.Analysis.SpecificLimits.Basic","initialProofState":"n : Nat\nhn : Ne n 0\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv x n) Filter.atTop Filter.atTop","decl":"lemma Nat.tendsto_div_const_atTop {n : â„•} (hn : n â‰  0) : Tendsto (Â· / n) atTop atTop := by\n  rw [Tendsto, map_div_atTop_eq_nat n hn.bot_lt]\n\n"}
