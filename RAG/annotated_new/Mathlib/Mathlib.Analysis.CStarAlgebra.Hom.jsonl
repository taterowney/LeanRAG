{"name":"IsSelfAdjoint.map_spectrum_real","module":"Mathlib.Analysis.CStarAlgebra.Hom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : CStarAlgebra A\ninstâœÂ³ : CStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : AlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\na : A\nha : IsSelfAdjoint a\nÏ† : F\nhÏ† : Function.Injective â‡‘Ï†\nâŠ¢ Eq (spectrum Real (Ï† a)) (spectrum Real a)","decl":"open CStarAlgebra in\nlemma IsSelfAdjoint.map_spectrum_real {F A B : Type*} [CStarAlgebra A] [CStarAlgebra B]\n    [FunLike F A B] [AlgHomClass F â„‚ A B] [StarHomClass F A B]\n    {a : A} (ha : IsSelfAdjoint a) (Ï† : F) (hÏ† : Function.Injective Ï†) :\n    spectrum â„ (Ï† a) = spectrum â„ a := by\n  have h_spec := AlgHom.spectrum_apply_subset ((Ï† : A â†’â‹†â‚[â„‚] B).restrictScalars â„) a\n  refine Set.eq_of_subset_of_subset h_spec fun x hx â†¦ ?_\n  /- we prove the reverse inclusion by contradiction, so assume that `x âˆˆ spectrum â„ a`, but\n  `x âˆ‰ spectrum â„ (Ï† a)`. Then by Urysohn's lemma we can get a function for which `f x = 1`, but\n  `f = 0` on `spectrum â„ a`. -/\n  by_contra hx'\n  obtain âŸ¨f, h_eqOn, h_eqOn_x, -âŸ© := exists_continuous_zero_one_of_isClosed\n    (spectrum.isClosed (ğ•œ := â„) (Ï† a)) (isClosed_singleton (x := x)) <| by simpa\n  /- it suffices to show that `Ï† (f a) = 0`, for if so, then `f a = 0` by injectivity of `Ï†`, and\n  hence `f = 0` on `spectrum â„ a`, contradicting the fact that `f x = 1`. -/\n  suffices Ï† (cfc f a) = 0 by\n    rw [map_eq_zero_iff Ï† hÏ†, â† cfc_zero â„ a, cfc_eq_cfc_iff_eqOn] at this\n    exact zero_ne_one <| calc\n      0 = f x := (this hx).symm\n      _ = 1 := h_eqOn_x <| Set.mem_singleton x\n  /- Finally, `Ï† (f a) = f (Ï† a) = 0`, where the last equality follows since `f = 0` on\n  `spectrum â„ (Ï† a)`. -/\n  calc Ï† (cfc f a) = cfc f (Ï† a) := StarAlgHomClass.map_cfc Ï† f a\n    _ = cfc (0 : â„ â†’ â„) (Ï† a) := cfc_congr h_eqOn\n    _ = 0 := by simp\n\n"}
{"name":"NonUnitalStarAlgHom.norm_map","module":"Mathlib.Analysis.CStarAlgebra.Hom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\nhÏ† : Function.Injective â‡‘Ï†\na : A\nâŠ¢ Eq (Norm.norm (Ï† a)) (Norm.norm a)","decl":"open CStarAlgebra Unitization in\n/-- A non-unital star algebra monomorphism of complex Câ‹†-algebras is isometric. -/\nlemma norm_map (Ï† : F) (hÏ† : Function.Injective Ï†) (a : A) : â€–Ï† aâ€– = â€–aâ€– := by\n  /- Since passing to the unitization is functorial, and it is an isometric embedding, we may assume\n  that `Ï†` is a unital star algebra monomorphism and that `A` and `B` are unital Câ‹†-algebras. -/\n  suffices âˆ€ {Ïˆ : Unitization â„‚ A â†’â‹†â‚[â„‚] Unitization â„‚ B} (_ : Function.Injective Ïˆ)\n      (a : Unitization â„‚ A), â€–Ïˆ aâ€– = â€–aâ€– by\n    simpa [norm_inr] using this (starMap_injective (Ï† := (Ï† : A â†’â‹†â‚™â‚[â„‚] B)) hÏ†) a\n  intro Ïˆ hÏˆ a\n  -- to show `â€–Ïˆ aâ€– = â€–aâ€–`, by the Câ‹†-property it suffices to show `â€–Ïˆ (star a * a)â€– = â€–star a * aâ€–`\n  rw [â† sq_eq_sqâ‚€ (by positivity) (by positivity)]\n  simp only [sq, â† CStarRing.norm_star_mul_self, â† map_star, â† map_mul]\n  /- since `star a * a` is selfadjoint, it has the same `â„`-spectrum as `Ïˆ (star a * a)`.\n  Since the spectral radius over `â„` coincides with the norm, `â€–Ïˆ (star a * a)â€– = â€–star a * aâ€–`. -/\n  have ha : IsSelfAdjoint (star a * a) := .star_mul_self a\n  calc â€–Ïˆ (star a * a)â€– = (spectralRadius â„ (Ïˆ (star a * a))).toReal :=\n      ha.map Ïˆ |>.toReal_spectralRadius_eq_norm.symm\n    _ = (spectralRadius â„ (star a * a)).toReal := by\n      simp only [spectralRadius, ha.map_spectrum_real Ïˆ hÏˆ]\n    _ = â€–star a * aâ€– := ha.toReal_spectralRadius_eq_norm\n\n"}
{"name":"NonUnitalStarAlgHom.nnnorm_map","module":"Mathlib.Analysis.CStarAlgebra.Hom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\nhÏ† : Function.Injective â‡‘Ï†\na : A\nâŠ¢ Eq (NNNorm.nnnorm (Ï† a)) (NNNorm.nnnorm a)","decl":"/-- A non-unital star algebra monomorphism of complex Câ‹†-algebras is isometric. -/\nlemma nnnorm_map (Ï† : F) (hÏ† : Function.Injective Ï†) (a : A) : â€–Ï† aâ€–â‚Š = â€–aâ€–â‚Š :=\n  Subtype.ext <| norm_map Ï† hÏ† a\n\n"}
{"name":"NonUnitalStarAlgHom.isometry","module":"Mathlib.Analysis.CStarAlgebra.Hom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\nhÏ† : Function.Injective â‡‘Ï†\nâŠ¢ Isometry â‡‘Ï†","decl":"lemma isometry (Ï† : F) (hÏ† : Function.Injective Ï†) : Isometry Ï† :=\n  AddMonoidHomClass.isometry_of_norm Ï† (norm_map Ï† hÏ†)\n\n"}
