{"name":"hasFDerivAtFilter_iff_isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nâŠ¢ Iff (HasFDerivAtFilter f f' x L) (Asymptotics.IsLittleOTVS ğ•œ L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x)","decl":"/-- A function `f` has the continuous linear map `f'` as derivative along the filter `L` if\n`f x' = f x + f' (x' - x) + o (x' - x)` when `x'` converges along the filter `L`. This definition\nis designed to be specialized for `L = ğ“ x` (in `HasFDerivAt`), giving rise to the usual notion\nof FrÃ©chet derivative, and for `L = ğ“[s] x` (in `HasFDerivWithinAt`), giving rise to\nthe notion of FrÃ©chet derivative along the set `s`. -/\n@[mk_iff hasFDerivAtFilter_iff_isLittleOTVS]\nstructure HasFDerivAtFilter (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (x : E) (L : Filter E) : Prop where\n  of_isLittleOTVS ::\n    isLittleOTVS : (fun x' => f x' - f x - f' (x' - x)) =o[ğ•œ;L] (fun x' => x' - x)\n\n"}
{"name":"HasFDerivAtFilter.isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nself : HasFDerivAtFilter f f' x L\nâŠ¢ Asymptotics.IsLittleOTVS ğ•œ L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x","decl":"/-- A function `f` has the continuous linear map `f'` as derivative along the filter `L` if\n`f x' = f x + f' (x' - x) + o (x' - x)` when `x'` converges along the filter `L`. This definition\nis designed to be specialized for `L = ğ“ x` (in `HasFDerivAt`), giving rise to the usual notion\nof FrÃ©chet derivative, and for `L = ğ“[s] x` (in `HasFDerivWithinAt`), giving rise to\nthe notion of FrÃ©chet derivative along the set `s`. -/\n@[mk_iff hasFDerivAtFilter_iff_isLittleOTVS]\nstructure HasFDerivAtFilter (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (x : E) (L : Filter E) : Prop where\n  of_isLittleOTVS ::\n    isLittleOTVS : (fun x' => f x' - f x - f' (x' - x)) =o[ğ•œ;L] (fun x' => x' - x)\n\n"}
{"name":"hasStrictFDerivAt_iff_isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Iff (HasStrictFDerivAt f f' x) (Asymptotics.IsLittleOTVS ğ•œ (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2)","decl":"/-- A function `f` has derivative `f'` at `a` in the sense of *strict differentiability*\nif `f x - f y - f' (x - y) = o(x - y)` as `x, y â†’ a`. This form of differentiability is required,\ne.g., by the inverse function theorem. Any `C^1` function on a vector space over `â„` is strictly\ndifferentiable but this definition works, e.g., for vector spaces over `p`-adic numbers. -/\n@[fun_prop, mk_iff hasStrictFDerivAt_iff_isLittleOTVS]\nstructure HasStrictFDerivAt (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (x : E) where\n  of_isLittleOTVS ::\n    isLittleOTVS :\n      (fun p : E Ã— E => f p.1 - f p.2 - f' (p.1 - p.2))\n        =o[ğ•œ;ğ“ (x, x)] (fun p : E Ã— E => p.1 - p.2)\n\n"}
{"name":"HasStrictFDerivAt.isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nself : HasStrictFDerivAt f f' x\nâŠ¢ Asymptotics.IsLittleOTVS ğ•œ (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2","decl":"/-- A function `f` has derivative `f'` at `a` in the sense of *strict differentiability*\nif `f x - f y - f' (x - y) = o(x - y)` as `x, y â†’ a`. This form of differentiability is required,\ne.g., by the inverse function theorem. Any `C^1` function on a vector space over `â„` is strictly\ndifferentiable but this definition works, e.g., for vector spaces over `p`-adic numbers. -/\n@[fun_prop, mk_iff hasStrictFDerivAt_iff_isLittleOTVS]\nstructure HasStrictFDerivAt (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (x : E) where\n  of_isLittleOTVS ::\n    isLittleOTVS :\n      (fun p : E Ã— E => f p.1 - f p.2 - f' (p.1 - p.2))\n        =o[ğ•œ;ğ“ (x, x)] (fun p : E Ã— E => p.1 - p.2)\n\n"}
{"name":"fderivWithin_def","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_5\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_6\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\ns : Set E\nx : E\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (ite (HasFDerivWithinAt f 0 s x) 0 (dite (DifferentiableWithinAt ğ•œ f s x) (fun h => Classical.choose h) fun h => 0))","decl":"open scoped Classical in\n/-- If `f` has a derivative at `x` within `s`, then `fderivWithin ğ•œ f s x` is such a derivative.\nOtherwise, it is set to `0`. We also set it to be zero, if zero is one of possible derivatives. -/\nirreducible_def fderivWithin (f : E â†’ F) (s : Set E) (x : E) : E â†’L[ğ•œ] F :=\n  if HasFDerivWithinAt f (0 : E â†’L[ğ•œ] F) s x\n    then 0\n  else if h : DifferentiableWithinAt ğ•œ f s x\n    then Classical.choose h\n  else 0\n\n"}
{"name":"fderiv_def","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_5\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_6\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nx : E\nâŠ¢ Eq (fderiv ğ•œ f x) (fderivWithin ğ•œ f Set.univ x)","decl":"/-- If `f` has a derivative at `x`, then `fderiv ğ•œ f x` is such a derivative. Otherwise, it is\nset to `0`. -/\nirreducible_def fderiv (f : E â†’ F) (x : E) : E â†’L[ğ•œ] F :=\n  fderivWithin ğ•œ f univ x\n\n"}
{"name":"fderivWithin_zero_of_not_differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nx : E\ns : Set E\nh : Not (DifferentiableWithinAt ğ•œ f s x)\nâŠ¢ Eq (fderivWithin ğ•œ f s x) 0","decl":"theorem fderivWithin_zero_of_not_differentiableWithinAt (h : Â¬DifferentiableWithinAt ğ•œ f s x) :\n    fderivWithin ğ•œ f s x = 0 := by\n  simp [fderivWithin, h]\n\n"}
{"name":"fderivWithin_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\nF : Type u_3\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : E â†’ F\nâŠ¢ Eq (fderivWithin ğ•œ f Set.univ) (fderiv ğ•œ f)","decl":"@[simp]\ntheorem fderivWithin_univ : fderivWithin ğ•œ f univ = fderiv ğ•œ f := by\n  ext\n  rw [fderiv]\n\n"}
{"name":"hasFDerivAtFilter_iff_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nâŠ¢ Iff (HasFDerivAtFilter f f' x L) (Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x)","decl":"theorem hasFDerivAtFilter_iff_isLittleO :\n    HasFDerivAtFilter f f' x L â†” (fun x' => f x' - f x - f' (x' - x)) =o[L] fun x' => x' - x :=\n  (hasFDerivAtFilter_iff_isLittleOTVS ..).trans isLittleOTVS_iff_isLittleO\n\n"}
{"name":"HasFDerivAtFilter.of_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\naâœ : Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x\nâŠ¢ HasFDerivAtFilter f f' x L","decl":"alias âŸ¨HasFDerivAtFilter.isLittleO, HasFDerivAtFilter.of_isLittleOâŸ© :=\n  hasFDerivAtFilter_iff_isLittleO\n\n"}
{"name":"HasFDerivAtFilter.isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\naâœ : HasFDerivAtFilter f f' x L\nâŠ¢ Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x","decl":"alias âŸ¨HasFDerivAtFilter.isLittleO, HasFDerivAtFilter.of_isLittleOâŸ© :=\n  hasFDerivAtFilter_iff_isLittleO\n\n"}
{"name":"hasStrictFDerivAt_iff_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Iff (HasStrictFDerivAt f f' x) (Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2)","decl":"theorem hasStrictFDerivAt_iff_isLittleO :\n    HasStrictFDerivAt f f' x â†”\n      (fun p : E Ã— E => f p.1 - f p.2 - f' (p.1 - p.2)) =o[ğ“ (x, x)] fun p : E Ã— E => p.1 - p.2 :=\n  (hasStrictFDerivAt_iff_isLittleOTVS ..).trans isLittleOTVS_iff_isLittleO\n\n"}
{"name":"HasStrictFDerivAt.isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\naâœ : HasStrictFDerivAt f f' x\nâŠ¢ Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2","decl":"alias âŸ¨HasStrictFDerivAt.isLittleO, HasStrictFDerivAt.of_isLittleOâŸ© :=\n  hasStrictFDerivAt_iff_isLittleO\n\n"}
{"name":"HasStrictFDerivAt.of_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\naâœ : Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2\nâŠ¢ HasStrictFDerivAt f f' x","decl":"alias âŸ¨HasStrictFDerivAt.isLittleO, HasStrictFDerivAt.of_isLittleOâŸ© :=\n  hasStrictFDerivAt_iff_isLittleO\n\n"}
{"name":"HasFDerivWithinAt.lim","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nÎ± : Type u_4\nl : Filter Î±\nc : Î± â†’ ğ•œ\nd : Î± â†’ E\nv : E\ndtop : Filter.Eventually (fun n => Membership.mem s (HAdd.hAdd x (d n))) l\nclim : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\ncdlim : Filter.Tendsto (fun n => HSMul.hSMul (c n) (d n)) l (nhds v)\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (c n) (HSub.hSub (f (HAdd.hAdd x (d n))) (f x))) l (nhds (f' v))","decl":"/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem HasFDerivWithinAt.lim (h : HasFDerivWithinAt f f' s x) {Î± : Type*} (l : Filter Î±)\n    {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E} (dtop : âˆ€á¶  n in l, x + d n âˆˆ s)\n    (clim : Tendsto (fun n => â€–c nâ€–) l atTop) (cdlim : Tendsto (fun n => c n â€¢ d n) l (ğ“ v)) :\n    Tendsto (fun n => c n â€¢ (f (x + d n) - f x)) l (ğ“ (f' v)) := by\n  have tendsto_arg : Tendsto (fun n => x + d n) l (ğ“[s] x) := by\n    conv in ğ“[s] x => rw [â† add_zero x]\n    rw [nhdsWithin, tendsto_inf]\n    constructor\n    Â· apply tendsto_const_nhds.add (tangentConeAt.lim_zero l clim cdlim)\n    Â· rwa [tendsto_principal]\n  have : (fun y => f y - f x - f' (y - x)) =o[ğ“[s] x] fun y => y - x := h.isLittleO\n  have : (fun n => f (x + d n) - f x - f' (x + d n - x)) =o[l] fun n => x + d n - x :=\n    this.comp_tendsto tendsto_arg\n  have : (fun n => f (x + d n) - f x - f' (d n)) =o[l] d := by simpa only [add_sub_cancel_left]\n  have : (fun n => c n â€¢ (f (x + d n) - f x - f' (d n))) =o[l] fun n => c n â€¢ d n :=\n    (isBigO_refl c l).smul_isLittleO this\n  have : (fun n => c n â€¢ (f (x + d n) - f x - f' (d n))) =o[l] fun _ => (1 : â„) :=\n    this.trans_isBigO (cdlim.isBigO_one â„)\n  have L1 : Tendsto (fun n => c n â€¢ (f (x + d n) - f x - f' (d n))) l (ğ“ 0) :=\n    (isLittleO_one_iff â„).1 this\n  have L2 : Tendsto (fun n => f' (c n â€¢ d n)) l (ğ“ (f' v)) :=\n    Tendsto.comp f'.cont.continuousAt cdlim\n  have L3 :\n    Tendsto (fun n => c n â€¢ (f (x + d n) - f x - f' (d n)) + f' (c n â€¢ d n)) l (ğ“ (0 + f' v)) :=\n    L1.add L2\n  have :\n    (fun n => c n â€¢ (f (x + d n) - f x - f' (d n)) + f' (c n â€¢ d n)) = fun n =>\n      c n â€¢ (f (x + d n) - f x) := by\n    ext n\n    simp [smul_add, smul_sub]\n  rwa [this, zero_add] at L3\n\n"}
{"name":"HasFDerivWithinAt.unique_on","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt f fâ‚' s x\nâŠ¢ Set.EqOn (â‡‘f') (â‡‘fâ‚') (tangentConeAt ğ•œ s x)","decl":"/-- If `f'` and `fâ‚'` are two derivatives of `f` within `s` at `x`, then they are equal on the\ntangent cone to `s` at `x` -/\ntheorem HasFDerivWithinAt.unique_on (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f fâ‚' s x) : EqOn f' fâ‚' (tangentConeAt ğ•œ s x) :=\n  fun _ âŸ¨_, _, dtop, clim, cdlimâŸ© =>\n  tendsto_nhds_unique (hf.lim atTop dtop clim cdlim) (hg.lim atTop dtop clim cdlim)\n\n"}
{"name":"UniqueDiffWithinAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nH : UniqueDiffWithinAt ğ•œ s x\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt f fâ‚' s x\nâŠ¢ Eq f' fâ‚'","decl":"/-- `UniqueDiffWithinAt` achieves its goal: it implies the uniqueness of the derivative. -/\ntheorem UniqueDiffWithinAt.eq (H : UniqueDiffWithinAt ğ•œ s x) (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f fâ‚' s x) : f' = fâ‚' :=\n  ContinuousLinearMap.ext_on H.1 (hf.unique_on hg)\n\n"}
{"name":"UniqueDiffOn.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nH : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nh : HasFDerivWithinAt f f' s x\nhâ‚ : HasFDerivWithinAt f fâ‚' s x\nâŠ¢ Eq f' fâ‚'","decl":"theorem UniqueDiffOn.eq (H : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (h : HasFDerivWithinAt f f' s x)\n    (hâ‚ : HasFDerivWithinAt f fâ‚' s x) : f' = fâ‚' :=\n  (H x hx).eq h hâ‚\n\n"}
{"name":"hasFDerivAtFilter_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nâŠ¢ Iff (HasFDerivAtFilter f f' x L) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) L (nhds 0))","decl":"theorem hasFDerivAtFilter_iff_tendsto :\n    HasFDerivAtFilter f f' x L â†”\n      Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - f' (x' - x)â€–) L (ğ“ 0) := by\n  have h : âˆ€ x', â€–x' - xâ€– = 0 â†’ â€–f x' - f x - f' (x' - x)â€– = 0 := fun x' hx' => by\n    rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]\n    simp\n  rw [hasFDerivAtFilter_iff_isLittleO, â† isLittleO_norm_left, â† isLittleO_norm_right,\n    isLittleO_iff_tendsto h]\n  exact tendsto_congr fun _ => div_eq_inv_mul _ _\n\n"}
{"name":"hasFDerivWithinAt_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nâŠ¢ Iff (HasFDerivWithinAt f f' s x) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) (nhdsWithin x s) (nhds 0))","decl":"theorem hasFDerivWithinAt_iff_tendsto :\n    HasFDerivWithinAt f f' s x â†”\n      Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - f' (x' - x)â€–) (ğ“[s] x) (ğ“ 0) :=\n  hasFDerivAtFilter_iff_tendsto\n\n"}
{"name":"hasFDerivAt_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Iff (HasFDerivAt f f' x) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) (nhds x) (nhds 0))","decl":"theorem hasFDerivAt_iff_tendsto :\n    HasFDerivAt f f' x â†” Tendsto (fun x' => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - f' (x' - x)â€–) (ğ“ x) (ğ“ 0) :=\n  hasFDerivAtFilter_iff_tendsto\n\n"}
{"name":"hasFDerivAt_iff_isLittleO_nhds_zero","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Iff (HasFDerivAt f f' x) (Asymptotics.IsLittleO (nhds 0) (fun h => HSub.hSub (HSub.hSub (f (HAdd.hAdd x h)) (f x)) (f' h)) fun h => h)","decl":"theorem hasFDerivAt_iff_isLittleO_nhds_zero :\n    HasFDerivAt f f' x â†” (fun h : E => f (x + h) - f x - f' h) =o[ğ“ 0] fun h => h := by\n  rw [HasFDerivAt, hasFDerivAtFilter_iff_isLittleO, â† map_add_left_nhds_zero x, isLittleO_map]\n  simp [Function.comp_def]\n\n"}
{"name":"HasFDerivAtFilter.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nLâ‚ Lâ‚‚ : Filter E\nh : HasFDerivAtFilter f f' x Lâ‚‚\nhst : LE.le Lâ‚ Lâ‚‚\nâŠ¢ HasFDerivAtFilter f f' x Lâ‚","decl":"nonrec theorem HasFDerivAtFilter.mono (h : HasFDerivAtFilter f f' x Lâ‚‚) (hst : Lâ‚ â‰¤ Lâ‚‚) :\n    HasFDerivAtFilter f f' x Lâ‚ :=\n  .of_isLittleOTVS <| h.isLittleOTVS.mono hst\n\n"}
{"name":"HasFDerivWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : Membership.mem (nhdsWithin x s) t\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"theorem HasFDerivWithinAt.mono_of_mem_nhdsWithin\n    (h : HasFDerivWithinAt f f' t x) (hst : t âˆˆ ğ“[s] x) :\n    HasFDerivWithinAt f f' s x :=\n  h.mono <| nhdsWithin_le_iff.mpr hst\n\n"}
{"name":"HasFDerivWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : Membership.mem (nhdsWithin x s) t\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias HasFDerivWithinAt.mono_of_mem := HasFDerivWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"HasFDerivWithinAt.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : HasSubset.Subset s t\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"nonrec theorem HasFDerivWithinAt.mono (h : HasFDerivWithinAt f f' t x) (hst : s âŠ† t) :\n    HasFDerivWithinAt f f' s x :=\n  h.mono <| nhdsWithin_mono _ hst\n\n"}
{"name":"HasFDerivAt.hasFDerivAtFilter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nh : HasFDerivAt f f' x\nhL : LE.le L (nhds x)\nâŠ¢ HasFDerivAtFilter f f' x L","decl":"theorem HasFDerivAt.hasFDerivAtFilter (h : HasFDerivAt f f' x) (hL : L â‰¤ ğ“ x) :\n    HasFDerivAtFilter f f' x L :=\n  h.mono hL\n\n"}
{"name":"HasFDerivAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivAt f f' x\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"@[fun_prop]\ntheorem HasFDerivAt.hasFDerivWithinAt (h : HasFDerivAt f f' x) : HasFDerivWithinAt f f' s x :=\n  h.hasFDerivAtFilter inf_le_left\n\n"}
{"name":"HasFDerivWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.differentiableWithinAt (h : HasFDerivWithinAt f f' s x) :\n    DifferentiableWithinAt ğ•œ f s x :=\n  âŸ¨f', hâŸ©\n\n"}
{"name":"HasFDerivAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"@[fun_prop]\ntheorem HasFDerivAt.differentiableAt (h : HasFDerivAt f f' x) : DifferentiableAt ğ•œ f x :=\n  âŸ¨f', hâŸ©\n\n"}
{"name":"hasFDerivWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Iff (HasFDerivWithinAt f f' Set.univ x) (HasFDerivAt f f' x)","decl":"@[simp]\ntheorem hasFDerivWithinAt_univ : HasFDerivWithinAt f f' univ x â†” HasFDerivAt f f' x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_univ, HasFDerivAt]\n\n"}
{"name":"HasFDerivWithinAt.hasFDerivAt_of_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\naâœ : HasFDerivWithinAt f f' Set.univ x\nâŠ¢ HasFDerivAt f f' x","decl":"alias âŸ¨HasFDerivWithinAt.hasFDerivAt_of_univ, _âŸ© := hasFDerivWithinAt_univ\n\n"}
{"name":"differentiableWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f Set.univ x) (DifferentiableAt ğ•œ f x)","decl":"theorem differentiableWithinAt_univ :\n    DifferentiableWithinAt ğ•œ f univ x â†” DifferentiableAt ğ•œ f x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_univ, DifferentiableAt]\n\n"}
{"name":"fderiv_zero_of_not_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Not (DifferentiableAt ğ•œ f x)\nâŠ¢ Eq (fderiv ğ•œ f x) 0","decl":"theorem fderiv_zero_of_not_differentiableAt (h : Â¬DifferentiableAt ğ•œ f x) : fderiv ğ•œ f x = 0 := by\n  rw [fderiv, fderivWithin_zero_of_not_differentiableWithinAt]\n  rwa [differentiableWithinAt_univ]\n\n"}
{"name":"hasFDerivWithinAt_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\nâŠ¢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivAt f f' x)","decl":"theorem hasFDerivWithinAt_of_mem_nhds (h : s âˆˆ ğ“ x) :\n    HasFDerivWithinAt f f' s x â†” HasFDerivAt f f' x := by\n  rw [HasFDerivAt, HasFDerivWithinAt, nhdsWithin_eq_nhds.mpr h]\n\n"}
{"name":"hasFDerivWithinAt_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : IsOpen s\nhx : Membership.mem s x\nâŠ¢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivAt f f' x)","decl":"lemma hasFDerivWithinAt_of_isOpen (h : IsOpen s) (hx : x âˆˆ s) :\n    HasFDerivWithinAt f f' s x â†” HasFDerivAt f f' x :=\n  hasFDerivWithinAt_of_mem_nhds (h.mem_nhds hx)\n\n"}
{"name":"hasFDerivWithinAt_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ny : E\nâŠ¢ Iff (HasFDerivWithinAt f f' (Insert.insert y s) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_insert {y : E} :\n    HasFDerivWithinAt f f' (insert y s) x â†” HasFDerivWithinAt f f' s x := by\n  rcases eq_or_ne x y with (rfl | h)\n  Â· simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]\n    apply isLittleOTVS_insert\n    simp only [sub_self, map_zero]\n  refine âŸ¨fun h => h.mono <| subset_insert y s, fun hf => hf.mono_of_mem_nhdsWithin ?_âŸ©\n  simp_rw [nhdsWithin_insert_of_ne h, self_mem_nhdsWithin]\n\n"}
{"name":"HasFDerivWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ny : E\naâœ : HasFDerivWithinAt f f' (Insert.insert y s) x\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"alias âŸ¨HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'âŸ© := hasFDerivWithinAt_insert\n\n"}
{"name":"HasFDerivWithinAt.insert'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ny : E\naâœ : HasFDerivWithinAt f f' s x\nâŠ¢ HasFDerivWithinAt f f' (Insert.insert y s) x","decl":"alias âŸ¨HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'âŸ© := hasFDerivWithinAt_insert\n\n"}
{"name":"HasFDerivWithinAt.insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ng : E â†’ F\ng' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt g g' s x\nâŠ¢ HasFDerivWithinAt g g' (Insert.insert x s) x","decl":"protected theorem HasFDerivWithinAt.insert (h : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt g g' (insert x s) x :=\n  h.insert'\n\n"}
{"name":"hasFDerivWithinAt_diff_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\ny : E\nâŠ¢ Iff (HasFDerivWithinAt f f' (SDiff.sdiff s (Singleton.singleton y)) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_diff_singleton (y : E) :\n    HasFDerivWithinAt f f' (s \\ {y}) x â†” HasFDerivWithinAt f f' s x := by\n  rw [â† hasFDerivWithinAt_insert, insert_diff_singleton, hasFDerivWithinAt_insert]\n\n"}
{"name":"HasStrictFDerivAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nâŠ¢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (f p.1) (f p.2)) fun p => HSub.hSub p.1 p.2","decl":"theorem HasStrictFDerivAt.isBigO_sub (hf : HasStrictFDerivAt f f' x) :\n    (fun p : E Ã— E => f p.1 - f p.2) =O[ğ“ (x, x)] fun p : E Ã— E => p.1 - p.2 :=\n  hf.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_comp _ _)\n\n"}
{"name":"HasFDerivAtFilter.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nh : HasFDerivAtFilter f f' x L\nâŠ¢ Asymptotics.IsBigO L (fun x' => HSub.hSub (f x') (f x)) fun x' => HSub.hSub x' x","decl":"theorem HasFDerivAtFilter.isBigO_sub (h : HasFDerivAtFilter f f' x L) :\n    (fun x' => f x' - f x) =O[L] fun x' => x' - x :=\n  h.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_sub _ _)\n\n"}
{"name":"HasStrictFDerivAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nâŠ¢ HasFDerivAt f f' x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.hasFDerivAt (hf : HasStrictFDerivAt f f' x) :\n    HasFDerivAt f f' x :=\n  .of_isLittleOTVS <| by\n    simpa only using hf.isLittleOTVS.comp_tendsto (tendsto_id.prod_mk_nhds tendsto_const_nhds)\n\n"}
{"name":"HasStrictFDerivAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"protected theorem HasStrictFDerivAt.differentiableAt (hf : HasStrictFDerivAt f f' x) :\n    DifferentiableAt ğ•œ f x :=\n  hf.hasFDerivAt.differentiableAt\n\n"}
{"name":"HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nK : NNReal\nhK : LT.lt (NNNorm.nnnorm f') K\nâŠ¢ Exists fun s => And (Membership.mem (nhds x) s) (LipschitzOnWith K f s)","decl":"/-- If `f` is strictly differentiable at `x` with derivative `f'` and `K > â€–f'â€–â‚Š`, then `f` is\n`K`-Lipschitz in a neighborhood of `x`. -/\ntheorem HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt (hf : HasStrictFDerivAt f f' x)\n    (K : â„â‰¥0) (hK : â€–f'â€–â‚Š < K) : âˆƒ s âˆˆ ğ“ x, LipschitzOnWith K f s := by\n  have := hf.isLittleO.add_isBigOWith (f'.isBigOWith_comp _ _) hK\n  simp only [sub_add_cancel, IsBigOWith] at this\n  rcases exists_nhds_square this with âŸ¨U, Uo, xU, hUâŸ©\n  exact\n    âŸ¨U, Uo.mem_nhds xU, lipschitzOnWith_iff_norm_sub_le.2 fun x hx y hy => hU (mk_mem_prod hx hy)âŸ©\n\n"}
{"name":"HasStrictFDerivAt.exists_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nâŠ¢ Exists fun K => Exists fun s => And (Membership.mem (nhds x) s) (LipschitzOnWith K f s)","decl":"/-- If `f` is strictly differentiable at `x` with derivative `f'`, then `f` is Lipschitz in a\nneighborhood of `x`. See also `HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt` for a\nmore precise statement. -/\ntheorem HasStrictFDerivAt.exists_lipschitzOnWith (hf : HasStrictFDerivAt f f' x) :\n    âˆƒ K, âˆƒ s âˆˆ ğ“ x, LipschitzOnWith K f s :=\n  (exists_gt _).imp hf.exists_lipschitzOnWith_of_nnnorm_lt\n\n"}
{"name":"HasFDerivAt.lim","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasFDerivAt f f' x\nv : E\nÎ± : Type u_4\nc : Î± â†’ ğ•œ\nl : Filter Î±\nhc : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (c n) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul (Inv.inv (c n)) v))) (f x))) l (nhds (f' v))","decl":"/-- Directional derivative agrees with `HasFDeriv`. -/\ntheorem HasFDerivAt.lim (hf : HasFDerivAt f f' x) (v : E) {Î± : Type*} {c : Î± â†’ ğ•œ} {l : Filter Î±}\n    (hc : Tendsto (fun n => â€–c nâ€–) l atTop) :\n    Tendsto (fun n => c n â€¢ (f (x + (c n)â»Â¹ â€¢ v) - f x)) l (ğ“ (f' v)) := by\n  refine (hasFDerivWithinAt_univ.2 hf).lim _ univ_mem hc ?_\n  intro U hU\n  refine (eventually_ne_of_tendsto_norm_atTop hc (0 : ğ•œ)).mono fun y hy => ?_\n  convert mem_of_mem_nhds hU\n  dsimp only\n  rw [â† mul_smul, mul_inv_cancelâ‚€ hy, one_smul]\n\n"}
{"name":"HasFDerivAt.unique","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nfâ‚€' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhâ‚€ : HasFDerivAt f fâ‚€' x\nhâ‚ : HasFDerivAt f fâ‚' x\nâŠ¢ Eq fâ‚€' fâ‚'","decl":"theorem HasFDerivAt.unique (hâ‚€ : HasFDerivAt f fâ‚€' x) (hâ‚ : HasFDerivAt f fâ‚' x) : fâ‚€' = fâ‚' := by\n  rw [â† hasFDerivWithinAt_univ] at hâ‚€ hâ‚\n  exact uniqueDiffWithinAt_univ.eq hâ‚€ hâ‚\n\n"}
{"name":"hasFDerivWithinAt_inter'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : Membership.mem (nhdsWithin x s) t\nâŠ¢ Iff (HasFDerivWithinAt f f' (Inter.inter s t) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_inter' (h : t âˆˆ ğ“[s] x) :\n    HasFDerivWithinAt f f' (s âˆ© t) x â†” HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict'' s h]\n\n"}
{"name":"hasFDerivWithinAt_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : Membership.mem (nhds x) t\nâŠ¢ Iff (HasFDerivWithinAt f f' (Inter.inter s t) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_inter (h : t âˆˆ ğ“ x) :\n    HasFDerivWithinAt f f' (s âˆ© t) x â†” HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict' s h]\n\n"}
{"name":"HasFDerivWithinAt.union","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nhs : HasFDerivWithinAt f f' s x\nht : HasFDerivWithinAt f f' t x\nâŠ¢ HasFDerivWithinAt f f' (Union.union s t) x","decl":"theorem HasFDerivWithinAt.union (hs : HasFDerivWithinAt f f' s x)\n    (ht : HasFDerivWithinAt f f' t x) : HasFDerivWithinAt f f' (s âˆª t) x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_union]\n  exact .of_isLittleOTVS <| hs.isLittleOTVS.sup ht.isLittleOTVS\n\n"}
{"name":"HasFDerivWithinAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Membership.mem (nhds x) s\nâŠ¢ HasFDerivAt f f' x","decl":"theorem HasFDerivWithinAt.hasFDerivAt (h : HasFDerivWithinAt f f' s x) (hs : s âˆˆ ğ“ x) :\n    HasFDerivAt f f' x := by\n  rwa [â† univ_inter s, hasFDerivWithinAt_inter hs, hasFDerivWithinAt_univ] at h\n\n"}
{"name":"DifferentiableWithinAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nhs : Membership.mem (nhds x) s\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"theorem DifferentiableWithinAt.differentiableAt (h : DifferentiableWithinAt ğ•œ f s x)\n    (hs : s âˆˆ ğ“ x) : DifferentiableAt ğ•œ f x :=\n  h.imp fun _ hf' => hf'.hasFDerivAt hs\n\n"}
{"name":"HasFDerivWithinAt.of_nhdsWithin_eq_bot","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"/-- If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem HasFDerivWithinAt.of_nhdsWithin_eq_bot (h : ğ“[s\\{x}] x = âŠ¥) :\n    HasFDerivWithinAt f f' s x := by\n  rw [â† hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h,\n    hasFDerivAtFilter_iff_isLittleOTVS]\n  exact .bot\n\n"}
{"name":"hasFDerivWithinAt_of_nmem_closure","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : Not (Membership.mem (closure s) x)\nâŠ¢ HasFDerivWithinAt f f' s x","decl":"/-- If `x` is not in the closure of `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem hasFDerivWithinAt_of_nmem_closure (h : x âˆ‰ closure s) : HasFDerivWithinAt f f' s x :=\n  .of_nhdsWithin_eq_bot <| eq_bot_mono (nhdsWithin_mono _ diff_subset) <| by\n    rwa [mem_closure_iff_nhdsWithin_neBot, not_neBot] at h\n\n"}
{"name":"fderivWithin_zero_of_isolated","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot\nâŠ¢ Eq (fderivWithin ğ•œ f s x) 0","decl":"theorem fderivWithin_zero_of_isolated (h : ğ“[s \\ {x}] x = âŠ¥) : fderivWithin ğ•œ f s x = 0 := by\n  rw [fderivWithin, if_pos (.of_nhdsWithin_eq_bot h)]\n\n"}
{"name":"fderivWithin_zero_of_nmem_closure","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : Not (Membership.mem (closure s) x)\nâŠ¢ Eq (fderivWithin ğ•œ f s x) 0","decl":"theorem fderivWithin_zero_of_nmem_closure (h : x âˆ‰ closure s) : fderivWithin ğ•œ f s x = 0 := by\n  rw [fderivWithin, if_pos (hasFDerivWithinAt_of_nmem_closure h)]\n\n"}
{"name":"DifferentiableWithinAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ HasFDerivWithinAt f (fderivWithin ğ•œ f s x) s x","decl":"theorem DifferentiableWithinAt.hasFDerivWithinAt (h : DifferentiableWithinAt ğ•œ f s x) :\n    HasFDerivWithinAt f (fderivWithin ğ•œ f s x) s x := by\n  simp only [fderivWithin, dif_pos h]\n  split_ifs with hâ‚€\n  exacts [hâ‚€, Classical.choose_spec h]\n\n"}
{"name":"DifferentiableAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : DifferentiableAt ğ•œ f x\nâŠ¢ HasFDerivAt f (fderiv ğ•œ f x) x","decl":"theorem DifferentiableAt.hasFDerivAt (h : DifferentiableAt ğ•œ f x) :\n    HasFDerivAt f (fderiv ğ•œ f x) x := by\n  rw [fderiv, â† hasFDerivWithinAt_univ]\n  rw [â† differentiableWithinAt_univ] at h\n  exact h.hasFDerivWithinAt\n\n"}
{"name":"DifferentiableOn.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableOn ğ•œ f s\nhs : Membership.mem (nhds x) s\nâŠ¢ HasFDerivAt f (fderiv ğ•œ f x) x","decl":"theorem DifferentiableOn.hasFDerivAt (h : DifferentiableOn ğ•œ f s) (hs : s âˆˆ ğ“ x) :\n    HasFDerivAt f (fderiv ğ•œ f x) x :=\n  ((h x (mem_of_mem_nhds hs)).differentiableAt hs).hasFDerivAt\n\n"}
{"name":"DifferentiableOn.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableOn ğ•œ f s\nhs : Membership.mem (nhds x) s\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"theorem DifferentiableOn.differentiableAt (h : DifferentiableOn ğ•œ f s) (hs : s âˆˆ ğ“ x) :\n    DifferentiableAt ğ•œ f x :=\n  (h.hasFDerivAt hs).differentiableAt\n\n"}
{"name":"DifferentiableOn.eventually_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableOn ğ•œ f s\nhs : Membership.mem (nhds x) s\nâŠ¢ Filter.Eventually (fun y => DifferentiableAt ğ•œ f y) (nhds x)","decl":"theorem DifferentiableOn.eventually_differentiableAt (h : DifferentiableOn ğ•œ f s) (hs : s âˆˆ ğ“ x) :\n    âˆ€á¶  y in ğ“ x, DifferentiableAt ğ•œ f y :=\n  (eventually_eventually_nhds.2 hs).mono fun _ => h.differentiableAt\n\n"}
{"name":"HasFDerivAt.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nâŠ¢ Eq (fderiv ğ•œ f x) f'","decl":"protected theorem HasFDerivAt.fderiv (h : HasFDerivAt f f' x) : fderiv ğ•œ f x = f' := by\n  ext\n  rw [h.unique h.differentiableAt.hasFDerivAt]\n\n"}
{"name":"fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nh : âˆ€ (x : E), HasFDerivAt f (f' x) x\nâŠ¢ Eq (fderiv ğ•œ f) f'","decl":"theorem fderiv_eq {f' : E â†’ E â†’L[ğ•œ] F} (h : âˆ€ x, HasFDerivAt f (f' x) x) : fderiv ğ•œ f = f' :=\n  funext fun x => (h x).fderiv\n\n"}
{"name":"HasFDerivWithinAt.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) f'","decl":"protected theorem HasFDerivWithinAt.fderivWithin (h : HasFDerivWithinAt f f' s x)\n    (hxs : UniqueDiffWithinAt ğ•œ s x) : fderivWithin ğ•œ f s x = f' :=\n  (hxs.eq h h.differentiableWithinAt.hasFDerivWithinAt).symm\n\n"}
{"name":"DifferentiableWithinAt.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nh : DifferentiableWithinAt ğ•œ f t x\nst : HasSubset.Subset s t\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"theorem DifferentiableWithinAt.mono (h : DifferentiableWithinAt ğ•œ f t x) (st : s âŠ† t) :\n    DifferentiableWithinAt ğ•œ f s x := by\n  rcases h with âŸ¨f', hf'âŸ©\n  exact âŸ¨f', hf'.mono stâŸ©\n\n"}
{"name":"DifferentiableWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ DifferentiableWithinAt ğ•œ f t x","decl":"theorem DifferentiableWithinAt.mono_of_mem_nhdsWithin\n    (h : DifferentiableWithinAt ğ•œ f s x) {t : Set E} (hst : s âˆˆ ğ“[t] x) :\n    DifferentiableWithinAt ğ•œ f t x :=\n  (h.hasFDerivWithinAt.mono_of_mem_nhdsWithin hst).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ DifferentiableWithinAt ğ•œ f t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias DifferentiableWithinAt.mono_of_mem := DifferentiableWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"DifferentiableWithinAt.congr_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nt : Set E\nhst : Eq (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ DifferentiableWithinAt ğ•œ f t x","decl":"theorem DifferentiableWithinAt.congr_nhds (h : DifferentiableWithinAt ğ•œ f s x) {t : Set E}\n    (hst : ğ“[s] x = ğ“[t] x) : DifferentiableWithinAt ğ•œ f t x :=\n  h.mono_of_mem_nhdsWithin <| hst â–¸ self_mem_nhdsWithin\n\n"}
{"name":"differentiableWithinAt_congr_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nhst : Eq (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f s x) (DifferentiableWithinAt ğ•œ f t x)","decl":"theorem differentiableWithinAt_congr_nhds {t : Set E} (hst : ğ“[s] x = ğ“[t] x) :\n    DifferentiableWithinAt ğ•œ f s x â†” DifferentiableWithinAt ğ•œ f t x :=\n  âŸ¨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symmâŸ©\n\n"}
{"name":"differentiableWithinAt_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f (Inter.inter s t) x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem differentiableWithinAt_inter (ht : t âˆˆ ğ“ x) :\n    DifferentiableWithinAt ğ•œ f (s âˆ© t) x â†” DifferentiableWithinAt ğ•œ f s x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter ht]\n\n"}
{"name":"differentiableWithinAt_inter'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nht : Membership.mem (nhdsWithin x s) t\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f (Inter.inter s t) x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem differentiableWithinAt_inter' (ht : t âˆˆ ğ“[s] x) :\n    DifferentiableWithinAt ğ•œ f (s âˆ© t) x â†” DifferentiableWithinAt ğ•œ f s x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter' ht]\n\n"}
{"name":"differentiableWithinAt_insert_self","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f (Insert.insert x s) x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem differentiableWithinAt_insert_self :\n    DifferentiableWithinAt ğ•œ f (insert x s) x â†” DifferentiableWithinAt ğ•œ f s x :=\n  âŸ¨fun h â†¦ h.mono (subset_insert x s), fun h â†¦ h.hasFDerivWithinAt.insert.differentiableWithinAtâŸ©\n\n"}
{"name":"differentiableWithinAt_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\ny : E\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f (Insert.insert y s) x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem differentiableWithinAt_insert {y : E} :\n    DifferentiableWithinAt ğ•œ f (insert y s) x â†” DifferentiableWithinAt ğ•œ f s x := by\n  rcases eq_or_ne x y with (rfl | h)\n  Â· exact differentiableWithinAt_insert_self\n  apply differentiableWithinAt_congr_nhds\n  exact nhdsWithin_insert_of_ne h\n\n"}
{"name":"DifferentiableWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\ny : E\naâœ : DifferentiableWithinAt ğ•œ f (Insert.insert y s) x\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"alias âŸ¨DifferentiableWithinAt.of_insert, DifferentiableWithinAt.insert'âŸ© :=\ndifferentiableWithinAt_insert\n\n"}
{"name":"DifferentiableWithinAt.insert'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\ny : E\naâœ : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert y s) x","decl":"alias âŸ¨DifferentiableWithinAt.of_insert, DifferentiableWithinAt.insert'âŸ© :=\ndifferentiableWithinAt_insert\n\n"}
{"name":"DifferentiableWithinAt.insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert x s) x","decl":"protected theorem DifferentiableWithinAt.insert (h : DifferentiableWithinAt ğ•œ f s x) :\n    DifferentiableWithinAt ğ•œ f (insert x s) x :=\n  h.insert'\n\n"}
{"name":"DifferentiableAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableAt ğ•œ f x\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"theorem DifferentiableAt.differentiableWithinAt (h : DifferentiableAt ğ•œ f x) :\n    DifferentiableWithinAt ğ•œ f s x :=\n  (differentiableWithinAt_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"Differentiable.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Differentiable ğ•œ f\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"@[fun_prop]\ntheorem Differentiable.differentiableAt (h : Differentiable ğ•œ f) : DifferentiableAt ğ•œ f x :=\n  h x\n\n"}
{"name":"DifferentiableAt.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableAt ğ•œ f x\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderiv ğ•œ f x)","decl":"protected theorem DifferentiableAt.fderivWithin (h : DifferentiableAt ğ•œ f x)\n    (hxs : UniqueDiffWithinAt ğ•œ s x) : fderivWithin ğ•œ f s x = fderiv ğ•œ f x :=\n  h.hasFDerivAt.hasFDerivWithinAt.fderivWithin hxs\n\n"}
{"name":"DifferentiableOn.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nh : DifferentiableOn ğ•œ f t\nst : HasSubset.Subset s t\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"theorem DifferentiableOn.mono (h : DifferentiableOn ğ•œ f t) (st : s âŠ† t) : DifferentiableOn ğ•œ f s :=\n  fun x hx => (h x (st hx)).mono st\n\n"}
{"name":"differentiableOn_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (DifferentiableOn ğ•œ f Set.univ) (Differentiable ğ•œ f)","decl":"theorem differentiableOn_univ : DifferentiableOn ğ•œ f univ â†” Differentiable ğ•œ f := by\n  simp only [DifferentiableOn, Differentiable, differentiableWithinAt_univ, mem_univ,\n    forall_true_left]\n\n"}
{"name":"Differentiable.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : Differentiable ğ•œ f\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"@[fun_prop]\ntheorem Differentiable.differentiableOn (h : Differentiable ğ•œ f) : DifferentiableOn ğ•œ f s :=\n  (differentiableOn_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"differentiableOn_of_locally_differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : âˆ€ (x : E), Membership.mem s x â†’ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (DifferentiableOn ğ•œ f (Inter.inter s u)))\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"theorem differentiableOn_of_locally_differentiableOn\n    (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ DifferentiableOn ğ•œ f (s âˆ© u)) :\n    DifferentiableOn ğ•œ f s := by\n  intro x xs\n  rcases h x xs with âŸ¨t, t_open, xt, htâŸ©\n  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 (ht x âŸ¨xs, xtâŸ©)\n\n"}
{"name":"fderivWithin_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nst : Membership.mem (nhdsWithin x s) t\nht : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableWithinAt ğ•œ f t x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ f t x)","decl":"theorem fderivWithin_of_mem_nhdsWithin (st : t âˆˆ ğ“[s] x) (ht : UniqueDiffWithinAt ğ•œ s x)\n    (h : DifferentiableWithinAt ğ•œ f t x) : fderivWithin ğ•œ f s x = fderivWithin ğ•œ f t x :=\n  ((DifferentiableWithinAt.hasFDerivWithinAt h).mono_of_mem_nhdsWithin st).fderivWithin ht\n\n"}
{"name":"fderivWithin_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nst : Membership.mem (nhdsWithin x s) t\nht : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableWithinAt ğ•œ f t x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ f t x)","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderivWithin_of_mem := fderivWithin_of_mem_nhdsWithin\n\n"}
{"name":"fderivWithin_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nst : HasSubset.Subset s t\nht : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableWithinAt ğ•œ f t x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ f t x)","decl":"theorem fderivWithin_subset (st : s âŠ† t) (ht : UniqueDiffWithinAt ğ•œ s x)\n    (h : DifferentiableWithinAt ğ•œ f t x) : fderivWithin ğ•œ f s x = fderivWithin ğ•œ f t x :=\n  fderivWithin_of_mem_nhdsWithin (nhdsWithin_mono _ st self_mem_nhdsWithin) ht h\n\n"}
{"name":"fderivWithin_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\nâŠ¢ Eq (fderivWithin ğ•œ f (Inter.inter s t) x) (fderivWithin ğ•œ f s x)","decl":"theorem fderivWithin_inter (ht : t âˆˆ ğ“ x) : fderivWithin ğ•œ f (s âˆ© t) x = fderivWithin ğ•œ f s x := by\n  classical\n  simp [fderivWithin, hasFDerivWithinAt_inter ht, DifferentiableWithinAt]\n\n"}
{"name":"fderivWithin_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderiv ğ•œ f x)","decl":"theorem fderivWithin_of_mem_nhds (h : s âˆˆ ğ“ x) : fderivWithin ğ•œ f s x = fderiv ğ•œ f x := by\n  rw [â† fderivWithin_univ, â† univ_inter s, fderivWithin_inter h]\n\n"}
{"name":"fderivWithin_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nhs : IsOpen s\nhx : Membership.mem s x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderiv ğ•œ f x)","decl":"theorem fderivWithin_of_isOpen (hs : IsOpen s) (hx : x âˆˆ s) : fderivWithin ğ•œ f s x = fderiv ğ•œ f x :=\n  fderivWithin_of_mem_nhds (hs.mem_nhds hx)\n\n"}
{"name":"fderivWithin_eq_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nhs : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderiv ğ•œ f x)","decl":"theorem fderivWithin_eq_fderiv (hs : UniqueDiffWithinAt ğ•œ s x) (h : DifferentiableAt ğ•œ f x) :\n    fderivWithin ğ•œ f s x = fderiv ğ•œ f x := by\n  rw [â† fderivWithin_univ]\n  exact fderivWithin_subset (subset_univ _) hs h.differentiableWithinAt\n\n"}
{"name":"fderiv_mem_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nx : E\nâŠ¢ Iff (Membership.mem s (fderiv ğ•œ f x)) (Or (And (DifferentiableAt ğ•œ f x) (Membership.mem s (fderiv ğ•œ f x))) (And (Not (DifferentiableAt ğ•œ f x)) (Membership.mem s 0)))","decl":"theorem fderiv_mem_iff {f : E â†’ F} {s : Set (E â†’L[ğ•œ] F)} {x : E} : fderiv ğ•œ f x âˆˆ s â†”\n    DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ s âˆ¨ Â¬DifferentiableAt ğ•œ f x âˆ§ (0 : E â†’L[ğ•œ] F) âˆˆ s := by\n  by_cases hx : DifferentiableAt ğ•œ f x <;> simp [fderiv_zero_of_not_differentiableAt, *]\n\n"}
{"name":"fderivWithin_mem_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nt : Set E\ns : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nx : E\nâŠ¢ Iff (Membership.mem s (fderivWithin ğ•œ f t x)) (Or (And (DifferentiableWithinAt ğ•œ f t x) (Membership.mem s (fderivWithin ğ•œ f t x))) (And (Not (DifferentiableWithinAt ğ•œ f t x)) (Membership.mem s 0)))","decl":"theorem fderivWithin_mem_iff {f : E â†’ F} {t : Set E} {s : Set (E â†’L[ğ•œ] F)} {x : E} :\n    fderivWithin ğ•œ f t x âˆˆ s â†”\n      DifferentiableWithinAt ğ•œ f t x âˆ§ fderivWithin ğ•œ f t x âˆˆ s âˆ¨\n        Â¬DifferentiableWithinAt ğ•œ f t x âˆ§ (0 : E â†’L[ğ•œ] F) âˆˆ s := by\n  by_cases hx : DifferentiableWithinAt ğ•œ f t x <;>\n    simp [fderivWithin_zero_of_not_differentiableWithinAt, *]\n\n"}
{"name":"Asymptotics.IsBigO.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nxâ‚€ : E\nn : Nat\nh : Asymptotics.IsBigO (nhdsWithin xâ‚€ s) f fun x => HPow.hPow (Norm.norm (HSub.hSub x xâ‚€)) n\nhxâ‚€ : Membership.mem s xâ‚€\nhn : LT.lt 1 n\nâŠ¢ HasFDerivWithinAt f 0 s xâ‚€","decl":"theorem Asymptotics.IsBigO.hasFDerivWithinAt {s : Set E} {xâ‚€ : E} {n : â„•}\n    (h : f =O[ğ“[s] xâ‚€] fun x => â€–x - xâ‚€â€– ^ n) (hxâ‚€ : xâ‚€ âˆˆ s) (hn : 1 < n) :\n    HasFDerivWithinAt f (0 : E â†’L[ğ•œ] F) s xâ‚€ := by\n  simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO,\n    h.eq_zero_of_norm_pow_within hxâ‚€ hn.ne_bot, zero_apply, sub_zero,\n    h.trans_isLittleO ((isLittleO_pow_sub_sub xâ‚€ hn).mono nhdsWithin_le_nhds)]\n\n"}
{"name":"Asymptotics.IsBigO.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nn : Nat\nh : Asymptotics.IsBigO (nhds xâ‚€) f fun x => HPow.hPow (Norm.norm (HSub.hSub x xâ‚€)) n\nhn : LT.lt 1 n\nâŠ¢ HasFDerivAt f 0 xâ‚€","decl":"theorem Asymptotics.IsBigO.hasFDerivAt {xâ‚€ : E} {n : â„•} (h : f =O[ğ“ xâ‚€] fun x => â€–x - xâ‚€â€– ^ n)\n    (hn : 1 < n) : HasFDerivAt f (0 : E â†’L[ğ•œ] F) xâ‚€ := by\n  rw [â† nhdsWithin_univ] at h\n  exact (h.hasFDerivWithinAt (mem_univ _) hn).hasFDerivAt_of_univ\n\n"}
{"name":"HasFDerivWithinAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nxâ‚€ : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nh : HasFDerivWithinAt f f' s xâ‚€\nâŠ¢ Asymptotics.IsBigO (nhdsWithin xâ‚€ s) (fun x => HSub.hSub (f x) (f xâ‚€)) fun x => HSub.hSub x xâ‚€","decl":"nonrec theorem HasFDerivWithinAt.isBigO_sub {f : E â†’ F} {s : Set E} {xâ‚€ : E} {f' : E â†’L[ğ•œ] F}\n    (h : HasFDerivWithinAt f f' s xâ‚€) : (f Â· - f xâ‚€) =O[ğ“[s] xâ‚€] (Â· - xâ‚€) :=\n  h.isBigO_sub\n\n"}
{"name":"DifferentiableWithinAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nxâ‚€ : E\nh : DifferentiableWithinAt ğ•œ f s xâ‚€\nâŠ¢ Asymptotics.IsBigO (nhdsWithin xâ‚€ s) (fun x => HSub.hSub (f x) (f xâ‚€)) fun x => HSub.hSub x xâ‚€","decl":"lemma DifferentiableWithinAt.isBigO_sub {f : E â†’ F} {s : Set E} {xâ‚€ : E}\n    (h : DifferentiableWithinAt ğ•œ f s xâ‚€) : (f Â· - f xâ‚€) =O[ğ“[s] xâ‚€] (Â· - xâ‚€) :=\n  h.hasFDerivWithinAt.isBigO_sub\n\n"}
{"name":"HasFDerivAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nh : HasFDerivAt f f' xâ‚€\nâŠ¢ Asymptotics.IsBigO (nhds xâ‚€) (fun x => HSub.hSub (f x) (f xâ‚€)) fun x => HSub.hSub x xâ‚€","decl":"nonrec theorem HasFDerivAt.isBigO_sub {f : E â†’ F} {xâ‚€ : E} {f' : E â†’L[ğ•œ] F}\n    (h : HasFDerivAt f f' xâ‚€) : (f Â· - f xâ‚€) =O[ğ“ xâ‚€] (Â· - xâ‚€) :=\n  h.isBigO_sub\n\n"}
{"name":"DifferentiableAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nh : DifferentiableAt ğ•œ f xâ‚€\nâŠ¢ Asymptotics.IsBigO (nhds xâ‚€) (fun x => HSub.hSub (f x) (f xâ‚€)) fun x => HSub.hSub x xâ‚€","decl":"nonrec theorem DifferentiableAt.isBigO_sub {f : E â†’ F} {xâ‚€ : E} (h : DifferentiableAt ğ•œ f xâ‚€) :\n    (f Â· - f xâ‚€) =O[ğ“ xâ‚€] (Â· - xâ‚€) :=\n  h.hasFDerivAt.isBigO_sub\n\n"}
{"name":"HasFDerivAtFilter.tendsto_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nhL : LE.le L (nhds x)\nh : HasFDerivAtFilter f f' x L\nâŠ¢ Filter.Tendsto f L (nhds (f x))","decl":"theorem HasFDerivAtFilter.tendsto_nhds (hL : L â‰¤ ğ“ x) (h : HasFDerivAtFilter f f' x L) :\n    Tendsto f L (ğ“ (f x)) := by\n  have : Tendsto (fun x' => f x' - f x) L (ğ“ 0) := by\n    refine h.isBigO_sub.trans_tendsto (Tendsto.mono_left ?_ hL)\n    rw [â† sub_self x]\n    exact tendsto_id.sub tendsto_const_nhds\n  have := this.add (tendsto_const_nhds (x := f x))\n  rw [zero_add (f x)] at this\n  exact this.congr (by simp only [sub_add_cancel, eq_self_iff_true, forall_const])\n\n"}
{"name":"HasFDerivWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nâŠ¢ ContinuousWithinAt f s x","decl":"theorem HasFDerivWithinAt.continuousWithinAt (h : HasFDerivWithinAt f f' s x) :\n    ContinuousWithinAt f s x :=\n  HasFDerivAtFilter.tendsto_nhds inf_le_left h\n\n"}
{"name":"HasFDerivAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nâŠ¢ ContinuousAt f x","decl":"theorem HasFDerivAt.continuousAt (h : HasFDerivAt f f' x) : ContinuousAt f x :=\n  HasFDerivAtFilter.tendsto_nhds le_rfl h\n\n"}
{"name":"DifferentiableWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ ContinuousWithinAt f s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.continuousWithinAt (h : DifferentiableWithinAt ğ•œ f s x) :\n    ContinuousWithinAt f s x :=\n  let âŸ¨_, hf'âŸ© := h\n  hf'.continuousWithinAt\n\n"}
{"name":"DifferentiableAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : DifferentiableAt ğ•œ f x\nâŠ¢ ContinuousAt f x","decl":"@[fun_prop]\ntheorem DifferentiableAt.continuousAt (h : DifferentiableAt ğ•œ f x) : ContinuousAt f x :=\n  let âŸ¨_, hf'âŸ© := h\n  hf'.continuousAt\n\n"}
{"name":"DifferentiableOn.continuousOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : DifferentiableOn ğ•œ f s\nâŠ¢ ContinuousOn f s","decl":"@[fun_prop]\ntheorem DifferentiableOn.continuousOn (h : DifferentiableOn ğ•œ f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuousWithinAt\n\n"}
{"name":"Differentiable.continuous","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nh : Differentiable ğ•œ f\nâŠ¢ Continuous f","decl":"@[fun_prop]\ntheorem Differentiable.continuous (h : Differentiable ğ•œ f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (h x).continuousAt\n\n"}
{"name":"HasStrictFDerivAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nâŠ¢ ContinuousAt f x","decl":"protected theorem HasStrictFDerivAt.continuousAt (hf : HasStrictFDerivAt f f' x) :\n    ContinuousAt f x :=\n  hf.hasFDerivAt.continuousAt\n\n"}
{"name":"HasStrictFDerivAt.isBigO_sub_rev","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nhf : HasStrictFDerivAt f (â†‘f') x\nâŠ¢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun p => HSub.hSub p.1 p.2) fun p => HSub.hSub (f p.1) (f p.2)","decl":"theorem HasStrictFDerivAt.isBigO_sub_rev {f' : E â‰ƒL[ğ•œ] F}\n    (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) x) :\n    (fun p : E Ã— E => p.1 - p.2) =O[ğ“ (x, x)] fun p : E Ã— E => f p.1 - f p.2 :=\n  ((f'.isBigO_comp_rev _ _).trans\n      (hf.isLittleO.trans_isBigO (f'.isBigO_comp_rev _ _)).right_isBigO_add).congr\n    (fun _ => rfl) fun _ => sub_add_cancel _ _\n\n"}
{"name":"HasFDerivAtFilter.isBigO_sub_rev","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nhf : HasFDerivAtFilter f f' x L\nC : NNReal\nhf' : AntilipschitzWith C â‡‘f'\nâŠ¢ Asymptotics.IsBigO L (fun x' => HSub.hSub x' x) fun x' => HSub.hSub (f x') (f x)","decl":"theorem HasFDerivAtFilter.isBigO_sub_rev (hf : HasFDerivAtFilter f f' x L) {C}\n    (hf' : AntilipschitzWith C f') : (fun x' => x' - x) =O[L] fun x' => f x' - f x :=\n  have : (fun x' => x' - x) =O[L] fun x' => f' (x' - x) :=\n    isBigO_iff.2 âŸ¨C, Eventually.of_forall fun _ => ZeroHomClass.bound_of_antilipschitz f' hf' _âŸ©\n  (this.trans (hf.isLittleO.trans_isBigO this).right_isBigO_add).congr (fun _ => rfl) fun _ =>\n    sub_add_cancel _ _\n\n"}
{"name":"hasFDerivWithinAt_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivWithinAt f f' t x)","decl":"theorem hasFDerivWithinAt_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    HasFDerivWithinAt f f' s x â†” HasFDerivWithinAt f f' t x :=\n  calc\n    HasFDerivWithinAt f f' s x â†” HasFDerivWithinAt f f' (s \\ {y}) x :=\n      (hasFDerivWithinAt_diff_singleton _).symm\n    _ â†” HasFDerivWithinAt f f' (t \\ {y}) x := by\n      suffices ğ“[s \\ {y}] x = ğ“[t \\ {y}] x by simp only [HasFDerivWithinAt, this]\n      simpa only [set_eventuallyEq_iff_inf_principal, â† nhdsWithin_inter', diff_eq,\n        inter_comm] using h\n    _ â†” HasFDerivWithinAt f f' t x := hasFDerivWithinAt_diff_singleton _\n\n"}
{"name":"hasFDerivWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\nâŠ¢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivWithinAt f f' t x)","decl":"theorem hasFDerivWithinAt_congr_set (h : s =á¶ [ğ“ x] t) :\n    HasFDerivWithinAt f f' s x â†” HasFDerivWithinAt f f' t x :=\n  hasFDerivWithinAt_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"differentiableWithinAt_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f s x) (DifferentiableWithinAt ğ•œ f t x)","decl":"theorem differentiableWithinAt_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    DifferentiableWithinAt ğ•œ f s x â†” DifferentiableWithinAt ğ•œ f t x :=\n  exists_congr fun _ => hasFDerivWithinAt_congr_set' _ h\n\n"}
{"name":"differentiableWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ f s x) (DifferentiableWithinAt ğ•œ f t x)","decl":"theorem differentiableWithinAt_congr_set (h : s =á¶ [ğ“ x] t) :\n    DifferentiableWithinAt ğ•œ f s x â†” DifferentiableWithinAt ğ•œ f t x :=\n  exists_congr fun _ => hasFDerivWithinAt_congr_set h\n\n"}
{"name":"fderivWithin_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ f t x)","decl":"theorem fderivWithin_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    fderivWithin ğ•œ f s x = fderivWithin ğ•œ f t x := by\n  classical\n  simp only [fderivWithin, differentiableWithinAt_congr_set' _ h, hasFDerivWithinAt_congr_set' _ h]\n\n"}
{"name":"fderivWithin_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\nâŠ¢ Eq (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ f t x)","decl":"theorem fderivWithin_congr_set (h : s =á¶ [ğ“ x] t) : fderivWithin ğ•œ f s x = fderivWithin ğ•œ f t x :=\n  fderivWithin_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"fderivWithin_eventually_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ (nhds x).EventuallyEq (fderivWithin ğ•œ f s) (fderivWithin ğ•œ f t)","decl":"theorem fderivWithin_eventually_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    fderivWithin ğ•œ f s =á¶ [ğ“ x] fderivWithin ğ•œ f t :=\n  (eventually_nhds_nhdsWithin.2 h).mono fun _ => fderivWithin_congr_set' y\n\n"}
{"name":"fderivWithin_eventually_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\nâŠ¢ (nhds x).EventuallyEq (fderivWithin ğ•œ f s) (fderivWithin ğ•œ f t)","decl":"theorem fderivWithin_eventually_congr_set (h : s =á¶ [ğ“ x] t) :\n    fderivWithin ğ•œ f s =á¶ [ğ“ x] fderivWithin ğ•œ f t :=\n  fderivWithin_eventually_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"Filter.EventuallyEq.hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nfâ‚€' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : (nhds x).EventuallyEq fâ‚€ fâ‚\nh' : âˆ€ (y : E), Eq (fâ‚€' y) (fâ‚' y)\nâŠ¢ Iff (HasStrictFDerivAt fâ‚€ fâ‚€' x) (HasStrictFDerivAt fâ‚ fâ‚' x)","decl":"theorem Filter.EventuallyEq.hasStrictFDerivAt_iff (h : fâ‚€ =á¶ [ğ“ x] fâ‚) (h' : âˆ€ y, fâ‚€' y = fâ‚' y) :\n    HasStrictFDerivAt fâ‚€ fâ‚€' x â†” HasStrictFDerivAt fâ‚ fâ‚' x := by\n  rw [hasStrictFDerivAt_iff_isLittleOTVS, hasStrictFDerivAt_iff_isLittleOTVS]\n  refine isLittleOTVS_congr ((h.prod_mk_nhds h).mono ?_) .rfl\n  rintro p âŸ¨hpâ‚, hpâ‚‚âŸ©\n  simp only [*]\n\n"}
{"name":"HasStrictFDerivAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' g' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasStrictFDerivAt f f' x\nh' : Eq f' g'\nâŠ¢ HasStrictFDerivAt f g' x","decl":"theorem HasStrictFDerivAt.congr_fderiv (h : HasStrictFDerivAt f f' x) (h' : f' = g') :\n    HasStrictFDerivAt f g' x :=\n  h' â–¸ h\n\n"}
{"name":"HasFDerivAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' g' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nh' : Eq f' g'\nâŠ¢ HasFDerivAt f g' x","decl":"theorem HasFDerivAt.congr_fderiv (h : HasFDerivAt f f' x) (h' : f' = g') : HasFDerivAt f g' x :=\n  h' â–¸ h\n\n"}
{"name":"HasFDerivWithinAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' g' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nh' : Eq f' g'\nâŠ¢ HasFDerivWithinAt f g' s x","decl":"theorem HasFDerivWithinAt.congr_fderiv (h : HasFDerivWithinAt f f' s x) (h' : f' = g') :\n    HasFDerivWithinAt f g' s x :=\n  h' â–¸ h\n\n"}
{"name":"HasStrictFDerivAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasStrictFDerivAt f f' x\nhâ‚ : (nhds x).EventuallyEq f fâ‚\nâŠ¢ HasStrictFDerivAt fâ‚ f' x","decl":"theorem HasStrictFDerivAt.congr_of_eventuallyEq (h : HasStrictFDerivAt f f' x)\n    (hâ‚ : f =á¶ [ğ“ x] fâ‚) : HasStrictFDerivAt fâ‚ f' x :=\n  (hâ‚.hasStrictFDerivAt_iff fun _ => rfl).1 h\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivAtFilter_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nfâ‚€' fâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nhâ‚€ : L.EventuallyEq fâ‚€ fâ‚\nhx : Eq (fâ‚€ x) (fâ‚ x)\nhâ‚ : âˆ€ (x : E), Eq (fâ‚€' x) (fâ‚' x)\nâŠ¢ Iff (HasFDerivAtFilter fâ‚€ fâ‚€' x L) (HasFDerivAtFilter fâ‚ fâ‚' x L)","decl":"theorem Filter.EventuallyEq.hasFDerivAtFilter_iff (hâ‚€ : fâ‚€ =á¶ [L] fâ‚) (hx : fâ‚€ x = fâ‚ x)\n    (hâ‚ : âˆ€ x, fâ‚€' x = fâ‚' x) : HasFDerivAtFilter fâ‚€ fâ‚€' x L â†” HasFDerivAtFilter fâ‚ fâ‚' x L := by\n  simp only [hasFDerivAtFilter_iff_isLittleOTVS]\n  exact isLittleOTVS_congr (hâ‚€.mono fun y hy => by simp only [hy, hâ‚, hx]) .rfl\n\n"}
{"name":"HasFDerivAtFilter.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nh : HasFDerivAtFilter f f' x L\nhL : L.EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ HasFDerivAtFilter fâ‚ f' x L","decl":"theorem HasFDerivAtFilter.congr_of_eventuallyEq (h : HasFDerivAtFilter f f' x L) (hL : fâ‚ =á¶ [L] f)\n    (hx : fâ‚ x = f x) : HasFDerivAtFilter fâ‚ f' x L :=\n  (hL.hasFDerivAtFilter_iff hx fun _ => rfl).2 h\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : (nhds x).EventuallyEq fâ‚€ fâ‚\nâŠ¢ Iff (HasFDerivAt fâ‚€ f' x) (HasFDerivAt fâ‚ f' x)","decl":"theorem Filter.EventuallyEq.hasFDerivAt_iff (h : fâ‚€ =á¶ [ğ“ x] fâ‚) :\n    HasFDerivAt fâ‚€ f' x â†” HasFDerivAt fâ‚ f' x :=\n  h.hasFDerivAtFilter_iff h.eq_of_nhds fun _ => _root_.rfl\n\n"}
{"name":"Filter.EventuallyEq.differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nx : E\nh : (nhds x).EventuallyEq fâ‚€ fâ‚\nâŠ¢ Iff (DifferentiableAt ğ•œ fâ‚€ x) (DifferentiableAt ğ•œ fâ‚ x)","decl":"theorem Filter.EventuallyEq.differentiableAt_iff (h : fâ‚€ =á¶ [ğ“ x] fâ‚) :\n    DifferentiableAt ğ•œ fâ‚€ x â†” DifferentiableAt ğ•œ fâ‚ x :=\n  exists_congr fun _ => h.hasFDerivAt_iff\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq fâ‚€ fâ‚\nhx : Eq (fâ‚€ x) (fâ‚ x)\nâŠ¢ Iff (HasFDerivWithinAt fâ‚€ f' s x) (HasFDerivWithinAt fâ‚ f' s x)","decl":"theorem Filter.EventuallyEq.hasFDerivWithinAt_iff (h : fâ‚€ =á¶ [ğ“[s] x] fâ‚) (hx : fâ‚€ x = fâ‚ x) :\n    HasFDerivWithinAt fâ‚€ f' s x â†” HasFDerivWithinAt fâ‚ f' s x :=\n  h.hasFDerivAtFilter_iff hx fun _ => _root_.rfl\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq fâ‚€ fâ‚\nhx : Membership.mem s x\nâŠ¢ Iff (HasFDerivWithinAt fâ‚€ f' s x) (HasFDerivWithinAt fâ‚ f' s x)","decl":"theorem Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem (h : fâ‚€ =á¶ [ğ“[s] x] fâ‚) (hx : x âˆˆ s) :\n    HasFDerivWithinAt fâ‚€ f' s x â†” HasFDerivWithinAt fâ‚ f' s x :=\n  h.hasFDerivWithinAt_iff (h.eq_of_nhdsWithin hx)\n\n"}
{"name":"Filter.EventuallyEq.differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq fâ‚€ fâ‚\nhx : Eq (fâ‚€ x) (fâ‚ x)\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ fâ‚€ s x) (DifferentiableWithinAt ğ•œ fâ‚ s x)","decl":"theorem Filter.EventuallyEq.differentiableWithinAt_iff (h : fâ‚€ =á¶ [ğ“[s] x] fâ‚) (hx : fâ‚€ x = fâ‚ x) :\n    DifferentiableWithinAt ğ•œ fâ‚€ s x â†” DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  exists_congr fun _ => h.hasFDerivWithinAt_iff hx\n\n"}
{"name":"Filter.EventuallyEq.differentiableWithinAt_iff_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚€ fâ‚ : E â†’ F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq fâ‚€ fâ‚\nhx : Membership.mem s x\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ fâ‚€ s x) (DifferentiableWithinAt ğ•œ fâ‚ s x)","decl":"theorem Filter.EventuallyEq.differentiableWithinAt_iff_of_mem (h : fâ‚€ =á¶ [ğ“[s] x] fâ‚) (hx : x âˆˆ s) :\n    DifferentiableWithinAt ğ•œ fâ‚€ s x â†” DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  h.differentiableWithinAt_iff (h.eq_of_nhdsWithin hx)\n\n"}
{"name":"HasFDerivWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' s x\nht : Set.EqOn fâ‚ f t\nhx : Eq (fâ‚ x) (f x)\nhâ‚ : HasSubset.Subset t s\nâŠ¢ HasFDerivWithinAt fâ‚ f' t x","decl":"theorem HasFDerivWithinAt.congr_mono (h : HasFDerivWithinAt f f' s x) (ht : EqOn fâ‚ f t)\n    (hx : fâ‚ x = f x) (hâ‚ : t âŠ† s) : HasFDerivWithinAt fâ‚ f' t x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq (h.mono hâ‚) (Filter.mem_inf_of_right ht) hx\n\n"}
{"name":"HasFDerivWithinAt.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Set.EqOn fâ‚ f s\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ HasFDerivWithinAt fâ‚ f' s x","decl":"theorem HasFDerivWithinAt.congr (h : HasFDerivWithinAt f f' s x) (hs : EqOn fâ‚ f s)\n    (hx : fâ‚ x = f x) : HasFDerivWithinAt fâ‚ f' s x :=\n  h.congr_mono hs hx (Subset.refl _)\n\n"}
{"name":"HasFDerivWithinAt.congr'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Set.EqOn fâ‚ f s\nhx : Membership.mem s x\nâŠ¢ HasFDerivWithinAt fâ‚ f' s x","decl":"theorem HasFDerivWithinAt.congr' (h : HasFDerivWithinAt f f' s x) (hs : EqOn fâ‚ f s) (hx : x âˆˆ s) :\n    HasFDerivWithinAt fâ‚ f' s x :=\n  h.congr hs (hs hx)\n\n"}
{"name":"HasFDerivWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ HasFDerivWithinAt fâ‚ f' s x","decl":"theorem HasFDerivWithinAt.congr_of_eventuallyEq (h : HasFDerivWithinAt f f' s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) : HasFDerivWithinAt fâ‚ f' s x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq h hâ‚ hx\n\n"}
{"name":"HasFDerivAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nhâ‚ : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ HasFDerivAt fâ‚ f' x","decl":"theorem HasFDerivAt.congr_of_eventuallyEq (h : HasFDerivAt f f' x) (hâ‚ : fâ‚ =á¶ [ğ“ x] f) :\n    HasFDerivAt fâ‚ f' x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq h hâ‚ (mem_of_mem_nhds hâ‚ :)\n\n"}
{"name":"DifferentiableWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns t : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nht : Set.EqOn fâ‚ f t\nhx : Eq (fâ‚ x) (f x)\nhâ‚ : HasSubset.Subset t s\nâŠ¢ DifferentiableWithinAt ğ•œ fâ‚ t x","decl":"theorem DifferentiableWithinAt.congr_mono (h : DifferentiableWithinAt ğ•œ f s x) (ht : EqOn fâ‚ f t)\n    (hx : fâ‚ x = f x) (hâ‚ : t âŠ† s) : DifferentiableWithinAt ğ•œ fâ‚ t x :=\n  (HasFDerivWithinAt.congr_mono h.hasFDerivWithinAt ht hx hâ‚).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nht : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ DifferentiableWithinAt ğ•œ fâ‚ s x","decl":"theorem DifferentiableWithinAt.congr (h : DifferentiableWithinAt ğ•œ f s x) (ht : âˆ€ x âˆˆ s, fâ‚ x = f x)\n    (hx : fâ‚ x = f x) : DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  DifferentiableWithinAt.congr_mono h ht hx (Subset.refl _)\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ DifferentiableWithinAt ğ•œ fâ‚ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq (h : DifferentiableWithinAt ğ•œ f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) : DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  (h.hasFDerivWithinAt.congr_of_eventuallyEq hâ‚ hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Membership.mem s x\nâŠ¢ DifferentiableWithinAt ğ•œ fâ‚ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq_of_mem (h : DifferentiableWithinAt ğ•œ f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) : DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  h.congr_of_eventuallyEq hâ‚ (mem_of_mem_nhdsWithin hx hâ‚ :)\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nhâ‚ : (nhdsWithin x (Insert.insert x s)).EventuallyEq fâ‚ f\nâŠ¢ DifferentiableWithinAt ğ•œ fâ‚ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq_insert (h : DifferentiableWithinAt ğ•œ f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[insert x s] x] f) : DifferentiableWithinAt ğ•œ fâ‚ s x :=\n  (h.insert.congr_of_eventuallyEq_of_mem hâ‚ (mem_insert _ _)).of_insert\n\n"}
{"name":"DifferentiableOn.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\ns t : Set E\nh : DifferentiableOn ğ•œ f s\nh' : âˆ€ (x : E), Membership.mem t x â†’ Eq (fâ‚ x) (f x)\nhâ‚ : HasSubset.Subset t s\nâŠ¢ DifferentiableOn ğ•œ fâ‚ t","decl":"theorem DifferentiableOn.congr_mono (h : DifferentiableOn ğ•œ f s) (h' : âˆ€ x âˆˆ t, fâ‚ x = f x)\n    (hâ‚ : t âŠ† s) : DifferentiableOn ğ•œ fâ‚ t := fun x hx => (h x (hâ‚ hx)).congr_mono h' (h' x hx) hâ‚\n\n"}
{"name":"DifferentiableOn.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\ns : Set E\nh : DifferentiableOn ğ•œ f s\nh' : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nâŠ¢ DifferentiableOn ğ•œ fâ‚ s","decl":"theorem DifferentiableOn.congr (h : DifferentiableOn ğ•œ f s) (h' : âˆ€ x âˆˆ s, fâ‚ x = f x) :\n    DifferentiableOn ğ•œ fâ‚ s := fun x hx => (h x hx).congr h' (h' x hx)\n\n"}
{"name":"differentiableOn_congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\ns : Set E\nh' : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nâŠ¢ Iff (DifferentiableOn ğ•œ fâ‚ s) (DifferentiableOn ğ•œ f s)","decl":"theorem differentiableOn_congr (h' : âˆ€ x âˆˆ s, fâ‚ x = f x) :\n    DifferentiableOn ğ•œ fâ‚ s â†” DifferentiableOn ğ•œ f s :=\n  âŸ¨fun h => DifferentiableOn.congr h fun y hy => (h' y hy).symm, fun h =>\n    DifferentiableOn.congr h h'âŸ©\n\n"}
{"name":"DifferentiableAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\nh : DifferentiableAt ğ•œ f x\nhL : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ DifferentiableAt ğ•œ fâ‚ x","decl":"theorem DifferentiableAt.congr_of_eventuallyEq (h : DifferentiableAt ğ•œ f x) (hL : fâ‚ =á¶ [ğ“ x] f) :\n    DifferentiableAt ğ•œ fâ‚ x :=\n  hL.differentiableAt_iff.2 h\n\n"}
{"name":"DifferentiableWithinAt.fderivWithin_congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns t : Set E\nh : DifferentiableWithinAt ğ•œ f s x\nhs : Set.EqOn fâ‚ f t\nhx : Eq (fâ‚ x) (f x)\nhxt : UniqueDiffWithinAt ğ•œ t x\nhâ‚ : HasSubset.Subset t s\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ t x) (fderivWithin ğ•œ f s x)","decl":"theorem DifferentiableWithinAt.fderivWithin_congr_mono (h : DifferentiableWithinAt ğ•œ f s x)\n    (hs : EqOn fâ‚ f t) (hx : fâ‚ x = f x) (hxt : UniqueDiffWithinAt ğ•œ t x) (hâ‚ : t âŠ† s) :\n    fderivWithin ğ•œ fâ‚ t x = fderivWithin ğ•œ f s x :=\n  (HasFDerivWithinAt.congr_mono h.hasFDerivWithinAt hs hx hâ‚).fderivWithin hxt\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq (hs : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x := by\n  classical\n  simp only [fderivWithin, DifferentiableWithinAt, hs.hasFDerivWithinAt_iff hx]\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Membership.mem s x\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_of_mem (hs : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x :=\n  hs.fderivWithin_eq (mem_of_mem_nhdsWithin hx hs :)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : (nhdsWithin x (Insert.insert x s)).EventuallyEq fâ‚ f\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_of_insert (hs : fâ‚ =á¶ [ğ“[insert x s] x] f) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x := by\n  apply Filter.EventuallyEq.fderivWithin_eq (nhdsWithin_mono _ (subset_insert x s) hs)\n  exact (mem_of_mem_nhdsWithin (mem_insert x s) hs :)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns t : Set E\nhs : (nhdsWithin x s).EventuallyEq fâ‚ f\nht : HasSubset.Subset t s\nâŠ¢ (nhdsWithin x s).EventuallyEq (fderivWithin ğ•œ fâ‚ t) (fderivWithin ğ•œ f t)","decl":"theorem Filter.EventuallyEq.fderivWithin' (hs : fâ‚ =á¶ [ğ“[s] x] f) (ht : t âŠ† s) :\n    fderivWithin ğ•œ fâ‚ t =á¶ [ğ“[s] x] fderivWithin ğ•œ f t :=\n  (eventually_eventually_nhdsWithin.2 hs).mp <|\n    eventually_mem_nhdsWithin.mono fun _y hys hs =>\n      EventuallyEq.fderivWithin_eq (hs.filter_mono <| nhdsWithin_mono _ ht)\n        (hs.self_of_nhdsWithin hys)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq fâ‚ f\nâŠ¢ (nhdsWithin x s).EventuallyEq (fderivWithin ğ•œ fâ‚ s) (fderivWithin ğ•œ f s)","decl":"protected theorem Filter.EventuallyEq.fderivWithin (hs : fâ‚ =á¶ [ğ“[s] x] f) :\n    fderivWithin ğ•œ fâ‚ s =á¶ [ğ“[s] x] fderivWithin ğ•œ f s :=\n  hs.fderivWithin' Subset.rfl\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nh : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_nhds (h : fâ‚ =á¶ [ğ“ x] f) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x :=\n  (h.filter_mono nhdsWithin_le_nhds).fderivWithin_eq h.self_of_nhds\n\n"}
{"name":"fderivWithin_congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : Set.EqOn fâ‚ f s\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem fderivWithin_congr (hs : EqOn fâ‚ f s) (hx : fâ‚ x = f x) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x :=\n  (hs.eventuallyEq.filter_mono inf_le_right).fderivWithin_eq hx\n\n"}
{"name":"fderivWithin_congr'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\ns : Set E\nhs : Set.EqOn fâ‚ f s\nhx : Membership.mem s x\nâŠ¢ Eq (fderivWithin ğ•œ fâ‚ s x) (fderivWithin ğ•œ f s x)","decl":"theorem fderivWithin_congr' (hs : EqOn fâ‚ f s) (hx : x âˆˆ s) :\n    fderivWithin ğ•œ fâ‚ s x = fderivWithin ğ•œ f s x :=\n  fderivWithin_congr hs (hs hx)\n\n"}
{"name":"Filter.EventuallyEq.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\nh : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ Eq (fderiv ğ•œ fâ‚ x) (fderiv ğ•œ f x)","decl":"theorem Filter.EventuallyEq.fderiv_eq (h : fâ‚ =á¶ [ğ“ x] f) : fderiv ğ•œ fâ‚ x = fderiv ğ•œ f x := by\n  rw [â† fderivWithin_univ, â† fderivWithin_univ, h.fderivWithin_eq_nhds]\n\n"}
{"name":"Filter.EventuallyEq.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\nh : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ (nhds x).EventuallyEq (fderiv ğ•œ fâ‚) (fderiv ğ•œ f)","decl":"protected theorem Filter.EventuallyEq.fderiv (h : fâ‚ =á¶ [ğ“ x] f) : fderiv ğ•œ fâ‚ =á¶ [ğ“ x] fderiv ğ•œ f :=\n  h.eventuallyEq_nhds.mono fun _ h => h.fderiv_eq\n\n"}
{"name":"hasStrictFDerivAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ HasStrictFDerivAt id (ContinuousLinearMap.id ğ•œ E) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_id (x : E) : HasStrictFDerivAt id (id ğ•œ E) x :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp\n\n"}
{"name":"hasFDerivAtFilter_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nL : Filter E\nâŠ¢ HasFDerivAtFilter id (ContinuousLinearMap.id ğ•œ E) x L","decl":"theorem hasFDerivAtFilter_id (x : E) (L : Filter E) : HasFDerivAtFilter id (id ğ•œ E) x L :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp\n\n"}
{"name":"hasFDerivWithinAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nâŠ¢ HasFDerivWithinAt id (ContinuousLinearMap.id ğ•œ E) s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_id (x : E) (s : Set E) : HasFDerivWithinAt id (id ğ•œ E) s x :=\n  hasFDerivAtFilter_id _ _\n\n"}
{"name":"hasFDerivAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ HasFDerivAt id (ContinuousLinearMap.id ğ•œ E) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_id (x : E) : HasFDerivAt id (id ğ•œ E) x :=\n  hasFDerivAtFilter_id _ _\n\n"}
{"name":"differentiableAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ DifferentiableAt ğ•œ id x","decl":"@[simp, fun_prop]\ntheorem differentiableAt_id : DifferentiableAt ğ•œ id x :=\n  (hasFDerivAt_id x).differentiableAt\n\n"}
{"name":"differentiableAt_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ DifferentiableAt ğ•œ (fun x => x) x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[simp]\ntheorem differentiableAt_id' : DifferentiableAt ğ•œ (fun x => x) x :=\n  (hasFDerivAt_id x).differentiableAt\n\n"}
{"name":"differentiableWithinAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nâŠ¢ DifferentiableWithinAt ğ•œ id s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_id : DifferentiableWithinAt ğ•œ id s x :=\n  differentiableAt_id.differentiableWithinAt\n\n"}
{"name":"differentiableWithinAt_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => x) s x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[fun_prop]\ntheorem differentiableWithinAt_id' : DifferentiableWithinAt ğ•œ (fun x => x) s x :=\n  differentiableWithinAt_id\n\n"}
{"name":"differentiable_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Differentiable ğ•œ id","decl":"@[simp, fun_prop]\ntheorem differentiable_id : Differentiable ğ•œ (id : E â†’ E) := fun _ => differentiableAt_id\n\n"}
{"name":"differentiable_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Differentiable ğ•œ fun x => x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[simp]\ntheorem differentiable_id' : Differentiable ğ•œ fun x : E => x := fun _ => differentiableAt_id\n\n"}
{"name":"differentiableOn_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ DifferentiableOn ğ•œ id s","decl":"@[fun_prop]\ntheorem differentiableOn_id : DifferentiableOn ğ•œ id s :=\n  differentiable_id.differentiableOn\n\n"}
{"name":"fderiv_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ Eq (fderiv ğ•œ id x) (ContinuousLinearMap.id ğ•œ E)","decl":"@[simp]\ntheorem fderiv_id : fderiv ğ•œ id x = id ğ•œ E :=\n  HasFDerivAt.fderiv (hasFDerivAt_id x)\n\n"}
{"name":"fderiv_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ Eq (fderiv ğ•œ (fun x => x) x) (ContinuousLinearMap.id ğ•œ E)","decl":"@[simp]\ntheorem fderiv_id' : fderiv ğ•œ (fun x : E => x) x = ContinuousLinearMap.id ğ•œ E :=\n  fderiv_id\n\n"}
{"name":"fderivWithin_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ id s x) (ContinuousLinearMap.id ğ•œ E)","decl":"theorem fderivWithin_id (hxs : UniqueDiffWithinAt ğ•œ s x) : fderivWithin ğ•œ id s x = id ğ•œ E := by\n  rw [DifferentiableAt.fderivWithin differentiableAt_id hxs]\n  exact fderiv_id\n\n"}
{"name":"fderivWithin_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => x) s x) (ContinuousLinearMap.id ğ•œ E)","decl":"theorem fderivWithin_id' (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x : E => x) s x = ContinuousLinearMap.id ğ•œ E :=\n  fderivWithin_id hxs\n\n"}
{"name":"hasStrictFDerivAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nx : E\nâŠ¢ HasStrictFDerivAt (fun x => c) 0 x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_const (c : F) (x : E) :\n    HasStrictFDerivAt (fun _ => c) (0 : E â†’L[ğ•œ] F) x :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left fun _ => by\n    simp only [zero_apply, sub_self, Pi.zero_apply]\n\n"}
{"name":"hasFDerivAtFilter_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nx : E\nL : Filter E\nâŠ¢ HasFDerivAtFilter (fun x => c) 0 x L","decl":"theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\n    HasFDerivAtFilter (fun _ => c) (0 : E â†’L[ğ•œ] F) x L :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left fun _ => by\n    simp only [zero_apply, sub_self, Pi.zero_apply]\n\n"}
{"name":"hasFDerivWithinAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nx : E\ns : Set E\nâŠ¢ HasFDerivWithinAt (fun x => c) 0 s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_const (c : F) (x : E) (s : Set E) :\n    HasFDerivWithinAt (fun _ => c) (0 : E â†’L[ğ•œ] F) s x :=\n  hasFDerivAtFilter_const _ _ _\n\n"}
{"name":"hasFDerivAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nx : E\nâŠ¢ HasFDerivAt (fun x => c) 0 x","decl":"@[fun_prop]\ntheorem hasFDerivAt_const (c : F) (x : E) : HasFDerivAt (fun _ => c) (0 : E â†’L[ğ•œ] F) x :=\n  hasFDerivAtFilter_const _ _ _\n\n"}
{"name":"differentiableAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nc : F\nâŠ¢ DifferentiableAt ğ•œ (fun x => c) x","decl":"@[simp, fun_prop]\ntheorem differentiableAt_const (c : F) : DifferentiableAt ğ•œ (fun _ => c) x :=\n  âŸ¨0, hasFDerivAt_const c xâŸ©\n\n"}
{"name":"differentiableWithinAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\nc : F\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => c) s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_const (c : F) : DifferentiableWithinAt ğ•œ (fun _ => c) s x :=\n  DifferentiableAt.differentiableWithinAt (differentiableAt_const _)\n\n"}
{"name":"fderivWithin_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\nc : F\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => c) s x) 0","decl":"theorem fderivWithin_const_apply (c : F) : fderivWithin ğ•œ (fun _ => c) s x = 0 := by\n  rw [fderivWithin, if_pos]\n  apply hasFDerivWithinAt_const\n\n"}
{"name":"fderivWithin_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nc : F\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => c) s) 0","decl":"@[simp]\ntheorem fderivWithin_const (c : F) : fderivWithin ğ•œ (fun _ â†¦ c) s = 0 := by\n  ext\n  rw [fderivWithin_const_apply, Pi.zero_apply]\n\n"}
{"name":"fderiv_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nc : F\nâŠ¢ Eq (fderiv ğ•œ (fun x => c) x) 0","decl":"theorem fderiv_const_apply (c : F) : fderiv ğ•œ (fun _ => c) x = 0 :=\n  (hasFDerivAt_const c x).fderiv\n\n"}
{"name":"fderiv_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nâŠ¢ Eq (fderiv ğ•œ fun x => c) 0","decl":"@[simp]\ntheorem fderiv_const (c : F) : (fderiv ğ•œ fun _ : E => c) = 0 := by\n  rw [â† fderivWithin_univ, fderivWithin_const]\n\n"}
{"name":"differentiable_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\nâŠ¢ Differentiable ğ•œ fun x => c","decl":"@[simp, fun_prop]\ntheorem differentiable_const (c : F) : Differentiable ğ•œ fun _ : E => c := fun _ =>\n  differentiableAt_const _\n\n"}
{"name":"differentiableOn_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nc : F\nâŠ¢ DifferentiableOn ğ•œ (fun x => c) s","decl":"@[simp, fun_prop]\ntheorem differentiableOn_const (c : F) : DifferentiableOn ğ•œ (fun _ => c) s :=\n  (differentiable_const _).differentiableOn\n\n"}
{"name":"hasFDerivWithinAt_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ HasFDerivWithinAt f 0 (Singleton.singleton x) x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_singleton (f : E â†’ F) (x : E) :\n    HasFDerivWithinAt f (0 : E â†’L[ğ•œ] F) {x} x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_singleton, hasFDerivAtFilter_iff_isLittleO,\n    isLittleO_pure, ContinuousLinearMap.zero_apply, sub_self]\n\n"}
{"name":"hasFDerivAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nh : Subsingleton E\nf : E â†’ F\nx : E\nâŠ¢ HasFDerivAt f 0 x","decl":"@[fun_prop]\ntheorem hasFDerivAt_of_subsingleton [h : Subsingleton E] (f : E â†’ F) (x : E) :\n    HasFDerivAt f (0 : E â†’L[ğ•œ] F) x := by\n  rw [â† hasFDerivWithinAt_univ, subsingleton_univ.eq_singleton_of_mem (mem_univ x)]\n  exact hasFDerivWithinAt_singleton f x\n\n"}
{"name":"differentiableOn_empty","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ DifferentiableOn ğ•œ f EmptyCollection.emptyCollection","decl":"@[fun_prop]\ntheorem differentiableOn_empty : DifferentiableOn ğ•œ f âˆ… := fun _ => False.elim\n\n"}
{"name":"differentiableOn_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ DifferentiableOn ğ•œ f (Singleton.singleton x)","decl":"@[fun_prop]\ntheorem differentiableOn_singleton : DifferentiableOn ğ•œ f {x} :=\n  forall_eq.2 (hasFDerivWithinAt_singleton f x).differentiableWithinAt\n\n"}
{"name":"Set.Subsingleton.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhs : s.Subsingleton\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"@[fun_prop]\ntheorem Set.Subsingleton.differentiableOn (hs : s.Subsingleton) : DifferentiableOn ğ•œ f s :=\n  hs.induction_on differentiableOn_empty fun _ => differentiableOn_singleton\n\n"}
{"name":"hasFDerivAt_zero_of_eventually_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nc : F\nhf : (nhds x).EventuallyEq f fun x => c\nâŠ¢ HasFDerivAt f 0 x","decl":"theorem hasFDerivAt_zero_of_eventually_const (c : F) (hf : f =á¶ [ğ“ x] fun _ => c) :\n    HasFDerivAt f (0 : E â†’L[ğ•œ] F) x :=\n  (hasFDerivAt_const _ _).congr_of_eventuallyEq hf\n\n"}
{"name":"HasFDerivAt.le_of_lip'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nxâ‚€ : E\nhf : HasFDerivAt f f' xâ‚€\nC : Real\nhCâ‚€ : LE.le 0 C\nhlip : Filter.Eventually (fun x => LE.le (Norm.norm (HSub.hSub (f x) (f xâ‚€))) (HMul.hMul C (Norm.norm (HSub.hSub x xâ‚€)))) (nhds xâ‚€)\nâŠ¢ LE.le (Norm.norm f') C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz\non a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version\nonly assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/\ntheorem HasFDerivAt.le_of_lip' {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : HasFDerivAt f f' xâ‚€)\n    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) : â€–f'â€– â‰¤ C := by\n  refine le_of_forall_pos_le_add fun Îµ Îµ0 => opNorm_le_of_nhds_zero ?_ ?_\n  Â· exact add_nonneg hCâ‚€ Îµ0.le\n  rw [â† map_add_left_nhds_zero xâ‚€, eventually_map] at hlip\n  filter_upwards [isLittleO_iff.1 (hasFDerivAt_iff_isLittleO_nhds_zero.1 hf) Îµ0, hlip] with y hy hyC\n  rw [add_sub_cancel_left] at hyC\n  calc\n    â€–f' yâ€– â‰¤ â€–f (xâ‚€ + y) - f xâ‚€â€– + â€–f (xâ‚€ + y) - f xâ‚€ - f' yâ€– := norm_le_insert _ _\n    _ â‰¤ C * â€–yâ€– + Îµ * â€–yâ€– := add_le_add hyC hy\n    _ = (C + Îµ) * â€–yâ€– := (add_mul _ _ _).symm\n\n"}
{"name":"HasFDerivAt.le_of_lipschitzOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nxâ‚€ : E\nhf : HasFDerivAt f f' xâ‚€\ns : Set E\nhs : Membership.mem (nhds xâ‚€) s\nC : NNReal\nhlip : LipschitzOnWith C f s\nâŠ¢ LE.le (Norm.norm f') â†‘C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz\non a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. -/\ntheorem HasFDerivAt.le_of_lipschitzOn\n    {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : HasFDerivAt f f' xâ‚€)\n    {s : Set E} (hs : s âˆˆ ğ“ xâ‚€) {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–f'â€– â‰¤ C := by\n  refine hf.le_of_lip' C.coe_nonneg ?_\n  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)\n\n"}
{"name":"HasFDerivAt.le_of_lipschitz","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nxâ‚€ : E\nhf : HasFDerivAt f f' xâ‚€\nC : NNReal\nhlip : LipschitzWith C f\nâŠ¢ LE.le (Norm.norm f') â†‘C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `xâ‚€` and `C`-lipschitz\nthen its derivative at `xâ‚€` has norm bounded by `C`. -/\ntheorem HasFDerivAt.le_of_lipschitz {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : HasFDerivAt f f' xâ‚€)\n    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–f'â€– â‰¤ C :=\n  hf.le_of_lipschitzOn univ_mem (lipschitzOnWith_univ.2 hlip)\n\n"}
{"name":"norm_fderiv_le_of_lip'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nC : Real\nhCâ‚€ : LE.le 0 C\nhlip : Filter.Eventually (fun x => LE.le (Norm.norm (HSub.hSub (f x) (f xâ‚€))) (HMul.hMul C (Norm.norm (HSub.hSub x xâ‚€)))) (nhds xâ‚€)\nâŠ¢ LE.le (Norm.norm (fderiv ğ•œ f xâ‚€)) C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz\non a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`. This version\nonly assumes that `â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–` in a neighborhood of `x`. -/\ntheorem norm_fderiv_le_of_lip' {f : E â†’ F} {xâ‚€ : E}\n    {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  x in ğ“ xâ‚€, â€–f x - f xâ‚€â€– â‰¤ C * â€–x - xâ‚€â€–) :\n    â€–fderiv ğ•œ f xâ‚€â€– â‰¤ C := by\n  by_cases hf : DifferentiableAt ğ•œ f xâ‚€\n  Â· exact hf.hasFDerivAt.le_of_lip' hCâ‚€ hlip\n  Â· rw [fderiv_zero_of_not_differentiableAt hf]\n    simp [hCâ‚€]\n\n"}
{"name":"norm_fderiv_le_of_lipschitzOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\ns : Set E\nhs : Membership.mem (nhds xâ‚€) s\nC : NNReal\nhlip : LipschitzOnWith C f s\nâŠ¢ LE.le (Norm.norm (fderiv ğ•œ f xâ‚€)) â†‘C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz\non a neighborhood of `xâ‚€` then its derivative at `xâ‚€` has norm bounded by `C`.\nVersion using `fderiv`. -/\n-- Porting note: renamed so that dot-notation makes sense\ntheorem norm_fderiv_le_of_lipschitzOn {f : E â†’ F} {xâ‚€ : E} {s : Set E} (hs : s âˆˆ ğ“ xâ‚€)\n    {C : â„â‰¥0} (hlip : LipschitzOnWith C f s) : â€–fderiv ğ•œ f xâ‚€â€– â‰¤ C := by\n  refine norm_fderiv_le_of_lip' ğ•œ C.coe_nonneg ?_\n  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)\n\n"}
{"name":"norm_fderiv_le_of_lipschitz","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nC : NNReal\nhlip : LipschitzWith C f\nâŠ¢ LE.le (Norm.norm (fderiv ğ•œ f xâ‚€)) â†‘C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz then\nits derivative at `xâ‚€` has norm bounded by `C`.\nVersion using `fderiv`. -/\ntheorem norm_fderiv_le_of_lipschitz {f : E â†’ F} {xâ‚€ : E}\n    {C : â„â‰¥0} (hlip : LipschitzWith C f) : â€–fderiv ğ•œ f xâ‚€â€– â‰¤ C :=\n  norm_fderiv_le_of_lipschitzOn ğ•œ univ_mem (lipschitzOnWith_univ.2 hlip)\n\n"}
{"name":"HasStrictFDerivAt.of_nmem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Not (Membership.mem (tsupport f) x)\nâŠ¢ HasStrictFDerivAt f 0 x","decl":"theorem HasStrictFDerivAt.of_nmem_tsupport (h : x âˆ‰ tsupport f) :\n    HasStrictFDerivAt f (0 : E â†’L[ğ•œ] F) x := by\n  rw [not_mem_tsupport_iff_eventuallyEq] at h\n  exact (hasStrictFDerivAt_const (0 : F) x).congr_of_eventuallyEq h.symm\n\n"}
{"name":"HasFDerivAt.of_nmem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Not (Membership.mem (tsupport f) x)\nâŠ¢ HasFDerivAt f 0 x","decl":"theorem HasFDerivAt.of_nmem_tsupport (h : x âˆ‰ tsupport f) :\n    HasFDerivAt f (0 : E â†’L[ğ•œ] F) x :=\n  (HasStrictFDerivAt.of_nmem_tsupport ğ•œ h).hasFDerivAt\n\n"}
{"name":"HasFDerivWithinAt.of_not_mem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nh : Not (Membership.mem (tsupport f) x)\nâŠ¢ HasFDerivWithinAt f 0 s x","decl":"theorem HasFDerivWithinAt.of_not_mem_tsupport {s : Set E} {x : E} (h : x âˆ‰ tsupport f) :\n    HasFDerivWithinAt f (0 : E â†’L[ğ•œ] F) s x :=\n  (HasFDerivAt.of_nmem_tsupport ğ•œ h).hasFDerivWithinAt\n\n"}
{"name":"fderiv_of_not_mem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Not (Membership.mem (tsupport f) x)\nâŠ¢ Eq (fderiv ğ•œ f x) 0","decl":"theorem fderiv_of_not_mem_tsupport (h : x âˆ‰ tsupport f) : fderiv ğ•œ f x = 0 :=\n  (HasFDerivAt.of_nmem_tsupport ğ•œ h).fderiv\n\n"}
{"name":"support_fderiv_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ HasSubset.Subset (Function.support (fderiv ğ•œ f)) (tsupport f)","decl":"theorem support_fderiv_subset : support (fderiv ğ•œ f) âŠ† tsupport f := fun x â†¦ by\n  rw [â† not_imp_not, nmem_support]\n  exact fderiv_of_not_mem_tsupport _\n\n"}
{"name":"tsupport_fderiv_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ HasSubset.Subset (tsupport (fderiv ğ•œ f)) (tsupport f)","decl":"theorem tsupport_fderiv_subset : tsupport (fderiv ğ•œ f) âŠ† tsupport f :=\n  closure_minimal (support_fderiv_subset ğ•œ) isClosed_closure\n\n"}
{"name":"HasCompactSupport.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : HasCompactSupport f\nâŠ¢ HasCompactSupport (fderiv ğ•œ f)","decl":"protected theorem HasCompactSupport.fderiv (hf : HasCompactSupport f) :\n    HasCompactSupport (fderiv ğ•œ f) :=\n  hf.mono' <| support_fderiv_subset ğ•œ\n\n"}
{"name":"HasCompactSupport.fderiv_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : HasCompactSupport f\nv : E\nâŠ¢ HasCompactSupport fun x => (fderiv ğ•œ f x) v","decl":"protected theorem HasCompactSupport.fderiv_apply (hf : HasCompactSupport f) (v : E) :\n    HasCompactSupport (fderiv ğ•œ f Â· v) :=\n  hf.fderiv ğ•œ |>.comp_left (g := fun L : E â†’L[ğ•œ] F â†¦ L v) rfl\n\n"}
