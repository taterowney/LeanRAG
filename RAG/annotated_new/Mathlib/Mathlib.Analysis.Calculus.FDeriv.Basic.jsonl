{"name":"hasFDerivAtFilter_iff_isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\n⊢ Iff (HasFDerivAtFilter f f' x L) (Asymptotics.IsLittleOTVS 𝕜 L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x)","decl":"/-- A function `f` has the continuous linear map `f'` as derivative along the filter `L` if\n`f x' = f x + f' (x' - x) + o (x' - x)` when `x'` converges along the filter `L`. This definition\nis designed to be specialized for `L = 𝓝 x` (in `HasFDerivAt`), giving rise to the usual notion\nof Fréchet derivative, and for `L = 𝓝[s] x` (in `HasFDerivWithinAt`), giving rise to\nthe notion of Fréchet derivative along the set `s`. -/\n@[mk_iff hasFDerivAtFilter_iff_isLittleOTVS]\nstructure HasFDerivAtFilter (f : E → F) (f' : E →L[𝕜] F) (x : E) (L : Filter E) : Prop where\n  of_isLittleOTVS ::\n    isLittleOTVS : (fun x' => f x' - f x - f' (x' - x)) =o[𝕜;L] (fun x' => x' - x)\n\n"}
{"name":"HasFDerivAtFilter.isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nself : HasFDerivAtFilter f f' x L\n⊢ Asymptotics.IsLittleOTVS 𝕜 L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x","decl":"/-- A function `f` has the continuous linear map `f'` as derivative along the filter `L` if\n`f x' = f x + f' (x' - x) + o (x' - x)` when `x'` converges along the filter `L`. This definition\nis designed to be specialized for `L = 𝓝 x` (in `HasFDerivAt`), giving rise to the usual notion\nof Fréchet derivative, and for `L = 𝓝[s] x` (in `HasFDerivWithinAt`), giving rise to\nthe notion of Fréchet derivative along the set `s`. -/\n@[mk_iff hasFDerivAtFilter_iff_isLittleOTVS]\nstructure HasFDerivAtFilter (f : E → F) (f' : E →L[𝕜] F) (x : E) (L : Filter E) : Prop where\n  of_isLittleOTVS ::\n    isLittleOTVS : (fun x' => f x' - f x - f' (x' - x)) =o[𝕜;L] (fun x' => x' - x)\n\n"}
{"name":"hasStrictFDerivAt_iff_isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Iff (HasStrictFDerivAt f f' x) (Asymptotics.IsLittleOTVS 𝕜 (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2)","decl":"/-- A function `f` has derivative `f'` at `a` in the sense of *strict differentiability*\nif `f x - f y - f' (x - y) = o(x - y)` as `x, y → a`. This form of differentiability is required,\ne.g., by the inverse function theorem. Any `C^1` function on a vector space over `ℝ` is strictly\ndifferentiable but this definition works, e.g., for vector spaces over `p`-adic numbers. -/\n@[fun_prop, mk_iff hasStrictFDerivAt_iff_isLittleOTVS]\nstructure HasStrictFDerivAt (f : E → F) (f' : E →L[𝕜] F) (x : E) where\n  of_isLittleOTVS ::\n    isLittleOTVS :\n      (fun p : E × E => f p.1 - f p.2 - f' (p.1 - p.2))\n        =o[𝕜;𝓝 (x, x)] (fun p : E × E => p.1 - p.2)\n\n"}
{"name":"HasStrictFDerivAt.isLittleOTVS","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nself : HasStrictFDerivAt f f' x\n⊢ Asymptotics.IsLittleOTVS 𝕜 (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2","decl":"/-- A function `f` has derivative `f'` at `a` in the sense of *strict differentiability*\nif `f x - f y - f' (x - y) = o(x - y)` as `x, y → a`. This form of differentiability is required,\ne.g., by the inverse function theorem. Any `C^1` function on a vector space over `ℝ` is strictly\ndifferentiable but this definition works, e.g., for vector spaces over `p`-adic numbers. -/\n@[fun_prop, mk_iff hasStrictFDerivAt_iff_isLittleOTVS]\nstructure HasStrictFDerivAt (f : E → F) (f' : E →L[𝕜] F) (x : E) where\n  of_isLittleOTVS ::\n    isLittleOTVS :\n      (fun p : E × E => f p.1 - f p.2 - f' (p.1 - p.2))\n        =o[𝕜;𝓝 (x, x)] (fun p : E × E => p.1 - p.2)\n\n"}
{"name":"fderivWithin_def","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_5\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_6\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\ns : Set E\nx : E\n⊢ Eq (fderivWithin 𝕜 f s x) (ite (HasFDerivWithinAt f 0 s x) 0 (dite (DifferentiableWithinAt 𝕜 f s x) (fun h => Classical.choose h) fun h => 0))","decl":"open scoped Classical in\n/-- If `f` has a derivative at `x` within `s`, then `fderivWithin 𝕜 f s x` is such a derivative.\nOtherwise, it is set to `0`. We also set it to be zero, if zero is one of possible derivatives. -/\nirreducible_def fderivWithin (f : E → F) (s : Set E) (x : E) : E →L[𝕜] F :=\n  if HasFDerivWithinAt f (0 : E →L[𝕜] F) s x\n    then 0\n  else if h : DifferentiableWithinAt 𝕜 f s x\n    then Classical.choose h\n  else 0\n\n"}
{"name":"fderiv_def","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_5\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_6\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nx : E\n⊢ Eq (fderiv 𝕜 f x) (fderivWithin 𝕜 f Set.univ x)","decl":"/-- If `f` has a derivative at `x`, then `fderiv 𝕜 f x` is such a derivative. Otherwise, it is\nset to `0`. -/\nirreducible_def fderiv (f : E → F) (x : E) : E →L[𝕜] F :=\n  fderivWithin 𝕜 f univ x\n\n"}
{"name":"fderivWithin_zero_of_not_differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\nx : E\ns : Set E\nh : Not (DifferentiableWithinAt 𝕜 f s x)\n⊢ Eq (fderivWithin 𝕜 f s x) 0","decl":"theorem fderivWithin_zero_of_not_differentiableWithinAt (h : ¬DifferentiableWithinAt 𝕜 f s x) :\n    fderivWithin 𝕜 f s x = 0 := by\n  simp [fderivWithin, h]\n\n"}
{"name":"fderivWithin_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\nF : Type u_3\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 F\ninst✝ : TopologicalSpace F\nf : E → F\n⊢ Eq (fderivWithin 𝕜 f Set.univ) (fderiv 𝕜 f)","decl":"@[simp]\ntheorem fderivWithin_univ : fderivWithin 𝕜 f univ = fderiv 𝕜 f := by\n  ext\n  rw [fderiv]\n\n"}
{"name":"hasFDerivAtFilter_iff_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\n⊢ Iff (HasFDerivAtFilter f f' x L) (Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x)","decl":"theorem hasFDerivAtFilter_iff_isLittleO :\n    HasFDerivAtFilter f f' x L ↔ (fun x' => f x' - f x - f' (x' - x)) =o[L] fun x' => x' - x :=\n  (hasFDerivAtFilter_iff_isLittleOTVS ..).trans isLittleOTVS_iff_isLittleO\n\n"}
{"name":"HasFDerivAtFilter.of_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\na✝ : Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x\n⊢ HasFDerivAtFilter f f' x L","decl":"alias ⟨HasFDerivAtFilter.isLittleO, HasFDerivAtFilter.of_isLittleO⟩ :=\n  hasFDerivAtFilter_iff_isLittleO\n\n"}
{"name":"HasFDerivAtFilter.isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\na✝ : HasFDerivAtFilter f f' x L\n⊢ Asymptotics.IsLittleO L (fun x' => HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))) fun x' => HSub.hSub x' x","decl":"alias ⟨HasFDerivAtFilter.isLittleO, HasFDerivAtFilter.of_isLittleO⟩ :=\n  hasFDerivAtFilter_iff_isLittleO\n\n"}
{"name":"hasStrictFDerivAt_iff_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Iff (HasStrictFDerivAt f f' x) (Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2)","decl":"theorem hasStrictFDerivAt_iff_isLittleO :\n    HasStrictFDerivAt f f' x ↔\n      (fun p : E × E => f p.1 - f p.2 - f' (p.1 - p.2)) =o[𝓝 (x, x)] fun p : E × E => p.1 - p.2 :=\n  (hasStrictFDerivAt_iff_isLittleOTVS ..).trans isLittleOTVS_iff_isLittleO\n\n"}
{"name":"HasStrictFDerivAt.isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\na✝ : HasStrictFDerivAt f f' x\n⊢ Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2","decl":"alias ⟨HasStrictFDerivAt.isLittleO, HasStrictFDerivAt.of_isLittleO⟩ :=\n  hasStrictFDerivAt_iff_isLittleO\n\n"}
{"name":"HasStrictFDerivAt.of_isLittleO","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\na✝ : Asymptotics.IsLittleO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (HSub.hSub (f p.1) (f p.2)) (f' (HSub.hSub p.1 p.2))) fun p => HSub.hSub p.1 p.2\n⊢ HasStrictFDerivAt f f' x","decl":"alias ⟨HasStrictFDerivAt.isLittleO, HasStrictFDerivAt.of_isLittleO⟩ :=\n  hasStrictFDerivAt_iff_isLittleO\n\n"}
{"name":"HasFDerivWithinAt.lim","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nα : Type u_4\nl : Filter α\nc : α → 𝕜\nd : α → E\nv : E\ndtop : Filter.Eventually (fun n => Membership.mem s (HAdd.hAdd x (d n))) l\nclim : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\ncdlim : Filter.Tendsto (fun n => HSMul.hSMul (c n) (d n)) l (nhds v)\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (c n) (HSub.hSub (f (HAdd.hAdd x (d n))) (f x))) l (nhds (f' v))","decl":"/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem HasFDerivWithinAt.lim (h : HasFDerivWithinAt f f' s x) {α : Type*} (l : Filter α)\n    {c : α → 𝕜} {d : α → E} {v : E} (dtop : ∀ᶠ n in l, x + d n ∈ s)\n    (clim : Tendsto (fun n => ‖c n‖) l atTop) (cdlim : Tendsto (fun n => c n • d n) l (𝓝 v)) :\n    Tendsto (fun n => c n • (f (x + d n) - f x)) l (𝓝 (f' v)) := by\n  have tendsto_arg : Tendsto (fun n => x + d n) l (𝓝[s] x) := by\n    conv in 𝓝[s] x => rw [← add_zero x]\n    rw [nhdsWithin, tendsto_inf]\n    constructor\n    · apply tendsto_const_nhds.add (tangentConeAt.lim_zero l clim cdlim)\n    · rwa [tendsto_principal]\n  have : (fun y => f y - f x - f' (y - x)) =o[𝓝[s] x] fun y => y - x := h.isLittleO\n  have : (fun n => f (x + d n) - f x - f' (x + d n - x)) =o[l] fun n => x + d n - x :=\n    this.comp_tendsto tendsto_arg\n  have : (fun n => f (x + d n) - f x - f' (d n)) =o[l] d := by simpa only [add_sub_cancel_left]\n  have : (fun n => c n • (f (x + d n) - f x - f' (d n))) =o[l] fun n => c n • d n :=\n    (isBigO_refl c l).smul_isLittleO this\n  have : (fun n => c n • (f (x + d n) - f x - f' (d n))) =o[l] fun _ => (1 : ℝ) :=\n    this.trans_isBigO (cdlim.isBigO_one ℝ)\n  have L1 : Tendsto (fun n => c n • (f (x + d n) - f x - f' (d n))) l (𝓝 0) :=\n    (isLittleO_one_iff ℝ).1 this\n  have L2 : Tendsto (fun n => f' (c n • d n)) l (𝓝 (f' v)) :=\n    Tendsto.comp f'.cont.continuousAt cdlim\n  have L3 :\n    Tendsto (fun n => c n • (f (x + d n) - f x - f' (d n)) + f' (c n • d n)) l (𝓝 (0 + f' v)) :=\n    L1.add L2\n  have :\n    (fun n => c n • (f (x + d n) - f x - f' (d n)) + f' (c n • d n)) = fun n =>\n      c n • (f (x + d n) - f x) := by\n    ext n\n    simp [smul_add, smul_sub]\n  rwa [this, zero_add] at L3\n\n"}
{"name":"HasFDerivWithinAt.unique_on","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt f f₁' s x\n⊢ Set.EqOn (⇑f') (⇑f₁') (tangentConeAt 𝕜 s x)","decl":"/-- If `f'` and `f₁'` are two derivatives of `f` within `s` at `x`, then they are equal on the\ntangent cone to `s` at `x` -/\ntheorem HasFDerivWithinAt.unique_on (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f f₁' s x) : EqOn f' f₁' (tangentConeAt 𝕜 s x) :=\n  fun _ ⟨_, _, dtop, clim, cdlim⟩ =>\n  tendsto_nhds_unique (hf.lim atTop dtop clim cdlim) (hg.lim atTop dtop clim cdlim)\n\n"}
{"name":"UniqueDiffWithinAt.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nH : UniqueDiffWithinAt 𝕜 s x\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt f f₁' s x\n⊢ Eq f' f₁'","decl":"/-- `UniqueDiffWithinAt` achieves its goal: it implies the uniqueness of the derivative. -/\ntheorem UniqueDiffWithinAt.eq (H : UniqueDiffWithinAt 𝕜 s x) (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f f₁' s x) : f' = f₁' :=\n  ContinuousLinearMap.ext_on H.1 (hf.unique_on hg)\n\n"}
{"name":"UniqueDiffOn.eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nH : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nh : HasFDerivWithinAt f f' s x\nh₁ : HasFDerivWithinAt f f₁' s x\n⊢ Eq f' f₁'","decl":"theorem UniqueDiffOn.eq (H : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (h : HasFDerivWithinAt f f' s x)\n    (h₁ : HasFDerivWithinAt f f₁' s x) : f' = f₁' :=\n  (H x hx).eq h h₁\n\n"}
{"name":"hasFDerivAtFilter_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\n⊢ Iff (HasFDerivAtFilter f f' x L) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) L (nhds 0))","decl":"theorem hasFDerivAtFilter_iff_tendsto :\n    HasFDerivAtFilter f f' x L ↔\n      Tendsto (fun x' => ‖x' - x‖⁻¹ * ‖f x' - f x - f' (x' - x)‖) L (𝓝 0) := by\n  have h : ∀ x', ‖x' - x‖ = 0 → ‖f x' - f x - f' (x' - x)‖ = 0 := fun x' hx' => by\n    rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]\n    simp\n  rw [hasFDerivAtFilter_iff_isLittleO, ← isLittleO_norm_left, ← isLittleO_norm_right,\n    isLittleO_iff_tendsto h]\n  exact tendsto_congr fun _ => div_eq_inv_mul _ _\n\n"}
{"name":"hasFDerivWithinAt_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\n⊢ Iff (HasFDerivWithinAt f f' s x) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) (nhdsWithin x s) (nhds 0))","decl":"theorem hasFDerivWithinAt_iff_tendsto :\n    HasFDerivWithinAt f f' s x ↔\n      Tendsto (fun x' => ‖x' - x‖⁻¹ * ‖f x' - f x - f' (x' - x)‖) (𝓝[s] x) (𝓝 0) :=\n  hasFDerivAtFilter_iff_tendsto\n\n"}
{"name":"hasFDerivAt_iff_tendsto","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Iff (HasFDerivAt f f' x) (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) (nhds x) (nhds 0))","decl":"theorem hasFDerivAt_iff_tendsto :\n    HasFDerivAt f f' x ↔ Tendsto (fun x' => ‖x' - x‖⁻¹ * ‖f x' - f x - f' (x' - x)‖) (𝓝 x) (𝓝 0) :=\n  hasFDerivAtFilter_iff_tendsto\n\n"}
{"name":"hasFDerivAt_iff_isLittleO_nhds_zero","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Iff (HasFDerivAt f f' x) (Asymptotics.IsLittleO (nhds 0) (fun h => HSub.hSub (HSub.hSub (f (HAdd.hAdd x h)) (f x)) (f' h)) fun h => h)","decl":"theorem hasFDerivAt_iff_isLittleO_nhds_zero :\n    HasFDerivAt f f' x ↔ (fun h : E => f (x + h) - f x - f' h) =o[𝓝 0] fun h => h := by\n  rw [HasFDerivAt, hasFDerivAtFilter_iff_isLittleO, ← map_add_left_nhds_zero x, isLittleO_map]\n  simp [Function.comp_def]\n\n"}
{"name":"HasFDerivAtFilter.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL₁ L₂ : Filter E\nh : HasFDerivAtFilter f f' x L₂\nhst : LE.le L₁ L₂\n⊢ HasFDerivAtFilter f f' x L₁","decl":"nonrec theorem HasFDerivAtFilter.mono (h : HasFDerivAtFilter f f' x L₂) (hst : L₁ ≤ L₂) :\n    HasFDerivAtFilter f f' x L₁ :=\n  .of_isLittleOTVS <| h.isLittleOTVS.mono hst\n\n"}
{"name":"HasFDerivWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : Membership.mem (nhdsWithin x s) t\n⊢ HasFDerivWithinAt f f' s x","decl":"theorem HasFDerivWithinAt.mono_of_mem_nhdsWithin\n    (h : HasFDerivWithinAt f f' t x) (hst : t ∈ 𝓝[s] x) :\n    HasFDerivWithinAt f f' s x :=\n  h.mono <| nhdsWithin_le_iff.mpr hst\n\n"}
{"name":"HasFDerivWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : Membership.mem (nhdsWithin x s) t\n⊢ HasFDerivWithinAt f f' s x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias HasFDerivWithinAt.mono_of_mem := HasFDerivWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"HasFDerivWithinAt.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' t x\nhst : HasSubset.Subset s t\n⊢ HasFDerivWithinAt f f' s x","decl":"nonrec theorem HasFDerivWithinAt.mono (h : HasFDerivWithinAt f f' t x) (hst : s ⊆ t) :\n    HasFDerivWithinAt f f' s x :=\n  h.mono <| nhdsWithin_mono _ hst\n\n"}
{"name":"HasFDerivAt.hasFDerivAtFilter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nh : HasFDerivAt f f' x\nhL : LE.le L (nhds x)\n⊢ HasFDerivAtFilter f f' x L","decl":"theorem HasFDerivAt.hasFDerivAtFilter (h : HasFDerivAt f f' x) (hL : L ≤ 𝓝 x) :\n    HasFDerivAtFilter f f' x L :=\n  h.mono hL\n\n"}
{"name":"HasFDerivAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivAt f f' x\n⊢ HasFDerivWithinAt f f' s x","decl":"@[fun_prop]\ntheorem HasFDerivAt.hasFDerivWithinAt (h : HasFDerivAt f f' x) : HasFDerivWithinAt f f' s x :=\n  h.hasFDerivAtFilter inf_le_left\n\n"}
{"name":"HasFDerivWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.differentiableWithinAt (h : HasFDerivWithinAt f f' s x) :\n    DifferentiableWithinAt 𝕜 f s x :=\n  ⟨f', h⟩\n\n"}
{"name":"HasFDerivAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\n⊢ DifferentiableAt 𝕜 f x","decl":"@[fun_prop]\ntheorem HasFDerivAt.differentiableAt (h : HasFDerivAt f f' x) : DifferentiableAt 𝕜 f x :=\n  ⟨f', h⟩\n\n"}
{"name":"hasFDerivWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Iff (HasFDerivWithinAt f f' Set.univ x) (HasFDerivAt f f' x)","decl":"@[simp]\ntheorem hasFDerivWithinAt_univ : HasFDerivWithinAt f f' univ x ↔ HasFDerivAt f f' x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_univ, HasFDerivAt]\n\n"}
{"name":"HasFDerivWithinAt.hasFDerivAt_of_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\na✝ : HasFDerivWithinAt f f' Set.univ x\n⊢ HasFDerivAt f f' x","decl":"alias ⟨HasFDerivWithinAt.hasFDerivAt_of_univ, _⟩ := hasFDerivWithinAt_univ\n\n"}
{"name":"differentiableWithinAt_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (DifferentiableWithinAt 𝕜 f Set.univ x) (DifferentiableAt 𝕜 f x)","decl":"theorem differentiableWithinAt_univ :\n    DifferentiableWithinAt 𝕜 f univ x ↔ DifferentiableAt 𝕜 f x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_univ, DifferentiableAt]\n\n"}
{"name":"fderiv_zero_of_not_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Not (DifferentiableAt 𝕜 f x)\n⊢ Eq (fderiv 𝕜 f x) 0","decl":"theorem fderiv_zero_of_not_differentiableAt (h : ¬DifferentiableAt 𝕜 f x) : fderiv 𝕜 f x = 0 := by\n  rw [fderiv, fderivWithin_zero_of_not_differentiableWithinAt]\n  rwa [differentiableWithinAt_univ]\n\n"}
{"name":"hasFDerivWithinAt_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\n⊢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivAt f f' x)","decl":"theorem hasFDerivWithinAt_of_mem_nhds (h : s ∈ 𝓝 x) :\n    HasFDerivWithinAt f f' s x ↔ HasFDerivAt f f' x := by\n  rw [HasFDerivAt, HasFDerivWithinAt, nhdsWithin_eq_nhds.mpr h]\n\n"}
{"name":"hasFDerivWithinAt_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : IsOpen s\nhx : Membership.mem s x\n⊢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivAt f f' x)","decl":"lemma hasFDerivWithinAt_of_isOpen (h : IsOpen s) (hx : x ∈ s) :\n    HasFDerivWithinAt f f' s x ↔ HasFDerivAt f f' x :=\n  hasFDerivWithinAt_of_mem_nhds (h.mem_nhds hx)\n\n"}
{"name":"hasFDerivWithinAt_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\ny : E\n⊢ Iff (HasFDerivWithinAt f f' (Insert.insert y s) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_insert {y : E} :\n    HasFDerivWithinAt f f' (insert y s) x ↔ HasFDerivWithinAt f f' s x := by\n  rcases eq_or_ne x y with (rfl | h)\n  · simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]\n    apply isLittleOTVS_insert\n    simp only [sub_self, map_zero]\n  refine ⟨fun h => h.mono <| subset_insert y s, fun hf => hf.mono_of_mem_nhdsWithin ?_⟩\n  simp_rw [nhdsWithin_insert_of_ne h, self_mem_nhdsWithin]\n\n"}
{"name":"HasFDerivWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\ny : E\na✝ : HasFDerivWithinAt f f' (Insert.insert y s) x\n⊢ HasFDerivWithinAt f f' s x","decl":"alias ⟨HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'⟩ := hasFDerivWithinAt_insert\n\n"}
{"name":"HasFDerivWithinAt.insert'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\ny : E\na✝ : HasFDerivWithinAt f f' s x\n⊢ HasFDerivWithinAt f f' (Insert.insert y s) x","decl":"alias ⟨HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'⟩ := hasFDerivWithinAt_insert\n\n"}
{"name":"HasFDerivWithinAt.insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ng : E → F\ng' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt g g' s x\n⊢ HasFDerivWithinAt g g' (Insert.insert x s) x","decl":"protected theorem HasFDerivWithinAt.insert (h : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt g g' (insert x s) x :=\n  h.insert'\n\n"}
{"name":"hasFDerivWithinAt_diff_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\ny : E\n⊢ Iff (HasFDerivWithinAt f f' (SDiff.sdiff s (Singleton.singleton y)) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_diff_singleton (y : E) :\n    HasFDerivWithinAt f f' (s \\ {y}) x ↔ HasFDerivWithinAt f f' s x := by\n  rw [← hasFDerivWithinAt_insert, insert_diff_singleton, hasFDerivWithinAt_insert]\n\n"}
{"name":"HasStrictFDerivAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\n⊢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun p => HSub.hSub (f p.1) (f p.2)) fun p => HSub.hSub p.1 p.2","decl":"theorem HasStrictFDerivAt.isBigO_sub (hf : HasStrictFDerivAt f f' x) :\n    (fun p : E × E => f p.1 - f p.2) =O[𝓝 (x, x)] fun p : E × E => p.1 - p.2 :=\n  hf.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_comp _ _)\n\n"}
{"name":"HasFDerivAtFilter.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nh : HasFDerivAtFilter f f' x L\n⊢ Asymptotics.IsBigO L (fun x' => HSub.hSub (f x') (f x)) fun x' => HSub.hSub x' x","decl":"theorem HasFDerivAtFilter.isBigO_sub (h : HasFDerivAtFilter f f' x L) :\n    (fun x' => f x' - f x) =O[L] fun x' => x' - x :=\n  h.isLittleO.isBigO.congr_of_sub.2 (f'.isBigO_sub _ _)\n\n"}
{"name":"HasStrictFDerivAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\n⊢ HasFDerivAt f f' x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.hasFDerivAt (hf : HasStrictFDerivAt f f' x) :\n    HasFDerivAt f f' x :=\n  .of_isLittleOTVS <| by\n    simpa only using hf.isLittleOTVS.comp_tendsto (tendsto_id.prod_mk_nhds tendsto_const_nhds)\n\n"}
{"name":"HasStrictFDerivAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\n⊢ DifferentiableAt 𝕜 f x","decl":"protected theorem HasStrictFDerivAt.differentiableAt (hf : HasStrictFDerivAt f f' x) :\n    DifferentiableAt 𝕜 f x :=\n  hf.hasFDerivAt.differentiableAt\n\n"}
{"name":"HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\nK : NNReal\nhK : LT.lt (NNNorm.nnnorm f') K\n⊢ Exists fun s => And (Membership.mem (nhds x) s) (LipschitzOnWith K f s)","decl":"/-- If `f` is strictly differentiable at `x` with derivative `f'` and `K > ‖f'‖₊`, then `f` is\n`K`-Lipschitz in a neighborhood of `x`. -/\ntheorem HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt (hf : HasStrictFDerivAt f f' x)\n    (K : ℝ≥0) (hK : ‖f'‖₊ < K) : ∃ s ∈ 𝓝 x, LipschitzOnWith K f s := by\n  have := hf.isLittleO.add_isBigOWith (f'.isBigOWith_comp _ _) hK\n  simp only [sub_add_cancel, IsBigOWith] at this\n  rcases exists_nhds_square this with ⟨U, Uo, xU, hU⟩\n  exact\n    ⟨U, Uo.mem_nhds xU, lipschitzOnWith_iff_norm_sub_le.2 fun x hx y hy => hU (mk_mem_prod hx hy)⟩\n\n"}
{"name":"HasStrictFDerivAt.exists_lipschitzOnWith","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\n⊢ Exists fun K => Exists fun s => And (Membership.mem (nhds x) s) (LipschitzOnWith K f s)","decl":"/-- If `f` is strictly differentiable at `x` with derivative `f'`, then `f` is Lipschitz in a\nneighborhood of `x`. See also `HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt` for a\nmore precise statement. -/\ntheorem HasStrictFDerivAt.exists_lipschitzOnWith (hf : HasStrictFDerivAt f f' x) :\n    ∃ K, ∃ s ∈ 𝓝 x, LipschitzOnWith K f s :=\n  (exists_gt _).imp hf.exists_lipschitzOnWith_of_nnnorm_lt\n\n"}
{"name":"HasFDerivAt.lim","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasFDerivAt f f' x\nv : E\nα : Type u_4\nc : α → 𝕜\nl : Filter α\nhc : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (c n) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul (Inv.inv (c n)) v))) (f x))) l (nhds (f' v))","decl":"/-- Directional derivative agrees with `HasFDeriv`. -/\ntheorem HasFDerivAt.lim (hf : HasFDerivAt f f' x) (v : E) {α : Type*} {c : α → 𝕜} {l : Filter α}\n    (hc : Tendsto (fun n => ‖c n‖) l atTop) :\n    Tendsto (fun n => c n • (f (x + (c n)⁻¹ • v) - f x)) l (𝓝 (f' v)) := by\n  refine (hasFDerivWithinAt_univ.2 hf).lim _ univ_mem hc ?_\n  intro U hU\n  refine (eventually_ne_of_tendsto_norm_atTop hc (0 : 𝕜)).mono fun y hy => ?_\n  convert mem_of_mem_nhds hU\n  dsimp only\n  rw [← mul_smul, mul_inv_cancel₀ hy, one_smul]\n\n"}
{"name":"HasFDerivAt.unique","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf₀' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh₀ : HasFDerivAt f f₀' x\nh₁ : HasFDerivAt f f₁' x\n⊢ Eq f₀' f₁'","decl":"theorem HasFDerivAt.unique (h₀ : HasFDerivAt f f₀' x) (h₁ : HasFDerivAt f f₁' x) : f₀' = f₁' := by\n  rw [← hasFDerivWithinAt_univ] at h₀ h₁\n  exact uniqueDiffWithinAt_univ.eq h₀ h₁\n\n"}
{"name":"hasFDerivWithinAt_inter'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : Membership.mem (nhdsWithin x s) t\n⊢ Iff (HasFDerivWithinAt f f' (Inter.inter s t) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_inter' (h : t ∈ 𝓝[s] x) :\n    HasFDerivWithinAt f f' (s ∩ t) x ↔ HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict'' s h]\n\n"}
{"name":"hasFDerivWithinAt_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : Membership.mem (nhds x) t\n⊢ Iff (HasFDerivWithinAt f f' (Inter.inter s t) x) (HasFDerivWithinAt f f' s x)","decl":"theorem hasFDerivWithinAt_inter (h : t ∈ 𝓝 x) :\n    HasFDerivWithinAt f f' (s ∩ t) x ↔ HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict' s h]\n\n"}
{"name":"HasFDerivWithinAt.union","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nhs : HasFDerivWithinAt f f' s x\nht : HasFDerivWithinAt f f' t x\n⊢ HasFDerivWithinAt f f' (Union.union s t) x","decl":"theorem HasFDerivWithinAt.union (hs : HasFDerivWithinAt f f' s x)\n    (ht : HasFDerivWithinAt f f' t x) : HasFDerivWithinAt f f' (s ∪ t) x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_union]\n  exact .of_isLittleOTVS <| hs.isLittleOTVS.sup ht.isLittleOTVS\n\n"}
{"name":"HasFDerivWithinAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Membership.mem (nhds x) s\n⊢ HasFDerivAt f f' x","decl":"theorem HasFDerivWithinAt.hasFDerivAt (h : HasFDerivWithinAt f f' s x) (hs : s ∈ 𝓝 x) :\n    HasFDerivAt f f' x := by\n  rwa [← univ_inter s, hasFDerivWithinAt_inter hs, hasFDerivWithinAt_univ] at h\n\n"}
{"name":"DifferentiableWithinAt.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nhs : Membership.mem (nhds x) s\n⊢ DifferentiableAt 𝕜 f x","decl":"theorem DifferentiableWithinAt.differentiableAt (h : DifferentiableWithinAt 𝕜 f s x)\n    (hs : s ∈ 𝓝 x) : DifferentiableAt 𝕜 f x :=\n  h.imp fun _ hf' => hf'.hasFDerivAt hs\n\n"}
{"name":"HasFDerivWithinAt.of_nhdsWithin_eq_bot","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot\n⊢ HasFDerivWithinAt f f' s x","decl":"/-- If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem HasFDerivWithinAt.of_nhdsWithin_eq_bot (h : 𝓝[s\\{x}] x = ⊥) :\n    HasFDerivWithinAt f f' s x := by\n  rw [← hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h,\n    hasFDerivAtFilter_iff_isLittleOTVS]\n  exact .bot\n\n"}
{"name":"hasFDerivWithinAt_of_nmem_closure","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : Not (Membership.mem (closure s) x)\n⊢ HasFDerivWithinAt f f' s x","decl":"/-- If `x` is not in the closure of `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. -/\ntheorem hasFDerivWithinAt_of_nmem_closure (h : x ∉ closure s) : HasFDerivWithinAt f f' s x :=\n  .of_nhdsWithin_eq_bot <| eq_bot_mono (nhdsWithin_mono _ diff_subset) <| by\n    rwa [mem_closure_iff_nhdsWithin_neBot, not_neBot] at h\n\n"}
{"name":"fderivWithin_zero_of_isolated","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot\n⊢ Eq (fderivWithin 𝕜 f s x) 0","decl":"theorem fderivWithin_zero_of_isolated (h : 𝓝[s \\ {x}] x = ⊥) : fderivWithin 𝕜 f s x = 0 := by\n  rw [fderivWithin, if_pos (.of_nhdsWithin_eq_bot h)]\n\n"}
{"name":"fderivWithin_zero_of_nmem_closure","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : Not (Membership.mem (closure s) x)\n⊢ Eq (fderivWithin 𝕜 f s x) 0","decl":"theorem fderivWithin_zero_of_nmem_closure (h : x ∉ closure s) : fderivWithin 𝕜 f s x = 0 := by\n  rw [fderivWithin, if_pos (hasFDerivWithinAt_of_nmem_closure h)]\n\n"}
{"name":"DifferentiableWithinAt.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\n⊢ HasFDerivWithinAt f (fderivWithin 𝕜 f s x) s x","decl":"theorem DifferentiableWithinAt.hasFDerivWithinAt (h : DifferentiableWithinAt 𝕜 f s x) :\n    HasFDerivWithinAt f (fderivWithin 𝕜 f s x) s x := by\n  simp only [fderivWithin, dif_pos h]\n  split_ifs with h₀\n  exacts [h₀, Classical.choose_spec h]\n\n"}
{"name":"DifferentiableAt.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : DifferentiableAt 𝕜 f x\n⊢ HasFDerivAt f (fderiv 𝕜 f x) x","decl":"theorem DifferentiableAt.hasFDerivAt (h : DifferentiableAt 𝕜 f x) :\n    HasFDerivAt f (fderiv 𝕜 f x) x := by\n  rw [fderiv, ← hasFDerivWithinAt_univ]\n  rw [← differentiableWithinAt_univ] at h\n  exact h.hasFDerivWithinAt\n\n"}
{"name":"DifferentiableOn.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableOn 𝕜 f s\nhs : Membership.mem (nhds x) s\n⊢ HasFDerivAt f (fderiv 𝕜 f x) x","decl":"theorem DifferentiableOn.hasFDerivAt (h : DifferentiableOn 𝕜 f s) (hs : s ∈ 𝓝 x) :\n    HasFDerivAt f (fderiv 𝕜 f x) x :=\n  ((h x (mem_of_mem_nhds hs)).differentiableAt hs).hasFDerivAt\n\n"}
{"name":"DifferentiableOn.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableOn 𝕜 f s\nhs : Membership.mem (nhds x) s\n⊢ DifferentiableAt 𝕜 f x","decl":"theorem DifferentiableOn.differentiableAt (h : DifferentiableOn 𝕜 f s) (hs : s ∈ 𝓝 x) :\n    DifferentiableAt 𝕜 f x :=\n  (h.hasFDerivAt hs).differentiableAt\n\n"}
{"name":"DifferentiableOn.eventually_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableOn 𝕜 f s\nhs : Membership.mem (nhds x) s\n⊢ Filter.Eventually (fun y => DifferentiableAt 𝕜 f y) (nhds x)","decl":"theorem DifferentiableOn.eventually_differentiableAt (h : DifferentiableOn 𝕜 f s) (hs : s ∈ 𝓝 x) :\n    ∀ᶠ y in 𝓝 x, DifferentiableAt 𝕜 f y :=\n  (eventually_eventually_nhds.2 hs).mono fun _ => h.differentiableAt\n\n"}
{"name":"HasFDerivAt.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\n⊢ Eq (fderiv 𝕜 f x) f'","decl":"protected theorem HasFDerivAt.fderiv (h : HasFDerivAt f f' x) : fderiv 𝕜 f x = f' := by\n  ext\n  rw [h.unique h.differentiableAt.hasFDerivAt]\n\n"}
{"name":"fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id 𝕜) E F\nh : ∀ (x : E), HasFDerivAt f (f' x) x\n⊢ Eq (fderiv 𝕜 f) f'","decl":"theorem fderiv_eq {f' : E → E →L[𝕜] F} (h : ∀ x, HasFDerivAt f (f' x) x) : fderiv 𝕜 f = f' :=\n  funext fun x => (h x).fderiv\n\n"}
{"name":"HasFDerivWithinAt.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 f s x) f'","decl":"protected theorem HasFDerivWithinAt.fderivWithin (h : HasFDerivWithinAt f f' s x)\n    (hxs : UniqueDiffWithinAt 𝕜 s x) : fderivWithin 𝕜 f s x = f' :=\n  (hxs.eq h h.differentiableWithinAt.hasFDerivWithinAt).symm\n\n"}
{"name":"DifferentiableWithinAt.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nh : DifferentiableWithinAt 𝕜 f t x\nst : HasSubset.Subset s t\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"theorem DifferentiableWithinAt.mono (h : DifferentiableWithinAt 𝕜 f t x) (st : s ⊆ t) :\n    DifferentiableWithinAt 𝕜 f s x := by\n  rcases h with ⟨f', hf'⟩\n  exact ⟨f', hf'.mono st⟩\n\n"}
{"name":"DifferentiableWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\n⊢ DifferentiableWithinAt 𝕜 f t x","decl":"theorem DifferentiableWithinAt.mono_of_mem_nhdsWithin\n    (h : DifferentiableWithinAt 𝕜 f s x) {t : Set E} (hst : s ∈ 𝓝[t] x) :\n    DifferentiableWithinAt 𝕜 f t x :=\n  (h.hasFDerivWithinAt.mono_of_mem_nhdsWithin hst).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\n⊢ DifferentiableWithinAt 𝕜 f t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias DifferentiableWithinAt.mono_of_mem := DifferentiableWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"DifferentiableWithinAt.congr_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nt : Set E\nhst : Eq (nhdsWithin x s) (nhdsWithin x t)\n⊢ DifferentiableWithinAt 𝕜 f t x","decl":"theorem DifferentiableWithinAt.congr_nhds (h : DifferentiableWithinAt 𝕜 f s x) {t : Set E}\n    (hst : 𝓝[s] x = 𝓝[t] x) : DifferentiableWithinAt 𝕜 f t x :=\n  h.mono_of_mem_nhdsWithin <| hst ▸ self_mem_nhdsWithin\n\n"}
{"name":"differentiableWithinAt_congr_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nhst : Eq (nhdsWithin x s) (nhdsWithin x t)\n⊢ Iff (DifferentiableWithinAt 𝕜 f s x) (DifferentiableWithinAt 𝕜 f t x)","decl":"theorem differentiableWithinAt_congr_nhds {t : Set E} (hst : 𝓝[s] x = 𝓝[t] x) :\n    DifferentiableWithinAt 𝕜 f s x ↔ DifferentiableWithinAt 𝕜 f t x :=\n  ⟨fun h => h.congr_nhds hst, fun h => h.congr_nhds hst.symm⟩\n\n"}
{"name":"differentiableWithinAt_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\n⊢ Iff (DifferentiableWithinAt 𝕜 f (Inter.inter s t) x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem differentiableWithinAt_inter (ht : t ∈ 𝓝 x) :\n    DifferentiableWithinAt 𝕜 f (s ∩ t) x ↔ DifferentiableWithinAt 𝕜 f s x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter ht]\n\n"}
{"name":"differentiableWithinAt_inter'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nht : Membership.mem (nhdsWithin x s) t\n⊢ Iff (DifferentiableWithinAt 𝕜 f (Inter.inter s t) x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem differentiableWithinAt_inter' (ht : t ∈ 𝓝[s] x) :\n    DifferentiableWithinAt 𝕜 f (s ∩ t) x ↔ DifferentiableWithinAt 𝕜 f s x := by\n  simp only [DifferentiableWithinAt, hasFDerivWithinAt_inter' ht]\n\n"}
{"name":"differentiableWithinAt_insert_self","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\n⊢ Iff (DifferentiableWithinAt 𝕜 f (Insert.insert x s) x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem differentiableWithinAt_insert_self :\n    DifferentiableWithinAt 𝕜 f (insert x s) x ↔ DifferentiableWithinAt 𝕜 f s x :=\n  ⟨fun h ↦ h.mono (subset_insert x s), fun h ↦ h.hasFDerivWithinAt.insert.differentiableWithinAt⟩\n\n"}
{"name":"differentiableWithinAt_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\ny : E\n⊢ Iff (DifferentiableWithinAt 𝕜 f (Insert.insert y s) x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem differentiableWithinAt_insert {y : E} :\n    DifferentiableWithinAt 𝕜 f (insert y s) x ↔ DifferentiableWithinAt 𝕜 f s x := by\n  rcases eq_or_ne x y with (rfl | h)\n  · exact differentiableWithinAt_insert_self\n  apply differentiableWithinAt_congr_nhds\n  exact nhdsWithin_insert_of_ne h\n\n"}
{"name":"DifferentiableWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\ny : E\na✝ : DifferentiableWithinAt 𝕜 f (Insert.insert y s) x\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"alias ⟨DifferentiableWithinAt.of_insert, DifferentiableWithinAt.insert'⟩ :=\ndifferentiableWithinAt_insert\n\n"}
{"name":"DifferentiableWithinAt.insert'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\ny : E\na✝ : DifferentiableWithinAt 𝕜 f s x\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert y s) x","decl":"alias ⟨DifferentiableWithinAt.of_insert, DifferentiableWithinAt.insert'⟩ :=\ndifferentiableWithinAt_insert\n\n"}
{"name":"DifferentiableWithinAt.insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert x s) x","decl":"protected theorem DifferentiableWithinAt.insert (h : DifferentiableWithinAt 𝕜 f s x) :\n    DifferentiableWithinAt 𝕜 f (insert x s) x :=\n  h.insert'\n\n"}
{"name":"DifferentiableAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableAt 𝕜 f x\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"theorem DifferentiableAt.differentiableWithinAt (h : DifferentiableAt 𝕜 f x) :\n    DifferentiableWithinAt 𝕜 f s x :=\n  (differentiableWithinAt_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"Differentiable.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Differentiable 𝕜 f\n⊢ DifferentiableAt 𝕜 f x","decl":"@[fun_prop]\ntheorem Differentiable.differentiableAt (h : Differentiable 𝕜 f) : DifferentiableAt 𝕜 f x :=\n  h x\n\n"}
{"name":"DifferentiableAt.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableAt 𝕜 f x\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderiv 𝕜 f x)","decl":"protected theorem DifferentiableAt.fderivWithin (h : DifferentiableAt 𝕜 f x)\n    (hxs : UniqueDiffWithinAt 𝕜 s x) : fderivWithin 𝕜 f s x = fderiv 𝕜 f x :=\n  h.hasFDerivAt.hasFDerivWithinAt.fderivWithin hxs\n\n"}
{"name":"DifferentiableOn.mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nh : DifferentiableOn 𝕜 f t\nst : HasSubset.Subset s t\n⊢ DifferentiableOn 𝕜 f s","decl":"theorem DifferentiableOn.mono (h : DifferentiableOn 𝕜 f t) (st : s ⊆ t) : DifferentiableOn 𝕜 f s :=\n  fun x hx => (h x (st hx)).mono st\n\n"}
{"name":"differentiableOn_univ","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (DifferentiableOn 𝕜 f Set.univ) (Differentiable 𝕜 f)","decl":"theorem differentiableOn_univ : DifferentiableOn 𝕜 f univ ↔ Differentiable 𝕜 f := by\n  simp only [DifferentiableOn, Differentiable, differentiableWithinAt_univ, mem_univ,\n    forall_true_left]\n\n"}
{"name":"Differentiable.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : Differentiable 𝕜 f\n⊢ DifferentiableOn 𝕜 f s","decl":"@[fun_prop]\ntheorem Differentiable.differentiableOn (h : Differentiable 𝕜 f) : DifferentiableOn 𝕜 f s :=\n  (differentiableOn_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"differentiableOn_of_locally_differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : ∀ (x : E), Membership.mem s x → Exists fun u => And (IsOpen u) (And (Membership.mem u x) (DifferentiableOn 𝕜 f (Inter.inter s u)))\n⊢ DifferentiableOn 𝕜 f s","decl":"theorem differentiableOn_of_locally_differentiableOn\n    (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ DifferentiableOn 𝕜 f (s ∩ u)) :\n    DifferentiableOn 𝕜 f s := by\n  intro x xs\n  rcases h x xs with ⟨t, t_open, xt, ht⟩\n  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 (ht x ⟨xs, xt⟩)\n\n"}
{"name":"fderivWithin_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nst : Membership.mem (nhdsWithin x s) t\nht : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableWithinAt 𝕜 f t x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderivWithin 𝕜 f t x)","decl":"theorem fderivWithin_of_mem_nhdsWithin (st : t ∈ 𝓝[s] x) (ht : UniqueDiffWithinAt 𝕜 s x)\n    (h : DifferentiableWithinAt 𝕜 f t x) : fderivWithin 𝕜 f s x = fderivWithin 𝕜 f t x :=\n  ((DifferentiableWithinAt.hasFDerivWithinAt h).mono_of_mem_nhdsWithin st).fderivWithin ht\n\n"}
{"name":"fderivWithin_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nst : Membership.mem (nhdsWithin x s) t\nht : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableWithinAt 𝕜 f t x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderivWithin 𝕜 f t x)","decl":"@[deprecated (since := \"2024-10-31\")]\nalias fderivWithin_of_mem := fderivWithin_of_mem_nhdsWithin\n\n"}
{"name":"fderivWithin_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nst : HasSubset.Subset s t\nht : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableWithinAt 𝕜 f t x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderivWithin 𝕜 f t x)","decl":"theorem fderivWithin_subset (st : s ⊆ t) (ht : UniqueDiffWithinAt 𝕜 s x)\n    (h : DifferentiableWithinAt 𝕜 f t x) : fderivWithin 𝕜 f s x = fderivWithin 𝕜 f t x :=\n  fderivWithin_of_mem_nhdsWithin (nhdsWithin_mono _ st self_mem_nhdsWithin) ht h\n\n"}
{"name":"fderivWithin_inter","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\n⊢ Eq (fderivWithin 𝕜 f (Inter.inter s t) x) (fderivWithin 𝕜 f s x)","decl":"theorem fderivWithin_inter (ht : t ∈ 𝓝 x) : fderivWithin 𝕜 f (s ∩ t) x = fderivWithin 𝕜 f s x := by\n  classical\n  simp [fderivWithin, hasFDerivWithinAt_inter ht, DifferentiableWithinAt]\n\n"}
{"name":"fderivWithin_of_mem_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\n⊢ Eq (fderivWithin 𝕜 f s x) (fderiv 𝕜 f x)","decl":"theorem fderivWithin_of_mem_nhds (h : s ∈ 𝓝 x) : fderivWithin 𝕜 f s x = fderiv 𝕜 f x := by\n  rw [← fderivWithin_univ, ← univ_inter s, fderivWithin_inter h]\n\n"}
{"name":"fderivWithin_of_isOpen","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nhs : IsOpen s\nhx : Membership.mem s x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderiv 𝕜 f x)","decl":"theorem fderivWithin_of_isOpen (hs : IsOpen s) (hx : x ∈ s) : fderivWithin 𝕜 f s x = fderiv 𝕜 f x :=\n  fderivWithin_of_mem_nhds (hs.mem_nhds hx)\n\n"}
{"name":"fderivWithin_eq_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nhs : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableAt 𝕜 f x\n⊢ Eq (fderivWithin 𝕜 f s x) (fderiv 𝕜 f x)","decl":"theorem fderivWithin_eq_fderiv (hs : UniqueDiffWithinAt 𝕜 s x) (h : DifferentiableAt 𝕜 f x) :\n    fderivWithin 𝕜 f s x = fderiv 𝕜 f x := by\n  rw [← fderivWithin_univ]\n  exact fderivWithin_subset (subset_univ _) hs h.differentiableWithinAt\n\n"}
{"name":"fderiv_mem_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nx : E\n⊢ Iff (Membership.mem s (fderiv 𝕜 f x)) (Or (And (DifferentiableAt 𝕜 f x) (Membership.mem s (fderiv 𝕜 f x))) (And (Not (DifferentiableAt 𝕜 f x)) (Membership.mem s 0)))","decl":"theorem fderiv_mem_iff {f : E → F} {s : Set (E →L[𝕜] F)} {x : E} : fderiv 𝕜 f x ∈ s ↔\n    DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ s ∨ ¬DifferentiableAt 𝕜 f x ∧ (0 : E →L[𝕜] F) ∈ s := by\n  by_cases hx : DifferentiableAt 𝕜 f x <;> simp [fderiv_zero_of_not_differentiableAt, *]\n\n"}
{"name":"fderivWithin_mem_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nt : Set E\ns : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nx : E\n⊢ Iff (Membership.mem s (fderivWithin 𝕜 f t x)) (Or (And (DifferentiableWithinAt 𝕜 f t x) (Membership.mem s (fderivWithin 𝕜 f t x))) (And (Not (DifferentiableWithinAt 𝕜 f t x)) (Membership.mem s 0)))","decl":"theorem fderivWithin_mem_iff {f : E → F} {t : Set E} {s : Set (E →L[𝕜] F)} {x : E} :\n    fderivWithin 𝕜 f t x ∈ s ↔\n      DifferentiableWithinAt 𝕜 f t x ∧ fderivWithin 𝕜 f t x ∈ s ∨\n        ¬DifferentiableWithinAt 𝕜 f t x ∧ (0 : E →L[𝕜] F) ∈ s := by\n  by_cases hx : DifferentiableWithinAt 𝕜 f t x <;>\n    simp [fderivWithin_zero_of_not_differentiableWithinAt, *]\n\n"}
{"name":"Asymptotics.IsBigO.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx₀ : E\nn : Nat\nh : Asymptotics.IsBigO (nhdsWithin x₀ s) f fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) n\nhx₀ : Membership.mem s x₀\nhn : LT.lt 1 n\n⊢ HasFDerivWithinAt f 0 s x₀","decl":"theorem Asymptotics.IsBigO.hasFDerivWithinAt {s : Set E} {x₀ : E} {n : ℕ}\n    (h : f =O[𝓝[s] x₀] fun x => ‖x - x₀‖ ^ n) (hx₀ : x₀ ∈ s) (hn : 1 < n) :\n    HasFDerivWithinAt f (0 : E →L[𝕜] F) s x₀ := by\n  simp_rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO,\n    h.eq_zero_of_norm_pow_within hx₀ hn.ne_bot, zero_apply, sub_zero,\n    h.trans_isLittleO ((isLittleO_pow_sub_sub x₀ hn).mono nhdsWithin_le_nhds)]\n\n"}
{"name":"Asymptotics.IsBigO.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nn : Nat\nh : Asymptotics.IsBigO (nhds x₀) f fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) n\nhn : LT.lt 1 n\n⊢ HasFDerivAt f 0 x₀","decl":"theorem Asymptotics.IsBigO.hasFDerivAt {x₀ : E} {n : ℕ} (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n)\n    (hn : 1 < n) : HasFDerivAt f (0 : E →L[𝕜] F) x₀ := by\n  rw [← nhdsWithin_univ] at h\n  exact (h.hasFDerivWithinAt (mem_univ _) hn).hasFDerivAt_of_univ\n\n"}
{"name":"HasFDerivWithinAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx₀ : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nh : HasFDerivWithinAt f f' s x₀\n⊢ Asymptotics.IsBigO (nhdsWithin x₀ s) (fun x => HSub.hSub (f x) (f x₀)) fun x => HSub.hSub x x₀","decl":"nonrec theorem HasFDerivWithinAt.isBigO_sub {f : E → F} {s : Set E} {x₀ : E} {f' : E →L[𝕜] F}\n    (h : HasFDerivWithinAt f f' s x₀) : (f · - f x₀) =O[𝓝[s] x₀] (· - x₀) :=\n  h.isBigO_sub\n\n"}
{"name":"DifferentiableWithinAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx₀ : E\nh : DifferentiableWithinAt 𝕜 f s x₀\n⊢ Asymptotics.IsBigO (nhdsWithin x₀ s) (fun x => HSub.hSub (f x) (f x₀)) fun x => HSub.hSub x x₀","decl":"lemma DifferentiableWithinAt.isBigO_sub {f : E → F} {s : Set E} {x₀ : E}\n    (h : DifferentiableWithinAt 𝕜 f s x₀) : (f · - f x₀) =O[𝓝[s] x₀] (· - x₀) :=\n  h.hasFDerivWithinAt.isBigO_sub\n\n"}
{"name":"HasFDerivAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nh : HasFDerivAt f f' x₀\n⊢ Asymptotics.IsBigO (nhds x₀) (fun x => HSub.hSub (f x) (f x₀)) fun x => HSub.hSub x x₀","decl":"nonrec theorem HasFDerivAt.isBigO_sub {f : E → F} {x₀ : E} {f' : E →L[𝕜] F}\n    (h : HasFDerivAt f f' x₀) : (f · - f x₀) =O[𝓝 x₀] (· - x₀) :=\n  h.isBigO_sub\n\n"}
{"name":"DifferentiableAt.isBigO_sub","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nh : DifferentiableAt 𝕜 f x₀\n⊢ Asymptotics.IsBigO (nhds x₀) (fun x => HSub.hSub (f x) (f x₀)) fun x => HSub.hSub x x₀","decl":"nonrec theorem DifferentiableAt.isBigO_sub {f : E → F} {x₀ : E} (h : DifferentiableAt 𝕜 f x₀) :\n    (f · - f x₀) =O[𝓝 x₀] (· - x₀) :=\n  h.hasFDerivAt.isBigO_sub\n\n"}
{"name":"HasFDerivAtFilter.tendsto_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nhL : LE.le L (nhds x)\nh : HasFDerivAtFilter f f' x L\n⊢ Filter.Tendsto f L (nhds (f x))","decl":"theorem HasFDerivAtFilter.tendsto_nhds (hL : L ≤ 𝓝 x) (h : HasFDerivAtFilter f f' x L) :\n    Tendsto f L (𝓝 (f x)) := by\n  have : Tendsto (fun x' => f x' - f x) L (𝓝 0) := by\n    refine h.isBigO_sub.trans_tendsto (Tendsto.mono_left ?_ hL)\n    rw [← sub_self x]\n    exact tendsto_id.sub tendsto_const_nhds\n  have := this.add (tendsto_const_nhds (x := f x))\n  rw [zero_add (f x)] at this\n  exact this.congr (by simp only [sub_add_cancel, eq_self_iff_true, forall_const])\n\n"}
{"name":"HasFDerivWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\n⊢ ContinuousWithinAt f s x","decl":"theorem HasFDerivWithinAt.continuousWithinAt (h : HasFDerivWithinAt f f' s x) :\n    ContinuousWithinAt f s x :=\n  HasFDerivAtFilter.tendsto_nhds inf_le_left h\n\n"}
{"name":"HasFDerivAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\n⊢ ContinuousAt f x","decl":"theorem HasFDerivAt.continuousAt (h : HasFDerivAt f f' x) : ContinuousAt f x :=\n  HasFDerivAtFilter.tendsto_nhds le_rfl h\n\n"}
{"name":"DifferentiableWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\n⊢ ContinuousWithinAt f s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.continuousWithinAt (h : DifferentiableWithinAt 𝕜 f s x) :\n    ContinuousWithinAt f s x :=\n  let ⟨_, hf'⟩ := h\n  hf'.continuousWithinAt\n\n"}
{"name":"DifferentiableAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : DifferentiableAt 𝕜 f x\n⊢ ContinuousAt f x","decl":"@[fun_prop]\ntheorem DifferentiableAt.continuousAt (h : DifferentiableAt 𝕜 f x) : ContinuousAt f x :=\n  let ⟨_, hf'⟩ := h\n  hf'.continuousAt\n\n"}
{"name":"DifferentiableOn.continuousOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : DifferentiableOn 𝕜 f s\n⊢ ContinuousOn f s","decl":"@[fun_prop]\ntheorem DifferentiableOn.continuousOn (h : DifferentiableOn 𝕜 f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuousWithinAt\n\n"}
{"name":"Differentiable.continuous","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nh : Differentiable 𝕜 f\n⊢ Continuous f","decl":"@[fun_prop]\ntheorem Differentiable.continuous (h : Differentiable 𝕜 f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (h x).continuousAt\n\n"}
{"name":"HasStrictFDerivAt.continuousAt","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhf : HasStrictFDerivAt f f' x\n⊢ ContinuousAt f x","decl":"protected theorem HasStrictFDerivAt.continuousAt (hf : HasStrictFDerivAt f f' x) :\n    ContinuousAt f x :=\n  hf.hasFDerivAt.continuousAt\n\n"}
{"name":"HasStrictFDerivAt.isBigO_sub_rev","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nhf : HasStrictFDerivAt f (↑f') x\n⊢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun p => HSub.hSub p.1 p.2) fun p => HSub.hSub (f p.1) (f p.2)","decl":"theorem HasStrictFDerivAt.isBigO_sub_rev {f' : E ≃L[𝕜] F}\n    (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) x) :\n    (fun p : E × E => p.1 - p.2) =O[𝓝 (x, x)] fun p : E × E => f p.1 - f p.2 :=\n  ((f'.isBigO_comp_rev _ _).trans\n      (hf.isLittleO.trans_isBigO (f'.isBigO_comp_rev _ _)).right_isBigO_add).congr\n    (fun _ => rfl) fun _ => sub_add_cancel _ _\n\n"}
{"name":"HasFDerivAtFilter.isBigO_sub_rev","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nhf : HasFDerivAtFilter f f' x L\nC : NNReal\nhf' : AntilipschitzWith C ⇑f'\n⊢ Asymptotics.IsBigO L (fun x' => HSub.hSub x' x) fun x' => HSub.hSub (f x') (f x)","decl":"theorem HasFDerivAtFilter.isBigO_sub_rev (hf : HasFDerivAtFilter f f' x L) {C}\n    (hf' : AntilipschitzWith C f') : (fun x' => x' - x) =O[L] fun x' => f x' - f x :=\n  have : (fun x' => x' - x) =O[L] fun x' => f' (x' - x) :=\n    isBigO_iff.2 ⟨C, Eventually.of_forall fun _ => ZeroHomClass.bound_of_antilipschitz f' hf' _⟩\n  (this.trans (hf.isLittleO.trans_isBigO this).right_isBigO_add).congr (fun _ => rfl) fun _ =>\n    sub_add_cancel _ _\n\n"}
{"name":"hasFDerivWithinAt_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivWithinAt f f' t x)","decl":"theorem hasFDerivWithinAt_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    HasFDerivWithinAt f f' s x ↔ HasFDerivWithinAt f f' t x :=\n  calc\n    HasFDerivWithinAt f f' s x ↔ HasFDerivWithinAt f f' (s \\ {y}) x :=\n      (hasFDerivWithinAt_diff_singleton _).symm\n    _ ↔ HasFDerivWithinAt f f' (t \\ {y}) x := by\n      suffices 𝓝[s \\ {y}] x = 𝓝[t \\ {y}] x by simp only [HasFDerivWithinAt, this]\n      simpa only [set_eventuallyEq_iff_inf_principal, ← nhdsWithin_inter', diff_eq,\n        inter_comm] using h\n    _ ↔ HasFDerivWithinAt f f' t x := hasFDerivWithinAt_diff_singleton _\n\n"}
{"name":"hasFDerivWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\n⊢ Iff (HasFDerivWithinAt f f' s x) (HasFDerivWithinAt f f' t x)","decl":"theorem hasFDerivWithinAt_congr_set (h : s =ᶠ[𝓝 x] t) :\n    HasFDerivWithinAt f f' s x ↔ HasFDerivWithinAt f f' t x :=\n  hasFDerivWithinAt_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"differentiableWithinAt_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ Iff (DifferentiableWithinAt 𝕜 f s x) (DifferentiableWithinAt 𝕜 f t x)","decl":"theorem differentiableWithinAt_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    DifferentiableWithinAt 𝕜 f s x ↔ DifferentiableWithinAt 𝕜 f t x :=\n  exists_congr fun _ => hasFDerivWithinAt_congr_set' _ h\n\n"}
{"name":"differentiableWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\n⊢ Iff (DifferentiableWithinAt 𝕜 f s x) (DifferentiableWithinAt 𝕜 f t x)","decl":"theorem differentiableWithinAt_congr_set (h : s =ᶠ[𝓝 x] t) :\n    DifferentiableWithinAt 𝕜 f s x ↔ DifferentiableWithinAt 𝕜 f t x :=\n  exists_congr fun _ => hasFDerivWithinAt_congr_set h\n\n"}
{"name":"fderivWithin_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ Eq (fderivWithin 𝕜 f s x) (fderivWithin 𝕜 f t x)","decl":"theorem fderivWithin_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    fderivWithin 𝕜 f s x = fderivWithin 𝕜 f t x := by\n  classical\n  simp only [fderivWithin, differentiableWithinAt_congr_set' _ h, hasFDerivWithinAt_congr_set' _ h]\n\n"}
{"name":"fderivWithin_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\n⊢ Eq (fderivWithin 𝕜 f s x) (fderivWithin 𝕜 f t x)","decl":"theorem fderivWithin_congr_set (h : s =ᶠ[𝓝 x] t) : fderivWithin 𝕜 f s x = fderivWithin 𝕜 f t x :=\n  fderivWithin_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"fderivWithin_eventually_congr_set'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\ny : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ (nhds x).EventuallyEq (fderivWithin 𝕜 f s) (fderivWithin 𝕜 f t)","decl":"theorem fderivWithin_eventually_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    fderivWithin 𝕜 f s =ᶠ[𝓝 x] fderivWithin 𝕜 f t :=\n  (eventually_nhds_nhdsWithin.2 h).mono fun _ => fderivWithin_congr_set' y\n\n"}
{"name":"fderivWithin_eventually_congr_set","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns t : Set E\nh : (nhds x).EventuallyEq s t\n⊢ (nhds x).EventuallyEq (fderivWithin 𝕜 f s) (fderivWithin 𝕜 f t)","decl":"theorem fderivWithin_eventually_congr_set (h : s =ᶠ[𝓝 x] t) :\n    fderivWithin 𝕜 f s =ᶠ[𝓝 x] fderivWithin 𝕜 f t :=\n  fderivWithin_eventually_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"Filter.EventuallyEq.hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nf₀' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : (nhds x).EventuallyEq f₀ f₁\nh' : ∀ (y : E), Eq (f₀' y) (f₁' y)\n⊢ Iff (HasStrictFDerivAt f₀ f₀' x) (HasStrictFDerivAt f₁ f₁' x)","decl":"theorem Filter.EventuallyEq.hasStrictFDerivAt_iff (h : f₀ =ᶠ[𝓝 x] f₁) (h' : ∀ y, f₀' y = f₁' y) :\n    HasStrictFDerivAt f₀ f₀' x ↔ HasStrictFDerivAt f₁ f₁' x := by\n  rw [hasStrictFDerivAt_iff_isLittleOTVS, hasStrictFDerivAt_iff_isLittleOTVS]\n  refine isLittleOTVS_congr ((h.prod_mk_nhds h).mono ?_) .rfl\n  rintro p ⟨hp₁, hp₂⟩\n  simp only [*]\n\n"}
{"name":"HasStrictFDerivAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' g' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasStrictFDerivAt f f' x\nh' : Eq f' g'\n⊢ HasStrictFDerivAt f g' x","decl":"theorem HasStrictFDerivAt.congr_fderiv (h : HasStrictFDerivAt f f' x) (h' : f' = g') :\n    HasStrictFDerivAt f g' x :=\n  h' ▸ h\n\n"}
{"name":"HasFDerivAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' g' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\nh' : Eq f' g'\n⊢ HasFDerivAt f g' x","decl":"theorem HasFDerivAt.congr_fderiv (h : HasFDerivAt f f' x) (h' : f' = g') : HasFDerivAt f g' x :=\n  h' ▸ h\n\n"}
{"name":"HasFDerivWithinAt.congr_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' g' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nh' : Eq f' g'\n⊢ HasFDerivWithinAt f g' s x","decl":"theorem HasFDerivWithinAt.congr_fderiv (h : HasFDerivWithinAt f f' s x) (h' : f' = g') :\n    HasFDerivWithinAt f g' s x :=\n  h' ▸ h\n\n"}
{"name":"HasStrictFDerivAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasStrictFDerivAt f f' x\nh₁ : (nhds x).EventuallyEq f f₁\n⊢ HasStrictFDerivAt f₁ f' x","decl":"theorem HasStrictFDerivAt.congr_of_eventuallyEq (h : HasStrictFDerivAt f f' x)\n    (h₁ : f =ᶠ[𝓝 x] f₁) : HasStrictFDerivAt f₁ f' x :=\n  (h₁.hasStrictFDerivAt_iff fun _ => rfl).1 h\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivAtFilter_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nf₀' f₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nh₀ : L.EventuallyEq f₀ f₁\nhx : Eq (f₀ x) (f₁ x)\nh₁ : ∀ (x : E), Eq (f₀' x) (f₁' x)\n⊢ Iff (HasFDerivAtFilter f₀ f₀' x L) (HasFDerivAtFilter f₁ f₁' x L)","decl":"theorem Filter.EventuallyEq.hasFDerivAtFilter_iff (h₀ : f₀ =ᶠ[L] f₁) (hx : f₀ x = f₁ x)\n    (h₁ : ∀ x, f₀' x = f₁' x) : HasFDerivAtFilter f₀ f₀' x L ↔ HasFDerivAtFilter f₁ f₁' x L := by\n  simp only [hasFDerivAtFilter_iff_isLittleOTVS]\n  exact isLittleOTVS_congr (h₀.mono fun y hy => by simp only [hy, h₁, hx]) .rfl\n\n"}
{"name":"HasFDerivAtFilter.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nh : HasFDerivAtFilter f f' x L\nhL : L.EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ HasFDerivAtFilter f₁ f' x L","decl":"theorem HasFDerivAtFilter.congr_of_eventuallyEq (h : HasFDerivAtFilter f f' x L) (hL : f₁ =ᶠ[L] f)\n    (hx : f₁ x = f x) : HasFDerivAtFilter f₁ f' x L :=\n  (hL.hasFDerivAtFilter_iff hx fun _ => rfl).2 h\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : (nhds x).EventuallyEq f₀ f₁\n⊢ Iff (HasFDerivAt f₀ f' x) (HasFDerivAt f₁ f' x)","decl":"theorem Filter.EventuallyEq.hasFDerivAt_iff (h : f₀ =ᶠ[𝓝 x] f₁) :\n    HasFDerivAt f₀ f' x ↔ HasFDerivAt f₁ f' x :=\n  h.hasFDerivAtFilter_iff h.eq_of_nhds fun _ => _root_.rfl\n\n"}
{"name":"Filter.EventuallyEq.differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nx : E\nh : (nhds x).EventuallyEq f₀ f₁\n⊢ Iff (DifferentiableAt 𝕜 f₀ x) (DifferentiableAt 𝕜 f₁ x)","decl":"theorem Filter.EventuallyEq.differentiableAt_iff (h : f₀ =ᶠ[𝓝 x] f₁) :\n    DifferentiableAt 𝕜 f₀ x ↔ DifferentiableAt 𝕜 f₁ x :=\n  exists_congr fun _ => h.hasFDerivAt_iff\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq f₀ f₁\nhx : Eq (f₀ x) (f₁ x)\n⊢ Iff (HasFDerivWithinAt f₀ f' s x) (HasFDerivWithinAt f₁ f' s x)","decl":"theorem Filter.EventuallyEq.hasFDerivWithinAt_iff (h : f₀ =ᶠ[𝓝[s] x] f₁) (hx : f₀ x = f₁ x) :\n    HasFDerivWithinAt f₀ f' s x ↔ HasFDerivWithinAt f₁ f' s x :=\n  h.hasFDerivAtFilter_iff hx fun _ => _root_.rfl\n\n"}
{"name":"Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq f₀ f₁\nhx : Membership.mem s x\n⊢ Iff (HasFDerivWithinAt f₀ f' s x) (HasFDerivWithinAt f₁ f' s x)","decl":"theorem Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem (h : f₀ =ᶠ[𝓝[s] x] f₁) (hx : x ∈ s) :\n    HasFDerivWithinAt f₀ f' s x ↔ HasFDerivWithinAt f₁ f' s x :=\n  h.hasFDerivWithinAt_iff (h.eq_of_nhdsWithin hx)\n\n"}
{"name":"Filter.EventuallyEq.differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq f₀ f₁\nhx : Eq (f₀ x) (f₁ x)\n⊢ Iff (DifferentiableWithinAt 𝕜 f₀ s x) (DifferentiableWithinAt 𝕜 f₁ s x)","decl":"theorem Filter.EventuallyEq.differentiableWithinAt_iff (h : f₀ =ᶠ[𝓝[s] x] f₁) (hx : f₀ x = f₁ x) :\n    DifferentiableWithinAt 𝕜 f₀ s x ↔ DifferentiableWithinAt 𝕜 f₁ s x :=\n  exists_congr fun _ => h.hasFDerivWithinAt_iff hx\n\n"}
{"name":"Filter.EventuallyEq.differentiableWithinAt_iff_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₀ f₁ : E → F\nx : E\ns : Set E\nh : (nhdsWithin x s).EventuallyEq f₀ f₁\nhx : Membership.mem s x\n⊢ Iff (DifferentiableWithinAt 𝕜 f₀ s x) (DifferentiableWithinAt 𝕜 f₁ s x)","decl":"theorem Filter.EventuallyEq.differentiableWithinAt_iff_of_mem (h : f₀ =ᶠ[𝓝[s] x] f₁) (hx : x ∈ s) :\n    DifferentiableWithinAt 𝕜 f₀ s x ↔ DifferentiableWithinAt 𝕜 f₁ s x :=\n  h.differentiableWithinAt_iff (h.eq_of_nhdsWithin hx)\n\n"}
{"name":"HasFDerivWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns t : Set E\nh : HasFDerivWithinAt f f' s x\nht : Set.EqOn f₁ f t\nhx : Eq (f₁ x) (f x)\nh₁ : HasSubset.Subset t s\n⊢ HasFDerivWithinAt f₁ f' t x","decl":"theorem HasFDerivWithinAt.congr_mono (h : HasFDerivWithinAt f f' s x) (ht : EqOn f₁ f t)\n    (hx : f₁ x = f x) (h₁ : t ⊆ s) : HasFDerivWithinAt f₁ f' t x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq (h.mono h₁) (Filter.mem_inf_of_right ht) hx\n\n"}
{"name":"HasFDerivWithinAt.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Set.EqOn f₁ f s\nhx : Eq (f₁ x) (f x)\n⊢ HasFDerivWithinAt f₁ f' s x","decl":"theorem HasFDerivWithinAt.congr (h : HasFDerivWithinAt f f' s x) (hs : EqOn f₁ f s)\n    (hx : f₁ x = f x) : HasFDerivWithinAt f₁ f' s x :=\n  h.congr_mono hs hx (Subset.refl _)\n\n"}
{"name":"HasFDerivWithinAt.congr'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhs : Set.EqOn f₁ f s\nhx : Membership.mem s x\n⊢ HasFDerivWithinAt f₁ f' s x","decl":"theorem HasFDerivWithinAt.congr' (h : HasFDerivWithinAt f f' s x) (hs : EqOn f₁ f s) (hx : x ∈ s) :\n    HasFDerivWithinAt f₁ f' s x :=\n  h.congr hs (hs hx)\n\n"}
{"name":"HasFDerivWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ HasFDerivWithinAt f₁ f' s x","decl":"theorem HasFDerivWithinAt.congr_of_eventuallyEq (h : HasFDerivWithinAt f f' s x)\n    (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) : HasFDerivWithinAt f₁ f' s x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq h h₁ hx\n\n"}
{"name":"HasFDerivAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\nh₁ : (nhds x).EventuallyEq f₁ f\n⊢ HasFDerivAt f₁ f' x","decl":"theorem HasFDerivAt.congr_of_eventuallyEq (h : HasFDerivAt f f' x) (h₁ : f₁ =ᶠ[𝓝 x] f) :\n    HasFDerivAt f₁ f' x :=\n  HasFDerivAtFilter.congr_of_eventuallyEq h h₁ (mem_of_mem_nhds h₁ :)\n\n"}
{"name":"DifferentiableWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns t : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nht : Set.EqOn f₁ f t\nhx : Eq (f₁ x) (f x)\nh₁ : HasSubset.Subset t s\n⊢ DifferentiableWithinAt 𝕜 f₁ t x","decl":"theorem DifferentiableWithinAt.congr_mono (h : DifferentiableWithinAt 𝕜 f s x) (ht : EqOn f₁ f t)\n    (hx : f₁ x = f x) (h₁ : t ⊆ s) : DifferentiableWithinAt 𝕜 f₁ t x :=\n  (HasFDerivWithinAt.congr_mono h.hasFDerivWithinAt ht hx h₁).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nht : ∀ (x : E), Membership.mem s x → Eq (f₁ x) (f x)\nhx : Eq (f₁ x) (f x)\n⊢ DifferentiableWithinAt 𝕜 f₁ s x","decl":"theorem DifferentiableWithinAt.congr (h : DifferentiableWithinAt 𝕜 f s x) (ht : ∀ x ∈ s, f₁ x = f x)\n    (hx : f₁ x = f x) : DifferentiableWithinAt 𝕜 f₁ s x :=\n  DifferentiableWithinAt.congr_mono h ht hx (Subset.refl _)\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ DifferentiableWithinAt 𝕜 f₁ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq (h : DifferentiableWithinAt 𝕜 f s x)\n    (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) : DifferentiableWithinAt 𝕜 f₁ s x :=\n  (h.hasFDerivWithinAt.congr_of_eventuallyEq h₁ hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Membership.mem s x\n⊢ DifferentiableWithinAt 𝕜 f₁ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq_of_mem (h : DifferentiableWithinAt 𝕜 f s x)\n    (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : x ∈ s) : DifferentiableWithinAt 𝕜 f₁ s x :=\n  h.congr_of_eventuallyEq h₁ (mem_of_mem_nhdsWithin hx h₁ :)\n\n"}
{"name":"DifferentiableWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nh₁ : (nhdsWithin x (Insert.insert x s)).EventuallyEq f₁ f\n⊢ DifferentiableWithinAt 𝕜 f₁ s x","decl":"theorem DifferentiableWithinAt.congr_of_eventuallyEq_insert (h : DifferentiableWithinAt 𝕜 f s x)\n    (h₁ : f₁ =ᶠ[𝓝[insert x s] x] f) : DifferentiableWithinAt 𝕜 f₁ s x :=\n  (h.insert.congr_of_eventuallyEq_of_mem h₁ (mem_insert _ _)).of_insert\n\n"}
{"name":"DifferentiableOn.congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\ns t : Set E\nh : DifferentiableOn 𝕜 f s\nh' : ∀ (x : E), Membership.mem t x → Eq (f₁ x) (f x)\nh₁ : HasSubset.Subset t s\n⊢ DifferentiableOn 𝕜 f₁ t","decl":"theorem DifferentiableOn.congr_mono (h : DifferentiableOn 𝕜 f s) (h' : ∀ x ∈ t, f₁ x = f x)\n    (h₁ : t ⊆ s) : DifferentiableOn 𝕜 f₁ t := fun x hx => (h x (h₁ hx)).congr_mono h' (h' x hx) h₁\n\n"}
{"name":"DifferentiableOn.congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\ns : Set E\nh : DifferentiableOn 𝕜 f s\nh' : ∀ (x : E), Membership.mem s x → Eq (f₁ x) (f x)\n⊢ DifferentiableOn 𝕜 f₁ s","decl":"theorem DifferentiableOn.congr (h : DifferentiableOn 𝕜 f s) (h' : ∀ x ∈ s, f₁ x = f x) :\n    DifferentiableOn 𝕜 f₁ s := fun x hx => (h x hx).congr h' (h' x hx)\n\n"}
{"name":"differentiableOn_congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\ns : Set E\nh' : ∀ (x : E), Membership.mem s x → Eq (f₁ x) (f x)\n⊢ Iff (DifferentiableOn 𝕜 f₁ s) (DifferentiableOn 𝕜 f s)","decl":"theorem differentiableOn_congr (h' : ∀ x ∈ s, f₁ x = f x) :\n    DifferentiableOn 𝕜 f₁ s ↔ DifferentiableOn 𝕜 f s :=\n  ⟨fun h => DifferentiableOn.congr h fun y hy => (h' y hy).symm, fun h =>\n    DifferentiableOn.congr h h'⟩\n\n"}
{"name":"DifferentiableAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\nh : DifferentiableAt 𝕜 f x\nhL : (nhds x).EventuallyEq f₁ f\n⊢ DifferentiableAt 𝕜 f₁ x","decl":"theorem DifferentiableAt.congr_of_eventuallyEq (h : DifferentiableAt 𝕜 f x) (hL : f₁ =ᶠ[𝓝 x] f) :\n    DifferentiableAt 𝕜 f₁ x :=\n  hL.differentiableAt_iff.2 h\n\n"}
{"name":"DifferentiableWithinAt.fderivWithin_congr_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns t : Set E\nh : DifferentiableWithinAt 𝕜 f s x\nhs : Set.EqOn f₁ f t\nhx : Eq (f₁ x) (f x)\nhxt : UniqueDiffWithinAt 𝕜 t x\nh₁ : HasSubset.Subset t s\n⊢ Eq (fderivWithin 𝕜 f₁ t x) (fderivWithin 𝕜 f s x)","decl":"theorem DifferentiableWithinAt.fderivWithin_congr_mono (h : DifferentiableWithinAt 𝕜 f s x)\n    (hs : EqOn f₁ f t) (hx : f₁ x = f x) (hxt : UniqueDiffWithinAt 𝕜 t x) (h₁ : t ⊆ s) :\n    fderivWithin 𝕜 f₁ t x = fderivWithin 𝕜 f s x :=\n  (HasFDerivWithinAt.congr_mono h.hasFDerivWithinAt hs hx h₁).fderivWithin hxt\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq (hs : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x := by\n  classical\n  simp only [fderivWithin, DifferentiableWithinAt, hs.hasFDerivWithinAt_iff hx]\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_of_mem","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Membership.mem s x\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_of_mem (hs : f₁ =ᶠ[𝓝[s] x] f) (hx : x ∈ s) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x :=\n  hs.fderivWithin_eq (mem_of_mem_nhdsWithin hx hs :)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_of_insert","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : (nhdsWithin x (Insert.insert x s)).EventuallyEq f₁ f\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_of_insert (hs : f₁ =ᶠ[𝓝[insert x s] x] f) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x := by\n  apply Filter.EventuallyEq.fderivWithin_eq (nhdsWithin_mono _ (subset_insert x s) hs)\n  exact (mem_of_mem_nhdsWithin (mem_insert x s) hs :)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns t : Set E\nhs : (nhdsWithin x s).EventuallyEq f₁ f\nht : HasSubset.Subset t s\n⊢ (nhdsWithin x s).EventuallyEq (fderivWithin 𝕜 f₁ t) (fderivWithin 𝕜 f t)","decl":"theorem Filter.EventuallyEq.fderivWithin' (hs : f₁ =ᶠ[𝓝[s] x] f) (ht : t ⊆ s) :\n    fderivWithin 𝕜 f₁ t =ᶠ[𝓝[s] x] fderivWithin 𝕜 f t :=\n  (eventually_eventually_nhdsWithin.2 hs).mp <|\n    eventually_mem_nhdsWithin.mono fun _y hys hs =>\n      EventuallyEq.fderivWithin_eq (hs.filter_mono <| nhdsWithin_mono _ ht)\n        (hs.self_of_nhdsWithin hys)\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : (nhdsWithin x s).EventuallyEq f₁ f\n⊢ (nhdsWithin x s).EventuallyEq (fderivWithin 𝕜 f₁ s) (fderivWithin 𝕜 f s)","decl":"protected theorem Filter.EventuallyEq.fderivWithin (hs : f₁ =ᶠ[𝓝[s] x] f) :\n    fderivWithin 𝕜 f₁ s =ᶠ[𝓝[s] x] fderivWithin 𝕜 f s :=\n  hs.fderivWithin' Subset.rfl\n\n"}
{"name":"Filter.EventuallyEq.fderivWithin_eq_nhds","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nh : (nhds x).EventuallyEq f₁ f\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem Filter.EventuallyEq.fderivWithin_eq_nhds (h : f₁ =ᶠ[𝓝 x] f) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x :=\n  (h.filter_mono nhdsWithin_le_nhds).fderivWithin_eq h.self_of_nhds\n\n"}
{"name":"fderivWithin_congr","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : Set.EqOn f₁ f s\nhx : Eq (f₁ x) (f x)\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem fderivWithin_congr (hs : EqOn f₁ f s) (hx : f₁ x = f x) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x :=\n  (hs.eventuallyEq.filter_mono inf_le_right).fderivWithin_eq hx\n\n"}
{"name":"fderivWithin_congr'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\ns : Set E\nhs : Set.EqOn f₁ f s\nhx : Membership.mem s x\n⊢ Eq (fderivWithin 𝕜 f₁ s x) (fderivWithin 𝕜 f s x)","decl":"theorem fderivWithin_congr' (hs : EqOn f₁ f s) (hx : x ∈ s) :\n    fderivWithin 𝕜 f₁ s x = fderivWithin 𝕜 f s x :=\n  fderivWithin_congr hs (hs hx)\n\n"}
{"name":"Filter.EventuallyEq.fderiv_eq","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\nh : (nhds x).EventuallyEq f₁ f\n⊢ Eq (fderiv 𝕜 f₁ x) (fderiv 𝕜 f x)","decl":"theorem Filter.EventuallyEq.fderiv_eq (h : f₁ =ᶠ[𝓝 x] f) : fderiv 𝕜 f₁ x = fderiv 𝕜 f x := by\n  rw [← fderivWithin_univ, ← fderivWithin_univ, h.fderivWithin_eq_nhds]\n\n"}
{"name":"Filter.EventuallyEq.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\nh : (nhds x).EventuallyEq f₁ f\n⊢ (nhds x).EventuallyEq (fderiv 𝕜 f₁) (fderiv 𝕜 f)","decl":"protected theorem Filter.EventuallyEq.fderiv (h : f₁ =ᶠ[𝓝 x] f) : fderiv 𝕜 f₁ =ᶠ[𝓝 x] fderiv 𝕜 f :=\n  h.eventuallyEq_nhds.mono fun _ h => h.fderiv_eq\n\n"}
{"name":"hasStrictFDerivAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ HasStrictFDerivAt id (ContinuousLinearMap.id 𝕜 E) x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_id (x : E) : HasStrictFDerivAt id (id 𝕜 E) x :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp\n\n"}
{"name":"hasFDerivAtFilter_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nL : Filter E\n⊢ HasFDerivAtFilter id (ContinuousLinearMap.id 𝕜 E) x L","decl":"theorem hasFDerivAtFilter_id (x : E) (L : Filter E) : HasFDerivAtFilter id (id 𝕜 E) x L :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left <| by simp\n\n"}
{"name":"hasFDerivWithinAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\n⊢ HasFDerivWithinAt id (ContinuousLinearMap.id 𝕜 E) s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_id (x : E) (s : Set E) : HasFDerivWithinAt id (id 𝕜 E) s x :=\n  hasFDerivAtFilter_id _ _\n\n"}
{"name":"hasFDerivAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ HasFDerivAt id (ContinuousLinearMap.id 𝕜 E) x","decl":"@[fun_prop]\ntheorem hasFDerivAt_id (x : E) : HasFDerivAt id (id 𝕜 E) x :=\n  hasFDerivAtFilter_id _ _\n\n"}
{"name":"differentiableAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ DifferentiableAt 𝕜 id x","decl":"@[simp, fun_prop]\ntheorem differentiableAt_id : DifferentiableAt 𝕜 id x :=\n  (hasFDerivAt_id x).differentiableAt\n\n"}
{"name":"differentiableAt_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ DifferentiableAt 𝕜 (fun x => x) x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[simp]\ntheorem differentiableAt_id' : DifferentiableAt 𝕜 (fun x => x) x :=\n  (hasFDerivAt_id x).differentiableAt\n\n"}
{"name":"differentiableWithinAt_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\n⊢ DifferentiableWithinAt 𝕜 id s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_id : DifferentiableWithinAt 𝕜 id s x :=\n  differentiableAt_id.differentiableWithinAt\n\n"}
{"name":"differentiableWithinAt_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\n⊢ DifferentiableWithinAt 𝕜 (fun x => x) s x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[fun_prop]\ntheorem differentiableWithinAt_id' : DifferentiableWithinAt 𝕜 (fun x => x) s x :=\n  differentiableWithinAt_id\n\n"}
{"name":"differentiable_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Differentiable 𝕜 id","decl":"@[simp, fun_prop]\ntheorem differentiable_id : Differentiable 𝕜 (id : E → E) := fun _ => differentiableAt_id\n\n"}
{"name":"differentiable_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Differentiable 𝕜 fun x => x","decl":"/-- Variant with `fun x => x` rather than `id` -/\n@[simp]\ntheorem differentiable_id' : Differentiable 𝕜 fun x : E => x := fun _ => differentiableAt_id\n\n"}
{"name":"differentiableOn_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ DifferentiableOn 𝕜 id s","decl":"@[fun_prop]\ntheorem differentiableOn_id : DifferentiableOn 𝕜 id s :=\n  differentiable_id.differentiableOn\n\n"}
{"name":"fderiv_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Eq (fderiv 𝕜 id x) (ContinuousLinearMap.id 𝕜 E)","decl":"@[simp]\ntheorem fderiv_id : fderiv 𝕜 id x = id 𝕜 E :=\n  HasFDerivAt.fderiv (hasFDerivAt_id x)\n\n"}
{"name":"fderiv_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Eq (fderiv 𝕜 (fun x => x) x) (ContinuousLinearMap.id 𝕜 E)","decl":"@[simp]\ntheorem fderiv_id' : fderiv 𝕜 (fun x : E => x) x = ContinuousLinearMap.id 𝕜 E :=\n  fderiv_id\n\n"}
{"name":"fderivWithin_id","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 id s x) (ContinuousLinearMap.id 𝕜 E)","decl":"theorem fderivWithin_id (hxs : UniqueDiffWithinAt 𝕜 s x) : fderivWithin 𝕜 id s x = id 𝕜 E := by\n  rw [DifferentiableAt.fderivWithin differentiableAt_id hxs]\n  exact fderiv_id\n\n"}
{"name":"fderivWithin_id'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x => x) s x) (ContinuousLinearMap.id 𝕜 E)","decl":"theorem fderivWithin_id' (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x : E => x) s x = ContinuousLinearMap.id 𝕜 E :=\n  fderivWithin_id hxs\n\n"}
{"name":"hasStrictFDerivAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\nx : E\n⊢ HasStrictFDerivAt (fun x => c) 0 x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_const (c : F) (x : E) :\n    HasStrictFDerivAt (fun _ => c) (0 : E →L[𝕜] F) x :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left fun _ => by\n    simp only [zero_apply, sub_self, Pi.zero_apply]\n\n"}
{"name":"hasFDerivAtFilter_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\nx : E\nL : Filter E\n⊢ HasFDerivAtFilter (fun x => c) 0 x L","decl":"theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\n    HasFDerivAtFilter (fun _ => c) (0 : E →L[𝕜] F) x L :=\n  .of_isLittleOTVS <| (IsLittleOTVS.zero _ _).congr_left fun _ => by\n    simp only [zero_apply, sub_self, Pi.zero_apply]\n\n"}
{"name":"hasFDerivWithinAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\nx : E\ns : Set E\n⊢ HasFDerivWithinAt (fun x => c) 0 s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_const (c : F) (x : E) (s : Set E) :\n    HasFDerivWithinAt (fun _ => c) (0 : E →L[𝕜] F) s x :=\n  hasFDerivAtFilter_const _ _ _\n\n"}
{"name":"hasFDerivAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\nx : E\n⊢ HasFDerivAt (fun x => c) 0 x","decl":"@[fun_prop]\ntheorem hasFDerivAt_const (c : F) (x : E) : HasFDerivAt (fun _ => c) (0 : E →L[𝕜] F) x :=\n  hasFDerivAtFilter_const _ _ _\n\n"}
{"name":"differentiableAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nc : F\n⊢ DifferentiableAt 𝕜 (fun x => c) x","decl":"@[simp, fun_prop]\ntheorem differentiableAt_const (c : F) : DifferentiableAt 𝕜 (fun _ => c) x :=\n  ⟨0, hasFDerivAt_const c x⟩\n\n"}
{"name":"differentiableWithinAt_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\nc : F\n⊢ DifferentiableWithinAt 𝕜 (fun x => c) s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_const (c : F) : DifferentiableWithinAt 𝕜 (fun _ => c) s x :=\n  DifferentiableAt.differentiableWithinAt (differentiableAt_const _)\n\n"}
{"name":"fderivWithin_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\nc : F\n⊢ Eq (fderivWithin 𝕜 (fun x => c) s x) 0","decl":"theorem fderivWithin_const_apply (c : F) : fderivWithin 𝕜 (fun _ => c) s x = 0 := by\n  rw [fderivWithin, if_pos]\n  apply hasFDerivWithinAt_const\n\n"}
{"name":"fderivWithin_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nc : F\n⊢ Eq (fderivWithin 𝕜 (fun x => c) s) 0","decl":"@[simp]\ntheorem fderivWithin_const (c : F) : fderivWithin 𝕜 (fun _ ↦ c) s = 0 := by\n  ext\n  rw [fderivWithin_const_apply, Pi.zero_apply]\n\n"}
{"name":"fderiv_const_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nc : F\n⊢ Eq (fderiv 𝕜 (fun x => c) x) 0","decl":"theorem fderiv_const_apply (c : F) : fderiv 𝕜 (fun _ => c) x = 0 :=\n  (hasFDerivAt_const c x).fderiv\n\n"}
{"name":"fderiv_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\n⊢ Eq (fderiv 𝕜 fun x => c) 0","decl":"@[simp]\ntheorem fderiv_const (c : F) : (fderiv 𝕜 fun _ : E => c) = 0 := by\n  rw [← fderivWithin_univ, fderivWithin_const]\n\n"}
{"name":"differentiable_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\n⊢ Differentiable 𝕜 fun x => c","decl":"@[simp, fun_prop]\ntheorem differentiable_const (c : F) : Differentiable 𝕜 fun _ : E => c := fun _ =>\n  differentiableAt_const _\n\n"}
{"name":"differentiableOn_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nc : F\n⊢ DifferentiableOn 𝕜 (fun x => c) s","decl":"@[simp, fun_prop]\ntheorem differentiableOn_const (c : F) : DifferentiableOn 𝕜 (fun _ => c) s :=\n  (differentiable_const _).differentiableOn\n\n"}
{"name":"hasFDerivWithinAt_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ HasFDerivWithinAt f 0 (Singleton.singleton x) x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_singleton (f : E → F) (x : E) :\n    HasFDerivWithinAt f (0 : E →L[𝕜] F) {x} x := by\n  simp only [HasFDerivWithinAt, nhdsWithin_singleton, hasFDerivAtFilter_iff_isLittleO,\n    isLittleO_pure, ContinuousLinearMap.zero_apply, sub_self]\n\n"}
{"name":"hasFDerivAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nh : Subsingleton E\nf : E → F\nx : E\n⊢ HasFDerivAt f 0 x","decl":"@[fun_prop]\ntheorem hasFDerivAt_of_subsingleton [h : Subsingleton E] (f : E → F) (x : E) :\n    HasFDerivAt f (0 : E →L[𝕜] F) x := by\n  rw [← hasFDerivWithinAt_univ, subsingleton_univ.eq_singleton_of_mem (mem_univ x)]\n  exact hasFDerivWithinAt_singleton f x\n\n"}
{"name":"differentiableOn_empty","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ DifferentiableOn 𝕜 f EmptyCollection.emptyCollection","decl":"@[fun_prop]\ntheorem differentiableOn_empty : DifferentiableOn 𝕜 f ∅ := fun _ => False.elim\n\n"}
{"name":"differentiableOn_singleton","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ DifferentiableOn 𝕜 f (Singleton.singleton x)","decl":"@[fun_prop]\ntheorem differentiableOn_singleton : DifferentiableOn 𝕜 f {x} :=\n  forall_eq.2 (hasFDerivWithinAt_singleton f x).differentiableWithinAt\n\n"}
{"name":"Set.Subsingleton.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhs : s.Subsingleton\n⊢ DifferentiableOn 𝕜 f s","decl":"@[fun_prop]\ntheorem Set.Subsingleton.differentiableOn (hs : s.Subsingleton) : DifferentiableOn 𝕜 f s :=\n  hs.induction_on differentiableOn_empty fun _ => differentiableOn_singleton\n\n"}
{"name":"hasFDerivAt_zero_of_eventually_const","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nc : F\nhf : (nhds x).EventuallyEq f fun x => c\n⊢ HasFDerivAt f 0 x","decl":"theorem hasFDerivAt_zero_of_eventually_const (c : F) (hf : f =ᶠ[𝓝 x] fun _ => c) :\n    HasFDerivAt f (0 : E →L[𝕜] F) x :=\n  (hasFDerivAt_const _ _).congr_of_eventuallyEq hf\n\n"}
{"name":"HasFDerivAt.le_of_lip'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx₀ : E\nhf : HasFDerivAt f f' x₀\nC : Real\nhC₀ : LE.le 0 C\nhlip : Filter.Eventually (fun x => LE.le (Norm.norm (HSub.hSub (f x) (f x₀))) (HMul.hMul C (Norm.norm (HSub.hSub x x₀)))) (nhds x₀)\n⊢ LE.le (Norm.norm f') C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\non a neighborhood of `x₀` then its derivative at `x₀` has norm bounded by `C`. This version\nonly assumes that `‖f x - f x₀‖ ≤ C * ‖x - x₀‖` in a neighborhood of `x`. -/\ntheorem HasFDerivAt.le_of_lip' {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : HasFDerivAt f f' x₀)\n    {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ x in 𝓝 x₀, ‖f x - f x₀‖ ≤ C * ‖x - x₀‖) : ‖f'‖ ≤ C := by\n  refine le_of_forall_pos_le_add fun ε ε0 => opNorm_le_of_nhds_zero ?_ ?_\n  · exact add_nonneg hC₀ ε0.le\n  rw [← map_add_left_nhds_zero x₀, eventually_map] at hlip\n  filter_upwards [isLittleO_iff.1 (hasFDerivAt_iff_isLittleO_nhds_zero.1 hf) ε0, hlip] with y hy hyC\n  rw [add_sub_cancel_left] at hyC\n  calc\n    ‖f' y‖ ≤ ‖f (x₀ + y) - f x₀‖ + ‖f (x₀ + y) - f x₀ - f' y‖ := norm_le_insert _ _\n    _ ≤ C * ‖y‖ + ε * ‖y‖ := add_le_add hyC hy\n    _ = (C + ε) * ‖y‖ := (add_mul _ _ _).symm\n\n"}
{"name":"HasFDerivAt.le_of_lipschitzOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx₀ : E\nhf : HasFDerivAt f f' x₀\ns : Set E\nhs : Membership.mem (nhds x₀) s\nC : NNReal\nhlip : LipschitzOnWith C f s\n⊢ LE.le (Norm.norm f') ↑C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\non a neighborhood of `x₀` then its derivative at `x₀` has norm bounded by `C`. -/\ntheorem HasFDerivAt.le_of_lipschitzOn\n    {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : HasFDerivAt f f' x₀)\n    {s : Set E} (hs : s ∈ 𝓝 x₀) {C : ℝ≥0} (hlip : LipschitzOnWith C f s) : ‖f'‖ ≤ C := by\n  refine hf.le_of_lip' C.coe_nonneg ?_\n  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)\n\n"}
{"name":"HasFDerivAt.le_of_lipschitz","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx₀ : E\nhf : HasFDerivAt f f' x₀\nC : NNReal\nhlip : LipschitzWith C f\n⊢ LE.le (Norm.norm f') ↑C","decl":"/-- Converse to the mean value inequality: if `f` is differentiable at `x₀` and `C`-lipschitz\nthen its derivative at `x₀` has norm bounded by `C`. -/\ntheorem HasFDerivAt.le_of_lipschitz {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : HasFDerivAt f f' x₀)\n    {C : ℝ≥0} (hlip : LipschitzWith C f) : ‖f'‖ ≤ C :=\n  hf.le_of_lipschitzOn univ_mem (lipschitzOnWith_univ.2 hlip)\n\n"}
{"name":"norm_fderiv_le_of_lip'","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nC : Real\nhC₀ : LE.le 0 C\nhlip : Filter.Eventually (fun x => LE.le (Norm.norm (HSub.hSub (f x) (f x₀))) (HMul.hMul C (Norm.norm (HSub.hSub x x₀)))) (nhds x₀)\n⊢ LE.le (Norm.norm (fderiv 𝕜 f x₀)) C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz\non a neighborhood of `x₀` then its derivative at `x₀` has norm bounded by `C`. This version\nonly assumes that `‖f x - f x₀‖ ≤ C * ‖x - x₀‖` in a neighborhood of `x`. -/\ntheorem norm_fderiv_le_of_lip' {f : E → F} {x₀ : E}\n    {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ x in 𝓝 x₀, ‖f x - f x₀‖ ≤ C * ‖x - x₀‖) :\n    ‖fderiv 𝕜 f x₀‖ ≤ C := by\n  by_cases hf : DifferentiableAt 𝕜 f x₀\n  · exact hf.hasFDerivAt.le_of_lip' hC₀ hlip\n  · rw [fderiv_zero_of_not_differentiableAt hf]\n    simp [hC₀]\n\n"}
{"name":"norm_fderiv_le_of_lipschitzOn","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\ns : Set E\nhs : Membership.mem (nhds x₀) s\nC : NNReal\nhlip : LipschitzOnWith C f s\n⊢ LE.le (Norm.norm (fderiv 𝕜 f x₀)) ↑C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz\non a neighborhood of `x₀` then its derivative at `x₀` has norm bounded by `C`.\nVersion using `fderiv`. -/\n-- Porting note: renamed so that dot-notation makes sense\ntheorem norm_fderiv_le_of_lipschitzOn {f : E → F} {x₀ : E} {s : Set E} (hs : s ∈ 𝓝 x₀)\n    {C : ℝ≥0} (hlip : LipschitzOnWith C f s) : ‖fderiv 𝕜 f x₀‖ ≤ C := by\n  refine norm_fderiv_le_of_lip' 𝕜 C.coe_nonneg ?_\n  filter_upwards [hs] with x hx using hlip.norm_sub_le hx (mem_of_mem_nhds hs)\n\n"}
{"name":"norm_fderiv_le_of_lipschitz","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nC : NNReal\nhlip : LipschitzWith C f\n⊢ LE.le (Norm.norm (fderiv 𝕜 f x₀)) ↑C","decl":"/-- Converse to the mean value inequality: if `f` is `C`-lipschitz then\nits derivative at `x₀` has norm bounded by `C`.\nVersion using `fderiv`. -/\ntheorem norm_fderiv_le_of_lipschitz {f : E → F} {x₀ : E}\n    {C : ℝ≥0} (hlip : LipschitzWith C f) : ‖fderiv 𝕜 f x₀‖ ≤ C :=\n  norm_fderiv_le_of_lipschitzOn 𝕜 univ_mem (lipschitzOnWith_univ.2 hlip)\n\n"}
{"name":"HasStrictFDerivAt.of_nmem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Not (Membership.mem (tsupport f) x)\n⊢ HasStrictFDerivAt f 0 x","decl":"theorem HasStrictFDerivAt.of_nmem_tsupport (h : x ∉ tsupport f) :\n    HasStrictFDerivAt f (0 : E →L[𝕜] F) x := by\n  rw [not_mem_tsupport_iff_eventuallyEq] at h\n  exact (hasStrictFDerivAt_const (0 : F) x).congr_of_eventuallyEq h.symm\n\n"}
{"name":"HasFDerivAt.of_nmem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Not (Membership.mem (tsupport f) x)\n⊢ HasFDerivAt f 0 x","decl":"theorem HasFDerivAt.of_nmem_tsupport (h : x ∉ tsupport f) :\n    HasFDerivAt f (0 : E →L[𝕜] F) x :=\n  (HasStrictFDerivAt.of_nmem_tsupport 𝕜 h).hasFDerivAt\n\n"}
{"name":"HasFDerivWithinAt.of_not_mem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nh : Not (Membership.mem (tsupport f) x)\n⊢ HasFDerivWithinAt f 0 s x","decl":"theorem HasFDerivWithinAt.of_not_mem_tsupport {s : Set E} {x : E} (h : x ∉ tsupport f) :\n    HasFDerivWithinAt f (0 : E →L[𝕜] F) s x :=\n  (HasFDerivAt.of_nmem_tsupport 𝕜 h).hasFDerivWithinAt\n\n"}
{"name":"fderiv_of_not_mem_tsupport","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Not (Membership.mem (tsupport f) x)\n⊢ Eq (fderiv 𝕜 f x) 0","decl":"theorem fderiv_of_not_mem_tsupport (h : x ∉ tsupport f) : fderiv 𝕜 f x = 0 :=\n  (HasFDerivAt.of_nmem_tsupport 𝕜 h).fderiv\n\n"}
{"name":"support_fderiv_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ HasSubset.Subset (Function.support (fderiv 𝕜 f)) (tsupport f)","decl":"theorem support_fderiv_subset : support (fderiv 𝕜 f) ⊆ tsupport f := fun x ↦ by\n  rw [← not_imp_not, nmem_support]\n  exact fderiv_of_not_mem_tsupport _\n\n"}
{"name":"tsupport_fderiv_subset","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ HasSubset.Subset (tsupport (fderiv 𝕜 f)) (tsupport f)","decl":"theorem tsupport_fderiv_subset : tsupport (fderiv 𝕜 f) ⊆ tsupport f :=\n  closure_minimal (support_fderiv_subset 𝕜) isClosed_closure\n\n"}
{"name":"HasCompactSupport.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : HasCompactSupport f\n⊢ HasCompactSupport (fderiv 𝕜 f)","decl":"protected theorem HasCompactSupport.fderiv (hf : HasCompactSupport f) :\n    HasCompactSupport (fderiv 𝕜 f) :=\n  hf.mono' <| support_fderiv_subset 𝕜\n\n"}
{"name":"HasCompactSupport.fderiv_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : HasCompactSupport f\nv : E\n⊢ HasCompactSupport fun x => (fderiv 𝕜 f x) v","decl":"protected theorem HasCompactSupport.fderiv_apply (hf : HasCompactSupport f) (v : E) :\n    HasCompactSupport (fderiv 𝕜 f · v) :=\n  hf.fderiv 𝕜 |>.comp_left (g := fun L : E →L[𝕜] F ↦ L v) rfl\n\n"}
