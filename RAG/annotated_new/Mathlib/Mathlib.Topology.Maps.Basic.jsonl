{"name":"Topology.IsInducing.induced","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Topology.IsInducing f","decl":"protected lemma IsInducing.induced (f : X ‚Üí Y) : @IsInducing X Y (induced f ‚Äπ_‚Ä∫) _ f :=\n  @IsInducing.mk _ _ (TopologicalSpace.induced f ‚Äπ_‚Ä∫) _ _ rfl\n\n"}
{"name":"Topology.inducing_induced","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_induced := IsInducing.induced\n\n"}
{"name":"Topology.IsInducing.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsInducing id","decl":"protected lemma IsInducing.id : IsInducing (@id X) := ‚ü®induced_id.symm‚ü©\n\n"}
{"name":"Topology.inducing_id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsInducing id","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_id := IsInducing.id\n\n"}
{"name":"Topology.IsInducing.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\nhf : Topology.IsInducing f\n‚ä¢ Topology.IsInducing (Function.comp g f)","decl":"protected lemma IsInducing.comp (hg : IsInducing g) (hf : IsInducing f) :\n    IsInducing (g ‚àò f) :=\n  ‚ü®by rw [hf.eq_induced, hg.eq_induced, induced_compose]‚ü©\n\n"}
{"name":"Topology.Inducing.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\nhf : Topology.IsInducing f\n‚ä¢ Topology.IsInducing (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.comp := IsInducing.comp\n\n"}
{"name":"Topology.IsInducing.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\n‚ä¢ Iff (Topology.IsInducing (Function.comp g f)) (Topology.IsInducing f)","decl":"lemma IsInducing.of_comp_iff (hg : IsInducing g) : IsInducing (g ‚àò f) ‚Üî IsInducing f := by\n  refine ‚ü®fun h ‚Ü¶ ?_, hg.comp‚ü©\n  rw [isInducing_iff, hg.eq_induced, induced_compose, h.eq_induced]\n\n"}
{"name":"Topology.Inducing.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\n‚ä¢ Iff (Topology.IsInducing (Function.comp g f)) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.of_comp_iff := IsInducing.of_comp_iff\n\n"}
{"name":"Topology.IsInducing.of_comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsInducing (Function.comp g f)\n‚ä¢ Topology.IsInducing f","decl":"lemma IsInducing.of_comp (hf : Continuous f) (hg : Continuous g) (hgf : IsInducing (g ‚àò f)) :\n    IsInducing f :=\n  ‚ü®le_antisymm (by rwa [‚Üê continuous_iff_le_induced])\n      (by\n        rw [hgf.eq_induced, ‚Üê induced_compose]\n        exact induced_mono hg.le_induced)‚ü©\n\n"}
{"name":"Topology.inducing_of_inducing_compose","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsInducing (Function.comp g f)\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_of_inducing_compose := IsInducing.of_comp\n\n"}
{"name":"Topology.isInducing_iff_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (Topology.IsInducing f) (‚àÄ (x : X), Eq (nhds x) (Filter.comap f (nhds (f x))))","decl":"lemma isInducing_iff_nhds : IsInducing f ‚Üî ‚àÄ x, ùìù x = comap f (ùìù (f x)) :=\n  (isInducing_iff _).trans (induced_iff_nhds_eq f)\n\n"}
{"name":"Topology.inducing_iff_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (Topology.IsInducing f) (‚àÄ (x : X), Eq (nhds x) (Filter.comap f (nhds (f x))))","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_iff_nhds := isInducing_iff_nhds\n\n"}
{"name":"Topology.IsInducing.nhds_eq_comap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\nx : X\n‚ä¢ Eq (nhds x) (Filter.comap f (nhds (f x)))","decl":"lemma nhds_eq_comap (hf : IsInducing f) : ‚àÄ x : X, ùìù x = comap f (ùìù <| f x) :=\n  isInducing_iff_nhds.1 hf\n\n"}
{"name":"Topology.IsInducing.basis_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nŒπ : Type u_4\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Y\nhf : Topology.IsInducing f\nx : X\nh_basis : (nhds (f x)).HasBasis p s\n‚ä¢ (nhds x).HasBasis p (Function.comp (Set.preimage f) s)","decl":"lemma basis_nhds {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Y} (hf : IsInducing f) {x : X}\n    (h_basis : (ùìù (f x)).HasBasis p s) : (ùìù x).HasBasis p (preimage f ‚àò s) :=\n  hf.nhds_eq_comap x ‚ñ∏ h_basis.comap f\n\n"}
{"name":"Topology.IsInducing.nhdsSet_eq_comap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Eq (nhdsSet s) (Filter.comap f (nhdsSet (Set.image f s)))","decl":"lemma nhdsSet_eq_comap (hf : IsInducing f) (s : Set X) :\n    ùìùÀ¢ s = comap f (ùìùÀ¢ (f '' s)) := by\n  simp only [nhdsSet, sSup_image, comap_iSup, hf.nhds_eq_comap, iSup_image]\n\n"}
{"name":"Topology.IsInducing.map_nhds_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\nx : X\n‚ä¢ Eq (Filter.map f (nhds x)) (nhdsWithin (f x) (Set.range f))","decl":"lemma map_nhds_eq (hf : IsInducing f) (x : X) : (ùìù x).map f = ùìù[range f] f x :=\n  hf.eq_induced ‚ñ∏ map_nhds_induced_eq x\n\n"}
{"name":"Topology.IsInducing.map_nhds_of_mem","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\nx : X\nh : Membership.mem (nhds (f x)) (Set.range f)\n‚ä¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"lemma map_nhds_of_mem (hf : IsInducing f) (x : X) (h : range f ‚àà ùìù (f x)) :\n    (ùìù x).map f = ùìù (f x) := hf.eq_induced ‚ñ∏ map_nhds_induced_of_mem h\n\n"}
{"name":"Topology.IsInducing.mapClusterPt_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\nx : X\nl : Filter X\n‚ä¢ Iff (MapClusterPt (f x) l f) (ClusterPt x l)","decl":"lemma mapClusterPt_iff (hf : IsInducing f) {x : X} {l : Filter X} :\n    MapClusterPt (f x) l f ‚Üî ClusterPt x l := by\n  delta MapClusterPt ClusterPt\n  rw [‚Üê Filter.push_pull', ‚Üê hf.nhds_eq_comap, map_neBot_iff]\n\n"}
{"name":"Topology.IsInducing.image_mem_nhdsWithin","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\nx : X\ns : Set X\nhs : Membership.mem (nhds x) s\n‚ä¢ Membership.mem (nhdsWithin (f x) (Set.range f)) (Set.image f s)","decl":"lemma image_mem_nhdsWithin (hf : IsInducing f) {x : X} {s : Set X} (hs : s ‚àà ùìù x) :\n    f '' s ‚àà ùìù[range f] f x :=\n  hf.map_nhds_eq x ‚ñ∏ image_mem_map hs\n\n"}
{"name":"Topology.IsInducing.tendsto_nhds_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"Y : Type u_2\nZ : Type u_3\nŒπ : Type u_4\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : Œπ ‚Üí Y\nl : Filter Œπ\ny : Y\nhg : Topology.IsInducing g\n‚ä¢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (Function.comp g f) l (nhds (g y)))","decl":"lemma tendsto_nhds_iff {f : Œπ ‚Üí Y} {l : Filter Œπ} {y : Y} (hg : IsInducing g) :\n    Tendsto f l (ùìù y) ‚Üî Tendsto (g ‚àò f) l (ùìù (g y)) := by\n  rw [hg.nhds_eq_comap, tendsto_comap_iff]\n\n"}
{"name":"Topology.IsInducing.continuousAt_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\nx : X\n‚ä¢ Iff (ContinuousAt f x) (ContinuousAt (Function.comp g f) x)","decl":"lemma continuousAt_iff (hg : IsInducing g) {x : X} :\n    ContinuousAt f x ‚Üî ContinuousAt (g ‚àò f) x :=\n  hg.tendsto_nhds_iff\n\n"}
{"name":"Topology.IsInducing.continuous_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsInducing g\n‚ä¢ Iff (Continuous f) (Continuous (Function.comp g f))","decl":"lemma continuous_iff (hg : IsInducing g) :\n    Continuous f ‚Üî Continuous (g ‚àò f) := by\n  simp_rw [continuous_iff_continuousAt, hg.continuousAt_iff]\n\n"}
{"name":"Topology.IsInducing.continuousAt_iff'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Z\nhf : Topology.IsInducing f\nx : X\nh : Membership.mem (nhds (f x)) (Set.range f)\n‚ä¢ Iff (ContinuousAt (Function.comp g f) x) (ContinuousAt g (f x))","decl":"lemma continuousAt_iff' (hf : IsInducing f) {x : X} (h : range f ‚àà ùìù (f x)) :\n    ContinuousAt (g ‚àò f) x ‚Üî ContinuousAt g (f x) := by\n  simp_rw [ContinuousAt, Filter.Tendsto, ‚Üê hf.map_nhds_of_mem _ h, Filter.map_map, comp]\n\n"}
{"name":"Topology.IsInducing.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\n‚ä¢ Continuous f","decl":"protected lemma continuous (hf : IsInducing f) : Continuous f :=\n  hf.continuous_iff.mp continuous_id\n\n"}
{"name":"Topology.IsInducing.closure_eq_preimage_closure_image","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Eq (closure s) (Set.preimage f (closure (Set.image f s)))","decl":"lemma closure_eq_preimage_closure_image (hf : IsInducing f) (s : Set X) :\n    closure s = f ‚Åª¬π' closure (f '' s) := by\n  ext x\n  rw [Set.mem_preimage, ‚Üê closure_induced, hf.eq_induced]\n\n"}
{"name":"Topology.IsInducing.isClosed_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Iff (IsClosed s) (Exists fun t => And (IsClosed t) (Eq (Set.preimage f t) s))","decl":"theorem isClosed_iff (hf : IsInducing f) {s : Set X} :\n    IsClosed s ‚Üî ‚àÉ t, IsClosed t ‚àß f ‚Åª¬π' t = s := by rw [hf.eq_induced, isClosed_induced_iff]\n\n"}
{"name":"Topology.IsInducing.isClosed_iff'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Iff (IsClosed s) (‚àÄ (x : X), Membership.mem (closure (Set.image f s)) (f x) ‚Üí Membership.mem s x)","decl":"theorem isClosed_iff' (hf : IsInducing f) {s : Set X} :\n    IsClosed s ‚Üî ‚àÄ x, f x ‚àà closure (f '' s) ‚Üí x ‚àà s := by rw [hf.eq_induced, isClosed_induced_iff']\n\n"}
{"name":"Topology.IsInducing.isClosed_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nh : Topology.IsInducing f\ns : Set Y\nhs : IsClosed s\n‚ä¢ IsClosed (Set.preimage f s)","decl":"theorem isClosed_preimage (h : IsInducing f) (s : Set Y) (hs : IsClosed s) :\n    IsClosed (f ‚Åª¬π' s) :=\n  (isClosed_iff h).mpr ‚ü®s, hs, rfl‚ü©\n\n"}
{"name":"Topology.IsInducing.isOpen_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Iff (IsOpen s) (Exists fun t => And (IsOpen t) (Eq (Set.preimage f t) s))","decl":"theorem isOpen_iff (hf : IsInducing f) {s : Set X} :\n    IsOpen s ‚Üî ‚àÉ t, IsOpen t ‚àß f ‚Åª¬π' t = s := by rw [hf.eq_induced, isOpen_induced_iff]\n\n"}
{"name":"Topology.IsInducing.setOf_isOpen","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\n‚ä¢ Eq (setOf fun s => IsOpen s) (Set.image (Set.preimage f) (setOf fun t => IsOpen t))","decl":"theorem setOf_isOpen (hf : IsInducing f) :\n    {s : Set X | IsOpen s} = preimage f '' {t | IsOpen t} :=\n  Set.ext fun _ ‚Ü¶ hf.isOpen_iff\n\n"}
{"name":"Topology.IsInducing.dense_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace X\nhf : Topology.IsInducing f\ns : Set X\n‚ä¢ Iff (Dense s) (‚àÄ (x : X), Membership.mem (closure (Set.image f s)) (f x))","decl":"theorem dense_iff (hf : IsInducing f) {s : Set X} :\n    Dense s ‚Üî ‚àÄ x, f x ‚àà closure (f '' s) := by\n  simp only [Dense, hf.closure_eq_preimage_closure_image, mem_preimage]\n\n"}
{"name":"Topology.IsInducing.of_subsingleton","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Subsingleton X\nf : X ‚Üí Y\n‚ä¢ Topology.IsInducing f","decl":"theorem of_subsingleton [Subsingleton X] (f : X ‚Üí Y) : IsInducing f :=\n  ‚ü®Subsingleton.elim _ _‚ü©\n\n"}
{"name":"Topology.IsEmbedding.induced","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\nt : TopologicalSpace Y\nhf : Function.Injective f\n‚ä¢ Topology.IsEmbedding f","decl":"lemma induced [t : TopologicalSpace Y] (hf : Injective f) :\n    @IsEmbedding X Y (t.induced f) t f :=\n  @IsEmbedding.mk X Y (t.induced f) t _ (.induced f) hf\n\n"}
{"name":"Function.Injective.isEmbedding_induced","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\nt : TopologicalSpace Y\nhf : Function.Injective f\n‚ä¢ Topology.IsEmbedding f","decl":"alias _root_.Function.Injective.isEmbedding_induced := IsEmbedding.induced\n\n"}
{"name":"Topology.IsEmbedding.Function.Injective.embedding_induced","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\nt : TopologicalSpace Y\nhf : Function.Injective f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Function.Injective.embedding_induced := _root_.Function.Injective.isEmbedding_induced\n\n"}
{"name":"Topology.IsEmbedding.isInducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"lemma isInducing (hf : IsEmbedding f) : IsInducing f := hf.toIsInducing\n\n"}
{"name":"Topology.IsEmbedding.inducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing := isInducing\n\n"}
{"name":"Topology.IsEmbedding.mk'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ninj : Function.Injective f\ninduced : ‚àÄ (x : X), Eq (Filter.comap f (nhds (f x))) (nhds x)\n‚ä¢ Topology.IsEmbedding f","decl":"lemma mk' (f : X ‚Üí Y) (inj : Injective f) (induced : ‚àÄ x, comap f (ùìù (f x)) = ùìù x) :\n    IsEmbedding f :=\n  ‚ü®isInducing_iff_nhds.2 fun x => (induced x).symm, inj‚ü©\n\n"}
{"name":"Topology.IsEmbedding.Embedding.mk'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ninj : Function.Injective f\ninduced : ‚àÄ (x : X), Eq (Filter.comap f (nhds (f x))) (nhds x)\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.mk' := mk'\n\n"}
{"name":"Topology.IsEmbedding.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsEmbedding id","decl":"protected lemma id : IsEmbedding (@id X) := ‚ü®.id, fun _ _ h => h‚ü©\n\n"}
{"name":"Topology.IsEmbedding.embedding_id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsEmbedding id","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_id := IsEmbedding.id\n\n"}
{"name":"Topology.IsEmbedding.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\nhf : Topology.IsEmbedding f\n‚ä¢ Topology.IsEmbedding (Function.comp g f)","decl":"protected lemma comp (hg : IsEmbedding g) (hf : IsEmbedding f) : IsEmbedding (g ‚àò f) :=\n  { hg.isInducing.comp hf.isInducing with injective := fun _ _ h => hf.injective <| hg.injective h }\n\n"}
{"name":"Topology.IsEmbedding.Embedding.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\nhf : Topology.IsEmbedding f\n‚ä¢ Topology.IsEmbedding (Function.comp g f)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.comp := IsEmbedding.comp\n\n"}
{"name":"Topology.IsEmbedding.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\n‚ä¢ Iff (Topology.IsEmbedding (Function.comp g f)) (Topology.IsEmbedding f)","decl":"lemma of_comp_iff (hg : IsEmbedding g) : IsEmbedding (g ‚àò f) ‚Üî IsEmbedding f := by\n  simp_rw [isEmbedding_iff, hg.isInducing.of_comp_iff, hg.injective.of_comp_iff f]\n\n"}
{"name":"Topology.IsEmbedding.Embedding.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\n‚ä¢ Iff (Topology.IsEmbedding (Function.comp g f)) (Topology.IsEmbedding f)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.of_comp_iff := of_comp_iff\n\n"}
{"name":"Topology.IsEmbedding.of_comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsEmbedding (Function.comp g f)\n‚ä¢ Topology.IsEmbedding f","decl":"protected lemma of_comp (hf : Continuous f) (hg : Continuous g) (hgf : IsEmbedding (g ‚àò f)) :\n    IsEmbedding f where\n  toIsInducing := hgf.isInducing.of_comp hf hg\n  injective := hgf.injective.of_comp\n\n"}
{"name":"Topology.IsEmbedding.embedding_of_embedding_compose","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsEmbedding (Function.comp g f)\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_of_embedding_compose := IsEmbedding.of_comp\n\n"}
{"name":"Topology.IsEmbedding.of_leftInverse","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ng : Y ‚Üí X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Topology.IsEmbedding g","decl":"lemma of_leftInverse {f : X ‚Üí Y} {g : Y ‚Üí X} (h : LeftInverse f g) (hf : Continuous f)\n    (hg : Continuous g) : IsEmbedding g := .of_comp hg hf <| h.comp_eq_id.symm ‚ñ∏ .id\n\n"}
{"name":"Function.LeftInverse.isEmbedding","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ng : Y ‚Üí X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Topology.IsEmbedding g","decl":"alias _root_.Function.LeftInverse.isEmbedding := of_leftInverse\n\n"}
{"name":"Function.LeftInverse.embedding","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ng : Y ‚Üí X\nh : Function.LeftInverse f g\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Topology.IsEmbedding g","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Function.LeftInverse.embedding := Function.LeftInverse.isEmbedding\n\n"}
{"name":"Topology.IsEmbedding.map_nhds_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nx : X\n‚ä¢ Eq (Filter.map f (nhds x)) (nhdsWithin (f x) (Set.range f))","decl":"lemma map_nhds_eq (hf : IsEmbedding f) (x : X) :     (ùìù x).map f = ùìù[range f] f x :=\n  hf.1.map_nhds_eq x\n\n"}
{"name":"Topology.IsEmbedding.Embedding.map_nhds_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nx : X\n‚ä¢ Eq (Filter.map f (nhds x)) (nhdsWithin (f x) (Set.range f))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.map_nhds_eq := map_nhds_eq\n\n"}
{"name":"Topology.IsEmbedding.map_nhds_of_mem","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nx : X\nh : Membership.mem (nhds (f x)) (Set.range f)\n‚ä¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"lemma map_nhds_of_mem (hf : IsEmbedding f) (x : X) (h : range f ‚àà ùìù (f x)) :\n    (ùìù x).map f = ùìù (f x) :=\n  hf.1.map_nhds_of_mem x h\n\n"}
{"name":"Topology.IsEmbedding.Embedding.map_nhds_of_mem","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nx : X\nh : Membership.mem (nhds (f x)) (Set.range f)\n‚ä¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.map_nhds_of_mem := map_nhds_of_mem\n\n"}
{"name":"Topology.IsEmbedding.tendsto_nhds_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"Y : Type u_2\nZ : Type u_3\nŒπ : Type u_4\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : Œπ ‚Üí Y\nl : Filter Œπ\ny : Y\nhg : Topology.IsEmbedding g\n‚ä¢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (Function.comp g f) l (nhds (g y)))","decl":"lemma tendsto_nhds_iff {f : Œπ ‚Üí Y} {l : Filter Œπ} {y : Y} (hg : IsEmbedding g) :\n    Tendsto f l (ùìù y) ‚Üî Tendsto (g ‚àò f) l (ùìù (g y)) := hg.isInducing.tendsto_nhds_iff\n\n"}
{"name":"Topology.IsEmbedding.continuous_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\n‚ä¢ Iff (Continuous f) (Continuous (Function.comp g f))","decl":"lemma continuous_iff (hg : IsEmbedding g) : Continuous f ‚Üî Continuous (g ‚àò f) :=\n  hg.isInducing.continuous_iff\n\n"}
{"name":"Topology.IsEmbedding.Embedding.continuous_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsEmbedding g\n‚ä¢ Iff (Continuous f) (Continuous (Function.comp g f))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.continuous_iff := continuous_iff\n\n"}
{"name":"Topology.IsEmbedding.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\n‚ä¢ Continuous f","decl":"lemma continuous (hf : IsEmbedding f) : Continuous f := hf.isInducing.continuous\n\n"}
{"name":"Topology.IsEmbedding.closure_eq_preimage_closure_image","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\ns : Set X\n‚ä¢ Eq (closure s) (Set.preimage f (closure (Set.image f s)))","decl":"lemma closure_eq_preimage_closure_image (hf : IsEmbedding f) (s : Set X) :\n    closure s = f ‚Åª¬π' closure (f '' s) :=\n  hf.1.closure_eq_preimage_closure_image s\n\n"}
{"name":"Topology.IsEmbedding.Embedding.closure_eq_preimage_closure_image","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\ns : Set X\n‚ä¢ Eq (closure s) (Set.preimage f (closure (Set.image f s)))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.closure_eq_preimage_closure_image := closure_eq_preimage_closure_image\n\n"}
{"name":"Topology.IsEmbedding.discreteTopology","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : DiscreteTopology Y\nhf : Topology.IsEmbedding f\n‚ä¢ DiscreteTopology X","decl":"/-- The topology induced under an inclusion `f : X ‚Üí Y` from a discrete topological space `Y`\nis the discrete topology on `X`.\n\nSee also `DiscreteTopology.of_continuous_injective`. -/\nlemma discreteTopology [DiscreteTopology Y] (hf : IsEmbedding f) : DiscreteTopology X :=\n  .of_continuous_injective hf.continuous hf.injective\n\n"}
{"name":"Topology.IsEmbedding.Embedding.discreteTopology","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : DiscreteTopology Y\nhf : Topology.IsEmbedding f\n‚ä¢ DiscreteTopology X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.discreteTopology := discreteTopology\n\n"}
{"name":"Topology.IsEmbedding.of_subsingleton","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : Subsingleton X\nf : X ‚Üí Y\n‚ä¢ Topology.IsEmbedding f","decl":"lemma of_subsingleton [Subsingleton X] (f : X ‚Üí Y) : IsEmbedding f :=\n  ‚ü®.of_subsingleton f, f.injective_of_subsingleton‚ü©\n\n"}
{"name":"Topology.IsEmbedding.Embedding.of_subsingleton","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : Subsingleton X\nf : X ‚Üí Y\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.of_subsingleton := of_subsingleton\n\n"}
{"name":"Topology.isQuotientMap_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsQuotientMap f) (And (Function.Surjective f) (‚àÄ (s : Set Y), Iff (IsOpen s) (IsOpen (Set.preimage f s))))","decl":"lemma isQuotientMap_iff : IsQuotientMap f ‚Üî Surjective f ‚àß ‚àÄ s, IsOpen s ‚Üî IsOpen (f ‚Åª¬π' s) :=\n  (isQuotientMap_iff' _).trans <| and_congr Iff.rfl TopologicalSpace.ext_iff\n\n"}
{"name":"Topology.quotientMap_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsQuotientMap f) (And (Function.Surjective f) (‚àÄ (s : Set Y), Iff (IsOpen s) (IsOpen (Set.preimage f s))))","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_iff := isQuotientMap_iff\n\n"}
{"name":"Topology.isQuotientMap_iff_isClosed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsQuotientMap f) (And (Function.Surjective f) (‚àÄ (s : Set Y), Iff (IsClosed s) (IsClosed (Set.preimage f s))))","decl":"theorem isQuotientMap_iff_isClosed :\n    IsQuotientMap f ‚Üî Surjective f ‚àß ‚àÄ s : Set Y, IsClosed s ‚Üî IsClosed (f ‚Åª¬π' s) :=\n  isQuotientMap_iff.trans <| Iff.rfl.and <| compl_surjective.forall.trans <| by\n    simp only [isOpen_compl_iff, preimage_compl]\n\n"}
{"name":"Topology.quotientMap_iff_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsQuotientMap f) (And (Function.Surjective f) (‚àÄ (s : Set Y), Iff (IsClosed s) (IsClosed (Set.preimage f s))))","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_iff_closed := isQuotientMap_iff_isClosed\n"}
{"name":"Topology.isQuotientMap_iff_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsQuotientMap f) (And (Function.Surjective f) (‚àÄ (s : Set Y), Iff (IsClosed s) (IsClosed (Set.preimage f s))))","decl":"@[deprecated (since := \"2024-11-19\")]\nalias isQuotientMap_iff_closed := isQuotientMap_iff_isClosed\n\n"}
{"name":"Topology.IsQuotientMap.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsQuotientMap id","decl":"protected theorem id : IsQuotientMap (@id X) :=\n  ‚ü®fun x => ‚ü®x, rfl‚ü©, coinduced_id.symm‚ü©\n\n"}
{"name":"Topology.IsQuotientMap.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsQuotientMap g\nhf : Topology.IsQuotientMap f\n‚ä¢ Topology.IsQuotientMap (Function.comp g f)","decl":"protected theorem comp (hg : IsQuotientMap g) (hf : IsQuotientMap f) : IsQuotientMap (g ‚àò f) :=\n  ‚ü®hg.surjective.comp hf.surjective, by rw [hg.eq_coinduced, hf.eq_coinduced, coinduced_compose]‚ü©\n\n"}
{"name":"Topology.IsQuotientMap.of_comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsQuotientMap (Function.comp g f)\n‚ä¢ Topology.IsQuotientMap g","decl":"protected theorem of_comp (hf : Continuous f) (hg : Continuous g)\n    (hgf : IsQuotientMap (g ‚àò f)) : IsQuotientMap g :=\n  ‚ü®hgf.1.of_comp,\n    le_antisymm\n      (by rw [hgf.eq_coinduced, ‚Üê coinduced_compose]; exact coinduced_mono hf.coinduced_le)\n      hg.coinduced_le‚ü©\n\n"}
{"name":"Topology.IsQuotientMap.of_quotientMap_compose","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Continuous f\nhg : Continuous g\nhgf : Topology.IsQuotientMap (Function.comp g f)\n‚ä¢ Topology.IsQuotientMap g","decl":"@[deprecated (since := \"2024-10-22\")]\nalias of_quotientMap_compose := IsQuotientMap.of_comp\n\n"}
{"name":"Topology.IsQuotientMap.of_inverse","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ng : Y ‚Üí X\nhf : Continuous f\nhg : Continuous g\nh : Function.LeftInverse g f\n‚ä¢ Topology.IsQuotientMap g","decl":"theorem of_inverse {g : Y ‚Üí X} (hf : Continuous f) (hg : Continuous g) (h : LeftInverse g f) :\n    IsQuotientMap g := .of_comp hf hg <| h.comp_eq_id.symm ‚ñ∏ IsQuotientMap.id\n\n"}
{"name":"Topology.IsQuotientMap.continuous_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Topology.IsQuotientMap f\n‚ä¢ Iff (Continuous g) (Continuous (Function.comp g f))","decl":"protected theorem continuous_iff (hf : IsQuotientMap f) : Continuous g ‚Üî Continuous (g ‚àò f) := by\n  rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.eq_coinduced, coinduced_compose]\n\n"}
{"name":"Topology.IsQuotientMap.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsQuotientMap f\n‚ä¢ Continuous f","decl":"protected theorem continuous (hf : IsQuotientMap f) : Continuous f :=\n  hf.continuous_iff.mp continuous_id\n\n"}
{"name":"Topology.IsQuotientMap.isOpen_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsQuotientMap f\ns : Set Y\n‚ä¢ Iff (IsOpen (Set.preimage f s)) (IsOpen s)","decl":"protected lemma isOpen_preimage (hf : IsQuotientMap f) {s : Set Y} : IsOpen (f ‚Åª¬π' s) ‚Üî IsOpen s :=\n  ((isQuotientMap_iff.1 hf).2 s).symm\n\n"}
{"name":"Topology.IsQuotientMap.isClosed_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsQuotientMap f\ns : Set Y\n‚ä¢ Iff (IsClosed (Set.preimage f s)) (IsClosed s)","decl":"protected theorem isClosed_preimage (hf : IsQuotientMap f) {s : Set Y} :\n    IsClosed (f ‚Åª¬π' s) ‚Üî IsClosed s :=\n  ((isQuotientMap_iff_isClosed.1 hf).2 s).symm\n\n"}
{"name":"IsOpenMap.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsOpenMap id","decl":"protected theorem id : IsOpenMap (@id X) := fun s hs => by rwa [image_id]\n\n"}
{"name":"IsOpenMap.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : IsOpenMap g\nhf : IsOpenMap f\n‚ä¢ IsOpenMap (Function.comp g f)","decl":"protected theorem comp (hg : IsOpenMap g) (hf : IsOpenMap f) :\n    IsOpenMap (g ‚àò f) := fun s hs => by rw [image_comp]; exact hg _ (hf _ hs)\n\n"}
{"name":"IsOpenMap.isOpen_range","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\n‚ä¢ IsOpen (Set.range f)","decl":"theorem isOpen_range (hf : IsOpenMap f) : IsOpen (range f) := by\n  rw [‚Üê image_univ]\n  exact hf _ isOpen_univ\n\n"}
{"name":"IsOpenMap.image_mem_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\nx : X\ns : Set X\nhx : Membership.mem (nhds x) s\n‚ä¢ Membership.mem (nhds (f x)) (Set.image f s)","decl":"theorem image_mem_nhds (hf : IsOpenMap f) {x : X} {s : Set X} (hx : s ‚àà ùìù x) : f '' s ‚àà ùìù (f x) :=\n  let ‚ü®t, hts, ht, hxt‚ü© := mem_nhds_iff.1 hx\n  mem_of_superset (IsOpen.mem_nhds (hf t ht) (mem_image_of_mem _ hxt)) (image_subset _ hts)\n\n"}
{"name":"IsOpenMap.range_mem_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\nx : X\n‚ä¢ Membership.mem (nhds (f x)) (Set.range f)","decl":"theorem range_mem_nhds (hf : IsOpenMap f) (x : X) : range f ‚àà ùìù (f x) :=\n  hf.isOpen_range.mem_nhds <| mem_range_self _\n\n"}
{"name":"IsOpenMap.mapsTo_interior","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set X\nt : Set Y\nh : Set.MapsTo f s t\n‚ä¢ Set.MapsTo f (interior s) (interior t)","decl":"theorem mapsTo_interior (hf : IsOpenMap f) {s : Set X} {t : Set Y} (h : MapsTo f s t) :\n    MapsTo f (interior s) (interior t) :=\n  mapsTo'.2 <|\n    interior_maximal (h.mono interior_subset Subset.rfl).image_subset (hf _ isOpen_interior)\n\n"}
{"name":"IsOpenMap.image_interior_subset","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set X\n‚ä¢ HasSubset.Subset (Set.image f (interior s)) (interior (Set.image f s))","decl":"theorem image_interior_subset (hf : IsOpenMap f) (s : Set X) :\n    f '' interior s ‚äÜ interior (f '' s) :=\n  (hf.mapsTo_interior (mapsTo_image f s)).image_subset\n\n"}
{"name":"IsOpenMap.nhds_le","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\nx : X\n‚ä¢ LE.le (nhds (f x)) (Filter.map f (nhds x))","decl":"theorem nhds_le (hf : IsOpenMap f) (x : X) : ùìù (f x) ‚â§ (ùìù x).map f :=\n  le_map fun _ => hf.image_mem_nhds\n\n"}
{"name":"IsOpenMap.of_nhds_le","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : ‚àÄ (x : X), LE.le (nhds (f x)) (Filter.map f (nhds x))\n‚ä¢ IsOpenMap f","decl":"theorem of_nhds_le (hf : ‚àÄ x, ùìù (f x) ‚â§ map f (ùìù x)) : IsOpenMap f := fun _s hs =>\n  isOpen_iff_mem_nhds.2 fun _y ‚ü®_x, hxs, hxy‚ü© => hxy ‚ñ∏ hf _ (image_mem_map <| hs.mem_nhds hxs)\n\n"}
{"name":"IsOpenMap.of_sections","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : ‚àÄ (x : X), Exists fun g => And (ContinuousAt g (f x)) (And (Eq (g (f x)) x) (Function.RightInverse g f))\n‚ä¢ IsOpenMap f","decl":"theorem of_sections\n    (h : ‚àÄ x, ‚àÉ g : Y ‚Üí X, ContinuousAt g (f x) ‚àß g (f x) = x ‚àß RightInverse g f) : IsOpenMap f :=\n  of_nhds_le fun x =>\n    let ‚ü®g, hgc, hgx, hgf‚ü© := h x\n    calc\n      ùìù (f x) = map f (map g (ùìù (f x))) := by rw [map_map, hgf.comp_eq_id, map_id]\n      _ ‚â§ map f (ùìù (g (f x))) := map_mono hgc\n      _ = map f (ùìù x) := by rw [hgx]\n\n"}
{"name":"IsOpenMap.of_inverse","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf' : Y ‚Üí X\nh : Continuous f'\nl_inv : Function.LeftInverse f f'\nr_inv : Function.RightInverse f f'\n‚ä¢ IsOpenMap f","decl":"theorem of_inverse {f' : Y ‚Üí X} (h : Continuous f') (l_inv : LeftInverse f f')\n    (r_inv : RightInverse f f') : IsOpenMap f :=\n  of_sections fun _ => ‚ü®f', h.continuousAt, r_inv _, l_inv‚ü©\n\n"}
{"name":"IsOpenMap.isQuotientMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nopen_map : IsOpenMap f\ncont : Continuous f\nsurj : Function.Surjective f\n‚ä¢ Topology.IsQuotientMap f","decl":"/-- A continuous surjective open map is a quotient map. -/\ntheorem isQuotientMap (open_map : IsOpenMap f) (cont : Continuous f) (surj : Surjective f) :\n    IsQuotientMap f :=\n  isQuotientMap_iff.2\n    ‚ü®surj, fun s => ‚ü®fun h => h.preimage cont, fun h => surj.image_preimage s ‚ñ∏ open_map _ h‚ü©‚ü©\n\n"}
{"name":"IsOpenMap.to_quotientMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nopen_map : IsOpenMap f\ncont : Continuous f\nsurj : Function.Surjective f\n‚ä¢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias to_quotientMap := isQuotientMap\n\n"}
{"name":"IsOpenMap.interior_preimage_subset_preimage_interior","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set Y\n‚ä¢ HasSubset.Subset (interior (Set.preimage f s)) (Set.preimage f (interior s))","decl":"theorem interior_preimage_subset_preimage_interior (hf : IsOpenMap f) {s : Set Y} :\n    interior (f ‚Åª¬π' s) ‚äÜ f ‚Åª¬π' interior s :=\n  hf.mapsTo_interior (mapsTo_preimage _ _)\n\n"}
{"name":"IsOpenMap.preimage_interior_eq_interior_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf‚ÇÅ : IsOpenMap f\nhf‚ÇÇ : Continuous f\ns : Set Y\n‚ä¢ Eq (Set.preimage f (interior s)) (interior (Set.preimage f s))","decl":"theorem preimage_interior_eq_interior_preimage (hf‚ÇÅ : IsOpenMap f) (hf‚ÇÇ : Continuous f)\n    (s : Set Y) : f ‚Åª¬π' interior s = interior (f ‚Åª¬π' s) :=\n  Subset.antisymm (preimage_interior_subset_interior_preimage hf‚ÇÇ)\n    (interior_preimage_subset_preimage_interior hf‚ÇÅ)\n\n"}
{"name":"IsOpenMap.preimage_closure_subset_closure_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set Y\n‚ä¢ HasSubset.Subset (Set.preimage f (closure s)) (closure (Set.preimage f s))","decl":"theorem preimage_closure_subset_closure_preimage (hf : IsOpenMap f) {s : Set Y} :\n    f ‚Åª¬π' closure s ‚äÜ closure (f ‚Åª¬π' s) := by\n  rw [‚Üê compl_subset_compl]\n  simp only [‚Üê interior_compl, ‚Üê preimage_compl, hf.interior_preimage_subset_preimage_interior]\n\n"}
{"name":"IsOpenMap.preimage_closure_eq_closure_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\nhfc : Continuous f\ns : Set Y\n‚ä¢ Eq (Set.preimage f (closure s)) (closure (Set.preimage f s))","decl":"theorem preimage_closure_eq_closure_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set Y) :\n    f ‚Åª¬π' closure s = closure (f ‚Åª¬π' s) :=\n  hf.preimage_closure_subset_closure_preimage.antisymm (hfc.closure_preimage_subset s)\n\n"}
{"name":"IsOpenMap.preimage_frontier_subset_frontier_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\ns : Set Y\n‚ä¢ HasSubset.Subset (Set.preimage f (frontier s)) (frontier (Set.preimage f s))","decl":"theorem preimage_frontier_subset_frontier_preimage (hf : IsOpenMap f) {s : Set Y} :\n    f ‚Åª¬π' frontier s ‚äÜ frontier (f ‚Åª¬π' s) := by\n  simpa only [frontier_eq_closure_inter_closure, preimage_inter] using\n    inter_subset_inter hf.preimage_closure_subset_closure_preimage\n      hf.preimage_closure_subset_closure_preimage\n\n"}
{"name":"IsOpenMap.preimage_frontier_eq_frontier_preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsOpenMap f\nhfc : Continuous f\ns : Set Y\n‚ä¢ Eq (Set.preimage f (frontier s)) (frontier (Set.preimage f s))","decl":"theorem preimage_frontier_eq_frontier_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set Y) :\n    f ‚Åª¬π' frontier s = frontier (f ‚Åª¬π' s) := by\n  simp only [frontier_eq_closure_inter_closure, preimage_inter, preimage_compl,\n    hf.preimage_closure_eq_closure_preimage hfc]\n\n"}
{"name":"IsOpenMap.of_isEmpty","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : IsEmpty X\nf : X ‚Üí Y\n‚ä¢ IsOpenMap f","decl":"theorem of_isEmpty [h : IsEmpty X] (f : X ‚Üí Y) : IsOpenMap f := of_nhds_le h.elim\n\n"}
{"name":"isOpenMap_iff_nhds_le","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (IsOpenMap f) (‚àÄ (x : X), LE.le (nhds (f x)) (Filter.map f (nhds x)))","decl":"theorem isOpenMap_iff_nhds_le : IsOpenMap f ‚Üî ‚àÄ x : X, ùìù (f x) ‚â§ (ùìù x).map f :=\n  ‚ü®fun hf => hf.nhds_le, IsOpenMap.of_nhds_le‚ü©\n\n"}
{"name":"isOpenMap_iff_interior","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (IsOpenMap f) (‚àÄ (s : Set X), HasSubset.Subset (Set.image f (interior s)) (interior (Set.image f s)))","decl":"theorem isOpenMap_iff_interior : IsOpenMap f ‚Üî ‚àÄ s, f '' interior s ‚äÜ interior (f '' s) :=\n  ‚ü®IsOpenMap.image_interior_subset, fun hs u hu =>\n    subset_interior_iff_isOpen.mp <|\n      calc\n        f '' u = f '' interior u := by rw [hu.interior_eq]\n        _ ‚äÜ interior (f '' u) := hs u‚ü©\n\n"}
{"name":"Topology.IsInducing.isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhi : Topology.IsInducing f\nho : IsOpen (Set.range f)\n‚ä¢ IsOpenMap f","decl":"/-- An inducing map with an open range is an open map. -/\nprotected lemma Topology.IsInducing.isOpenMap (hi : IsInducing f) (ho : IsOpen (range f)) :\n    IsOpenMap f :=\n  IsOpenMap.of_nhds_le fun _ => (hi.map_nhds_of_mem _ <| IsOpen.mem_nhds ho <| mem_range_self _).ge\n\n"}
{"name":"Inducing.isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhi : Topology.IsInducing f\nho : IsOpen (Set.range f)\n‚ä¢ IsOpenMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isOpenMap := IsInducing.isOpenMap\n\n"}
{"name":"Dense.preimage","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nhs : Dense s\nhf : IsOpenMap f\n‚ä¢ Dense (Set.preimage f s)","decl":"/-- Preimage of a dense set under an open map is dense. -/\nprotected theorem Dense.preimage {s : Set Y} (hs : Dense s) (hf : IsOpenMap f) :\n    Dense (f ‚Åª¬π' s) := fun x ‚Ü¶\n  hf.preimage_closure_subset_closure_preimage <| hs (f x)\n\n"}
{"name":"IsClosedMap.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsClosedMap id","decl":"protected theorem id : IsClosedMap (@id X) := fun s hs => by rwa [image_id]\n\n"}
{"name":"IsClosedMap.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : IsClosedMap g\nhf : IsClosedMap f\n‚ä¢ IsClosedMap (Function.comp g f)","decl":"protected theorem comp (hg : IsClosedMap g) (hf : IsClosedMap f) : IsClosedMap (g ‚àò f) := by\n  intro s hs\n  rw [image_comp]\n  exact hg _ (hf _ hs)\n\n"}
{"name":"IsClosedMap.of_comp_surjective","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Function.Surjective f\nhf' : Continuous f\nhfg : IsClosedMap (Function.comp g f)\n‚ä¢ IsClosedMap g","decl":"protected theorem of_comp_surjective (hf : Surjective f) (hf' : Continuous f)\n    (hfg : IsClosedMap (g ‚àò f)) : IsClosedMap g := by\n  intro K hK\n  rw [‚Üê image_preimage_eq K hf, ‚Üê image_comp]\n  exact hfg _ (hK.preimage hf')\n\n"}
{"name":"IsClosedMap.closure_image_subset","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsClosedMap f\ns : Set X\n‚ä¢ HasSubset.Subset (closure (Set.image f s)) (Set.image f (closure s))","decl":"theorem closure_image_subset (hf : IsClosedMap f) (s : Set X) :\n    closure (f '' s) ‚äÜ f '' closure s :=\n  closure_minimal (image_subset _ subset_closure) (hf _ isClosed_closure)\n\n"}
{"name":"IsClosedMap.of_inverse","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf' : Y ‚Üí X\nh : Continuous f'\nl_inv : Function.LeftInverse f f'\nr_inv : Function.RightInverse f f'\n‚ä¢ IsClosedMap f","decl":"theorem of_inverse {f' : Y ‚Üí X} (h : Continuous f') (l_inv : LeftInverse f f')\n    (r_inv : RightInverse f f') : IsClosedMap f := fun s hs => by\n  rw [image_eq_preimage_of_inverse r_inv l_inv]\n  exact hs.preimage h\n\n"}
{"name":"IsClosedMap.of_nonempty","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : ‚àÄ (s : Set X), IsClosed s ‚Üí s.Nonempty ‚Üí IsClosed (Set.image f s)\n‚ä¢ IsClosedMap f","decl":"theorem of_nonempty (h : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí IsClosed (f '' s)) :\n    IsClosedMap f := by\n  intro s hs; rcases eq_empty_or_nonempty s with h2s | h2s\n  ¬∑ simp_rw [h2s, image_empty, isClosed_empty]\n  ¬∑ exact h s hs h2s\n\n"}
{"name":"IsClosedMap.isClosed_range","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : IsClosedMap f\n‚ä¢ IsClosed (Set.range f)","decl":"theorem isClosed_range (hf : IsClosedMap f) : IsClosed (range f) :=\n  @image_univ _ _ f ‚ñ∏ hf _ isClosed_univ\n\n\n"}
{"name":"IsClosedMap.isQuotientMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhcl : IsClosedMap f\nhcont : Continuous f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsQuotientMap f","decl":"theorem isQuotientMap (hcl : IsClosedMap f) (hcont : Continuous f)\n    (hsurj : Surjective f) : IsQuotientMap f :=\n  isQuotientMap_iff_isClosed.2 ‚ü®hsurj, fun s =>\n    ‚ü®fun hs => hs.preimage hcont, fun hs => hsurj.image_preimage s ‚ñ∏ hcl _ hs‚ü©‚ü©\n\n"}
{"name":"IsClosedMap.to_quotientMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhcl : IsClosedMap f\nhcont : Continuous f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias to_quotientMap := isQuotientMap\n\n"}
{"name":"Topology.IsInducing.isClosedMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsInducing f\nh : IsClosed (Set.range f)\n‚ä¢ IsClosedMap f","decl":"lemma Topology.IsInducing.isClosedMap (hf : IsInducing f) (h : IsClosed (range f)) :\n    IsClosedMap f := by\n  intro s hs\n  rcases hf.isClosed_iff.1 hs with ‚ü®t, ht, rfl‚ü©\n  rw [image_preimage_eq_inter_range]\n  exact ht.inter h\n\n"}
{"name":"Inducing.isClosedMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsInducing f\nh : IsClosed (Set.range f)\n‚ä¢ IsClosedMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isClosedMap := IsInducing.isClosedMap\n\n"}
{"name":"isClosedMap_iff_closure_image","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (IsClosedMap f) (‚àÄ (s : Set X), HasSubset.Subset (closure (Set.image f s)) (Set.image f (closure s)))","decl":"theorem isClosedMap_iff_closure_image :\n    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=\n  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>\n    isClosed_of_closure_subset <|\n      calc\n        closure (f '' c) ‚äÜ f '' closure c := hs c\n        _ = f '' c := by rw [hc.closure_eq]‚ü©\n\n"}
{"name":"isClosedMap_iff_clusterPt","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (IsClosedMap f) (‚àÄ (s : Set X) (y : Y), MapClusterPt y (Filter.principal s) f ‚Üí Exists fun x => And (Eq (f x) y) (ClusterPt x (Filter.principal s)))","decl":"/-- A map `f : X ‚Üí Y` is closed if and only if for all sets `s`, any cluster point of `f '' s` is\nthe image by `f` of some cluster point of `s`.\nIf you require this for all filters instead of just principal filters, and also that `f` is\ncontinuous, you get the notion of **proper map**. See `isProperMap_iff_clusterPt`. -/\ntheorem isClosedMap_iff_clusterPt :\n    IsClosedMap f ‚Üî ‚àÄ s y, MapClusterPt y (ùìü s) f ‚Üí ‚àÉ x, f x = y ‚àß ClusterPt x (ùìü s) := by\n  simp [MapClusterPt, isClosedMap_iff_closure_image, subset_def, mem_closure_iff_clusterPt,\n    and_comm]\n\n"}
{"name":"IsClosedMap.closure_image_eq_of_continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf_closed : IsClosedMap f\nf_cont : Continuous f\ns : Set X\n‚ä¢ Eq (closure (Set.image f s)) (Set.image f (closure s))","decl":"theorem IsClosedMap.closure_image_eq_of_continuous\n    (f_closed : IsClosedMap f) (f_cont : Continuous f) (s : Set X) :\n    closure (f '' s) = f '' closure s :=\n  subset_antisymm (f_closed.closure_image_subset s) (image_closure_subset_closure_image f_cont)\n\n"}
{"name":"IsClosedMap.lift'_closure_map_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n‚ä¢ Eq ((Filter.map f F).lift' closure) (Filter.map f (F.lift' closure))","decl":"theorem IsClosedMap.lift'_closure_map_eq\n    (f_closed : IsClosedMap f) (f_cont : Continuous f) (F : Filter X) :\n    (map f F).lift' closure = map f (F.lift' closure) := by\n  rw [map_lift'_eq2 (monotone_closure Y), map_lift'_eq (monotone_closure X)]\n  congr\n  ext s : 1\n  exact f_closed.closure_image_eq_of_continuous f_cont s\n\n"}
{"name":"IsClosedMap.mapClusterPt_iff_lift'_closure","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nF : Filter X\nf_closed : IsClosedMap f\nf_cont : Continuous f\ny : Y\n‚ä¢ Iff (MapClusterPt y F f) (Min.min (F.lift' closure) (Filter.principal (Set.preimage f (Singleton.singleton y)))).NeBot","decl":"theorem IsClosedMap.mapClusterPt_iff_lift'_closure\n    {F : Filter X} (f_closed : IsClosedMap f) (f_cont : Continuous f) {y : Y} :\n    MapClusterPt y F f ‚Üî ((F.lift' closure) ‚äì ùìü (f ‚Åª¬π' {y})).NeBot := by\n  rw [MapClusterPt, clusterPt_iff_lift'_closure', f_closed.lift'_closure_map_eq f_cont,\n      ‚Üê comap_principal, ‚Üê map_neBot_iff f, Filter.push_pull, principal_singleton]\n\n"}
{"name":"Topology.IsOpenEmbedding.isEmbedding","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Topology.IsEmbedding f","decl":"lemma IsOpenEmbedding.isEmbedding (hf : IsOpenEmbedding f) : IsEmbedding f := hf.toIsEmbedding\n"}
{"name":"Topology.IsOpenEmbedding.isInducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"lemma IsOpenEmbedding.isInducing (hf : IsOpenEmbedding f) : IsInducing f :=\n  hf.isEmbedding.isInducing\n\n"}
{"name":"Topology.IsOpenEmbedding.inducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias IsOpenEmbedding.inducing := IsOpenEmbedding.isInducing\n\n"}
{"name":"Topology.IsOpenEmbedding.isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ IsOpenMap f","decl":"lemma IsOpenEmbedding.isOpenMap (hf : IsOpenEmbedding f) : IsOpenMap f :=\n  hf.isEmbedding.isInducing.isOpenMap hf.isOpen_range\n\n"}
{"name":"Topology.OpenEmbedding.isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ IsOpenMap f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.isOpenMap := IsOpenEmbedding.isOpenMap\n\n"}
{"name":"Topology.IsOpenEmbedding.map_nhds_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\nx : X\n‚ä¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"theorem IsOpenEmbedding.map_nhds_eq (hf : IsOpenEmbedding f) (x : X) :\n    map f (ùìù x) = ùìù (f x) :=\n  hf.isEmbedding.map_nhds_of_mem _ <| hf.isOpen_range.mem_nhds <| mem_range_self _\n\n"}
{"name":"Topology.OpenEmbedding.map_nhds_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\nx : X\n‚ä¢ Eq (Filter.map f (nhds x)) (nhds (f x))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.map_nhds_eq := IsOpenEmbedding.map_nhds_eq\n\n"}
{"name":"Topology.IsOpenEmbedding.isOpen_iff_image_isOpen","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set X\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.image f s))","decl":"lemma IsOpenEmbedding.isOpen_iff_image_isOpen (hf : IsOpenEmbedding f) {s : Set X} :\n    IsOpen s ‚Üî IsOpen (f '' s) where\n  mp := hf.isOpenMap s\n  mpr h := by convert ‚Üê h.preimage hf.isEmbedding.continuous; apply preimage_image_eq _ hf.injective\n\n"}
{"name":"Topology.IsOpenEmbedding.open_iff_image_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set X\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.image f s))","decl":"@[deprecated (since := \"2024-10-30\")]\nalias IsOpenEmbedding.open_iff_image_open := IsOpenEmbedding.isOpen_iff_image_isOpen\n\n"}
{"name":"Topology.OpenEmbedding.open_iff_image_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set X\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.image f s))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.open_iff_image_open := IsOpenEmbedding.isOpen_iff_image_isOpen\n\n"}
{"name":"Topology.IsOpenEmbedding.tendsto_nhds_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"Y : Type u_2\nZ : Type u_3\nŒπ : Type u_4\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : Œπ ‚Üí Y\nl : Filter Œπ\ny : Y\nhg : Topology.IsOpenEmbedding g\n‚ä¢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (Function.comp g f) l (nhds (g y)))","decl":"theorem IsOpenEmbedding.tendsto_nhds_iff [TopologicalSpace Z] {f : Œπ ‚Üí Y} {l : Filter Œπ} {y : Y}\n    (hg : IsOpenEmbedding g) : Tendsto f l (ùìù y) ‚Üî Tendsto (g ‚àò f) l (ùìù (g y)) :=\n  hg.isEmbedding.tendsto_nhds_iff\n\n"}
{"name":"Topology.OpenEmbedding.tendsto_nhds_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"Y : Type u_2\nZ : Type u_3\nŒπ : Type u_4\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : Œπ ‚Üí Y\nl : Filter Œπ\ny : Y\nhg : Topology.IsOpenEmbedding g\n‚ä¢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (Function.comp g f) l (nhds (g y)))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.tendsto_nhds_iff := IsOpenEmbedding.tendsto_nhds_iff\n\n"}
{"name":"Topology.IsOpenEmbedding.tendsto_nhds_iff'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\nl : Filter Z\nx : X\n‚ä¢ Iff (Filter.Tendsto (Function.comp g f) (nhds x) l) (Filter.Tendsto g (nhds (f x)) l)","decl":"theorem IsOpenEmbedding.tendsto_nhds_iff' (hf : IsOpenEmbedding f) {l : Filter Z} {x : X} :\n    Tendsto (g ‚àò f) (ùìù x) l ‚Üî Tendsto g (ùìù (f x)) l := by\n  rw [Tendsto, ‚Üê map_map, hf.map_nhds_eq]; rfl\n\n"}
{"name":"Topology.OpenEmbedding.tendsto_nhds_iff'","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\nl : Filter Z\nx : X\n‚ä¢ Iff (Filter.Tendsto (Function.comp g f) (nhds x) l) (Filter.Tendsto g (nhds (f x)) l)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.tendsto_nhds_iff' := IsOpenEmbedding.tendsto_nhds_iff'\n\n"}
{"name":"Topology.IsOpenEmbedding.continuousAt_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Topology.IsOpenEmbedding f\nx : X\n‚ä¢ Iff (ContinuousAt (Function.comp g f) x) (ContinuousAt g (f x))","decl":"theorem IsOpenEmbedding.continuousAt_iff [TopologicalSpace Z] (hf : IsOpenEmbedding f) {x : X} :\n    ContinuousAt (g ‚àò f) x ‚Üî ContinuousAt g (f x) :=\n  hf.tendsto_nhds_iff'\n\n"}
{"name":"Topology.OpenEmbedding.continuousAt_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhf : Topology.IsOpenEmbedding f\nx : X\n‚ä¢ Iff (ContinuousAt (Function.comp g f) x) (ContinuousAt g (f x))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.continuousAt_iff := IsOpenEmbedding.continuousAt_iff\n\n"}
{"name":"Topology.IsOpenEmbedding.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Continuous f","decl":"theorem IsOpenEmbedding.continuous (hf : IsOpenEmbedding f) : Continuous f :=\n  hf.isEmbedding.continuous\n\n"}
{"name":"Topology.OpenEmbedding.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Continuous f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.continuous := IsOpenEmbedding.continuous\n\n"}
{"name":"Topology.IsOpenEmbedding.isOpen_iff_preimage_isOpen","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set Y\nhs : HasSubset.Subset s (Set.range f)\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.preimage f s))","decl":"lemma IsOpenEmbedding.isOpen_iff_preimage_isOpen (hf : IsOpenEmbedding f) {s : Set Y}\n    (hs : s ‚äÜ range f) : IsOpen s ‚Üî IsOpen (f ‚Åª¬π' s) := by\n  rw [hf.isOpen_iff_image_isOpen, image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]\n\n"}
{"name":"Topology.IsOpenEmbedding.open_iff_preimage_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set Y\nhs : HasSubset.Subset s (Set.range f)\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.preimage f s))","decl":"@[deprecated (since := \"2024-10-30\")]\nalias IsOpenEmbedding.open_iff_preimage_open := IsOpenEmbedding.isOpen_iff_preimage_isOpen\n\n"}
{"name":"Topology.OpenEmbedding.open_iff_preimage_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsOpenEmbedding f\ns : Set Y\nhs : HasSubset.Subset s (Set.range f)\n‚ä¢ Iff (IsOpen s) (IsOpen (Set.preimage f s))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.open_iff_preimage_open := IsOpenEmbedding.isOpen_iff_preimage_isOpen\n\n"}
{"name":"Topology.IsOpenEmbedding.of_isEmbedding_isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsOpenMap f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"lemma IsOpenEmbedding.of_isEmbedding_isOpenMap (h‚ÇÅ : IsEmbedding f) (h‚ÇÇ : IsOpenMap f) :\n    IsOpenEmbedding f :=\n  ‚ü®h‚ÇÅ, h‚ÇÇ.isOpen_range‚ü©\n\n"}
{"name":"Topology.isOpenEmbedding_of_embedding_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsOpenMap f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias isOpenEmbedding_of_embedding_open := IsOpenEmbedding.of_isEmbedding_isOpenMap\n\n"}
{"name":"Topology.openEmbedding_of_embedding_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsOpenMap f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_of_embedding_open := IsOpenEmbedding.of_isEmbedding_isOpenMap\n\n"}
{"name":"Topology.IsEmbedding.isOpenEmbedding_of_surjective","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"/-- A surjective embedding is an `IsOpenEmbedding`. -/\nlemma IsEmbedding.isOpenEmbedding_of_surjective (hf : IsEmbedding f) (hsurj : f.Surjective) :\n    IsOpenEmbedding f :=\n  ‚ü®hf, hsurj.range_eq ‚ñ∏ isOpen_univ‚ü©\n\n"}
{"name":"Embedding.toIsOpenEmbedding_of_surjective","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Embedding.toIsOpenEmbedding_of_surjective := IsEmbedding.isOpenEmbedding_of_surjective\n\n"}
{"name":"Topology.IsOpenEmbedding.of_isEmbedding","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"alias IsOpenEmbedding.of_isEmbedding := IsEmbedding.isOpenEmbedding_of_surjective\n\n"}
{"name":"Embedding.toOpenEmbedding_of_surjective","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsEmbedding f\nhsurj : Function.Surjective f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias _root_.Embedding.toOpenEmbedding_of_surjective := IsEmbedding.isOpenEmbedding_of_surjective\n\n"}
{"name":"Topology.isOpenEmbedding_iff_isEmbedding_isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Topology.IsEmbedding f) (IsOpenMap f))","decl":"lemma isOpenEmbedding_iff_isEmbedding_isOpenMap : IsOpenEmbedding f ‚Üî IsEmbedding f ‚àß IsOpenMap f :=\n  ‚ü®fun h => ‚ü®h.1, h.isOpenMap‚ü©, fun h => .of_isEmbedding_isOpenMap h.1 h.2‚ü©\n\n"}
{"name":"Topology.isOpenEmbedding_iff_embedding_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Topology.IsEmbedding f) (IsOpenMap f))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias isOpenEmbedding_iff_embedding_open := isOpenEmbedding_iff_isEmbedding_isOpenMap\n\n"}
{"name":"Topology.openEmbedding_iff_embedding_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Topology.IsEmbedding f) (IsOpenMap f))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_iff_embedding_open := isOpenEmbedding_iff_isEmbedding_isOpenMap\n\n"}
{"name":"Topology.IsOpenEmbedding.of_continuous_injective_isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Continuous f\nh‚ÇÇ : Function.Injective f\nh‚ÇÉ : IsOpenMap f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"theorem IsOpenEmbedding.of_continuous_injective_isOpenMap\n    (h‚ÇÅ : Continuous f) (h‚ÇÇ : Injective f) (h‚ÇÉ : IsOpenMap f) : IsOpenEmbedding f := by\n  simp only [isOpenEmbedding_iff_isEmbedding_isOpenMap, isEmbedding_iff, isInducing_iff_nhds, *,\n    and_true]\n  exact fun x =>\n    le_antisymm (h‚ÇÅ.tendsto _).le_comap (@comap_map _ _ (ùìù x) _ h‚ÇÇ ‚ñ∏ comap_mono (h‚ÇÉ.nhds_le _))\n\n"}
{"name":"Topology.isOpenEmbedding_iff_continuous_injective_isOpenMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Continuous f) (And (Function.Injective f) (IsOpenMap f)))","decl":"lemma isOpenEmbedding_iff_continuous_injective_isOpenMap :\n    IsOpenEmbedding f ‚Üî Continuous f ‚àß Injective f ‚àß IsOpenMap f :=\n  ‚ü®fun h => ‚ü®h.continuous, h.injective, h.isOpenMap‚ü©, fun h =>\n    .of_continuous_injective_isOpenMap h.1 h.2.1 h.2.2‚ü©\n\n"}
{"name":"Topology.isOpenEmbedding_iff_continuous_injective_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Continuous f) (And (Function.Injective f) (IsOpenMap f)))","decl":"@[deprecated (since := \"2024-10-30\")]\nalias isOpenEmbedding_iff_continuous_injective_open :=\n  isOpenEmbedding_iff_continuous_injective_isOpenMap\n\n"}
{"name":"Topology.openEmbedding_iff_continuous_injective_open","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Iff (Topology.IsOpenEmbedding f) (And (Continuous f) (And (Function.Injective f) (IsOpenMap f)))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_iff_continuous_injective_open :=\n  isOpenEmbedding_iff_continuous_injective_isOpenMap\n\n"}
{"name":"Topology.IsOpenEmbedding.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsOpenEmbedding id","decl":"protected lemma id : IsOpenEmbedding (@id X) := ‚ü®.id, IsOpenMap.id.isOpen_range‚ü©\n\n"}
{"name":"openEmbedding_id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsOpenEmbedding id","decl":"@[deprecated (since := \"2024-10-18\")]\nalias _root_.openEmbedding_id := IsOpenEmbedding.id\n\n"}
{"name":"Topology.IsOpenEmbedding.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsOpenEmbedding g\nhf : Topology.IsOpenEmbedding f\n‚ä¢ Topology.IsOpenEmbedding (Function.comp g f)","decl":"protected lemma comp (hg : IsOpenEmbedding g)\n    (hf : IsOpenEmbedding f) : IsOpenEmbedding (g ‚àò f) :=\n  ‚ü®hg.1.comp hf.1, (hg.isOpenMap.comp hf.isOpenMap).isOpen_range‚ü©\n\n"}
{"name":"Topology.IsOpenEmbedding.isOpenMap_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsOpenEmbedding g\n‚ä¢ Iff (IsOpenMap f) (IsOpenMap (Function.comp g f))","decl":"theorem isOpenMap_iff (hg : IsOpenEmbedding g) :\n    IsOpenMap f ‚Üî IsOpenMap (g ‚àò f) := by\n  simp_rw [isOpenMap_iff_nhds_le, ‚Üê map_map, comp, ‚Üê hg.map_nhds_eq, map_le_map_iff hg.injective]\n\n"}
{"name":"Topology.IsOpenEmbedding.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\nhg : Topology.IsOpenEmbedding g\n‚ä¢ Iff (Topology.IsOpenEmbedding (Function.comp g f)) (Topology.IsOpenEmbedding f)","decl":"theorem of_comp_iff (f : X ‚Üí Y) (hg : IsOpenEmbedding g) :\n    IsOpenEmbedding (g ‚àò f) ‚Üî IsOpenEmbedding f := by\n  simp only [isOpenEmbedding_iff_continuous_injective_isOpenMap, ‚Üê hg.isOpenMap_iff, ‚Üê\n    hg.1.continuous_iff, hg.injective.of_comp_iff]\n\n"}
{"name":"Topology.IsOpenEmbedding.of_comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\nhg : Topology.IsOpenEmbedding g\nh : Topology.IsOpenEmbedding (Function.comp g f)\n‚ä¢ Topology.IsOpenEmbedding f","decl":"lemma of_comp (f : X ‚Üí Y) (hg : IsOpenEmbedding g) (h : IsOpenEmbedding (g ‚àò f)) :\n    IsOpenEmbedding f := (IsOpenEmbedding.of_comp_iff f hg).1 h\n\n"}
{"name":"Topology.IsOpenEmbedding.of_isEmpty","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : IsEmpty X\nf : X ‚Üí Y\n‚ä¢ Topology.IsOpenEmbedding f","decl":"theorem of_isEmpty [IsEmpty X] (f : X ‚Üí Y) : IsOpenEmbedding f :=\n  of_isEmbedding_isOpenMap (.of_subsingleton f) (.of_isEmpty f)\n\n"}
{"name":"Topology.IsOpenEmbedding.image_mem_nhds","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsOpenEmbedding f\ns : Set X\nx : X\n‚ä¢ Iff (Membership.mem (nhds (f x)) (Set.image f s)) (Membership.mem (nhds x) s)","decl":"theorem image_mem_nhds {f : X ‚Üí Y} (hf : IsOpenEmbedding f) {s : Set X} {x : X} :\n    f '' s ‚àà ùìù (f x) ‚Üî s ‚àà ùìù x := by\n  rw [‚Üê hf.map_nhds_eq, mem_map, preimage_image_eq _ hf.injective]\n\n"}
{"name":"Topology.IsClosedEmbedding.isEmbedding","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Topology.IsEmbedding f","decl":"lemma isEmbedding (hf : IsClosedEmbedding f) : IsEmbedding f := hf.toIsEmbedding\n"}
{"name":"Topology.IsClosedEmbedding.isInducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"lemma isInducing (hf : IsClosedEmbedding f) : IsInducing f := hf.isEmbedding.isInducing\n"}
{"name":"Topology.IsClosedEmbedding.continuous","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Continuous f","decl":"lemma continuous (hf : IsClosedEmbedding f) : Continuous f := hf.isEmbedding.continuous\n\n"}
{"name":"Topology.IsClosedEmbedding.inducing","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing := isInducing\n\n"}
{"name":"Topology.IsClosedEmbedding.tendsto_nhds_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nŒπ : Type u_4\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ng : Œπ ‚Üí X\nl : Filter Œπ\nx : X\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Iff (Filter.Tendsto g l (nhds x)) (Filter.Tendsto (Function.comp f g) l (nhds (f x)))","decl":"lemma tendsto_nhds_iff {g : Œπ ‚Üí X} {l : Filter Œπ} {x : X} (hf : IsClosedEmbedding f) :\n    Tendsto g l (ùìù x) ‚Üî Tendsto (f ‚àò g) l (ùìù (f x)) := hf.isEmbedding.tendsto_nhds_iff\n\n"}
{"name":"Topology.IsClosedEmbedding.isClosedMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ IsClosedMap f","decl":"lemma isClosedMap (hf : IsClosedEmbedding f) : IsClosedMap f :=\n  hf.isEmbedding.isInducing.isClosedMap hf.isClosed_range\n\n"}
{"name":"Topology.IsClosedEmbedding.isClosed_iff_image_isClosed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\ns : Set X\n‚ä¢ Iff (IsClosed s) (IsClosed (Set.image f s))","decl":"lemma isClosed_iff_image_isClosed (hf : IsClosedEmbedding f) {s : Set X} :\n    IsClosed s ‚Üî IsClosed (f '' s) :=\n  ‚ü®hf.isClosedMap s, fun h => by\n    rw [‚Üê preimage_image_eq s hf.injective]\n    exact h.preimage hf.continuous‚ü©\n\n"}
{"name":"Topology.IsClosedEmbedding.closed_iff_image_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\ns : Set X\n‚ä¢ Iff (IsClosed s) (IsClosed (Set.image f s))","decl":"@[deprecated (since := \"2024-10-30\")] alias closed_iff_image_closed := isClosed_iff_image_isClosed\n\n"}
{"name":"Topology.IsClosedEmbedding.isClosed_iff_preimage_isClosed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\ns : Set Y\nhs : HasSubset.Subset s (Set.range f)\n‚ä¢ Iff (IsClosed s) (IsClosed (Set.preimage f s))","decl":"lemma isClosed_iff_preimage_isClosed (hf : IsClosedEmbedding f) {s : Set Y}\n    (hs : s ‚äÜ range f) : IsClosed s ‚Üî IsClosed (f ‚Åª¬π' s) := by\n  rw [hf.isClosed_iff_image_isClosed, image_preimage_eq_of_subset hs]\n\n"}
{"name":"Topology.IsClosedEmbedding.closed_iff_preimage_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\ns : Set Y\nhs : HasSubset.Subset s (Set.range f)\n‚ä¢ Iff (IsClosed s) (IsClosed (Set.preimage f s))","decl":"@[deprecated (since := \"2024-10-30\")]\nalias closed_iff_preimage_closed := isClosed_iff_preimage_isClosed\n\n"}
{"name":"Topology.IsClosedEmbedding.of_isEmbedding_isClosedMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsClosedMap f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"lemma of_isEmbedding_isClosedMap (h‚ÇÅ : IsEmbedding f) (h‚ÇÇ : IsClosedMap f) :\n    IsClosedEmbedding f :=\n  ‚ü®h‚ÇÅ, image_univ (f := f) ‚ñ∏ h‚ÇÇ univ isClosed_univ‚ü©\n\n"}
{"name":"IsClosedEmbedding.of_embedding_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsClosedMap f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.IsClosedEmbedding.of_embedding_closed := of_isEmbedding_isClosedMap\n\n"}
{"name":"closedEmbedding_of_embedding_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Topology.IsEmbedding f\nh‚ÇÇ : IsClosedMap f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.closedEmbedding_of_embedding_closed := of_isEmbedding_isClosedMap\n\n"}
{"name":"Topology.IsClosedEmbedding.of_continuous_injective_isClosedMap","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Continuous f\nh‚ÇÇ : Function.Injective f\nh‚ÇÉ : IsClosedMap f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"lemma of_continuous_injective_isClosedMap (h‚ÇÅ : Continuous f) (h‚ÇÇ : Injective f)\n    (h‚ÇÉ : IsClosedMap f) : IsClosedEmbedding f := by\n  refine .of_isEmbedding_isClosedMap ‚ü®‚ü®?_‚ü©, h‚ÇÇ‚ü© h‚ÇÉ\n  refine h‚ÇÅ.le_induced.antisymm fun s hs => ?_\n  refine ‚ü®(f '' s·∂ú)·∂ú, (h‚ÇÉ _ hs.isClosed_compl).isOpen_compl, ?_‚ü©\n  rw [preimage_compl, preimage_image_eq _ h‚ÇÇ, compl_compl]\n\n"}
{"name":"closedEmbedding_of_continuous_injective_closed","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh‚ÇÅ : Continuous f\nh‚ÇÇ : Function.Injective f\nh‚ÇÉ : IsClosedMap f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.closedEmbedding_of_continuous_injective_closed :=\n  IsClosedEmbedding.of_continuous_injective_isClosedMap\n\n"}
{"name":"Topology.IsClosedEmbedding.id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsClosedEmbedding id","decl":"protected theorem id : IsClosedEmbedding (@id X) := ‚ü®.id, IsClosedMap.id.isClosed_range‚ü©\n\n"}
{"name":"closedEmbedding_id","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsClosedEmbedding id","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.closedEmbedding_id := IsClosedEmbedding.id\n\n"}
{"name":"Topology.IsClosedEmbedding.comp","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsClosedEmbedding g\nhf : Topology.IsClosedEmbedding f\n‚ä¢ Topology.IsClosedEmbedding (Function.comp g f)","decl":"theorem comp (hg : IsClosedEmbedding g) (hf : IsClosedEmbedding f) :\n    IsClosedEmbedding (g ‚àò f) :=\n  ‚ü®hg.isEmbedding.comp hf.isEmbedding, (hg.isClosedMap.comp hf.isClosedMap).isClosed_range‚ü©\n\n"}
{"name":"Topology.IsClosedEmbedding.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsClosedEmbedding g\n‚ä¢ Iff (Topology.IsClosedEmbedding (Function.comp g f)) (Topology.IsClosedEmbedding f)","decl":"lemma of_comp_iff (hg : IsClosedEmbedding g) : IsClosedEmbedding (g ‚àò f) ‚Üî IsClosedEmbedding f := by\n  simp_rw [isClosedEmbedding_iff, hg.isEmbedding.of_comp_iff, Set.range_comp,\n    ‚Üê hg.isClosed_iff_image_isClosed]\n\n"}
{"name":"Topology.IsClosedEmbedding.Embedding.of_comp_iff","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : X ‚Üí Y\ng : Y ‚Üí Z\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nhg : Topology.IsClosedEmbedding g\n‚ä¢ Iff (Topology.IsClosedEmbedding (Function.comp g f)) (Topology.IsClosedEmbedding f)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.of_comp_iff := of_comp_iff\n\n"}
{"name":"Topology.IsClosedEmbedding.closure_image_eq","module":"Mathlib.Topology.Maps.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nf : X ‚Üí Y\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nhf : Topology.IsClosedEmbedding f\ns : Set X\n‚ä¢ Eq (closure (Set.image f s)) (Set.image f (closure s))","decl":"theorem closure_image_eq (hf : IsClosedEmbedding f) (s : Set X) :\n    closure (f '' s) = f '' closure s :=\n  hf.isClosedMap.closure_image_eq_of_continuous hf.continuous s\n\n"}
