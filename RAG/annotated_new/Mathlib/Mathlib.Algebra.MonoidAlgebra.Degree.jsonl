{"name":"AddMonoidAlgebra.sup_support_add_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : SemilatticeSup B\ninst✝¹ : OrderBot B\ninst✝ : Semiring R\ndegb : A → B\nf g : AddMonoidAlgebra R A\n⊢ LE.le ((HAdd.hAdd f g).support.sup degb) (Max.max (f.support.sup degb) (g.support.sup degb))","decl":"theorem sup_support_add_le :\n    (f + g).support.sup degb ≤ f.support.sup degb ⊔ g.support.sup degb := by\n  classical\n  exact (Finset.sup_mono Finsupp.support_add).trans_eq Finset.sup_union\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_add","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝² : SemilatticeInf T\ninst✝¹ : OrderTop T\ninst✝ : Semiring R\ndegt : A → T\nf g : AddMonoidAlgebra R A\n⊢ LE.le (Min.min (f.support.inf degt) (g.support.inf degt)) ((HAdd.hAdd f g).support.inf degt)","decl":"theorem le_inf_support_add : f.support.inf degt ⊓ g.support.inf degt ≤ (f + g).support.inf degt :=\n  sup_support_add_le (fun a : A => OrderDual.toDual (degt a)) f g\n\n"}
{"name":"AddMonoidAlgebra.sup_support_mul_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : SemilatticeSup B\ninst✝⁵ : OrderBot B\ninst✝⁴ : Semiring R\ninst✝³ : Add A\ninst✝² : Add B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\ndegb : A → B\ndegbm : ∀ {a b : A}, LE.le (degb (HAdd.hAdd a b)) (HAdd.hAdd (degb a) (degb b))\nf g : AddMonoidAlgebra R A\n⊢ LE.le ((HMul.hMul f g).support.sup degb) (HAdd.hAdd (f.support.sup degb) (g.support.sup degb))","decl":"theorem sup_support_mul_le {degb : A → B} (degbm : ∀ {a b}, degb (a + b) ≤ degb a + degb b)\n    (f g : R[A]) :\n    (f * g).support.sup degb ≤ f.support.sup degb + g.support.sup degb := by\n  classical\n  exact (Finset.sup_mono <| support_mul _ _).trans <| Finset.sup_add_le.2 fun _fd fds _gd gds ↦\n    degbm.trans <| add_le_add (Finset.le_sup fds) (Finset.le_sup gds)\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝⁶ : SemilatticeInf T\ninst✝⁵ : OrderTop T\ninst✝⁴ : Semiring R\ninst✝³ : Add A\ninst✝² : Add T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\ndegt : A → T\ndegtm : ∀ {a b : A}, LE.le (HAdd.hAdd (degt a) (degt b)) (degt (HAdd.hAdd a b))\nf g : AddMonoidAlgebra R A\n⊢ LE.le (HAdd.hAdd (f.support.inf degt) (g.support.inf degt)) ((HMul.hMul f g).support.inf degt)","decl":"theorem le_inf_support_mul {degt : A → T} (degtm : ∀ {a b}, degt a + degt b ≤ degt (a + b))\n    (f g : R[A]) :\n    f.support.inf degt + g.support.inf degt ≤ (f * g).support.inf degt :=\n  sup_support_mul_le (B := Tᵒᵈ) degtm f g\n\n"}
{"name":"AddMonoidAlgebra.sup_support_list_prod_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : SemilatticeSup B\ninst✝⁵ : OrderBot B\ninst✝⁴ : Semiring R\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\ndegb : A → B\ndegb0 : LE.le (degb 0) 0\ndegbm : ∀ (a b : A), LE.le (degb (HAdd.hAdd a b)) (HAdd.hAdd (degb a) (degb b))\nl : List (AddMonoidAlgebra R A)\n⊢ LE.le (l.prod.support.sup degb) (List.map (fun f => f.support.sup degb) l).sum","decl":"theorem sup_support_list_prod_le (degb0 : degb 0 ≤ 0)\n    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) :\n    ∀ l : List R[A],\n      l.prod.support.sup degb ≤ (l.map fun f : R[A] => f.support.sup degb).sum\n  | [] => by\n    rw [List.map_nil, Finset.sup_le_iff, List.prod_nil, List.sum_nil]\n    exact fun a ha => by rwa [Finset.mem_singleton.mp (Finsupp.support_single_subset ha)]\n  | f::fs => by\n    rw [List.prod_cons, List.map_cons, List.sum_cons]\n    exact (sup_support_mul_le (@fun a b => degbm a b) _ _).trans\n        (add_le_add_left (sup_support_list_prod_le degb0 degbm fs) _)\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_list_prod","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝⁶ : SemilatticeInf T\ninst✝⁵ : OrderTop T\ninst✝⁴ : Semiring R\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\ndegt : A → T\ndegt0 : LE.le 0 (degt 0)\ndegtm : ∀ (a b : A), LE.le (HAdd.hAdd (degt a) (degt b)) (degt (HAdd.hAdd a b))\nl : List (AddMonoidAlgebra R A)\n⊢ LE.le (List.map (fun f => f.support.inf degt) l).sum (l.prod.support.inf degt)","decl":"theorem le_inf_support_list_prod (degt0 : 0 ≤ degt 0)\n    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (l : List R[A]) :\n    (l.map fun f : R[A] => f.support.inf degt).sum ≤ l.prod.support.inf degt := by\n  refine OrderDual.ofDual_le_ofDual.mpr ?_\n  refine sup_support_list_prod_le ?_ ?_ l\n  · refine (OrderDual.ofDual_le_ofDual.mp ?_)\n    exact degt0\n  · refine (fun a b => OrderDual.ofDual_le_ofDual.mp ?_)\n    exact degtm a b\n\n"}
{"name":"AddMonoidAlgebra.sup_support_pow_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : SemilatticeSup B\ninst✝⁵ : OrderBot B\ninst✝⁴ : Semiring R\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\ndegb : A → B\ndegb0 : LE.le (degb 0) 0\ndegbm : ∀ (a b : A), LE.le (degb (HAdd.hAdd a b)) (HAdd.hAdd (degb a) (degb b))\nn : Nat\nf : AddMonoidAlgebra R A\n⊢ LE.le ((HPow.hPow f n).support.sup degb) (HSMul.hSMul n (f.support.sup degb))","decl":"theorem sup_support_pow_le (degb0 : degb 0 ≤ 0) (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b)\n    (n : ℕ) (f : R[A]) : (f ^ n).support.sup degb ≤ n • f.support.sup degb := by\n  rw [← List.prod_replicate, ← List.sum_replicate]\n  refine (sup_support_list_prod_le degb0 degbm _).trans_eq ?_\n  rw [List.map_replicate]\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_pow","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝⁶ : SemilatticeInf T\ninst✝⁵ : OrderTop T\ninst✝⁴ : Semiring R\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\ndegt : A → T\ndegt0 : LE.le 0 (degt 0)\ndegtm : ∀ (a b : A), LE.le (HAdd.hAdd (degt a) (degt b)) (degt (HAdd.hAdd a b))\nn : Nat\nf : AddMonoidAlgebra R A\n⊢ LE.le (HSMul.hSMul n (f.support.inf degt)) ((HPow.hPow f n).support.inf degt)","decl":"theorem le_inf_support_pow (degt0 : 0 ≤ degt 0) (degtm : ∀ a b, degt a + degt b ≤ degt (a + b))\n    (n : ℕ) (f : R[A]) : n • f.support.inf degt ≤ (f ^ n).support.inf degt := by\n  refine OrderDual.ofDual_le_ofDual.mpr <| sup_support_pow_le (OrderDual.ofDual_le_ofDual.mp ?_)\n      (fun a b => OrderDual.ofDual_le_ofDual.mp ?_) n f\n  · exact degt0\n  · exact degtm _ _\n\n"}
{"name":"AddMonoidAlgebra.sup_support_multiset_prod_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : SemilatticeSup B\ninst✝⁵ : OrderBot B\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid A\ninst✝² : AddCommMonoid B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\ndegb : A → B\ndegb0 : LE.le (degb 0) 0\ndegbm : ∀ (a b : A), LE.le (degb (HAdd.hAdd a b)) (HAdd.hAdd (degb a) (degb b))\nm : Multiset (AddMonoidAlgebra R A)\n⊢ LE.le (m.prod.support.sup degb) (Multiset.map (fun f => f.support.sup degb) m).sum","decl":"theorem sup_support_multiset_prod_le (degb0 : degb 0 ≤ 0)\n    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (m : Multiset R[A]) :\n    m.prod.support.sup degb ≤ (m.map fun f : R[A] => f.support.sup degb).sum := by\n  induction m using Quot.inductionOn\n  rw [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.sum_coe, Multiset.prod_coe]\n  exact sup_support_list_prod_le degb0 degbm _\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_multiset_prod","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝⁶ : SemilatticeInf T\ninst✝⁵ : OrderTop T\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid A\ninst✝² : AddCommMonoid T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\ndegt : A → T\ndegt0 : LE.le 0 (degt 0)\ndegtm : ∀ (a b : A), LE.le (HAdd.hAdd (degt a) (degt b)) (degt (HAdd.hAdd a b))\nm : Multiset (AddMonoidAlgebra R A)\n⊢ LE.le (Multiset.map (fun f => f.support.inf degt) m).sum (m.prod.support.inf degt)","decl":"theorem le_inf_support_multiset_prod (degt0 : 0 ≤ degt 0)\n    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (m : Multiset R[A]) :\n    (m.map fun f : R[A] => f.support.inf degt).sum ≤ m.prod.support.inf degt := by\n  refine OrderDual.ofDual_le_ofDual.mpr <|\n    sup_support_multiset_prod_le (OrderDual.ofDual_le_ofDual.mp ?_)\n      (fun a b => OrderDual.ofDual_le_ofDual.mp ?_) m\n  · exact degt0\n  · exact degtm _ _\n\n"}
{"name":"AddMonoidAlgebra.sup_support_finset_prod_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\nι : Type u_6\ninst✝⁶ : SemilatticeSup B\ninst✝⁵ : OrderBot B\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid A\ninst✝² : AddCommMonoid B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\ndegb : A → B\ndegb0 : LE.le (degb 0) 0\ndegbm : ∀ (a b : A), LE.le (degb (HAdd.hAdd a b)) (HAdd.hAdd (degb a) (degb b))\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\n⊢ LE.le ((s.prod fun i => f i).support.sup degb) (s.sum fun i => (f i).support.sup degb)","decl":"theorem sup_support_finset_prod_le (degb0 : degb 0 ≤ 0)\n    (degbm : ∀ a b, degb (a + b) ≤ degb a + degb b) (s : Finset ι) (f : ι → R[A]) :\n    (∏ i ∈ s, f i).support.sup degb ≤ ∑ i ∈ s, (f i).support.sup degb :=\n  (sup_support_multiset_prod_le degb0 degbm _).trans_eq <| congr_arg _ <| Multiset.map_map _ _ _\n\n"}
{"name":"AddMonoidAlgebra.le_inf_support_finset_prod","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\nι : Type u_6\ninst✝⁶ : SemilatticeInf T\ninst✝⁵ : OrderTop T\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid A\ninst✝² : AddCommMonoid T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\ndegt : A → T\ndegt0 : LE.le 0 (degt 0)\ndegtm : ∀ (a b : A), LE.le (HAdd.hAdd (degt a) (degt b)) (degt (HAdd.hAdd a b))\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\n⊢ LE.le (s.sum fun i => (f i).support.inf degt) ((s.prod fun i => f i).support.inf degt)","decl":"theorem le_inf_support_finset_prod (degt0 : 0 ≤ degt 0)\n    (degtm : ∀ a b, degt a + degt b ≤ degt (a + b)) (s : Finset ι) (f : ι → R[A]) :\n    (∑ i ∈ s, (f i).support.inf degt) ≤ (∏ i ∈ s, f i).support.inf degt :=\n  le_of_eq_of_le (by rw [Multiset.map_map]; rfl) (le_inf_support_multiset_prod degt0 degtm _)\n\n"}
{"name":"AddMonoidAlgebra.supDegree_add_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\nf g : AddMonoidAlgebra R A\n⊢ LE.le (AddMonoidAlgebra.supDegree D (HAdd.hAdd f g)) (Max.max (AddMonoidAlgebra.supDegree D f) (AddMonoidAlgebra.supDegree D g))","decl":"theorem supDegree_add_le {f g : R[A]} :\n    (f + g).supDegree D ≤ (f.supDegree D) ⊔ (g.supDegree D) :=\n  sup_support_add_le D f g\n\n"}
{"name":"AddMonoidAlgebra.supDegree_neg","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R' : Type u_2\nA : Type u_3\nB : Type u_5\ninst✝² : Ring R'\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\nf : AddMonoidAlgebra R' A\n⊢ Eq (AddMonoidAlgebra.supDegree D (Neg.neg f)) (AddMonoidAlgebra.supDegree D f)","decl":"@[simp]\ntheorem supDegree_neg {f : R'[A]} :\n    (-f).supDegree D = f.supDegree D := by\n  rw [supDegree, supDegree, Finsupp.support_neg]\n\n"}
{"name":"AddMonoidAlgebra.supDegree_sub_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R' : Type u_2\nA : Type u_3\nB : Type u_5\ninst✝² : Ring R'\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\nf g : AddMonoidAlgebra R' A\n⊢ LE.le (AddMonoidAlgebra.supDegree D (HSub.hSub f g)) (Max.max (AddMonoidAlgebra.supDegree D f) (AddMonoidAlgebra.supDegree D g))","decl":"theorem supDegree_sub_le {f g : R'[A]} :\n    (f - g).supDegree D ≤ f.supDegree D ⊔ g.supDegree D := by\n  rw [sub_eq_add_neg, ← supDegree_neg (f := g)]; apply supDegree_add_le\n\n"}
{"name":"AddMonoidAlgebra.supDegree_sum_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\nι : Type u_7\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\n⊢ LE.le (AddMonoidAlgebra.supDegree D (s.sum fun i => f i)) (s.sup fun i => AddMonoidAlgebra.supDegree D (f i))","decl":"theorem supDegree_sum_le {ι} {s : Finset ι} {f : ι → R[A]} :\n    (∑ i ∈ s, f i).supDegree D ≤ s.sup (fun i => (f i).supDegree D) := by\n  classical\n  exact (Finset.sup_mono Finsupp.support_finset_sum).trans_eq (Finset.sup_biUnion _ _)\n\n"}
{"name":"AddMonoidAlgebra.supDegree_single_ne_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\na : A\nr : R\nhr : Ne r 0\n⊢ Eq (AddMonoidAlgebra.supDegree D (AddMonoidAlgebra.single a r)) (D a)","decl":"theorem supDegree_single_ne_zero (a : A) {r : R} (hr : r ≠ 0) :\n    (single a r).supDegree D = D a := by\n  rw [supDegree, Finsupp.support_single_ne_zero a hr, Finset.sup_singleton]\n\n"}
{"name":"AddMonoidAlgebra.supDegree_single","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\na : A\nr : R\n⊢ Eq (AddMonoidAlgebra.supDegree D (AddMonoidAlgebra.single a r)) (ite (Eq r 0) Bot.bot (D a))","decl":"open Classical in\ntheorem supDegree_single (a : A) (r : R) :\n    (single a r).supDegree D = if r = 0 then ⊥ else D a := by\n  split_ifs with hr <;> simp [supDegree_single_ne_zero, hr]\n\n"}
{"name":"AddMonoidAlgebra.apply_eq_zero_of_not_le_supDegree","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\np : AddMonoidAlgebra R A\na : A\nhlt : Not (LE.le (D a) (AddMonoidAlgebra.supDegree D p))\n⊢ Eq (p a) 0","decl":"theorem apply_eq_zero_of_not_le_supDegree {p : R[A]} {a : A} (hlt : ¬ D a ≤ p.supDegree D) :\n    p a = 0 := by\n  contrapose! hlt\n  exact Finset.le_sup (Finsupp.mem_support_iff.2 hlt)\n\n"}
{"name":"AddMonoidAlgebra.supDegree_withBot_some_comp","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\ns : AddMonoidAlgebra R A\nhs : s.support.Nonempty\n⊢ Eq (AddMonoidAlgebra.supDegree (Function.comp WithBot.some D) s) ↑(AddMonoidAlgebra.supDegree D s)","decl":"theorem supDegree_withBot_some_comp {s : AddMonoidAlgebra R A} (hs : s.support.Nonempty) :\n    supDegree (WithBot.some ∘ D) s = supDegree D s := by\n  unfold AddMonoidAlgebra.supDegree\n  rw [← Finset.coe_sup' hs, Finset.sup'_eq_sup]\n\n"}
{"name":"AddMonoidAlgebra.supDegree_eq_of_isMaxOn","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : SemilatticeSup B\ninst✝ : OrderBot B\nD : A → B\np : AddMonoidAlgebra R A\na : A\nhmem : Membership.mem p.support a\nhmax : IsMaxOn D (↑p.support) a\n⊢ Eq (AddMonoidAlgebra.supDegree D p) (D a)","decl":"theorem supDegree_eq_of_isMaxOn {p : R[A]} {a : A} (hmem : a ∈ p.support)\n    (hmax : IsMaxOn D p.support a) : p.supDegree D = D a :=\n  sup_eq_of_isMaxOn hmem hmax\n\n"}
{"name":"AddMonoidAlgebra.supDegree_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : SemilatticeSup B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : AddZeroClass A\n⊢ Eq (AddMonoidAlgebra.supDegree D 0) Bot.bot","decl":"@[simp]\ntheorem supDegree_zero : (0 : R[A]).supDegree D = ⊥ := by simp [supDegree]\n\n"}
{"name":"AddMonoidAlgebra.ne_zero_of_supDegree_ne_bot","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : SemilatticeSup B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : AddZeroClass A\np : AddMonoidAlgebra R A\na✝ : Ne (AddMonoidAlgebra.supDegree D p) Bot.bot\n⊢ Ne p 0","decl":"theorem ne_zero_of_supDegree_ne_bot : p.supDegree D ≠ ⊥ → p ≠ 0 := mt (fun h => h ▸ supDegree_zero)\n\n"}
{"name":"AddMonoidAlgebra.ne_zero_of_not_supDegree_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : SemilatticeSup B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : AddZeroClass A\np : AddMonoidAlgebra R A\nb : B\nh : Not (LE.le (AddMonoidAlgebra.supDegree D p) b)\n⊢ Ne p 0","decl":"theorem ne_zero_of_not_supDegree_le {b : B} (h : ¬ p.supDegree D ≤ b) : p ≠ 0 :=\n  ne_zero_of_supDegree_ne_bot (fun he => h <| he ▸ bot_le)\n\n"}
{"name":"AddMonoidAlgebra.supDegree_eq_of_max","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : SemilatticeSup B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : AddZeroClass A\np : AddMonoidAlgebra R A\nb : B\nhb : Membership.mem (Set.range D) b\nhmem : Membership.mem p.support (Function.invFun D b)\nhmax : ∀ (a : A), Membership.mem p.support a → LE.le (D a) b\n⊢ Eq (AddMonoidAlgebra.supDegree D p) b","decl":"theorem supDegree_eq_of_max {b : B} (hb : b ∈ Set.range D) (hmem : D.invFun b ∈ p.support)\n    (hmax : ∀ a ∈ p.support, D a ≤ b) : p.supDegree D = b :=\n  sup_eq_of_max hb hmem hmax\n\n"}
{"name":"AddMonoidAlgebra.supDegree_mul_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : SemilatticeSup B\ninst✝⁴ : OrderBot B\nD : A → B\ninst✝³ : AddZeroClass A\np q : AddMonoidAlgebra R A\ninst✝² : Add B\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\n⊢ LE.le (AddMonoidAlgebra.supDegree D (HMul.hMul p q)) (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q))","decl":"theorem supDegree_mul_le (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    [AddLeftMono B] [AddRightMono B] :\n    (p * q).supDegree D ≤ p.supDegree D + q.supDegree D :=\n  sup_support_mul_le (fun {_ _} => (hadd _ _).le) p q\n\n"}
{"name":"AddMonoidAlgebra.supDegree_prod_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_7\nA : Type u_8\nB : Type u_9\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : AddCommMonoid B\ninst✝³ : SemilatticeSup B\ninst✝² : OrderBot B\ninst✝¹ : AddLeftMono B\ninst✝ : AddRightMono B\nD : A → B\nhzero : Eq (D 0) 0\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nι : Type u_10\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\n⊢ LE.le (AddMonoidAlgebra.supDegree D (s.prod fun i => f i)) (s.sum fun i => AddMonoidAlgebra.supDegree D (f i))","decl":"theorem supDegree_prod_le {R A B : Type*} [CommSemiring R] [AddCommMonoid A] [AddCommMonoid B]\n    [SemilatticeSup B] [OrderBot B]\n    [AddLeftMono B] [AddRightMono B]\n    {D : A → B} (hzero : D 0 = 0) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    {ι} {s : Finset ι} {f : ι → R[A]} :\n    (∏ i ∈ s, f i).supDegree D ≤ ∑ i ∈ s, (f i).supDegree D := by\n  classical\n  refine s.induction ?_ ?_\n  · rw [Finset.prod_empty, Finset.sum_empty, one_def, supDegree_single]\n    split_ifs; exacts [bot_le, hzero.le]\n  · intro i s his ih\n    rw [Finset.prod_insert his, Finset.sum_insert his]\n    exact (supDegree_mul_le hadd).trans (by gcongr)\n\n"}
{"name":"AddMonoidAlgebra.apply_add_of_supDegree_le","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : SemilatticeSup B\ninst✝⁴ : OrderBot B\nD : A → B\ninst✝³ : AddZeroClass A\np q : AddMonoidAlgebra R A\ninst✝² : Add B\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nap aq : A\nhp : LE.le (AddMonoidAlgebra.supDegree D p) (D ap)\nhq : LE.le (AddMonoidAlgebra.supDegree D q) (D aq)\n⊢ Eq ((HMul.hMul p q) (HAdd.hAdd ap aq)) (HMul.hMul (p ap) (q aq))","decl":"theorem apply_add_of_supDegree_le (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    [AddLeftStrictMono B] [AddRightStrictMono B]\n    (hD : D.Injective) {ap aq : A} (hp : p.supDegree D ≤ D ap) (hq : q.supDegree D ≤ D aq) :\n    (p * q) (ap + aq) = p ap * q aq := by\n  classical\n  simp_rw [mul_apply, Finsupp.sum]\n  rw [Finset.sum_eq_single ap, Finset.sum_eq_single aq, if_pos rfl]\n  · refine fun a ha hne => if_neg (fun he => ?_)\n    apply_fun D at he; simp_rw [hadd] at he\n    exact (add_lt_add_left (((Finset.le_sup ha).trans hq).lt_of_ne <| hD.ne_iff.2 hne) _).ne he\n  · intro h; rw [if_pos rfl, Finsupp.not_mem_support_iff.1 h, mul_zero]\n  · refine fun a ha hne => Finset.sum_eq_zero (fun a' ha' => if_neg <| fun he => ?_)\n    apply_fun D at he\n    simp_rw [hadd] at he\n    have := addLeftMono_of_addLeftStrictMono B\n    exact (add_lt_add_of_lt_of_le (((Finset.le_sup ha).trans hp).lt_of_ne <| hD.ne_iff.2 hne)\n      <| (Finset.le_sup ha').trans hq).ne he\n  · refine fun h => Finset.sum_eq_zero (fun a _ => ite_eq_right_iff.mpr <| fun _ => ?_)\n    rw [Finsupp.not_mem_support_iff.mp h, zero_mul]\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_single","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : Nonempty A\nhD : Function.Injective D\na : A\nr : R\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (AddMonoidAlgebra.single a r)) r","decl":"@[simp]\ntheorem leadingCoeff_single [Nonempty A] (hD : D.Injective) (a : A) (r : R) :\n    (single a r).leadingCoeff D = r := by\n  classical\n  rw [leadingCoeff, supDegree_single]\n  split_ifs with hr\n  · simp [hr]\n  · rw [Function.leftInverse_invFun hD, single_apply, if_pos rfl]\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : Nonempty A\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D 0) 0","decl":"@[simp]\ntheorem leadingCoeff_zero [Nonempty A] : (0 : R[A]).leadingCoeff D = 0 := rfl\n\n"}
{"name":"AddMonoidAlgebra.Monic.ne_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : LinearOrder B\ninst✝² : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\ninst✝¹ : Nonempty A\ninst✝ : Nontrivial R\nhp : AddMonoidAlgebra.Monic D p\n⊢ Ne p 0","decl":"lemma Monic.ne_zero [Nonempty A] [Nontrivial R] (hp : p.Monic D) : p ≠ 0 := fun h => by\n  simp_rw [Monic, h, leadingCoeff_zero, zero_ne_one] at hp\n\n"}
{"name":"AddMonoidAlgebra.monic_one","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\ninst✝ : AddZeroClass A\nhD : Function.Injective D\n⊢ AddMonoidAlgebra.Monic D 1","decl":"@[simp]\ntheorem monic_one [AddZeroClass A] (hD : D.Injective) : (1 : R[A]).Monic D := by\n  rw [Monic, one_def, leadingCoeff_single hD]\n\n"}
{"name":"AddMonoidAlgebra.exists_supDegree_mem_support","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : LinearOrder B\ninst✝ : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\nhp : Ne p 0\n⊢ Exists fun a => And (Membership.mem p.support a) (Eq (AddMonoidAlgebra.supDegree D p) (D a))","decl":"variable (D) in\nlemma exists_supDegree_mem_support (hp : p ≠ 0) : ∃ a ∈ p.support, p.supDegree D = D a :=\n  Finset.exists_mem_eq_sup _ (Finsupp.support_nonempty_iff.mpr hp) D\n\n"}
{"name":"AddMonoidAlgebra.supDegree_mem_range","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : LinearOrder B\ninst✝ : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\nhp : Ne p 0\n⊢ Membership.mem (Set.range D) (AddMonoidAlgebra.supDegree D p)","decl":"variable (D) in\nlemma supDegree_mem_range (hp : p ≠ 0) : p.supDegree D ∈ Set.range D := by\n  obtain ⟨a, -, he⟩ := exists_supDegree_mem_support D hp; exact ⟨a, he.symm⟩\n\n"}
{"name":"AddMonoidAlgebra.supDegree_sum_lt","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝² : Semiring R\ninst✝¹ : LinearOrder B\ninst✝ : OrderBot B\nD : A → B\nι : Type u_7\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\nhs : s.Nonempty\nb : B\nh : ∀ (i : ι), Membership.mem s i → LT.lt (AddMonoidAlgebra.supDegree D (f i)) b\n⊢ LT.lt (AddMonoidAlgebra.supDegree D (s.sum fun i => f i)) b","decl":"lemma supDegree_sum_lt (hs : s.Nonempty) {b : B}\n    (h : ∀ i ∈ s, (f i).supDegree D < b) : (∑ i ∈ s, f i).supDegree D < b := by\n  refine supDegree_sum_le.trans_lt ((Finset.sup_lt_iff ?_).mpr h)\n  obtain ⟨i, hi⟩ := hs; exact bot_le.trans_lt (h i hi)\n\n"}
{"name":"AddMonoidAlgebra.supDegree_add_eq_left","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nh : LT.lt (AddMonoidAlgebra.supDegree D q) (AddMonoidAlgebra.supDegree D p)\n⊢ Eq (AddMonoidAlgebra.supDegree D (HAdd.hAdd p q)) (AddMonoidAlgebra.supDegree D p)","decl":"open Finsupp in\nlemma supDegree_add_eq_left (h : q.supDegree D < p.supDegree D) :\n    (p + q).supDegree D = p.supDegree D := by\n  apply (supDegree_add_le.trans <| sup_le le_rfl h.le).antisymm\n  obtain ⟨a, ha, he⟩ := exists_supDegree_mem_support D (ne_zero_of_not_supDegree_le h.not_le)\n  rw [he] at h ⊢\n  apply Finset.le_sup\n  rw [mem_support_iff, add_apply, apply_eq_zero_of_not_le_supDegree h.not_le, add_zero]\n  exact mem_support_iff.mp ha\n\n"}
{"name":"AddMonoidAlgebra.supDegree_add_eq_right","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nh : LT.lt (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q)\n⊢ Eq (AddMonoidAlgebra.supDegree D (HAdd.hAdd p q)) (AddMonoidAlgebra.supDegree D q)","decl":"lemma supDegree_add_eq_right (h : p.supDegree D < q.supDegree D) :\n    (p + q).supDegree D = q.supDegree D := by\n  rw [add_comm, supDegree_add_eq_left h]\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_add_eq_left","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nh : LT.lt (AddMonoidAlgebra.supDegree D q) (AddMonoidAlgebra.supDegree D p)\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (HAdd.hAdd p q)) (AddMonoidAlgebra.leadingCoeff D p)","decl":"lemma leadingCoeff_add_eq_left (h : q.supDegree D < p.supDegree D) :\n    (p + q).leadingCoeff D = p.leadingCoeff D := by\n  obtain ⟨a, he⟩ := supDegree_mem_range D (ne_zero_of_not_supDegree_le h.not_le)\n  rw [leadingCoeff, supDegree_add_eq_left h, Finsupp.add_apply, ← leadingCoeff,\n    apply_eq_zero_of_not_le_supDegree (D := D), add_zero]\n  rw [← he, Function.apply_invFun_apply (f := D), he]; exact h.not_le\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_add_eq_right","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nh : LT.lt (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q)\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (HAdd.hAdd p q)) (AddMonoidAlgebra.leadingCoeff D q)","decl":"lemma leadingCoeff_add_eq_right (h : p.supDegree D < q.supDegree D) :\n    (p + q).leadingCoeff D = q.leadingCoeff D := by\n  rw [add_comm, leadingCoeff_add_eq_left h]\n\n"}
{"name":"AddMonoidAlgebra.supDegree_mem_support","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nhD : Function.Injective D\nhp : Ne p 0\n⊢ Membership.mem p.support (Function.invFun D (AddMonoidAlgebra.supDegree D p))","decl":"lemma supDegree_mem_support (hD : D.Injective) (hp : p ≠ 0) :\n    D.invFun (p.supDegree D) ∈ p.support := by\n  obtain ⟨a, ha, he⟩ := exists_supDegree_mem_support D hp\n  rwa [he, Function.leftInverse_invFun hD]\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_eq_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nhD : Function.Injective D\n⊢ Iff (Eq (AddMonoidAlgebra.leadingCoeff D p) 0) (Eq p 0)","decl":"@[simp]\nlemma leadingCoeff_eq_zero (hD : D.Injective) : p.leadingCoeff D = 0 ↔ p = 0 := by\n  refine ⟨(fun h => ?_).mtr, fun h => h ▸ leadingCoeff_zero⟩\n  rw [leadingCoeff, ← Ne, ← Finsupp.mem_support_iff]\n  exact supDegree_mem_support hD h\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_ne_zero","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\np : AddMonoidAlgebra R A\nD : A → B\ninst✝ : AddZeroClass A\nhD : Function.Injective D\n⊢ Iff (Ne (AddMonoidAlgebra.leadingCoeff D p) 0) (Ne p 0)","decl":"lemma leadingCoeff_ne_zero (hD : D.Injective) : p.leadingCoeff D ≠ 0 ↔ p ≠ 0 :=\n  (leadingCoeff_eq_zero hD).ne\n\n"}
{"name":"AddMonoidAlgebra.supDegree_sub_lt_of_leadingCoeff_eq","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"A : Type u_3\nB : Type u_5\ninst✝³ : LinearOrder B\ninst✝² : OrderBot B\nD : A → B\ninst✝¹ : AddZeroClass A\nhD : Function.Injective D\nR : Type u_8\ninst✝ : CommRing R\np q : AddMonoidAlgebra R A\nhd : Eq (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q)\nhc : Eq (AddMonoidAlgebra.leadingCoeff D p) (AddMonoidAlgebra.leadingCoeff D q)\n⊢ Or (LT.lt (AddMonoidAlgebra.supDegree D (HSub.hSub p q)) (AddMonoidAlgebra.supDegree D p)) (Eq p q)","decl":"lemma supDegree_sub_lt_of_leadingCoeff_eq (hD : D.Injective) {R} [CommRing R] {p q : R[A]}\n    (hd : p.supDegree D = q.supDegree D) (hc : p.leadingCoeff D = q.leadingCoeff D) :\n    (p - q).supDegree D < p.supDegree D ∨ p = q := by\n  rw [or_iff_not_imp_right]\n  refine fun he => (supDegree_sub_le.trans ?_).lt_of_ne ?_\n  · rw [hd, sup_idem]\n  · rw [← sub_eq_zero, ← leadingCoeff_eq_zero hD, leadingCoeff] at he\n    refine fun h => he ?_\n    rwa [h, Finsupp.sub_apply, ← leadingCoeff, hd, ← leadingCoeff, sub_eq_zero]\n\n"}
{"name":"AddMonoidAlgebra.supDegree_leadingCoeff_sum_eq","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\nι : Type u_7\ns : Finset ι\ni : ι\nf : ι → AddMonoidAlgebra R A\ninst✝ : AddZeroClass A\nhi : Membership.mem s i\nhmax : ∀ (j : ι), Membership.mem s j → Ne j i → LT.lt (AddMonoidAlgebra.supDegree D (f j)) (AddMonoidAlgebra.supDegree D (f i))\n⊢ And (Eq (AddMonoidAlgebra.supDegree D (s.sum fun j => f j)) (AddMonoidAlgebra.supDegree D (f i))) (Eq (AddMonoidAlgebra.leadingCoeff D (s.sum fun j => f j)) (AddMonoidAlgebra.leadingCoeff D (f i)))","decl":"lemma supDegree_leadingCoeff_sum_eq\n    (hi : i ∈ s) (hmax : ∀ j ∈ s, j ≠ i → (f j).supDegree D < (f i).supDegree D) :\n    (∑ j ∈ s, f j).supDegree D = (f i).supDegree D ∧\n    (∑ j ∈ s, f j).leadingCoeff D = (f i).leadingCoeff D := by\n  classical\n  rw [← s.add_sum_erase _ hi]\n  by_cases hs : s.erase i = ∅\n  · rw [hs, Finset.sum_empty, add_zero]; exact ⟨rfl, rfl⟩\n  suffices _ from ⟨supDegree_add_eq_left this, leadingCoeff_add_eq_left this⟩\n  refine supDegree_sum_lt ?_ (fun j hj => ?_)\n  · rw [Finset.nonempty_iff_ne_empty]; exact hs\n  · rw [Finset.mem_erase] at hj; exact hmax j hj.2 hj.1\n\n"}
{"name":"AddMonoidAlgebra.sum_ne_zero_of_injOn_supDegree'","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\nι : Type u_7\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\ninst✝ : AddZeroClass A\nhs : Exists fun i => And (Membership.mem s i) (Ne (f i) 0)\nhd : Set.InjOn (Function.comp (AddMonoidAlgebra.supDegree D) f) ↑s\n⊢ Ne (s.sum fun i => f i) 0","decl":"open Finset in\nlemma sum_ne_zero_of_injOn_supDegree' (hs : ∃ i ∈ s, f i ≠ 0)\n    (hd : (s : Set ι).InjOn (supDegree D ∘ f)) :\n    ∑ i ∈ s, f i ≠ 0 := by\n  obtain ⟨j, hj, hne⟩ := hs\n  obtain ⟨i, hi, he⟩ := exists_mem_eq_sup _ ⟨j, hj⟩ (supDegree D ∘ f)\n  by_cases h : ∀ k ∈ s, k = i\n  · refine (sum_eq_single_of_mem j hj (fun k hk hne => ?_)).trans_ne hne\n    rw [h k hk, h j hj] at hne; exact hne.irrefl.elim\n  push_neg at h; obtain ⟨j, hj, hne⟩ := h\n  apply ne_zero_of_supDegree_ne_bot (D := D)\n  have (k) (hk : k ∈ s) (hne : k ≠ i) : supDegree D (f k) < supDegree D (f i) :=\n    ((le_sup hk).trans_eq he).lt_of_ne (hd.ne hk hi hne)\n  rw [(supDegree_leadingCoeff_sum_eq hi this).1]\n  exact (this j hj hne).ne_bot\n\n"}
{"name":"AddMonoidAlgebra.sum_ne_zero_of_injOn_supDegree","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝³ : Semiring R\ninst✝² : LinearOrder B\ninst✝¹ : OrderBot B\nD : A → B\nι : Type u_7\ns : Finset ι\nf : ι → AddMonoidAlgebra R A\ninst✝ : AddZeroClass A\nhs : Ne s EmptyCollection.emptyCollection\nhf : ∀ (i : ι), Membership.mem s i → Ne (f i) 0\nhd : Set.InjOn (Function.comp (AddMonoidAlgebra.supDegree D) f) ↑s\n⊢ Ne (s.sum fun i => f i) 0","decl":"lemma sum_ne_zero_of_injOn_supDegree (hs : s ≠ ∅)\n    (hf : ∀ i ∈ s, f i ≠ 0) (hd : (s : Set ι).InjOn (supDegree D ∘ f)) :\n    ∑ i ∈ s, f i ≠ 0 :=\n  let ⟨i, hi⟩ := Finset.nonempty_iff_ne_empty.2 hs\n  sum_ne_zero_of_injOn_supDegree' ⟨i, hi, hf i hi⟩ hd\n\n"}
{"name":"AddMonoidAlgebra.apply_supDegree_add_supDegree","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\n⊢ Eq ((HMul.hMul p q) (Function.invFun D (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q)))) (HMul.hMul (AddMonoidAlgebra.leadingCoeff D p) (AddMonoidAlgebra.leadingCoeff D q))","decl":"lemma apply_supDegree_add_supDegree (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) :\n    (p * q) (D.invFun (p.supDegree D + q.supDegree D)) = p.leadingCoeff D * q.leadingCoeff D := by\n  obtain rfl | hp := eq_or_ne p 0\n  · simp_rw [leadingCoeff_zero, zero_mul, Finsupp.coe_zero, Pi.zero_apply]\n  obtain rfl | hq := eq_or_ne q 0\n  · simp_rw [leadingCoeff_zero, mul_zero, Finsupp.coe_zero, Pi.zero_apply]\n  obtain ⟨ap, -, hp⟩ := exists_supDegree_mem_support D hp\n  obtain ⟨aq, -, hq⟩ := exists_supDegree_mem_support D hq\n  simp_rw [leadingCoeff, hp, hq, ← hadd, Function.leftInverse_invFun hD _]\n  exact apply_add_of_supDegree_le hadd hD hp.le hq.le\n\n"}
{"name":"AddMonoidAlgebra.supDegree_mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhpq : Ne (HMul.hMul (AddMonoidAlgebra.leadingCoeff D p) (AddMonoidAlgebra.leadingCoeff D q)) 0\nhp : Ne p 0\nhq : Ne q 0\n⊢ Eq (AddMonoidAlgebra.supDegree D (HMul.hMul p q)) (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q))","decl":"lemma supDegree_mul\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hpq : leadingCoeff D p * leadingCoeff D q ≠ 0)\n    (hp : p ≠ 0) (hq : q ≠ 0) :\n    (p * q).supDegree D = p.supDegree D + q.supDegree D := by\n  cases subsingleton_or_nontrivial R; · exact (hp (Subsingleton.elim _ _)).elim\n  apply supDegree_eq_of_max\n  · rw [← AddSubsemigroup.coe_set_mk (Set.range D), ← AddHom.srange_mk _ hadd, SetLike.mem_coe]\n    exact add_mem (supDegree_mem_range D hp) (supDegree_mem_range D hq)\n  · simp_rw [Finsupp.mem_support_iff, apply_supDegree_add_supDegree hD hadd]\n    exact hpq\n  · have := covariantClass_le_of_lt B B (· + ·)\n    have := covariantClass_le_of_lt B B (Function.swap (· + ·))\n    exact fun a ha => (Finset.le_sup ha).trans (supDegree_mul_le hadd)\n\n"}
{"name":"AddMonoidAlgebra.Monic.supDegree_mul_of_ne_zero_left","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhq : AddMonoidAlgebra.Monic D q\nhp : Ne p 0\n⊢ Eq (AddMonoidAlgebra.supDegree D (HMul.hMul p q)) (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q))","decl":"lemma Monic.supDegree_mul_of_ne_zero_left\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hq : q.Monic D) (hp : p ≠ 0) :\n    (p * q).supDegree D = p.supDegree D + q.supDegree D := by\n  cases subsingleton_or_nontrivial R; · exact (hp (Subsingleton.elim _ _)).elim\n  apply supDegree_mul hD hadd ?_ hp hq.ne_zero\n  simp_rw [hq, mul_one, Ne, leadingCoeff_eq_zero hD, hp, not_false_eq_true]\n\n"}
{"name":"AddMonoidAlgebra.Monic.supDegree_mul_of_ne_zero_right","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhp : AddMonoidAlgebra.Monic D p\nhq : Ne q 0\n⊢ Eq (AddMonoidAlgebra.supDegree D (HMul.hMul p q)) (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q))","decl":"lemma Monic.supDegree_mul_of_ne_zero_right\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hp : p.Monic D) (hq : q ≠ 0) :\n    (p * q).supDegree D = p.supDegree D + q.supDegree D := by\n  cases subsingleton_or_nontrivial R; · exact (hq (Subsingleton.elim _ _)).elim\n  apply supDegree_mul hD hadd ?_ hp.ne_zero hq\n  simp_rw [hp, one_mul, Ne, leadingCoeff_eq_zero hD, hq, not_false_eq_true]\n\n"}
{"name":"AddMonoidAlgebra.Monic.supDegree_mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhbot : Eq (HAdd.hAdd Bot.bot Bot.bot) Bot.bot\nhp : AddMonoidAlgebra.Monic D p\nhq : AddMonoidAlgebra.Monic D q\n⊢ Eq (AddMonoidAlgebra.supDegree D (HMul.hMul p q)) (HAdd.hAdd (AddMonoidAlgebra.supDegree D p) (AddMonoidAlgebra.supDegree D q))","decl":"lemma Monic.supDegree_mul\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hbot : (⊥ : B) + ⊥ = ⊥) (hp : p.Monic D) (hq : q.Monic D) :\n    (p * q).supDegree D = p.supDegree D + q.supDegree D := by\n  cases subsingleton_or_nontrivial R\n  · simp_rw [Subsingleton.eq_zero p, Subsingleton.eq_zero q, mul_zero, supDegree_zero, hbot]\n  exact hq.supDegree_mul_of_ne_zero_left hD hadd hp.ne_zero\n\n"}
{"name":"AddMonoidAlgebra.leadingCoeff_mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : LinearOrder B\ninst✝⁵ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝⁴ : AddZeroClass A\ninst✝³ : Add B\ninst✝² : AddLeftStrictMono B\ninst✝¹ : AddRightStrictMono B\ninst✝ : NoZeroDivisors R\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (HMul.hMul p q)) (HMul.hMul (AddMonoidAlgebra.leadingCoeff D p) (AddMonoidAlgebra.leadingCoeff D q))","decl":"lemma leadingCoeff_mul [NoZeroDivisors R]\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) :\n    (p * q).leadingCoeff D = p.leadingCoeff D * q.leadingCoeff D := by\n  obtain rfl | hp := eq_or_ne p 0\n  · simp_rw [leadingCoeff_zero, zero_mul, leadingCoeff_zero]\n  obtain rfl | hq := eq_or_ne q 0\n  · simp_rw [leadingCoeff_zero, mul_zero, leadingCoeff_zero]\n  rw [← apply_supDegree_add_supDegree hD hadd, ← supDegree_mul hD hadd ?_ hp hq, leadingCoeff]\n  apply mul_ne_zero <;> rwa [Ne, leadingCoeff_eq_zero hD]\n\n"}
{"name":"AddMonoidAlgebra.Monic.leadingCoeff_mul_eq_left","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhq : AddMonoidAlgebra.Monic D q\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (HMul.hMul p q)) (AddMonoidAlgebra.leadingCoeff D p)","decl":"lemma Monic.leadingCoeff_mul_eq_left\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) (hq : q.Monic D) :\n    (p * q).leadingCoeff D = p.leadingCoeff D := by\n  obtain rfl | hp := eq_or_ne p 0\n  · rw [zero_mul]\n  rw [leadingCoeff, hq.supDegree_mul_of_ne_zero_left hD hadd hp,\n    apply_supDegree_add_supDegree hD hadd, hq, mul_one]\n\n"}
{"name":"AddMonoidAlgebra.Monic.leadingCoeff_mul_eq_right","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhp : AddMonoidAlgebra.Monic D p\n⊢ Eq (AddMonoidAlgebra.leadingCoeff D (HMul.hMul p q)) (AddMonoidAlgebra.leadingCoeff D q)","decl":"lemma Monic.leadingCoeff_mul_eq_right\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) (hp : p.Monic D) :\n    (p * q).leadingCoeff D = q.leadingCoeff D := by\n  obtain rfl | hq := eq_or_ne q 0\n  · rw [mul_zero]\n  rw [leadingCoeff, hp.supDegree_mul_of_ne_zero_right hD hadd hq,\n    apply_supDegree_add_supDegree hD hadd, hp, one_mul]\n\n"}
{"name":"AddMonoidAlgebra.Monic.mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nB : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder B\ninst✝⁴ : OrderBot B\np q : AddMonoidAlgebra R A\nD : A → B\ninst✝³ : AddZeroClass A\ninst✝² : Add B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nhD : Function.Injective D\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhp : AddMonoidAlgebra.Monic D p\nhq : AddMonoidAlgebra.Monic D q\n⊢ AddMonoidAlgebra.Monic D (HMul.hMul p q)","decl":"lemma Monic.mul\n    (hD : D.Injective) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hp : p.Monic D) (hq : q.Monic D) : (p * q).Monic D := by\n  rw [Monic, hq.leadingCoeff_mul_eq_left hD hadd]; exact hp\n\n"}
{"name":"AddMonoidAlgebra.Monic.pow","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nA : Type u_8\nB : Type u_9\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : LinearOrder B\ninst✝² : OrderBot B\ninst✝¹ : AddLeftStrictMono B\ninst✝ : AddRightStrictMono B\nD : A → B\np : AddMonoidAlgebra R A\nn : Nat\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhD : Function.Injective D\nhp : AddMonoidAlgebra.Monic D p\n⊢ AddMonoidAlgebra.Monic D (HPow.hPow p n)","decl":"lemma Monic.pow\n    (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) (hD : D.Injective)\n    (hp : p.Monic D) : (p ^ n).Monic D := by\n  induction n with\n  | zero => rw [pow_zero]; exact monic_one hD\n  | succ n ih => rw [pow_succ']; exact hp.mul hD hadd ih\n\n"}
{"name":"AddMonoidAlgebra.Monic.supDegree_pow","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nA : Type u_8\nB : Type u_9\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : LinearOrder B\ninst✝³ : OrderBot B\ninst✝² : AddLeftStrictMono B\ninst✝¹ : AddRightStrictMono B\nD : A → B\np : AddMonoidAlgebra R A\nn : Nat\nhzero : Eq (D 0) 0\nhadd : ∀ (a1 a2 : A), Eq (D (HAdd.hAdd a1 a2)) (HAdd.hAdd (D a1) (D a2))\nhD : Function.Injective D\ninst✝ : Nontrivial R\nhp : AddMonoidAlgebra.Monic D p\n⊢ Eq (AddMonoidAlgebra.supDegree D (HPow.hPow p n)) (HSMul.hSMul n (AddMonoidAlgebra.supDegree D p))","decl":"lemma Monic.supDegree_pow\n    (hzero : D 0 = 0) (hadd : ∀ a1 a2, D (a1 + a2) = D a1 + D a2) (hD : D.Injective)\n    [Nontrivial R] (hp : p.Monic D) :\n    (p ^ n).supDegree D = n • p.supDegree D := by\n  induction n with\n  | zero => rw [pow_zero, zero_nsmul, one_def, supDegree_single 0 1, if_neg one_ne_zero, hzero]\n  | succ n ih => rw [pow_succ', (hp.pow hadd hD).supDegree_mul_of_ne_zero_left hD hadd hp.ne_zero,\n      ih, succ_nsmul']\n\n"}
{"name":"AddMonoidAlgebra.le_infDegree_add","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝² : Semiring R\ninst✝¹ : SemilatticeInf T\ninst✝ : OrderTop T\nD : A → T\nf g : AddMonoidAlgebra R A\n⊢ LE.le (Min.min (AddMonoidAlgebra.infDegree D f) (AddMonoidAlgebra.infDegree D g)) (AddMonoidAlgebra.infDegree D (HAdd.hAdd f g))","decl":"theorem le_infDegree_add (f g : R[A]) :\n    (f.infDegree D) ⊓ (g.infDegree D) ≤ (f + g).infDegree D :=\n  le_inf_support_add D f g\n\n"}
{"name":"AddMonoidAlgebra.infDegree_withTop_some_comp","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝² : Semiring R\ninst✝¹ : SemilatticeInf T\ninst✝ : OrderTop T\nD : A → T\ns : AddMonoidAlgebra R A\nhs : s.support.Nonempty\n⊢ Eq (AddMonoidAlgebra.infDegree (Function.comp WithTop.some D) s) ↑(AddMonoidAlgebra.infDegree D s)","decl":"variable {D} in\ntheorem infDegree_withTop_some_comp {s : AddMonoidAlgebra R A} (hs : s.support.Nonempty) :\n    infDegree (WithTop.some ∘ D) s = infDegree D s := by\n  unfold AddMonoidAlgebra.infDegree\n  rw [← Finset.coe_inf' hs, Finset.inf'_eq_inf]\n\n"}
{"name":"AddMonoidAlgebra.le_infDegree_mul","module":"Mathlib.Algebra.MonoidAlgebra.Degree","initialProofState":"R : Type u_1\nA : Type u_3\nT : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : SemilatticeInf T\ninst✝⁴ : OrderTop T\ninst✝³ : AddZeroClass A\ninst✝² : Add T\ninst✝¹ : AddLeftMono T\ninst✝ : AddRightMono T\nD : AddHom A T\nf g : AddMonoidAlgebra R A\n⊢ LE.le (HAdd.hAdd (AddMonoidAlgebra.infDegree (⇑D) f) (AddMonoidAlgebra.infDegree (⇑D) g)) (AddMonoidAlgebra.infDegree (⇑D) (HMul.hMul f g))","decl":"theorem le_infDegree_mul [AddZeroClass A] [Add T] [AddLeftMono T] [AddRightMono T]\n    (D : AddHom A T) (f g : R[A]) :\n    f.infDegree D + g.infDegree D ≤ (f * g).infDegree D :=\n  le_inf_support_mul (fun {a b : A} => (map_add D a b).ge) _ _\n\n"}
