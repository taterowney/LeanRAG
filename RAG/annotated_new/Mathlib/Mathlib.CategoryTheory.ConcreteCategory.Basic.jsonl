{"name":"CategoryTheory.HasForget.forget_faithful","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.HasForget C\n‚ä¢ CategoryTheory.HasForget.forget.Faithful","decl":"/-- A concrete category is a category `C` with a fixed faithful functor `Forget : C ‚•§ Type`.\n\nNote that `HasForget` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `Forget : C ‚•§ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n-/\nclass HasForget (C : Type u) [Category.{v} C] where\n  /-- We have a functor to Type -/\n  protected forget : C ‚•§ Type w\n  /-- That functor is faithful -/\n  [forget_faithful : forget.Faithful]\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hom_ext","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf g : Quiver.Hom X Y\nw : ‚àÄ (x : (CategoryTheory.forget C).obj X), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"/-- In any concrete category, we can test equality of morphisms by pointwise evaluations. -/\n@[ext low] -- Porting note: lowered priority\ntheorem ConcreteCategory.hom_ext {X Y : C} (f g : X ‚ü∂ Y) (w : ‚àÄ x : X, f x = g x) : f = g := by\n  apply (forget C).map_injective\n  dsimp [forget]\n  funext x\n  exact w x\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hom_ext_iff","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : (CategoryTheory.forget C).obj X), Eq (f x) (g x))","decl":"/-- In any concrete category, we can test equality of morphisms by pointwise evaluations. -/\n@[ext low] -- Porting note: lowered priority\ntheorem ConcreteCategory.hom_ext {X Y : C} (f g : X ‚ü∂ Y) (w : ‚àÄ x : X, f x = g x) : f = g := by\n  apply (forget C).map_injective\n  dsimp [forget]\n  funext x\n  exact w x\n\n"}
{"name":"CategoryTheory.forget_map_eq_coe","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget C).map f) ‚áëf","decl":"theorem forget_map_eq_coe {X Y : C} (f : X ‚ü∂ Y) : (forget C).map f = f := rfl\n\n"}
{"name":"CategoryTheory.congr_hom","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq f g\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq (f x) (g x)","decl":"/-- Analogue of `congr_fun h x`,\nwhen `h : f = g` is an equality between morphisms in a concrete category.\n-/\ntheorem congr_hom {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : X) : f x = g x :=\n  congrFun (congrArg (fun k : X ‚ü∂ Y => (k : X ‚Üí Y)) h) x\n\n"}
{"name":"CategoryTheory.coe_id","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX : C\n‚ä¢ Eq (‚áë(CategoryTheory.CategoryStruct.id X)) id","decl":"theorem coe_id {X : C} : (ùüô X : X ‚Üí X) = id :=\n  (forget _).map_id X\n\n"}
{"name":"CategoryTheory.coe_comp","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.CategoryStruct.comp f g)) (Function.comp ‚áëg ‚áëf)","decl":"theorem coe_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g : X ‚Üí Z) = g ‚àò f :=\n  (forget _).map_comp f g\n\n"}
{"name":"CategoryTheory.id_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX : C\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id X) x) x","decl":"@[simp] theorem id_apply {X : C} (x : X) : (ùüô X : X ‚Üí X) x = x :=\n  congr_fun ((forget _).map_id X) x\n\n"}
{"name":"CategoryTheory.comp_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g) x) (g (f x))","decl":"@[simp] theorem comp_apply {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=\n  congr_fun ((forget _).map_comp _ _) x\n\n"}
{"name":"CategoryTheory.comp_apply'","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq ((CategoryTheory.forget C).map (CategoryTheory.CategoryStruct.comp f g) x) ((CategoryTheory.forget C).map g ((CategoryTheory.forget C).map f x))","decl":"/-- Variation of `ConcreteCategory.comp_apply` that uses `forget` instead. -/\ntheorem comp_apply' {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) :\n    (forget C).map (f ‚â´ g) x = (forget C).map g ((forget C).map f x) := comp_apply f g x\n\n"}
{"name":"CategoryTheory.ConcreteCategory.congr_hom","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq f g\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq (f x) (g x)","decl":"theorem ConcreteCategory.congr_hom {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : X) : f x = g x :=\n  congr_fun (congr_arg (fun f : X ‚ü∂ Y => (f : X ‚Üí Y)) h) x\n\n"}
{"name":"CategoryTheory.ConcreteCategory.congr_arg","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\nx x' : (CategoryTheory.forget C).obj X\nh : Eq x x'\n‚ä¢ Eq (f x) (f x')","decl":"theorem ConcreteCategory.congr_arg {X Y : C} (f : X ‚ü∂ Y) {x x' : X} (h : x = x') : f x = f x' :=\n  congrArg (f : X ‚Üí Y) h\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hasCoeToFun_Type","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n‚ä¢ Eq (CoeFun.coe f) f","decl":"@[simp]\ntheorem ConcreteCategory.hasCoeToFun_Type {X Y : Type u} (f : X ‚ü∂ Y) : CoeFun.coe f = f := rfl\n\n"}
{"name":"CategoryTheory.HasForget‚ÇÇ.forget_comp","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.HasForget C\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nself : CategoryTheory.HasForget‚ÇÇ C D\n‚ä¢ Eq (CategoryTheory.HasForget‚ÇÇ.forget‚ÇÇ.comp (CategoryTheory.forget D)) (CategoryTheory.forget C)","decl":"/-- `HasForget‚ÇÇ C D`, where `C` and `D` are both concrete categories, provides a functor\n`forget‚ÇÇ C D : C ‚•§ D` and a proof that `forget‚ÇÇ ‚ãô (forget D) = forget C`.\n-/\nclass HasForget‚ÇÇ (C : Type u) (D : Type u') [Category.{v} C] [HasForget.{w} C]\n  [Category.{v'} D] [HasForget.{w} D] where\n  /-- A functor from `C` to `D` -/\n  forget‚ÇÇ : C ‚•§ D\n  /-- It covers the `HasForget.forget` for `C` and `D` -/\n  forget_comp : forget‚ÇÇ ‚ãô forget D = forget C := by aesop\n\n"}
{"name":"CategoryTheory.forget‚ÇÇ_comp_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\nD : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.HasForget C\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\ninst‚úù : CategoryTheory.HasForget‚ÇÇ C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : (CategoryTheory.forget D).obj ((CategoryTheory.forget‚ÇÇ C D).obj X)\n‚ä¢ Eq (((CategoryTheory.forget‚ÇÇ C D).map (CategoryTheory.CategoryStruct.comp f g)) x) (((CategoryTheory.forget‚ÇÇ C D).map g) (((CategoryTheory.forget‚ÇÇ C D).map f) x))","decl":"lemma forget‚ÇÇ_comp_apply {C : Type u} {D : Type u'} [Category.{v} C] [HasForget.{w} C]\n    [Category.{v'} D] [HasForget.{w} D] [HasForget‚ÇÇ C D] {X Y Z : C}\n    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : (forget‚ÇÇ C D).obj X) :\n    ((forget‚ÇÇ C D).map (f ‚â´ g) x) =\n      (forget‚ÇÇ C D).map g ((forget‚ÇÇ C D).map f x) := by\n  rw [Functor.map_comp, comp_apply]\n\n"}
{"name":"CategoryTheory.forget‚ÇÇ_faithful","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\nD : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.HasForget C\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\ninst‚úù : CategoryTheory.HasForget‚ÇÇ C D\n‚ä¢ (CategoryTheory.forget‚ÇÇ C D).Faithful","decl":"instance forget‚ÇÇ_faithful (C : Type u) (D : Type u') [Category.{v} C] [HasForget.{w} C]\n    [Category.{v'} D] [HasForget.{w} D] [HasForget‚ÇÇ C D] : (forget‚ÇÇ C D).Faithful :=\n  HasForget‚ÇÇ.forget_comp.faithful_of_comp\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù : CategoryTheory.HasForget D\nF G : CategoryTheory.Functor C D\nœÜ : Quiver.Hom F G\nX Y : C\nf : Quiver.Hom X Y\nx : (CategoryTheory.forget D).obj (F.obj X)\n‚ä¢ Eq ((œÜ.app Y) ((F.map f) x)) ((G.map f) ((œÜ.app X) x))","decl":"@[simp]\nlemma NatTrans.naturality_apply {C D : Type*} [Category C] [Category D] [HasForget D]\n    {F G : C ‚•§ D} (œÜ : F ‚ü∂ G) {X Y : C} (f : X ‚ü∂ Y) (x : F.obj X) :\n    œÜ.app Y (F.map f x) = G.map f (œÜ.app X x) := by\n  simpa only [Functor.map_comp] using congr_fun ((forget D).congr_map (œÜ.naturality f)) x\n\n"}
{"name":"CategoryTheory.ConcreteCategory.comp_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nFC : outParam (C ‚Üí C ‚Üí Type u_1)\nCC : outParam (C ‚Üí Type w)\ninst‚úù : outParam ((X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y))\nself : CategoryTheory.ConcreteCategory C FC\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : CC X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"/-- A concrete category is a category `C` where objects correspond to types and morphisms to\n(bundled) functions between those types.\n\nIn other words, it has a fixed faithful functor `forget : C ‚•§ Type`.\n\nNote that `ConcreteCategory` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `forget : C ‚•§ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n-/\nclass ConcreteCategory (C : Type u) [Category.{v} C]\n    (FC : outParam <| C ‚Üí C ‚Üí Type*) {CC : outParam <| C ‚Üí Type w}\n    [outParam <| ‚àÄ X Y, FunLike (FC X Y) (CC X) (CC Y)] where\n  /-- Convert a morphism of `C` to a bundled function. -/\n  (hom : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí FC X Y)\n  /-- Convert a bundled function to a morphism of `C`. -/\n  (ofHom : ‚àÄ {X Y}, FC X Y ‚Üí (X ‚ü∂ Y))\n  (hom_ofHom : ‚àÄ {X Y} (f : FC X Y), hom (ofHom f) = f := by aesop_cat)\n  (ofHom_hom : ‚àÄ {X Y} (f : X ‚ü∂ Y), ofHom (hom f) = f := by aesop_cat)\n  (id_apply : ‚àÄ {X} (x : CC X), hom (ùüô X) x = x := by aesop_cat)\n  (comp_apply : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : CC X),\n    hom (f ‚â´ g) x = hom g (hom f x) := by aesop_cat)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.id_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nFC : outParam (C ‚Üí C ‚Üí Type u_1)\nCC : outParam (C ‚Üí Type w)\ninst‚úù : outParam ((X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y))\nself : CategoryTheory.ConcreteCategory C FC\nX : C\nx : CC X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X)) x) x","decl":"/-- A concrete category is a category `C` where objects correspond to types and morphisms to\n(bundled) functions between those types.\n\nIn other words, it has a fixed faithful functor `forget : C ‚•§ Type`.\n\nNote that `ConcreteCategory` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `forget : C ‚•§ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n-/\nclass ConcreteCategory (C : Type u) [Category.{v} C]\n    (FC : outParam <| C ‚Üí C ‚Üí Type*) {CC : outParam <| C ‚Üí Type w}\n    [outParam <| ‚àÄ X Y, FunLike (FC X Y) (CC X) (CC Y)] where\n  /-- Convert a morphism of `C` to a bundled function. -/\n  (hom : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí FC X Y)\n  /-- Convert a bundled function to a morphism of `C`. -/\n  (ofHom : ‚àÄ {X Y}, FC X Y ‚Üí (X ‚ü∂ Y))\n  (hom_ofHom : ‚àÄ {X Y} (f : FC X Y), hom (ofHom f) = f := by aesop_cat)\n  (ofHom_hom : ‚àÄ {X Y} (f : X ‚ü∂ Y), ofHom (hom f) = f := by aesop_cat)\n  (id_apply : ‚àÄ {X} (x : CC X), hom (ùüô X) x = x := by aesop_cat)\n  (comp_apply : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : CC X),\n    hom (f ‚â´ g) x = hom g (hom f x) := by aesop_cat)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hom_ofHom","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nFC : outParam (C ‚Üí C ‚Üí Type u_1)\nCC : outParam (C ‚Üí Type w)\ninst‚úù : outParam ((X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y))\nself : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf : FC X Y\n‚ä¢ Eq (CategoryTheory.ConcreteCategory.hom (CategoryTheory.ConcreteCategory.ofHom f)) f","decl":"/-- A concrete category is a category `C` where objects correspond to types and morphisms to\n(bundled) functions between those types.\n\nIn other words, it has a fixed faithful functor `forget : C ‚•§ Type`.\n\nNote that `ConcreteCategory` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `forget : C ‚•§ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n-/\nclass ConcreteCategory (C : Type u) [Category.{v} C]\n    (FC : outParam <| C ‚Üí C ‚Üí Type*) {CC : outParam <| C ‚Üí Type w}\n    [outParam <| ‚àÄ X Y, FunLike (FC X Y) (CC X) (CC Y)] where\n  /-- Convert a morphism of `C` to a bundled function. -/\n  (hom : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí FC X Y)\n  /-- Convert a bundled function to a morphism of `C`. -/\n  (ofHom : ‚àÄ {X Y}, FC X Y ‚Üí (X ‚ü∂ Y))\n  (hom_ofHom : ‚àÄ {X Y} (f : FC X Y), hom (ofHom f) = f := by aesop_cat)\n  (ofHom_hom : ‚àÄ {X Y} (f : X ‚ü∂ Y), ofHom (hom f) = f := by aesop_cat)\n  (id_apply : ‚àÄ {X} (x : CC X), hom (ùüô X) x = x := by aesop_cat)\n  (comp_apply : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : CC X),\n    hom (f ‚â´ g) x = hom g (hom f x) := by aesop_cat)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.ofHom_hom","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nFC : outParam (C ‚Üí C ‚Üí Type u_1)\nCC : outParam (C ‚Üí Type w)\ninst‚úù : outParam ((X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y))\nself : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.ConcreteCategory.ofHom (CategoryTheory.ConcreteCategory.hom f)) f","decl":"/-- A concrete category is a category `C` where objects correspond to types and morphisms to\n(bundled) functions between those types.\n\nIn other words, it has a fixed faithful functor `forget : C ‚•§ Type`.\n\nNote that `ConcreteCategory` potentially depends on three independent universe levels,\n* the universe level `w` appearing in `forget : C ‚•§ Type w`\n* the universe level `v` of the morphisms (i.e. we have a `Category.{v} C`)\n* the universe level `u` of the objects (i.e `C : Type u`)\nThey are specified that order, to avoid unnecessary universe annotations.\n-/\nclass ConcreteCategory (C : Type u) [Category.{v} C]\n    (FC : outParam <| C ‚Üí C ‚Üí Type*) {CC : outParam <| C ‚Üí Type w}\n    [outParam <| ‚àÄ X Y, FunLike (FC X Y) (CC X) (CC Y)] where\n  /-- Convert a morphism of `C` to a bundled function. -/\n  (hom : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí FC X Y)\n  /-- Convert a bundled function to a morphism of `C`. -/\n  (ofHom : ‚àÄ {X Y}, FC X Y ‚Üí (X ‚ü∂ Y))\n  (hom_ofHom : ‚àÄ {X Y} (f : FC X Y), hom (ofHom f) = f := by aesop_cat)\n  (ofHom_hom : ‚àÄ {X Y} (f : X ‚ü∂ Y), ofHom (hom f) = f := by aesop_cat)\n  (id_apply : ‚àÄ {X} (x : CC X), hom (ùüô X) x = x := by aesop_cat)\n  (comp_apply : ‚àÄ {X Y Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : CC X),\n    hom (f ‚â´ g) x = hom g (hom f x) := by aesop_cat)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hom_bijective","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\n‚ä¢ Function.Bijective CategoryTheory.ConcreteCategory.hom","decl":"lemma hom_bijective {X Y : C} : Function.Bijective (hom : (X ‚ü∂ Y) ‚Üí ToHom X Y) :=\n  homEquiv.bijective\n\n"}
{"name":"CategoryTheory.ConcreteCategory.hom_injective","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\n‚ä¢ Function.Injective CategoryTheory.ConcreteCategory.hom","decl":"lemma hom_injective {X Y : C} : Function.Injective (hom : (X ‚ü∂ Y) ‚Üí ToHom X Y) :=\n  hom_bijective.injective\n\n"}
{"name":"CategoryTheory.ConcreteCategory.ext_iff","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (CategoryTheory.ConcreteCategory.hom f) (CategoryTheory.ConcreteCategory.hom g))","decl":"/-- In any concrete category, we can test equality of morphisms by pointwise evaluations. -/\n@[ext] lemma ext {X Y : C} {f g : X ‚ü∂ Y} (h : hom f = hom g) : f = g :=\n  hom_injective h\n\n"}
{"name":"CategoryTheory.ConcreteCategory.ext","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq (CategoryTheory.ConcreteCategory.hom f) (CategoryTheory.ConcreteCategory.hom g)\n‚ä¢ Eq f g","decl":"/-- In any concrete category, we can test equality of morphisms by pointwise evaluations. -/\n@[ext] lemma ext {X Y : C} {f g : X ‚ü∂ Y} (h : hom f = hom g) : f = g :=\n  hom_injective h\n\n"}
{"name":"CategoryTheory.ConcreteCategory.coe_ext","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq ‚áë(CategoryTheory.ConcreteCategory.hom f) ‚áë(CategoryTheory.ConcreteCategory.hom g)\n‚ä¢ Eq f g","decl":"lemma coe_ext {X Y : C} {f g : X ‚ü∂ Y} (h : ‚áë(hom f) = ‚áë(hom g)) : f = g :=\n  ext (DFunLike.coe_injective h)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.ext_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf g : Quiver.Hom X Y\nh : ‚àÄ (x : CC X), Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)\n‚ä¢ Eq f g","decl":"lemma ext_apply {X Y : C} {f g : X ‚ü∂ Y} (h : ‚àÄ x, f x = g x) : f = g :=\n  ext (DFunLike.ext _ _ h)\n\n"}
{"name":"CategoryTheory.forget_obj","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX : C\n‚ä¢ Eq ((CategoryTheory.forget C).obj X) (CategoryTheory.ToType X)","decl":"theorem forget_obj (X : C) : (forget C).obj X = ToType X := by\n  with_reducible_and_instances rfl\n\n"}
{"name":"CategoryTheory.ConcreteCategory.forget_map_eq_coe","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget C).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"@[simp]\ntheorem ConcreteCategory.forget_map_eq_coe {X Y : C} (f : X ‚ü∂ Y) : (forget C).map f = f := by\n  with_reducible_and_instances rfl\n\n"}
{"name":"CategoryTheory.congr_fun","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq f g\nx : CategoryTheory.ToType X\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom g) x)","decl":"/-- Analogue of `congr_fun h x`,\nwhen `h : f = g` is an equality between morphisms in a concrete category.\n-/\nprotected theorem congr_fun {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : ToType X) : f x = g x :=\n  congrFun (congrArg (fun k : X ‚ü∂ Y => (k : ToType X ‚Üí ToType Y)) h) x\n\n"}
{"name":"CategoryTheory.congr_arg","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf : Quiver.Hom X Y\nx x' : CategoryTheory.ToType X\nh : Eq x x'\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom f) x) ((CategoryTheory.ConcreteCategory.hom f) x')","decl":"/-- Analogue of `congr_arg f h`,\nwhen `h : x = x'` is an equality between elements of objects in a concrete category.\n-/\nprotected theorem congr_arg {X Y : C} (f : X ‚ü∂ Y) {x x' : ToType X} (h : x = x') : f x = f x' :=\n  congrArg (f : ToType X ‚Üí ToType Y) h\n\n"}
{"name":"CategoryTheory.hom_id","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX : C\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id X))) id","decl":"theorem hom_id {X : C} : (ùüô X : ToType X ‚Üí ToType X) = id :=\n  (forget _).map_id X\n\n"}
{"name":"CategoryTheory.hom_comp","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nFC : C ‚Üí C ‚Üí Type u_1\nCC : C ‚Üí Type w\ninst‚úù¬π : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (‚áë(CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g))) (Function.comp ‚áë(CategoryTheory.ConcreteCategory.hom g) ‚áë(CategoryTheory.ConcreteCategory.hom f))","decl":"theorem hom_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g : ToType X ‚Üí ToType Z) = g ‚àò f :=\n  (forget _).map_comp f g\n\n"}
{"name":"CategoryTheory.coe_toHasForget_instFunLike","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} C\nFC : C ‚Üí C ‚Üí Type u_3\nCC : C ‚Üí Type u_4\ninst : (X Y : C) ‚Üí FunLike (FC X Y) (CC X) (CC Y)\ninst‚úù : CategoryTheory.ConcreteCategory C FC\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ‚áëf ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"/-- Using the `FunLike` coercion of `HasForget` does the same as the original coercion.\n-/\ntheorem coe_toHasForget_instFunLike {C : Type*} [Category C] {FC : C ‚Üí C ‚Üí Type*} {CC : C ‚Üí Type*}\n    [inst : ‚àÄ X Y : C, FunLike (FC X Y) (CC X) (CC Y)] [ConcreteCategory C FC] {X Y : C}\n    (f : X ‚ü∂ Y) :\n    @DFunLike.coe (X ‚ü∂ Y) (ToType X) (fun _ => ToType Y) HasForget.instFunLike f = f := rfl\n\n"}
{"name":"CategoryTheory.forget_eq_ConcreteCategory_hom","module":"Mathlib.CategoryTheory.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget C).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"/--\nNote that the `ConcreteCategory` and `HasForget` instances here differ from `forget_map_eq_coe`.\n-/\ntheorem forget_eq_ConcreteCategory_hom [HasForget C] {X Y : C} (f : X ‚ü∂ Y) :\n    (forget C).map f = @ConcreteCategory.hom _ _ _ _ _ (HasForget.toConcreteCategory C) _ _ f := by\n  with_reducible_and_instances rfl\n\n"}
