{"name":"Nat.prime_mul_iff","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"a b : Nat\n⊢ Iff (Nat.Prime (HMul.hMul a b)) (Or (And (Nat.Prime a) (Eq b 1)) (And (Nat.Prime b) (Eq a 1)))","decl":"theorem prime_mul_iff {a b : ℕ} : Nat.Prime (a * b) ↔ a.Prime ∧ b = 1 ∨ b.Prime ∧ a = 1 := by\n  simp only [irreducible_mul_iff, ← irreducible_iff_nat_prime, Nat.isUnit_iff]\n\n"}
{"name":"Nat.not_prime_mul","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"a b : Nat\na1 : Ne a 1\nb1 : Ne b 1\n⊢ Not (Nat.Prime (HMul.hMul a b))","decl":"theorem not_prime_mul {a b : ℕ} (a1 : a ≠ 1) (b1 : b ≠ 1) : ¬Prime (a * b) := by\n  simp [prime_mul_iff, _root_.not_or, *]\n\n"}
{"name":"Nat.not_prime_mul'","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"a b n : Nat\nh : Eq (HMul.hMul a b) n\nh₁ : Ne a 1\nh₂ : Ne b 1\n⊢ Not (Nat.Prime n)","decl":"theorem not_prime_mul' {a b n : ℕ} (h : a * b = n) (h₁ : a ≠ 1) (h₂ : b ≠ 1) : ¬Prime n :=\n  h ▸ not_prime_mul h₁ h₂\n\n"}
{"name":"Nat.Prime.dvd_iff_eq","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p a : Nat\nhp : Nat.Prime p\na1 : Ne a 1\n⊢ Iff (Dvd.dvd a p) (Eq p a)","decl":"theorem Prime.dvd_iff_eq {p a : ℕ} (hp : p.Prime) (a1 : a ≠ 1) : a ∣ p ↔ p = a := by\n  refine ⟨?_, by rintro rfl; rfl⟩\n  rintro ⟨j, rfl⟩\n  rcases prime_mul_iff.mp hp with (⟨_, rfl⟩ | ⟨_, rfl⟩)\n  · exact mul_one _\n  · exact (a1 rfl).elim\n\n"}
{"name":"Nat.Prime.eq_two_or_odd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Or (Eq p 2) (Eq (HMod.hMod p 2) 1)","decl":"theorem Prime.eq_two_or_odd {p : ℕ} (hp : Prime p) : p = 2 ∨ p % 2 = 1 :=\n  p.mod_two_eq_zero_or_one.imp_left fun h =>\n    ((hp.eq_one_or_self_of_dvd 2 (dvd_of_mod_eq_zero h)).resolve_left (by decide)).symm\n\n"}
{"name":"Nat.Prime.eq_two_or_odd'","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Or (Eq p 2) (Odd p)","decl":"theorem Prime.eq_two_or_odd' {p : ℕ} (hp : Prime p) : p = 2 ∨ Odd p :=\n  Or.imp_right (fun h => ⟨p / 2, (div_add_mod p 2).symm.trans (congr_arg _ h)⟩) hp.eq_two_or_odd\n\n"}
{"name":"Nat.Prime.five_le_of_ne_two_of_ne_three","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\nh_two : Ne p 2\nh_three : Ne p 3\n⊢ LE.le 5 p","decl":"theorem Prime.five_le_of_ne_two_of_ne_three {p : ℕ} (hp : p.Prime) (h_two : p ≠ 2)\n    (h_three : p ≠ 3) : 5 ≤ p := by\n  by_contra! h\n  revert h_two h_three hp\n  decide +revert\n\n"}
{"name":"Nat.Prime.pred_pos","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ LT.lt 0 p.pred","decl":"theorem Prime.pred_pos {p : ℕ} (pp : Prime p) : 0 < pred p :=\n  lt_pred_iff.2 pp.one_lt\n\n"}
{"name":"Nat.succ_pred_prime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ Eq p.pred.succ p","decl":"theorem succ_pred_prime {p : ℕ} (pp : Prime p) : succ (pred p) = p :=\n  succ_pred_eq_of_pos pp.pos\n\n"}
{"name":"Nat.exists_dvd_of_not_prime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\nn2 : LE.le 2 n\nnp : Not (Nat.Prime n)\n⊢ Exists fun m => And (Dvd.dvd m n) (And (Ne m 1) (Ne m n))","decl":"theorem exists_dvd_of_not_prime {n : ℕ} (n2 : 2 ≤ n) (np : ¬Prime n) : ∃ m, m ∣ n ∧ m ≠ 1 ∧ m ≠ n :=\n  ⟨minFac n, minFac_dvd _, ne_of_gt (minFac_prime (ne_of_gt n2)).one_lt,\n    ne_of_lt <| (not_prime_iff_minFac_lt n2).1 np⟩\n\n"}
{"name":"Nat.exists_dvd_of_not_prime2","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\nn2 : LE.le 2 n\nnp : Not (Nat.Prime n)\n⊢ Exists fun m => And (Dvd.dvd m n) (And (LE.le 2 m) (LT.lt m n))","decl":"theorem exists_dvd_of_not_prime2 {n : ℕ} (n2 : 2 ≤ n) (np : ¬Prime n) :\n    ∃ m, m ∣ n ∧ 2 ≤ m ∧ m < n :=\n  ⟨minFac n, minFac_dvd _, (minFac_prime (ne_of_gt n2)).two_le,\n    (not_prime_iff_minFac_lt n2).1 np⟩\n\n"}
{"name":"Nat.not_prime_of_dvd_of_ne","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"m n : Nat\nh1 : Dvd.dvd m n\nh2 : Ne m 1\nh3 : Ne m n\n⊢ Not (Nat.Prime n)","decl":"theorem not_prime_of_dvd_of_ne {m n : ℕ} (h1 : m ∣ n) (h2 : m ≠ 1) (h3 : m ≠ n) : ¬Prime n :=\n  fun h => Or.elim (h.eq_one_or_self_of_dvd m h1) h2 h3\n\n"}
{"name":"Nat.not_prime_of_dvd_of_lt","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"m n : Nat\nh1 : Dvd.dvd m n\nh2 : LE.le 2 m\nh3 : LT.lt m n\n⊢ Not (Nat.Prime n)","decl":"theorem not_prime_of_dvd_of_lt {m n : ℕ} (h1 : m ∣ n) (h2 : 2 ≤ m) (h3 : m < n) : ¬Prime n :=\n  not_prime_of_dvd_of_ne h1 (ne_of_gt h2) (ne_of_lt h3)\n\n"}
{"name":"Nat.not_prime_iff_exists_dvd_ne","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ Iff (Not (Nat.Prime n)) (Exists fun m => And (Dvd.dvd m n) (And (Ne m 1) (Ne m n)))","decl":"theorem not_prime_iff_exists_dvd_ne {n : ℕ} (h : 2 ≤ n) : (¬Prime n) ↔ ∃ m, m ∣ n ∧ m ≠ 1 ∧ m ≠ n :=\n  ⟨exists_dvd_of_not_prime h, fun ⟨_, h1, h2, h3⟩ => not_prime_of_dvd_of_ne h1 h2 h3⟩\n\n"}
{"name":"Nat.not_prime_iff_exists_dvd_lt","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\nh : LE.le 2 n\n⊢ Iff (Not (Nat.Prime n)) (Exists fun m => And (Dvd.dvd m n) (And (LE.le 2 m) (LT.lt m n)))","decl":"theorem not_prime_iff_exists_dvd_lt {n : ℕ} (h : 2 ≤ n) : (¬Prime n) ↔ ∃ m, m ∣ n ∧ 2 ≤ m ∧ m < n :=\n  ⟨exists_dvd_of_not_prime2 h, fun ⟨_, h1, h2, h3⟩ => not_prime_of_dvd_of_lt h1 h2 h3⟩\n\n"}
{"name":"Nat.dvd_of_forall_prime_mul_dvd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"a b : Nat\nhdvd : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p a → Dvd.dvd (HMul.hMul p a) b\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_forall_prime_mul_dvd {a b : ℕ}\n    (hdvd : ∀ p : ℕ, p.Prime → p ∣ a → p * a ∣ b) : a ∣ b := by\n  obtain rfl | ha := eq_or_ne a 1\n  · apply one_dvd\n  obtain ⟨p, hp⟩ := exists_prime_and_dvd ha\n  exact _root_.trans (dvd_mul_left a p) (hdvd p hp.1 hp.2)\n\n"}
{"name":"Nat.Prime.even_iff","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Iff (Even p) (Eq p 2)","decl":"theorem Prime.even_iff {p : ℕ} (hp : Prime p) : Even p ↔ p = 2 := by\n  rw [even_iff_two_dvd, prime_dvd_prime_iff_eq prime_two hp, eq_comm]\n\n"}
{"name":"Nat.Prime.odd_of_ne_two","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\nh_two : Ne p 2\n⊢ Odd p","decl":"theorem Prime.odd_of_ne_two {p : ℕ} (hp : p.Prime) (h_two : p ≠ 2) : Odd p :=\n  hp.eq_two_or_odd'.resolve_left h_two\n\n"}
{"name":"Nat.Prime.even_sub_one","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\nh2 : Ne p 2\n⊢ Even (HSub.hSub p 1)","decl":"theorem Prime.even_sub_one {p : ℕ} (hp : p.Prime) (h2 : p ≠ 2) : Even (p - 1) :=\n  let ⟨n, hn⟩ := hp.odd_of_ne_two h2; ⟨n, by rw [hn, Nat.add_sub_cancel, two_mul]⟩\n\n"}
{"name":"Nat.Prime.mod_two_eq_one_iff_ne_two","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Iff (Eq (HMod.hMod p 2) 1) (Ne p 2)","decl":"/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem Prime.mod_two_eq_one_iff_ne_two {p : ℕ} [Fact p.Prime] : p % 2 = 1 ↔ p ≠ 2 := by\n  refine ⟨fun h hf => ?_, (Nat.Prime.eq_two_or_odd <| @Fact.out p.Prime _).resolve_left⟩\n  rw [hf] at h\n  simp at h\n\n"}
{"name":"Nat.coprime_of_dvd'","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"m n : Nat\nH : ∀ (k : Nat), Nat.Prime k → Dvd.dvd k m → Dvd.dvd k n → Dvd.dvd k 1\n⊢ m.Coprime n","decl":"theorem coprime_of_dvd' {m n : ℕ} (H : ∀ k, Prime k → k ∣ m → k ∣ n → k ∣ 1) : Coprime m n :=\n  coprime_of_dvd fun k kp km kn => not_le_of_gt kp.one_lt <| le_of_dvd Nat.one_pos <| H k kp km kn\n\n"}
{"name":"Nat.Prime.dvd_iff_not_coprime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p n : Nat\npp : Nat.Prime p\n⊢ Iff (Dvd.dvd p n) (Not (p.Coprime n))","decl":"theorem Prime.dvd_iff_not_coprime {p n : ℕ} (pp : Prime p) : p ∣ n ↔ ¬Coprime p n :=\n  iff_not_comm.2 pp.coprime_iff_not_dvd\n\n"}
{"name":"Nat.Prime.not_coprime_iff_dvd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"m n : Nat\n⊢ Iff (Not (m.Coprime n)) (Exists fun p => And (Nat.Prime p) (And (Dvd.dvd p m) (Dvd.dvd p n)))","decl":"theorem Prime.not_coprime_iff_dvd {m n : ℕ} : ¬Coprime m n ↔ ∃ p, Prime p ∧ p ∣ m ∧ p ∣ n := by\n  apply Iff.intro\n  · intro h\n    exact\n      ⟨minFac (gcd m n), minFac_prime h, (minFac_dvd (gcd m n)).trans (gcd_dvd_left m n),\n        (minFac_dvd (gcd m n)).trans (gcd_dvd_right m n)⟩\n  · intro h\n    cases' h with p hp\n    apply Nat.not_coprime_of_dvd_of_dvd (Prime.one_lt hp.1) hp.2.1 hp.2.2\n\n"}
{"name":"Nat.Prime.not_dvd_mul","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p m n : Nat\npp : Nat.Prime p\nHm : Not (Dvd.dvd p m)\nHn : Not (Dvd.dvd p n)\n⊢ Not (Dvd.dvd p (HMul.hMul m n))","decl":"theorem Prime.not_dvd_mul {p m n : ℕ} (pp : Prime p) (Hm : ¬p ∣ m) (Hn : ¬p ∣ n) : ¬p ∣ m * n :=\n  mt pp.dvd_mul.1 <| by simp [Hm, Hn]\n\n"}
{"name":"Nat.coprime_two_left","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\n⊢ Iff (Nat.Coprime 2 n) (Odd n)","decl":"@[simp] lemma coprime_two_left : Coprime 2 n ↔ Odd n := by\n  rw [prime_two.coprime_iff_not_dvd, ← not_even_iff_odd, even_iff_two_dvd]\n\n"}
{"name":"Nat.coprime_two_right","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\n⊢ Iff (n.Coprime 2) (Odd n)","decl":"@[simp] lemma coprime_two_right : n.Coprime 2 ↔ Odd n := coprime_comm.trans coprime_two_left\n\n"}
{"name":"Odd.coprime_two_left","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\na✝ : Odd n\n⊢ Nat.Coprime 2 n","decl":"protected alias ⟨Coprime.odd_of_left, _root_.Odd.coprime_two_left⟩ := coprime_two_left\n"}
{"name":"Nat.Coprime.odd_of_left","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\na✝ : Nat.Coprime 2 n\n⊢ Odd n","decl":"protected alias ⟨Coprime.odd_of_left, _root_.Odd.coprime_two_left⟩ := coprime_two_left\n"}
{"name":"Odd.coprime_two_right","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\na✝ : Odd n\n⊢ n.Coprime 2","decl":"protected alias ⟨Coprime.odd_of_right, _root_.Odd.coprime_two_right⟩ := coprime_two_right\n\n"}
{"name":"Nat.Coprime.odd_of_right","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\na✝ : n.Coprime 2\n⊢ Odd n","decl":"protected alias ⟨Coprime.odd_of_right, _root_.Odd.coprime_two_right⟩ := coprime_two_right\n\n"}
{"name":"Nat.Prime.dvd_of_dvd_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p m n : Nat\npp : Nat.Prime p\nh : Dvd.dvd p (HPow.hPow m n)\n⊢ Dvd.dvd p m","decl":"theorem Prime.dvd_of_dvd_pow {p m n : ℕ} (pp : Prime p) (h : p ∣ m ^ n) : p ∣ m :=\n  pp.prime.dvd_of_dvd_pow h\n\n"}
{"name":"Nat.Prime.not_prime_pow'","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"x n : Nat\nhn : Ne n 1\n⊢ Not (Nat.Prime (HPow.hPow x n))","decl":"theorem Prime.not_prime_pow' {x n : ℕ} (hn : n ≠ 1) : ¬(x ^ n).Prime :=\n  not_irreducible_pow hn\n\n"}
{"name":"Nat.Prime.not_prime_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"x n : Nat\nhn : LE.le 2 n\n⊢ Not (Nat.Prime (HPow.hPow x n))","decl":"theorem Prime.not_prime_pow {x n : ℕ} (hn : 2 ≤ n) : ¬(x ^ n).Prime :=\n  not_prime_pow' ((two_le_iff _).mp hn).2\n\n"}
{"name":"Nat.Prime.eq_one_of_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"x n : Nat\nh : Nat.Prime (HPow.hPow x n)\n⊢ Eq n 1","decl":"theorem Prime.eq_one_of_pow {x n : ℕ} (h : (x ^ n).Prime) : n = 1 :=\n  not_imp_not.mp Prime.not_prime_pow' h\n\n"}
{"name":"Nat.Prime.pow_eq_iff","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p a k : Nat\nhp : Nat.Prime p\n⊢ Iff (Eq (HPow.hPow a k) p) (And (Eq a p) (Eq k 1))","decl":"theorem Prime.pow_eq_iff {p a k : ℕ} (hp : p.Prime) : a ^ k = p ↔ a = p ∧ k = 1 := by\n  refine ⟨fun h => ?_, fun h => by rw [h.1, h.2, pow_one]⟩\n  rw [← h] at hp\n  rw [← h, hp.eq_one_of_pow, eq_self_iff_true, _root_.and_true, pow_one]\n\n"}
{"name":"Nat.Prime.mul_eq_prime_sq_iff","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"x y p : Nat\nhp : Nat.Prime p\nhx : Ne x 1\nhy : Ne y 1\n⊢ Iff (Eq (HMul.hMul x y) (HPow.hPow p 2)) (And (Eq x p) (Eq y p))","decl":"theorem Prime.mul_eq_prime_sq_iff {x y p : ℕ} (hp : p.Prime) (hx : x ≠ 1) (hy : y ≠ 1) :\n    x * y = p ^ 2 ↔ x = p ∧ y = p := by\n  refine ⟨fun h => ?_, fun ⟨h₁, h₂⟩ => h₁.symm ▸ h₂.symm ▸ (sq _).symm⟩\n  have pdvdxy : p ∣ x * y := by rw [h]; simp [sq]\n  -- Could be `wlog := hp.dvd_mul.1 pdvdxy using x y`, but that imports more than we want.\n  suffices ∀ x' y' : ℕ, x' ≠ 1 → y' ≠ 1 → x' * y' = p ^ 2 → p ∣ x' → x' = p ∧ y' = p by\n    obtain hx | hy := hp.dvd_mul.1 pdvdxy <;>\n      [skip; rw [And.comm]] <;>\n      [skip; rw [mul_comm] at h pdvdxy] <;>\n      apply this <;>\n      assumption\n  rintro x y hx hy h ⟨a, ha⟩\n  have : a ∣ p := ⟨y, by rwa [ha, sq, mul_assoc, mul_right_inj' hp.ne_zero, eq_comm] at h⟩\n  obtain ha1 | hap := (Nat.dvd_prime hp).mp ‹a ∣ p›\n  · subst ha1\n    rw [mul_one] at ha\n    subst ha\n    simp only [sq, mul_right_inj' hp.ne_zero] at h\n    subst h\n    exact ⟨rfl, rfl⟩\n  · refine (hy ?_).elim\n    subst hap\n    subst ha\n    rw [sq, Nat.mul_right_eq_self_iff (Nat.mul_pos hp.pos hp.pos : 0 < a * a)] at h\n    exact h\n\n"}
{"name":"Nat.Prime.coprime_pow_of_not_dvd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p m a : Nat\npp : Nat.Prime p\nh : Not (Dvd.dvd p a)\n⊢ a.Coprime (HPow.hPow p m)","decl":"theorem Prime.coprime_pow_of_not_dvd {p m a : ℕ} (pp : Prime p) (h : ¬p ∣ a) : Coprime a (p ^ m) :=\n  (pp.coprime_iff_not_dvd.2 h).symm.pow_right _\n\n"}
{"name":"Nat.coprime_primes","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p q : Nat\npp : Nat.Prime p\npq : Nat.Prime q\n⊢ Iff (p.Coprime q) (Ne p q)","decl":"theorem coprime_primes {p q : ℕ} (pp : Prime p) (pq : Prime q) : Coprime p q ↔ p ≠ q :=\n  pp.coprime_iff_not_dvd.trans <| not_congr <| dvd_prime_two_le pq pp.two_le\n\n"}
{"name":"Nat.coprime_pow_primes","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p q n m : Nat\npp : Nat.Prime p\npq : Nat.Prime q\nh : Ne p q\n⊢ (HPow.hPow p n).Coprime (HPow.hPow q m)","decl":"theorem coprime_pow_primes {p q : ℕ} (n m : ℕ) (pp : Prime p) (pq : Prime q) (h : p ≠ q) :\n    Coprime (p ^ n) (q ^ m) :=\n  ((coprime_primes pp pq).2 h).pow _ _\n\n"}
{"name":"Nat.coprime_or_dvd_of_prime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\npp : Nat.Prime p\ni : Nat\n⊢ Or (p.Coprime i) (Dvd.dvd p i)","decl":"theorem coprime_or_dvd_of_prime {p} (pp : Prime p) (i : ℕ) : Coprime p i ∨ p ∣ i := by\n  rw [pp.dvd_iff_not_coprime]; apply em\n\n"}
{"name":"Nat.coprime_of_lt_prime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n p : Nat\nn_pos : LT.lt 0 n\nhlt : LT.lt n p\npp : Nat.Prime p\n⊢ p.Coprime n","decl":"theorem coprime_of_lt_prime {n p} (n_pos : 0 < n) (hlt : n < p) (pp : Prime p) : Coprime p n :=\n  (coprime_or_dvd_of_prime pp n).resolve_right fun h => Nat.lt_le_asymm hlt (le_of_dvd n_pos h)\n\n"}
{"name":"Nat.eq_or_coprime_of_le_prime","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n p : Nat\nn_pos : LT.lt 0 n\nhle : LE.le n p\npp : Nat.Prime p\n⊢ Or (Eq p n) (p.Coprime n)","decl":"theorem eq_or_coprime_of_le_prime {n p} (n_pos : 0 < n) (hle : n ≤ p) (pp : Prime p) :\n    p = n ∨ Coprime p n :=\n  hle.eq_or_lt.imp Eq.symm fun h => coprime_of_lt_prime n_pos h pp\n\n"}
{"name":"Nat.prime_eq_prime_of_dvd_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"m p q : Nat\npp : Nat.Prime p\npq : Nat.Prime q\nh : Dvd.dvd p (HPow.hPow q m)\n⊢ Eq p q","decl":"theorem prime_eq_prime_of_dvd_pow {m p q} (pp : Prime p) (pq : Prime q) (h : p ∣ q ^ m) : p = q :=\n  (prime_dvd_prime_iff_eq pp pq).mp (pp.dvd_of_dvd_pow h)\n\n"}
{"name":"Nat.dvd_prime_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\npp : Nat.Prime p\nm i : Nat\n⊢ Iff (Dvd.dvd i (HPow.hPow p m)) (Exists fun k => And (LE.le k m) (Eq i (HPow.hPow p k)))","decl":"theorem dvd_prime_pow {p : ℕ} (pp : Prime p) {m i : ℕ} : i ∣ p ^ m ↔ ∃ k ≤ m, i = p ^ k := by\n  simp_rw [_root_.dvd_prime_pow (prime_iff.mp pp) m, associated_eq_eq]\n\n"}
{"name":"Nat.Prime.dvd_mul_of_dvd_ne","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p1 p2 n : Nat\nh_neq : Ne p1 p2\npp1 : Nat.Prime p1\npp2 : Nat.Prime p2\nh1 : Dvd.dvd p1 n\nh2 : Dvd.dvd p2 n\n⊢ Dvd.dvd (HMul.hMul p1 p2) n","decl":"theorem Prime.dvd_mul_of_dvd_ne {p1 p2 n : ℕ} (h_neq : p1 ≠ p2) (pp1 : Prime p1) (pp2 : Prime p2)\n    (h1 : p1 ∣ n) (h2 : p2 ∣ n) : p1 * p2 ∣ n :=\n  Coprime.mul_dvd_of_dvd_of_dvd ((coprime_primes pp1 pp2).mpr h_neq) h1 h2\n\n"}
{"name":"Nat.eq_prime_pow_of_dvd_least_prime_pow","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"a p k : Nat\npp : Nat.Prime p\nh₁ : Not (Dvd.dvd a (HPow.hPow p k))\nh₂ : Dvd.dvd a (HPow.hPow p (HAdd.hAdd k 1))\n⊢ Eq a (HPow.hPow p (HAdd.hAdd k 1))","decl":"/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`.\n-/\ntheorem eq_prime_pow_of_dvd_least_prime_pow {a p k : ℕ} (pp : Prime p) (h₁ : ¬a ∣ p ^ k)\n    (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1) := by\n  obtain ⟨l, ⟨h, rfl⟩⟩ := (dvd_prime_pow pp).1 h₂\n  congr\n  exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (Prime.one_lt pp))).1 h₁))\n\n"}
{"name":"Nat.ne_one_iff_exists_prime_dvd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\n⊢ Iff (Ne n 1) (Exists fun p => And (Nat.Prime p) (Dvd.dvd p n))","decl":"theorem ne_one_iff_exists_prime_dvd : ∀ {n}, n ≠ 1 ↔ ∃ p : ℕ, p.Prime ∧ p ∣ n\n  | 0 => by simpa using Exists.intro 2 Nat.prime_two\n  | 1 => by simp [Nat.not_prime_one]\n  | n + 2 => by\n    let a := n + 2\n    have ha : a ≠ 1 := Nat.succ_succ_ne_one n\n    simp only [a, true_iff, Ne, not_false_iff, ha]\n    exact ⟨a.minFac, Nat.minFac_prime ha, a.minFac_dvd⟩\n\n"}
{"name":"Nat.eq_one_iff_not_exists_prime_dvd","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq n 1) (∀ (p : Nat), Nat.Prime p → Not (Dvd.dvd p n))","decl":"theorem eq_one_iff_not_exists_prime_dvd {n : ℕ} : n = 1 ↔ ∀ p : ℕ, p.Prime → ¬p ∣ n := by\n  simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd\n\n"}
{"name":"Nat.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul","module":"Mathlib.Data.Nat.Prime.Basic","initialProofState":"p : Nat\np_prime : Nat.Prime p\nm n k l : Nat\nhpm : Dvd.dvd (HPow.hPow p k) m\nhpn : Dvd.dvd (HPow.hPow p l) n\nhpmn : Dvd.dvd (HPow.hPow p (HAdd.hAdd (HAdd.hAdd k l) 1)) (HMul.hMul m n)\n⊢ Or (Dvd.dvd (HPow.hPow p (HAdd.hAdd k 1)) m) (Dvd.dvd (HPow.hPow p (HAdd.hAdd l 1)) n)","decl":"theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul {p : ℕ} (p_prime : Prime p) {m n k l : ℕ}\n    (hpm : p ^ k ∣ m) (hpn : p ^ l ∣ n) (hpmn : p ^ (k + l + 1) ∣ m * n) :\n    p ^ (k + 1) ∣ m ∨ p ^ (l + 1) ∣ n := by\n  have hpd : p ^ (k + l) * p ∣ m * n := by\n      let hpmn' : p ^ (succ (k + l)) ∣ m * n := hpmn\n      rwa [pow_succ'] at hpmn'\n  have hpd2 : p ∣ m * n / p ^ (k + l) := dvd_div_of_mul_dvd hpd\n  have hpd3 : p ∣ m * n / (p ^ k * p ^ l) := by simpa [pow_add] using hpd2\n  have hpd4 : p ∣ m / p ^ k * (n / p ^ l) := by simpa [Nat.div_mul_div_comm hpm hpn] using hpd3\n  have hpd5 : p ∣ m / p ^ k ∨ p ∣ n / p ^ l :=\n    (Prime.dvd_mul p_prime).1 hpd4\n  suffices p ^ k * p ∣ m ∨ p ^ l * p ∣ n by rwa [_root_.pow_succ, _root_.pow_succ]\n  exact hpd5.elim (fun h : p ∣ m / p ^ k => Or.inl <| mul_dvd_of_dvd_div hpm h)\n    fun h : p ∣ n / p ^ l => Or.inr <| mul_dvd_of_dvd_div hpn h\n\n"}
