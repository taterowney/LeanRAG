{"name":"exteriorPower.ιMulti_apply_coe","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\na : Fin n → M\n⊢ Eq (↑((exteriorPower.ιMulti R n) a)) ((ExteriorAlgebra.ιMulti R n) a)","decl":"@[simp] lemma ιMulti_apply_coe (a : Fin n → M) : ιMulti R n a = ExteriorAlgebra.ιMulti R n a := rfl\n\n"}
{"name":"exteriorPower.ιMulti_span_fixedDegree","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R (Set.range ⇑(ExteriorAlgebra.ιMulti R n))) (ExteriorAlgebra.exteriorPower R n M)","decl":"/-- The image of `ExteriorAlgebra.ιMulti R n` spans the `n`th exterior power. Variant of\n`ExteriorAlgebra.ιMulti_span_fixedDegree`, useful in rewrites. -/\nlemma ιMulti_span_fixedDegree :\n    Submodule.span R (Set.range (ExteriorAlgebra.ιMulti R n)) = ⋀[R]^n M :=\n  ExteriorAlgebra.ιMulti_span_fixedDegree R n\n\n"}
{"name":"exteriorPower.ιMulti_span","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R (Set.range ⇑(exteriorPower.ιMulti R n))) Top.top","decl":"/-- The image of `exteriorPower.ιMulti` spans `⋀[R]^n M`. -/\nlemma ιMulti_span :\n    Submodule.span R (Set.range (ιMulti R n)) = (⊤ : Submodule R (⋀[R]^n M)) := by\n  apply LinearMap.map_injective (Submodule.ker_subtype (⋀[R]^n M))\n  rw [LinearMap.map_span, ← Set.image_univ, Set.image_image]\n  simp only [Submodule.coe_subtype, ιMulti_apply_coe, Set.image_univ, Submodule.map_top,\n    Submodule.range_subtype]\n  exact ExteriorAlgebra.ιMulti_span_fixedDegree R n\n\n"}
{"name":"exteriorPower.presentation.Rels.smul.inj","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ : ι\nr✝ : R\nx✝¹ : M\nm : ι → M\ni : ι\nr : R\nx : M\nx✝ : Eq (exteriorPower.presentation.Rels.smul m✝ i✝ r✝ x✝¹) (exteriorPower.presentation.Rels.smul m i r x)\n⊢ And (Eq m✝ m) (And (Eq i✝ i) (And (Eq r✝ r) (Eq x✝¹ x)))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.smul.injEq","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ : ι\nr✝ : R\nx✝ : M\nm : ι → M\ni : ι\nr : R\nx : M\n⊢ Eq (Eq (exteriorPower.presentation.Rels.smul m✝ i✝ r✝ x✝) (exteriorPower.presentation.Rels.smul m i r x)) (And (Eq m✝ m) (And (Eq i✝ i) (And (Eq r✝ r) (Eq x✝ x))))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.alt.sizeOf_spec","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\ninst✝² : SizeOf R\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf M\nm : ι → M\ni j : ι\nhm : Eq (m i) (m j)\nhij : Ne i j\n⊢ Eq (SizeOf.sizeOf (exteriorPower.presentation.Rels.alt m i j hm hij)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf hm))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.add.sizeOf_spec","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\ninst✝² : SizeOf R\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf M\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (SizeOf.sizeOf (exteriorPower.presentation.Rels.add m i x y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf x)) (SizeOf.sizeOf y))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.smul.sizeOf_spec","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\ninst✝² : SizeOf R\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf M\nm : ι → M\ni : ι\nr : R\nx : M\n⊢ Eq (SizeOf.sizeOf (exteriorPower.presentation.Rels.smul m i r x)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf r)) (SizeOf.sizeOf x))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.alt.inj","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ j✝ : ι\nhm✝ : Eq (m✝ i✝) (m✝ j✝)\nhij✝ : Ne i✝ j✝\nm : ι → M\ni j : ι\nhm : Eq (m i) (m j)\nhij : Ne i j\nx✝ : Eq (exteriorPower.presentation.Rels.alt m✝ i✝ j✝ hm✝ hij✝) (exteriorPower.presentation.Rels.alt m i j hm hij)\n⊢ And (Eq m✝ m) (And (Eq i✝ i) (Eq j✝ j))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.add.inj","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ : ι\nx✝¹ y✝ : M\nm : ι → M\ni : ι\nx y : M\nx✝ : Eq (exteriorPower.presentation.Rels.add m✝ i✝ x✝¹ y✝) (exteriorPower.presentation.Rels.add m i x y)\n⊢ And (Eq m✝ m) (And (Eq i✝ i) (And (Eq x✝¹ x) (Eq y✝ y)))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.add.injEq","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ : ι\nx✝ y✝ : M\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (Eq (exteriorPower.presentation.Rels.add m✝ i✝ x✝ y✝) (exteriorPower.presentation.Rels.add m i x y)) (And (Eq m✝ m) (And (Eq i✝ i) (And (Eq x✝ x) (Eq y✝ y))))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.Rels.alt.injEq","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\nι : Type u_4\nM : Type u_5\nm✝ : ι → M\ni✝ j✝ : ι\nhm✝ : Eq (m✝ i✝) (m✝ j✝)\nhij✝ : Ne i✝ j✝\nm : ι → M\ni j : ι\nhm : Eq (m i) (m j)\nhij : Ne i j\n⊢ Eq (Eq (exteriorPower.presentation.Rels.alt m✝ i✝ j✝ hm✝ hij✝) (exteriorPower.presentation.Rels.alt m i j hm hij)) (And (Eq m✝ m) (And (Eq i✝ i) (Eq j✝ j)))","decl":"/-- The index type for the relations in the standard presentation of `⋀[R]^n M`,\nin the particular case `ι` is `Fin n`. -/\ninductive Rels (ι : Type*) (M : Type*)\n  | add (m : ι → M) (i : ι) (x y : M)\n  | smul (m : ι → M) (i : ι) (r : R) (x : M)\n  | alt (m : ι → M) (i j : ι) (hm : m i = m j) (hij : i ≠ j)\n\n"}
{"name":"exteriorPower.presentation.relations_relation","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nι : Type u_4\ninst✝² : DecidableEq ι\nM : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx✝ : exteriorPower.presentation.Rels R ι M\n⊢ Eq ((exteriorPower.presentation.relations R ι M).relation x✝) (exteriorPower.presentation.relations.match_1 R ι M (fun x => Finsupp (ι → M) R) x✝ (fun m i x y => HSub.hSub (HAdd.hAdd (Finsupp.single (Function.update m i x) 1) (Finsupp.single (Function.update m i y) 1)) (Finsupp.single (Function.update m i (HAdd.hAdd x y)) 1)) (fun m i r x => HSub.hSub (Finsupp.single (Function.update m i (HSMul.hSMul r x)) 1) (HSMul.hSMul r (Finsupp.single (Function.update m i x) 1))) fun m i j hm hij => Finsupp.single m 1)","decl":"/-- The relations in the standard presentation of `⋀[R]^n M` with generators and relations. -/\n@[simps]\nnoncomputable def relations (ι : Type*) [DecidableEq ι] (M : Type*)\n    [AddCommGroup M] [Module R M] :\n    Module.Relations R where\n  G := ι → M\n  R := Rels R ι M\n  relation\n    | .add m i x y => Finsupp.single (update m i x) 1 +\n        Finsupp.single (update m i y) 1 -\n        Finsupp.single (update m i (x + y)) 1\n    | .smul m i r x => Finsupp.single (update m i (r • x)) 1 -\n        r • Finsupp.single (update m i x) 1\n    | .alt m _ _ _ _ => Finsupp.single m 1\n\n"}
{"name":"exteriorPower.presentation.relations_G","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nι : Type u_4\ninst✝² : DecidableEq ι\nM : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.presentation.relations R ι M).G (ι → M)","decl":"/-- The relations in the standard presentation of `⋀[R]^n M` with generators and relations. -/\n@[simps]\nnoncomputable def relations (ι : Type*) [DecidableEq ι] (M : Type*)\n    [AddCommGroup M] [Module R M] :\n    Module.Relations R where\n  G := ι → M\n  R := Rels R ι M\n  relation\n    | .add m i x y => Finsupp.single (update m i x) 1 +\n        Finsupp.single (update m i y) 1 -\n        Finsupp.single (update m i (x + y)) 1\n    | .smul m i r x => Finsupp.single (update m i (r • x)) 1 -\n        r • Finsupp.single (update m i x) 1\n    | .alt m _ _ _ _ => Finsupp.single m 1\n\n"}
{"name":"exteriorPower.presentation.relations_R","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nι : Type u_4\ninst✝² : DecidableEq ι\nM : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.presentation.relations R ι M).R (exteriorPower.presentation.Rels R ι M)","decl":"/-- The relations in the standard presentation of `⋀[R]^n M` with generators and relations. -/\n@[simps]\nnoncomputable def relations (ι : Type*) [DecidableEq ι] (M : Type*)\n    [AddCommGroup M] [Module R M] :\n    Module.Relations R where\n  G := ι → M\n  R := Rels R ι M\n  relation\n    | .add m i x y => Finsupp.single (update m i x) 1 +\n        Finsupp.single (update m i y) 1 -\n        Finsupp.single (update m i (x + y)) 1\n    | .smul m i r x => Finsupp.single (update m i (r • x)) 1 -\n        r • Finsupp.single (update m i x) 1\n    | .alt m _ _ _ _ => Finsupp.single m 1\n\n"}
{"name":"exteriorPower.presentation.relationsSolutionEquiv_apply_apply","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nN : Type u_2\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nι : Type u_4\ninst✝² : DecidableEq ι\nM : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : (exteriorPower.presentation.relations R ι M).Solution N\nm : ι → M\n⊢ Eq ((exteriorPower.presentation.relationsSolutionEquiv s) m) (s.var m)","decl":"variable {R} in\n/-- The solutions in a module `N` to the linear equations\ngiven by `exteriorPower.relations R ι M` identify to alternating maps to `N`. -/\n@[simps!]\ndef relationsSolutionEquiv {ι : Type*} [DecidableEq ι] {M : Type*}\n    [AddCommGroup M] [Module R M] :\n    (relations R ι M).Solution N ≃ AlternatingMap R M N ι where\n  toFun s :=\n    { toFun := fun m ↦ s.var m\n      map_update_add' := fun m i x y ↦ by\n        have := s.linearCombination_var_relation (.add m i x y)\n        dsimp at this ⊢\n        rw [map_sub, map_add, Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, one_smul, sub_eq_zero] at this\n        convert this.symm -- `convert` is necessary due to the implementation of `MultilinearMap`\n      map_update_smul' := fun m i r x ↦ by\n        have := s.linearCombination_var_relation (.smul m i r x)\n        dsimp at this ⊢\n        rw [Finsupp.smul_single, smul_eq_mul, mul_one, map_sub,\n          Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, sub_eq_zero] at this\n        convert this\n      map_eq_zero_of_eq' := fun v i j hm hij ↦\n        by simpa using s.linearCombination_var_relation (.alt v i j hm hij) }\n  invFun f :=\n    { var := fun m ↦ f m\n      linearCombination_var_relation := by\n        rintro (⟨m, i, x, y⟩ | ⟨m, i, r, x⟩ | ⟨v, i, j, hm, hij⟩)\n        · simp\n        · simp\n        · simpa using f.map_eq_zero_of_eq v hm hij }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"exteriorPower.presentation.relationsSolutionEquiv_symm_apply_var","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nN : Type u_2\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nι : Type u_4\ninst✝² : DecidableEq ι\nM : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : AlternatingMap R M N ι\nm : (exteriorPower.presentation.relations R ι M).G\n⊢ Eq ((exteriorPower.presentation.relationsSolutionEquiv.symm f).var m) (f m)","decl":"variable {R} in\n/-- The solutions in a module `N` to the linear equations\ngiven by `exteriorPower.relations R ι M` identify to alternating maps to `N`. -/\n@[simps!]\ndef relationsSolutionEquiv {ι : Type*} [DecidableEq ι] {M : Type*}\n    [AddCommGroup M] [Module R M] :\n    (relations R ι M).Solution N ≃ AlternatingMap R M N ι where\n  toFun s :=\n    { toFun := fun m ↦ s.var m\n      map_update_add' := fun m i x y ↦ by\n        have := s.linearCombination_var_relation (.add m i x y)\n        dsimp at this ⊢\n        rw [map_sub, map_add, Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, one_smul, sub_eq_zero] at this\n        convert this.symm -- `convert` is necessary due to the implementation of `MultilinearMap`\n      map_update_smul' := fun m i r x ↦ by\n        have := s.linearCombination_var_relation (.smul m i r x)\n        dsimp at this ⊢\n        rw [Finsupp.smul_single, smul_eq_mul, mul_one, map_sub,\n          Finsupp.linearCombination_single, one_smul,\n          Finsupp.linearCombination_single, sub_eq_zero] at this\n        convert this\n      map_eq_zero_of_eq' := fun v i j hm hij ↦\n        by simpa using s.linearCombination_var_relation (.alt v i j hm hij) }\n  invFun f :=\n    { var := fun m ↦ f m\n      linearCombination_var_relation := by\n        rintro (⟨m, i, x, y⟩ | ⟨m, i, r, x⟩ | ⟨v, i, j, hm, hij⟩)\n        · simp\n        · simp\n        · simpa using f.map_eq_zero_of_eq v hm hij }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"exteriorPower.presentation_R","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.presentation R n M).R (exteriorPower.presentation.Rels R (Fin n) M)","decl":"/-- The standard presentation of the `R`-module `⋀[R]^n M`. -/\n@[simps! G R relation var]\nnoncomputable def presentation : Module.Presentation R (⋀[R]^n M) :=\n  .ofIsPresentation (presentation.isPresentationCore R n M).isPresentation\n\n"}
{"name":"exteriorPower.presentation_G","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.presentation R n M).G (Fin n → M)","decl":"/-- The standard presentation of the `R`-module `⋀[R]^n M`. -/\n@[simps! G R relation var]\nnoncomputable def presentation : Module.Presentation R (⋀[R]^n M) :=\n  .ofIsPresentation (presentation.isPresentationCore R n M).isPresentation\n\n"}
{"name":"exteriorPower.presentation_var","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : (exteriorPower.presentation.relations R (Fin n) M).G\n⊢ Eq ((exteriorPower.presentation R n M).var m) ((exteriorPower.ιMulti R n) m)","decl":"/-- The standard presentation of the `R`-module `⋀[R]^n M`. -/\n@[simps! G R relation var]\nnoncomputable def presentation : Module.Presentation R (⋀[R]^n M) :=\n  .ofIsPresentation (presentation.isPresentationCore R n M).isPresentation\n\n"}
{"name":"exteriorPower.presentation_relation","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : (exteriorPower.presentation.relations R (Fin n) M).R\n⊢ Eq ((exteriorPower.presentation R n M).relation r) (exteriorPower.presentation.relations.match_1 R (Fin n) M (fun x => Finsupp (Fin n → M) R) r (fun m i x y => HSub.hSub (HAdd.hAdd (Finsupp.single (Function.update m i x) 1) (Finsupp.single (Function.update m i y) 1)) (Finsupp.single (Function.update m i (HAdd.hAdd x y)) 1)) (fun m i r x => HSub.hSub (Finsupp.single (Function.update m i (HSMul.hSMul r x)) 1) (Finsupp.single (Function.update m i x) r)) fun m i j hm hij => Finsupp.single m 1)","decl":"/-- The standard presentation of the `R`-module `⋀[R]^n M`. -/\n@[simps! G R relation var]\nnoncomputable def presentation : Module.Presentation R (⋀[R]^n M) :=\n  .ofIsPresentation (presentation.isPresentationCore R n M).isPresentation\n\n"}
{"name":"exteriorPower.linearMap_ext_iff","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R n M) x) N\n⊢ Iff (Eq f g) (Eq (f.compAlternatingMap (exteriorPower.ιMulti R n)) (g.compAlternatingMap (exteriorPower.ιMulti R n)))","decl":"/-- Two linear maps on `⋀[R]^n M` that agree on the image of `exteriorPower.ιMulti`\nare equal. -/\n@[ext]\nlemma linearMap_ext {f : ⋀[R]^n M →ₗ[R] N} {g : ⋀[R]^n M →ₗ[R] N}\n    (heq : f.compAlternatingMap (ιMulti R n) = g.compAlternatingMap (ιMulti R n)) : f = g :=\n  (presentation R n M).postcomp_injective (by ext f; apply DFunLike.congr_fun heq )\n\n"}
{"name":"exteriorPower.linearMap_ext","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R n M) x) N\nheq : Eq (f.compAlternatingMap (exteriorPower.ιMulti R n)) (g.compAlternatingMap (exteriorPower.ιMulti R n))\n⊢ Eq f g","decl":"/-- Two linear maps on `⋀[R]^n M` that agree on the image of `exteriorPower.ιMulti`\nare equal. -/\n@[ext]\nlemma linearMap_ext {f : ⋀[R]^n M →ₗ[R] N} {g : ⋀[R]^n M →ₗ[R] N}\n    (heq : f.compAlternatingMap (ιMulti R n) = g.compAlternatingMap (ιMulti R n)) : f = g :=\n  (presentation R n M).postcomp_injective (by ext f; apply DFunLike.congr_fun heq )\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_comp_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : AlternatingMap R M N (Fin n)\n⊢ Eq ((exteriorPower.alternatingMapLinearEquiv f).compAlternatingMap (exteriorPower.ιMulti R n)) f","decl":"@[simp]\nlemma alternatingMapLinearEquiv_comp_ιMulti (f : M [⋀^Fin n]→ₗ[R] N) :\n    (alternatingMapLinearEquiv f).compAlternatingMap (ιMulti R n) = f := by\n  obtain ⟨φ, rfl⟩ := alternatingMapLinearEquiv.symm.surjective f\n  dsimp [alternatingMapLinearEquiv]\n  simp only [LinearEquiv.symm_apply_apply]\n  rfl\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : AlternatingMap R M N (Fin n)\na : Fin n → M\n⊢ Eq ((exteriorPower.alternatingMapLinearEquiv f) ((exteriorPower.ιMulti R n) a)) (f a)","decl":"@[simp]\nlemma alternatingMapLinearEquiv_apply_ιMulti (f : M [⋀^Fin n]→ₗ[R] N) (a : Fin n → M) :\n    alternatingMapLinearEquiv f (ιMulti R n a) = f a :=\n  DFunLike.congr_fun (alternatingMapLinearEquiv_comp_ιMulti f) a\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_symm_apply","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nF : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R n M) x) N\nm : Fin n → M\n⊢ Eq ((exteriorPower.alternatingMapLinearEquiv.symm F) m) ((F.compAlternatingMap (exteriorPower.ιMulti R n)) m)","decl":"@[simp]\nlemma alternatingMapLinearEquiv_symm_apply (F : ⋀[R]^n M →ₗ[R] N) (m : Fin n → M) :\n    alternatingMapLinearEquiv.symm F m = F.compAlternatingMap (ιMulti R n) m := by\n  obtain ⟨f, rfl⟩ := alternatingMapLinearEquiv.surjective F\n  simp only [LinearEquiv.symm_apply_apply, alternatingMapLinearEquiv_comp_ιMulti]\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.alternatingMapLinearEquiv (exteriorPower.ιMulti R n)) LinearMap.id","decl":"@[simp]\nlemma alternatingMapLinearEquiv_ιMulti :\n    alternatingMapLinearEquiv (ιMulti R n (M := M)) = LinearMap.id := by\n  ext\n  simp only [alternatingMapLinearEquiv_comp_ιMulti, ιMulti_apply_coe,\n    LinearMap.compAlternatingMap_apply, LinearMap.id_coe, id_eq]\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_comp","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\nN' : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\ng : LinearMap (RingHom.id R) N N'\nf : AlternatingMap R M N (Fin n)\n⊢ Eq (exteriorPower.alternatingMapLinearEquiv (g.compAlternatingMap f)) (g.comp (exteriorPower.alternatingMapLinearEquiv f))","decl":"/-- If `f` is an alternating map from `M` to `N`,\n`alternatingMapLinearEquiv f` is the corresponding linear map from `⋀[R]^n M` to `N`,\nand if `g` is a linear map from `N` to `N'`, then\nthe alternating map `g.compAlternatingMap f` from `M` to `N'` corresponds to the linear\nmap `g.comp (alternatingMapLinearEquiv f)` on `⋀[R]^n M`. -/\nlemma alternatingMapLinearEquiv_comp (g : N →ₗ[R] N') (f : M [⋀^Fin n]→ₗ[R] N) :\n    alternatingMapLinearEquiv (g.compAlternatingMap f) = g.comp (alternatingMapLinearEquiv f) := by\n  ext\n  simp only [alternatingMapLinearEquiv_comp_ιMulti, LinearMap.compAlternatingMap_apply,\n    LinearMap.coe_comp, comp_apply, alternatingMapLinearEquiv_apply_ιMulti]\n\n"}
{"name":"exteriorPower.alternatingMapLinearEquiv_symm_map","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (exteriorPower.alternatingMapLinearEquiv.symm (exteriorPower.map n f)) ((exteriorPower.ιMulti R n).compLinearMap f)","decl":"@[simp] lemma alternatingMapLinearEquiv_symm_map (f : M →ₗ[R] N) :\n    alternatingMapLinearEquiv.symm (map n f) = (ιMulti R n).compLinearMap f := by\n  simp only [map, LinearEquiv.symm_apply_apply]\n\n"}
{"name":"exteriorPower.map_comp_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((exteriorPower.map n f).compAlternatingMap (exteriorPower.ιMulti R n)) ((exteriorPower.ιMulti R n).compLinearMap f)","decl":"@[simp]\ntheorem map_comp_ιMulti (f : M →ₗ[R] N) :\n    (map n f).compAlternatingMap (ιMulti R n) = (ιMulti R n).compLinearMap f := by\n  simp only [map, alternatingMapLinearEquiv_comp_ιMulti]\n\n"}
{"name":"exteriorPower.map_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nm : Fin n → M\n⊢ Eq ((exteriorPower.map n f) ((exteriorPower.ιMulti R n) m)) ((exteriorPower.ιMulti R n) (Function.comp (⇑f) m))","decl":"@[simp]\ntheorem map_apply_ιMulti (f : M →ₗ[R] N) (m : Fin n → M) :\n    map n f (ιMulti R n m) = ιMulti R n (f ∘ m) := by\n  simp only [map, alternatingMapLinearEquiv_apply_ιMulti, AlternatingMap.compLinearMap_apply]\n  rfl\n\n"}
{"name":"exteriorPower.map_id","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Nat\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (exteriorPower.map n LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem map_id :\n    map n (LinearMap.id (R := R) (M := M)) = LinearMap.id := by\n  aesop\n\n"}
{"name":"exteriorPower.map_comp","module":"Mathlib.LinearAlgebra.ExteriorPower.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nn : Nat\nM : Type u_1\nN : Type u_2\nN' : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N N'\n⊢ Eq (exteriorPower.map n (g.comp f)) ((exteriorPower.map n g).comp (exteriorPower.map n f))","decl":"@[simp]\ntheorem map_comp (f : M →ₗ[R] N) (g : N →ₗ[R] N') :\n    map n (g ∘ₗ f) = map n g ∘ₗ map n f := by\n  aesop\n\n"}
