{"name":"MixedCharZero.charP_quotient","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\nself : MixedCharZero R p\n⊢ Exists fun I => And (Ne I Top.top) (CharP (HasQuotient.Quotient R I) p)","decl":"/--\nA ring of characteristic zero is of \"mixed characteristic `(0, p)`\" if there exists an ideal\nsuch that the quotient `R ⧸ I` has characteristic `p`.\n\n**Remark:** For `p = 0`, `MixedChar R 0` is a meaningless definition (i.e. satisfied by any ring)\nas `R ⧸ ⊥ ≅ R` has by definition always characteristic zero.\nOne could require `(I ≠ ⊥)` in the definition, but then `MixedChar R 0` would mean something\nlike `ℤ`-algebra of extension degree `≥ 1` and would be completely independent from\nwhether something is a `ℚ`-algebra or not (e.g. `ℚ[X]` would satisfy it but `ℚ` wouldn't).\n-/\nclass MixedCharZero (p : ℕ) : Prop where\n  [toCharZero : CharZero R]\n  charP_quotient : ∃ I : Ideal R, I ≠ ⊤ ∧ CharP (R ⧸ I) p\n\n"}
{"name":"MixedCharZero.toCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\nself : MixedCharZero R p\n⊢ CharZero R","decl":"/--\nA ring of characteristic zero is of \"mixed characteristic `(0, p)`\" if there exists an ideal\nsuch that the quotient `R ⧸ I` has characteristic `p`.\n\n**Remark:** For `p = 0`, `MixedChar R 0` is a meaningless definition (i.e. satisfied by any ring)\nas `R ⧸ ⊥ ≅ R` has by definition always characteristic zero.\nOne could require `(I ≠ ⊥)` in the definition, but then `MixedChar R 0` would mean something\nlike `ℤ`-algebra of extension degree `≥ 1` and would be completely independent from\nwhether something is a `ℚ`-algebra or not (e.g. `ℚ[X]` would satisfy it but `ℚ` wouldn't).\n-/\nclass MixedCharZero (p : ℕ) : Prop where\n  [toCharZero : CharZero R]\n  charP_quotient : ∃ I : Ideal R, I ≠ ⊤ ∧ CharP (R ⧸ I) p\n\n"}
{"name":"MixedCharZero.reduce_to_p_prime","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Prop\n⊢ Iff (∀ (p : Nat), GT.gt p 0 → MixedCharZero R p → P) (∀ (p : Nat), Nat.Prime p → MixedCharZero R p → P)","decl":"/--\nReduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime.\n-/\ntheorem reduce_to_p_prime {P : Prop} :\n    (∀ p > 0, MixedCharZero R p → P) ↔ ∀ p : ℕ, p.Prime → MixedCharZero R p → P := by\n  constructor\n  · intro h q q_prime q_mixedChar\n    exact h q (Nat.Prime.pos q_prime) q_mixedChar\n  · intro h q q_pos q_mixedChar\n    rcases q_mixedChar.charP_quotient with ⟨I, hI_ne_top, _⟩\n    -- Krull's Thm: There exists a prime ideal `P` such that `I ≤ P`\n    rcases Ideal.exists_le_maximal I hI_ne_top with ⟨M, hM_max, h_IM⟩\n    let r := ringChar (R ⧸ M)\n    have r_pos : r ≠ 0 := by\n      have q_zero :=\n        congr_arg (Ideal.Quotient.factor I M h_IM) (CharP.cast_eq_zero (R ⧸ I) q)\n      simp only [map_natCast, map_zero] at q_zero\n      apply ne_zero_of_dvd_ne_zero (ne_of_gt q_pos)\n      exact (CharP.cast_eq_zero_iff (R ⧸ M) r q).mp q_zero\n    have r_prime : Nat.Prime r :=\n      or_iff_not_imp_right.1 (CharP.char_is_prime_or_zero (R ⧸ M) r) r_pos\n    apply h r r_prime\n    have : CharZero R := q_mixedChar.toCharZero\n    exact ⟨⟨M, hM_max.ne_top, ringChar.of_eq rfl⟩⟩\n\n"}
{"name":"MixedCharZero.reduce_to_maximal_ideal","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\nhp : Nat.Prime p\n⊢ Iff (Exists fun I => And (Ne I Top.top) (CharP (HasQuotient.Quotient R I) p)) (Exists fun I => And I.IsMaximal (CharP (HasQuotient.Quotient R I) p))","decl":"/--\nReduction to `I` prime ideal: When proving statements about mixed characteristic rings,\nafter we reduced to `p` prime, we can assume that the ideal `I` in the definition is maximal.\n-/\ntheorem reduce_to_maximal_ideal {p : ℕ} (hp : Nat.Prime p) :\n    (∃ I : Ideal R, I ≠ ⊤ ∧ CharP (R ⧸ I) p) ↔ ∃ I : Ideal R, I.IsMaximal ∧ CharP (R ⧸ I) p := by\n  constructor\n  · intro g\n    rcases g with ⟨I, ⟨hI_not_top, _⟩⟩\n    -- Krull's Thm: There exists a prime ideal `M` such that `I ≤ M`.\n    rcases Ideal.exists_le_maximal I hI_not_top with ⟨M, ⟨hM_max, hM_ge⟩⟩\n    use M\n    constructor\n    · exact hM_max\n    · cases CharP.exists (R ⧸ M) with\n      | intro r hr =>\n        convert hr\n        have r_dvd_p : r ∣ p := by\n          rw [← CharP.cast_eq_zero_iff (R ⧸ M) r p]\n          convert congr_arg (Ideal.Quotient.factor I M hM_ge) (CharP.cast_eq_zero (R ⧸ I) p)\n        symm\n        apply (Nat.Prime.eq_one_or_self_of_dvd hp r r_dvd_p).resolve_left\n        exact CharP.char_ne_one (R ⧸ M) r\n  · intro ⟨I, hI_max, h_charP⟩\n    use I\n    exact ⟨Ideal.IsMaximal.ne_top hI_max, h_charP⟩\n\n"}
{"name":"EqualCharZero.of_algebraRat","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Algebra Rat R\nI : Ideal R\na✝ : Ne I Top.top\n⊢ CharZero (HasQuotient.Quotient R I)","decl":"/-- `ℚ`-algebra implies equal characteristic. -/\ntheorem of_algebraRat [Algebra ℚ R] : ∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I) := by\n  intro I hI\n  constructor\n  intro a b h_ab\n  contrapose! hI\n  -- `↑a - ↑b` is a unit contained in `I`, which contradicts `I ≠ ⊤`.\n  refine I.eq_top_of_isUnit_mem ?_ (IsUnit.map (algebraMap ℚ R) (IsUnit.mk0 (a - b : ℚ) ?_))\n  · simpa only [← Ideal.Quotient.eq_zero_iff_mem, map_sub, sub_eq_zero, map_natCast]\n  simpa only [Ne, sub_eq_zero] using (@Nat.cast_injective ℚ _ _).ne hI\n\n"}
{"name":"EqualCharZero.PNat.isUnit_natCast","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nh : Fact (∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I))\nn : PNat\n⊢ IsUnit ↑↑n","decl":"/-- Internal: Not intended to be used outside this local construction. -/\ntheorem PNat.isUnit_natCast [h : Fact (∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I))]\n    (n : ℕ+) : IsUnit (n : R) := by\n  -- `n : R` is a unit iff `(n)` is not a proper ideal in `R`.\n  rw [← Ideal.span_singleton_eq_top]\n  -- So by contrapositive, we should show the quotient does not have characteristic zero.\n  apply not_imp_comm.mp (h.elim (Ideal.span {↑n}))\n  intro h_char_zero\n  -- In particular, the image of `n` in the quotient should be nonzero.\n  apply h_char_zero.cast_injective.ne n.ne_zero\n  -- But `n` generates the ideal, so its image is clearly zero.\n  rw [← map_natCast (Ideal.Quotient.mk _), Nat.cast_zero, Ideal.Quotient.eq_zero_iff_mem]\n  exact Ideal.subset_span (Set.mem_singleton _)\n\n"}
{"name":"EqualCharZero.pnatCast_one","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I))\n⊢ Eq (↑1) 1","decl":"/-- Internal: Not intended to be used outside this local construction. -/\n@[simp]\ntheorem pnatCast_one [Fact (∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I))] : ((1 : ℕ+) : Rˣ) = 1 := by\n  apply Units.ext\n  rw [Units.val_one]\n  change ((PNat.isUnit_natCast (R := R) 1).unit : R) = 1\n  rw [IsUnit.unit_spec (PNat.isUnit_natCast 1)]\n  rw [PNat.one_coe, Nat.cast_one]\n\n"}
{"name":"EqualCharZero.pnatCast_eq_natCast","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I))\nn : PNat\n⊢ Eq ↑↑n ↑↑n","decl":"/-- Internal: Not intended to be used outside this local construction. -/\n@[simp]\ntheorem pnatCast_eq_natCast [Fact (∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I))] (n : ℕ+) :\n    ((n : Rˣ) : R) = ↑n := by\n  change ((PNat.isUnit_natCast (R := R) n).unit : R) = ↑n\n  simp only [IsUnit.unit_spec]\n\n"}
{"name":"EqualCharZero.of_not_mixedCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\nh : ∀ (p : Nat), GT.gt p 0 → Not (MixedCharZero R p)\nI : Ideal R\na✝ : Ne I Top.top\n⊢ CharZero (HasQuotient.Quotient R I)","decl":"/-- Not mixed characteristic implies equal characteristic. -/\ntheorem of_not_mixedCharZero [CharZero R] (h : ∀ p > 0, ¬MixedCharZero R p) :\n    ∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I) := by\n  intro I hI_ne_top\n  suffices CharP (R ⧸ I) 0 from CharP.charP_to_charZero _\n  cases CharP.exists (R ⧸ I) with\n  | intro p hp =>\n    cases p with\n    | zero => exact hp\n    | succ p =>\n      have h_mixed : MixedCharZero R p.succ := ⟨⟨I, ⟨hI_ne_top, hp⟩⟩⟩\n      exact absurd h_mixed (h p.succ p.succ_pos)\n\n"}
{"name":"EqualCharZero.to_not_mixedCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nh : ∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I)\np : Nat\na✝ : GT.gt p 0\n⊢ Not (MixedCharZero R p)","decl":"/-- Equal characteristic implies not mixed characteristic. -/\ntheorem to_not_mixedCharZero (h : ∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I)) :\n    ∀ p > 0, ¬MixedCharZero R p := by\n  intro p p_pos\n  by_contra hp_mixedChar\n  rcases hp_mixedChar.charP_quotient with ⟨I, hI_ne_top, hI_p⟩\n  replace hI_zero : CharP (R ⧸ I) 0 := @CharP.ofCharZero _ _ (h I hI_ne_top)\n  exact absurd (CharP.eq (R ⧸ I) hI_p hI_zero) (ne_of_gt p_pos)\n\n"}
{"name":"EqualCharZero.iff_not_mixedCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\n⊢ Iff (∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I)) (∀ (p : Nat), GT.gt p 0 → Not (MixedCharZero R p))","decl":"/--\nA ring of characteristic zero has equal characteristic iff it does not\nhave mixed characteristic for any `p`.\n-/\ntheorem iff_not_mixedCharZero [CharZero R] :\n    (∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I)) ↔ ∀ p > 0, ¬MixedCharZero R p :=\n  ⟨to_not_mixedCharZero R, of_not_mixedCharZero R⟩\n\n"}
{"name":"EqualCharZero.nonempty_algebraRat_iff","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (Nonempty (Algebra Rat R)) (∀ (I : Ideal R), Ne I Top.top → CharZero (HasQuotient.Quotient R I))","decl":"/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem nonempty_algebraRat_iff :\n    Nonempty (Algebra ℚ R) ↔ ∀ I : Ideal R, I ≠ ⊤ → CharZero (R ⧸ I) := by\n  constructor\n  · intro h_alg\n    haveI h_alg' : Algebra ℚ R := h_alg.some\n    apply of_algebraRat\n  · intro h\n    apply Nonempty.intro\n    exact algebraRat h\n\n"}
{"name":"isEmpty_algebraRat_iff_mixedCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\n⊢ Iff (IsEmpty (Algebra Rat R)) (Exists fun p => And (GT.gt p 0) (MixedCharZero R p))","decl":"/--\nA ring of characteristic zero is not a `ℚ`-algebra iff it has mixed characteristic for some `p`.\n-/\ntheorem isEmpty_algebraRat_iff_mixedCharZero [CharZero R] :\n    IsEmpty (Algebra ℚ R) ↔ ∃ p > 0, MixedCharZero R p := by\n  rw [← not_iff_not]\n  push_neg\n  rw [not_isEmpty_iff, ← EqualCharZero.iff_not_mixedCharZero]\n  apply EqualCharZero.nonempty_algebraRat_iff\n\n"}
{"name":"split_equalCharZero_mixedCharZero","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Prop\ninst✝ : CharZero R\nh_equal : Algebra Rat R → P\nh_mixed : ∀ (p : Nat), Nat.Prime p → MixedCharZero R p → P\n⊢ P","decl":"/-- Split a `Prop` in characteristic zero into equal and mixed characteristic. -/\ntheorem split_equalCharZero_mixedCharZero [CharZero R] (h_equal : Algebra ℚ R → P)\n    (h_mixed : ∀ p : ℕ, Nat.Prime p → MixedCharZero R p → P) : P := by\n  by_cases h : ∃ p > 0, MixedCharZero R p\n  · rcases h with ⟨p, ⟨H, hp⟩⟩\n    rw [← MixedCharZero.reduce_to_p_prime] at h_mixed\n    exact h_mixed p H hp\n  · apply h_equal\n    rw [← isEmpty_algebraRat_iff_mixedCharZero, not_isEmpty_iff] at h\n    exact h.some\n\n"}
{"name":"split_by_characteristic","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Prop\nh_pos : ∀ (p : Nat), Ne p 0 → CharP R p → P\nh_equal : Algebra Rat R → P\nh_mixed : ∀ (p : Nat), Nat.Prime p → MixedCharZero R p → P\n⊢ P","decl":"/--\nSplit any `Prop` over `R` into the three cases:\n- positive characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic (h_pos : ∀ p : ℕ, p ≠ 0 → CharP R p → P) (h_equal : Algebra ℚ R → P)\n    (h_mixed : ∀ p : ℕ, Nat.Prime p → MixedCharZero R p → P) : P := by\n  cases CharP.exists R with\n  | intro p p_charP =>\n    by_cases h : p = 0\n    · rw [h] at p_charP\n      haveI h0 : CharZero R := CharP.charP_to_charZero R\n      exact split_equalCharZero_mixedCharZero R h_equal h_mixed\n    · exact h_pos p h p_charP\n\n"}
{"name":"split_by_characteristic_domain","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Prop\ninst✝ : IsDomain R\nh_pos : ∀ (p : Nat), Nat.Prime p → CharP R p → P\nh_equal : Algebra Rat R → P\nh_mixed : ∀ (p : Nat), Nat.Prime p → MixedCharZero R p → P\n⊢ P","decl":"/--\nIn an `IsDomain R`, split any `Prop` over `R` into the three cases:\n- *prime* characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic_domain [IsDomain R] (h_pos : ∀ p : ℕ, Nat.Prime p → CharP R p → P)\n    (h_equal : Algebra ℚ R → P) (h_mixed : ∀ p : ℕ, Nat.Prime p → MixedCharZero R p → P) : P := by\n  refine split_by_characteristic R ?_ h_equal h_mixed\n  intro p p_pos p_char\n  have p_prime : Nat.Prime p := or_iff_not_imp_right.mp (CharP.char_is_prime_or_zero R p) p_pos\n  exact h_pos p p_prime p_char\n\n"}
{"name":"split_by_characteristic_localRing","module":"Mathlib.Algebra.CharP.MixedCharZero","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Prop\ninst✝ : IsLocalRing R\nh_pos : ∀ (p : Nat), IsPrimePow p → CharP R p → P\nh_equal : Algebra Rat R → P\nh_mixed : ∀ (p : Nat), Nat.Prime p → MixedCharZero R p → P\n⊢ P","decl":"/--\nIn a local ring `R`, split any predicate over `R` into the three cases:\n- *prime power* characteristic.\n- equal characteristic zero.\n- mixed characteristic `(0, p)`.\n-/\ntheorem split_by_characteristic_localRing [IsLocalRing R]\n    (h_pos : ∀ p : ℕ, IsPrimePow p → CharP R p → P) (h_equal : Algebra ℚ R → P)\n    (h_mixed : ∀ p : ℕ, Nat.Prime p → MixedCharZero R p → P) : P := by\n  refine split_by_characteristic R ?_ h_equal h_mixed\n  intro p p_pos p_char\n  have p_ppow : IsPrimePow (p : ℕ) := or_iff_not_imp_left.mp (charP_zero_or_prime_power R p) p_pos\n  exact h_pos p p_ppow p_char\n\n"}
