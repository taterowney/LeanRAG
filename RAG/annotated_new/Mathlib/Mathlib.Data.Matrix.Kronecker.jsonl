{"name":"Matrix.kroneckerMap_apply","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nf : α → β → γ\nA : Matrix l m α\nB : Matrix n p β\ni : Prod l n\nj : Prod m p\n⊢ Eq (Matrix.kroneckerMap f A B i j) (f (A i.1 j.1) (B i.2 j.2))","decl":"@[simp]\ntheorem kroneckerMap_apply (f : α → β → γ) (A : Matrix l m α) (B : Matrix n p β) (i j) :\n    kroneckerMap f A B i j = f (A i.1 j.1) (B i.2 j.2) :=\n  rfl\n\n"}
{"name":"Matrix.kroneckerMap_transpose","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nf : α → β → γ\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f A.transpose B.transpose) (Matrix.kroneckerMap f A B).transpose","decl":"theorem kroneckerMap_transpose (f : α → β → γ) (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f Aᵀ Bᵀ = (kroneckerMap f A B)ᵀ :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.kroneckerMap_map_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nα' : Type u_3\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nf : α' → β → γ\ng : α → α'\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f (A.map g) B) (Matrix.kroneckerMap (fun a b => f (g a) b) A B)","decl":"theorem kroneckerMap_map_left (f : α' → β → γ) (g : α → α') (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f (A.map g) B = kroneckerMap (fun a b => f (g a) b) A B :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.kroneckerMap_map_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nβ' : Type u_5\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nf : α → β' → γ\ng : β → β'\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f A (B.map g)) (Matrix.kroneckerMap (fun a b => f a (g b)) A B)","decl":"theorem kroneckerMap_map_right (f : α → β' → γ) (g : β → β') (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f A (B.map g) = kroneckerMap (fun a b => f a (g b)) A B :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.kroneckerMap_map","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nγ' : Type u_7\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nf : α → β → γ\ng : γ → γ'\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq ((Matrix.kroneckerMap f A B).map g) (Matrix.kroneckerMap (fun a b => g (f a b)) A B)","decl":"theorem kroneckerMap_map (f : α → β → γ) (g : γ → γ') (A : Matrix l m α) (B : Matrix n p β) :\n    (kroneckerMap f A B).map g = kroneckerMap (fun a b => g (f a b)) A B :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.kroneckerMap_zero_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : Zero α\ninst✝ : Zero γ\nf : α → β → γ\nhf : ∀ (b : β), Eq (f 0 b) 0\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f 0 B) 0","decl":"@[simp]\ntheorem kroneckerMap_zero_left [Zero α] [Zero γ] (f : α → β → γ) (hf : ∀ b, f 0 b = 0)\n    (B : Matrix n p β) : kroneckerMap f (0 : Matrix l m α) B = 0 :=\n  ext fun _ _ => hf _\n\n"}
{"name":"Matrix.kroneckerMap_zero_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : Zero β\ninst✝ : Zero γ\nf : α → β → γ\nhf : ∀ (a : α), Eq (f a 0) 0\nA : Matrix l m α\n⊢ Eq (Matrix.kroneckerMap f A 0) 0","decl":"@[simp]\ntheorem kroneckerMap_zero_right [Zero β] [Zero γ] (f : α → β → γ) (hf : ∀ a, f a 0 = 0)\n    (A : Matrix l m α) : kroneckerMap f A (0 : Matrix n p β) = 0 :=\n  ext fun _ _ => hf _\n\n"}
{"name":"Matrix.kroneckerMap_add_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : Add α\ninst✝ : Add γ\nf : α → β → γ\nhf : ∀ (a₁ a₂ : α) (b : β), Eq (f (HAdd.hAdd a₁ a₂) b) (HAdd.hAdd (f a₁ b) (f a₂ b))\nA₁ A₂ : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f (HAdd.hAdd A₁ A₂) B) (HAdd.hAdd (Matrix.kroneckerMap f A₁ B) (Matrix.kroneckerMap f A₂ B))","decl":"theorem kroneckerMap_add_left [Add α] [Add γ] (f : α → β → γ)\n    (hf : ∀ a₁ a₂ b, f (a₁ + a₂) b = f a₁ b + f a₂ b) (A₁ A₂ : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f (A₁ + A₂) B = kroneckerMap f A₁ B + kroneckerMap f A₂ B :=\n  ext fun _ _ => hf _ _ _\n\n"}
{"name":"Matrix.kroneckerMap_add_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : Add β\ninst✝ : Add γ\nf : α → β → γ\nhf : ∀ (a : α) (b₁ b₂ : β), Eq (f a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (f a b₁) (f a b₂))\nA : Matrix l m α\nB₁ B₂ : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f A (HAdd.hAdd B₁ B₂)) (HAdd.hAdd (Matrix.kroneckerMap f A B₁) (Matrix.kroneckerMap f A B₂))","decl":"theorem kroneckerMap_add_right [Add β] [Add γ] (f : α → β → γ)\n    (hf : ∀ a b₁ b₂, f a (b₁ + b₂) = f a b₁ + f a b₂) (A : Matrix l m α) (B₁ B₂ : Matrix n p β) :\n    kroneckerMap f A (B₁ + B₂) = kroneckerMap f A B₁ + kroneckerMap f A B₂ :=\n  ext fun _ _ => hf _ _ _\n\n"}
{"name":"Matrix.kroneckerMap_smul_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : SMul R α\ninst✝ : SMul R γ\nf : α → β → γ\nr : R\nhf : ∀ (a : α) (b : β), Eq (f (HSMul.hSMul r a) b) (HSMul.hSMul r (f a b))\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f (HSMul.hSMul r A) B) (HSMul.hSMul r (Matrix.kroneckerMap f A B))","decl":"theorem kroneckerMap_smul_left [SMul R α] [SMul R γ] (f : α → β → γ) (r : R)\n    (hf : ∀ a b, f (r • a) b = r • f a b) (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f (r • A) B = r • kroneckerMap f A B :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"Matrix.kroneckerMap_smul_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝¹ : SMul R β\ninst✝ : SMul R γ\nf : α → β → γ\nr : R\nhf : ∀ (a : α) (b : β), Eq (f a (HSMul.hSMul r b)) (HSMul.hSMul r (f a b))\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f A (HSMul.hSMul r B)) (HSMul.hSMul r (Matrix.kroneckerMap f A B))","decl":"theorem kroneckerMap_smul_right [SMul R β] [SMul R γ] (f : α → β → γ) (r : R)\n    (hf : ∀ a b, f a (r • b) = r • f a b) (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerMap f A (r • B) = r • kroneckerMap f A B :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"Matrix.kroneckerMap_stdBasisMatrix_stdBasisMatrix","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁶ : Zero α\ninst✝⁵ : Zero β\ninst✝⁴ : Zero γ\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq p\ni₁ : l\nj₁ : m\ni₂ : n\nj₂ : p\nf : α → β → γ\nhf₁ : ∀ (b : β), Eq (f 0 b) 0\nhf₂ : ∀ (a : α), Eq (f a 0) 0\na : α\nb : β\n⊢ Eq (Matrix.kroneckerMap f (Matrix.stdBasisMatrix i₁ j₁ a) (Matrix.stdBasisMatrix i₂ j₂ b)) (Matrix.stdBasisMatrix { fst := i₁, snd := i₂ } { fst := j₁, snd := j₂ } (f a b))","decl":"theorem kroneckerMap_stdBasisMatrix_stdBasisMatrix\n    [Zero α] [Zero β] [Zero γ] [DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]\n    (i₁ : l) (j₁ : m) (i₂ : n) (j₂ : p)\n    (f : α → β → γ) (hf₁ : ∀ b, f 0 b = 0) (hf₂ : ∀ a, f a 0 = 0) (a : α) (b : β) :\n    kroneckerMap f (stdBasisMatrix i₁ j₁ a) (stdBasisMatrix i₂ j₂ b) =\n      stdBasisMatrix (i₁, i₂) (j₁, j₂) (f a b) := by\n  ext ⟨i₁', i₂'⟩ ⟨j₁', j₂'⟩\n  dsimp [stdBasisMatrix]\n  aesop\n\n"}
{"name":"Matrix.kroneckerMap_diagonal_diagonal","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nm : Type u_9\nn : Type u_10\ninst✝⁴ : Zero α\ninst✝³ : Zero β\ninst✝² : Zero γ\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nf : α → β → γ\nhf₁ : ∀ (b : β), Eq (f 0 b) 0\nhf₂ : ∀ (a : α), Eq (f a 0) 0\na : m → α\nb : n → β\n⊢ Eq (Matrix.kroneckerMap f (Matrix.diagonal a) (Matrix.diagonal b)) (Matrix.diagonal fun mn => f (a mn.1) (b mn.2))","decl":"theorem kroneckerMap_diagonal_diagonal [Zero α] [Zero β] [Zero γ] [DecidableEq m] [DecidableEq n]\n    (f : α → β → γ) (hf₁ : ∀ b, f 0 b = 0) (hf₂ : ∀ a, f a 0 = 0) (a : m → α) (b : n → β) :\n    kroneckerMap f (diagonal a) (diagonal b) = diagonal fun mn => f (a mn.1) (b mn.2) := by\n  ext ⟨i₁, i₂⟩ ⟨j₁, j₂⟩\n  simp [diagonal, apply_ite f, ite_and, ite_apply, apply_ite (f (a i₁)), hf₁, hf₂]\n\n"}
{"name":"Matrix.kroneckerMap_diagonal_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝² : Zero β\ninst✝¹ : Zero γ\ninst✝ : DecidableEq n\nf : α → β → γ\nhf : ∀ (a : α), Eq (f a 0) 0\nA : Matrix l m α\nb : n → β\n⊢ Eq (Matrix.kroneckerMap f A (Matrix.diagonal b)) (Matrix.blockDiagonal fun i => A.map fun a => f a (b i))","decl":"theorem kroneckerMap_diagonal_right [Zero β] [Zero γ] [DecidableEq n] (f : α → β → γ)\n    (hf : ∀ a, f a 0 = 0) (A : Matrix l m α) (b : n → β) :\n    kroneckerMap f A (diagonal b) = blockDiagonal fun i => A.map fun a => f a (b i) := by\n  ext ⟨i₁, i₂⟩ ⟨j₁, j₂⟩\n  simp [diagonal, blockDiagonal, apply_ite (f (A i₁ j₁)), hf]\n\n"}
{"name":"Matrix.kroneckerMap_diagonal_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝² : Zero α\ninst✝¹ : Zero γ\ninst✝ : DecidableEq l\nf : α → β → γ\nhf : ∀ (b : β), Eq (f 0 b) 0\na : l → α\nB : Matrix m n β\n⊢ Eq (Matrix.kroneckerMap f (Matrix.diagonal a) B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun i => B.map fun b => f (a i) b))","decl":"theorem kroneckerMap_diagonal_left [Zero α] [Zero γ] [DecidableEq l] (f : α → β → γ)\n    (hf : ∀ b, f 0 b = 0) (a : l → α) (B : Matrix m n β) :\n    kroneckerMap f (diagonal a) B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _)\n        (blockDiagonal fun i => B.map fun b => f (a i) b) := by\n  ext ⟨i₁, i₂⟩ ⟨j₁, j₂⟩\n  simp [diagonal, blockDiagonal, apply_ite f, ite_apply, hf]\n\n"}
{"name":"Matrix.kroneckerMap_one_one","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nm : Type u_9\nn : Type u_10\ninst✝⁷ : Zero α\ninst✝⁶ : Zero β\ninst✝⁵ : Zero γ\ninst✝⁴ : One α\ninst✝³ : One β\ninst✝² : One γ\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nf : α → β → γ\nhf₁ : ∀ (b : β), Eq (f 0 b) 0\nhf₂ : ∀ (a : α), Eq (f a 0) 0\nhf₃ : Eq (f 1 1) 1\n⊢ Eq (Matrix.kroneckerMap f 1 1) 1","decl":"@[simp]\ntheorem kroneckerMap_one_one [Zero α] [Zero β] [Zero γ] [One α] [One β] [One γ] [DecidableEq m]\n    [DecidableEq n] (f : α → β → γ) (hf₁ : ∀ b, f 0 b = 0) (hf₂ : ∀ a, f a 0 = 0)\n    (hf₃ : f 1 1 = 1) : kroneckerMap f (1 : Matrix m m α) (1 : Matrix n n β) = 1 :=\n  (kroneckerMap_diagonal_diagonal _ hf₁ hf₂ _ _).trans <| by simp only [hf₃, diagonal_one]\n\n"}
{"name":"Matrix.kroneckerMap_reindex","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\np' : Type u_17\nf : α → β → γ\nel : Equiv l l'\nem : Equiv m m'\nen : Equiv n n'\nep : Equiv p p'\nM : Matrix l m α\nN : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap f ((Matrix.reindex el em) M) ((Matrix.reindex en ep) N)) ((Matrix.reindex (el.prodCongr en) (em.prodCongr ep)) (Matrix.kroneckerMap f M N))","decl":"theorem kroneckerMap_reindex (f : α → β → γ) (el : l ≃ l') (em : m ≃ m') (en : n ≃ n') (ep : p ≃ p')\n    (M : Matrix l m α) (N : Matrix n p β) :\n    kroneckerMap f (reindex el em M) (reindex en ep N) =\n      reindex (el.prodCongr en) (em.prodCongr ep) (kroneckerMap f M N) := by\n  ext ⟨i, i'⟩ ⟨j, j'⟩\n  rfl\n\n"}
{"name":"Matrix.kroneckerMap_reindex_left","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\nf : α → β → γ\nel : Equiv l l'\nem : Equiv m m'\nM : Matrix l m α\nN : Matrix n n' β\n⊢ Eq (Matrix.kroneckerMap f ((Matrix.reindex el em) M) N) ((Matrix.reindex (el.prodCongr (Equiv.refl n)) (em.prodCongr (Equiv.refl n'))) (Matrix.kroneckerMap f M N))","decl":"theorem kroneckerMap_reindex_left (f : α → β → γ) (el : l ≃ l') (em : m ≃ m') (M : Matrix l m α)\n    (N : Matrix n n' β) :\n    kroneckerMap f (Matrix.reindex el em M) N =\n      reindex (el.prodCongr (Equiv.refl _)) (em.prodCongr (Equiv.refl _)) (kroneckerMap f M N) :=\n  kroneckerMap_reindex _ _ _ (Equiv.refl _) (Equiv.refl _) _ _\n\n"}
{"name":"Matrix.kroneckerMap_reindex_right","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\nf : α → β → γ\nem : Equiv m m'\nen : Equiv n n'\nM : Matrix l l' α\nN : Matrix m n β\n⊢ Eq (Matrix.kroneckerMap f M ((Matrix.reindex em en) N)) ((Matrix.reindex ((Equiv.refl l).prodCongr em) ((Equiv.refl l').prodCongr en)) (Matrix.kroneckerMap f M N))","decl":"theorem kroneckerMap_reindex_right (f : α → β → γ) (em : m ≃ m') (en : n ≃ n') (M : Matrix l l' α)\n    (N : Matrix m n β) :\n    kroneckerMap f M (reindex em en N) =\n      reindex ((Equiv.refl _).prodCongr em) ((Equiv.refl _).prodCongr en) (kroneckerMap f M N) :=\n  kroneckerMap_reindex _ (Equiv.refl _) (Equiv.refl _) _ _ _ _\n\n"}
{"name":"Matrix.kroneckerMap_assoc","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\nδ : Type u_18\nξ : Type u_19\nω : Type u_20\nω' : Type u_21\nf : α → β → γ\ng : γ → δ → ω\nf' : α → ξ → ω'\ng' : β → δ → ξ\nA : Matrix l m α\nB : Matrix n p β\nD : Matrix q r δ\nφ : Equiv ω ω'\nhφ : ∀ (a : α) (b : β) (d : δ), Eq (φ (g (f a b) d)) (f' a (g' b d))\n⊢ Eq (((Matrix.reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)).trans φ.mapMatrix) (Matrix.kroneckerMap g (Matrix.kroneckerMap f A B) D)) (Matrix.kroneckerMap f' A (Matrix.kroneckerMap g' B D))","decl":"theorem kroneckerMap_assoc {δ ξ ω ω' : Type*} (f : α → β → γ) (g : γ → δ → ω) (f' : α → ξ → ω')\n    (g' : β → δ → ξ) (A : Matrix l m α) (B : Matrix n p β) (D : Matrix q r δ) (φ : ω ≃ ω')\n    (hφ : ∀ a b d, φ (g (f a b) d) = f' a (g' b d)) :\n    (reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)).trans (Equiv.mapMatrix φ)\n        (kroneckerMap g (kroneckerMap f A B) D) =\n      kroneckerMap f' A (kroneckerMap g' B D) :=\n  ext fun _ _ => hφ _ _ _\n\n"}
{"name":"Matrix.kroneckerMap_assoc₁","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\nδ : Type u_18\nξ : Type u_19\nω : Type u_20\nf : α → β → γ\ng : γ → δ → ω\nf' : α → ξ → ω\ng' : β → δ → ξ\nA : Matrix l m α\nB : Matrix n p β\nD : Matrix q r δ\nh : ∀ (a : α) (b : β) (d : δ), Eq (g (f a b) d) (f' a (g' b d))\n⊢ Eq ((Matrix.reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)) (Matrix.kroneckerMap g (Matrix.kroneckerMap f A B) D)) (Matrix.kroneckerMap f' A (Matrix.kroneckerMap g' B D))","decl":"theorem kroneckerMap_assoc₁ {δ ξ ω : Type*} (f : α → β → γ) (g : γ → δ → ω) (f' : α → ξ → ω)\n    (g' : β → δ → ξ) (A : Matrix l m α) (B : Matrix n p β) (D : Matrix q r δ)\n    (h : ∀ a b d, g (f a b) d = f' a (g' b d)) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)\n        (kroneckerMap g (kroneckerMap f A B) D) =\n      kroneckerMap f' A (kroneckerMap g' B D) :=\n  ext fun _ _ => h _ _ _\n\n"}
{"name":"Matrix.kroneckerMapBilinear_apply_apply","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm✝ : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearMap (RingHom.id R) α (LinearMap (RingHom.id R) β γ)\nm : Matrix l m✝ α\nB : Matrix n p β\n⊢ Eq (((Matrix.kroneckerMapBilinear f) m) B) (Matrix.kroneckerMap (fun r s => (f r) s) m B)","decl":"/-- When `f` is bilinear then `Matrix.kroneckerMap f` is also bilinear. -/\n@[simps!]\ndef kroneckerMapBilinear [CommSemiring R] [AddCommMonoid α] [AddCommMonoid β] [AddCommMonoid γ]\n    [Module R α] [Module R β] [Module R γ] (f : α →ₗ[R] β →ₗ[R] γ) :\n    Matrix l m α →ₗ[R] Matrix n p β →ₗ[R] Matrix (l × n) (m × p) γ :=\n  LinearMap.mk₂ R (kroneckerMap fun r s => f r s) (kroneckerMap_add_left _ <| f.map_add₂)\n    (fun _ => kroneckerMap_smul_left _ _ <| f.map_smul₂ _)\n    (kroneckerMap_add_right _ fun a => (f a).map_add) fun r =>\n    kroneckerMap_smul_right _ _ fun a => (f a).map_smul r\n\n"}
{"name":"Matrix.kroneckerMapBilinear_mul_mul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype m'\ninst✝⁵ : NonUnitalNonAssocSemiring α\ninst✝⁴ : NonUnitalNonAssocSemiring β\ninst✝³ : NonUnitalNonAssocSemiring γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearMap (RingHom.id R) α (LinearMap (RingHom.id R) β γ)\nh_comm : ∀ (a b : α) (a' b' : β), Eq ((f (HMul.hMul a b)) (HMul.hMul a' b')) (HMul.hMul ((f a) a') ((f b) b'))\nA : Matrix l m α\nB : Matrix m n α\nA' : Matrix l' m' β\nB' : Matrix m' n' β\n⊢ Eq (((Matrix.kroneckerMapBilinear f) (HMul.hMul A B)) (HMul.hMul A' B')) (HMul.hMul (((Matrix.kroneckerMapBilinear f) A) A') (((Matrix.kroneckerMapBilinear f) B) B'))","decl":"/-- `Matrix.kroneckerMapBilinear` commutes with `*` if `f` does.\n\nThis is primarily used with `R = ℕ` to prove `Matrix.mul_kronecker_mul`. -/\ntheorem kroneckerMapBilinear_mul_mul [CommSemiring R] [Fintype m] [Fintype m']\n    [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] [NonUnitalNonAssocSemiring γ]\n    [Module R α] [Module R β] [Module R γ] (f : α →ₗ[R] β →ₗ[R] γ)\n    (h_comm : ∀ a b a' b', f (a * b) (a' * b') = f a a' * f b b') (A : Matrix l m α)\n    (B : Matrix m n α) (A' : Matrix l' m' β) (B' : Matrix m' n' β) :\n    kroneckerMapBilinear f (A * B) (A' * B') =\n      kroneckerMapBilinear f A A' * kroneckerMapBilinear f B B' := by\n  ext ⟨i, i'⟩ ⟨j, j'⟩\n  simp only [kroneckerMapBilinear_apply_apply, mul_apply, ← Finset.univ_product_univ,\n    Finset.sum_product, kroneckerMap_apply]\n  simp_rw [map_sum f, LinearMap.sum_apply, map_sum, h_comm]\n\n"}
{"name":"Matrix.trace_kroneckerMapBilinear","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nm : Type u_9\nn : Type u_10\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype n\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearMap (RingHom.id R) α (LinearMap (RingHom.id R) β γ)\nA : Matrix m m α\nB : Matrix n n β\n⊢ Eq (((Matrix.kroneckerMapBilinear f) A) B).trace ((f A.trace) B.trace)","decl":"/-- `trace` distributes over `Matrix.kroneckerMapBilinear`.\n\nThis is primarily used with `R = ℕ` to prove `Matrix.trace_kronecker`. -/\ntheorem trace_kroneckerMapBilinear [CommSemiring R] [Fintype m] [Fintype n] [AddCommMonoid α]\n    [AddCommMonoid β] [AddCommMonoid γ] [Module R α] [Module R β] [Module R γ]\n    (f : α →ₗ[R] β →ₗ[R] γ) (A : Matrix m m α) (B : Matrix n n β) :\n    trace (kroneckerMapBilinear f A B) = f (trace A) (trace B) := by\n  simp_rw [Matrix.trace, Matrix.diag, kroneckerMapBilinear_apply_apply, LinearMap.map_sum₂,\n    map_sum, ← Finset.univ_product_univ, Finset.sum_product, kroneckerMap_apply]\n\n"}
{"name":"Matrix.det_kroneckerMapBilinear","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nm : Type u_9\nn : Type u_10\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Fintype m\ninst✝⁸ : Fintype n\ninst✝⁷ : DecidableEq m\ninst✝⁶ : DecidableEq n\ninst✝⁵ : CommRing α\ninst✝⁴ : CommRing β\ninst✝³ : CommRing γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nf : LinearMap (RingHom.id R) α (LinearMap (RingHom.id R) β γ)\nh_comm : ∀ (a b : α) (a' b' : β), Eq ((f (HMul.hMul a b)) (HMul.hMul a' b')) (HMul.hMul ((f a) a') ((f b) b'))\nA : Matrix m m α\nB : Matrix n n β\n⊢ Eq (((Matrix.kroneckerMapBilinear f) A) B).det (HMul.hMul (HPow.hPow (A.map fun a => (f a) 1).det (Fintype.card n)) (HPow.hPow (B.map fun b => (f 1) b).det (Fintype.card m)))","decl":"/-- `determinant` of `Matrix.kroneckerMapBilinear`.\n\nThis is primarily used with `R = ℕ` to prove `Matrix.det_kronecker`. -/\ntheorem det_kroneckerMapBilinear [CommSemiring R] [Fintype m] [Fintype n] [DecidableEq m]\n    [DecidableEq n] [CommRing α] [CommRing β] [CommRing γ] [Module R α] [Module R β] [Module R γ]\n    (f : α →ₗ[R] β →ₗ[R] γ) (h_comm : ∀ a b a' b', f (a * b) (a' * b') = f a a' * f b b')\n    (A : Matrix m m α) (B : Matrix n n β) :\n    det (kroneckerMapBilinear f A B) =\n      det (A.map fun a => f a 1) ^ Fintype.card n * det (B.map fun b => f 1 b) ^ Fintype.card m :=\n  calc\n    det (kroneckerMapBilinear f A B) =\n        det (kroneckerMapBilinear f A 1 * kroneckerMapBilinear f 1 B) := by\n      rw [← kroneckerMapBilinear_mul_mul f h_comm, Matrix.mul_one, Matrix.one_mul]\n    _ = det (blockDiagonal fun (_ : n) => A.map fun a => f a 1) *\n        det (blockDiagonal fun (_ : m) => B.map fun b => f 1 b) := by\n      rw [det_mul, ← diagonal_one, ← diagonal_one, kroneckerMapBilinear_apply_apply,\n        kroneckerMap_diagonal_right _ fun _ => _, kroneckerMapBilinear_apply_apply,\n        kroneckerMap_diagonal_left _ fun _ => _, det_reindex_self]\n      · intro; exact LinearMap.map_zero₂ _ _\n      · intro; exact map_zero _\n    _ = _ := by simp_rw [det_blockDiagonal, Finset.prod_const, Finset.card_univ]\n\n"}
{"name":"Matrix.kronecker_apply","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝ : Mul α\nA : Matrix l m α\nB : Matrix n p α\ni₁ : l\ni₂ : n\nj₁ : m\nj₂ : p\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B { fst := i₁, snd := i₂ } { fst := j₁, snd := j₂ }) (HMul.hMul (A i₁ j₁) (B i₂ j₂))","decl":"@[simp]\ntheorem kronecker_apply [Mul α] (A : Matrix l m α) (B : Matrix n p α) (i₁ i₂ j₁ j₂) :\n    (A ⊗ₖ B) (i₁, i₂) (j₁, j₂) = A i₁ j₁ * B i₂ j₂ :=\n  rfl\n\n"}
{"name":"Matrix.zero_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝ : MulZeroClass α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) 0 B) 0","decl":"theorem zero_kronecker [MulZeroClass α] (B : Matrix n p α) : (0 : Matrix l m α) ⊗ₖ B = 0 :=\n  kroneckerMap_zero_left _ zero_mul B\n\n"}
{"name":"Matrix.kronecker_zero","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝ : MulZeroClass α\nA : Matrix l m α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A 0) 0","decl":"theorem kronecker_zero [MulZeroClass α] (A : Matrix l m α) : A ⊗ₖ (0 : Matrix n p α) = 0 :=\n  kroneckerMap_zero_right _ mul_zero A\n\n"}
{"name":"Matrix.add_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝ : Distrib α\nA₁ A₂ : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (HAdd.hAdd A₁ A₂) B) (HAdd.hAdd (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A₁ B) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A₂ B))","decl":"theorem add_kronecker [Distrib α] (A₁ A₂ : Matrix l m α) (B : Matrix n p α) :\n    (A₁ + A₂) ⊗ₖ B = A₁ ⊗ₖ B + A₂ ⊗ₖ B :=\n  kroneckerMap_add_left _ add_mul _ _ _\n\n"}
{"name":"Matrix.kronecker_add","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝ : Distrib α\nA : Matrix l m α\nB₁ B₂ : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (HAdd.hAdd B₁ B₂)) (HAdd.hAdd (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B₁) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B₂))","decl":"theorem kronecker_add [Distrib α] (A : Matrix l m α) (B₁ B₂ : Matrix n p α) :\n    A ⊗ₖ (B₁ + B₂) = A ⊗ₖ B₁ + A ⊗ₖ B₂ :=\n  kroneckerMap_add_right _ mul_add _ _ _\n\n"}
{"name":"Matrix.smul_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝³ : Monoid R\ninst✝² : Monoid α\ninst✝¹ : MulAction R α\ninst✝ : IsScalarTower R α α\nr : R\nA : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (HSMul.hSMul r A) B) (HSMul.hSMul r (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B))","decl":"theorem smul_kronecker [Monoid R] [Monoid α] [MulAction R α] [IsScalarTower R α α] (r : R)\n    (A : Matrix l m α) (B : Matrix n p α) : (r • A) ⊗ₖ B = r • A ⊗ₖ B :=\n  kroneckerMap_smul_left _ _ (fun _ _ => smul_mul_assoc _ _ _) _ _\n\n"}
{"name":"Matrix.kronecker_smul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝³ : Monoid R\ninst✝² : Monoid α\ninst✝¹ : MulAction R α\ninst✝ : SMulCommClass R α α\nr : R\nA : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (HSMul.hSMul r B)) (HSMul.hSMul r (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B))","decl":"theorem kronecker_smul [Monoid R] [Monoid α] [MulAction R α] [SMulCommClass R α α] (r : R)\n    (A : Matrix l m α) (B : Matrix n p α) : A ⊗ₖ (r • B) = r • A ⊗ₖ B :=\n  kroneckerMap_smul_right _ _ (fun _ _ => mul_smul_comm _ _ _) _ _\n\n"}
{"name":"Matrix.stdBasisMatrix_kronecker_stdBasisMatrix","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁴ : MulZeroClass α\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq p\nia : l\nja : m\nib : n\njb : p\na b : α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Matrix.stdBasisMatrix ia ja a) (Matrix.stdBasisMatrix ib jb b)) (Matrix.stdBasisMatrix { fst := ia, snd := ib } { fst := ja, snd := jb } (HMul.hMul a b))","decl":"theorem stdBasisMatrix_kronecker_stdBasisMatrix\n    [MulZeroClass α] [DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]\n    (ia : l) (ja : m) (ib : n) (jb : p) (a b : α) :\n    stdBasisMatrix ia ja a ⊗ₖ stdBasisMatrix ib jb b = stdBasisMatrix (ia, ib) (ja, jb) (a * b) :=\n  kroneckerMap_stdBasisMatrix_stdBasisMatrix _ _ _ _ _ zero_mul mul_zero _ _\n\n"}
{"name":"Matrix.diagonal_kronecker_diagonal","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝² : MulZeroClass α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\na : m → α\nb : n → α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Matrix.diagonal a) (Matrix.diagonal b)) (Matrix.diagonal fun mn => HMul.hMul (a mn.1) (b mn.2))","decl":"theorem diagonal_kronecker_diagonal [MulZeroClass α] [DecidableEq m] [DecidableEq n] (a : m → α)\n    (b : n → α) : diagonal a ⊗ₖ diagonal b = diagonal fun mn => a mn.1 * b mn.2 :=\n  kroneckerMap_diagonal_diagonal _ zero_mul mul_zero _ _\n\n"}
{"name":"Matrix.kronecker_diagonal","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : MulZeroClass α\ninst✝ : DecidableEq n\nA : Matrix l m α\nb : n → α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (Matrix.diagonal b)) (Matrix.blockDiagonal fun i => HSMul.hSMul (MulOpposite.op (b i)) A)","decl":"theorem kronecker_diagonal [MulZeroClass α] [DecidableEq n] (A : Matrix l m α) (b : n → α) :\n    A ⊗ₖ diagonal b = blockDiagonal fun i => A <• b i :=\n  kroneckerMap_diagonal_right _ mul_zero _ _\n\n"}
{"name":"Matrix.diagonal_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : MulZeroClass α\ninst✝ : DecidableEq l\na : l → α\nB : Matrix m n α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Matrix.diagonal a) B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun i => HSMul.hSMul (a i) B))","decl":"theorem diagonal_kronecker [MulZeroClass α] [DecidableEq l] (a : l → α) (B : Matrix m n α) :\n    diagonal a ⊗ₖ B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _) (blockDiagonal fun i => a i • B) :=\n  kroneckerMap_diagonal_left _ zero_mul _ _\n\n"}
{"name":"Matrix.natCast_kronecker_natCast","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝² : NonAssocSemiring α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\na b : Nat\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) ↑a ↑b) ↑(HMul.hMul a b)","decl":"@[simp]\ntheorem natCast_kronecker_natCast [NonAssocSemiring α] [DecidableEq m] [DecidableEq n] (a b : ℕ) :\n    (a : Matrix m m α) ⊗ₖ (b : Matrix n n α) = ↑(a * b) :=\n  (diagonal_kronecker_diagonal _ _).trans <| by simp_rw [← Nat.cast_mul]; rfl\n\n"}
{"name":"Matrix.kronecker_natCast","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq n\nA : Matrix l m α\nb : Nat\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A ↑b) (Matrix.blockDiagonal fun x => HSMul.hSMul b A)","decl":"theorem kronecker_natCast [NonAssocSemiring α] [DecidableEq n] (A : Matrix l m α) (b : ℕ) :\n    A ⊗ₖ (b : Matrix n n α) = blockDiagonal fun _ => b • A :=\n  kronecker_diagonal _ _ |>.trans <| by\n    congr! 2\n    ext\n    simp [(Nat.cast_commute b _).eq]\n\n"}
{"name":"Matrix.natCast_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq l\na : Nat\nB : Matrix m n α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (↑a) B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun x => HSMul.hSMul a B))","decl":"theorem natCast_kronecker [NonAssocSemiring α] [DecidableEq l] (a : ℕ) (B : Matrix m n α) :\n    (a : Matrix l l α) ⊗ₖ B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _) (blockDiagonal fun _ => a • B) :=\n  diagonal_kronecker _ _ |>.trans <| by\n    congr! 2\n    ext\n    simp [(Nat.cast_commute a _).eq]\n\n"}
{"name":"Matrix.kronecker_ofNat","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝² : Semiring α\ninst✝¹ : DecidableEq n\nA : Matrix l m α\nb : Nat\ninst✝ : b.AtLeastTwo\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (OfNat.ofNat b)) (Matrix.blockDiagonal fun x => HSMul.hSMul (MulOpposite.op (OfNat.ofNat b)) A)","decl":"theorem kronecker_ofNat [Semiring α] [DecidableEq n] (A : Matrix l m α) (b : ℕ) [b.AtLeastTwo] :\n    A ⊗ₖ (ofNat(b) : Matrix n n α) =\n      blockDiagonal fun _ => A <• (ofNat(b) : α) :=\n  kronecker_diagonal _ _\n\n"}
{"name":"Matrix.ofNat_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝² : Semiring α\ninst✝¹ : DecidableEq l\na : Nat\ninst✝ : a.AtLeastTwo\nB : Matrix m n α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (OfNat.ofNat a) B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun x => HSMul.hSMul (OfNat.ofNat a) B))","decl":"theorem ofNat_kronecker [Semiring α] [DecidableEq l] (a : ℕ) [a.AtLeastTwo] (B : Matrix m n α) :\n    (ofNat(a) : Matrix l l α) ⊗ₖ B =\n      Matrix.reindex (.prodComm _ _) (.prodComm _ _)\n        (blockDiagonal fun _ => (ofNat(a) : α) • B) :=\n  diagonal_kronecker _ _\n\n"}
{"name":"Matrix.one_kronecker_one","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝² : MulZeroOneClass α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) 1 1) 1","decl":"theorem one_kronecker_one [MulZeroOneClass α] [DecidableEq m] [DecidableEq n] :\n    (1 : Matrix m m α) ⊗ₖ (1 : Matrix n n α) = 1 :=\n  kroneckerMap_one_one _ zero_mul mul_zero (one_mul _)\n\n"}
{"name":"Matrix.kronecker_one","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : MulZeroOneClass α\ninst✝ : DecidableEq n\nA : Matrix l m α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A 1) (Matrix.blockDiagonal fun x => A)","decl":"theorem kronecker_one [MulZeroOneClass α] [DecidableEq n] (A : Matrix l m α) :\n    A ⊗ₖ (1 : Matrix n n α) = blockDiagonal fun _ => A :=\n  (kronecker_diagonal _ _).trans <| congr_arg _ <| funext fun _ => Matrix.ext fun _ _ => mul_one _\n\n"}
{"name":"Matrix.one_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝¹ : MulZeroOneClass α\ninst✝ : DecidableEq l\nB : Matrix m n α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) 1 B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun x => B))","decl":"theorem one_kronecker [MulZeroOneClass α] [DecidableEq l] (B : Matrix m n α) :\n    (1 : Matrix l l α) ⊗ₖ B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _) (blockDiagonal fun _ => B) :=\n  (diagonal_kronecker _ _).trans <|\n    congr_arg _ <| congr_arg _ <| funext fun _ => Matrix.ext fun _ _ => one_mul _\n\n"}
{"name":"Matrix.mul_kronecker_mul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\ninst✝² : Fintype m\ninst✝¹ : Fintype m'\ninst✝ : CommSemiring α\nA : Matrix l m α\nB : Matrix m n α\nA' : Matrix l' m' α\nB' : Matrix m' n' α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (HMul.hMul A B) (HMul.hMul A' B')) (HMul.hMul (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A A') (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) B B'))","decl":"theorem mul_kronecker_mul [Fintype m] [Fintype m'] [CommSemiring α] (A : Matrix l m α)\n    (B : Matrix m n α) (A' : Matrix l' m' α) (B' : Matrix m' n' α) :\n    (A * B) ⊗ₖ (A' * B') = A ⊗ₖ A' * B ⊗ₖ B' :=\n  kroneckerMapBilinear_mul_mul (Algebra.lmul ℕ α).toLinearMap mul_mul_mul_comm A B A' B'\n\n-- @[simp] -- Porting note: simp-normal form is `kronecker_assoc'`\n"}
{"name":"Matrix.kronecker_assoc","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\ninst✝ : Semigroup α\nA : Matrix l m α\nB : Matrix n p α\nC : Matrix q r α\n⊢ Eq ((Matrix.reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B) C)) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) B C))","decl":"theorem kronecker_assoc [Semigroup α] (A : Matrix l m α) (B : Matrix n p α) (C : Matrix q r α) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r) (A ⊗ₖ B ⊗ₖ C) = A ⊗ₖ (B ⊗ₖ C) :=\n  kroneckerMap_assoc₁ _ _ _ _ A B C mul_assoc\n\n"}
{"name":"Matrix.kronecker_assoc'","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\ninst✝ : Semigroup α\nA : Matrix l m α\nB : Matrix n p α\nC : Matrix q r α\n⊢ Eq ((Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B) C).submatrix ⇑(Equiv.prodAssoc l n q).symm ⇑(Equiv.prodAssoc m p r).symm) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) B C))","decl":"@[simp]\ntheorem kronecker_assoc' [Semigroup α] (A : Matrix l m α) (B : Matrix n p α) (C : Matrix q r α) :\n    submatrix (A ⊗ₖ B ⊗ₖ C) (Equiv.prodAssoc l n q).symm (Equiv.prodAssoc m p r).symm =\n    A ⊗ₖ (B ⊗ₖ C) :=\n  kroneckerMap_assoc₁ _ _ _ _ A B C mul_assoc\n\n"}
{"name":"Matrix.trace_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"α : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : Semiring α\nA : Matrix m m α\nB : Matrix n n α\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B).trace (HMul.hMul A.trace B.trace)","decl":"theorem trace_kronecker [Fintype m] [Fintype n] [Semiring α] (A : Matrix m m α) (B : Matrix n n α) :\n    trace (A ⊗ₖ B) = trace A * trace B :=\n  trace_kroneckerMapBilinear (Algebra.lmul ℕ α).toLinearMap _ _\n\n"}
{"name":"Matrix.det_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nm : Type u_9\nn : Type u_10\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing R\nA : Matrix m m R\nB : Matrix n n R\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B).det (HMul.hMul (HPow.hPow A.det (Fintype.card n)) (HPow.hPow B.det (Fintype.card m)))","decl":"theorem det_kronecker [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] [CommRing R]\n    (A : Matrix m m R) (B : Matrix n n R) :\n    det (A ⊗ₖ B) = det A ^ Fintype.card n * det B ^ Fintype.card m := by\n  refine (det_kroneckerMapBilinear (Algebra.lmul ℕ R).toLinearMap mul_mul_mul_comm _ _).trans ?_\n  congr 3\n  · ext i j\n    exact mul_one _\n  · ext i j\n    exact one_mul _\n\n"}
{"name":"Matrix.inv_kronecker","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nm : Type u_9\nn : Type u_10\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing R\nA : Matrix m m R\nB : Matrix n n R\n⊢ Eq (Inv.inv (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B)) (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) (Inv.inv A) (Inv.inv B))","decl":"theorem inv_kronecker [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] [CommRing R]\n    (A : Matrix m m R) (B : Matrix n n R) : (A ⊗ₖ B)⁻¹ = A⁻¹ ⊗ₖ B⁻¹ := by\n  -- handle the special cases where either matrix is not invertible\n  by_cases hA : IsUnit A.det\n  swap\n  · cases isEmpty_or_nonempty n\n    · subsingleton\n    have hAB : ¬IsUnit (A ⊗ₖ B).det := by\n      refine mt (fun hAB => ?_) hA\n      rw [det_kronecker] at hAB\n      exact (isUnit_pow_iff Fintype.card_ne_zero).mp (isUnit_of_mul_isUnit_left hAB)\n    rw [nonsing_inv_apply_not_isUnit _ hA, zero_kronecker, nonsing_inv_apply_not_isUnit _ hAB]\n  by_cases hB : IsUnit B.det; swap\n  · cases isEmpty_or_nonempty m\n    · subsingleton\n    have hAB : ¬IsUnit (A ⊗ₖ B).det := by\n      refine mt (fun hAB => ?_) hB\n      rw [det_kronecker] at hAB\n      exact (isUnit_pow_iff Fintype.card_ne_zero).mp (isUnit_of_mul_isUnit_right hAB)\n    rw [nonsing_inv_apply_not_isUnit _ hB, kronecker_zero, nonsing_inv_apply_not_isUnit _ hAB]\n  -- otherwise follows trivially from `mul_kronecker_mul`\n  · apply inv_eq_right_inv\n    rw [← mul_kronecker_mul, ← one_kronecker_one, mul_nonsing_inv _ hA, mul_nonsing_inv _ hB]\n\n"}
{"name":"Matrix.kroneckerTMul_apply","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nA : Matrix l m α\nB : Matrix n p β\ni₁ : l\ni₂ : n\nj₁ : m\nj₂ : p\n⊢ Eq (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B { fst := i₁, snd := i₂ } { fst := j₁, snd := j₂ }) (TensorProduct.tmul R (A i₁ j₁) (B i₂ j₂))","decl":"@[simp]\ntheorem kroneckerTMul_apply (A : Matrix l m α) (B : Matrix n p β) (i₁ i₂ j₁ j₂) :\n    (A ⊗ₖₜ B) (i₁, i₂) (j₁, j₂) = A i₁ j₁ ⊗ₜ[R] B i₂ j₂ :=\n  rfl\n\n"}
{"name":"Matrix.kroneckerTMulBilinear_apply","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nA : Matrix l m α\nB : Matrix n p β\n⊢ Eq (((Matrix.kroneckerTMulBilinear R) A) B) (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B)","decl":"@[simp]\ntheorem kroneckerTMulBilinear_apply (A : Matrix l m α) (B : Matrix n p β) :\n    kroneckerTMulBilinear R A B = A ⊗ₖₜ B := rfl\n\n"}
{"name":"Matrix.zero_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nB : Matrix n p β\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) 0 B) 0","decl":"theorem zero_kroneckerTMul (B : Matrix n p β) : (0 : Matrix l m α) ⊗ₖₜ[R] B = 0 :=\n  kroneckerMap_zero_left _ (zero_tmul α) B\n\n"}
{"name":"Matrix.kroneckerTMul_zero","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : Module R α\ninst✝ : Module R β\nA : Matrix l m α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A 0) 0","decl":"theorem kroneckerTMul_zero (A : Matrix l m α) : A ⊗ₖₜ[R] (0 : Matrix n p β) = 0 :=\n  kroneckerMap_zero_right _ (tmul_zero β) A\n\n"}
{"name":"Matrix.add_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\nA₁ A₂ : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (HAdd.hAdd A₁ A₂) B) (HAdd.hAdd (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A₁ B) (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A₂ B))","decl":"theorem add_kroneckerTMul (A₁ A₂ : Matrix l m α) (B : Matrix n p α) :\n    (A₁ + A₂) ⊗ₖₜ[R] B = A₁ ⊗ₖₜ B + A₂ ⊗ₖₜ B :=\n  kroneckerMap_add_left _ add_tmul _ _ _\n\n"}
{"name":"Matrix.kroneckerTMul_add","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\nA : Matrix l m α\nB₁ B₂ : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A (HAdd.hAdd B₁ B₂)) (HAdd.hAdd (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B₁) (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B₂))","decl":"theorem kroneckerTMul_add (A : Matrix l m α) (B₁ B₂ : Matrix n p α) :\n    A ⊗ₖₜ[R] (B₁ + B₂) = A ⊗ₖₜ B₁ + A ⊗ₖₜ B₂ :=\n  kroneckerMap_add_right _ tmul_add _ _ _\n\n"}
{"name":"Matrix.smul_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\nr : R\nA : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (HSMul.hSMul r A) B) (HSMul.hSMul r (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B))","decl":"theorem smul_kroneckerTMul (r : R) (A : Matrix l m α) (B : Matrix n p α) :\n    (r • A) ⊗ₖₜ[R] B = r • A ⊗ₖₜ B :=\n  kroneckerMap_smul_left _ _ (fun _ _ => smul_tmul' _ _ _) _ _\n\n"}
{"name":"Matrix.kroneckerTMul_smul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\nr : R\nA : Matrix l m α\nB : Matrix n p α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A (HSMul.hSMul r B)) (HSMul.hSMul r (Matrix.kroneckerMap (fun x1 x2 => TensorProduct.tmul R x1 x2) A B))","decl":"theorem kroneckerTMul_smul (r : R) (A : Matrix l m α) (B : Matrix n p α) :\n    A ⊗ₖₜ[R] (r • B) = r • A ⊗ₖₜ B :=\n  kroneckerMap_smul_right _ _ (fun _ _ => tmul_smul _ _ _) _ _\n\n"}
{"name":"Matrix.stdBasisMatrix_kroneckerTMul_stdBasisMatrix","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid α\ninst✝⁶ : AddCommMonoid β\ninst✝⁵ : Module R α\ninst✝⁴ : Module R β\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq p\ni₁ : l\nj₁ : m\ni₂ : n\nj₂ : p\na : α\nb : β\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (Matrix.stdBasisMatrix i₁ j₁ a) (Matrix.stdBasisMatrix i₂ j₂ b)) (Matrix.stdBasisMatrix { fst := i₁, snd := i₂ } { fst := j₁, snd := j₂ } (TensorProduct.tmul R a b))","decl":"theorem stdBasisMatrix_kroneckerTMul_stdBasisMatrix\n    [DecidableEq l] [DecidableEq m] [DecidableEq n] [DecidableEq p]\n    (i₁ : l) (j₁ : m) (i₂ : n) (j₂ : p) (a : α) (b : β) :\n    stdBasisMatrix i₁ j₁ a ⊗ₖₜ[R] stdBasisMatrix i₂ j₂ b =\n      stdBasisMatrix (i₁, i₂) (j₁, j₂) (a ⊗ₜ b) :=\n  kroneckerMap_stdBasisMatrix_stdBasisMatrix _ _ _ _ _ (zero_tmul _) (tmul_zero _) _ _\n\n"}
{"name":"Matrix.diagonal_kroneckerTMul_diagonal","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid α\ninst✝² : Module R α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\na : m → α\nb : n → α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (Matrix.diagonal a) (Matrix.diagonal b)) (Matrix.diagonal fun mn => TensorProduct.tmul R (a mn.1) (b mn.2))","decl":"theorem diagonal_kroneckerTMul_diagonal [DecidableEq m] [DecidableEq n] (a : m → α) (b : n → α) :\n    diagonal a ⊗ₖₜ[R] diagonal b = diagonal fun mn => a mn.1 ⊗ₜ b mn.2 :=\n  kroneckerMap_diagonal_diagonal _ (zero_tmul _) (tmul_zero _) _ _\n\n"}
{"name":"Matrix.kroneckerTMul_diagonal","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid α\ninst✝¹ : Module R α\ninst✝ : DecidableEq n\nA : Matrix l m α\nb : n → α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A (Matrix.diagonal b)) (Matrix.blockDiagonal fun i => A.map fun a => TensorProduct.tmul R a (b i))","decl":"theorem kroneckerTMul_diagonal [DecidableEq n] (A : Matrix l m α) (b : n → α) :\n    A ⊗ₖₜ[R] diagonal b = blockDiagonal fun i => A.map fun a => a ⊗ₜ[R] b i :=\n  kroneckerMap_diagonal_right _ (tmul_zero _) _ _\n\n"}
{"name":"Matrix.diagonal_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nl : Type u_8\nm : Type u_9\nn : Type u_10\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid α\ninst✝¹ : Module R α\ninst✝ : DecidableEq l\na : l → α\nB : Matrix m n α\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (Matrix.diagonal a) B) ((Matrix.reindex (Equiv.prodComm m l) (Equiv.prodComm n l)) (Matrix.blockDiagonal fun i => B.map fun b => TensorProduct.tmul R (a i) b))","decl":"theorem diagonal_kroneckerTMul [DecidableEq l] (a : l → α) (B : Matrix m n α) :\n    diagonal a ⊗ₖₜ[R] B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _)\n        (blockDiagonal fun i => B.map fun b => a i ⊗ₜ[R] b) :=\n  kroneckerMap_diagonal_left _ (zero_tmul _) _ _\n\n-- @[simp] -- Porting note: simp-normal form is `kroneckerTMul_assoc'`\n"}
{"name":"Matrix.kroneckerTMul_assoc","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nA : Matrix l m α\nB : Matrix n p β\nC : Matrix q r γ\n⊢ Eq ((Matrix.reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)) ((Matrix.kroneckerMap (TensorProduct.tmul R) (Matrix.kroneckerMap (TensorProduct.tmul R) A B) C).map ⇑(TensorProduct.assoc R α β γ))) (Matrix.kroneckerMap (TensorProduct.tmul R) A (Matrix.kroneckerMap (TensorProduct.tmul R) B C))","decl":"theorem kroneckerTMul_assoc (A : Matrix l m α) (B : Matrix n p β) (C : Matrix q r γ) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)\n        (((A ⊗ₖₜ[R] B) ⊗ₖₜ[R] C).map (TensorProduct.assoc R α β γ)) =\n      A ⊗ₖₜ[R] B ⊗ₖₜ[R] C :=\n  ext fun _ _ => assoc_tmul _ _ _\n\n"}
{"name":"Matrix.kroneckerTMul_assoc'","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nγ : Type u_6\nl : Type u_8\nm : Type u_9\nn : Type u_10\np : Type u_11\nq : Type u_12\nr : Type u_13\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : AddCommMonoid γ\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : Module R γ\nA : Matrix l m α\nB : Matrix n p β\nC : Matrix q r γ\n⊢ Eq (((Matrix.kroneckerMap (TensorProduct.tmul R) (Matrix.kroneckerMap (TensorProduct.tmul R) A B) C).map ⇑(TensorProduct.assoc R α β γ)).submatrix ⇑(Equiv.prodAssoc l n q).symm ⇑(Equiv.prodAssoc m p r).symm) (Matrix.kroneckerMap (TensorProduct.tmul R) A (Matrix.kroneckerMap (TensorProduct.tmul R) B C))","decl":"@[simp]\ntheorem kroneckerTMul_assoc' (A : Matrix l m α) (B : Matrix n p β) (C : Matrix q r γ) :\n    submatrix (((A ⊗ₖₜ[R] B) ⊗ₖₜ[R] C).map (TensorProduct.assoc R α β γ))\n      (Equiv.prodAssoc l n q).symm (Equiv.prodAssoc m p r).symm = A ⊗ₖₜ[R] B ⊗ₖₜ[R] C :=\n  ext fun _ _ => assoc_tmul _ _ _\n\n"}
{"name":"Matrix.trace_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nm : Type u_9\nn : Type u_10\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : Module R α\ninst✝² : Module R β\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nA : Matrix m m α\nB : Matrix n n β\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A B).trace (TensorProduct.tmul R A.trace B.trace)","decl":"theorem trace_kroneckerTMul [Fintype m] [Fintype n] (A : Matrix m m α) (B : Matrix n n β) :\n    trace (A ⊗ₖₜ[R] B) = trace A ⊗ₜ[R] trace B :=\n  trace_kroneckerMapBilinear (TensorProduct.mk R α β) _ _\n\n"}
{"name":"Matrix.one_kroneckerTMul_one","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nm : Type u_9\nn : Type u_10\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring α\ninst✝² : Algebra R α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) 1 1) 1","decl":"@[simp]\ntheorem one_kroneckerTMul_one [DecidableEq m] [DecidableEq n] :\n    (1 : Matrix m m α) ⊗ₖₜ[R] (1 : Matrix n n α) = 1 :=\n  kroneckerMap_one_one _ (zero_tmul _) (tmul_zero _) rfl\n\n"}
{"name":"Matrix.mul_kroneckerTMul_mul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nl : Type u_8\nm : Type u_9\nn : Type u_10\nl' : Type u_14\nm' : Type u_15\nn' : Type u_16\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring α\ninst✝⁴ : Semiring β\ninst✝³ : Algebra R α\ninst✝² : Algebra R β\ninst✝¹ : Fintype m\ninst✝ : Fintype m'\nA : Matrix l m α\nB : Matrix m n α\nA' : Matrix l' m' β\nB' : Matrix m' n' β\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) (HMul.hMul A B) (HMul.hMul A' B')) (HMul.hMul (Matrix.kroneckerMap (TensorProduct.tmul R) A A') (Matrix.kroneckerMap (TensorProduct.tmul R) B B'))","decl":"unseal mul in\ntheorem mul_kroneckerTMul_mul [Fintype m] [Fintype m'] (A : Matrix l m α) (B : Matrix m n α)\n    (A' : Matrix l' m' β) (B' : Matrix m' n' β) :\n    (A * B) ⊗ₖₜ[R] (A' * B') = A ⊗ₖₜ[R] A' * B ⊗ₖₜ[R] B' :=\n  kroneckerMapBilinear_mul_mul (TensorProduct.mk R α β) tmul_mul_tmul A B A' B'\n\n"}
{"name":"Matrix.det_kroneckerTMul","module":"Mathlib.Data.Matrix.Kronecker","initialProofState":"R : Type u_1\nα : Type u_2\nβ : Type u_4\nm : Type u_9\nn : Type u_10\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing α\ninst✝⁶ : CommRing β\ninst✝⁵ : Algebra R α\ninst✝⁴ : Algebra R β\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nA : Matrix m m α\nB : Matrix n n β\n⊢ Eq (Matrix.kroneckerMap (TensorProduct.tmul R) A B).det (TensorProduct.tmul R (HPow.hPow A.det (Fintype.card n)) (HPow.hPow B.det (Fintype.card m)))","decl":"unseal mul in\ntheorem det_kroneckerTMul [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n]\n    (A : Matrix m m α) (B : Matrix n n β) :\n    det (A ⊗ₖₜ[R] B) = (det A ^ Fintype.card n) ⊗ₜ[R] (det B ^ Fintype.card m) := by\n  refine (det_kroneckerMapBilinear (TensorProduct.mk R α β) tmul_mul_tmul _ _).trans ?_\n  simp (config := { eta := false }) only [mk_apply, ← includeLeft_apply (S := R),\n    ← includeRight_apply]\n  simp only [← AlgHom.mapMatrix_apply, ← AlgHom.map_det]\n  simp only [includeLeft_apply, includeRight_apply, tmul_pow, tmul_mul_tmul, one_pow,\n    _root_.mul_one, _root_.one_mul]\n\n"}
