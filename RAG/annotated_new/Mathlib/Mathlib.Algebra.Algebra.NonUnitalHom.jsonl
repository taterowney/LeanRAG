{"name":"NonUnitalAlgHom.mk.injEq","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\ntoDistribMulActionHom✝ : DistribMulActionHom φ A B\nmap_mul'✝ : ∀ (x y : A), Eq (toDistribMulActionHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom✝.toFun x) (toDistribMulActionHom✝.toFun y))\ntoDistribMulActionHom : DistribMulActionHom φ A B\nmap_mul' : ∀ (x y : A), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\n⊢ Eq (Eq { toDistribMulActionHom := toDistribMulActionHom✝, map_mul' := map_mul'✝ } { toDistribMulActionHom := toDistribMulActionHom, map_mul' := map_mul' }) (Eq toDistribMulActionHom✝ toDistribMulActionHom)","decl":"/-- A morphism respecting addition, multiplication, and scalar multiplication\n(denoted as `A →ₛₙₐ[φ] B`, or `A →ₙₐ[R] B` when `φ` is the identity on `R`).\nWhen these arise from algebra structures, this is the same\nas a not-necessarily-unital morphism of algebras. -/\nstructure NonUnitalAlgHom [Monoid R] [Monoid S] (φ : R →* S) (A : Type v) (B : Type w)\n    [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction S B] extends A →ₑ+[φ] B, A →ₙ* B\n\n"}
{"name":"NonUnitalAlgHom.mk.inj","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\ntoDistribMulActionHom✝ : DistribMulActionHom φ A B\nmap_mul'✝ : ∀ (x y : A), Eq (toDistribMulActionHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom✝.toFun x) (toDistribMulActionHom✝.toFun y))\ntoDistribMulActionHom : DistribMulActionHom φ A B\nmap_mul' : ∀ (x y : A), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\nx✝ : Eq { toDistribMulActionHom := toDistribMulActionHom✝, map_mul' := map_mul'✝ } { toDistribMulActionHom := toDistribMulActionHom, map_mul' := map_mul' }\n⊢ Eq toDistribMulActionHom✝ toDistribMulActionHom","decl":"/-- A morphism respecting addition, multiplication, and scalar multiplication\n(denoted as `A →ₛₙₐ[φ] B`, or `A →ₙₐ[R] B` when `φ` is the identity on `R`).\nWhen these arise from algebra structures, this is the same\nas a not-necessarily-unital morphism of algebras. -/\nstructure NonUnitalAlgHom [Monoid R] [Monoid S] (φ : R →* S) (A : Type v) (B : Type w)\n    [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction S B] extends A →ₑ+[φ] B, A →ₙ* B\n\n"}
{"name":"NonUnitalAlgHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁹ : Monoid R\ninst✝⁸ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : DistribMulAction R A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction S B\ninst✝³ : SizeOf R\ninst✝² : SizeOf S\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoDistribMulActionHom : DistribMulActionHom φ A B\nmap_mul' : ∀ (x y : A), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toDistribMulActionHom := toDistribMulActionHom, map_mul' := map_mul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toDistribMulActionHom))","decl":"/-- A morphism respecting addition, multiplication, and scalar multiplication\n(denoted as `A →ₛₙₐ[φ] B`, or `A →ₙₐ[R] B` when `φ` is the identity on `R`).\nWhen these arise from algebra structures, this is the same\nas a not-necessarily-unital morphism of algebras. -/\nstructure NonUnitalAlgHom [Monoid R] [Monoid S] (φ : R →* S) (A : Type v) (B : Type w)\n    [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction S B] extends A →ₑ+[φ] B, A →ₙ* B\n\n"}
{"name":"NonUnitalAlgHom.map_mul'","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nself : NonUnitalAlgHom φ A B\nx y : A\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- A morphism respecting addition, multiplication, and scalar multiplication\n(denoted as `A →ₛₙₐ[φ] B`, or `A →ₙₐ[R] B` when `φ` is the identity on `R`).\nWhen these arise from algebra structures, this is the same\nas a not-necessarily-unital morphism of algebras. -/\nstructure NonUnitalAlgHom [Monoid R] [Monoid S] (φ : R →* S) (A : Type v) (B : Type w)\n    [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction S B] extends A →ₑ+[φ] B, A →ₙ* B\n\n"}
{"name":"NonUnitalAlgSemiHomClass.toDistribMulActionSemiHomClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nS : outParam (Type u_3)\ninst✝⁶ : Monoid R\ninst✝⁵ : Monoid S\nφ : outParam (MonoidHom R S)\nA : outParam (Type u_4)\nB : outParam (Type u_5)\ninst✝⁴ : NonUnitalNonAssocSemiring A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : DistribMulAction R A\ninst✝¹ : DistribMulAction S B\ninst✝ : FunLike F A B\nself : NonUnitalAlgSemiHomClass F φ A B\n⊢ DistribMulActionSemiHomClass F (⇑φ) A B","decl":"/-- `NonUnitalAlgSemiHomClass F φ A B` asserts `F` is a type of bundled algebra homomorphisms\nfrom `A` to `B` which are equivariant with respect to `φ`. -/\nclass NonUnitalAlgSemiHomClass (F : Type*) {R S : outParam Type*} [Monoid R] [Monoid S]\n    (φ : outParam (R →* S)) (A B : outParam Type*)\n    [NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R A] [DistribMulAction S B] [FunLike F A B]\n    extends DistribMulActionSemiHomClass F φ A B, MulHomClass F A B : Prop\n\n"}
{"name":"NonUnitalAlgSemiHomClass.toMulHomClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nS : outParam (Type u_3)\ninst✝⁶ : Monoid R\ninst✝⁵ : Monoid S\nφ : outParam (MonoidHom R S)\nA : outParam (Type u_4)\nB : outParam (Type u_5)\ninst✝⁴ : NonUnitalNonAssocSemiring A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : DistribMulAction R A\ninst✝¹ : DistribMulAction S B\ninst✝ : FunLike F A B\nself : NonUnitalAlgSemiHomClass F φ A B\n⊢ MulHomClass F A B","decl":"/-- `NonUnitalAlgSemiHomClass F φ A B` asserts `F` is a type of bundled algebra homomorphisms\nfrom `A` to `B` which are equivariant with respect to `φ`. -/\nclass NonUnitalAlgSemiHomClass (F : Type*) {R S : outParam Type*} [Monoid R] [Monoid S]\n    (φ : outParam (R →* S)) (A B : outParam Type*)\n    [NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B]\n    [DistribMulAction R A] [DistribMulAction S B] [FunLike F A B]\n    extends DistribMulActionSemiHomClass F φ A B, MulHomClass F A B : Prop\n\n"}
{"name":"NonUnitalAlgHomClass.toNonUnitalRingHomClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\nx✝³ : Monoid R\nx✝² : Monoid S\nφ : outParam (MonoidHom R S)\nx✝¹ : NonUnitalNonAssocSemiring A\ninst✝³ : DistribMulAction R A\nx✝ : NonUnitalNonAssocSemiring B\ninst✝² : DistribMulAction S B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgSemiHomClass F φ A B\n⊢ NonUnitalRingHomClass F A B","decl":"instance (priority := 100) toNonUnitalRingHomClass\n  {F R S A B : Type*} {_ : Monoid R} {_ : Monoid S} {φ : outParam (R →* S)}\n    {_ : NonUnitalNonAssocSemiring A} [DistribMulAction R A]\n    {_ : NonUnitalNonAssocSemiring B} [DistribMulAction S B] [FunLike F A B]\n    [NonUnitalAlgSemiHomClass F φ A B] : NonUnitalRingHomClass F A B :=\n  { ‹NonUnitalAlgSemiHomClass F φ A B› with }\n\n"}
{"name":"NonUnitalAlgHomClass.instSemilinearMapClassOfNonUnitalAlgSemiHomClassToMonoidHomRingHom","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\nA : Type u_6\nB : Type u_7\nx✝³ : Semiring R\nx✝² : Semiring S\nφ : RingHom R S\nx✝¹ : NonUnitalSemiring A\nx✝ : NonUnitalSemiring B\ninst✝³ : Module R A\ninst✝² : Module S B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgSemiHomClass F (↑φ) A B\n⊢ SemilinearMapClass F φ A B","decl":"instance (priority := 100) {F R S A B : Type*}\n    {_ : Semiring R} {_ : Semiring S} {φ : R →+* S}\n    {_ : NonUnitalSemiring A} {_ : NonUnitalSemiring B} [Module R A] [Module S B] [FunLike F A B]\n    [NonUnitalAlgSemiHomClass (R := R) (S := S) F φ A B] :\n    SemilinearMapClass F φ A B :=\n  { ‹NonUnitalAlgSemiHomClass F φ A B› with map_smulₛₗ := map_smulₛₗ }\n\n"}
{"name":"NonUnitalAlgHomClass.instLinearMapClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type u_1\nB : Type u_2\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : Module R A\ninst✝³ : NonUnitalNonAssocSemiring B\nF : Type u_3\ninst✝² : FunLike F A B\ninst✝¹ : Module R B\ninst✝ : NonUnitalAlgHomClass F R A B\n⊢ LinearMapClass F R A B","decl":"instance (priority := 100) {F : Type*} [FunLike F A B] [Module R B] [NonUnitalAlgHomClass F R A B] :\n    LinearMapClass F R A B :=\n  { ‹NonUnitalAlgHomClass F R A B› with map_smulₛₗ := map_smulₛₗ }\n\n"}
{"name":"NonUnitalAlgHom.toFun_eq_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe (f : A →ₛₙₐ[φ] B) : f.toFun = ⇑f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁷ : Monoid R\ninst✝⁶ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : DistribMulAction S B\nF : Type u_2\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgSemiHomClass F φ A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\nprotected theorem coe_coe {F : Type*} [FunLike F A B]\n    [NonUnitalAlgSemiHomClass F φ A B] (f : F) :\n    ⇑(f : A →ₛₙₐ[φ] B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_injective","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (A →ₛₙₐ[φ] B) (A → B) (↑) := by\n  rintro ⟨⟨⟨f, _⟩, _⟩, _⟩ ⟨⟨⟨g, _⟩, _⟩, _⟩ h; congr\n"}
{"name":"NonUnitalAlgHom.instNonUnitalAlgSemiHomClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\n⊢ NonUnitalAlgSemiHomClass (NonUnitalAlgHom φ A B) φ A B","decl":"instance : NonUnitalAlgSemiHomClass (A →ₛₙₐ[φ] B) φ A B where\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n  map_mul f := f.map_mul'\n  map_smulₛₗ f := f.map_smul'\n\n"}
{"name":"NonUnitalAlgHom.ext_iff","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf g : NonUnitalAlgHom φ A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : A →ₛₙₐ[φ] B} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"NonUnitalAlgHom.ext","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf g : NonUnitalAlgHom φ A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A →ₛₙₐ[φ] B} (h : ∀ x, f x = g x) : f = g :=\n  coe_injective <| funext h\n\n"}
{"name":"NonUnitalAlgHom.congr_fun","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf g : NonUnitalAlgHom φ A B\nh : Eq f g\nx : A\n⊢ Eq (f x) (g x)","decl":"theorem congr_fun {f g : A →ₛₙₐ[φ] B} (h : f = g) (x : A) : f x = g x :=\n  h ▸ rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_mk","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : A → B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))\nh₂ : Eq ({ toFun := f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, map_smul' := h₁ }.toFun x) ({ toFun := f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\n⊢ Eq (⇑{ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ }) f","decl":"@[simp]\ntheorem coe_mk (f : A → B) (h₁ h₂ h₃ h₄) : ⇑(⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩ : A →ₛₙₐ[φ] B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.mk_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))\nh₂ : Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_smul' := h₁ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\n⊢ Eq { toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ } f","decl":"@[simp]\ntheorem mk_coe (f : A →ₛₙₐ[φ] B) (h₁ h₂ h₃ h₄) : (⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩ : A →ₛₙₐ[φ] B) = f := by\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.toDistribMulActionHom_eq_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq f.toDistribMulActionHom ↑f","decl":"@[simp]\ntheorem toDistribMulActionHom_eq_coe (f : A →ₛₙₐ[φ] B) : f.toDistribMulActionHom = ↑f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.toMulHom_eq_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq f.toMulHom ↑f","decl":"@[simp]\ntheorem toMulHom_eq_coe (f : A →ₛₙₐ[φ] B) : f.toMulHom = ↑f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_to_distribMulActionHom","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_to_distribMulActionHom (f : A →ₛₙₐ[φ] B) : ⇑(f : A →ₑ+[φ] B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_to_mulHom","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_to_mulHom (f : A →ₛₙₐ[φ] B) : ⇑(f : A →ₙ* B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.to_distribMulActionHom_injective","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf g : NonUnitalAlgHom φ A B\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem to_distribMulActionHom_injective {f g : A →ₛₙₐ[φ] B}\n    (h : (f : A →ₑ+[φ] B) = (g : A →ₑ+[φ] B)) : f = g := by\n  ext a\n  exact DistribMulActionHom.congr_fun h a\n\n"}
{"name":"NonUnitalAlgHom.to_mulHom_injective","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf g : NonUnitalAlgHom φ A B\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem to_mulHom_injective {f g : A →ₛₙₐ[φ] B} (h : (f : A →ₙ* B) = (g : A →ₙ* B)) : f = g := by\n  ext a\n  exact DFunLike.congr_fun h a\n\n"}
{"name":"NonUnitalAlgHom.coe_distribMulActionHom_mk","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))\nh₂ : Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_smul' := h₁ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\n⊢ Eq ↑{ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ } { toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }","decl":"@[norm_cast]\ntheorem coe_distribMulActionHom_mk (f : A →ₛₙₐ[φ] B) (h₁ h₂ h₃ h₄) :\n    ((⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩ : A →ₛₙₐ[φ] B) : A →ₑ+[φ] B) = ⟨⟨f, h₁⟩, h₂, h₃⟩ := by\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_mulHom_mk","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))\nh₂ : Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_smul' := h₁ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\n⊢ Eq ↑{ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ } { toFun := ⇑f, map_mul' := h₄ }","decl":"@[norm_cast]\ntheorem coe_mulHom_mk (f : A →ₛₙₐ[φ] B) (h₁ h₂ h₃ h₄) :\n    ((⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩ : A →ₛₙₐ[φ] B) : A →ₙ* B) = ⟨f, h₄⟩ := by\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.map_smul","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nc : R\nx : A\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (φ c) (f x))","decl":"@[simp] -- Marked as `@[simp]` because `MulActionSemiHomClass.map_smulₛₗ` can't be.\nprotected theorem map_smul (f : A →ₛₙₐ[φ] B) (c : R) (x : A) : f (c • x) = (φ c) • f x :=\n  map_smulₛₗ _ _ _\n\n"}
{"name":"NonUnitalAlgHom.map_add","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nx y : A\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"protected theorem map_add (f : A →ₛₙₐ[φ] B) (x y : A) : f (x + y) = f x + f y :=\n  map_add _ _ _\n\n"}
{"name":"NonUnitalAlgHom.map_mul","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\nx y : A\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"protected theorem map_mul (f : A →ₛₙₐ[φ] B) (x y : A) : f (x * y) = f x * f y :=\n  map_mul _ _ _\n\n"}
{"name":"NonUnitalAlgHom.map_zero","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nf : NonUnitalAlgHom φ A B\n⊢ Eq (f 0) 0","decl":"protected theorem map_zero (f : A →ₛₙₐ[φ] B) : f 0 = 0 :=\n  map_zero _\n\n"}
{"name":"NonUnitalAlgHom.coe_id","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝² : Monoid R\nA : Type v\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction R A\n⊢ Eq (⇑(NonUnitalAlgHom.id R A)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(NonUnitalAlgHom.id R A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_zero","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : A →ₛₙₐ[φ] B) = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_one","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝² : Monoid R\nA : Type v\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction R A\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ((1 : A →ₙₐ[R] A) : A → A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.zero_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\na : A\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : A) : (0 : A →ₛₙₐ[φ] B) a = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.one_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝² : Monoid R\nA : Type v\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction R A\na : A\n⊢ Eq (1 a) a","decl":"theorem one_apply (a : A) : (1 : A →ₙₐ[R] A) a = a :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_comp","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\nT : Type u_1\ninst✝⁹ : Monoid R\ninst✝⁸ : Monoid S\ninst✝⁷ : Monoid T\nφ : MonoidHom R S\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : DistribMulAction R A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : DistribMulAction S B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction T C\nψ : MonoidHom S T\nχ : MonoidHom R T\nf : NonUnitalAlgHom ψ B C\ng : NonUnitalAlgHom φ A B\ninst✝ : φ.CompTriple ψ χ\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_comp (f : B →ₛₙₐ[ψ] C) (g : A →ₛₙₐ[φ] B) [MonoidHom.CompTriple φ ψ χ] :\n    ⇑(f.comp g) = (⇑f) ∘ (⇑g) := rfl\n\n"}
{"name":"NonUnitalAlgHom.comp_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\nT : Type u_1\ninst✝⁹ : Monoid R\ninst✝⁸ : Monoid S\ninst✝⁷ : Monoid T\nφ : MonoidHom R S\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : DistribMulAction R A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : DistribMulAction S B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction T C\nψ : MonoidHom S T\nχ : MonoidHom R T\nf : NonUnitalAlgHom ψ B C\ng : NonUnitalAlgHom φ A B\ninst✝ : φ.CompTriple ψ χ\nx : A\n⊢ Eq ((f.comp g) x) (f (g x))","decl":"theorem comp_apply (f : B →ₛₙₐ[ψ] C) (g : A →ₛₙₐ[φ] B) [MonoidHom.CompTriple φ ψ χ] (x : A) :\n    f.comp g x = f (g x) := rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_inverse","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\nB₁ : Type u_2\ninst✝¹ : NonUnitalNonAssocSemiring B₁\ninst✝ : DistribMulAction R B₁\nf : NonUnitalAlgHom (MonoidHom.id R) A B₁\ng : B₁ → A\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (⇑(f.inverse g h₁ h₂)) g","decl":"@[simp]\ntheorem coe_inverse (f : A →ₙₐ[R] B₁) (g : B₁ → A) (h₁ : Function.LeftInverse g f)\n    (h₂ : Function.RightInverse g f) : (inverse f g h₁ h₂ : B₁ → A) = g :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_inverse'","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\nS : Type u₁\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\nφ : MonoidHom R S\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction S B\nφ' : MonoidHom S R\nf : NonUnitalAlgHom φ A B\ng : B → A\nk : Function.RightInverse ⇑φ' ⇑φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (⇑(f.inverse' g k h₁ h₂)) g","decl":"@[simp]\ntheorem coe_inverse' (f : A →ₛₙₐ[φ] B) (g : B → A)\n    (k : Function.RightInverse φ' φ)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n    (inverse' f g k h₁ h₂ : B → A) = g :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.fst_toFun","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nself : Prod A B\n⊢ Eq ((NonUnitalAlgHom.fst R A B) self) self.1","decl":"/-- The first projection of a product is a non-unital alg_hom. -/\n@[simps]\ndef fst : A × B →ₙₐ[R] A where\n  toFun := Prod.fst\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.fst_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nself : Prod A B\n⊢ Eq ((NonUnitalAlgHom.fst R A B) self) self.1","decl":"/-- The first projection of a product is a non-unital alg_hom. -/\n@[simps]\ndef fst : A × B →ₙₐ[R] A where\n  toFun := Prod.fst\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.snd_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nself : Prod A B\n⊢ Eq ((NonUnitalAlgHom.snd R A B) self) self.2","decl":"/-- The second projection of a product is a non-unital alg_hom. -/\n@[simps]\ndef snd : A × B →ₙₐ[R] B where\n  toFun := Prod.snd\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.snd_toFun","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nself : Prod A B\n⊢ Eq ((NonUnitalAlgHom.snd R A B) self) self.2","decl":"/-- The second projection of a product is a non-unital alg_hom. -/\n@[simps]\ndef snd : A × B →ₙₐ[R] B where\n  toFun := Prod.snd\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.prod_toFun","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A B\ng : NonUnitalAlgHom (MonoidHom.id R) A C\ni : A\n⊢ Eq ((f.prod g) i) (Pi.prod (⇑f) (⇑g) i)","decl":"/-- The prod of two morphisms is a morphism. -/\n@[simps]\ndef prod (f : A →ₙₐ[R] B) (g : A →ₙₐ[R] C) : A →ₙₐ[R] B × C where\n  toFun := Pi.prod f g\n  map_zero' := by simp only [Pi.prod, Prod.mk_zero_zero, map_zero]\n  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]\n  map_mul' x y := by simp only [Pi.prod, Prod.mk_mul_mk, map_mul]\n  map_smul' c x := by simp only [Pi.prod, map_smul, MonoidHom.id_apply, id_eq, Prod.smul_mk]\n\n"}
{"name":"NonUnitalAlgHom.prod_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A B\ng : NonUnitalAlgHom (MonoidHom.id R) A C\ni : A\n⊢ Eq ((f.prod g) i) (Pi.prod (⇑f) (⇑g) i)","decl":"/-- The prod of two morphisms is a morphism. -/\n@[simps]\ndef prod (f : A →ₙₐ[R] B) (g : A →ₙₐ[R] C) : A →ₙₐ[R] B × C where\n  toFun := Pi.prod f g\n  map_zero' := by simp only [Pi.prod, Prod.mk_zero_zero, map_zero]\n  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]\n  map_mul' x y := by simp only [Pi.prod, Prod.mk_mul_mk, map_mul]\n  map_smul' c x := by simp only [Pi.prod, map_smul, MonoidHom.id_apply, id_eq, Prod.smul_mk]\n\n"}
{"name":"NonUnitalAlgHom.coe_prod","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A B\ng : NonUnitalAlgHom (MonoidHom.id R) A C\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"theorem coe_prod (f : A →ₙₐ[R] B) (g : A →ₙₐ[R] C) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.fst_prod","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A B\ng : NonUnitalAlgHom (MonoidHom.id R) A C\n⊢ Eq ((NonUnitalAlgHom.fst R B C).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_prod (f : A →ₙₐ[R] B) (g : A →ₙₐ[R] C) : (fst R B C).comp (prod f g) = f := by\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.snd_prod","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A B\ng : NonUnitalAlgHom (MonoidHom.id R) A C\n⊢ Eq ((NonUnitalAlgHom.snd R B C).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_prod (f : A →ₙₐ[R] B) (g : A →ₙₐ[R] C) : (snd R B C).comp (prod f g) = g := by\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.prod_fst_snd","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\n⊢ Eq ((NonUnitalAlgHom.fst R A B).prod (NonUnitalAlgHom.snd R A B)) 1","decl":"@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1 :=\n  coe_injective Pi.prod_fst_snd\n\n"}
{"name":"NonUnitalAlgHom.prodEquiv_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : Prod (NonUnitalAlgHom (MonoidHom.id R) A B) (NonUnitalAlgHom (MonoidHom.id R) A C)\n⊢ Eq (NonUnitalAlgHom.prodEquiv f) (f.1.prod f.2)","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →ₙₐ[R] B) × (A →ₙₐ[R] C) ≃ (A →ₙₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.prodEquiv_symm_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁶ : Monoid R\nA : Type v\nB : Type w\nC : Type w₁\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R B\ninst✝ : DistribMulAction R C\nf : NonUnitalAlgHom (MonoidHom.id R) A (Prod B C)\n⊢ Eq (NonUnitalAlgHom.prodEquiv.symm f) { fst := (NonUnitalAlgHom.fst R B C).comp f, snd := (NonUnitalAlgHom.snd R B C).comp f }","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →ₙₐ[R] B) × (A →ₙₐ[R] C) ≃ (A →ₙₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_inl","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\n⊢ Eq ⇑(NonUnitalAlgHom.inl R A B) fun x => { fst := x, snd := 0 }","decl":"@[simp]\ntheorem coe_inl : (inl R A B : A → A × B) = fun x => (x, 0) :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.inl_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nx : A\n⊢ Eq ((NonUnitalAlgHom.inl R A B) x) { fst := x, snd := 0 }","decl":"theorem inl_apply (x : A) : inl R A B x = (x, 0) :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_inr","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\n⊢ Eq (⇑(NonUnitalAlgHom.inr R A B)) (Prod.mk 0)","decl":"@[simp]\ntheorem coe_inr : (inr R A B : B → A × B) = Prod.mk 0 :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.inr_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\nA : Type v\nB : Type w\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : DistribMulAction R A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : DistribMulAction R B\nx : B\n⊢ Eq ((NonUnitalAlgHom.inr R A B) x) { fst := 0, snd := x }","decl":"theorem inr_apply (x : B) : inr R A B x = (0, x) :=\n  rfl\n\n"}
{"name":"AlgHom.instNonUnitalAlgHomClassOfAlgHomClass","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"F : Type u_1\nR : Type u_2\ninst✝⁶ : CommSemiring R\nA : Type u_3\nB : Type u_4\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : FunLike F A B\ninst✝ : AlgHomClass F R A B\n⊢ NonUnitalAlgHomClass F R A B","decl":"instance (priority := 100) [FunLike F A B] [AlgHomClass F R A B] : NonUnitalAlgHomClass F R A B :=\n  { ‹AlgHomClass F R A B› with map_smulₛₗ := map_smul }\n\n"}
{"name":"AlgHom.toNonUnitalAlgHom_eq_coe","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u_2\ninst✝⁴ : CommSemiring R\nA : Type u_3\nB : Type u_4\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (↑f) (NonUnitalAlgHomClass.toNonUnitalAlgHom f)","decl":"@[simp]\ntheorem toNonUnitalAlgHom_eq_coe (f : A →ₐ[R] B) : f.toNonUnitalAlgHom = f :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.restrictScalars_apply","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : Monoid R\ninst✝⁹ : Monoid S\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalAlgHom (MonoidHom.id S) A B\nx : A\n⊢ Eq ((NonUnitalAlgHom.restrictScalars R f) x) (f x)","decl":"@[simp]\nlemma restrictScalars_apply (f : A →ₙₐ[S] B) (x : A) : f.restrictScalars R x = f x := rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_restrictScalars","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : Monoid R\ninst✝⁹ : Monoid S\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalAlgHom (MonoidHom.id S) A B\n⊢ Eq ↑(NonUnitalAlgHom.restrictScalars R f) ↑f","decl":"lemma coe_restrictScalars (f : A →ₙₐ[S] B) : (f.restrictScalars R : A →ₙ+* B) = f := rfl\n\n"}
{"name":"NonUnitalAlgHom.coe_restrictScalars'","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : Monoid R\ninst✝⁹ : Monoid S\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalAlgHom (MonoidHom.id S) A B\n⊢ Eq ⇑(NonUnitalAlgHom.restrictScalars R f) ⇑f","decl":"lemma coe_restrictScalars' (f : A →ₙₐ[S] B) : (f.restrictScalars R : A → B) = f := rfl\n\n"}
{"name":"NonUnitalAlgHom.restrictScalars_injective","module":"Mathlib.Algebra.Algebra.NonUnitalHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : Monoid R\ninst✝⁹ : Monoid S\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\n⊢ Function.Injective (NonUnitalAlgHom.restrictScalars R)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A →ₙₐ[S] B) → A →ₙₐ[R] B) :=\n  fun _ _ h ↦ ext (congr_fun h :)\n\n"}
