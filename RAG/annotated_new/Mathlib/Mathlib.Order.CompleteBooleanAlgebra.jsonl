{"name":"Order.Frame.MinimalAxioms.inf_sSup_le_iSup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : Order.Frame.MinimalAxioms α\na : α\ns : Set α\n⊢ LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"/-- Structure containing the minimal axioms required to check that an order is a frame. Do NOT use,\nexcept for implementing `Order.Frame` via `Order.Frame.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl` fields, which can be recovered using\n`Order.Frame.ofMinimalAxioms`. -/\nclass Order.Frame.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n\n"}
{"name":"Order.Coframe.MinimalAxioms.iInf_sup_le_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : Order.Coframe.MinimalAxioms α\na : α\ns : Set α\n⊢ LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))","decl":"/-- Structure containing the minimal axioms required to check that an order is a coframe. Do NOT\nuse, except for implementing `Order.Coframe` via `Order.Coframe.ofMinimalAxioms`.\n\nThis structure omits the `sdiff`, `hnot` fields, which can be recovered using\n`Order.Coframe.ofMinimalAxioms`. -/\nclass Order.Coframe.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n"}
{"name":"Order.Frame.himp_bot","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Frame α\na : α\n⊢ Eq (HImp.himp a Bot.bot) (HasCompl.compl a)","decl":"/-- A frame, aka complete Heyting algebra, is a complete lattice whose `⊓` distributes over `⨆`. -/\nclass Order.Frame (α : Type*) extends CompleteLattice α, HeytingAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n\n"}
{"name":"Order.Frame.le_himp_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Frame α\na b c : α\n⊢ Iff (LE.le a (HImp.himp b c)) (LE.le (Min.min a b) c)","decl":"/-- A frame, aka complete Heyting algebra, is a complete lattice whose `⊓` distributes over `⨆`. -/\nclass Order.Frame (α : Type*) extends CompleteLattice α, HeytingAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n\n"}
{"name":"Order.Frame.inf_sSup_le_iSup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Frame α\na : α\ns : Set α\n⊢ LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"/-- A frame, aka complete Heyting algebra, is a complete lattice whose `⊓` distributes over `⨆`. -/\nclass Order.Frame (α : Type*) extends CompleteLattice α, HeytingAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n\n"}
{"name":"Order.Coframe.top_sdiff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Coframe α\na : α\n⊢ Eq (SDiff.sdiff Top.top a) (HNot.hnot a)","decl":"/-- A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `⊔` distributes over `⨅`. -/\nclass Order.Coframe (α : Type*) extends CompleteLattice α, CoheytingAlgebra α where\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n"}
{"name":"Order.Coframe.sdiff_le_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Coframe α\na b c : α\n⊢ Iff (LE.le (SDiff.sdiff a b) c) (LE.le a (Max.max b c))","decl":"/-- A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `⊔` distributes over `⨅`. -/\nclass Order.Coframe (α : Type*) extends CompleteLattice α, CoheytingAlgebra α where\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n"}
{"name":"Order.Coframe.iInf_sup_le_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : Order.Coframe α\na : α\ns : Set α\n⊢ LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))","decl":"/-- A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `⊔` distributes over `⨅`. -/\nclass Order.Coframe (α : Type*) extends CompleteLattice α, CoheytingAlgebra α where\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n"}
{"name":"CompleteDistribLattice.MinimalAxioms.mk.injEq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ntoCompleteLattice✝ : CompleteLattice α\ninf_sSup_le_iSup_inf✝ : ∀ (a : α) (s : Set α), LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)\niInf_sup_le_sup_sInf✝ : ∀ (a : α) (s : Set α), LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))\ntoCompleteLattice : CompleteLattice α\ninf_sSup_le_iSup_inf : ∀ (a : α) (s : Set α), LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)\niInf_sup_le_sup_sInf : ∀ (a : α) (s : Set α), LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))\n⊢ Eq (Eq { toCompleteLattice := toCompleteLattice✝, inf_sSup_le_iSup_inf := inf_sSup_le_iSup_inf✝, iInf_sup_le_sup_sInf := iInf_sup_le_sup_sInf✝ } { toCompleteLattice := toCompleteLattice, inf_sSup_le_iSup_inf := inf_sSup_le_iSup_inf, iInf_sup_le_sup_sInf := iInf_sup_le_sup_sInf }) (Eq toCompleteLattice✝ toCompleteLattice)","decl":"/-- Structure containing the minimal axioms required to check that an order is a complete\ndistributive lattice. Do NOT use, except for implementing `CompleteDistribLattice` via\n`CompleteDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompleteDistribLattice.ofMinimalAxioms`. -/\nstructure CompleteDistribLattice.MinimalAxioms (α : Type u)\n    extends CompleteLattice α, Frame.MinimalAxioms α, Coframe.MinimalAxioms α where\n\n-- We give those projections better name further down\n"}
{"name":"CompleteDistribLattice.MinimalAxioms.iInf_sup_le_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteDistribLattice.MinimalAxioms α\na : α\ns : Set α\n⊢ LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))","decl":"/-- Structure containing the minimal axioms required to check that an order is a complete\ndistributive lattice. Do NOT use, except for implementing `CompleteDistribLattice` via\n`CompleteDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompleteDistribLattice.ofMinimalAxioms`. -/\nstructure CompleteDistribLattice.MinimalAxioms (α : Type u)\n    extends CompleteLattice α, Frame.MinimalAxioms α, Coframe.MinimalAxioms α where\n\n-- We give those projections better name further down\n"}
{"name":"CompleteDistribLattice.MinimalAxioms.mk.inj","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ntoCompleteLattice✝ : CompleteLattice α\ninf_sSup_le_iSup_inf✝ : ∀ (a : α) (s : Set α), LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)\niInf_sup_le_sup_sInf✝ : ∀ (a : α) (s : Set α), LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))\ntoCompleteLattice : CompleteLattice α\ninf_sSup_le_iSup_inf : ∀ (a : α) (s : Set α), LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)\niInf_sup_le_sup_sInf : ∀ (a : α) (s : Set α), LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))\nx✝ : Eq { toCompleteLattice := toCompleteLattice✝, inf_sSup_le_iSup_inf := inf_sSup_le_iSup_inf✝, iInf_sup_le_sup_sInf := iInf_sup_le_sup_sInf✝ } { toCompleteLattice := toCompleteLattice, inf_sSup_le_iSup_inf := inf_sSup_le_iSup_inf, iInf_sup_le_sup_sInf := iInf_sup_le_sup_sInf }\n⊢ Eq toCompleteLattice✝ toCompleteLattice","decl":"/-- Structure containing the minimal axioms required to check that an order is a complete\ndistributive lattice. Do NOT use, except for implementing `CompleteDistribLattice` via\n`CompleteDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompleteDistribLattice.ofMinimalAxioms`. -/\nstructure CompleteDistribLattice.MinimalAxioms (α : Type u)\n    extends CompleteLattice α, Frame.MinimalAxioms α, Coframe.MinimalAxioms α where\n\n-- We give those projections better name further down\n"}
{"name":"CompleteDistribLattice.MinimalAxioms.mk.sizeOf_spec","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : SizeOf α\ntoCompleteLattice : CompleteLattice α\ninf_sSup_le_iSup_inf : ∀ (a : α) (s : Set α), LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)\niInf_sup_le_sup_sInf : ∀ (a : α) (s : Set α), LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))\n⊢ Eq (SizeOf.sizeOf { toCompleteLattice := toCompleteLattice, inf_sSup_le_iSup_inf := inf_sSup_le_iSup_inf, iInf_sup_le_sup_sInf := iInf_sup_le_sup_sInf }) (HAdd.hAdd 1 (SizeOf.sizeOf toCompleteLattice))","decl":"/-- Structure containing the minimal axioms required to check that an order is a complete\ndistributive lattice. Do NOT use, except for implementing `CompleteDistribLattice` via\n`CompleteDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompleteDistribLattice.ofMinimalAxioms`. -/\nstructure CompleteDistribLattice.MinimalAxioms (α : Type u)\n    extends CompleteLattice α, Frame.MinimalAxioms α, Coframe.MinimalAxioms α where\n\n-- We give those projections better name further down\n"}
{"name":"CompleteDistribLattice.MinimalAxioms.inf_sSup_le_iSup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteDistribLattice.MinimalAxioms α\na : α\ns : Set α\n⊢ LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"/-- Structure containing the minimal axioms required to check that an order is a complete\ndistributive lattice. Do NOT use, except for implementing `CompleteDistribLattice` via\n`CompleteDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompleteDistribLattice.ofMinimalAxioms`. -/\nstructure CompleteDistribLattice.MinimalAxioms (α : Type u)\n    extends CompleteLattice α, Frame.MinimalAxioms α, Coframe.MinimalAxioms α where\n\n-- We give those projections better name further down\n"}
{"name":"CompleteDistribLattice.sdiff_le_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteDistribLattice α\na b c : α\n⊢ Iff (LE.le (SDiff.sdiff a b) c) (LE.le a (Max.max b c))","decl":"/-- A complete distributive lattice is a complete lattice whose `⊔` and `⊓` respectively\ndistribute over `⨅` and `⨆`. -/\nclass CompleteDistribLattice (α : Type*) extends Frame α, Coframe α, BiheytingAlgebra α\n\n"}
{"name":"CompleteDistribLattice.top_sdiff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteDistribLattice α\na : α\n⊢ Eq (SDiff.sdiff Top.top a) (HNot.hnot a)","decl":"/-- A complete distributive lattice is a complete lattice whose `⊔` and `⊓` respectively\ndistribute over `⨅` and `⨆`. -/\nclass CompleteDistribLattice (α : Type*) extends Frame α, Coframe α, BiheytingAlgebra α\n\n"}
{"name":"CompleteDistribLattice.iInf_sup_le_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteDistribLattice α\na : α\ns : Set α\n⊢ LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))","decl":"/-- A complete distributive lattice is a complete lattice whose `⊔` and `⊓` respectively\ndistribute over `⨅` and `⨆`. -/\nclass CompleteDistribLattice (α : Type*) extends Frame α, Coframe α, BiheytingAlgebra α\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.mk.injEq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ntoCompleteLattice✝ : CompleteLattice α\niInf_iSup_eq✝ : ∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))\ntoCompleteLattice : CompleteLattice α\niInf_iSup_eq : ∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))\n⊢ Eq (Eq { toCompleteLattice := toCompleteLattice✝, iInf_iSup_eq := iInf_iSup_eq✝ } { toCompleteLattice := toCompleteLattice, iInf_iSup_eq := iInf_iSup_eq }) (Eq toCompleteLattice✝ toCompleteLattice)","decl":"/-- Structure containing the minimal axioms required to check that an order is a completely\ndistributive. Do NOT use, except for implementing `CompletelyDistribLattice` via\n`CompletelyDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompletelyDistribLattice.ofMinimalAxioms`. -/\nstructure CompletelyDistribLattice.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.iInf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice.MinimalAxioms α\nι : Type u\nκ : ι → Type u\nf : (a : ι) → κ a → α\n⊢ Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))","decl":"/-- Structure containing the minimal axioms required to check that an order is a completely\ndistributive. Do NOT use, except for implementing `CompletelyDistribLattice` via\n`CompletelyDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompletelyDistribLattice.ofMinimalAxioms`. -/\nstructure CompletelyDistribLattice.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.mk.sizeOf_spec","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : SizeOf α\ntoCompleteLattice : CompleteLattice α\niInf_iSup_eq : ∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))\n⊢ Eq (SizeOf.sizeOf { toCompleteLattice := toCompleteLattice, iInf_iSup_eq := iInf_iSup_eq }) (HAdd.hAdd 1 (SizeOf.sizeOf toCompleteLattice))","decl":"/-- Structure containing the minimal axioms required to check that an order is a completely\ndistributive. Do NOT use, except for implementing `CompletelyDistribLattice` via\n`CompletelyDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompletelyDistribLattice.ofMinimalAxioms`. -/\nstructure CompletelyDistribLattice.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.mk.inj","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ntoCompleteLattice✝ : CompleteLattice α\niInf_iSup_eq✝ : ∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))\ntoCompleteLattice : CompleteLattice α\niInf_iSup_eq : ∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))\nx✝ : Eq { toCompleteLattice := toCompleteLattice✝, iInf_iSup_eq := iInf_iSup_eq✝ } { toCompleteLattice := toCompleteLattice, iInf_iSup_eq := iInf_iSup_eq }\n⊢ Eq toCompleteLattice✝ toCompleteLattice","decl":"/-- Structure containing the minimal axioms required to check that an order is a completely\ndistributive. Do NOT use, except for implementing `CompletelyDistribLattice` via\n`CompletelyDistribLattice.ofMinimalAxioms`.\n\nThis structure omits the `himp`, `compl`, `sdiff`, `hnot` fields, which can be recovered using\n`CompletelyDistribLattice.ofMinimalAxioms`. -/\nstructure CompletelyDistribLattice.MinimalAxioms (α : Type u) extends CompleteLattice α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.iInf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice α\nι : Type u\nκ : ι → Type u\nf : (a : ι) → κ a → α\n⊢ Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))","decl":"/-- A completely distributive lattice is a complete lattice whose `⨅` and `⨆`\ndistribute over each other. -/\nclass CompletelyDistribLattice (α : Type u) extends CompleteLattice α, BiheytingAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.top_sdiff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice α\na : α\n⊢ Eq (SDiff.sdiff Top.top a) (HNot.hnot a)","decl":"/-- A completely distributive lattice is a complete lattice whose `⨅` and `⨆`\ndistribute over each other. -/\nclass CompletelyDistribLattice (α : Type u) extends CompleteLattice α, BiheytingAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.sdiff_le_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice α\na b c : α\n⊢ Iff (LE.le (SDiff.sdiff a b) c) (LE.le a (Max.max b c))","decl":"/-- A completely distributive lattice is a complete lattice whose `⨅` and `⨆`\ndistribute over each other. -/\nclass CompletelyDistribLattice (α : Type u) extends CompleteLattice α, BiheytingAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.himp_bot","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice α\na : α\n⊢ Eq (HImp.himp a Bot.bot) (HasCompl.compl a)","decl":"/-- A completely distributive lattice is a complete lattice whose `⨅` and `⨆`\ndistribute over each other. -/\nclass CompletelyDistribLattice (α : Type u) extends CompleteLattice α, BiheytingAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"CompletelyDistribLattice.le_himp_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompletelyDistribLattice α\na b c : α\n⊢ Iff (LE.le a (HImp.himp b c)) (LE.le (Min.min a b) c)","decl":"/-- A completely distributive lattice is a complete lattice whose `⨅` and `⨆`\ndistribute over each other. -/\nclass CompletelyDistribLattice (α : Type u) extends CompleteLattice α, BiheytingAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n"}
{"name":"le_iInf_iSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : CompleteLattice α\nf : (a : ι) → κ a → α\n⊢ LE.le (iSup fun g => iInf fun a => f a (g a)) (iInf fun a => iSup fun b => f a b)","decl":"theorem le_iInf_iSup [CompleteLattice α] {f : ∀ a, κ a → α} :\n    (⨆ g : ∀ a, κ a, ⨅ a, f a (g a)) ≤ ⨅ a, ⨆ b, f a b :=\n  iSup_le fun _ => le_iInf fun a => le_trans (iInf_le _ a) (le_iSup _ _)\n\n"}
{"name":"iSup_iInf_le","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : CompleteLattice α\nf : (a : ι) → κ a → α\n⊢ LE.le (iSup fun a => iInf fun b => f a b) (iInf fun g => iSup fun a => f a (g a))","decl":"lemma iSup_iInf_le [CompleteLattice α] {f : ∀ a, κ a → α} :\n    ⨆ a, ⨅ b, f a b ≤ ⨅ g : ∀ a, κ a, ⨆ a, f a (g a) :=\n  le_iInf_iSup (α := αᵒᵈ)\n\n"}
{"name":"Order.Frame.MinimalAxioms.inf_sSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nminAx : Order.Frame.MinimalAxioms α\ns : Set α\na : α\n⊢ Eq (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"lemma inf_sSup_eq : a ⊓ sSup s = ⨆ b ∈ s, a ⊓ b :=\n  (minAx.inf_sSup_le_iSup_inf _ _).antisymm iSup_inf_le_inf_sSup\n\n"}
{"name":"Order.Frame.MinimalAxioms.sSup_inf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nminAx : Order.Frame.MinimalAxioms α\ns : Set α\nb : α\n⊢ Eq (Min.min (SupSet.sSup s) b) (iSup fun a => iSup fun h => Min.min a b)","decl":"lemma sSup_inf_eq : sSup s ⊓ b = ⨆ a ∈ s, a ⊓ b := by\n  simpa only [inf_comm] using @inf_sSup_eq α _ s b\n\n"}
{"name":"Order.Frame.MinimalAxioms.iSup_inf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nminAx : Order.Frame.MinimalAxioms α\nf : ι → α\na : α\n⊢ Eq (Min.min (iSup fun i => f i) a) (iSup fun i => Min.min (f i) a)","decl":"lemma iSup_inf_eq (f : ι → α) (a : α) : (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a := by\n  rw [iSup, sSup_inf_eq, iSup_range]\n\n"}
{"name":"Order.Frame.MinimalAxioms.inf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nminAx : Order.Frame.MinimalAxioms α\na : α\nf : ι → α\n⊢ Eq (Min.min a (iSup fun i => f i)) (iSup fun i => Min.min a (f i))","decl":"lemma inf_iSup_eq (a : α) (f : ι → α) : (a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i := by\n  simpa only [inf_comm] using minAx.iSup_inf_eq f a\n\n"}
{"name":"Order.Frame.MinimalAxioms.inf_iSup₂_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\nminAx : Order.Frame.MinimalAxioms α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Min.min a (iSup fun i => iSup fun j => f i j)) (iSup fun i => iSup fun j => Min.min a (f i j))","decl":"lemma inf_iSup₂_eq {f : ∀ i, κ i → α} (a : α) : (a ⊓ ⨆ i, ⨆ j, f i j) = ⨆ i, ⨆ j, a ⊓ f i j := by\n  simp only [inf_iSup_eq]\n\n"}
{"name":"Order.Coframe.MinimalAxioms.sup_sInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nminAx : Order.Coframe.MinimalAxioms α\ns : Set α\na : α\n⊢ Eq (Max.max a (InfSet.sInf s)) (iInf fun b => iInf fun h => Max.max a b)","decl":"lemma sup_sInf_eq : a ⊔ sInf s = ⨅ b ∈ s, a ⊔ b :=\n  sup_sInf_le_iInf_sup.antisymm (minAx.iInf_sup_le_sup_sInf _ _)\n\n"}
{"name":"Order.Coframe.MinimalAxioms.sInf_sup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nminAx : Order.Coframe.MinimalAxioms α\ns : Set α\nb : α\n⊢ Eq (Max.max (InfSet.sInf s) b) (iInf fun a => iInf fun h => Max.max a b)","decl":"lemma sInf_sup_eq : sInf s ⊔ b = ⨅ a ∈ s, a ⊔ b := by\n  simpa only [sup_comm] using @sup_sInf_eq α _ s b\n\n"}
{"name":"Order.Coframe.MinimalAxioms.iInf_sup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nminAx : Order.Coframe.MinimalAxioms α\nf : ι → α\na : α\n⊢ Eq (Max.max (iInf fun i => f i) a) (iInf fun i => Max.max (f i) a)","decl":"lemma iInf_sup_eq (f : ι → α) (a : α) : (⨅ i, f i) ⊔ a = ⨅ i, f i ⊔ a := by\n  rw [iInf, sInf_sup_eq, iInf_range]\n\n"}
{"name":"Order.Coframe.MinimalAxioms.sup_iInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nminAx : Order.Coframe.MinimalAxioms α\na : α\nf : ι → α\n⊢ Eq (Max.max a (iInf fun i => f i)) (iInf fun i => Max.max a (f i))","decl":"lemma sup_iInf_eq (a : α) (f : ι → α) : (a ⊔ ⨅ i, f i) = ⨅ i, a ⊔ f i := by\n  simpa only [sup_comm] using minAx.iInf_sup_eq f a\n\n"}
{"name":"Order.Coframe.MinimalAxioms.sup_iInf₂_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\nminAx : Order.Coframe.MinimalAxioms α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Max.max a (iInf fun i => iInf fun j => f i j)) (iInf fun i => iInf fun j => Max.max a (f i j))","decl":"lemma sup_iInf₂_eq {f : ∀ i, κ i → α} (a : α) : (a ⊔ ⨅ i, ⨅ j, f i j) = ⨅ i, ⨅ j, a ⊔ f i j := by\n  simp only [sup_iInf_eq]\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.iInf_iSup_eq'","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\nminAx : CompletelyDistribLattice.MinimalAxioms α\nf : (a : ι) → κ a → α\n⊢ let x := minAx.toCompleteLattice;\n  Eq (iInf fun i => iSup fun j => f i j) (iSup fun g => iInf fun i => f i (g i))","decl":"lemma iInf_iSup_eq' (f : ∀ a, κ a → α) :\n    let _ := minAx.toCompleteLattice\n    ⨅ i, ⨆ j, f i j = ⨆ g : ∀ i, κ i, ⨅ i, f i (g i) := by\n  let _ := minAx.toCompleteLattice\n  refine le_antisymm ?_ le_iInf_iSup\n  calc\n    _ = ⨅ a : range (range <| f ·), ⨆ b : a.1, b.1 := by\n      simp_rw [iInf_subtype, iInf_range, iSup_subtype, iSup_range]\n    _ = _ := minAx.iInf_iSup_eq _\n    _ ≤ _ := iSup_le fun g => by\n      refine le_trans ?_ <| le_iSup _ fun a => Classical.choose (g ⟨_, a, rfl⟩).2\n      refine le_iInf fun a => le_trans (iInf_le _ ⟨range (f a), a, rfl⟩) ?_\n      rw [← Classical.choose_spec (g ⟨_, a, rfl⟩).2]\n\n"}
{"name":"CompletelyDistribLattice.MinimalAxioms.iSup_iInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\nminAx : CompletelyDistribLattice.MinimalAxioms α\nf : (i : ι) → κ i → α\n⊢ let x := minAx.toCompleteLattice;\n  Eq (iSup fun i => iInf fun j => f i j) (iInf fun g => iSup fun i => f i (g i))","decl":"lemma iSup_iInf_eq (f : ∀ i, κ i → α) :\n    let _ := minAx.toCompleteLattice\n    ⨆ i, ⨅ j, f i j = ⨅ g : ∀ i, κ i, ⨆ i, f i (g i) := by\n  let _ := minAx.toCompleteLattice\n  refine le_antisymm iSup_iInf_le ?_\n  rw [minAx.iInf_iSup_eq']\n  refine iSup_le fun g => ?_\n  have ⟨a, ha⟩ : ∃ a, ∀ b, ∃ f, ∃ h : a = g f, h ▸ b = f (g f) := of_not_not fun h => by\n    push_neg at h\n    choose h hh using h\n    have := hh _ h rfl\n    contradiction\n  refine le_trans ?_ (le_iSup _ a)\n  refine le_iInf fun b => ?_\n  obtain ⟨h, rfl, rfl⟩ := ha b\n  exact iInf_le _ _\n\n"}
{"name":"iInf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : CompletelyDistribLattice α\nf : (a : ι) → κ a → α\n⊢ Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))","decl":"theorem iInf_iSup_eq [CompletelyDistribLattice α] {f : ∀ a, κ a → α} :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a) :=\n  CompletelyDistribLattice.MinimalAxioms.of.iInf_iSup_eq' _\n\n"}
{"name":"iSup_iInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : CompletelyDistribLattice α\nf : (a : ι) → κ a → α\n⊢ Eq (iSup fun a => iInf fun b => f a b) (iInf fun g => iSup fun a => f a (g a))","decl":"theorem iSup_iInf_eq [CompletelyDistribLattice α] {f : ∀ a, κ a → α} :\n    (⨆ a, ⨅ b, f a b) = ⨅ g : ∀ a, κ a, ⨆ a, f a (g a) :=\n  CompletelyDistribLattice.MinimalAxioms.of.iSup_iInf_eq _\n\n"}
{"name":"inf_sSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\ns : Set α\na : α\n⊢ Eq (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"theorem inf_sSup_eq : a ⊓ sSup s = ⨆ b ∈ s, a ⊓ b :=\n  (Frame.inf_sSup_le_iSup_inf _ _).antisymm iSup_inf_le_inf_sSup\n\n"}
{"name":"sSup_inf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\ns : Set α\nb : α\n⊢ Eq (Min.min (SupSet.sSup s) b) (iSup fun a => iSup fun h => Min.min a b)","decl":"theorem sSup_inf_eq : sSup s ⊓ b = ⨆ a ∈ s, a ⊓ b := by\n  simpa only [inf_comm] using @inf_sSup_eq α _ s b\n\n"}
{"name":"iSup_inf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Frame α\nf : ι → α\na : α\n⊢ Eq (Min.min (iSup fun i => f i) a) (iSup fun i => Min.min (f i) a)","decl":"theorem iSup_inf_eq (f : ι → α) (a : α) : (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a := by\n  rw [iSup, sSup_inf_eq, iSup_range]\n\n"}
{"name":"inf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Frame α\na : α\nf : ι → α\n⊢ Eq (Min.min a (iSup fun i => f i)) (iSup fun i => Min.min a (f i))","decl":"theorem inf_iSup_eq (a : α) (f : ι → α) : (a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i := by\n  simpa only [inf_comm] using iSup_inf_eq f a\n\n"}
{"name":"iSup₂_inf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Frame α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Min.min (iSup fun i => iSup fun j => f i j) a) (iSup fun i => iSup fun j => Min.min (f i j) a)","decl":"theorem iSup₂_inf_eq {f : ∀ i, κ i → α} (a : α) :\n    (⨆ (i) (j), f i j) ⊓ a = ⨆ (i) (j), f i j ⊓ a := by\n  simp only [iSup_inf_eq]\n\n"}
{"name":"inf_iSup₂_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Frame α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Min.min a (iSup fun i => iSup fun j => f i j)) (iSup fun i => iSup fun j => Min.min a (f i j))","decl":"theorem inf_iSup₂_eq {f : ∀ i, κ i → α} (a : α) :\n    (a ⊓ ⨆ (i) (j), f i j) = ⨆ (i) (j), a ⊓ f i j := by\n  simp only [inf_iSup_eq]\n\n"}
{"name":"iSup_inf_iSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\nι : Type u_1\nι' : Type u_2\nf : ι → α\ng : ι' → α\n⊢ Eq (Min.min (iSup fun i => f i) (iSup fun j => g j)) (iSup fun i => Min.min (f i.1) (g i.2))","decl":"theorem iSup_inf_iSup {ι ι' : Type*} {f : ι → α} {g : ι' → α} :\n    ((⨆ i, f i) ⊓ ⨆ j, g j) = ⨆ i : ι × ι', f i.1 ⊓ g i.2 := by\n  simp_rw [iSup_inf_eq, inf_iSup_eq, iSup_prod]\n\n"}
{"name":"biSup_inf_biSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\nι : Type u_1\nι' : Type u_2\nf : ι → α\ng : ι' → α\ns : Set ι\nt : Set ι'\n⊢ Eq (Min.min (iSup fun i => iSup fun h => f i) (iSup fun j => iSup fun h => g j)) (iSup fun p => iSup fun h => Min.min (f p.1) (g p.2))","decl":"theorem biSup_inf_biSup {ι ι' : Type*} {f : ι → α} {g : ι' → α} {s : Set ι} {t : Set ι'} :\n    ((⨆ i ∈ s, f i) ⊓ ⨆ j ∈ t, g j) = ⨆ p ∈ s ×ˢ t, f (p : ι × ι').1 ⊓ g p.2 := by\n  simp only [iSup_subtype', iSup_inf_iSup]\n  exact (Equiv.surjective _).iSup_congr (Equiv.Set.prod s t).symm fun x => rfl\n\n"}
{"name":"sSup_inf_sSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\ns t : Set α\n⊢ Eq (Min.min (SupSet.sSup s) (SupSet.sSup t)) (iSup fun p => iSup fun h => Min.min p.1 p.2)","decl":"theorem sSup_inf_sSup : sSup s ⊓ sSup t = ⨆ p ∈ s ×ˢ t, (p : α × α).1 ⊓ p.2 := by\n  simp only [sSup_eq_iSup, biSup_inf_biSup]\n\n"}
{"name":"iSup_disjoint_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Frame α\na : α\nf : ι → α\n⊢ Iff (Disjoint (iSup fun i => f i) a) (∀ (i : ι), Disjoint (f i) a)","decl":"theorem iSup_disjoint_iff {f : ι → α} : Disjoint (⨆ i, f i) a ↔ ∀ i, Disjoint (f i) a := by\n  simp only [disjoint_iff, iSup_inf_eq, iSup_eq_bot]\n\n"}
{"name":"disjoint_iSup_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Frame α\na : α\nf : ι → α\n⊢ Iff (Disjoint a (iSup fun i => f i)) (∀ (i : ι), Disjoint a (f i))","decl":"theorem disjoint_iSup_iff {f : ι → α} : Disjoint a (⨆ i, f i) ↔ ∀ i, Disjoint a (f i) := by\n  simpa only [disjoint_comm] using @iSup_disjoint_iff\n\n"}
{"name":"iSup₂_disjoint_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Frame α\na : α\nf : (i : ι) → κ i → α\n⊢ Iff (Disjoint (iSup fun i => iSup fun j => f i j) a) (∀ (i : ι) (j : κ i), Disjoint (f i j) a)","decl":"theorem iSup₂_disjoint_iff {f : ∀ i, κ i → α} :\n    Disjoint (⨆ (i) (j), f i j) a ↔ ∀ i j, Disjoint (f i j) a := by\n  simp_rw [iSup_disjoint_iff]\n\n"}
{"name":"disjoint_iSup₂_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Frame α\na : α\nf : (i : ι) → κ i → α\n⊢ Iff (Disjoint a (iSup fun i => iSup fun j => f i j)) (∀ (i : ι) (j : κ i), Disjoint a (f i j))","decl":"theorem disjoint_iSup₂_iff {f : ∀ i, κ i → α} :\n    Disjoint a (⨆ (i) (j), f i j) ↔ ∀ i j, Disjoint a (f i j) := by\n  simp_rw [disjoint_iSup_iff]\n\n"}
{"name":"sSup_disjoint_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\na : α\ns : Set α\n⊢ Iff (Disjoint (SupSet.sSup s) a) (∀ (b : α), Membership.mem s b → Disjoint b a)","decl":"theorem sSup_disjoint_iff {s : Set α} : Disjoint (sSup s) a ↔ ∀ b ∈ s, Disjoint b a := by\n  simp only [disjoint_iff, sSup_inf_eq, iSup_eq_bot]\n\n"}
{"name":"disjoint_sSup_iff","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\na : α\ns : Set α\n⊢ Iff (Disjoint a (SupSet.sSup s)) (∀ (b : α), Membership.mem s b → Disjoint a b)","decl":"theorem disjoint_sSup_iff {s : Set α} : Disjoint a (sSup s) ↔ ∀ b ∈ s, Disjoint a b := by\n  simpa only [disjoint_comm] using @sSup_disjoint_iff\n\n"}
{"name":"iSup_inf_of_monotone","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝² : Order.Frame α\nι : Type u_1\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf g : ι → α\nhf : Monotone f\nhg : Monotone g\n⊢ Eq (iSup fun i => Min.min (f i) (g i)) (Min.min (iSup fun i => f i) (iSup fun i => g i))","decl":"theorem iSup_inf_of_monotone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f g : ι → α}\n    (hf : Monotone f) (hg : Monotone g) : ⨆ i, f i ⊓ g i = (⨆ i, f i) ⊓ ⨆ i, g i := by\n  refine (le_iSup_inf_iSup f g).antisymm ?_\n  rw [iSup_inf_iSup]\n  refine iSup_mono' fun i => ?_\n  rcases directed_of (· ≤ ·) i.1 i.2 with ⟨j, h₁, h₂⟩\n  exact ⟨j, inf_le_inf (hf h₁) (hg h₂)⟩\n\n"}
{"name":"iSup_inf_of_antitone","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝² : Order.Frame α\nι : Type u_1\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι (Function.swap fun x1 x2 => LE.le x1 x2)\nf g : ι → α\nhf : Antitone f\nhg : Antitone g\n⊢ Eq (iSup fun i => Min.min (f i) (g i)) (Min.min (iSup fun i => f i) (iSup fun i => g i))","decl":"theorem iSup_inf_of_antitone {ι : Type*} [Preorder ι] [IsDirected ι (swap (· ≤ ·))] {f g : ι → α}\n    (hf : Antitone f) (hg : Antitone g) : ⨆ i, f i ⊓ g i = (⨆ i, f i) ⊓ ⨆ i, g i :=\n  @iSup_inf_of_monotone α _ ιᵒᵈ _ _ f g hf.dual_left hg.dual_left\n\n"}
{"name":"himp_eq_sSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\na b : α\n⊢ Eq (HImp.himp a b) (SupSet.sSup (setOf fun w => LE.le (Min.min w a) b))","decl":"theorem himp_eq_sSup : a ⇨ b = sSup {w | w ⊓ a ≤ b} :=\n  (isGreatest_himp a b).isLUB.sSup_eq.symm\n\n"}
{"name":"compl_eq_sSup_disjoint","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Frame α\na : α\n⊢ Eq (HasCompl.compl a) (SupSet.sSup (setOf fun w => Disjoint w a))","decl":"theorem compl_eq_sSup_disjoint : aᶜ = sSup {w | Disjoint w a} :=\n  (isGreatest_compl a).isLUB.sSup_eq.symm\n\n-- see Note [lower instance priority]\n"}
{"name":"sup_sInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\ns : Set α\na : α\n⊢ Eq (Max.max a (InfSet.sInf s)) (iInf fun b => iInf fun h => Max.max a b)","decl":"theorem sup_sInf_eq : a ⊔ sInf s = ⨅ b ∈ s, a ⊔ b :=\n  @inf_sSup_eq αᵒᵈ _ _ _\n\n"}
{"name":"sInf_sup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\ns : Set α\nb : α\n⊢ Eq (Max.max (InfSet.sInf s) b) (iInf fun a => iInf fun h => Max.max a b)","decl":"theorem sInf_sup_eq : sInf s ⊔ b = ⨅ a ∈ s, a ⊔ b :=\n  @sSup_inf_eq αᵒᵈ _ _ _\n\n"}
{"name":"iInf_sup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Coframe α\nf : ι → α\na : α\n⊢ Eq (Max.max (iInf fun i => f i) a) (iInf fun i => Max.max (f i) a)","decl":"theorem iInf_sup_eq (f : ι → α) (a : α) : (⨅ i, f i) ⊔ a = ⨅ i, f i ⊔ a :=\n  @iSup_inf_eq αᵒᵈ _ _ _ _\n\n"}
{"name":"sup_iInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Order.Coframe α\na : α\nf : ι → α\n⊢ Eq (Max.max a (iInf fun i => f i)) (iInf fun i => Max.max a (f i))","decl":"theorem sup_iInf_eq (a : α) (f : ι → α) : (a ⊔ ⨅ i, f i) = ⨅ i, a ⊔ f i :=\n  @inf_iSup_eq αᵒᵈ _ _ _ _\n\n"}
{"name":"iInf₂_sup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Coframe α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Max.max (iInf fun i => iInf fun j => f i j) a) (iInf fun i => iInf fun j => Max.max (f i j) a)","decl":"theorem iInf₂_sup_eq {f : ∀ i, κ i → α} (a : α) : (⨅ (i) (j), f i j) ⊔ a = ⨅ (i) (j), f i j ⊔ a :=\n  @iSup₂_inf_eq αᵒᵈ _ _ _ _ _\n\n"}
{"name":"sup_iInf₂_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\nκ : ι → Sort w'\ninst✝ : Order.Coframe α\nf : (i : ι) → κ i → α\na : α\n⊢ Eq (Max.max a (iInf fun i => iInf fun j => f i j)) (iInf fun i => iInf fun j => Max.max a (f i j))","decl":"theorem sup_iInf₂_eq {f : ∀ i, κ i → α} (a : α) : (a ⊔ ⨅ (i) (j), f i j) = ⨅ (i) (j), a ⊔ f i j :=\n  @inf_iSup₂_eq αᵒᵈ _ _ _ _ _\n\n"}
{"name":"iInf_sup_iInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\nι : Type u_1\nι' : Type u_2\nf : ι → α\ng : ι' → α\n⊢ Eq (Max.max (iInf fun i => f i) (iInf fun i => g i)) (iInf fun i => Max.max (f i.1) (g i.2))","decl":"theorem iInf_sup_iInf {ι ι' : Type*} {f : ι → α} {g : ι' → α} :\n    ((⨅ i, f i) ⊔ ⨅ i, g i) = ⨅ i : ι × ι', f i.1 ⊔ g i.2 :=\n  @iSup_inf_iSup αᵒᵈ _ _ _ _ _\n\n"}
{"name":"biInf_sup_biInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\nι : Type u_1\nι' : Type u_2\nf : ι → α\ng : ι' → α\ns : Set ι\nt : Set ι'\n⊢ Eq (Max.max (iInf fun i => iInf fun h => f i) (iInf fun j => iInf fun h => g j)) (iInf fun p => iInf fun h => Max.max (f p.1) (g p.2))","decl":"theorem biInf_sup_biInf {ι ι' : Type*} {f : ι → α} {g : ι' → α} {s : Set ι} {t : Set ι'} :\n    ((⨅ i ∈ s, f i) ⊔ ⨅ j ∈ t, g j) = ⨅ p ∈ s ×ˢ t, f (p : ι × ι').1 ⊔ g p.2 :=\n  @biSup_inf_biSup αᵒᵈ _ _ _ _ _ _ _\n\n"}
{"name":"sInf_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\ns t : Set α\n⊢ Eq (Max.max (InfSet.sInf s) (InfSet.sInf t)) (iInf fun p => iInf fun h => Max.max p.1 p.2)","decl":"theorem sInf_sup_sInf : sInf s ⊔ sInf t = ⨅ p ∈ s ×ˢ t, (p : α × α).1 ⊔ p.2 :=\n  @sSup_inf_sSup αᵒᵈ _ _ _\n\n"}
{"name":"iInf_sup_of_monotone","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝² : Order.Coframe α\nι : Type u_1\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι (Function.swap fun x1 x2 => LE.le x1 x2)\nf g : ι → α\nhf : Monotone f\nhg : Monotone g\n⊢ Eq (iInf fun i => Max.max (f i) (g i)) (Max.max (iInf fun i => f i) (iInf fun i => g i))","decl":"theorem iInf_sup_of_monotone {ι : Type*} [Preorder ι] [IsDirected ι (swap (· ≤ ·))] {f g : ι → α}\n    (hf : Monotone f) (hg : Monotone g) : ⨅ i, f i ⊔ g i = (⨅ i, f i) ⊔ ⨅ i, g i :=\n  @iSup_inf_of_antitone αᵒᵈ _ _ _ _ _ _ hf.dual_right hg.dual_right\n\n"}
{"name":"iInf_sup_of_antitone","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝² : Order.Coframe α\nι : Type u_1\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf g : ι → α\nhf : Antitone f\nhg : Antitone g\n⊢ Eq (iInf fun i => Max.max (f i) (g i)) (Max.max (iInf fun i => f i) (iInf fun i => g i))","decl":"theorem iInf_sup_of_antitone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f g : ι → α}\n    (hf : Antitone f) (hg : Antitone g) : ⨅ i, f i ⊔ g i = (⨅ i, f i) ⊔ ⨅ i, g i :=\n  @iSup_inf_of_monotone αᵒᵈ _ _ _ _ _ _ hf.dual_right hg.dual_right\n\n"}
{"name":"sdiff_eq_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\na b : α\n⊢ Eq (SDiff.sdiff a b) (InfSet.sInf (setOf fun w => LE.le a (Max.max b w)))","decl":"theorem sdiff_eq_sInf : a \\ b = sInf {w | a ≤ b ⊔ w} :=\n  (isLeast_sdiff a b).isGLB.sInf_eq.symm\n\n"}
{"name":"hnot_eq_sInf_codisjoint","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : Order.Coframe α\na : α\n⊢ Eq (HNot.hnot a) (InfSet.sInf (setOf fun w => Codisjoint a w))","decl":"theorem hnot_eq_sInf_codisjoint : ￢a = sInf {w | Codisjoint a w} :=\n  (isLeast_hnot a).isGLB.sInf_eq.symm\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.top_le_sup_compl","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\nx : α\n⊢ LE.le Top.top (Max.max x (HasCompl.compl x))","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.inf_sSup_le_iSup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\na : α\ns : Set α\n⊢ LE.le (Min.min a (SupSet.sSup s)) (iSup fun b => iSup fun h => Min.min a b)","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.le_sup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\nx y z : α\n⊢ LE.le (Min.min (Max.max x y) (Max.max x z)) (Max.max x (Min.min y z))","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.himp_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\nx y : α\n⊢ Eq (HImp.himp x y) (Max.max y (HasCompl.compl x))","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.iInf_sup_le_sup_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\na : α\ns : Set α\n⊢ LE.le (iInf fun b => iInf fun h => Max.max a b) (Max.max a (InfSet.sInf s))","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.sdiff_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\nx y : α\n⊢ Eq (SDiff.sdiff x y) (Min.min x (HasCompl.compl y))","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteBooleanAlgebra.inf_compl_le_bot","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u_1\nself : CompleteBooleanAlgebra α\nx : α\n⊢ LE.le (Min.min x (HasCompl.compl x)) Bot.bot","decl":"/--\nA complete Boolean algebra is a Boolean algebra that is also a complete distributive lattice.\n\nIt is only completely distributive if it is also atomic.\n-/\n-- We do not directly extend `CompleteDistribLattice` to avoid having the `hnot` field\nclass CompleteBooleanAlgebra (α) extends CompleteLattice α, BooleanAlgebra α where\n  /-- `⊓` distributes over `⨆`. -/\n  inf_sSup_le_iSup_inf (a : α) (s : Set α) : a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b\n  /-- `⊔` distributes over `⨅`. -/\n  iInf_sup_le_sup_sInf (a : α) (s : Set α) : ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s\n\n-- See note [lower instance priority]\n"}
{"name":"compl_iInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : CompleteBooleanAlgebra α\nf : ι → α\n⊢ Eq (HasCompl.compl (iInf f)) (iSup fun i => HasCompl.compl (f i))","decl":"theorem compl_iInf : (iInf f)ᶜ = ⨆ i, (f i)ᶜ :=\n  le_antisymm\n    (compl_le_of_compl_le <| le_iInf fun i => compl_le_of_compl_le <|\n      le_iSup (HasCompl.compl ∘ f) i)\n    (iSup_le fun _ => compl_le_compl <| iInf_le _ _)\n\n"}
{"name":"compl_iSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : CompleteBooleanAlgebra α\nf : ι → α\n⊢ Eq (HasCompl.compl (iSup f)) (iInf fun i => HasCompl.compl (f i))","decl":"theorem compl_iSup : (iSup f)ᶜ = ⨅ i, (f i)ᶜ :=\n  compl_injective (by simp [compl_iInf])\n\n"}
{"name":"compl_sInf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : CompleteBooleanAlgebra α\ns : Set α\n⊢ Eq (HasCompl.compl (InfSet.sInf s)) (iSup fun i => iSup fun h => HasCompl.compl i)","decl":"theorem compl_sInf : (sInf s)ᶜ = ⨆ i ∈ s, iᶜ := by simp only [sInf_eq_iInf, compl_iInf]\n\n"}
{"name":"compl_sSup","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : CompleteBooleanAlgebra α\ns : Set α\n⊢ Eq (HasCompl.compl (SupSet.sSup s)) (iInf fun i => iInf fun h => HasCompl.compl i)","decl":"theorem compl_sSup : (sSup s)ᶜ = ⨅ i ∈ s, iᶜ := by simp only [sSup_eq_iSup, compl_iSup]\n\n"}
{"name":"compl_sInf'","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : CompleteBooleanAlgebra α\ns : Set α\n⊢ Eq (HasCompl.compl (InfSet.sInf s)) (SupSet.sSup (Set.image HasCompl.compl s))","decl":"theorem compl_sInf' : (sInf s)ᶜ = sSup (HasCompl.compl '' s) :=\n  compl_sInf.trans sSup_image.symm\n\n"}
{"name":"compl_sSup'","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\ninst✝ : CompleteBooleanAlgebra α\ns : Set α\n⊢ Eq (HasCompl.compl (SupSet.sSup s)) (InfSet.sInf (Set.image HasCompl.compl s))","decl":"theorem compl_sSup' : (sSup s)ᶜ = sInf (HasCompl.compl '' s) :=\n  compl_sSup.trans sInf_image.symm\n\n"}
{"name":"iSup_symmDiff_iSup_le","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : CompleteBooleanAlgebra α\nf g : ι → α\n⊢ LE.le (symmDiff (iSup fun i => f i) (iSup fun i => g i)) (iSup fun i => symmDiff (f i) (g i))","decl":"open scoped symmDiff in\n/-- The symmetric difference of two `iSup`s is at most the `iSup` of the symmetric differences. -/\ntheorem iSup_symmDiff_iSup_le {g : ι → α} : (⨆ i, f i) ∆ (⨆ i, g i) ≤ ⨆ i, ((f i) ∆ (g i)) := by\n  simp_rw [symmDiff_le_iff, ← iSup_sup_eq]\n  exact ⟨iSup_mono fun i ↦ sup_comm (g i) _ ▸ le_symmDiff_sup_right ..,\n    iSup_mono fun i ↦ sup_comm (f i) _ ▸ symmDiff_comm (f i) _ ▸ le_symmDiff_sup_right ..⟩\n\n"}
{"name":"biSup_symmDiff_biSup_le","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nι : Sort w\ninst✝ : CompleteBooleanAlgebra α\np : ι → Prop\nf g : (i : ι) → p i → α\n⊢ LE.le (symmDiff (iSup fun i => iSup fun h => f i h) (iSup fun i => iSup fun h => g i h)) (iSup fun i => iSup fun h => symmDiff (f i h) (g i h))","decl":"open scoped symmDiff in\n/-- A `biSup` version of `iSup_symmDiff_iSup_le`. -/\ntheorem biSup_symmDiff_biSup_le {p : ι → Prop} {f g : (i : ι) → p i → α} :\n    (⨆ i, ⨆ (h : p i), f i h) ∆ (⨆ i, ⨆ (h : p i), g i h) ≤\n    ⨆ i, ⨆ (h : p i), ((f i h) ∆ (g i h)) :=\n  le_trans iSup_symmDiff_iSup_le <|iSup_mono fun _ ↦ iSup_symmDiff_iSup_le\n\n"}
{"name":"CompleteAtomicBooleanAlgebra.himp_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nx y : α\n⊢ Eq (HImp.himp x y) (Max.max y (HasCompl.compl x))","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteAtomicBooleanAlgebra.inf_compl_le_bot","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nx : α\n⊢ LE.le (Min.min x (HasCompl.compl x)) Bot.bot","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteAtomicBooleanAlgebra.iInf_iSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nι : Type u\nκ : ι → Type u\nf : (a : ι) → κ a → α\n⊢ Eq (iInf fun a => iSup fun b => f a b) (iSup fun g => iInf fun a => f a (g a))","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteAtomicBooleanAlgebra.sdiff_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nx y : α\n⊢ Eq (SDiff.sdiff x y) (Min.min x (HasCompl.compl y))","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteAtomicBooleanAlgebra.top_le_sup_compl","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nx : α\n⊢ LE.le Top.top (Max.max x (HasCompl.compl x))","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"CompleteAtomicBooleanAlgebra.le_sup_inf","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"α : Type u\nself : CompleteAtomicBooleanAlgebra α\nx y z : α\n⊢ LE.le (Min.min (Max.max x y) (Max.max x z)) (Max.max x (Min.min y z))","decl":"/--\nA complete atomic Boolean algebra is a complete Boolean algebra\nthat is also completely distributive.\n\nWe take iSup_iInf_eq as the definition here,\nand prove later on that this implies atomicity.\n-/\n-- We do not directly extend `CompletelyDistribLattice` to avoid having the `hnot` field\n-- We do not directly extend `CompleteBooleanAlgebra` to avoid having the `inf_sSup_le_iSup_inf` and\n-- `iInf_sup_le_sup_sInf` fields\nclass CompleteAtomicBooleanAlgebra (α : Type u) extends CompleteLattice α, BooleanAlgebra α where\n  protected iInf_iSup_eq {ι : Type u} {κ : ι → Type u} (f : ∀ a, κ a → α) :\n    (⨅ a, ⨆ b, f a b) = ⨆ g : ∀ a, κ a, ⨅ a, f a (g a)\n\n-- See note [lower instance priority]\n"}
{"name":"PUnit.sSup_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"s : Set PUnit.{u + 1}\n⊢ Eq (SupSet.sSup s) PUnit.unit","decl":"@[simp]\ntheorem sSup_eq : sSup s = unit :=\n  rfl\n\n"}
{"name":"PUnit.sInf_eq","module":"Mathlib.Order.CompleteBooleanAlgebra","initialProofState":"s : Set PUnit.{u + 1}\n⊢ Eq (InfSet.sInf s) PUnit.unit","decl":"@[simp]\ntheorem sInf_eq : sInf s = unit :=\n  rfl\n\n"}
