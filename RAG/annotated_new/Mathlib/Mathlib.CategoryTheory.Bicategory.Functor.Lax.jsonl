{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map g)) (self.mapComp f' g))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (self.mapComp f (CategoryTheory.CategoryStruct.id b))))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)) (self.mapComp f g'))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a)) (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g)) (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left‚úù : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map g)) (mapComp‚úù f' g))) _auto‚úù\nmapComp_naturality_right‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)) (mapComp‚úù f g'))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g) (toPrelaxFunctor‚úù.map h)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h)) (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h))))) _auto‚úù\nmap‚ÇÇ_leftUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a) (toPrelaxFunctor‚úù.map f)) (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f)))) _auto‚úù\nmap‚ÇÇ_rightUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b)) (mapComp‚úù f (CategoryTheory.CategoryStruct.id b))))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f g'))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto‚úù\n‚ä¢ Eq (Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, mapComp_naturality_left := mapComp_naturality_left‚úù, mapComp_naturality_right := mapComp_naturality_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor‚úù, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }) (And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp)))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f g'))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctor))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (self.mapComp (CategoryTheory.CategoryStruct.id a) f)))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a)) (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g)) (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left‚úù : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map g)) (mapComp‚úù f' g))) _auto‚úù\nmapComp_naturality_right‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)) (mapComp‚úù f g'))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g) (toPrelaxFunctor‚úù.map h)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h)) (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h))))) _auto‚úù\nmap‚ÇÇ_leftUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a) (toPrelaxFunctor‚úù.map f)) (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f)))) _auto‚úù\nmap‚ÇÇ_rightUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b)) (mapComp‚úù f (CategoryTheory.CategoryStruct.id b))))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f g'))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto‚úù\nx‚úù : Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, mapComp_naturality_left := mapComp_naturality_left‚úù, mapComp_naturality_right := mapComp_naturality_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor‚úù, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }\n‚ä¢ And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_associator","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h)) (self.mapComp f (CategoryTheory.CategoryStruct.comp g h))))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`ùüô (F.obj a) ‚ü∂ F.map (ùüô a)` and `F.map f ‚â´ F.map g ‚ü∂ F.map (f ‚â´ g)`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ) [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : ùüô (obj a) ‚ü∂ map (ùüô a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map f ‚â´ map g ‚ü∂ map (f ‚â´ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      mapComp f g ‚â´ map‚ÇÇ (Œ∑ ‚ñ∑ g) = map‚ÇÇ Œ∑ ‚ñ∑ map g ‚â´ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n     mapComp f g ‚â´ map‚ÇÇ (f ‚óÅ Œ∑) = map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      mapComp f g ‚ñ∑ map h ‚â´ mapComp (f ‚â´ g) h ‚â´ map‚ÇÇ (Œ±_ f g h).hom =\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ mapComp g h ‚â´ mapComp f (g ‚â´ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).inv = (Œª_ (map f)).inv ‚â´ mapId a ‚ñ∑ map f ‚â´ mapComp (ùüô a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).inv = (œÅ_ (map f)).inv ‚â´ map f ‚óÅ mapId b ‚â´ mapComp f (ùüô b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_associator_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (self.obj a) (self.obj d)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h‚úù)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h‚úù)) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) h)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f g')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g') h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)).app X)) (CategoryTheory.CategoryStruct.comp ((self.map g).map ((self.map‚ÇÇ Œ∑).app X)) ((self.mapComp f' g).app X))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_associator_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.map h).map ((self.mapComp f g).app X)) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) ((self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp g h).app ((self.map f).obj X)) ((self.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f' g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map g)) (CategoryTheory.CategoryStruct.comp (self.mapComp f' g) h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)).app X)) (CategoryTheory.CategoryStruct.comp ((self.map‚ÇÇ Œ∑).app ((self.map f).obj X)) ((self.mapComp f g').app X))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.rightUnitor (self.map f)).inv.app X) (CategoryTheory.CategoryStruct.comp ((self.mapId b).app ((self.map f).obj X)) ((self.mapComp f (CategoryTheory.CategoryStruct.id b)).app X)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)) h)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f) h)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.leftUnitor (self.map f)).inv.app X) (CategoryTheory.CategoryStruct.comp ((self.map f).map ((self.mapId a).app X)) ((self.mapComp (CategoryTheory.CategoryStruct.id a) f).app X)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h)) (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)) (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f g ‚ñ∑ F.map h ‚â´ F.mapComp (f ‚â´ g) h = (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´\n      F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv := by\n  rw [‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê F.map‚ÇÇ_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map‚ÇÇ_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).app X)) ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f g ‚ñ∑ F.map h ‚â´ F.mapComp (f ‚â´ g) h = (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´\n      F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv := by\n  rw [‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê F.map‚ÇÇ_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map‚ÇÇ_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).inv) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f g ‚ñ∑ F.map h ‚â´ F.mapComp (f ‚â´ g) h = (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´\n      F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv := by\n  rw [‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê F.map‚ÇÇ_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map‚ÇÇ_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).app ((F.map f).obj X)) ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) =\n      (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n        F.mapComp (f ‚â´ g) h ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom := by\n  simp only [map‚ÇÇ_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h)) (F.mapComp f (CategoryTheory.CategoryStruct.comp g h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) =\n      (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n        F.mapComp (f ‚â´ g) h ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom := by\n  simp only [map‚ÇÇ_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ F.mapComp g h ‚â´ F.mapComp f (g ‚â´ h) =\n      (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n        F.mapComp (f ‚â´ g) h ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom := by\n  simp only [map‚ÇÇ_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((CategoryTheory.Bicategory.leftUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map f).map ((F.mapId a).app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom).app X)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_leftUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (Œª_ (F.map f)).hom = F.mapId a ‚ñ∑ F.map f ‚â´ F.mapComp (ùüô a) f ‚â´ F.map‚ÇÇ (Œª_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (F.map f)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) h)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_leftUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (Œª_ (F.map f)).hom = F.mapId a ‚ñ∑ F.map f ‚â´ F.mapComp (ùüô a) f ‚â´ F.map‚ÇÇ (Œª_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_leftUnitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (F.map f)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f) (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_leftUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (Œª_ (F.map f)).hom = F.mapId a ‚ñ∑ F.map f ‚â´ F.mapComp (ùüô a) f ‚â´ F.map‚ÇÇ (Œª_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)) (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_rightUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (œÅ_ (F.map f)).hom = F.map f ‚óÅ F.mapId b ‚â´ F.mapComp f (ùüô b) ‚â´ F.map‚ÇÇ (œÅ_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((CategoryTheory.Bicategory.rightUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapId b).app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom).app X)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_rightUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (œÅ_ (F.map f)).hom = F.map f ‚óÅ F.mapId b ‚â´ F.mapComp f (ùüô b) ‚â´ F.map‚ÇÇ (œÅ_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map‚ÇÇ_rightUnitor_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) h)))","decl":"@[reassoc, to_app]\nlemma map‚ÇÇ_rightUnitor_hom {a b : B} (f : a ‚ü∂ b) :\n    (œÅ_ (F.map f)).hom = F.map f ‚óÅ F.mapId b ‚â´ F.mapComp f (ùüô b) ‚â´ F.map‚ÇÇ (œÅ_ f).hom := by\n  rw [‚Üê PrelaxFunctor.map‚ÇÇIso_hom, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map‚ÇÇ_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\n‚ä¢ Eq (CategoryTheory.LaxFunctor.id B).toPrelaxFunctor (CategoryTheory.PrelaxFunctor.id B)","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.LaxFunctor.id B).mapComp f g) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na : B\n‚ä¢ Eq ((CategoryTheory.LaxFunctor.id B).mapId a) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.id a))","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\na : B\n‚ä¢ Eq ((F.comp G).mapId a) (CategoryTheory.CategoryStruct.comp (G.mapId (F.obj a)) (G.map‚ÇÇ (F.mapId a)))","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u‚ÇÉ} [Bicategory.{w‚ÇÉ, v‚ÇÉ} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ‚â´ G.map‚ÇÇ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ‚â´ G.map‚ÇÇ (F.mapComp f g)\n  mapComp_naturality_left := fun Œ∑ g => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_left, G.map‚ÇÇ_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ Œ∑ => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_right, G.map‚ÇÇ_comp, mapComp_naturality_right_assoc]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ‚Üê mapComp_naturality_right, ‚Üê map‚ÇÇ_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [‚Üê G.map‚ÇÇ_comp, ‚Üê G.map‚ÇÇ_comp, ‚Üê F.map‚ÇÇ_associator, G.map‚ÇÇ_comp, G.map‚ÇÇ_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ‚Üê G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map‚ÇÇ_leftUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_leftUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map‚ÇÇ_rightUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_rightUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\n‚ä¢ Eq (F.comp G).toPrelaxFunctor (F.comp G.toPrelaxFunctor)","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u‚ÇÉ} [Bicategory.{w‚ÇÉ, v‚ÇÉ} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ‚â´ G.map‚ÇÇ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ‚â´ G.map‚ÇÇ (F.mapComp f g)\n  mapComp_naturality_left := fun Œ∑ g => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_left, G.map‚ÇÇ_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ Œ∑ => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_right, G.map‚ÇÇ_comp, mapComp_naturality_right_assoc]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ‚Üê mapComp_naturality_right, ‚Üê map‚ÇÇ_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [‚Üê G.map‚ÇÇ_comp, ‚Üê G.map‚ÇÇ_comp, ‚Üê F.map‚ÇÇ_associator, G.map‚ÇÇ_comp, G.map‚ÇÇ_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ‚Üê G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map‚ÇÇ_leftUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_leftUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map‚ÇÇ_rightUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_rightUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((F.comp G).mapComp f g) (CategoryTheory.CategoryStruct.comp (G.mapComp (F.map f) (F.map g)) (G.map‚ÇÇ (F.mapComp f g)))","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u‚ÇÉ} [Bicategory.{w‚ÇÉ, v‚ÇÉ} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ‚â´ G.map‚ÇÇ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ‚â´ G.map‚ÇÇ (F.mapComp f g)\n  mapComp_naturality_left := fun Œ∑ g => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_left, G.map‚ÇÇ_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ Œ∑ => by\n    dsimp\n    rw [assoc, ‚Üê G.map‚ÇÇ_comp, mapComp_naturality_right, G.map‚ÇÇ_comp, mapComp_naturality_right_assoc]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ‚Üê mapComp_naturality_right, ‚Üê map‚ÇÇ_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [‚Üê G.map‚ÇÇ_comp, ‚Üê G.map‚ÇÇ_comp, ‚Üê F.map‚ÇÇ_associator, G.map‚ÇÇ_comp, G.map‚ÇÇ_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ‚Üê G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map‚ÇÇ_leftUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_leftUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map‚ÇÇ_rightUnitor := fun f => by\n    dsimp\n    simp only [map‚ÇÇ_rightUnitor, PrelaxFunctor.map‚ÇÇ_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mapIdIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nself : F.PseudoCore\na : B\n‚ä¢ Eq (self.mapIdIso a).inv (F.mapId a)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mapCompIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nself : F.PseudoCore\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (self.mapCompIso f g).inv (F.mapComp f g)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nmapIdIso‚úù : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv‚úù : autoParam (‚àÄ {a : B}, Eq (mapIdIso‚úù a).inv (F.mapId a)) _auto‚úù\nmapCompIso_inv‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso‚úù f g).inv (F.mapComp f g)) _auto‚úù\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto‚úù\nmapCompIso_inv : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto‚úù\n‚ä¢ Eq (Eq { mapIdIso := mapIdIso‚úù, mapCompIso := mapCompIso‚úù, mapIdIso_inv := mapIdIso_inv‚úù, mapCompIso_inv := mapCompIso_inv‚úù } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }) (And (Eq mapIdIso‚úù mapIdIso) (Eq mapCompIso‚úù mapCompIso))","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto‚úù\nmapCompIso_inv : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }) 1","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nmapIdIso‚úù : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv‚úù : autoParam (‚àÄ {a : B}, Eq (mapIdIso‚úù a).inv (F.mapId a)) _auto‚úù\nmapCompIso_inv‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso‚úù f g).inv (F.mapComp f g)) _auto‚úù\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto‚úù\nmapCompIso_inv : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto‚úù\nx‚úù : Eq { mapIdIso := mapIdIso‚úù, mapCompIso := mapCompIso‚úù, mapIdIso_inv := mapIdIso_inv‚úù, mapCompIso_inv := mapCompIso_inv‚úù } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }\n‚ä¢ And (Eq mapIdIso‚úù mapIdIso) (Eq mapCompIso‚úù mapCompIso)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
