{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nη : Quiver.Hom f f'\ng : Quiver.Hom b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (self.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map₂ η) (self.map g)) (self.mapComp f' g))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq (self.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (self.mapComp f (CategoryTheory.CategoryStruct.id b))))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nη : Quiver.Hom g g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (self.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map₂ η)) (self.mapComp f g'))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\ntoPrelaxFunctor✝ : CategoryTheory.PrelaxFunctor B C\nmapId✝ : (a : B) → Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor✝.obj a)) (toPrelaxFunctor✝.map (CategoryTheory.CategoryStruct.id a))\nmapComp✝ : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map g)) (toPrelaxFunctor✝.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left✝ : autoParam (∀ {a b c : B} {f f' : Quiver.Hom a b} (η : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp✝ f g) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor✝.map₂ η) (toPrelaxFunctor✝.map g)) (mapComp✝ f' g))) _auto✝\nmapComp_naturality_right✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (η : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp✝ f g) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map₂ η)) (mapComp✝ f g'))) _auto✝\nmap₂_associator✝ : autoParam (∀ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp✝ f g) (toPrelaxFunctor✝.map h)) (CategoryTheory.CategoryStruct.comp (mapComp✝ (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map g) (toPrelaxFunctor✝.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (mapComp✝ g h)) (mapComp✝ f (CategoryTheory.CategoryStruct.comp g h))))) _auto✝\nmap₂_leftUnitor✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor✝.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId✝ a) (toPrelaxFunctor✝.map f)) (mapComp✝ (CategoryTheory.CategoryStruct.id a) f)))) _auto✝\nmap₂_rightUnitor✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor✝.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (mapId✝ b)) (mapComp✝ f (CategoryTheory.CategoryStruct.id b))))) _auto✝\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) → Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (∀ {a b c : B} {f f' : Quiver.Hom a b} (η : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map₂ η) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto✝\nmapComp_naturality_right : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (η : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map₂ η)) (mapComp f g'))) _auto✝\nmap₂_associator : autoParam (∀ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto✝\nmap₂_leftUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto✝\nmap₂_rightUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto✝\n⊢ Eq (Eq { toPrelaxFunctor := toPrelaxFunctor✝, mapId := mapId✝, mapComp := mapComp✝, mapComp_naturality_left := mapComp_naturality_left✝, mapComp_naturality_right := mapComp_naturality_right✝, map₂_associator := map₂_associator✝, map₂_leftUnitor := map₂_leftUnitor✝, map₂_rightUnitor := map₂_rightUnitor✝ } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map₂_associator := map₂_associator, map₂_leftUnitor := map₂_leftUnitor, map₂_rightUnitor := map₂_rightUnitor }) (And (Eq toPrelaxFunctor✝ toPrelaxFunctor) (And (HEq mapId✝ mapId) (HEq mapComp✝ mapComp)))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) → Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (∀ {a b c : B} {f f' : Quiver.Hom a b} (η : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map₂ η) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto✝\nmapComp_naturality_right : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (η : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map₂ η)) (mapComp f g'))) _auto✝\nmap₂_associator : autoParam (∀ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto✝\nmap₂_leftUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto✝\nmap₂_rightUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map₂_associator := map₂_associator, map₂_leftUnitor := map₂_leftUnitor, map₂_rightUnitor := map₂_rightUnitor }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctor))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq (self.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (self.mapComp (CategoryTheory.CategoryStruct.id a) f)))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\ntoPrelaxFunctor✝ : CategoryTheory.PrelaxFunctor B C\nmapId✝ : (a : B) → Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor✝.obj a)) (toPrelaxFunctor✝.map (CategoryTheory.CategoryStruct.id a))\nmapComp✝ : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map g)) (toPrelaxFunctor✝.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left✝ : autoParam (∀ {a b c : B} {f f' : Quiver.Hom a b} (η : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp✝ f g) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor✝.map₂ η) (toPrelaxFunctor✝.map g)) (mapComp✝ f' g))) _auto✝\nmapComp_naturality_right✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (η : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp✝ f g) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map₂ η)) (mapComp✝ f g'))) _auto✝\nmap₂_associator✝ : autoParam (∀ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp✝ f g) (toPrelaxFunctor✝.map h)) (CategoryTheory.CategoryStruct.comp (mapComp✝ (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor✝.map f) (toPrelaxFunctor✝.map g) (toPrelaxFunctor✝.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (mapComp✝ g h)) (mapComp✝ f (CategoryTheory.CategoryStruct.comp g h))))) _auto✝\nmap₂_leftUnitor✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor✝.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId✝ a) (toPrelaxFunctor✝.map f)) (mapComp✝ (CategoryTheory.CategoryStruct.id a) f)))) _auto✝\nmap₂_rightUnitor✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor✝.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor✝.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor✝.map f) (mapId✝ b)) (mapComp✝ f (CategoryTheory.CategoryStruct.id b))))) _auto✝\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) → Quiver.Hom (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a))\nmapComp : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g)) (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g))\nmapComp_naturality_left : autoParam (∀ {a b c : B} {f f' : Quiver.Hom a b} (η : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerRight η g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map₂ η) (toPrelaxFunctor.map g)) (mapComp f' g))) _auto✝\nmapComp_naturality_right : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (η : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (mapComp f g) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.whiskerLeft f η))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map₂ η)) (mapComp f g'))) _auto✝\nmap₂_associator : autoParam (∀ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)) (mapComp f (CategoryTheory.CategoryStruct.comp g h))))) _auto✝\nmap₂_leftUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (mapComp (CategoryTheory.CategoryStruct.id a) f)))) _auto✝\nmap₂_rightUnitor : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (mapComp f (CategoryTheory.CategoryStruct.id b))))) _auto✝\nx✝ : Eq { toPrelaxFunctor := toPrelaxFunctor✝, mapId := mapId✝, mapComp := mapComp✝, mapComp_naturality_left := mapComp_naturality_left✝, mapComp_naturality_right := mapComp_naturality_right✝, map₂_associator := map₂_associator✝, map₂_leftUnitor := map₂_leftUnitor✝, map₂_rightUnitor := map₂_rightUnitor✝ } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map₂_associator := map₂_associator, map₂_leftUnitor := map₂_leftUnitor, map₂_rightUnitor := map₂_rightUnitor }\n⊢ And (Eq toPrelaxFunctor✝ toPrelaxFunctor) (And (HEq mapId✝ mapId) (HEq mapComp✝ mapComp))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_associator","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (self.map₂ (CategoryTheory.Bicategory.associator f g h).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h)) (self.mapComp f (CategoryTheory.CategoryStruct.comp g h))))","decl":"/-- A lax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map₂`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`𝟙 (F.obj a) ⟶ F.map (𝟙 a)` and `F.map f ≫ F.map g ⟶ F.map (f ≫ g)`.\n\n`F.map₂` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure LaxFunctor (B: Type u₁) [Bicategory.{w₁, v₁} B] (C : Type u₂) [Bicategory.{w₂, v₂} C]\n    extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the lax unity constraint. -/\n  mapId (a : B) : 𝟙 (obj a) ⟶ map (𝟙 a)\n  /-- The 2-morphism underlying the lax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : map f ≫ map g ⟶ map (f ≫ g)\n  /-- Naturality of the lax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ∀ {a b c : B} {f f' : a ⟶ b} (η : f ⟶ f') (g : b ⟶ c),\n      mapComp f g ≫ map₂ (η ▷ g) = map₂ η ▷ map g ≫ mapComp f' g:= by aesop_cat\n  /-- Naturality of the lax functoriality constraint, on the right. -/\n  mapComp_naturality_right :\n    ∀ {a b c : B} (f : a ⟶ b) {g g' : b ⟶ c} (η : g ⟶ g'),\n     mapComp f g ≫ map₂ (f ◁ η) = map f ◁ map₂ η ≫ mapComp f g' := by aesop_cat\n  /-- Lax associativity. -/\n  map₂_associator :\n    ∀ {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d),\n      mapComp f g ▷ map h ≫ mapComp (f ≫ g) h ≫ map₂ (α_ f g h).hom =\n      (α_ (map f) (map g) (map h)).hom ≫ map f ◁ mapComp g h ≫ mapComp f (g ≫ h) := by aesop_cat\n  /-- Lax left unity. -/\n  map₂_leftUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (λ_ f).inv = (λ_ (map f)).inv ≫ mapId a ▷ map f ≫ mapComp (𝟙 a) f := by aesop_cat\n  /-- Lax right unity. -/\n  map₂_rightUnitor :\n    ∀ {a b : B} (f : a ⟶ b),\n      map₂ (ρ_ f).inv = (ρ_ (map f)).inv ≫ map f ◁ mapId b ≫ mapComp f (𝟙 b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_associator_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh✝ : Quiver.Hom c d\nZ : Quiver.Hom (self.obj a) (self.obj d)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h✝)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h✝) (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.Bicategory.associator f g h✝).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h✝)) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.comp g h✝)) h)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nη : Quiver.Hom g g'\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f g')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.Bicategory.whiskerLeft f η)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map₂ η)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g') h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c : B\nf f' : Quiver.Hom a b\nη : Quiver.Hom f f'\ng : Quiver.Hom b c\nX : ↑(self.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map₂ (CategoryTheory.Bicategory.whiskerRight η g)).app X)) (CategoryTheory.CategoryStruct.comp ((self.map g).map ((self.map₂ η).app X)) ((self.mapComp f' g).app X))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_associator_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ↑(self.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((self.map h).map ((self.mapComp f g).app X)) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) ((self.map₂ (CategoryTheory.Bicategory.associator f g h).hom).app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp g h).app ((self.map f).obj X)) ((self.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nη : Quiver.Hom f f'\ng : Quiver.Hom b c\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f' g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.Bicategory.whiskerRight η g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map₂ η) (self.map g)) (CategoryTheory.CategoryStruct.comp (self.mapComp f' g) h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_naturality_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nη : Quiver.Hom g g'\nX : ↑(self.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map₂ (CategoryTheory.Bicategory.whiskerLeft f η)).app X)) (CategoryTheory.CategoryStruct.comp ((self.map₂ η).app ((self.map f).obj X)) ((self.mapComp f g').app X))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map₂_associator\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ↑(self.obj a)\n⊢ Eq ((self.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.rightUnitor (self.map f)).inv.app X) (CategoryTheory.CategoryStruct.comp ((self.mapId b).app ((self.map f).obj X)) ((self.mapComp f (CategoryTheory.CategoryStruct.id b)).app X)))","decl":"attribute [simp, reassoc, to_app] map₂_leftUnitor map₂_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.Bicategory.rightUnitor f).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)) h)))","decl":"attribute [simp, reassoc, to_app] map₂_leftUnitor map₂_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nself : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f) h)))","decl":"attribute [simp, reassoc, to_app] map₂_leftUnitor map₂_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nself : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ↑(self.obj a)\n⊢ Eq ((self.map₂ (CategoryTheory.Bicategory.leftUnitor f).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.leftUnitor (self.map f)).inv.app X) (CategoryTheory.CategoryStruct.comp ((self.map f).map ((self.mapId a).app X)) ((self.mapComp (CategoryTheory.CategoryStruct.id a) f).app X)))","decl":"attribute [simp, reassoc, to_app] map₂_leftUnitor map₂_rightUnitor\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h)) (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)) (F.map₂ (CategoryTheory.Bicategory.associator f g h).inv))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.mapComp f g ▷ F.map h ≫ F.mapComp (f ≫ g) h = (α_ (F.map f) (F.map g) (F.map h)).hom ≫\n      F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) ≫ F.map₂ (α_ f g h).inv := by\n  rw [← F.map₂_associator_assoc, ← F.map₂_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map₂_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ↑(F.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).app X)) ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X) ((F.map₂ (CategoryTheory.Bicategory.associator f g h).inv).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.mapComp f g ▷ F.map h ≫ F.mapComp (f ≫ g) h = (α_ (F.map f) (F.map g) (F.map h)).hom ≫\n      F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) ≫ F.map₂ (α_ f g h).inv := by\n  rw [← F.map₂_associator_assoc, ← F.map₂_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map₂_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh✝ : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h✝)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h✝)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h✝)) (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.Bicategory.associator f g h✝).inv) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.mapComp f g ▷ F.map h ≫ F.mapComp (f ≫ g) h = (α_ (F.map f) (F.map g) (F.map h)).hom ≫\n      F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) ≫ F.map₂ (α_ f g h).inv := by\n  rw [← F.map₂_associator_assoc, ← F.map₂_comp]\n  simp only [Iso.hom_inv_id, PrelaxFunctor.map₂_id, comp_id]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ↑(F.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).app ((F.map f).obj X)) ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) ((F.map₂ (CategoryTheory.Bicategory.associator f g h).hom).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) =\n      (α_ (F.map f) (F.map g) (F.map h)).inv ≫ F.mapComp f g ▷ F.map h ≫\n        F.mapComp (f ≫ g) h ≫ F.map₂ (α_ f g h).hom := by\n  simp only [map₂_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h)) (F.mapComp f (CategoryTheory.CategoryStruct.comp g h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (F.map₂ (CategoryTheory.Bicategory.associator f g h).hom))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) =\n      (α_ (F.map f) (F.map g) (F.map h)).inv ≫ F.mapComp f g ▷ F.map h ≫\n        F.mapComp (f ≫ g) h ≫ F.map₂ (α_ f g h).hom := by\n  simp only [map₂_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.mapComp_assoc_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh✝ : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h✝)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h✝)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h✝)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h✝) (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.Bicategory.associator f g h✝).hom) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n    F.map f ◁ F.mapComp g h ≫ F.mapComp f (g ≫ h) =\n      (α_ (F.map f) (F.map g) (F.map h)).inv ≫ F.mapComp f g ▷ F.map h ≫\n        F.mapComp (f ≫ g) h ≫ F.map₂ (α_ f g h).hom := by\n  simp only [map₂_associator, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ↑(F.obj a)\n⊢ Eq ((CategoryTheory.Bicategory.leftUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map f).map ((F.mapId a).app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).app X) ((F.map₂ (CategoryTheory.Bicategory.leftUnitor f).hom).app X)))","decl":"@[reassoc, to_app]\nlemma map₂_leftUnitor_hom {a b : B} (f : a ⟶ b) :\n    (λ_ (F.map f)).hom = F.mapId a ▷ F.map f ≫ F.mapComp (𝟙 a) f ≫ F.map₂ (λ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (F.map f)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.Bicategory.leftUnitor f).hom) h)))","decl":"@[reassoc, to_app]\nlemma map₂_leftUnitor_hom {a b : B} (f : a ⟶ b) :\n    (λ_ (F.map f)).hom = F.mapId a ▷ F.map f ≫ F.mapComp (𝟙 a) f ≫ F.map₂ (λ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_leftUnitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (F.map f)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f) (F.map₂ (CategoryTheory.Bicategory.leftUnitor f).hom)))","decl":"@[reassoc, to_app]\nlemma map₂_leftUnitor_hom {a b : B} (f : a ⟶ b) :\n    (λ_ (F.map f)).hom = F.mapId a ▷ F.map f ≫ F.mapComp (𝟙 a) f ≫ F.map₂ (λ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_leftUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\n⊢ Eq (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)) (F.map₂ (CategoryTheory.Bicategory.rightUnitor f).hom)))","decl":"@[reassoc, to_app]\nlemma map₂_rightUnitor_hom {a b : B} (f : a ⟶ b) :\n    (ρ_ (F.map f)).hom = F.map f ◁ F.mapId b ≫ F.mapComp f (𝟙 b) ≫ F.map₂ (ρ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u_1\ninst✝ : CategoryTheory.Bicategory B\nF : CategoryTheory.LaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ↑(F.obj a)\n⊢ Eq ((CategoryTheory.Bicategory.rightUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapId b).app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).app X) ((F.map₂ (CategoryTheory.Bicategory.rightUnitor f).hom).app X)))","decl":"@[reassoc, to_app]\nlemma map₂_rightUnitor_hom {a b : B} (f : a ⟶ b) :\n    (ρ_ (F.map f)).hom = F.map f ◁ F.mapId b ≫ F.mapComp f (𝟙 b) ≫ F.map₂ (ρ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.map₂_rightUnitor_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b)) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (F.map₂ (CategoryTheory.Bicategory.rightUnitor f).hom) h)))","decl":"@[reassoc, to_app]\nlemma map₂_rightUnitor_hom {a b : B} (f : a ⟶ b) :\n    (ρ_ (F.map f)).hom = F.map f ◁ F.mapId b ≫ F.mapComp f (𝟙 b) ≫ F.map₂ (ρ_ f).hom := by\n  rw [← PrelaxFunctor.map₂Iso_hom, ← assoc, ← Iso.comp_inv_eq, ← Iso.eq_inv_comp]\n  simp only [Functor.mapIso_inv, PrelaxFunctor.mapFunctor_map, map₂_rightUnitor]\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝ : CategoryTheory.Bicategory B\n⊢ Eq (CategoryTheory.LaxFunctor.id B).toPrelaxFunctor (CategoryTheory.PrelaxFunctor.id B)","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u₁) [Bicategory.{w₁, v₁} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => 𝟙 (𝟙 a)\n  mapComp := fun f g => 𝟙 (f ≫ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝ : CategoryTheory.Bicategory B\na✝ b✝ c✝ : B\nf : Quiver.Hom a✝ b✝\ng : Quiver.Hom b✝ c✝\n⊢ Eq ((CategoryTheory.LaxFunctor.id B).mapComp f g) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u₁) [Bicategory.{w₁, v₁} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => 𝟙 (𝟙 a)\n  mapComp := fun f g => 𝟙 (f ≫ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.id_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝ : CategoryTheory.Bicategory B\na : B\n⊢ Eq ((CategoryTheory.LaxFunctor.id B).mapId a) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.id a))","decl":"/-- The identity lax functor. -/\n@[simps]\ndef id (B : Type u₁) [Bicategory.{w₁, v₁} B] : LaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => 𝟙 (𝟙 a)\n  mapComp := fun f g => 𝟙 (f ≫ g)\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nD : Type u₃\ninst✝ : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\na : B\n⊢ Eq ((F.comp G).mapId a) (CategoryTheory.CategoryStruct.comp (G.mapId (F.obj a)) (G.map₂ (F.mapId a)))","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u₃} [Bicategory.{w₃, v₃} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ≫ G.map₂ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ≫ G.map₂ (F.mapComp f g)\n  mapComp_naturality_left := fun η g => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_left, G.map₂_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ η => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_right, G.map₂_comp, mapComp_naturality_right_assoc]\n  map₂_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ← mapComp_naturality_right, ← map₂_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [← G.map₂_comp, ← G.map₂_comp, ← F.map₂_associator, G.map₂_comp, G.map₂_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ← G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map₂_leftUnitor := fun f => by\n    dsimp\n    simp only [map₂_leftUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map₂_rightUnitor := fun f => by\n    dsimp\n    simp only [map₂_rightUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nD : Type u₃\ninst✝ : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\n⊢ Eq (F.comp G).toPrelaxFunctor (F.comp G.toPrelaxFunctor)","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u₃} [Bicategory.{w₃, v₃} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ≫ G.map₂ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ≫ G.map₂ (F.mapComp f g)\n  mapComp_naturality_left := fun η g => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_left, G.map₂_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ η => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_right, G.map₂_comp, mapComp_naturality_right_assoc]\n  map₂_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ← mapComp_naturality_right, ← map₂_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [← G.map₂_comp, ← G.map₂_comp, ← F.map₂_associator, G.map₂_comp, G.map₂_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ← G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map₂_leftUnitor := fun f => by\n    dsimp\n    simp only [map₂_leftUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map₂_rightUnitor := fun f => by\n    dsimp\n    simp only [map₂_rightUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.comp_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝¹ : CategoryTheory.Bicategory C\nD : Type u₃\ninst✝ : CategoryTheory.Bicategory D\nF : CategoryTheory.LaxFunctor B C\nG : CategoryTheory.LaxFunctor C D\na✝ b✝ c✝ : B\nf : Quiver.Hom a✝ b✝\ng : Quiver.Hom b✝ c✝\n⊢ Eq ((F.comp G).mapComp f g) (CategoryTheory.CategoryStruct.comp (G.mapComp (F.map f) (F.map g)) (G.map₂ (F.mapComp f g)))","decl":"/-- Composition of lax functors. -/\n@[simps]\ndef comp {D : Type u₃} [Bicategory.{w₃, v₃} D] (F : LaxFunctor B C) (G : LaxFunctor C D) :\n    LaxFunctor B D where\n  toPrelaxFunctor := PrelaxFunctor.comp F.toPrelaxFunctor G.toPrelaxFunctor\n  mapId := fun a => G.mapId (F.obj a) ≫ G.map₂ (F.mapId a)\n  mapComp := fun f g => G.mapComp (F.map f) (F.map g) ≫ G.map₂ (F.mapComp f g)\n  mapComp_naturality_left := fun η g => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_left, G.map₂_comp, mapComp_naturality_left_assoc]\n  mapComp_naturality_right := fun f _ _ η => by\n    dsimp\n    rw [assoc, ← G.map₂_comp, mapComp_naturality_right, G.map₂_comp, mapComp_naturality_right_assoc]\n  map₂_associator := fun f g h => by\n    dsimp\n    slice_rhs 1 3 =>\n      rw [Bicategory.whiskerLeft_comp, assoc, ← mapComp_naturality_right, ← map₂_associator_assoc]\n    slice_rhs 3 5 =>\n      rw [← G.map₂_comp, ← G.map₂_comp, ← F.map₂_associator, G.map₂_comp, G.map₂_comp]\n    slice_lhs 1 3 =>\n      rw [comp_whiskerRight, assoc, ← G.mapComp_naturality_left_assoc]\n    simp only [assoc]\n  map₂_leftUnitor := fun f => by\n    dsimp\n    simp only [map₂_leftUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_left_assoc,\n      comp_whiskerRight]\n  map₂_rightUnitor := fun f => by\n    dsimp\n    simp only [map₂_rightUnitor, PrelaxFunctor.map₂_comp, assoc, mapComp_naturality_right_assoc,\n      Bicategory.whiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mapIdIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nself : F.PseudoCore\na : B\n⊢ Eq (self.mapIdIso a).inv (F.mapId a)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mapCompIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nself : F.PseudoCore\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (self.mapCompIso f g).inv (F.mapComp f g)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nmapIdIso✝ : (a : B) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso✝ : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv✝ : autoParam (∀ {a : B}, Eq (mapIdIso✝ a).inv (F.mapId a)) _auto✝\nmapCompIso_inv✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso✝ f g).inv (F.mapComp f g)) _auto✝\nmapIdIso : (a : B) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (∀ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto✝\nmapCompIso_inv : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto✝\n⊢ Eq (Eq { mapIdIso := mapIdIso✝, mapCompIso := mapCompIso✝, mapIdIso_inv := mapIdIso_inv✝, mapCompIso_inv := mapCompIso_inv✝ } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }) (And (Eq mapIdIso✝ mapIdIso) (Eq mapCompIso✝ mapCompIso))","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\nmapIdIso : (a : B) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (∀ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto✝\nmapCompIso_inv : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto✝\n⊢ Eq (SizeOf.sizeOf { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }) 1","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LaxFunctor.PseudoCore.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Lax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nmapIdIso✝ : (a : B) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso✝ : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv✝ : autoParam (∀ {a : B}, Eq (mapIdIso✝ a).inv (F.mapId a)) _auto✝\nmapCompIso_inv✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso✝ f g).inv (F.mapComp f g)) _auto✝\nmapIdIso : (a : B) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} → (f : Quiver.Hom a b) → (g : Quiver.Hom b c) → CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_inv : autoParam (∀ {a : B}, Eq (mapIdIso a).inv (F.mapId a)) _auto✝\nmapCompIso_inv : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).inv (F.mapComp f g)) _auto✝\nx✝ : Eq { mapIdIso := mapIdIso✝, mapCompIso := mapCompIso✝, mapIdIso_inv := mapIdIso_inv✝, mapCompIso_inv := mapCompIso_inv✝ } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_inv := mapIdIso_inv, mapCompIso_inv := mapCompIso_inv }\n⊢ And (Eq mapIdIso✝ mapIdIso) (Eq mapCompIso✝ mapCompIso)","decl":"/-- A structure on an Lax functor that promotes an Lax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfLax`. -/\nstructure PseudoCore (F : LaxFunctor B C) where\n  /-- The isomorphism giving rise to the lax unity constraint -/\n  mapIdIso (a : B) : F.map (𝟙 a) ≅ 𝟙 (F.obj a)\n  /-- The isomorphism giving rise to the lax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : F.map (f ≫ g) ≅ F.map f ≫ F.map g\n  /-- `mapIdIso` gives rise to the lax unity constraint -/\n  mapIdIso_inv {a : B} : (mapIdIso a).inv = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the lax functoriality constraint -/\n  mapCompIso_inv {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : (mapCompIso f g).inv = F.mapComp f g := by\n    aesop_cat\n\n"}
