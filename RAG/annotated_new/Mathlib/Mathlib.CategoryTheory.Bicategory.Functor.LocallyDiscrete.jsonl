{"name":"CategoryTheory.pseudofunctorOfIsLocallyDiscrete_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nX‚úù Y‚úù : B\na‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).map a‚úù) (map a‚úù)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps obj map mapId mapComp]\ndef pseudofunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  map‚ÇÇ_whisker_right Œ∑ _ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapComp f g) (mapComp f g)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps obj map mapId mapComp]\ndef pseudofunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  map‚ÇÇ_whisker_right Œ∑ _ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nb : B\n‚ä¢ Eq ((CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapId b) (mapId b)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps obj map mapId mapComp]\ndef pseudofunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  map‚ÇÇ_whisker_right Œ∑ _ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.pseudofunctorOfIsLocallyDiscrete_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\na‚úù : B\n‚ä¢ Eq ((CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).obj a‚úù) (obj a‚úù)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps obj map mapId mapComp]\ndef pseudofunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  map‚ÇÇ_whisker_right Œ∑ _ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.oplaxFunctorOfIsLocallyDiscrete_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (map h)) (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ) (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ)) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nb : B\n‚ä¢ Eq ((CategoryTheory.oplaxFunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapId b) (mapId b)","decl":"/-- Constructor for oplax functors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of oplax functors. -/\n@[simps obj map mapId mapComp]\ndef oplaxFunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚ü∂ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚ü∂ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      eqToHom (by simp) ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n        mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n          aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp (ùüô b‚ÇÄ) f ‚â´ mapId b‚ÇÄ ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp f (ùüô b‚ÇÅ) ‚â´ map f ‚óÅ mapId b‚ÇÅ ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    OplaxFunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  mapComp_naturality_left Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  mapComp_naturality_right _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.oplaxFunctorOfIsLocallyDiscrete_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (map h)) (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ) (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ)) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.oplaxFunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapComp f g) (mapComp f g)","decl":"/-- Constructor for oplax functors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of oplax functors. -/\n@[simps obj map mapId mapComp]\ndef oplaxFunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚ü∂ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚ü∂ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      eqToHom (by simp) ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n        mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n          aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp (ùüô b‚ÇÄ) f ‚â´ mapId b‚ÇÄ ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp f (ùüô b‚ÇÅ) ‚â´ map f ‚óÅ mapId b‚ÇÅ ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    OplaxFunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  mapComp_naturality_left Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  mapComp_naturality_right _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.oplaxFunctorOfIsLocallyDiscrete_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (map h)) (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ) (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ)) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\na‚úù : B\n‚ä¢ Eq ((CategoryTheory.oplaxFunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).obj a‚úù) (obj a‚úù)","decl":"/-- Constructor for oplax functors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of oplax functors. -/\n@[simps obj map mapId mapComp]\ndef oplaxFunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚ü∂ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚ü∂ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      eqToHom (by simp) ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n        mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n          aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp (ùüô b‚ÇÄ) f ‚â´ mapId b‚ÇÄ ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp f (ùüô b‚ÇÅ) ‚â´ map f ‚óÅ mapId b‚ÇÅ ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    OplaxFunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  mapComp_naturality_left Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  mapComp_naturality_right _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.oplaxFunctorOfIsLocallyDiscrete_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Bicategory B\ninst‚úù¬π : CategoryTheory.Bicategory.IsLocallyDiscrete B\ninst‚úù : CategoryTheory.Bicategory C\nobj : B ‚Üí C\nmap : {b b' : B} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí Quiver.Hom (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (map h)) (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ) (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ)) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nX‚úù Y‚úù : B\na‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.oplaxFunctorOfIsLocallyDiscrete obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).map a‚úù) (map a‚úù)","decl":"/-- Constructor for oplax functors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of oplax functors. -/\n@[simps obj map mapId mapComp]\ndef oplaxFunctorOfIsLocallyDiscrete\n    {B C : Type*} [Bicategory B] [IsLocallyDiscrete B] [Bicategory C]\n    (obj : B ‚Üí C)\n    (map : ‚àÄ {b b' : B}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B), map (ùüô b) ‚ü∂ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚ü∂ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      eqToHom (by simp) ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n        mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n          aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp (ùüô b‚ÇÄ) f ‚â´ mapId b‚ÇÄ ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      mapComp f (ùüô b‚ÇÅ) ‚â´ map f ‚óÅ mapId b‚ÇÅ ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    OplaxFunctor B C where\n  obj := obj\n  map := map\n  map‚ÇÇ œÜ := eqToHom (by\n    obtain rfl := obj_ext_of_isDiscrete œÜ\n    dsimp)\n  mapId := mapId\n  mapComp := mapComp\n  mapComp_naturality_left Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n  mapComp_naturality_right _ _ _ Œ∑ := by\n    obtain rfl := obj_ext_of_isDiscrete Œ∑\n    simp\n\n"}
{"name":"CategoryTheory.Functor.toPseudoFunctor_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nx‚úù : CategoryTheory.LocallyDiscrete I\n‚ä¢ Eq (F.toPseudoFunctor.mapId x‚úù) (CategoryTheory.eqToIso ‚ãØ)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to a pseudofunctor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toPseudoFunctor : Pseudofunctor (LocallyDiscrete I) B :=\n  pseudofunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToIso (by simp)) (fun f g ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toPseudoFunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nx‚úù : CategoryTheory.LocallyDiscrete I\n‚ä¢ Eq (F.toPseudoFunctor.obj x‚úù) (F.obj x‚úù.as)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to a pseudofunctor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toPseudoFunctor : Pseudofunctor (LocallyDiscrete I) B :=\n  pseudofunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToIso (by simp)) (fun f g ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toPseudoFunctor_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\na‚úù b‚úù c‚úù : CategoryTheory.LocallyDiscrete I\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq (F.toPseudoFunctor.mapComp f g) (CategoryTheory.eqToIso ‚ãØ)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to a pseudofunctor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toPseudoFunctor : Pseudofunctor (LocallyDiscrete I) B :=\n  pseudofunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToIso (by simp)) (fun f g ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toPseudoFunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nX‚úù Y‚úù : CategoryTheory.LocallyDiscrete I\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.toPseudoFunctor.map x‚úù) (F.map x‚úù.as)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to a pseudofunctor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toPseudoFunctor : Pseudofunctor (LocallyDiscrete I) B :=\n  pseudofunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToIso (by simp)) (fun f g ‚Ü¶ eqToIso (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toOplaxFunctor_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\na‚úù b‚úù c‚úù : CategoryTheory.LocallyDiscrete I\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq (F.toOplaxFunctor.mapComp f g) (CategoryTheory.eqToHom ‚ãØ)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to an oplax functor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toOplaxFunctor : OplaxFunctor (LocallyDiscrete I) B :=\n  oplaxFunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToHom (by simp)) (fun f g ‚Ü¶ eqToHom (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toOplaxFunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nx‚úù : CategoryTheory.LocallyDiscrete I\n‚ä¢ Eq (F.toOplaxFunctor.obj x‚úù) (F.obj x‚úù.as)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to an oplax functor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toOplaxFunctor : OplaxFunctor (LocallyDiscrete I) B :=\n  oplaxFunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToHom (by simp)) (fun f g ‚Ü¶ eqToHom (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toOplaxFunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nX‚úù Y‚úù : CategoryTheory.LocallyDiscrete I\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.toOplaxFunctor.map x‚úù) (F.map x‚úù.as)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to an oplax functor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toOplaxFunctor : OplaxFunctor (LocallyDiscrete I) B :=\n  oplaxFunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToHom (by simp)) (fun f g ‚Ü¶ eqToHom (by simp))\n\n"}
{"name":"CategoryTheory.Functor.toOplaxFunctor_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"I : Type u_1\nB : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} I\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.Strict B\nF : CategoryTheory.Functor I B\nx‚úù : CategoryTheory.LocallyDiscrete I\n‚ä¢ Eq (F.toOplaxFunctor.mapId x‚úù) (CategoryTheory.eqToHom ‚ãØ)","decl":"/--\nIf `B` is a strict bicategory and `I` is a (1-)category, any functor (of 1-categories) `I ‚•§ B` can\nbe promoted to an oplax functor from `LocallyDiscrete I` to `B`.\n-/\n@[simps! obj map mapId mapComp]\ndef Functor.toOplaxFunctor : OplaxFunctor (LocallyDiscrete I) B :=\n  oplaxFunctorOfIsLocallyDiscrete\n    (fun ‚ü®X‚ü© ‚Ü¶ F.obj X) (fun ‚ü®f‚ü© ‚Ü¶ F.map f)\n    (fun ‚ü®X‚ü© ‚Ü¶ eqToHom (by simp)) (fun f g ‚Ü¶ eqToHom (by simp))\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mkPseudofunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B‚ÇÄ : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} B‚ÇÄ\ninst‚úù : CategoryTheory.Bicategory C\nobj : B‚ÇÄ ‚Üí C\nmap : {b b' : B‚ÇÄ} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B‚ÇÄ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nX‚úù Y‚úù : CategoryTheory.LocallyDiscrete B‚ÇÄ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.LocallyDiscrete.mkPseudofunctor obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).map f) (map f.as)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps! obj map mapId mapComp]\ndef mkPseudofunctor {B‚ÇÄ C : Type*} [Category B‚ÇÄ] [Bicategory C]\n    (obj : B‚ÇÄ ‚Üí C)\n    (map : ‚àÄ {b b' : B‚ÇÄ}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B‚ÇÄ), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor (LocallyDiscrete B‚ÇÄ) C :=\n  pseudofunctorOfIsLocallyDiscrete (fun b ‚Ü¶ obj b.as) (fun f ‚Ü¶ map f.as)\n    (fun _ ‚Ü¶ mapId _) (fun _ _ ‚Ü¶ mapComp _ _) (fun _ _ _ ‚Ü¶ map‚ÇÇ_associator _ _ _)\n    (fun _ ‚Ü¶ map‚ÇÇ_left_unitor _) (fun _ ‚Ü¶ map‚ÇÇ_right_unitor _)\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mkPseudofunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B‚ÇÄ : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} B‚ÇÄ\ninst‚úù : CategoryTheory.Bicategory C\nobj : B‚ÇÄ ‚Üí C\nmap : {b b' : B‚ÇÄ} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B‚ÇÄ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nb : CategoryTheory.LocallyDiscrete B‚ÇÄ\n‚ä¢ Eq ((CategoryTheory.LocallyDiscrete.mkPseudofunctor obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).obj b) (obj b.as)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps! obj map mapId mapComp]\ndef mkPseudofunctor {B‚ÇÄ C : Type*} [Category B‚ÇÄ] [Bicategory C]\n    (obj : B‚ÇÄ ‚Üí C)\n    (map : ‚àÄ {b b' : B‚ÇÄ}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B‚ÇÄ), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor (LocallyDiscrete B‚ÇÄ) C :=\n  pseudofunctorOfIsLocallyDiscrete (fun b ‚Ü¶ obj b.as) (fun f ‚Ü¶ map f.as)\n    (fun _ ‚Ü¶ mapId _) (fun _ _ ‚Ü¶ mapComp _ _) (fun _ _ _ ‚Ü¶ map‚ÇÇ_associator _ _ _)\n    (fun _ ‚Ü¶ map‚ÇÇ_left_unitor _) (fun _ ‚Ü¶ map‚ÇÇ_right_unitor _)\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mkPseudofunctor_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B‚ÇÄ : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} B‚ÇÄ\ninst‚úù : CategoryTheory.Bicategory C\nobj : B‚ÇÄ ‚Üí C\nmap : {b b' : B‚ÇÄ} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B‚ÇÄ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\na‚úù b‚úù c‚úù : CategoryTheory.LocallyDiscrete B‚ÇÄ\nx‚úù¬π : Quiver.Hom a‚úù b‚úù\nx‚úù : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.LocallyDiscrete.mkPseudofunctor obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapComp x‚úù¬π x‚úù) (mapComp x‚úù¬π.as x‚úù.as)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps! obj map mapId mapComp]\ndef mkPseudofunctor {B‚ÇÄ C : Type*} [Category B‚ÇÄ] [Bicategory C]\n    (obj : B‚ÇÄ ‚Üí C)\n    (map : ‚àÄ {b b' : B‚ÇÄ}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B‚ÇÄ), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor (LocallyDiscrete B‚ÇÄ) C :=\n  pseudofunctorOfIsLocallyDiscrete (fun b ‚Ü¶ obj b.as) (fun f ‚Ü¶ map f.as)\n    (fun _ ‚Ü¶ mapId _) (fun _ _ ‚Ü¶ mapComp _ _) (fun _ _ _ ‚Ü¶ map‚ÇÇ_associator _ _ _)\n    (fun _ ‚Ü¶ map‚ÇÇ_left_unitor _) (fun _ ‚Ü¶ map‚ÇÇ_right_unitor _)\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mkPseudofunctor_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete","initialProofState":"B‚ÇÄ : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} B‚ÇÄ\ninst‚úù : CategoryTheory.Bicategory C\nobj : B‚ÇÄ ‚Üí C\nmap : {b b' : B‚ÇÄ} ‚Üí Quiver.Hom b b' ‚Üí Quiver.Hom (obj b) (obj b')\nmapId : (b : B‚ÇÄ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.id (obj b))\nmapComp : {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} ‚Üí (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) ‚Üí (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) ‚Üí CategoryTheory.Iso (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (map g))\nmap‚ÇÇ_associator : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ) (g : Quiver.Hom b‚ÇÅ b‚ÇÇ) (h : Quiver.Hom b‚ÇÇ b‚ÇÉ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv)))) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b‚ÇÄ) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b‚ÇÄ).hom (map f)) (CategoryTheory.Bicategory.leftUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : Quiver.Hom b‚ÇÄ b‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b‚ÇÅ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b‚ÇÅ).hom) (CategoryTheory.Bicategory.rightUnitor (map f)).hom)) (CategoryTheory.eqToHom ‚ãØ)) _auto‚úù\nx‚úù : CategoryTheory.LocallyDiscrete B‚ÇÄ\n‚ä¢ Eq ((CategoryTheory.LocallyDiscrete.mkPseudofunctor obj map mapId mapComp map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor).mapId x‚úù) (mapId x‚úù.as)","decl":"/-- Constructor for pseudofunctors from a locally discrete bicategory. In that\ncase, we do not need to provide the `map‚ÇÇ` field of pseudofunctors. -/\n@[simps! obj map mapId mapComp]\ndef mkPseudofunctor {B‚ÇÄ C : Type*} [Category B‚ÇÄ] [Bicategory C]\n    (obj : B‚ÇÄ ‚Üí C)\n    (map : ‚àÄ {b b' : B‚ÇÄ}, (b ‚ü∂ b') ‚Üí (obj b ‚ü∂ obj b'))\n    (mapId : ‚àÄ (b : B‚ÇÄ), map (ùüô b) ‚âÖ ùüô _)\n    (mapComp : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ), map (f ‚â´ g) ‚âÖ map f ‚â´ map g)\n    (map‚ÇÇ_associator : ‚àÄ {b‚ÇÄ b‚ÇÅ b‚ÇÇ b‚ÇÉ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ) (g : b‚ÇÅ ‚ü∂ b‚ÇÇ) (h : b‚ÇÇ ‚ü∂ b‚ÇÉ),\n      (mapComp (f ‚â´ g) h).hom ‚â´\n        (mapComp f g).hom ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom ‚â´\n          map f ‚óÅ (mapComp g h).inv ‚â´ (mapComp f (g ‚â´ h)).inv = eqToHom (by simp) := by aesop_cat)\n    (map‚ÇÇ_left_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp (ùüô b‚ÇÄ) f).hom ‚â´ (mapId b‚ÇÄ).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat)\n    (map‚ÇÇ_right_unitor : ‚àÄ {b‚ÇÄ b‚ÇÅ : B‚ÇÄ} (f : b‚ÇÄ ‚ü∂ b‚ÇÅ),\n      (mapComp f (ùüô b‚ÇÅ)).hom ‚â´ map f ‚óÅ (mapId b‚ÇÅ).hom ‚â´ (œÅ_ (map f)).hom = eqToHom (by simp) := by\n        aesop_cat) :\n    Pseudofunctor (LocallyDiscrete B‚ÇÄ) C :=\n  pseudofunctorOfIsLocallyDiscrete (fun b ‚Ü¶ obj b.as) (fun f ‚Ü¶ map f.as)\n    (fun _ ‚Ü¶ mapId _) (fun _ _ ‚Ü¶ mapComp _ _) (fun _ _ _ ‚Ü¶ map‚ÇÇ_associator _ _ _)\n    (fun _ ‚Ü¶ map‚ÇÇ_left_unitor _) (fun _ ‚Ü¶ map‚ÇÇ_right_unitor _)\n\n"}
