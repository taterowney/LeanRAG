{"name":"CategoryTheory.Dial.mk.injEq","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasFiniteProducts C\nsrcâœ tgtâœ : C\nrelâœ : CategoryTheory.Subobject (CategoryTheory.Limits.prod srcâœ tgtâœ)\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\nâŠ¢ Eq (Eq { src := srcâœ, tgt := tgtâœ, rel := relâœ } { src := src, tgt := tgt, rel := rel }) (And (Eq srcâœ src) (And (Eq tgtâœ tgt) (HEq relâœ rel)))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `âŸ¨U, X, Î± âŠ† U Ã— XâŸ©`,\nand a morphism from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair `(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that\n`{(u,y) | Î±(u, F(u, y))} âŠ† {(u,y) | Î²(f(u), y)}`. The subset `Î±` is actually encoded as an element\nof `Subobject (U Ã— X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src â¨¯ tgt`, interpreted as a relation -/\n  rel : Subobject (src â¨¯ tgt)\n\n"}
{"name":"CategoryTheory.Dial.mk.inj","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasFiniteProducts C\nsrcâœ tgtâœ : C\nrelâœ : CategoryTheory.Subobject (CategoryTheory.Limits.prod srcâœ tgtâœ)\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\nxâœ : Eq { src := srcâœ, tgt := tgtâœ, rel := relâœ } { src := src, tgt := tgt, rel := rel }\nâŠ¢ And (Eq srcâœ src) (And (Eq tgtâœ tgt) (HEq relâœ rel))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `âŸ¨U, X, Î± âŠ† U Ã— XâŸ©`,\nand a morphism from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair `(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that\n`{(u,y) | Î±(u, F(u, y))} âŠ† {(u,y) | Î²(f(u), y)}`. The subset `Î±` is actually encoded as an element\nof `Subobject (U Ã— X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src â¨¯ tgt`, interpreted as a relation -/\n  rel : Subobject (src â¨¯ tgt)\n\n"}
{"name":"CategoryTheory.Dial.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : SizeOf C\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\nâŠ¢ Eq (SizeOf.sizeOf { src := src, tgt := tgt, rel := rel }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf src)) (SizeOf.sizeOf tgt)) (SizeOf.sizeOf rel))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `âŸ¨U, X, Î± âŠ† U Ã— XâŸ©`,\nand a morphism from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair `(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that\n`{(u,y) | Î±(u, F(u, y))} âŠ† {(u,y) | Î²(f(u), y)}`. The subset `Î±` is actually encoded as an element\nof `Subobject (U Ã— X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src â¨¯ tgt`, interpreted as a relation -/\n  rel : Subobject (src â¨¯ tgt)\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nfâœ : Quiver.Hom X.src Y.src\nFâœ : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nleâœ : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst Fâœ)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map fâœ (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nâŠ¢ Eq (Eq { f := fâœ, F := Fâœ, le := leâœ } { f := f, F := F, le := le }) (And (Eq fâœ f) (Eq Fâœ F))","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ninstâœ : SizeOf C\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nâŠ¢ Eq (SizeOf.sizeOf { f := f, F := F, le := le }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf F)) (SizeOf.sizeOf le))","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.inj","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nfâœ : Quiver.Hom X.src Y.src\nFâœ : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nleâœ : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst Fâœ)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map fâœ (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nxâœ : Eq { f := fâœ, F := Fâœ, le := leâœ } { f := f, F := F, le := le }\nâŠ¢ And (Eq fâœ f) (Eq Fâœ F)","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.ext","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : X.Hom Y\nf : Eq x.f y.f\nF : Eq x.F y.F\nâŠ¢ Eq x y","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.ext_iff","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : X.Hom Y\nâŠ¢ Iff (Eq x y) (And (Eq x.f y.f) (Eq x.F y.F))","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.le","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nself : X.Hom Y\nâŠ¢ LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst self.F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map self.f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)","decl":"/-- A morphism in the `Dial C` category from `âŸ¨U, X, Î±âŸ©` to `âŸ¨V, Y, Î²âŸ©` is a pair\n`(f : U âŸ¶ V, F : U â¨¯ Y âŸ¶ X)` such that `{(u,y) | Î±(u, F(u, y))} â‰¤ {(u,y) | Î²(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src âŸ¶ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src â¨¯ Y.tgt âŸ¶ X.tgt\n  /-- This says `{(u, y) | Î±(u, F(u, y))} âŠ† {(u, y) | Î²(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback Ï€(Ï€â‚, F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map f (ğŸ™ _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.comp_le_lemma","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\nF : X.Hom Y\nG : Y.Hom Z\nâŠ¢ LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map F.f (CategoryTheory.CategoryStruct.id Z.tgt)) G.F)) F.F))).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp F.f G.f) (CategoryTheory.CategoryStruct.id Z.tgt))).obj Z.rel)","decl":"theorem comp_le_lemma {X Y Z : Dial C} (F : Dial.Hom X Y) (G : Dial.Hom Y Z) :\n    (Subobject.pullback Ï€(Ï€â‚, Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F) â‰« F.F)).obj X.rel â‰¤\n    (Subobject.pullback (prod.map (F.f â‰« G.f) (ğŸ™ Z.tgt))).obj Z.rel := by\n  refine\n    le_trans ?_ <| ((Subobject.pullback (Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F))).monotone F.le).trans <|\n    le_trans ?_ <| ((Subobject.pullback (prod.map F.f (ğŸ™ Z.tgt))).monotone G.le).trans ?_\n    <;> simp [â† Subobject.pullback_comp]\n\n"}
{"name":"CategoryTheory.Dial.instCategory_comp_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nxâœÂ² xâœÂ¹ xâœ : CategoryTheory.Dial C\nF : xâœÂ².Hom xâœÂ¹\nG : xâœÂ¹.Hom xâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp F G).F (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map F.f (CategoryTheory.CategoryStruct.id xâœ.tgt)) G.F)) F.F)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ğŸ™ _\n    F := Ï€â‚‚\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f â‰« G.f\n    F := Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F) â‰« F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [â† Category.assoc, â† Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_id_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.src)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ğŸ™ _\n    F := Ï€â‚‚\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f â‰« G.f\n    F := Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F) â‰« F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [â† Category.assoc, â† Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_id_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).F CategoryTheory.Limits.prod.snd","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ğŸ™ _\n    F := Ï€â‚‚\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f â‰« G.f\n    F := Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F) â‰« F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [â† Category.assoc, â† Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_comp_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nxâœÂ² xâœÂ¹ xâœ : CategoryTheory.Dial C\nF : xâœÂ².Hom xâœÂ¹\nG : xâœÂ¹.Hom xâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp F G).f (CategoryTheory.CategoryStruct.comp F.f G.f)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ğŸ™ _\n    F := Ï€â‚‚\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f â‰« G.f\n    F := Ï€(Ï€â‚, prod.map F.f (ğŸ™ _) â‰« G.F) â‰« F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [â† Category.assoc, â† Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.hom_ext_iff","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : Quiver.Hom X Y\nâŠ¢ Iff (Eq x y) (And (Eq x.f y.f) (Eq x.F y.F))","decl":"@[ext] theorem hom_ext {X Y : Dial C} {x y : X âŸ¶ Y} (hf : x.f = y.f) (hF : x.F = y.F) : x = y :=\n   Hom.ext hf hF\n\n"}
{"name":"CategoryTheory.Dial.hom_ext","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : Quiver.Hom X Y\nhf : Eq x.f y.f\nhF : Eq x.F y.F\nâŠ¢ Eq x y","decl":"@[ext] theorem hom_ext {X Y : Dial C} {x y : X âŸ¶ Y} (hf : x.f = y.f) (hF : x.F = y.F) : x = y :=\n   Hom.ext hf hF\n\n"}
{"name":"CategoryTheory.Dial.isoMk_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\neâ‚ : CategoryTheory.Iso X.src Y.src\neâ‚‚ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel)\nâŠ¢ Eq (CategoryTheory.Dial.isoMk eâ‚ eâ‚‚ eq).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd eâ‚‚.hom)","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (eâ‚ : X.src â‰… Y.src) (eâ‚‚ : X.tgt â‰… Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel) : X â‰… Y where\n  hom := {\n    f := eâ‚.hom\n    F := Ï€â‚‚ â‰« eâ‚‚.inv\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := eâ‚.inv\n    F := Ï€â‚‚ â‰« eâ‚‚.hom\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\neâ‚ : CategoryTheory.Iso X.src Y.src\neâ‚‚ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel)\nâŠ¢ Eq (CategoryTheory.Dial.isoMk eâ‚ eâ‚‚ eq).hom.f eâ‚.hom","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (eâ‚ : X.src â‰… Y.src) (eâ‚‚ : X.tgt â‰… Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel) : X â‰… Y where\n  hom := {\n    f := eâ‚.hom\n    F := Ï€â‚‚ â‰« eâ‚‚.inv\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := eâ‚.inv\n    F := Ï€â‚‚ â‰« eâ‚‚.hom\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\neâ‚ : CategoryTheory.Iso X.src Y.src\neâ‚‚ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel)\nâŠ¢ Eq (CategoryTheory.Dial.isoMk eâ‚ eâ‚‚ eq).hom.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd eâ‚‚.inv)","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (eâ‚ : X.src â‰… Y.src) (eâ‚‚ : X.tgt â‰… Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel) : X â‰… Y where\n  hom := {\n    f := eâ‚.hom\n    F := Ï€â‚‚ â‰« eâ‚‚.inv\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := eâ‚.inv\n    F := Ï€â‚‚ â‰« eâ‚‚.hom\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\neâ‚ : CategoryTheory.Iso X.src Y.src\neâ‚‚ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel)\nâŠ¢ Eq (CategoryTheory.Dial.isoMk eâ‚ eâ‚‚ eq).inv.f eâ‚.inv","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (eâ‚ : X.src â‰… Y.src) (eâ‚‚ : X.tgt â‰… Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map eâ‚.hom eâ‚‚.hom)).obj Y.rel) : X â‰… Y where\n  hom := {\n    f := eâ‚.hom\n    F := Ï€â‚‚ â‰« eâ‚‚.inv\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := eâ‚.inv\n    F := Ï€â‚‚ â‰« eâ‚‚.hom\n    le := by rw [eq, â† Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
