{"name":"CategoryTheory.Dial.mk.injEq","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\nsrc‚úù tgt‚úù : C\nrel‚úù : CategoryTheory.Subobject (CategoryTheory.Limits.prod src‚úù tgt‚úù)\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\n‚ä¢ Eq (Eq { src := src‚úù, tgt := tgt‚úù, rel := rel‚úù } { src := src, tgt := tgt, rel := rel }) (And (Eq src‚úù src) (And (Eq tgt‚úù tgt) (HEq rel‚úù rel)))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `‚ü®U, X, Œ± ‚äÜ U √ó X‚ü©`,\nand a morphism from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair `(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that\n`{(u,y) | Œ±(u, F(u, y))} ‚äÜ {(u,y) | Œ≤(f(u), y)}`. The subset `Œ±` is actually encoded as an element\nof `Subobject (U √ó X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src ‚®Ø tgt`, interpreted as a relation -/\n  rel : Subobject (src ‚®Ø tgt)\n\n"}
{"name":"CategoryTheory.Dial.mk.inj","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\nsrc‚úù tgt‚úù : C\nrel‚úù : CategoryTheory.Subobject (CategoryTheory.Limits.prod src‚úù tgt‚úù)\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\nx‚úù : Eq { src := src‚úù, tgt := tgt‚úù, rel := rel‚úù } { src := src, tgt := tgt, rel := rel }\n‚ä¢ And (Eq src‚úù src) (And (Eq tgt‚úù tgt) (HEq rel‚úù rel))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `‚ü®U, X, Œ± ‚äÜ U √ó X‚ü©`,\nand a morphism from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair `(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that\n`{(u,y) | Œ±(u, F(u, y))} ‚äÜ {(u,y) | Œ≤(f(u), y)}`. The subset `Œ±` is actually encoded as an element\nof `Subobject (U √ó X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src ‚®Ø tgt`, interpreted as a relation -/\n  rel : Subobject (src ‚®Ø tgt)\n\n"}
{"name":"CategoryTheory.Dial.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : SizeOf C\nsrc tgt : C\nrel : CategoryTheory.Subobject (CategoryTheory.Limits.prod src tgt)\n‚ä¢ Eq (SizeOf.sizeOf { src := src, tgt := tgt, rel := rel }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf src)) (SizeOf.sizeOf tgt)) (SizeOf.sizeOf rel))","decl":"variable (C) in\n/-- The Dialectica category. An object of the category is a triple `‚ü®U, X, Œ± ‚äÜ U √ó X‚ü©`,\nand a morphism from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair `(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that\n`{(u,y) | Œ±(u, F(u, y))} ‚äÜ {(u,y) | Œ≤(f(u), y)}`. The subset `Œ±` is actually encoded as an element\nof `Subobject (U √ó X)`, and the above inequality is expressed using pullbacks. -/\nstructure Dial where\n  /-- The source object -/\n  src : C\n  /-- The target object -/\n  tgt : C\n  /-- A subobject of `src ‚®Ø tgt`, interpreted as a relation -/\n  rel : Subobject (src ‚®Ø tgt)\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf‚úù : Quiver.Hom X.src Y.src\nF‚úù : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle‚úù : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F‚úù)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f‚úù (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\n‚ä¢ Eq (Eq { f := f‚úù, F := F‚úù, le := le‚úù } { f := f, F := F, le := le }) (And (Eq f‚úù f) (Eq F‚úù F))","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ninst‚úù : SizeOf C\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\n‚ä¢ Eq (SizeOf.sizeOf { f := f, F := F, le := le }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf F)) (SizeOf.sizeOf le))","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.mk.inj","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf‚úù : Quiver.Hom X.src Y.src\nF‚úù : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle‚úù : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F‚úù)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f‚úù (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nf : Quiver.Hom X.src Y.src\nF : Quiver.Hom (CategoryTheory.Limits.prod X.src Y.tgt) X.tgt\nle : LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)\nx‚úù : Eq { f := f‚úù, F := F‚úù, le := le‚úù } { f := f, F := F, le := le }\n‚ä¢ And (Eq f‚úù f) (Eq F‚úù F)","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.ext","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : X.Hom Y\nf : Eq x.f y.f\nF : Eq x.F y.F\n‚ä¢ Eq x y","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.ext_iff","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (And (Eq x.f y.f) (Eq x.F y.F))","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.Hom.le","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nself : X.Hom Y\n‚ä¢ LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst self.F)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map self.f (CategoryTheory.CategoryStruct.id Y.tgt))).obj Y.rel)","decl":"/-- A morphism in the `Dial C` category from `‚ü®U, X, Œ±‚ü©` to `‚ü®V, Y, Œ≤‚ü©` is a pair\n`(f : U ‚ü∂ V, F : U ‚®Ø Y ‚ü∂ X)` such that `{(u,y) | Œ±(u, F(u, y))} ‚â§ {(u,y) | Œ≤(f(u), y)}`. -/\n@[ext] structure Hom (X Y : Dial C) where\n  /-- Maps the sources -/\n  f : X.src ‚ü∂ Y.src\n  /-- Maps the targets (contravariantly) -/\n  F : X.src ‚®Ø Y.tgt ‚ü∂ X.tgt\n  /-- This says `{(u, y) | Œ±(u, F(u, y))} ‚äÜ {(u, y) | Œ≤(f(u), y)}` using subobject pullbacks -/\n  le :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map f (ùüô _))).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.comp_le_lemma","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\nF : X.Hom Y\nG : Y.Hom Z\n‚ä¢ LE.le ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map F.f (CategoryTheory.CategoryStruct.id Z.tgt)) G.F)) F.F))).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp F.f G.f) (CategoryTheory.CategoryStruct.id Z.tgt))).obj Z.rel)","decl":"theorem comp_le_lemma {X Y Z : Dial C} (F : Dial.Hom X Y) (G : Dial.Hom Y Z) :\n    (Subobject.pullback œÄ(œÄ‚ÇÅ, œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F) ‚â´ F.F)).obj X.rel ‚â§\n    (Subobject.pullback (prod.map (F.f ‚â´ G.f) (ùüô Z.tgt))).obj Z.rel := by\n  refine\n    le_trans ?_ <| ((Subobject.pullback (œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F))).monotone F.le).trans <|\n    le_trans ?_ <| ((Subobject.pullback (prod.map F.f (ùüô Z.tgt))).monotone G.le).trans ?_\n    <;> simp [‚Üê Subobject.pullback_comp]\n\n"}
{"name":"CategoryTheory.Dial.instCategory_comp_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nx‚úù¬≤ x‚úù¬π x‚úù : CategoryTheory.Dial C\nF : x‚úù¬≤.Hom x‚úù¬π\nG : x‚úù¬π.Hom x‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F G).F (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map F.f (CategoryTheory.CategoryStruct.id x‚úù.tgt)) G.F)) F.F)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ùüô _\n    F := œÄ‚ÇÇ\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f ‚â´ G.f\n    F := œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F) ‚â´ F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [‚Üê Category.assoc, ‚Üê Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_id_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.src)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ùüô _\n    F := œÄ‚ÇÇ\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f ‚â´ G.f\n    F := œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F) ‚â´ F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [‚Üê Category.assoc, ‚Üê Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_id_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).F CategoryTheory.Limits.prod.snd","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ùüô _\n    F := œÄ‚ÇÇ\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f ‚â´ G.f\n    F := œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F) ‚â´ F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [‚Üê Category.assoc, ‚Üê Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.instCategory_comp_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nx‚úù¬≤ x‚úù¬π x‚úù : CategoryTheory.Dial C\nF : x‚úù¬≤.Hom x‚úù¬π\nG : x‚úù¬π.Hom x‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F G).f (CategoryTheory.CategoryStruct.comp F.f G.f)","decl":"@[simps]\ninstance : Category (Dial C) where\n  Hom := Dial.Hom\n  id X := {\n    f := ùüô _\n    F := œÄ‚ÇÇ\n    le := by simp\n  }\n  comp {_ _ _} (F G : Dial.Hom ..) := {\n    f := F.f ‚â´ G.f\n    F := œÄ(œÄ‚ÇÅ, prod.map F.f (ùüô _) ‚â´ G.F) ‚â´ F.F\n    le := comp_le_lemma F G\n  }\n  id_comp f := by simp; rfl\n  comp_id f := by simp; rfl\n  assoc f g h := by\n    simp only [Category.assoc, Hom.mk.injEq, true_and]\n    rw [‚Üê Category.assoc, ‚Üê Category.assoc]; congr 1\n    ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.hom_ext_iff","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : Quiver.Hom X Y\n‚ä¢ Iff (Eq x y) (And (Eq x.f y.f) (Eq x.F y.F))","decl":"@[ext] theorem hom_ext {X Y : Dial C} {x y : X ‚ü∂ Y} (hf : x.f = y.f) (hF : x.F = y.F) : x = y :=\n   Hom.ext hf hF\n\n"}
{"name":"CategoryTheory.Dial.hom_ext","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nx y : Quiver.Hom X Y\nhf : Eq x.f y.f\nhF : Eq x.F y.F\n‚ä¢ Eq x y","decl":"@[ext] theorem hom_ext {X Y : Dial C} {x y : X ‚ü∂ Y} (hf : x.f = y.f) (hF : x.F = y.F) : x = y :=\n   Hom.ext hf hF\n\n"}
{"name":"CategoryTheory.Dial.isoMk_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ne‚ÇÅ : CategoryTheory.Iso X.src Y.src\ne‚ÇÇ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel)\n‚ä¢ Eq (CategoryTheory.Dial.isoMk e‚ÇÅ e‚ÇÇ eq).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd e‚ÇÇ.hom)","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (e‚ÇÅ : X.src ‚âÖ Y.src) (e‚ÇÇ : X.tgt ‚âÖ Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel) : X ‚âÖ Y where\n  hom := {\n    f := e‚ÇÅ.hom\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.inv\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := e‚ÇÅ.inv\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.hom\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ne‚ÇÅ : CategoryTheory.Iso X.src Y.src\ne‚ÇÇ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel)\n‚ä¢ Eq (CategoryTheory.Dial.isoMk e‚ÇÅ e‚ÇÇ eq).hom.f e‚ÇÅ.hom","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (e‚ÇÅ : X.src ‚âÖ Y.src) (e‚ÇÇ : X.tgt ‚âÖ Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel) : X ‚âÖ Y where\n  hom := {\n    f := e‚ÇÅ.hom\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.inv\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := e‚ÇÅ.inv\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.hom\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ne‚ÇÅ : CategoryTheory.Iso X.src Y.src\ne‚ÇÇ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel)\n‚ä¢ Eq (CategoryTheory.Dial.isoMk e‚ÇÅ e‚ÇÇ eq).hom.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd e‚ÇÇ.inv)","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (e‚ÇÅ : X.src ‚âÖ Y.src) (e‚ÇÇ : X.tgt ‚âÖ Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel) : X ‚âÖ Y where\n  hom := {\n    f := e‚ÇÅ.hom\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.inv\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := e‚ÇÅ.inv\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.hom\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
{"name":"CategoryTheory.Dial.isoMk_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\ne‚ÇÅ : CategoryTheory.Iso X.src Y.src\ne‚ÇÇ : CategoryTheory.Iso X.tgt Y.tgt\neq : Eq X.rel ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel)\n‚ä¢ Eq (CategoryTheory.Dial.isoMk e‚ÇÅ e‚ÇÇ eq).inv.f e‚ÇÅ.inv","decl":"/--\nAn isomorphism in `Dial C` can be induced by isomorphisms on the source and target,\nwhich respect the respective relations on `X` and `Y`.\n-/\n@[simps] def isoMk {X Y : Dial C} (e‚ÇÅ : X.src ‚âÖ Y.src) (e‚ÇÇ : X.tgt ‚âÖ Y.tgt)\n    (eq : X.rel = (Subobject.pullback (prod.map e‚ÇÅ.hom e‚ÇÇ.hom)).obj Y.rel) : X ‚âÖ Y where\n  hom := {\n    f := e‚ÇÅ.hom\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.inv\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n  inv := {\n    f := e‚ÇÅ.inv\n    F := œÄ‚ÇÇ ‚â´ e‚ÇÇ.hom\n    le := by rw [eq, ‚Üê Subobject.pullback_comp]; apply le_of_eq; congr; ext <;> simp\n  }\n\n"}
