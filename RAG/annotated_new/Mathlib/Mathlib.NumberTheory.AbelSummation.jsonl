{"name":"integrableOn_mul_sum_Icc","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\na b : Real\nm : Nat\nha : LE.le 0 a\ng : Real → 𝕜\nhg_int : MeasureTheory.IntegrableOn g (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IntegrableOn (fun t => HMul.hMul (g t) ((Finset.Icc m (Nat.floor t)).sum fun k => c k)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume","decl":"theorem _root_.integrableOn_mul_sum_Icc {m : ℕ} (ha : 0 ≤ a) {g : ℝ → 𝕜}\n    (hg_int : IntegrableOn g (Set.Icc a b)) :\n    IntegrableOn (fun t ↦ g t * ∑ k ∈ Icc m ⌊t⌋₊, c k) (Set.Icc a b) := by\n  obtain hab | hab := le_or_gt a b\n  · obtain hb | hb := eq_or_lt_of_le (Nat.floor_le_floor hab)\n    · have : ∀ᵐ t, t ∈ Set.Icc a b → ∑ k ∈ Icc m ⌊a⌋₊, c k = ∑ k ∈ Icc m ⌊t⌋₊, c k := by\n        filter_upwards [sumlocc c ⌊a⌋₊] with t ht₁ ht₂\n        rw [ht₁ ⟨(Nat.floor_le ha).trans ht₂.1, hb ▸ ht₂.2.trans (Nat.lt_floor_add_one b).le⟩]\n      rw [← ae_restrict_iff' measurableSet_Icc] at this\n      exact IntegrableOn.congr_fun_ae\n        (hg_int.mul_const _) ((Filter.EventuallyEq.refl _ g).mul this)\n    · have h_locint {t₁ t₂ : ℝ} {n : ℕ} (h : t₁ ≤ t₂) (h₁ : n ≤ t₁) (h₂ : t₂ ≤ n + 1)\n          (h₃ : a ≤ t₁) (h₄ : t₂ ≤ b) :\n          IntervalIntegrable (fun t ↦ g t * ∑ k ∈ Icc m ⌊t⌋₊, c k) volume t₁ t₂ := by\n        rw [intervalIntegrable_iff_integrableOn_Icc_of_le h]\n        exact (IntegrableOn.mono_set (hg_int.mul_const _) (Set.Icc_subset_Icc h₃ h₄)).congr\n          <| ae_restrict_of_ae_restrict_of_subset (Set.Icc_subset_Icc h₁ h₂)\n            <| (ae_restrict_iff' measurableSet_Icc).mpr\n              (by filter_upwards [sumlocc c n] with t h ht using by rw [h ht])\n      have aux1 : 0 ≤ b := (Nat.pos_of_floor_pos <| (Nat.zero_le _).trans_lt hb).le\n      have aux2 : ⌊a⌋₊ + 1 ≤ b := by rwa [← Nat.cast_add_one, ← Nat.le_floor_iff aux1]\n      have aux3 : a ≤ ⌊a⌋₊ + 1 := (Nat.lt_floor_add_one _).le\n      have aux4 : a ≤ ⌊b⌋₊ := le_of_lt (by rwa [← Nat.floor_lt ha])\n      -- now break up into 3 subintervals\n      rw [← intervalIntegrable_iff_integrableOn_Icc_of_le (aux3.trans aux2)]\n      have I1 : IntervalIntegrable _ volume a ↑(⌊a⌋₊ + 1) :=\n        h_locint (mod_cast aux3) (Nat.floor_le ha) (mod_cast le_rfl) le_rfl (mod_cast aux2)\n      have I2 : IntervalIntegrable _ volume ↑(⌊a⌋₊ + 1) ⌊b⌋₊ :=\n        trans_iterate_Ico hb fun k hk ↦ h_locint (mod_cast k.le_succ)\n          le_rfl (mod_cast le_rfl) (ineqofmemIco hk).1 (mod_cast (ineqofmemIco hk).2)\n      have I3 : IntervalIntegrable _ volume ⌊b⌋₊ b :=\n        h_locint (Nat.floor_le aux1) le_rfl (Nat.lt_floor_add_one _).le aux4 le_rfl\n      exact (I1.trans I2).trans I3\n  · rw [Set.Icc_eq_empty_of_lt hab]\n    exact integrableOn_empty\n\n"}
{"name":"sum_mul_eq_sub_sub_integral_mul","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\na b : Real\nha : LE.le 0 a\nhab : LE.le a b\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc a b) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc a b) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Ioc (Nat.floor a) (Nat.floor b)).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (HMul.hMul (f a) ((Finset.Icc 0 (Nat.floor a)).sum fun k => c k))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc a b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Abel's summation formula. -/\ntheorem _root_.sum_mul_eq_sub_sub_integral_mul (ha : 0 ≤ a) (hab : a ≤ b)\n    (hf_diff : ∀ t ∈ Set.Icc a b, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc a b)) :\n    ∑ k ∈ Ioc ⌊a⌋₊ ⌊b⌋₊, f k * c k =\n      f b * (∑ k ∈ Icc 0 ⌊b⌋₊, c k) - f a * (∑ k ∈ Icc 0 ⌊a⌋₊, c k) -\n        ∫ t in Set.Ioc a b, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  rw [← integral_of_le hab]\n  have aux1 : ⌊a⌋₊ ≤ a := Nat.floor_le ha\n  have aux2 : b ≤ ⌊b⌋₊ + 1 := (Nat.lt_floor_add_one _).le\n  -- We consider two cases depending on whether the sum is empty or not\n  obtain hb | hb := eq_or_lt_of_le (Nat.floor_le_floor hab)\n  · rw [hb, Ioc_eq_empty_of_le le_rfl, sum_empty, ← sub_mul,\n      integralmulsum c hf_diff hf_int _ _ ⌊b⌋₊ hab (hb ▸ aux1) aux2 le_rfl le_rfl, sub_self]\n  have aux3 : a ≤ ⌊a⌋₊ + 1 := (Nat.lt_floor_add_one _).le\n  have aux4 : ⌊a⌋₊ + 1 ≤ b := by rwa [← Nat.cast_add_one,  ← Nat.le_floor_iff (ha.trans hab)]\n  have aux5 : ⌊b⌋₊ ≤ b := Nat.floor_le (ha.trans hab)\n  have aux6 : a ≤ ⌊b⌋₊ := Nat.floor_lt ha |>.mp hb |>.le\n  simp_rw [← smul_eq_mul, sum_Ioc_by_parts (fun k ↦ f k) _ hb, range_eq_Ico, Nat.Ico_succ_right,\n    smul_eq_mul]\n  have : ∑ k ∈ Ioc ⌊a⌋₊ (⌊b⌋₊ - 1), (f ↑(k + 1) - f k) * ∑ n ∈ Icc 0 k, c n =\n        ∑ k ∈ Ico (⌊a⌋₊ + 1) ⌊b⌋₊, ∫ t in k..↑(k + 1), deriv f t * ∑ n ∈ Icc 0 ⌊t⌋₊, c n := by\n    rw [← Nat.Ico_succ_succ, Nat.succ_eq_add_one,  Nat.succ_eq_add_one, Nat.sub_add_cancel\n      (by omega), Eq.comm]\n    exact sum_congr rfl fun k hk ↦ (integralmulsum c hf_diff hf_int _ _ _  (mod_cast k.le_succ)\n      le_rfl (mod_cast le_rfl) (ineqofmemIco' hk).1 <| mod_cast (ineqofmemIco' hk).2)\n  rw [this, sum_integral_adjacent_intervals_Ico hb, Nat.cast_add, Nat.cast_one,\n    ← integral_interval_sub_left (a := a) (c := ⌊a⌋₊ + 1),\n    ← integral_add_adjacent_intervals (b := ⌊b⌋₊) (c := b),\n    integralmulsum c hf_diff hf_int _ _ _ aux3 aux1 le_rfl le_rfl aux4,\n    integralmulsum c hf_diff hf_int _ _ _ aux5 le_rfl aux2 aux6 le_rfl]\n  · ring\n  -- now deal with the integrability side goals\n  -- (Note we have 5 goals, but the 1st and 3rd are identical. TODO: find a non-hacky way of dealing\n  -- with both at once.)\n  · rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux6]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux5)\n  · rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux5]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_left aux6)\n  · rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux6]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux5)\n  · rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux3]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux4)\n  · exact fun k hk ↦ (intervalIntegrable_iff_integrableOn_Icc_of_le (mod_cast k.le_succ)).mpr\n      <| (integrableOn_mul_sum_Icc c ha hf_int).mono_set\n        <| (Set.Icc_subset_Icc_iff (mod_cast k.le_succ)).mpr <| mod_cast (ineqofmemIco hk)\n\n"}
{"name":"sum_mul_eq_sub_sub_integral_mul'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nn m : Nat\nh : LE.le n m\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc ↑n ↑m) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc ↑n ↑m) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Ioc n m).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HSub.hSub (HMul.hMul (f ↑m) ((Finset.Icc 0 m).sum fun k => c k)) (HMul.hMul (f ↑n) ((Finset.Icc 0 n).sum fun k => c k))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc ↑n ↑m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_sub_integral_mul` where the endpoints are `Nat`. -/\ntheorem _root_.sum_mul_eq_sub_sub_integral_mul' {n m : ℕ} (h : n ≤ m)\n    (hf_diff : ∀ t ∈ Set.Icc (n : ℝ) m, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (n : ℝ) m)) :\n    ∑ k ∈ Ioc n m, f k * c k =\n      f m * (∑ k ∈ Icc 0 m, c k) - f n * (∑ k ∈ Icc 0 n, c k) -\n        ∫ t in Set.Ioc (n : ℝ) m, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  convert sum_mul_eq_sub_sub_integral_mul c n.cast_nonneg (Nat.cast_le.mpr h) hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"sum_mul_eq_sub_integral_mul","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nb : Real\nhb : LE.le 0 b\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc 0 b) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 0 b) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Icc 0 (Nat.floor b)).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Specialized version of `sum_mul_eq_sub_sub_integral_mul` for the case `a = 0`.-/\ntheorem sum_mul_eq_sub_integral_mul {b : ℝ} (hb : 0 ≤ b)\n    (hf_diff : ∀ t ∈ Set.Icc 0 b, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc 0 b)) :\n    ∑ k ∈ Icc 0 ⌊b⌋₊, f k * c k =\n      f b * (∑ k ∈ Icc 0 ⌊b⌋₊, c k) - ∫ t in Set.Ioc 0 b, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  nth_rewrite 1 [Icc_eq_cons_Ioc (Nat.zero_le _)]\n  rw [sum_cons, ← Nat.floor_zero (α := ℝ), sum_mul_eq_sub_sub_integral_mul c le_rfl hb hf_diff\n    hf_int, Nat.floor_zero, Nat.cast_zero, Icc_self, sum_singleton]\n  ring\n\n"}
{"name":"sum_mul_eq_sub_integral_mul'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nm : Nat\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc 0 ↑m) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 0 ↑m) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Icc 0 m).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HMul.hMul (f ↑m) ((Finset.Icc 0 m).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 ↑m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_integral_mul` where the endpoint is a `Nat`. -/\ntheorem sum_mul_eq_sub_integral_mul' (m : ℕ)\n    (hf_diff : ∀ t ∈ Set.Icc (0 : ℝ) m, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (0 : ℝ) m)) :\n    ∑ k ∈ Icc 0 m, f k * c k =\n      f m * (∑ k ∈ Icc 0 m, c k) -\n        ∫ t in Set.Ioc (0 : ℝ) m, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  convert sum_mul_eq_sub_integral_mul c m.cast_nonneg hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"sum_mul_eq_sub_integral_mul₀","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhc : Eq (c 0) 0\nb : Real\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc 1 b) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 1 b) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Icc 0 (Nat.floor b)).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 1 b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Specialized version of `sum_mul_eq_sub_integral_mul` when the first coefficient of the sequence\n`c` is equal to `0`. -/\ntheorem sum_mul_eq_sub_integral_mul₀ (hc : c 0 = 0) (b : ℝ)\n    (hf_diff : ∀ t ∈ Set.Icc 1 b, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc 1 b)) :\n    ∑ k ∈ Icc 0 ⌊b⌋₊, f k * c k =\n      f b * (∑ k ∈ Icc 0 ⌊b⌋₊, c k) - ∫ t in Set.Ioc 1 b, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  obtain hb | hb := le_or_gt 1 b\n  · have : 1 ≤ ⌊b⌋₊ := (Nat.one_le_floor_iff _).mpr hb\n    nth_rewrite 1 [Icc_eq_cons_Ioc (Nat.zero_le _), sum_cons, ← Nat.Icc_succ_left,\n      Icc_eq_cons_Ioc (by omega), sum_cons]\n    rw [Nat.succ_eq_add_one, zero_add, ← Nat.floor_one (α := ℝ),\n      sum_mul_eq_sub_sub_integral_mul c zero_le_one hb hf_diff hf_int, Nat.floor_one, Nat.cast_one,\n      Icc_eq_cons_Ioc zero_le_one, sum_cons, show 1 = 0 + 1 by rfl, Nat.Ioc_succ_singleton,\n      zero_add, sum_singleton, hc, mul_zero, zero_add]\n    ring\n  · simp_rw [Nat.floor_eq_zero.mpr hb, Icc_self, sum_singleton, Nat.cast_zero, hc, mul_zero,\n      Set.Ioc_eq_empty_of_le hb.le, Measure.restrict_empty, integral_zero_measure, sub_self]\n\n"}
{"name":"sum_mul_eq_sub_integral_mul₀'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhc : Eq (c 0) 0\nm : Nat\nhf_diff : ∀ (t : Real), Membership.mem (Set.Icc 1 ↑m) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 1 ↑m) MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Finset.Icc 0 m).sum fun k => HMul.hMul (f ↑k) (c k)) (HSub.hSub (HMul.hMul (f ↑m) ((Finset.Icc 0 m).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 1 ↑m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_integral_mul₀` where the endpoint is a `Nat`. -/\ntheorem sum_mul_eq_sub_integral_mul₀' (hc : c 0 = 0) (m : ℕ)\n    (hf_diff : ∀ t ∈ Set.Icc (1 : ℝ) m, DifferentiableAt ℝ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (1 : ℝ) m)) :\n    ∑ k ∈ Icc 0 m, f k * c k =\n      f m * (∑ k ∈ Icc 0 m, c k) -\n        ∫ t in Set.Ioc (1 : ℝ) m, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k := by\n  convert sum_mul_eq_sub_integral_mul₀ c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"locallyIntegrableOn_mul_sum_Icc","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\na : Real\nm : Nat\nha : LE.le 0 a\ng : Real → 𝕜\nhg : MeasureTheory.LocallyIntegrableOn g (Set.Ici a) MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.LocallyIntegrableOn (fun t => HMul.hMul (g t) ((Finset.Icc m (Nat.floor t)).sum fun k => c k)) (Set.Ici a) MeasureTheory.MeasureSpace.volume","decl":"theorem locallyIntegrableOn_mul_sum_Icc {m : ℕ} (ha : 0 ≤ a) {g : ℝ → 𝕜}\n    (hg : LocallyIntegrableOn g (Set.Ici a)) :\n    LocallyIntegrableOn (fun t ↦ g t * ∑ k ∈ Icc m ⌊t⌋₊, c k) (Set.Ici a) := by\n  refine (locallyIntegrableOn_iff isLocallyClosed_Ici).mpr fun K hK₁ hK₂ ↦ ?_\n  by_cases hK₃ : K.Nonempty\n  · have h_inf : a ≤ sInf K := (hK₁ (hK₂.sInf_mem hK₃))\n    refine IntegrableOn.mono_set ?_ (Bornology.IsBounded.subset_Icc_sInf_sSup hK₂.isBounded)\n    refine integrableOn_mul_sum_Icc _ (ha.trans h_inf) ?_\n    refine hg.integrableOn_compact_subset ?_ isCompact_Icc\n    exact (Set.Icc_subset_Ici_iff (Real.sInf_le_sSup _ hK₂.bddBelow hK₂.bddAbove)).mpr h_inf\n  · rw [Set.not_nonempty_iff_eq_empty.mp hK₃]\n    exact integrableOn_empty\n\n"}
{"name":"tendsto_sum_mul_atTop_nhds_one_sub_integral","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhf_diff : ∀ (t : Real), Membership.mem (Set.Ici 0) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv f) (Set.Ici 0) MeasureTheory.MeasureSpace.volume\nl : 𝕜\nh_lim : Filter.Tendsto (fun n => HMul.hMul (f ↑n) ((Finset.Icc 0 n).sum fun k => c k)) Filter.atTop (nhds l)\ng : Real → 𝕜\nhg_dom : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)) g\nhg_int : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto (fun n => (Finset.Icc 0 n).sum fun k => HMul.hMul (f ↑k) (c k)) Filter.atTop (nhds (HSub.hSub l (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k))))","decl":"theorem tendsto_sum_mul_atTop_nhds_one_sub_integral\n    (hf_diff : ∀ t ∈ Set.Ici 0, DifferentiableAt ℝ f t)\n    (hf_int : LocallyIntegrableOn (deriv f) (Set.Ici 0)) {l : 𝕜}\n    (h_lim : Tendsto (fun n : ℕ ↦ f n * ∑ k ∈ Icc 0 n, c k) atTop (𝓝 l))\n    {g : ℝ → 𝕜} (hg_dom : (fun t ↦ deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k) =O[atTop] g)\n    (hg_int : IntegrableAtFilter g atTop) :\n    Tendsto (fun n : ℕ ↦ ∑ k ∈ Icc 0 n, f k * c k) atTop\n      (𝓝 (l - ∫ t in Set.Ioi 0, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)) := by\n  have h_lim' : Tendsto (fun n : ℕ ↦ ∫ t in Set.Ioc (0 : ℝ) n, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)\n      atTop (𝓝 (∫ t in Set.Ioi 0, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)) := by\n    refine Tendsto.congr (fun _ ↦ by rw [← integral_of_le (Nat.cast_nonneg _)]) ?_\n    refine intervalIntegral_tendsto_integral_Ioi _ ?_ tendsto_natCast_atTop_atTop\n    exact integrableOn_Ici_iff_integrableOn_Ioi.mp\n      <| (locallyIntegrableOn_mul_sum_Icc c le_rfl hf_int).integrableOn_of_isBigO_atTop\n        hg_dom hg_int\n  refine (h_lim.sub h_lim').congr (fun _ ↦ ?_)\n  rw [sum_mul_eq_sub_integral_mul' _ _ (fun t ht ↦ hf_diff _ ht.1)]\n  exact hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc\n\n"}
{"name":"tendsto_sum_mul_atTop_nhds_one_sub_integral₀","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhc : Eq (c 0) 0\nhf_diff : ∀ (t : Real), Membership.mem (Set.Ici 1) t → DifferentiableAt Real f t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv f) (Set.Ici 1) MeasureTheory.MeasureSpace.volume\nl : 𝕜\nh_lim : Filter.Tendsto (fun n => HMul.hMul (f ↑n) ((Finset.Icc 0 n).sum fun k => c k)) Filter.atTop (nhds l)\ng : Real → Real\nhg_dom : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)) g\nhg_int : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto (fun n => (Finset.Icc 0 n).sum fun k => HMul.hMul (f ↑k) (c k)) Filter.atTop (nhds (HSub.hSub l (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 1)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k))))","decl":"theorem tendsto_sum_mul_atTop_nhds_one_sub_integral₀ (hc : c 0 = 0)\n    (hf_diff : ∀ t ∈ Set.Ici 1, DifferentiableAt ℝ f t)\n    (hf_int : LocallyIntegrableOn (deriv f) (Set.Ici 1)) {l : 𝕜}\n    (h_lim: Tendsto (fun n : ℕ ↦ f n * ∑ k ∈ Icc 0 n, c k) atTop (𝓝 l))\n    {g : ℝ → ℝ} (hg_dom : (fun t ↦ deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k) =O[atTop] g)\n    (hg_int : IntegrableAtFilter g atTop) :\n    Tendsto (fun n : ℕ ↦ ∑ k ∈ Icc 0 n, f k * c k) atTop\n      (𝓝 (l - ∫ t in Set.Ioi 1, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)) := by\n  have h : (fun n : ℕ ↦ ∫ (x : ℝ) in (1 : ℝ)..n, deriv f x * ∑ k ∈ Icc 0 ⌊x⌋₊, c k) =ᶠ[atTop]\n      (fun n : ℕ ↦ ∫ (t : ℝ) in Set.Ioc 1 ↑n, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k) := by\n    filter_upwards [eventually_ge_atTop 1] with _ h\n    rw [← integral_of_le (Nat.one_le_cast.mpr h)]\n  have h_lim' : Tendsto (fun n : ℕ ↦ ∫ t in Set.Ioc (1 : ℝ) n, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)\n      atTop (𝓝 (∫ t in Set.Ioi 1, deriv f t * ∑ k ∈ Icc 0 ⌊t⌋₊, c k)) := by\n    refine Tendsto.congr' h (intervalIntegral_tendsto_integral_Ioi _ ?_ tendsto_natCast_atTop_atTop)\n    exact integrableOn_Ici_iff_integrableOn_Ioi.mp\n      <| (locallyIntegrableOn_mul_sum_Icc c zero_le_one hf_int).integrableOn_of_isBigO_atTop\n        hg_dom hg_int\n  refine (h_lim.sub h_lim').congr (fun _ ↦ ?_)\n  rw [sum_mul_eq_sub_integral_mul₀' _ hc _ (fun t ht ↦ hf_diff _ ht.1)]\n  exact hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc\n\n"}
{"name":"summable_mul_of_bigO_atTop","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhf_diff : ∀ (t : Real), Membership.mem (Set.Ici 0) t → DifferentiableAt Real (fun x => Norm.norm (f x)) t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv fun t => Norm.norm (f t)) (Set.Ici 0) MeasureTheory.MeasureSpace.volume\nh_bdd : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (f ↑n)) ((Finset.Icc 0 n).sum fun k => Norm.norm (c k))) fun x => 1\ng : Real → Real\nhg₁ : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv (fun t => Norm.norm (f t)) t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => Norm.norm (c k))) g\nhg₂ : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\n⊢ Summable fun n => HMul.hMul (f ↑n) (c n)","decl":"theorem summable_mul_of_bigO_atTop\n    (hf_diff : ∀ t ∈ Set.Ici 0, DifferentiableAt ℝ (fun x ↦ ‖f x‖) t)\n    (hf_int : LocallyIntegrableOn (deriv (fun t ↦ ‖f t‖)) (Set.Ici 0))\n    (h_bdd : (fun n : ℕ ↦ ‖f n‖ * ∑ k ∈ Icc 0 n, ‖c k‖) =O[atTop] fun _ ↦ (1 : ℝ))\n    {g : ℝ → ℝ} (hg₁ : (fun t ↦ deriv (fun t ↦ ‖f t‖) t * ∑ k ∈ Icc 0 ⌊t⌋₊, ‖c k‖) =O[atTop] g)\n    (hg₂ : IntegrableAtFilter g atTop) :\n    Summable (fun n : ℕ ↦ f n * c n) := by\n  refine summable_mul_of_bigO_atTop_aux c 0 h_bdd (by rwa [Nat.cast_zero]) (fun n ↦ ?_) hg₁ hg₂\n  exact_mod_cast sum_mul_eq_sub_integral_mul' _ _ (fun _ ht ↦ hf_diff _ ht.1)\n    (hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc)\n\n"}
{"name":"summable_mul_of_bigO_atTop'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nc : Nat → 𝕜\nf : Real → 𝕜\nhf_diff : ∀ (t : Real), Membership.mem (Set.Ici 1) t → DifferentiableAt Real (fun x => Norm.norm (f x)) t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv fun t => Norm.norm (f t)) (Set.Ici 1) MeasureTheory.MeasureSpace.volume\nh_bdd : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (f ↑n)) ((Finset.Icc 1 n).sum fun k => Norm.norm (c k))) fun x => 1\ng : Real → Real\nhg₁ : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv (fun t => Norm.norm (f t)) t) ((Finset.Icc 1 (Nat.floor t)).sum fun k => Norm.norm (c k))) g\nhg₂ : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\n⊢ Summable fun n => HMul.hMul (f ↑n) (c n)","decl":"/-- A version of `summable_mul_of_bigO_atTop` that can be useful to avoid difficulties near zero. -/\ntheorem summable_mul_of_bigO_atTop'\n    (hf_diff : ∀ t ∈ Set.Ici 1, DifferentiableAt ℝ (fun x ↦ ‖f x‖) t)\n    (hf_int : LocallyIntegrableOn (deriv (fun t ↦ ‖f t‖)) (Set.Ici 1))\n    (h_bdd : (fun n : ℕ ↦ ‖f n‖ * ∑ k ∈ Icc 1 n, ‖c k‖) =O[atTop] fun _ ↦ (1 : ℝ))\n    {g : ℝ → ℝ} (hg₁ : (fun t ↦ deriv (fun t ↦ ‖f t‖) t * ∑ k ∈ Icc 1 ⌊t⌋₊, ‖c k‖) =O[atTop] g)\n    (hg₂ : IntegrableAtFilter g atTop) :\n    Summable (fun n : ℕ ↦ f n * c n) := by\n  have h : ∀ n, ∑ k ∈ Icc 1 n, ‖c k‖ = ∑ k ∈ Icc 0 n, ‖(fun n ↦ if n = 0 then 0 else c n) k‖ := by\n    intro n\n    rw [Icc_eq_cons_Ioc n.zero_le, sum_cons, ← Nat.Icc_succ_left, Nat.succ_eq_add_one, zero_add]\n    simp_rw [if_pos, norm_zero, zero_add]\n    exact Finset.sum_congr rfl fun _ h ↦ by rw [if_neg (zero_lt_one.trans_le (mem_Icc.mp h).1).ne']\n  simp_rw [h] at h_bdd hg₁\n  refine Summable.congr_atTop (summable_mul_of_bigO_atTop_aux (fun n ↦ if n = 0 then 0 else c n) 1\n    h_bdd (by rwa [Nat.cast_one]) (fun n ↦ ?_) hg₁ hg₂) ?_\n  · exact_mod_cast sum_mul_eq_sub_integral_mul₀' _ (by simp only [reduceIte, norm_zero]) n\n      (fun _ ht ↦ hf_diff _ ht.1)\n      (hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc)\n  · filter_upwards [eventually_ne_atTop 0] with k hk\n    simp_rw [if_neg hk]\n\n"}
