{"name":"integrableOn_mul_sum_Icc","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\na b : Real\nm : Nat\nha : LE.le 0 a\ng : Real â†’ ğ•œ\nhg_int : MeasureTheory.IntegrableOn g (Set.Icc a b) MeasureTheory.MeasureSpace.volume\nâŠ¢ MeasureTheory.IntegrableOn (fun t => HMul.hMul (g t) ((Finset.Icc m (Nat.floor t)).sum fun k => c k)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume","decl":"theorem _root_.integrableOn_mul_sum_Icc {m : â„•} (ha : 0 â‰¤ a) {g : â„ â†’ ğ•œ}\n    (hg_int : IntegrableOn g (Set.Icc a b)) :\n    IntegrableOn (fun t â†¦ g t * âˆ‘ k âˆˆ Icc m âŒŠtâŒ‹â‚Š, c k) (Set.Icc a b) := by\n  obtain hab | hab := le_or_gt a b\n  Â· obtain hb | hb := eq_or_lt_of_le (Nat.floor_le_floor hab)\n    Â· have : âˆ€áµ t, t âˆˆ Set.Icc a b â†’ âˆ‘ k âˆˆ Icc m âŒŠaâŒ‹â‚Š, c k = âˆ‘ k âˆˆ Icc m âŒŠtâŒ‹â‚Š, c k := by\n        filter_upwards [sumlocc c âŒŠaâŒ‹â‚Š] with t htâ‚ htâ‚‚\n        rw [htâ‚ âŸ¨(Nat.floor_le ha).trans htâ‚‚.1, hb â–¸ htâ‚‚.2.trans (Nat.lt_floor_add_one b).leâŸ©]\n      rw [â† ae_restrict_iff' measurableSet_Icc] at this\n      exact IntegrableOn.congr_fun_ae\n        (hg_int.mul_const _) ((Filter.EventuallyEq.refl _ g).mul this)\n    Â· have h_locint {tâ‚ tâ‚‚ : â„} {n : â„•} (h : tâ‚ â‰¤ tâ‚‚) (hâ‚ : n â‰¤ tâ‚) (hâ‚‚ : tâ‚‚ â‰¤ n + 1)\n          (hâ‚ƒ : a â‰¤ tâ‚) (hâ‚„ : tâ‚‚ â‰¤ b) :\n          IntervalIntegrable (fun t â†¦ g t * âˆ‘ k âˆˆ Icc m âŒŠtâŒ‹â‚Š, c k) volume tâ‚ tâ‚‚ := by\n        rw [intervalIntegrable_iff_integrableOn_Icc_of_le h]\n        exact (IntegrableOn.mono_set (hg_int.mul_const _) (Set.Icc_subset_Icc hâ‚ƒ hâ‚„)).congr\n          <| ae_restrict_of_ae_restrict_of_subset (Set.Icc_subset_Icc hâ‚ hâ‚‚)\n            <| (ae_restrict_iff' measurableSet_Icc).mpr\n              (by filter_upwards [sumlocc c n] with t h ht using by rw [h ht])\n      have aux1 : 0 â‰¤ b := (Nat.pos_of_floor_pos <| (Nat.zero_le _).trans_lt hb).le\n      have aux2 : âŒŠaâŒ‹â‚Š + 1 â‰¤ b := by rwa [â† Nat.cast_add_one, â† Nat.le_floor_iff aux1]\n      have aux3 : a â‰¤ âŒŠaâŒ‹â‚Š + 1 := (Nat.lt_floor_add_one _).le\n      have aux4 : a â‰¤ âŒŠbâŒ‹â‚Š := le_of_lt (by rwa [â† Nat.floor_lt ha])\n      -- now break up into 3 subintervals\n      rw [â† intervalIntegrable_iff_integrableOn_Icc_of_le (aux3.trans aux2)]\n      have I1 : IntervalIntegrable _ volume a â†‘(âŒŠaâŒ‹â‚Š + 1) :=\n        h_locint (mod_cast aux3) (Nat.floor_le ha) (mod_cast le_rfl) le_rfl (mod_cast aux2)\n      have I2 : IntervalIntegrable _ volume â†‘(âŒŠaâŒ‹â‚Š + 1) âŒŠbâŒ‹â‚Š :=\n        trans_iterate_Ico hb fun k hk â†¦ h_locint (mod_cast k.le_succ)\n          le_rfl (mod_cast le_rfl) (ineqofmemIco hk).1 (mod_cast (ineqofmemIco hk).2)\n      have I3 : IntervalIntegrable _ volume âŒŠbâŒ‹â‚Š b :=\n        h_locint (Nat.floor_le aux1) le_rfl (Nat.lt_floor_add_one _).le aux4 le_rfl\n      exact (I1.trans I2).trans I3\n  Â· rw [Set.Icc_eq_empty_of_lt hab]\n    exact integrableOn_empty\n\n"}
{"name":"sum_mul_eq_sub_sub_integral_mul","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\na b : Real\nha : LE.le 0 a\nhab : LE.le a b\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc a b) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc a b) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Ioc (Nat.floor a) (Nat.floor b)).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (HMul.hMul (f a) ((Finset.Icc 0 (Nat.floor a)).sum fun k => c k))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc a b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Abel's summation formula. -/\ntheorem _root_.sum_mul_eq_sub_sub_integral_mul (ha : 0 â‰¤ a) (hab : a â‰¤ b)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc a b, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc a b)) :\n    âˆ‘ k âˆˆ Ioc âŒŠaâŒ‹â‚Š âŒŠbâŒ‹â‚Š, f k * c k =\n      f b * (âˆ‘ k âˆˆ Icc 0 âŒŠbâŒ‹â‚Š, c k) - f a * (âˆ‘ k âˆˆ Icc 0 âŒŠaâŒ‹â‚Š, c k) -\n        âˆ« t in Set.Ioc a b, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  rw [â† integral_of_le hab]\n  have aux1 : âŒŠaâŒ‹â‚Š â‰¤ a := Nat.floor_le ha\n  have aux2 : b â‰¤ âŒŠbâŒ‹â‚Š + 1 := (Nat.lt_floor_add_one _).le\n  -- We consider two cases depending on whether the sum is empty or not\n  obtain hb | hb := eq_or_lt_of_le (Nat.floor_le_floor hab)\n  Â· rw [hb, Ioc_eq_empty_of_le le_rfl, sum_empty, â† sub_mul,\n      integralmulsum c hf_diff hf_int _ _ âŒŠbâŒ‹â‚Š hab (hb â–¸ aux1) aux2 le_rfl le_rfl, sub_self]\n  have aux3 : a â‰¤ âŒŠaâŒ‹â‚Š + 1 := (Nat.lt_floor_add_one _).le\n  have aux4 : âŒŠaâŒ‹â‚Š + 1 â‰¤ b := by rwa [â† Nat.cast_add_one,  â† Nat.le_floor_iff (ha.trans hab)]\n  have aux5 : âŒŠbâŒ‹â‚Š â‰¤ b := Nat.floor_le (ha.trans hab)\n  have aux6 : a â‰¤ âŒŠbâŒ‹â‚Š := Nat.floor_lt ha |>.mp hb |>.le\n  simp_rw [â† smul_eq_mul, sum_Ioc_by_parts (fun k â†¦ f k) _ hb, range_eq_Ico, Nat.Ico_succ_right,\n    smul_eq_mul]\n  have : âˆ‘ k âˆˆ Ioc âŒŠaâŒ‹â‚Š (âŒŠbâŒ‹â‚Š - 1), (f â†‘(k + 1) - f k) * âˆ‘ n âˆˆ Icc 0 k, c n =\n        âˆ‘ k âˆˆ Ico (âŒŠaâŒ‹â‚Š + 1) âŒŠbâŒ‹â‚Š, âˆ« t in k..â†‘(k + 1), deriv f t * âˆ‘ n âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c n := by\n    rw [â† Nat.Ico_succ_succ, Nat.succ_eq_add_one,  Nat.succ_eq_add_one, Nat.sub_add_cancel\n      (by omega), Eq.comm]\n    exact sum_congr rfl fun k hk â†¦ (integralmulsum c hf_diff hf_int _ _ _  (mod_cast k.le_succ)\n      le_rfl (mod_cast le_rfl) (ineqofmemIco' hk).1 <| mod_cast (ineqofmemIco' hk).2)\n  rw [this, sum_integral_adjacent_intervals_Ico hb, Nat.cast_add, Nat.cast_one,\n    â† integral_interval_sub_left (a := a) (c := âŒŠaâŒ‹â‚Š + 1),\n    â† integral_add_adjacent_intervals (b := âŒŠbâŒ‹â‚Š) (c := b),\n    integralmulsum c hf_diff hf_int _ _ _ aux3 aux1 le_rfl le_rfl aux4,\n    integralmulsum c hf_diff hf_int _ _ _ aux5 le_rfl aux2 aux6 le_rfl]\n  Â· ring\n  -- now deal with the integrability side goals\n  -- (Note we have 5 goals, but the 1st and 3rd are identical. TODO: find a non-hacky way of dealing\n  -- with both at once.)\n  Â· rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux6]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux5)\n  Â· rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux5]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_left aux6)\n  Â· rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux6]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux5)\n  Â· rw [intervalIntegrable_iff_integrableOn_Icc_of_le aux3]\n    exact (integrableOn_mul_sum_Icc c ha hf_int).mono_set (Set.Icc_subset_Icc_right aux4)\n  Â· exact fun k hk â†¦ (intervalIntegrable_iff_integrableOn_Icc_of_le (mod_cast k.le_succ)).mpr\n      <| (integrableOn_mul_sum_Icc c ha hf_int).mono_set\n        <| (Set.Icc_subset_Icc_iff (mod_cast k.le_succ)).mpr <| mod_cast (ineqofmemIco hk)\n\n"}
{"name":"sum_mul_eq_sub_sub_integral_mul'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nn m : Nat\nh : LE.le n m\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc â†‘n â†‘m) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc â†‘n â†‘m) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Ioc n m).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HSub.hSub (HMul.hMul (f â†‘m) ((Finset.Icc 0 m).sum fun k => c k)) (HMul.hMul (f â†‘n) ((Finset.Icc 0 n).sum fun k => c k))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc â†‘n â†‘m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_sub_integral_mul` where the endpoints are `Nat`. -/\ntheorem _root_.sum_mul_eq_sub_sub_integral_mul' {n m : â„•} (h : n â‰¤ m)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc (n : â„) m, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (n : â„) m)) :\n    âˆ‘ k âˆˆ Ioc n m, f k * c k =\n      f m * (âˆ‘ k âˆˆ Icc 0 m, c k) - f n * (âˆ‘ k âˆˆ Icc 0 n, c k) -\n        âˆ« t in Set.Ioc (n : â„) m, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  convert sum_mul_eq_sub_sub_integral_mul c n.cast_nonneg (Nat.cast_le.mpr h) hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"sum_mul_eq_sub_integral_mul","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nb : Real\nhb : LE.le 0 b\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc 0 b) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 0 b) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Icc 0 (Nat.floor b)).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Specialized version of `sum_mul_eq_sub_sub_integral_mul` for the case `a = 0`.-/\ntheorem sum_mul_eq_sub_integral_mul {b : â„} (hb : 0 â‰¤ b)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc 0 b, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc 0 b)) :\n    âˆ‘ k âˆˆ Icc 0 âŒŠbâŒ‹â‚Š, f k * c k =\n      f b * (âˆ‘ k âˆˆ Icc 0 âŒŠbâŒ‹â‚Š, c k) - âˆ« t in Set.Ioc 0 b, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  nth_rewrite 1 [Icc_eq_cons_Ioc (Nat.zero_le _)]\n  rw [sum_cons, â† Nat.floor_zero (Î± := â„), sum_mul_eq_sub_sub_integral_mul c le_rfl hb hf_diff\n    hf_int, Nat.floor_zero, Nat.cast_zero, Icc_self, sum_singleton]\n  ring\n\n"}
{"name":"sum_mul_eq_sub_integral_mul'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nm : Nat\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc 0 â†‘m) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 0 â†‘m) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Icc 0 m).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HMul.hMul (f â†‘m) ((Finset.Icc 0 m).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 â†‘m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_integral_mul` where the endpoint is a `Nat`. -/\ntheorem sum_mul_eq_sub_integral_mul' (m : â„•)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc (0 : â„) m, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (0 : â„) m)) :\n    âˆ‘ k âˆˆ Icc 0 m, f k * c k =\n      f m * (âˆ‘ k âˆˆ Icc 0 m, c k) -\n        âˆ« t in Set.Ioc (0 : â„) m, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  convert sum_mul_eq_sub_integral_mul c m.cast_nonneg hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"sum_mul_eq_sub_integral_mulâ‚€","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhc : Eq (c 0) 0\nb : Real\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc 1 b) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 1 b) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Icc 0 (Nat.floor b)).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HMul.hMul (f b) ((Finset.Icc 0 (Nat.floor b)).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 1 b)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- Specialized version of `sum_mul_eq_sub_integral_mul` when the first coefficient of the sequence\n`c` is equal to `0`. -/\ntheorem sum_mul_eq_sub_integral_mulâ‚€ (hc : c 0 = 0) (b : â„)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc 1 b, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc 1 b)) :\n    âˆ‘ k âˆˆ Icc 0 âŒŠbâŒ‹â‚Š, f k * c k =\n      f b * (âˆ‘ k âˆˆ Icc 0 âŒŠbâŒ‹â‚Š, c k) - âˆ« t in Set.Ioc 1 b, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  obtain hb | hb := le_or_gt 1 b\n  Â· have : 1 â‰¤ âŒŠbâŒ‹â‚Š := (Nat.one_le_floor_iff _).mpr hb\n    nth_rewrite 1 [Icc_eq_cons_Ioc (Nat.zero_le _), sum_cons, â† Nat.Icc_succ_left,\n      Icc_eq_cons_Ioc (by omega), sum_cons]\n    rw [Nat.succ_eq_add_one, zero_add, â† Nat.floor_one (Î± := â„),\n      sum_mul_eq_sub_sub_integral_mul c zero_le_one hb hf_diff hf_int, Nat.floor_one, Nat.cast_one,\n      Icc_eq_cons_Ioc zero_le_one, sum_cons, show 1 = 0 + 1 by rfl, Nat.Ioc_succ_singleton,\n      zero_add, sum_singleton, hc, mul_zero, zero_add]\n    ring\n  Â· simp_rw [Nat.floor_eq_zero.mpr hb, Icc_self, sum_singleton, Nat.cast_zero, hc, mul_zero,\n      Set.Ioc_eq_empty_of_le hb.le, Measure.restrict_empty, integral_zero_measure, sub_self]\n\n"}
{"name":"sum_mul_eq_sub_integral_mulâ‚€'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhc : Eq (c 0) 0\nm : Nat\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Icc 1 â†‘m) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.IntegrableOn (deriv f) (Set.Icc 1 â†‘m) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Finset.Icc 0 m).sum fun k => HMul.hMul (f â†‘k) (c k)) (HSub.hSub (HMul.hMul (f â†‘m) ((Finset.Icc 0 m).sum fun k => c k)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 1 â†‘m)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)))","decl":"/-- A version of `sum_mul_eq_sub_integral_mulâ‚€` where the endpoint is a `Nat`. -/\ntheorem sum_mul_eq_sub_integral_mulâ‚€' (hc : c 0 = 0) (m : â„•)\n    (hf_diff : âˆ€ t âˆˆ Set.Icc (1 : â„) m, DifferentiableAt â„ f t)\n    (hf_int : IntegrableOn (deriv f) (Set.Icc (1 : â„) m)) :\n    âˆ‘ k âˆˆ Icc 0 m, f k * c k =\n      f m * (âˆ‘ k âˆˆ Icc 0 m, c k) -\n        âˆ« t in Set.Ioc (1 : â„) m, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k := by\n  convert sum_mul_eq_sub_integral_mulâ‚€ c hc m hf_diff hf_int\n  all_goals rw [Nat.floor_natCast]\n\n"}
{"name":"locallyIntegrableOn_mul_sum_Icc","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\na : Real\nm : Nat\nha : LE.le 0 a\ng : Real â†’ ğ•œ\nhg : MeasureTheory.LocallyIntegrableOn g (Set.Ici a) MeasureTheory.MeasureSpace.volume\nâŠ¢ MeasureTheory.LocallyIntegrableOn (fun t => HMul.hMul (g t) ((Finset.Icc m (Nat.floor t)).sum fun k => c k)) (Set.Ici a) MeasureTheory.MeasureSpace.volume","decl":"theorem locallyIntegrableOn_mul_sum_Icc {m : â„•} (ha : 0 â‰¤ a) {g : â„ â†’ ğ•œ}\n    (hg : LocallyIntegrableOn g (Set.Ici a)) :\n    LocallyIntegrableOn (fun t â†¦ g t * âˆ‘ k âˆˆ Icc m âŒŠtâŒ‹â‚Š, c k) (Set.Ici a) := by\n  refine (locallyIntegrableOn_iff isLocallyClosed_Ici).mpr fun K hKâ‚ hKâ‚‚ â†¦ ?_\n  by_cases hKâ‚ƒ : K.Nonempty\n  Â· have h_inf : a â‰¤ sInf K := (hKâ‚ (hKâ‚‚.sInf_mem hKâ‚ƒ))\n    refine IntegrableOn.mono_set ?_ (Bornology.IsBounded.subset_Icc_sInf_sSup hKâ‚‚.isBounded)\n    refine integrableOn_mul_sum_Icc _ (ha.trans h_inf) ?_\n    refine hg.integrableOn_compact_subset ?_ isCompact_Icc\n    exact (Set.Icc_subset_Ici_iff (Real.sInf_le_sSup _ hKâ‚‚.bddBelow hKâ‚‚.bddAbove)).mpr h_inf\n  Â· rw [Set.not_nonempty_iff_eq_empty.mp hKâ‚ƒ]\n    exact integrableOn_empty\n\n"}
{"name":"tendsto_sum_mul_atTop_nhds_one_sub_integral","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Ici 0) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv f) (Set.Ici 0) MeasureTheory.MeasureSpace.volume\nl : ğ•œ\nh_lim : Filter.Tendsto (fun n => HMul.hMul (f â†‘n) ((Finset.Icc 0 n).sum fun k => c k)) Filter.atTop (nhds l)\ng : Real â†’ ğ•œ\nhg_dom : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)) g\nhg_int : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto (fun n => (Finset.Icc 0 n).sum fun k => HMul.hMul (f â†‘k) (c k)) Filter.atTop (nhds (HSub.hSub l (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k))))","decl":"theorem tendsto_sum_mul_atTop_nhds_one_sub_integral\n    (hf_diff : âˆ€ t âˆˆ Set.Ici 0, DifferentiableAt â„ f t)\n    (hf_int : LocallyIntegrableOn (deriv f) (Set.Ici 0)) {l : ğ•œ}\n    (h_lim : Tendsto (fun n : â„• â†¦ f n * âˆ‘ k âˆˆ Icc 0 n, c k) atTop (ğ“ l))\n    {g : â„ â†’ ğ•œ} (hg_dom : (fun t â†¦ deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k) =O[atTop] g)\n    (hg_int : IntegrableAtFilter g atTop) :\n    Tendsto (fun n : â„• â†¦ âˆ‘ k âˆˆ Icc 0 n, f k * c k) atTop\n      (ğ“ (l - âˆ« t in Set.Ioi 0, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)) := by\n  have h_lim' : Tendsto (fun n : â„• â†¦ âˆ« t in Set.Ioc (0 : â„) n, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)\n      atTop (ğ“ (âˆ« t in Set.Ioi 0, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)) := by\n    refine Tendsto.congr (fun _ â†¦ by rw [â† integral_of_le (Nat.cast_nonneg _)]) ?_\n    refine intervalIntegral_tendsto_integral_Ioi _ ?_ tendsto_natCast_atTop_atTop\n    exact integrableOn_Ici_iff_integrableOn_Ioi.mp\n      <| (locallyIntegrableOn_mul_sum_Icc c le_rfl hf_int).integrableOn_of_isBigO_atTop\n        hg_dom hg_int\n  refine (h_lim.sub h_lim').congr (fun _ â†¦ ?_)\n  rw [sum_mul_eq_sub_integral_mul' _ _ (fun t ht â†¦ hf_diff _ ht.1)]\n  exact hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc\n\n"}
{"name":"tendsto_sum_mul_atTop_nhds_one_sub_integralâ‚€","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhc : Eq (c 0) 0\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Ici 1) t â†’ DifferentiableAt Real f t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv f) (Set.Ici 1) MeasureTheory.MeasureSpace.volume\nl : ğ•œ\nh_lim : Filter.Tendsto (fun n => HMul.hMul (f â†‘n) ((Finset.Icc 0 n).sum fun k => c k)) Filter.atTop (nhds l)\ng : Real â†’ Real\nhg_dom : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k)) g\nhg_int : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto (fun n => (Finset.Icc 0 n).sum fun k => HMul.hMul (f â†‘k) (c k)) Filter.atTop (nhds (HSub.hSub l (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 1)) fun t => HMul.hMul (deriv f t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => c k))))","decl":"theorem tendsto_sum_mul_atTop_nhds_one_sub_integralâ‚€ (hc : c 0 = 0)\n    (hf_diff : âˆ€ t âˆˆ Set.Ici 1, DifferentiableAt â„ f t)\n    (hf_int : LocallyIntegrableOn (deriv f) (Set.Ici 1)) {l : ğ•œ}\n    (h_lim: Tendsto (fun n : â„• â†¦ f n * âˆ‘ k âˆˆ Icc 0 n, c k) atTop (ğ“ l))\n    {g : â„ â†’ â„} (hg_dom : (fun t â†¦ deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k) =O[atTop] g)\n    (hg_int : IntegrableAtFilter g atTop) :\n    Tendsto (fun n : â„• â†¦ âˆ‘ k âˆˆ Icc 0 n, f k * c k) atTop\n      (ğ“ (l - âˆ« t in Set.Ioi 1, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)) := by\n  have h : (fun n : â„• â†¦ âˆ« (x : â„) in (1 : â„)..n, deriv f x * âˆ‘ k âˆˆ Icc 0 âŒŠxâŒ‹â‚Š, c k) =á¶ [atTop]\n      (fun n : â„• â†¦ âˆ« (t : â„) in Set.Ioc 1 â†‘n, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k) := by\n    filter_upwards [eventually_ge_atTop 1] with _ h\n    rw [â† integral_of_le (Nat.one_le_cast.mpr h)]\n  have h_lim' : Tendsto (fun n : â„• â†¦ âˆ« t in Set.Ioc (1 : â„) n, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)\n      atTop (ğ“ (âˆ« t in Set.Ioi 1, deriv f t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, c k)) := by\n    refine Tendsto.congr' h (intervalIntegral_tendsto_integral_Ioi _ ?_ tendsto_natCast_atTop_atTop)\n    exact integrableOn_Ici_iff_integrableOn_Ioi.mp\n      <| (locallyIntegrableOn_mul_sum_Icc c zero_le_one hf_int).integrableOn_of_isBigO_atTop\n        hg_dom hg_int\n  refine (h_lim.sub h_lim').congr (fun _ â†¦ ?_)\n  rw [sum_mul_eq_sub_integral_mulâ‚€' _ hc _ (fun t ht â†¦ hf_diff _ ht.1)]\n  exact hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc\n\n"}
{"name":"summable_mul_of_bigO_atTop","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Ici 0) t â†’ DifferentiableAt Real (fun x => Norm.norm (f x)) t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv fun t => Norm.norm (f t)) (Set.Ici 0) MeasureTheory.MeasureSpace.volume\nh_bdd : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (f â†‘n)) ((Finset.Icc 0 n).sum fun k => Norm.norm (c k))) fun x => 1\ng : Real â†’ Real\nhgâ‚ : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv (fun t => Norm.norm (f t)) t) ((Finset.Icc 0 (Nat.floor t)).sum fun k => Norm.norm (c k))) g\nhgâ‚‚ : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\nâŠ¢ Summable fun n => HMul.hMul (f â†‘n) (c n)","decl":"theorem summable_mul_of_bigO_atTop\n    (hf_diff : âˆ€ t âˆˆ Set.Ici 0, DifferentiableAt â„ (fun x â†¦ â€–f xâ€–) t)\n    (hf_int : LocallyIntegrableOn (deriv (fun t â†¦ â€–f tâ€–)) (Set.Ici 0))\n    (h_bdd : (fun n : â„• â†¦ â€–f nâ€– * âˆ‘ k âˆˆ Icc 0 n, â€–c kâ€–) =O[atTop] fun _ â†¦ (1 : â„))\n    {g : â„ â†’ â„} (hgâ‚ : (fun t â†¦ deriv (fun t â†¦ â€–f tâ€–) t * âˆ‘ k âˆˆ Icc 0 âŒŠtâŒ‹â‚Š, â€–c kâ€–) =O[atTop] g)\n    (hgâ‚‚ : IntegrableAtFilter g atTop) :\n    Summable (fun n : â„• â†¦ f n * c n) := by\n  refine summable_mul_of_bigO_atTop_aux c 0 h_bdd (by rwa [Nat.cast_zero]) (fun n â†¦ ?_) hgâ‚ hgâ‚‚\n  exact_mod_cast sum_mul_eq_sub_integral_mul' _ _ (fun _ ht â†¦ hf_diff _ ht.1)\n    (hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc)\n\n"}
{"name":"summable_mul_of_bigO_atTop'","module":"Mathlib.NumberTheory.AbelSummation","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nc : Nat â†’ ğ•œ\nf : Real â†’ ğ•œ\nhf_diff : âˆ€ (t : Real), Membership.mem (Set.Ici 1) t â†’ DifferentiableAt Real (fun x => Norm.norm (f x)) t\nhf_int : MeasureTheory.LocallyIntegrableOn (deriv fun t => Norm.norm (f t)) (Set.Ici 1) MeasureTheory.MeasureSpace.volume\nh_bdd : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (f â†‘n)) ((Finset.Icc 1 n).sum fun k => Norm.norm (c k))) fun x => 1\ng : Real â†’ Real\nhgâ‚ : Asymptotics.IsBigO Filter.atTop (fun t => HMul.hMul (deriv (fun t => Norm.norm (f t)) t) ((Finset.Icc 1 (Nat.floor t)).sum fun k => Norm.norm (c k))) g\nhgâ‚‚ : MeasureTheory.IntegrableAtFilter g Filter.atTop MeasureTheory.MeasureSpace.volume\nâŠ¢ Summable fun n => HMul.hMul (f â†‘n) (c n)","decl":"/-- A version of `summable_mul_of_bigO_atTop` that can be useful to avoid difficulties near zero. -/\ntheorem summable_mul_of_bigO_atTop'\n    (hf_diff : âˆ€ t âˆˆ Set.Ici 1, DifferentiableAt â„ (fun x â†¦ â€–f xâ€–) t)\n    (hf_int : LocallyIntegrableOn (deriv (fun t â†¦ â€–f tâ€–)) (Set.Ici 1))\n    (h_bdd : (fun n : â„• â†¦ â€–f nâ€– * âˆ‘ k âˆˆ Icc 1 n, â€–c kâ€–) =O[atTop] fun _ â†¦ (1 : â„))\n    {g : â„ â†’ â„} (hgâ‚ : (fun t â†¦ deriv (fun t â†¦ â€–f tâ€–) t * âˆ‘ k âˆˆ Icc 1 âŒŠtâŒ‹â‚Š, â€–c kâ€–) =O[atTop] g)\n    (hgâ‚‚ : IntegrableAtFilter g atTop) :\n    Summable (fun n : â„• â†¦ f n * c n) := by\n  have h : âˆ€ n, âˆ‘ k âˆˆ Icc 1 n, â€–c kâ€– = âˆ‘ k âˆˆ Icc 0 n, â€–(fun n â†¦ if n = 0 then 0 else c n) kâ€– := by\n    intro n\n    rw [Icc_eq_cons_Ioc n.zero_le, sum_cons, â† Nat.Icc_succ_left, Nat.succ_eq_add_one, zero_add]\n    simp_rw [if_pos, norm_zero, zero_add]\n    exact Finset.sum_congr rfl fun _ h â†¦ by rw [if_neg (zero_lt_one.trans_le (mem_Icc.mp h).1).ne']\n  simp_rw [h] at h_bdd hgâ‚\n  refine Summable.congr_atTop (summable_mul_of_bigO_atTop_aux (fun n â†¦ if n = 0 then 0 else c n) 1\n    h_bdd (by rwa [Nat.cast_one]) (fun n â†¦ ?_) hgâ‚ hgâ‚‚) ?_\n  Â· exact_mod_cast sum_mul_eq_sub_integral_mulâ‚€' _ (by simp only [reduceIte, norm_zero]) n\n      (fun _ ht â†¦ hf_diff _ ht.1)\n      (hf_int.integrableOn_compact_subset Set.Icc_subset_Ici_self isCompact_Icc)\n  Â· filter_upwards [eventually_ne_atTop 0] with k hk\n    simp_rw [if_neg hk]\n\n"}
