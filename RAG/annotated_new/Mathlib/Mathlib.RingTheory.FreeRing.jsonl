{"name":"instNontrivialFreeRing","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\n⊢ Nontrivial (FreeRing α)","decl":"instance (α : Type u) : Nontrivial (FreeRing α) :=\n  inferInstanceAs <| Nontrivial (FreeAbelianGroup _)\n\n"}
{"name":"FreeRing.of_injective","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\n⊢ Function.Injective FreeRing.of","decl":"theorem of_injective : Function.Injective (of : α → FreeRing α) :=\n  FreeAbelianGroup.of_injective.comp FreeMonoid.of_injective\n\n"}
{"name":"FreeRing.of_ne_zero","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nx : α\n⊢ Ne (FreeRing.of x) 0","decl":"@[simp]\ntheorem of_ne_zero (x : α) : of x ≠ 0 := FreeAbelianGroup.of_ne_zero _\n\n"}
{"name":"FreeRing.zero_ne_of","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nx : α\n⊢ Ne 0 (FreeRing.of x)","decl":"@[simp]\ntheorem zero_ne_of (x : α) : 0 ≠ of x := FreeAbelianGroup.zero_ne_of _\n\n"}
{"name":"FreeRing.of_ne_one","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nx : α\n⊢ Ne (FreeRing.of x) 1","decl":"@[simp]\ntheorem of_ne_one (x : α) : of x ≠ 1 := FreeAbelianGroup.of_injective.ne <| FreeMonoid.of_ne_one _\n\n"}
{"name":"FreeRing.one_ne_of","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nx : α\n⊢ Ne 1 (FreeRing.of x)","decl":"@[simp]\ntheorem one_ne_of (x : α) : 1 ≠ of x := FreeAbelianGroup.of_injective.ne <| FreeMonoid.one_ne_of _\n\n"}
{"name":"FreeRing.induction_on","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nC : FreeRing α → Prop\nz : FreeRing α\nhn1 : C (-1)\nhb : ∀ (b : α), C (FreeRing.of b)\nha : ∀ (x y : FreeRing α), C x → C y → C (HAdd.hAdd x y)\nhm : ∀ (x y : FreeRing α), C x → C y → C (HMul.hMul x y)\n⊢ C z","decl":"@[elab_as_elim, induction_eliminator]\nprotected theorem induction_on {C : FreeRing α → Prop} (z : FreeRing α) (hn1 : C (-1))\n    (hb : ∀ b, C (of b)) (ha : ∀ x y, C x → C y → C (x + y)) (hm : ∀ x y, C x → C y → C (x * y)) :\n    C z :=\n  have hn : ∀ x, C x → C (-x) := fun x ih => neg_one_mul x ▸ hm _ _ hn1 ih\n  have h1 : C 1 := neg_neg (1 : FreeRing α) ▸ hn _ hn1\n  FreeAbelianGroup.induction_on z (neg_add_cancel (1 : FreeRing α) ▸ ha _ _ hn1 h1)\n    (fun m => List.recOn m h1 fun a m ih => by\n      -- Porting note: in mathlib, convert was not necessary, `exact hm _ _ (hb a) ih` worked fine\n      convert hm _ _ (hb a) ih\n      rw [of, ← FreeAbelianGroup.of_mul]\n      rfl)\n    (fun _ ih => hn _ ih) ha\n\n"}
{"name":"FreeRing.lift_of","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : Ring R\nf : α → R\nx : α\n⊢ Eq ((FreeRing.lift f) (FreeRing.of x)) (f x)","decl":"@[simp]\ntheorem lift_of (x : α) : lift f (of x) = f x :=\n  congr_fun (lift.left_inv f) x\n\n"}
{"name":"FreeRing.lift_comp_of","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : Ring R\nf : RingHom (FreeRing α) R\n⊢ Eq (FreeRing.lift (Function.comp (⇑f) FreeRing.of)) f","decl":"@[simp]\ntheorem lift_comp_of (f : FreeRing α →+* R) : lift (f ∘ of) = f :=\n  lift.right_inv f\n\n"}
{"name":"FreeRing.hom_ext_iff","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : Ring R\nf g : RingHom (FreeRing α) R\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f (FreeRing.of x)) (g (FreeRing.of x)))","decl":"@[ext]\ntheorem hom_ext ⦃f g : FreeRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  lift.symm.injective (funext h)\n\n"}
{"name":"FreeRing.hom_ext","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : Ring R\nf g : RingHom (FreeRing α) R\nh : ∀ (x : α), Eq (f (FreeRing.of x)) (g (FreeRing.of x))\n⊢ Eq f g","decl":"@[ext]\ntheorem hom_ext ⦃f g : FreeRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  lift.symm.injective (funext h)\n\n"}
{"name":"FreeRing.map_of","module":"Mathlib.RingTheory.FreeRing","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeRing.map f) (FreeRing.of x)) (FreeRing.of (f x))","decl":"@[simp]\ntheorem map_of (x : α) : map f (of x) = of (f x) :=\n  lift_of _ _\n\n"}
