{"name":"MultilinearMap.dfinsupp_ext","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : AddCommMonoid N\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : Module R N\ninst✝ : (i : ι) → DecidableEq (κ i)\nf g : MultilinearMap R (fun i => DFinsupp fun j => M i j) N\nh : ∀ (p : (i : ι) → κ i), Eq (f.compLinearMap fun i => DFinsupp.lsingle (p i)) (g.compLinearMap fun i => DFinsupp.lsingle (p i))\n⊢ Eq f g","decl":"/-- Two multilinear maps from finitely supported functions are equal if they agree on the\ngenerators.\n\nThis is a multilinear version of `DFinsupp.lhom_ext'`. -/\n@[ext]\ntheorem dfinsupp_ext [∀ i, DecidableEq (κ i)]\n    ⦃f g : MultilinearMap R (fun i ↦ Π₀ j : κ i, M i j) N⦄\n    (h : ∀ p : Π i, κ i,\n      f.compLinearMap (fun i => DFinsupp.lsingle (p i)) =\n      g.compLinearMap (fun i => DFinsupp.lsingle (p i))) : f = g := by\n  ext x\n  show f (fun i ↦ x i) = g (fun i ↦ x i)\n  classical\n  rw [funext (fun i ↦ Eq.symm (DFinsupp.sum_single (f := x i)))]\n  simp_rw [DFinsupp.sum, MultilinearMap.map_sum_finset]\n  congr! 1 with p\n  simp_rw [MultilinearMap.ext_iff] at h\n  exact h _ _\n\n"}
{"name":"MultilinearMap.dfinsupp_ext_iff","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : AddCommMonoid N\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : Module R N\ninst✝ : (i : ι) → DecidableEq (κ i)\nf g : MultilinearMap R (fun i => DFinsupp fun j => M i j) N\n⊢ Iff (Eq f g) (∀ (p : (i : ι) → κ i), Eq (f.compLinearMap fun i => DFinsupp.lsingle (p i)) (g.compLinearMap fun i => DFinsupp.lsingle (p i)))","decl":"/-- Two multilinear maps from finitely supported functions are equal if they agree on the\ngenerators.\n\nThis is a multilinear version of `DFinsupp.lhom_ext'`. -/\n@[ext]\ntheorem dfinsupp_ext [∀ i, DecidableEq (κ i)]\n    ⦃f g : MultilinearMap R (fun i ↦ Π₀ j : κ i, M i j) N⦄\n    (h : ∀ p : Π i, κ i,\n      f.compLinearMap (fun i => DFinsupp.lsingle (p i)) =\n      g.compLinearMap (fun i => DFinsupp.lsingle (p i))) : f = g := by\n  ext x\n  show f (fun i ↦ x i) = g (fun i ↦ x i)\n  classical\n  rw [funext (fun i ↦ Eq.symm (DFinsupp.sum_single (f := x i)))]\n  simp_rw [DFinsupp.sum, MultilinearMap.map_sum_finset]\n  congr! 1 with p\n  simp_rw [MultilinearMap.ext_iff] at h\n  exact h _ _\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_apply_toFun","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → DFinsupp fun j => M i j\np : (i : ι) → κ i\n⊢ Eq (((MultilinearMap.dfinsuppFamily f) x) p) ((f p) fun i => (x i) (p i))","decl":"/--\nGiven a family of indices `κ` and a multilinear map `f p` for each way `p` to select one index from\neach family, `dfinsuppFamily f` maps a family of finitely-supported functions (one for each domain\n`κ i`) into a finitely-supported function from each selection of indices (with domain `Π i, κ i`).\n\nStrictly this doesn't need multilinearity, only the fact that `f p m = 0` whenever `m i = 0` for\nsome `i`.\n\nThis is the `DFinsupp` version of `MultilinearMap.piFamily`.\n-/\n@[simps]\ndef dfinsuppFamily\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    MultilinearMap R (fun i => Π₀ j : κ i, M i j) (Π₀ t : Π i, κ i, N t) where\n  toFun x :=\n  { toFun := fun p => f p (fun i => x i (p i))\n    support' := (Trunc.finChoice fun i => (x i).support').map fun s => ⟨\n      Finset.univ.val.pi (fun i ↦ (s i).val) |>.map fun f i => f i (Finset.mem_univ _),\n      fun p => by\n        simp only [Multiset.mem_map, Multiset.mem_pi, Finset.mem_val, Finset.mem_univ,\n          forall_true_left]\n        simp_rw [or_iff_not_imp_right]\n        intro h\n        push_neg at h\n        refine ⟨fun i _ => p i, fun i => (s i).prop _ |>.resolve_right ?_, rfl⟩\n        exact mt ((f p).map_coord_zero (m := fun i => x i _) i) h⟩}\n  map_update_add' {dec} m i x y := DFinsupp.ext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, DFinsupp.add_apply, (f p).map_update_add]\n  map_update_smul' {dec} m i c x := DFinsupp.ext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, DFinsupp.smul_apply,\n      (f p).map_update_smul]\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_apply_support'","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → DFinsupp fun j => M i j\n⊢ Eq ((MultilinearMap.dfinsuppFamily f) x).support' (Trunc.map (fun s => ⟨Multiset.map (fun f i => f i ⋯) (Finset.univ.val.pi fun i => ↑(s i)), ⋯⟩) (Trunc.finChoice fun i => (x i).support'))","decl":"/--\nGiven a family of indices `κ` and a multilinear map `f p` for each way `p` to select one index from\neach family, `dfinsuppFamily f` maps a family of finitely-supported functions (one for each domain\n`κ i`) into a finitely-supported function from each selection of indices (with domain `Π i, κ i`).\n\nStrictly this doesn't need multilinearity, only the fact that `f p m = 0` whenever `m i = 0` for\nsome `i`.\n\nThis is the `DFinsupp` version of `MultilinearMap.piFamily`.\n-/\n@[simps]\ndef dfinsuppFamily\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    MultilinearMap R (fun i => Π₀ j : κ i, M i j) (Π₀ t : Π i, κ i, N t) where\n  toFun x :=\n  { toFun := fun p => f p (fun i => x i (p i))\n    support' := (Trunc.finChoice fun i => (x i).support').map fun s => ⟨\n      Finset.univ.val.pi (fun i ↦ (s i).val) |>.map fun f i => f i (Finset.mem_univ _),\n      fun p => by\n        simp only [Multiset.mem_map, Multiset.mem_pi, Finset.mem_val, Finset.mem_univ,\n          forall_true_left]\n        simp_rw [or_iff_not_imp_right]\n        intro h\n        push_neg at h\n        refine ⟨fun i _ => p i, fun i => (s i).prop _ |>.resolve_right ?_, rfl⟩\n        exact mt ((f p).map_coord_zero (m := fun i => x i _) i) h⟩}\n  map_update_add' {dec} m i x y := DFinsupp.ext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, DFinsupp.add_apply, (f p).map_update_add]\n  map_update_smul' {dec} m i c x := DFinsupp.ext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, DFinsupp.smul_apply,\n      (f p).map_update_smul]\n\n"}
{"name":"MultilinearMap.support_dfinsuppFamily_subset","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : Fintype ι\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁵ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝⁴ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝³ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝² : (i : ι) → DecidableEq (κ i)\ninst✝¹ : (i : ι) → (j : κ i) → (x : M i j) → Decidable (Ne x 0)\ninst✝ : (i : (i : ι) → κ i) → (x : N i) → Decidable (Ne x 0)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → DFinsupp fun j => M i j\n⊢ HasSubset.Subset ((MultilinearMap.dfinsuppFamily f) x).support (Fintype.piFinset fun i => (x i).support)","decl":"theorem support_dfinsuppFamily_subset\n    [∀ i, DecidableEq (κ i)]\n    [∀ i j, (x : M i j) → Decidable (x ≠ 0)] [∀ i, (x : N i) → Decidable (x ≠ 0)]\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p))\n    (x : ∀ i, Π₀ j : κ i, M i j) :\n    (dfinsuppFamily f x).support ⊆ Fintype.piFinset fun i => (x i).support := by\n  intro p hp\n  simp only [DFinsupp.mem_support_toFun, dfinsuppFamily_apply_toFun, ne_eq,\n    Fintype.mem_piFinset] at hp ⊢\n  intro i\n  exact mt ((f p).map_coord_zero (m := fun i => x i _) i) hp\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_single","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝ : (i : ι) → DecidableEq (κ i)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\np : (i : ι) → κ i\nm : (i : ι) → M i (p i)\n⊢ Eq ((MultilinearMap.dfinsuppFamily f) fun i => DFinsupp.single (p i) (m i)) (DFinsupp.single p ((f p) m))","decl":"/-- When applied to a family of finitely-supported functions each supported on a single element,\n`dfinsuppFamily` is itself supported on a single element, with value equal to the map `f` applied\nat that point. -/\n@[simp]\ntheorem dfinsuppFamily_single [∀ i, DecidableEq (κ i)]\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p))\n    (p : ∀ i, κ i) (m : ∀ i, M i (p i)) :\n    dfinsuppFamily f (fun i => .single (p i) (m i)) = DFinsupp.single p (f p m) := by\n  ext q\n  obtain rfl | hpq := eq_or_ne p q\n  · simp\n  · rw [DFinsupp.single_eq_of_ne hpq]\n    rw [Function.ne_iff] at hpq\n    obtain ⟨i, hpqi⟩ := hpq\n    apply (f q).map_coord_zero i\n    simp_rw [DFinsupp.single_eq_of_ne hpqi]\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_single_left_apply","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝ : (i : ι) → DecidableEq (κ i)\np : (i : ι) → κ i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → DFinsupp fun j => M i j\n⊢ Eq ((MultilinearMap.dfinsuppFamily (Pi.single p f)) x) (DFinsupp.single p (f fun i => (x i) (p i)))","decl":"/-- When only one member of the family of multilinear maps is nonzero, the result consists only of\nthe component from that member. -/\n@[simp]\ntheorem dfinsuppFamily_single_left_apply [∀ i, DecidableEq (κ i)]\n    (p : Π i, κ i) (f : MultilinearMap R (fun i ↦ M i (p i)) (N p)) (x : Π i, Π₀ j, M i j) :\n    dfinsuppFamily (Pi.single p f) x = DFinsupp.single p (f fun i => x _ (p i)) := by\n  ext p'\n  obtain rfl | hp := eq_or_ne p p'\n  · simp\n  · simp [hp]\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_single_left","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝ : (i : ι) → DecidableEq (κ i)\np : (i : ι) → κ i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.dfinsuppFamily (Pi.single p f)) ((DFinsupp.lsingle p).compMultilinearMap (f.compLinearMap fun i => DFinsupp.lapply (p i)))","decl":"theorem dfinsuppFamily_single_left [∀ i, DecidableEq (κ i)]\n    (p : Π i, κ i) (f : MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    dfinsuppFamily (Pi.single p f) =\n      (DFinsupp.lsingle p).compMultilinearMap (f.compLinearMap fun i => DFinsupp.lapply (p i)) :=\n  ext <| dfinsuppFamily_single_left_apply _ _\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_compLinearMap_lsingle","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Fintype ι\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝³ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝² : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝¹ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝ : (i : ι) → DecidableEq (κ i)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\np : (i : ι) → κ i\n⊢ Eq ((MultilinearMap.dfinsuppFamily f).compLinearMap fun i => DFinsupp.lsingle (p i)) ((DFinsupp.lsingle p).compMultilinearMap (f p))","decl":"@[simp]\ntheorem dfinsuppFamily_compLinearMap_lsingle [∀ i, DecidableEq (κ i)]\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) (p : ∀ i, κ i) :\n    (dfinsuppFamily f).compLinearMap (fun i => DFinsupp.lsingle (p i))\n      = (DFinsupp.lsingle p).compMultilinearMap (f p) :=\n  MultilinearMap.ext <| dfinsuppFamily_single f p\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_zero","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\n⊢ Eq (MultilinearMap.dfinsuppFamily 0) 0","decl":"@[simp]\ntheorem dfinsuppFamily_zero :\n    dfinsuppFamily (0 : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) = 0 := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_add","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf g : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.dfinsuppFamily (HAdd.hAdd f g)) (HAdd.hAdd (MultilinearMap.dfinsuppFamily f) (MultilinearMap.dfinsuppFamily g))","decl":"@[simp]\ntheorem dfinsuppFamily_add (f g : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    dfinsuppFamily (f + g) = dfinsuppFamily f + dfinsuppFamily g := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.dfinsuppFamily_smul","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nS : Type uS\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : Fintype ι\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁵ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝⁴ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝³ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝² : Monoid S\ninst✝¹ : (p : (i : ι) → κ i) → DistribMulAction S (N p)\ninst✝ : ∀ (p : (i : ι) → κ i), SMulCommClass R S (N p)\ns : S\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.dfinsuppFamily (HSMul.hSMul s f)) (HSMul.hSMul s (MultilinearMap.dfinsuppFamily f))","decl":"@[simp]\ntheorem dfinsuppFamily_smul\n    [Monoid S] [∀ p, DistribMulAction S (N p)] [∀ p, SMulCommClass R S (N p)]\n    (s : S) (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    dfinsuppFamily (s • f) = s • dfinsuppFamily f := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.dfinsuppFamilyₗ_apply","module":"Mathlib.LinearAlgebra.Multilinear.DFinsupp","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.dfinsuppFamilyₗ f) (MultilinearMap.dfinsuppFamily f)","decl":"/-- `MultilinearMap.dfinsuppFamily` as a linear map. -/\n@[simps]\ndef dfinsuppFamilyₗ :\n    (Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p))\n      →ₗ[R] MultilinearMap R (fun i => Π₀ j : κ i, M i j) (Π₀ t : Π i, κ i, N t) where\n  toFun := dfinsuppFamily\n  map_add' := dfinsuppFamily_add\n  map_smul' := dfinsuppFamily_smul\n\n"}
