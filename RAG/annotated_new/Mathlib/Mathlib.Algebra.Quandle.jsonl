{"name":"Shelf.self_distrib","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u\nself : Shelf α\nx y z : α\n⊢ Eq (Shelf.act x (Shelf.act y z)) (Shelf.act (Shelf.act x y) (Shelf.act x z))","decl":"/-- A *Shelf* is a structure with a self-distributive binary operation.\nThe binary operation is regarded as a left action of the type on itself.\n-/\nclass Shelf (α : Type u) where\n  /-- The action of the `Shelf` over `α`-/\n  act : α → α → α\n  /-- A verification that `act` is self-distributive -/\n  self_distrib : ∀ {x y z : α}, act x (act y z) = act (act x y) (act x z)\n\n"}
{"name":"UnitalShelf.one_act","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u\nself : UnitalShelf α\na : α\n⊢ Eq (Shelf.act 1 a) a","decl":"/--\nA *unital shelf* is a shelf equipped with an element `1` such that, for all elements `x`,\nwe have both `x ◃ 1` and `1 ◃ x` equal `x`.\n-/\nclass UnitalShelf (α : Type u) extends Shelf α, One α where\n  one_act : ∀ a : α, act 1 a = a\n  act_one : ∀ a : α, act a 1 = a\n\n"}
{"name":"UnitalShelf.act_one","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u\nself : UnitalShelf α\na : α\n⊢ Eq (Shelf.act a 1) a","decl":"/--\nA *unital shelf* is a shelf equipped with an element `1` such that, for all elements `x`,\nwe have both `x ◃ 1` and `1 ◃ x` equal `x`.\n-/\nclass UnitalShelf (α : Type u) extends Shelf α, One α where\n  one_act : ∀ a : α, act 1 a = a\n  act_one : ∀ a : α, act a 1 = a\n\n"}
{"name":"ShelfHom.mk.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\ntoFun✝ : S₁ → S₂\nmap_act'✝ : ∀ {x y : S₁}, Eq (toFun✝ (Shelf.act x y)) (Shelf.act (toFun✝ x) (toFun✝ y))\ntoFun : S₁ → S₂\nmap_act' : ∀ {x y : S₁}, Eq (toFun (Shelf.act x y)) (Shelf.act (toFun x) (toFun y))\nx✝ : Eq { toFun := toFun✝, map_act' := map_act'✝ } { toFun := toFun, map_act' := map_act' }\n⊢ Eq toFun✝ toFun","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"ShelfHom.mk.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\ntoFun✝ : S₁ → S₂\nmap_act'✝ : ∀ {x y : S₁}, Eq (toFun✝ (Shelf.act x y)) (Shelf.act (toFun✝ x) (toFun✝ y))\ntoFun : S₁ → S₂\nmap_act' : ∀ {x y : S₁}, Eq (toFun (Shelf.act x y)) (Shelf.act (toFun x) (toFun y))\n⊢ Eq (Eq { toFun := toFun✝, map_act' := map_act'✝ } { toFun := toFun, map_act' := map_act' }) (Eq toFun✝ toFun)","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"ShelfHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝³ : Shelf S₁\ninst✝² : Shelf S₂\ninst✝¹ : SizeOf S₁\ninst✝ : SizeOf S₂\ntoFun : S₁ → S₂\nmap_act' : ∀ {x y : S₁}, Eq (toFun (Shelf.act x y)) (Shelf.act (toFun x) (toFun y))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_act' := map_act' }) 1","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"ShelfHom.ext","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\nx y : ShelfHom S₁ S₂\ntoFun : Eq x.toFun y.toFun\n⊢ Eq x y","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"ShelfHom.map_act'","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\nself : ShelfHom S₁ S₂\nx y : S₁\n⊢ Eq (self.toFun (Shelf.act x y)) (Shelf.act (self.toFun x) (self.toFun y))","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"ShelfHom.ext_iff","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\nx y : ShelfHom S₁ S₂\n⊢ Iff (Eq x y) (Eq x.toFun y.toFun)","decl":"/-- The type of homomorphisms between shelves.\nThis is also the notion of rack and quandle homomorphisms.\n-/\n@[ext]\nstructure ShelfHom (S₁ : Type*) (S₂ : Type*) [Shelf S₁] [Shelf S₂] where\n  /-- The function under the Shelf Homomorphism -/\n  toFun : S₁ → S₂\n  /-- The homomorphism property of a Shelf Homomorphism -/\n  map_act' : ∀ {x y : S₁}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)\n\n"}
{"name":"Rack.left_inv","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u\nself : Rack α\nx : α\n⊢ Function.LeftInverse (Rack.invAct x) (Shelf.act x)","decl":"/-- A *rack* is an automorphic set (a set with an action on itself by\nbijections) that is self-distributive.  It is a shelf such that each\nelement's action is invertible.\n\nThe notations `x ◃ y` and `x ◃⁻¹ y` denote the action and the\ninverse action, respectively, and they are right associative.\n-/\nclass Rack (α : Type u) extends Shelf α where\n  /-- The inverse actions of the elements -/\n  invAct : α → α → α\n  /-- Proof of left inverse -/\n  left_inv : ∀ x, Function.LeftInverse (invAct x) (act x)\n  /-- Proof of right inverse -/\n  right_inv : ∀ x, Function.RightInverse (invAct x) (act x)\n\n"}
{"name":"Rack.right_inv","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u\nself : Rack α\nx : α\n⊢ Function.RightInverse (Rack.invAct x) (Shelf.act x)","decl":"/-- A *rack* is an automorphic set (a set with an action on itself by\nbijections) that is self-distributive.  It is a shelf such that each\nelement's action is invertible.\n\nThe notations `x ◃ y` and `x ◃⁻¹ y` denote the action and the\ninverse action, respectively, and they are right associative.\n-/\nclass Rack (α : Type u) extends Shelf α where\n  /-- The inverse actions of the elements -/\n  invAct : α → α → α\n  /-- Proof of left inverse -/\n  left_inv : ∀ x, Function.LeftInverse (invAct x) (act x)\n  /-- Proof of right inverse -/\n  right_inv : ∀ x, Function.RightInverse (invAct x) (act x)\n\n"}
{"name":"UnitalShelf.act_act_self_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"S : Type u_1\ninst✝ : UnitalShelf S\nx y : S\n⊢ Eq (Shelf.act (Shelf.act x y) x) (Shelf.act x y)","decl":"/--\nA monoid is *graphic* if, for all `x` and `y`, the *graphic identity*\n`(x * y) * x = x * y` holds.  For a unital shelf, this graphic\nidentity holds.\n-/\nlemma act_act_self_eq (x y : S) : (x ◃ y) ◃ x = x ◃ y := by\n  have h : (x ◃ y) ◃ x = (x ◃ y) ◃ (x ◃ 1) := by rw [act_one]\n  rw [h, ← Shelf.self_distrib, act_one]\n\n"}
{"name":"UnitalShelf.act_idem","module":"Mathlib.Algebra.Quandle","initialProofState":"S : Type u_1\ninst✝ : UnitalShelf S\nx : S\n⊢ Eq (Shelf.act x x) x","decl":"lemma act_idem (x : S) : (x ◃ x) = x := by rw [← act_one x, ← Shelf.self_distrib, act_one]\n\n"}
{"name":"UnitalShelf.act_self_act_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"S : Type u_1\ninst✝ : UnitalShelf S\nx y : S\n⊢ Eq (Shelf.act x (Shelf.act x y)) (Shelf.act x y)","decl":"lemma act_self_act_eq (x y : S) : x ◃ (x ◃ y) = x ◃ y := by\n  have h : x ◃ (x ◃ y) = (x ◃ 1) ◃ (x ◃ y) := by rw [act_one]\n  rw [h, ← Shelf.self_distrib, one_act]\n\n"}
{"name":"UnitalShelf.assoc","module":"Mathlib.Algebra.Quandle","initialProofState":"S : Type u_1\ninst✝ : UnitalShelf S\nx y z : S\n⊢ Eq (Shelf.act (Shelf.act x y) z) (Shelf.act x (Shelf.act y z))","decl":"/--\nThe associativity of a unital shelf comes for free.\n-/\nlemma assoc (x y z : S) : (x ◃ y) ◃ z = x ◃ y ◃ z := by\n  rw [self_distrib, self_distrib, act_act_self_eq, act_self_act_eq]\n\n"}
{"name":"Rack.act'_apply","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq ((Rack.act' x) y) (Shelf.act x y)","decl":"@[simp]\ntheorem act'_apply (x y : R) : act' x y = x ◃ y :=\n  rfl\n\n"}
{"name":"Rack.act'_symm_apply","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq ((Rack.act' x).symm y) (Rack.invAct x y)","decl":"@[simp]\ntheorem act'_symm_apply (x y : R) : (act' x).symm y = x ◃⁻¹ y :=\n  rfl\n\n"}
{"name":"Rack.invAct_apply","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq ((Inv.inv (Rack.act' x)) y) (Rack.invAct x y)","decl":"@[simp]\ntheorem invAct_apply (x y : R) : (act' x)⁻¹ y = x ◃⁻¹ y :=\n  rfl\n\n"}
{"name":"Rack.invAct_act_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Rack.invAct x (Shelf.act x y)) y","decl":"@[simp]\ntheorem invAct_act_eq (x y : R) : x ◃⁻¹ x ◃ y = y :=\n  left_inv x y\n\n"}
{"name":"Rack.act_invAct_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Shelf.act x (Rack.invAct x y)) y","decl":"@[simp]\ntheorem act_invAct_eq (x y : R) : x ◃ x ◃⁻¹ y = y :=\n  right_inv x y\n\n"}
{"name":"Rack.left_cancel","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y y' : R\n⊢ Iff (Eq (Shelf.act x y) (Shelf.act x y')) (Eq y y')","decl":"theorem left_cancel (x : R) {y y' : R} : x ◃ y = x ◃ y' ↔ y = y' := by\n  constructor\n  · apply (act' x).injective\n  rintro rfl\n  rfl\n\n"}
{"name":"Rack.left_cancel_inv","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y y' : R\n⊢ Iff (Eq (Rack.invAct x y) (Rack.invAct x y')) (Eq y y')","decl":"theorem left_cancel_inv (x : R) {y y' : R} : x ◃⁻¹ y = x ◃⁻¹ y' ↔ y = y' := by\n  constructor\n  · apply (act' x).symm.injective\n  rintro rfl\n  rfl\n\n"}
{"name":"Rack.self_distrib_inv","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y z : R\n⊢ Eq (Rack.invAct x (Rack.invAct y z)) (Rack.invAct (Rack.invAct x y) (Rack.invAct x z))","decl":"theorem self_distrib_inv {x y z : R} : x ◃⁻¹ y ◃⁻¹ z = (x ◃⁻¹ y) ◃⁻¹ x ◃⁻¹ z := by\n  rw [← left_cancel (x ◃⁻¹ y), right_inv, ← left_cancel x, right_inv, self_distrib]\n  repeat' rw [right_inv]\n\n"}
{"name":"Rack.ad_conj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_2\ninst✝ : Rack R\nx y : R\n⊢ Eq (Rack.act' (Shelf.act x y)) (HMul.hMul (HMul.hMul (Rack.act' x) (Rack.act' y)) (Inv.inv (Rack.act' x)))","decl":"/-- The *adjoint action* of a rack on itself is `op'`, and the adjoint\naction of `x ◃ y` is the conjugate of the action of `y` by the action\nof `x`. It is another way to understand the self-distributivity axiom.\n\nThis is used in the natural rack homomorphism `toConj` from `R` to\n`Conj (R ≃ R)` defined by `op'`.\n-/\ntheorem ad_conj {R : Type*} [Rack R] (x y : R) : act' (x ◃ y) = act' x * act' y * (act' x)⁻¹ := by\n  rw [eq_mul_inv_iff_mul_eq]; ext z\n  apply self_distrib.symm\n\n"}
{"name":"Rack.op_act_op_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Shelf.act (MulOpposite.op x) (MulOpposite.op y)) (MulOpposite.op (Rack.invAct x y))","decl":"@[simp]\ntheorem op_act_op_eq {x y : R} : op x ◃ op y = op (x ◃⁻¹ y) :=\n  rfl\n\n"}
{"name":"Rack.op_invAct_op_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Rack.invAct (MulOpposite.op x) (MulOpposite.op y)) (MulOpposite.op (Shelf.act x y))","decl":"@[simp]\ntheorem op_invAct_op_eq {x y : R} : op x ◃⁻¹ op y = op (x ◃ y) :=\n  rfl\n\n"}
{"name":"Rack.self_act_act_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Shelf.act (Shelf.act x x) y) (Shelf.act x y)","decl":"@[simp]\ntheorem self_act_act_eq {x y : R} : (x ◃ x) ◃ y = x ◃ y := by rw [← right_inv x y, ← self_distrib]\n\n"}
{"name":"Rack.self_invAct_invAct_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Rack.invAct (Rack.invAct x x) y) (Rack.invAct x y)","decl":"@[simp]\ntheorem self_invAct_invAct_eq {x y : R} : (x ◃⁻¹ x) ◃⁻¹ y = x ◃⁻¹ y := by\n  have h := @self_act_act_eq _ _ (op x) (op y)\n  simpa using h\n\n"}
{"name":"Rack.self_act_invAct_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Rack.invAct (Shelf.act x x) y) (Rack.invAct x y)","decl":"@[simp]\ntheorem self_act_invAct_eq {x y : R} : (x ◃ x) ◃⁻¹ y = x ◃⁻¹ y := by\n  rw [← left_cancel (x ◃ x)]\n  rw [right_inv]\n  rw [self_act_act_eq]\n  rw [right_inv]\n\n"}
{"name":"Rack.self_invAct_act_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq (Shelf.act (Rack.invAct x x) y) (Shelf.act x y)","decl":"@[simp]\ntheorem self_invAct_act_eq {x y : R} : (x ◃⁻¹ x) ◃ y = x ◃ y := by\n  have h := @self_act_invAct_eq _ _ (op x) (op y)\n  simpa using h\n\n"}
{"name":"Rack.self_act_eq_iff_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Iff (Eq (Shelf.act x x) (Shelf.act y y)) (Eq x y)","decl":"theorem self_act_eq_iff_eq {x y : R} : x ◃ x = y ◃ y ↔ x = y := by\n  constructor; swap\n  · rintro rfl; rfl\n  intro h\n  trans (x ◃ x) ◃⁻¹ x ◃ x\n  · rw [← left_cancel (x ◃ x), right_inv, self_act_act_eq]\n  · rw [h, ← left_cancel (y ◃ y), right_inv, self_act_act_eq]\n\n"}
{"name":"Rack.self_invAct_eq_iff_eq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Iff (Eq (Rack.invAct x x) (Rack.invAct y y)) (Eq x y)","decl":"theorem self_invAct_eq_iff_eq {x y : R} : x ◃⁻¹ x = y ◃⁻¹ y ↔ x = y := by\n  have h := @self_act_eq_iff_eq _ _ (op x) (op y)\n  simpa using h\n\n"}
{"name":"Rack.involutory_invAct_eq_act","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_2\ninst✝ : Rack R\nh : Rack.IsInvolutory R\nx y : R\n⊢ Eq (Rack.invAct x y) (Shelf.act x y)","decl":"theorem involutory_invAct_eq_act {R : Type*} [Rack R] (h : IsInvolutory R) (x y : R) :\n    x ◃⁻¹ y = x ◃ y := by\n  rw [← left_cancel x, right_inv, h x]\n\n"}
{"name":"Rack.assoc_iff_id","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_2\ninst✝ : Rack R\nx y z : R\n⊢ Iff (Eq (Shelf.act x (Shelf.act y z)) (Shelf.act (Shelf.act x y) z)) (Eq (Shelf.act x z) z)","decl":"/-- Associative racks are uninteresting.\n-/\ntheorem assoc_iff_id {R : Type*} [Rack R] {x y z : R} : x ◃ y ◃ z = (x ◃ y) ◃ z ↔ x ◃ z = z := by\n  rw [self_distrib]\n  rw [left_cancel]\n\n"}
{"name":"ShelfHom.toFun_eq_coe","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\nf : ShelfHom S₁ S₂\n⊢ Eq f.toFun ⇑f","decl":"@[simp] theorem toFun_eq_coe (f : S₁ →◃ S₂) : f.toFun = f := rfl\n\n"}
{"name":"ShelfHom.map_act","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\ninst✝¹ : Shelf S₁\ninst✝ : Shelf S₂\nf : ShelfHom S₁ S₂\nx y : S₁\n⊢ Eq (f (Shelf.act x y)) (Shelf.act (f x) (f y))","decl":"@[simp]\ntheorem map_act (f : S₁ →◃ S₂) {x y : S₁} : f (x ◃ y) = f x ◃ f y :=\n  map_act' f\n\n"}
{"name":"ShelfHom.comp_apply","module":"Mathlib.Algebra.Quandle","initialProofState":"S₁ : Type u_1\nS₂ : Type u_2\nS₃ : Type u_3\ninst✝² : Shelf S₁\ninst✝¹ : Shelf S₂\ninst✝ : Shelf S₃\ng : ShelfHom S₂ S₃\nf : ShelfHom S₁ S₂\nx : S₁\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : S₂ →◃ S₃) (f : S₁ →◃ S₂) (x : S₁) : (g.comp f) x = g (f x) :=\n  rfl\n\n"}
{"name":"Quandle.fix","module":"Mathlib.Algebra.Quandle","initialProofState":"α : Type u_1\nself : Quandle α\nx : α\n⊢ Eq (Shelf.act x x) x","decl":"/-- A quandle is a rack such that each automorphism fixes its corresponding element.\n-/\nclass Quandle (α : Type*) extends Rack α where\n  /-- The fixing property of a Quandle -/\n  fix : ∀ {x : α}, act x x = x\n\n"}
{"name":"Quandle.fix_inv","module":"Mathlib.Algebra.Quandle","initialProofState":"Q : Type u_1\ninst✝ : Quandle Q\nx : Q\n⊢ Eq (Rack.invAct x x) x","decl":"@[simp]\ntheorem fix_inv {x : Q} : x ◃⁻¹ x = x := by\n  rw [← left_cancel x]\n  simp\n\n"}
{"name":"Quandle.conj_act_eq_conj","module":"Mathlib.Algebra.Quandle","initialProofState":"G : Type u_2\ninst✝ : Group G\nx y : Quandle.Conj G\n⊢ Eq (Shelf.act x y) (HMul.hMul (HMul.hMul x y) (Inv.inv x))","decl":"@[simp]\ntheorem conj_act_eq_conj {G : Type*} [Group G] (x y : Conj G) :\n    x ◃ y = ((x : G) * (y : G) * (x : G)⁻¹ : G) :=\n  rfl\n\n"}
{"name":"Quandle.conj_swap","module":"Mathlib.Algebra.Quandle","initialProofState":"G : Type u_2\ninst✝ : Group G\nx y : Quandle.Conj G\n⊢ Iff (Eq (Shelf.act x y) y) (Eq (Shelf.act y x) x)","decl":"theorem conj_swap {G : Type*} [Group G] (x y : Conj G) : x ◃ y = y ↔ y ◃ x = x := by\n  dsimp [Conj] at *; constructor\n  repeat' intro h; conv_rhs => rw [eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h)]; simp\n\n"}
{"name":"Quandle.dihedralAct.inv","module":"Mathlib.Algebra.Quandle","initialProofState":"n : Nat\na : ZMod n\n⊢ Function.Involutive (Quandle.dihedralAct n a)","decl":"theorem dihedralAct.inv (n : ℕ) (a : ZMod n) : Function.Involutive (dihedralAct n a) := by\n  intro b\n  dsimp only [dihedralAct]\n  simp\n\n"}
{"name":"Rack.PreEnvelGroup.inv.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : SizeOf R\na : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf a.inv) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.unit.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : SizeOf R\n⊢ Eq (SizeOf.sizeOf Rack.PreEnvelGroup.unit) 1","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.incl.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\nx✝¹ x : R\nx✝ : Eq (Rack.PreEnvelGroup.incl x✝¹) (Rack.PreEnvelGroup.incl x)\n⊢ Eq x✝¹ x","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.mul.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\na✝ b✝ a b : Rack.PreEnvelGroup R\n⊢ Eq (Eq (a✝.mul b✝) (a.mul b)) (And (Eq a✝ a) (Eq b✝ b))","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.incl.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : SizeOf R\nx : R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroup.incl x)) (HAdd.hAdd 1 (SizeOf.sizeOf x))","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.mul.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\na✝ b✝ a b : Rack.PreEnvelGroup R\nx✝ : Eq (a✝.mul b✝) (a.mul b)\n⊢ And (Eq a✝ a) (Eq b✝ b)","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.incl.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\nx✝ x : R\n⊢ Eq (Eq (Rack.PreEnvelGroup.incl x✝) (Rack.PreEnvelGroup.incl x)) (Eq x✝ x)","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.inv.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\na✝ a : Rack.PreEnvelGroup R\n⊢ Eq (Eq a✝.inv a.inv) (Eq a✝ a)","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.mul.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : SizeOf R\na b : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf (a.mul b)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b))","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroup.inv.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\na✝ a : Rack.PreEnvelGroup R\nx✝ : Eq a✝.inv a.inv\n⊢ Eq a✝ a","decl":"/-- Free generators of the enveloping group.\n-/\ninductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R\n\n"}
{"name":"Rack.PreEnvelGroupRel'.one_mul.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroupRel'.one_mul a)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_inv.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na a' : Rack.PreEnvelGroup R\nha✝ ha : Rack.PreEnvelGroupRel' R a a'\n⊢ Eq (Eq ha✝.congr_inv ha.congr_inv) (Eq ha✝ ha)","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.assoc.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na b c : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroupRel'.assoc a b c)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_inv.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na a' : Rack.PreEnvelGroup R\nha✝ ha : Rack.PreEnvelGroupRel' R a a'\nx✝ : Eq ha✝.congr_inv ha.congr_inv\n⊢ Eq ha✝ ha","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.inv_mul_cancel.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroupRel'.inv_mul_cancel a)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.refl.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf Rack.PreEnvelGroupRel'.refl) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.trans.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b✝ c : Rack.PreEnvelGroup R\nhab✝ : Rack.PreEnvelGroupRel' R a b✝\nhbc✝ : Rack.PreEnvelGroupRel' R b✝ c\nb : Rack.PreEnvelGroup R\nhab : Rack.PreEnvelGroupRel' R a b\nhbc : Rack.PreEnvelGroupRel' R b c\nx✝ : Eq (hab✝.trans hbc✝) (hab.trans hbc)\n⊢ And (Eq b✝ b) (And (HEq hab✝ hab) (HEq hbc✝ hbc))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_mul.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b a' b' : Rack.PreEnvelGroup R\nha✝ : Rack.PreEnvelGroupRel' R a a'\nhb✝ : Rack.PreEnvelGroupRel' R b b'\nha : Rack.PreEnvelGroupRel' R a a'\nhb : Rack.PreEnvelGroupRel' R b b'\n⊢ Eq (Eq (ha✝.congr_mul hb✝) (ha.congr_mul hb)) (And (Eq ha✝ ha) (Eq hb✝ hb))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.mul_one.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na : Rack.PreEnvelGroup R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroupRel'.mul_one a)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.trans.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b✝ c : Rack.PreEnvelGroup R\nhab✝ : Rack.PreEnvelGroupRel' R a b✝\nhbc✝ : Rack.PreEnvelGroupRel' R b✝ c\nb : Rack.PreEnvelGroup R\nhab : Rack.PreEnvelGroupRel' R a b\nhbc : Rack.PreEnvelGroupRel' R b c\n⊢ Eq (Eq (hab✝.trans hbc✝) (hab.trans hbc)) (And (Eq b✝ b) (And (HEq hab✝ hab) (HEq hbc✝ hbc)))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.symm.injEq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b : Rack.PreEnvelGroup R\nhab✝ hab : Rack.PreEnvelGroupRel' R a b\n⊢ Eq (Eq hab✝.symm hab.symm) (Eq hab✝ hab)","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_mul.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b a' b' : Rack.PreEnvelGroup R\nha✝ : Rack.PreEnvelGroupRel' R a a'\nhb✝ : Rack.PreEnvelGroupRel' R b b'\nha : Rack.PreEnvelGroupRel' R a a'\nhb : Rack.PreEnvelGroupRel' R b b'\nx✝ : Eq (ha✝.congr_mul hb✝) (ha.congr_mul hb)\n⊢ And (Eq ha✝ ha) (Eq hb✝ hb)","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.symm.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na b : Rack.PreEnvelGroup R\nhab : Rack.PreEnvelGroupRel' R a b\n⊢ Eq (SizeOf.sizeOf hab.symm) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf hab))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_inv.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na a' : Rack.PreEnvelGroup R\nha : Rack.PreEnvelGroupRel' R a a'\n⊢ Eq (SizeOf.sizeOf ha.congr_inv) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf a')) (SizeOf.sizeOf ha))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.act_incl.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\nx y : R\n⊢ Eq (SizeOf.sizeOf (Rack.PreEnvelGroupRel'.act_incl x y)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf y))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.trans.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na b c : Rack.PreEnvelGroup R\nhab : Rack.PreEnvelGroupRel' R a b\nhbc : Rack.PreEnvelGroupRel' R b c\n⊢ Eq (SizeOf.sizeOf (hab.trans hbc)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf hab)) (SizeOf.sizeOf hbc))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.congr_mul.sizeOf_spec","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝¹ : Rack R\ninst✝ : SizeOf R\na b a' b' : Rack.PreEnvelGroup R\nha : Rack.PreEnvelGroupRel' R a a'\nhb : Rack.PreEnvelGroupRel' R b b'\n⊢ Eq (SizeOf.sizeOf (ha.congr_mul hb)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf a')) (SizeOf.sizeOf b')) (SizeOf.sizeOf ha)) (SizeOf.sizeOf hb))","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.symm.inj","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b : Rack.PreEnvelGroup R\nhab✝ hab : Rack.PreEnvelGroupRel' R a b\nx✝ : Eq hab✝.symm hab.symm\n⊢ Eq hab✝ hab","decl":"/-- Relations for the enveloping group. This is a type-valued relation because\n`toEnvelGroup.mapAux.well_def` inducts on it to show `toEnvelGroup.map`\nis well-defined.  The relation `PreEnvelGroupRel` is the `Prop`-valued version,\nwhich is used to define `EnvelGroup` itself.\n-/\ninductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R → PreEnvelGroup R → Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | inv_mul_cancel (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x ◃ y))\n\n"}
{"name":"Rack.PreEnvelGroupRel'.rel","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b : Rack.PreEnvelGroup R\na✝ : Rack.PreEnvelGroupRel' R a b\n⊢ Rack.PreEnvelGroupRel R a b","decl":"/-- A quick way to convert a `PreEnvelGroupRel'` to a `PreEnvelGroupRel`.\n-/\ntheorem PreEnvelGroupRel'.rel {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel' R a b → PreEnvelGroupRel R a b := PreEnvelGroupRel.rel\n\n"}
{"name":"Rack.PreEnvelGroupRel.refl","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na : Rack.PreEnvelGroup R\n⊢ Rack.PreEnvelGroupRel R a a","decl":"@[refl]\ntheorem PreEnvelGroupRel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} :\n    PreEnvelGroupRel R a a :=\n  PreEnvelGroupRel.rel PreEnvelGroupRel'.refl\n\n"}
{"name":"Rack.PreEnvelGroupRel.symm","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b : Rack.PreEnvelGroup R\na✝ : Rack.PreEnvelGroupRel R a b\n⊢ Rack.PreEnvelGroupRel R b a","decl":"@[symm]\ntheorem PreEnvelGroupRel.symm {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b → PreEnvelGroupRel R b a\n  | ⟨r⟩ => r.symm.rel\n\n"}
{"name":"Rack.PreEnvelGroupRel.trans","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u\ninst✝ : Rack R\na b c : Rack.PreEnvelGroup R\na✝¹ : Rack.PreEnvelGroupRel R a b\na✝ : Rack.PreEnvelGroupRel R b c\n⊢ Rack.PreEnvelGroupRel R a c","decl":"@[trans]\ntheorem PreEnvelGroupRel.trans {R : Type u} [Rack R] {a b c : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b → PreEnvelGroupRel R b c → PreEnvelGroupRel R a c\n  | ⟨rab⟩, ⟨rbc⟩ => (rab.trans rbc).rel\n\n"}
{"name":"Rack.toEnvelGroup.mapAux.well_def","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝¹ : Rack R\nG : Type u_2\ninst✝ : Group G\nf : ShelfHom R (Quandle.Conj G)\na b : Rack.PreEnvelGroup R\na✝ : Rack.PreEnvelGroupRel' R a b\n⊢ Eq (Rack.toEnvelGroup.mapAux f a) (Rack.toEnvelGroup.mapAux f b)","decl":"/-- Show that `toEnvelGroup.mapAux` sends equivalent expressions to equal terms.\n-/\ntheorem well_def {R : Type*} [Rack R] {G : Type*} [Group G] (f : R →◃ Quandle.Conj G) :\n    ∀ {a b : PreEnvelGroup R},\n      PreEnvelGroupRel' R a b → toEnvelGroup.mapAux f a = toEnvelGroup.mapAux f b\n  | _, _, PreEnvelGroupRel'.refl => rfl\n  | _, _, PreEnvelGroupRel'.symm h => (well_def f h).symm\n  | _, _, PreEnvelGroupRel'.trans hac hcb => Eq.trans (well_def f hac) (well_def f hcb)\n  | _, _, PreEnvelGroupRel'.congr_mul ha hb => by\n    simp [toEnvelGroup.mapAux, well_def f ha, well_def f hb]\n  | _, _, congr_inv ha => by simp [toEnvelGroup.mapAux, well_def f ha]\n  | _, _, assoc a b c => by apply mul_assoc\n  | _, _, PreEnvelGroupRel'.one_mul a => by simp [toEnvelGroup.mapAux]\n  | _, _, PreEnvelGroupRel'.mul_one a => by simp [toEnvelGroup.mapAux]\n  | _, _, PreEnvelGroupRel'.inv_mul_cancel a => by simp [toEnvelGroup.mapAux]\n  | _, _, act_incl x y => by simp [toEnvelGroup.mapAux]\n\n"}
{"name":"Rack.toEnvelGroup.univ","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝¹ : Rack R\nG : Type u_2\ninst✝ : Group G\nf : ShelfHom R (Quandle.Conj G)\n⊢ Eq ((Quandle.Conj.map (Rack.toEnvelGroup.map f)).comp (Rack.toEnvelGroup R)) f","decl":"/-- Given a homomorphism from a rack to a group, it factors through the enveloping group.\n-/\ntheorem toEnvelGroup.univ (R : Type*) [Rack R] (G : Type*) [Group G] (f : R →◃ Quandle.Conj G) :\n    (Quandle.Conj.map (toEnvelGroup.map f)).comp (toEnvelGroup R) = f :=\n  toEnvelGroup.map.symm_apply_apply f\n\n"}
{"name":"Rack.toEnvelGroup.univ_uniq","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝¹ : Rack R\nG : Type u_2\ninst✝ : Group G\nf : ShelfHom R (Quandle.Conj G)\ng : MonoidHom (Rack.EnvelGroup R) G\nh : Eq f ((Quandle.Conj.map g).comp (Rack.toEnvelGroup R))\n⊢ Eq g (Rack.toEnvelGroup.map f)","decl":"/-- The homomorphism `toEnvelGroup.map f` is the unique map that fits into the commutative\ntriangle in `toEnvelGroup.univ`.\n-/\ntheorem toEnvelGroup.univ_uniq (R : Type*) [Rack R] (G : Type*) [Group G]\n    (f : R →◃ Quandle.Conj G) (g : EnvelGroup R →* G)\n    (h : f = (Quandle.Conj.map g).comp (toEnvelGroup R)) : g = toEnvelGroup.map f :=\n  h.symm ▸ (toEnvelGroup.map.apply_symm_apply g).symm\n\n"}
{"name":"Rack.envelAction_prop","module":"Mathlib.Algebra.Quandle","initialProofState":"R : Type u_1\ninst✝ : Rack R\nx y : R\n⊢ Eq ((Rack.envelAction ((Rack.toEnvelGroup R) x)) y) (Shelf.act x y)","decl":"@[simp]\ntheorem envelAction_prop {R : Type*} [Rack R] (x y : R) :\n    envelAction (toEnvelGroup R x) y = x ◃ y :=\n  rfl\n\n"}
