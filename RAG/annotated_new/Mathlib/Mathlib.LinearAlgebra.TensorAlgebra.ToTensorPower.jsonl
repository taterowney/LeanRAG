{"name":"TensorPower.toTensorAlgebra_tprod","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nx : Fin n → M\n⊢ Eq (TensorPower.toTensorAlgebra ((PiTensorProduct.tprod R) x)) ((TensorAlgebra.tprod R M n) x)","decl":"@[simp]\ntheorem toTensorAlgebra_tprod {n} (x : Fin n → M) :\n    TensorPower.toTensorAlgebra (PiTensorProduct.tprod R x) = TensorAlgebra.tprod R M n x :=\n  PiTensorProduct.lift.tprod _\n\n"}
{"name":"TensorPower.toTensorAlgebra_gOne","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorPower.toTensorAlgebra GradedMonoid.GOne.one) 1","decl":"@[simp]\ntheorem toTensorAlgebra_gOne :\n    TensorPower.toTensorAlgebra (@GradedMonoid.GOne.one _ (fun n => ⨂[R]^n M) _ _) = 1 := by\n  simp [GradedMonoid.GOne.one, TensorPower.toTensorAlgebra_tprod]\n\n"}
{"name":"TensorPower.toTensorAlgebra_gMul","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\na : TensorPower R i M\nb : TensorPower R j M\n⊢ Eq (TensorPower.toTensorAlgebra (GradedMonoid.GMul.mul a b)) (HMul.hMul (TensorPower.toTensorAlgebra a) (TensorPower.toTensorAlgebra b))","decl":"@[simp]\ntheorem toTensorAlgebra_gMul {i j} (a : (⨂[R]^i) M) (b : (⨂[R]^j) M) :\n    TensorPower.toTensorAlgebra (@GradedMonoid.GMul.mul _ (fun n => ⨂[R]^n M) _ _ _ _ a b) =\n      TensorPower.toTensorAlgebra a * TensorPower.toTensorAlgebra b := by\n  -- change `a` and `b` to `tprod R a` and `tprod R b`\n  rw [TensorPower.gMul_eq_coe_linearMap, ← LinearMap.compr₂_apply, ← @LinearMap.mul_apply' R, ←\n    LinearMap.compl₂_apply, ← LinearMap.comp_apply]\n  refine LinearMap.congr_fun (LinearMap.congr_fun ?_ a) b\n  clear! a b\n  ext (a b)\n  -- Porting note: pulled the next two lines out of the long `simp only` below.\n  simp only [LinearMap.compMultilinearMap_apply]\n  rw [LinearMap.compr₂_apply, ← gMul_eq_coe_linearMap]\n  simp only [LinearMap.compr₂_apply, LinearMap.mul_apply', LinearMap.compl₂_apply,\n    LinearMap.comp_apply, LinearMap.compMultilinearMap_apply, PiTensorProduct.lift.tprod,\n    TensorPower.tprod_mul_tprod, TensorPower.toTensorAlgebra_tprod, TensorAlgebra.tprod_apply, ←\n    gMul_eq_coe_linearMap]\n  refine Eq.trans ?_ List.prod_append\n  congr\n  -- Porting note: `erw` for `Function.comp`\n  erw [← List.map_ofFn _ (TensorAlgebra.ι R), ← List.map_ofFn _ (TensorAlgebra.ι R), ←\n    List.map_ofFn _ (TensorAlgebra.ι R), ← List.map_append, List.ofFn_fin_append]\n\n"}
{"name":"TensorPower.toTensorAlgebra_galgebra_toFun","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\n⊢ Eq (TensorPower.toTensorAlgebra (DirectSum.GAlgebra.toFun r)) ((algebraMap R (TensorAlgebra R M)) r)","decl":"@[simp]\ntheorem toTensorAlgebra_galgebra_toFun (r : R) :\n    TensorPower.toTensorAlgebra (DirectSum.GAlgebra.toFun (R := R) (A := fun n => ⨂[R]^n M) r) =\n      algebraMap _ _ r := by\n  rw [TensorPower.galgebra_toFun_def, TensorPower.algebraMap₀_eq_smul_one, LinearMap.map_smul,\n    TensorPower.toTensorAlgebra_gOne, Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"TensorAlgebra.ofDirectSum_of_tprod","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nx : Fin n → M\n⊢ Eq (TensorAlgebra.ofDirectSum ((DirectSum.of (fun n => TensorPower R n M) n) ((PiTensorProduct.tprod R) x))) ((TensorAlgebra.tprod R M n) x)","decl":"@[simp]\ntheorem ofDirectSum_of_tprod {n} (x : Fin n → M) :\n    ofDirectSum (DirectSum.of _ n (PiTensorProduct.tprod R x)) = tprod R M n x :=\n  (DirectSum.toAddMonoid_of\n    (fun _ ↦ LinearMap.toAddMonoidHom TensorPower.toTensorAlgebra) _ _).trans\n  (TensorPower.toTensorAlgebra_tprod _)\n\n"}
{"name":"TensorAlgebra.toDirectSum_ι","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (TensorAlgebra.toDirectSum ((TensorAlgebra.ι R) x)) ((DirectSum.of (fun n => TensorPower R n M) 1) ((PiTensorProduct.tprod R) fun x_1 => x))","decl":"@[simp]\ntheorem toDirectSum_ι (x : M) :\n    toDirectSum (ι R x) =\n      DirectSum.of (fun n => ⨂[R]^n M) _ (PiTensorProduct.tprod R fun _ : Fin 1 => x) :=\n  TensorAlgebra.lift_ι_apply _ _\n\n"}
{"name":"TensorAlgebra.ofDirectSum_comp_toDirectSum","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorAlgebra.ofDirectSum.comp TensorAlgebra.toDirectSum) (AlgHom.id R (TensorAlgebra R M))","decl":"theorem ofDirectSum_comp_toDirectSum :\n    ofDirectSum.comp toDirectSum = AlgHom.id R (TensorAlgebra R M) := by\n  ext\n  simp [DirectSum.lof_eq_of, tprod_apply]\n\n"}
{"name":"TensorAlgebra.ofDirectSum_toDirectSum","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : TensorAlgebra R M\n⊢ Eq (TensorAlgebra.ofDirectSum (TensorAlgebra.toDirectSum x)) x","decl":"@[simp]\ntheorem ofDirectSum_toDirectSum (x : TensorAlgebra R M) :\n    ofDirectSum (TensorAlgebra.toDirectSum x) = x :=\n  AlgHom.congr_fun ofDirectSum_comp_toDirectSum x\n\n-- See https://github.com/leanprover-community/batteries/issues/365 for the simpNF issue.\n"}
{"name":"TensorAlgebra.mk_reindex_cast","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn m : Nat\nh : Eq n m\nx : TensorPower R n M\n⊢ Eq (GradedMonoid.mk m ((PiTensorProduct.reindex R (fun x => M) (Equiv.cast ⋯)) x)) (GradedMonoid.mk n x)","decl":"@[simp, nolint simpNF]\ntheorem mk_reindex_cast {n m : ℕ} (h : n = m) (x : ⨂[R]^n M) :\n    GradedMonoid.mk (A := fun i => (⨂[R]^i) M) m\n    (PiTensorProduct.reindex R (fun _ ↦ M) (Equiv.cast <| congr_arg Fin h) x) =\n    GradedMonoid.mk n x :=\n  Eq.symm (PiTensorProduct.gradedMonoid_eq_of_reindex_cast h rfl)\n\n"}
{"name":"TensorAlgebra.mk_reindex_fin_cast","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn m : Nat\nh : Eq n m\nx : TensorPower R n M\n⊢ Eq (GradedMonoid.mk m ((PiTensorProduct.reindex R (fun x => M) (finCongr h)) x)) (GradedMonoid.mk n x)","decl":"@[simp]\ntheorem mk_reindex_fin_cast {n m : ℕ} (h : n = m) (x : ⨂[R]^n M) :\n    GradedMonoid.mk (A := fun i => (⨂[R]^i) M) m\n    (PiTensorProduct.reindex R (fun _ ↦ M) (finCongr h) x) = GradedMonoid.mk n x := by\n  rw [finCongr_eq_equivCast, mk_reindex_cast h]\n\n"}
{"name":"TensorPower.list_prod_gradedMonoid_mk_single","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nx : Fin n → M\n⊢ Eq (List.map (fun a => GradedMonoid.mk 1 ((PiTensorProduct.tprod R) fun x_1 => x a)) (List.finRange n)).prod (GradedMonoid.mk n ((PiTensorProduct.tprod R) x))","decl":"/-- The product of tensor products made of a single vector is the same as a single product of\nall the vectors. -/\ntheorem _root_.TensorPower.list_prod_gradedMonoid_mk_single (n : ℕ) (x : Fin n → M) :\n    ((List.finRange n).map fun a =>\n          (GradedMonoid.mk _ (PiTensorProduct.tprod R fun _ : Fin 1 => x a) :\n            GradedMonoid fun n => ⨂[R]^n M)).prod =\n      GradedMonoid.mk n (PiTensorProduct.tprod R x) := by\n  refine Fin.consInduction ?_ ?_ x <;> clear x\n  · rw [List.finRange_zero, List.map_nil, List.prod_nil]\n    rfl\n  · intro n x₀ x ih\n    rw [List.finRange_succ_eq_map, List.map_cons, List.prod_cons, List.map_map]\n    simp_rw [Function.comp_def, Fin.cons_zero, Fin.cons_succ]\n    rw [ih, GradedMonoid.mk_mul_mk, TensorPower.tprod_mul_tprod]\n    refine TensorPower.gradedMonoid_eq_of_cast (add_comm _ _) ?_\n    dsimp only [GradedMonoid.mk]\n    rw [TensorPower.cast_tprod]\n    simp_rw [Fin.append_left_eq_cons, Function.comp_def]\n    congr 1 with i\n\n"}
{"name":"TensorAlgebra.toDirectSum_tensorPower_tprod","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nx : Fin n → M\n⊢ Eq (TensorAlgebra.toDirectSum ((TensorAlgebra.tprod R M n) x)) ((DirectSum.of (fun i => TensorPower R i M) n) ((PiTensorProduct.tprod R) x))","decl":"theorem toDirectSum_tensorPower_tprod {n} (x : Fin n → M) :\n    toDirectSum (tprod R M n x) = DirectSum.of _ n (PiTensorProduct.tprod R x) := by\n  rw [tprod_apply, map_list_prod, List.map_ofFn]\n  simp_rw [Function.comp_def, toDirectSum_ι]\n  rw [DirectSum.list_prod_ofFn_of_eq_dProd]\n  apply DirectSum.of_eq_of_gradedMonoid_eq\n  rw [GradedMonoid.mk_list_dProd]\n  rw [TensorPower.list_prod_gradedMonoid_mk_single]\n\n"}
{"name":"TensorAlgebra.toDirectSum_comp_ofDirectSum","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorAlgebra.toDirectSum.comp TensorAlgebra.ofDirectSum) (AlgHom.id R (DirectSum Nat fun n => TensorPower R n M))","decl":"theorem toDirectSum_comp_ofDirectSum :\n    toDirectSum.comp ofDirectSum = AlgHom.id R (⨁ n, ⨂[R]^n M) := by\n  ext\n  simp [DirectSum.lof_eq_of, -tprod_apply, toDirectSum_tensorPower_tprod]\n\n"}
{"name":"TensorAlgebra.toDirectSum_ofDirectSum","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : DirectSum Nat fun n => TensorPower R n M\n⊢ Eq (TensorAlgebra.toDirectSum (TensorAlgebra.ofDirectSum x)) x","decl":"@[simp]\ntheorem toDirectSum_ofDirectSum (x : ⨁ n, ⨂[R]^n M) :\n    TensorAlgebra.toDirectSum (ofDirectSum x) = x :=\n  AlgHom.congr_fun toDirectSum_comp_ofDirectSum x\n\n"}
{"name":"TensorAlgebra.equivDirectSum_symm_apply","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : DirectSum Nat fun n => TensorPower R n M\n⊢ Eq (TensorAlgebra.equivDirectSum.symm a) (TensorAlgebra.ofDirectSum a)","decl":"/-- The tensor algebra is isomorphic to a direct sum of tensor powers. -/\n@[simps!]\ndef equivDirectSum : TensorAlgebra R M ≃ₐ[R] ⨁ n, ⨂[R]^n M :=\n  AlgEquiv.ofAlgHom toDirectSum ofDirectSum toDirectSum_comp_ofDirectSum\n    ofDirectSum_comp_toDirectSum\n\n"}
{"name":"TensorAlgebra.equivDirectSum_apply","module":"Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : TensorAlgebra R M\n⊢ Eq (TensorAlgebra.equivDirectSum a) (TensorAlgebra.toDirectSum a)","decl":"/-- The tensor algebra is isomorphic to a direct sum of tensor powers. -/\n@[simps!]\ndef equivDirectSum : TensorAlgebra R M ≃ₐ[R] ⨁ n, ⨂[R]^n M :=\n  AlgEquiv.ofAlgHom toDirectSum ofDirectSum toDirectSum_comp_ofDirectSum\n    ofDirectSum_comp_toDirectSum\n\n"}
