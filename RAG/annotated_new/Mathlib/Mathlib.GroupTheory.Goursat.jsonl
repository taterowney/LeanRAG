{"name":"Subgroup.mem_goursatFst","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\ng : G\n⊢ Iff (Membership.mem I.goursatFst g) (Membership.mem I { fst := g, snd := 1 })","decl":"@[to_additive (attr := simp)]\nlemma mem_goursatFst {g : G} : g ∈ I.goursatFst ↔ (g, 1) ∈ I := by simp [goursatFst]\n\n"}
{"name":"AddSubgroup.mem_goursatFst","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\ng : G\n⊢ Iff (Membership.mem I.goursatFst g) (Membership.mem I { fst := g, snd := 0 })","decl":"@[to_additive (attr := simp)]\nlemma mem_goursatFst {g : G} : g ∈ I.goursatFst ↔ (g, 1) ∈ I := by simp [goursatFst]\n\n"}
{"name":"AddSubgroup.mem_goursatSnd","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\nh : H\n⊢ Iff (Membership.mem I.goursatSnd h) (Membership.mem I { fst := 0, snd := h })","decl":"@[to_additive (attr := simp)]\nlemma mem_goursatSnd {h : H} : h ∈ I.goursatSnd ↔ (1, h) ∈ I := by simp [goursatSnd]\n\n"}
{"name":"Subgroup.mem_goursatSnd","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\nh : H\n⊢ Iff (Membership.mem I.goursatSnd h) (Membership.mem I { fst := 1, snd := h })","decl":"@[to_additive (attr := simp)]\nlemma mem_goursatSnd {h : H} : h ∈ I.goursatSnd ↔ (1, h) ∈ I := by simp [goursatSnd]\n\n"}
{"name":"AddSubgroup.normal_goursatFst","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\n⊢ I.goursatFst.Normal","decl":"include hI₁ in\n@[to_additive] lemma normal_goursatFst : I.goursatFst.Normal := .map inferInstance _ hI₁\n\n"}
{"name":"Subgroup.normal_goursatFst","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\n⊢ I.goursatFst.Normal","decl":"include hI₁ in\n@[to_additive] lemma normal_goursatFst : I.goursatFst.Normal := .map inferInstance _ hI₁\n\n"}
{"name":"AddSubgroup.normal_goursatSnd","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\n⊢ I.goursatSnd.Normal","decl":"include hI₂ in\n@[to_additive] lemma normal_goursatSnd : I.goursatSnd.Normal := .map inferInstance _ hI₂\n\n"}
{"name":"Subgroup.normal_goursatSnd","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\n⊢ I.goursatSnd.Normal","decl":"include hI₂ in\n@[to_additive] lemma normal_goursatSnd : I.goursatSnd.Normal := .map inferInstance _ hI₂\n\n"}
{"name":"AddSubgroup.mk_goursatFst_eq_iff_mk_goursatSnd_eq","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\nx y : Prod G H\nhx : Membership.mem I x\nhy : Membership.mem I y\n⊢ Iff (Eq ↑x.1 ↑y.1) (Eq ↑x.2 ↑y.2)","decl":"include hI₁ hI₂ in\n@[to_additive]\nlemma mk_goursatFst_eq_iff_mk_goursatSnd_eq {x y : G × H} (hx : x ∈ I) (hy : y ∈ I) :\n    (x.1 : G ⧸ I.goursatFst) = y.1 ↔ (x.2 : H ⧸ I.goursatSnd) = y.2 := by\n  have := normal_goursatFst hI₁\n  have := normal_goursatSnd hI₂\n  rw [eq_comm]\n  simp [QuotientGroup.eq_iff_div_mem]\n  constructor <;> intro h\n  · simpa [Prod.mul_def, Prod.div_def] using div_mem (mul_mem h hx) hy\n  · simpa [Prod.mul_def, Prod.div_def] using div_mem (mul_mem h hy) hx\n\n"}
{"name":"Subgroup.mk_goursatFst_eq_iff_mk_goursatSnd_eq","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\nx y : Prod G H\nhx : Membership.mem I x\nhy : Membership.mem I y\n⊢ Iff (Eq ↑x.1 ↑y.1) (Eq ↑x.2 ↑y.2)","decl":"include hI₁ hI₂ in\n@[to_additive]\nlemma mk_goursatFst_eq_iff_mk_goursatSnd_eq {x y : G × H} (hx : x ∈ I) (hy : y ∈ I) :\n    (x.1 : G ⧸ I.goursatFst) = y.1 ↔ (x.2 : H ⧸ I.goursatSnd) = y.2 := by\n  have := normal_goursatFst hI₁\n  have := normal_goursatSnd hI₂\n  rw [eq_comm]\n  simp [QuotientGroup.eq_iff_div_mem]\n  constructor <;> intro h\n  · simpa [Prod.mul_def, Prod.div_def] using div_mem (mul_mem h hx) hy\n  · simpa [Prod.mul_def, Prod.div_def] using div_mem (mul_mem h hy) hx\n\n"}
{"name":"AddSubgroup.goursatFst_prod_goursatSnd_le","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\n⊢ LE.le (I.goursatFst.prod I.goursatSnd) I","decl":"variable (I) in\n@[to_additive AddSubgroup.goursatFst_prod_goursatSnd_le]\nlemma goursatFst_prod_goursatSnd_le : I.goursatFst.prod I.goursatSnd ≤ I := by\n  rintro ⟨g, h⟩ ⟨hg, hh⟩\n  simpa using mul_mem (mem_goursatFst.1 hg) (mem_goursatSnd.1 hh)\n\n"}
{"name":"Subgroup.goursatFst_prod_goursatSnd_le","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\n⊢ LE.le (I.goursatFst.prod I.goursatSnd) I","decl":"variable (I) in\n@[to_additive AddSubgroup.goursatFst_prod_goursatSnd_le]\nlemma goursatFst_prod_goursatSnd_le : I.goursatFst.prod I.goursatSnd ≤ I := by\n  rintro ⟨g, h⟩ ⟨hg, hh⟩\n  simpa using mul_mem (mem_goursatFst.1 hg) (mem_goursatSnd.1 hh)\n\n"}
{"name":"Subgroup.goursat_surjective","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\n⊢ letFun ⋯ fun this => letFun ⋯ fun this_1 => Exists fun e => Eq (((QuotientGroup.mk' I.goursatFst).prodMap (QuotientGroup.mk' I.goursatSnd)).comp I.subtype).range e.toMonoidHom.graph","decl":"/-- **Goursat's lemma** for a subgroup of a product with surjective projections.\n\nIf `I` is a subgroup of `G × H` which projects fully on both factors, then there exist normal\nsubgroups `M ≤ G` and `N ≤ H` such that `G' × H' ≤ I` and the image of `I` in `G ⧸ M × H ⧸ N` is the\ngraph of an isomorphism `G ⧸ M ≃ H ⧸ N'`.\n\n`G'` and `H'` can be explicitly constructed as `I.goursatFst` and `I.goursatSnd` respectively. -/\n@[to_additive\n\"**Goursat's lemma** for a subgroup of a product with surjective projections.\n\nIf `I` is a subgroup of `G × H` which projects fully on both factors, then there exist normal\nsubgroups `M ≤ G` and `N ≤ H` such that `G' × H' ≤ I` and the image of `I` in `G ⧸ M × H ⧸ N` is the\ngraph of an isomorphism `G ⧸ M ≃ H ⧸ N'`.\n\n`G'` and `H'` can be explicitly constructed as `I.goursatFst` and `I.goursatSnd` respectively.\"]\nlemma goursat_surjective :\n    have := normal_goursatFst hI₁\n    have := normal_goursatSnd hI₂\n    ∃ e : G ⧸ I.goursatFst ≃* H ⧸ I.goursatSnd,\n      (((QuotientGroup.mk' _).prodMap (QuotientGroup.mk' _)).comp I.subtype).range =\n        e.toMonoidHom.graph := by\n  have := normal_goursatFst hI₁\n  have := normal_goursatSnd hI₂\n  exact (((QuotientGroup.mk' I.goursatFst).prodMap\n    (QuotientGroup.mk' I.goursatSnd)).comp I.subtype).exists_mulEquiv_range_eq_graph\n    ((QuotientGroup.mk'_surjective _).comp hI₁) ((QuotientGroup.mk'_surjective _).comp hI₂)\n    fun ⟨x, hx⟩ ⟨y, hy⟩ ↦ mk_goursatFst_eq_iff_mk_goursatSnd_eq hI₁ hI₂ hx hy\n\n"}
{"name":"AddSubgroup.goursat_surjective","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\nhI₁ : Function.Surjective (Function.comp Prod.fst ⇑I.subtype)\nhI₂ : Function.Surjective (Function.comp Prod.snd ⇑I.subtype)\n⊢ letFun ⋯ fun this => letFun ⋯ fun this_1 => Exists fun e => Eq (((QuotientAddGroup.mk' I.goursatFst).prodMap (QuotientAddGroup.mk' I.goursatSnd)).comp I.subtype).range e.toAddMonoidHom.graph","decl":"/-- **Goursat's lemma** for a subgroup of a product with surjective projections.\n\nIf `I` is a subgroup of `G × H` which projects fully on both factors, then there exist normal\nsubgroups `M ≤ G` and `N ≤ H` such that `G' × H' ≤ I` and the image of `I` in `G ⧸ M × H ⧸ N` is the\ngraph of an isomorphism `G ⧸ M ≃ H ⧸ N'`.\n\n`G'` and `H'` can be explicitly constructed as `I.goursatFst` and `I.goursatSnd` respectively. -/\n@[to_additive\n\"**Goursat's lemma** for a subgroup of a product with surjective projections.\n\nIf `I` is a subgroup of `G × H` which projects fully on both factors, then there exist normal\nsubgroups `M ≤ G` and `N ≤ H` such that `G' × H' ≤ I` and the image of `I` in `G ⧸ M × H ⧸ N` is the\ngraph of an isomorphism `G ⧸ M ≃ H ⧸ N'`.\n\n`G'` and `H'` can be explicitly constructed as `I.goursatFst` and `I.goursatSnd` respectively.\"]\nlemma goursat_surjective :\n    have := normal_goursatFst hI₁\n    have := normal_goursatSnd hI₂\n    ∃ e : G ⧸ I.goursatFst ≃* H ⧸ I.goursatSnd,\n      (((QuotientGroup.mk' _).prodMap (QuotientGroup.mk' _)).comp I.subtype).range =\n        e.toMonoidHom.graph := by\n  have := normal_goursatFst hI₁\n  have := normal_goursatSnd hI₂\n  exact (((QuotientGroup.mk' I.goursatFst).prodMap\n    (QuotientGroup.mk' I.goursatSnd)).comp I.subtype).exists_mulEquiv_range_eq_graph\n    ((QuotientGroup.mk'_surjective _).comp hI₁) ((QuotientGroup.mk'_surjective _).comp hI₂)\n    fun ⟨x, hx⟩ ⟨y, hy⟩ ↦ mk_goursatFst_eq_iff_mk_goursatSnd_eq hI₁ hI₂ hx hy\n\n"}
{"name":"Subgroup.goursat","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nI : Subgroup (Prod G H)\n⊢ Exists fun G' => Exists fun H' => Exists fun M => Exists fun N => Exists fun x => Exists fun x_1 => Exists fun e => Eq I (Subgroup.map (G'.subtype.prodMap H'.subtype) (Subgroup.comap ((QuotientGroup.mk' M).prodMap (QuotientGroup.mk' N)) e.toMonoidHom.graph))","decl":"/-- **Goursat's lemma** for an arbitrary subgroup.\n\nIf `I` is a subgroup of `G × H`, then there exist subgroups `G' ≤ G`, `H' ≤ H` and normal subgroups\n`M ⊴ G'` and `N ⊴ H'` such that `M × N ≤ I` and the image of `I` in `G' ⧸ M × H' ⧸ N` is the graph\nof an isomorphism `G' ⧸ M ≃ H' ⧸ N`. -/\n@[to_additive\n\"**Goursat's lemma** for an arbitrary subgroup.\n\nIf `I` is a subgroup of `G × H`, then there exist subgroups `G' ≤ G`, `H' ≤ H` and normal subgroups\n`M ≤ G'` and `N ≤ H'` such that `M × N ≤ I` and the image of `I` in `G' ⧸ M × H' ⧸ N` is the graph\nof an isomorphism `G ⧸ G' ≃ H ⧸ H'`.\"]\nlemma goursat :\n    ∃ (G' : Subgroup G) (H' : Subgroup H) (M : Subgroup G') (N : Subgroup H') (_ : M.Normal)\n      (_ : N.Normal) (e : G' ⧸ M ≃* H' ⧸ N),\n      I = (e.toMonoidHom.graph.comap <| (QuotientGroup.mk' M).prodMap (QuotientGroup.mk' N)).map\n        (G'.subtype.prodMap H'.subtype) := by\n  let G' := I.map (MonoidHom.fst ..)\n  let H' := I.map (MonoidHom.snd ..)\n  let P : I →* G' := (MonoidHom.fst ..).subgroupMap I\n  let Q : I →* H' := (MonoidHom.snd ..).subgroupMap I\n  let I' : Subgroup (G' × H') := (P.prod Q).range\n  have hI₁' : Surjective (Prod.fst ∘ I'.subtype) := by\n    simp only [← MonoidHom.coe_fst, ← MonoidHom.coe_comp, ← MonoidHom.range_eq_top,\n      MonoidHom.range_comp, Subgroup.range_subtype, I']\n    simp only [← MonoidHom.range_comp, MonoidHom.fst_comp_prod, MonoidHom.range_eq_top]\n    exact (MonoidHom.fst ..).subgroupMap_surjective I\n  have hI₂' : Surjective (Prod.snd ∘ I'.subtype) := by\n    simp only [← MonoidHom.coe_snd, ← MonoidHom.coe_comp, ← MonoidHom.range_eq_top,\n      MonoidHom.range_comp, Subgroup.range_subtype, I']\n    simp only [← MonoidHom.range_comp, MonoidHom.fst_comp_prod, MonoidHom.range_eq_top]\n    exact (MonoidHom.snd ..).subgroupMap_surjective I\n  have := normal_goursatFst hI₁'\n  have := normal_goursatSnd hI₂'\n  obtain ⟨e, he⟩ := goursat_surjective hI₁' hI₂'\n  refine ⟨I.map (MonoidHom.fst ..), I.map (MonoidHom.snd ..),\n    I'.goursatFst, I'.goursatSnd, inferInstance, inferInstance, e, ?_⟩\n  rw [← he]\n  simp only [MonoidHom.range_comp, Subgroup.range_subtype, I']\n  rw [comap_map_eq_self]\n  · ext ⟨g, h⟩\n    constructor\n    · intro hgh\n      simpa only [G', H', mem_map, MonoidHom.mem_range, MonoidHom.prod_apply, Subtype.exists,\n        Prod.exists, MonoidHom.coe_prodMap, coeSubtype, Prod.mk.injEq, Prod.map_apply,\n        MonoidHom.coe_snd, exists_eq_right, exists_and_right, exists_eq_right_right,\n        MonoidHom.coe_fst]\n        using ⟨⟨h, hgh⟩, ⟨g, hgh⟩, g, h, hgh, ⟨rfl, rfl⟩⟩\n    · simp only [G', H', mem_map, MonoidHom.mem_range, MonoidHom.prod_apply, Subtype.exists,\n        Prod.exists, MonoidHom.coe_prodMap, coeSubtype, Prod.mk.injEq, Prod.map_apply,\n        MonoidHom.coe_snd, exists_eq_right, exists_and_right, exists_eq_right_right,\n        MonoidHom.coe_fst, forall_exists_index, and_imp]\n      rintro h₁ hgh₁ g₁ hg₁h g₂ h₂ hg₂h₂ hP hQ\n      simp only [Subtype.ext_iff] at hP hQ\n      rwa [← hP, ← hQ]\n  · convert goursatFst_prod_goursatSnd_le (P.prod Q).range\n    ext ⟨g, h⟩\n    simp_rw [G', H', MonoidHom.mem_ker, MonoidHom.coe_prodMap, Prod.map_apply, Subgroup.mem_prod,\n      Prod.one_eq_mk, Prod.ext_iff, ← MonoidHom.mem_ker, QuotientGroup.ker_mk']\n\n"}
{"name":"AddSubgroup.goursat","module":"Mathlib.GroupTheory.Goursat","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nI : AddSubgroup (Prod G H)\n⊢ Exists fun G' => Exists fun H' => Exists fun M => Exists fun N => Exists fun x => Exists fun x_1 => Exists fun e => Eq I (AddSubgroup.map (G'.subtype.prodMap H'.subtype) (AddSubgroup.comap ((QuotientAddGroup.mk' M).prodMap (QuotientAddGroup.mk' N)) e.toAddMonoidHom.graph))","decl":"/-- **Goursat's lemma** for an arbitrary subgroup.\n\nIf `I` is a subgroup of `G × H`, then there exist subgroups `G' ≤ G`, `H' ≤ H` and normal subgroups\n`M ⊴ G'` and `N ⊴ H'` such that `M × N ≤ I` and the image of `I` in `G' ⧸ M × H' ⧸ N` is the graph\nof an isomorphism `G' ⧸ M ≃ H' ⧸ N`. -/\n@[to_additive\n\"**Goursat's lemma** for an arbitrary subgroup.\n\nIf `I` is a subgroup of `G × H`, then there exist subgroups `G' ≤ G`, `H' ≤ H` and normal subgroups\n`M ≤ G'` and `N ≤ H'` such that `M × N ≤ I` and the image of `I` in `G' ⧸ M × H' ⧸ N` is the graph\nof an isomorphism `G ⧸ G' ≃ H ⧸ H'`.\"]\nlemma goursat :\n    ∃ (G' : Subgroup G) (H' : Subgroup H) (M : Subgroup G') (N : Subgroup H') (_ : M.Normal)\n      (_ : N.Normal) (e : G' ⧸ M ≃* H' ⧸ N),\n      I = (e.toMonoidHom.graph.comap <| (QuotientGroup.mk' M).prodMap (QuotientGroup.mk' N)).map\n        (G'.subtype.prodMap H'.subtype) := by\n  let G' := I.map (MonoidHom.fst ..)\n  let H' := I.map (MonoidHom.snd ..)\n  let P : I →* G' := (MonoidHom.fst ..).subgroupMap I\n  let Q : I →* H' := (MonoidHom.snd ..).subgroupMap I\n  let I' : Subgroup (G' × H') := (P.prod Q).range\n  have hI₁' : Surjective (Prod.fst ∘ I'.subtype) := by\n    simp only [← MonoidHom.coe_fst, ← MonoidHom.coe_comp, ← MonoidHom.range_eq_top,\n      MonoidHom.range_comp, Subgroup.range_subtype, I']\n    simp only [← MonoidHom.range_comp, MonoidHom.fst_comp_prod, MonoidHom.range_eq_top]\n    exact (MonoidHom.fst ..).subgroupMap_surjective I\n  have hI₂' : Surjective (Prod.snd ∘ I'.subtype) := by\n    simp only [← MonoidHom.coe_snd, ← MonoidHom.coe_comp, ← MonoidHom.range_eq_top,\n      MonoidHom.range_comp, Subgroup.range_subtype, I']\n    simp only [← MonoidHom.range_comp, MonoidHom.fst_comp_prod, MonoidHom.range_eq_top]\n    exact (MonoidHom.snd ..).subgroupMap_surjective I\n  have := normal_goursatFst hI₁'\n  have := normal_goursatSnd hI₂'\n  obtain ⟨e, he⟩ := goursat_surjective hI₁' hI₂'\n  refine ⟨I.map (MonoidHom.fst ..), I.map (MonoidHom.snd ..),\n    I'.goursatFst, I'.goursatSnd, inferInstance, inferInstance, e, ?_⟩\n  rw [← he]\n  simp only [MonoidHom.range_comp, Subgroup.range_subtype, I']\n  rw [comap_map_eq_self]\n  · ext ⟨g, h⟩\n    constructor\n    · intro hgh\n      simpa only [G', H', mem_map, MonoidHom.mem_range, MonoidHom.prod_apply, Subtype.exists,\n        Prod.exists, MonoidHom.coe_prodMap, coeSubtype, Prod.mk.injEq, Prod.map_apply,\n        MonoidHom.coe_snd, exists_eq_right, exists_and_right, exists_eq_right_right,\n        MonoidHom.coe_fst]\n        using ⟨⟨h, hgh⟩, ⟨g, hgh⟩, g, h, hgh, ⟨rfl, rfl⟩⟩\n    · simp only [G', H', mem_map, MonoidHom.mem_range, MonoidHom.prod_apply, Subtype.exists,\n        Prod.exists, MonoidHom.coe_prodMap, coeSubtype, Prod.mk.injEq, Prod.map_apply,\n        MonoidHom.coe_snd, exists_eq_right, exists_and_right, exists_eq_right_right,\n        MonoidHom.coe_fst, forall_exists_index, and_imp]\n      rintro h₁ hgh₁ g₁ hg₁h g₂ h₂ hg₂h₂ hP hQ\n      simp only [Subtype.ext_iff] at hP hQ\n      rwa [← hP, ← hQ]\n  · convert goursatFst_prod_goursatSnd_le (P.prod Q).range\n    ext ⟨g, h⟩\n    simp_rw [G', H', MonoidHom.mem_ker, MonoidHom.coe_prodMap, Prod.map_apply, Subgroup.mem_prod,\n      Prod.one_eq_mk, Prod.ext_iff, ← MonoidHom.mem_ker, QuotientGroup.ker_mk']\n\n"}
