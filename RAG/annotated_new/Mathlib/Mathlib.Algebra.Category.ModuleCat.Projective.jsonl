{"name":"IsProjective.iff_projective","module":"Mathlib.Algebra.Category.ModuleCat.Projective","initialProofState":"R : Type u\ninst✝² : Ring R\nP : Type (max u v)\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\n⊢ Iff (Module.Projective R P) (CategoryTheory.Projective (ModuleCat.of R P))","decl":"/-- The categorical notion of projective object agrees with the explicit module-theoretic notion. -/\ntheorem IsProjective.iff_projective {R : Type u} [Ring R] {P : Type max u v} [AddCommGroup P]\n    [Module R P] : Module.Projective R P ↔ Projective (ModuleCat.of R P) := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · letI : Module.Projective R (ModuleCat.of R P) := h\n    refine ⟨fun E X epi => ?_⟩\n    obtain ⟨f, h⟩ := Module.projective_lifting_property X.hom E.hom\n      ((ModuleCat.epi_iff_surjective _).mp epi)\n    exact ⟨ofHom f, hom_ext h⟩\n  · refine Module.Projective.of_lifting_property.{u,v} ?_\n    intro E X mE mX sE sX f g s\n    haveI : Epi (↟f) := (ModuleCat.epi_iff_surjective (↟f)).mpr s\n    letI : Projective (ModuleCat.of R P) := h\n    exact ⟨(Projective.factorThru (↟g) (↟f)).hom,\n      ModuleCat.hom_ext_iff.mp <| Projective.factorThru_comp (↟g) (↟f)⟩\n\n"}
{"name":"ModuleCat.projective_of_free","module":"Mathlib.Algebra.Category.ModuleCat.Projective","initialProofState":"R : Type u\ninst✝ : Ring R\nM : ModuleCat R\nι : Type u'\nb : Basis ι R ↑M\n⊢ CategoryTheory.Projective M","decl":"/-- Modules that have a basis are projective. -/\ntheorem projective_of_free {ι : Type u'} (b : Basis ι R M) : Projective M :=\n  Projective.of_iso (ModuleCat.ofSelfIso M)\n    (IsProjective.iff_projective.{v,u}.mp (Module.Projective.of_basis b))\n\n"}
{"name":"ModuleCat.moduleCat_enoughProjectives","module":"Mathlib.Algebra.Category.ModuleCat.Projective","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.EnoughProjectives (ModuleCat R)","decl":"/-- The category of modules has enough projectives, since every module is a quotient of a free\n    module. -/\ninstance moduleCat_enoughProjectives : EnoughProjectives (ModuleCat.{max u v} R) where\n  presentation M :=\n    ⟨{  p := ModuleCat.of R (M →₀ R)\n        projective :=\n          projective_of_free.{v,u} (ι := M) (M := ModuleCat.of R (M →₀ R)) <|\n            Finsupp.basisSingleOne\n        f := ofHom <| Finsupp.basisSingleOne.constr ℕ _root_.id\n        epi := (epi_iff_range_eq_top _).mpr\n            (range_eq_top.2 fun m => ⟨Finsupp.single m (1 : R), by\n              simp [Finsupp.linearCombination_single, Basis.constr] ⟩)}⟩\n\n"}
