{"name":"LieSubmodule.lcs_zero","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.lcs 0 N) N","decl":"@[simp]\ntheorem lcs_zero (N : LieSubmodule R L M) : N.lcs 0 = N :=\n  rfl\n\n"}
{"name":"LieSubmodule.lcs_succ","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nk : Nat\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.lcs (HAdd.hAdd k 1) N) (Bracket.bracket Top.top (LieSubmodule.lcs k N))","decl":"@[simp]\ntheorem lcs_succ : N.lcs (k + 1) = ⁅(⊤ : LieIdeal R L), N.lcs k⁆ :=\n  Function.iterate_succ_apply' (fun N' => ⁅⊤, N'⁆) k N\n\n"}
{"name":"LieSubmodule.lcs_sup","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN₁ N₂ : LieSubmodule R L M\nk : Nat\n⊢ Eq (LieSubmodule.lcs k (Max.max N₁ N₂)) (Max.max (LieSubmodule.lcs k N₁) (LieSubmodule.lcs k N₂))","decl":"@[simp]\nlemma lcs_sup {N₁ N₂ : LieSubmodule R L M} {k : ℕ} :\n    (N₁ ⊔ N₂).lcs k = N₁.lcs k ⊔ N₂.lcs k := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp only [LieSubmodule.lcs_succ, ih, LieSubmodule.lie_sup]\n\n"}
{"name":"LieModule.lowerCentralSeries_zero","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (LieModule.lowerCentralSeries R L M 0) Top.top","decl":"@[simp]\ntheorem lowerCentralSeries_zero : lowerCentralSeries R L M 0 = ⊤ :=\n  rfl\n\n"}
{"name":"LieModule.lowerCentralSeries_succ","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nk : Nat\n⊢ Eq (LieModule.lowerCentralSeries R L M (HAdd.hAdd k 1)) (Bracket.bracket Top.top (LieModule.lowerCentralSeries R L M k))","decl":"@[simp]\ntheorem lowerCentralSeries_succ :\n    lowerCentralSeries R L M (k + 1) = ⁅(⊤ : LieIdeal R L), lowerCentralSeries R L M k⁆ :=\n  (⊤ : LieSubmodule R L M).lcs_succ k\n\n"}
{"name":"LieModule.coe_lowerCentralSeries_eq_int","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Eq ↑(LieModule.lowerCentralSeries R L M k) ↑(LieModule.lowerCentralSeries Int L M k)","decl":"theorem coe_lowerCentralSeries_eq_int [LieModule R L M] (k : ℕ) :\n    (lowerCentralSeries R L M k : Set M) = (lowerCentralSeries ℤ L M k : Set M) := by\n  show ((lowerCentralSeries R L M k).toSubmodule : Set M) =\n       ((lowerCentralSeries ℤ L M k).toSubmodule : Set M)\n  induction k with\n  | zero => rfl\n  | succ k ih =>\n    rw [lowerCentralSeries_succ, lowerCentralSeries_succ]\n    rw [LieSubmodule.lieIdeal_oper_eq_linear_span', LieSubmodule.lieIdeal_oper_eq_linear_span']\n    rw [Set.ext_iff] at ih\n    simp only [SetLike.mem_coe, LieSubmodule.mem_toSubmodule] at ih\n    simp only [LieSubmodule.mem_top, ih, true_and]\n    apply le_antisymm\n    · exact coe_lowerCentralSeries_eq_int_aux _ _ L M k\n    · simp only [← ih]\n      exact coe_lowerCentralSeries_eq_int_aux _ _ L M k\n\n"}
{"name":"LieSubmodule.lcs_le_self","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nk : Nat\nN : LieSubmodule R L M\n⊢ LE.le (LieSubmodule.lcs k N) N","decl":"theorem lcs_le_self : N.lcs k ≤ N := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp only [lcs_succ]\n    exact (LieSubmodule.mono_lie_right ⊤ ih).trans (N.lie_le_right ⊤)\n\n"}
{"name":"LieSubmodule.lowerCentralSeries_eq_lcs_comap","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nk : Nat\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\n⊢ Eq (LieModule.lowerCentralSeries R L (Subtype fun x => Membership.mem N x) k) (LieSubmodule.comap N.incl (LieSubmodule.lcs k N))","decl":"theorem lowerCentralSeries_eq_lcs_comap : lowerCentralSeries R L N k = (N.lcs k).comap N.incl := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp only [lcs_succ, lowerCentralSeries_succ] at ih ⊢\n    have : N.lcs k ≤ N.incl.range := by\n      rw [N.range_incl]\n      apply lcs_le_self\n    rw [ih, LieSubmodule.comap_bracket_eq _ N.incl _ N.ker_incl this]\n\n"}
{"name":"LieSubmodule.lowerCentralSeries_map_eq_lcs","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nk : Nat\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.map N.incl (LieModule.lowerCentralSeries R L (Subtype fun x => Membership.mem N x) k)) (LieSubmodule.lcs k N)","decl":"theorem lowerCentralSeries_map_eq_lcs : (lowerCentralSeries R L N k).map N.incl = N.lcs k := by\n  rw [lowerCentralSeries_eq_lcs_comap, LieSubmodule.map_comap_incl, inf_eq_right]\n  apply lcs_le_self\n\n"}
{"name":"LieModule.antitone_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Antitone (LieModule.lowerCentralSeries R L M)","decl":"theorem antitone_lowerCentralSeries : Antitone <| lowerCentralSeries R L M := by\n  intro l k\n  induction k generalizing l with\n  | zero => exact fun h ↦ (Nat.le_zero.mp h).symm ▸ le_rfl\n  | succ k ih =>\n    intro h\n    rcases Nat.of_le_succ h with (hk | hk)\n    · rw [lowerCentralSeries_succ]\n      exact (LieSubmodule.mono_lie_right ⊤ (ih hk)).trans (LieSubmodule.lie_le_right _ _)\n    · exact hk.symm ▸ le_rfl\n\n"}
{"name":"LieModule.eventually_iInf_lowerCentralSeries_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsArtinian R M\n⊢ Filter.Eventually (fun l => Eq (iInf fun k => LieModule.lowerCentralSeries R L M k) (LieModule.lowerCentralSeries R L M l)) Filter.atTop","decl":"theorem eventually_iInf_lowerCentralSeries_eq [IsArtinian R M] :\n    ∀ᶠ l in Filter.atTop, ⨅ k, lowerCentralSeries R L M k = lowerCentralSeries R L M l := by\n  have h_wf : WellFoundedGT (LieSubmodule R L M)ᵒᵈ :=\n    LieSubmodule.wellFoundedLT_of_isArtinian R L M\n  obtain ⟨n, hn : ∀ m, n ≤ m → lowerCentralSeries R L M n = lowerCentralSeries R L M m⟩ :=\n    WellFounded.monotone_chain_condition.mp h_wf.wf ⟨_, antitone_lowerCentralSeries R L M⟩\n  refine Filter.eventually_atTop.mpr ⟨n, fun l hl ↦ le_antisymm (iInf_le _ _) (le_iInf fun m ↦ ?_)⟩\n  rcases le_or_lt l m with h | h\n  · rw [← hn _ hl, ← hn _ (hl.trans h)]\n  · exact antitone_lowerCentralSeries R L M (le_of_lt h)\n\n"}
{"name":"LieModule.trivial_iff_lower_central_eq_bot","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Iff (LieModule.IsTrivial L M) (Eq (LieModule.lowerCentralSeries R L M 1) Bot.bot)","decl":"theorem trivial_iff_lower_central_eq_bot : IsTrivial L M ↔ lowerCentralSeries R L M 1 = ⊥ := by\n  constructor <;> intro h\n  · simp\n  · rw [LieSubmodule.eq_bot_iff] at h; apply IsTrivial.mk; intro x m; apply h\n    apply LieSubmodule.subset_lieSpan\n    -- Porting note: was `use x, m; rfl`\n    simp only [LieSubmodule.top_coe, Subtype.exists, LieSubmodule.mem_top, exists_prop, true_and,\n      Set.mem_setOf]\n    exact ⟨x, m, rfl⟩\n\n"}
{"name":"LieModule.iterate_toEnd_mem_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nm : M\nk : Nat\n⊢ Membership.mem (LieModule.lowerCentralSeries R L M k) (Nat.iterate (⇑((LieModule.toEnd R L M) x)) k m)","decl":"theorem iterate_toEnd_mem_lowerCentralSeries (x : L) (m : M) (k : ℕ) :\n    (toEnd R L M x)^[k] m ∈ lowerCentralSeries R L M k := by\n  induction k with\n  | zero => simp only [Function.iterate_zero, lowerCentralSeries_zero, LieSubmodule.mem_top]\n  | succ k ih =>\n    simp only [lowerCentralSeries_succ, Function.comp_apply, Function.iterate_succ',\n      toEnd_apply_apply]\n    exact LieSubmodule.lie_mem_lie (LieSubmodule.mem_top x) ih\n\n"}
{"name":"LieModule.iterate_toEnd_mem_lowerCentralSeries₂","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nm : M\nk : Nat\n⊢ Membership.mem (LieModule.lowerCentralSeries R L M (HMul.hMul 2 k)) (Nat.iterate (⇑(LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y))) k m)","decl":"theorem iterate_toEnd_mem_lowerCentralSeries₂ (x y : L) (m : M) (k : ℕ) :\n    (toEnd R L M x ∘ₗ toEnd R L M y)^[k] m ∈\n      lowerCentralSeries R L M (2 * k) := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    have hk : 2 * k.succ = (2 * k + 1) + 1 := rfl\n    simp only [lowerCentralSeries_succ, Function.comp_apply, Function.iterate_succ', hk,\n      toEnd_apply_apply, LinearMap.coe_comp, toEnd_apply_apply]\n    refine LieSubmodule.lie_mem_lie (LieSubmodule.mem_top x) ?_\n    exact LieSubmodule.lie_mem_lie (LieSubmodule.mem_top y) ih\n\n"}
{"name":"LieModule.map_lowerCentralSeries_le","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\nk : Nat\nM₂ : Type w₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M₂\ninst✝² : LieRingModule L M₂\ninst✝¹ : LieModule R L M₂\ninst✝ : LieModule R L M\nf : LieModuleHom R L M M₂\n⊢ LE.le (LieSubmodule.map f (LieModule.lowerCentralSeries R L M k)) (LieModule.lowerCentralSeries R L M₂ k)","decl":"theorem map_lowerCentralSeries_le (f : M →ₗ⁅R,L⁆ M₂) :\n    (lowerCentralSeries R L M k).map f ≤ lowerCentralSeries R L M₂ k := by\n  induction k with\n  | zero => simp only [lowerCentralSeries_zero, le_top]\n  | succ k ih =>\n    simp only [LieModule.lowerCentralSeries_succ, LieSubmodule.map_bracket_eq]\n    exact LieSubmodule.mono_lie_right ⊤ ih\n\n"}
{"name":"LieModule.map_lowerCentralSeries_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\nk : Nat\nM₂ : Type w₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M₂\ninst✝² : LieRingModule L M₂\ninst✝¹ : LieModule R L M₂\ninst✝ : LieModule R L M\nf : LieModuleHom R L M M₂\nhf : Function.Surjective ⇑f\n⊢ Eq (LieSubmodule.map f (LieModule.lowerCentralSeries R L M k)) (LieModule.lowerCentralSeries R L M₂ k)","decl":"lemma map_lowerCentralSeries_eq {f : M →ₗ⁅R,L⁆ M₂} (hf : Function.Surjective f) :\n    (lowerCentralSeries R L M k).map f = lowerCentralSeries R L M₂ k := by\n  apply le_antisymm (map_lowerCentralSeries_le k f)\n  induction k with\n  | zero =>\n    rwa [lowerCentralSeries_zero, lowerCentralSeries_zero, top_le_iff, f.map_top,\n      f.range_eq_top]\n  | succ =>\n    simp only [lowerCentralSeries_succ, LieSubmodule.map_bracket_eq]\n    apply LieSubmodule.mono_lie_right\n    assumption\n\n"}
{"name":"LieModule.derivedSeries_le_lowerCentralSeries","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk : Nat\n⊢ LE.le (LieAlgebra.derivedSeries R L k) (LieModule.lowerCentralSeries R L L k)","decl":"theorem derivedSeries_le_lowerCentralSeries (k : ℕ) :\n    derivedSeries R L k ≤ lowerCentralSeries R L L k := by\n  induction k with\n  | zero => rw [derivedSeries_def, derivedSeriesOfIdeal_zero, lowerCentralSeries_zero]\n  | succ k h =>\n    have h' : derivedSeries R L k ≤ ⊤ := by simp only [le_top]\n    rw [derivedSeries_def, derivedSeriesOfIdeal_succ, lowerCentralSeries_succ]\n    exact LieSubmodule.mono_lie h' h\n\n"}
{"name":"LieModule.IsNilpotent.nilpotent_int","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nself : LieModule.IsNilpotent L M\n⊢ Exists fun k => Eq (LieModule.lowerCentralSeries Int L M k) Bot.bot","decl":"/-- A Lie module is nilpotent if its lower central series reaches 0 (in a finite number of\nsteps). -/\n@[mk_iff isNilpotent_iff_int]\nclass IsNilpotent : Prop where\n  mk_int ::\n  nilpotent_int : ∃ k, lowerCentralSeries ℤ L M k = ⊥\n\n"}
{"name":"LieModule.isNilpotent_iff_int","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ Iff (LieModule.IsNilpotent L M) (Exists fun k => Eq (LieModule.lowerCentralSeries Int L M k) Bot.bot)","decl":"/-- A Lie module is nilpotent if its lower central series reaches 0 (in a finite number of\nsteps). -/\n@[mk_iff isNilpotent_iff_int]\nclass IsNilpotent : Prop where\n  mk_int ::\n  nilpotent_int : ∃ k, lowerCentralSeries ℤ L M k = ⊥\n\n"}
{"name":"LieModule.isNilpotent_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent L M) (Exists fun k => Eq (LieModule.lowerCentralSeries R L M k) Bot.bot)","decl":"/-- See also `LieModule.isNilpotent_iff_exists_ucs_eq_top`. -/\nlemma isNilpotent_iff :\n    IsNilpotent L M ↔ ∃ k, lowerCentralSeries R L M k = ⊥ := by\n  simp [isNilpotent_iff_int, SetLike.ext'_iff, coe_lowerCentralSeries_eq_int R L M]\n\n"}
{"name":"LieModule.IsNilpotent.nilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Exists fun k => Eq (LieModule.lowerCentralSeries R L M k) Bot.bot","decl":"lemma IsNilpotent.nilpotent [IsNilpotent L M] : ∃ k, lowerCentralSeries R L M k = ⊥ :=\n  (isNilpotent_iff R L M).mp ‹_›\n\n"}
{"name":"LieModule.IsNilpotent.mk","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\nh : Eq (LieModule.lowerCentralSeries R L M k) Bot.bot\n⊢ LieModule.IsNilpotent L M","decl":"variable {R L} in\nlemma IsNilpotent.mk {k : ℕ} (h : lowerCentralSeries R L M k = ⊥) : IsNilpotent L M :=\n  (isNilpotent_iff R L M).mpr ⟨k, h⟩\n\n"}
{"name":"LieModule.exists_lowerCentralSeries_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Exists fun k => Eq (LieModule.lowerCentralSeries R L M k) Bot.bot","decl":"@[deprecated IsNilpotent.nilpotent (since := \"2025-01-07\")]\ntheorem exists_lowerCentralSeries_eq_bot_of_isNilpotent [IsNilpotent L M] :\n    ∃ k, lowerCentralSeries R L M k = ⊥ :=\n  IsNilpotent.nilpotent R L M\n\n"}
{"name":"LieModule.iInf_lowerCentralSeries_eq_bot_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Eq (iInf fun k => LieModule.lowerCentralSeries R L M k) Bot.bot","decl":"@[simp] lemma iInf_lowerCentralSeries_eq_bot_of_isNilpotent [IsNilpotent L M] :\n    ⨅ k, lowerCentralSeries R L M k = ⊥ := by\n  obtain ⟨k, hk⟩ := IsNilpotent.nilpotent R L M\n  rw [eq_bot_iff, ← hk]\n  exact iInf_le _ _\n\n"}
{"name":"LieSubmodule.isNilpotent_iff_exists_lcs_eq_bot","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\n⊢ Iff (LieModule.IsNilpotent L (Subtype fun x => Membership.mem N x)) (Exists fun k => Eq (LieSubmodule.lcs k N) Bot.bot)","decl":"theorem _root_.LieSubmodule.isNilpotent_iff_exists_lcs_eq_bot (N : LieSubmodule R L M) :\n    LieModule.IsNilpotent L N ↔ ∃ k, N.lcs k = ⊥ := by\n  rw [isNilpotent_iff R L N]\n  refine exists_congr fun k => ?_\n  rw [N.lowerCentralSeries_eq_lcs_comap k, LieSubmodule.comap_incl_eq_bot,\n    inf_eq_right.mpr (N.lcs_le_self k)]\n\n"}
{"name":"LieModule.trivialIsNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule.IsTrivial L M\n⊢ LieModule.IsNilpotent L M","decl":"instance (priority := 100) trivialIsNilpotent [IsTrivial L M] : IsNilpotent L M :=\n  ⟨by use 1; change ⁅⊤, ⊤⁆ = ⊥; simp⟩\n\n"}
{"name":"LieModule.exists_forall_pow_toEnd_eq_zero","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Exists fun k => ∀ (x : L), Eq (HPow.hPow ((LieModule.toEnd R L M) x) k) 0","decl":"theorem exists_forall_pow_toEnd_eq_zero [IsNilpotent L M] :\n    ∃ k : ℕ, ∀ x : L, toEnd R L M x ^ k = 0 := by\n  obtain ⟨k, hM⟩ := IsNilpotent.nilpotent R L M\n  use k\n  intro x; ext m\n  rw [LinearMap.pow_apply, LinearMap.zero_apply, ← @LieSubmodule.mem_bot R L M, ← hM]\n  exact iterate_toEnd_mem_lowerCentralSeries R L M x m k\n\n"}
{"name":"LieModule.isNilpotent_toEnd_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\nx : L\n⊢ IsNilpotent ((LieModule.toEnd R L M) x)","decl":"theorem isNilpotent_toEnd_of_isNilpotent [IsNilpotent L M] (x : L) :\n    _root_.IsNilpotent (toEnd R L M x) := by\n  change ∃ k, toEnd R L M x ^ k = 0\n  have := exists_forall_pow_toEnd_eq_zero R L M\n  tauto\n\n"}
{"name":"LieModule.isNilpotent_toEnd_of_isNilpotent₂","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\nx y : L\n⊢ IsNilpotent (LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y))","decl":"theorem isNilpotent_toEnd_of_isNilpotent₂ [IsNilpotent L M] (x y : L) :\n    _root_.IsNilpotent (toEnd R L M x ∘ₗ toEnd R L M y) := by\n  obtain ⟨k, hM⟩ := IsNilpotent.nilpotent R L M\n  replace hM : lowerCentralSeries R L M (2 * k) = ⊥ := by\n    rw [eq_bot_iff, ← hM]; exact antitone_lowerCentralSeries R L M (by omega)\n  use k\n  ext m\n  rw [LinearMap.pow_apply, LinearMap.zero_apply, ← LieSubmodule.mem_bot (R := R) (L := L), ← hM]\n  exact iterate_toEnd_mem_lowerCentralSeries₂ R L M x y m k\n\n"}
{"name":"LieModule.maxGenEigenSpace_toEnd_eq_top","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\nx : L\n⊢ Eq (((LieModule.toEnd R L M) x).maxGenEigenspace 0) Top.top","decl":"@[simp] lemma maxGenEigenSpace_toEnd_eq_top [IsNilpotent L M] (x : L) :\n    ((toEnd R L M x).maxGenEigenspace 0) = ⊤ := by\n  ext m\n  simp only [Module.End.mem_maxGenEigenspace, zero_smul, sub_zero, Submodule.mem_top,\n    iff_true]\n  obtain ⟨k, hk⟩ := exists_forall_pow_toEnd_eq_zero R L M\n  exact ⟨k, by simp [hk x]⟩\n\n"}
{"name":"LieModule.nilpotentOfNilpotentQuotient","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nh₁ : LE.le N (LieModule.maxTrivSubmodule R L M)\nh₂ : LieModule.IsNilpotent L (HasQuotient.Quotient M N)\n⊢ LieModule.IsNilpotent L M","decl":"/-- If the quotient of a Lie module `M` by a Lie submodule on which the Lie algebra acts trivially\nis nilpotent then `M` is nilpotent.\n\nThis is essentially the Lie module equivalent of the fact that a central\nextension of nilpotent Lie algebras is nilpotent. See `LieAlgebra.nilpotent_of_nilpotent_quotient`\nbelow for the corresponding result for Lie algebras. -/\ntheorem nilpotentOfNilpotentQuotient {N : LieSubmodule R L M} (h₁ : N ≤ maxTrivSubmodule R L M)\n    (h₂ : IsNilpotent L (M ⧸ N)) : IsNilpotent L M := by\n  rw [isNilpotent_iff R L] at h₂ ⊢\n  obtain ⟨k, hk⟩ := h₂\n  use k + 1\n  simp only [lowerCentralSeries_succ]\n  suffices lowerCentralSeries R L M k ≤ N by\n    replace this := LieSubmodule.mono_lie_right ⊤ (le_trans this h₁)\n    rwa [ideal_oper_maxTrivSubmodule_eq_bot, le_bot_iff] at this\n  rw [← LieSubmodule.Quotient.map_mk'_eq_bot_le, ← le_bot_iff, ← hk]\n  exact map_lowerCentralSeries_le k (LieSubmodule.Quotient.mk' N)\n\n"}
{"name":"LieModule.isNilpotent_quotient_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent L (HasQuotient.Quotient M N)) (Exists fun k => LE.le (LieModule.lowerCentralSeries R L M k) N)","decl":"theorem isNilpotent_quotient_iff :\n    IsNilpotent L (M ⧸ N) ↔ ∃ k, lowerCentralSeries R L M k ≤ N := by\n  rw [isNilpotent_iff R L]\n  refine exists_congr fun k ↦ ?_\n  rw [← LieSubmodule.Quotient.map_mk'_eq_bot_le, map_lowerCentralSeries_eq k\n    (LieSubmodule.Quotient.surjective_mk' N)]\n\n"}
{"name":"LieModule.iInf_lcs_le_of_isNilpotent_quot","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\nh : LieModule.IsNilpotent L (HasQuotient.Quotient M N)\n⊢ LE.le (iInf fun k => LieModule.lowerCentralSeries R L M k) N","decl":"theorem iInf_lcs_le_of_isNilpotent_quot (h : IsNilpotent L (M ⧸ N)) :\n    ⨅ k, lowerCentralSeries R L M k ≤ N := by\n  obtain ⟨k, hk⟩ := (isNilpotent_quotient_iff R L M N).mp h\n  exact iInf_le_of_le k hk\n\n"}
{"name":"LieModule.nilpotencyLength_eq_zero_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Iff (Eq (LieModule.nilpotencyLength L M) 0) (Subsingleton M)","decl":"@[simp]\ntheorem nilpotencyLength_eq_zero_iff [IsNilpotent L M] :\n    nilpotencyLength L M = 0 ↔ Subsingleton M := by\n  let s := {k | lowerCentralSeries ℤ L M k = ⊥}\n  have hs : s.Nonempty := by\n    obtain ⟨k, hk⟩ := IsNilpotent.nilpotent ℤ L M\n    exact ⟨k, hk⟩\n  change sInf s = 0 ↔ _\n  rw [← LieSubmodule.subsingleton_iff ℤ L M, ← subsingleton_iff_bot_eq_top, ←\n    lowerCentralSeries_zero, @eq_comm (LieSubmodule ℤ L M)]\n  refine ⟨fun h => h ▸ Nat.sInf_mem hs, fun h => ?_⟩\n  rw [Nat.sInf_eq_zero]\n  exact Or.inl h\n\n"}
{"name":"LieModule.nilpotencyLength_eq_succ_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Iff (Eq (LieModule.nilpotencyLength L M) (HAdd.hAdd k 1)) (And (Eq (LieModule.lowerCentralSeries R L M (HAdd.hAdd k 1)) Bot.bot) (Ne (LieModule.lowerCentralSeries R L M k) Bot.bot))","decl":"theorem nilpotencyLength_eq_succ_iff (k : ℕ) :\n    nilpotencyLength L M = k + 1 ↔\n      lowerCentralSeries R L M (k + 1) = ⊥ ∧ lowerCentralSeries R L M k ≠ ⊥ := by\n  have aux (k : ℕ) : lowerCentralSeries R L M k = ⊥ ↔ lowerCentralSeries ℤ L M k = ⊥ := by\n    simp [SetLike.ext'_iff, coe_lowerCentralSeries_eq_int R L M]\n  let s := {k | lowerCentralSeries ℤ L M k = ⊥}\n  rw [aux, ne_eq, aux]\n  change sInf s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s\n  have hs : ∀ k₁ k₂, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s := by\n    rintro k₁ k₂ h₁₂ (h₁ : lowerCentralSeries ℤ L M k₁ = ⊥)\n    exact eq_bot_iff.mpr (h₁ ▸ antitone_lowerCentralSeries ℤ L M h₁₂)\n  exact Nat.sInf_upward_closed_eq_succ_iff hs k\n\n"}
{"name":"LieModule.nilpotencyLength_eq_one_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : Nontrivial M\n⊢ Iff (Eq (LieModule.nilpotencyLength L M) 1) (LieModule.IsTrivial L M)","decl":"@[simp]\ntheorem nilpotencyLength_eq_one_iff [Nontrivial M] :\n    nilpotencyLength L M = 1 ↔ IsTrivial L M := by\n  rw [nilpotencyLength_eq_succ_iff ℤ, ← trivial_iff_lower_central_eq_bot]\n  simp\n\n"}
{"name":"LieModule.isTrivial_of_nilpotencyLength_le_one","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\nM : Type w\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule.IsNilpotent L M\nh : LE.le (LieModule.nilpotencyLength L M) 1\n⊢ LieModule.IsTrivial L M","decl":"theorem isTrivial_of_nilpotencyLength_le_one [IsNilpotent L M] (h : nilpotencyLength L M ≤ 1) :\n    IsTrivial L M := by\n  nontriviality M\n  cases' Nat.le_one_iff_eq_zero_or_eq_one.mp h with h h\n  · rw [nilpotencyLength_eq_zero_iff] at h; infer_instance\n  · rwa [nilpotencyLength_eq_one_iff] at h\n\n"}
{"name":"LieModule.lowerCentralSeriesLast_le_max_triv","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LE.le (LieModule.lowerCentralSeriesLast R L M) (LieModule.maxTrivSubmodule R L M)","decl":"theorem lowerCentralSeriesLast_le_max_triv [LieModule R L M] :\n    lowerCentralSeriesLast R L M ≤ maxTrivSubmodule R L M := by\n  rw [lowerCentralSeriesLast]\n  cases' h : nilpotencyLength L M with k\n  · exact bot_le\n  · rw [le_max_triv_iff_bracket_eq_bot]\n    rw [nilpotencyLength_eq_succ_iff R, lowerCentralSeries_succ] at h\n    exact h.1\n\n"}
{"name":"LieModule.nontrivial_lowerCentralSeriesLast","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : Nontrivial M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Nontrivial (Subtype fun x => Membership.mem (LieModule.lowerCentralSeriesLast R L M) x)","decl":"theorem nontrivial_lowerCentralSeriesLast [LieModule R L M] [Nontrivial M] [IsNilpotent L M] :\n    Nontrivial (lowerCentralSeriesLast R L M) := by\n  rw [LieSubmodule.nontrivial_iff_ne_bot, lowerCentralSeriesLast]\n  cases h : nilpotencyLength L M\n  · rw [nilpotencyLength_eq_zero_iff, ← not_nontrivial_iff_subsingleton] at h\n    contradiction\n  · rw [nilpotencyLength_eq_succ_iff R] at h\n    exact h.2\n\n"}
{"name":"LieModule.lowerCentralSeriesLast_le_of_not_isTrivial","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule.IsNilpotent L M\nh : Not (LieModule.IsTrivial L M)\n⊢ LE.le (LieModule.lowerCentralSeriesLast R L M) (LieModule.lowerCentralSeries R L M 1)","decl":"theorem lowerCentralSeriesLast_le_of_not_isTrivial [IsNilpotent L M] (h : ¬ IsTrivial L M) :\n    lowerCentralSeriesLast R L M ≤ lowerCentralSeries R L M 1 := by\n  rw [lowerCentralSeriesLast]\n  replace h : 1 < nilpotencyLength L M := by\n    by_contra contra\n    have := isTrivial_of_nilpotencyLength_le_one L M (not_lt.mp contra)\n    contradiction\n  cases' hk : nilpotencyLength L M with k <;> rw [hk] at h\n  · contradiction\n  · exact antitone_lowerCentralSeries _ _ _ (Nat.lt_succ.mp h)\n\n"}
{"name":"LieModule.disjoint_lowerCentralSeries_maxTrivSubmodule_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Iff (Disjoint (LieModule.lowerCentralSeries R L M 1) (LieModule.maxTrivSubmodule R L M)) (LieModule.IsTrivial L M)","decl":"/-- For a nilpotent Lie module `M` of a Lie algebra `L`, the first term in the lower central series\nof `M` contains a non-zero element on which `L` acts trivially unless the entire action is trivial.\n\nTaking `M = L`, this provides a useful characterisation of Abelian-ness for nilpotent Lie\nalgebras. -/\nlemma disjoint_lowerCentralSeries_maxTrivSubmodule_iff [IsNilpotent L M] :\n    Disjoint (lowerCentralSeries R L M 1) (maxTrivSubmodule R L M) ↔ IsTrivial L M := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by simp⟩\n  nontriviality M\n  by_contra contra\n  have : lowerCentralSeriesLast R L M ≤ lowerCentralSeries R L M 1 ⊓ maxTrivSubmodule R L M :=\n    le_inf_iff.mpr ⟨lowerCentralSeriesLast_le_of_not_isTrivial R L M contra,\n      lowerCentralSeriesLast_le_max_triv R L M⟩\n  suffices ¬ Nontrivial (lowerCentralSeriesLast R L M) by\n    exact this (nontrivial_lowerCentralSeriesLast R L M)\n  rw [h.eq_bot, le_bot_iff] at this\n  exact this ▸ not_nontrivial _\n\n"}
{"name":"LieModule.nontrivial_max_triv_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : Nontrivial M\ninst✝ : LieModule.IsNilpotent L M\n⊢ Nontrivial (Subtype fun x => Membership.mem (LieModule.maxTrivSubmodule R L M) x)","decl":"theorem nontrivial_max_triv_of_isNilpotent [Nontrivial M] [IsNilpotent L M] :\n    Nontrivial (maxTrivSubmodule R L M) :=\n  Set.nontrivial_mono (lowerCentralSeriesLast_le_max_triv R L M)\n    (nontrivial_lowerCentralSeriesLast R L M)\n\n"}
{"name":"LieModule.coe_lcs_range_toEnd_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Eq ↑(LieModule.lowerCentralSeries R (Subtype fun x => Membership.mem (LieModule.toEnd R L M).range x) M k) ↑(LieModule.lowerCentralSeries R L M k)","decl":"@[simp]\ntheorem coe_lcs_range_toEnd_eq (k : ℕ) :\n    (lowerCentralSeries R (toEnd R L M).range M k : Submodule R M) =\n      lowerCentralSeries R L M k := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp only [lowerCentralSeries_succ, LieSubmodule.lieIdeal_oper_eq_linear_span', ←\n      (lowerCentralSeries R (toEnd R L M).range M k).mem_toSubmodule, ih]\n    congr\n    ext m\n    constructor\n    · rintro ⟨⟨-, ⟨y, rfl⟩⟩, -, n, hn, rfl⟩\n      exact ⟨y, LieSubmodule.mem_top _, n, hn, rfl⟩\n    · rintro ⟨x, -, n, hn, rfl⟩\n      exact\n        ⟨⟨toEnd R L M x, LieHom.mem_range_self _ x⟩, LieSubmodule.mem_top _, n, hn, rfl⟩\n\n"}
{"name":"LieModule.isNilpotent_range_toEnd_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent (Subtype fun x => Membership.mem (LieModule.toEnd R L M).range x) M) (LieModule.IsNilpotent L M)","decl":"@[simp]\ntheorem isNilpotent_range_toEnd_iff :\n    IsNilpotent (toEnd R L M).range M ↔ IsNilpotent L M := by\n  simp only [isNilpotent_iff R _ M]\n  constructor <;> rintro ⟨k, hk⟩ <;> use k <;>\n      rw [← LieSubmodule.toSubmodule_inj] at hk ⊢ <;>\n    simpa using hk\n\n"}
{"name":"LieSubmodule.ucs_zero","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.ucs 0 N) N","decl":"@[simp]\ntheorem ucs_zero : N.ucs 0 = N :=\n  rfl\n\n"}
{"name":"LieSubmodule.ucs_succ","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Eq (LieSubmodule.ucs (HAdd.hAdd k 1) N) (LieSubmodule.ucs k N).normalizer","decl":"@[simp]\ntheorem ucs_succ (k : ℕ) : N.ucs (k + 1) = (N.ucs k).normalizer :=\n  Function.iterate_succ_apply' normalizer k N\n\n"}
{"name":"LieSubmodule.ucs_add","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\nk l : Nat\n⊢ Eq (LieSubmodule.ucs (HAdd.hAdd k l) N) (LieSubmodule.ucs k (LieSubmodule.ucs l N))","decl":"theorem ucs_add (k l : ℕ) : N.ucs (k + l) = (N.ucs l).ucs k :=\n  Function.iterate_add_apply normalizer k l N\n\n"}
{"name":"LieSubmodule.ucs_mono","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN₁ N₂ : LieSubmodule R L M\ninst✝ : LieModule R L M\nk : Nat\nh : LE.le N₁ N₂\n⊢ LE.le (LieSubmodule.ucs k N₁) (LieSubmodule.ucs k N₂)","decl":"@[gcongr, mono]\ntheorem ucs_mono (k : ℕ) (h : N₁ ≤ N₂) : N₁.ucs k ≤ N₂.ucs k := by\n  induction k with\n  | zero => simpa\n  | succ k ih =>\n    simp only [ucs_succ]\n    gcongr\n\n"}
{"name":"LieSubmodule.ucs_eq_self_of_normalizer_eq_self","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN₁ : LieSubmodule R L M\ninst✝ : LieModule R L M\nh : Eq N₁.normalizer N₁\nk : Nat\n⊢ Eq (LieSubmodule.ucs k N₁) N₁","decl":"theorem ucs_eq_self_of_normalizer_eq_self (h : N₁.normalizer = N₁) (k : ℕ) : N₁.ucs k = N₁ := by\n  induction k with\n  | zero => simp\n  | succ k ih => rwa [ucs_succ, ih]\n\n"}
{"name":"LieSubmodule.ucs_le_of_normalizer_eq_self","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN₁ : LieSubmodule R L M\ninst✝ : LieModule R L M\nh : Eq N₁.normalizer N₁\nk : Nat\n⊢ LE.le (LieSubmodule.ucs k Bot.bot) N₁","decl":"/-- If a Lie module `M` contains a self-normalizing Lie submodule `N`, then all terms of the upper\ncentral series of `M` are contained in `N`.\n\nAn important instance of this situation arises from a Cartan subalgebra `H ⊆ L` with the roles of\n`L`, `M`, `N` played by `H`, `L`, `H`, respectively. -/\ntheorem ucs_le_of_normalizer_eq_self (h : N₁.normalizer = N₁) (k : ℕ) :\n    (⊥ : LieSubmodule R L M).ucs k ≤ N₁ := by\n  rw [← ucs_eq_self_of_normalizer_eq_self h k]\n  gcongr\n  simp\n\n"}
{"name":"LieSubmodule.lcs_add_le_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN₁ N₂ : LieSubmodule R L M\ninst✝ : LieModule R L M\nl k : Nat\n⊢ Iff (LE.le (LieSubmodule.lcs (HAdd.hAdd l k) N₁) N₂) (LE.le (LieSubmodule.lcs l N₁) (LieSubmodule.ucs k N₂))","decl":"theorem lcs_add_le_iff (l k : ℕ) : N₁.lcs (l + k) ≤ N₂ ↔ N₁.lcs l ≤ N₂.ucs k := by\n  induction k generalizing l with\n  | zero => simp\n  | succ k ih =>\n    rw [(by abel : l + (k + 1) = l + 1 + k), ih, ucs_succ, lcs_succ, top_lie_le_iff_le_normalizer]\n\n"}
{"name":"LieSubmodule.lcs_le_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN₁ N₂ : LieSubmodule R L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Iff (LE.le (LieSubmodule.lcs k N₁) N₂) (LE.le N₁ (LieSubmodule.ucs k N₂))","decl":"theorem lcs_le_iff (k : ℕ) : N₁.lcs k ≤ N₂ ↔ N₁ ≤ N₂.ucs k := by\n  -- Porting note: `convert` needed type annotations\n  convert lcs_add_le_iff (R := R) (L := L) (M := M) 0 k\n  rw [zero_add]\n\n"}
{"name":"LieSubmodule.gc_lcs_ucs","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ GaloisConnection (fun N => LieSubmodule.lcs k N) fun N => LieSubmodule.ucs k N","decl":"theorem gc_lcs_ucs (k : ℕ) :\n    GaloisConnection (fun N : LieSubmodule R L M => N.lcs k) fun N : LieSubmodule R L M =>\n      N.ucs k :=\n  fun _ _ => lcs_le_iff k\n\n"}
{"name":"LieSubmodule.ucs_eq_top_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Iff (Eq (LieSubmodule.ucs k N) Top.top) (LE.le (LieModule.lowerCentralSeries R L M k) N)","decl":"theorem ucs_eq_top_iff (k : ℕ) : N.ucs k = ⊤ ↔ LieModule.lowerCentralSeries R L M k ≤ N := by\n  rw [eq_top_iff, ← lcs_le_iff]; rfl\n\n"}
{"name":"LieModule.isNilpotent_iff_exists_ucs_eq_top","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent L M) (Exists fun k => Eq (LieSubmodule.ucs k Bot.bot) Top.top)","decl":"variable (R) in\ntheorem _root_.LieModule.isNilpotent_iff_exists_ucs_eq_top :\n    LieModule.IsNilpotent L M ↔ ∃ k, (⊥ : LieSubmodule R L M).ucs k = ⊤ := by\n  rw [LieModule.isNilpotent_iff R]; exact exists_congr fun k => by simp [ucs_eq_top_iff]\n\n"}
{"name":"LieSubmodule.ucs_comap_incl","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\nk : Nat\n⊢ Eq (LieSubmodule.comap N.incl (LieSubmodule.ucs k Bot.bot)) (LieSubmodule.ucs k Bot.bot)","decl":"theorem ucs_comap_incl (k : ℕ) :\n    ((⊥ : LieSubmodule R L M).ucs k).comap N.incl = (⊥ : LieSubmodule R L N).ucs k := by\n  induction k with\n  | zero => exact N.ker_incl\n  | succ k ih => simp [← ih]\n\n"}
{"name":"LieSubmodule.isNilpotent_iff_exists_self_le_ucs","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent L (Subtype fun x => Membership.mem N x)) (Exists fun k => LE.le N (LieSubmodule.ucs k Bot.bot))","decl":"theorem isNilpotent_iff_exists_self_le_ucs :\n    LieModule.IsNilpotent L N ↔ ∃ k, N ≤ (⊥ : LieSubmodule R L M).ucs k := by\n  simp_rw [LieModule.isNilpotent_iff_exists_ucs_eq_top R, ← ucs_comap_incl, comap_incl_eq_top]\n\n"}
{"name":"LieSubmodule.ucs_bot_one","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.ucs 1 Bot.bot) (LieModule.maxTrivSubmodule R L M)","decl":"theorem ucs_bot_one : (⊥ : LieSubmodule R L M).ucs 1 = LieModule.maxTrivSubmodule R L M := by\n  simp [LieSubmodule.normalizer_bot_eq_maxTrivSubmodule]\n\n"}
{"name":"Function.Surjective.lieModule_lcs_map_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹² : CommRing R\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : LieAlgebra R L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieModule R L M\nL₂ : Type u_1\nM₂ : Type u_2\ninst✝⁵ : LieRing L₂\ninst✝⁴ : LieAlgebra R L₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L₂ M₂\ninst✝ : LieModule R L₂ M₂\nf : LieHom R L L₂\ng : LinearMap (RingHom.id R) M M₂\nhf : Function.Surjective ⇑f\nhg : Function.Surjective ⇑g\nhfg : ∀ (x : L) (m : M), Eq (Bracket.bracket (f x) (g m)) (g (Bracket.bracket x m))\nk : Nat\n⊢ Eq (Submodule.map g ↑(LieModule.lowerCentralSeries R L M k)) ↑(LieModule.lowerCentralSeries R L₂ M₂ k)","decl":"include hf hg hfg in\ntheorem Function.Surjective.lieModule_lcs_map_eq (k : ℕ) :\n    (lowerCentralSeries R L M k : Submodule R M).map g = lowerCentralSeries R L₂ M₂ k := by\n  induction k with\n  | zero => simpa [LinearMap.range_eq_top]\n  | succ k ih =>\n    suffices\n      g '' {m | ∃ (x : L) (n : _), n ∈ lowerCentralSeries R L M k ∧ ⁅x, n⁆ = m} =\n        {m | ∃ (x : L₂) (n : _), n ∈ lowerCentralSeries R L M k ∧ ⁅x, g n⁆ = m} by\n      simp only [← LieSubmodule.mem_toSubmodule] at this\n      -- Porting note: was\n      -- simp [← LieSubmodule.mem_toSubmodule, ← ih, LieSubmodule.lieIdeal_oper_eq_linear_span',\n      --   Submodule.map_span, -Submodule.span_image, this,\n      --   -LieSubmodule.mem_toSubmodule]\n      simp_rw [lowerCentralSeries_succ, LieSubmodule.lieIdeal_oper_eq_linear_span',\n        Submodule.map_span, LieSubmodule.mem_top, true_and, ← LieSubmodule.mem_toSubmodule, this,\n        ← ih, Submodule.mem_map, exists_exists_and_eq_and]\n    ext m₂\n    constructor\n    · rintro ⟨m, ⟨x, n, hn, rfl⟩, rfl⟩\n      exact ⟨f x, n, hn, hfg x n⟩\n    · rintro ⟨x, n, hn, rfl⟩\n      obtain ⟨y, rfl⟩ := hf x\n      exact ⟨⁅y, n⁆, ⟨y, n, hn, rfl⟩, (hfg y n).symm⟩\n\n"}
{"name":"Function.Surjective.lieModuleIsNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹³ : CommRing R\ninst✝¹² : LieRing L\ninst✝¹¹ : LieAlgebra R L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : LieModule R L M\nL₂ : Type u_1\nM₂ : Type u_2\ninst✝⁶ : LieRing L₂\ninst✝⁵ : LieAlgebra R L₂\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M₂\ninst✝² : LieRingModule L₂ M₂\ninst✝¹ : LieModule R L₂ M₂\nf : LieHom R L L₂\ng : LinearMap (RingHom.id R) M M₂\nhf : Function.Surjective ⇑f\nhg : Function.Surjective ⇑g\nhfg : ∀ (x : L) (m : M), Eq (Bracket.bracket (f x) (g m)) (g (Bracket.bracket x m))\ninst✝ : LieModule.IsNilpotent L M\n⊢ LieModule.IsNilpotent L₂ M₂","decl":"include hf hg hfg in\ntheorem Function.Surjective.lieModuleIsNilpotent [IsNilpotent L M] : IsNilpotent L₂ M₂ := by\n  obtain ⟨k, hk⟩ := IsNilpotent.nilpotent R L M\n  rw [isNilpotent_iff R]\n  use k\n  rw [← LieSubmodule.toSubmodule_inj] at hk ⊢\n  simp [← hf.lieModule_lcs_map_eq hg hfg k, hk]\n\n"}
{"name":"Equiv.lieModule_isNilpotent_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹² : CommRing R\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : LieAlgebra R L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieModule R L M\nL₂ : Type u_1\nM₂ : Type u_2\ninst✝⁵ : LieRing L₂\ninst✝⁴ : LieAlgebra R L₂\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L₂ M₂\ninst✝ : LieModule R L₂ M₂\nf : LieEquiv R L L₂\ng : LinearEquiv (RingHom.id R) M M₂\nhfg : ∀ (x : L) (m : M), Eq (Bracket.bracket (f x) (g m)) (g (Bracket.bracket x m))\n⊢ Iff (LieModule.IsNilpotent L M) (LieModule.IsNilpotent L₂ M₂)","decl":"theorem Equiv.lieModule_isNilpotent_iff (f : L ≃ₗ⁅R⁆ L₂) (g : M ≃ₗ[R] M₂)\n    (hfg : ∀ x m, ⁅f x, g m⁆ = g ⁅x, m⁆) : IsNilpotent L M ↔ IsNilpotent L₂ M₂ := by\n  constructor <;> intro h\n  · have hg : Surjective (g : M →ₗ[R] M₂) := g.surjective\n    exact f.surjective.lieModuleIsNilpotent hg hfg\n  · have hg : Surjective (g.symm : M₂ →ₗ[R] M) := g.symm.surjective\n    refine f.symm.surjective.lieModuleIsNilpotent hg fun x m => ?_\n    rw [LinearEquiv.coe_coe, LieEquiv.coe_toLieHom, ← g.symm_apply_apply ⁅f.symm x, g.symm m⁆, ←\n      hfg, f.apply_symm_apply, g.apply_symm_apply]\n\n"}
{"name":"LieModule.isNilpotent_of_top_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent (Subtype fun x => Membership.mem Top.top x) M) (LieModule.IsNilpotent L M)","decl":"@[simp]\ntheorem LieModule.isNilpotent_of_top_iff :\n    IsNilpotent (⊤ : LieSubalgebra R L) M ↔ IsNilpotent L M :=\n  Equiv.lieModule_isNilpotent_iff LieSubalgebra.topEquiv (1 : M ≃ₗ[R] M) fun _ _ => rfl\n\n"}
{"name":"LieModule.isNilpotent_of_top_iff'","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Iff (LieModule.IsNilpotent L (Subtype fun x => Membership.mem Top.top x)) (LieModule.IsNilpotent L M)","decl":"@[simp] lemma LieModule.isNilpotent_of_top_iff' :\n    IsNilpotent L {x // x ∈ (⊤ : LieSubmodule R L M)} ↔ IsNilpotent L M :=\n  Equiv.lieModule_isNilpotent_iff 1 (LinearEquiv.ofTop ⊤ rfl) fun _ _ ↦ rfl\n\n"}
{"name":"LieAlgebra.isSolvable_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"L : Type v\ninst✝ : LieRing L\nhL : LieModule.IsNilpotent L L\n⊢ LieAlgebra.IsSolvable L","decl":"instance (priority := 100) LieAlgebra.isSolvable_of_isNilpotent (L : Type v)\n    [LieRing L] [hL : LieModule.IsNilpotent L L] :\n    LieAlgebra.IsSolvable L := by\n  obtain ⟨k, h⟩ : ∃ k, LieModule.lowerCentralSeries ℤ L L k = ⊥ := hL.nilpotent_int\n  use k; rw [← le_bot_iff] at h ⊢\n  exact le_trans (LieModule.derivedSeries_le_lowerCentralSeries ℤ L k) h\n\n"}
{"name":"LieAlgebra.nilpotent_ad_of_nilpotent_algebra","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieRing.IsNilpotent L\n⊢ Exists fun k => ∀ (x : L), Eq (HPow.hPow ((LieAlgebra.ad R L) x) k) 0","decl":"theorem LieAlgebra.nilpotent_ad_of_nilpotent_algebra [IsNilpotent L] :\n    ∃ k : ℕ, ∀ x : L, ad R L x ^ k = 0 :=\n  LieModule.exists_forall_pow_toEnd_eq_zero R L L\n\n-- TODO Generalise the below to Lie modules if / when we define morphisms, equivs of Lie modules\n-- covering a Lie algebra morphism of (possibly different) Lie algebras.\n"}
{"name":"coe_lowerCentralSeries_ideal_quot_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Eq ↑(LieModule.lowerCentralSeries R L (HasQuotient.Quotient L I) k) ↑(LieModule.lowerCentralSeries R (HasQuotient.Quotient L I) (HasQuotient.Quotient L I) k)","decl":"/-- Given an ideal `I` of a Lie algebra `L`, the lower central series of `L ⧸ I` is the same\nwhether we regard `L ⧸ I` as an `L` module or an `L ⧸ I` module.\n\nTODO: This result obviously generalises but the generalisation requires the missing definition of\nmorphisms between Lie modules over different Lie algebras. -/\n-- Porting note: added `LieSubmodule.toSubmodule` in the statement\ntheorem coe_lowerCentralSeries_ideal_quot_eq {I : LieIdeal R L} (k : ℕ) :\n    LieSubmodule.toSubmodule (lowerCentralSeries R L (L ⧸ I) k) =\n      LieSubmodule.toSubmodule (lowerCentralSeries R (L ⧸ I) (L ⧸ I) k) := by\n  induction k with\n  | zero =>\n    simp only [LieModule.lowerCentralSeries_zero, LieSubmodule.top_toSubmodule,\n      LieIdeal.top_toLieSubalgebra, LieSubalgebra.top_toSubmodule]\n  | succ k ih =>\n    simp only [LieModule.lowerCentralSeries_succ, LieSubmodule.lieIdeal_oper_eq_linear_span]\n    congr\n    ext x\n    constructor\n    · rintro ⟨⟨y, -⟩, ⟨z, hz⟩, rfl : ⁅y, z⁆ = x⟩\n      rw [← LieSubmodule.mem_toSubmodule, ih, LieSubmodule.mem_toSubmodule] at hz\n      exact ⟨⟨LieSubmodule.Quotient.mk y, LieSubmodule.mem_top _⟩, ⟨z, hz⟩, rfl⟩\n    · rintro ⟨⟨⟨y⟩, -⟩, ⟨z, hz⟩, rfl : ⁅y, z⁆ = x⟩\n      rw [← LieSubmodule.mem_toSubmodule, ← ih, LieSubmodule.mem_toSubmodule] at hz\n      exact ⟨⟨y, LieSubmodule.mem_top _⟩, ⟨z, hz⟩, rfl⟩\n\n"}
{"name":"LieModule.coe_lowerCentralSeries_ideal_le","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ LE.le ↑(LieModule.lowerCentralSeries R (Subtype fun x => Membership.mem I x) (Subtype fun x => Membership.mem I x) k) ↑(LieModule.lowerCentralSeries R L (Subtype fun x => Membership.mem I x) k)","decl":"/-- Note that the below inequality can be strict. For example the ideal of strictly-upper-triangular\n2x2 matrices inside the Lie algebra of upper-triangular 2x2 matrices with `k = 1`. -/\n-- Porting note: added `LieSubmodule.toSubmodule` in the statement\ntheorem LieModule.coe_lowerCentralSeries_ideal_le {I : LieIdeal R L} (k : ℕ) :\n    LieSubmodule.toSubmodule (lowerCentralSeries R I I k) ≤ lowerCentralSeries R L I k := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp only [LieModule.lowerCentralSeries_succ, LieSubmodule.lieIdeal_oper_eq_linear_span]\n    apply Submodule.span_mono\n    rintro x ⟨⟨y, -⟩, ⟨z, hz⟩, rfl : ⁅y, z⁆ = x⟩\n    exact ⟨⟨y.val, LieSubmodule.mem_top _⟩, ⟨z, ih hz⟩, rfl⟩\n\n"}
{"name":"LieAlgebra.nilpotent_of_nilpotent_quotient","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nh₁ : LE.le I (LieAlgebra.center R L)\nh₂ : LieRing.IsNilpotent (HasQuotient.Quotient L I)\n⊢ LieRing.IsNilpotent L","decl":"/-- A central extension of nilpotent Lie algebras is nilpotent. -/\ntheorem LieAlgebra.nilpotent_of_nilpotent_quotient {I : LieIdeal R L} (h₁ : I ≤ center R L)\n    (h₂ : IsNilpotent (L ⧸ I)) : IsNilpotent L := by\n  suffices LieModule.IsNilpotent L (L ⧸ I) by\n    exact LieModule.nilpotentOfNilpotentQuotient R L L h₁ this\n  simp only [LieRing.IsNilpotent, LieModule.isNilpotent_iff R] at h₂ ⊢\n  peel h₂ with k hk\n  simp [← LieSubmodule.toSubmodule_inj, coe_lowerCentralSeries_ideal_quot_eq, hk]\n\n"}
{"name":"LieAlgebra.non_trivial_center_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : Nontrivial L\ninst✝ : LieRing.IsNilpotent L\n⊢ Nontrivial (Subtype fun x => Membership.mem (LieAlgebra.center R L) x)","decl":"theorem LieAlgebra.non_trivial_center_of_isNilpotent [Nontrivial L] [IsNilpotent L] :\n    Nontrivial <| center R L :=\n  LieModule.nontrivial_max_triv_of_isNilpotent R L L\n\n"}
{"name":"LieIdeal.map_lowerCentralSeries_le","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nk : Nat\nf : LieHom R L L'\n⊢ LE.le (LieIdeal.map f (LieModule.lowerCentralSeries R L L k)) (LieModule.lowerCentralSeries R L' L' k)","decl":"theorem LieIdeal.map_lowerCentralSeries_le (k : ℕ) {f : L →ₗ⁅R⁆ L'} :\n    LieIdeal.map f (lowerCentralSeries R L L k) ≤ lowerCentralSeries R L' L' k := by\n  induction k with\n  | zero => simp only [LieModule.lowerCentralSeries_zero, le_top]\n  | succ k ih =>\n    simp only [LieModule.lowerCentralSeries_succ]\n    exact le_trans (LieIdeal.map_bracket_le f) (LieSubmodule.mono_lie le_top ih)\n\n"}
{"name":"LieIdeal.lowerCentralSeries_map_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nk : Nat\nf : LieHom R L L'\nh : Function.Surjective ⇑f\n⊢ Eq (LieIdeal.map f (LieModule.lowerCentralSeries R L L k)) (LieModule.lowerCentralSeries R L' L' k)","decl":"theorem LieIdeal.lowerCentralSeries_map_eq (k : ℕ) {f : L →ₗ⁅R⁆ L'} (h : Function.Surjective f) :\n    LieIdeal.map f (lowerCentralSeries R L L k) = lowerCentralSeries R L' L' k := by\n  have h' : (⊤ : LieIdeal R L).map f = ⊤ := by\n    rw [← f.idealRange_eq_map]\n    exact f.idealRange_eq_top_of_surjective h\n  induction k with\n  | zero => simp only [LieModule.lowerCentralSeries_zero]; exact h'\n  | succ k ih => simp only [LieModule.lowerCentralSeries_succ, LieIdeal.map_bracket_eq f h, ih, h']\n\n"}
{"name":"Function.Injective.lieAlgebra_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nh₁ : LieRing.IsNilpotent L'\nf : LieHom R L L'\nh₂ : Function.Injective ⇑f\n⊢ LieRing.IsNilpotent L","decl":"theorem Function.Injective.lieAlgebra_isNilpotent [h₁ : IsNilpotent L'] {f : L →ₗ⁅R⁆ L'}\n    (h₂ : Function.Injective f) : IsNilpotent L := by\n  rw [LieRing.IsNilpotent, LieModule.isNilpotent_iff R] at h₁ ⊢\n  peel h₁ with k hk\n  apply LieIdeal.bot_of_map_eq_bot h₂; rw [eq_bot_iff, ← hk]\n  apply LieIdeal.map_lowerCentralSeries_le\n\n"}
{"name":"Function.Surjective.lieAlgebra_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nh₁ : LieRing.IsNilpotent L\nf : LieHom R L L'\nh₂ : Function.Surjective ⇑f\n⊢ LieRing.IsNilpotent L'","decl":"theorem Function.Surjective.lieAlgebra_isNilpotent [h₁ : IsNilpotent L] {f : L →ₗ⁅R⁆ L'}\n    (h₂ : Function.Surjective f) : IsNilpotent L' := by\n  rw [LieRing.IsNilpotent, LieModule.isNilpotent_iff R] at h₁ ⊢\n  peel h₁ with k hk\n  rw [← LieIdeal.lowerCentralSeries_map_eq k h₂, hk]\n  simp only [LieIdeal.map_eq_bot_iff, bot_le]\n\n"}
{"name":"LieEquiv.nilpotent_iff_equiv_nilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ne : LieEquiv R L L'\n⊢ Iff (LieRing.IsNilpotent L) (LieRing.IsNilpotent L')","decl":"theorem LieEquiv.nilpotent_iff_equiv_nilpotent (e : L ≃ₗ⁅R⁆ L') :\n    IsNilpotent L ↔ IsNilpotent L' := by\n  constructor <;> intro h\n  · exact e.symm.injective.lieAlgebra_isNilpotent\n  · exact e.injective.lieAlgebra_isNilpotent\n\n"}
{"name":"LieHom.isNilpotent_range","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\nL' : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieRing.IsNilpotent L\nf : LieHom R L L'\n⊢ LieRing.IsNilpotent (Subtype fun x => Membership.mem f.range x)","decl":"theorem LieHom.isNilpotent_range [IsNilpotent L] (f : L →ₗ⁅R⁆ L') : IsNilpotent f.range :=\n  f.surjective_rangeRestrict.lieAlgebra_isNilpotent\n\n"}
{"name":"LieAlgebra.isNilpotent_range_ad_iff","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Iff (LieRing.IsNilpotent (Subtype fun x => Membership.mem (LieAlgebra.ad R L).range x)) (LieRing.IsNilpotent L)","decl":"/-- Note that this result is not quite a special case of\n`LieModule.isNilpotent_range_toEnd_iff` which concerns nilpotency of the\n`(ad R L).range`-module `L`, whereas this result concerns nilpotency of the `(ad R L).range`-module\n`(ad R L).range`. -/\n@[simp]\ntheorem LieAlgebra.isNilpotent_range_ad_iff : IsNilpotent (ad R L).range ↔ IsNilpotent L := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have : (ad R L).ker = center R L := by simp\n    exact\n      LieAlgebra.nilpotent_of_nilpotent_quotient (le_of_eq this)\n        ((ad R L).quotKerEquivRange.nilpotent_iff_equiv_nilpotent.mpr h)\n  · intro h\n    exact (ad R L).isNilpotent_range\n\n"}
{"name":"instIsNilpotentSubtypeMemLieSubalgebraTop","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nh : LieRing.IsNilpotent L\n⊢ LieRing.IsNilpotent (Subtype fun x => Membership.mem Top.top x)","decl":"instance [h : LieRing.IsNilpotent L] : LieRing.IsNilpotent (⊤ : LieSubalgebra R L) :=\n  LieSubalgebra.topEquiv.nilpotent_iff_equiv_nilpotent.mpr h\n\n"}
{"name":"LieIdeal.lcs_zero","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nI : LieIdeal R L\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (I.lcs M 0) Top.top","decl":"@[simp]\ntheorem lcs_zero : I.lcs M 0 = ⊤ :=\n  rfl\n\n"}
{"name":"LieIdeal.lcs_succ","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nI : LieIdeal R L\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nk : Nat\n⊢ Eq (I.lcs M (HAdd.hAdd k 1)) (Bracket.bracket I (I.lcs M k))","decl":"@[simp]\ntheorem lcs_succ : I.lcs M (k + 1) = ⁅I, I.lcs M k⁆ :=\n  Function.iterate_succ_apply' (fun N => ⁅I, N⁆) k ⊤\n\n"}
{"name":"LieIdeal.lcs_top","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nk : Nat\n⊢ Eq (Top.top.lcs M k) (LieModule.lowerCentralSeries R L M k)","decl":"theorem lcs_top : (⊤ : LieIdeal R L).lcs M k = lowerCentralSeries R L M k :=\n  rfl\n\n-- Porting note: added `LieSubmodule.toSubmodule` in the statement\n"}
{"name":"LieIdeal.coe_lcs_eq","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\nI : LieIdeal R L\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nk : Nat\ninst✝ : LieModule R L M\n⊢ Eq ↑(I.lcs M k) ↑(LieModule.lowerCentralSeries R (Subtype fun x => Membership.mem I x) M k)","decl":"theorem coe_lcs_eq [LieModule R L M] :\n    LieSubmodule.toSubmodule (I.lcs M k) = lowerCentralSeries R I M k := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp_rw [lowerCentralSeries_succ, lcs_succ, LieSubmodule.lieIdeal_oper_eq_linear_span', ←\n      (I.lcs M k).mem_toSubmodule, ih, LieSubmodule.mem_toSubmodule, LieSubmodule.mem_top,\n      true_and, (I : LieSubalgebra R L).coe_bracket_of_module]\n    congr\n    ext m\n    constructor\n    · rintro ⟨x, hx, m, hm, rfl⟩\n      exact ⟨⟨x, hx⟩, m, hm, rfl⟩\n    · rintro ⟨⟨x, hx⟩, m, hm, rfl⟩\n      exact ⟨x, hx, m, hm, rfl⟩\n\n"}
{"name":"LieAlgebra.ad_nilpotent_of_nilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nh : IsNilpotent a\n⊢ IsNilpotent ((LieAlgebra.ad R A) a)","decl":"theorem _root_.LieAlgebra.ad_nilpotent_of_nilpotent {a : A} (h : IsNilpotent a) :\n    IsNilpotent (LieAlgebra.ad R A a) := by\n  rw [LieAlgebra.ad_eq_lmul_left_sub_lmul_right]\n  have hl : IsNilpotent (LinearMap.mulLeft R a) := by rwa [LinearMap.isNilpotent_mulLeft_iff]\n  have hr : IsNilpotent (LinearMap.mulRight R a) := by rwa [LinearMap.isNilpotent_mulRight_iff]\n  have := @LinearMap.commute_mulLeft_right R A _ _ _ _ _ a a\n  exact this.isNilpotent_sub hl hr\n\n"}
{"name":"LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\ninst✝² : CommRing R\nL : Type v\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\nx : Subtype fun x => Membership.mem K x\nh : IsNilpotent ((LieAlgebra.ad R L) ↑x)\n⊢ IsNilpotent ((LieAlgebra.ad R (Subtype fun x => Membership.mem K x)) x)","decl":"theorem _root_.LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad {L : Type v} [LieRing L]\n    [LieAlgebra R L] (K : LieSubalgebra R L) {x : K} (h : IsNilpotent (LieAlgebra.ad R L ↑x)) :\n    IsNilpotent (LieAlgebra.ad R K x) := by\n  obtain ⟨n, hn⟩ := h\n  use n\n  exact LinearMap.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn\n\n"}
{"name":"LieAlgebra.isNilpotent_ad_of_isNilpotent","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nL : LieSubalgebra R A\nx : Subtype fun x => Membership.mem L x\nh : IsNilpotent ↑x\n⊢ IsNilpotent ((LieAlgebra.ad R (Subtype fun x => Membership.mem L x)) x)","decl":"theorem _root_.LieAlgebra.isNilpotent_ad_of_isNilpotent {L : LieSubalgebra R A} {x : L}\n    (h : IsNilpotent (x : A)) : IsNilpotent (LieAlgebra.ad R L x) :=\n  L.isNilpotent_ad_of_isNilpotent_ad <| LieAlgebra.ad_nilpotent_of_nilpotent R h\n\n"}
{"name":"LieSubmodule.lowerCentralSeries_tensor_eq_baseChange","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nk : Nat\n⊢ Eq (LieModule.lowerCentralSeries A (TensorProduct R A L) (TensorProduct R A M) k) (LieSubmodule.baseChange A (LieModule.lowerCentralSeries R L M k))","decl":"@[simp]\nlemma LieSubmodule.lowerCentralSeries_tensor_eq_baseChange (k : ℕ) :\n    lowerCentralSeries A (A ⊗[R] L) (A ⊗[R] M) k =\n    (lowerCentralSeries R L M k).baseChange A := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp only [lowerCentralSeries_succ, ih, ← baseChange_top, lie_baseChange]\n\n"}
{"name":"LieModule.instIsNilpotentTensor","module":"Mathlib.Algebra.Lie.Nilpotent","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : LieModule.IsNilpotent L M\n⊢ LieModule.IsNilpotent (TensorProduct R A L) (TensorProduct R A M)","decl":"instance LieModule.instIsNilpotentTensor [IsNilpotent L M] :\n    IsNilpotent (A ⊗[R] L) (A ⊗[R] M) := by\n  obtain ⟨k, hk⟩ := IsNilpotent.nilpotent R L M\n  rw [isNilpotent_iff A]\n  exact ⟨k, by simp [hk]⟩\n\n"}
