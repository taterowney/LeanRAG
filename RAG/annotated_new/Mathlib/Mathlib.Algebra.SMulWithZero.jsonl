{"name":"SMulWithZero.zero_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : Zero R\ninst✝ : Zero M\nself : SMulWithZero R M\nm : M\n⊢ Eq (HSMul.hSMul 0 m) 0","decl":"/-- `SMulWithZero` is a class consisting of a Type `R` with `0 ∈ R` and a scalar multiplication\nof `R` on a Type `M` with `0`, such that the equality `r • m = 0` holds if at least one among `r`\nor `m` equals `0`. -/\nclass SMulWithZero [Zero R] [Zero M] extends SMulZeroClass R M where\n  /-- Scalar multiplication by the scalar `0` is `0`. -/\n  zero_smul : ∀ m : M, (0 : R) • m = 0\n\n"}
{"name":"zero_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\nm : M\n⊢ Eq (HSMul.hSMul 0 m) 0","decl":"@[simp]\ntheorem zero_smul (m : M) : (0 : R) • m = 0 :=\n  SMulWithZero.zero_smul m\n\n"}
{"name":"smul_eq_zero_of_left","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\na : R\nh : Eq a 0\nb : M\n⊢ Eq (HSMul.hSMul a b) 0","decl":"lemma smul_eq_zero_of_left (h : a = 0) (b : M) : a • b = 0 := h.symm ▸ zero_smul _ b\n"}
{"name":"left_ne_zero_of_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Zero R\ninst✝¹ : Zero M\ninst✝ : SMulWithZero R M\na : R\nb : M\na✝ : Ne (HSMul.hSMul a b) 0\n⊢ Ne a 0","decl":"lemma left_ne_zero_of_smul : a • b ≠ 0 → a ≠ 0 := mt fun h ↦ smul_eq_zero_of_left h b\n\n"}
{"name":"MulActionWithZero.zero_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : MonoidWithZero R\ninst✝ : Zero M\nself : MulActionWithZero R M\nm : M\n⊢ Eq (HSMul.hSMul 0 m) 0","decl":"/-- An action of a monoid with zero `R` on a Type `M`, also with `0`, extends `MulAction` and\nis compatible with `0` (both in `R` and in `M`), with `1 ∈ R`, and with associativity of\nmultiplication on the monoid `M`. -/\nclass MulActionWithZero extends MulAction R M where\n  -- these fields are copied from `SMulWithZero`, as `extends` behaves poorly\n  /-- Scalar multiplication by any element send `0` to `0`. -/\n  smul_zero : ∀ r : R, r • (0 : M) = 0\n  /-- Scalar multiplication by the scalar `0` is `0`. -/\n  zero_smul : ∀ m : M, (0 : R) • m = 0\n\n-- see Note [lower instance priority]\n"}
{"name":"MulActionWithZero.smul_zero","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝¹ : MonoidWithZero R\ninst✝ : Zero M\nself : MulActionWithZero R M\nr : R\n⊢ Eq (HSMul.hSMul r 0) 0","decl":"/-- An action of a monoid with zero `R` on a Type `M`, also with `0`, extends `MulAction` and\nis compatible with `0` (both in `R` and in `M`), with `1 ∈ R`, and with associativity of\nmultiplication on the monoid `M`. -/\nclass MulActionWithZero extends MulAction R M where\n  -- these fields are copied from `SMulWithZero`, as `extends` behaves poorly\n  /-- Scalar multiplication by any element send `0` to `0`. -/\n  smul_zero : ∀ r : R, r • (0 : M) = 0\n  /-- Scalar multiplication by the scalar `0` is `0`. -/\n  zero_smul : ∀ m : M, (0 : R) • m = 0\n\n-- see Note [lower instance priority]\n"}
{"name":"MulActionWithZero.subsingleton","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : MonoidWithZero R\ninst✝² : Zero M\ninst✝¹ : MulActionWithZero R M\ninst✝ : Subsingleton R\n⊢ Subsingleton M","decl":"protected lemma MulActionWithZero.subsingleton\n    [MulActionWithZero R M] [Subsingleton R] : Subsingleton M :=\n  ⟨fun x y => by\n    rw [← one_smul R x, ← one_smul R y, Subsingleton.elim (1 : R) 0, zero_smul, zero_smul]⟩\n\n"}
{"name":"MulActionWithZero.nontrivial","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : MonoidWithZero R\ninst✝² : Zero M\ninst✝¹ : MulActionWithZero R M\ninst✝ : Nontrivial M\n⊢ Nontrivial R","decl":"protected lemma MulActionWithZero.nontrivial\n    [MulActionWithZero R M] [Nontrivial M] : Nontrivial R :=\n  (subsingleton_or_nontrivial R).resolve_left fun _ =>\n    not_subsingleton M <| MulActionWithZero.subsingleton R M\n\n"}
{"name":"ite_zero_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : MonoidWithZero R\ninst✝² : Zero M\ninst✝¹ : MulActionWithZero R M\np : Prop\ninst✝ : Decidable p\na : R\nb : M\n⊢ Eq (HSMul.hSMul (ite p a 0) b) (ite p (HSMul.hSMul a b) 0)","decl":"lemma ite_zero_smul (a : R) (b : M) : (if p then a else 0 : R) • b = if p then a • b else 0 := by\n  rw [ite_smul, zero_smul]\n\n"}
{"name":"boole_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : MonoidWithZero R\ninst✝² : Zero M\ninst✝¹ : MulActionWithZero R M\np : Prop\ninst✝ : Decidable p\na : M\n⊢ Eq (HSMul.hSMul (ite p 1 0) a) (ite p a 0)","decl":"lemma boole_smul (a : M) : (if p then 1 else 0 : R) • a = if p then a else 0 := by simp\n\n"}
{"name":"Pi.single_apply_smul","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : MonoidWithZero R\ninst✝² : Zero M\ninst✝¹ : MulActionWithZero R M\nι : Type u_5\ninst✝ : DecidableEq ι\nx : M\ni j : ι\n⊢ Eq (HSMul.hSMul (Pi.single i 1 j) x) (Pi.single i x j)","decl":"lemma Pi.single_apply_smul {ι : Type*} [DecidableEq ι] (x : M) (i j : ι) :\n    (Pi.single i 1 : ι → R) j • x = (Pi.single i x : ι → M) j := by\n  rw [single_apply, ite_smul, one_smul, zero_smul, single_apply]\n\n"}
{"name":"smul_inv₀","module":"Mathlib.Algebra.SMulWithZero","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁴ : GroupWithZero α\ninst✝³ : GroupWithZero β\ninst✝² : MulActionWithZero α β\ninst✝¹ : SMulCommClass α β β\ninst✝ : IsScalarTower α β β\nc : α\nx : β\n⊢ Eq (Inv.inv (HSMul.hSMul c x)) (HSMul.hSMul (Inv.inv c) (Inv.inv x))","decl":"theorem smul_inv₀ [SMulCommClass α β β] [IsScalarTower α β β] (c : α) (x : β) :\n    (c • x)⁻¹ = c⁻¹ • x⁻¹ := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp only [inv_zero, zero_smul]\n  obtain rfl | hx := eq_or_ne x 0\n  · simp only [inv_zero, smul_zero]\n  · refine inv_eq_of_mul_eq_one_left ?_\n    rw [smul_mul_smul_comm, inv_mul_cancel₀ hc, inv_mul_cancel₀ hx, one_smul]\n\n"}
