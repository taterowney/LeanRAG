{"name":"MvPolynomial.eval₂_eq","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\ng : RingHom R S₁\nX : σ → S₁\nf : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ g X f) (f.support.sum fun d => HMul.hMul (g (MvPolynomial.coeff d f)) (d.support.prod fun i => HPow.hPow (X i) (d i)))","decl":"theorem eval₂_eq (g : R →+* S₁) (X : σ → S₁) (f : MvPolynomial σ R) :\n    f.eval₂ g X = ∑ d ∈ f.support, g (f.coeff d) * ∏ i ∈ d.support, X i ^ d i :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂_eq'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Fintype σ\ng : RingHom R S₁\nX : σ → S₁\nf : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ g X f) (f.support.sum fun d => HMul.hMul (g (MvPolynomial.coeff d f)) (Finset.univ.prod fun i => HPow.hPow (X i) (d i)))","decl":"theorem eval₂_eq' [Fintype σ] (g : R →+* S₁) (X : σ → S₁) (f : MvPolynomial σ R) :\n    f.eval₂ g X = ∑ d ∈ f.support, g (f.coeff d) * ∏ i, X i ^ d i := by\n  simp only [eval₂_eq, ← Finsupp.prod_pow]\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (MvPolynomial.eval₂ f g 0) 0","decl":"@[simp]\ntheorem eval₂_zero : (0 : MvPolynomial σ R).eval₂ f g = 0 :=\n  Finsupp.sum_zero_index\n\n"}
{"name":"MvPolynomial.eval₂_add","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\np q : MvPolynomial σ R\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (MvPolynomial.eval₂ f g (HAdd.hAdd p q)) (HAdd.hAdd (MvPolynomial.eval₂ f g p) (MvPolynomial.eval₂ f g q))","decl":"@[simp]\ntheorem eval₂_add : (p + q).eval₂ f g = p.eval₂ f g + q.eval₂ f g := by\n  classical exact Finsupp.sum_add_index (by simp [f.map_zero]) (by simp [add_mul, f.map_add])\n\n"}
{"name":"MvPolynomial.eval₂_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (MvPolynomial.eval₂ f g ((MvPolynomial.monomial s) a)) (HMul.hMul (f a) (s.prod fun n e => HPow.hPow (g n) e))","decl":"@[simp]\ntheorem eval₂_monomial : (monomial s a).eval₂ f g = f a * s.prod fun n e => g n ^ e :=\n  Finsupp.sum_single_index (by simp [f.map_zero])\n\n"}
{"name":"MvPolynomial.eval₂_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\na : R\n⊢ Eq (MvPolynomial.eval₂ f g (MvPolynomial.C a)) (f a)","decl":"@[simp]\ntheorem eval₂_C (a) : (C a).eval₂ f g = f a := by\n  rw [C_apply, eval₂_monomial, prod_zero_index, mul_one]\n\n"}
{"name":"MvPolynomial.eval₂_one","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (MvPolynomial.eval₂ f g 1) 1","decl":"@[simp]\ntheorem eval₂_one : (1 : MvPolynomial σ R).eval₂ f g = 1 :=\n  (eval₂_C _ _ _).trans f.map_one\n\n"}
{"name":"MvPolynomial.eval₂_natCast","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nn : Nat\n⊢ Eq (MvPolynomial.eval₂ f g ↑n) ↑n","decl":"@[simp] theorem eval₂_natCast (n : Nat) : (n : MvPolynomial σ R).eval₂ f g = n :=\n  (eval₂_C _ _ _).trans (map_natCast f n)\n\n"}
{"name":"MvPolynomial.eval₂_ofNat","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (MvPolynomial.eval₂ f g (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] theorem eval₂_ofNat (n : Nat) [n.AtLeastTwo] :\n    (ofNat(n) : MvPolynomial σ R).eval₂ f g = ofNat(n) :=\n  eval₂_natCast f g n\n\n"}
{"name":"MvPolynomial.eval₂_X","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nn : σ\n⊢ Eq (MvPolynomial.eval₂ f g (MvPolynomial.X n)) (g n)","decl":"@[simp]\ntheorem eval₂_X (n) : (X n).eval₂ f g = g n := by\n  simp [eval₂_monomial, f.map_one, X, prod_single_index, pow_one]\n\n"}
{"name":"MvPolynomial.eval₂_mul_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\np : MvPolynomial σ R\nf : RingHom R S₁\ng : σ → S₁\ns : Finsupp σ Nat\na : R\n⊢ Eq (MvPolynomial.eval₂ f g (HMul.hMul p ((MvPolynomial.monomial s) a))) (HMul.hMul (HMul.hMul (MvPolynomial.eval₂ f g p) (f a)) (s.prod fun n e => HPow.hPow (g n) e))","decl":"theorem eval₂_mul_monomial :\n    ∀ {s a}, (p * monomial s a).eval₂ f g = p.eval₂ f g * f a * s.prod fun n e => g n ^ e := by\n  classical\n  apply MvPolynomial.induction_on p\n  · intro a' s a\n    simp [C_mul_monomial, eval₂_monomial, f.map_mul]\n  · intro p q ih_p ih_q\n    simp [add_mul, eval₂_add, ih_p, ih_q]\n  · intro p n ih s a\n    exact\n      calc (p * X n * monomial s a).eval₂ f g\n        _ = (p * monomial (Finsupp.single n 1 + s) a).eval₂ f g := by\n          rw [monomial_single_add, pow_one, mul_assoc]\n        _ = (p * monomial (Finsupp.single n 1) 1).eval₂ f g * f a * s.prod fun n e => g n ^ e := by\n          simp [ih, prod_single_index, prod_add_index, pow_one, pow_add, mul_assoc, mul_left_comm,\n            f.map_one]\n\n"}
{"name":"MvPolynomial.eval₂_mul_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\na : R\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\np : MvPolynomial σ R\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (MvPolynomial.eval₂ f g (HMul.hMul p (MvPolynomial.C a))) (HMul.hMul (MvPolynomial.eval₂ f g p) (f a))","decl":"theorem eval₂_mul_C : (p * C a).eval₂ f g = p.eval₂ f g * f a :=\n  (eval₂_mul_monomial _ _).trans <| by simp\n\n"}
{"name":"MvPolynomial.eval₂_mul","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nq : MvPolynomial σ R\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f g (HMul.hMul p q)) (HMul.hMul (MvPolynomial.eval₂ f g p) (MvPolynomial.eval₂ f g q))","decl":"@[simp]\ntheorem eval₂_mul : ∀ {p}, (p * q).eval₂ f g = p.eval₂ f g * q.eval₂ f g := by\n  apply MvPolynomial.induction_on q\n  · simp [eval₂_C, eval₂_mul_C]\n  · simp +contextual [mul_add, eval₂_add]\n  · simp +contextual [X, eval₂_monomial, eval₂_mul_monomial, ← mul_assoc]\n\n"}
{"name":"MvPolynomial.eval₂_pow","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\nn : Nat\n⊢ Eq (MvPolynomial.eval₂ f g (HPow.hPow p n)) (HPow.hPow (MvPolynomial.eval₂ f g p) n)","decl":"@[simp]\ntheorem eval₂_pow {p : MvPolynomial σ R} : ∀ {n : ℕ}, (p ^ n).eval₂ f g = p.eval₂ f g ^ n\n  | 0 => by\n    rw [pow_zero, pow_zero]\n    exact eval₂_one _ _\n  | n + 1 => by rw [pow_add, pow_one, pow_add, pow_one, eval₂_mul, eval₂_pow]\n\n"}
{"name":"MvPolynomial.coe_eval₂Hom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\n⊢ Eq (⇑(MvPolynomial.eval₂Hom f g)) (MvPolynomial.eval₂ f g)","decl":"@[simp]\ntheorem coe_eval₂Hom (f : R →+* S₁) (g : σ → S₁) : ⇑(eval₂Hom f g) = eval₂ f g :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_congr","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf₁ f₂ : RingHom R S₁\ng₁ g₂ : σ → S₁\np₁ p₂ : MvPolynomial σ R\na✝² : Eq f₁ f₂\na✝¹ : Eq g₁ g₂\na✝ : Eq p₁ p₂\n⊢ Eq ((MvPolynomial.eval₂Hom f₁ g₁) p₁) ((MvPolynomial.eval₂Hom f₂ g₂) p₂)","decl":"theorem eval₂Hom_congr {f₁ f₂ : R →+* S₁} {g₁ g₂ : σ → S₁} {p₁ p₂ : MvPolynomial σ R} :\n    f₁ = f₂ → g₁ = g₂ → p₁ = p₂ → eval₂Hom f₁ g₁ p₁ = eval₂Hom f₂ g₂ p₂ := by\n  rintro rfl rfl rfl; rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nr : R\n⊢ Eq ((MvPolynomial.eval₂Hom f g) (MvPolynomial.C r)) (f r)","decl":"@[simp]\ntheorem eval₂Hom_C (f : R →+* S₁) (g : σ → S₁) (r : R) : eval₂Hom f g (C r) = f r :=\n  eval₂_C f g r\n\n"}
{"name":"MvPolynomial.eval₂Hom_X'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\ni : σ\n⊢ Eq ((MvPolynomial.eval₂Hom f g) (MvPolynomial.X i)) (g i)","decl":"@[simp]\ntheorem eval₂Hom_X' (f : R →+* S₁) (g : σ → S₁) (i : σ) : eval₂Hom f g (X i) = g i :=\n  eval₂_X f g i\n\n"}
{"name":"MvPolynomial.comp_eval₂Hom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\nf : RingHom R S₁\ng : σ → S₁\nφ : RingHom S₁ S₂\n⊢ Eq (φ.comp (MvPolynomial.eval₂Hom f g)) (MvPolynomial.eval₂Hom (φ.comp f) fun i => φ (g i))","decl":"@[simp]\ntheorem comp_eval₂Hom [CommSemiring S₂] (f : R →+* S₁) (g : σ → S₁) (φ : S₁ →+* S₂) :\n    φ.comp (eval₂Hom f g) = eval₂Hom (φ.comp f) fun i => φ (g i) := by\n  apply MvPolynomial.ringHom_ext\n  · intro r\n    rw [RingHom.comp_apply, eval₂Hom_C, eval₂Hom_C, RingHom.comp_apply]\n  · intro i\n    rw [RingHom.comp_apply, eval₂Hom_X', eval₂Hom_X']\n\n"}
{"name":"MvPolynomial.map_eval₂Hom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\nf : RingHom R S₁\ng : σ → S₁\nφ : RingHom S₁ S₂\np : MvPolynomial σ R\n⊢ Eq (φ ((MvPolynomial.eval₂Hom f g) p)) ((MvPolynomial.eval₂Hom (φ.comp f) fun i => φ (g i)) p)","decl":"theorem map_eval₂Hom [CommSemiring S₂] (f : R →+* S₁) (g : σ → S₁) (φ : S₁ →+* S₂)\n    (p : MvPolynomial σ R) : φ (eval₂Hom f g p) = eval₂Hom (φ.comp f) (fun i => φ (g i)) p := by\n  rw [← comp_eval₂Hom]\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nd : Finsupp σ Nat\nr : R\n⊢ Eq ((MvPolynomial.eval₂Hom f g) ((MvPolynomial.monomial d) r)) (HMul.hMul (f r) (d.prod fun i k => HPow.hPow (g i) k))","decl":"theorem eval₂Hom_monomial (f : R →+* S₁) (g : σ → S₁) (d : σ →₀ ℕ) (r : R) :\n    eval₂Hom f g (monomial d r) = f r * d.prod fun i k => g i ^ k := by\n  simp only [monomial_eq, RingHom.map_mul, eval₂Hom_C, Finsupp.prod, map_prod,\n    RingHom.map_pow, eval₂Hom_X']\n\n"}
{"name":"MvPolynomial.eval₂_comp_left","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\nS₂ : Type u_2\ninst✝ : CommSemiring S₂\nk : RingHom S₁ S₂\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\n⊢ Eq (k (MvPolynomial.eval₂ f g p)) (MvPolynomial.eval₂ (k.comp f) (Function.comp (⇑k) g) p)","decl":"theorem eval₂_comp_left {S₂} [CommSemiring S₂] (k : S₁ →+* S₂) (f : R →+* S₁) (g : σ → S₁) (p) :\n    k (eval₂ f g p) = eval₂ (k.comp f) (k ∘ g) p := by\n  apply MvPolynomial.induction_on p <;>\n    simp +contextual [eval₂_add, k.map_add, eval₂_mul, k.map_mul]\n\n"}
{"name":"MvPolynomial.eval₂_eta","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ MvPolynomial.C MvPolynomial.X p) p","decl":"@[simp]\ntheorem eval₂_eta (p : MvPolynomial σ R) : eval₂ C X p = p := by\n  apply MvPolynomial.induction_on p <;>\n    simp +contextual [eval₂_add, eval₂_mul]\n\n"}
{"name":"MvPolynomial.eval₂_congr","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\np : MvPolynomial σ R\nf : RingHom R S₁\ng₁ g₂ : σ → S₁\nh : ∀ {i : σ} {c : Finsupp σ Nat}, Membership.mem c.support i → Ne (MvPolynomial.coeff c p) 0 → Eq (g₁ i) (g₂ i)\n⊢ Eq (MvPolynomial.eval₂ f g₁ p) (MvPolynomial.eval₂ f g₂ p)","decl":"theorem eval₂_congr (g₁ g₂ : σ → S₁)\n    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :\n    p.eval₂ f g₁ = p.eval₂ f g₂ := by\n  apply Finset.sum_congr rfl\n  intro C hc; dsimp; congr 1\n  apply Finset.prod_congr rfl\n  intro i hi; dsimp; congr 1\n  apply h hi\n  rwa [Finsupp.mem_support_iff] at hc\n\n"}
{"name":"MvPolynomial.eval₂_sum","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\ns : Finset S₂\np : S₂ → MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f g (s.sum fun x => p x)) (s.sum fun x => MvPolynomial.eval₂ f g (p x))","decl":"theorem eval₂_sum (s : Finset S₂) (p : S₂ → MvPolynomial σ R) :\n    eval₂ f g (∑ x ∈ s, p x) = ∑ x ∈ s, eval₂ f g (p x) :=\n  map_sum (eval₂Hom f g) _ s\n\n"}
{"name":"MvPolynomial.eval₂_prod","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\ns : Finset S₂\np : S₂ → MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f g (s.prod fun x => p x)) (s.prod fun x => MvPolynomial.eval₂ f g (p x))","decl":"@[to_additive existing (attr := simp)]\ntheorem eval₂_prod (s : Finset S₂) (p : S₂ → MvPolynomial σ R) :\n    eval₂ f g (∏ x ∈ s, p x) = ∏ x ∈ s, eval₂ f g (p x) :=\n  map_prod (eval₂Hom f g) _ s\n\n"}
{"name":"MvPolynomial.eval₂_assoc","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\nq : S₂ → MvPolynomial σ R\np : MvPolynomial S₂ R\n⊢ Eq (MvPolynomial.eval₂ f (fun t => MvPolynomial.eval₂ f g (q t)) p) (MvPolynomial.eval₂ f g (MvPolynomial.eval₂ MvPolynomial.C q p))","decl":"theorem eval₂_assoc (q : S₂ → MvPolynomial σ R) (p : MvPolynomial S₂ R) :\n    eval₂ f (fun t => eval₂ f g (q t)) p = eval₂ f g (eval₂ C q p) := by\n  show _ = eval₂Hom f g (eval₂ C q p)\n  rw [eval₂_comp_left (eval₂Hom f g)]; congr with a; simp\n\n"}
{"name":"MvPolynomial.eval_eq","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nX : σ → R\nf : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval X) f) (f.support.sum fun d => HMul.hMul (MvPolynomial.coeff d f) (d.support.prod fun i => HPow.hPow (X i) (d i)))","decl":"theorem eval_eq (X : σ → R) (f : MvPolynomial σ R) :\n    eval X f = ∑ d ∈ f.support, f.coeff d * ∏ i ∈ d.support, X i ^ d i :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval_eq'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nX : σ → R\nf : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval X) f) (f.support.sum fun d => HMul.hMul (MvPolynomial.coeff d f) (Finset.univ.prod fun i => HPow.hPow (X i) (d i)))","decl":"theorem eval_eq' [Fintype σ] (X : σ → R) (f : MvPolynomial σ R) :\n    eval X f = ∑ d ∈ f.support, f.coeff d * ∏ i, X i ^ d i :=\n  eval₂_eq' (RingHom.id R) X f\n\n"}
{"name":"MvPolynomial.eval_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\na : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\nf : σ → R\n⊢ Eq ((MvPolynomial.eval f) ((MvPolynomial.monomial s) a)) (HMul.hMul a (s.prod fun n e => HPow.hPow (f n) e))","decl":"theorem eval_monomial : eval f (monomial s a) = a * s.prod fun n e => f n ^ e :=\n  eval₂_monomial _ _\n\n"}
{"name":"MvPolynomial.eval_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : σ → R\na : R\n⊢ Eq ((MvPolynomial.eval f) (MvPolynomial.C a)) a","decl":"@[simp]\ntheorem eval_C : ∀ a, eval f (C a) = a :=\n  eval₂_C _ _\n\n"}
{"name":"MvPolynomial.eval_X","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nf : σ → R\nn : σ\n⊢ Eq ((MvPolynomial.eval f) (MvPolynomial.X n)) (f n)","decl":"@[simp]\ntheorem eval_X : ∀ n, eval f (X n) = f n :=\n  eval₂_X _ _\n\n"}
{"name":"MvPolynomial.eval_ofNat","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nf : σ → R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((MvPolynomial.eval f) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] theorem eval_ofNat (n : Nat) [n.AtLeastTwo] :\n    (ofNat(n) : MvPolynomial σ R).eval f = ofNat(n) :=\n  map_ofNat _ n\n\n"}
{"name":"MvPolynomial.smul_eval","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nx : σ → R\np : MvPolynomial σ R\ns : R\n⊢ Eq ((MvPolynomial.eval x) (HSMul.hSMul s p)) (HMul.hMul s ((MvPolynomial.eval x) p))","decl":"@[simp]\ntheorem smul_eval (x) (p : MvPolynomial σ R) (s) : eval x (s • p) = s * eval x p := by\n  rw [smul_eq_C_mul, (eval x).map_mul, eval_C]\n\n"}
{"name":"MvPolynomial.eval_add","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nf : σ → R\n⊢ Eq ((MvPolynomial.eval f) (HAdd.hAdd p q)) (HAdd.hAdd ((MvPolynomial.eval f) p) ((MvPolynomial.eval f) q))","decl":"theorem eval_add : eval f (p + q) = eval f p + eval f q :=\n  eval₂_add _ _\n\n"}
{"name":"MvPolynomial.eval_mul","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np q : MvPolynomial σ R\nf : σ → R\n⊢ Eq ((MvPolynomial.eval f) (HMul.hMul p q)) (HMul.hMul ((MvPolynomial.eval f) p) ((MvPolynomial.eval f) q))","decl":"theorem eval_mul : eval f (p * q) = eval f p * eval f q :=\n  eval₂_mul _ _\n\n"}
{"name":"MvPolynomial.eval_pow","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nf : σ → R\nn : Nat\n⊢ Eq ((MvPolynomial.eval f) (HPow.hPow p n)) (HPow.hPow ((MvPolynomial.eval f) p) n)","decl":"theorem eval_pow : ∀ n, eval f (p ^ n) = eval f p ^ n :=\n  fun _ => eval₂_pow _ _\n\n"}
{"name":"MvPolynomial.eval_sum","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nf : ι → MvPolynomial σ R\ng : σ → R\n⊢ Eq ((MvPolynomial.eval g) (s.sum fun i => f i)) (s.sum fun i => (MvPolynomial.eval g) (f i))","decl":"theorem eval_sum {ι : Type*} (s : Finset ι) (f : ι → MvPolynomial σ R) (g : σ → R) :\n    eval g (∑ i ∈ s, f i) = ∑ i ∈ s, eval g (f i) :=\n  map_sum (eval g) _ _\n\n"}
{"name":"MvPolynomial.eval_prod","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nf : ι → MvPolynomial σ R\ng : σ → R\n⊢ Eq ((MvPolynomial.eval g) (s.prod fun i => f i)) (s.prod fun i => (MvPolynomial.eval g) (f i))","decl":"@[to_additive existing]\ntheorem eval_prod {ι : Type*} (s : Finset ι) (f : ι → MvPolynomial σ R) (g : σ → R) :\n    eval g (∏ i ∈ s, f i) = ∏ i ∈ s, eval g (f i) :=\n  map_prod (eval g) _ _\n\n"}
{"name":"MvPolynomial.eval_assoc","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nτ : Type u_2\nf : σ → MvPolynomial τ R\ng : τ → R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval (Function.comp (⇑(MvPolynomial.eval g)) f)) p) ((MvPolynomial.eval g) (MvPolynomial.eval₂ MvPolynomial.C f p))","decl":"theorem eval_assoc {τ} (f : σ → MvPolynomial τ R) (g : τ → R) (p : MvPolynomial σ R) :\n    eval (eval g ∘ f) p = eval g (eval₂ C f p) := by\n  rw [eval₂_comp_left (eval g)]\n  unfold eval; simp only [coe_eval₂Hom]\n  congr with a; simp\n\n"}
{"name":"MvPolynomial.eval₂_id","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\ng : σ → R\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ (RingHom.id R) g p) ((MvPolynomial.eval g) p)","decl":"@[simp]\ntheorem eval₂_id {g : σ → R} (p : MvPolynomial σ R) : eval₂ (RingHom.id _) g p = eval g p :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval_eval₂","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\nS : Type u_2\nτ : Type u_3\nx : τ → S\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial τ S)\ng : σ → MvPolynomial τ S\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval x) (MvPolynomial.eval₂ f g p)) (MvPolynomial.eval₂ ((MvPolynomial.eval x).comp f) (fun s => (MvPolynomial.eval x) (g s)) p)","decl":"theorem eval_eval₂ {S τ : Type*} {x : τ → S} [CommSemiring S]\n    (f : R →+* MvPolynomial τ S) (g : σ → MvPolynomial τ S) (p : MvPolynomial σ R) :\n    eval x (eval₂ f g p) = eval₂ ((eval x).comp f) (fun s => eval x (g s)) p := by\n  apply induction_on p\n  · simp\n  · intro p q hp hq\n    simp [hp, hq]\n  · intro p n hp\n    simp [hp]\n\n"}
{"name":"MvPolynomial.map_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ns : Finsupp σ Nat\na : R\n⊢ Eq ((MvPolynomial.map f) ((MvPolynomial.monomial s) a)) ((MvPolynomial.monomial s) (f a))","decl":"@[simp]\ntheorem map_monomial (s : σ →₀ ℕ) (a : R) : map f (monomial s a) = monomial s (f a) :=\n  (eval₂_monomial _ _).trans monomial_eq.symm\n\n"}
{"name":"MvPolynomial.map_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\na : R\n⊢ Eq ((MvPolynomial.map f) (MvPolynomial.C a)) (MvPolynomial.C (f a))","decl":"@[simp]\ntheorem map_C : ∀ a : R, map f (C a : MvPolynomial σ R) = C (f a) :=\n  map_monomial _ _\n\n"}
{"name":"MvPolynomial.map_ofNat","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\nf : RingHom R S₁\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((MvPolynomial.map f) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] protected theorem map_ofNat (n : Nat) [n.AtLeastTwo] :\n    (ofNat(n) : MvPolynomial σ R).map f = ofNat(n) :=\n  _root_.map_ofNat _ _\n\n"}
{"name":"MvPolynomial.map_X","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\nn : σ\n⊢ Eq ((MvPolynomial.map f) (MvPolynomial.X n)) (MvPolynomial.X n)","decl":"@[simp]\ntheorem map_X : ∀ n : σ, map f (X n : MvPolynomial σ R) = X n :=\n  eval₂_X _ _\n\n"}
{"name":"MvPolynomial.map_id","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.map (RingHom.id R)) p) p","decl":"theorem map_id : ∀ p : MvPolynomial σ R, map (RingHom.id R) p = p :=\n  eval₂_eta\n\n"}
{"name":"MvPolynomial.map_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\nf : RingHom R S₁\ninst✝ : CommSemiring S₂\ng : RingHom S₁ S₂\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.map g) ((MvPolynomial.map f) p)) ((MvPolynomial.map (g.comp f)) p)","decl":"theorem map_map [CommSemiring S₂] (g : S₁ →+* S₂) (p : MvPolynomial σ R) :\n    map g (map f p) = map (g.comp f) p :=\n  (eval₂_comp_left (map g) (C.comp f) X p).trans <| by\n    congr\n    · ext1 a\n      simp only [map_C, comp_apply, RingHom.coe_comp]\n    · ext1 n\n      simp only [map_X, comp_apply]\n\n"}
{"name":"MvPolynomial.eval₂_eq_eval_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f g p) ((MvPolynomial.eval g) ((MvPolynomial.map f) p))","decl":"theorem eval₂_eq_eval_map (g : σ → S₁) (p : MvPolynomial σ R) : p.eval₂ f g = eval g (map f p) := by\n  unfold map eval; simp only [coe_eval₂Hom]\n\n  have h := eval₂_comp_left (eval₂Hom (RingHom.id S₁) g) (C.comp f) X p\n  -- Porting note: the Lean 3 version of `h` was full of metavariables which\n  -- were later unified during `rw [h]`. Also needed to add `-eval₂_id`.\n  dsimp [-eval₂_id] at h\n  rw [h]\n  congr\n  · ext1 a\n    simp only [coe_eval₂Hom, RingHom.id_apply, comp_apply, eval₂_C, RingHom.coe_comp]\n  · ext1 n\n    simp only [comp_apply, eval₂_X]\n\n"}
{"name":"MvPolynomial.eval₂_comp_right","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\nS₂ : Type u_2\ninst✝ : CommSemiring S₂\nk : RingHom S₁ S₂\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\n⊢ Eq (k (MvPolynomial.eval₂ f g p)) (MvPolynomial.eval₂ k (Function.comp (⇑k) g) ((MvPolynomial.map f) p))","decl":"theorem eval₂_comp_right {S₂} [CommSemiring S₂] (k : S₁ →+* S₂) (f : R →+* S₁) (g : σ → S₁) (p) :\n    k (eval₂ f g p) = eval₂ k (k ∘ g) (map f p) := by\n  apply MvPolynomial.induction_on p\n  · intro r\n    rw [eval₂_C, map_C, eval₂_C]\n  · intro p q hp hq\n    rw [eval₂_add, k.map_add, (map f).map_add, eval₂_add, hp, hq]\n  · intro p s hp\n    rw [eval₂_mul, k.map_mul, (map f).map_mul, eval₂_mul, map_X, hp, eval₂_X, eval₂_X]\n    rfl\n\n"}
{"name":"MvPolynomial.map_eval₂","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nS₃ : Type x\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : S₂ → MvPolynomial S₃ R\np : MvPolynomial S₂ R\n⊢ Eq ((MvPolynomial.map f) (MvPolynomial.eval₂ MvPolynomial.C g p)) (MvPolynomial.eval₂ MvPolynomial.C (Function.comp (⇑(MvPolynomial.map f)) g) ((MvPolynomial.map f) p))","decl":"theorem map_eval₂ (f : R →+* S₁) (g : S₂ → MvPolynomial S₃ R) (p : MvPolynomial S₂ R) :\n    map f (eval₂ C g p) = eval₂ C (map f ∘ g) (map f p) := by\n  apply MvPolynomial.induction_on p\n  · intro r\n    rw [eval₂_C, map_C, map_C, eval₂_C]\n  · intro p q hp hq\n    rw [eval₂_add, (map f).map_add, hp, hq, (map f).map_add, eval₂_add]\n  · intro p s hp\n    rw [eval₂_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval₂_mul, eval₂_X, eval₂_X]\n    rfl\n\n"}
{"name":"MvPolynomial.coeff_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\np : MvPolynomial σ R\nm : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff m ((MvPolynomial.map f) p)) (f (MvPolynomial.coeff m p))","decl":"theorem coeff_map (p : MvPolynomial σ R) : ∀ m : σ →₀ ℕ, coeff m (map f p) = f (coeff m p) := by\n  classical\n  apply MvPolynomial.induction_on p <;> clear p\n  · intro r m\n    rw [map_C]\n    simp only [coeff_C]\n    split_ifs\n    · rfl\n    rw [f.map_zero]\n  · intro p q hp hq m\n    simp only [hp, hq, (map f).map_add, coeff_add]\n    rw [f.map_add]\n  · intro p i hp m\n    simp only [hp, (map f).map_mul, map_X]\n    simp only [hp, mem_support_iff, coeff_mul_X']\n    split_ifs\n    · rfl\n    rw [f.map_zero]\n\n"}
{"name":"MvPolynomial.map_injective","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(MvPolynomial.map f)","decl":"theorem map_injective (hf : Function.Injective f) :\n    Function.Injective (map f : MvPolynomial σ R → MvPolynomial σ S₁) := by\n  intro p q h\n  simp only [MvPolynomial.ext_iff, coeff_map] at h ⊢\n  intro m\n  exact hf (h m)\n\n"}
{"name":"MvPolynomial.map_surjective","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(MvPolynomial.map f)","decl":"theorem map_surjective (hf : Function.Surjective f) :\n    Function.Surjective (map f : MvPolynomial σ R → MvPolynomial σ S₁) := fun p => by\n  induction' p using MvPolynomial.induction_on' with i fr a b ha hb\n  · obtain ⟨r, rfl⟩ := hf fr\n    exact ⟨monomial i r, map_monomial _ _ _⟩\n  · obtain ⟨a, rfl⟩ := ha\n    obtain ⟨b, rfl⟩ := hb\n    exact ⟨a + b, RingHom.map_add _ _ _⟩\n\n"}
{"name":"MvPolynomial.map_leftInverse","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : RingHom S₁ R\nhf : Function.LeftInverse ⇑f ⇑g\n⊢ Function.LeftInverse ⇑(MvPolynomial.map f) ⇑(MvPolynomial.map g)","decl":"/-- If `f` is a left-inverse of `g` then `map f` is a left-inverse of `map g`. -/\ntheorem map_leftInverse {f : R →+* S₁} {g : S₁ →+* R} (hf : Function.LeftInverse f g) :\n    Function.LeftInverse (map f : MvPolynomial σ R → MvPolynomial σ S₁) (map g) := fun X => by\n  rw [map_map, (RingHom.ext hf : f.comp g = RingHom.id _), map_id]\n\n"}
{"name":"MvPolynomial.map_rightInverse","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : RingHom S₁ R\nhf : Function.RightInverse ⇑f ⇑g\n⊢ Function.RightInverse ⇑(MvPolynomial.map f) ⇑(MvPolynomial.map g)","decl":"/-- If `f` is a right-inverse of `g` then `map f` is a right-inverse of `map g`. -/\ntheorem map_rightInverse {f : R →+* S₁} {g : S₁ →+* R} (hf : Function.RightInverse f g) :\n    Function.RightInverse (map f : MvPolynomial σ R → MvPolynomial σ S₁) (map g) :=\n  (map_leftInverse hf.leftInverse).rightInverse\n\n"}
{"name":"MvPolynomial.eval_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → S₁\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval g) ((MvPolynomial.map f) p)) (MvPolynomial.eval₂ f g p)","decl":"@[simp]\ntheorem eval_map (f : R →+* S₁) (g : σ → S₁) (p : MvPolynomial σ R) :\n    eval g (map f p) = eval₂ f g p := by\n  apply MvPolynomial.induction_on p <;> · simp +contextual\n\n"}
{"name":"MvPolynomial.eval₂_comp","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : σ → R\np : MvPolynomial σ R\n⊢ Eq (f ((MvPolynomial.eval g) p)) (MvPolynomial.eval₂ f (Function.comp (⇑f) g) p)","decl":"theorem eval₂_comp (f : R →+* S₁) (g : σ → R) (p : MvPolynomial σ R) :\n    f (eval g p) = eval₂ f (f ∘ g) p := by\n  rw [← p.map_id, eval_map, eval₂_comp_right]\n\n"}
{"name":"MvPolynomial.eval₂_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\nf : RingHom R S₁\ng : σ → S₂\nφ : RingHom S₁ S₂\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ φ g ((MvPolynomial.map f) p)) (MvPolynomial.eval₂ (φ.comp f) g p)","decl":"@[simp]\ntheorem eval₂_map [CommSemiring S₂] (f : R →+* S₁) (g : σ → S₂) (φ : S₁ →+* S₂)\n    (p : MvPolynomial σ R) : eval₂ φ g (map f p) = eval₂ (φ.comp f) g p := by\n  rw [← eval_map, ← eval_map, map_map]\n\n"}
{"name":"MvPolynomial.eval₂Hom_map_hom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\nf : RingHom R S₁\ng : σ → S₂\nφ : RingHom S₁ S₂\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom φ g) ((MvPolynomial.map f) p)) ((MvPolynomial.eval₂Hom (φ.comp f) g) p)","decl":"@[simp]\ntheorem eval₂Hom_map_hom [CommSemiring S₂] (f : R →+* S₁) (g : σ → S₂) (φ : S₁ →+* S₂)\n    (p : MvPolynomial σ R) : eval₂Hom φ g (map f p) = eval₂Hom (φ.comp f) g p :=\n  eval₂_map f g φ p\n\n"}
{"name":"MvPolynomial.constantCoeff_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.constantCoeff ((MvPolynomial.map f) φ)) (f (MvPolynomial.constantCoeff φ))","decl":"@[simp]\ntheorem constantCoeff_map (f : R →+* S₁) (φ : MvPolynomial σ R) :\n    constantCoeff (MvPolynomial.map f φ) = f (constantCoeff φ) :=\n  coeff_map f φ 0\n\n"}
{"name":"MvPolynomial.constantCoeff_comp_map","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\n⊢ Eq (MvPolynomial.constantCoeff.comp (MvPolynomial.map f)) (f.comp MvPolynomial.constantCoeff)","decl":"theorem constantCoeff_comp_map (f : R →+* S₁) :\n    (constantCoeff : MvPolynomial σ S₁ →+* S₁).comp (MvPolynomial.map f) = f.comp constantCoeff :=\n  by ext <;> simp\n\n"}
{"name":"MvPolynomial.support_map_subset","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\np : MvPolynomial σ R\n⊢ HasSubset.Subset ((MvPolynomial.map f) p).support p.support","decl":"theorem support_map_subset (p : MvPolynomial σ R) : (map f p).support ⊆ p.support := by\n  intro x\n  simp only [mem_support_iff]\n  contrapose!\n  change p.coeff x = 0 → (map f p).coeff x = 0\n  rw [coeff_map]\n  intro hx\n  rw [hx]\n  exact RingHom.map_zero f\n\n"}
{"name":"MvPolynomial.support_map_of_injective","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\np : MvPolynomial σ R\nf : RingHom R S₁\nhf : Function.Injective ⇑f\n⊢ Eq ((MvPolynomial.map f) p).support p.support","decl":"theorem support_map_of_injective (p : MvPolynomial σ R) {f : R →+* S₁} (hf : Injective f) :\n    (map f p).support = p.support := by\n  apply Finset.Subset.antisymm\n  · exact MvPolynomial.support_map_subset _ _\n  intro x hx\n  rw [mem_support_iff]\n  contrapose! hx\n  simp only [Classical.not_not, mem_support_iff]\n  replace hx : (map f p).coeff x = 0 := hx\n  rw [coeff_map, ← f.map_zero] at hx\n  exact hf hx\n\n"}
{"name":"MvPolynomial.C_dvd_iff_map_hom_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nq : RingHom R S₁\nr : R\nhr : ∀ (r' : R), Iff (Eq (q r') 0) (Dvd.dvd r r')\nφ : MvPolynomial σ R\n⊢ Iff (Dvd.dvd (MvPolynomial.C r) φ) (Eq ((MvPolynomial.map q) φ) 0)","decl":"theorem C_dvd_iff_map_hom_eq_zero (q : R →+* S₁) (r : R) (hr : ∀ r' : R, q r' = 0 ↔ r ∣ r')\n    (φ : MvPolynomial σ R) : C r ∣ φ ↔ map q φ = 0 := by\n  rw [C_dvd_iff_dvd_coeff, MvPolynomial.ext_iff]\n  simp only [coeff_map, coeff_zero, hr]\n\n"}
{"name":"MvPolynomial.map_mapRange_eq_iff","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₁\nf : RingHom R S₁\ng : S₁ → R\nhg : Eq (g 0) 0\nφ : MvPolynomial σ S₁\n⊢ Iff (Eq ((MvPolynomial.map f) (Finsupp.mapRange g hg φ)) φ) (∀ (d : Finsupp σ Nat), Eq (f (g (MvPolynomial.coeff d φ))) (MvPolynomial.coeff d φ))","decl":"theorem map_mapRange_eq_iff (f : R →+* S₁) (g : S₁ → R) (hg : g 0 = 0) (φ : MvPolynomial σ S₁) :\n    map f (Finsupp.mapRange g hg φ) = φ ↔ ∀ d, f (g (coeff d φ)) = coeff d φ := by\n  rw [MvPolynomial.ext_iff]\n  apply forall_congr'; intro m\n  rw [coeff_map]\n  apply eq_iff_eq_cancel_right.mpr\n  rfl\n\n"}
{"name":"MvPolynomial.mapAlgHom_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S₁\ninst✝² : CommSemiring S₂\ninst✝¹ : Algebra R S₁\ninst✝ : Algebra R S₂\nf : AlgHom R S₁ S₂\np : MvPolynomial σ S₁\n⊢ Eq ((MvPolynomial.mapAlgHom f) p) (MvPolynomial.eval₂ (MvPolynomial.C.comp ↑f) MvPolynomial.X p)","decl":"/-- If `f : S₁ →ₐ[R] S₂` is a morphism of `R`-algebras, then so is `MvPolynomial.map f`. -/\n@[simps!]\ndef mapAlgHom [CommSemiring S₂] [Algebra R S₁] [Algebra R S₂] (f : S₁ →ₐ[R] S₂) :\n    MvPolynomial σ S₁ →ₐ[R] MvPolynomial σ S₂ :=\n  { map (↑f : S₁ →+* S₂) with\n    commutes' := fun r => by\n      have h₁ : algebraMap R (MvPolynomial σ S₁) r = C (algebraMap R S₁ r) := rfl\n      have h₂ : algebraMap R (MvPolynomial σ S₂) r = C (algebraMap R S₂ r) := rfl\n      simp_rw [OneHom.toFun_eq_coe]\n      -- Porting note: we're missing some `simp` lemmas like `MonoidHom.coe_toOneHom`\n      change @DFunLike.coe (_ →+* _) _ _ _ _ _ = _\n      rw [h₁, h₂, map, eval₂Hom_C, RingHom.comp_apply, AlgHom.coe_toRingHom, AlgHom.commutes] }\n\n"}
{"name":"MvPolynomial.mapAlgHom_id","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\n⊢ Eq (MvPolynomial.mapAlgHom (AlgHom.id R S₁)) (AlgHom.id R (MvPolynomial σ S₁))","decl":"@[simp]\ntheorem mapAlgHom_id [Algebra R S₁] :\n    mapAlgHom (AlgHom.id R S₁) = AlgHom.id R (MvPolynomial σ S₁) :=\n  AlgHom.ext map_id\n\n"}
{"name":"MvPolynomial.mapAlgHom_coe_ringHom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S₁\ninst✝² : CommSemiring S₂\ninst✝¹ : Algebra R S₁\ninst✝ : Algebra R S₂\nf : AlgHom R S₁ S₂\n⊢ Eq (↑(MvPolynomial.mapAlgHom f)) (MvPolynomial.map ↑f)","decl":"@[simp]\ntheorem mapAlgHom_coe_ringHom [CommSemiring S₂] [Algebra R S₁] [Algebra R S₂] (f : S₁ →ₐ[R] S₂) :\n    ↑(mapAlgHom f : _ →ₐ[R] MvPolynomial σ S₂) =\n      (map ↑f : MvPolynomial σ S₁ →+* MvPolynomial σ S₂) :=\n  RingHom.mk_coe _ _ _ _ _\n\n"}
{"name":"MvPolynomial.algebraMap_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nr : R\n⊢ Eq ((algebraMap R (MvPolynomial σ S₁)) r) (MvPolynomial.C ((algebraMap R S₁) r))","decl":"@[simp]\ntheorem algebraMap_apply (r : R) : algebraMap R (MvPolynomial σ S₁) r = C (algebraMap R S₁ r) := rfl\n\n"}
{"name":"MvPolynomial.aeval_def","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) p) (MvPolynomial.eval₂ (algebraMap R S₁) f p)","decl":"theorem aeval_def (p : MvPolynomial σ R) : aeval f p = eval₂ (algebraMap R S₁) f p :=\n  rfl\n\n"}
{"name":"MvPolynomial.aeval_eq_eval₂Hom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) p) ((MvPolynomial.eval₂Hom (algebraMap R S₁) f) p)","decl":"theorem aeval_eq_eval₂Hom (p : MvPolynomial σ R) : aeval f p = eval₂Hom (algebraMap R S₁) f p :=\n  rfl\n\n"}
{"name":"MvPolynomial.coe_aeval_eq_eval","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"S₁ : Type v\nσ : Type u_1\ninst✝ : CommSemiring S₁\nf : σ → S₁\n⊢ Eq (↑(MvPolynomial.aeval f)) (MvPolynomial.eval f)","decl":"@[simp]\nlemma coe_aeval_eq_eval : RingHomClass.toRingHom (MvPolynomial.aeval f) = MvPolynomial.eval f :=\n  rfl\n\n"}
{"name":"MvPolynomial.aeval_X","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\ns : σ\n⊢ Eq ((MvPolynomial.aeval f) (MvPolynomial.X s)) (f s)","decl":"@[simp]\ntheorem aeval_X (s : σ) : aeval f (X s : MvPolynomial _ R) = f s :=\n  eval₂_X _ _ _\n\n"}
{"name":"MvPolynomial.aeval_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\nr : R\n⊢ Eq ((MvPolynomial.aeval f) (MvPolynomial.C r)) ((algebraMap R S₁) r)","decl":"theorem aeval_C (r : R) : aeval f (C r) = algebraMap R S₁ r :=\n  eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.aeval_ofNat","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S₁\ninst✝¹ : Algebra R S₁\nf : σ → S₁\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((MvPolynomial.aeval f) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] theorem aeval_ofNat (n : Nat) [n.AtLeastTwo] :\n    aeval f (ofNat(n) : MvPolynomial σ R) = ofNat(n) :=\n  map_ofNat _ _\n\n"}
{"name":"MvPolynomial.aeval_unique","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nφ : AlgHom R (MvPolynomial σ R) S₁\n⊢ Eq φ (MvPolynomial.aeval (Function.comp (⇑φ) MvPolynomial.X))","decl":"theorem aeval_unique (φ : MvPolynomial σ R →ₐ[R] S₁) : φ = aeval (φ ∘ X) := by\n  ext i\n  simp\n\n"}
{"name":"MvPolynomial.aeval_X_left","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.aeval MvPolynomial.X) (AlgHom.id R (MvPolynomial σ R))","decl":"theorem aeval_X_left : aeval X = AlgHom.id R (MvPolynomial σ R) :=\n  (aeval_unique (AlgHom.id R _)).symm\n\n"}
{"name":"MvPolynomial.aeval_X_left_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval MvPolynomial.X) p) p","decl":"theorem aeval_X_left_apply (p : MvPolynomial σ R) : aeval X p = p :=\n  AlgHom.congr_fun aeval_X_left p\n\n"}
{"name":"MvPolynomial.comp_aeval","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S₁\ninst✝² : Algebra R S₁\nf : σ → S₁\nB : Type u_2\ninst✝¹ : CommSemiring B\ninst✝ : Algebra R B\nφ : AlgHom R S₁ B\n⊢ Eq (φ.comp (MvPolynomial.aeval f)) (MvPolynomial.aeval fun i => φ (f i))","decl":"theorem comp_aeval {B : Type*} [CommSemiring B] [Algebra R B] (φ : S₁ →ₐ[R] B) :\n    φ.comp (aeval f) = aeval fun i => φ (f i) := by\n  ext i\n  simp\n\n"}
{"name":"MvPolynomial.comp_aeval_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S₁\ninst✝² : Algebra R S₁\nf : σ → S₁\nB : Type u_2\ninst✝¹ : CommSemiring B\ninst✝ : Algebra R B\nφ : AlgHom R S₁ B\np : MvPolynomial σ R\n⊢ Eq (φ ((MvPolynomial.aeval f) p)) ((MvPolynomial.aeval fun i => φ (f i)) p)","decl":"lemma comp_aeval_apply {B : Type*} [CommSemiring B] [Algebra R B] (φ : S₁ →ₐ[R] B)\n    (p : MvPolynomial σ R) :\n    φ (aeval f p) = aeval (fun i ↦ φ (f i)) p := by\n  rw [← comp_aeval, AlgHom.coe_comp, comp_apply]\n\n"}
{"name":"MvPolynomial.map_aeval","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S₁\ninst✝¹ : Algebra R S₁\nB : Type u_2\ninst✝ : CommSemiring B\ng : σ → S₁\nφ : RingHom S₁ B\np : MvPolynomial σ R\n⊢ Eq (φ ((MvPolynomial.aeval g) p)) ((MvPolynomial.eval₂Hom (φ.comp (algebraMap R S₁)) fun i => φ (g i)) p)","decl":"@[simp]\ntheorem map_aeval {B : Type*} [CommSemiring B] (g : σ → S₁) (φ : S₁ →+* B) (p : MvPolynomial σ R) :\n    φ (aeval g p) = eval₂Hom (φ.comp (algebraMap R S₁)) (fun i => φ (g i)) p := by\n  rw [← comp_eval₂Hom]\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\n⊢ Eq (MvPolynomial.eval₂Hom f 0) (f.comp MvPolynomial.constantCoeff)","decl":"@[simp]\ntheorem eval₂Hom_zero (f : R →+* S₂) : eval₂Hom f (0 : σ → S₂) = f.comp constantCoeff := by\n  ext <;> simp\n\n"}
{"name":"MvPolynomial.eval₂Hom_zero'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\n⊢ Eq (MvPolynomial.eval₂Hom f fun x => 0) (f.comp MvPolynomial.constantCoeff)","decl":"@[simp]\ntheorem eval₂Hom_zero' (f : R →+* S₂) : eval₂Hom f (fun _ => 0 : σ → S₂) = f.comp constantCoeff :=\n  eval₂Hom_zero f\n\n"}
{"name":"MvPolynomial.eval₂Hom_zero_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom f 0) p) (f (MvPolynomial.constantCoeff p))","decl":"theorem eval₂Hom_zero_apply (f : R →+* S₂) (p : MvPolynomial σ R) :\n    eval₂Hom f (0 : σ → S₂) p = f (constantCoeff p) :=\n  RingHom.congr_fun (eval₂Hom_zero f) p\n\n"}
{"name":"MvPolynomial.eval₂Hom_zero'_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom f fun x => 0) p) (f (MvPolynomial.constantCoeff p))","decl":"theorem eval₂Hom_zero'_apply (f : R →+* S₂) (p : MvPolynomial σ R) :\n    eval₂Hom f (fun _ => 0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂Hom_zero_apply f p\n\n"}
{"name":"MvPolynomial.eval₂_zero_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f 0 p) (f (MvPolynomial.constantCoeff p))","decl":"@[simp]\ntheorem eval₂_zero_apply (f : R →+* S₂) (p : MvPolynomial σ R) :\n    eval₂ f (0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂Hom_zero_apply _ _\n\n"}
{"name":"MvPolynomial.eval₂_zero'_apply","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f (fun x => 0) p) (f (MvPolynomial.constantCoeff p))","decl":"@[simp]\ntheorem eval₂_zero'_apply (f : R →+* S₂) (p : MvPolynomial σ R) :\n    eval₂ f (fun _ => 0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂_zero_apply f p\n\n"}
{"name":"MvPolynomial.aeval_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval 0) p) ((algebraMap R S₁) (MvPolynomial.constantCoeff p))","decl":"@[simp]\ntheorem aeval_zero (p : MvPolynomial σ R) :\n    aeval (0 : σ → S₁) p = algebraMap _ _ (constantCoeff p) :=\n  eval₂Hom_zero_apply (algebraMap R S₁) p\n\n"}
{"name":"MvPolynomial.aeval_zero'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval fun x => 0) p) ((algebraMap R S₁) (MvPolynomial.constantCoeff p))","decl":"@[simp]\ntheorem aeval_zero' (p : MvPolynomial σ R) :\n    aeval (fun _ => 0 : σ → S₁) p = algebraMap _ _ (constantCoeff p) :=\n  aeval_zero p\n\n"}
{"name":"MvPolynomial.eval_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.eval 0) MvPolynomial.constantCoeff","decl":"@[simp]\ntheorem eval_zero : eval (0 : σ → R) = constantCoeff :=\n  eval₂Hom_zero _\n\n"}
{"name":"MvPolynomial.eval_zero'","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.eval fun x => 0) MvPolynomial.constantCoeff","decl":"@[simp]\ntheorem eval_zero' : eval (fun _ => 0 : σ → R) = constantCoeff :=\n  eval₂Hom_zero _\n\n"}
{"name":"MvPolynomial.aeval_monomial","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\ng : σ → S₁\nd : Finsupp σ Nat\nr : R\n⊢ Eq ((MvPolynomial.aeval g) ((MvPolynomial.monomial d) r)) (HMul.hMul ((algebraMap R S₁) r) (d.prod fun i k => HPow.hPow (g i) k))","decl":"theorem aeval_monomial (g : σ → S₁) (d : σ →₀ ℕ) (r : R) :\n    aeval g (monomial d r) = algebraMap _ _ r * d.prod fun i k => g i ^ k :=\n  eval₂Hom_monomial _ _ _ _\n\n"}
{"name":"MvPolynomial.eval₂Hom_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₂\nf : RingHom R S₂\ng : σ → S₂\nφ : MvPolynomial σ R\nh : ∀ (d : Finsupp σ Nat), Ne (MvPolynomial.coeff d φ) 0 → Exists fun i => And (Membership.mem d.support i) (Eq (g i) 0)\n⊢ Eq ((MvPolynomial.eval₂Hom f g) φ) 0","decl":"theorem eval₂Hom_eq_zero (f : R →+* S₂) (g : σ → S₂) (φ : MvPolynomial σ R)\n    (h : ∀ d, φ.coeff d ≠ 0 → ∃ i ∈ d.support, g i = 0) : eval₂Hom f g φ = 0 := by\n  rw [φ.as_sum, map_sum]\n  refine Finset.sum_eq_zero fun d hd => ?_\n  obtain ⟨i, hi, hgi⟩ : ∃ i ∈ d.support, g i = 0 := h d (Finsupp.mem_support_iff.mp hd)\n  rw [eval₂Hom_monomial, Finsupp.prod, Finset.prod_eq_zero hi, mul_zero]\n  rw [hgi, zero_pow]\n  rwa [← Finsupp.mem_support_iff]\n\n"}
{"name":"MvPolynomial.aeval_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₂ : Type w\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₂\ninst✝ : Algebra R S₂\nf : σ → S₂\nφ : MvPolynomial σ R\nh : ∀ (d : Finsupp σ Nat), Ne (MvPolynomial.coeff d φ) 0 → Exists fun i => And (Membership.mem d.support i) (Eq (f i) 0)\n⊢ Eq ((MvPolynomial.aeval f) φ) 0","decl":"theorem aeval_eq_zero [Algebra R S₂] (f : σ → S₂) (φ : MvPolynomial σ R)\n    (h : ∀ d, φ.coeff d ≠ 0 → ∃ i ∈ d.support, f i = 0) : aeval f φ = 0 :=\n  eval₂Hom_eq_zero _ _ _ h\n\n"}
{"name":"MvPolynomial.aeval_sum","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\nι : Type u_2\ns : Finset ι\nφ : ι → MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) (s.sum fun i => φ i)) (s.sum fun i => (MvPolynomial.aeval f) (φ i))","decl":"theorem aeval_sum {ι : Type*} (s : Finset ι) (φ : ι → MvPolynomial σ R) :\n    aeval f (∑ i ∈ s, φ i) = ∑ i ∈ s, aeval f (φ i) :=\n  map_sum (MvPolynomial.aeval f) _ _\n\n"}
{"name":"MvPolynomial.aeval_prod","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\nι : Type u_2\ns : Finset ι\nφ : ι → MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) (s.prod fun i => φ i)) (s.prod fun i => (MvPolynomial.aeval f) (φ i))","decl":"@[to_additive existing]\ntheorem aeval_prod {ι : Type*} (s : Finset ι) (φ : ι → MvPolynomial σ R) :\n    aeval f (∏ i ∈ s, φ i) = ∏ i ∈ s, aeval f (φ i) :=\n  map_prod (MvPolynomial.aeval f) _ _\n\n"}
{"name":"Algebra.adjoin_range_eq_range_aeval","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\n⊢ Eq (Algebra.adjoin R (Set.range f)) (MvPolynomial.aeval f).range","decl":"theorem _root_.Algebra.adjoin_range_eq_range_aeval :\n    Algebra.adjoin R (Set.range f) = (MvPolynomial.aeval f).range := by\n  simp only [← Algebra.map_top, ← MvPolynomial.adjoin_range_X, AlgHom.map_adjoin, ← Set.range_comp,\n    Function.comp_def, MvPolynomial.aeval_X]\n\n"}
{"name":"Algebra.adjoin_eq_range","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nS₁ : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\ns : Set S₁\n⊢ Eq (Algebra.adjoin R s) (MvPolynomial.aeval Subtype.val).range","decl":"theorem _root_.Algebra.adjoin_eq_range (s : Set S₁) :\n    Algebra.adjoin R s = (MvPolynomial.aeval ((↑) : s → S₁)).range := by\n  rw [← Algebra.adjoin_range_eq_range_aeval, Subtype.range_coe]\n\n"}
{"name":"MvPolynomial.aevalTower_X","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\ni : σ\n⊢ Eq ((MvPolynomial.aevalTower g y) (MvPolynomial.X i)) (y i)","decl":"@[simp]\ntheorem aevalTower_X (i : σ) : aevalTower g y (X i) = y i :=\n  eval₂_X _ _ _\n\n"}
{"name":"MvPolynomial.aevalTower_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\nx : R\n⊢ Eq ((MvPolynomial.aevalTower g y) (MvPolynomial.C x)) (g x)","decl":"@[simp]\ntheorem aevalTower_C (x : R) : aevalTower g y (C x) = g x :=\n  eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.aevalTower_ofNat","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁵ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommSemiring S\ninst✝³ : CommSemiring A\ninst✝² : Algebra S R\ninst✝¹ : Algebra S A\ng : AlgHom S R A\ny : σ → A\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((MvPolynomial.aevalTower g y) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem aevalTower_ofNat (n : Nat) [n.AtLeastTwo] :\n    aevalTower g y (ofNat(n) : MvPolynomial σ R) = ofNat(n) :=\n  _root_.map_ofNat _ _\n\n"}
{"name":"MvPolynomial.aevalTower_comp_C","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\n⊢ Eq ((↑(MvPolynomial.aevalTower g y)).comp MvPolynomial.C) ↑g","decl":"@[simp]\ntheorem aevalTower_comp_C : (aevalTower g y : MvPolynomial σ R →+* A).comp C = g :=\n  RingHom.ext <| aevalTower_C _ _\n\n"}
{"name":"MvPolynomial.aevalTower_algebraMap","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\nx : R\n⊢ Eq ((MvPolynomial.aevalTower g y) ((algebraMap R (MvPolynomial σ R)) x)) (g x)","decl":"theorem aevalTower_algebraMap (x : R) : aevalTower g y (algebraMap R (MvPolynomial σ R) x) = g x :=\n  eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.aevalTower_comp_algebraMap","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\n⊢ Eq ((↑(MvPolynomial.aevalTower g y)).comp (algebraMap R (MvPolynomial σ R))) ↑g","decl":"theorem aevalTower_comp_algebraMap :\n    (aevalTower g y : MvPolynomial σ R →+* A).comp (algebraMap R (MvPolynomial σ R)) = g :=\n  aevalTower_comp_C _ _\n\n"}
{"name":"MvPolynomial.aevalTower_toAlgHom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\nx : R\n⊢ Eq ((MvPolynomial.aevalTower g y) ((IsScalarTower.toAlgHom S R (MvPolynomial σ R)) x)) (g x)","decl":"theorem aevalTower_toAlgHom (x : R) :\n    aevalTower g y (IsScalarTower.toAlgHom S R (MvPolynomial σ R) x) = g x :=\n  aevalTower_algebraMap _ _ _\n\n"}
{"name":"MvPolynomial.aevalTower_comp_toAlgHom","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra S R\ninst✝ : Algebra S A\ng : AlgHom S R A\ny : σ → A\n⊢ Eq ((MvPolynomial.aevalTower g y).comp (IsScalarTower.toAlgHom S R (MvPolynomial σ R))) g","decl":"@[simp]\ntheorem aevalTower_comp_toAlgHom :\n    (aevalTower g y).comp (IsScalarTower.toAlgHom S R (MvPolynomial σ R)) = g :=\n  AlgHom.coe_ringHom_injective <| aevalTower_comp_algebraMap _ _\n\n"}
{"name":"MvPolynomial.aevalTower_id","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"σ : Type u_1\nS : Type u_2\ninst✝ : CommSemiring S\n⊢ Eq (MvPolynomial.aevalTower (AlgHom.id S S)) MvPolynomial.aeval","decl":"@[simp]\ntheorem aevalTower_id :\n    aevalTower (AlgHom.id S S) = (aeval : (σ → S) → MvPolynomial σ S →ₐ[S] S) := by\n  ext\n  simp only [aevalTower_X, aeval_X]\n\n"}
{"name":"MvPolynomial.aevalTower_ofId","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"σ : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝² : CommSemiring S\ninst✝¹ : CommSemiring A\ninst✝ : Algebra S A\n⊢ Eq (MvPolynomial.aevalTower (Algebra.ofId S A)) MvPolynomial.aeval","decl":"@[simp]\ntheorem aevalTower_ofId :\n    aevalTower (Algebra.ofId S A) = (aeval : (σ → A) → MvPolynomial σ S →ₐ[S] A) := by\n  ext\n  simp only [aeval_X, aevalTower_X]\n\n"}
{"name":"MvPolynomial.eval₂_mem","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\nσ : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\nsubS : Type u_3\ninst✝² : CommSemiring S\ninst✝¹ : SetLike subS S\ninst✝ : SubsemiringClass subS S\nf : RingHom R S\np : MvPolynomial σ R\ns : subS\nhs : ∀ (i : Finsupp σ Nat), Membership.mem p.support i → Membership.mem s (f (MvPolynomial.coeff i p))\nv : σ → S\nhv : ∀ (i : σ), Membership.mem s (v i)\n⊢ Membership.mem s (MvPolynomial.eval₂ f v p)","decl":"theorem eval₂_mem {f : R →+* S} {p : MvPolynomial σ R} {s : subS}\n    (hs : ∀ i ∈ p.support, f (p.coeff i) ∈ s) {v : σ → S} (hv : ∀ i, v i ∈ s) :\n    MvPolynomial.eval₂ f v p ∈ s := by\n  classical\n  replace hs : ∀ i, f (p.coeff i) ∈ s := by\n    intro i\n    by_cases hi : i ∈ p.support\n    · exact hs i hi\n    · rw [MvPolynomial.not_mem_support_iff.1 hi, f.map_zero]\n      exact zero_mem s\n  induction' p using MvPolynomial.induction_on''' with a a b f ha _ ih\n  · simpa using hs 0\n  rw [eval₂_add, eval₂_monomial]\n  refine add_mem (mul_mem ?_ <| prod_mem fun i _ => pow_mem (hv _) _) (ih fun i => ?_)\n  · have := hs a -- Porting note: was `simpa only [...]`\n    rwa [coeff_add, MvPolynomial.not_mem_support_iff.1 ha, add_zero, coeff_monomial,\n      if_pos rfl] at this\n  have := hs i\n  rw [coeff_add, coeff_monomial] at this\n  split_ifs at this with h\n  · subst h\n    rw [MvPolynomial.not_mem_support_iff.1 ha, map_zero]\n    exact zero_mem _\n  · rwa [zero_add] at this\n\n"}
{"name":"MvPolynomial.eval_mem","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"σ : Type u_1\nS : Type u_2\nsubS : Type u_3\ninst✝² : CommSemiring S\ninst✝¹ : SetLike subS S\ninst✝ : SubsemiringClass subS S\np : MvPolynomial σ S\ns : subS\nhs : ∀ (i : Finsupp σ Nat), Membership.mem p.support i → Membership.mem s (MvPolynomial.coeff i p)\nv : σ → S\nhv : ∀ (i : σ), Membership.mem s (v i)\n⊢ Membership.mem s ((MvPolynomial.eval v) p)","decl":"theorem eval_mem {p : MvPolynomial σ S} {s : subS} (hs : ∀ i ∈ p.support, p.coeff i ∈ s) {v : σ → S}\n    (hv : ∀ i, v i ∈ s) : MvPolynomial.eval v p ∈ s :=\n  eval₂_mem hs hv\n\n"}
{"name":"MvPolynomial.aeval_sum_elim","module":"Mathlib.Algebra.MvPolynomial.Eval","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nS : Type u_2\nT : Type u_3\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : CommSemiring T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nσ : Type u_4\nτ : Type u_5\np : MvPolynomial (Sum σ τ) R\nf : τ → S\ng : σ → T\n⊢ Eq ((MvPolynomial.aeval (Sum.elim g (Function.comp (⇑(algebraMap S T)) f))) p) ((MvPolynomial.aeval g) ((MvPolynomial.aeval (Sum.elim MvPolynomial.X (Function.comp (⇑MvPolynomial.C) f))) p))","decl":"lemma aeval_sum_elim {σ τ : Type*} (p : MvPolynomial (σ ⊕ τ) R) (f : τ → S) (g : σ → T) :\n    (aeval (Sum.elim g (algebraMap S T ∘ f))) p =\n      (aeval g) ((aeval (Sum.elim X (C ∘ f))) p) := by\n  induction' p using MvPolynomial.induction_on with r p q hp hq p i h\n  · simp [← IsScalarTower.algebraMap_apply]\n  · simp [hp, hq]\n  · cases i <;> simp [h]\n\n"}
