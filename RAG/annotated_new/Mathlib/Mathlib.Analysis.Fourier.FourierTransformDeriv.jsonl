{"name":"Real.hasDerivAt_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"x : Real\n⊢ HasDerivAt (fun x => ↑(Real.fourierChar x)) (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑(Real.fourierChar x)) x","decl":"lemma hasDerivAt_fourierChar (x : ℝ) : HasDerivAt (𝐞 · : ℝ → ℂ) (2 * π * I * 𝐞 x) x := by\n  have h1 (y : ℝ) : 𝐞 y = fourier 1 (y : UnitAddCircle) := by\n    rw [fourierChar_apply, fourier_coe_apply]\n    push_cast\n    ring_nf\n  simpa only [h1, Int.cast_one, ofReal_one, div_one, mul_one] using hasDerivAt_fourier 1 1 x\n\n"}
{"name":"Real.differentiable_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"⊢ Differentiable Real fun x => ↑(Real.fourierChar x)","decl":"lemma differentiable_fourierChar : Differentiable ℝ (𝐞 · : ℝ → ℂ) :=\n  fun x ↦ (Real.hasDerivAt_fourierChar x).differentiableAt\n\n"}
{"name":"Real.deriv_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"x : Real\n⊢ Eq (deriv (fun x => ↑(Real.fourierChar x)) x) (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑(Real.fourierChar x))","decl":"lemma deriv_fourierChar (x : ℝ) : deriv (𝐞 · : ℝ → ℂ) x = 2 * π * I * 𝐞 x :=\n  (Real.hasDerivAt_fourierChar x).deriv\n\n"}
{"name":"Real.hasFDerivAt_fourierChar_neg_bilinear_right","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw : W\n⊢ HasFDerivAt (fun w => ↑(Real.fourierChar (Neg.neg ((L v) w)))) (HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑(Real.fourierChar (Neg.neg ((L v) w)))) (Complex.ofRealCLM.comp (L v))) w","decl":"lemma hasFDerivAt_fourierChar_neg_bilinear_right (v : V) (w : W) :\n    HasFDerivAt (fun w ↦ (𝐞 (-L v w) : ℂ))\n      ((-2 * π * I * 𝐞 (-L v w)) • (ofRealCLM ∘L (L v))) w := by\n  have ha : HasFDerivAt (fun w' : W ↦ L v w') (L v) w := ContinuousLinearMap.hasFDerivAt (L v)\n  convert (hasDerivAt_fourierChar (-L v w)).hasFDerivAt.comp w ha.neg using 1\n  ext y\n  simp only [neg_mul, ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ofRealCLM_apply, smul_eq_mul, ContinuousLinearMap.comp_neg,\n    ContinuousLinearMap.neg_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.one_apply, real_smul, neg_inj]\n  ring\n\n"}
{"name":"Real.fderiv_fourierChar_neg_bilinear_right_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw y : W\n⊢ Eq ((fderiv Real (fun w => ↑(Real.fourierChar (Neg.neg ((L v) w)))) w) y) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑((L v) y)) ↑(Real.fourierChar (Neg.neg ((L v) w))))","decl":"lemma fderiv_fourierChar_neg_bilinear_right_apply (v : V) (w y : W) :\n    fderiv ℝ (fun w ↦ (𝐞 (-L v w) : ℂ)) w y = -2 * π * I * L v y * 𝐞 (-L v w) := by\n  simp only [(hasFDerivAt_fourierChar_neg_bilinear_right L v w).fderiv, neg_mul,\n    ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ofRealCLM_apply, smul_eq_mul, neg_inj]\n  ring\n\n"}
{"name":"Real.differentiable_fourierChar_neg_bilinear_right","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\n⊢ Differentiable Real fun w => ↑(Real.fourierChar (Neg.neg ((L v) w)))","decl":"lemma differentiable_fourierChar_neg_bilinear_right (v : V) :\n    Differentiable ℝ (fun w ↦ (𝐞 (-L v w) : ℂ)) :=\n  fun w ↦ (hasFDerivAt_fourierChar_neg_bilinear_right L v w).differentiableAt\n\n"}
{"name":"Real.hasFDerivAt_fourierChar_neg_bilinear_left","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw : W\n⊢ HasFDerivAt (fun v => ↑(Real.fourierChar (Neg.neg ((L v) w)))) (HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑(Real.fourierChar (Neg.neg ((L v) w)))) (Complex.ofRealCLM.comp (L.flip w))) v","decl":"lemma hasFDerivAt_fourierChar_neg_bilinear_left (v : V) (w : W) :\n    HasFDerivAt (fun v ↦ (𝐞 (-L v w) : ℂ))\n      ((-2 * π * I * 𝐞 (-L v w)) • (ofRealCLM ∘L (L.flip w))) v :=\n  hasFDerivAt_fourierChar_neg_bilinear_right L.flip w v\n\n"}
{"name":"Real.fderiv_fourierChar_neg_bilinear_left_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv y : V\nw : W\n⊢ Eq ((fderiv Real (fun v => ↑(Real.fourierChar (Neg.neg ((L v) w)))) v) y) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑((L y) w)) ↑(Real.fourierChar (Neg.neg ((L v) w))))","decl":"lemma fderiv_fourierChar_neg_bilinear_left_apply (v y : V) (w : W) :\n    fderiv ℝ (fun v ↦ (𝐞 (-L v w) : ℂ)) v y = -2 * π * I * L y w * 𝐞 (-L v w) := by\n  simp only [(hasFDerivAt_fourierChar_neg_bilinear_left L v w).fderiv, neg_mul,\n    ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ContinuousLinearMap.flip_apply, ofRealCLM_apply, smul_eq_mul, neg_inj]\n  ring\n\n"}
{"name":"Real.differentiable_fourierChar_neg_bilinear_left","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nw : W\n⊢ Differentiable Real fun v => ↑(Real.fourierChar (Neg.neg ((L v) w)))","decl":"lemma differentiable_fourierChar_neg_bilinear_left (w : W) :\n    Differentiable ℝ (fun v ↦ (𝐞 (-L v w) : ℂ)) :=\n  fun v ↦ (hasFDerivAt_fourierChar_neg_bilinear_left L v w).differentiableAt\n\n"}
{"name":"VectorFourier.fourierSMulRight_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\nw : W\n⊢ Eq ((VectorFourier.fourierSMulRight L f v) w) (HSMul.hSMul (Neg.neg (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (HSMul.hSMul ((L v) w) (f v)))","decl":"@[simp] lemma fourierSMulRight_apply (v : V) (w : W) :\n    fourierSMulRight L f v w = -(2 * π * I) • L v w • f v := rfl\n\n"}
{"name":"VectorFourier.hasFDerivAt_fourierChar_smul","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\nw : W\n⊢ HasFDerivAt (fun w' => HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w'))) (f v)) (HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w))) (VectorFourier.fourierSMulRight L f v)) w","decl":"/-- The `w`-derivative of the Fourier transform integrand. -/\nlemma hasFDerivAt_fourierChar_smul (v : V) (w : W) :\n    HasFDerivAt (fun w' ↦ 𝐞 (-L v w') • f v) (𝐞 (-L v w) • fourierSMulRight L f v) w := by\n  have ha : HasFDerivAt (fun w' : W ↦ L v w') (L v) w := ContinuousLinearMap.hasFDerivAt (L v)\n  convert ((hasDerivAt_fourierChar (-L v w)).hasFDerivAt.comp w ha.neg).smul_const (f v)\n  ext w' : 1\n  simp_rw [fourierSMulRight, ContinuousLinearMap.smul_apply, ContinuousLinearMap.smulRight_apply]\n  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.neg_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, ← smul_assoc, smul_comm,\n    ← smul_assoc, real_smul, real_smul, Submonoid.smul_def, smul_eq_mul]\n  push_cast\n  ring_nf\n\n"}
{"name":"VectorFourier.norm_fourierSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\n⊢ Eq (Norm.norm (VectorFourier.fourierSMulRight L f v)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm (L v))) (Norm.norm (f v)))","decl":"lemma norm_fourierSMulRight (L : V →L[ℝ] W →L[ℝ] ℝ) (f : V → E) (v : V) :\n    ‖fourierSMulRight L f v‖ = (2 * π) * ‖L v‖ * ‖f v‖ := by\n  rw [fourierSMulRight, norm_smul _ (ContinuousLinearMap.smulRight (L v) (f v)),\n    norm_neg, norm_mul, norm_mul, norm_eq_abs I, abs_I,\n    mul_one, norm_eq_abs ((_ : ℝ) : ℂ), Complex.abs_of_nonneg pi_pos.le, norm_eq_abs (2 : ℂ),\n    Complex.abs_two, ContinuousLinearMap.norm_smulRight_apply, ← mul_assoc]\n\n"}
{"name":"VectorFourier.norm_fourierSMulRight_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\n⊢ LE.le (Norm.norm (VectorFourier.fourierSMulRight L f v)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) (Norm.norm v)) (Norm.norm (f v)))","decl":"lemma norm_fourierSMulRight_le (L : V →L[ℝ] W →L[ℝ] ℝ) (f : V → E) (v : V) :\n    ‖fourierSMulRight L f v‖ ≤ 2 * π * ‖L‖ * ‖v‖ * ‖f v‖ := calc\n  ‖fourierSMulRight L f v‖ = (2 * π) * ‖L v‖ * ‖f v‖ := norm_fourierSMulRight _ _ _\n  _ ≤ (2 * π) * (‖L‖ * ‖v‖) * ‖f v‖ := by gcongr; exact L.le_opNorm _\n  _ = 2 * π * ‖L‖ * ‖v‖ * ‖f v‖ := by ring\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.fourierSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\ninst✝² : SecondCountableTopologyEither V (ContinuousLinearMap (RingHom.id Real) W Real)\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nμ : MeasureTheory.Measure V\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun v => VectorFourier.fourierSMulRight L f v) μ","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.fourierSMulRight\n    [SecondCountableTopologyEither V (W →L[ℝ] ℝ)] [MeasurableSpace V] [BorelSpace V]\n    {L : V →L[ℝ] W →L[ℝ] ℝ} {f : V → E} {μ : Measure V}\n    (hf : AEStronglyMeasurable f μ) :\n    AEStronglyMeasurable (fun v ↦ fourierSMulRight L f v) μ := by\n  apply AEStronglyMeasurable.const_smul'\n  have aux0 : Continuous fun p : (W →L[ℝ] ℝ) × E ↦ p.1.smulRight p.2 :=\n    (ContinuousLinearMap.smulRightL ℝ W E).continuous₂\n  have aux1 : AEStronglyMeasurable (fun v ↦ (L v, f v)) μ :=\n    L.continuous.aestronglyMeasurable.prod_mk hf\n  -- Elaboration without the expected type is faster here:\n  exact (aux0.comp_aestronglyMeasurable aux1 :)\n\n"}
{"name":"VectorFourier.hasFDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : SecondCountableTopology V\nμ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f μ\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) μ\nw : W\n⊢ HasFDerivAt (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (VectorFourier.fourierSMulRight L f) w) w","decl":"/-- Main theorem of this section: if both `f` and `x ↦ ‖x‖ * ‖f x‖` are integrable, then the\nFourier transform of `f` has a Fréchet derivative (everywhere in its domain) and its derivative is\nthe Fourier transform of `smulRight L f`. -/\ntheorem hasFDerivAt_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {μ : Measure V}\n    (hf : Integrable f μ) (hf' : Integrable (fun v : V ↦ ‖v‖ * ‖f v‖) μ) (w : W) :\n    HasFDerivAt (fourierIntegral 𝐞 μ L.toLinearMap₂ f)\n      (fourierIntegral 𝐞 μ L.toLinearMap₂ (fourierSMulRight L f) w) w := by\n  let F : W → V → E := fun w' v ↦ 𝐞 (-L v w') • f v\n  let F' : W → V → W →L[ℝ] E := fun w' v ↦ 𝐞 (-L v w') • fourierSMulRight L f v\n  let B : V → ℝ := fun v ↦ 2 * π * ‖L‖ * ‖v‖ * ‖f v‖\n  have h0 (w' : W) : Integrable (F w') μ :=\n    (fourierIntegral_convergent_iff continuous_fourierChar\n      (by apply L.continuous₂ : Continuous (fun p : V × W ↦ L.toLinearMap₂ p.1 p.2)) w').2 hf\n  have h1 : ∀ᶠ w' in 𝓝 w, AEStronglyMeasurable (F w') μ :=\n    Eventually.of_forall (fun w' ↦ (h0 w').aestronglyMeasurable)\n  have h3 : AEStronglyMeasurable (F' w) μ := by\n    refine .smul ?_ hf.1.fourierSMulRight\n    refine (continuous_fourierChar.comp ?_).aestronglyMeasurable\n    exact (L.continuous₂.comp (Continuous.Prod.mk_left w)).neg\n  have h4 : (∀ᵐ v ∂μ, ∀ (w' : W), w' ∈ Metric.ball w 1 → ‖F' w' v‖ ≤ B v) := by\n    filter_upwards with v w' _\n    rw [Circle.norm_smul _ (fourierSMulRight L f v)]\n    exact norm_fourierSMulRight_le L f v\n  have h5 : Integrable B μ := by simpa only [← mul_assoc] using hf'.const_mul (2 * π * ‖L‖)\n  have h6 : ∀ᵐ v ∂μ, ∀ w', w' ∈ Metric.ball w 1 → HasFDerivAt (fun x ↦ F x v) (F' w' v) w' :=\n    ae_of_all _ (fun v w' _ ↦ hasFDerivAt_fourierChar_smul L f v w')\n  exact hasFDerivAt_integral_of_dominated_of_fderiv_le one_pos h1 (h0 w) h3 h4 h5 h6\n\n"}
{"name":"VectorFourier.fderiv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : SecondCountableTopology V\nμ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f μ\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) μ\n⊢ Eq (fderiv Real (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (VectorFourier.fourierSMulRight L f))","decl":"lemma fderiv_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {μ : Measure V}\n    (hf : Integrable f μ) (hf' : Integrable (fun v : V ↦ ‖v‖ * ‖f v‖) μ) :\n    fderiv ℝ (fourierIntegral 𝐞 μ L.toLinearMap₂ f) =\n      fourierIntegral 𝐞 μ L.toLinearMap₂ (fourierSMulRight L f) := by\n  ext w : 1\n  exact (hasFDerivAt_fourierIntegral L hf hf' w).fderiv\n\n"}
{"name":"VectorFourier.differentiable_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : SecondCountableTopology V\nμ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f μ\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) μ\n⊢ Differentiable Real (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)","decl":"lemma differentiable_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {μ : Measure V}\n    (hf : Integrable f μ) (hf' : Integrable (fun v : V ↦ ‖v‖ * ‖f v‖) μ) :\n    Differentiable ℝ (fourierIntegral 𝐞 μ L.toLinearMap₂ f) :=\n  fun w ↦ (hasFDerivAt_fourierIntegral L hf hf' w).differentiableAt\n\n"}
{"name":"VectorFourier.fourierIntegral_fderiv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝³ : MeasurableSpace V\ninst✝² : BorelSpace V\ninst✝¹ : FiniteDimensional Real V\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddHaarMeasure\nhf : MeasureTheory.Integrable f μ\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (fderiv Real f) μ\n⊢ Eq (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (fderiv Real f)) (VectorFourier.fourierSMulRight (Neg.neg L.flip) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f))","decl":"/-- The Fourier integral of the derivative of a function is obtained by multiplying the Fourier\nintegral of the original function by `-L w v`. -/\ntheorem fourierIntegral_fderiv [MeasurableSpace V] [BorelSpace V] [FiniteDimensional ℝ V]\n    {μ : Measure V} [Measure.IsAddHaarMeasure μ]\n    (hf : Integrable f μ) (h'f : Differentiable ℝ f) (hf' : Integrable (fderiv ℝ f) μ) :\n    fourierIntegral 𝐞 μ L.toLinearMap₂ (fderiv ℝ f)\n      = fourierSMulRight (-L.flip) (fourierIntegral 𝐞 μ L.toLinearMap₂ f) := by\n  ext w y\n  let g (v : V) : ℂ := 𝐞 (-L v w)\n  /- First rewrite things in a simplified form, without any real change. -/\n  suffices ∫ x, g x • fderiv ℝ f x y ∂μ = ∫ x, (2 * ↑π * I * L y w * g x) • f x ∂μ by\n    rw [fourierIntegral_continuousLinearMap_apply' hf']\n    simpa only [fourierIntegral, ContinuousLinearMap.toLinearMap₂_apply, fourierSMulRight_apply,\n      ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply, ← integral_smul, neg_smul,\n      smul_neg, ← smul_smul, coe_smul, neg_neg]\n  -- Key step: integrate by parts with respect to `y` to switch the derivative from `f` to `g`.\n  have A x : fderiv ℝ g x y = - 2 * ↑π * I * L y w * g x :=\n    fderiv_fourierChar_neg_bilinear_left_apply _ _ _ _\n  rw [integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable, ← integral_neg]\n  · congr with x\n    simp only [A, neg_mul, neg_smul, neg_neg]\n  · have : Integrable (fun x ↦ (-(2 * ↑π * I * ↑((L y) w)) • ((g x : ℂ) • f x))) μ :=\n      ((fourierIntegral_convergent_iff' _ _).2 hf).smul _\n    convert this using 2 with x\n    simp only [A, neg_mul, neg_smul, smul_smul]\n  · exact (fourierIntegral_convergent_iff' _ _).2 (hf'.apply_continuousLinearMap _)\n  · exact (fourierIntegral_convergent_iff' _ _).2 hf\n  · exact differentiable_fourierChar_neg_bilinear_left _ _\n  · exact h'f\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\nn : Nat\nm : Fin n → W\n⊢ Eq ((VectorFourier.fourierPowSMulRight L f v n) m) (HSMul.hSMul (HPow.hPow (Neg.neg (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) n) (HSMul.hSMul (Finset.univ.prod fun i => (L v) (m i)) (f v)))","decl":"@[simp 1100] lemma fourierPowSMulRight_apply {f : V → E} {v : V} {n : ℕ} {m : Fin n → W} :\n    fourierPowSMulRight L f v n m = (- (2 * π * I))^n • (∏ i, L v (m i)) • f v := by\n  simp [fourierPowSMulRight]\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_eq_comp","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\nn : Nat\n⊢ Eq (VectorFourier.fourierPowSMulRight L f v n) (HSMul.hSMul (HPow.hPow (Neg.neg (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) n) (((ContinuousMultilinearMap.smulRightL Real (fun x => W) E) ((ContinuousMultilinearMap.mkPiAlgebra Real (Fin n) Real).compContinuousLinearMapLRight fun x => L v)) (f v)))","decl":"/-- Decomposing `fourierPowSMulRight L f v n` as a composition of continuous bilinear and\nmultilinear maps, to deduce easily its continuity and differentiability properties. -/\nlemma fourierPowSMulRight_eq_comp {f : V → E} {v : V} {n : ℕ} :\n    fourierPowSMulRight L f v n = (- (2 * π * I))^n • smulRightL ℝ (fun (_ : Fin n) ↦ W) E\n      (compContinuousLinearMapLRight\n        (ContinuousMultilinearMap.mkPiAlgebra ℝ (Fin n) ℝ) (fun _ ↦ L v)) (f v) := rfl\n\n"}
{"name":"Continuous.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nhf : Continuous f\nn : Nat\n⊢ Continuous fun v => VectorFourier.fourierPowSMulRight L f v n","decl":"@[continuity, fun_prop]\nlemma _root_.Continuous.fourierPowSMulRight {f : V → E} (hf : Continuous f) (n : ℕ) :\n    Continuous (fun v ↦ fourierPowSMulRight L f v n) := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply Continuous.const_smul\n  apply (smulRightL ℝ (fun (_ : Fin n) ↦ W) E).continuous₂.comp₂ _ hf\n  exact Continuous.comp (map_continuous _) (continuous_pi (fun _ ↦ L.continuous))\n\n"}
{"name":"ContDiff.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nk : WithTop ENat\nhf : ContDiff Real k f\nn : Nat\n⊢ ContDiff Real k fun v => VectorFourier.fourierPowSMulRight L f v n","decl":"lemma _root_.ContDiff.fourierPowSMulRight\n    {f : V → E} {k : WithTop ℕ∞} (hf : ContDiff ℝ k f) (n : ℕ) :\n    ContDiff ℝ k (fun v ↦ fourierPowSMulRight L f v n) := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply ContDiff.const_smul\n  apply (smulRightL ℝ (fun (_ : Fin n) ↦ W) E).isBoundedBilinearMap.contDiff.comp₂ _ hf\n  apply (ContinuousMultilinearMap.contDiff _).comp\n  exact contDiff_pi.2 (fun _ ↦ L.contDiff)\n\n"}
{"name":"VectorFourier.norm_fourierPowSMulRight_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nv : V\nn : Nat\n⊢ LE.le (Norm.norm (VectorFourier.fourierPowSMulRight L f v n)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) n) (HPow.hPow (Norm.norm v) n)) (Norm.norm (f v)))","decl":"lemma norm_fourierPowSMulRight_le (f : V → E) (v : V) (n : ℕ) :\n    ‖fourierPowSMulRight L f v n‖ ≤ (2 * π * ‖L‖) ^ n * ‖v‖ ^ n * ‖f v‖ := by\n  apply ContinuousMultilinearMap.opNorm_le_bound (by positivity) (fun m ↦ ?_)\n  calc\n  ‖fourierPowSMulRight L f v n m‖\n    = (2 * π) ^ n * ((∏ x : Fin n, |(L v) (m x)|) * ‖f v‖) := by\n      simp [_root_.abs_of_nonneg pi_nonneg, norm_smul]\n  _ ≤ (2 * π) ^ n * ((∏ x : Fin n, ‖L‖ * ‖v‖ * ‖m x‖) * ‖f v‖) := by\n      gcongr with i _hi\n      exact L.le_opNorm₂ v (m i)\n  _ = (2 * π * ‖L‖) ^ n * ‖v‖ ^ n * ‖f v‖ * ∏ i : Fin n, ‖m i‖ := by\n      simp [Finset.prod_mul_distrib, mul_pow]; ring\n\n"}
{"name":"VectorFourier.norm_iteratedFDeriv_fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : NormedAddCommGroup W\ninst✝ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\nK : WithTop ENat\nC : Real\nhf : ContDiff Real K f\nn k : Nat\nhk : LE.le (↑k) K\nv : V\nhv : ∀ (i : Nat), LE.le i k → ∀ (j : Nat), LE.le j n → LE.le (HMul.hMul (HPow.hPow (Norm.norm v) j) (Norm.norm (iteratedFDeriv Real i f v))) C\n⊢ LE.le (Norm.norm (iteratedFDeriv Real k (fun v => VectorFourier.fourierPowSMulRight L f v n) v)) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) n) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 ↑n) 2) k)) (HPow.hPow (Norm.norm L) n)) C)","decl":"set_option maxSynthPendingDepth 2 in\n/-- The iterated derivative of a function multiplied by `(L v ⬝) ^ n` can be controlled in terms\nof the iterated derivatives of the initial function. -/\nlemma norm_iteratedFDeriv_fourierPowSMulRight\n    {f : V → E} {K : WithTop ℕ∞} {C : ℝ} (hf : ContDiff ℝ K f) {n : ℕ} {k : ℕ} (hk : k ≤ K)\n    {v : V} (hv : ∀ i ≤ k, ∀ j ≤ n, ‖v‖ ^ j * ‖iteratedFDeriv ℝ i f v‖ ≤ C) :\n    ‖iteratedFDeriv ℝ k (fun v ↦ fourierPowSMulRight L f v n) v‖ ≤\n      (2 * π) ^ n * (2 * n + 2) ^ k * ‖L‖ ^ n * C := by\n  /- We write `fourierPowSMulRight L f v n` as a composition of bilinear and multilinear maps,\n  thanks to `fourierPowSMulRight_eq_comp`, and then we control the iterated derivatives of these\n  thanks to general bounds on derivatives of bilinear and multilinear maps. More precisely,\n  `fourierPowSMulRight L f v n m = (- (2 * π * I))^n • (∏ i, L v (m i)) • f v`. Here,\n  `(- (2 * π * I))^n` contributes `(2π)^n` to the bound. The second product is bilinear, so the\n  iterated derivative is controlled as a weighted sum of those of `v ↦ ∏ i, L v (m i)` and of `f`.\n\n  The harder part is to control the iterated derivatives of `v ↦ ∏ i, L v (m i)`. For this, one\n  argues that this is multilinear in `v`, to apply general bounds for iterated derivatives of\n  multilinear maps. More precisely, we write it as the composition of a multilinear map `T` (making\n  the product operation) and the tuple of linear maps `v ↦ (L v ⬝, ..., L v ⬝)` -/\n  simp_rw [fourierPowSMulRight_eq_comp]\n  -- first step: controlling the iterated derivatives of `v ↦ ∏ i, L v (m i)`, written below\n  -- as `v ↦ T (fun _ ↦ L v)`, or `T ∘ (ContinuousLinearMap.pi (fun (_ : Fin n) ↦ L))`.\n  let T : (W →L[ℝ] ℝ) [×n]→L[ℝ] (W [×n]→L[ℝ] ℝ) :=\n    compContinuousLinearMapLRight (ContinuousMultilinearMap.mkPiAlgebra ℝ (Fin n) ℝ)\n  have I₁ m : ‖iteratedFDeriv ℝ m T (fun _ ↦ L v)‖ ≤\n      n.descFactorial m * 1 * (‖L‖ * ‖v‖) ^ (n - m) := by\n    have : ‖T‖ ≤ 1 := by\n      apply (norm_compContinuousLinearMapLRight_le _ _).trans\n      simp only [norm_mkPiAlgebra, le_refl]\n    apply (ContinuousMultilinearMap.norm_iteratedFDeriv_le _ _ _).trans\n    simp only [Fintype.card_fin]\n    gcongr\n    refine (pi_norm_le_iff_of_nonneg (by positivity)).mpr (fun _ ↦ ?_)\n    exact ContinuousLinearMap.le_opNorm _ _\n  have I₂ m : ‖iteratedFDeriv ℝ m (T ∘ (ContinuousLinearMap.pi (fun (_ : Fin n) ↦ L))) v‖ ≤\n      (n.descFactorial m * 1 * (‖L‖ * ‖v‖) ^ (n - m)) * ‖L‖ ^ m := by\n    rw [ContinuousLinearMap.iteratedFDeriv_comp_right _ (ContinuousMultilinearMap.contDiff _)\n      _ (mod_cast le_top)]\n    apply (norm_compContinuousLinearMap_le _ _).trans\n    simp only [Finset.prod_const, Finset.card_fin]\n    gcongr\n    · exact I₁ m\n    · exact ContinuousLinearMap.norm_pi_le_of_le (fun _ ↦ le_rfl) (norm_nonneg _)\n  have I₃ m : ‖iteratedFDeriv ℝ m (T ∘ (ContinuousLinearMap.pi (fun (_ : Fin n) ↦ L))) v‖ ≤\n      n.descFactorial m * ‖L‖ ^ n * ‖v‖ ^ (n - m) := by\n    apply (I₂ m).trans (le_of_eq _)\n    rcases le_or_lt m n with hm | hm\n    · rw [show ‖L‖ ^ n = ‖L‖ ^ (m + (n - m)) by rw [Nat.add_sub_cancel' hm], pow_add]\n      ring\n    · simp only [Nat.descFactorial_eq_zero_iff_lt.mpr hm, CharP.cast_eq_zero, mul_one, zero_mul]\n  -- second step: factor out the `(2 * π) ^ n` factor, and cancel it on both sides.\n  have A : ContDiff ℝ K (fun y ↦ T (fun _ ↦ L y)) :=\n    (ContinuousMultilinearMap.contDiff _).comp (contDiff_pi.2 fun _ ↦ L.contDiff)\n  rw [iteratedFDeriv_const_smul_apply' (hf := ((smulRightL ℝ (fun _ ↦ W)\n    E).isBoundedBilinearMap.contDiff.comp₂ (A.of_le hk) (hf.of_le hk)).contDiffAt),\n    norm_smul (β := V [×k]→L[ℝ] (W [×n]→L[ℝ] E))]\n  simp only [norm_pow, norm_neg, norm_mul, RCLike.norm_ofNat, Complex.norm_eq_abs, abs_ofReal,\n    _root_.abs_of_nonneg pi_nonneg, abs_I, mul_one, mul_assoc]\n  gcongr\n  -- third step: argue that the scalar multiplication is bilinear to bound the iterated derivatives\n  -- of `v ↦ (∏ i, L v (m i)) • f v` in terms of those of `v ↦ (∏ i, L v (m i))` and of `f`.\n  -- The former are controlled by the first step, the latter by the assumptions.\n  apply (ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear_of_le_one _ A hf _\n    hk ContinuousMultilinearMap.norm_smulRightL_le).trans\n  calc\n  ∑ i ∈ Finset.range (k + 1),\n    k.choose i * ‖iteratedFDeriv ℝ i (fun (y : V) ↦ T (fun _ ↦ L y)) v‖ *\n      ‖iteratedFDeriv ℝ (k - i) f v‖\n    ≤ ∑ i ∈ Finset.range (k + 1),\n      k.choose i * (n.descFactorial i * ‖L‖ ^ n * ‖v‖ ^ (n - i)) *\n        ‖iteratedFDeriv ℝ (k - i) f v‖ := by\n    gcongr with i _hi\n    exact I₃ i\n  _ = ∑ i ∈ Finset.range (k + 1), (k.choose i * n.descFactorial i * ‖L‖ ^ n) *\n        (‖v‖ ^ (n - i) * ‖iteratedFDeriv ℝ (k - i) f v‖) := by\n    congr with i\n    ring\n  _ ≤ ∑ i ∈ Finset.range (k + 1), (k.choose i * (n + 1 : ℕ) ^ k * ‖L‖ ^ n) * C := by\n    gcongr with i hi\n    · rw [← Nat.cast_pow, Nat.cast_le]\n      calc n.descFactorial i ≤ n ^ i := Nat.descFactorial_le_pow _ _\n      _ ≤ (n + 1) ^ i := by gcongr; omega\n      _ ≤ (n + 1) ^ k := by gcongr; exacts [le_add_self, Finset.mem_range_succ_iff.mp hi]\n    · exact hv _ (by omega) _ (by omega)\n  _ = (2 * n + 2) ^ k * (‖L‖^n * C) := by\n    simp only [← Finset.sum_mul, ← Nat.cast_sum, Nat.sum_range_choose, mul_one, ← mul_assoc,\n      Nat.cast_pow, Nat.cast_ofNat, Nat.cast_add, Nat.cast_one, ← mul_pow, mul_add]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nhf : MeasureTheory.AEStronglyMeasurable f μ\nn : Nat\n⊢ MeasureTheory.AEStronglyMeasurable (fun v => VectorFourier.fourierPowSMulRight L f v n) μ","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.fourierPowSMulRight\n    (hf : AEStronglyMeasurable f μ) (n : ℕ) :\n    AEStronglyMeasurable (fun v ↦ fourierPowSMulRight L f v n) μ := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply AEStronglyMeasurable.const_smul'\n  apply (smulRightL ℝ (fun (_ : Fin n) ↦ W) E).continuous₂.comp_aestronglyMeasurable₂ _ hf\n  apply Continuous.aestronglyMeasurable\n  exact Continuous.comp (map_continuous _) (continuous_pi (fun _ ↦ L.continuous))\n\n"}
{"name":"VectorFourier.integrable_fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nn : Nat\nhf : MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) μ\nh'f : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.Integrable (fun v => VectorFourier.fourierPowSMulRight L f v n) μ","decl":"lemma integrable_fourierPowSMulRight {n : ℕ} (hf : Integrable (fun v ↦ ‖v‖ ^ n * ‖f v‖) μ)\n    (h'f : AEStronglyMeasurable f μ) : Integrable (fun v ↦ fourierPowSMulRight L f v n) μ := by\n  refine (hf.const_mul ((2 * π * ‖L‖) ^ n)).mono' (h'f.fourierPowSMulRight L n) ?_\n  filter_upwards with v\n  exact (norm_fourierPowSMulRight_le L f v n).trans (le_of_eq (by ring))\n\n"}
{"name":"VectorFourier.hasFTaylorSeriesUpTo_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nN : WithTop ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) μ\nh'f : MeasureTheory.AEStronglyMeasurable f μ\n⊢ HasFTaylorSeriesUpTo N (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f) fun w n => VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (fun v => VectorFourier.fourierPowSMulRight L f v n) w","decl":"lemma hasFTaylorSeriesUpTo_fourierIntegral {N : WithTop ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖) μ)\n    (h'f : AEStronglyMeasurable f μ) :\n    HasFTaylorSeriesUpTo N (fourierIntegral 𝐞 μ L.toLinearMap₂ f)\n      (fun w n ↦ fourierIntegral 𝐞 μ L.toLinearMap₂ (fun v ↦ fourierPowSMulRight L f v n) w) := by\n  constructor\n  · intro w\n    rw [curry0_apply, Matrix.zero_empty, fourierIntegral_continuousMultilinearMap_apply'\n      (integrable_fourierPowSMulRight L (hf 0 bot_le) h'f)]\n    simp only [fourierPowSMulRight_apply, pow_zero, Finset.univ_eq_empty, Finset.prod_empty,\n      one_smul]\n  · intro n hn w\n    have I₁ : Integrable (fun v ↦ fourierPowSMulRight L f v n) μ :=\n      integrable_fourierPowSMulRight L (hf n hn.le) h'f\n    have I₂ : Integrable (fun v ↦ ‖v‖ * ‖fourierPowSMulRight L f v n‖) μ := by\n      apply ((hf (n+1) (ENat.add_one_natCast_le_withTop_of_lt hn)).const_mul\n          ((2 * π * ‖L‖) ^ n)).mono'\n        (continuous_norm.aestronglyMeasurable.mul (h'f.fourierPowSMulRight L n).norm)\n      filter_upwards with v\n      simp only [Pi.mul_apply, norm_mul, norm_norm]\n      calc\n      ‖v‖ * ‖fourierPowSMulRight L f v n‖\n        ≤ ‖v‖ * ((2 * π * ‖L‖) ^ n * ‖v‖ ^ n * ‖f v‖) := by\n          gcongr; apply norm_fourierPowSMulRight_le\n      _ = (2 * π * ‖L‖) ^ n * (‖v‖ ^ (n + 1) * ‖f v‖) := by rw [pow_succ]; ring\n    have I₃ : Integrable (fun v ↦ fourierPowSMulRight L f v (n + 1)) μ :=\n      integrable_fourierPowSMulRight L (hf (n + 1) (ENat.add_one_natCast_le_withTop_of_lt hn)) h'f\n    have I₄ : Integrable\n        (fun v ↦ fourierSMulRight L (fun v ↦ fourierPowSMulRight L f v n) v) μ := by\n      apply (I₂.const_mul ((2 * π * ‖L‖))).mono' (h'f.fourierPowSMulRight L n).fourierSMulRight\n      filter_upwards with v\n      exact (norm_fourierSMulRight_le _ _ _).trans (le_of_eq (by ring))\n    have E : curryLeft\n          (fourierIntegral 𝐞 μ L.toLinearMap₂ (fun v ↦ fourierPowSMulRight L f v (n + 1)) w) =\n        fourierIntegral 𝐞 μ L.toLinearMap₂\n          (fourierSMulRight L fun v ↦ fourierPowSMulRight L f v n) w := by\n      ext w' m\n      rw [curryLeft_apply, fourierIntegral_continuousMultilinearMap_apply' I₃,\n        fourierIntegral_continuousLinearMap_apply' I₄,\n        fourierIntegral_continuousMultilinearMap_apply' (I₄.apply_continuousLinearMap _)]\n      congr with v\n      simp only [fourierPowSMulRight_apply, mul_comm, pow_succ, neg_mul, Fin.prod_univ_succ,\n        Fin.cons_zero, Fin.cons_succ, neg_smul, fourierSMulRight_apply, neg_apply, smul_apply,\n        smul_comm (M := ℝ) (N := ℂ) (α := E), smul_smul]\n    exact E ▸ hasFDerivAt_fourierIntegral L I₁ I₂ w\n  · intro n hn\n    apply fourierIntegral_continuous Real.continuous_fourierChar (by apply L.continuous₂)\n    exact integrable_fourierPowSMulRight L (hf n hn) h'f\n\n"}
{"name":"VectorFourier.hasFTaylorSeriesUpTo_fourierIntegral'","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nN : ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) μ\nh'f : MeasureTheory.AEStronglyMeasurable f μ\n⊢ HasFTaylorSeriesUpTo (↑N) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f) fun w n => VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (fun v => VectorFourier.fourierPowSMulRight L f v n) w","decl":"/-- Variant of `hasFTaylorSeriesUpTo_fourierIntegral` in which the smoothness index is restricted\nto `ℕ∞` (and so are the inequalities in the assumption `hf`). Avoids normcasting in some\napplications. -/\nlemma hasFTaylorSeriesUpTo_fourierIntegral' {N : ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖) μ)\n    (h'f : AEStronglyMeasurable f μ) :\n    HasFTaylorSeriesUpTo N (fourierIntegral 𝐞 μ L.toLinearMap₂ f)\n      (fun w n ↦ fourierIntegral 𝐞 μ L.toLinearMap₂ (fun v ↦ fourierPowSMulRight L f v n) w) :=\n  hasFTaylorSeriesUpTo_fourierIntegral _ (fun n hn ↦ hf n (mod_cast hn)) h'f\n\n"}
{"name":"VectorFourier.contDiff_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nN : ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) μ\n⊢ ContDiff Real (↑N) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)","decl":"/-- If `‖v‖^n * ‖f v‖` is integrable for all `n ≤ N`, then the Fourier transform of `f` is `C^N`. -/\ntheorem contDiff_fourierIntegral {N : ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖) μ) :\n    ContDiff ℝ N (fourierIntegral 𝐞 μ L.toLinearMap₂ f) := by\n  by_cases h'f : Integrable f μ\n  · exact (hasFTaylorSeriesUpTo_fourierIntegral' L hf h'f.1).contDiff\n  · have : fourierIntegral 𝐞 μ L.toLinearMap₂ f = 0 := by\n      ext w; simp [fourierIntegral, integral, h'f]\n    simpa [this] using contDiff_const\n\n"}
{"name":"VectorFourier.iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedSpace Real V\ninst✝⁴ : NormedAddCommGroup W\ninst✝³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\nμ : MeasureTheory.Measure V\ninst✝ : SecondCountableTopology V\nN : ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) μ\nh'f : MeasureTheory.AEStronglyMeasurable f μ\nn : Nat\nhn : LE.le (↑n) N\n⊢ Eq (iteratedFDeriv Real n (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ fun v => VectorFourier.fourierPowSMulRight L f v n)","decl":"/-- If `‖v‖^n * ‖f v‖` is integrable for all `n ≤ N`, then the `n`-th derivative of the Fourier\ntransform of `f` is the Fourier transform of `fourierPowSMulRight L f v n`,\ni.e., `(L v ⬝) ^ n • f v`. -/\nlemma iteratedFDeriv_fourierIntegral {N : ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖) μ)\n    (h'f : AEStronglyMeasurable f μ) {n : ℕ} (hn : n ≤ N) :\n    iteratedFDeriv ℝ n (fourierIntegral 𝐞 μ L.toLinearMap₂ f) =\n      fourierIntegral 𝐞 μ L.toLinearMap₂ (fun v ↦ fourierPowSMulRight L f v n) := by\n  ext w : 1\n  exact ((hasFTaylorSeriesUpTo_fourierIntegral' L hf h'f).eq_iteratedFDeriv\n    (mod_cast hn) w).symm\n\n"}
{"name":"VectorFourier.fourierIntegral_iteratedFDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝³ : MeasurableSpace V\ninst✝² : BorelSpace V\ninst✝¹ : FiniteDimensional Real V\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddHaarMeasure\nN : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (iteratedFDeriv Real n f) μ\nn : Nat\nhn : LE.le (↑n) N\n⊢ Eq (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (iteratedFDeriv Real n f)) fun w => VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f) w n","decl":"/-- The Fourier integral of the `n`-th derivative of a function is obtained by multiplying the\nFourier integral of the original function by `(2πI L w ⬝ )^n`. -/\ntheorem fourierIntegral_iteratedFDeriv [FiniteDimensional ℝ V]\n    {μ : Measure V} [Measure.IsAddHaarMeasure μ] {N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (n : ℕ), n ≤ N → Integrable (iteratedFDeriv ℝ n f) μ) {n : ℕ} (hn : n ≤ N) :\n    fourierIntegral 𝐞 μ L.toLinearMap₂ (iteratedFDeriv ℝ n f)\n      = (fun w ↦ fourierPowSMulRight (-L.flip) (fourierIntegral 𝐞 μ L.toLinearMap₂ f) w n) := by\n  induction n with\n  | zero =>\n    ext w m\n    simp only [iteratedFDeriv_zero_apply, fourierPowSMulRight_apply, pow_zero,\n      Finset.univ_eq_empty, ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply,\n      Finset.prod_empty, one_smul, fourierIntegral_continuousMultilinearMap_apply' ((h'f 0 bot_le))]\n  | succ n ih =>\n    ext w m\n    have J : Integrable (fderiv ℝ (iteratedFDeriv ℝ n f)) μ := by\n      specialize h'f (n + 1) hn\n      rwa [iteratedFDeriv_succ_eq_comp_left, Function.comp_def,\n          LinearIsometryEquiv.integrable_comp_iff (𝕜 := ℝ) (φ := fderiv ℝ (iteratedFDeriv ℝ n f))]\n        at h'f\n    suffices H : (fourierIntegral 𝐞 μ L.toLinearMap₂ (fderiv ℝ (iteratedFDeriv ℝ n f)) w)\n          (m 0) (Fin.tail m) =\n        (-(2 * π * I)) ^ (n + 1) • (∏ x : Fin (n + 1), -L (m x) w) • ∫ v, 𝐞 (-L v w) • f v ∂μ by\n      rw [fourierIntegral_continuousMultilinearMap_apply' (h'f _ hn)]\n      simp only [iteratedFDeriv_succ_apply_left, fourierPowSMulRight_apply,\n        ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply]\n      rw [← fourierIntegral_continuousMultilinearMap_apply' ((J.apply_continuousLinearMap _)),\n          ← fourierIntegral_continuousLinearMap_apply' J]\n      exact H\n    have h'n : n < N := (Nat.cast_lt.mpr n.lt_succ_self).trans_le hn\n    rw [fourierIntegral_fderiv _ (h'f n h'n.le)\n      (hf.differentiable_iteratedFDeriv (mod_cast h'n)) J]\n    simp only [ih h'n.le, fourierSMulRight_apply, ContinuousLinearMap.neg_apply,\n      ContinuousLinearMap.flip_apply, neg_smul, smul_neg, neg_neg, smul_apply,\n      fourierPowSMulRight_apply, ← coe_smul (E := E), smul_smul]\n    congr 1\n    simp only [ofReal_prod, ofReal_neg, pow_succ, mul_neg, Fin.prod_univ_succ, neg_mul,\n      ofReal_mul, neg_neg, Fin.tail_def]\n    ring\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝³ : MeasurableSpace V\ninst✝² : BorelSpace V\ninst✝¹ : FiniteDimensional Real V\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (k n : Nat), LE.le (↑k) K → LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) μ\nk n : Nat\nhk : LE.le (↑k) K\nhn : LE.le (↑n) N\nw : W\n⊢ Eq (VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)) w n) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (iteratedFDeriv Real n fun v => VectorFourier.fourierPowSMulRight L f v k) w)","decl":"/-- The `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`, is the\nFourier integral of the `n`-th derivative of `(L v w) ^ k * f`. -/\ntheorem fourierPowSMulRight_iteratedFDeriv_fourierIntegral [FiniteDimensional ℝ V]\n    {μ : Measure V} [Measure.IsAddHaarMeasure μ] {K N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (k n : ℕ), k ≤ K → n ≤ N → Integrable (fun v ↦ ‖v‖^k * ‖iteratedFDeriv ℝ n f v‖) μ)\n    {k n : ℕ} (hk : k ≤ K) (hn : n ≤ N) {w : W} :\n    fourierPowSMulRight (-L.flip)\n      (iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w n =\n    fourierIntegral 𝐞 μ L.toLinearMap₂\n      (iteratedFDeriv ℝ n (fun v ↦ fourierPowSMulRight L f v k)) w := by\n  rw [fourierIntegral_iteratedFDeriv (N := N) _ (hf.fourierPowSMulRight _ _) _ hn]\n  · congr\n    rw [iteratedFDeriv_fourierIntegral (N := K) _ _ hf.continuous.aestronglyMeasurable hk]\n    intro k hk\n    simpa only [norm_iteratedFDeriv_zero] using h'f k 0 hk bot_le\n  · intro m hm\n    have I : Integrable (fun v ↦ ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (m + 1),\n        ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖) μ := by\n      apply integrable_finset_sum _ (fun p hp ↦ ?_)\n      simp only [Finset.mem_product, Finset.mem_range_succ_iff] at hp\n      exact h'f _ _ ((Nat.cast_le.2 hp.1).trans hk) ((Nat.cast_le.2 hp.2).trans hm)\n    apply (I.const_mul ((2 * π) ^ k * (2 * k + 2) ^ m * ‖L‖ ^ k)).mono'\n      ((hf.fourierPowSMulRight L k).continuous_iteratedFDeriv (mod_cast hm)).aestronglyMeasurable\n    filter_upwards with v\n    refine norm_iteratedFDeriv_fourierPowSMulRight _ hf (mod_cast hm) (fun i hi j hj ↦ ?_)\n    apply Finset.single_le_sum (f := fun p ↦ ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖) (a := (j, i))\n    · intro i _hi\n      positivity\n    · simpa only [Finset.mem_product, Finset.mem_range_succ_iff] using ⟨hj, hi⟩\n\n"}
{"name":"VectorFourier.norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝³ : MeasurableSpace V\ninst✝² : BorelSpace V\ninst✝¹ : FiniteDimensional Real V\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (k n : Nat), LE.le (↑k) K → LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) μ\nk n : Nat\nhk : LE.le (↑k) K\nhn : LE.le (↑n) N\nw : W\n⊢ LE.le (Norm.norm (VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f)) w n)) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) k) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 ↑k) 2) n)) (HPow.hPow (Norm.norm L) k)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral μ fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound the `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`,\nin terms of integrals of iterated derivatives of `f` (of order up to `n`) multiplied by `‖v‖ ^ i`\n(for `i ≤ k`).\nAuxiliary version in terms of the operator norm of `fourierPowSMulRight (-L.flip) ⬝`. For a version\nin terms of `|L v w| ^ n * ⬝`, see `pow_mul_norm_iteratedFDeriv_fourierIntegral_le`.\n-/\ntheorem norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le [FiniteDimensional ℝ V]\n    {μ : Measure V} [Measure.IsAddHaarMeasure μ] {K N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (k n : ℕ), k ≤ K → n ≤ N → Integrable (fun v ↦ ‖v‖^k * ‖iteratedFDeriv ℝ n f v‖) μ)\n    {k n : ℕ} (hk : k ≤ K) (hn : n ≤ N) {w : W} :\n    ‖fourierPowSMulRight (-L.flip)\n      (iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w n‖ ≤\n    (2 * π) ^ k * (2 * k + 2) ^ n * ‖L‖ ^ k * ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n      ∫ v, ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ ∂μ := by\n  rw [fourierPowSMulRight_iteratedFDeriv_fourierIntegral L hf h'f hk hn]\n  apply (norm_fourierIntegral_le_integral_norm _ _ _ _ _).trans\n  have I p (hp : p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1)) :\n      Integrable (fun v ↦ ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖) μ := by\n    simp only [Finset.mem_product, Finset.mem_range_succ_iff] at hp\n    exact h'f _ _ (le_trans (by simpa using hp.1) hk) (le_trans (by simpa using hp.2) hn)\n  rw [← integral_finset_sum _ I, ← integral_mul_left]\n  apply integral_mono_of_nonneg\n  · filter_upwards with v using norm_nonneg _\n  · exact (integrable_finset_sum _ I).const_mul _\n  · filter_upwards with v\n    apply norm_iteratedFDeriv_fourierPowSMulRight _ hf (mod_cast hn) _\n    intro i hi j hj\n    apply Finset.single_le_sum (f := fun p ↦ ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖) (a := (j, i))\n    · intro i _hi\n      positivity\n    · simp only [Finset.mem_product, Finset.mem_range_succ_iff]\n      exact ⟨hj, hi⟩\n\n"}
{"name":"VectorFourier.pow_mul_norm_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V → E\ninst✝³ : MeasurableSpace V\ninst✝² : BorelSpace V\ninst✝¹ : FiniteDimensional Real V\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (k n : Nat), LE.le (↑k) K → LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) μ\nk n : Nat\nhk : LE.le (↑k) K\nhn : LE.le (↑n) N\nv : V\nw : W\n⊢ LE.le (HMul.hMul (HPow.hPow (abs ((L v) w)) n) (Norm.norm (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f) w))) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (Norm.norm v) n) (HPow.hPow (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) k)) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 ↑k) 2) n)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral μ fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound the `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`,\nin terms of integrals of iterated derivatives of `f` (of order up to `n`) multiplied by `‖v‖ ^ i`\n(for `i ≤ k`). -/\nlemma pow_mul_norm_iteratedFDeriv_fourierIntegral_le [FiniteDimensional ℝ V]\n    {μ : Measure V} [Measure.IsAddHaarMeasure μ] {K N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (k n : ℕ), k ≤ K → n ≤ N → Integrable (fun v ↦ ‖v‖^k * ‖iteratedFDeriv ℝ n f v‖) μ)\n    {k n : ℕ} (hk : k ≤ K) (hn : n ≤ N) (v : V) (w : W) :\n    |L v w| ^ n * ‖(iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w‖ ≤\n      ‖v‖ ^ n * (2 * π * ‖L‖) ^ k * (2 * k + 2) ^ n *\n        ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n          ∫ v, ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ ∂μ := calc\n  |L v w| ^ n * ‖(iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w‖\n  _ ≤ (2 * π) ^ n\n      * (|L v w| ^ n * ‖iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f) w‖) := by\n    apply le_mul_of_one_le_left (by positivity)\n    apply one_le_pow₀\n    linarith [one_le_pi_div_two]\n  _ = ‖fourierPowSMulRight (-L.flip)\n        (iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w n (fun _ ↦ v)‖ := by\n    simp [norm_smul, _root_.abs_of_nonneg pi_nonneg]\n  _ ≤ ‖fourierPowSMulRight (-L.flip)\n        (iteratedFDeriv ℝ k (fourierIntegral 𝐞 μ L.toLinearMap₂ f)) w n‖ * ∏ _ : Fin n, ‖v‖ :=\n    le_opNorm _ _\n  _ ≤ ((2 * π) ^ k * (2 * k + 2) ^ n * ‖L‖ ^ k *\n      ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n        ∫ v, ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ ∂μ) * ‖v‖ ^ n := by\n    gcongr\n    · apply norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le _ hf h'f hk hn\n    · simp\n  _ = ‖v‖ ^ n * (2 * π * ‖L‖) ^ k * (2 * k + 2) ^ n *\n        ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n          ∫ v, ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ ∂μ := by\n    simp [mul_pow]\n    ring\n\n"}
{"name":"Real.hasFDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nx : V\n⊢ HasFDerivAt (Real.fourierIntegral f) (Real.fourierIntegral (VectorFourier.fourierSMulRight (innerSL Real) f) x) x","decl":"/-- The Fréchet derivative of the Fourier transform of `f` is the Fourier transform of\n    `fun v ↦ -2 * π * I ⟪v, ⬝⟫ f v`. -/\ntheorem hasFDerivAt_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v ↦ ‖v‖ * ‖f v‖)) (x : V) :\n    HasFDerivAt (𝓕 f) (𝓕 (fourierSMulRight (innerSL ℝ) f) x) x :=\n  VectorFourier.hasFDerivAt_fourierIntegral (innerSL ℝ) hf_int hvf_int x\n\n"}
{"name":"Real.fderiv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\n⊢ Eq (fderiv Real (Real.fourierIntegral f)) (Real.fourierIntegral (VectorFourier.fourierSMulRight (innerSL Real) f))","decl":"/-- The Fréchet derivative of the Fourier transform of `f` is the Fourier transform of\n    `fun v ↦ -2 * π * I ⟪v, ⬝⟫ f v`. -/\ntheorem fderiv_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v ↦ ‖v‖ * ‖f v‖)) :\n    fderiv ℝ (𝓕 f) = 𝓕 (fourierSMulRight (innerSL ℝ) f) :=\n  VectorFourier.fderiv_fourierIntegral (innerSL ℝ) hf_int hvf_int\n\n"}
{"name":"Real.differentiable_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\n⊢ Differentiable Real (Real.fourierIntegral f)","decl":"theorem differentiable_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v ↦ ‖v‖ * ‖f v‖)) :\n    Differentiable ℝ (𝓕 f) :=\n  VectorFourier.differentiable_fourierIntegral (innerSL ℝ) hf_int hvf_int\n\n"}
{"name":"Real.fourierIntegral_fderiv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (fderiv Real f) MeasureTheory.MeasureSpace.volume\n⊢ Eq (Real.fourierIntegral (fderiv Real f)) (VectorFourier.fourierSMulRight (Neg.neg (innerSL Real)) (Real.fourierIntegral f))","decl":"/-- The Fourier integral of the Fréchet derivative of a function is obtained by multiplying the\nFourier integral of the original function by `2πI ⟪v, w⟫`. -/\ntheorem fourierIntegral_fderiv\n    (hf : Integrable f) (h'f : Differentiable ℝ f) (hf' : Integrable (fderiv ℝ f)) :\n    𝓕 (fderiv ℝ f) = fourierSMulRight (-innerSL ℝ) (𝓕 f) := by\n  rw [← innerSL_real_flip V]\n  exact VectorFourier.fourierIntegral_fderiv (innerSL ℝ) hf h'f hf'\n\n"}
{"name":"Real.contDiff_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nN : ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\n⊢ ContDiff Real (↑N) (Real.fourierIntegral f)","decl":"/-- If `‖v‖^n * ‖f v‖` is integrable, then the Fourier transform of `f` is `C^n`. -/\ntheorem contDiff_fourierIntegral {N : ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖)) :\n    ContDiff ℝ N (𝓕 f) :=\n  VectorFourier.contDiff_fourierIntegral (innerSL ℝ) hf\n\n"}
{"name":"Real.iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nN : ENat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.AEStronglyMeasurable f MeasureTheory.MeasureSpace.volume\nn : Nat\nhn : LE.le (↑n) N\n⊢ Eq (iteratedFDeriv Real n (Real.fourierIntegral f)) (Real.fourierIntegral fun v => VectorFourier.fourierPowSMulRight (innerSL Real) f v n)","decl":"/-- If `‖v‖^n * ‖f v‖` is integrable, then the `n`-th derivative of the Fourier transform of `f` is\n  the Fourier transform of `fun v ↦ (-2 * π * I) ^ n ⟪v, ⬝⟫^n f v`. -/\ntheorem iteratedFDeriv_fourierIntegral {N : ℕ∞}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun v ↦ ‖v‖^n * ‖f v‖))\n    (h'f : AEStronglyMeasurable f) {n : ℕ} (hn : n ≤ N) :\n    iteratedFDeriv ℝ n (𝓕 f) = 𝓕 (fun v ↦ fourierPowSMulRight (innerSL ℝ) f v n) :=\n  VectorFourier.iteratedFDeriv_fourierIntegral (innerSL ℝ) hf h'f hn\n\n"}
{"name":"Real.fourierIntegral_iteratedFDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nN : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (iteratedFDeriv Real n f) MeasureTheory.MeasureSpace.volume\nn : Nat\nhn : LE.le (↑n) N\n⊢ Eq (Real.fourierIntegral (iteratedFDeriv Real n f)) fun w => VectorFourier.fourierPowSMulRight (Neg.neg (innerSL Real)) (Real.fourierIntegral f) w n","decl":"/-- The Fourier integral of the `n`-th derivative of a function is obtained by multiplying the\nFourier integral of the original function by `(2πI L w ⬝ )^n`. -/\ntheorem fourierIntegral_iteratedFDeriv {N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (n : ℕ), n ≤ N → Integrable (iteratedFDeriv ℝ n f)) {n : ℕ} (hn : n ≤ N) :\n    𝓕 (iteratedFDeriv ℝ n f)\n      = (fun w ↦ fourierPowSMulRight (-innerSL ℝ) (𝓕 f) w n) := by\n  rw [← innerSL_real_flip V]\n  exact VectorFourier.fourierIntegral_iteratedFDeriv (innerSL ℝ) hf h'f hn\n\n"}
{"name":"Real.pow_mul_norm_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : FiniteDimensional Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nf : V → E\nK N : ENat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (k n : Nat), LE.le (↑k) K → LE.le (↑n) N → MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) MeasureTheory.MeasureSpace.volume\nk n : Nat\nhk : LE.le (↑k) K\nhn : LE.le (↑n) N\nw : V\n⊢ LE.le (HMul.hMul (HPow.hPow (Norm.norm w) n) (Norm.norm (iteratedFDeriv Real k (Real.fourierIntegral f) w))) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) k) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 ↑k) 2) n)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound `‖w‖^n * ‖D^k (𝓕 f) w‖` in terms of integrals of the derivatives of `f` (or order\nat most `n`) multiplied by powers of `v` (of order at most `k`). -/\nlemma pow_mul_norm_iteratedFDeriv_fourierIntegral_le\n    {K N : ℕ∞} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (k n : ℕ), k ≤ K → n ≤ N → Integrable (fun v ↦ ‖v‖^k * ‖iteratedFDeriv ℝ n f v‖))\n    {k n : ℕ} (hk : k ≤ K) (hn : n ≤ N) (w : V) :\n    ‖w‖ ^ n * ‖iteratedFDeriv ℝ k (𝓕 f) w‖ ≤ (2 * π) ^ k * (2 * k + 2) ^ n *\n      ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n        ∫ v, ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ := by\n  have Z : ‖w‖ ^ n * (‖w‖ ^ n * ‖iteratedFDeriv ℝ k (𝓕 f) w‖) ≤\n      ‖w‖ ^ n * ((2 * (π * ‖innerSL (E := V) ℝ‖)) ^ k * ((2 * k + 2) ^ n *\n          ∑ p ∈ Finset.range (k + 1) ×ˢ Finset.range (n + 1),\n            ∫ (v : V), ‖v‖ ^ p.1 * ‖iteratedFDeriv ℝ p.2 f v‖ ∂volume)) := by\n    have := VectorFourier.pow_mul_norm_iteratedFDeriv_fourierIntegral_le (innerSL ℝ) hf h'f hk hn\n      w w\n    simp only [innerSL_apply _ w w, real_inner_self_eq_norm_sq w, _root_.abs_pow, abs_norm,\n      mul_assoc] at this\n    rwa [pow_two, mul_pow, mul_assoc] at this\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp only [pow_zero, one_mul, mul_one, zero_add, Finset.range_one, Finset.product_singleton,\n      Finset.sum_map, Function.Embedding.coeFn_mk, norm_iteratedFDeriv_zero] at Z ⊢\n    apply Z.trans\n    conv_rhs => rw [← mul_one π]\n    gcongr\n    exact norm_innerSL_le _\n  rcases eq_or_ne w 0 with rfl | hw\n  · simp [hn]\n    positivity\n  rw [mul_le_mul_left (pow_pos (by simp [hw]) n)] at Z\n  apply Z.trans\n  conv_rhs => rw [← mul_one π]\n  simp only [mul_assoc]\n  gcongr\n  exact norm_innerSL_le _\n\n"}
{"name":"Real.hasDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhf' : MeasureTheory.Integrable (fun x => HSMul.hSMul x (f x)) MeasureTheory.MeasureSpace.volume\nw : Real\n⊢ HasDerivAt (Real.fourierIntegral f) (Real.fourierIntegral (fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑x) (f x)) w) w","decl":"lemma hasDerivAt_fourierIntegral\n    {f : ℝ → E} (hf : Integrable f) (hf' : Integrable (fun x : ℝ ↦ x • f x)) (w : ℝ) :\n    HasDerivAt (𝓕 f) (𝓕 (fun x : ℝ ↦ (-2 * π * I * x) • f x) w) w := by\n  have hf'' : Integrable (fun v : ℝ ↦ ‖v‖ * ‖f v‖) := by simpa only [norm_smul] using hf'.norm\n  let L := ContinuousLinearMap.mul ℝ ℝ\n  have h_int : Integrable fun v ↦ fourierSMulRight L f v := by\n    suffices Integrable fun v ↦ ContinuousLinearMap.smulRight (L v) (f v) by\n      simpa only [fourierSMulRight, neg_smul, neg_mul, Pi.smul_apply] using this.smul (-2 * π * I)\n    convert ((ContinuousLinearMap.ring_lmap_equiv_self ℝ\n      E).symm.toContinuousLinearEquiv.toContinuousLinearMap).integrable_comp hf' using 2 with v\n    apply ContinuousLinearMap.ext_ring\n    rw [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.mul_apply', mul_one,\n      ContinuousLinearMap.map_smul]\n    exact congr_arg (fun x ↦ v • x) (one_smul ℝ (f v)).symm\n  rw [← VectorFourier.fourierIntegral_convergent_iff continuous_fourierChar L.continuous₂ w]\n    at h_int\n  convert (VectorFourier.hasFDerivAt_fourierIntegral L hf hf'' w).hasDerivAt using 1\n  erw [ContinuousLinearMap.integral_apply h_int]\n  simp_rw [ContinuousLinearMap.smul_apply, fourierSMulRight, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, L, ContinuousLinearMap.mul_apply', mul_one,\n    ← neg_mul, mul_smul]\n  rfl\n\n"}
{"name":"Real.deriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhf' : MeasureTheory.Integrable (fun x => HSMul.hSMul x (f x)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (deriv (Real.fourierIntegral f)) (Real.fourierIntegral fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑x) (f x))","decl":"theorem deriv_fourierIntegral\n    {f : ℝ → E} (hf : Integrable f) (hf' : Integrable (fun x : ℝ ↦ x • f x)) :\n    deriv (𝓕 f) = 𝓕 (fun x : ℝ ↦ (-2 * π * I * x) • f x) := by\n  ext x\n  exact (hasDerivAt_fourierIntegral hf hf' x).deriv\n\n"}
{"name":"Real.fourierIntegral_deriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (deriv f) MeasureTheory.MeasureSpace.volume\n⊢ Eq (Real.fourierIntegral (deriv f)) fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑x) (Real.fourierIntegral f x)","decl":"/-- The Fourier integral of the Fréchet derivative of a function is obtained by multiplying the\nFourier integral of the original function by `2πI x`. -/\ntheorem fourierIntegral_deriv\n    {f : ℝ → E} (hf : Integrable f) (h'f : Differentiable ℝ f) (hf' : Integrable (deriv f)) :\n    𝓕 (deriv f) = fun (x : ℝ) ↦ (2 * π * I * x) • (𝓕 f x) := by\n  ext x\n  have I : Integrable (fun x ↦ fderiv ℝ f x) := by\n    simpa only [← deriv_fderiv] using (ContinuousLinearMap.smulRightL ℝ ℝ E 1).integrable_comp hf'\n  have : 𝓕 (deriv f) x = 𝓕 (fderiv ℝ f) x 1 := by\n    simp only [fourierIntegral_continuousLinearMap_apply I, fderiv_deriv]\n  rw [this, fourierIntegral_fderiv hf h'f I]\n  simp only [fourierSMulRight_apply, ContinuousLinearMap.neg_apply, innerSL_apply, smul_smul,\n    RCLike.inner_apply, conj_trivial, mul_one, neg_smul, smul_neg, neg_neg, neg_mul, ← coe_smul]\n\n"}
{"name":"Real.iteratedDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nN : ENat\nn : Nat\nhf : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (fun x => HSMul.hSMul (HPow.hPow x n) (f x)) MeasureTheory.MeasureSpace.volume\nhn : LE.le (↑n) N\n⊢ Eq (iteratedDeriv n (Real.fourierIntegral f)) (Real.fourierIntegral fun x => HSMul.hSMul (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑x) n) (f x))","decl":"theorem iteratedDeriv_fourierIntegral {f : ℝ → E} {N : ℕ∞} {n : ℕ}\n    (hf : ∀ (n : ℕ), n ≤ N → Integrable (fun x ↦ x^n • f x)) (hn : n ≤ N) :\n    iteratedDeriv n (𝓕 f) = 𝓕 (fun x : ℝ ↦ (-2 * π * I * x) ^ n • f x) := by\n  ext x : 1\n  have A (n : ℕ) (hn : n ≤ N) : Integrable (fun v ↦ ‖v‖^n * ‖f v‖) := by\n    convert (hf n hn).norm with x\n    simp [norm_smul]\n  have B : AEStronglyMeasurable f := by simpa using (hf 0 (zero_le _)).1\n  rw [iteratedDeriv, iteratedFDeriv_fourierIntegral A B hn,\n    fourierIntegral_continuousMultilinearMap_apply (integrable_fourierPowSMulRight _ (A n hn) B),\n    fourierIntegral_eq, fourierIntegral_eq]\n  congr with y\n  suffices (-(2 * π * I)) ^ n • y ^ n • f y = (-(2 * π * I * y)) ^ n • f y by\n    simpa [innerSL_apply _]\n  simp only [← neg_mul, ← coe_smul, smul_smul, mul_pow, ofReal_pow, mul_assoc]\n\n"}
{"name":"Real.fourierIntegral_iteratedDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nN : ENat\nn : Nat\nhf : ContDiff Real (↑N) f\nh'f : ∀ (n : Nat), LE.le (↑n) N → MeasureTheory.Integrable (iteratedDeriv n f) MeasureTheory.MeasureSpace.volume\nhn : LE.le (↑n) N\n⊢ Eq (Real.fourierIntegral (iteratedDeriv n f)) fun x => HSMul.hSMul (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑x) n) (Real.fourierIntegral f x)","decl":"theorem fourierIntegral_iteratedDeriv {f : ℝ → E} {N : ℕ∞} {n : ℕ} (hf : ContDiff ℝ N f)\n    (h'f : ∀ (n : ℕ), n ≤ N → Integrable (iteratedDeriv n f)) (hn : n ≤ N) :\n    𝓕 (iteratedDeriv n f) = fun (x : ℝ) ↦ (2 * π * I * x) ^ n • (𝓕 f x) := by\n  ext x : 1\n  have A : ∀ (n : ℕ), n ≤ N → Integrable (iteratedFDeriv ℝ n f) := by\n    intro n hn\n    rw [iteratedFDeriv_eq_equiv_comp]\n    exact (LinearIsometryEquiv.integrable_comp_iff _).2 (h'f n hn)\n  change 𝓕 (fun x ↦ iteratedDeriv n f x) x = _\n  simp_rw [iteratedDeriv, ← fourierIntegral_continuousMultilinearMap_apply (A n hn),\n    fourierIntegral_iteratedFDeriv hf A hn]\n  simp [← coe_smul, smul_smul, ← mul_pow]\n\n"}
