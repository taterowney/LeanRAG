{"name":"Real.hasDerivAt_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"x : Real\nâŠ¢ HasDerivAt (fun x => â†‘(Real.fourierChar x)) (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) â†‘(Real.fourierChar x)) x","decl":"lemma hasDerivAt_fourierChar (x : â„) : HasDerivAt (ğ Â· : â„ â†’ â„‚) (2 * Ï€ * I * ğ x) x := by\n  have h1 (y : â„) : ğ y = fourier 1 (y : UnitAddCircle) := by\n    rw [fourierChar_apply, fourier_coe_apply]\n    push_cast\n    ring_nf\n  simpa only [h1, Int.cast_one, ofReal_one, div_one, mul_one] using hasDerivAt_fourier 1 1 x\n\n"}
{"name":"Real.differentiable_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"âŠ¢ Differentiable Real fun x => â†‘(Real.fourierChar x)","decl":"lemma differentiable_fourierChar : Differentiable â„ (ğ Â· : â„ â†’ â„‚) :=\n  fun x â†¦ (Real.hasDerivAt_fourierChar x).differentiableAt\n\n"}
{"name":"Real.deriv_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"x : Real\nâŠ¢ Eq (deriv (fun x => â†‘(Real.fourierChar x)) x) (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) â†‘(Real.fourierChar x))","decl":"lemma deriv_fourierChar (x : â„) : deriv (ğ Â· : â„ â†’ â„‚) x = 2 * Ï€ * I * ğ x :=\n  (Real.hasDerivAt_fourierChar x).deriv\n\n"}
{"name":"Real.hasFDerivAt_fourierChar_neg_bilinear_right","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw : W\nâŠ¢ HasFDerivAt (fun w => â†‘(Real.fourierChar (Neg.neg ((L v) w)))) (HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘(Real.fourierChar (Neg.neg ((L v) w)))) (Complex.ofRealCLM.comp (L v))) w","decl":"lemma hasFDerivAt_fourierChar_neg_bilinear_right (v : V) (w : W) :\n    HasFDerivAt (fun w â†¦ (ğ (-L v w) : â„‚))\n      ((-2 * Ï€ * I * ğ (-L v w)) â€¢ (ofRealCLM âˆ˜L (L v))) w := by\n  have ha : HasFDerivAt (fun w' : W â†¦ L v w') (L v) w := ContinuousLinearMap.hasFDerivAt (L v)\n  convert (hasDerivAt_fourierChar (-L v w)).hasFDerivAt.comp w ha.neg using 1\n  ext y\n  simp only [neg_mul, ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ofRealCLM_apply, smul_eq_mul, ContinuousLinearMap.comp_neg,\n    ContinuousLinearMap.neg_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.one_apply, real_smul, neg_inj]\n  ring\n\n"}
{"name":"Real.fderiv_fourierChar_neg_bilinear_right_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw y : W\nâŠ¢ Eq ((fderiv Real (fun w => â†‘(Real.fourierChar (Neg.neg ((L v) w)))) w) y) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘((L v) y)) â†‘(Real.fourierChar (Neg.neg ((L v) w))))","decl":"lemma fderiv_fourierChar_neg_bilinear_right_apply (v : V) (w y : W) :\n    fderiv â„ (fun w â†¦ (ğ (-L v w) : â„‚)) w y = -2 * Ï€ * I * L v y * ğ (-L v w) := by\n  simp only [(hasFDerivAt_fourierChar_neg_bilinear_right L v w).fderiv, neg_mul,\n    ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ofRealCLM_apply, smul_eq_mul, neg_inj]\n  ring\n\n"}
{"name":"Real.differentiable_fourierChar_neg_bilinear_right","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nâŠ¢ Differentiable Real fun w => â†‘(Real.fourierChar (Neg.neg ((L v) w)))","decl":"lemma differentiable_fourierChar_neg_bilinear_right (v : V) :\n    Differentiable â„ (fun w â†¦ (ğ (-L v w) : â„‚)) :=\n  fun w â†¦ (hasFDerivAt_fourierChar_neg_bilinear_right L v w).differentiableAt\n\n"}
{"name":"Real.hasFDerivAt_fourierChar_neg_bilinear_left","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv : V\nw : W\nâŠ¢ HasFDerivAt (fun v => â†‘(Real.fourierChar (Neg.neg ((L v) w)))) (HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘(Real.fourierChar (Neg.neg ((L v) w)))) (Complex.ofRealCLM.comp (L.flip w))) v","decl":"lemma hasFDerivAt_fourierChar_neg_bilinear_left (v : V) (w : W) :\n    HasFDerivAt (fun v â†¦ (ğ (-L v w) : â„‚))\n      ((-2 * Ï€ * I * ğ (-L v w)) â€¢ (ofRealCLM âˆ˜L (L.flip w))) v :=\n  hasFDerivAt_fourierChar_neg_bilinear_right L.flip w v\n\n"}
{"name":"Real.fderiv_fourierChar_neg_bilinear_left_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nv y : V\nw : W\nâŠ¢ Eq ((fderiv Real (fun v => â†‘(Real.fourierChar (Neg.neg ((L v) w)))) v) y) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘((L y) w)) â†‘(Real.fourierChar (Neg.neg ((L v) w))))","decl":"lemma fderiv_fourierChar_neg_bilinear_left_apply (v y : V) (w : W) :\n    fderiv â„ (fun v â†¦ (ğ (-L v w) : â„‚)) v y = -2 * Ï€ * I * L y w * ğ (-L v w) := by\n  simp only [(hasFDerivAt_fourierChar_neg_bilinear_left L v w).fderiv, neg_mul,\n    ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_comp', Pi.smul_apply,\n    Function.comp_apply, ContinuousLinearMap.flip_apply, ofRealCLM_apply, smul_eq_mul, neg_inj]\n  ring\n\n"}
{"name":"Real.differentiable_fourierChar_neg_bilinear_left","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"V : Type u_1\nW : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nw : W\nâŠ¢ Differentiable Real fun v => â†‘(Real.fourierChar (Neg.neg ((L v) w)))","decl":"lemma differentiable_fourierChar_neg_bilinear_left (w : W) :\n    Differentiable â„ (fun v â†¦ (ğ (-L v w) : â„‚)) :=\n  fun v â†¦ (hasFDerivAt_fourierChar_neg_bilinear_left L v w).differentiableAt\n\n"}
{"name":"VectorFourier.fourierSMulRight_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nw : W\nâŠ¢ Eq ((VectorFourier.fourierSMulRight L f v) w) (HSMul.hSMul (Neg.neg (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (HSMul.hSMul ((L v) w) (f v)))","decl":"@[simp] lemma fourierSMulRight_apply (v : V) (w : W) :\n    fourierSMulRight L f v w = -(2 * Ï€ * I) â€¢ L v w â€¢ f v := rfl\n\n"}
{"name":"VectorFourier.hasFDerivAt_fourierChar_smul","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nw : W\nâŠ¢ HasFDerivAt (fun w' => HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w'))) (f v)) (HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w))) (VectorFourier.fourierSMulRight L f v)) w","decl":"/-- The `w`-derivative of the Fourier transform integrand. -/\nlemma hasFDerivAt_fourierChar_smul (v : V) (w : W) :\n    HasFDerivAt (fun w' â†¦ ğ (-L v w') â€¢ f v) (ğ (-L v w) â€¢ fourierSMulRight L f v) w := by\n  have ha : HasFDerivAt (fun w' : W â†¦ L v w') (L v) w := ContinuousLinearMap.hasFDerivAt (L v)\n  convert ((hasDerivAt_fourierChar (-L v w)).hasFDerivAt.comp w ha.neg).smul_const (f v)\n  ext w' : 1\n  simp_rw [fourierSMulRight, ContinuousLinearMap.smul_apply, ContinuousLinearMap.smulRight_apply]\n  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.neg_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, â† smul_assoc, smul_comm,\n    â† smul_assoc, real_smul, real_smul, Submonoid.smul_def, smul_eq_mul]\n  push_cast\n  ring_nf\n\n"}
{"name":"VectorFourier.norm_fourierSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nâŠ¢ Eq (Norm.norm (VectorFourier.fourierSMulRight L f v)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm (L v))) (Norm.norm (f v)))","decl":"lemma norm_fourierSMulRight (L : V â†’L[â„] W â†’L[â„] â„) (f : V â†’ E) (v : V) :\n    â€–fourierSMulRight L f vâ€– = (2 * Ï€) * â€–L vâ€– * â€–f vâ€– := by\n  rw [fourierSMulRight, norm_smul _ (ContinuousLinearMap.smulRight (L v) (f v)),\n    norm_neg, norm_mul, norm_mul, norm_eq_abs I, abs_I,\n    mul_one, norm_eq_abs ((_ : â„) : â„‚), Complex.abs_of_nonneg pi_pos.le, norm_eq_abs (2 : â„‚),\n    Complex.abs_two, ContinuousLinearMap.norm_smulRight_apply, â† mul_assoc]\n\n"}
{"name":"VectorFourier.norm_fourierSMulRight_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nâŠ¢ LE.le (Norm.norm (VectorFourier.fourierSMulRight L f v)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) (Norm.norm v)) (Norm.norm (f v)))","decl":"lemma norm_fourierSMulRight_le (L : V â†’L[â„] W â†’L[â„] â„) (f : V â†’ E) (v : V) :\n    â€–fourierSMulRight L f vâ€– â‰¤ 2 * Ï€ * â€–Lâ€– * â€–vâ€– * â€–f vâ€– := calc\n  â€–fourierSMulRight L f vâ€– = (2 * Ï€) * â€–L vâ€– * â€–f vâ€– := norm_fourierSMulRight _ _ _\n  _ â‰¤ (2 * Ï€) * (â€–Lâ€– * â€–vâ€–) * â€–f vâ€– := by gcongr; exact L.le_opNorm _\n  _ = 2 * Ï€ * â€–Lâ€– * â€–vâ€– * â€–f vâ€– := by ring\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.fourierSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\ninstâœÂ² : SecondCountableTopologyEither V (ContinuousLinearMap (RingHom.id Real) W Real)\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nÎ¼ : MeasureTheory.Measure V\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun v => VectorFourier.fourierSMulRight L f v) Î¼","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.fourierSMulRight\n    [SecondCountableTopologyEither V (W â†’L[â„] â„)] [MeasurableSpace V] [BorelSpace V]\n    {L : V â†’L[â„] W â†’L[â„] â„} {f : V â†’ E} {Î¼ : Measure V}\n    (hf : AEStronglyMeasurable f Î¼) :\n    AEStronglyMeasurable (fun v â†¦ fourierSMulRight L f v) Î¼ := by\n  apply AEStronglyMeasurable.const_smul'\n  have aux0 : Continuous fun p : (W â†’L[â„] â„) Ã— E â†¦ p.1.smulRight p.2 :=\n    (ContinuousLinearMap.smulRightL â„ W E).continuousâ‚‚\n  have aux1 : AEStronglyMeasurable (fun v â†¦ (L v, f v)) Î¼ :=\n    L.continuous.aestronglyMeasurable.prod_mk hf\n  -- Elaboration without the expected type is faster here:\n  exact (aux0.comp_aestronglyMeasurable aux1 :)\n\n"}
{"name":"VectorFourier.hasFDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : SecondCountableTopology V\nÎ¼ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f Î¼\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) Î¼\nw : W\nâŠ¢ HasFDerivAt (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (VectorFourier.fourierSMulRight L f) w) w","decl":"/-- Main theorem of this section: if both `f` and `x â†¦ â€–xâ€– * â€–f xâ€–` are integrable, then the\nFourier transform of `f` has a FrÃ©chet derivative (everywhere in its domain) and its derivative is\nthe Fourier transform of `smulRight L f`. -/\ntheorem hasFDerivAt_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {Î¼ : Measure V}\n    (hf : Integrable f Î¼) (hf' : Integrable (fun v : V â†¦ â€–vâ€– * â€–f vâ€–) Î¼) (w : W) :\n    HasFDerivAt (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)\n      (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fourierSMulRight L f) w) w := by\n  let F : W â†’ V â†’ E := fun w' v â†¦ ğ (-L v w') â€¢ f v\n  let F' : W â†’ V â†’ W â†’L[â„] E := fun w' v â†¦ ğ (-L v w') â€¢ fourierSMulRight L f v\n  let B : V â†’ â„ := fun v â†¦ 2 * Ï€ * â€–Lâ€– * â€–vâ€– * â€–f vâ€–\n  have h0 (w' : W) : Integrable (F w') Î¼ :=\n    (fourierIntegral_convergent_iff continuous_fourierChar\n      (by apply L.continuousâ‚‚ : Continuous (fun p : V Ã— W â†¦ L.toLinearMapâ‚‚ p.1 p.2)) w').2 hf\n  have h1 : âˆ€á¶  w' in ğ“ w, AEStronglyMeasurable (F w') Î¼ :=\n    Eventually.of_forall (fun w' â†¦ (h0 w').aestronglyMeasurable)\n  have h3 : AEStronglyMeasurable (F' w) Î¼ := by\n    refine .smul ?_ hf.1.fourierSMulRight\n    refine (continuous_fourierChar.comp ?_).aestronglyMeasurable\n    exact (L.continuousâ‚‚.comp (Continuous.Prod.mk_left w)).neg\n  have h4 : (âˆ€áµ v âˆ‚Î¼, âˆ€ (w' : W), w' âˆˆ Metric.ball w 1 â†’ â€–F' w' vâ€– â‰¤ B v) := by\n    filter_upwards with v w' _\n    rw [Circle.norm_smul _ (fourierSMulRight L f v)]\n    exact norm_fourierSMulRight_le L f v\n  have h5 : Integrable B Î¼ := by simpa only [â† mul_assoc] using hf'.const_mul (2 * Ï€ * â€–Lâ€–)\n  have h6 : âˆ€áµ v âˆ‚Î¼, âˆ€ w', w' âˆˆ Metric.ball w 1 â†’ HasFDerivAt (fun x â†¦ F x v) (F' w' v) w' :=\n    ae_of_all _ (fun v w' _ â†¦ hasFDerivAt_fourierChar_smul L f v w')\n  exact hasFDerivAt_integral_of_dominated_of_fderiv_le one_pos h1 (h0 w) h3 h4 h5 h6\n\n"}
{"name":"VectorFourier.fderiv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : SecondCountableTopology V\nÎ¼ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f Î¼\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) Î¼\nâŠ¢ Eq (fderiv Real (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (VectorFourier.fourierSMulRight L f))","decl":"lemma fderiv_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {Î¼ : Measure V}\n    (hf : Integrable f Î¼) (hf' : Integrable (fun v : V â†¦ â€–vâ€– * â€–f vâ€–) Î¼) :\n    fderiv â„ (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) =\n      fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fourierSMulRight L f) := by\n  ext w : 1\n  exact (hasFDerivAt_fourierIntegral L hf hf' w).fderiv\n\n"}
{"name":"VectorFourier.differentiable_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : SecondCountableTopology V\nÎ¼ : MeasureTheory.Measure V\nhf : MeasureTheory.Integrable f Î¼\nhf' : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) Î¼\nâŠ¢ Differentiable Real (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)","decl":"lemma differentiable_fourierIntegral\n    [MeasurableSpace V] [BorelSpace V] [SecondCountableTopology V] {Î¼ : Measure V}\n    (hf : Integrable f Î¼) (hf' : Integrable (fun v : V â†¦ â€–vâ€– * â€–f vâ€–) Î¼) :\n    Differentiable â„ (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) :=\n  fun w â†¦ (hasFDerivAt_fourierIntegral L hf hf' w).differentiableAt\n\n"}
{"name":"VectorFourier.fourierIntegral_fderiv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nhf : MeasureTheory.Integrable f Î¼\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (fderiv Real f) Î¼\nâŠ¢ Eq (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (fderiv Real f)) (VectorFourier.fourierSMulRight (Neg.neg L.flip) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f))","decl":"/-- The Fourier integral of the derivative of a function is obtained by multiplying the Fourier\nintegral of the original function by `-L w v`. -/\ntheorem fourierIntegral_fderiv [MeasurableSpace V] [BorelSpace V] [FiniteDimensional â„ V]\n    {Î¼ : Measure V} [Measure.IsAddHaarMeasure Î¼]\n    (hf : Integrable f Î¼) (h'f : Differentiable â„ f) (hf' : Integrable (fderiv â„ f) Î¼) :\n    fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fderiv â„ f)\n      = fourierSMulRight (-L.flip) (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) := by\n  ext w y\n  let g (v : V) : â„‚ := ğ (-L v w)\n  /- First rewrite things in a simplified form, without any real change. -/\n  suffices âˆ« x, g x â€¢ fderiv â„ f x y âˆ‚Î¼ = âˆ« x, (2 * â†‘Ï€ * I * L y w * g x) â€¢ f x âˆ‚Î¼ by\n    rw [fourierIntegral_continuousLinearMap_apply' hf']\n    simpa only [fourierIntegral, ContinuousLinearMap.toLinearMapâ‚‚_apply, fourierSMulRight_apply,\n      ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply, â† integral_smul, neg_smul,\n      smul_neg, â† smul_smul, coe_smul, neg_neg]\n  -- Key step: integrate by parts with respect to `y` to switch the derivative from `f` to `g`.\n  have A x : fderiv â„ g x y = - 2 * â†‘Ï€ * I * L y w * g x :=\n    fderiv_fourierChar_neg_bilinear_left_apply _ _ _ _\n  rw [integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable, â† integral_neg]\n  Â· congr with x\n    simp only [A, neg_mul, neg_smul, neg_neg]\n  Â· have : Integrable (fun x â†¦ (-(2 * â†‘Ï€ * I * â†‘((L y) w)) â€¢ ((g x : â„‚) â€¢ f x))) Î¼ :=\n      ((fourierIntegral_convergent_iff' _ _).2 hf).smul _\n    convert this using 2 with x\n    simp only [A, neg_mul, neg_smul, smul_smul]\n  Â· exact (fourierIntegral_convergent_iff' _ _).2 (hf'.apply_continuousLinearMap _)\n  Â· exact (fourierIntegral_convergent_iff' _ _).2 hf\n  Â· exact differentiable_fourierChar_neg_bilinear_left _ _\n  Â· exact h'f\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_apply","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nn : Nat\nm : Fin n â†’ W\nâŠ¢ Eq ((VectorFourier.fourierPowSMulRight L f v n) m) (HSMul.hSMul (HPow.hPow (Neg.neg (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) n) (HSMul.hSMul (Finset.univ.prod fun i => (L v) (m i)) (f v)))","decl":"@[simp 1100] lemma fourierPowSMulRight_apply {f : V â†’ E} {v : V} {n : â„•} {m : Fin n â†’ W} :\n    fourierPowSMulRight L f v n m = (- (2 * Ï€ * I))^n â€¢ (âˆ i, L v (m i)) â€¢ f v := by\n  simp [fourierPowSMulRight]\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_eq_comp","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nn : Nat\nâŠ¢ Eq (VectorFourier.fourierPowSMulRight L f v n) (HSMul.hSMul (HPow.hPow (Neg.neg (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) n) (((ContinuousMultilinearMap.smulRightL Real (fun x => W) E) ((ContinuousMultilinearMap.mkPiAlgebra Real (Fin n) Real).compContinuousLinearMapLRight fun x => L v)) (f v)))","decl":"/-- Decomposing `fourierPowSMulRight L f v n` as a composition of continuous bilinear and\nmultilinear maps, to deduce easily its continuity and differentiability properties. -/\nlemma fourierPowSMulRight_eq_comp {f : V â†’ E} {v : V} {n : â„•} :\n    fourierPowSMulRight L f v n = (- (2 * Ï€ * I))^n â€¢ smulRightL â„ (fun (_ : Fin n) â†¦ W) E\n      (compContinuousLinearMapLRight\n        (ContinuousMultilinearMap.mkPiAlgebra â„ (Fin n) â„) (fun _ â†¦ L v)) (f v) := rfl\n\n"}
{"name":"Continuous.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nhf : Continuous f\nn : Nat\nâŠ¢ Continuous fun v => VectorFourier.fourierPowSMulRight L f v n","decl":"@[continuity, fun_prop]\nlemma _root_.Continuous.fourierPowSMulRight {f : V â†’ E} (hf : Continuous f) (n : â„•) :\n    Continuous (fun v â†¦ fourierPowSMulRight L f v n) := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply Continuous.const_smul\n  apply (smulRightL â„ (fun (_ : Fin n) â†¦ W) E).continuousâ‚‚.compâ‚‚ _ hf\n  exact Continuous.comp (map_continuous _) (continuous_pi (fun _ â†¦ L.continuous))\n\n"}
{"name":"ContDiff.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nk : WithTop ENat\nhf : ContDiff Real k f\nn : Nat\nâŠ¢ ContDiff Real k fun v => VectorFourier.fourierPowSMulRight L f v n","decl":"lemma _root_.ContDiff.fourierPowSMulRight\n    {f : V â†’ E} {k : WithTop â„•âˆ} (hf : ContDiff â„ k f) (n : â„•) :\n    ContDiff â„ k (fun v â†¦ fourierPowSMulRight L f v n) := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply ContDiff.const_smul\n  apply (smulRightL â„ (fun (_ : Fin n) â†¦ W) E).isBoundedBilinearMap.contDiff.compâ‚‚ _ hf\n  apply (ContinuousMultilinearMap.contDiff _).comp\n  exact contDiff_pi.2 (fun _ â†¦ L.contDiff)\n\n"}
{"name":"VectorFourier.norm_fourierPowSMulRight_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nv : V\nn : Nat\nâŠ¢ LE.le (Norm.norm (VectorFourier.fourierPowSMulRight L f v n)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) n) (HPow.hPow (Norm.norm v) n)) (Norm.norm (f v)))","decl":"lemma norm_fourierPowSMulRight_le (f : V â†’ E) (v : V) (n : â„•) :\n    â€–fourierPowSMulRight L f v nâ€– â‰¤ (2 * Ï€ * â€–Lâ€–) ^ n * â€–vâ€– ^ n * â€–f vâ€– := by\n  apply ContinuousMultilinearMap.opNorm_le_bound (by positivity) (fun m â†¦ ?_)\n  calc\n  â€–fourierPowSMulRight L f v n mâ€–\n    = (2 * Ï€) ^ n * ((âˆ x : Fin n, |(L v) (m x)|) * â€–f vâ€–) := by\n      simp [_root_.abs_of_nonneg pi_nonneg, norm_smul]\n  _ â‰¤ (2 * Ï€) ^ n * ((âˆ x : Fin n, â€–Lâ€– * â€–vâ€– * â€–m xâ€–) * â€–f vâ€–) := by\n      gcongr with i _hi\n      exact L.le_opNormâ‚‚ v (m i)\n  _ = (2 * Ï€ * â€–Lâ€–) ^ n * â€–vâ€– ^ n * â€–f vâ€– * âˆ i : Fin n, â€–m iâ€– := by\n      simp [Finset.prod_mul_distrib, mul_pow]; ring\n\n"}
{"name":"VectorFourier.norm_iteratedFDeriv_fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : NormedAddCommGroup W\ninstâœ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\nK : WithTop ENat\nC : Real\nhf : ContDiff Real K f\nn k : Nat\nhk : LE.le (â†‘k) K\nv : V\nhv : âˆ€ (i : Nat), LE.le i k â†’ âˆ€ (j : Nat), LE.le j n â†’ LE.le (HMul.hMul (HPow.hPow (Norm.norm v) j) (Norm.norm (iteratedFDeriv Real i f v))) C\nâŠ¢ LE.le (Norm.norm (iteratedFDeriv Real k (fun v => VectorFourier.fourierPowSMulRight L f v n) v)) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) n) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 â†‘n) 2) k)) (HPow.hPow (Norm.norm L) n)) C)","decl":"set_option maxSynthPendingDepth 2 in\n/-- The iterated derivative of a function multiplied by `(L v â¬) ^ n` can be controlled in terms\nof the iterated derivatives of the initial function. -/\nlemma norm_iteratedFDeriv_fourierPowSMulRight\n    {f : V â†’ E} {K : WithTop â„•âˆ} {C : â„} (hf : ContDiff â„ K f) {n : â„•} {k : â„•} (hk : k â‰¤ K)\n    {v : V} (hv : âˆ€ i â‰¤ k, âˆ€ j â‰¤ n, â€–vâ€– ^ j * â€–iteratedFDeriv â„ i f vâ€– â‰¤ C) :\n    â€–iteratedFDeriv â„ k (fun v â†¦ fourierPowSMulRight L f v n) vâ€– â‰¤\n      (2 * Ï€) ^ n * (2 * n + 2) ^ k * â€–Lâ€– ^ n * C := by\n  /- We write `fourierPowSMulRight L f v n` as a composition of bilinear and multilinear maps,\n  thanks to `fourierPowSMulRight_eq_comp`, and then we control the iterated derivatives of these\n  thanks to general bounds on derivatives of bilinear and multilinear maps. More precisely,\n  `fourierPowSMulRight L f v n m = (- (2 * Ï€ * I))^n â€¢ (âˆ i, L v (m i)) â€¢ f v`. Here,\n  `(- (2 * Ï€ * I))^n` contributes `(2Ï€)^n` to the bound. The second product is bilinear, so the\n  iterated derivative is controlled as a weighted sum of those of `v â†¦ âˆ i, L v (m i)` and of `f`.\n\n  The harder part is to control the iterated derivatives of `v â†¦ âˆ i, L v (m i)`. For this, one\n  argues that this is multilinear in `v`, to apply general bounds for iterated derivatives of\n  multilinear maps. More precisely, we write it as the composition of a multilinear map `T` (making\n  the product operation) and the tuple of linear maps `v â†¦ (L v â¬, ..., L v â¬)` -/\n  simp_rw [fourierPowSMulRight_eq_comp]\n  -- first step: controlling the iterated derivatives of `v â†¦ âˆ i, L v (m i)`, written below\n  -- as `v â†¦ T (fun _ â†¦ L v)`, or `T âˆ˜ (ContinuousLinearMap.pi (fun (_ : Fin n) â†¦ L))`.\n  let T : (W â†’L[â„] â„) [Ã—n]â†’L[â„] (W [Ã—n]â†’L[â„] â„) :=\n    compContinuousLinearMapLRight (ContinuousMultilinearMap.mkPiAlgebra â„ (Fin n) â„)\n  have Iâ‚ m : â€–iteratedFDeriv â„ m T (fun _ â†¦ L v)â€– â‰¤\n      n.descFactorial m * 1 * (â€–Lâ€– * â€–vâ€–) ^ (n - m) := by\n    have : â€–Tâ€– â‰¤ 1 := by\n      apply (norm_compContinuousLinearMapLRight_le _ _).trans\n      simp only [norm_mkPiAlgebra, le_refl]\n    apply (ContinuousMultilinearMap.norm_iteratedFDeriv_le _ _ _).trans\n    simp only [Fintype.card_fin]\n    gcongr\n    refine (pi_norm_le_iff_of_nonneg (by positivity)).mpr (fun _ â†¦ ?_)\n    exact ContinuousLinearMap.le_opNorm _ _\n  have Iâ‚‚ m : â€–iteratedFDeriv â„ m (T âˆ˜ (ContinuousLinearMap.pi (fun (_ : Fin n) â†¦ L))) vâ€– â‰¤\n      (n.descFactorial m * 1 * (â€–Lâ€– * â€–vâ€–) ^ (n - m)) * â€–Lâ€– ^ m := by\n    rw [ContinuousLinearMap.iteratedFDeriv_comp_right _ (ContinuousMultilinearMap.contDiff _)\n      _ (mod_cast le_top)]\n    apply (norm_compContinuousLinearMap_le _ _).trans\n    simp only [Finset.prod_const, Finset.card_fin]\n    gcongr\n    Â· exact Iâ‚ m\n    Â· exact ContinuousLinearMap.norm_pi_le_of_le (fun _ â†¦ le_rfl) (norm_nonneg _)\n  have Iâ‚ƒ m : â€–iteratedFDeriv â„ m (T âˆ˜ (ContinuousLinearMap.pi (fun (_ : Fin n) â†¦ L))) vâ€– â‰¤\n      n.descFactorial m * â€–Lâ€– ^ n * â€–vâ€– ^ (n - m) := by\n    apply (Iâ‚‚ m).trans (le_of_eq _)\n    rcases le_or_lt m n with hm | hm\n    Â· rw [show â€–Lâ€– ^ n = â€–Lâ€– ^ (m + (n - m)) by rw [Nat.add_sub_cancel' hm], pow_add]\n      ring\n    Â· simp only [Nat.descFactorial_eq_zero_iff_lt.mpr hm, CharP.cast_eq_zero, mul_one, zero_mul]\n  -- second step: factor out the `(2 * Ï€) ^ n` factor, and cancel it on both sides.\n  have A : ContDiff â„ K (fun y â†¦ T (fun _ â†¦ L y)) :=\n    (ContinuousMultilinearMap.contDiff _).comp (contDiff_pi.2 fun _ â†¦ L.contDiff)\n  rw [iteratedFDeriv_const_smul_apply' (hf := ((smulRightL â„ (fun _ â†¦ W)\n    E).isBoundedBilinearMap.contDiff.compâ‚‚ (A.of_le hk) (hf.of_le hk)).contDiffAt),\n    norm_smul (Î² := V [Ã—k]â†’L[â„] (W [Ã—n]â†’L[â„] E))]\n  simp only [norm_pow, norm_neg, norm_mul, RCLike.norm_ofNat, Complex.norm_eq_abs, abs_ofReal,\n    _root_.abs_of_nonneg pi_nonneg, abs_I, mul_one, mul_assoc]\n  gcongr\n  -- third step: argue that the scalar multiplication is bilinear to bound the iterated derivatives\n  -- of `v â†¦ (âˆ i, L v (m i)) â€¢ f v` in terms of those of `v â†¦ (âˆ i, L v (m i))` and of `f`.\n  -- The former are controlled by the first step, the latter by the assumptions.\n  apply (ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear_of_le_one _ A hf _\n    hk ContinuousMultilinearMap.norm_smulRightL_le).trans\n  calc\n  âˆ‘ i âˆˆ Finset.range (k + 1),\n    k.choose i * â€–iteratedFDeriv â„ i (fun (y : V) â†¦ T (fun _ â†¦ L y)) vâ€– *\n      â€–iteratedFDeriv â„ (k - i) f vâ€–\n    â‰¤ âˆ‘ i âˆˆ Finset.range (k + 1),\n      k.choose i * (n.descFactorial i * â€–Lâ€– ^ n * â€–vâ€– ^ (n - i)) *\n        â€–iteratedFDeriv â„ (k - i) f vâ€– := by\n    gcongr with i _hi\n    exact Iâ‚ƒ i\n  _ = âˆ‘ i âˆˆ Finset.range (k + 1), (k.choose i * n.descFactorial i * â€–Lâ€– ^ n) *\n        (â€–vâ€– ^ (n - i) * â€–iteratedFDeriv â„ (k - i) f vâ€–) := by\n    congr with i\n    ring\n  _ â‰¤ âˆ‘ i âˆˆ Finset.range (k + 1), (k.choose i * (n + 1 : â„•) ^ k * â€–Lâ€– ^ n) * C := by\n    gcongr with i hi\n    Â· rw [â† Nat.cast_pow, Nat.cast_le]\n      calc n.descFactorial i â‰¤ n ^ i := Nat.descFactorial_le_pow _ _\n      _ â‰¤ (n + 1) ^ i := by gcongr; omega\n      _ â‰¤ (n + 1) ^ k := by gcongr; exacts [le_add_self, Finset.mem_range_succ_iff.mp hi]\n    Â· exact hv _ (by omega) _ (by omega)\n  _ = (2 * n + 2) ^ k * (â€–Lâ€–^n * C) := by\n    simp only [â† Finset.sum_mul, â† Nat.cast_sum, Nat.sum_range_choose, mul_one, â† mul_assoc,\n      Nat.cast_pow, Nat.cast_ofNat, Nat.cast_add, Nat.cast_one, â† mul_pow, mul_add]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nn : Nat\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun v => VectorFourier.fourierPowSMulRight L f v n) Î¼","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.fourierPowSMulRight\n    (hf : AEStronglyMeasurable f Î¼) (n : â„•) :\n    AEStronglyMeasurable (fun v â†¦ fourierPowSMulRight L f v n) Î¼ := by\n  simp_rw [fourierPowSMulRight_eq_comp]\n  apply AEStronglyMeasurable.const_smul'\n  apply (smulRightL â„ (fun (_ : Fin n) â†¦ W) E).continuousâ‚‚.comp_aestronglyMeasurableâ‚‚ _ hf\n  apply Continuous.aestronglyMeasurable\n  exact Continuous.comp (map_continuous _) (continuous_pi (fun _ â†¦ L.continuous))\n\n"}
{"name":"VectorFourier.integrable_fourierPowSMulRight","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nn : Nat\nhf : MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) Î¼\nh'f : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun v => VectorFourier.fourierPowSMulRight L f v n) Î¼","decl":"lemma integrable_fourierPowSMulRight {n : â„•} (hf : Integrable (fun v â†¦ â€–vâ€– ^ n * â€–f vâ€–) Î¼)\n    (h'f : AEStronglyMeasurable f Î¼) : Integrable (fun v â†¦ fourierPowSMulRight L f v n) Î¼ := by\n  refine (hf.const_mul ((2 * Ï€ * â€–Lâ€–) ^ n)).mono' (h'f.fourierPowSMulRight L n) ?_\n  filter_upwards with v\n  exact (norm_fourierPowSMulRight_le L f v n).trans (le_of_eq (by ring))\n\n"}
{"name":"VectorFourier.hasFTaylorSeriesUpTo_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nN : WithTop ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) Î¼\nh'f : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ HasFTaylorSeriesUpTo N (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f) fun w n => VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (fun v => VectorFourier.fourierPowSMulRight L f v n) w","decl":"lemma hasFTaylorSeriesUpTo_fourierIntegral {N : WithTop â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–) Î¼)\n    (h'f : AEStronglyMeasurable f Î¼) :\n    HasFTaylorSeriesUpTo N (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)\n      (fun w n â†¦ fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun v â†¦ fourierPowSMulRight L f v n) w) := by\n  constructor\n  Â· intro w\n    rw [curry0_apply, Matrix.zero_empty, fourierIntegral_continuousMultilinearMap_apply'\n      (integrable_fourierPowSMulRight L (hf 0 bot_le) h'f)]\n    simp only [fourierPowSMulRight_apply, pow_zero, Finset.univ_eq_empty, Finset.prod_empty,\n      one_smul]\n  Â· intro n hn w\n    have Iâ‚ : Integrable (fun v â†¦ fourierPowSMulRight L f v n) Î¼ :=\n      integrable_fourierPowSMulRight L (hf n hn.le) h'f\n    have Iâ‚‚ : Integrable (fun v â†¦ â€–vâ€– * â€–fourierPowSMulRight L f v nâ€–) Î¼ := by\n      apply ((hf (n+1) (ENat.add_one_natCast_le_withTop_of_lt hn)).const_mul\n          ((2 * Ï€ * â€–Lâ€–) ^ n)).mono'\n        (continuous_norm.aestronglyMeasurable.mul (h'f.fourierPowSMulRight L n).norm)\n      filter_upwards with v\n      simp only [Pi.mul_apply, norm_mul, norm_norm]\n      calc\n      â€–vâ€– * â€–fourierPowSMulRight L f v nâ€–\n        â‰¤ â€–vâ€– * ((2 * Ï€ * â€–Lâ€–) ^ n * â€–vâ€– ^ n * â€–f vâ€–) := by\n          gcongr; apply norm_fourierPowSMulRight_le\n      _ = (2 * Ï€ * â€–Lâ€–) ^ n * (â€–vâ€– ^ (n + 1) * â€–f vâ€–) := by rw [pow_succ]; ring\n    have Iâ‚ƒ : Integrable (fun v â†¦ fourierPowSMulRight L f v (n + 1)) Î¼ :=\n      integrable_fourierPowSMulRight L (hf (n + 1) (ENat.add_one_natCast_le_withTop_of_lt hn)) h'f\n    have Iâ‚„ : Integrable\n        (fun v â†¦ fourierSMulRight L (fun v â†¦ fourierPowSMulRight L f v n) v) Î¼ := by\n      apply (Iâ‚‚.const_mul ((2 * Ï€ * â€–Lâ€–))).mono' (h'f.fourierPowSMulRight L n).fourierSMulRight\n      filter_upwards with v\n      exact (norm_fourierSMulRight_le _ _ _).trans (le_of_eq (by ring))\n    have E : curryLeft\n          (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun v â†¦ fourierPowSMulRight L f v (n + 1)) w) =\n        fourierIntegral ğ Î¼ L.toLinearMapâ‚‚\n          (fourierSMulRight L fun v â†¦ fourierPowSMulRight L f v n) w := by\n      ext w' m\n      rw [curryLeft_apply, fourierIntegral_continuousMultilinearMap_apply' Iâ‚ƒ,\n        fourierIntegral_continuousLinearMap_apply' Iâ‚„,\n        fourierIntegral_continuousMultilinearMap_apply' (Iâ‚„.apply_continuousLinearMap _)]\n      congr with v\n      simp only [fourierPowSMulRight_apply, mul_comm, pow_succ, neg_mul, Fin.prod_univ_succ,\n        Fin.cons_zero, Fin.cons_succ, neg_smul, fourierSMulRight_apply, neg_apply, smul_apply,\n        smul_comm (M := â„) (N := â„‚) (Î± := E), smul_smul]\n    exact E â–¸ hasFDerivAt_fourierIntegral L Iâ‚ Iâ‚‚ w\n  Â· intro n hn\n    apply fourierIntegral_continuous Real.continuous_fourierChar (by apply L.continuousâ‚‚)\n    exact integrable_fourierPowSMulRight L (hf n hn) h'f\n\n"}
{"name":"VectorFourier.hasFTaylorSeriesUpTo_fourierIntegral'","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nN : ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) Î¼\nh'f : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ HasFTaylorSeriesUpTo (â†‘N) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f) fun w n => VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (fun v => VectorFourier.fourierPowSMulRight L f v n) w","decl":"/-- Variant of `hasFTaylorSeriesUpTo_fourierIntegral` in which the smoothness index is restricted\nto `â„•âˆ` (and so are the inequalities in the assumption `hf`). Avoids normcasting in some\napplications. -/\nlemma hasFTaylorSeriesUpTo_fourierIntegral' {N : â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–) Î¼)\n    (h'f : AEStronglyMeasurable f Î¼) :\n    HasFTaylorSeriesUpTo N (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)\n      (fun w n â†¦ fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun v â†¦ fourierPowSMulRight L f v n) w) :=\n  hasFTaylorSeriesUpTo_fourierIntegral _ (fun n hn â†¦ hf n (mod_cast hn)) h'f\n\n"}
{"name":"VectorFourier.contDiff_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nN : ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) Î¼\nâŠ¢ ContDiff Real (â†‘N) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)","decl":"/-- If `â€–vâ€–^n * â€–f vâ€–` is integrable for all `n â‰¤ N`, then the Fourier transform of `f` is `C^N`. -/\ntheorem contDiff_fourierIntegral {N : â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–) Î¼) :\n    ContDiff â„ N (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) := by\n  by_cases h'f : Integrable f Î¼\n  Â· exact (hasFTaylorSeriesUpTo_fourierIntegral' L hf h'f.1).contDiff\n  Â· have : fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f = 0 := by\n      ext w; simp [fourierIntegral, integral, h'f]\n    simpa [this] using contDiff_const\n\n"}
{"name":"VectorFourier.iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : NormedSpace Real V\ninstâœâ´ : NormedAddCommGroup W\ninstâœÂ³ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : SecondCountableTopology V\nN : ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) Î¼\nh'f : MeasureTheory.AEStronglyMeasurable f Î¼\nn : Nat\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (iteratedFDeriv Real n (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ fun v => VectorFourier.fourierPowSMulRight L f v n)","decl":"/-- If `â€–vâ€–^n * â€–f vâ€–` is integrable for all `n â‰¤ N`, then the `n`-th derivative of the Fourier\ntransform of `f` is the Fourier transform of `fourierPowSMulRight L f v n`,\ni.e., `(L v â¬) ^ n â€¢ f v`. -/\nlemma iteratedFDeriv_fourierIntegral {N : â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–) Î¼)\n    (h'f : AEStronglyMeasurable f Î¼) {n : â„•} (hn : n â‰¤ N) :\n    iteratedFDeriv â„ n (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) =\n      fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun v â†¦ fourierPowSMulRight L f v n) := by\n  ext w : 1\n  exact ((hasFTaylorSeriesUpTo_fourierIntegral' L hf h'f).eq_iteratedFDeriv\n    (mod_cast hn) w).symm\n\n"}
{"name":"VectorFourier.fourierIntegral_iteratedFDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nN : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (iteratedFDeriv Real n f) Î¼\nn : Nat\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (iteratedFDeriv Real n f)) fun w => VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f) w n","decl":"/-- The Fourier integral of the `n`-th derivative of a function is obtained by multiplying the\nFourier integral of the original function by `(2Ï€I L w â¬ )^n`. -/\ntheorem fourierIntegral_iteratedFDeriv [FiniteDimensional â„ V]\n    {Î¼ : Measure V} [Measure.IsAddHaarMeasure Î¼] {N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (iteratedFDeriv â„ n f) Î¼) {n : â„•} (hn : n â‰¤ N) :\n    fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (iteratedFDeriv â„ n f)\n      = (fun w â†¦ fourierPowSMulRight (-L.flip) (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) w n) := by\n  induction n with\n  | zero =>\n    ext w m\n    simp only [iteratedFDeriv_zero_apply, fourierPowSMulRight_apply, pow_zero,\n      Finset.univ_eq_empty, ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply,\n      Finset.prod_empty, one_smul, fourierIntegral_continuousMultilinearMap_apply' ((h'f 0 bot_le))]\n  | succ n ih =>\n    ext w m\n    have J : Integrable (fderiv â„ (iteratedFDeriv â„ n f)) Î¼ := by\n      specialize h'f (n + 1) hn\n      rwa [iteratedFDeriv_succ_eq_comp_left, Function.comp_def,\n          LinearIsometryEquiv.integrable_comp_iff (ğ•œ := â„) (Ï† := fderiv â„ (iteratedFDeriv â„ n f))]\n        at h'f\n    suffices H : (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fderiv â„ (iteratedFDeriv â„ n f)) w)\n          (m 0) (Fin.tail m) =\n        (-(2 * Ï€ * I)) ^ (n + 1) â€¢ (âˆ x : Fin (n + 1), -L (m x) w) â€¢ âˆ« v, ğ (-L v w) â€¢ f v âˆ‚Î¼ by\n      rw [fourierIntegral_continuousMultilinearMap_apply' (h'f _ hn)]\n      simp only [iteratedFDeriv_succ_apply_left, fourierPowSMulRight_apply,\n        ContinuousLinearMap.neg_apply, ContinuousLinearMap.flip_apply]\n      rw [â† fourierIntegral_continuousMultilinearMap_apply' ((J.apply_continuousLinearMap _)),\n          â† fourierIntegral_continuousLinearMap_apply' J]\n      exact H\n    have h'n : n < N := (Nat.cast_lt.mpr n.lt_succ_self).trans_le hn\n    rw [fourierIntegral_fderiv _ (h'f n h'n.le)\n      (hf.differentiable_iteratedFDeriv (mod_cast h'n)) J]\n    simp only [ih h'n.le, fourierSMulRight_apply, ContinuousLinearMap.neg_apply,\n      ContinuousLinearMap.flip_apply, neg_smul, smul_neg, neg_neg, smul_apply,\n      fourierPowSMulRight_apply, â† coe_smul (E := E), smul_smul]\n    congr 1\n    simp only [ofReal_prod, ofReal_neg, pow_succ, mul_neg, Fin.prod_univ_succ, neg_mul,\n      ofReal_mul, neg_neg, Fin.tail_def]\n    ring\n\n"}
{"name":"VectorFourier.fourierPowSMulRight_iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (k n : Nat), LE.le (â†‘k) K â†’ LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) Î¼\nk n : Nat\nhk : LE.le (â†‘k) K\nhn : LE.le (â†‘n) N\nw : W\nâŠ¢ Eq (VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)) w n) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (iteratedFDeriv Real n fun v => VectorFourier.fourierPowSMulRight L f v k) w)","decl":"/-- The `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`, is the\nFourier integral of the `n`-th derivative of `(L v w) ^ k * f`. -/\ntheorem fourierPowSMulRight_iteratedFDeriv_fourierIntegral [FiniteDimensional â„ V]\n    {Î¼ : Measure V} [Measure.IsAddHaarMeasure Î¼] {K N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (k n : â„•), k â‰¤ K â†’ n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^k * â€–iteratedFDeriv â„ n f vâ€–) Î¼)\n    {k n : â„•} (hk : k â‰¤ K) (hn : n â‰¤ N) {w : W} :\n    fourierPowSMulRight (-L.flip)\n      (iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) w n =\n    fourierIntegral ğ Î¼ L.toLinearMapâ‚‚\n      (iteratedFDeriv â„ n (fun v â†¦ fourierPowSMulRight L f v k)) w := by\n  rw [fourierIntegral_iteratedFDeriv (N := N) _ (hf.fourierPowSMulRight _ _) _ hn]\n  Â· congr\n    rw [iteratedFDeriv_fourierIntegral (N := K) _ _ hf.continuous.aestronglyMeasurable hk]\n    intro k hk\n    simpa only [norm_iteratedFDeriv_zero] using h'f k 0 hk bot_le\n  Â· intro m hm\n    have I : Integrable (fun v â†¦ âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (m + 1),\n        â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€–) Î¼ := by\n      apply integrable_finset_sum _ (fun p hp â†¦ ?_)\n      simp only [Finset.mem_product, Finset.mem_range_succ_iff] at hp\n      exact h'f _ _ ((Nat.cast_le.2 hp.1).trans hk) ((Nat.cast_le.2 hp.2).trans hm)\n    apply (I.const_mul ((2 * Ï€) ^ k * (2 * k + 2) ^ m * â€–Lâ€– ^ k)).mono'\n      ((hf.fourierPowSMulRight L k).continuous_iteratedFDeriv (mod_cast hm)).aestronglyMeasurable\n    filter_upwards with v\n    refine norm_iteratedFDeriv_fourierPowSMulRight _ hf (mod_cast hm) (fun i hi j hj â†¦ ?_)\n    apply Finset.single_le_sum (f := fun p â†¦ â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€–) (a := (j, i))\n    Â· intro i _hi\n      positivity\n    Â· simpa only [Finset.mem_product, Finset.mem_range_succ_iff] using âŸ¨hj, hiâŸ©\n\n"}
{"name":"VectorFourier.norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (k n : Nat), LE.le (â†‘k) K â†’ LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) Î¼\nk n : Nat\nhk : LE.le (â†‘k) K\nhn : LE.le (â†‘n) N\nw : W\nâŠ¢ LE.le (Norm.norm (VectorFourier.fourierPowSMulRight (Neg.neg L.flip) (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f)) w n)) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) k) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 â†‘k) 2) n)) (HPow.hPow (Norm.norm L) k)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral Î¼ fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound the `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`,\nin terms of integrals of iterated derivatives of `f` (of order up to `n`) multiplied by `â€–vâ€– ^ i`\n(for `i â‰¤ k`).\nAuxiliary version in terms of the operator norm of `fourierPowSMulRight (-L.flip) â¬`. For a version\nin terms of `|L v w| ^ n * â¬`, see `pow_mul_norm_iteratedFDeriv_fourierIntegral_le`.\n-/\ntheorem norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le [FiniteDimensional â„ V]\n    {Î¼ : Measure V} [Measure.IsAddHaarMeasure Î¼] {K N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (k n : â„•), k â‰¤ K â†’ n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^k * â€–iteratedFDeriv â„ n f vâ€–) Î¼)\n    {k n : â„•} (hk : k â‰¤ K) (hn : n â‰¤ N) {w : W} :\n    â€–fourierPowSMulRight (-L.flip)\n      (iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) w nâ€– â‰¤\n    (2 * Ï€) ^ k * (2 * k + 2) ^ n * â€–Lâ€– ^ k * âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n      âˆ« v, â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– âˆ‚Î¼ := by\n  rw [fourierPowSMulRight_iteratedFDeriv_fourierIntegral L hf h'f hk hn]\n  apply (norm_fourierIntegral_le_integral_norm _ _ _ _ _).trans\n  have I p (hp : p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1)) :\n      Integrable (fun v â†¦ â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€–) Î¼ := by\n    simp only [Finset.mem_product, Finset.mem_range_succ_iff] at hp\n    exact h'f _ _ (le_trans (by simpa using hp.1) hk) (le_trans (by simpa using hp.2) hn)\n  rw [â† integral_finset_sum _ I, â† integral_mul_left]\n  apply integral_mono_of_nonneg\n  Â· filter_upwards with v using norm_nonneg _\n  Â· exact (integrable_finset_sum _ I).const_mul _\n  Â· filter_upwards with v\n    apply norm_iteratedFDeriv_fourierPowSMulRight _ hf (mod_cast hn) _\n    intro i hi j hj\n    apply Finset.single_le_sum (f := fun p â†¦ â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€–) (a := (j, i))\n    Â· intro i _hi\n      positivity\n    Â· simp only [Finset.mem_product, Finset.mem_range_succ_iff]\n      exact âŸ¨hj, hiâŸ©\n\n"}
{"name":"VectorFourier.pow_mul_norm_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nf : V â†’ E\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nK N : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (k n : Nat), LE.le (â†‘k) K â†’ LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) Î¼\nk n : Nat\nhk : LE.le (â†‘k) K\nhn : LE.le (â†‘n) N\nv : V\nw : W\nâŠ¢ LE.le (HMul.hMul (HPow.hPow (abs ((L v) w)) n) (Norm.norm (iteratedFDeriv Real k (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f) w))) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (Norm.norm v) n) (HPow.hPow (HMul.hMul (HMul.hMul 2 Real.pi) (Norm.norm L)) k)) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 â†‘k) 2) n)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral Î¼ fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound the `k`-th derivative of the Fourier integral of `f`, multiplied by `(L v w) ^ n`,\nin terms of integrals of iterated derivatives of `f` (of order up to `n`) multiplied by `â€–vâ€– ^ i`\n(for `i â‰¤ k`). -/\nlemma pow_mul_norm_iteratedFDeriv_fourierIntegral_le [FiniteDimensional â„ V]\n    {Î¼ : Measure V} [Measure.IsAddHaarMeasure Î¼] {K N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (k n : â„•), k â‰¤ K â†’ n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^k * â€–iteratedFDeriv â„ n f vâ€–) Î¼)\n    {k n : â„•} (hk : k â‰¤ K) (hn : n â‰¤ N) (v : V) (w : W) :\n    |L v w| ^ n * â€–(iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) wâ€– â‰¤\n      â€–vâ€– ^ n * (2 * Ï€ * â€–Lâ€–) ^ k * (2 * k + 2) ^ n *\n        âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n          âˆ« v, â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– âˆ‚Î¼ := calc\n  |L v w| ^ n * â€–(iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) wâ€–\n  _ â‰¤ (2 * Ï€) ^ n\n      * (|L v w| ^ n * â€–iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f) wâ€–) := by\n    apply le_mul_of_one_le_left (by positivity)\n    apply one_le_powâ‚€\n    linarith [one_le_pi_div_two]\n  _ = â€–fourierPowSMulRight (-L.flip)\n        (iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) w n (fun _ â†¦ v)â€– := by\n    simp [norm_smul, _root_.abs_of_nonneg pi_nonneg]\n  _ â‰¤ â€–fourierPowSMulRight (-L.flip)\n        (iteratedFDeriv â„ k (fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f)) w nâ€– * âˆ _ : Fin n, â€–vâ€– :=\n    le_opNorm _ _\n  _ â‰¤ ((2 * Ï€) ^ k * (2 * k + 2) ^ n * â€–Lâ€– ^ k *\n      âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n        âˆ« v, â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– âˆ‚Î¼) * â€–vâ€– ^ n := by\n    gcongr\n    Â· apply norm_fourierPowSMulRight_iteratedFDeriv_fourierIntegral_le _ hf h'f hk hn\n    Â· simp\n  _ = â€–vâ€– ^ n * (2 * Ï€ * â€–Lâ€–) ^ k * (2 * k + 2) ^ n *\n        âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n          âˆ« v, â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– âˆ‚Î¼ := by\n    simp [mul_pow]\n    ring\n\n"}
{"name":"Real.hasFDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nx : V\nâŠ¢ HasFDerivAt (Real.fourierIntegral f) (Real.fourierIntegral (VectorFourier.fourierSMulRight (innerSL Real) f) x) x","decl":"/-- The FrÃ©chet derivative of the Fourier transform of `f` is the Fourier transform of\n    `fun v â†¦ -2 * Ï€ * I âŸªv, â¬âŸ« f v`. -/\ntheorem hasFDerivAt_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v â†¦ â€–vâ€– * â€–f vâ€–)) (x : V) :\n    HasFDerivAt (ğ“• f) (ğ“• (fourierSMulRight (innerSL â„) f) x) x :=\n  VectorFourier.hasFDerivAt_fourierIntegral (innerSL â„) hf_int hvf_int x\n\n"}
{"name":"Real.fderiv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (fderiv Real (Real.fourierIntegral f)) (Real.fourierIntegral (VectorFourier.fourierSMulRight (innerSL Real) f))","decl":"/-- The FrÃ©chet derivative of the Fourier transform of `f` is the Fourier transform of\n    `fun v â†¦ -2 * Ï€ * I âŸªv, â¬âŸ« f v`. -/\ntheorem fderiv_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v â†¦ â€–vâ€– * â€–f vâ€–)) :\n    fderiv â„ (ğ“• f) = ğ“• (fourierSMulRight (innerSL â„) f) :=\n  VectorFourier.fderiv_fourierIntegral (innerSL â„) hf_int hvf_int\n\n"}
{"name":"Real.differentiable_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nhf_int : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhvf_int : MeasureTheory.Integrable (fun v => HMul.hMul (Norm.norm v) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nâŠ¢ Differentiable Real (Real.fourierIntegral f)","decl":"theorem differentiable_fourierIntegral\n    (hf_int : Integrable f) (hvf_int : Integrable (fun v â†¦ â€–vâ€– * â€–f vâ€–)) :\n    Differentiable â„ (ğ“• f) :=\n  VectorFourier.differentiable_fourierIntegral (innerSL â„) hf_int hvf_int\n\n"}
{"name":"Real.fourierIntegral_fderiv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (fderiv Real f) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (Real.fourierIntegral (fderiv Real f)) (VectorFourier.fourierSMulRight (Neg.neg (innerSL Real)) (Real.fourierIntegral f))","decl":"/-- The Fourier integral of the FrÃ©chet derivative of a function is obtained by multiplying the\nFourier integral of the original function by `2Ï€I âŸªv, wâŸ«`. -/\ntheorem fourierIntegral_fderiv\n    (hf : Integrable f) (h'f : Differentiable â„ f) (hf' : Integrable (fderiv â„ f)) :\n    ğ“• (fderiv â„ f) = fourierSMulRight (-innerSL â„) (ğ“• f) := by\n  rw [â† innerSL_real_flip V]\n  exact VectorFourier.fourierIntegral_fderiv (innerSL â„) hf h'f hf'\n\n"}
{"name":"Real.contDiff_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nN : ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nâŠ¢ ContDiff Real (â†‘N) (Real.fourierIntegral f)","decl":"/-- If `â€–vâ€–^n * â€–f vâ€–` is integrable, then the Fourier transform of `f` is `C^n`. -/\ntheorem contDiff_fourierIntegral {N : â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–)) :\n    ContDiff â„ N (ğ“• f) :=\n  VectorFourier.contDiff_fourierIntegral (innerSL â„) hf\n\n"}
{"name":"Real.iteratedFDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nN : ENat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) n) (Norm.norm (f v))) MeasureTheory.MeasureSpace.volume\nh'f : MeasureTheory.AEStronglyMeasurable f MeasureTheory.MeasureSpace.volume\nn : Nat\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (iteratedFDeriv Real n (Real.fourierIntegral f)) (Real.fourierIntegral fun v => VectorFourier.fourierPowSMulRight (innerSL Real) f v n)","decl":"/-- If `â€–vâ€–^n * â€–f vâ€–` is integrable, then the `n`-th derivative of the Fourier transform of `f` is\n  the Fourier transform of `fun v â†¦ (-2 * Ï€ * I) ^ n âŸªv, â¬âŸ«^n f v`. -/\ntheorem iteratedFDeriv_fourierIntegral {N : â„•âˆ}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–))\n    (h'f : AEStronglyMeasurable f) {n : â„•} (hn : n â‰¤ N) :\n    iteratedFDeriv â„ n (ğ“• f) = ğ“• (fun v â†¦ fourierPowSMulRight (innerSL â„) f v n) :=\n  VectorFourier.iteratedFDeriv_fourierIntegral (innerSL â„) hf h'f hn\n\n"}
{"name":"Real.fourierIntegral_iteratedFDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nN : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (iteratedFDeriv Real n f) MeasureTheory.MeasureSpace.volume\nn : Nat\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (Real.fourierIntegral (iteratedFDeriv Real n f)) fun w => VectorFourier.fourierPowSMulRight (Neg.neg (innerSL Real)) (Real.fourierIntegral f) w n","decl":"/-- The Fourier integral of the `n`-th derivative of a function is obtained by multiplying the\nFourier integral of the original function by `(2Ï€I L w â¬ )^n`. -/\ntheorem fourierIntegral_iteratedFDeriv {N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (iteratedFDeriv â„ n f)) {n : â„•} (hn : n â‰¤ N) :\n    ğ“• (iteratedFDeriv â„ n f)\n      = (fun w â†¦ fourierPowSMulRight (-innerSL â„) (ğ“• f) w n) := by\n  rw [â† innerSL_real_flip V]\n  exact VectorFourier.fourierIntegral_iteratedFDeriv (innerSL â„) hf h'f hn\n\n"}
{"name":"Real.pow_mul_norm_iteratedFDeriv_fourierIntegral_le","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : FiniteDimensional Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nf : V â†’ E\nK N : ENat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (k n : Nat), LE.le (â†‘k) K â†’ LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun v => HMul.hMul (HPow.hPow (Norm.norm v) k) (Norm.norm (iteratedFDeriv Real n f v))) MeasureTheory.MeasureSpace.volume\nk n : Nat\nhk : LE.le (â†‘k) K\nhn : LE.le (â†‘n) N\nw : V\nâŠ¢ LE.le (HMul.hMul (HPow.hPow (Norm.norm w) n) (Norm.norm (iteratedFDeriv Real k (Real.fourierIntegral f) w))) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 Real.pi) k) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 â†‘k) 2) n)) ((SProd.sprod (Finset.range (HAdd.hAdd k 1)) (Finset.range (HAdd.hAdd n 1))).sum fun p => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HMul.hMul (HPow.hPow (Norm.norm v) p.1) (Norm.norm (iteratedFDeriv Real p.2 f v))))","decl":"/-- One can bound `â€–wâ€–^n * â€–D^k (ğ“• f) wâ€–` in terms of integrals of the derivatives of `f` (or order\nat most `n`) multiplied by powers of `v` (of order at most `k`). -/\nlemma pow_mul_norm_iteratedFDeriv_fourierIntegral_le\n    {K N : â„•âˆ} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (k n : â„•), k â‰¤ K â†’ n â‰¤ N â†’ Integrable (fun v â†¦ â€–vâ€–^k * â€–iteratedFDeriv â„ n f vâ€–))\n    {k n : â„•} (hk : k â‰¤ K) (hn : n â‰¤ N) (w : V) :\n    â€–wâ€– ^ n * â€–iteratedFDeriv â„ k (ğ“• f) wâ€– â‰¤ (2 * Ï€) ^ k * (2 * k + 2) ^ n *\n      âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n        âˆ« v, â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– := by\n  have Z : â€–wâ€– ^ n * (â€–wâ€– ^ n * â€–iteratedFDeriv â„ k (ğ“• f) wâ€–) â‰¤\n      â€–wâ€– ^ n * ((2 * (Ï€ * â€–innerSL (E := V) â„â€–)) ^ k * ((2 * k + 2) ^ n *\n          âˆ‘ p âˆˆ Finset.range (k + 1) Ã—Ë¢ Finset.range (n + 1),\n            âˆ« (v : V), â€–vâ€– ^ p.1 * â€–iteratedFDeriv â„ p.2 f vâ€– âˆ‚volume)) := by\n    have := VectorFourier.pow_mul_norm_iteratedFDeriv_fourierIntegral_le (innerSL â„) hf h'f hk hn\n      w w\n    simp only [innerSL_apply _ w w, real_inner_self_eq_norm_sq w, _root_.abs_pow, abs_norm,\n      mul_assoc] at this\n    rwa [pow_two, mul_pow, mul_assoc] at this\n  rcases eq_or_ne n 0 with rfl | hn\n  Â· simp only [pow_zero, one_mul, mul_one, zero_add, Finset.range_one, Finset.product_singleton,\n      Finset.sum_map, Function.Embedding.coeFn_mk, norm_iteratedFDeriv_zero] at Z âŠ¢\n    apply Z.trans\n    conv_rhs => rw [â† mul_one Ï€]\n    gcongr\n    exact norm_innerSL_le _\n  rcases eq_or_ne w 0 with rfl | hw\n  Â· simp [hn]\n    positivity\n  rw [mul_le_mul_left (pow_pos (by simp [hw]) n)] at Z\n  apply Z.trans\n  conv_rhs => rw [â† mul_one Ï€]\n  simp only [mul_assoc]\n  gcongr\n  exact norm_innerSL_le _\n\n"}
{"name":"Real.hasDerivAt_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhf' : MeasureTheory.Integrable (fun x => HSMul.hSMul x (f x)) MeasureTheory.MeasureSpace.volume\nw : Real\nâŠ¢ HasDerivAt (Real.fourierIntegral f) (Real.fourierIntegral (fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘x) (f x)) w) w","decl":"lemma hasDerivAt_fourierIntegral\n    {f : â„ â†’ E} (hf : Integrable f) (hf' : Integrable (fun x : â„ â†¦ x â€¢ f x)) (w : â„) :\n    HasDerivAt (ğ“• f) (ğ“• (fun x : â„ â†¦ (-2 * Ï€ * I * x) â€¢ f x) w) w := by\n  have hf'' : Integrable (fun v : â„ â†¦ â€–vâ€– * â€–f vâ€–) := by simpa only [norm_smul] using hf'.norm\n  let L := ContinuousLinearMap.mul â„ â„\n  have h_int : Integrable fun v â†¦ fourierSMulRight L f v := by\n    suffices Integrable fun v â†¦ ContinuousLinearMap.smulRight (L v) (f v) by\n      simpa only [fourierSMulRight, neg_smul, neg_mul, Pi.smul_apply] using this.smul (-2 * Ï€ * I)\n    convert ((ContinuousLinearMap.ring_lmap_equiv_self â„\n      E).symm.toContinuousLinearEquiv.toContinuousLinearMap).integrable_comp hf' using 2 with v\n    apply ContinuousLinearMap.ext_ring\n    rw [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.mul_apply', mul_one,\n      ContinuousLinearMap.map_smul]\n    exact congr_arg (fun x â†¦ v â€¢ x) (one_smul â„ (f v)).symm\n  rw [â† VectorFourier.fourierIntegral_convergent_iff continuous_fourierChar L.continuousâ‚‚ w]\n    at h_int\n  convert (VectorFourier.hasFDerivAt_fourierIntegral L hf hf'' w).hasDerivAt using 1\n  erw [ContinuousLinearMap.integral_apply h_int]\n  simp_rw [ContinuousLinearMap.smul_apply, fourierSMulRight, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, L, ContinuousLinearMap.mul_apply', mul_one,\n    â† neg_mul, mul_smul]\n  rfl\n\n"}
{"name":"Real.deriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nhf' : MeasureTheory.Integrable (fun x => HSMul.hSMul x (f x)) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (deriv (Real.fourierIntegral f)) (Real.fourierIntegral fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘x) (f x))","decl":"theorem deriv_fourierIntegral\n    {f : â„ â†’ E} (hf : Integrable f) (hf' : Integrable (fun x : â„ â†¦ x â€¢ f x)) :\n    deriv (ğ“• f) = ğ“• (fun x : â„ â†¦ (-2 * Ï€ * I * x) â€¢ f x) := by\n  ext x\n  exact (hasDerivAt_fourierIntegral hf hf' x).deriv\n\n"}
{"name":"Real.fourierIntegral_deriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nh'f : Differentiable Real f\nhf' : MeasureTheory.Integrable (deriv f) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (Real.fourierIntegral (deriv f)) fun x => HSMul.hSMul (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) â†‘x) (Real.fourierIntegral f x)","decl":"/-- The Fourier integral of the FrÃ©chet derivative of a function is obtained by multiplying the\nFourier integral of the original function by `2Ï€I x`. -/\ntheorem fourierIntegral_deriv\n    {f : â„ â†’ E} (hf : Integrable f) (h'f : Differentiable â„ f) (hf' : Integrable (deriv f)) :\n    ğ“• (deriv f) = fun (x : â„) â†¦ (2 * Ï€ * I * x) â€¢ (ğ“• f x) := by\n  ext x\n  have I : Integrable (fun x â†¦ fderiv â„ f x) := by\n    simpa only [â† deriv_fderiv] using (ContinuousLinearMap.smulRightL â„ â„ E 1).integrable_comp hf'\n  have : ğ“• (deriv f) x = ğ“• (fderiv â„ f) x 1 := by\n    simp only [fourierIntegral_continuousLinearMap_apply I, fderiv_deriv]\n  rw [this, fourierIntegral_fderiv hf h'f I]\n  simp only [fourierSMulRight_apply, ContinuousLinearMap.neg_apply, innerSL_apply, smul_smul,\n    RCLike.inner_apply, conj_trivial, mul_one, neg_smul, smul_neg, neg_neg, neg_mul, â† coe_smul]\n\n"}
{"name":"Real.iteratedDeriv_fourierIntegral","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nN : ENat\nn : Nat\nhf : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (fun x => HSMul.hSMul (HPow.hPow x n) (f x)) MeasureTheory.MeasureSpace.volume\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (iteratedDeriv n (Real.fourierIntegral f)) (Real.fourierIntegral fun x => HSMul.hSMul (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul (-2) â†‘Real.pi) Complex.I) â†‘x) n) (f x))","decl":"theorem iteratedDeriv_fourierIntegral {f : â„ â†’ E} {N : â„•âˆ} {n : â„•}\n    (hf : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (fun x â†¦ x^n â€¢ f x)) (hn : n â‰¤ N) :\n    iteratedDeriv n (ğ“• f) = ğ“• (fun x : â„ â†¦ (-2 * Ï€ * I * x) ^ n â€¢ f x) := by\n  ext x : 1\n  have A (n : â„•) (hn : n â‰¤ N) : Integrable (fun v â†¦ â€–vâ€–^n * â€–f vâ€–) := by\n    convert (hf n hn).norm with x\n    simp [norm_smul]\n  have B : AEStronglyMeasurable f := by simpa using (hf 0 (zero_le _)).1\n  rw [iteratedDeriv, iteratedFDeriv_fourierIntegral A B hn,\n    fourierIntegral_continuousMultilinearMap_apply (integrable_fourierPowSMulRight _ (A n hn) B),\n    fourierIntegral_eq, fourierIntegral_eq]\n  congr with y\n  suffices (-(2 * Ï€ * I)) ^ n â€¢ y ^ n â€¢ f y = (-(2 * Ï€ * I * y)) ^ n â€¢ f y by\n    simpa [innerSL_apply _]\n  simp only [â† neg_mul, â† coe_smul, smul_smul, mul_pow, ofReal_pow, mul_assoc]\n\n"}
{"name":"Real.fourierIntegral_iteratedDeriv","module":"Mathlib.Analysis.Fourier.FourierTransformDeriv","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nN : ENat\nn : Nat\nhf : ContDiff Real (â†‘N) f\nh'f : âˆ€ (n : Nat), LE.le (â†‘n) N â†’ MeasureTheory.Integrable (iteratedDeriv n f) MeasureTheory.MeasureSpace.volume\nhn : LE.le (â†‘n) N\nâŠ¢ Eq (Real.fourierIntegral (iteratedDeriv n f)) fun x => HSMul.hSMul (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) â†‘x) n) (Real.fourierIntegral f x)","decl":"theorem fourierIntegral_iteratedDeriv {f : â„ â†’ E} {N : â„•âˆ} {n : â„•} (hf : ContDiff â„ N f)\n    (h'f : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (iteratedDeriv n f)) (hn : n â‰¤ N) :\n    ğ“• (iteratedDeriv n f) = fun (x : â„) â†¦ (2 * Ï€ * I * x) ^ n â€¢ (ğ“• f x) := by\n  ext x : 1\n  have A : âˆ€ (n : â„•), n â‰¤ N â†’ Integrable (iteratedFDeriv â„ n f) := by\n    intro n hn\n    rw [iteratedFDeriv_eq_equiv_comp]\n    exact (LinearIsometryEquiv.integrable_comp_iff _).2 (h'f n hn)\n  change ğ“• (fun x â†¦ iteratedDeriv n f x) x = _\n  simp_rw [iteratedDeriv, â† fourierIntegral_continuousMultilinearMap_apply (A n hn),\n    fourierIntegral_iteratedFDeriv hf A hn]\n  simp [â† coe_smul, smul_smul, â† mul_pow]\n\n"}
