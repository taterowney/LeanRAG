{"name":"IsCyclotomicExtension.Rat.discr_prime_pow_ne_two'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhk : Ne (HPow.hPow p (HAdd.hAdd k 1)) 2\nâŠ¢ Eq (Algebra.discr Rat â‡‘(IsPrimitiveRoot.subOnePowerBasis Rat hÎ¶).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HPow.hPow (â†‘p) (HAdd.hAdd k 1)).totient 2)) (HPow.hPow (â†‘â†‘p) (HMul.hMul (HPow.hPow (â†‘p) k) (HSub.hSub (HMul.hMul (HSub.hSub (â†‘p) 1) (HAdd.hAdd k 1)) 1))))","decl":"/-- The discriminant of the power basis given by `Î¶ - 1`. -/\ntheorem discr_prime_pow_ne_two' [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hk : p ^ (k + 1) â‰  2) :\n    discr â„š (hÎ¶.subOnePowerBasis â„š).basis =\n      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) := by\n  rw [â† discr_prime_pow_ne_two hÎ¶ (cyclotomic.irreducible_rat (p ^ (k + 1)).pos) hk]\n  exact hÎ¶.discr_zeta_eq_discr_zeta_sub_one.symm\n\n"}
{"name":"IsCyclotomicExtension.Rat.discr_odd_prime'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nhodd : Ne p 2\nâŠ¢ Eq (Algebra.discr Rat â‡‘(IsPrimitiveRoot.subOnePowerBasis Rat hÎ¶).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HSub.hSub (â†‘p) 1) 2)) (HPow.hPow (â†‘â†‘p) (HSub.hSub (â†‘p) 2)))","decl":"theorem discr_odd_prime' [IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) (hodd : p â‰  2) :\n    discr â„š (hÎ¶.subOnePowerBasis â„š).basis = (-1) ^ (((p : â„•) - 1) / 2) * p ^ ((p : â„•) - 2) := by\n  rw [â† discr_odd_prime hÎ¶ (cyclotomic.irreducible_rat hp.out.pos) hodd]\n  exact hÎ¶.discr_zeta_eq_discr_zeta_sub_one.symm\n\n"}
{"name":"IsCyclotomicExtension.Rat.discr_prime_pow'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ Eq (Algebra.discr Rat â‡‘(IsPrimitiveRoot.subOnePowerBasis Rat hÎ¶).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HPow.hPow (â†‘p) k).totient 2)) (HPow.hPow (â†‘â†‘p) (HMul.hMul (HPow.hPow (â†‘p) (HSub.hSub k 1)) (HSub.hSub (HMul.hMul (HSub.hSub (â†‘p) 1) k) 1))))","decl":"/-- The discriminant of the power basis given by `Î¶ - 1`. Beware that in the cases `p ^ k = 1` and\n`p ^ k = 2` the formula uses `1 / 2 = 0` and `0 - 1 = 0`. It is useful only to have a uniform\nresult. See also `IsCyclotomicExtension.Rat.discr_prime_pow_eq_unit_mul_pow'`. -/\ntheorem discr_prime_pow' [IsCyclotomicExtension {p ^ k} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    discr â„š (hÎ¶.subOnePowerBasis â„š).basis =\n      (-1) ^ ((p ^ k : â„•).totient / 2) * p ^ ((p : â„•) ^ (k - 1) * ((p - 1) * k - 1)) := by\n  rw [â† discr_prime_pow hÎ¶ (cyclotomic.irreducible_rat (p ^ k).pos)]\n  exact hÎ¶.discr_zeta_eq_discr_zeta_sub_one.symm\n\n"}
{"name":"IsCyclotomicExtension.Rat.discr_prime_pow_eq_unit_mul_pow'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ Exists fun u => Exists fun n => Eq (Algebra.discr Rat â‡‘(IsPrimitiveRoot.subOnePowerBasis Rat hÎ¶).basis) (HMul.hMul (â†‘â†‘u) (HPow.hPow (â†‘â†‘p) n))","decl":"/-- If `p` is a prime and `IsCyclotomicExtension {p ^ k} K L`, then there are `u : â„¤Ë£` and\n`n : â„•` such that the discriminant of the power basis given by `Î¶ - 1` is `u * p ^ n`. Often this is\nenough and less cumbersome to use than `IsCyclotomicExtension.Rat.discr_prime_pow'`. -/\ntheorem discr_prime_pow_eq_unit_mul_pow' [IsCyclotomicExtension {p ^ k} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    âˆƒ (u : â„¤Ë£) (n : â„•), discr â„š (hÎ¶.subOnePowerBasis â„š).basis = u * p ^ n := by\n  rw [hÎ¶.discr_zeta_eq_discr_zeta_sub_one.symm]\n  exact discr_prime_pow_eq_unit_mul_pow hÎ¶ (cyclotomic.irreducible_rat (p ^ k).pos)\n\n"}
{"name":"IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ IsIntegralClosure (Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x) Int K","decl":"/-- If `K` is a `p ^ k`-th cyclotomic extension of `â„š`, then `(adjoin â„¤ {Î¶})` is the\nintegral closure of `â„¤` in `K`. -/\ntheorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K := by\n  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©\n  swap\n  Â· rintro âŸ¨y, rflâŸ©\n    exact\n      IsIntegral.algebraMap\n        ((le_integralClosure_iff_isIntegral.1\n          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)\n  let B := hÎ¶.subOnePowerBasis â„š\n  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one\n-- Porting note: the following `haveI` was not needed because the locale `cyclotomic` set it\n-- as instances.\n  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K\n  have H := discr_mul_isIntegral_mem_adjoin â„š hint h\n  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶\n  rw [hun] at H\n  replace H := Subalgebra.smul_mem _ H u.inv\n-- Porting note: the proof is slightly different because of coercions.\n  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,\n    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H\n  cases k\n  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl\n    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by\n      rw [singleton_one â„š K]\n      exact mem_top\n    obtain âŸ¨y, rflâŸ© := mem_bot.1 this\n    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h\n    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h\n    rw [â† hz, â† IsScalarTower.algebraMap_apply]\n    exact Subalgebra.algebraMap_mem _ _\n  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by\n      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint\n      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)\n      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚\n      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,\n        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚\n      rw [IsPrimitiveRoot.subOnePowerBasis_gen,\n        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]\n      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _\n    refine\n      adjoin_le ?_\n        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)\n          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)\n    simp only [Set.singleton_subset_iff, SetLike.mem_coe]\n    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)\n\n"}
{"name":"IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ IsIntegralClosure (Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x) Int K","decl":"theorem isIntegralClosure_adjoin_singleton_of_prime [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K := by\n  rw [â† pow_one p] at hÎ¶ hcycl\n  exact isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶\n\n"}
{"name":"IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime_pow","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nhp : Fact (Nat.Prime â†‘p)\nâŠ¢ IsIntegralClosure (CyclotomicRing (HPow.hPow p k) Int Rat) Int (CyclotomicField (HPow.hPow p k) Rat)","decl":"/-- The integral closure of `â„¤` inside `CyclotomicField (p ^ k) â„š` is\n`CyclotomicRing (p ^ k) â„¤ â„š`. -/\ntheorem cyclotomicRing_isIntegralClosure_of_prime_pow :\n    IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š) := by\n  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)\n  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©\n-- Porting note: having `.isIntegral_iff` inside the definition of `this` causes an error.\n  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶\n    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h\n    refine adjoin_mono ?_ y.2\n    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]\n    exact hÎ¶.pow_eq_one\n  Â· rintro âŸ¨y, rflâŸ©\n    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _).isIntegral _)\n\n"}
{"name":"IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nhp : Fact (Nat.Prime â†‘p)\nâŠ¢ IsIntegralClosure (CyclotomicRing p Int Rat) Int (CyclotomicField p Rat)","decl":"theorem cyclotomicRing_isIntegralClosure_of_prime :\n    IsIntegralClosure (CyclotomicRing p â„¤ â„š) â„¤ (CyclotomicField p â„š) := by\n  rw [â† pow_one p]\n  exact cyclotomicRing_isIntegralClosure_of_prime_pow\n\n"}
{"name":"IsPrimitiveRoot.adjoinEquivRingOfIntegers_symm_apply","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\na : NumberField.RingOfIntegers K\nâŠ¢ Eq (hÎ¶.adjoinEquivRingOfIntegers.symm a) ((IsIntegralClosure.lift Int (Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x) K) a)","decl":"/-- The algebra isomorphism `adjoin â„¤ {Î¶} â‰ƒâ‚[â„¤] (ğ“ K)`, where `Î¶` is a primitive `p ^ k`-th root of\nunity and `K` is a `p ^ k`-th cyclotomic extension of `â„š`. -/\n@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers\n    [IsCyclotomicExtension {p ^ k} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    adjoin â„¤ ({Î¶} : Set K) â‰ƒâ‚[â„¤] ğ“ K :=\n  let _ := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶\n  IsIntegralClosure.equiv â„¤ (adjoin â„¤ ({Î¶} : Set K)) K (ğ“ K)\n\n"}
{"name":"IsPrimitiveRoot.adjoinEquivRingOfIntegers_apply","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\na : Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x\nâŠ¢ Eq (hÎ¶.adjoinEquivRingOfIntegers a) ((IsIntegralClosure.lift Int (NumberField.RingOfIntegers K) K) a)","decl":"/-- The algebra isomorphism `adjoin â„¤ {Î¶} â‰ƒâ‚[â„¤] (ğ“ K)`, where `Î¶` is a primitive `p ^ k`-th root of\nunity and `K` is a `p ^ k`-th cyclotomic extension of `â„š`. -/\n@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers\n    [IsCyclotomicExtension {p ^ k} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    adjoin â„¤ ({Î¶} : Set K) â‰ƒâ‚[â„¤] ğ“ K :=\n  let _ := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶\n  IsIntegralClosure.equiv â„¤ (adjoin â„¤ ({Î¶} : Set K)) K (ğ“ K)\n\n"}
{"name":"IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nâŠ¢ IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Int (NumberField.RingOfIntegers K)","decl":"/-- The ring of integers of a `p ^ k`-th cyclotomic extension of `â„š` is a cyclotomic extension. -/\ninstance IsCyclotomicExtension.ringOfIntegers [IsCyclotomicExtension {p ^ k} â„š K] :\n    IsCyclotomicExtension {p ^ k} â„¤ (ğ“ K) :=\n  let _ := (zeta_spec (p ^ k) â„š K).adjoin_isCyclotomicExtension â„¤\n  IsCyclotomicExtension.equiv _ â„¤ _ (zeta_spec (p ^ k) â„š K).adjoinEquivRingOfIntegers\n\n"}
{"name":"IsPrimitiveRoot.coe_toInteger","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"K : Type u\ninstâœ : Field K\nÎ¶ : K\nk : PNat\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘k\nâŠ¢ Eq (â†‘hÎ¶.toInteger) Î¶","decl":"lemma coe_toInteger {k : â„•+} (hÎ¶ : IsPrimitiveRoot Î¶ k) : hÎ¶.toInteger.1 = Î¶ := rfl\n\n"}
{"name":"IsPrimitiveRoot.finite_quotient_toInteger_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"K : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\ninstâœ : NumberField K\nk : PNat\nhk : LT.lt 1 k\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘k\nâŠ¢ Finite (HasQuotient.Quotient (NumberField.RingOfIntegers K) (Ideal.span (Singleton.singleton (HSub.hSub hÎ¶.toInteger 1))))","decl":"/-- `ğ“ K â§¸ Ideal.span {Î¶ - 1}` is finite. -/\nlemma finite_quotient_toInteger_sub_one [NumberField K] {k : â„•+} (hk : 1 < k)\n    (hÎ¶ : IsPrimitiveRoot Î¶ k) : Finite (ğ“ K â§¸ Ideal.span {hÎ¶.toInteger - 1}) := by\n  refine (finite_iff_nonempty_fintype _).2 âŸ¨?_âŸ©\n  refine Ideal.fintypeQuotientOfFreeOfNeBot _ (fun h â†¦ ?_)\n  simp only [Ideal.span_singleton_eq_bot, sub_eq_zero, â† Subtype.coe_inj] at h\n  exact hÎ¶.ne_one hk (RingOfIntegers.ext_iff.1 h)\n\n"}
{"name":"IsPrimitiveRoot.card_quotient_toInteger_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"K : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\ninstâœ : NumberField K\nk : PNat\nhk : LT.lt 1 k\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘k\nâŠ¢ Eq (Nat.card (HasQuotient.Quotient (NumberField.RingOfIntegers K) (Ideal.span (Singleton.singleton (HSub.hSub hÎ¶.toInteger 1))))) ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1)).natAbs","decl":"/-- We have that `ğ“ K â§¸ Ideal.span {Î¶ - 1}` has cardinality equal to the norm of `Î¶ - 1`.\n\nSee the results below to compute this norm in various cases. -/\nlemma card_quotient_toInteger_sub_one [NumberField K] {k : â„•+} (hk : 1 < k)\n    (hÎ¶ : IsPrimitiveRoot Î¶ k) :\n    Nat.card (ğ“ K â§¸ Ideal.span {hÎ¶.toInteger - 1}) =\n      (Algebra.norm â„¤ (hÎ¶.toInteger - 1)).natAbs := by\n  have := hÎ¶.finite_quotient_toInteger_sub_one hk\n  let _ := Fintype.ofFinite (ğ“ K â§¸ Ideal.span {hÎ¶.toInteger - 1})\n  rw [â† Submodule.cardQuot_apply, â† Ideal.absNorm_apply, Ideal.absNorm_span_singleton]\n\n"}
{"name":"IsPrimitiveRoot.toInteger_isPrimitiveRoot","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"K : Type u\ninstâœ : Field K\nÎ¶ : K\nk : PNat\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘k\nâŠ¢ IsPrimitiveRoot hÎ¶.toInteger â†‘k","decl":"lemma toInteger_isPrimitiveRoot {k : â„•+} (hÎ¶ : IsPrimitiveRoot Î¶ k) :\n    IsPrimitiveRoot hÎ¶.toInteger k :=\n  IsPrimitiveRoot.of_map_of_injective (by exact hÎ¶) RingOfIntegers.coe_injective\n\n"}
{"name":"IsPrimitiveRoot.integralPowerBasis_gen","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ Eq hÎ¶.integralPowerBasis.gen hÎ¶.toInteger","decl":"@[simp]\ntheorem integralPowerBasis_gen [hcycl : IsCyclotomicExtension {p ^ k} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    hÎ¶.integralPowerBasis.gen = hÎ¶.toInteger :=\n  Subtype.ext <| show algebraMap _ K hÎ¶.integralPowerBasis.gen = _ by\n    rw [integralPowerBasis, PowerBasis.map_gen, adjoin.powerBasis'_gen]\n    simp only [adjoinEquivRingOfIntegers_apply, IsIntegralClosure.algebraMap_lift]\n    rfl\n\n"}
{"name":"IsPrimitiveRoot.integralPowerBasis_dim","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ Eq hÎ¶.integralPowerBasis.dim (HPow.hPow (â†‘p) k).totient","decl":"set_option linter.unusedVariables false in\n@[simp]\ntheorem integralPowerBasis_dim [hcycl : IsCyclotomicExtension {p ^ k} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : hÎ¶.integralPowerBasis.dim = Ï† (p ^ k) := by\n  simp [integralPowerBasis, â† cyclotomic_eq_minpoly hÎ¶, natDegree_cyclotomic]\n\n"}
{"name":"IsPrimitiveRoot.adjoinEquivRingOfIntegers'_apply","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\na : Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x\nâŠ¢ Eq (hÎ¶.adjoinEquivRingOfIntegers' a) ((IsIntegralClosure.lift Int (NumberField.RingOfIntegers K) K) a)","decl":"/-- The algebra isomorphism `adjoin â„¤ {Î¶} â‰ƒâ‚[â„¤] (ğ“ K)`, where `Î¶` is a primitive `p`-th root of\nunity and `K` is a `p`-th cyclotomic extension of `â„š`. -/\n@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers'\n    [hcycl : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    adjoin â„¤ ({Î¶} : Set K) â‰ƒâ‚[â„¤] ğ“ K :=\n  have : IsCyclotomicExtension {p ^ 1} â„š K := by convert hcycl; rw [pow_one]\n  adjoinEquivRingOfIntegers (p := p) (k := 1) (Î¶ := Î¶) (by rwa [pow_one])\n\n"}
{"name":"IsPrimitiveRoot.adjoinEquivRingOfIntegers'_symm_apply","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\na : NumberField.RingOfIntegers K\nâŠ¢ Eq (hÎ¶.adjoinEquivRingOfIntegers'.symm a) ((IsIntegralClosure.lift Int (Subtype fun x => Membership.mem (Algebra.adjoin Int (Singleton.singleton Î¶)) x) K) a)","decl":"/-- The algebra isomorphism `adjoin â„¤ {Î¶} â‰ƒâ‚[â„¤] (ğ“ K)`, where `Î¶` is a primitive `p`-th root of\nunity and `K` is a `p`-th cyclotomic extension of `â„š`. -/\n@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers'\n    [hcycl : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    adjoin â„¤ ({Î¶} : Set K) â‰ƒâ‚[â„¤] ğ“ K :=\n  have : IsCyclotomicExtension {p ^ 1} â„š K := by convert hcycl; rw [pow_one]\n  adjoinEquivRingOfIntegers (p := p) (k := 1) (Î¶ := Î¶) (by rwa [pow_one])\n\n"}
{"name":"IsCyclotomicExtension.ring_of_integers'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ² : Field K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton p) Rat K\nâŠ¢ IsCyclotomicExtension (Singleton.singleton p) Int (NumberField.RingOfIntegers K)","decl":"/-- The ring of integers of a `p`-th cyclotomic extension of `â„š` is a cyclotomic extension. -/\ninstance _root_.IsCyclotomicExtension.ring_of_integers' [IsCyclotomicExtension {p} â„š K] :\n    IsCyclotomicExtension {p} â„¤ (ğ“ K) :=\n  let _ := (zeta_spec p â„š K).adjoin_isCyclotomicExtension â„¤\n  IsCyclotomicExtension.equiv _ â„¤ _ (zeta_spec p â„š K).adjoinEquivRingOfIntegers'\n\n"}
{"name":"IsPrimitiveRoot.integralPowerBasis'_gen","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Eq hÎ¶.integralPowerBasis'.gen hÎ¶.toInteger","decl":"@[simp]\ntheorem integralPowerBasis'_gen [hcycl : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    hÎ¶.integralPowerBasis'.gen = hÎ¶.toInteger :=\n  integralPowerBasis_gen (hcycl := by rwa [pow_one]) (by rwa [pow_one])\n\n"}
{"name":"IsPrimitiveRoot.power_basis_int'_dim","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Eq hÎ¶.integralPowerBasis'.dim (â†‘p).totient","decl":"@[simp]\ntheorem power_basis_int'_dim [hcycl : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    hÎ¶.integralPowerBasis'.dim = Ï† p := by\n  erw [integralPowerBasis_dim (hcycl := by rwa [pow_one]) (by rwa [pow_one]), pow_one]\n\n\n"}
{"name":"IsPrimitiveRoot.subOneIntegralPowerBasis_gen","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p k)\nâŠ¢ Eq hÎ¶.subOneIntegralPowerBasis.gen âŸ¨HSub.hSub Î¶ 1, â‹¯âŸ©","decl":"@[simp]\ntheorem subOneIntegralPowerBasis_gen [IsCyclotomicExtension {p ^ k} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) :\n    hÎ¶.subOneIntegralPowerBasis.gen =\n      âŸ¨Î¶ - 1, Subalgebra.sub_mem _ (hÎ¶.isIntegral (p ^ k).pos) (Subalgebra.one_mem _)âŸ© := by\n  simp [subOneIntegralPowerBasis]\n\n"}
{"name":"IsPrimitiveRoot.subOneIntegralPowerBasis'_gen","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Eq hÎ¶.subOneIntegralPowerBasis'.gen (HSub.hSub hÎ¶.toInteger 1)","decl":"@[simp, nolint unusedHavesSuffices]\ntheorem subOneIntegralPowerBasis'_gen [IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    hÎ¶.subOneIntegralPowerBasis'.gen = hÎ¶.toInteger - 1 :=\n  -- The `unusedHavesSuffices` linter incorrectly thinks this `have` is unnecessary.\n  have : IsCyclotomicExtension {p ^ 1} â„š K := by rwa [pow_one]\n  subOneIntegralPowerBasis_gen (by rwa [pow_one])\n\n"}
{"name":"IsPrimitiveRoot.zeta_sub_one_prime_of_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhodd : Ne p 2\nâŠ¢ Prime (HSub.hSub hÎ¶.toInteger 1)","decl":"/-- `Î¶ - 1` is prime if `p â‰  2` and `Î¶` is a primitive `p ^ (k + 1)`-th root of unity.\n  See `zeta_sub_one_prime` for a general statement. -/\ntheorem zeta_sub_one_prime_of_ne_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hodd : p â‰  2) :\n    Prime (hÎ¶.toInteger - 1) := by\n  letI := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n  refine Ideal.prime_of_irreducible_absNorm_span (fun h â†¦ ?_) ?_\n  Â· apply hÎ¶.pow_ne_one_of_pos_of_lt zero_lt_one (one_lt_powâ‚€ hp.out.one_lt (by simp))\n    rw [sub_eq_zero] at h\n    simpa using congrArg (algebraMap _ K) h\n  rw [Nat.irreducible_iff_prime, Ideal.absNorm_span_singleton, â† Nat.prime_iff,\n    â† Int.prime_iff_natAbs_prime]\n  convert Nat.prime_iff_prime_int.1 hp.out\n  apply RingHom.injective_int (algebraMap â„¤ â„š)\n  rw [â† Algebra.norm_localization (Sâ‚˜ := K) â„¤ (nonZeroDivisors â„¤)]\n  simp only [PNat.pow_coe, id.map_eq_id, RingHomCompTriple.comp_eq, RingHom.coe_coe,\n    Subalgebra.coe_val, algebraMap_int_eq, map_natCast]\n  exact hÎ¶.norm_sub_one_of_prime_ne_two (Polynomial.cyclotomic.irreducible_rat (PNat.pos _)) hodd\n\n"}
{"name":"IsPrimitiveRoot.zeta_sub_one_prime_of_two_pow","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"k : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow 2 (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow 2 (HAdd.hAdd k 1))\nâŠ¢ Prime (HSub.hSub hÎ¶.toInteger 1)","decl":"/-- `Î¶ - 1` is prime if `Î¶` is a primitive `2 ^ (k + 1)`-th root of unity.\n  See `zeta_sub_one_prime` for a general statement. -/\ntheorem zeta_sub_one_prime_of_two_pow [IsCyclotomicExtension {(2 : â„•+) ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘((2 : â„•+) ^ (k + 1))) :\n    Prime (hÎ¶.toInteger - 1) := by\n  letI := IsCyclotomicExtension.numberField {(2 : â„•+) ^ (k + 1)} â„š K\n  refine Ideal.prime_of_irreducible_absNorm_span (fun h â†¦ ?_) ?_\n  Â· apply hÎ¶.pow_ne_one_of_pos_of_lt zero_lt_one (one_lt_powâ‚€ (by decide) (by simp))\n    rw [sub_eq_zero] at h\n    simpa using congrArg (algebraMap _ K) h\n  rw [Nat.irreducible_iff_prime, Ideal.absNorm_span_singleton, â† Nat.prime_iff,\n    â† Int.prime_iff_natAbs_prime]\n  cases k\n  Â· convert Prime.neg Int.prime_two\n    apply RingHom.injective_int (algebraMap â„¤ â„š)\n    rw [â† Algebra.norm_localization (Sâ‚˜ := K) â„¤ (nonZeroDivisors â„¤)]\n    simp only [PNat.pow_coe, id.map_eq_id, RingHomCompTriple.comp_eq, RingHom.coe_coe,\n      Subalgebra.coe_val, algebraMap_int_eq, map_neg, map_ofNat]\n    simpa only [zero_add, pow_one, AddSubgroupClass.coe_sub, OneMemClass.coe_one,\n        pow_zero]\n      using hÎ¶.norm_pow_sub_one_two (cyclotomic.irreducible_rat\n        (by simp only [zero_add, pow_one, Nat.ofNat_pos]))\n  convert Int.prime_two\n  apply RingHom.injective_int (algebraMap â„¤ â„š)\n  rw [â† Algebra.norm_localization (Sâ‚˜ := K) â„¤ (nonZeroDivisors â„¤)]\n  simp only [PNat.pow_coe, id.map_eq_id, RingHomCompTriple.comp_eq, RingHom.coe_coe,\n    Subalgebra.coe_val, algebraMap_int_eq, map_natCast]\n  exact hÎ¶.norm_sub_one_two Nat.AtLeastTwo.prop (cyclotomic.irreducible_rat (by simp))\n\n"}
{"name":"IsPrimitiveRoot.zeta_sub_one_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nâŠ¢ Prime (HSub.hSub hÎ¶.toInteger 1)","decl":"/-- `Î¶ - 1` is prime if `Î¶` is a primitive `p ^ (k + 1)`-th root of unity. -/\ntheorem zeta_sub_one_prime [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) : Prime (hÎ¶.toInteger - 1) := by\n  by_cases htwo : p = 2\n  Â· subst htwo\n    apply hÎ¶.zeta_sub_one_prime_of_two_pow\n  Â· apply hÎ¶.zeta_sub_one_prime_of_ne_two htwo\n\n"}
{"name":"IsPrimitiveRoot.zeta_sub_one_prime'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nh : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Prime (HSub.hSub hÎ¶.toInteger 1)","decl":"/-- `Î¶ - 1` is prime if `Î¶` is a primitive `p`-th root of unity. -/\ntheorem zeta_sub_one_prime' [h : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ p) :\n    Prime ((hÎ¶.toInteger - 1)) := by\n  convert zeta_sub_one_prime (k := 0) (by simpa only [zero_add, pow_one])\n  simpa only [zero_add, pow_one]\n\n"}
{"name":"IsPrimitiveRoot.subOneIntegralPowerBasis_gen_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nâŠ¢ Prime hÎ¶.subOneIntegralPowerBasis.gen","decl":"theorem subOneIntegralPowerBasis_gen_prime [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) :\n    Prime hÎ¶.subOneIntegralPowerBasis.gen := by\n  simpa only [subOneIntegralPowerBasis_gen] using hÎ¶.zeta_sub_one_prime\n\n"}
{"name":"IsPrimitiveRoot.subOneIntegralPowerBasis'_gen_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Prime hÎ¶.subOneIntegralPowerBasis'.gen","decl":"theorem subOneIntegralPowerBasis'_gen_prime [IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) :\n    Prime hÎ¶.subOneIntegralPowerBasis'.gen := by\n  simpa only [subOneIntegralPowerBasis'_gen] using hÎ¶.zeta_sub_one_prime'\n\n"}
{"name":"IsPrimitiveRoot.norm_toInteger_pow_sub_one_of_prime_pow_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\ns : Nat\nhs : LE.le s k\nhtwo : Ne (HPow.hPow p (HAdd.hAdd (HSub.hSub k s) 1)) 2\nâŠ¢ Eq ((Algebra.norm Int) (HSub.hSub (HPow.hPow hÎ¶.toInteger (HPow.hPow (â†‘p) s)) 1)) (HPow.hPow (â†‘â†‘p) (HPow.hPow (â†‘p) s))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ ^ p ^ s - 1` in a `p ^ (k + 1)`-th cyclotomic extension of `â„š`\nis p ^ p ^ s` if `s â‰¤ k` and `p ^ (k - s + 1) â‰  2`. -/\nlemma norm_toInteger_pow_sub_one_of_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) {s : â„•} (hs : s â‰¤ k) (htwo : p ^ (k - s + 1) â‰  2) :\n    Algebra.norm â„¤ (hÎ¶.toInteger ^ (p : â„•) ^ s - 1) = p ^ (p : â„•) ^ s := by\n  have : NumberField K := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n  rw [Algebra.norm_eq_iff â„¤ (Sâ‚˜ := K) (Râ‚˜ := â„š) rfl.le]\n  simp [hÎ¶.norm_pow_sub_one_of_prime_pow_ne_two\n          (cyclotomic.irreducible_rat (by simp only [PNat.pow_coe, gt_iff_lt, PNat.pos, pow_pos]))\n          hs htwo]\n\n"}
{"name":"IsPrimitiveRoot.norm_toInteger_pow_sub_one_of_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"k : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow 2 (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow 2 (HAdd.hAdd k 1))\nâŠ¢ Eq ((Algebra.norm Int) (HSub.hSub (HPow.hPow hÎ¶.toInteger (HPow.hPow 2 k)) 1)) (HPow.hPow (-2) (HPow.hPow 2 k))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ ^ 2 ^ k - 1` in a `2 ^ (k + 1)`-th cyclotomic extension of `â„š`\nis `(-2) ^ 2 ^ k`. -/\nlemma norm_toInteger_pow_sub_one_of_two [IsCyclotomicExtension {2 ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘((2 : â„•+) ^ (k + 1))) :\n    Algebra.norm â„¤ (hÎ¶.toInteger ^ 2 ^ k - 1) = (-2) ^ (2 : â„•) ^ k := by\n  have : NumberField K := IsCyclotomicExtension.numberField {2 ^ (k + 1)} â„š K\n  rw [Algebra.norm_eq_iff â„¤ (Sâ‚˜ := K) (Râ‚˜ := â„š) rfl.le]\n  simp [hÎ¶.norm_pow_sub_one_two (cyclotomic.irreducible_rat (pow_pos (by decide) _))]\n\n"}
{"name":"IsPrimitiveRoot.norm_toInteger_pow_sub_one_of_prime_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\ns : Nat\nhs : LE.le s k\nhodd : Ne p 2\nâŠ¢ Eq ((Algebra.norm Int) (HSub.hSub (HPow.hPow hÎ¶.toInteger (HPow.hPow (â†‘p) s)) 1)) (HPow.hPow (â†‘â†‘p) (HPow.hPow (â†‘p) s))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ ^ p ^ s - 1` in a `p ^ (k + 1)`-th cyclotomic extension of `â„š`\nis `p ^ p ^ s` if `s â‰¤ k` and `p â‰  2`. -/\nlemma norm_toInteger_pow_sub_one_of_prime_ne_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) {s : â„•} (hs : s â‰¤ k) (hodd : p â‰  2) :\n    Algebra.norm â„¤ (hÎ¶.toInteger ^ (p : â„•) ^ s - 1) = p ^ (p : â„•) ^ s := by\n  refine hÎ¶.norm_toInteger_pow_sub_one_of_prime_pow_ne_two hs (fun h â†¦ hodd ?_)\n  suffices h : (p : â„•) = 2 from PNat.coe_injective h\n  apply eq_of_prime_pow_eq hp.out.prime Nat.prime_two.prime (k - s).succ_pos\n  rw [pow_one]\n  exact congr_arg Subtype.val h\n\n"}
{"name":"IsPrimitiveRoot.norm_toInteger_sub_one_of_prime_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhodd : Ne p 2\nâŠ¢ Eq ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1)) â†‘â†‘p","decl":"/-- The norm, relative to `â„¤`, of `Î¶ - 1` in a `p ^ (k + 1)`-th cyclotomic extension of `â„š` is\n`p` if `p â‰  2`. -/\nlemma norm_toInteger_sub_one_of_prime_ne_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hodd : p â‰  2) :\n    Algebra.norm â„¤ (hÎ¶.toInteger - 1) = p := by\n  simpa only [pow_zero, pow_one] using\n    hÎ¶.norm_toInteger_pow_sub_one_of_prime_ne_two (Nat.zero_le _) hodd\n\n"}
{"name":"IsPrimitiveRoot.norm_toInteger_sub_one_of_prime_ne_two'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nh : Ne p 2\nâŠ¢ Eq ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1)) â†‘â†‘p","decl":"/-- The norm, relative to `â„¤`, of `Î¶ - 1` in a `p`-th cyclotomic extension of `â„š` is `p` if\n`p â‰  2`. -/\nlemma norm_toInteger_sub_one_of_prime_ne_two' [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ p) (h : p â‰  2) : Algebra.norm â„¤ (hÎ¶.toInteger - 1) = p := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by simpa using hcycl\n  replace hÎ¶ : IsPrimitiveRoot Î¶ (p ^ (0 + 1)) := by simpa using hÎ¶\n  exact hÎ¶.norm_toInteger_sub_one_of_prime_ne_two h\n\n"}
{"name":"IsPrimitiveRoot.prime_norm_toInteger_sub_one_of_prime_pow_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhtwo : Ne (HPow.hPow p (HAdd.hAdd k 1)) 2\nâŠ¢ Prime ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ - 1` in a `p ^ (k + 1)`-th cyclotomic extension of `â„š` is\na prime if `p ^ (k  + 1) â‰  2`. -/\nlemma prime_norm_toInteger_sub_one_of_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (htwo : p ^ (k + 1) â‰  2) :\n    Prime (Algebra.norm â„¤ (hÎ¶.toInteger - 1)) := by\n  have := hÎ¶.norm_toInteger_pow_sub_one_of_prime_pow_ne_two (zero_le _) htwo\n  simp only [pow_zero, pow_one] at this\n  rw [this]\n  exact Nat.prime_iff_prime_int.1 hp.out\n\n"}
{"name":"IsPrimitiveRoot.prime_norm_toInteger_sub_one_of_prime_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhodd : Ne p 2\nâŠ¢ Prime ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ - 1` in a `p ^ (k + 1)`-th cyclotomic extension of `â„š` is\na prime if `p â‰  2`. -/\nlemma prime_norm_toInteger_sub_one_of_prime_ne_two [hcycl : IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hodd : p â‰  2) :\n    Prime (Algebra.norm â„¤ (hÎ¶.toInteger - 1)) := by\n  have := hÎ¶.norm_toInteger_sub_one_of_prime_ne_two hodd\n  simp only [pow_zero, pow_one] at this\n  rw [this]\n  exact Nat.prime_iff_prime_int.1 hp.out\n\n"}
{"name":"IsPrimitiveRoot.prime_norm_toInteger_sub_one_of_prime_ne_two'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nhodd : Ne p 2\nâŠ¢ Prime ((Algebra.norm Int) (HSub.hSub hÎ¶.toInteger 1))","decl":"/-- The norm, relative to `â„¤`, of `Î¶ - 1` in a `p`-th cyclotomic extension of `â„š` is a prime if\n`p â‰  2`. -/\nlemma prime_norm_toInteger_sub_one_of_prime_ne_two' [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) (hodd : p â‰  2) :\n    Prime (Algebra.norm â„¤ (hÎ¶.toInteger - 1)) := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by simpa using hcycl\n  replace hÎ¶ : IsPrimitiveRoot Î¶ (p ^ (0 + 1)) := by simpa using hÎ¶\n  exact hÎ¶.prime_norm_toInteger_sub_one_of_prime_ne_two hodd\n\n"}
{"name":"IsPrimitiveRoot.not_exists_int_prime_dvd_sub_of_prime_pow_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhtwo : Ne (HPow.hPow p (HAdd.hAdd k 1)) 2\nâŠ¢ Not (Exists fun n => Dvd.dvd (â†‘â†‘p) (HSub.hSub hÎ¶.toInteger â†‘n))","decl":"/-- In a `p ^ (k + 1)`-th cyclotomic extension of `â„š `, we have that `Î¶` is not congruent to an\n  integer modulo `p` if `p ^ (k  + 1) â‰  2`. -/\ntheorem not_exists_int_prime_dvd_sub_of_prime_pow_ne_two\n    [hcycl : IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (htwo : p ^ (k + 1) â‰  2) :\n    Â¬(âˆƒ n : â„¤, (p : ğ“ K) âˆ£ (hÎ¶.toInteger - n : ğ“ K)) := by\n  intro âŸ¨n, x, hâŸ©\n  -- Let `pB` be the power basis of `ğ“ K` given by powers of `Î¶`.\n  let pB := hÎ¶.integralPowerBasis\n  have hdim : pB.dim = â†‘p ^ k * (â†‘p - 1) := by\n    simp [integralPowerBasis_dim, pB, Nat.totient_prime_pow hp.1 (Nat.zero_lt_succ k)]\n  replace hdim : 1 < pB.dim := by\n    rw [Nat.one_lt_iff_ne_zero_and_ne_one, hdim]\n    refine âŸ¨by simp only [ne_eq, mul_eq_zero, pow_eq_zero_iff', PNat.ne_zero, false_and, false_or,\n      Nat.sub_eq_zero_iff_le, not_le, Nat.Prime.one_lt hp.out], ne_of_gt ?_âŸ©\n    by_cases hk : k = 0\n    Â· simp only [hk, zero_add, pow_one, pow_zero, one_mul, Nat.lt_sub_iff_add_lt,\n        Nat.reduceAdd] at htwo âŠ¢\n      exact htwo.symm.lt_of_le hp.1.two_le\n    Â· exact one_lt_mul_of_lt_of_le (one_lt_powâ‚€ hp.1.one_lt hk)\n        (have := Nat.Prime.two_le hp.out; by omega)\n  rw [sub_eq_iff_eq_add] at h\n  -- We are assuming that `Î¶ = n + p * x` for some integer `n` and `x : ğ“ K`. Looking at the\n  -- coordinates in the base `pB`, we obtain that `1` is a multiple of `p`, contradiction.\n  replace h := pB.basis.ext_elem_iff.1 h âŸ¨1, hdimâŸ©\n  have := pB.basis_eq_pow âŸ¨1, hdimâŸ©\n  rw [hÎ¶.integralPowerBasis_gen] at this\n  simp only [PowerBasis.coe_basis, pow_one] at this\n  rw [â† this, show pB.gen = pB.gen ^ (âŸ¨1, hdimâŸ© : Fin pB.dim).1 by simp, â† pB.basis_eq_pow,\n    pB.basis.repr_self_apply] at h\n  simp only [â†“reduceIte, map_add, Finsupp.coe_add, Pi.add_apply] at h\n  rw [show (p : ğ“ K) * x = (p : â„¤) â€¢ x by simp, â† pB.basis.coord_apply,\n    LinearMap.map_smul, â† zsmul_one, â† pB.basis.coord_apply, LinearMap.map_smul,\n    show 1 = pB.gen ^ (âŸ¨0, by omegaâŸ© : Fin pB.dim).1 by simp, â† pB.basis_eq_pow,\n    pB.basis.coord_apply, pB.basis.coord_apply, pB.basis.repr_self_apply] at h\n  simp only [smul_eq_mul, Fin.mk.injEq, zero_ne_one, â†“reduceIte, mul_zero, add_zero] at h\n  exact (Int.prime_iff_natAbs_prime.2 (by simp [hp.1])).not_dvd_one âŸ¨_, hâŸ©\n\n"}
{"name":"IsPrimitiveRoot.not_exists_int_prime_dvd_sub_of_prime_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhodd : Ne p 2\nâŠ¢ Not (Exists fun n => Dvd.dvd (â†‘â†‘p) (HSub.hSub hÎ¶.toInteger â†‘n))","decl":"/-- In a `p ^ (k + 1)`-th cyclotomic extension of `â„š `, we have that `Î¶` is not congruent to an\n  integer modulo `p` if `p â‰  2`. -/\ntheorem not_exists_int_prime_dvd_sub_of_prime_ne_two\n    [hcycl : IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hodd : p â‰  2) :\n    Â¬(âˆƒ n : â„¤, (p : ğ“ K) âˆ£ (hÎ¶.toInteger - n : ğ“ K)) := by\n  refine not_exists_int_prime_dvd_sub_of_prime_pow_ne_two hÎ¶ (fun h â†¦ ?_)\n  simp_all only [(@Nat.Prime.pow_eq_iff 2 p (k+1) Nat.prime_two).mp (by assumption_mod_cast),\n    pow_one, ne_eq]\n\n"}
{"name":"IsPrimitiveRoot.not_exists_int_prime_dvd_sub_of_prime_ne_two'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nhodd : Ne p 2\nâŠ¢ Not (Exists fun n => Dvd.dvd (â†‘â†‘p) (HSub.hSub hÎ¶.toInteger â†‘n))","decl":"/-- In a `p`-th cyclotomic extension of `â„š `, we have that `Î¶` is not congruent to an\n  integer modulo `p` if `p â‰  2`. -/\ntheorem not_exists_int_prime_dvd_sub_of_prime_ne_two'\n    [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) (hodd : p â‰  2) :\n    Â¬(âˆƒ n : â„¤, (p : ğ“ K) âˆ£ (hÎ¶.toInteger - n : ğ“ K)) := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by simpa using hcycl\n  replace hÎ¶ : IsPrimitiveRoot Î¶ (p ^ (0 + 1)) := by simpa using hÎ¶\n  exact not_exists_int_prime_dvd_sub_of_prime_ne_two hÎ¶ hodd\n\n"}
{"name":"IsPrimitiveRoot.finite_quotient_span_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nâŠ¢ Finite (HasQuotient.Quotient (NumberField.RingOfIntegers K) (Ideal.span (Singleton.singleton (HSub.hSub hÎ¶.toInteger 1))))","decl":"theorem finite_quotient_span_sub_one [hcycl : IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) :\n    Finite (ğ“ K â§¸ Ideal.span {hÎ¶.toInteger - 1}) := by\n  have : NumberField K := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n  refine Fintype.finite <| Ideal.fintypeQuotientOfFreeOfNeBot _ (fun h â†¦ ?_)\n  simp only [Ideal.span_singleton_eq_bot, sub_eq_zero, â† Subtype.coe_inj] at h\n  exact hÎ¶.ne_one (one_lt_powâ‚€ hp.1.one_lt (Nat.zero_ne_add_one k).symm)\n    (RingOfIntegers.ext_iff.1 h)\n\n"}
{"name":"IsPrimitiveRoot.finite_quotient_span_sub_one'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Finite (HasQuotient.Quotient (NumberField.RingOfIntegers K) (Ideal.span (Singleton.singleton (HSub.hSub hÎ¶.toInteger 1))))","decl":"theorem finite_quotient_span_sub_one' [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) :\n    Finite (ğ“ K â§¸ Ideal.span {hÎ¶.toInteger - 1}) := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by simpa using hcycl\n  replace hÎ¶ : IsPrimitiveRoot Î¶ (p ^ (0 + 1)) := by simpa using hÎ¶\n  exact hÎ¶.finite_quotient_span_sub_one\n\n"}
{"name":"IsPrimitiveRoot.toInteger_sub_one_dvd_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nâŠ¢ Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) â†‘â†‘p","decl":"/-- In a `p ^ (k + 1)`-th cyclotomic extension of `â„š`, we have that\n  `Î¶ - 1` divides `p` in `ğ“ K`. -/\nlemma toInteger_sub_one_dvd_prime [hcycl : IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) : ((hÎ¶.toInteger - 1)) âˆ£ p := by\n  by_cases htwo : p ^ (k + 1) = 2\n  Â· replace htwo : (p : â„•) ^ (k + 1) = 2 := by exact_mod_cast htwo\n    have âŸ¨hp2, hkâŸ© := (Nat.Prime.pow_eq_iff Nat.prime_two).1 htwo\n    simp only [add_left_eq_self] at hk\n    have hÎ¶' : Î¶ = -1 := by\n      refine IsPrimitiveRoot.eq_neg_one_of_two_right ?_\n      rwa [hk, zero_add, pow_one, hp2] at hÎ¶\n    replace hÎ¶' : hÎ¶.toInteger = -1 := by\n      ext\n      exact hÎ¶'\n    rw [hÎ¶', hp2]\n    exact âŸ¨-1, by ringâŸ©\n  suffices (hÎ¶.toInteger - 1) âˆ£ (p : â„¤) by simpa\n  have := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n  have H := hÎ¶.norm_toInteger_pow_sub_one_of_prime_pow_ne_two (zero_le _) htwo\n  rw [pow_zero, pow_one] at H\n  rw [â† Ideal.norm_dvd_iff, H]\n  Â· simp\n  Â· exact prime_norm_toInteger_sub_one_of_prime_pow_ne_two hÎ¶ htwo\n\n"}
{"name":"IsPrimitiveRoot.toInteger_sub_one_dvd_prime'","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ¹ : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœ : CharZero K\nhcycl : IsCyclotomicExtension (Singleton.singleton p) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘p\nâŠ¢ Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) â†‘â†‘p","decl":"/-- In a `p`-th cyclotomic extension of `â„š`, we have that `Î¶ - 1` divides `p` in `ğ“ K`. -/\nlemma toInteger_sub_one_dvd_prime' [hcycl : IsCyclotomicExtension {p} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p) : ((hÎ¶.toInteger - 1)) âˆ£ p := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by simpa using hcycl\n  replace hÎ¶ : IsPrimitiveRoot Î¶ (p ^ (0 + 1)) := by simpa using hÎ¶\n  exact toInteger_sub_one_dvd_prime hÎ¶\n\n"}
{"name":"IsPrimitiveRoot.toInteger_sub_one_not_dvd_two","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nÎ¶ : K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘(HPow.hPow p (HAdd.hAdd k 1))\nhodd : Ne p 2\nâŠ¢ Not (Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) 2)","decl":"/-- We have that `hÎ¶.toInteger - 1` does not divide `2`. -/\nlemma toInteger_sub_one_not_dvd_two [IsCyclotomicExtension {p ^ (k + 1)} â„š K]\n    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hodd : p â‰  2) : Â¬ hÎ¶.toInteger - 1 âˆ£ 2 := fun h â†¦ by\n  have : NumberField K := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n  replace h : hÎ¶.toInteger - 1 âˆ£ â†‘(2 : â„¤) := by simp [h]\n  rw [â† Ideal.norm_dvd_iff, hÎ¶.norm_toInteger_sub_one_of_prime_ne_two hodd] at h\n  Â· refine hodd <| PNat.coe_inj.1 <| (prime_dvd_prime_iff_eq ?_ ?_).1 ?_\n    Â· exact Nat.prime_iff.1 hp.1\n    Â· exact Nat.prime_iff.1 Nat.prime_two\n    Â· exact Int.ofNat_dvd.mp h\n  Â· rw [hÎ¶.norm_toInteger_sub_one_of_prime_ne_two hodd]\n    exact Nat.prime_iff_prime_int.1 hp.1\n\n"}
{"name":"IsCyclotomicExtension.Rat.absdiscr_prime_pow","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) Rat K\nâŠ¢ Eq (NumberField.discr K) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HPow.hPow (â†‘p) k).totient 2)) (HPow.hPow (â†‘â†‘p) (HMul.hMul (HPow.hPow (â†‘p) (HSub.hSub k 1)) (HSub.hSub (HMul.hMul (HSub.hSub (â†‘p) 1) k) 1))))","decl":"/-- We compute the absolute discriminant of a `p ^ k`-th cyclotomic field.\n  Beware that in the cases `p ^ k = 1` and `p ^ k = 2` the formula uses `1 / 2 = 0` and `0 - 1 = 0`.\n  See also the results below. -/\ntheorem absdiscr_prime_pow [IsCyclotomicExtension {p ^ k} â„š K] :\n    haveI : NumberField K := IsCyclotomicExtension.numberField {p ^ k} â„š K\n    NumberField.discr K =\n    (-1) ^ ((p ^ k : â„•).totient / 2) * p ^ ((p : â„•) ^ (k - 1) * ((p - 1) * k - 1)) := by\n  have hÎ¶ := IsCyclotomicExtension.zeta_spec (p ^ k) â„š K\n  have : NumberField K := IsCyclotomicExtension.numberField {p ^ k} â„š K\n  let pBâ‚ := integralPowerBasis hÎ¶\n  apply (algebraMap â„¤ â„š).injective_int\n  rw [â† NumberField.discr_eq_discr _ pBâ‚.basis, â† Algebra.discr_localizationLocalization â„¤ â„¤â° K]\n  convert IsCyclotomicExtension.discr_prime_pow hÎ¶ (cyclotomic.irreducible_rat (p ^ k).2) using 1\n  Â· have : pBâ‚.dim = (IsPrimitiveRoot.powerBasis â„š hÎ¶).dim := by\n      rw [â† PowerBasis.finrank, â† PowerBasis.finrank]\n      exact RingOfIntegers.rank K\n    rw [â† Algebra.discr_reindex _ _ (finCongr this)]\n    congr 1\n    ext i\n    simp_rw [Function.comp_apply, Basis.localizationLocalization_apply, powerBasis_dim,\n      PowerBasis.coe_basis, pBâ‚, integralPowerBasis_gen]\n    convert â† ((IsPrimitiveRoot.powerBasis â„š hÎ¶).basis_eq_pow i).symm using 1\n  Â· simp_rw [algebraMap_int_eq, map_mul, map_pow, map_neg, map_one, map_natCast]\n\n"}
{"name":"IsCyclotomicExtension.Rat.absdiscr_prime_pow_succ","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nk : Nat\nK : Type u\ninstâœÂ² : Field K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) Rat K\nâŠ¢ Eq (NumberField.discr K) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HMul.hMul (HPow.hPow (â†‘p) k) (HSub.hSub (â†‘p) 1)) 2)) (HPow.hPow (â†‘â†‘p) (HMul.hMul (HPow.hPow (â†‘p) k) (HSub.hSub (HMul.hMul (HSub.hSub (â†‘p) 1) (HAdd.hAdd k 1)) 1))))","decl":"open Nat in\n/-- We compute the absolute discriminant of a `p ^ (k + 1)`-th cyclotomic field.\n  Beware that in the case `p ^ k = 2` the formula uses `1 / 2 = 0`. See also the results below. -/\ntheorem absdiscr_prime_pow_succ [IsCyclotomicExtension {p ^ (k + 1)} â„š K] :\n    haveI : NumberField K := IsCyclotomicExtension.numberField {p ^ (k + 1)} â„š K\n    NumberField.discr K =\n    (-1) ^ ((p : â„•) ^ k * (p - 1) / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) := by\n  simpa [totient_prime_pow hp.out (succ_pos k)] using absdiscr_prime_pow p (k + 1) K\n\n"}
{"name":"IsCyclotomicExtension.Rat.absdiscr_prime","module":"Mathlib.NumberTheory.Cyclotomic.Rat","initialProofState":"p : PNat\nK : Type u\ninstâœÂ² : Field K\nhp : Fact (Nat.Prime â†‘p)\ninstâœÂ¹ : CharZero K\ninstâœ : IsCyclotomicExtension (Singleton.singleton p) Rat K\nâŠ¢ Eq (NumberField.discr K) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HSub.hSub (â†‘p) 1) 2)) (HPow.hPow (â†‘â†‘p) (HSub.hSub (â†‘p) 2)))","decl":"/-- We compute the absolute discriminant of a `p`-th cyclotomic field where `p` is prime. -/\ntheorem absdiscr_prime [IsCyclotomicExtension {p} â„š K] :\n    haveI : NumberField K := IsCyclotomicExtension.numberField {p} â„š K\n    NumberField.discr K = (-1) ^ (((p : â„•) - 1) / 2) * p ^ ((p : â„•) - 2) := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} â„š K := by\n    rw [zero_add, pow_one]\n    infer_instance\n  rw [absdiscr_prime_pow_succ p 0 K]\n  simp only [Int.reduceNeg, pow_zero, one_mul, zero_add, mul_one, mul_eq_mul_left_iff, gt_iff_lt,\n    Nat.cast_pos, PNat.pos, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, ne_eq, false_and, or_false]\n  rfl\n\n"}
