{"name":"MeasureTheory.extend_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Œ± ‚Üí Prop\nm : (s : Œ±) ‚Üí P s ‚Üí ENNReal\ns : Œ±\nh : P s\n‚ä¢ Eq (MeasureTheory.extend m s) (m s h)","decl":"theorem extend_eq {s : Œ±} (h : P s) : extend m s = m s h := by simp [extend, h]\n\n"}
{"name":"MeasureTheory.extend_eq_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Œ± ‚Üí Prop\nm : (s : Œ±) ‚Üí P s ‚Üí ENNReal\ns : Œ±\nh : Not (P s)\n‚ä¢ Eq (MeasureTheory.extend m s) Top.top","decl":"theorem extend_eq_top {s : Œ±} (h : ¬¨P s) : extend m s = ‚àû := by simp [extend, h]\n\n"}
{"name":"MeasureTheory.smul_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Œ± ‚Üí Prop\nm : (s : Œ±) ‚Üí P s ‚Üí ENNReal\nR : Type u_2\ninst‚úù¬≥ : Zero R\ninst‚úù¬≤ : SMulWithZero R ENNReal\ninst‚úù¬π : IsScalarTower R ENNReal ENNReal\ninst‚úù : NoZeroSMulDivisors R ENNReal\nc : R\nhc : Ne c 0\n‚ä¢ Eq (HSMul.hSMul c (MeasureTheory.extend m)) (MeasureTheory.extend fun s h => HSMul.hSMul c (m s h))","decl":"theorem smul_extend {R} [Zero R] [SMulWithZero R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû]\n    [NoZeroSMulDivisors R ‚Ñù‚â•0‚àû] {c : R} (hc : c ‚â† 0) :\n    c ‚Ä¢ extend m = extend fun s h => c ‚Ä¢ m s h := by\n  classical\n  ext1 s\n  dsimp [extend]\n  by_cases h : P s\n  ¬∑ simp [h]\n  ¬∑ simp [h, ENNReal.smul_top, hc]\n\n"}
{"name":"MeasureTheory.le_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Œ± ‚Üí Prop\nm : (s : Œ±) ‚Üí P s ‚Üí ENNReal\ns : Œ±\nh : P s\n‚ä¢ LE.le (m s h) (MeasureTheory.extend m s)","decl":"theorem le_extend {s : Œ±} (h : P s) : m s h ‚â§ extend m s := by\n  simp only [extend, le_iInf_iff]\n  intro\n  rfl\n\n-- TODO: why this is a bad `congr` lemma?\n"}
{"name":"MeasureTheory.extend_congr","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Œ± ‚Üí Prop\nm : (s : Œ±) ‚Üí P s ‚Üí ENNReal\nŒ≤ : Type u_2\nPb : Œ≤ ‚Üí Prop\nmb : (s : Œ≤) ‚Üí Pb s ‚Üí ENNReal\nsa : Œ±\nsb : Œ≤\nhP : Iff (P sa) (Pb sb)\nhm : ‚àÄ (ha : P sa) (hb : Pb sb), Eq (m sa ha) (mb sb hb)\n‚ä¢ Eq (MeasureTheory.extend m sa) (MeasureTheory.extend mb sb)","decl":"theorem extend_congr {Œ≤ : Type*} {Pb : Œ≤ ‚Üí Prop} {mb : ‚àÄ s : Œ≤, Pb s ‚Üí ‚Ñù‚â•0‚àû} {sa : Œ±} {sb : Œ≤}\n    (hP : P sa ‚Üî Pb sb) (hm : ‚àÄ (ha : P sa) (hb : Pb sb), m sa ha = mb sb hb) :\n    extend m sa = extend mb sb :=\n  iInf_congr_Prop hP fun _h => hm _ _\n\n"}
{"name":"MeasureTheory.extend_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_2\nP : Œ± ‚Üí Prop\n‚ä¢ Eq (MeasureTheory.extend fun x x => Top.top) Top.top","decl":"@[simp]\ntheorem extend_top {Œ± : Type*} {P : Œ± ‚Üí Prop} : extend (fun _ _ => ‚àû : ‚àÄ s : Œ±, P s ‚Üí ‚Ñù‚â•0‚àû) = ‚ä§ :=\n  funext fun _ => iInf_eq_top.mpr fun _ => rfl\n\n"}
{"name":"MeasureTheory.extend_iUnion_nat","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nf : Nat ‚Üí Set Œ±\nhm : ‚àÄ (i : Nat), P (f i)\nmU : Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\n‚ä¢ Eq (MeasureTheory.extend m (Set.iUnion fun i => f i)) (tsum fun i => MeasureTheory.extend m (f i))","decl":"theorem extend_iUnion_nat {f : ‚Ñï ‚Üí Set Œ±} (hm : ‚àÄ i, P (f i))\n    (mU : m (‚ãÉ i, f i) (PU hm) = ‚àë' i, m (f i) (hm i)) :\n    extend m (‚ãÉ i, f i) = ‚àë' i, extend m (f i) :=\n  (extend_eq _ _).trans <|\n    mU.trans <| by\n      congr with i\n      rw [extend_eq]\n\n"}
{"name":"MeasureTheory.extend_empty","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\n‚ä¢ Eq (MeasureTheory.extend m EmptyCollection.emptyCollection) 0","decl":"include P0 m0 in\ntheorem extend_empty : extend m ‚àÖ = 0 :=\n  (extend_eq _ P0).trans m0\n\n"}
{"name":"MeasureTheory.extend_iUnion_le_tsum_nat'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns : Nat ‚Üí Set Œ±\n‚ä¢ LE.le (MeasureTheory.extend m (Set.iUnion fun i => s i)) (tsum fun i => MeasureTheory.extend m (s i))","decl":"include PU msU in\ntheorem extend_iUnion_le_tsum_nat' (s : ‚Ñï ‚Üí Set Œ±) :\n    extend m (‚ãÉ i, s i) ‚â§ ‚àë' i, extend m (s i) := by\n  by_cases h : ‚àÄ i, P (s i)\n  ¬∑ rw [extend_eq _ (PU h), congr_arg tsum _]\n    ¬∑ apply msU h\n    funext i\n    apply extend_eq _ (h i)\n  ¬∑ cases' not_forall.1 h with i hi\n    exact le_trans (le_iInf fun h => hi.elim h) (ENNReal.le_tsum i)\n\n"}
{"name":"MeasureTheory.extend_mono'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns‚ÇÅ s‚ÇÇ : Set Œ±\nh‚ÇÅ : P s‚ÇÅ\nhs : HasSubset.Subset s‚ÇÅ s‚ÇÇ\n‚ä¢ LE.le (MeasureTheory.extend m s‚ÇÅ) (MeasureTheory.extend m s‚ÇÇ)","decl":"include m_mono in\ntheorem extend_mono' ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (h‚ÇÅ : P s‚ÇÅ) (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) : extend m s‚ÇÅ ‚â§ extend m s‚ÇÇ := by\n  refine le_iInf ?_\n  intro h‚ÇÇ\n  rw [extend_eq m h‚ÇÅ]\n  exact m_mono h‚ÇÅ h‚ÇÇ hs\n\n"}
{"name":"MeasureTheory.extend_iUnion","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nŒ≤ : Type u_2\ninst‚úù : Countable Œ≤\nf : Œ≤ ‚Üí Set Œ±\nhd : Pairwise (Function.onFun Disjoint f)\nhm : ‚àÄ (i : Œ≤), P (f i)\n‚ä¢ Eq (MeasureTheory.extend m (Set.iUnion fun i => f i)) (tsum fun i => MeasureTheory.extend m (f i))","decl":"include P0 m0 PU mU in\ntheorem extend_iUnion {Œ≤} [Countable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (hd : Pairwise (Disjoint on f))\n    (hm : ‚àÄ i, P (f i)) : extend m (‚ãÉ i, f i) = ‚àë' i, extend m (f i) := by\n  cases nonempty_encodable Œ≤\n  rw [‚Üê Encodable.iUnion_decode‚ÇÇ, ‚Üê tsum_iUnion_decode‚ÇÇ]\n  ¬∑ exact\n      extend_iUnion_nat PU (fun n => Encodable.iUnion_decode‚ÇÇ_cases P0 hm)\n        (mU _ (Encodable.iUnion_decode‚ÇÇ_disjoint_on hd))\n  ¬∑ exact extend_empty P0 m0\n\n"}
{"name":"MeasureTheory.extend_union","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns‚ÇÅ s‚ÇÇ : Set Œ±\nhd : Disjoint s‚ÇÅ s‚ÇÇ\nh‚ÇÅ : P s‚ÇÅ\nh‚ÇÇ : P s‚ÇÇ\n‚ä¢ Eq (MeasureTheory.extend m (Union.union s‚ÇÅ s‚ÇÇ)) (HAdd.hAdd (MeasureTheory.extend m s‚ÇÅ) (MeasureTheory.extend m s‚ÇÇ))","decl":"include P0 m0 PU mU in\ntheorem extend_union {s‚ÇÅ s‚ÇÇ : Set Œ±} (hd : Disjoint s‚ÇÅ s‚ÇÇ) (h‚ÇÅ : P s‚ÇÅ) (h‚ÇÇ : P s‚ÇÇ) :\n    extend m (s‚ÇÅ ‚à™ s‚ÇÇ) = extend m s‚ÇÅ + extend m s‚ÇÇ := by\n  rw [union_eq_iUnion,\n    extend_iUnion P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (Bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©),\n    tsum_fintype]\n  simp\n\n"}
{"name":"MeasureTheory.le_inducedOuterMeasure","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nŒº : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Iff (LE.le Œº (MeasureTheory.inducedOuterMeasure m P0 m0)) (‚àÄ (s : Set Œ±) (hs : P s), LE.le (Œº s) (m s hs))","decl":"theorem le_inducedOuterMeasure {Œº : OuterMeasure Œ±} :\n    Œº ‚â§ inducedOuterMeasure m P0 m0 ‚Üî ‚àÄ (s) (hs : P s), Œº s ‚â§ m s hs :=\n  le_ofFunction.trans <| forall_congr' fun _s => le_iInf_iff\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_union_of_false_of_nonempty_inter","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\ns t : Set Œ±\nh : ‚àÄ (u : Set Œ±), (Inter.inter s u).Nonempty ‚Üí (Inter.inter t u).Nonempty ‚Üí Not (P u)\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) (Union.union s t)) (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) s) ((MeasureTheory.inducedOuterMeasure m P0 m0) t))","decl":"/-- If `P u` is `False` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`Œº (s ‚à™ t) = Œº s + Œº t`, where `Œº = inducedOuterMeasure m P0 m0`.\n\nE.g., if `Œ±` is an (e)metric space and `P u = diam u < r`, then this lemma implies that\n`Œº (s ‚à™ t) = Œº s + Œº t` on any two sets such that `r ‚â§ edist x y` for all `x ‚àà s` and `y ‚àà t`. -/\ntheorem inducedOuterMeasure_union_of_false_of_nonempty_inter {s t : Set Œ±}\n    (h : ‚àÄ u, (s ‚à© u).Nonempty ‚Üí (t ‚à© u).Nonempty ‚Üí ¬¨P u) :\n    inducedOuterMeasure m P0 m0 (s ‚à™ t) =\n      inducedOuterMeasure m P0 m0 s + inducedOuterMeasure m P0 m0 t :=\n  ofFunction_union_of_top_of_nonempty_inter fun u hsu htu => @iInf_of_empty _ _ _ ‚ü®h u hsu htu‚ü© _\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_extend'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns : Set Œ±\nhs : P s\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (MeasureTheory.extend m s)","decl":"theorem inducedOuterMeasure_eq_extend' {s : Set Œ±} (hs : P s) :\n    inducedOuterMeasure m P0 m0 s = extend m s :=\n  ofFunction_eq s (fun _t => extend_mono' m_mono hs) (extend_iUnion_le_tsum_nat' PU msU)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns : Set Œ±\nhs : P s\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (m s hs)","decl":"theorem inducedOuterMeasure_eq' {s : Set Œ±} (hs : P s) : inducedOuterMeasure m P0 m0 s = m s hs :=\n  (inducedOuterMeasure_eq_extend' PU msU m_mono hs).trans <| extend_eq _ _\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns : Set Œ±\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (iInf fun t => iInf fun ht => iInf fun x => m t ht)","decl":"theorem inducedOuterMeasure_eq_iInf (s : Set Œ±) :\n    inducedOuterMeasure m P0 m0 s = ‚®Ö (t : Set Œ±) (ht : P t) (_ : s ‚äÜ t), m t ht := by\n  apply le_antisymm\n  ¬∑ simp only [le_iInf_iff]\n    intro t ht hs\n    refine le_trans (measure_mono hs) ?_\n    exact le_of_eq (inducedOuterMeasure_eq' _ msU m_mono _)\n  ¬∑ refine le_iInf ?_\n    intro f\n    refine le_iInf ?_\n    intro hf\n    refine le_trans ?_ (extend_iUnion_le_tsum_nat' _ msU _)\n    refine le_iInf ?_\n    intro h2f\n    exact iInf_le_of_le _ (iInf_le_of_le h2f <| iInf_le _ hf)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_preimage","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\nf : Equiv Œ± Œ±\nPm : ‚àÄ (s : Set Œ±), Iff (P (Set.preimage (‚áëf) s)) (P s)\nmm : ‚àÄ (s : Set Œ±) (hs : P s), Eq (m (Set.preimage (‚áëf) s) ‚ãØ) (m s hs)\nA : Set Œ±\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) (Set.preimage (‚áëf) A)) ((MeasureTheory.inducedOuterMeasure m P0 m0) A)","decl":"theorem inducedOuterMeasure_preimage (f : Œ± ‚âÉ Œ±) (Pm : ‚àÄ s : Set Œ±, P (f ‚Åª¬π' s) ‚Üî P s)\n    (mm : ‚àÄ (s : Set Œ±) (hs : P s), m (f ‚Åª¬π' s) ((Pm _).mpr hs) = m s hs) {A : Set Œ±} :\n    inducedOuterMeasure m P0 m0 (f ‚Åª¬π' A) = inducedOuterMeasure m P0 m0 A := by\n    rw [inducedOuterMeasure_eq_iInf _ msU m_mono, inducedOuterMeasure_eq_iInf _ msU m_mono]; symm\n    refine f.injective.preimage_surjective.iInf_congr (preimage f) fun s => ?_\n    refine iInf_congr_Prop (Pm s) ?_; intro hs\n    refine iInf_congr_Prop f.surjective.preimage_subset_preimage_iff ?_\n    intro _; exact mm s hs\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_exists_set","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns : Set Œ±\nhs : Ne ((MeasureTheory.inducedOuterMeasure m P0 m0) s) Top.top\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun t => And (P t) (And (HasSubset.Subset s t) (LE.le ((MeasureTheory.inducedOuterMeasure m P0 m0) t) (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) s) Œµ)))","decl":"theorem inducedOuterMeasure_exists_set {s : Set Œ±} (hs : inducedOuterMeasure m P0 m0 s ‚â† ‚àû)\n    {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ t : Set Œ±,\n      P t ‚àß s ‚äÜ t ‚àß inducedOuterMeasure m P0 m0 t ‚â§ inducedOuterMeasure m P0 m0 s + Œµ := by\n  have h := ENNReal.lt_add_right hs hŒµ\n  conv at h =>\n    lhs\n    rw [inducedOuterMeasure_eq_iInf _ msU m_mono]\n  simp only [iInf_lt_iff] at h\n  rcases h with ‚ü®t, h1t, h2t, h3t‚ü©\n  exact\n    ‚ü®t, h1t, h2t, le_trans (le_of_eq <| inducedOuterMeasure_eq' _ msU m_mono h1t) (le_of_lt h3t)‚ü©\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\nP : Set Œ± ‚Üí Prop\nm : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : Nat), P (f i)) ‚Üí P (Set.iUnion fun i => f i)\nmsU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\nm_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), HasSubset.Subset s‚ÇÅ s‚ÇÇ ‚Üí LE.le (m s‚ÇÅ hs‚ÇÅ) (m s‚ÇÇ hs‚ÇÇ)\ns : Set Œ±\n‚ä¢ Iff (MeasurableSet s) (‚àÄ (t : Set Œ±), P t ‚Üí LE.le (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) (Inter.inter t s)) ((MeasureTheory.inducedOuterMeasure m P0 m0) (SDiff.sdiff t s))) ((MeasureTheory.inducedOuterMeasure m P0 m0) t))","decl":"/-- To test whether `s` is Carath√©odory-measurable we only need to check the sets `t` for which\n  `P t` holds. See `ofFunction_caratheodory` for another way to show the Carath√©odory-measurability\n  of `s`.\n-/\ntheorem inducedOuterMeasure_caratheodory (s : Set Œ±) :\n    MeasurableSet[(inducedOuterMeasure m P0 m0).caratheodory] s ‚Üî\n      ‚àÄ t : Set Œ±,\n        P t ‚Üí\n          inducedOuterMeasure m P0 m0 (t ‚à© s) + inducedOuterMeasure m P0 m0 (t \\ s) ‚â§\n            inducedOuterMeasure m P0 m0 t := by\n  rw [isCaratheodory_iff_le]\n  constructor\n  ¬∑ intro h t _ht\n    exact h t\n  ¬∑ intro h u\n    conv_rhs => rw [inducedOuterMeasure_eq_iInf _ msU m_mono]\n    refine le_iInf ?_\n    intro t\n    refine le_iInf ?_\n    intro ht\n    refine le_iInf ?_\n    intro h2t\n    refine le_trans ?_ ((h t ht).trans_eq <| inducedOuterMeasure_eq' _ msU m_mono ht)\n    gcongr\n\n"}
{"name":"MeasureTheory.extend_mono","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : (s : Set Œ±) ‚Üí MeasurableSet s ‚Üí ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ‚ãØ) 0\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns‚ÇÅ s‚ÇÇ : Set Œ±\nh‚ÇÅ : MeasurableSet s‚ÇÅ\nhs : HasSubset.Subset s‚ÇÅ s‚ÇÇ\n‚ä¢ LE.le (MeasureTheory.extend m s‚ÇÅ) (MeasureTheory.extend m s‚ÇÇ)","decl":"theorem extend_mono {s‚ÇÅ s‚ÇÇ : Set Œ±} (h‚ÇÅ : MeasurableSet s‚ÇÅ) (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) :\n    extend m s‚ÇÅ ‚â§ extend m s‚ÇÇ := by\n  refine le_iInf ?_; intro h‚ÇÇ\n  have :=\n    extend_union MeasurableSet.empty m0 MeasurableSet.iUnion mU disjoint_sdiff_self_right h‚ÇÅ\n      (h‚ÇÇ.diff h‚ÇÅ)\n  rw [union_diff_cancel hs] at this\n  rw [‚Üê extend_eq m]\n  exact le_iff_exists_add.2 ‚ü®_, this‚ü©\n\n"}
{"name":"MeasureTheory.extend_iUnion_le_tsum_nat","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : (s : Set Œ±) ‚Üí MeasurableSet s ‚Üí ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ‚ãØ) 0\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns : Nat ‚Üí Set Œ±\n‚ä¢ LE.le (MeasureTheory.extend m (Set.iUnion fun i => s i)) (tsum fun i => MeasureTheory.extend m (s i))","decl":"theorem extend_iUnion_le_tsum_nat : ‚àÄ s : ‚Ñï ‚Üí Set Œ±,\n    extend m (‚ãÉ i, s i) ‚â§ ‚àë' i, extend m (s i) := by\n  refine extend_iUnion_le_tsum_nat' MeasurableSet.iUnion ?_; intro f h\n  simp (config := { singlePass := true }) only [iUnion_disjointed.symm]\n  rw [mU (MeasurableSet.disjointed h) (disjoint_disjointed _)]\n  refine ENNReal.tsum_le_tsum fun i => ?_\n  rw [‚Üê extend_eq m, ‚Üê extend_eq m]\n  exact extend_mono m0 mU (MeasurableSet.disjointed h _) (disjointed_le f _)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : (s : Set Œ±) ‚Üí MeasurableSet s ‚Üí ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ‚ãØ) 0\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m ‚ãØ m0) s) (MeasureTheory.extend m s)","decl":"theorem inducedOuterMeasure_eq_extend {s : Set Œ±} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = extend m s :=\n  ofFunction_eq s (fun _t => extend_mono m0 mU hs) (extend_iUnion_le_tsum_nat m0 mU)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : (s : Set Œ±) ‚Üí MeasurableSet s ‚Üí ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ‚ãØ) 0\nmU : ‚àÄ ‚¶Éf : Nat ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) ‚Üí Eq (m (Set.iUnion fun i => f i) ‚ãØ) (tsum fun i => m (f i) ‚ãØ)\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq ((MeasureTheory.inducedOuterMeasure m ‚ãØ m0) s) (m s hs)","decl":"theorem inducedOuterMeasure_eq {s : Set Œ±} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = m s hs :=\n  (inducedOuterMeasure_eq_extend m0 mU hs).trans <| extend_eq _ _\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Iff (LE.le m‚ÇÅ m‚ÇÇ.trim) (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (m‚ÇÅ s) (m‚ÇÇ s))","decl":"theorem le_trim_iff {m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±} :\n    m‚ÇÅ ‚â§ m‚ÇÇ.trim ‚Üî ‚àÄ s, MeasurableSet s ‚Üí m‚ÇÅ s ‚â§ m‚ÇÇ s :=\n  le_inducedOuterMeasure\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\n‚ä¢ LE.le m m.trim","decl":"theorem le_trim : m ‚â§ m.trim := le_trim_iff.2 fun _ _ ‚Ü¶ le_rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq (m.trim s) (m s)","decl":"@[simp] -- Porting note: added `simp`\ntheorem trim_eq {s : Set Œ±} (hs : MeasurableSet s) : m.trim s = m s :=\n  inducedOuterMeasure_eq' MeasurableSet.iUnion (fun f _hf => measure_iUnion_le f)\n    (fun _ _ _ _ h => measure_mono h) hs\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_congr","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\nH : ‚àÄ {s : Set Œ±}, MeasurableSet s ‚Üí Eq (m‚ÇÅ s) (m‚ÇÇ s)\n‚ä¢ Eq m‚ÇÅ.trim m‚ÇÇ.trim","decl":"theorem trim_congr {m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±} (H : ‚àÄ {s : Set Œ±}, MeasurableSet s ‚Üí m‚ÇÅ s = m‚ÇÇ s) :\n    m‚ÇÅ.trim = m‚ÇÇ.trim := by\n  simp +contextual only [trim, H]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_mono","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\n‚ä¢ Monotone MeasureTheory.OuterMeasure.trim","decl":"@[mono]\ntheorem trim_mono : Monotone (trim : OuterMeasure Œ± ‚Üí OuterMeasure Œ±) := fun _m‚ÇÅ _m‚ÇÇ H _s =>\n  iInf‚ÇÇ_mono fun _f _hs => ENNReal.tsum_le_tsum fun _b => iInf_mono fun _hf => H _\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_anti_measurableSpace","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_2\nm : MeasureTheory.OuterMeasure Œ±\nm0 m1 : MeasurableSpace Œ±\nh : LE.le m0 m1\n‚ä¢ LE.le m.trim m.trim","decl":"/-- `OuterMeasure.trim` is antitone in the œÉ-algebra. -/\ntheorem trim_anti_measurableSpace {Œ±} (m : OuterMeasure Œ±) {m0 m1 : MeasurableSpace Œ±}\n    (h : m0 ‚â§ m1) : @trim _ m1 m ‚â§ @trim _ m0 m := by\n  simp only [le_trim_iff]\n  intro s hs\n  rw [trim_eq _ (h s hs)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_le_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Iff (LE.le m‚ÇÅ.trim m‚ÇÇ.trim) (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (m‚ÇÅ s) (m‚ÇÇ s))","decl":"theorem trim_le_trim_iff {m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±} :\n    m‚ÇÅ.trim ‚â§ m‚ÇÇ.trim ‚Üî ‚àÄ s, MeasurableSet s ‚Üí m‚ÇÅ s ‚â§ m‚ÇÇ s :=\n  le_trim_iff.trans <| forall‚ÇÇ_congr fun s hs => by rw [trim_eq _ hs]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Iff (Eq m‚ÇÅ.trim m‚ÇÇ.trim) (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí Eq (m‚ÇÅ s) (m‚ÇÇ s))","decl":"theorem trim_eq_trim_iff {m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±} :\n    m‚ÇÅ.trim = m‚ÇÇ.trim ‚Üî ‚àÄ s, MeasurableSet s ‚Üí m‚ÇÅ s = m‚ÇÇ s := by\n  simp only [le_antisymm_iff, trim_le_trim_iff, forall_and]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\n‚ä¢ Eq (m.trim s) (iInf fun t => iInf fun x => iInf fun x => m t)","decl":"theorem trim_eq_iInf (s : Set Œ±) : m.trim s = ‚®Ö (t) (_ : s ‚äÜ t) (_ : MeasurableSet t), m t := by\n  simp (config := { singlePass := true }) only [iInf_comm]\n  exact\n    inducedOuterMeasure_eq_iInf MeasurableSet.iUnion (fun f _ => measure_iUnion_le f)\n      (fun _ _ _ _ h => measure_mono h) s\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_iInf'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\n‚ä¢ Eq (m.trim s) (iInf fun t => m ‚Üët)","decl":"theorem trim_eq_iInf' (s : Set Œ±) : m.trim s = ‚®Ö t : { t // s ‚äÜ t ‚àß MeasurableSet t }, m t := by\n  simp [iInf_subtype, iInf_and, trim_eq_iInf]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Eq m.trim.trim m.trim","decl":"theorem trim_trim (m : OuterMeasure Œ±) : m.trim.trim = m.trim :=\n  trim_eq_trim_iff.2 fun _s => m.trim_eq\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\n‚ä¢ Eq Top.top.trim Top.top","decl":"@[simp]\ntheorem trim_top : (‚ä§ : OuterMeasure Œ±).trim = ‚ä§ :=\n  top_unique <| le_trim _\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\n‚ä¢ Eq (MeasureTheory.OuterMeasure.trim 0) 0","decl":"@[simp]\ntheorem trim_zero : (0 : OuterMeasure Œ±).trim = 0 :=\n  ext fun s =>\n    le_antisymm\n      ((measure_mono (subset_univ s)).trans_eq <| trim_eq _ MeasurableSet.univ)\n      (zero_le _)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_sum_ge","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒπ : Type u_2\nm : Œπ ‚Üí MeasureTheory.OuterMeasure Œ±\n‚ä¢ LE.le (MeasureTheory.OuterMeasure.sum fun i => (m i).trim) (MeasureTheory.OuterMeasure.sum m).trim","decl":"theorem trim_sum_ge {Œπ} (m : Œπ ‚Üí OuterMeasure Œ±) : (sum fun i => (m i).trim) ‚â§ (sum m).trim :=\n  fun s => by\n  simp only [sum_apply, trim_eq_iInf, le_iInf_iff]\n  exact fun t st ht =>\n    ENNReal.tsum_le_tsum fun i => iInf_le_of_le t <| iInf_le_of_le st <| iInf_le _ ht\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_eq_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\n‚ä¢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (m t) (m.trim s)))","decl":"theorem exists_measurable_superset_eq_trim (m : OuterMeasure Œ±) (s : Set Œ±) :\n    ‚àÉ t, s ‚äÜ t ‚àß MeasurableSet t ‚àß m t = m.trim s := by\n  simp only [trim_eq_iInf]; set ms := ‚®Ö (t : Set Œ±) (_ : s ‚äÜ t) (_ : MeasurableSet t), m t\n  by_cases hs : ms = ‚àû\n  ¬∑ simp only [hs]\n    simp only [iInf_eq_top, ms] at hs\n    exact ‚ü®univ, subset_univ s, MeasurableSet.univ, hs _ (subset_univ s) MeasurableSet.univ‚ü©\n  ¬∑ have : ‚àÄ r > ms, ‚àÉ t, s ‚äÜ t ‚àß MeasurableSet t ‚àß m t < r := by\n      intro r hs\n      have : ‚àÉt, MeasurableSet t ‚àß s ‚äÜ t ‚àß m t < r := by simpa [ms, iInf_lt_iff] using hs\n      rcases this with ‚ü®t, hmt, hin, hlt‚ü©\n      exists t\n    have : ‚àÄ n : ‚Ñï, ‚àÉ t, s ‚äÜ t ‚àß MeasurableSet t ‚àß m t < ms + (n : ‚Ñù‚â•0‚àû)‚Åª¬π := by\n      intro n\n      refine this _ (ENNReal.lt_add_right hs ?_)\n      simp\n    choose t hsub hm hm' using this\n    refine ‚ü®‚ãÇ n, t n, subset_iInter hsub, MeasurableSet.iInter hm, ?_‚ü©\n    have : Tendsto (fun n : ‚Ñï => ms + (n : ‚Ñù‚â•0‚àû)‚Åª¬π) atTop (ùìù (ms + 0)) :=\n      tendsto_const_nhds.add ENNReal.tendsto_inv_nat_nhds_zero\n    rw [add_zero] at this\n    refine le_antisymm (ge_of_tendsto' this fun n => ?_) ?_\n    ¬∑ exact le_trans (measure_mono <| iInter_subset t n) (hm' n).le\n    ¬∑ refine iInf_le_of_le (‚ãÇ n, t n) ?_\n      refine iInf_le_of_le (subset_iInter hsub) ?_\n      exact iInf_le _ (MeasurableSet.iInter hm)\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_of_trim_eq_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\nh : Eq (m.trim s) 0\n‚ä¢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (m t) 0))","decl":"theorem exists_measurable_superset_of_trim_eq_zero {m : OuterMeasure Œ±} {s : Set Œ±}\n    (h : m.trim s = 0) : ‚àÉ t, s ‚äÜ t ‚àß MeasurableSet t ‚àß m t = 0 := by\n  rcases exists_measurable_superset_eq_trim m s with ‚ü®t, hst, ht, hm‚ü©\n  exact ‚ü®t, hst, ht, h ‚ñ∏ hm‚ü©\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_forall_eq_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\nŒπ : Sort u_2\ninst‚úù : Countable Œπ\nŒº : Œπ ‚Üí MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\n‚ä¢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (‚àÄ (i : Œπ), Eq ((Œº i) t) ((Œº i).trim s)))","decl":"/-- If `Œº i` is a countable family of outer measures, then for every set `s` there exists\na measurable set `t ‚äá s` such that `Œº i t = (Œº i).trim s` for all `i`. -/\ntheorem exists_measurable_superset_forall_eq_trim {Œπ} [Countable Œπ] (Œº : Œπ ‚Üí OuterMeasure Œ±)\n    (s : Set Œ±) : ‚àÉ t, s ‚äÜ t ‚àß MeasurableSet t ‚àß ‚àÄ i, Œº i t = (Œº i).trim s := by\n  choose t hst ht hŒºt using fun i => (Œº i).exists_measurable_superset_eq_trim s\n  replace hst := subset_iInter hst\n  replace ht := MeasurableSet.iInter ht\n  refine ‚ü®‚ãÇ i, t i, hst, ht, fun i => le_antisymm ?_ ?_‚ü©\n  exacts [hŒºt i ‚ñ∏ (Œº i).mono (iInter_subset _ _), (measure_mono hst).trans_eq ((Œº i).trim_eq ht)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_binop","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : MeasureTheory.OuterMeasure Œ±\nop : ENNReal ‚Üí ENNReal ‚Üí ENNReal\nh : ‚àÄ (s : Set Œ±), Eq (m‚ÇÅ s) (op (m‚ÇÇ s) (m‚ÇÉ s))\ns : Set Œ±\n‚ä¢ Eq (m‚ÇÅ.trim s) (op (m‚ÇÇ.trim s) (m‚ÇÉ.trim s))","decl":"/-- If `m‚ÇÅ s = op (m‚ÇÇ s) (m‚ÇÉ s)` for all `s`, then the same is true for `m‚ÇÅ.trim`, `m‚ÇÇ.trim`,\nand `m‚ÇÉ s`. -/\ntheorem trim_binop {m‚ÇÅ m‚ÇÇ m‚ÇÉ : OuterMeasure Œ±} {op : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû}\n    (h : ‚àÄ s, m‚ÇÅ s = op (m‚ÇÇ s) (m‚ÇÉ s)) (s : Set Œ±) : m‚ÇÅ.trim s = op (m‚ÇÇ.trim s) (m‚ÇÉ.trim s) := by\n  rcases exists_measurable_superset_forall_eq_trim ![m‚ÇÅ, m‚ÇÇ, m‚ÇÉ] s with ‚ü®t, _hst, _ht, htm‚ü©\n  simp only [Fin.forall_iff_succ, Matrix.cons_val_zero, Matrix.cons_val_succ] at htm\n  rw [‚Üê htm.1, ‚Üê htm.2.1, ‚Üê htm.2.2.1, h]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_op","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\nop : ENNReal ‚Üí ENNReal\nh : ‚àÄ (s : Set Œ±), Eq (m‚ÇÅ s) (op (m‚ÇÇ s))\ns : Set Œ±\n‚ä¢ Eq (m‚ÇÅ.trim s) (op (m‚ÇÇ.trim s))","decl":"/-- If `m‚ÇÅ s = op (m‚ÇÇ s)` for all `s`, then the same is true for `m‚ÇÅ.trim` and `m‚ÇÇ.trim`. -/\ntheorem trim_op {m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±} {op : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ s, m‚ÇÅ s = op (m‚ÇÇ s))\n    (s : Set Œ±) : m‚ÇÅ.trim s = op (m‚ÇÇ.trim s) :=\n  @trim_binop Œ± _ m‚ÇÅ m‚ÇÇ 0 (fun a _b => op a) h s\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_add","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Eq (HAdd.hAdd m‚ÇÅ m‚ÇÇ).trim (HAdd.hAdd m‚ÇÅ.trim m‚ÇÇ.trim)","decl":"/-- `trim` is additive. -/\ntheorem trim_add (m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±) : (m‚ÇÅ + m‚ÇÇ).trim = m‚ÇÅ.trim + m‚ÇÇ.trim :=\n  ext <| trim_binop (add_apply m‚ÇÅ m‚ÇÇ)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_smul","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ±\nR : Type u_2\ninst‚úù¬π : SMul R ENNReal\ninst‚úù : IsScalarTower R ENNReal ENNReal\nc : R\nm : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Eq (HSMul.hSMul c m).trim (HSMul.hSMul c m.trim)","decl":"/-- `trim` respects scalar multiplication. -/\ntheorem trim_smul {R : Type*} [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (c : R)\n    (m : OuterMeasure Œ±) : (c ‚Ä¢ m).trim = c ‚Ä¢ m.trim :=\n  ext <| trim_op (smul_apply c m)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_sup","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nm‚ÇÅ m‚ÇÇ : MeasureTheory.OuterMeasure Œ±\n‚ä¢ Eq (Max.max m‚ÇÅ m‚ÇÇ).trim (Max.max m‚ÇÅ.trim m‚ÇÇ.trim)","decl":"/-- `trim` sends the supremum of two outer measures to the supremum of the trimmed measures. -/\ntheorem trim_sup (m‚ÇÅ m‚ÇÇ : OuterMeasure Œ±) : (m‚ÇÅ ‚äî m‚ÇÇ).trim = m‚ÇÅ.trim ‚äî m‚ÇÇ.trim :=\n  ext fun s => (trim_binop (sup_apply m‚ÇÅ m‚ÇÇ) s).trans (sup_apply _ _ _).symm\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_iSup","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\nŒπ : Sort u_2\ninst‚úù : Countable Œπ\nŒº : Œπ ‚Üí MeasureTheory.OuterMeasure Œ±\n‚ä¢ Eq (iSup fun i => Œº i).trim (iSup fun i => (Œº i).trim)","decl":"/-- `trim` sends the supremum of a countable family of outer measures to the supremum\nof the trimmed measures. -/\ntheorem trim_iSup {Œπ} [Countable Œπ] (Œº : Œπ ‚Üí OuterMeasure Œ±) :\n    trim (‚®Ü i, Œº i) = ‚®Ü i, trim (Œº i) := by\n  simp_rw [‚Üê @iSup_plift_down _ Œπ]\n  ext1 s\n  obtain ‚ü®t, _, _, hŒºt‚ü© :=\n    exists_measurable_superset_forall_eq_trim\n      (Option.elim' (‚®Ü i, Œº (PLift.down i)) (Œº ‚àò PLift.down)) s\n  simp only [Option.forall, Option.elim'] at hŒºt\n  simp only [iSup_apply, ‚Üê hŒºt.1]\n  exact iSup_congr hŒºt.2\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.OuterMeasure Œ±\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq ((MeasureTheory.OuterMeasure.restrict s) Œº).trim ((MeasureTheory.OuterMeasure.restrict s) Œº.trim)","decl":"/-- The trimmed property of a measure Œº states that `Œº.toOuterMeasure.trim = Œº.toOuterMeasure`.\nThis theorem shows that a restricted trimmed outer measure is a trimmed outer measure. -/\ntheorem restrict_trim {Œº : OuterMeasure Œ±} {s : Set Œ±} (hs : MeasurableSet s) :\n    (restrict s Œº).trim = restrict s Œº.trim := by\n  refine le_antisymm (fun t => ?_) (le_trim_iff.2 fun t ht => ?_)\n  ¬∑ rw [restrict_apply]\n    rcases Œº.exists_measurable_superset_eq_trim (t ‚à© s) with ‚ü®t', htt', ht', hŒºt'‚ü©\n    rw [‚Üê hŒºt']\n    rw [inter_subset] at htt'\n    refine (measure_mono htt').trans ?_\n    rw [trim_eq _ (hs.compl.union ht'), restrict_apply, union_inter_distrib_right, compl_inter_self,\n      Set.empty_union]\n    exact measure_mono inter_subset_left\n  ¬∑ rw [restrict_apply, trim_eq _ (ht.inter hs), restrict_apply]\n\n"}
