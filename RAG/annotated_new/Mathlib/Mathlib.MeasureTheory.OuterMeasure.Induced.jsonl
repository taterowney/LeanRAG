{"name":"MeasureTheory.extend_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : α → Prop\nm : (s : α) → P s → ENNReal\ns : α\nh : P s\n⊢ Eq (MeasureTheory.extend m s) (m s h)","decl":"theorem extend_eq {s : α} (h : P s) : extend m s = m s h := by simp [extend, h]\n\n"}
{"name":"MeasureTheory.extend_eq_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : α → Prop\nm : (s : α) → P s → ENNReal\ns : α\nh : Not (P s)\n⊢ Eq (MeasureTheory.extend m s) Top.top","decl":"theorem extend_eq_top {s : α} (h : ¬P s) : extend m s = ∞ := by simp [extend, h]\n\n"}
{"name":"MeasureTheory.smul_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : α → Prop\nm : (s : α) → P s → ENNReal\nR : Type u_2\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\nc : R\nhc : Ne c 0\n⊢ Eq (HSMul.hSMul c (MeasureTheory.extend m)) (MeasureTheory.extend fun s h => HSMul.hSMul c (m s h))","decl":"theorem smul_extend {R} [Zero R] [SMulWithZero R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    [NoZeroSMulDivisors R ℝ≥0∞] {c : R} (hc : c ≠ 0) :\n    c • extend m = extend fun s h => c • m s h := by\n  classical\n  ext1 s\n  dsimp [extend]\n  by_cases h : P s\n  · simp [h]\n  · simp [h, ENNReal.smul_top, hc]\n\n"}
{"name":"MeasureTheory.le_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : α → Prop\nm : (s : α) → P s → ENNReal\ns : α\nh : P s\n⊢ LE.le (m s h) (MeasureTheory.extend m s)","decl":"theorem le_extend {s : α} (h : P s) : m s h ≤ extend m s := by\n  simp only [extend, le_iInf_iff]\n  intro\n  rfl\n\n-- TODO: why this is a bad `congr` lemma?\n"}
{"name":"MeasureTheory.extend_congr","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : α → Prop\nm : (s : α) → P s → ENNReal\nβ : Type u_2\nPb : β → Prop\nmb : (s : β) → Pb s → ENNReal\nsa : α\nsb : β\nhP : Iff (P sa) (Pb sb)\nhm : ∀ (ha : P sa) (hb : Pb sb), Eq (m sa ha) (mb sb hb)\n⊢ Eq (MeasureTheory.extend m sa) (MeasureTheory.extend mb sb)","decl":"theorem extend_congr {β : Type*} {Pb : β → Prop} {mb : ∀ s : β, Pb s → ℝ≥0∞} {sa : α} {sb : β}\n    (hP : P sa ↔ Pb sb) (hm : ∀ (ha : P sa) (hb : Pb sb), m sa ha = mb sb hb) :\n    extend m sa = extend mb sb :=\n  iInf_congr_Prop hP fun _h => hm _ _\n\n"}
{"name":"MeasureTheory.extend_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_2\nP : α → Prop\n⊢ Eq (MeasureTheory.extend fun x x => Top.top) Top.top","decl":"@[simp]\ntheorem extend_top {α : Type*} {P : α → Prop} : extend (fun _ _ => ∞ : ∀ s : α, P s → ℝ≥0∞) = ⊤ :=\n  funext fun _ => iInf_eq_top.mpr fun _ => rfl\n\n"}
{"name":"MeasureTheory.extend_iUnion_nat","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nf : Nat → Set α\nhm : ∀ (i : Nat), P (f i)\nmU : Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\n⊢ Eq (MeasureTheory.extend m (Set.iUnion fun i => f i)) (tsum fun i => MeasureTheory.extend m (f i))","decl":"theorem extend_iUnion_nat {f : ℕ → Set α} (hm : ∀ i, P (f i))\n    (mU : m (⋃ i, f i) (PU hm) = ∑' i, m (f i) (hm i)) :\n    extend m (⋃ i, f i) = ∑' i, extend m (f i) :=\n  (extend_eq _ _).trans <|\n    mU.trans <| by\n      congr with i\n      rw [extend_eq]\n\n"}
{"name":"MeasureTheory.extend_empty","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\n⊢ Eq (MeasureTheory.extend m EmptyCollection.emptyCollection) 0","decl":"include P0 m0 in\ntheorem extend_empty : extend m ∅ = 0 :=\n  (extend_eq _ P0).trans m0\n\n"}
{"name":"MeasureTheory.extend_iUnion_le_tsum_nat'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns : Nat → Set α\n⊢ LE.le (MeasureTheory.extend m (Set.iUnion fun i => s i)) (tsum fun i => MeasureTheory.extend m (s i))","decl":"include PU msU in\ntheorem extend_iUnion_le_tsum_nat' (s : ℕ → Set α) :\n    extend m (⋃ i, s i) ≤ ∑' i, extend m (s i) := by\n  by_cases h : ∀ i, P (s i)\n  · rw [extend_eq _ (PU h), congr_arg tsum _]\n    · apply msU h\n    funext i\n    apply extend_eq _ (h i)\n  · cases' not_forall.1 h with i hi\n    exact le_trans (le_iInf fun h => hi.elim h) (ENNReal.le_tsum i)\n\n"}
{"name":"MeasureTheory.extend_mono'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns₁ s₂ : Set α\nh₁ : P s₁\nhs : HasSubset.Subset s₁ s₂\n⊢ LE.le (MeasureTheory.extend m s₁) (MeasureTheory.extend m s₂)","decl":"include m_mono in\ntheorem extend_mono' ⦃s₁ s₂ : Set α⦄ (h₁ : P s₁) (hs : s₁ ⊆ s₂) : extend m s₁ ≤ extend m s₂ := by\n  refine le_iInf ?_\n  intro h₂\n  rw [extend_eq m h₁]\n  exact m_mono h₁ h₂ hs\n\n"}
{"name":"MeasureTheory.extend_iUnion","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nβ : Type u_2\ninst✝ : Countable β\nf : β → Set α\nhd : Pairwise (Function.onFun Disjoint f)\nhm : ∀ (i : β), P (f i)\n⊢ Eq (MeasureTheory.extend m (Set.iUnion fun i => f i)) (tsum fun i => MeasureTheory.extend m (f i))","decl":"include P0 m0 PU mU in\ntheorem extend_iUnion {β} [Countable β] {f : β → Set α} (hd : Pairwise (Disjoint on f))\n    (hm : ∀ i, P (f i)) : extend m (⋃ i, f i) = ∑' i, extend m (f i) := by\n  cases nonempty_encodable β\n  rw [← Encodable.iUnion_decode₂, ← tsum_iUnion_decode₂]\n  · exact\n      extend_iUnion_nat PU (fun n => Encodable.iUnion_decode₂_cases P0 hm)\n        (mU _ (Encodable.iUnion_decode₂_disjoint_on hd))\n  · exact extend_empty P0 m0\n\n"}
{"name":"MeasureTheory.extend_union","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns₁ s₂ : Set α\nhd : Disjoint s₁ s₂\nh₁ : P s₁\nh₂ : P s₂\n⊢ Eq (MeasureTheory.extend m (Union.union s₁ s₂)) (HAdd.hAdd (MeasureTheory.extend m s₁) (MeasureTheory.extend m s₂))","decl":"include P0 m0 PU mU in\ntheorem extend_union {s₁ s₂ : Set α} (hd : Disjoint s₁ s₂) (h₁ : P s₁) (h₂ : P s₂) :\n    extend m (s₁ ∪ s₂) = extend m s₁ + extend m s₂ := by\n  rw [union_eq_iUnion,\n    extend_iUnion P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (Bool.forall_bool.2 ⟨h₂, h₁⟩),\n    tsum_fintype]\n  simp\n\n"}
{"name":"MeasureTheory.le_inducedOuterMeasure","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nμ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le μ (MeasureTheory.inducedOuterMeasure m P0 m0)) (∀ (s : Set α) (hs : P s), LE.le (μ s) (m s hs))","decl":"theorem le_inducedOuterMeasure {μ : OuterMeasure α} :\n    μ ≤ inducedOuterMeasure m P0 m0 ↔ ∀ (s) (hs : P s), μ s ≤ m s hs :=\n  le_ofFunction.trans <| forall_congr' fun _s => le_iInf_iff\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_union_of_false_of_nonempty_inter","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\ns t : Set α\nh : ∀ (u : Set α), (Inter.inter s u).Nonempty → (Inter.inter t u).Nonempty → Not (P u)\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) (Union.union s t)) (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) s) ((MeasureTheory.inducedOuterMeasure m P0 m0) t))","decl":"/-- If `P u` is `False` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = inducedOuterMeasure m P0 m0`.\n\nE.g., if `α` is an (e)metric space and `P u = diam u < r`, then this lemma implies that\n`μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s` and `y ∈ t`. -/\ntheorem inducedOuterMeasure_union_of_false_of_nonempty_inter {s t : Set α}\n    (h : ∀ u, (s ∩ u).Nonempty → (t ∩ u).Nonempty → ¬P u) :\n    inducedOuterMeasure m P0 m0 (s ∪ t) =\n      inducedOuterMeasure m P0 m0 s + inducedOuterMeasure m P0 m0 t :=\n  ofFunction_union_of_top_of_nonempty_inter fun u hsu htu => @iInf_of_empty _ _ _ ⟨h u hsu htu⟩ _\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_extend'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns : Set α\nhs : P s\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (MeasureTheory.extend m s)","decl":"theorem inducedOuterMeasure_eq_extend' {s : Set α} (hs : P s) :\n    inducedOuterMeasure m P0 m0 s = extend m s :=\n  ofFunction_eq s (fun _t => extend_mono' m_mono hs) (extend_iUnion_le_tsum_nat' PU msU)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns : Set α\nhs : P s\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (m s hs)","decl":"theorem inducedOuterMeasure_eq' {s : Set α} (hs : P s) : inducedOuterMeasure m P0 m0 s = m s hs :=\n  (inducedOuterMeasure_eq_extend' PU msU m_mono hs).trans <| extend_eq _ _\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns : Set α\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) s) (iInf fun t => iInf fun ht => iInf fun x => m t ht)","decl":"theorem inducedOuterMeasure_eq_iInf (s : Set α) :\n    inducedOuterMeasure m P0 m0 s = ⨅ (t : Set α) (ht : P t) (_ : s ⊆ t), m t ht := by\n  apply le_antisymm\n  · simp only [le_iInf_iff]\n    intro t ht hs\n    refine le_trans (measure_mono hs) ?_\n    exact le_of_eq (inducedOuterMeasure_eq' _ msU m_mono _)\n  · refine le_iInf ?_\n    intro f\n    refine le_iInf ?_\n    intro hf\n    refine le_trans ?_ (extend_iUnion_le_tsum_nat' _ msU _)\n    refine le_iInf ?_\n    intro h2f\n    exact iInf_le_of_le _ (iInf_le_of_le h2f <| iInf_le _ hf)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_preimage","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\nf : Equiv α α\nPm : ∀ (s : Set α), Iff (P (Set.preimage (⇑f) s)) (P s)\nmm : ∀ (s : Set α) (hs : P s), Eq (m (Set.preimage (⇑f) s) ⋯) (m s hs)\nA : Set α\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m P0 m0) (Set.preimage (⇑f) A)) ((MeasureTheory.inducedOuterMeasure m P0 m0) A)","decl":"theorem inducedOuterMeasure_preimage (f : α ≃ α) (Pm : ∀ s : Set α, P (f ⁻¹' s) ↔ P s)\n    (mm : ∀ (s : Set α) (hs : P s), m (f ⁻¹' s) ((Pm _).mpr hs) = m s hs) {A : Set α} :\n    inducedOuterMeasure m P0 m0 (f ⁻¹' A) = inducedOuterMeasure m P0 m0 A := by\n    rw [inducedOuterMeasure_eq_iInf _ msU m_mono, inducedOuterMeasure_eq_iInf _ msU m_mono]; symm\n    refine f.injective.preimage_surjective.iInf_congr (preimage f) fun s => ?_\n    refine iInf_congr_Prop (Pm s) ?_; intro hs\n    refine iInf_congr_Prop f.surjective.preimage_subset_preimage_iff ?_\n    intro _; exact mm s hs\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_exists_set","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns : Set α\nhs : Ne ((MeasureTheory.inducedOuterMeasure m P0 m0) s) Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun t => And (P t) (And (HasSubset.Subset s t) (LE.le ((MeasureTheory.inducedOuterMeasure m P0 m0) t) (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) s) ε)))","decl":"theorem inducedOuterMeasure_exists_set {s : Set α} (hs : inducedOuterMeasure m P0 m0 s ≠ ∞)\n    {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ t : Set α,\n      P t ∧ s ⊆ t ∧ inducedOuterMeasure m P0 m0 t ≤ inducedOuterMeasure m P0 m0 s + ε := by\n  have h := ENNReal.lt_add_right hs hε\n  conv at h =>\n    lhs\n    rw [inducedOuterMeasure_eq_iInf _ msU m_mono]\n  simp only [iInf_lt_iff] at h\n  rcases h with ⟨t, h1t, h2t, h3t⟩\n  exact\n    ⟨t, h1t, h2t, le_trans (le_of_eq <| inducedOuterMeasure_eq' _ msU m_mono h1t) (le_of_lt h3t)⟩\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\nP : Set α → Prop\nm : (s : Set α) → P s → ENNReal\nP0 : P EmptyCollection.emptyCollection\nm0 : Eq (m EmptyCollection.emptyCollection P0) 0\nPU : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), P (f i)) → P (Set.iUnion fun i => f i)\nmsU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), P (f i)), LE.le (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\nm_mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), HasSubset.Subset s₁ s₂ → LE.le (m s₁ hs₁) (m s₂ hs₂)\ns : Set α\n⊢ Iff (MeasurableSet s) (∀ (t : Set α), P t → LE.le (HAdd.hAdd ((MeasureTheory.inducedOuterMeasure m P0 m0) (Inter.inter t s)) ((MeasureTheory.inducedOuterMeasure m P0 m0) (SDiff.sdiff t s))) ((MeasureTheory.inducedOuterMeasure m P0 m0) t))","decl":"/-- To test whether `s` is Carathéodory-measurable we only need to check the sets `t` for which\n  `P t` holds. See `ofFunction_caratheodory` for another way to show the Carathéodory-measurability\n  of `s`.\n-/\ntheorem inducedOuterMeasure_caratheodory (s : Set α) :\n    MeasurableSet[(inducedOuterMeasure m P0 m0).caratheodory] s ↔\n      ∀ t : Set α,\n        P t →\n          inducedOuterMeasure m P0 m0 (t ∩ s) + inducedOuterMeasure m P0 m0 (t \\ s) ≤\n            inducedOuterMeasure m P0 m0 t := by\n  rw [isCaratheodory_iff_le]\n  constructor\n  · intro h t _ht\n    exact h t\n  · intro h u\n    conv_rhs => rw [inducedOuterMeasure_eq_iInf _ msU m_mono]\n    refine le_iInf ?_\n    intro t\n    refine le_iInf ?_\n    intro ht\n    refine le_iInf ?_\n    intro h2t\n    refine le_trans ?_ ((h t ht).trans_eq <| inducedOuterMeasure_eq' _ msU m_mono ht)\n    gcongr\n\n"}
{"name":"MeasureTheory.extend_mono","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : (s : Set α) → MeasurableSet s → ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ⋯) 0\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nhs : HasSubset.Subset s₁ s₂\n⊢ LE.le (MeasureTheory.extend m s₁) (MeasureTheory.extend m s₂)","decl":"theorem extend_mono {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (hs : s₁ ⊆ s₂) :\n    extend m s₁ ≤ extend m s₂ := by\n  refine le_iInf ?_; intro h₂\n  have :=\n    extend_union MeasurableSet.empty m0 MeasurableSet.iUnion mU disjoint_sdiff_self_right h₁\n      (h₂.diff h₁)\n  rw [union_diff_cancel hs] at this\n  rw [← extend_eq m]\n  exact le_iff_exists_add.2 ⟨_, this⟩\n\n"}
{"name":"MeasureTheory.extend_iUnion_le_tsum_nat","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : (s : Set α) → MeasurableSet s → ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ⋯) 0\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns : Nat → Set α\n⊢ LE.le (MeasureTheory.extend m (Set.iUnion fun i => s i)) (tsum fun i => MeasureTheory.extend m (s i))","decl":"theorem extend_iUnion_le_tsum_nat : ∀ s : ℕ → Set α,\n    extend m (⋃ i, s i) ≤ ∑' i, extend m (s i) := by\n  refine extend_iUnion_le_tsum_nat' MeasurableSet.iUnion ?_; intro f h\n  simp (config := { singlePass := true }) only [iUnion_disjointed.symm]\n  rw [mU (MeasurableSet.disjointed h) (disjoint_disjointed _)]\n  refine ENNReal.tsum_le_tsum fun i => ?_\n  rw [← extend_eq m, ← extend_eq m]\n  exact extend_mono m0 mU (MeasurableSet.disjointed h _) (disjointed_le f _)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq_extend","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : (s : Set α) → MeasurableSet s → ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ⋯) 0\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m ⋯ m0) s) (MeasureTheory.extend m s)","decl":"theorem inducedOuterMeasure_eq_extend {s : Set α} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = extend m s :=\n  ofFunction_eq s (fun _t => extend_mono m0 mU hs) (extend_iUnion_le_tsum_nat m0 mU)\n\n"}
{"name":"MeasureTheory.inducedOuterMeasure_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : (s : Set α) → MeasurableSet s → ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ⋯) 0\nmU : ∀ ⦃f : Nat → Set α⦄ (hm : ∀ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.inducedOuterMeasure m ⋯ m0) s) (m s hs)","decl":"theorem inducedOuterMeasure_eq {s : Set α} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = m s hs :=\n  (inducedOuterMeasure_eq_extend m0 mU hs).trans <| extend_eq _ _\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le m₁ m₂.trim) (∀ (s : Set α), MeasurableSet s → LE.le (m₁ s) (m₂ s))","decl":"theorem le_trim_iff {m₁ m₂ : OuterMeasure α} :\n    m₁ ≤ m₂.trim ↔ ∀ s, MeasurableSet s → m₁ s ≤ m₂ s :=\n  le_inducedOuterMeasure\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\n⊢ LE.le m m.trim","decl":"theorem le_trim : m ≤ m.trim := le_trim_iff.2 fun _ _ ↦ le_rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (m.trim s) (m s)","decl":"@[simp] -- Porting note: added `simp`\ntheorem trim_eq {s : Set α} (hs : MeasurableSet s) : m.trim s = m s :=\n  inducedOuterMeasure_eq' MeasurableSet.iUnion (fun f _hf => measure_iUnion_le f)\n    (fun _ _ _ _ h => measure_mono h) hs\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_congr","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\nH : ∀ {s : Set α}, MeasurableSet s → Eq (m₁ s) (m₂ s)\n⊢ Eq m₁.trim m₂.trim","decl":"theorem trim_congr {m₁ m₂ : OuterMeasure α} (H : ∀ {s : Set α}, MeasurableSet s → m₁ s = m₂ s) :\n    m₁.trim = m₂.trim := by\n  simp +contextual only [trim, H]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_mono","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Monotone MeasureTheory.OuterMeasure.trim","decl":"@[mono]\ntheorem trim_mono : Monotone (trim : OuterMeasure α → OuterMeasure α) := fun _m₁ _m₂ H _s =>\n  iInf₂_mono fun _f _hs => ENNReal.tsum_le_tsum fun _b => iInf_mono fun _hf => H _\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_anti_measurableSpace","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_2\nm : MeasureTheory.OuterMeasure α\nm0 m1 : MeasurableSpace α\nh : LE.le m0 m1\n⊢ LE.le m.trim m.trim","decl":"/-- `OuterMeasure.trim` is antitone in the σ-algebra. -/\ntheorem trim_anti_measurableSpace {α} (m : OuterMeasure α) {m0 m1 : MeasurableSpace α}\n    (h : m0 ≤ m1) : @trim _ m1 m ≤ @trim _ m0 m := by\n  simp only [le_trim_iff]\n  intro s hs\n  rw [trim_eq _ (h s hs)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_le_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le m₁.trim m₂.trim) (∀ (s : Set α), MeasurableSet s → LE.le (m₁ s) (m₂ s))","decl":"theorem trim_le_trim_iff {m₁ m₂ : OuterMeasure α} :\n    m₁.trim ≤ m₂.trim ↔ ∀ s, MeasurableSet s → m₁ s ≤ m₂ s :=\n  le_trim_iff.trans <| forall₂_congr fun s hs => by rw [trim_eq _ hs]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_trim_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ Iff (Eq m₁.trim m₂.trim) (∀ (s : Set α), MeasurableSet s → Eq (m₁ s) (m₂ s))","decl":"theorem trim_eq_trim_iff {m₁ m₂ : OuterMeasure α} :\n    m₁.trim = m₂.trim ↔ ∀ s, MeasurableSet s → m₁ s = m₂ s := by\n  simp only [le_antisymm_iff, trim_le_trim_iff, forall_and]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Eq (m.trim s) (iInf fun t => iInf fun x => iInf fun x => m t)","decl":"theorem trim_eq_iInf (s : Set α) : m.trim s = ⨅ (t) (_ : s ⊆ t) (_ : MeasurableSet t), m t := by\n  simp (config := { singlePass := true }) only [iInf_comm]\n  exact\n    inducedOuterMeasure_eq_iInf MeasurableSet.iUnion (fun f _ => measure_iUnion_le f)\n      (fun _ _ _ _ h => measure_mono h) s\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_eq_iInf'","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Eq (m.trim s) (iInf fun t => m ↑t)","decl":"theorem trim_eq_iInf' (s : Set α) : m.trim s = ⨅ t : { t // s ⊆ t ∧ MeasurableSet t }, m t := by\n  simp [iInf_subtype, iInf_and, trim_eq_iInf]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\n⊢ Eq m.trim.trim m.trim","decl":"theorem trim_trim (m : OuterMeasure α) : m.trim.trim = m.trim :=\n  trim_eq_trim_iff.2 fun _s => m.trim_eq\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_top","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq Top.top.trim Top.top","decl":"@[simp]\ntheorem trim_top : (⊤ : OuterMeasure α).trim = ⊤ :=\n  top_unique <| le_trim _\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.OuterMeasure.trim 0) 0","decl":"@[simp]\ntheorem trim_zero : (0 : OuterMeasure α).trim = 0 :=\n  ext fun s =>\n    le_antisymm\n      ((measure_mono (subset_univ s)).trans_eq <| trim_eq _ MeasurableSet.univ)\n      (zero_le _)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_sum_ge","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nι : Type u_2\nm : ι → MeasureTheory.OuterMeasure α\n⊢ LE.le (MeasureTheory.OuterMeasure.sum fun i => (m i).trim) (MeasureTheory.OuterMeasure.sum m).trim","decl":"theorem trim_sum_ge {ι} (m : ι → OuterMeasure α) : (sum fun i => (m i).trim) ≤ (sum m).trim :=\n  fun s => by\n  simp only [sum_apply, trim_eq_iInf, le_iInf_iff]\n  exact fun t st ht =>\n    ENNReal.tsum_le_tsum fun i => iInf_le_of_le t <| iInf_le_of_le st <| iInf_le _ ht\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_eq_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (m t) (m.trim s)))","decl":"theorem exists_measurable_superset_eq_trim (m : OuterMeasure α) (s : Set α) :\n    ∃ t, s ⊆ t ∧ MeasurableSet t ∧ m t = m.trim s := by\n  simp only [trim_eq_iInf]; set ms := ⨅ (t : Set α) (_ : s ⊆ t) (_ : MeasurableSet t), m t\n  by_cases hs : ms = ∞\n  · simp only [hs]\n    simp only [iInf_eq_top, ms] at hs\n    exact ⟨univ, subset_univ s, MeasurableSet.univ, hs _ (subset_univ s) MeasurableSet.univ⟩\n  · have : ∀ r > ms, ∃ t, s ⊆ t ∧ MeasurableSet t ∧ m t < r := by\n      intro r hs\n      have : ∃t, MeasurableSet t ∧ s ⊆ t ∧ m t < r := by simpa [ms, iInf_lt_iff] using hs\n      rcases this with ⟨t, hmt, hin, hlt⟩\n      exists t\n    have : ∀ n : ℕ, ∃ t, s ⊆ t ∧ MeasurableSet t ∧ m t < ms + (n : ℝ≥0∞)⁻¹ := by\n      intro n\n      refine this _ (ENNReal.lt_add_right hs ?_)\n      simp\n    choose t hsub hm hm' using this\n    refine ⟨⋂ n, t n, subset_iInter hsub, MeasurableSet.iInter hm, ?_⟩\n    have : Tendsto (fun n : ℕ => ms + (n : ℝ≥0∞)⁻¹) atTop (𝓝 (ms + 0)) :=\n      tendsto_const_nhds.add ENNReal.tendsto_inv_nat_nhds_zero\n    rw [add_zero] at this\n    refine le_antisymm (ge_of_tendsto' this fun n => ?_) ?_\n    · exact le_trans (measure_mono <| iInter_subset t n) (hm' n).le\n    · refine iInf_le_of_le (⋂ n, t n) ?_\n      refine iInf_le_of_le (subset_iInter hsub) ?_\n      exact iInf_le _ (MeasurableSet.iInter hm)\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_of_trim_eq_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\ns : Set α\nh : Eq (m.trim s) 0\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (m t) 0))","decl":"theorem exists_measurable_superset_of_trim_eq_zero {m : OuterMeasure α} {s : Set α}\n    (h : m.trim s = 0) : ∃ t, s ⊆ t ∧ MeasurableSet t ∧ m t = 0 := by\n  rcases exists_measurable_superset_eq_trim m s with ⟨t, hst, ht, hm⟩\n  exact ⟨t, hst, ht, h ▸ hm⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.exists_measurable_superset_forall_eq_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nι : Sort u_2\ninst✝ : Countable ι\nμ : ι → MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (∀ (i : ι), Eq ((μ i) t) ((μ i).trim s)))","decl":"/-- If `μ i` is a countable family of outer measures, then for every set `s` there exists\na measurable set `t ⊇ s` such that `μ i t = (μ i).trim s` for all `i`. -/\ntheorem exists_measurable_superset_forall_eq_trim {ι} [Countable ι] (μ : ι → OuterMeasure α)\n    (s : Set α) : ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ∀ i, μ i t = (μ i).trim s := by\n  choose t hst ht hμt using fun i => (μ i).exists_measurable_superset_eq_trim s\n  replace hst := subset_iInter hst\n  replace ht := MeasurableSet.iInter ht\n  refine ⟨⋂ i, t i, hst, ht, fun i => le_antisymm ?_ ?_⟩\n  exacts [hμt i ▸ (μ i).mono (iInter_subset _ _), (measure_mono hst).trans_eq ((μ i).trim_eq ht)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_binop","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ m₃ : MeasureTheory.OuterMeasure α\nop : ENNReal → ENNReal → ENNReal\nh : ∀ (s : Set α), Eq (m₁ s) (op (m₂ s) (m₃ s))\ns : Set α\n⊢ Eq (m₁.trim s) (op (m₂.trim s) (m₃.trim s))","decl":"/-- If `m₁ s = op (m₂ s) (m₃ s)` for all `s`, then the same is true for `m₁.trim`, `m₂.trim`,\nand `m₃ s`. -/\ntheorem trim_binop {m₁ m₂ m₃ : OuterMeasure α} {op : ℝ≥0∞ → ℝ≥0∞ → ℝ≥0∞}\n    (h : ∀ s, m₁ s = op (m₂ s) (m₃ s)) (s : Set α) : m₁.trim s = op (m₂.trim s) (m₃.trim s) := by\n  rcases exists_measurable_superset_forall_eq_trim ![m₁, m₂, m₃] s with ⟨t, _hst, _ht, htm⟩\n  simp only [Fin.forall_iff_succ, Matrix.cons_val_zero, Matrix.cons_val_succ] at htm\n  rw [← htm.1, ← htm.2.1, ← htm.2.2.1, h]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_op","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\nop : ENNReal → ENNReal\nh : ∀ (s : Set α), Eq (m₁ s) (op (m₂ s))\ns : Set α\n⊢ Eq (m₁.trim s) (op (m₂.trim s))","decl":"/-- If `m₁ s = op (m₂ s)` for all `s`, then the same is true for `m₁.trim` and `m₂.trim`. -/\ntheorem trim_op {m₁ m₂ : OuterMeasure α} {op : ℝ≥0∞ → ℝ≥0∞} (h : ∀ s, m₁ s = op (m₂ s))\n    (s : Set α) : m₁.trim s = op (m₂.trim s) :=\n  @trim_binop α _ m₁ m₂ 0 (fun a _b => op a) h s\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_add","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ Eq (HAdd.hAdd m₁ m₂).trim (HAdd.hAdd m₁.trim m₂.trim)","decl":"/-- `trim` is additive. -/\ntheorem trim_add (m₁ m₂ : OuterMeasure α) : (m₁ + m₂).trim = m₁.trim + m₂.trim :=\n  ext <| trim_binop (add_apply m₁ m₂)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_smul","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nR : Type u_2\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nc : R\nm : MeasureTheory.OuterMeasure α\n⊢ Eq (HSMul.hSMul c m).trim (HSMul.hSMul c m.trim)","decl":"/-- `trim` respects scalar multiplication. -/\ntheorem trim_smul {R : Type*} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] (c : R)\n    (m : OuterMeasure α) : (c • m).trim = c • m.trim :=\n  ext <| trim_op (smul_apply c m)\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_sup","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ Eq (Max.max m₁ m₂).trim (Max.max m₁.trim m₂.trim)","decl":"/-- `trim` sends the supremum of two outer measures to the supremum of the trimmed measures. -/\ntheorem trim_sup (m₁ m₂ : OuterMeasure α) : (m₁ ⊔ m₂).trim = m₁.trim ⊔ m₂.trim :=\n  ext fun s => (trim_binop (sup_apply m₁ m₂) s).trans (sup_apply _ _ _).symm\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_iSup","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nι : Sort u_2\ninst✝ : Countable ι\nμ : ι → MeasureTheory.OuterMeasure α\n⊢ Eq (iSup fun i => μ i).trim (iSup fun i => (μ i).trim)","decl":"/-- `trim` sends the supremum of a countable family of outer measures to the supremum\nof the trimmed measures. -/\ntheorem trim_iSup {ι} [Countable ι] (μ : ι → OuterMeasure α) :\n    trim (⨆ i, μ i) = ⨆ i, trim (μ i) := by\n  simp_rw [← @iSup_plift_down _ ι]\n  ext1 s\n  obtain ⟨t, _, _, hμt⟩ :=\n    exists_measurable_superset_forall_eq_trim\n      (Option.elim' (⨆ i, μ (PLift.down i)) (μ ∘ PLift.down)) s\n  simp only [Option.forall, Option.elim'] at hμt\n  simp only [iSup_apply, ← hμt.1]\n  exact iSup_congr hμt.2\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_trim","module":"Mathlib.MeasureTheory.OuterMeasure.Induced","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.OuterMeasure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) μ).trim ((MeasureTheory.OuterMeasure.restrict s) μ.trim)","decl":"/-- The trimmed property of a measure μ states that `μ.toOuterMeasure.trim = μ.toOuterMeasure`.\nThis theorem shows that a restricted trimmed outer measure is a trimmed outer measure. -/\ntheorem restrict_trim {μ : OuterMeasure α} {s : Set α} (hs : MeasurableSet s) :\n    (restrict s μ).trim = restrict s μ.trim := by\n  refine le_antisymm (fun t => ?_) (le_trim_iff.2 fun t ht => ?_)\n  · rw [restrict_apply]\n    rcases μ.exists_measurable_superset_eq_trim (t ∩ s) with ⟨t', htt', ht', hμt'⟩\n    rw [← hμt']\n    rw [inter_subset] at htt'\n    refine (measure_mono htt').trans ?_\n    rw [trim_eq _ (hs.compl.union ht'), restrict_apply, union_inter_distrib_right, compl_inter_self,\n      Set.empty_union]\n    exact measure_mono inter_subset_left\n  · rw [restrict_apply, trim_eq _ (ht.inter hs), restrict_apply]\n\n"}
