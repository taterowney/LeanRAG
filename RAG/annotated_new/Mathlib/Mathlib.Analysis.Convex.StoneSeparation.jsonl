{"name":"not_disjoint_segment_convexHull_triple","module":"Mathlib.Analysis.Convex.StoneSeparation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q u v x y z : E\nhz : Membership.mem (segment 𝕜 x y) z\nhu : Membership.mem (segment 𝕜 x p) u\nhv : Membership.mem (segment 𝕜 y q) v\n⊢ Not (Disjoint (segment 𝕜 u v) ((convexHull 𝕜) (Insert.insert p (Insert.insert q (Singleton.singleton z)))))","decl":"/-- In a tetrahedron with vertices `x`, `y`, `p`, `q`, any segment `[u, v]` joining the opposite\nedges `[x, p]` and `[y, q]` passes through any triangle of vertices `p`, `q`, `z` where\n`z ∈ [x, y]`. -/\ntheorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z ∈ segment 𝕜 x y)\n    (hu : u ∈ segment 𝕜 x p) (hv : v ∈ segment 𝕜 y q) :\n    ¬Disjoint (segment 𝕜 u v) (convexHull 𝕜 {p, q, z}) := by\n  rw [not_disjoint_iff]\n  obtain ⟨az, bz, haz, hbz, habz, rfl⟩ := hz\n  obtain rfl | haz' := haz.eq_or_lt\n  · rw [zero_add] at habz\n    rw [zero_smul, zero_add, habz, one_smul]\n    refine ⟨v, by apply right_mem_segment, segment_subset_convexHull ?_ ?_ hv⟩ <;> simp\n  obtain ⟨av, bv, hav, hbv, habv, rfl⟩ := hv\n  obtain rfl | hav' := hav.eq_or_lt\n  · rw [zero_add] at habv\n    rw [zero_smul, zero_add, habv, one_smul]\n    exact ⟨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simp⟩\n  obtain ⟨au, bu, hau, hbu, habu, rfl⟩ := hu\n  have hab : 0 < az * av + bz * au := by positivity\n  refine ⟨(az * av / (az * av + bz * au)) • (au • x + bu • p) +\n    (bz * au / (az * av + bz * au)) • (av • y + bv • q), ⟨_, _, ?_, ?_, ?_, rfl⟩, ?_⟩\n  · positivity\n  · positivity\n  · rw [← add_div, div_self]; positivity\n  classical\n    let w : Fin 3 → 𝕜 := ![az * av * bu, bz * au * bv, au * av]\n    let z : Fin 3 → E := ![p, q, az • x + bz • y]\n    have hw₀ : ∀ i, 0 ≤ w i := by\n      rintro i\n      fin_cases i\n      · exact mul_nonneg (mul_nonneg haz hav) hbu\n      · exact mul_nonneg (mul_nonneg hbz hau) hbv\n      · exact mul_nonneg hau hav\n    have hw : ∑ i, w i = az * av + bz * au := by\n      trans az * av * bu + (bz * au * bv + au * av)\n      · simp [w, Fin.sum_univ_succ, Fin.sum_univ_zero]\n      linear_combination (au * bv - 1 * au) * habz + (-(1 * az * au) + au) * habv + az * av * habu\n    have hz : ∀ i, z i ∈ ({p, q, az • x + bz • y} : Set E) := fun i => by fin_cases i <;> simp [z]\n    convert (Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hw₀ i)\n        (by rwa [hw]) fun i _ => hz i : Finset.univ.centerMass w z ∈ _)\n    rw [Finset.centerMass, hw]\n    trans (az * av + bz * au)⁻¹ •\n      ((az * av * bu) • p + ((bz * au * bv) • q + (au * av) • (az • x + bz • y)))\n    · module\n    congr 3\n    simp [w, z]\n\n"}
{"name":"exists_convex_convex_compl_subset","module":"Mathlib.Analysis.Convex.StoneSeparation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nhs : Convex 𝕜 s\nht : Convex 𝕜 t\nhst : Disjoint s t\n⊢ Exists fun C => And (Convex 𝕜 C) (And (Convex 𝕜 (HasCompl.compl C)) (And (HasSubset.Subset s C) (HasSubset.Subset t (HasCompl.compl C))))","decl":"/-- **Stone's Separation Theorem** -/\ntheorem exists_convex_convex_compl_subset (hs : Convex 𝕜 s) (ht : Convex 𝕜 t) (hst : Disjoint s t) :\n    ∃ C : Set E, Convex 𝕜 C ∧ Convex 𝕜 Cᶜ ∧ s ⊆ C ∧ t ⊆ Cᶜ := by\n  let S : Set (Set E) := { C | Convex 𝕜 C ∧ Disjoint C t }\n  obtain ⟨C, hsC, hmax⟩ :=\n    zorn_subset_nonempty S\n      (fun c hcS hc ⟨_, _⟩ =>\n        ⟨⋃₀ c,\n          ⟨hc.directedOn.convex_sUnion fun s hs => (hcS hs).1,\n            disjoint_sUnion_left.2 fun c hc => (hcS hc).2⟩,\n          fun s => subset_sUnion_of_mem⟩)\n      s ⟨hs, hst⟩\n  obtain hC : _ ∧ _ := hmax.prop\n  refine\n    ⟨C, hC.1, convex_iff_segment_subset.2 fun x hx y hy z hz hzC => ?_, hsC, hC.2.subset_compl_left⟩\n  suffices h : ∀ c ∈ Cᶜ, ∃ a ∈ C, (segment 𝕜 c a ∩ t).Nonempty by\n    obtain ⟨p, hp, u, hu, hut⟩ := h x hx\n    obtain ⟨q, hq, v, hv, hvt⟩ := h y hy\n    refine\n      not_disjoint_segment_convexHull_triple hz hu hv\n        (hC.2.symm.mono (ht.segment_subset hut hvt) <| convexHull_min ?_ hC.1)\n    simp [insert_subset_iff, hp, hq, singleton_subset_iff.2 hzC]\n  rintro c hc\n  by_contra! h\n  suffices h : Disjoint (convexHull 𝕜 (insert c C)) t by\n    rw [hmax.eq_of_subset ⟨convex_convexHull _ _, h⟩ <|\n      (subset_insert ..).trans <| subset_convexHull ..] at hc\n    exact hc (subset_convexHull _ _ <| mem_insert _ _)\n  rw [convexHull_insert ⟨z, hzC⟩, convexJoin_singleton_left]\n  refine disjoint_iUnion₂_left.2 fun a ha => disjoint_iff_inter_eq_empty.2 (h a ?_)\n  rwa [← hC.1.convexHull_eq]\n"}
