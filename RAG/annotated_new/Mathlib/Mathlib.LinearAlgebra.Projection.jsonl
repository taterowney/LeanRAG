{"name":"LinearMap.ker_id_sub_eq_of_proj","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E (Subtype fun x => Membership.mem p x)\nhf : ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ Eq (LinearMap.ker (HSub.hSub LinearMap.id (p.subtype.comp f))) p","decl":"theorem ker_id_sub_eq_of_proj {f : E →ₗ[R] p} (hf : ∀ x : p, f x = x) :\n    ker (id - p.subtype.comp f) = p := by\n  ext x\n  simp only [comp_apply, mem_ker, subtype_apply, sub_apply, id_apply, sub_eq_zero]\n  exact ⟨fun h => h.symm ▸ Submodule.coe_mem _, fun hx => by rw [hf ⟨x, hx⟩, Subtype.coe_mk]⟩\n\n"}
{"name":"LinearMap.range_eq_of_proj","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E (Subtype fun x => Membership.mem p x)\nhf : ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ Eq (LinearMap.range f) Top.top","decl":"theorem range_eq_of_proj {f : E →ₗ[R] p} (hf : ∀ x : p, f x = x) : range f = ⊤ :=\n  range_eq_top.2 fun x => ⟨x, hf x⟩\n\n"}
{"name":"LinearMap.isCompl_of_proj","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E (Subtype fun x => Membership.mem p x)\nhf : ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ IsCompl p (LinearMap.ker f)","decl":"theorem isCompl_of_proj {f : E →ₗ[R] p} (hf : ∀ x : p, f x = x) : IsCompl p (ker f) := by\n  constructor\n  · rw [disjoint_iff_inf_le]\n    rintro x ⟨hpx, hfx⟩\n    rw [SetLike.mem_coe, mem_ker, hf ⟨x, hpx⟩, mk_eq_zero] at hfx\n    simp only [hfx, SetLike.mem_coe, zero_mem]\n  · rw [codisjoint_iff_le_sup]\n    intro x _\n    rw [mem_sup']\n    refine ⟨f x, ⟨x - f x, ?_⟩, add_sub_cancel _ _⟩\n    rw [mem_ker, LinearMap.map_sub, hf, sub_self]\n\n"}
{"name":"Submodule.quotientEquivOfIsCompl_symm_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem q x\n⊢ Eq ((p.quotientEquivOfIsCompl q h).symm x) (Submodule.Quotient.mk ↑x)","decl":"@[simp]\ntheorem quotientEquivOfIsCompl_symm_apply (h : IsCompl p q) (x : q) :\n    -- Porting note: type ascriptions needed on the RHS\n    (quotientEquivOfIsCompl p q h).symm x = (Quotient.mk (x : E) : E ⧸ p) := rfl\n\n"}
{"name":"Submodule.quotientEquivOfIsCompl_apply_mk_coe","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem q x\n⊢ Eq ((p.quotientEquivOfIsCompl q h) (Submodule.Quotient.mk ↑x)) x","decl":"@[simp]\ntheorem quotientEquivOfIsCompl_apply_mk_coe (h : IsCompl p q) (x : q) :\n    quotientEquivOfIsCompl p q h (Quotient.mk x) = x :=\n  (quotientEquivOfIsCompl p q h).apply_symm_apply x\n\n"}
{"name":"Submodule.mk_quotientEquivOfIsCompl_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : HasQuotient.Quotient E p\n⊢ Eq (Submodule.Quotient.mk ↑((p.quotientEquivOfIsCompl q h) x)) x","decl":"@[simp]\ntheorem mk_quotientEquivOfIsCompl_apply (h : IsCompl p q) (x : E ⧸ p) :\n    (Quotient.mk (quotientEquivOfIsCompl p q h x) : E ⧸ p) = x :=\n  (quotientEquivOfIsCompl p q h).symm_apply_apply x\n\n"}
{"name":"Submodule.coe_prodEquivOfIsCompl","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq (↑(p.prodEquivOfIsCompl q h)) (p.subtype.coprod q.subtype)","decl":"@[simp]\ntheorem coe_prodEquivOfIsCompl (h : IsCompl p q) :\n    (prodEquivOfIsCompl p q h : p × q →ₗ[R] E) = p.subtype.coprod q.subtype := rfl\n\n"}
{"name":"Submodule.coe_prodEquivOfIsCompl'","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Prod (Subtype fun x => Membership.mem p x) (Subtype fun x => Membership.mem q x)\n⊢ Eq ((p.prodEquivOfIsCompl q h) x) (HAdd.hAdd ↑x.1 ↑x.2)","decl":"@[simp]\ntheorem coe_prodEquivOfIsCompl' (h : IsCompl p q) (x : p × q) :\n    prodEquivOfIsCompl p q h x = x.1 + x.2 := rfl\n\n"}
{"name":"Submodule.prodEquivOfIsCompl_symm_apply_left","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((p.prodEquivOfIsCompl q h).symm ↑x) { fst := x, snd := 0 }","decl":"@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_left (h : IsCompl p q) (x : p) :\n    (prodEquivOfIsCompl p q h).symm x = (x, 0) :=\n  (prodEquivOfIsCompl p q h).symm_apply_eq.2 <| by simp\n\n"}
{"name":"Submodule.prodEquivOfIsCompl_symm_apply_right","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem q x\n⊢ Eq ((p.prodEquivOfIsCompl q h).symm ↑x) { fst := 0, snd := x }","decl":"@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_right (h : IsCompl p q) (x : q) :\n    (prodEquivOfIsCompl p q h).symm x = (0, x) :=\n  (prodEquivOfIsCompl p q h).symm_apply_eq.2 <| by simp\n\n"}
{"name":"Submodule.prodEquivOfIsCompl_symm_apply_fst_eq_zero","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n⊢ Iff (Eq ((p.prodEquivOfIsCompl q h).symm x).1 0) (Membership.mem q x)","decl":"@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_fst_eq_zero (h : IsCompl p q) {x : E} :\n    ((prodEquivOfIsCompl p q h).symm x).1 = 0 ↔ x ∈ q := by\n  conv_rhs => rw [← (prodEquivOfIsCompl p q h).apply_symm_apply x]\n  rw [coe_prodEquivOfIsCompl', Submodule.add_mem_iff_left _ (Submodule.coe_mem _),\n    mem_right_iff_eq_zero_of_disjoint h.disjoint]\n\n"}
{"name":"Submodule.prodEquivOfIsCompl_symm_apply_snd_eq_zero","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n⊢ Iff (Eq ((p.prodEquivOfIsCompl q h).symm x).2 0) (Membership.mem p x)","decl":"@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_snd_eq_zero (h : IsCompl p q) {x : E} :\n    ((prodEquivOfIsCompl p q h).symm x).2 = 0 ↔ x ∈ p := by\n  conv_rhs => rw [← (prodEquivOfIsCompl p q h).apply_symm_apply x]\n  rw [coe_prodEquivOfIsCompl', Submodule.add_mem_iff_right _ (Submodule.coe_mem _),\n    mem_left_iff_eq_zero_of_disjoint h.disjoint]\n\n"}
{"name":"Submodule.prodComm_trans_prodEquivOfIsCompl","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq ((LinearEquiv.prodComm R (Subtype fun x => Membership.mem q x) (Subtype fun x => Membership.mem p x)).trans (p.prodEquivOfIsCompl q h)) (q.prodEquivOfIsCompl p ⋯)","decl":"@[simp]\ntheorem prodComm_trans_prodEquivOfIsCompl (h : IsCompl p q) :\n    LinearEquiv.prodComm R q p ≪≫ₗ prodEquivOfIsCompl p q h = prodEquivOfIsCompl q p h.symm :=\n  LinearEquiv.ext fun _ => add_comm _ _\n\n"}
{"name":"Submodule.linearProjOfIsCompl_apply_left","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((p.linearProjOfIsCompl q h) ↑x) x","decl":"@[simp]\ntheorem linearProjOfIsCompl_apply_left (h : IsCompl p q) (x : p) :\n    linearProjOfIsCompl p q h x = x := by simp [linearProjOfIsCompl]\n\n"}
{"name":"Submodule.linearProjOfIsCompl_range","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq (LinearMap.range (p.linearProjOfIsCompl q h)) Top.top","decl":"@[simp]\ntheorem linearProjOfIsCompl_range (h : IsCompl p q) : range (linearProjOfIsCompl p q h) = ⊤ :=\n  range_eq_of_proj (linearProjOfIsCompl_apply_left h)\n\n"}
{"name":"Submodule.linearProjOfIsCompl_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n⊢ Iff (Eq ((p.linearProjOfIsCompl q h) x) 0) (Membership.mem q x)","decl":"@[simp]\ntheorem linearProjOfIsCompl_apply_eq_zero_iff (h : IsCompl p q) {x : E} :\n    linearProjOfIsCompl p q h x = 0 ↔ x ∈ q := by simp [linearProjOfIsCompl]\n\n"}
{"name":"Submodule.linearProjOfIsCompl_apply_right'","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\nhx : Membership.mem q x\n⊢ Eq ((p.linearProjOfIsCompl q h) x) 0","decl":"theorem linearProjOfIsCompl_apply_right' (h : IsCompl p q) (x : E) (hx : x ∈ q) :\n    linearProjOfIsCompl p q h x = 0 :=\n  (linearProjOfIsCompl_apply_eq_zero_iff h).2 hx\n\n"}
{"name":"Submodule.linearProjOfIsCompl_apply_right","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : Subtype fun x => Membership.mem q x\n⊢ Eq ((p.linearProjOfIsCompl q h) ↑x) 0","decl":"@[simp]\ntheorem linearProjOfIsCompl_apply_right (h : IsCompl p q) (x : q) :\n    linearProjOfIsCompl p q h x = 0 :=\n  linearProjOfIsCompl_apply_right' h x x.2\n\n"}
{"name":"Submodule.linearProjOfIsCompl_ker","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq (LinearMap.ker (p.linearProjOfIsCompl q h)) q","decl":"@[simp]\ntheorem linearProjOfIsCompl_ker (h : IsCompl p q) : ker (linearProjOfIsCompl p q h) = q :=\n  ext fun _ => mem_ker.trans (linearProjOfIsCompl_apply_eq_zero_iff h)\n\n"}
{"name":"Submodule.linearProjOfIsCompl_comp_subtype","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq ((p.linearProjOfIsCompl q h).comp p.subtype) LinearMap.id","decl":"theorem linearProjOfIsCompl_comp_subtype (h : IsCompl p q) :\n    (linearProjOfIsCompl p q h).comp p.subtype = LinearMap.id :=\n  LinearMap.ext <| linearProjOfIsCompl_apply_left h\n\n"}
{"name":"Submodule.linearProjOfIsCompl_idempotent","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nh : IsCompl p q\nx : E\n⊢ Eq ((p.linearProjOfIsCompl q h) ↑((p.linearProjOfIsCompl q h) x)) ((p.linearProjOfIsCompl q h) x)","decl":"theorem linearProjOfIsCompl_idempotent (h : IsCompl p q) (x : E) :\n    linearProjOfIsCompl p q h (linearProjOfIsCompl p q h x) = linearProjOfIsCompl p q h x :=\n  linearProjOfIsCompl_apply_left h _\n\n"}
{"name":"Submodule.existsUnique_add_of_isCompl_prod","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nhc : IsCompl p q\nx : E\n⊢ ExistsUnique fun u => Eq (HAdd.hAdd ↑u.1 ↑u.2) x","decl":"theorem existsUnique_add_of_isCompl_prod (hc : IsCompl p q) (x : E) :\n    ∃! u : p × q, (u.fst : E) + u.snd = x :=\n  (prodEquivOfIsCompl _ _ hc).toEquiv.bijective.existsUnique _\n\n"}
{"name":"Submodule.existsUnique_add_of_isCompl","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nhc : IsCompl p q\nx : E\n⊢ Exists fun u => Exists fun v => And (Eq (HAdd.hAdd ↑u ↑v) x) (∀ (r : Subtype fun x => Membership.mem p x) (s : Subtype fun x => Membership.mem q x), Eq (HAdd.hAdd ↑r ↑s) x → And (Eq r u) (Eq s v))","decl":"theorem existsUnique_add_of_isCompl (hc : IsCompl p q) (x : E) :\n    ∃ (u : p) (v : q), (u : E) + v = x ∧ ∀ (r : p) (s : q), (r : E) + s = x → r = u ∧ s = v :=\n  let ⟨u, hu₁, hu₂⟩ := existsUnique_add_of_isCompl_prod hc x\n  ⟨u.1, u.2, hu₁, fun r s hrs => Prod.eq_iff_fst_eq_snd_eq.1 (hu₂ ⟨r, s⟩ hrs)⟩\n\n"}
{"name":"Submodule.linear_proj_add_linearProjOfIsCompl_eq_self","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np q : Submodule R E\nhpq : IsCompl p q\nx : E\n⊢ Eq (HAdd.hAdd ↑((p.linearProjOfIsCompl q hpq) x) ↑((q.linearProjOfIsCompl p ⋯) x)) x","decl":"theorem linear_proj_add_linearProjOfIsCompl_eq_self (hpq : IsCompl p q) (x : E) :\n    (p.linearProjOfIsCompl q hpq x + q.linearProjOfIsCompl p hpq.symm x : E) = x := by\n  dsimp only [linearProjOfIsCompl]\n  rw [← prodComm_trans_prodEquivOfIsCompl _ _ hpq]\n  exact (prodEquivOfIsCompl _ _ hpq).apply_symm_apply x\n\n"}
{"name":"LinearMap.linearProjOfIsCompl_apply_left","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nq : Submodule R E\nF : Type u_7\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ni : LinearMap (RingHom.id R) F E\nhi : Function.Injective ⇑i\nh : IsCompl (LinearMap.range i) q\nx : F\n⊢ Eq ((LinearMap.linearProjOfIsCompl q i hi h) (i x)) x","decl":"@[simp]\ntheorem linearProjOfIsCompl_apply_left {F : Type*} [AddCommGroup F] [Module R F]\n    (i : F →ₗ[R] E) (hi : Function.Injective i)\n    (h : IsCompl (LinearMap.range i) q) (x : F) :\n    linearProjOfIsCompl q i hi h (i x) = x := by\n  let ix : LinearMap.range i := ⟨i x, mem_range_self i x⟩\n  change linearProjOfIsCompl q i hi h ix = x\n  rw [linearProjOfIsCompl, coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    LinearEquiv.symm_apply_eq, Submodule.linearProjOfIsCompl_apply_left, Subtype.ext_iff,\n    LinearEquiv.ofInjective_apply]\n\n"}
{"name":"LinearMap.ofIsCompl_left_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\nu : Subtype fun x => Membership.mem p x\n⊢ Eq ((LinearMap.ofIsCompl h φ ψ) ↑u) (φ u)","decl":"@[simp]\ntheorem ofIsCompl_left_apply (h : IsCompl p q) {φ : p →ₗ[R] F} {ψ : q →ₗ[R] F} (u : p) :\n    ofIsCompl h φ ψ (u : E) = φ u := by simp [ofIsCompl]\n\n"}
{"name":"LinearMap.ofIsCompl_right_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\nv : Subtype fun x => Membership.mem q x\n⊢ Eq ((LinearMap.ofIsCompl h φ ψ) ↑v) (ψ v)","decl":"@[simp]\ntheorem ofIsCompl_right_apply (h : IsCompl p q) {φ : p →ₗ[R] F} {ψ : q →ₗ[R] F} (v : q) :\n    ofIsCompl h φ ψ (v : E) = ψ v := by simp [ofIsCompl]\n\n"}
{"name":"LinearMap.ofIsCompl_eq","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\nχ : LinearMap (RingHom.id R) E F\nhφ : ∀ (u : Subtype fun x => Membership.mem p x), Eq (φ u) (χ ↑u)\nhψ : ∀ (u : Subtype fun x => Membership.mem q x), Eq (ψ u) (χ ↑u)\n⊢ Eq (LinearMap.ofIsCompl h φ ψ) χ","decl":"theorem ofIsCompl_eq (h : IsCompl p q) {φ : p →ₗ[R] F} {ψ : q →ₗ[R] F} {χ : E →ₗ[R] F}\n    (hφ : ∀ u, φ u = χ u) (hψ : ∀ u, ψ u = χ u) : ofIsCompl h φ ψ = χ := by\n  ext x\n  obtain ⟨_, _, rfl, _⟩ := existsUnique_add_of_isCompl h x\n  simp [ofIsCompl, hφ, hψ]\n\n"}
{"name":"LinearMap.ofIsCompl_eq'","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\nχ : LinearMap (RingHom.id R) E F\nhφ : Eq φ (χ.comp p.subtype)\nhψ : Eq ψ (χ.comp q.subtype)\n⊢ Eq (LinearMap.ofIsCompl h φ ψ) χ","decl":"theorem ofIsCompl_eq' (h : IsCompl p q) {φ : p →ₗ[R] F} {ψ : q →ₗ[R] F} {χ : E →ₗ[R] F}\n    (hφ : φ = χ.comp p.subtype) (hψ : ψ = χ.comp q.subtype) : ofIsCompl h φ ψ = χ :=\n  ofIsCompl_eq h (fun _ => hφ.symm ▸ rfl) fun _ => hψ.symm ▸ rfl\n\n"}
{"name":"LinearMap.ofIsCompl_zero","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\n⊢ Eq (LinearMap.ofIsCompl h 0 0) 0","decl":"@[simp]\ntheorem ofIsCompl_zero (h : IsCompl p q) : (ofIsCompl h 0 0 : E →ₗ[R] F) = 0 :=\n  ofIsCompl_eq _ (fun _ => rfl) fun _ => rfl\n\n"}
{"name":"LinearMap.ofIsCompl_add","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ₁ φ₂ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ₁ ψ₂ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\n⊢ Eq (LinearMap.ofIsCompl h (HAdd.hAdd φ₁ φ₂) (HAdd.hAdd ψ₁ ψ₂)) (HAdd.hAdd (LinearMap.ofIsCompl h φ₁ ψ₁) (LinearMap.ofIsCompl h φ₂ ψ₂))","decl":"@[simp]\ntheorem ofIsCompl_add (h : IsCompl p q) {φ₁ φ₂ : p →ₗ[R] F} {ψ₁ ψ₂ : q →ₗ[R] F} :\n    ofIsCompl h (φ₁ + φ₂) (ψ₁ + ψ₂) = ofIsCompl h φ₁ ψ₁ + ofIsCompl h φ₂ ψ₂ :=\n  ofIsCompl_eq _ (by simp) (by simp)\n\n"}
{"name":"LinearMap.ofIsCompl_smul","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_7\ninst✝⁴ : CommRing R\nE : Type u_8\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_9\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np q : Submodule R E\nh : IsCompl p q\nφ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem q x) F\nc : R\n⊢ Eq (LinearMap.ofIsCompl h (HSMul.hSMul c φ) (HSMul.hSMul c ψ)) (HSMul.hSMul c (LinearMap.ofIsCompl h φ ψ))","decl":"@[simp]\ntheorem ofIsCompl_smul {R : Type*} [CommRing R] {E : Type*} [AddCommGroup E] [Module R E]\n    {F : Type*} [AddCommGroup F] [Module R F] {p q : Submodule R E} (h : IsCompl p q)\n    {φ : p →ₗ[R] F} {ψ : q →ₗ[R] F} (c : R) : ofIsCompl h (c • φ) (c • ψ) = c • ofIsCompl h φ ψ :=\n  ofIsCompl_eq _ (by simp) (by simp)\n\n"}
{"name":"LinearMap.ofIsComplProd_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\nF : Type u_3\ninst✝³ : AddCommGroup F\nR₁ : Type u_7\ninst✝² : CommRing R₁\ninst✝¹ : Module R₁ E\ninst✝ : Module R₁ F\np q : Submodule R₁ E\nh : IsCompl p q\nφ : Prod (LinearMap (RingHom.id R₁) (Subtype fun x => Membership.mem p x) F) (LinearMap (RingHom.id R₁) (Subtype fun x => Membership.mem q x) F)\n⊢ Eq ((LinearMap.ofIsComplProd h) φ) (LinearMap.ofIsCompl h φ.1 φ.2)","decl":"@[simp]\ntheorem ofIsComplProd_apply {p q : Submodule R₁ E} (h : IsCompl p q)\n    (φ : (p →ₗ[R₁] F) × (q →ₗ[R₁] F)) : ofIsComplProd h φ = ofIsCompl h φ.1 φ.2 :=\n  rfl\n\n"}
{"name":"LinearMap.linearProjOfIsCompl_of_proj","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E (Subtype fun x => Membership.mem p x)\nhf : ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ Eq (p.linearProjOfIsCompl (LinearMap.ker f) ⋯) f","decl":"@[simp, nolint simpNF] -- Porting note: linter claims that LHS doesn't simplify, but it does\ntheorem linearProjOfIsCompl_of_proj (f : E →ₗ[R] p) (hf : ∀ x : p, f x = x) :\n    p.linearProjOfIsCompl (ker f) (isCompl_of_proj hf) = f := by\n  ext x\n  have : x ∈ p ⊔ (ker f) := by simp only [(isCompl_of_proj hf).sup_eq_top, mem_top]\n  rcases mem_sup'.1 this with ⟨x, y, rfl⟩\n  simp [hf]\n\n"}
{"name":"LinearMap.coe_equivProdOfSurjectiveOfIsCompl","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁶ : Ring R\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module R E\nF : Type u_3\ninst✝³ : AddCommGroup F\ninst✝² : Module R F\nG : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : Module R G\nf : LinearMap (RingHom.id R) E F\ng : LinearMap (RingHom.id R) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\n⊢ Eq (↑(f.equivProdOfSurjectiveOfIsCompl g hf hg hfg)) (f.prod g)","decl":"@[simp]\ntheorem coe_equivProdOfSurjectiveOfIsCompl {f : E →ₗ[R] F} {g : E →ₗ[R] G} (hf : range f = ⊤)\n    (hg : range g = ⊤) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg : E →ₗ[R] F × G) = f.prod g := rfl\n\n"}
{"name":"LinearMap.equivProdOfSurjectiveOfIsCompl_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝⁶ : Ring R\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module R E\nF : Type u_3\ninst✝³ : AddCommGroup F\ninst✝² : Module R F\nG : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : Module R G\nf : LinearMap (RingHom.id R) E F\ng : LinearMap (RingHom.id R) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\nx : E\n⊢ Eq ((f.equivProdOfSurjectiveOfIsCompl g hf hg hfg) x) { fst := f x, snd := g x }","decl":"@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_apply {f : E →ₗ[R] F} {g : E →ₗ[R] G} (hf : range f = ⊤)\n    (hg : range g = ⊤) (hfg : IsCompl (ker f) (ker g)) (x : E) :\n    equivProdOfSurjectiveOfIsCompl f g hf hg hfg x = (f x, g x) := rfl\n\n"}
{"name":"Submodule.coe_isComplEquivProj_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nq : Subtype fun q => IsCompl p q\n⊢ Eq (↑(p.isComplEquivProj q)) (p.linearProjOfIsCompl ↑q ⋯)","decl":"@[simp]\ntheorem coe_isComplEquivProj_apply (q : { q // IsCompl p q }) :\n    (p.isComplEquivProj q : E →ₗ[R] p) = linearProjOfIsCompl p q q.2 := rfl\n\n"}
{"name":"Submodule.coe_isComplEquivProj_symm_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : Subtype fun f => ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ Eq (↑(p.isComplEquivProj.symm f)) (LinearMap.ker ↑f)","decl":"@[simp]\ntheorem coe_isComplEquivProj_symm_apply (f : { f : E →ₗ[R] p // ∀ x : p, f x = x }) :\n    (p.isComplEquivProj.symm f : Submodule R E) = ker (f : E →ₗ[R] p) := rfl\n\n"}
{"name":"Submodule.isIdempotentElemEquiv_symm_apply_coe","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : Subtype fun f => ∀ (x : Subtype fun x => Membership.mem p x), Eq (f ↑x) x\n⊢ Eq (↑(p.isIdempotentElemEquiv.symm f)) (p.subtype.comp ↑f)","decl":"/-- The idempotent endomorphisms of a module with range equal to a submodule are in 1-1\ncorrespondence with linear maps to the submodule that restrict to the identity on the submodule. -/\n@[simps] def isIdempotentElemEquiv :\n    { f : Module.End R E // IsIdempotentElem f ∧ range f = p } ≃\n    { f : E →ₗ[R] p // ∀ x : p, f x = x } where\n  toFun f := ⟨f.1.codRestrict _ fun x ↦ by simp_rw [← f.2.2]; exact mem_range_self f.1 x,\n    fun ⟨x, hx⟩ ↦ Subtype.ext <| by\n      obtain ⟨x, rfl⟩ := f.2.2.symm ▸ hx\n      exact DFunLike.congr_fun f.2.1 x⟩\n  invFun f := ⟨p.subtype ∘ₗ f.1, LinearMap.ext fun x ↦ by simp [f.2], le_antisymm\n    ((range_comp_le_range _ _).trans_eq p.range_subtype)\n    fun x hx ↦ ⟨x, Subtype.ext_iff.1 <| f.2 ⟨x, hx⟩⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Submodule.isIdempotentElemEquiv_apply_coe","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : Subtype fun f => And (IsIdempotentElem f) (Eq (LinearMap.range f) p)\n⊢ Eq (↑(p.isIdempotentElemEquiv f)) (LinearMap.codRestrict p ↑f ⋯)","decl":"/-- The idempotent endomorphisms of a module with range equal to a submodule are in 1-1\ncorrespondence with linear maps to the submodule that restrict to the identity on the submodule. -/\n@[simps] def isIdempotentElemEquiv :\n    { f : Module.End R E // IsIdempotentElem f ∧ range f = p } ≃\n    { f : E →ₗ[R] p // ∀ x : p, f x = x } where\n  toFun f := ⟨f.1.codRestrict _ fun x ↦ by simp_rw [← f.2.2]; exact mem_range_self f.1 x,\n    fun ⟨x, hx⟩ ↦ Subtype.ext <| by\n      obtain ⟨x, rfl⟩ := f.2.2.symm ▸ hx\n      exact DFunLike.congr_fun f.2.1 x⟩\n  invFun f := ⟨p.subtype ∘ₗ f.1, LinearMap.ext fun x ↦ by simp [f.2], le_antisymm\n    ((range_comp_le_range _ _).trans_eq p.range_subtype)\n    fun x hx ↦ ⟨x, Subtype.ext_iff.1 <| f.2 ⟨x, hx⟩⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"LinearMap.IsProj.map_id","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝³ : Semiring S\nM : Type u_6\ninst✝² : AddCommMonoid M\ninst✝¹ : Module S M\nm : Submodule S M\nF : Type u_7\ninst✝ : FunLike F M M\nf : F\nself : LinearMap.IsProj m f\nx : M\na✝ : Membership.mem m x\n⊢ Eq (f x) x","decl":"/--\nA linear endomorphism of a module `E` is a projection onto a submodule `p` if it sends every element\nof `E` to `p` and fixes every element of `p`.\nThe definition allow more generally any `FunLike` type and not just linear maps, so that it can be\nused for example with `ContinuousLinearMap` or `Matrix`.\n-/\nstructure IsProj {F : Type*} [FunLike F M M] (f : F) : Prop where\n  map_mem : ∀ x, f x ∈ m\n  map_id : ∀ x ∈ m, f x = x\n\n"}
{"name":"LinearMap.IsProj.map_mem","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝³ : Semiring S\nM : Type u_6\ninst✝² : AddCommMonoid M\ninst✝¹ : Module S M\nm : Submodule S M\nF : Type u_7\ninst✝ : FunLike F M M\nf : F\nself : LinearMap.IsProj m f\nx : M\n⊢ Membership.mem m (f x)","decl":"/--\nA linear endomorphism of a module `E` is a projection onto a submodule `p` if it sends every element\nof `E` to `p` and fixes every element of `p`.\nThe definition allow more generally any `FunLike` type and not just linear maps, so that it can be\nused for example with `ContinuousLinearMap` or `Matrix`.\n-/\nstructure IsProj {F : Type*} [FunLike F M M] (f : F) : Prop where\n  map_mem : ∀ x, f x ∈ m\n  map_id : ∀ x ∈ m, f x = x\n\n"}
{"name":"LinearMap.isProj_iff_isIdempotentElem","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝² : Semiring S\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\nf : LinearMap (RingHom.id S) M M\n⊢ Iff (Exists fun p => LinearMap.IsProj p f) (IsIdempotentElem f)","decl":"theorem isProj_iff_isIdempotentElem (f : M →ₗ[S] M) :\n    (∃ p : Submodule S M, IsProj p f) ↔ IsIdempotentElem f := by\n  constructor\n  · intro ⟨p, hp⟩\n    ext x\n    exact hp.map_id (f x) (hp.map_mem x)\n  · intro h\n    use range f\n    constructor\n    · intro x\n      exact mem_range_self f x\n    · intro x hx\n      obtain ⟨y, hy⟩ := mem_range.1 hx\n      rw [← hy, ← mul_apply, h]\n\n"}
{"name":"LinearMap.isProj_iff_idempotent","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝² : Semiring S\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\nf : LinearMap (RingHom.id S) M M\n⊢ Iff (Exists fun p => LinearMap.IsProj p f) (IsIdempotentElem f)","decl":"@[deprecated (since := \"2025-01-12\")] alias isProj_iff_idempotent := isProj_iff_isIdempotentElem\n\n"}
{"name":"LinearMap.IsProj.codRestrict_apply","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝² : Semiring S\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\nm : Submodule S M\nf : LinearMap (RingHom.id S) M M\nh : LinearMap.IsProj m f\nx : M\n⊢ Eq (↑(h.codRestrict x)) (f x)","decl":"@[simp]\ntheorem codRestrict_apply {f : M →ₗ[S] M} (h : IsProj m f) (x : M) : ↑(h.codRestrict x) = f x :=\n  f.codRestrict_apply m x\n\n"}
{"name":"LinearMap.IsProj.codRestrict_apply_cod","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝² : Semiring S\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\nm : Submodule S M\nf : LinearMap (RingHom.id S) M M\nh : LinearMap.IsProj m f\nx : Subtype fun x => Membership.mem m x\n⊢ Eq (h.codRestrict ↑x) x","decl":"@[simp]\ntheorem codRestrict_apply_cod {f : M →ₗ[S] M} (h : IsProj m f) (x : m) : h.codRestrict x = x := by\n  ext\n  rw [codRestrict_apply]\n  exact h.map_id x x.2\n\n"}
{"name":"LinearMap.IsProj.codRestrict_ker","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"S : Type u_5\ninst✝² : Semiring S\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\nm : Submodule S M\nf : LinearMap (RingHom.id S) M M\nh : LinearMap.IsProj m f\n⊢ Eq (LinearMap.ker h.codRestrict) (LinearMap.ker f)","decl":"theorem codRestrict_ker {f : M →ₗ[S] M} (h : IsProj m f) : ker h.codRestrict = ker f :=\n  f.ker_codRestrict m _\n\n"}
{"name":"LinearMap.IsProj.isCompl","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E E\nh : LinearMap.IsProj p f\n⊢ IsCompl p (LinearMap.ker f)","decl":"theorem isCompl {f : E →ₗ[R] E} (h : IsProj p f) : IsCompl p (ker f) := by\n  rw [← codRestrict_ker]\n  exact isCompl_of_proj h.codRestrict_apply_cod\n\n"}
{"name":"LinearMap.IsProj.eq_conj_prod_map'","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : Ring R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E E\nh : LinearMap.IsProj p f\n⊢ Eq f ((↑(p.prodEquivOfIsCompl (LinearMap.ker f) ⋯)).comp ((LinearMap.id.prodMap 0).comp ↑(p.prodEquivOfIsCompl (LinearMap.ker f) ⋯).symm))","decl":"theorem eq_conj_prod_map' {f : E →ₗ[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).toLinearMap ∘ₗ\n        prodMap id 0 ∘ₗ (p.prodEquivOfIsCompl (ker f) h.isCompl).symm.toLinearMap := by\n  rw [← LinearMap.comp_assoc, LinearEquiv.eq_comp_toLinearMap_symm]\n  ext x\n  · simp only [coe_prodEquivOfIsCompl, comp_apply, coe_inl, coprod_apply, coe_subtype,\n      _root_.map_zero, add_zero, h.map_id x x.2, prodMap_apply, id_apply]\n  · simp only [coe_prodEquivOfIsCompl, comp_apply, coe_inr, coprod_apply, _root_.map_zero,\n      coe_subtype, zero_add, map_coe_ker, prodMap_apply, zero_apply, add_zero]\n\n"}
{"name":"LinearMap.IsProj.eq_conj_prodMap","module":"Mathlib.LinearAlgebra.Projection","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module R E\np : Submodule R E\nf : LinearMap (RingHom.id R) E E\nh : LinearMap.IsProj p f\n⊢ Eq f ((p.prodEquivOfIsCompl (LinearMap.ker f) ⋯).conj (LinearMap.id.prodMap 0))","decl":"theorem IsProj.eq_conj_prodMap {f : E →ₗ[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).conj (prodMap id 0) := by\n  rw [LinearEquiv.conj_apply]\n  exact h.eq_conj_prod_map'\n\n"}
