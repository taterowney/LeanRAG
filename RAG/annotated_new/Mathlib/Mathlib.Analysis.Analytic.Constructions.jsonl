{"name":"hasFPowerSeriesOnBall_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\ne : E\n⊢ HasFPowerSeriesOnBall (fun x => c) (constFormalMultilinearSeries 𝕜 E c) e Top.top","decl":"theorem hasFPowerSeriesOnBall_const {c : F} {e : E} :\n    HasFPowerSeriesOnBall (fun _ => c) (constFormalMultilinearSeries 𝕜 E c) e ⊤ := by\n  refine ⟨by simp, WithTop.top_pos, fun _ => hasSum_single 0 fun n hn => ?_⟩\n  simp [constFormalMultilinearSeries_apply hn]\n\n"}
{"name":"hasFPowerSeriesAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\ne : E\n⊢ HasFPowerSeriesAt (fun x => c) (constFormalMultilinearSeries 𝕜 E c) e","decl":"theorem hasFPowerSeriesAt_const {c : F} {e : E} :\n    HasFPowerSeriesAt (fun _ => c) (constFormalMultilinearSeries 𝕜 E c) e :=\n  ⟨⊤, hasFPowerSeriesOnBall_const⟩\n\n"}
{"name":"analyticAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\nx : E\n⊢ AnalyticAt 𝕜 (fun x => v) x","decl":"@[fun_prop]\ntheorem analyticAt_const {v : F} {x : E} : AnalyticAt 𝕜 (fun _ => v) x :=\n  ⟨constFormalMultilinearSeries 𝕜 E v, hasFPowerSeriesAt_const⟩\n\n"}
{"name":"analyticOnNhd_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\ns : Set E\n⊢ AnalyticOnNhd 𝕜 (fun x => v) s","decl":"theorem analyticOnNhd_const {v : F} {s : Set E} : AnalyticOnNhd 𝕜 (fun _ => v) s :=\n  fun _ _ => analyticAt_const\n\n"}
{"name":"analyticWithinAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\ns : Set E\nx : E\n⊢ AnalyticWithinAt 𝕜 (fun x => v) s x","decl":"theorem analyticWithinAt_const {v : F} {s : Set E} {x : E} : AnalyticWithinAt 𝕜 (fun _ => v) s x :=\n  analyticAt_const.analyticWithinAt\n\n"}
{"name":"analyticOn_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\ns : Set E\n⊢ AnalyticOn 𝕜 (fun x => v) s","decl":"theorem analyticOn_const {v : F} {s : Set E} : AnalyticOn 𝕜 (fun _ => v) s :=\n  analyticOnNhd_const.analyticOn\n\n"}
{"name":"analyticWithinOn_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\ns : Set E\n⊢ AnalyticOn 𝕜 (fun x => v) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_const := analyticOn_const\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nhg : HasFPowerSeriesWithinOnBall g pg s x r\n⊢ HasFPowerSeriesWithinOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.add (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (hg : HasFPowerSeriesWithinOnBall g pg s x r) :\n    HasFPowerSeriesWithinOnBall (f + g) (pf + pg) s x r :=\n  { r_le := le_trans (le_min_iff.2 ⟨hf.r_le, hg.r_le⟩) (pf.min_radius_le_radius_add pg)\n    r_pos := hf.r_pos\n    hasSum := fun hy h'y => (hf.hasSum hy h'y).add (hg.hasSum hy h'y) }\n\n"}
{"name":"HasFPowerSeriesOnBall.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nhg : HasFPowerSeriesOnBall g pg x r\n⊢ HasFPowerSeriesOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) x r","decl":"theorem HasFPowerSeriesOnBall.add (hf : HasFPowerSeriesOnBall f pf x r)\n    (hg : HasFPowerSeriesOnBall g pg x r) : HasFPowerSeriesOnBall (f + g) (pf + pg) x r :=\n  { r_le := le_trans (le_min_iff.2 ⟨hf.r_le, hg.r_le⟩) (pf.min_radius_le_radius_add pg)\n    r_pos := hf.r_pos\n    hasSum := fun hy => (hf.hasSum hy).add (hg.hasSum hy) }\n\n"}
{"name":"HasFPowerSeriesWithinAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nhg : HasFPowerSeriesWithinAt g pg s x\n⊢ HasFPowerSeriesWithinAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) s x","decl":"theorem HasFPowerSeriesWithinAt.add\n    (hf : HasFPowerSeriesWithinAt f pf s x) (hg : HasFPowerSeriesWithinAt g pg s x) :\n    HasFPowerSeriesWithinAt (f + g) (pf + pg) s x := by\n  rcases (hf.eventually.and hg.eventually).exists with ⟨r, hr⟩\n  exact ⟨r, hr.1.add hr.2⟩\n\n"}
{"name":"HasFPowerSeriesAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nhg : HasFPowerSeriesAt g pg x\n⊢ HasFPowerSeriesAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) x","decl":"theorem HasFPowerSeriesAt.add (hf : HasFPowerSeriesAt f pf x) (hg : HasFPowerSeriesAt g pg x) :\n    HasFPowerSeriesAt (f + g) (pf + pg) x := by\n  rcases (hf.eventually.and hg.eventually).exists with ⟨r, hr⟩\n  exact ⟨r, hr.1.add hr.2⟩\n\n"}
{"name":"AnalyticWithinAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nhg : AnalyticWithinAt 𝕜 g s x\n⊢ AnalyticWithinAt 𝕜 (HAdd.hAdd f g) s x","decl":"theorem AnalyticWithinAt.add (hf : AnalyticWithinAt 𝕜 f s x) (hg : AnalyticWithinAt 𝕜 g s x) :\n    AnalyticWithinAt 𝕜 (f + g) s x :=\n  let ⟨_, hpf⟩ := hf\n  let ⟨_, hqf⟩ := hg\n  (hpf.add hqf).analyticWithinAt\n\n"}
{"name":"AnalyticAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\nhg : AnalyticAt 𝕜 g x\n⊢ AnalyticAt 𝕜 (HAdd.hAdd f g) x","decl":"@[fun_prop]\ntheorem AnalyticAt.add (hf : AnalyticAt 𝕜 f x) (hg : AnalyticAt 𝕜 g x) : AnalyticAt 𝕜 (f + g) x :=\n  let ⟨_, hpf⟩ := hf\n  let ⟨_, hqf⟩ := hg\n  (hpf.add hqf).analyticAt\n\n"}
{"name":"AnalyticAt.add'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\nhg : AnalyticAt 𝕜 g x\n⊢ AnalyticAt 𝕜 (fun z => HAdd.hAdd (f z) (g z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.add' (hf : AnalyticAt 𝕜 f x) (hg : AnalyticAt 𝕜 g x) :\n    AnalyticAt 𝕜 (fun z ↦ f z + g z) x :=\n  hf.add hg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\n⊢ HasFPowerSeriesWithinOnBall (Neg.neg f) (Neg.neg pf) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.neg (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (-f) (-pf) s x r :=\n  { r_le := by\n      rw [pf.radius_neg]\n      exact hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun hy h'y => (hf.hasSum hy h'y).neg }\n\n"}
{"name":"HasFPowerSeriesOnBall.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\n⊢ HasFPowerSeriesOnBall (Neg.neg f) (Neg.neg pf) x r","decl":"theorem HasFPowerSeriesOnBall.neg (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (-f) (-pf) x r :=\n  { r_le := by\n      rw [pf.radius_neg]\n      exact hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun hy => (hf.hasSum hy).neg }\n\n"}
{"name":"HasFPowerSeriesWithinAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\n⊢ HasFPowerSeriesWithinAt (Neg.neg f) (Neg.neg pf) s x","decl":"theorem HasFPowerSeriesWithinAt.neg (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (-f) (-pf) s x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.neg.hasFPowerSeriesWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f pf x\n⊢ HasFPowerSeriesAt (Neg.neg f) (Neg.neg pf) x","decl":"theorem HasFPowerSeriesAt.neg (hf : HasFPowerSeriesAt f pf x) : HasFPowerSeriesAt (-f) (-pf) x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.neg.hasFPowerSeriesAt\n\n"}
{"name":"AnalyticWithinAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\n⊢ AnalyticWithinAt 𝕜 (Neg.neg f) s x","decl":"theorem AnalyticWithinAt.neg (hf : AnalyticWithinAt 𝕜 f s x) : AnalyticWithinAt 𝕜 (-f) s x :=\n  let ⟨_, hpf⟩ := hf\n  hpf.neg.analyticWithinAt\n\n"}
{"name":"AnalyticAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (Neg.neg f) x","decl":"@[fun_prop]\ntheorem AnalyticAt.neg (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (-f) x :=\n  let ⟨_, hpf⟩ := hf\n  hpf.neg.analyticAt\n\n"}
{"name":"AnalyticAt.neg'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (fun z => Neg.neg (f z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.neg' (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (fun z ↦ -f z) x :=\n  hf.neg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nhg : HasFPowerSeriesWithinOnBall g pg s x r\n⊢ HasFPowerSeriesWithinOnBall (HSub.hSub f g) (HSub.hSub pf pg) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.sub (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (hg : HasFPowerSeriesWithinOnBall g pg s x r) :\n    HasFPowerSeriesWithinOnBall (f - g) (pf - pg) s x r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesOnBall.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nhg : HasFPowerSeriesOnBall g pg x r\n⊢ HasFPowerSeriesOnBall (HSub.hSub f g) (HSub.hSub pf pg) x r","decl":"theorem HasFPowerSeriesOnBall.sub (hf : HasFPowerSeriesOnBall f pf x r)\n    (hg : HasFPowerSeriesOnBall g pg x r) : HasFPowerSeriesOnBall (f - g) (pf - pg) x r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesWithinAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nhg : HasFPowerSeriesWithinAt g pg s x\n⊢ HasFPowerSeriesWithinAt (HSub.hSub f g) (HSub.hSub pf pg) s x","decl":"theorem HasFPowerSeriesWithinAt.sub\n    (hf : HasFPowerSeriesWithinAt f pf s x) (hg : HasFPowerSeriesWithinAt g pg s x) :\n    HasFPowerSeriesWithinAt (f - g) (pf - pg) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nhg : HasFPowerSeriesAt g pg x\n⊢ HasFPowerSeriesAt (HSub.hSub f g) (HSub.hSub pf pg) x","decl":"theorem HasFPowerSeriesAt.sub (hf : HasFPowerSeriesAt f pf x) (hg : HasFPowerSeriesAt g pg x) :\n    HasFPowerSeriesAt (f - g) (pf - pg) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticWithinAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nhg : AnalyticWithinAt 𝕜 g s x\n⊢ AnalyticWithinAt 𝕜 (HSub.hSub f g) s x","decl":"theorem AnalyticWithinAt.sub (hf : AnalyticWithinAt 𝕜 f s x) (hg : AnalyticWithinAt 𝕜 g s x) :\n    AnalyticWithinAt 𝕜 (f - g) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\nhg : AnalyticAt 𝕜 g x\n⊢ AnalyticAt 𝕜 (HSub.hSub f g) x","decl":"@[fun_prop]\ntheorem AnalyticAt.sub (hf : AnalyticAt 𝕜 f x) (hg : AnalyticAt 𝕜 g x) :\n    AnalyticAt 𝕜 (f - g) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticAt.sub'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\nhg : AnalyticAt 𝕜 g x\n⊢ AnalyticAt 𝕜 (fun z => HSub.hSub (f z) (g z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.sub' (hf : AnalyticAt 𝕜 f x) (hg : AnalyticAt 𝕜 g x) :\n    AnalyticAt 𝕜 (fun z ↦ f z - g z) x :=\n  hf.sub hg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nc : 𝕜\nhf : HasFPowerSeriesWithinOnBall f pf s x r\n⊢ HasFPowerSeriesWithinOnBall (HSMul.hSMul c f) (HSMul.hSMul c pf) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.const_smul (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (c • f) (c • pf) s x r where\n  r_le := le_trans hf.r_le pf.radius_le_smul\n  r_pos := hf.r_pos\n  hasSum := fun hy h'y => (hf.hasSum hy h'y).const_smul _\n\n"}
{"name":"HasFPowerSeriesOnBall.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nc : 𝕜\nhf : HasFPowerSeriesOnBall f pf x r\n⊢ HasFPowerSeriesOnBall (HSMul.hSMul c f) (HSMul.hSMul c pf) x r","decl":"theorem HasFPowerSeriesOnBall.const_smul (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (c • f) (c • pf) x r where\n  r_le := le_trans hf.r_le pf.radius_le_smul\n  r_pos := hf.r_pos\n  hasSum := fun hy => (hf.hasSum hy).const_smul _\n\n"}
{"name":"HasFPowerSeriesWithinAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nc : 𝕜\nhf : HasFPowerSeriesWithinAt f pf s x\n⊢ HasFPowerSeriesWithinAt (HSMul.hSMul c f) (HSMul.hSMul c pf) s x","decl":"theorem HasFPowerSeriesWithinAt.const_smul (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (c • f) (c • pf) s x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.const_smul.hasFPowerSeriesWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nc : 𝕜\nhf : HasFPowerSeriesAt f pf x\n⊢ HasFPowerSeriesAt (HSMul.hSMul c f) (HSMul.hSMul c pf) x","decl":"theorem HasFPowerSeriesAt.const_smul (hf : HasFPowerSeriesAt f pf x) :\n    HasFPowerSeriesAt (c • f) (c • pf) x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.const_smul.hasFPowerSeriesAt\n\n"}
{"name":"AnalyticWithinAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nc : 𝕜\nhf : AnalyticWithinAt 𝕜 f s x\n⊢ AnalyticWithinAt 𝕜 (HSMul.hSMul c f) s x","decl":"theorem AnalyticWithinAt.const_smul (hf : AnalyticWithinAt 𝕜 f s x) :\n    AnalyticWithinAt 𝕜 (c • f) s x :=\n  let ⟨_, hpf⟩ := hf\n  hpf.const_smul.analyticWithinAt\n\n"}
{"name":"AnalyticAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nc : 𝕜\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (HSMul.hSMul c f) x","decl":"@[fun_prop]\ntheorem AnalyticAt.const_smul (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (c • f) x :=\n  let ⟨_, hpf⟩ := hf\n  hpf.const_smul.analyticAt\n\n"}
{"name":"AnalyticAt.const_smul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nc : 𝕜\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (fun z => HSMul.hSMul c (f z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.const_smul' (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (fun z ↦ c • f z) x :=\n  hf.const_smul\n\n"}
{"name":"AnalyticOn.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (HAdd.hAdd f g) s","decl":"theorem AnalyticOn.add (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g s) :\n    AnalyticOn 𝕜 (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"AnalyticWithinOn.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (HAdd.hAdd f g) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.add := AnalyticOn.add\n\n"}
{"name":"AnalyticOnNhd.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOnNhd 𝕜 g s\n⊢ AnalyticOnNhd 𝕜 (HAdd.hAdd f g) s","decl":"theorem AnalyticOnNhd.add (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOnNhd 𝕜 g s) :\n    AnalyticOnNhd 𝕜 (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"AnalyticOn.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (Neg.neg f) s","decl":"theorem AnalyticOn.neg (hf : AnalyticOn 𝕜 f s) : AnalyticOn 𝕜 (-f) s :=\n  fun z hz ↦ (hf z hz).neg\n\n"}
{"name":"AnalyticWithinOn.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (Neg.neg f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.neg := AnalyticOn.neg\n\n"}
{"name":"AnalyticOnNhd.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (Neg.neg f) s","decl":"theorem AnalyticOnNhd.neg (hf : AnalyticOnNhd 𝕜 f s) : AnalyticOnNhd 𝕜 (-f) s :=\n  fun z hz ↦ (hf z hz).neg\n\n"}
{"name":"AnalyticOn.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (HSub.hSub f g) s","decl":"theorem AnalyticOn.sub (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g s) :\n    AnalyticOn 𝕜 (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"AnalyticWithinOn.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (HSub.hSub f g) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.sub := AnalyticOn.sub\n\n"}
{"name":"AnalyticOnNhd.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOnNhd 𝕜 g s\n⊢ AnalyticOnNhd 𝕜 (HSub.hSub f g) s","decl":"theorem AnalyticOnNhd.sub (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOnNhd 𝕜 g s) :\n    AnalyticOnNhd 𝕜 (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"FormalMultilinearSeries.radius_prod_eq_min","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 E G\n⊢ Eq (p.prod q).radius (Min.min p.radius q.radius)","decl":"/-- The radius of the Cartesian product of two formal series is the minimum of their radii. -/\nlemma FormalMultilinearSeries.radius_prod_eq_min\n    (p : FormalMultilinearSeries 𝕜 E F) (q : FormalMultilinearSeries 𝕜 E G) :\n    (p.prod q).radius = min p.radius q.radius := by\n  apply le_antisymm\n  · refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n    rw [le_min_iff]\n    have := (p.prod q).isLittleO_one_of_lt_radius hr\n    constructor\n    all_goals\n      apply FormalMultilinearSeries.le_radius_of_isBigO\n      refine (isBigO_of_le _ fun n ↦ ?_).trans this.isBigO\n      rw [norm_mul, norm_norm, norm_mul, norm_norm]\n      refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n      rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.opNorm_prod]\n    · apply le_max_left\n    · apply le_max_right\n  · refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n    rw [lt_min_iff] at hr\n    have := ((p.isLittleO_one_of_lt_radius hr.1).add\n      (q.isLittleO_one_of_lt_radius hr.2)).isBigO\n    refine (p.prod q).le_radius_of_isBigO ((isBigO_of_le _ fun n ↦ ?_).trans this)\n    rw [norm_mul, norm_norm, ← add_mul, norm_mul]\n    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n    rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.opNorm_prod]\n    refine (max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)).trans ?_\n    apply Real.le_norm_self\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\nr s : ENNReal\nt : Set E\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 E G\nhf : HasFPowerSeriesWithinOnBall f p t e r\nhg : HasFPowerSeriesWithinOnBall g q t e s\n⊢ HasFPowerSeriesWithinOnBall (fun x => { fst := f x, snd := g x }) (p.prod q) t e (Min.min r s)","decl":"lemma HasFPowerSeriesWithinOnBall.prod {e : E} {f : E → F} {g : E → G} {r s : ℝ≥0∞} {t : Set E}\n    {p : FormalMultilinearSeries 𝕜 E F} {q : FormalMultilinearSeries 𝕜 E G}\n    (hf : HasFPowerSeriesWithinOnBall f p t e r) (hg : HasFPowerSeriesWithinOnBall g q t e s) :\n    HasFPowerSeriesWithinOnBall (fun x ↦ (f x, g x)) (p.prod q) t e (min r s) where\n  r_le := by\n    rw [p.radius_prod_eq_min]\n    exact min_le_min hf.r_le hg.r_le\n  r_pos := lt_min hf.r_pos hg.r_pos\n  hasSum := by\n    intro y h'y hy\n    simp_rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.prod_apply]\n    refine (hf.hasSum h'y ?_).prod_mk (hg.hasSum h'y ?_)\n    · exact EMetric.mem_ball.mpr (lt_of_lt_of_le hy (min_le_left _ _))\n    · exact EMetric.mem_ball.mpr (lt_of_lt_of_le hy (min_le_right _ _))\n\n"}
{"name":"HasFPowerSeriesOnBall.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\nr s : ENNReal\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 E G\nhf : HasFPowerSeriesOnBall f p e r\nhg : HasFPowerSeriesOnBall g q e s\n⊢ HasFPowerSeriesOnBall (fun x => { fst := f x, snd := g x }) (p.prod q) e (Min.min r s)","decl":"lemma HasFPowerSeriesOnBall.prod {e : E} {f : E → F} {g : E → G} {r s : ℝ≥0∞}\n    {p : FormalMultilinearSeries 𝕜 E F} {q : FormalMultilinearSeries 𝕜 E G}\n    (hf : HasFPowerSeriesOnBall f p e r) (hg : HasFPowerSeriesOnBall g q e s) :\n    HasFPowerSeriesOnBall (fun x ↦ (f x, g x)) (p.prod q) e (min r s) := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf hg ⊢\n  exact hf.prod hg\n\n"}
{"name":"HasFPowerSeriesWithinAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\ns : Set E\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 E G\nhf : HasFPowerSeriesWithinAt f p s e\nhg : HasFPowerSeriesWithinAt g q s e\n⊢ HasFPowerSeriesWithinAt (fun x => { fst := f x, snd := g x }) (p.prod q) s e","decl":"lemma HasFPowerSeriesWithinAt.prod {e : E} {f : E → F} {g : E → G} {s : Set E}\n    {p : FormalMultilinearSeries 𝕜 E F} {q : FormalMultilinearSeries 𝕜 E G}\n    (hf : HasFPowerSeriesWithinAt f p s e) (hg : HasFPowerSeriesWithinAt g q s e) :\n    HasFPowerSeriesWithinAt (fun x ↦ (f x, g x)) (p.prod q) s e := by\n  rcases hf with ⟨_, hf⟩\n  rcases hg with ⟨_, hg⟩\n  exact ⟨_, hf.prod hg⟩\n\n"}
{"name":"HasFPowerSeriesAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 E G\nhf : HasFPowerSeriesAt f p e\nhg : HasFPowerSeriesAt g q e\n⊢ HasFPowerSeriesAt (fun x => { fst := f x, snd := g x }) (p.prod q) e","decl":"lemma HasFPowerSeriesAt.prod {e : E} {f : E → F} {g : E → G}\n    {p : FormalMultilinearSeries 𝕜 E F} {q : FormalMultilinearSeries 𝕜 E G}\n    (hf : HasFPowerSeriesAt f p e) (hg : HasFPowerSeriesAt g q e) :\n    HasFPowerSeriesAt (fun x ↦ (f x, g x)) (p.prod q) e := by\n  rcases hf with ⟨_, hf⟩\n  rcases hg with ⟨_, hg⟩\n  exact ⟨_, hf.prod hg⟩\n\n"}
{"name":"AnalyticWithinAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\ns : Set E\nhf : AnalyticWithinAt 𝕜 f s e\nhg : AnalyticWithinAt 𝕜 g s e\n⊢ AnalyticWithinAt 𝕜 (fun x => { fst := f x, snd := g x }) s e","decl":"/-- The Cartesian product of analytic functions is analytic. -/\nlemma AnalyticWithinAt.prod {e : E} {f : E → F} {g : E → G} {s : Set E}\n    (hf : AnalyticWithinAt 𝕜 f s e) (hg : AnalyticWithinAt 𝕜 g s e) :\n    AnalyticWithinAt 𝕜 (fun x ↦ (f x, g x)) s e := by\n  rcases hf with ⟨_, hf⟩\n  rcases hg with ⟨_, hg⟩\n  exact ⟨_, hf.prod hg⟩\n\n"}
{"name":"AnalyticAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ne : E\nf : E → F\ng : E → G\nhf : AnalyticAt 𝕜 f e\nhg : AnalyticAt 𝕜 g e\n⊢ AnalyticAt 𝕜 (fun x => { fst := f x, snd := g x }) e","decl":"/-- The Cartesian product of analytic functions is analytic. -/\n@[fun_prop]\nlemma AnalyticAt.prod {e : E} {f : E → F} {g : E → G}\n    (hf : AnalyticAt 𝕜 f e) (hg : AnalyticAt 𝕜 g e) :\n    AnalyticAt 𝕜 (fun x ↦ (f x, g x)) e := by\n  rcases hf with ⟨_, hf⟩\n  rcases hg with ⟨_, hg⟩\n  exact ⟨_, hf.prod hg⟩\n\n"}
{"name":"AnalyticOn.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : E → G\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => { fst := f x, snd := g x }) s","decl":"/-- The Cartesian product of analytic functions within a set is analytic. -/\nlemma AnalyticOn.prod {f : E → F} {g : E → G} {s : Set E}\n    (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g s) :\n    AnalyticOn 𝕜 (fun x ↦ (f x, g x)) s :=\n  fun x hx ↦ (hf x hx).prod (hg x hx)\n\n"}
{"name":"AnalyticWithinOn.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : E → G\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => { fst := f x, snd := g x }) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.prod := AnalyticOn.prod\n\n"}
{"name":"AnalyticOnNhd.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : E → G\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOnNhd 𝕜 g s\n⊢ AnalyticOnNhd 𝕜 (fun x => { fst := f x, snd := g x }) s","decl":"/-- The Cartesian product of analytic functions is analytic. -/\nlemma AnalyticOnNhd.prod {f : E → F} {g : E → G} {s : Set E}\n    (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOnNhd 𝕜 g s) :\n    AnalyticOnNhd 𝕜 (fun x ↦ (f x, g x)) s :=\n  fun x hx ↦ (hf x hx).prod (hg x hx)\n\n"}
{"name":"AnalyticAt.comp₂","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\nx : E\nha : AnalyticAt 𝕜 h { fst := f x, snd := g x }\nfa : AnalyticAt 𝕜 f x\nga : AnalyticAt 𝕜 g x\n⊢ AnalyticAt 𝕜 (fun x => h { fst := f x, snd := g x }) x","decl":"/-- `AnalyticAt.comp` for functions on product spaces -/\ntheorem AnalyticAt.comp₂ {h : F × G → H} {f : E → F} {g : E → G} {x : E}\n    (ha : AnalyticAt 𝕜 h (f x, g x)) (fa : AnalyticAt 𝕜 f x)\n    (ga : AnalyticAt 𝕜 g x) :\n    AnalyticAt 𝕜 (fun x ↦ h (f x, g x)) x :=\n  AnalyticAt.comp ha (fa.prod ga)\n\n"}
{"name":"AnalyticWithinAt.comp₂","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\ns : Set (Prod F G)\nt : Set E\nx : E\nha : AnalyticWithinAt 𝕜 h s { fst := f x, snd := g x }\nfa : AnalyticWithinAt 𝕜 f t x\nga : AnalyticWithinAt 𝕜 g t x\nhf : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\n⊢ AnalyticWithinAt 𝕜 (fun x => h { fst := f x, snd := g x }) t x","decl":"/-- `AnalyticWithinAt.comp` for functions on product spaces -/\ntheorem AnalyticWithinAt.comp₂ {h : F × G → H} {f : E → F} {g : E → G} {s : Set (F × G)}\n    {t : Set E} {x : E}\n    (ha : AnalyticWithinAt 𝕜 h s (f x, g x)) (fa : AnalyticWithinAt 𝕜 f t x)\n    (ga : AnalyticWithinAt 𝕜 g t x) (hf : Set.MapsTo (fun y ↦ (f y, g y)) t s) :\n    AnalyticWithinAt 𝕜 (fun x ↦ h (f x, g x)) t x :=\n  AnalyticWithinAt.comp ha (fa.prod ga) hf\n\n"}
{"name":"AnalyticAt.comp₂_analyticWithinAt","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\nx : E\ns : Set E\nha : AnalyticAt 𝕜 h { fst := f x, snd := g x }\nfa : AnalyticWithinAt 𝕜 f s x\nga : AnalyticWithinAt 𝕜 g s x\n⊢ AnalyticWithinAt 𝕜 (fun x => h { fst := f x, snd := g x }) s x","decl":"/-- `AnalyticAt.comp_analyticWithinAt` for functions on product spaces -/\ntheorem AnalyticAt.comp₂_analyticWithinAt\n    {h : F × G → H} {f : E → F} {g : E → G} {x : E} {s : Set E}\n    (ha : AnalyticAt 𝕜 h (f x, g x)) (fa : AnalyticWithinAt 𝕜 f s x)\n    (ga : AnalyticWithinAt 𝕜 g s x) :\n    AnalyticWithinAt 𝕜 (fun x ↦ h (f x, g x)) s x :=\n  AnalyticAt.comp_analyticWithinAt ha (fa.prod ga)\n\n"}
{"name":"AnalyticOnNhd.comp₂","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOnNhd 𝕜 h s\nfa : AnalyticOnNhd 𝕜 f t\nga : AnalyticOnNhd 𝕜 g t\nm : ∀ (x : E), Membership.mem t x → Membership.mem s { fst := f x, snd := g x }\n⊢ AnalyticOnNhd 𝕜 (fun x => h { fst := f x, snd := g x }) t","decl":"/-- `AnalyticOnNhd.comp` for functions on product spaces -/\ntheorem AnalyticOnNhd.comp₂ {h : F × G → H} {f : E → F} {g : E → G} {s : Set (F × G)} {t : Set E}\n    (ha : AnalyticOnNhd 𝕜 h s) (fa : AnalyticOnNhd 𝕜 f t) (ga : AnalyticOnNhd 𝕜 g t)\n    (m : ∀ x, x ∈ t → (f x, g x) ∈ s) : AnalyticOnNhd 𝕜 (fun x ↦ h (f x, g x)) t :=\n  fun _ xt ↦ (ha _ (m _ xt)).comp₂ (fa _ xt) (ga _ xt)\n\n"}
{"name":"AnalyticOn.comp₂","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOn 𝕜 h s\nfa : AnalyticOn 𝕜 f t\nga : AnalyticOn 𝕜 g t\nm : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\n⊢ AnalyticOn 𝕜 (fun x => h { fst := f x, snd := g x }) t","decl":"/-- `AnalyticOn.comp` for functions on product spaces -/\ntheorem AnalyticOn.comp₂ {h : F × G → H} {f : E → F} {g : E → G} {s : Set (F × G)}\n    {t : Set E}\n    (ha : AnalyticOn 𝕜 h s) (fa : AnalyticOn 𝕜 f t)\n    (ga : AnalyticOn 𝕜 g t) (m : Set.MapsTo (fun y ↦ (f y, g y)) t s) :\n    AnalyticOn 𝕜 (fun x ↦ h (f x, g x)) t :=\n  fun x hx ↦ (ha _ (m hx)).comp₂ (fa x hx) (ga x hx) m\n\n"}
{"name":"AnalyticWithinOn.comp₂","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nh : Prod F G → H\nf : E → F\ng : E → G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOn 𝕜 h s\nfa : AnalyticOn 𝕜 f t\nga : AnalyticOn 𝕜 g t\nm : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\n⊢ AnalyticOn 𝕜 (fun x => h { fst := f x, snd := g x }) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.comp₂ := AnalyticOn.comp₂\n\n"}
{"name":"AnalyticAt.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\np : Prod E F\nfa : AnalyticAt 𝕜 f p\n⊢ AnalyticAt 𝕜 (fun x => f { fst := x, snd := p.2 }) p.1","decl":"/-- Analytic functions on products are analytic in the first coordinate -/\ntheorem AnalyticAt.curry_left {f : E × F → G} {p : E × F} (fa : AnalyticAt 𝕜 f p) :\n    AnalyticAt 𝕜 (fun x ↦ f (x, p.2)) p.1 :=\n  AnalyticAt.comp₂ fa analyticAt_id analyticAt_const\n"}
{"name":"AnalyticAt.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\np : Prod E F\nfa : AnalyticAt 𝕜 f p\n⊢ AnalyticAt 𝕜 (fun x => f { fst := x, snd := p.2 }) p.1","decl":"alias AnalyticAt.along_fst := AnalyticAt.curry_left\n\n"}
{"name":"AnalyticWithinAt.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\np : Prod E F\nfa : AnalyticWithinAt 𝕜 f s p\n⊢ AnalyticWithinAt 𝕜 (fun x => f { fst := x, snd := p.2 }) (setOf fun x => Membership.mem s { fst := x, snd := p.2 }) p.1","decl":"theorem AnalyticWithinAt.curry_left\n    {f : E × F → G} {s : Set (E × F)} {p : E × F} (fa : AnalyticWithinAt 𝕜 f s p) :\n    AnalyticWithinAt 𝕜 (fun x ↦ f (x, p.2)) {x | (x, p.2) ∈ s} p.1 :=\n  AnalyticWithinAt.comp₂ fa analyticWithinAt_id analyticWithinAt_const (fun _ hx ↦ hx)\n\n"}
{"name":"AnalyticAt.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\np : Prod E F\nfa : AnalyticAt 𝕜 f p\n⊢ AnalyticAt 𝕜 (fun y => f { fst := p.1, snd := y }) p.2","decl":"/-- Analytic functions on products are analytic in the second coordinate -/\ntheorem AnalyticAt.curry_right {f : E × F → G} {p : E × F} (fa : AnalyticAt 𝕜 f p) :\n    AnalyticAt 𝕜 (fun y ↦ f (p.1, y)) p.2 :=\n  AnalyticAt.comp₂ fa analyticAt_const analyticAt_id\n"}
{"name":"AnalyticAt.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\np : Prod E F\nfa : AnalyticAt 𝕜 f p\n⊢ AnalyticAt 𝕜 (fun y => f { fst := p.1, snd := y }) p.2","decl":"alias AnalyticAt.along_snd := AnalyticAt.curry_right\n\n"}
{"name":"AnalyticWithinAt.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\np : Prod E F\nfa : AnalyticWithinAt 𝕜 f s p\n⊢ AnalyticWithinAt 𝕜 (fun y => f { fst := p.1, snd := y }) (setOf fun y => Membership.mem s { fst := p.1, snd := y }) p.2","decl":"theorem AnalyticWithinAt.curry_right\n    {f : E × F → G} {s : Set (E × F)} {p : E × F} (fa : AnalyticWithinAt 𝕜 f s p) :\n    AnalyticWithinAt 𝕜 (fun y ↦ f (p.1, y)) {y | (p.1, y) ∈ s} p.2 :=\n  AnalyticWithinAt.comp₂ fa  analyticWithinAt_const analyticWithinAt_id (fun _ hx ↦ hx)\n\n"}
{"name":"AnalyticOnNhd.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"/-- Analytic functions on products are analytic in the first coordinate -/\ntheorem AnalyticOnNhd.curry_left {f : E × F → G} {s : Set (E × F)} {y : F}\n    (fa : AnalyticOnNhd 𝕜 f s) :\n    AnalyticOnNhd 𝕜 (fun x ↦ f (x, y)) {x | (x, y) ∈ s} :=\n  fun x m ↦ (fa (x, y) m).curry_left\n"}
{"name":"AnalyticOnNhd.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"alias AnalyticOnNhd.along_fst := AnalyticOnNhd.curry_left\n\n"}
{"name":"AnalyticOn.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.along_fst := AnalyticOnNhd.curry_left\n\n"}
{"name":"AnalyticOn.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"theorem AnalyticOn.curry_left\n    {f : E × F → G} {s : Set (E × F)} {y : F} (fa : AnalyticOn 𝕜 f s) :\n    AnalyticOn 𝕜 (fun x ↦ f (x, y)) {x | (x, y) ∈ s} :=\n  fun x m ↦ (fa (x, y) m).curry_left\n\n"}
{"name":"AnalyticWithinOn.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.curry_left := AnalyticOn.curry_left\n\n"}
{"name":"AnalyticOnNhd.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"/-- Analytic functions on products are analytic in the second coordinate -/\ntheorem AnalyticOnNhd.curry_right {f : E × F → G} {x : E} {s : Set (E × F)}\n    (fa : AnalyticOnNhd 𝕜 f s) :\n    AnalyticOnNhd 𝕜 (fun y ↦ f (x, y)) {y | (x, y) ∈ s} :=\n  fun y m ↦ (fa (x, y) m).curry_right\n"}
{"name":"AnalyticOnNhd.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"alias AnalyticOnNhd.along_snd := AnalyticOnNhd.curry_right\n\n"}
{"name":"AnalyticOn.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.along_snd := AnalyticOnNhd.curry_right\n\n"}
{"name":"AnalyticOn.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"theorem AnalyticOn.curry_right\n    {f : E × F → G} {x : E} {s : Set (E × F)} (fa : AnalyticOn 𝕜 f s) :\n    AnalyticOn 𝕜 (fun y ↦ f (x, y)) {y | (x, y) ∈ s} :=\n  fun y m ↦ (fa (x, y) m).curry_right\n\n"}
{"name":"AnalyticWithinOn.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.curry_right := AnalyticOn.curry_right\n\n"}
{"name":"FormalMultilinearSeries.radius_pi_le","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\ni : ι\n⊢ LE.le (FormalMultilinearSeries.pi p).radius (p i).radius","decl":"lemma FormalMultilinearSeries.radius_pi_le (p : Π i, FormalMultilinearSeries 𝕜 E (Fm i)) (i : ι) :\n    (FormalMultilinearSeries.pi p).radius ≤ (p i).radius := by\n  apply le_of_forall_nnreal_lt (fun r' hr' ↦ ?_)\n  obtain ⟨C, -, hC⟩ : ∃ C > 0, ∀ n, ‖pi p n‖ * ↑r' ^ n ≤ C := norm_mul_pow_le_of_lt_radius _ hr'\n  apply le_radius_of_bound _ C (fun n ↦ ?_)\n  apply le_trans _ (hC n)\n  gcongr\n  rw [pi, ContinuousMultilinearMap.opNorm_pi]\n  exact norm_le_pi_norm (fun i ↦ p i n) i\n\n"}
{"name":"FormalMultilinearSeries.le_radius_pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nr : ENNReal\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nh : ∀ (i : ι), LE.le r (p i).radius\n⊢ LE.le r (FormalMultilinearSeries.pi p).radius","decl":"lemma FormalMultilinearSeries.le_radius_pi (h : ∀ i, r ≤ (p i).radius) :\n    r ≤ (FormalMultilinearSeries.pi p).radius := by\n  apply le_of_forall_nnreal_lt (fun r' hr' ↦ ?_)\n  have I i : ∃ C > 0, ∀ n, ‖p i n‖ * (r' : ℝ) ^ n ≤ C :=\n    norm_mul_pow_le_of_lt_radius _ (hr'.trans_le (h i))\n  choose C C_pos hC using I\n  obtain ⟨D, D_nonneg, hD⟩ : ∃ D ≥ 0, ∀ i, C i ≤ D :=\n    ⟨∑ i, C i, Finset.sum_nonneg (fun i _ ↦ (C_pos i).le),\n      fun i ↦ Finset.single_le_sum (fun j _ ↦ (C_pos j).le) (Finset.mem_univ _)⟩\n  apply le_radius_of_bound _ D (fun n ↦ ?_)\n  rcases le_or_lt ((r' : ℝ)^n) 0 with hr' | hr'\n  · exact le_trans (mul_nonpos_of_nonneg_of_nonpos (by positivity) hr') D_nonneg\n  · simp only [pi]\n    rw [← le_div_iff₀ hr', ContinuousMultilinearMap.opNorm_pi,\n      pi_norm_le_iff_of_nonneg (by positivity)]\n    intro i\n    exact (le_div_iff₀ hr').2 ((hC i n).trans (hD i))\n\n"}
{"name":"FormalMultilinearSeries.radius_pi_eq_iInf","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\n⊢ Eq (FormalMultilinearSeries.pi p).radius (iInf fun i => (p i).radius)","decl":"lemma FormalMultilinearSeries.radius_pi_eq_iInf :\n    (FormalMultilinearSeries.pi p).radius = ⨅ i, (p i).radius := by\n  refine le_antisymm (by simp [radius_pi_le]) ?_\n  apply le_of_forall_nnreal_lt (fun r' hr' ↦ ?_)\n  exact le_radius_pi (fun i ↦ le_iInf_iff.1 hr'.le i)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nr : ENNReal\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhf : ∀ (i : ι), HasFPowerSeriesWithinOnBall (f i) (p i) s e r\nhr : LT.lt 0 r\n⊢ HasFPowerSeriesWithinOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e r","decl":"/-- If each function in a finite family has a power series within a ball, then so does the\nfamily as a whole. Note that the positivity assumption on the radius is only needed when\nthe family is empty. -/\nlemma HasFPowerSeriesWithinOnBall.pi\n    (hf : ∀ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r) (hr : 0 < r) :\n    HasFPowerSeriesWithinOnBall (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) s e r where\n  r_le := by\n    apply FormalMultilinearSeries.le_radius_pi (fun i ↦ ?_)\n    exact (hf i).r_le\n  r_pos := hr\n  hasSum {_} m hy := Pi.hasSum.2 (fun i ↦ (hf i).hasSum m hy)\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nr : ENNReal\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhr : LT.lt 0 r\n⊢ Iff (HasFPowerSeriesWithinOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e r) (∀ (i : ι), HasFPowerSeriesWithinOnBall (f i) (p i) s e r)","decl":"lemma hasFPowerSeriesWithinOnBall_pi_iff (hr : 0 < r) :\n    HasFPowerSeriesWithinOnBall (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) s e r ↔\n      ∀ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r where\n  mp h i :=\n    ⟨h.r_le.trans (FormalMultilinearSeries.radius_pi_le _ _), hr,\n      fun m hy ↦ Pi.hasSum.1 (h.hasSum m hy) i⟩\n  mpr h := .pi h hr\n\n"}
{"name":"HasFPowerSeriesOnBall.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\nr : ENNReal\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhf : ∀ (i : ι), HasFPowerSeriesOnBall (f i) (p i) e r\nhr : LT.lt 0 r\n⊢ HasFPowerSeriesOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e r","decl":"lemma HasFPowerSeriesOnBall.pi\n    (hf : ∀ i, HasFPowerSeriesOnBall (f i) (p i) e r) (hr : 0 < r) :\n    HasFPowerSeriesOnBall (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) e r := by\n  simp_rw [← hasFPowerSeriesWithinOnBall_univ] at hf ⊢\n  exact HasFPowerSeriesWithinOnBall.pi hf hr\n\n"}
{"name":"hasFPowerSeriesOnBall_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\nr : ENNReal\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhr : LT.lt 0 r\n⊢ Iff (HasFPowerSeriesOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e r) (∀ (i : ι), HasFPowerSeriesOnBall (f i) (p i) e r)","decl":"lemma hasFPowerSeriesOnBall_pi_iff (hr : 0 < r) :\n    HasFPowerSeriesOnBall (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) e r ↔\n      ∀ i, HasFPowerSeriesOnBall (f i) (p i) e r := by\n  simp_rw [← hasFPowerSeriesWithinOnBall_univ]\n  exact hasFPowerSeriesWithinOnBall_pi_iff hr\n\n"}
{"name":"HasFPowerSeriesWithinAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhf : ∀ (i : ι), HasFPowerSeriesWithinAt (f i) (p i) s e\n⊢ HasFPowerSeriesWithinAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e","decl":"lemma HasFPowerSeriesWithinAt.pi\n    (hf : ∀ i, HasFPowerSeriesWithinAt (f i) (p i) s e) :\n    HasFPowerSeriesWithinAt (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) s e := by\n  have : ∀ᶠ r in 𝓝[>] 0, ∀ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r :=\n    eventually_all.mpr (fun i ↦ (hf i).eventually)\n  obtain ⟨r, hr, r_pos⟩ := (this.and self_mem_nhdsWithin).exists\n  exact ⟨r, HasFPowerSeriesWithinOnBall.pi hr r_pos⟩\n\n"}
{"name":"hasFPowerSeriesWithinAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\n⊢ Iff (HasFPowerSeriesWithinAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e) (∀ (i : ι), HasFPowerSeriesWithinAt (f i) (p i) s e)","decl":"lemma hasFPowerSeriesWithinAt_pi_iff :\n    HasFPowerSeriesWithinAt (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) s e ↔\n      ∀ i, HasFPowerSeriesWithinAt (f i) (p i) s e := by\n  refine ⟨fun h i ↦ ?_, fun h ↦ .pi h⟩\n  obtain ⟨r, hr⟩ := h\n  exact ⟨r, (hasFPowerSeriesWithinOnBall_pi_iff hr.r_pos).1 hr i⟩\n\n"}
{"name":"HasFPowerSeriesAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\nhf : ∀ (i : ι), HasFPowerSeriesAt (f i) (p i) e\n⊢ HasFPowerSeriesAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e","decl":"lemma HasFPowerSeriesAt.pi\n    (hf : ∀ i, HasFPowerSeriesAt (f i) (p i) e) :\n    HasFPowerSeriesAt (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) e := by\n  simp_rw [← hasFPowerSeriesWithinAt_univ] at hf ⊢\n  exact HasFPowerSeriesWithinAt.pi hf\n\n"}
{"name":"hasFPowerSeriesAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\np : (i : ι) → FormalMultilinearSeries 𝕜 E (Fm i)\n⊢ Iff (HasFPowerSeriesAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e) (∀ (i : ι), HasFPowerSeriesAt (f i) (p i) e)","decl":"lemma hasFPowerSeriesAt_pi_iff :\n    HasFPowerSeriesAt (fun x ↦ (f · x)) (FormalMultilinearSeries.pi p) e ↔\n      ∀ i, HasFPowerSeriesAt (f i) (p i) e := by\n  simp_rw [← hasFPowerSeriesWithinAt_univ]\n  exact hasFPowerSeriesWithinAt_pi_iff\n\n"}
{"name":"AnalyticWithinAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nhf : ∀ (i : ι), AnalyticWithinAt 𝕜 (f i) s e\n⊢ AnalyticWithinAt 𝕜 (fun x x_1 => f x_1 x) s e","decl":"lemma AnalyticWithinAt.pi (hf : ∀ i, AnalyticWithinAt 𝕜 (f i) s e) :\n    AnalyticWithinAt 𝕜 (fun x ↦ (f · x)) s e := by\n  choose p hp using hf\n  exact ⟨FormalMultilinearSeries.pi p, HasFPowerSeriesWithinAt.pi hp⟩\n\n"}
{"name":"analyticWithinAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\n⊢ Iff (AnalyticWithinAt 𝕜 (fun x x_1 => f x_1 x) s e) (∀ (i : ι), AnalyticWithinAt 𝕜 (f i) s e)","decl":"lemma analyticWithinAt_pi_iff :\n    AnalyticWithinAt 𝕜 (fun x ↦ (f · x)) s e ↔ ∀ i, AnalyticWithinAt 𝕜 (f i) s e := by\n  refine ⟨fun h i ↦ ?_, fun h ↦ .pi h⟩\n  exact ((ContinuousLinearMap.proj (R := 𝕜) i).analyticAt _).comp_analyticWithinAt h\n\n"}
{"name":"AnalyticAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\nhf : ∀ (i : ι), AnalyticAt 𝕜 (f i) e\n⊢ AnalyticAt 𝕜 (fun x x_1 => f x_1 x) e","decl":"lemma AnalyticAt.pi (hf : ∀ i, AnalyticAt 𝕜 (f i) e) :\n    AnalyticAt 𝕜 (fun x ↦ (f · x)) e := by\n  simp_rw [← analyticWithinAt_univ] at hf ⊢\n  exact AnalyticWithinAt.pi hf\n\n"}
{"name":"analyticAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\ne : E\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\n⊢ Iff (AnalyticAt 𝕜 (fun x x_1 => f x_1 x) e) (∀ (i : ι), AnalyticAt 𝕜 (f i) e)","decl":"lemma analyticAt_pi_iff :\n    AnalyticAt 𝕜 (fun x ↦ (f · x)) e ↔ ∀ i, AnalyticAt 𝕜 (f i) e := by\n  simp_rw [← analyticWithinAt_univ]\n  exact analyticWithinAt_pi_iff\n\n"}
{"name":"AnalyticOn.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nhf : ∀ (i : ι), AnalyticOn 𝕜 (f i) s\n⊢ AnalyticOn 𝕜 (fun x x_1 => f x_1 x) s","decl":"lemma AnalyticOn.pi (hf : ∀ i, AnalyticOn 𝕜 (f i) s) :\n    AnalyticOn 𝕜 (fun x ↦ (f · x)) s :=\n  fun x hx ↦ AnalyticWithinAt.pi (fun i ↦ hf i x hx)\n\n"}
{"name":"AnalyticWithinOn.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nhf : ∀ (i : ι), AnalyticOn 𝕜 (f i) s\n⊢ AnalyticOn 𝕜 (fun x x_1 => f x_1 x) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.pi := AnalyticOn.pi\n\n"}
{"name":"analyticOn_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\n⊢ Iff (AnalyticOn 𝕜 (fun x x_1 => f x_1 x) s) (∀ (i : ι), AnalyticOn 𝕜 (f i) s)","decl":"lemma analyticOn_pi_iff :\n    AnalyticOn 𝕜 (fun x ↦ (f · x)) s ↔ ∀ i, AnalyticOn 𝕜 (f i) s :=\n  ⟨fun h i x hx ↦ analyticWithinAt_pi_iff.1 (h x hx) i, fun h ↦ .pi h⟩\n\n"}
{"name":"analyticWithinOn_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\n⊢ Iff (AnalyticOn 𝕜 (fun x x_1 => f x_1 x) s) (∀ (i : ι), AnalyticOn 𝕜 (f i) s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_pi_iff := analyticOn_pi_iff\n\n"}
{"name":"AnalyticOnNhd.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\nhf : ∀ (i : ι), AnalyticOnNhd 𝕜 (f i) s\n⊢ AnalyticOnNhd 𝕜 (fun x x_1 => f x_1 x) s","decl":"lemma AnalyticOnNhd.pi (hf : ∀ i, AnalyticOnNhd 𝕜 (f i) s) :\n    AnalyticOnNhd 𝕜 (fun x ↦ (f · x)) s :=\n  fun x hx ↦ AnalyticAt.pi (fun i ↦ hf i x hx)\n\n"}
{"name":"analyticOnNhd_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nFm : ι → Type u_10\ninst✝¹ : (i : ι) → NormedAddCommGroup (Fm i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (Fm i)\nf : (i : ι) → E → Fm i\ns : Set E\n⊢ Iff (AnalyticOnNhd 𝕜 (fun x x_1 => f x_1 x) s) (∀ (i : ι), AnalyticOnNhd 𝕜 (f i) s)","decl":"lemma analyticOnNhd_pi_iff :\n    AnalyticOnNhd 𝕜 (fun x ↦ (f · x)) s ↔ ∀ i, AnalyticOnNhd 𝕜 (f i) s :=\n  ⟨fun h i x hx ↦ analyticAt_pi_iff.1 (h x hx) i, fun h ↦ .pi h⟩\n\n"}
{"name":"analyticAt_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 E\ninst✝ : IsScalarTower 𝕜 𝕝 E\nz : Prod 𝕝 E\n⊢ AnalyticAt 𝕜 (fun x => HSMul.hSMul x.1 x.2) z","decl":"/-- Scalar multiplication is analytic (jointly in both variables). The statement is a little\npedantic to allow towers of field extensions.\n\nTODO: can we replace `𝕜'` with a \"normed module\" in such a way that `analyticAt_mul` is a special\ncase of this? -/\n@[fun_prop]\nlemma analyticAt_smul [NormedSpace 𝕝 E] [IsScalarTower 𝕜 𝕝 E] (z : 𝕝 × E) :\n    AnalyticAt 𝕜 (fun x : 𝕝 × E ↦ x.1 • x.2) z :=\n  (ContinuousLinearMap.lsmul 𝕜 𝕝).analyticAt_bilinear z\n\n"}
{"name":"analyticAt_mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nz : Prod A A\n⊢ AnalyticAt 𝕜 (fun x => HMul.hMul x.1 x.2) z","decl":"/-- Multiplication in a normed algebra over `𝕜` is analytic. -/\n@[fun_prop]\nlemma analyticAt_mul (z : A × A) : AnalyticAt 𝕜 (fun x : A × A ↦ x.1 * x.2) z :=\n  (ContinuousLinearMap.mul 𝕜 A).analyticAt_bilinear z\n\n"}
{"name":"AnalyticWithinAt.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\ns : Set E\nz : E\nhf : AnalyticWithinAt 𝕜 f s z\nhg : AnalyticWithinAt 𝕜 g s z\n⊢ AnalyticWithinAt 𝕜 (fun x => HSMul.hSMul (f x) (g x)) s z","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticWithinAt.smul [NormedSpace 𝕝 F] [IsScalarTower 𝕜 𝕝 F]\n    {f : E → 𝕝} {g : E → F} {s : Set E} {z : E}\n    (hf : AnalyticWithinAt 𝕜 f s z) (hg : AnalyticWithinAt 𝕜 g s z) :\n    AnalyticWithinAt 𝕜 (fun x ↦ f x • g x) s z :=\n  (analyticAt_smul _).comp₂_analyticWithinAt hf hg\n\n"}
{"name":"AnalyticAt.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\nz : E\nhf : AnalyticAt 𝕜 f z\nhg : AnalyticAt 𝕜 g z\n⊢ AnalyticAt 𝕜 (HSMul.hSMul f g) z","decl":"/-- Scalar multiplication of one analytic function by another. -/\n@[fun_prop]\nlemma AnalyticAt.smul [NormedSpace 𝕝 F] [IsScalarTower 𝕜 𝕝 F] {f : E → 𝕝} {g : E → F} {z : E}\n    (hf : AnalyticAt 𝕜 f z) (hg : AnalyticAt 𝕜 g z) :\n    AnalyticAt 𝕜 (f • g) z :=\n  (analyticAt_smul _).comp₂ hf hg\n\n"}
{"name":"AnalyticAt.smul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\nz : E\nhf : AnalyticAt 𝕜 f z\nhg : AnalyticAt 𝕜 g z\n⊢ AnalyticAt 𝕜 (fun x => HSMul.hSMul (f x) (g x)) z","decl":"/-- Scalar multiplication of one analytic function by another. -/\n@[fun_prop]\nlemma AnalyticAt.smul' [NormedSpace 𝕝 F] [IsScalarTower 𝕜 𝕝 F] {f : E → 𝕝} {g : E → F} {z : E}\n    (hf : AnalyticAt 𝕜 f z) (hg : AnalyticAt 𝕜 g z) :\n    AnalyticAt 𝕜 (fun x ↦ f x • g x) z :=\n  hf.smul hg\n\n"}
{"name":"AnalyticOn.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticOn.smul [NormedSpace 𝕝 F] [IsScalarTower 𝕜 𝕝 F]\n    {f : E → 𝕝} {g : E → F} {s : Set E}\n    (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g s) :\n    AnalyticOn 𝕜 (fun x ↦ f x • g x) s :=\n  fun _ m ↦ (hf _ m).smul (hg _ m)\n\n"}
{"name":"AnalyticWithinOn.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => HSMul.hSMul (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.smul := AnalyticOn.smul\n\n"}
{"name":"AnalyticOnNhd.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕝 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕝\ninst✝² : NormedAlgebra 𝕜 𝕝\ninst✝¹ : NormedSpace 𝕝 F\ninst✝ : IsScalarTower 𝕜 𝕝 F\nf : E → 𝕝\ng : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOnNhd 𝕜 g s\n⊢ AnalyticOnNhd 𝕜 (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticOnNhd.smul [NormedSpace 𝕝 F] [IsScalarTower 𝕜 𝕝 F] {f : E → 𝕝} {g : E → F} {s : Set E}\n    (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOnNhd 𝕜 g s) :\n    AnalyticOnNhd 𝕜 (fun x ↦ f x • g x) s :=\n  fun _ m ↦ (hf _ m).smul (hg _ m)\n\n"}
{"name":"AnalyticWithinAt.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\ns : Set E\nz : E\nhf : AnalyticWithinAt 𝕜 f s z\nhg : AnalyticWithinAt 𝕜 g s z\n⊢ AnalyticWithinAt 𝕜 (fun x => HMul.hMul (f x) (g x)) s z","decl":"/-- Multiplication of analytic functions (valued in a normed `𝕜`-algebra) is analytic. -/\nlemma AnalyticWithinAt.mul {f g : E → A} {s : Set E} {z : E}\n    (hf : AnalyticWithinAt 𝕜 f s z) (hg : AnalyticWithinAt 𝕜 g s z) :\n    AnalyticWithinAt 𝕜 (fun x ↦ f x * g x) s z :=\n  (analyticAt_mul _).comp₂_analyticWithinAt hf hg\n\n"}
{"name":"AnalyticAt.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\nz : E\nhf : AnalyticAt 𝕜 f z\nhg : AnalyticAt 𝕜 g z\n⊢ AnalyticAt 𝕜 (HMul.hMul f g) z","decl":"/-- Multiplication of analytic functions (valued in a normed `𝕜`-algebra) is analytic. -/\n@[fun_prop]\nlemma AnalyticAt.mul {f g : E → A} {z : E} (hf : AnalyticAt 𝕜 f z) (hg : AnalyticAt 𝕜 g z) :\n    AnalyticAt 𝕜 (f * g) z :=\n  (analyticAt_mul _).comp₂ hf hg\n\n"}
{"name":"AnalyticAt.mul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\nz : E\nhf : AnalyticAt 𝕜 f z\nhg : AnalyticAt 𝕜 g z\n⊢ AnalyticAt 𝕜 (fun x => HMul.hMul (f x) (g x)) z","decl":"@[fun_prop]\nlemma AnalyticAt.mul' {f g : E → A} {z : E} (hf : AnalyticAt 𝕜 f z) (hg : AnalyticAt 𝕜 g z) :\n    AnalyticAt 𝕜 (fun x ↦ f x * g x) z :=\n  hf.mul hg\n\n"}
{"name":"AnalyticOn.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- Multiplication of analytic functions (valued in a normed `𝕜`-algebra) is analytic. -/\nlemma AnalyticOn.mul {f g : E → A} {s : Set E}\n    (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g s) :\n    AnalyticOn 𝕜 (fun x ↦ f x * g x) s :=\n  fun _ m ↦ (hf _ m).mul (hg _ m)\n\n"}
{"name":"AnalyticWithinOn.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g s\n⊢ AnalyticOn 𝕜 (fun x => HMul.hMul (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.mul := AnalyticOn.mul\n\n"}
{"name":"AnalyticOnNhd.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOnNhd 𝕜 g s\n⊢ AnalyticOnNhd 𝕜 (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- Multiplication of analytic functions (valued in a normed `𝕜`-algebra) is analytic. -/\nlemma AnalyticOnNhd.mul {f g : E → A} {s : Set E}\n    (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOnNhd 𝕜 g s) :\n    AnalyticOnNhd 𝕜 (fun x ↦ f x * g x) s :=\n  fun _ m ↦ (hf _ m).mul (hg _ m)\n\n"}
{"name":"AnalyticWithinAt.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : E → A\nz : E\ns : Set E\nhf : AnalyticWithinAt 𝕜 f s z\nn : Nat\n⊢ AnalyticWithinAt 𝕜 (fun x => HPow.hPow (f x) n) s z","decl":"/-- Powers of analytic functions (into a normed `𝕜`-algebra) are analytic. -/\nlemma AnalyticWithinAt.pow {f : E → A} {z : E} {s : Set E} (hf : AnalyticWithinAt 𝕜 f s z) (n : ℕ) :\n    AnalyticWithinAt 𝕜 (fun x ↦ f x ^ n) s z := by\n  induction n with\n  | zero =>\n    simp only [pow_zero]\n    apply analyticWithinAt_const\n  | succ m hm =>\n    simp only [pow_succ]\n    exact hm.mul hf\n\n"}
{"name":"AnalyticAt.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : E → A\nz : E\nhf : AnalyticAt 𝕜 f z\nn : Nat\n⊢ AnalyticAt 𝕜 (fun x => HPow.hPow (f x) n) z","decl":"/-- Powers of analytic functions (into a normed `𝕜`-algebra) are analytic. -/\n@[fun_prop]\nlemma AnalyticAt.pow {f : E → A} {z : E} (hf : AnalyticAt 𝕜 f z) (n : ℕ) :\n    AnalyticAt 𝕜 (fun x ↦ f x ^ n) z := by\n  rw [← analyticWithinAt_univ] at hf ⊢\n  exact hf.pow n\n\n"}
{"name":"AnalyticOn.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : E → A\ns : Set E\nhf : AnalyticOn 𝕜 f s\nn : Nat\n⊢ AnalyticOn 𝕜 (fun x => HPow.hPow (f x) n) s","decl":"/-- Powers of analytic functions (into a normed `𝕜`-algebra) are analytic. -/\nlemma AnalyticOn.pow {f : E → A} {s : Set E} (hf : AnalyticOn 𝕜 f s) (n : ℕ) :\n    AnalyticOn 𝕜 (fun x ↦ f x ^ n) s :=\n  fun _ m ↦ (hf _ m).pow n\n\n"}
{"name":"AnalyticWithinOn.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : E → A\ns : Set E\nhf : AnalyticOn 𝕜 f s\nn : Nat\n⊢ AnalyticOn 𝕜 (fun x => HPow.hPow (f x) n) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.pow := AnalyticOn.pow\n\n"}
{"name":"AnalyticOnNhd.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_8\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : E → A\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nn : Nat\n⊢ AnalyticOnNhd 𝕜 (fun x => HPow.hPow (f x) n) s","decl":"/-- Powers of analytic functions (into a normed `𝕜`-algebra) are analytic. -/\nlemma AnalyticOnNhd.pow {f : E → A} {s : Set E} (hf : AnalyticOnNhd 𝕜 f s) (n : ℕ) :\n    AnalyticOnNhd 𝕜 (fun x ↦ f x ^ n) s :=\n  fun _ m ↦ (hf _ m).pow n\n\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\np : FormalMultilinearSeries 𝕜' E F\nx : E\ns : Set E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ HasFPowerSeriesWithinOnBall f (FormalMultilinearSeries.restrictScalars 𝕜 p) s x r","decl":"lemma HasFPowerSeriesWithinOnBall.restrictScalars (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    HasFPowerSeriesWithinOnBall f (p.restrictScalars 𝕜) s x r :=\n  ⟨hf.r_le.trans (FormalMultilinearSeries.radius_le_of_le (fun n ↦ by simp)), hf.r_pos, hf.hasSum⟩\n\n"}
{"name":"HasFPowerSeriesOnBall.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\np : FormalMultilinearSeries 𝕜' E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ HasFPowerSeriesOnBall f (FormalMultilinearSeries.restrictScalars 𝕜 p) x r","decl":"lemma HasFPowerSeriesOnBall.restrictScalars (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall f (p.restrictScalars 𝕜) x r :=\n  ⟨hf.r_le.trans (FormalMultilinearSeries.radius_le_of_le (fun n ↦ by simp)), hf.r_pos, hf.hasSum⟩\n\n"}
{"name":"HasFPowerSeriesWithinAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\np : FormalMultilinearSeries 𝕜' E F\nx : E\ns : Set E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ HasFPowerSeriesWithinAt f (FormalMultilinearSeries.restrictScalars 𝕜 p) s x","decl":"lemma HasFPowerSeriesWithinAt.restrictScalars (hf : HasFPowerSeriesWithinAt f p s x) :\n    HasFPowerSeriesWithinAt f (p.restrictScalars 𝕜) s x := by\n  rcases hf with ⟨r, hr⟩\n  exact ⟨r, hr.restrictScalars⟩\n\n"}
{"name":"HasFPowerSeriesAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\np : FormalMultilinearSeries 𝕜' E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ HasFPowerSeriesAt f (FormalMultilinearSeries.restrictScalars 𝕜 p) x","decl":"lemma HasFPowerSeriesAt.restrictScalars (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesAt f (p.restrictScalars 𝕜) x := by\n  rcases hf with ⟨r, hr⟩\n  exact ⟨r, hr.restrictScalars⟩\n\n"}
{"name":"AnalyticWithinAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\nx : E\ns : Set E\nhf : AnalyticWithinAt 𝕜' f s x\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"lemma AnalyticWithinAt.restrictScalars (hf : AnalyticWithinAt 𝕜' f s x) :\n    AnalyticWithinAt 𝕜 f s x := by\n  rcases hf with ⟨p, hp⟩\n  exact ⟨p.restrictScalars 𝕜, hp.restrictScalars⟩\n\n"}
{"name":"AnalyticAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\nx : E\nhf : AnalyticAt 𝕜' f x\n⊢ AnalyticAt 𝕜 f x","decl":"lemma AnalyticAt.restrictScalars (hf : AnalyticAt 𝕜' f x) :\n    AnalyticAt 𝕜 f x := by\n  rcases hf with ⟨p, hp⟩\n  exact ⟨p.restrictScalars 𝕜, hp.restrictScalars⟩\n\n"}
{"name":"AnalyticOn.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\ns : Set E\nhf : AnalyticOn 𝕜' f s\n⊢ AnalyticOn 𝕜 f s","decl":"lemma AnalyticOn.restrictScalars (hf : AnalyticOn 𝕜' f s) :\n    AnalyticOn 𝕜 f s :=\n  fun x hx ↦ (hf x hx).restrictScalars\n\n"}
{"name":"AnalyticOnNhd.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜' f s\n⊢ AnalyticOnNhd 𝕜 f s","decl":"lemma AnalyticOnNhd.restrictScalars (hf : AnalyticOnNhd 𝕜' f s) :\n    AnalyticOnNhd 𝕜 f s :=\n  fun x hx ↦ (hf x hx).restrictScalars\n\n"}
{"name":"formalMultilinearSeries_geometric_eq_ofScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\nA : Type u_10\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ Eq (formalMultilinearSeries_geometric 𝕜 A) (FormalMultilinearSeries.ofScalars A fun x => 1)","decl":"/-- The geometric series as an `ofScalars` series. -/\ntheorem formalMultilinearSeries_geometric_eq_ofScalars :\n    formalMultilinearSeries_geometric 𝕜 A =\n      FormalMultilinearSeries.ofScalars A fun _ ↦ (1 : 𝕜) := by\n  simp_rw [FormalMultilinearSeries.ext_iff, FormalMultilinearSeries.ofScalars,\n    formalMultilinearSeries_geometric, one_smul, implies_true]\n\n"}
{"name":"formalMultilinearSeries_geometric_apply_norm_le","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\nA : Type u_10\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nn : Nat\n⊢ LE.le (Norm.norm (formalMultilinearSeries_geometric 𝕜 A n)) (Max.max 1 (Norm.norm 1))","decl":"lemma formalMultilinearSeries_geometric_apply_norm_le (n : ℕ) :\n    ‖formalMultilinearSeries_geometric 𝕜 A n‖ ≤ max 1 ‖(1 : A)‖ :=\n  ContinuousMultilinearMap.norm_mkPiAlgebraFin_le\n\n"}
{"name":"formalMultilinearSeries_geometric_apply_norm","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\nA : Type u_10\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : NormOneClass A\nn : Nat\n⊢ Eq (Norm.norm (formalMultilinearSeries_geometric 𝕜 A n)) 1","decl":"lemma formalMultilinearSeries_geometric_apply_norm [NormOneClass A] (n : ℕ) :\n    ‖formalMultilinearSeries_geometric 𝕜 A n‖ = 1 :=\n  ContinuousMultilinearMap.norm_mkPiAlgebraFin\n\n"}
{"name":"one_le_formalMultilinearSeries_geometric_radius","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝² : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ LE.le 1 (formalMultilinearSeries_geometric 𝕜 A).radius","decl":"lemma one_le_formalMultilinearSeries_geometric_radius (𝕜 : Type*) [NontriviallyNormedField 𝕜]\n    (A : Type*) [NormedRing A] [NormedAlgebra 𝕜 A] :\n    1 ≤ (formalMultilinearSeries_geometric 𝕜 A).radius := by\n  convert formalMultilinearSeries_geometric_eq_ofScalars 𝕜 A ▸\n    FormalMultilinearSeries.ofScalars_radius_ge_inv_of_tendsto A _ one_ne_zero (by simp) |>.le\n  simp\n\n"}
{"name":"formalMultilinearSeries_geometric_radius","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝³ : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝² : NormedRing A\ninst✝¹ : NormOneClass A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ Eq (formalMultilinearSeries_geometric 𝕜 A).radius 1","decl":"lemma formalMultilinearSeries_geometric_radius (𝕜 : Type*) [NontriviallyNormedField 𝕜]\n    (A : Type*) [NormedRing A] [NormOneClass A] [NormedAlgebra 𝕜 A] :\n    (formalMultilinearSeries_geometric 𝕜 A).radius = 1 :=\n  formalMultilinearSeries_geometric_eq_ofScalars 𝕜 A ▸\n    FormalMultilinearSeries.ofScalars_radius_eq_of_tendsto A _ one_ne_zero (by simp)\n\n"}
{"name":"hasFPowerSeriesOnBall_inverse_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝³ : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : HasSummableGeomSeries A\n⊢ HasFPowerSeriesOnBall (fun x => Ring.inverse (HSub.hSub 1 x)) (formalMultilinearSeries_geometric 𝕜 A) 0 1","decl":"lemma hasFPowerSeriesOnBall_inverse_one_sub\n    (𝕜 : Type*) [NontriviallyNormedField 𝕜]\n    (A : Type*) [NormedRing A] [NormedAlgebra 𝕜 A] [HasSummableGeomSeries A] :\n    HasFPowerSeriesOnBall (fun x : A ↦ Ring.inverse (1 - x))\n      (formalMultilinearSeries_geometric 𝕜 A) 0 1 := by\n  constructor\n  · exact one_le_formalMultilinearSeries_geometric_radius 𝕜 A\n  · exact one_pos\n  · intro y hy\n    simp only [EMetric.mem_ball, edist_dist, dist_zero_right, ofReal_lt_one] at hy\n    simp only [zero_add, NormedRing.inverse_one_sub _ hy, Units.oneSub, Units.inv_mk,\n      formalMultilinearSeries_geometric, ContinuousMultilinearMap.mkPiAlgebraFin_apply,\n      List.ofFn_const, List.prod_replicate]\n    exact (summable_geometric_of_norm_lt_one hy).hasSum\n\n"}
{"name":"analyticAt_inverse_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝³ : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : HasSummableGeomSeries A\n⊢ AnalyticAt 𝕜 (fun x => Ring.inverse (HSub.hSub 1 x)) 0","decl":"@[fun_prop]\nlemma analyticAt_inverse_one_sub (𝕜 : Type*) [NontriviallyNormedField 𝕜]\n    (A : Type*) [NormedRing A] [NormedAlgebra 𝕜 A] [HasSummableGeomSeries A] :\n    AnalyticAt 𝕜 (fun x : A ↦ Ring.inverse (1 - x)) 0 :=\n  ⟨_, ⟨_, hasFPowerSeriesOnBall_inverse_one_sub 𝕜 A⟩⟩\n\n"}
{"name":"analyticAt_inverse","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝³ : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : HasSummableGeomSeries A\nz : Units A\n⊢ AnalyticAt 𝕜 Ring.inverse ↑z","decl":"/-- If `A` is a normed algebra over `𝕜` with summable geometric series, then inversion on `A` is\nanalytic at any unit. -/\n@[fun_prop]\nlemma analyticAt_inverse {𝕜 : Type*} [NontriviallyNormedField 𝕜]\n    {A : Type*} [NormedRing A] [NormedAlgebra 𝕜 A] [HasSummableGeomSeries A] (z : Aˣ) :\n    AnalyticAt 𝕜 Ring.inverse (z : A) := by\n  rcases subsingleton_or_nontrivial A with hA|hA\n  · convert analyticAt_const (v := (0 : A))\n  · let f1 : A → A := fun a ↦ a * z.inv\n    let f2 : A → A := fun b ↦ Ring.inverse (1 - b)\n    let f3 : A → A := fun c ↦ 1 - z.inv * c\n    have feq : ∀ᶠ y in 𝓝 (z : A), (f1 ∘ f2 ∘ f3) y = Ring.inverse y := by\n      have : Metric.ball (z : A) (‖(↑z⁻¹ : A)‖⁻¹) ∈ 𝓝 (z : A) := by\n        apply Metric.ball_mem_nhds\n        simp\n      filter_upwards [this] with y hy\n      simp only [Metric.mem_ball, dist_eq_norm] at hy\n      have : y = Units.ofNearby z y hy := rfl\n      rw [this, Eq.comm]\n      simp only [Ring.inverse_unit, Function.comp_apply]\n      simp [Units.ofNearby, f1, f2, f3, Units.add, _root_.mul_sub]\n      rw [← Ring.inverse_unit]\n      congr\n      simp\n    apply AnalyticAt.congr _ feq\n    apply (analyticAt_id.mul analyticAt_const).comp\n    apply AnalyticAt.comp\n    · simp only [Units.inv_eq_val_inv, Units.inv_mul, sub_self, f2, f3]\n      exact analyticAt_inverse_one_sub 𝕜 A\n    · exact analyticAt_const.sub (analyticAt_const.mul analyticAt_id)\n\n"}
{"name":"analyticOnNhd_inverse","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\ninst✝³ : NontriviallyNormedField 𝕜\nA : Type u_10\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : HasSummableGeomSeries A\n⊢ AnalyticOnNhd 𝕜 Ring.inverse (setOf fun x => IsUnit x)","decl":"lemma analyticOnNhd_inverse {𝕜 : Type*} [NontriviallyNormedField 𝕜]\n    {A : Type*} [NormedRing A] [NormedAlgebra 𝕜 A] [HasSummableGeomSeries A] :\n    AnalyticOnNhd 𝕜 Ring.inverse {x : A | IsUnit x} :=\n  fun _ hx ↦ analyticAt_inverse (IsUnit.unit hx)\n\n"}
{"name":"hasFPowerSeriesOnBall_inv_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_9\n𝕝 : Type u_10\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\n⊢ HasFPowerSeriesOnBall (fun x => Inv.inv (HSub.hSub 1 x)) (formalMultilinearSeries_geometric 𝕜 𝕝) 0 1","decl":"lemma hasFPowerSeriesOnBall_inv_one_sub\n    (𝕜 𝕝 : Type*) [NontriviallyNormedField 𝕜] [NontriviallyNormedField 𝕝] [NormedAlgebra 𝕜 𝕝] :\n    HasFPowerSeriesOnBall (fun x : 𝕝 ↦ (1 - x)⁻¹) (formalMultilinearSeries_geometric 𝕜 𝕝) 0 1 := by\n  convert hasFPowerSeriesOnBall_inverse_one_sub 𝕜 𝕝\n  exact Ring.inverse_eq_inv'.symm\n\n"}
{"name":"analyticAt_inv_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\n𝕝 : Type u_9\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\n⊢ AnalyticAt 𝕜 (fun x => Inv.inv (HSub.hSub 1 x)) 0","decl":"@[fun_prop]\nlemma analyticAt_inv_one_sub (𝕝 : Type*) [NontriviallyNormedField 𝕝] [NormedAlgebra 𝕜 𝕝] :\n    AnalyticAt 𝕜 (fun x : 𝕝 ↦ (1 - x)⁻¹) 0 :=\n  ⟨_, ⟨_, hasFPowerSeriesOnBall_inv_one_sub 𝕜 𝕝⟩⟩\n\n"}
{"name":"analyticAt_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nz : 𝕝\nhz : Ne z 0\n⊢ AnalyticAt 𝕜 Inv.inv z","decl":"/-- If `𝕝` is a normed field extension of `𝕜`, then the inverse map `𝕝 → 𝕝` is `𝕜`-analytic\naway from 0. -/\n@[fun_prop]\nlemma analyticAt_inv {z : 𝕝} (hz : z ≠ 0) : AnalyticAt 𝕜 Inv.inv z := by\n  convert analyticAt_inverse (𝕜 := 𝕜) (Units.mk0 _ hz)\n  exact Ring.inverse_eq_inv'.symm\n\n"}
{"name":"analyticOnNhd_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\n⊢ AnalyticOnNhd 𝕜 (fun z => Inv.inv z) (setOf fun z => Ne z 0)","decl":"/-- `x⁻¹` is analytic away from zero -/\nlemma analyticOnNhd_inv : AnalyticOnNhd 𝕜 (fun z ↦ z⁻¹) {z : 𝕝 | z ≠ 0} := by\n  intro z m; exact analyticAt_inv m\n\n"}
{"name":"analyticOn_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\n⊢ AnalyticOn 𝕜 (fun z => Inv.inv z) (setOf fun z => Ne z 0)","decl":"lemma analyticOn_inv : AnalyticOn 𝕜 (fun z ↦ z⁻¹) {z : 𝕝 | z ≠ 0} :=\n  analyticOnNhd_inv.analyticOn\n\n"}
{"name":"AnalyticWithinAt.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\nx : E\ns : Set E\nfa : AnalyticWithinAt 𝕜 f s x\nf0 : Ne (f x) 0\n⊢ AnalyticWithinAt 𝕜 (fun x => Inv.inv (f x)) s x","decl":"/-- `(f x)⁻¹` is analytic away from `f x = 0` -/\ntheorem AnalyticWithinAt.inv {f : E → 𝕝} {x : E} {s : Set E}\n    (fa : AnalyticWithinAt 𝕜 f s x) (f0 : f x ≠ 0) :\n    AnalyticWithinAt 𝕜 (fun x ↦ (f x)⁻¹) s x :=\n  (analyticAt_inv f0).comp_analyticWithinAt fa\n\n"}
{"name":"AnalyticAt.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\nx : E\nfa : AnalyticAt 𝕜 f x\nf0 : Ne (f x) 0\n⊢ AnalyticAt 𝕜 (Inv.inv f) x","decl":"/-- `(f x)⁻¹` is analytic away from `f x = 0` -/\n@[fun_prop]\ntheorem AnalyticAt.inv {f : E → 𝕝} {x : E} (fa : AnalyticAt 𝕜 f x) (f0 : f x ≠ 0) :\n    AnalyticAt 𝕜 f⁻¹ x :=\n  (analyticAt_inv f0).comp fa\n\n"}
{"name":"AnalyticAt.inv'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\nx : E\nfa : AnalyticAt 𝕜 f x\nf0 : Ne (f x) 0\n⊢ AnalyticAt 𝕜 (fun x => Inv.inv (f x)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.inv' {f : E → 𝕝} {x : E} (fa : AnalyticAt 𝕜 f x) (f0 : f x ≠ 0) :\n    AnalyticAt 𝕜 (fun x ↦ (f x)⁻¹) x :=\n  fa.inv f0\n\n"}
{"name":"AnalyticOn.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\ns : Set E\nfa : AnalyticOn 𝕜 f s\nf0 : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ AnalyticOn 𝕜 (fun x => Inv.inv (f x)) s","decl":"/-- `(f x)⁻¹` is analytic away from `f x = 0` -/\ntheorem AnalyticOn.inv {f : E → 𝕝} {s : Set E}\n    (fa : AnalyticOn 𝕜 f s) (f0 : ∀ x ∈ s, f x ≠ 0) :\n    AnalyticOn 𝕜 (fun x ↦ (f x)⁻¹) s :=\n  fun x m ↦ (fa x m).inv (f0 x m)\n\n"}
{"name":"AnalyticWithinOn.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\ns : Set E\nfa : AnalyticOn 𝕜 f s\nf0 : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ AnalyticOn 𝕜 (fun x => Inv.inv (f x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.inv := AnalyticOn.inv\n\n"}
{"name":"AnalyticOnNhd.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf : E → 𝕝\ns : Set E\nfa : AnalyticOnNhd 𝕜 f s\nf0 : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ AnalyticOnNhd 𝕜 (fun x => Inv.inv (f x)) s","decl":"/-- `(f x)⁻¹` is analytic away from `f x = 0` -/\ntheorem AnalyticOnNhd.inv {f : E → 𝕝} {s : Set E}\n    (fa : AnalyticOnNhd 𝕜 f s) (f0 : ∀ x ∈ s, f x ≠ 0) :\n    AnalyticOnNhd 𝕜 (fun x ↦ (f x)⁻¹) s :=\n  fun x m ↦ (fa x m).inv (f0 x m)\n\n"}
{"name":"AnalyticWithinAt.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\ns : Set E\nx : E\nfa : AnalyticWithinAt 𝕜 f s x\nga : AnalyticWithinAt 𝕜 g s x\ng0 : Ne (g x) 0\n⊢ AnalyticWithinAt 𝕜 (fun x => HDiv.hDiv (f x) (g x)) s x","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticWithinAt.div {f g : E → 𝕝} {s : Set E} {x : E}\n    (fa : AnalyticWithinAt 𝕜 f s x) (ga : AnalyticWithinAt 𝕜 g s x) (g0 : g x ≠ 0) :\n    AnalyticWithinAt 𝕜 (fun x ↦ f x / g x) s x := by\n  simp_rw [div_eq_mul_inv]; exact fa.mul (ga.inv g0)\n\n"}
{"name":"AnalyticAt.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\nx : E\nfa : AnalyticAt 𝕜 f x\nga : AnalyticAt 𝕜 g x\ng0 : Ne (g x) 0\n⊢ AnalyticAt 𝕜 (HDiv.hDiv f g) x","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\n@[fun_prop]\ntheorem AnalyticAt.div {f g : E → 𝕝} {x : E}\n    (fa : AnalyticAt 𝕜 f x) (ga : AnalyticAt 𝕜 g x) (g0 : g x ≠ 0) :\n    AnalyticAt 𝕜 (f / g) x := by\n  simp_rw [div_eq_mul_inv]; exact fa.mul (ga.inv g0)\n\n"}
{"name":"AnalyticAt.div'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\nx : E\nfa : AnalyticAt 𝕜 f x\nga : AnalyticAt 𝕜 g x\ng0 : Ne (g x) 0\n⊢ AnalyticAt 𝕜 (fun x => HDiv.hDiv (f x) (g x)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.div' {f g : E → 𝕝} {x : E}\n    (fa : AnalyticAt 𝕜 f x) (ga : AnalyticAt 𝕜 g x) (g0 : g x ≠ 0) :\n    AnalyticAt 𝕜 (fun x ↦ f x / g x) x :=\n  fa.div ga g0\n\n"}
{"name":"AnalyticOn.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\ns : Set E\nfa : AnalyticOn 𝕜 f s\nga : AnalyticOn 𝕜 g s\ng0 : ∀ (x : E), Membership.mem s x → Ne (g x) 0\n⊢ AnalyticOn 𝕜 (fun x => HDiv.hDiv (f x) (g x)) s","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticOn.div {f g : E → 𝕝} {s : Set E}\n    (fa : AnalyticOn 𝕜 f s) (ga : AnalyticOn 𝕜 g s) (g0 : ∀ x ∈ s, g x ≠ 0) :\n    AnalyticOn 𝕜 (fun x ↦ f x / g x) s := fun x m ↦\n  (fa x m).div (ga x m) (g0 x m)\n\n"}
{"name":"AnalyticWithinOn.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\ns : Set E\nfa : AnalyticOn 𝕜 f s\nga : AnalyticOn 𝕜 g s\ng0 : ∀ (x : E), Membership.mem s x → Ne (g x) 0\n⊢ AnalyticOn 𝕜 (fun x => HDiv.hDiv (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.div := AnalyticOn.div\n\n"}
{"name":"AnalyticOnNhd.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕝 : Type u_7\ninst✝¹ : NontriviallyNormedField 𝕝\ninst✝ : NormedAlgebra 𝕜 𝕝\nf g : E → 𝕝\ns : Set E\nfa : AnalyticOnNhd 𝕜 f s\nga : AnalyticOnNhd 𝕜 g s\ng0 : ∀ (x : E), Membership.mem s x → Ne (g x) 0\n⊢ AnalyticOnNhd 𝕜 (fun x => HDiv.hDiv (f x) (g x)) s","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticOnNhd.div {f g : E → 𝕝} {s : Set E}\n    (fa : AnalyticOnNhd 𝕜 f s) (ga : AnalyticOnNhd 𝕜 g s) (g0 : ∀ x ∈ s, g x ≠ 0) :\n    AnalyticOnNhd 𝕜 (fun x ↦ f x / g x) s := fun x m ↦\n  (fa x m).div (ga x m) (g0 x m)\n\n"}
{"name":"Finset.analyticWithinAt_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : α → E → F\nc : E\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticWithinAt 𝕜 (f n) s c\n⊢ AnalyticWithinAt 𝕜 (fun z => N.sum fun n => f n z) s c","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticWithinAt_sum {f : α → E → F} {c : E} {s : Set E}\n    (N : Finset α) (h : ∀ n ∈ N, AnalyticWithinAt 𝕜 (f n) s c) :\n    AnalyticWithinAt 𝕜 (fun z ↦ ∑ n ∈ N, f n z) s c := by\n  classical\n  induction' N using Finset.induction with a B aB hB\n  · simp only [Finset.sum_empty]\n    exact analyticWithinAt_const\n  · simp_rw [Finset.sum_insert aB]\n    simp only [Finset.mem_insert] at h\n    exact (h a (Or.inl rfl)).add (hB fun b m ↦ h b (Or.inr m))\n\n"}
{"name":"Finset.analyticAt_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : α → E → F\nc : E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticAt 𝕜 (f n) c\n⊢ AnalyticAt 𝕜 (fun z => N.sum fun n => f n z) c","decl":"/-- Finite sums of analytic functions are analytic -/\n@[fun_prop]\ntheorem Finset.analyticAt_sum {f : α → E → F} {c : E}\n    (N : Finset α) (h : ∀ n ∈ N, AnalyticAt 𝕜 (f n) c) :\n    AnalyticAt 𝕜 (fun z ↦ ∑ n ∈ N, f n z) c := by\n  simp_rw [← analyticWithinAt_univ] at h ⊢\n  exact N.analyticWithinAt_sum h\n\n"}
{"name":"Finset.analyticOn_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : α → E → F\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOn 𝕜 (f n) s\n⊢ AnalyticOn 𝕜 (fun z => N.sum fun n => f n z) s","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticOn_sum {f : α → E → F} {s : Set E}\n    (N : Finset α) (h : ∀ n ∈ N, AnalyticOn 𝕜 (f n) s) :\n    AnalyticOn 𝕜 (fun z ↦ ∑ n ∈ N, f n z) s :=\n  fun z zs ↦ N.analyticWithinAt_sum (fun n m ↦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinOn_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : α → E → F\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOn 𝕜 (f n) s\n⊢ AnalyticOn 𝕜 (fun z => N.sum fun n => f n z) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias Finset.analyticWithinOn_sum := Finset.analyticOn_sum\n\n"}
{"name":"Finset.analyticOnNhd_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : α → E → F\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOnNhd 𝕜 (f n) s\n⊢ AnalyticOnNhd 𝕜 (fun z => N.sum fun n => f n z) s","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticOnNhd_sum {f : α → E → F} {s : Set E}\n    (N : Finset α) (h : ∀ n ∈ N, AnalyticOnNhd 𝕜 (f n) s) :\n    AnalyticOnNhd 𝕜 (fun z ↦ ∑ n ∈ N, f n z) s :=\n  fun z zs ↦ N.analyticAt_sum (fun n m ↦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinAt_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_9\ninst✝¹ : NormedCommRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : α → E → A\nc : E\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticWithinAt 𝕜 (f n) s c\n⊢ AnalyticWithinAt 𝕜 (fun z => N.prod fun n => f n z) s c","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticWithinAt_prod {A : Type*} [NormedCommRing A] [NormedAlgebra 𝕜 A]\n    {f : α → E → A} {c : E} {s : Set E} (N : Finset α) (h : ∀ n ∈ N, AnalyticWithinAt 𝕜 (f n) s c) :\n    AnalyticWithinAt 𝕜 (fun z ↦ ∏ n ∈ N, f n z) s c := by\n  classical\n  induction' N using Finset.induction with a B aB hB\n  · simp only [Finset.prod_empty]\n    exact analyticWithinAt_const\n  · simp_rw [Finset.prod_insert aB]\n    simp only [Finset.mem_insert] at h\n    exact (h a (Or.inl rfl)).mul (hB fun b m ↦ h b (Or.inr m))\n\n"}
{"name":"Finset.analyticAt_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_9\ninst✝¹ : NormedCommRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : α → E → A\nc : E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticAt 𝕜 (f n) c\n⊢ AnalyticAt 𝕜 (fun z => N.prod fun n => f n z) c","decl":"/-- Finite products of analytic functions are analytic -/\n@[fun_prop]\ntheorem Finset.analyticAt_prod {A : Type*} [NormedCommRing A] [NormedAlgebra 𝕜 A]\n    {f : α → E → A} {c : E} (N : Finset α) (h : ∀ n ∈ N, AnalyticAt 𝕜 (f n) c) :\n    AnalyticAt 𝕜 (fun z ↦ ∏ n ∈ N, f n z) c := by\n  simp_rw [← analyticWithinAt_univ] at h ⊢\n  exact N.analyticWithinAt_prod h\n\n"}
{"name":"Finset.analyticOn_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_9\ninst✝¹ : NormedCommRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : α → E → A\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOn 𝕜 (f n) s\n⊢ AnalyticOn 𝕜 (fun z => N.prod fun n => f n z) s","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticOn_prod {A : Type*} [NormedCommRing A] [NormedAlgebra 𝕜 A]\n    {f : α → E → A} {s : Set E} (N : Finset α) (h : ∀ n ∈ N, AnalyticOn 𝕜 (f n) s) :\n    AnalyticOn 𝕜 (fun z ↦ ∏ n ∈ N, f n z) s :=\n  fun z zs ↦ N.analyticWithinAt_prod (fun n m ↦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinOn_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_9\ninst✝¹ : NormedCommRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : α → E → A\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOn 𝕜 (f n) s\n⊢ AnalyticOn 𝕜 (fun z => N.prod fun n => f n z) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias Finset.analyticWithinOn_prod := Finset.analyticOn_prod\n\n"}
{"name":"Finset.analyticOnNhd_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_9\ninst✝¹ : NormedCommRing A\ninst✝ : NormedAlgebra 𝕜 A\nf : α → E → A\ns : Set E\nN : Finset α\nh : ∀ (n : α), Membership.mem N n → AnalyticOnNhd 𝕜 (f n) s\n⊢ AnalyticOnNhd 𝕜 (fun z => N.prod fun n => f n z) s","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticOnNhd_prod {A : Type*} [NormedCommRing A] [NormedAlgebra 𝕜 A]\n    {f : α → E → A} {s : Set E} (N : Finset α) (h : ∀ n ∈ N, AnalyticOnNhd 𝕜 (f n) s) :\n    AnalyticOnNhd 𝕜 (fun z ↦ ∏ n ∈ N, f n z) s :=\n  fun z zs ↦ N.analyticAt_prod (fun n m ↦ h n m z zs)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → ContinuousLinearMap (RingHom.id 𝕜) E F\npf : FormalMultilinearSeries 𝕜 E (ContinuousLinearMap (RingHom.id 𝕜) E F)\ns : Set E\nx : E\nr : ENNReal\nz : F\nhf : HasFPowerSeriesWithinOnBall f pf s x r\n⊢ HasFPowerSeriesWithinOnBall (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.unshift (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (fun y ↦ z + f y (y - x)) (pf.unshift z) s x r where\n  r_le := by\n    rw [FormalMultilinearSeries.radius_unshift]\n    exact hf.r_le\n  r_pos := hf.r_pos\n  hasSum := by\n    intro y hy h'y\n    apply HasSum.zero_add\n    simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one,\n      continuousMultilinearCurryRightEquiv_symm_apply', add_sub_cancel_left]\n    exact (ContinuousLinearMap.apply 𝕜 F y).hasSum (hf.hasSum hy h'y)\n\n"}
{"name":"HasFPowerSeriesOnBall.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → ContinuousLinearMap (RingHom.id 𝕜) E F\npf : FormalMultilinearSeries 𝕜 E (ContinuousLinearMap (RingHom.id 𝕜) E F)\nx : E\nr : ENNReal\nz : F\nhf : HasFPowerSeriesOnBall f pf x r\n⊢ HasFPowerSeriesOnBall (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) x r","decl":"theorem HasFPowerSeriesOnBall.unshift (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (fun y ↦ z + f y (y - x)) (pf.unshift z) x r where\n  r_le := by\n    rw [FormalMultilinearSeries.radius_unshift]\n    exact hf.r_le\n  r_pos := hf.r_pos\n  hasSum := by\n    intro y hy\n    apply HasSum.zero_add\n    simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one,\n      continuousMultilinearCurryRightEquiv_symm_apply', add_sub_cancel_left]\n    exact (ContinuousLinearMap.apply 𝕜 F y).hasSum (hf.hasSum hy)\n\n"}
{"name":"HasFPowerSeriesWithinAt.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"𝕜 : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_3\nF : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → ContinuousLinearMap (RingHom.id 𝕜) E F\npf : FormalMultilinearSeries 𝕜 E (ContinuousLinearMap (RingHom.id 𝕜) E F)\ns : Set E\nx : E\nz : F\nhf : HasFPowerSeriesWithinAt f pf s x\n⊢ HasFPowerSeriesWithinAt (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) s x","decl":"theorem HasFPowerSeriesWithinAt.unshift (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (fun y ↦ z + f y (y - x)) (pf.unshift z) s x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.unshift.hasFPowerSeriesWithinAt\n\n"}
