{"name":"hasFPowerSeriesOnBall_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\ne : E\nâŠ¢ HasFPowerSeriesOnBall (fun x => c) (constFormalMultilinearSeries ğ•œ E c) e Top.top","decl":"theorem hasFPowerSeriesOnBall_const {c : F} {e : E} :\n    HasFPowerSeriesOnBall (fun _ => c) (constFormalMultilinearSeries ğ•œ E c) e âŠ¤ := by\n  refine âŸ¨by simp, WithTop.top_pos, fun _ => hasSum_single 0 fun n hn => ?_âŸ©\n  simp [constFormalMultilinearSeries_apply hn]\n\n"}
{"name":"hasFPowerSeriesAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\ne : E\nâŠ¢ HasFPowerSeriesAt (fun x => c) (constFormalMultilinearSeries ğ•œ E c) e","decl":"theorem hasFPowerSeriesAt_const {c : F} {e : E} :\n    HasFPowerSeriesAt (fun _ => c) (constFormalMultilinearSeries ğ•œ E c) e :=\n  âŸ¨âŠ¤, hasFPowerSeriesOnBall_constâŸ©\n\n"}
{"name":"analyticAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\nx : E\nâŠ¢ AnalyticAt ğ•œ (fun x => v) x","decl":"@[fun_prop]\ntheorem analyticAt_const {v : F} {x : E} : AnalyticAt ğ•œ (fun _ => v) x :=\n  âŸ¨constFormalMultilinearSeries ğ•œ E v, hasFPowerSeriesAt_constâŸ©\n\n"}
{"name":"analyticOnNhd_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\ns : Set E\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => v) s","decl":"theorem analyticOnNhd_const {v : F} {s : Set E} : AnalyticOnNhd ğ•œ (fun _ => v) s :=\n  fun _ _ => analyticAt_const\n\n"}
{"name":"analyticWithinAt_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\ns : Set E\nx : E\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => v) s x","decl":"theorem analyticWithinAt_const {v : F} {s : Set E} {x : E} : AnalyticWithinAt ğ•œ (fun _ => v) s x :=\n  analyticAt_const.analyticWithinAt\n\n"}
{"name":"analyticOn_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\ns : Set E\nâŠ¢ AnalyticOn ğ•œ (fun x => v) s","decl":"theorem analyticOn_const {v : F} {s : Set E} : AnalyticOn ğ•œ (fun _ => v) s :=\n  analyticOnNhd_const.analyticOn\n\n"}
{"name":"analyticWithinOn_const","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\ns : Set E\nâŠ¢ AnalyticOn ğ•œ (fun x => v) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_const := analyticOn_const\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nhg : HasFPowerSeriesWithinOnBall g pg s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.add (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (hg : HasFPowerSeriesWithinOnBall g pg s x r) :\n    HasFPowerSeriesWithinOnBall (f + g) (pf + pg) s x r :=\n  { r_le := le_trans (le_min_iff.2 âŸ¨hf.r_le, hg.r_leâŸ©) (pf.min_radius_le_radius_add pg)\n    r_pos := hf.r_pos\n    hasSum := fun hy h'y => (hf.hasSum hy h'y).add (hg.hasSum hy h'y) }\n\n"}
{"name":"HasFPowerSeriesOnBall.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nhg : HasFPowerSeriesOnBall g pg x r\nâŠ¢ HasFPowerSeriesOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) x r","decl":"theorem HasFPowerSeriesOnBall.add (hf : HasFPowerSeriesOnBall f pf x r)\n    (hg : HasFPowerSeriesOnBall g pg x r) : HasFPowerSeriesOnBall (f + g) (pf + pg) x r :=\n  { r_le := le_trans (le_min_iff.2 âŸ¨hf.r_le, hg.r_leâŸ©) (pf.min_radius_le_radius_add pg)\n    r_pos := hf.r_pos\n    hasSum := fun hy => (hf.hasSum hy).add (hg.hasSum hy) }\n\n"}
{"name":"HasFPowerSeriesWithinAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nhg : HasFPowerSeriesWithinAt g pg s x\nâŠ¢ HasFPowerSeriesWithinAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) s x","decl":"theorem HasFPowerSeriesWithinAt.add\n    (hf : HasFPowerSeriesWithinAt f pf s x) (hg : HasFPowerSeriesWithinAt g pg s x) :\n    HasFPowerSeriesWithinAt (f + g) (pf + pg) s x := by\n  rcases (hf.eventually.and hg.eventually).exists with âŸ¨r, hrâŸ©\n  exact âŸ¨r, hr.1.add hr.2âŸ©\n\n"}
{"name":"HasFPowerSeriesAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nhg : HasFPowerSeriesAt g pg x\nâŠ¢ HasFPowerSeriesAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) x","decl":"theorem HasFPowerSeriesAt.add (hf : HasFPowerSeriesAt f pf x) (hg : HasFPowerSeriesAt g pg x) :\n    HasFPowerSeriesAt (f + g) (pf + pg) x := by\n  rcases (hf.eventually.and hg.eventually).exists with âŸ¨r, hrâŸ©\n  exact âŸ¨r, hr.1.add hr.2âŸ©\n\n"}
{"name":"AnalyticWithinAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nhg : AnalyticWithinAt ğ•œ g s x\nâŠ¢ AnalyticWithinAt ğ•œ (HAdd.hAdd f g) s x","decl":"theorem AnalyticWithinAt.add (hf : AnalyticWithinAt ğ•œ f s x) (hg : AnalyticWithinAt ğ•œ g s x) :\n    AnalyticWithinAt ğ•œ (f + g) s x :=\n  let âŸ¨_, hpfâŸ© := hf\n  let âŸ¨_, hqfâŸ© := hg\n  (hpf.add hqf).analyticWithinAt\n\n"}
{"name":"AnalyticAt.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nhg : AnalyticAt ğ•œ g x\nâŠ¢ AnalyticAt ğ•œ (HAdd.hAdd f g) x","decl":"@[fun_prop]\ntheorem AnalyticAt.add (hf : AnalyticAt ğ•œ f x) (hg : AnalyticAt ğ•œ g x) : AnalyticAt ğ•œ (f + g) x :=\n  let âŸ¨_, hpfâŸ© := hf\n  let âŸ¨_, hqfâŸ© := hg\n  (hpf.add hqf).analyticAt\n\n"}
{"name":"AnalyticAt.add'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nhg : AnalyticAt ğ•œ g x\nâŠ¢ AnalyticAt ğ•œ (fun z => HAdd.hAdd (f z) (g z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.add' (hf : AnalyticAt ğ•œ f x) (hg : AnalyticAt ğ•œ g x) :\n    AnalyticAt ğ•œ (fun z â†¦ f z + g z) x :=\n  hf.add hg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (Neg.neg f) (Neg.neg pf) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.neg (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (-f) (-pf) s x r :=\n  { r_le := by\n      rw [pf.radius_neg]\n      exact hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun hy h'y => (hf.hasSum hy h'y).neg }\n\n"}
{"name":"HasFPowerSeriesOnBall.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nâŠ¢ HasFPowerSeriesOnBall (Neg.neg f) (Neg.neg pf) x r","decl":"theorem HasFPowerSeriesOnBall.neg (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (-f) (-pf) x r :=\n  { r_le := by\n      rw [pf.radius_neg]\n      exact hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun hy => (hf.hasSum hy).neg }\n\n"}
{"name":"HasFPowerSeriesWithinAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nâŠ¢ HasFPowerSeriesWithinAt (Neg.neg f) (Neg.neg pf) s x","decl":"theorem HasFPowerSeriesWithinAt.neg (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (-f) (-pf) s x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.neg.hasFPowerSeriesWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nâŠ¢ HasFPowerSeriesAt (Neg.neg f) (Neg.neg pf) x","decl":"theorem HasFPowerSeriesAt.neg (hf : HasFPowerSeriesAt f pf x) : HasFPowerSeriesAt (-f) (-pf) x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.neg.hasFPowerSeriesAt\n\n"}
{"name":"AnalyticWithinAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nâŠ¢ AnalyticWithinAt ğ•œ (Neg.neg f) s x","decl":"theorem AnalyticWithinAt.neg (hf : AnalyticWithinAt ğ•œ f s x) : AnalyticWithinAt ğ•œ (-f) s x :=\n  let âŸ¨_, hpfâŸ© := hf\n  hpf.neg.analyticWithinAt\n\n"}
{"name":"AnalyticAt.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (Neg.neg f) x","decl":"@[fun_prop]\ntheorem AnalyticAt.neg (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (-f) x :=\n  let âŸ¨_, hpfâŸ© := hf\n  hpf.neg.analyticAt\n\n"}
{"name":"AnalyticAt.neg'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (fun z => Neg.neg (f z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.neg' (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (fun z â†¦ -f z) x :=\n  hf.neg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nhg : HasFPowerSeriesWithinOnBall g pg s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (HSub.hSub f g) (HSub.hSub pf pg) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.sub (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (hg : HasFPowerSeriesWithinOnBall g pg s x r) :\n    HasFPowerSeriesWithinOnBall (f - g) (pf - pg) s x r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesOnBall.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nhg : HasFPowerSeriesOnBall g pg x r\nâŠ¢ HasFPowerSeriesOnBall (HSub.hSub f g) (HSub.hSub pf pg) x r","decl":"theorem HasFPowerSeriesOnBall.sub (hf : HasFPowerSeriesOnBall f pf x r)\n    (hg : HasFPowerSeriesOnBall g pg x r) : HasFPowerSeriesOnBall (f - g) (pf - pg) x r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesWithinAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nhg : HasFPowerSeriesWithinAt g pg s x\nâŠ¢ HasFPowerSeriesWithinAt (HSub.hSub f g) (HSub.hSub pf pg) s x","decl":"theorem HasFPowerSeriesWithinAt.sub\n    (hf : HasFPowerSeriesWithinAt f pf s x) (hg : HasFPowerSeriesWithinAt g pg s x) :\n    HasFPowerSeriesWithinAt (f - g) (pf - pg) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFPowerSeriesAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nhg : HasFPowerSeriesAt g pg x\nâŠ¢ HasFPowerSeriesAt (HSub.hSub f g) (HSub.hSub pf pg) x","decl":"theorem HasFPowerSeriesAt.sub (hf : HasFPowerSeriesAt f pf x) (hg : HasFPowerSeriesAt g pg x) :\n    HasFPowerSeriesAt (f - g) (pf - pg) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticWithinAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nhg : AnalyticWithinAt ğ•œ g s x\nâŠ¢ AnalyticWithinAt ğ•œ (HSub.hSub f g) s x","decl":"theorem AnalyticWithinAt.sub (hf : AnalyticWithinAt ğ•œ f s x) (hg : AnalyticWithinAt ğ•œ g s x) :\n    AnalyticWithinAt ğ•œ (f - g) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticAt.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nhg : AnalyticAt ğ•œ g x\nâŠ¢ AnalyticAt ğ•œ (HSub.hSub f g) x","decl":"@[fun_prop]\ntheorem AnalyticAt.sub (hf : AnalyticAt ğ•œ f x) (hg : AnalyticAt ğ•œ g x) :\n    AnalyticAt ğ•œ (f - g) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"AnalyticAt.sub'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nhg : AnalyticAt ğ•œ g x\nâŠ¢ AnalyticAt ğ•œ (fun z => HSub.hSub (f z) (g z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.sub' (hf : AnalyticAt ğ•œ f x) (hg : AnalyticAt ğ•œ g x) :\n    AnalyticAt ğ•œ (fun z â†¦ f z - g z) x :=\n  hf.sub hg\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nc : ğ•œ\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (HSMul.hSMul c f) (HSMul.hSMul c pf) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.const_smul (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (c â€¢ f) (c â€¢ pf) s x r where\n  r_le := le_trans hf.r_le pf.radius_le_smul\n  r_pos := hf.r_pos\n  hasSum := fun hy h'y => (hf.hasSum hy h'y).const_smul _\n\n"}
{"name":"HasFPowerSeriesOnBall.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nc : ğ•œ\nhf : HasFPowerSeriesOnBall f pf x r\nâŠ¢ HasFPowerSeriesOnBall (HSMul.hSMul c f) (HSMul.hSMul c pf) x r","decl":"theorem HasFPowerSeriesOnBall.const_smul (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (c â€¢ f) (c â€¢ pf) x r where\n  r_le := le_trans hf.r_le pf.radius_le_smul\n  r_pos := hf.r_pos\n  hasSum := fun hy => (hf.hasSum hy).const_smul _\n\n"}
{"name":"HasFPowerSeriesWithinAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nc : ğ•œ\nhf : HasFPowerSeriesWithinAt f pf s x\nâŠ¢ HasFPowerSeriesWithinAt (HSMul.hSMul c f) (HSMul.hSMul c pf) s x","decl":"theorem HasFPowerSeriesWithinAt.const_smul (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (c â€¢ f) (c â€¢ pf) s x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.const_smul.hasFPowerSeriesWithinAt\n\n"}
{"name":"HasFPowerSeriesAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nc : ğ•œ\nhf : HasFPowerSeriesAt f pf x\nâŠ¢ HasFPowerSeriesAt (HSMul.hSMul c f) (HSMul.hSMul c pf) x","decl":"theorem HasFPowerSeriesAt.const_smul (hf : HasFPowerSeriesAt f pf x) :\n    HasFPowerSeriesAt (c â€¢ f) (c â€¢ pf) x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.const_smul.hasFPowerSeriesAt\n\n"}
{"name":"AnalyticWithinAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nc : ğ•œ\nhf : AnalyticWithinAt ğ•œ f s x\nâŠ¢ AnalyticWithinAt ğ•œ (HSMul.hSMul c f) s x","decl":"theorem AnalyticWithinAt.const_smul (hf : AnalyticWithinAt ğ•œ f s x) :\n    AnalyticWithinAt ğ•œ (c â€¢ f) s x :=\n  let âŸ¨_, hpfâŸ© := hf\n  hpf.const_smul.analyticWithinAt\n\n"}
{"name":"AnalyticAt.const_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nc : ğ•œ\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (HSMul.hSMul c f) x","decl":"@[fun_prop]\ntheorem AnalyticAt.const_smul (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (c â€¢ f) x :=\n  let âŸ¨_, hpfâŸ© := hf\n  hpf.const_smul.analyticAt\n\n"}
{"name":"AnalyticAt.const_smul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nc : ğ•œ\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (fun z => HSMul.hSMul c (f z)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.const_smul' (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (fun z â†¦ c â€¢ f z) x :=\n  hf.const_smul\n\n"}
{"name":"AnalyticOn.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (HAdd.hAdd f g) s","decl":"theorem AnalyticOn.add (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g s) :\n    AnalyticOn ğ•œ (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"AnalyticWithinOn.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (HAdd.hAdd f g) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.add := AnalyticOn.add\n\n"}
{"name":"AnalyticOnNhd.add","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOnNhd ğ•œ g s\nâŠ¢ AnalyticOnNhd ğ•œ (HAdd.hAdd f g) s","decl":"theorem AnalyticOnNhd.add (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOnNhd ğ•œ g s) :\n    AnalyticOnNhd ğ•œ (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"AnalyticOn.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (Neg.neg f) s","decl":"theorem AnalyticOn.neg (hf : AnalyticOn ğ•œ f s) : AnalyticOn ğ•œ (-f) s :=\n  fun z hz â†¦ (hf z hz).neg\n\n"}
{"name":"AnalyticWithinOn.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (Neg.neg f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.neg := AnalyticOn.neg\n\n"}
{"name":"AnalyticOnNhd.neg","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (Neg.neg f) s","decl":"theorem AnalyticOnNhd.neg (hf : AnalyticOnNhd ğ•œ f s) : AnalyticOnNhd ğ•œ (-f) s :=\n  fun z hz â†¦ (hf z hz).neg\n\n"}
{"name":"AnalyticOn.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (HSub.hSub f g) s","decl":"theorem AnalyticOn.sub (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g s) :\n    AnalyticOn ğ•œ (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"AnalyticWithinOn.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (HSub.hSub f g) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.sub := AnalyticOn.sub\n\n"}
{"name":"AnalyticOnNhd.sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOnNhd ğ•œ g s\nâŠ¢ AnalyticOnNhd ğ•œ (HSub.hSub f g) s","decl":"theorem AnalyticOnNhd.sub (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOnNhd ğ•œ g s) :\n    AnalyticOnNhd ğ•œ (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"FormalMultilinearSeries.radius_prod_eq_min","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ E G\nâŠ¢ Eq (p.prod q).radius (Min.min p.radius q.radius)","decl":"/-- The radius of the Cartesian product of two formal series is the minimum of their radii. -/\nlemma FormalMultilinearSeries.radius_prod_eq_min\n    (p : FormalMultilinearSeries ğ•œ E F) (q : FormalMultilinearSeries ğ•œ E G) :\n    (p.prod q).radius = min p.radius q.radius := by\n  apply le_antisymm\n  Â· refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n    rw [le_min_iff]\n    have := (p.prod q).isLittleO_one_of_lt_radius hr\n    constructor\n    all_goals\n      apply FormalMultilinearSeries.le_radius_of_isBigO\n      refine (isBigO_of_le _ fun n â†¦ ?_).trans this.isBigO\n      rw [norm_mul, norm_norm, norm_mul, norm_norm]\n      refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n      rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.opNorm_prod]\n    Â· apply le_max_left\n    Â· apply le_max_right\n  Â· refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n    rw [lt_min_iff] at hr\n    have := ((p.isLittleO_one_of_lt_radius hr.1).add\n      (q.isLittleO_one_of_lt_radius hr.2)).isBigO\n    refine (p.prod q).le_radius_of_isBigO ((isBigO_of_le _ fun n â†¦ ?_).trans this)\n    rw [norm_mul, norm_norm, â† add_mul, norm_mul]\n    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n    rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.opNorm_prod]\n    refine (max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)).trans ?_\n    apply Real.le_norm_self\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\nr s : ENNReal\nt : Set E\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ E G\nhf : HasFPowerSeriesWithinOnBall f p t e r\nhg : HasFPowerSeriesWithinOnBall g q t e s\nâŠ¢ HasFPowerSeriesWithinOnBall (fun x => { fst := f x, snd := g x }) (p.prod q) t e (Min.min r s)","decl":"lemma HasFPowerSeriesWithinOnBall.prod {e : E} {f : E â†’ F} {g : E â†’ G} {r s : â„â‰¥0âˆ} {t : Set E}\n    {p : FormalMultilinearSeries ğ•œ E F} {q : FormalMultilinearSeries ğ•œ E G}\n    (hf : HasFPowerSeriesWithinOnBall f p t e r) (hg : HasFPowerSeriesWithinOnBall g q t e s) :\n    HasFPowerSeriesWithinOnBall (fun x â†¦ (f x, g x)) (p.prod q) t e (min r s) where\n  r_le := by\n    rw [p.radius_prod_eq_min]\n    exact min_le_min hf.r_le hg.r_le\n  r_pos := lt_min hf.r_pos hg.r_pos\n  hasSum := by\n    intro y h'y hy\n    simp_rw [FormalMultilinearSeries.prod, ContinuousMultilinearMap.prod_apply]\n    refine (hf.hasSum h'y ?_).prod_mk (hg.hasSum h'y ?_)\n    Â· exact EMetric.mem_ball.mpr (lt_of_lt_of_le hy (min_le_left _ _))\n    Â· exact EMetric.mem_ball.mpr (lt_of_lt_of_le hy (min_le_right _ _))\n\n"}
{"name":"HasFPowerSeriesOnBall.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\nr s : ENNReal\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ E G\nhf : HasFPowerSeriesOnBall f p e r\nhg : HasFPowerSeriesOnBall g q e s\nâŠ¢ HasFPowerSeriesOnBall (fun x => { fst := f x, snd := g x }) (p.prod q) e (Min.min r s)","decl":"lemma HasFPowerSeriesOnBall.prod {e : E} {f : E â†’ F} {g : E â†’ G} {r s : â„â‰¥0âˆ}\n    {p : FormalMultilinearSeries ğ•œ E F} {q : FormalMultilinearSeries ğ•œ E G}\n    (hf : HasFPowerSeriesOnBall f p e r) (hg : HasFPowerSeriesOnBall g q e s) :\n    HasFPowerSeriesOnBall (fun x â†¦ (f x, g x)) (p.prod q) e (min r s) := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf hg âŠ¢\n  exact hf.prod hg\n\n"}
{"name":"HasFPowerSeriesWithinAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\ns : Set E\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ E G\nhf : HasFPowerSeriesWithinAt f p s e\nhg : HasFPowerSeriesWithinAt g q s e\nâŠ¢ HasFPowerSeriesWithinAt (fun x => { fst := f x, snd := g x }) (p.prod q) s e","decl":"lemma HasFPowerSeriesWithinAt.prod {e : E} {f : E â†’ F} {g : E â†’ G} {s : Set E}\n    {p : FormalMultilinearSeries ğ•œ E F} {q : FormalMultilinearSeries ğ•œ E G}\n    (hf : HasFPowerSeriesWithinAt f p s e) (hg : HasFPowerSeriesWithinAt g q s e) :\n    HasFPowerSeriesWithinAt (fun x â†¦ (f x, g x)) (p.prod q) s e := by\n  rcases hf with âŸ¨_, hfâŸ©\n  rcases hg with âŸ¨_, hgâŸ©\n  exact âŸ¨_, hf.prod hgâŸ©\n\n"}
{"name":"HasFPowerSeriesAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ E G\nhf : HasFPowerSeriesAt f p e\nhg : HasFPowerSeriesAt g q e\nâŠ¢ HasFPowerSeriesAt (fun x => { fst := f x, snd := g x }) (p.prod q) e","decl":"lemma HasFPowerSeriesAt.prod {e : E} {f : E â†’ F} {g : E â†’ G}\n    {p : FormalMultilinearSeries ğ•œ E F} {q : FormalMultilinearSeries ğ•œ E G}\n    (hf : HasFPowerSeriesAt f p e) (hg : HasFPowerSeriesAt g q e) :\n    HasFPowerSeriesAt (fun x â†¦ (f x, g x)) (p.prod q) e := by\n  rcases hf with âŸ¨_, hfâŸ©\n  rcases hg with âŸ¨_, hgâŸ©\n  exact âŸ¨_, hf.prod hgâŸ©\n\n"}
{"name":"AnalyticWithinAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\ns : Set E\nhf : AnalyticWithinAt ğ•œ f s e\nhg : AnalyticWithinAt ğ•œ g s e\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => { fst := f x, snd := g x }) s e","decl":"/-- The Cartesian product of analytic functions is analytic. -/\nlemma AnalyticWithinAt.prod {e : E} {f : E â†’ F} {g : E â†’ G} {s : Set E}\n    (hf : AnalyticWithinAt ğ•œ f s e) (hg : AnalyticWithinAt ğ•œ g s e) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ (f x, g x)) s e := by\n  rcases hf with âŸ¨_, hfâŸ©\n  rcases hg with âŸ¨_, hgâŸ©\n  exact âŸ¨_, hf.prod hgâŸ©\n\n"}
{"name":"AnalyticAt.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ne : E\nf : E â†’ F\ng : E â†’ G\nhf : AnalyticAt ğ•œ f e\nhg : AnalyticAt ğ•œ g e\nâŠ¢ AnalyticAt ğ•œ (fun x => { fst := f x, snd := g x }) e","decl":"/-- The Cartesian product of analytic functions is analytic. -/\n@[fun_prop]\nlemma AnalyticAt.prod {e : E} {f : E â†’ F} {g : E â†’ G}\n    (hf : AnalyticAt ğ•œ f e) (hg : AnalyticAt ğ•œ g e) :\n    AnalyticAt ğ•œ (fun x â†¦ (f x, g x)) e := by\n  rcases hf with âŸ¨_, hfâŸ©\n  rcases hg with âŸ¨_, hgâŸ©\n  exact âŸ¨_, hf.prod hgâŸ©\n\n"}
{"name":"AnalyticOn.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : E â†’ G\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => { fst := f x, snd := g x }) s","decl":"/-- The Cartesian product of analytic functions within a set is analytic. -/\nlemma AnalyticOn.prod {f : E â†’ F} {g : E â†’ G} {s : Set E}\n    (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g s) :\n    AnalyticOn ğ•œ (fun x â†¦ (f x, g x)) s :=\n  fun x hx â†¦ (hf x hx).prod (hg x hx)\n\n"}
{"name":"AnalyticWithinOn.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : E â†’ G\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => { fst := f x, snd := g x }) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.prod := AnalyticOn.prod\n\n"}
{"name":"AnalyticOnNhd.prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : E â†’ G\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOnNhd ğ•œ g s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => { fst := f x, snd := g x }) s","decl":"/-- The Cartesian product of analytic functions is analytic. -/\nlemma AnalyticOnNhd.prod {f : E â†’ F} {g : E â†’ G} {s : Set E}\n    (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOnNhd ğ•œ g s) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ (f x, g x)) s :=\n  fun x hx â†¦ (hf x hx).prod (hg x hx)\n\n"}
{"name":"AnalyticAt.compâ‚‚","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\nx : E\nha : AnalyticAt ğ•œ h { fst := f x, snd := g x }\nfa : AnalyticAt ğ•œ f x\nga : AnalyticAt ğ•œ g x\nâŠ¢ AnalyticAt ğ•œ (fun x => h { fst := f x, snd := g x }) x","decl":"/-- `AnalyticAt.comp` for functions on product spaces -/\ntheorem AnalyticAt.compâ‚‚ {h : F Ã— G â†’ H} {f : E â†’ F} {g : E â†’ G} {x : E}\n    (ha : AnalyticAt ğ•œ h (f x, g x)) (fa : AnalyticAt ğ•œ f x)\n    (ga : AnalyticAt ğ•œ g x) :\n    AnalyticAt ğ•œ (fun x â†¦ h (f x, g x)) x :=\n  AnalyticAt.comp ha (fa.prod ga)\n\n"}
{"name":"AnalyticWithinAt.compâ‚‚","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\ns : Set (Prod F G)\nt : Set E\nx : E\nha : AnalyticWithinAt ğ•œ h s { fst := f x, snd := g x }\nfa : AnalyticWithinAt ğ•œ f t x\nga : AnalyticWithinAt ğ•œ g t x\nhf : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => h { fst := f x, snd := g x }) t x","decl":"/-- `AnalyticWithinAt.comp` for functions on product spaces -/\ntheorem AnalyticWithinAt.compâ‚‚ {h : F Ã— G â†’ H} {f : E â†’ F} {g : E â†’ G} {s : Set (F Ã— G)}\n    {t : Set E} {x : E}\n    (ha : AnalyticWithinAt ğ•œ h s (f x, g x)) (fa : AnalyticWithinAt ğ•œ f t x)\n    (ga : AnalyticWithinAt ğ•œ g t x) (hf : Set.MapsTo (fun y â†¦ (f y, g y)) t s) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ h (f x, g x)) t x :=\n  AnalyticWithinAt.comp ha (fa.prod ga) hf\n\n"}
{"name":"AnalyticAt.compâ‚‚_analyticWithinAt","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\nx : E\ns : Set E\nha : AnalyticAt ğ•œ h { fst := f x, snd := g x }\nfa : AnalyticWithinAt ğ•œ f s x\nga : AnalyticWithinAt ğ•œ g s x\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => h { fst := f x, snd := g x }) s x","decl":"/-- `AnalyticAt.comp_analyticWithinAt` for functions on product spaces -/\ntheorem AnalyticAt.compâ‚‚_analyticWithinAt\n    {h : F Ã— G â†’ H} {f : E â†’ F} {g : E â†’ G} {x : E} {s : Set E}\n    (ha : AnalyticAt ğ•œ h (f x, g x)) (fa : AnalyticWithinAt ğ•œ f s x)\n    (ga : AnalyticWithinAt ğ•œ g s x) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ h (f x, g x)) s x :=\n  AnalyticAt.comp_analyticWithinAt ha (fa.prod ga)\n\n"}
{"name":"AnalyticOnNhd.compâ‚‚","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOnNhd ğ•œ h s\nfa : AnalyticOnNhd ğ•œ f t\nga : AnalyticOnNhd ğ•œ g t\nm : âˆ€ (x : E), Membership.mem t x â†’ Membership.mem s { fst := f x, snd := g x }\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => h { fst := f x, snd := g x }) t","decl":"/-- `AnalyticOnNhd.comp` for functions on product spaces -/\ntheorem AnalyticOnNhd.compâ‚‚ {h : F Ã— G â†’ H} {f : E â†’ F} {g : E â†’ G} {s : Set (F Ã— G)} {t : Set E}\n    (ha : AnalyticOnNhd ğ•œ h s) (fa : AnalyticOnNhd ğ•œ f t) (ga : AnalyticOnNhd ğ•œ g t)\n    (m : âˆ€ x, x âˆˆ t â†’ (f x, g x) âˆˆ s) : AnalyticOnNhd ğ•œ (fun x â†¦ h (f x, g x)) t :=\n  fun _ xt â†¦ (ha _ (m _ xt)).compâ‚‚ (fa _ xt) (ga _ xt)\n\n"}
{"name":"AnalyticOn.compâ‚‚","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOn ğ•œ h s\nfa : AnalyticOn ğ•œ f t\nga : AnalyticOn ğ•œ g t\nm : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\nâŠ¢ AnalyticOn ğ•œ (fun x => h { fst := f x, snd := g x }) t","decl":"/-- `AnalyticOn.comp` for functions on product spaces -/\ntheorem AnalyticOn.compâ‚‚ {h : F Ã— G â†’ H} {f : E â†’ F} {g : E â†’ G} {s : Set (F Ã— G)}\n    {t : Set E}\n    (ha : AnalyticOn ğ•œ h s) (fa : AnalyticOn ğ•œ f t)\n    (ga : AnalyticOn ğ•œ g t) (m : Set.MapsTo (fun y â†¦ (f y, g y)) t s) :\n    AnalyticOn ğ•œ (fun x â†¦ h (f x, g x)) t :=\n  fun x hx â†¦ (ha _ (m hx)).compâ‚‚ (fa x hx) (ga x hx) m\n\n"}
{"name":"AnalyticWithinOn.compâ‚‚","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\nH : Type u_6\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nh : Prod F G â†’ H\nf : E â†’ F\ng : E â†’ G\ns : Set (Prod F G)\nt : Set E\nha : AnalyticOn ğ•œ h s\nfa : AnalyticOn ğ•œ f t\nga : AnalyticOn ğ•œ g t\nm : Set.MapsTo (fun y => { fst := f y, snd := g y }) t s\nâŠ¢ AnalyticOn ğ•œ (fun x => h { fst := f x, snd := g x }) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.compâ‚‚ := AnalyticOn.compâ‚‚\n\n"}
{"name":"AnalyticAt.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\np : Prod E F\nfa : AnalyticAt ğ•œ f p\nâŠ¢ AnalyticAt ğ•œ (fun x => f { fst := x, snd := p.2 }) p.1","decl":"/-- Analytic functions on products are analytic in the first coordinate -/\ntheorem AnalyticAt.curry_left {f : E Ã— F â†’ G} {p : E Ã— F} (fa : AnalyticAt ğ•œ f p) :\n    AnalyticAt ğ•œ (fun x â†¦ f (x, p.2)) p.1 :=\n  AnalyticAt.compâ‚‚ fa analyticAt_id analyticAt_const\n"}
{"name":"AnalyticAt.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\np : Prod E F\nfa : AnalyticAt ğ•œ f p\nâŠ¢ AnalyticAt ğ•œ (fun x => f { fst := x, snd := p.2 }) p.1","decl":"alias AnalyticAt.along_fst := AnalyticAt.curry_left\n\n"}
{"name":"AnalyticWithinAt.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\np : Prod E F\nfa : AnalyticWithinAt ğ•œ f s p\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => f { fst := x, snd := p.2 }) (setOf fun x => Membership.mem s { fst := x, snd := p.2 }) p.1","decl":"theorem AnalyticWithinAt.curry_left\n    {f : E Ã— F â†’ G} {s : Set (E Ã— F)} {p : E Ã— F} (fa : AnalyticWithinAt ğ•œ f s p) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ f (x, p.2)) {x | (x, p.2) âˆˆ s} p.1 :=\n  AnalyticWithinAt.compâ‚‚ fa analyticWithinAt_id analyticWithinAt_const (fun _ hx â†¦ hx)\n\n"}
{"name":"AnalyticAt.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\np : Prod E F\nfa : AnalyticAt ğ•œ f p\nâŠ¢ AnalyticAt ğ•œ (fun y => f { fst := p.1, snd := y }) p.2","decl":"/-- Analytic functions on products are analytic in the second coordinate -/\ntheorem AnalyticAt.curry_right {f : E Ã— F â†’ G} {p : E Ã— F} (fa : AnalyticAt ğ•œ f p) :\n    AnalyticAt ğ•œ (fun y â†¦ f (p.1, y)) p.2 :=\n  AnalyticAt.compâ‚‚ fa analyticAt_const analyticAt_id\n"}
{"name":"AnalyticAt.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\np : Prod E F\nfa : AnalyticAt ğ•œ f p\nâŠ¢ AnalyticAt ğ•œ (fun y => f { fst := p.1, snd := y }) p.2","decl":"alias AnalyticAt.along_snd := AnalyticAt.curry_right\n\n"}
{"name":"AnalyticWithinAt.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\np : Prod E F\nfa : AnalyticWithinAt ğ•œ f s p\nâŠ¢ AnalyticWithinAt ğ•œ (fun y => f { fst := p.1, snd := y }) (setOf fun y => Membership.mem s { fst := p.1, snd := y }) p.2","decl":"theorem AnalyticWithinAt.curry_right\n    {f : E Ã— F â†’ G} {s : Set (E Ã— F)} {p : E Ã— F} (fa : AnalyticWithinAt ğ•œ f s p) :\n    AnalyticWithinAt ğ•œ (fun y â†¦ f (p.1, y)) {y | (p.1, y) âˆˆ s} p.2 :=\n  AnalyticWithinAt.compâ‚‚ fa  analyticWithinAt_const analyticWithinAt_id (fun _ hx â†¦ hx)\n\n"}
{"name":"AnalyticOnNhd.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"/-- Analytic functions on products are analytic in the first coordinate -/\ntheorem AnalyticOnNhd.curry_left {f : E Ã— F â†’ G} {s : Set (E Ã— F)} {y : F}\n    (fa : AnalyticOnNhd ğ•œ f s) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ f (x, y)) {x | (x, y) âˆˆ s} :=\n  fun x m â†¦ (fa (x, y) m).curry_left\n"}
{"name":"AnalyticOnNhd.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"alias AnalyticOnNhd.along_fst := AnalyticOnNhd.curry_left\n\n"}
{"name":"AnalyticOn.along_fst","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.along_fst := AnalyticOnNhd.curry_left\n\n"}
{"name":"AnalyticOn.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"theorem AnalyticOn.curry_left\n    {f : E Ã— F â†’ G} {s : Set (E Ã— F)} {y : F} (fa : AnalyticOn ğ•œ f s) :\n    AnalyticOn ğ•œ (fun x â†¦ f (x, y)) {x | (x, y) âˆˆ s} :=\n  fun x m â†¦ (fa (x, y) m).curry_left\n\n"}
{"name":"AnalyticWithinOn.curry_left","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\ns : Set (Prod E F)\ny : F\nfa : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (fun x => f { fst := x, snd := y }) (setOf fun x => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.curry_left := AnalyticOn.curry_left\n\n"}
{"name":"AnalyticOnNhd.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"/-- Analytic functions on products are analytic in the second coordinate -/\ntheorem AnalyticOnNhd.curry_right {f : E Ã— F â†’ G} {x : E} {s : Set (E Ã— F)}\n    (fa : AnalyticOnNhd ğ•œ f s) :\n    AnalyticOnNhd ğ•œ (fun y â†¦ f (x, y)) {y | (x, y) âˆˆ s} :=\n  fun y m â†¦ (fa (x, y) m).curry_right\n"}
{"name":"AnalyticOnNhd.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"alias AnalyticOnNhd.along_snd := AnalyticOnNhd.curry_right\n\n"}
{"name":"AnalyticOn.along_snd","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.along_snd := AnalyticOnNhd.curry_right\n\n"}
{"name":"AnalyticOn.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"theorem AnalyticOn.curry_right\n    {f : E Ã— F â†’ G} {x : E} {s : Set (E Ã— F)} (fa : AnalyticOn ğ•œ f s) :\n    AnalyticOn ğ•œ (fun y â†¦ f (x, y)) {y | (x, y) âˆˆ s} :=\n  fun y m â†¦ (fa (x, y) m).curry_right\n\n"}
{"name":"AnalyticWithinOn.curry_right","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nx : E\ns : Set (Prod E F)\nfa : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (fun y => f { fst := x, snd := y }) (setOf fun y => Membership.mem s { fst := x, snd := y })","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.curry_right := AnalyticOn.curry_right\n\n"}
{"name":"FormalMultilinearSeries.radius_pi_le","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\ni : Î¹\nâŠ¢ LE.le (FormalMultilinearSeries.pi p).radius (p i).radius","decl":"lemma FormalMultilinearSeries.radius_pi_le (p : Î  i, FormalMultilinearSeries ğ•œ E (Fm i)) (i : Î¹) :\n    (FormalMultilinearSeries.pi p).radius â‰¤ (p i).radius := by\n  apply le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)\n  obtain âŸ¨C, -, hCâŸ© : âˆƒ C > 0, âˆ€ n, â€–pi p nâ€– * â†‘r' ^ n â‰¤ C := norm_mul_pow_le_of_lt_radius _ hr'\n  apply le_radius_of_bound _ C (fun n â†¦ ?_)\n  apply le_trans _ (hC n)\n  gcongr\n  rw [pi, ContinuousMultilinearMap.opNorm_pi]\n  exact norm_le_pi_norm (fun i â†¦ p i n) i\n\n"}
{"name":"FormalMultilinearSeries.le_radius_pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nr : ENNReal\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nh : âˆ€ (i : Î¹), LE.le r (p i).radius\nâŠ¢ LE.le r (FormalMultilinearSeries.pi p).radius","decl":"lemma FormalMultilinearSeries.le_radius_pi (h : âˆ€ i, r â‰¤ (p i).radius) :\n    r â‰¤ (FormalMultilinearSeries.pi p).radius := by\n  apply le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)\n  have I i : âˆƒ C > 0, âˆ€ n, â€–p i nâ€– * (r' : â„) ^ n â‰¤ C :=\n    norm_mul_pow_le_of_lt_radius _ (hr'.trans_le (h i))\n  choose C C_pos hC using I\n  obtain âŸ¨D, D_nonneg, hDâŸ© : âˆƒ D â‰¥ 0, âˆ€ i, C i â‰¤ D :=\n    âŸ¨âˆ‘ i, C i, Finset.sum_nonneg (fun i _ â†¦ (C_pos i).le),\n      fun i â†¦ Finset.single_le_sum (fun j _ â†¦ (C_pos j).le) (Finset.mem_univ _)âŸ©\n  apply le_radius_of_bound _ D (fun n â†¦ ?_)\n  rcases le_or_lt ((r' : â„)^n) 0 with hr' | hr'\n  Â· exact le_trans (mul_nonpos_of_nonneg_of_nonpos (by positivity) hr') D_nonneg\n  Â· simp only [pi]\n    rw [â† le_div_iffâ‚€ hr', ContinuousMultilinearMap.opNorm_pi,\n      pi_norm_le_iff_of_nonneg (by positivity)]\n    intro i\n    exact (le_div_iffâ‚€ hr').2 ((hC i n).trans (hD i))\n\n"}
{"name":"FormalMultilinearSeries.radius_pi_eq_iInf","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nâŠ¢ Eq (FormalMultilinearSeries.pi p).radius (iInf fun i => (p i).radius)","decl":"lemma FormalMultilinearSeries.radius_pi_eq_iInf :\n    (FormalMultilinearSeries.pi p).radius = â¨… i, (p i).radius := by\n  refine le_antisymm (by simp [radius_pi_le]) ?_\n  apply le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)\n  exact le_radius_pi (fun i â†¦ le_iInf_iff.1 hr'.le i)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nr : ENNReal\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhf : âˆ€ (i : Î¹), HasFPowerSeriesWithinOnBall (f i) (p i) s e r\nhr : LT.lt 0 r\nâŠ¢ HasFPowerSeriesWithinOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e r","decl":"/-- If each function in a finite family has a power series within a ball, then so does the\nfamily as a whole. Note that the positivity assumption on the radius is only needed when\nthe family is empty. -/\nlemma HasFPowerSeriesWithinOnBall.pi\n    (hf : âˆ€ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r) (hr : 0 < r) :\n    HasFPowerSeriesWithinOnBall (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) s e r where\n  r_le := by\n    apply FormalMultilinearSeries.le_radius_pi (fun i â†¦ ?_)\n    exact (hf i).r_le\n  r_pos := hr\n  hasSum {_} m hy := Pi.hasSum.2 (fun i â†¦ (hf i).hasSum m hy)\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nr : ENNReal\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhr : LT.lt 0 r\nâŠ¢ Iff (HasFPowerSeriesWithinOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e r) (âˆ€ (i : Î¹), HasFPowerSeriesWithinOnBall (f i) (p i) s e r)","decl":"lemma hasFPowerSeriesWithinOnBall_pi_iff (hr : 0 < r) :\n    HasFPowerSeriesWithinOnBall (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) s e r â†”\n      âˆ€ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r where\n  mp h i :=\n    âŸ¨h.r_le.trans (FormalMultilinearSeries.radius_pi_le _ _), hr,\n      fun m hy â†¦ Pi.hasSum.1 (h.hasSum m hy) iâŸ©\n  mpr h := .pi h hr\n\n"}
{"name":"HasFPowerSeriesOnBall.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\nr : ENNReal\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhf : âˆ€ (i : Î¹), HasFPowerSeriesOnBall (f i) (p i) e r\nhr : LT.lt 0 r\nâŠ¢ HasFPowerSeriesOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e r","decl":"lemma HasFPowerSeriesOnBall.pi\n    (hf : âˆ€ i, HasFPowerSeriesOnBall (f i) (p i) e r) (hr : 0 < r) :\n    HasFPowerSeriesOnBall (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) e r := by\n  simp_rw [â† hasFPowerSeriesWithinOnBall_univ] at hf âŠ¢\n  exact HasFPowerSeriesWithinOnBall.pi hf hr\n\n"}
{"name":"hasFPowerSeriesOnBall_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\nr : ENNReal\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhr : LT.lt 0 r\nâŠ¢ Iff (HasFPowerSeriesOnBall (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e r) (âˆ€ (i : Î¹), HasFPowerSeriesOnBall (f i) (p i) e r)","decl":"lemma hasFPowerSeriesOnBall_pi_iff (hr : 0 < r) :\n    HasFPowerSeriesOnBall (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) e r â†”\n      âˆ€ i, HasFPowerSeriesOnBall (f i) (p i) e r := by\n  simp_rw [â† hasFPowerSeriesWithinOnBall_univ]\n  exact hasFPowerSeriesWithinOnBall_pi_iff hr\n\n"}
{"name":"HasFPowerSeriesWithinAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhf : âˆ€ (i : Î¹), HasFPowerSeriesWithinAt (f i) (p i) s e\nâŠ¢ HasFPowerSeriesWithinAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e","decl":"lemma HasFPowerSeriesWithinAt.pi\n    (hf : âˆ€ i, HasFPowerSeriesWithinAt (f i) (p i) s e) :\n    HasFPowerSeriesWithinAt (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) s e := by\n  have : âˆ€á¶  r in ğ“[>] 0, âˆ€ i, HasFPowerSeriesWithinOnBall (f i) (p i) s e r :=\n    eventually_all.mpr (fun i â†¦ (hf i).eventually)\n  obtain âŸ¨r, hr, r_posâŸ© := (this.and self_mem_nhdsWithin).exists\n  exact âŸ¨r, HasFPowerSeriesWithinOnBall.pi hr r_posâŸ©\n\n"}
{"name":"hasFPowerSeriesWithinAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nâŠ¢ Iff (HasFPowerSeriesWithinAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) s e) (âˆ€ (i : Î¹), HasFPowerSeriesWithinAt (f i) (p i) s e)","decl":"lemma hasFPowerSeriesWithinAt_pi_iff :\n    HasFPowerSeriesWithinAt (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) s e â†”\n      âˆ€ i, HasFPowerSeriesWithinAt (f i) (p i) s e := by\n  refine âŸ¨fun h i â†¦ ?_, fun h â†¦ .pi hâŸ©\n  obtain âŸ¨r, hrâŸ© := h\n  exact âŸ¨r, (hasFPowerSeriesWithinOnBall_pi_iff hr.r_pos).1 hr iâŸ©\n\n"}
{"name":"HasFPowerSeriesAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nhf : âˆ€ (i : Î¹), HasFPowerSeriesAt (f i) (p i) e\nâŠ¢ HasFPowerSeriesAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e","decl":"lemma HasFPowerSeriesAt.pi\n    (hf : âˆ€ i, HasFPowerSeriesAt (f i) (p i) e) :\n    HasFPowerSeriesAt (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) e := by\n  simp_rw [â† hasFPowerSeriesWithinAt_univ] at hf âŠ¢\n  exact HasFPowerSeriesWithinAt.pi hf\n\n"}
{"name":"hasFPowerSeriesAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\np : (i : Î¹) â†’ FormalMultilinearSeries ğ•œ E (Fm i)\nâŠ¢ Iff (HasFPowerSeriesAt (fun x x_1 => f x_1 x) (FormalMultilinearSeries.pi p) e) (âˆ€ (i : Î¹), HasFPowerSeriesAt (f i) (p i) e)","decl":"lemma hasFPowerSeriesAt_pi_iff :\n    HasFPowerSeriesAt (fun x â†¦ (f Â· x)) (FormalMultilinearSeries.pi p) e â†”\n      âˆ€ i, HasFPowerSeriesAt (f i) (p i) e := by\n  simp_rw [â† hasFPowerSeriesWithinAt_univ]\n  exact hasFPowerSeriesWithinAt_pi_iff\n\n"}
{"name":"AnalyticWithinAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nhf : âˆ€ (i : Î¹), AnalyticWithinAt ğ•œ (f i) s e\nâŠ¢ AnalyticWithinAt ğ•œ (fun x x_1 => f x_1 x) s e","decl":"lemma AnalyticWithinAt.pi (hf : âˆ€ i, AnalyticWithinAt ğ•œ (f i) s e) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ (f Â· x)) s e := by\n  choose p hp using hf\n  exact âŸ¨FormalMultilinearSeries.pi p, HasFPowerSeriesWithinAt.pi hpâŸ©\n\n"}
{"name":"analyticWithinAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nâŠ¢ Iff (AnalyticWithinAt ğ•œ (fun x x_1 => f x_1 x) s e) (âˆ€ (i : Î¹), AnalyticWithinAt ğ•œ (f i) s e)","decl":"lemma analyticWithinAt_pi_iff :\n    AnalyticWithinAt ğ•œ (fun x â†¦ (f Â· x)) s e â†” âˆ€ i, AnalyticWithinAt ğ•œ (f i) s e := by\n  refine âŸ¨fun h i â†¦ ?_, fun h â†¦ .pi hâŸ©\n  exact ((ContinuousLinearMap.proj (R := ğ•œ) i).analyticAt _).comp_analyticWithinAt h\n\n"}
{"name":"AnalyticAt.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\nhf : âˆ€ (i : Î¹), AnalyticAt ğ•œ (f i) e\nâŠ¢ AnalyticAt ğ•œ (fun x x_1 => f x_1 x) e","decl":"lemma AnalyticAt.pi (hf : âˆ€ i, AnalyticAt ğ•œ (f i) e) :\n    AnalyticAt ğ•œ (fun x â†¦ (f Â· x)) e := by\n  simp_rw [â† analyticWithinAt_univ] at hf âŠ¢\n  exact AnalyticWithinAt.pi hf\n\n"}
{"name":"analyticAt_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\ne : E\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\nâŠ¢ Iff (AnalyticAt ğ•œ (fun x x_1 => f x_1 x) e) (âˆ€ (i : Î¹), AnalyticAt ğ•œ (f i) e)","decl":"lemma analyticAt_pi_iff :\n    AnalyticAt ğ•œ (fun x â†¦ (f Â· x)) e â†” âˆ€ i, AnalyticAt ğ•œ (f i) e := by\n  simp_rw [â† analyticWithinAt_univ]\n  exact analyticWithinAt_pi_iff\n\n"}
{"name":"AnalyticOn.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nhf : âˆ€ (i : Î¹), AnalyticOn ğ•œ (f i) s\nâŠ¢ AnalyticOn ğ•œ (fun x x_1 => f x_1 x) s","decl":"lemma AnalyticOn.pi (hf : âˆ€ i, AnalyticOn ğ•œ (f i) s) :\n    AnalyticOn ğ•œ (fun x â†¦ (f Â· x)) s :=\n  fun x hx â†¦ AnalyticWithinAt.pi (fun i â†¦ hf i x hx)\n\n"}
{"name":"AnalyticWithinOn.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nhf : âˆ€ (i : Î¹), AnalyticOn ğ•œ (f i) s\nâŠ¢ AnalyticOn ğ•œ (fun x x_1 => f x_1 x) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.pi := AnalyticOn.pi\n\n"}
{"name":"analyticOn_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nâŠ¢ Iff (AnalyticOn ğ•œ (fun x x_1 => f x_1 x) s) (âˆ€ (i : Î¹), AnalyticOn ğ•œ (f i) s)","decl":"lemma analyticOn_pi_iff :\n    AnalyticOn ğ•œ (fun x â†¦ (f Â· x)) s â†” âˆ€ i, AnalyticOn ğ•œ (f i) s :=\n  âŸ¨fun h i x hx â†¦ analyticWithinAt_pi_iff.1 (h x hx) i, fun h â†¦ .pi hâŸ©\n\n"}
{"name":"analyticWithinOn_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nâŠ¢ Iff (AnalyticOn ğ•œ (fun x x_1 => f x_1 x) s) (âˆ€ (i : Î¹), AnalyticOn ğ•œ (f i) s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_pi_iff := analyticOn_pi_iff\n\n"}
{"name":"AnalyticOnNhd.pi","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nhf : âˆ€ (i : Î¹), AnalyticOnNhd ğ•œ (f i) s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x x_1 => f x_1 x) s","decl":"lemma AnalyticOnNhd.pi (hf : âˆ€ i, AnalyticOnNhd ğ•œ (f i) s) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ (f Â· x)) s :=\n  fun x hx â†¦ AnalyticAt.pi (fun i â†¦ hf i x hx)\n\n"}
{"name":"analyticOnNhd_pi_iff","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nFm : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (Fm i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (Fm i)\nf : (i : Î¹) â†’ E â†’ Fm i\ns : Set E\nâŠ¢ Iff (AnalyticOnNhd ğ•œ (fun x x_1 => f x_1 x) s) (âˆ€ (i : Î¹), AnalyticOnNhd ğ•œ (f i) s)","decl":"lemma analyticOnNhd_pi_iff :\n    AnalyticOnNhd ğ•œ (fun x â†¦ (f Â· x)) s â†” âˆ€ i, AnalyticOnNhd ğ•œ (f i) s :=\n  âŸ¨fun h i x hx â†¦ analyticAt_pi_iff.1 (h x hx) i, fun h â†¦ .pi hâŸ©\n\n"}
{"name":"analyticAt_smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• E\ninstâœ : IsScalarTower ğ•œ ğ• E\nz : Prod ğ• E\nâŠ¢ AnalyticAt ğ•œ (fun x => HSMul.hSMul x.1 x.2) z","decl":"/-- Scalar multiplication is analytic (jointly in both variables). The statement is a little\npedantic to allow towers of field extensions.\n\nTODO: can we replace `ğ•œ'` with a \"normed module\" in such a way that `analyticAt_mul` is a special\ncase of this? -/\n@[fun_prop]\nlemma analyticAt_smul [NormedSpace ğ• E] [IsScalarTower ğ•œ ğ• E] (z : ğ• Ã— E) :\n    AnalyticAt ğ•œ (fun x : ğ• Ã— E â†¦ x.1 â€¢ x.2) z :=\n  (ContinuousLinearMap.lsmul ğ•œ ğ•).analyticAt_bilinear z\n\n"}
{"name":"analyticAt_mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nz : Prod A A\nâŠ¢ AnalyticAt ğ•œ (fun x => HMul.hMul x.1 x.2) z","decl":"/-- Multiplication in a normed algebra over `ğ•œ` is analytic. -/\n@[fun_prop]\nlemma analyticAt_mul (z : A Ã— A) : AnalyticAt ğ•œ (fun x : A Ã— A â†¦ x.1 * x.2) z :=\n  (ContinuousLinearMap.mul ğ•œ A).analyticAt_bilinear z\n\n"}
{"name":"AnalyticWithinAt.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\ns : Set E\nz : E\nhf : AnalyticWithinAt ğ•œ f s z\nhg : AnalyticWithinAt ğ•œ g s z\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => HSMul.hSMul (f x) (g x)) s z","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticWithinAt.smul [NormedSpace ğ• F] [IsScalarTower ğ•œ ğ• F]\n    {f : E â†’ ğ•} {g : E â†’ F} {s : Set E} {z : E}\n    (hf : AnalyticWithinAt ğ•œ f s z) (hg : AnalyticWithinAt ğ•œ g s z) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ f x â€¢ g x) s z :=\n  (analyticAt_smul _).compâ‚‚_analyticWithinAt hf hg\n\n"}
{"name":"AnalyticAt.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\nz : E\nhf : AnalyticAt ğ•œ f z\nhg : AnalyticAt ğ•œ g z\nâŠ¢ AnalyticAt ğ•œ (HSMul.hSMul f g) z","decl":"/-- Scalar multiplication of one analytic function by another. -/\n@[fun_prop]\nlemma AnalyticAt.smul [NormedSpace ğ• F] [IsScalarTower ğ•œ ğ• F] {f : E â†’ ğ•} {g : E â†’ F} {z : E}\n    (hf : AnalyticAt ğ•œ f z) (hg : AnalyticAt ğ•œ g z) :\n    AnalyticAt ğ•œ (f â€¢ g) z :=\n  (analyticAt_smul _).compâ‚‚ hf hg\n\n"}
{"name":"AnalyticAt.smul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\nz : E\nhf : AnalyticAt ğ•œ f z\nhg : AnalyticAt ğ•œ g z\nâŠ¢ AnalyticAt ğ•œ (fun x => HSMul.hSMul (f x) (g x)) z","decl":"/-- Scalar multiplication of one analytic function by another. -/\n@[fun_prop]\nlemma AnalyticAt.smul' [NormedSpace ğ• F] [IsScalarTower ğ•œ ğ• F] {f : E â†’ ğ•} {g : E â†’ F} {z : E}\n    (hf : AnalyticAt ğ•œ f z) (hg : AnalyticAt ğ•œ g z) :\n    AnalyticAt ğ•œ (fun x â†¦ f x â€¢ g x) z :=\n  hf.smul hg\n\n"}
{"name":"AnalyticOn.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticOn.smul [NormedSpace ğ• F] [IsScalarTower ğ•œ ğ• F]\n    {f : E â†’ ğ•} {g : E â†’ F} {s : Set E}\n    (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g s) :\n    AnalyticOn ğ•œ (fun x â†¦ f x â€¢ g x) s :=\n  fun _ m â†¦ (hf _ m).smul (hg _ m)\n\n"}
{"name":"AnalyticWithinOn.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => HSMul.hSMul (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.smul := AnalyticOn.smul\n\n"}
{"name":"AnalyticOnNhd.smul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nğ• : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•\ninstâœÂ² : NormedAlgebra ğ•œ ğ•\ninstâœÂ¹ : NormedSpace ğ• F\ninstâœ : IsScalarTower ğ•œ ğ• F\nf : E â†’ ğ•\ng : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOnNhd ğ•œ g s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- Scalar multiplication of one analytic function by another. -/\nlemma AnalyticOnNhd.smul [NormedSpace ğ• F] [IsScalarTower ğ•œ ğ• F] {f : E â†’ ğ•} {g : E â†’ F} {s : Set E}\n    (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOnNhd ğ•œ g s) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ f x â€¢ g x) s :=\n  fun _ m â†¦ (hf _ m).smul (hg _ m)\n\n"}
{"name":"AnalyticWithinAt.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\ns : Set E\nz : E\nhf : AnalyticWithinAt ğ•œ f s z\nhg : AnalyticWithinAt ğ•œ g s z\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => HMul.hMul (f x) (g x)) s z","decl":"/-- Multiplication of analytic functions (valued in a normed `ğ•œ`-algebra) is analytic. -/\nlemma AnalyticWithinAt.mul {f g : E â†’ A} {s : Set E} {z : E}\n    (hf : AnalyticWithinAt ğ•œ f s z) (hg : AnalyticWithinAt ğ•œ g s z) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ f x * g x) s z :=\n  (analyticAt_mul _).compâ‚‚_analyticWithinAt hf hg\n\n"}
{"name":"AnalyticAt.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\nz : E\nhf : AnalyticAt ğ•œ f z\nhg : AnalyticAt ğ•œ g z\nâŠ¢ AnalyticAt ğ•œ (HMul.hMul f g) z","decl":"/-- Multiplication of analytic functions (valued in a normed `ğ•œ`-algebra) is analytic. -/\n@[fun_prop]\nlemma AnalyticAt.mul {f g : E â†’ A} {z : E} (hf : AnalyticAt ğ•œ f z) (hg : AnalyticAt ğ•œ g z) :\n    AnalyticAt ğ•œ (f * g) z :=\n  (analyticAt_mul _).compâ‚‚ hf hg\n\n"}
{"name":"AnalyticAt.mul'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\nz : E\nhf : AnalyticAt ğ•œ f z\nhg : AnalyticAt ğ•œ g z\nâŠ¢ AnalyticAt ğ•œ (fun x => HMul.hMul (f x) (g x)) z","decl":"@[fun_prop]\nlemma AnalyticAt.mul' {f g : E â†’ A} {z : E} (hf : AnalyticAt ğ•œ f z) (hg : AnalyticAt ğ•œ g z) :\n    AnalyticAt ğ•œ (fun x â†¦ f x * g x) z :=\n  hf.mul hg\n\n"}
{"name":"AnalyticOn.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- Multiplication of analytic functions (valued in a normed `ğ•œ`-algebra) is analytic. -/\nlemma AnalyticOn.mul {f g : E â†’ A} {s : Set E}\n    (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g s) :\n    AnalyticOn ğ•œ (fun x â†¦ f x * g x) s :=\n  fun _ m â†¦ (hf _ m).mul (hg _ m)\n\n"}
{"name":"AnalyticWithinOn.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g s\nâŠ¢ AnalyticOn ğ•œ (fun x => HMul.hMul (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.mul := AnalyticOn.mul\n\n"}
{"name":"AnalyticOnNhd.mul","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf g : E â†’ A\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOnNhd ğ•œ g s\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- Multiplication of analytic functions (valued in a normed `ğ•œ`-algebra) is analytic. -/\nlemma AnalyticOnNhd.mul {f g : E â†’ A} {s : Set E}\n    (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOnNhd ğ•œ g s) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ f x * g x) s :=\n  fun _ m â†¦ (hf _ m).mul (hg _ m)\n\n"}
{"name":"AnalyticWithinAt.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : E â†’ A\nz : E\ns : Set E\nhf : AnalyticWithinAt ğ•œ f s z\nn : Nat\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => HPow.hPow (f x) n) s z","decl":"/-- Powers of analytic functions (into a normed `ğ•œ`-algebra) are analytic. -/\nlemma AnalyticWithinAt.pow {f : E â†’ A} {z : E} {s : Set E} (hf : AnalyticWithinAt ğ•œ f s z) (n : â„•) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ f x ^ n) s z := by\n  induction n with\n  | zero =>\n    simp only [pow_zero]\n    apply analyticWithinAt_const\n  | succ m hm =>\n    simp only [pow_succ]\n    exact hm.mul hf\n\n"}
{"name":"AnalyticAt.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : E â†’ A\nz : E\nhf : AnalyticAt ğ•œ f z\nn : Nat\nâŠ¢ AnalyticAt ğ•œ (fun x => HPow.hPow (f x) n) z","decl":"/-- Powers of analytic functions (into a normed `ğ•œ`-algebra) are analytic. -/\n@[fun_prop]\nlemma AnalyticAt.pow {f : E â†’ A} {z : E} (hf : AnalyticAt ğ•œ f z) (n : â„•) :\n    AnalyticAt ğ•œ (fun x â†¦ f x ^ n) z := by\n  rw [â† analyticWithinAt_univ] at hf âŠ¢\n  exact hf.pow n\n\n"}
{"name":"AnalyticOn.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : E â†’ A\ns : Set E\nhf : AnalyticOn ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOn ğ•œ (fun x => HPow.hPow (f x) n) s","decl":"/-- Powers of analytic functions (into a normed `ğ•œ`-algebra) are analytic. -/\nlemma AnalyticOn.pow {f : E â†’ A} {s : Set E} (hf : AnalyticOn ğ•œ f s) (n : â„•) :\n    AnalyticOn ğ•œ (fun x â†¦ f x ^ n) s :=\n  fun _ m â†¦ (hf _ m).pow n\n\n"}
{"name":"AnalyticWithinOn.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : E â†’ A\ns : Set E\nhf : AnalyticOn ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOn ğ•œ (fun x => HPow.hPow (f x) n) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.pow := AnalyticOn.pow\n\n"}
{"name":"AnalyticOnNhd.pow","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_8\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : E â†’ A\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nn : Nat\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => HPow.hPow (f x) n) s","decl":"/-- Powers of analytic functions (into a normed `ğ•œ`-algebra) are analytic. -/\nlemma AnalyticOnNhd.pow {f : E â†’ A} {s : Set E} (hf : AnalyticOnNhd ğ•œ f s) (n : â„•) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ f x ^ n) s :=\n  fun _ m â†¦ (hf _ m).pow n\n\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ' E F\nx : E\ns : Set E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ HasFPowerSeriesWithinOnBall f (FormalMultilinearSeries.restrictScalars ğ•œ p) s x r","decl":"lemma HasFPowerSeriesWithinOnBall.restrictScalars (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    HasFPowerSeriesWithinOnBall f (p.restrictScalars ğ•œ) s x r :=\n  âŸ¨hf.r_le.trans (FormalMultilinearSeries.radius_le_of_le (fun n â†¦ by simp)), hf.r_pos, hf.hasSumâŸ©\n\n"}
{"name":"HasFPowerSeriesOnBall.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ' E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ HasFPowerSeriesOnBall f (FormalMultilinearSeries.restrictScalars ğ•œ p) x r","decl":"lemma HasFPowerSeriesOnBall.restrictScalars (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall f (p.restrictScalars ğ•œ) x r :=\n  âŸ¨hf.r_le.trans (FormalMultilinearSeries.radius_le_of_le (fun n â†¦ by simp)), hf.r_pos, hf.hasSumâŸ©\n\n"}
{"name":"HasFPowerSeriesWithinAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ' E F\nx : E\ns : Set E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ HasFPowerSeriesWithinAt f (FormalMultilinearSeries.restrictScalars ğ•œ p) s x","decl":"lemma HasFPowerSeriesWithinAt.restrictScalars (hf : HasFPowerSeriesWithinAt f p s x) :\n    HasFPowerSeriesWithinAt f (p.restrictScalars ğ•œ) s x := by\n  rcases hf with âŸ¨r, hrâŸ©\n  exact âŸ¨r, hr.restrictScalarsâŸ©\n\n"}
{"name":"HasFPowerSeriesAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ' E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ HasFPowerSeriesAt f (FormalMultilinearSeries.restrictScalars ğ•œ p) x","decl":"lemma HasFPowerSeriesAt.restrictScalars (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesAt f (p.restrictScalars ğ•œ) x := by\n  rcases hf with âŸ¨r, hrâŸ©\n  exact âŸ¨r, hr.restrictScalarsâŸ©\n\n"}
{"name":"AnalyticWithinAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\nx : E\ns : Set E\nhf : AnalyticWithinAt ğ•œ' f s x\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"lemma AnalyticWithinAt.restrictScalars (hf : AnalyticWithinAt ğ•œ' f s x) :\n    AnalyticWithinAt ğ•œ f s x := by\n  rcases hf with âŸ¨p, hpâŸ©\n  exact âŸ¨p.restrictScalars ğ•œ, hp.restrictScalarsâŸ©\n\n"}
{"name":"AnalyticAt.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ' f x\nâŠ¢ AnalyticAt ğ•œ f x","decl":"lemma AnalyticAt.restrictScalars (hf : AnalyticAt ğ•œ' f x) :\n    AnalyticAt ğ•œ f x := by\n  rcases hf with âŸ¨p, hpâŸ©\n  exact âŸ¨p.restrictScalars ğ•œ, hp.restrictScalarsâŸ©\n\n"}
{"name":"AnalyticOn.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ' f s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"lemma AnalyticOn.restrictScalars (hf : AnalyticOn ğ•œ' f s) :\n    AnalyticOn ğ•œ f s :=\n  fun x hx â†¦ (hf x hx).restrictScalars\n\n"}
{"name":"AnalyticOnNhd.restrictScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nf : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ' f s\nâŠ¢ AnalyticOnNhd ğ•œ f s","decl":"lemma AnalyticOnNhd.restrictScalars (hf : AnalyticOnNhd ğ•œ' f s) :\n    AnalyticOnNhd ğ•œ f s :=\n  fun x hx â†¦ (hf x hx).restrictScalars\n\n"}
{"name":"formalMultilinearSeries_geometric_eq_ofScalars","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\nA : Type u_10\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ Eq (formalMultilinearSeries_geometric ğ•œ A) (FormalMultilinearSeries.ofScalars A fun x => 1)","decl":"/-- The geometric series as an `ofScalars` series. -/\ntheorem formalMultilinearSeries_geometric_eq_ofScalars :\n    formalMultilinearSeries_geometric ğ•œ A =\n      FormalMultilinearSeries.ofScalars A fun _ â†¦ (1 : ğ•œ) := by\n  simp_rw [FormalMultilinearSeries.ext_iff, FormalMultilinearSeries.ofScalars,\n    formalMultilinearSeries_geometric, one_smul, implies_true]\n\n"}
{"name":"formalMultilinearSeries_geometric_apply_norm_le","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\nA : Type u_10\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nn : Nat\nâŠ¢ LE.le (Norm.norm (formalMultilinearSeries_geometric ğ•œ A n)) (Max.max 1 (Norm.norm 1))","decl":"lemma formalMultilinearSeries_geometric_apply_norm_le (n : â„•) :\n    â€–formalMultilinearSeries_geometric ğ•œ A nâ€– â‰¤ max 1 â€–(1 : A)â€– :=\n  ContinuousMultilinearMap.norm_mkPiAlgebraFin_le\n\n"}
{"name":"formalMultilinearSeries_geometric_apply_norm","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\nA : Type u_10\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : NormOneClass A\nn : Nat\nâŠ¢ Eq (Norm.norm (formalMultilinearSeries_geometric ğ•œ A n)) 1","decl":"lemma formalMultilinearSeries_geometric_apply_norm [NormOneClass A] (n : â„•) :\n    â€–formalMultilinearSeries_geometric ğ•œ A nâ€– = 1 :=\n  ContinuousMultilinearMap.norm_mkPiAlgebraFin\n\n"}
{"name":"one_le_formalMultilinearSeries_geometric_radius","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ² : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ LE.le 1 (formalMultilinearSeries_geometric ğ•œ A).radius","decl":"lemma one_le_formalMultilinearSeries_geometric_radius (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]\n    (A : Type*) [NormedRing A] [NormedAlgebra ğ•œ A] :\n    1 â‰¤ (formalMultilinearSeries_geometric ğ•œ A).radius := by\n  convert formalMultilinearSeries_geometric_eq_ofScalars ğ•œ A â–¸\n    FormalMultilinearSeries.ofScalars_radius_ge_inv_of_tendsto A _ one_ne_zero (by simp) |>.le\n  simp\n\n"}
{"name":"formalMultilinearSeries_geometric_radius","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormOneClass A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ Eq (formalMultilinearSeries_geometric ğ•œ A).radius 1","decl":"lemma formalMultilinearSeries_geometric_radius (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]\n    (A : Type*) [NormedRing A] [NormOneClass A] [NormedAlgebra ğ•œ A] :\n    (formalMultilinearSeries_geometric ğ•œ A).radius = 1 :=\n  formalMultilinearSeries_geometric_eq_ofScalars ğ•œ A â–¸\n    FormalMultilinearSeries.ofScalars_radius_eq_of_tendsto A _ one_ne_zero (by simp)\n\n"}
{"name":"hasFPowerSeriesOnBall_inverse_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : HasSummableGeomSeries A\nâŠ¢ HasFPowerSeriesOnBall (fun x => Ring.inverse (HSub.hSub 1 x)) (formalMultilinearSeries_geometric ğ•œ A) 0 1","decl":"lemma hasFPowerSeriesOnBall_inverse_one_sub\n    (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]\n    (A : Type*) [NormedRing A] [NormedAlgebra ğ•œ A] [HasSummableGeomSeries A] :\n    HasFPowerSeriesOnBall (fun x : A â†¦ Ring.inverse (1 - x))\n      (formalMultilinearSeries_geometric ğ•œ A) 0 1 := by\n  constructor\n  Â· exact one_le_formalMultilinearSeries_geometric_radius ğ•œ A\n  Â· exact one_pos\n  Â· intro y hy\n    simp only [EMetric.mem_ball, edist_dist, dist_zero_right, ofReal_lt_one] at hy\n    simp only [zero_add, NormedRing.inverse_one_sub _ hy, Units.oneSub, Units.inv_mk,\n      formalMultilinearSeries_geometric, ContinuousMultilinearMap.mkPiAlgebraFin_apply,\n      List.ofFn_const, List.prod_replicate]\n    exact (summable_geometric_of_norm_lt_one hy).hasSum\n\n"}
{"name":"analyticAt_inverse_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : HasSummableGeomSeries A\nâŠ¢ AnalyticAt ğ•œ (fun x => Ring.inverse (HSub.hSub 1 x)) 0","decl":"@[fun_prop]\nlemma analyticAt_inverse_one_sub (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]\n    (A : Type*) [NormedRing A] [NormedAlgebra ğ•œ A] [HasSummableGeomSeries A] :\n    AnalyticAt ğ•œ (fun x : A â†¦ Ring.inverse (1 - x)) 0 :=\n  âŸ¨_, âŸ¨_, hasFPowerSeriesOnBall_inverse_one_sub ğ•œ AâŸ©âŸ©\n\n"}
{"name":"analyticAt_inverse","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : HasSummableGeomSeries A\nz : Units A\nâŠ¢ AnalyticAt ğ•œ Ring.inverse â†‘z","decl":"/-- If `A` is a normed algebra over `ğ•œ` with summable geometric series, then inversion on `A` is\nanalytic at any unit. -/\n@[fun_prop]\nlemma analyticAt_inverse {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]\n    {A : Type*} [NormedRing A] [NormedAlgebra ğ•œ A] [HasSummableGeomSeries A] (z : AË£) :\n    AnalyticAt ğ•œ Ring.inverse (z : A) := by\n  rcases subsingleton_or_nontrivial A with hA|hA\n  Â· convert analyticAt_const (v := (0 : A))\n  Â· let f1 : A â†’ A := fun a â†¦ a * z.inv\n    let f2 : A â†’ A := fun b â†¦ Ring.inverse (1 - b)\n    let f3 : A â†’ A := fun c â†¦ 1 - z.inv * c\n    have feq : âˆ€á¶  y in ğ“ (z : A), (f1 âˆ˜ f2 âˆ˜ f3) y = Ring.inverse y := by\n      have : Metric.ball (z : A) (â€–(â†‘zâ»Â¹ : A)â€–â»Â¹) âˆˆ ğ“ (z : A) := by\n        apply Metric.ball_mem_nhds\n        simp\n      filter_upwards [this] with y hy\n      simp only [Metric.mem_ball, dist_eq_norm] at hy\n      have : y = Units.ofNearby z y hy := rfl\n      rw [this, Eq.comm]\n      simp only [Ring.inverse_unit, Function.comp_apply]\n      simp [Units.ofNearby, f1, f2, f3, Units.add, _root_.mul_sub]\n      rw [â† Ring.inverse_unit]\n      congr\n      simp\n    apply AnalyticAt.congr _ feq\n    apply (analyticAt_id.mul analyticAt_const).comp\n    apply AnalyticAt.comp\n    Â· simp only [Units.inv_eq_val_inv, Units.inv_mul, sub_self, f2, f3]\n      exact analyticAt_inverse_one_sub ğ•œ A\n    Â· exact analyticAt_const.sub (analyticAt_const.mul analyticAt_id)\n\n"}
{"name":"analyticOnNhd_inverse","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nA : Type u_10\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : HasSummableGeomSeries A\nâŠ¢ AnalyticOnNhd ğ•œ Ring.inverse (setOf fun x => IsUnit x)","decl":"lemma analyticOnNhd_inverse {ğ•œ : Type*} [NontriviallyNormedField ğ•œ]\n    {A : Type*} [NormedRing A] [NormedAlgebra ğ•œ A] [HasSummableGeomSeries A] :\n    AnalyticOnNhd ğ•œ Ring.inverse {x : A | IsUnit x} :=\n  fun _ hx â†¦ analyticAt_inverse (IsUnit.unit hx)\n\n"}
{"name":"hasFPowerSeriesOnBall_inv_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_9\nğ• : Type u_10\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nâŠ¢ HasFPowerSeriesOnBall (fun x => Inv.inv (HSub.hSub 1 x)) (formalMultilinearSeries_geometric ğ•œ ğ•) 0 1","decl":"lemma hasFPowerSeriesOnBall_inv_one_sub\n    (ğ•œ ğ• : Type*) [NontriviallyNormedField ğ•œ] [NontriviallyNormedField ğ•] [NormedAlgebra ğ•œ ğ•] :\n    HasFPowerSeriesOnBall (fun x : ğ• â†¦ (1 - x)â»Â¹) (formalMultilinearSeries_geometric ğ•œ ğ•) 0 1 := by\n  convert hasFPowerSeriesOnBall_inverse_one_sub ğ•œ ğ•\n  exact Ring.inverse_eq_inv'.symm\n\n"}
{"name":"analyticAt_inv_one_sub","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ• : Type u_9\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nâŠ¢ AnalyticAt ğ•œ (fun x => Inv.inv (HSub.hSub 1 x)) 0","decl":"@[fun_prop]\nlemma analyticAt_inv_one_sub (ğ• : Type*) [NontriviallyNormedField ğ•] [NormedAlgebra ğ•œ ğ•] :\n    AnalyticAt ğ•œ (fun x : ğ• â†¦ (1 - x)â»Â¹) 0 :=\n  âŸ¨_, âŸ¨_, hasFPowerSeriesOnBall_inv_one_sub ğ•œ ğ•âŸ©âŸ©\n\n"}
{"name":"analyticAt_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nz : ğ•\nhz : Ne z 0\nâŠ¢ AnalyticAt ğ•œ Inv.inv z","decl":"/-- If `ğ•` is a normed field extension of `ğ•œ`, then the inverse map `ğ• â†’ ğ•` is `ğ•œ`-analytic\naway from 0. -/\n@[fun_prop]\nlemma analyticAt_inv {z : ğ•} (hz : z â‰  0) : AnalyticAt ğ•œ Inv.inv z := by\n  convert analyticAt_inverse (ğ•œ := ğ•œ) (Units.mk0 _ hz)\n  exact Ring.inverse_eq_inv'.symm\n\n"}
{"name":"analyticOnNhd_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nâŠ¢ AnalyticOnNhd ğ•œ (fun z => Inv.inv z) (setOf fun z => Ne z 0)","decl":"/-- `xâ»Â¹` is analytic away from zero -/\nlemma analyticOnNhd_inv : AnalyticOnNhd ğ•œ (fun z â†¦ zâ»Â¹) {z : ğ• | z â‰  0} := by\n  intro z m; exact analyticAt_inv m\n\n"}
{"name":"analyticOn_inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nâŠ¢ AnalyticOn ğ•œ (fun z => Inv.inv z) (setOf fun z => Ne z 0)","decl":"lemma analyticOn_inv : AnalyticOn ğ•œ (fun z â†¦ zâ»Â¹) {z : ğ• | z â‰  0} :=\n  analyticOnNhd_inv.analyticOn\n\n"}
{"name":"AnalyticWithinAt.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\nx : E\ns : Set E\nfa : AnalyticWithinAt ğ•œ f s x\nf0 : Ne (f x) 0\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => Inv.inv (f x)) s x","decl":"/-- `(f x)â»Â¹` is analytic away from `f x = 0` -/\ntheorem AnalyticWithinAt.inv {f : E â†’ ğ•} {x : E} {s : Set E}\n    (fa : AnalyticWithinAt ğ•œ f s x) (f0 : f x â‰  0) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ (f x)â»Â¹) s x :=\n  (analyticAt_inv f0).comp_analyticWithinAt fa\n\n"}
{"name":"AnalyticAt.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\nx : E\nfa : AnalyticAt ğ•œ f x\nf0 : Ne (f x) 0\nâŠ¢ AnalyticAt ğ•œ (Inv.inv f) x","decl":"/-- `(f x)â»Â¹` is analytic away from `f x = 0` -/\n@[fun_prop]\ntheorem AnalyticAt.inv {f : E â†’ ğ•} {x : E} (fa : AnalyticAt ğ•œ f x) (f0 : f x â‰  0) :\n    AnalyticAt ğ•œ fâ»Â¹ x :=\n  (analyticAt_inv f0).comp fa\n\n"}
{"name":"AnalyticAt.inv'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\nx : E\nfa : AnalyticAt ğ•œ f x\nf0 : Ne (f x) 0\nâŠ¢ AnalyticAt ğ•œ (fun x => Inv.inv (f x)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.inv' {f : E â†’ ğ•} {x : E} (fa : AnalyticAt ğ•œ f x) (f0 : f x â‰  0) :\n    AnalyticAt ğ•œ (fun x â†¦ (f x)â»Â¹) x :=\n  fa.inv f0\n\n"}
{"name":"AnalyticOn.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\ns : Set E\nfa : AnalyticOn ğ•œ f s\nf0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (f x) 0\nâŠ¢ AnalyticOn ğ•œ (fun x => Inv.inv (f x)) s","decl":"/-- `(f x)â»Â¹` is analytic away from `f x = 0` -/\ntheorem AnalyticOn.inv {f : E â†’ ğ•} {s : Set E}\n    (fa : AnalyticOn ğ•œ f s) (f0 : âˆ€ x âˆˆ s, f x â‰  0) :\n    AnalyticOn ğ•œ (fun x â†¦ (f x)â»Â¹) s :=\n  fun x m â†¦ (fa x m).inv (f0 x m)\n\n"}
{"name":"AnalyticWithinOn.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\ns : Set E\nfa : AnalyticOn ğ•œ f s\nf0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (f x) 0\nâŠ¢ AnalyticOn ğ•œ (fun x => Inv.inv (f x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.inv := AnalyticOn.inv\n\n"}
{"name":"AnalyticOnNhd.inv","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf : E â†’ ğ•\ns : Set E\nfa : AnalyticOnNhd ğ•œ f s\nf0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (f x) 0\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => Inv.inv (f x)) s","decl":"/-- `(f x)â»Â¹` is analytic away from `f x = 0` -/\ntheorem AnalyticOnNhd.inv {f : E â†’ ğ•} {s : Set E}\n    (fa : AnalyticOnNhd ğ•œ f s) (f0 : âˆ€ x âˆˆ s, f x â‰  0) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ (f x)â»Â¹) s :=\n  fun x m â†¦ (fa x m).inv (f0 x m)\n\n"}
{"name":"AnalyticWithinAt.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\ns : Set E\nx : E\nfa : AnalyticWithinAt ğ•œ f s x\nga : AnalyticWithinAt ğ•œ g s x\ng0 : Ne (g x) 0\nâŠ¢ AnalyticWithinAt ğ•œ (fun x => HDiv.hDiv (f x) (g x)) s x","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticWithinAt.div {f g : E â†’ ğ•} {s : Set E} {x : E}\n    (fa : AnalyticWithinAt ğ•œ f s x) (ga : AnalyticWithinAt ğ•œ g s x) (g0 : g x â‰  0) :\n    AnalyticWithinAt ğ•œ (fun x â†¦ f x / g x) s x := by\n  simp_rw [div_eq_mul_inv]; exact fa.mul (ga.inv g0)\n\n"}
{"name":"AnalyticAt.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\nx : E\nfa : AnalyticAt ğ•œ f x\nga : AnalyticAt ğ•œ g x\ng0 : Ne (g x) 0\nâŠ¢ AnalyticAt ğ•œ (HDiv.hDiv f g) x","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\n@[fun_prop]\ntheorem AnalyticAt.div {f g : E â†’ ğ•} {x : E}\n    (fa : AnalyticAt ğ•œ f x) (ga : AnalyticAt ğ•œ g x) (g0 : g x â‰  0) :\n    AnalyticAt ğ•œ (f / g) x := by\n  simp_rw [div_eq_mul_inv]; exact fa.mul (ga.inv g0)\n\n"}
{"name":"AnalyticAt.div'","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\nx : E\nfa : AnalyticAt ğ•œ f x\nga : AnalyticAt ğ•œ g x\ng0 : Ne (g x) 0\nâŠ¢ AnalyticAt ğ•œ (fun x => HDiv.hDiv (f x) (g x)) x","decl":"@[fun_prop]\ntheorem AnalyticAt.div' {f g : E â†’ ğ•} {x : E}\n    (fa : AnalyticAt ğ•œ f x) (ga : AnalyticAt ğ•œ g x) (g0 : g x â‰  0) :\n    AnalyticAt ğ•œ (fun x â†¦ f x / g x) x :=\n  fa.div ga g0\n\n"}
{"name":"AnalyticOn.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\ns : Set E\nfa : AnalyticOn ğ•œ f s\nga : AnalyticOn ğ•œ g s\ng0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ AnalyticOn ğ•œ (fun x => HDiv.hDiv (f x) (g x)) s","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticOn.div {f g : E â†’ ğ•} {s : Set E}\n    (fa : AnalyticOn ğ•œ f s) (ga : AnalyticOn ğ•œ g s) (g0 : âˆ€ x âˆˆ s, g x â‰  0) :\n    AnalyticOn ğ•œ (fun x â†¦ f x / g x) s := fun x m â†¦\n  (fa x m).div (ga x m) (g0 x m)\n\n"}
{"name":"AnalyticWithinOn.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\ns : Set E\nfa : AnalyticOn ğ•œ f s\nga : AnalyticOn ğ•œ g s\ng0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ AnalyticOn ğ•œ (fun x => HDiv.hDiv (f x) (g x)) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.div := AnalyticOn.div\n\n"}
{"name":"AnalyticOnNhd.div","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ• : Type u_7\ninstâœÂ¹ : NontriviallyNormedField ğ•\ninstâœ : NormedAlgebra ğ•œ ğ•\nf g : E â†’ ğ•\ns : Set E\nfa : AnalyticOnNhd ğ•œ f s\nga : AnalyticOnNhd ğ•œ g s\ng0 : âˆ€ (x : E), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ AnalyticOnNhd ğ•œ (fun x => HDiv.hDiv (f x) (g x)) s","decl":"/-- `f x / g x` is analytic away from `g x = 0` -/\ntheorem AnalyticOnNhd.div {f g : E â†’ ğ•} {s : Set E}\n    (fa : AnalyticOnNhd ğ•œ f s) (ga : AnalyticOnNhd ğ•œ g s) (g0 : âˆ€ x âˆˆ s, g x â‰  0) :\n    AnalyticOnNhd ğ•œ (fun x â†¦ f x / g x) s := fun x m â†¦\n  (fa x m).div (ga x m) (g0 x m)\n\n"}
{"name":"Finset.analyticWithinAt_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nc : E\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticWithinAt ğ•œ (f n) s c\nâŠ¢ AnalyticWithinAt ğ•œ (fun z => N.sum fun n => f n z) s c","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticWithinAt_sum {f : Î± â†’ E â†’ F} {c : E} {s : Set E}\n    (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticWithinAt ğ•œ (f n) s c) :\n    AnalyticWithinAt ğ•œ (fun z â†¦ âˆ‘ n âˆˆ N, f n z) s c := by\n  classical\n  induction' N using Finset.induction with a B aB hB\n  Â· simp only [Finset.sum_empty]\n    exact analyticWithinAt_const\n  Â· simp_rw [Finset.sum_insert aB]\n    simp only [Finset.mem_insert] at h\n    exact (h a (Or.inl rfl)).add (hB fun b m â†¦ h b (Or.inr m))\n\n"}
{"name":"Finset.analyticAt_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nc : E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticAt ğ•œ (f n) c\nâŠ¢ AnalyticAt ğ•œ (fun z => N.sum fun n => f n z) c","decl":"/-- Finite sums of analytic functions are analytic -/\n@[fun_prop]\ntheorem Finset.analyticAt_sum {f : Î± â†’ E â†’ F} {c : E}\n    (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticAt ğ•œ (f n) c) :\n    AnalyticAt ğ•œ (fun z â†¦ âˆ‘ n âˆˆ N, f n z) c := by\n  simp_rw [â† analyticWithinAt_univ] at h âŠ¢\n  exact N.analyticWithinAt_sum h\n\n"}
{"name":"Finset.analyticOn_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOn ğ•œ (f n) s\nâŠ¢ AnalyticOn ğ•œ (fun z => N.sum fun n => f n z) s","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticOn_sum {f : Î± â†’ E â†’ F} {s : Set E}\n    (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticOn ğ•œ (f n) s) :\n    AnalyticOn ğ•œ (fun z â†¦ âˆ‘ n âˆˆ N, f n z) s :=\n  fun z zs â†¦ N.analyticWithinAt_sum (fun n m â†¦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinOn_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOn ğ•œ (f n) s\nâŠ¢ AnalyticOn ğ•œ (fun z => N.sum fun n => f n z) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias Finset.analyticWithinOn_sum := Finset.analyticOn_sum\n\n"}
{"name":"Finset.analyticOnNhd_sum","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOnNhd ğ•œ (f n) s\nâŠ¢ AnalyticOnNhd ğ•œ (fun z => N.sum fun n => f n z) s","decl":"/-- Finite sums of analytic functions are analytic -/\ntheorem Finset.analyticOnNhd_sum {f : Î± â†’ E â†’ F} {s : Set E}\n    (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticOnNhd ğ•œ (f n) s) :\n    AnalyticOnNhd ğ•œ (fun z â†¦ âˆ‘ n âˆˆ N, f n z) s :=\n  fun z zs â†¦ N.analyticAt_sum (fun n m â†¦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinAt_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_9\ninstâœÂ¹ : NormedCommRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : Î± â†’ E â†’ A\nc : E\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticWithinAt ğ•œ (f n) s c\nâŠ¢ AnalyticWithinAt ğ•œ (fun z => N.prod fun n => f n z) s c","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticWithinAt_prod {A : Type*} [NormedCommRing A] [NormedAlgebra ğ•œ A]\n    {f : Î± â†’ E â†’ A} {c : E} {s : Set E} (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticWithinAt ğ•œ (f n) s c) :\n    AnalyticWithinAt ğ•œ (fun z â†¦ âˆ n âˆˆ N, f n z) s c := by\n  classical\n  induction' N using Finset.induction with a B aB hB\n  Â· simp only [Finset.prod_empty]\n    exact analyticWithinAt_const\n  Â· simp_rw [Finset.prod_insert aB]\n    simp only [Finset.mem_insert] at h\n    exact (h a (Or.inl rfl)).mul (hB fun b m â†¦ h b (Or.inr m))\n\n"}
{"name":"Finset.analyticAt_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_9\ninstâœÂ¹ : NormedCommRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : Î± â†’ E â†’ A\nc : E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticAt ğ•œ (f n) c\nâŠ¢ AnalyticAt ğ•œ (fun z => N.prod fun n => f n z) c","decl":"/-- Finite products of analytic functions are analytic -/\n@[fun_prop]\ntheorem Finset.analyticAt_prod {A : Type*} [NormedCommRing A] [NormedAlgebra ğ•œ A]\n    {f : Î± â†’ E â†’ A} {c : E} (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticAt ğ•œ (f n) c) :\n    AnalyticAt ğ•œ (fun z â†¦ âˆ n âˆˆ N, f n z) c := by\n  simp_rw [â† analyticWithinAt_univ] at h âŠ¢\n  exact N.analyticWithinAt_prod h\n\n"}
{"name":"Finset.analyticOn_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_9\ninstâœÂ¹ : NormedCommRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : Î± â†’ E â†’ A\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOn ğ•œ (f n) s\nâŠ¢ AnalyticOn ğ•œ (fun z => N.prod fun n => f n z) s","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticOn_prod {A : Type*} [NormedCommRing A] [NormedAlgebra ğ•œ A]\n    {f : Î± â†’ E â†’ A} {s : Set E} (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticOn ğ•œ (f n) s) :\n    AnalyticOn ğ•œ (fun z â†¦ âˆ n âˆˆ N, f n z) s :=\n  fun z zs â†¦ N.analyticWithinAt_prod (fun n m â†¦ h n m z zs)\n\n"}
{"name":"Finset.analyticWithinOn_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_9\ninstâœÂ¹ : NormedCommRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : Î± â†’ E â†’ A\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOn ğ•œ (f n) s\nâŠ¢ AnalyticOn ğ•œ (fun z => N.prod fun n => f n z) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias Finset.analyticWithinOn_prod := Finset.analyticOn_prod\n\n"}
{"name":"Finset.analyticOnNhd_prod","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nA : Type u_9\ninstâœÂ¹ : NormedCommRing A\ninstâœ : NormedAlgebra ğ•œ A\nf : Î± â†’ E â†’ A\ns : Set E\nN : Finset Î±\nh : âˆ€ (n : Î±), Membership.mem N n â†’ AnalyticOnNhd ğ•œ (f n) s\nâŠ¢ AnalyticOnNhd ğ•œ (fun z => N.prod fun n => f n z) s","decl":"/-- Finite products of analytic functions are analytic -/\ntheorem Finset.analyticOnNhd_prod {A : Type*} [NormedCommRing A] [NormedAlgebra ğ•œ A]\n    {f : Î± â†’ E â†’ A} {s : Set E} (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticOnNhd ğ•œ (f n) s) :\n    AnalyticOnNhd ğ•œ (fun z â†¦ âˆ n âˆˆ N, f n z) s :=\n  fun z zs â†¦ N.analyticAt_prod (fun n m â†¦ h n m z zs)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\npf : FormalMultilinearSeries ğ•œ E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\ns : Set E\nx : E\nr : ENNReal\nz : F\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) s x r","decl":"theorem HasFPowerSeriesWithinOnBall.unshift (hf : HasFPowerSeriesWithinOnBall f pf s x r) :\n    HasFPowerSeriesWithinOnBall (fun y â†¦ z + f y (y - x)) (pf.unshift z) s x r where\n  r_le := by\n    rw [FormalMultilinearSeries.radius_unshift]\n    exact hf.r_le\n  r_pos := hf.r_pos\n  hasSum := by\n    intro y hy h'y\n    apply HasSum.zero_add\n    simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one,\n      continuousMultilinearCurryRightEquiv_symm_apply', add_sub_cancel_left]\n    exact (ContinuousLinearMap.apply ğ•œ F y).hasSum (hf.hasSum hy h'y)\n\n"}
{"name":"HasFPowerSeriesOnBall.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\npf : FormalMultilinearSeries ğ•œ E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nx : E\nr : ENNReal\nz : F\nhf : HasFPowerSeriesOnBall f pf x r\nâŠ¢ HasFPowerSeriesOnBall (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) x r","decl":"theorem HasFPowerSeriesOnBall.unshift (hf : HasFPowerSeriesOnBall f pf x r) :\n    HasFPowerSeriesOnBall (fun y â†¦ z + f y (y - x)) (pf.unshift z) x r where\n  r_le := by\n    rw [FormalMultilinearSeries.radius_unshift]\n    exact hf.r_le\n  r_pos := hf.r_pos\n  hasSum := by\n    intro y hy\n    apply HasSum.zero_add\n    simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one,\n      continuousMultilinearCurryRightEquiv_symm_apply', add_sub_cancel_left]\n    exact (ContinuousLinearMap.apply ğ•œ F y).hasSum (hf.hasSum hy)\n\n"}
{"name":"HasFPowerSeriesWithinAt.unshift","module":"Mathlib.Analysis.Analytic.Constructions","initialProofState":"ğ•œ : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_3\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\npf : FormalMultilinearSeries ğ•œ E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\ns : Set E\nx : E\nz : F\nhf : HasFPowerSeriesWithinAt f pf s x\nâŠ¢ HasFPowerSeriesWithinAt (fun y => HAdd.hAdd z ((f y) (HSub.hSub y x))) (pf.unshift z) s x","decl":"theorem HasFPowerSeriesWithinAt.unshift (hf : HasFPowerSeriesWithinAt f pf s x) :\n    HasFPowerSeriesWithinAt (fun y â†¦ z + f y (y - x)) (pf.unshift z) s x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.unshift.hasFPowerSeriesWithinAt\n\n"}
