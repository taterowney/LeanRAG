{"name":"GeneralizedBooleanAlgebra.sup_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : GeneralizedBooleanAlgebra α\na b : α\n⊢ Eq (Max.max (Min.min a b) (SDiff.sdiff a b)) a","decl":"/-- A generalized Boolean algebra is a distributive lattice with `⊥` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a ⊓ b) ⊔ (a \\ b) = a` and\n`(a ⊓ b) ⊓ (a \\ b) = ⊥`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `Finset α` for arbitrary\n(not-necessarily-`Fintype`) `α`. -/\nclass GeneralizedBooleanAlgebra (α : Type u) extends DistribLattice α, SDiff α, Bot α where\n  /-- For any `a`, `b`, `(a ⊓ b) ⊔ (a / b) = a` -/\n  sup_inf_sdiff : ∀ a b : α, a ⊓ b ⊔ a \\ b = a\n  /-- For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` -/\n  inf_inf_sdiff : ∀ a b : α, a ⊓ b ⊓ a \\ b = ⊥\n\n-- We might want an `IsCompl_of` predicate (for relative complements) generalizing `IsCompl`,\n-- however we'd need another type class for lattices with bot, and all the API for that.\n"}
{"name":"GeneralizedBooleanAlgebra.inf_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : GeneralizedBooleanAlgebra α\na b : α\n⊢ Eq (Min.min (Min.min a b) (SDiff.sdiff a b)) Bot.bot","decl":"/-- A generalized Boolean algebra is a distributive lattice with `⊥` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a ⊓ b) ⊔ (a \\ b) = a` and\n`(a ⊓ b) ⊓ (a \\ b) = ⊥`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `Finset α` for arbitrary\n(not-necessarily-`Fintype`) `α`. -/\nclass GeneralizedBooleanAlgebra (α : Type u) extends DistribLattice α, SDiff α, Bot α where\n  /-- For any `a`, `b`, `(a ⊓ b) ⊔ (a / b) = a` -/\n  sup_inf_sdiff : ∀ a b : α, a ⊓ b ⊔ a \\ b = a\n  /-- For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` -/\n  inf_inf_sdiff : ∀ a b : α, a ⊓ b ⊓ a \\ b = ⊥\n\n-- We might want an `IsCompl_of` predicate (for relative complements) generalizing `IsCompl`,\n-- however we'd need another type class for lattices with bot, and all the API for that.\n"}
{"name":"sup_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y : α\n⊢ Eq (Max.max (Min.min x y) (SDiff.sdiff x y)) x","decl":"@[simp]\ntheorem sup_inf_sdiff (x y : α) : x ⊓ y ⊔ x \\ y = x :=\n  GeneralizedBooleanAlgebra.sup_inf_sdiff _ _\n\n"}
{"name":"inf_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y : α\n⊢ Eq (Min.min (Min.min x y) (SDiff.sdiff x y)) Bot.bot","decl":"@[simp]\ntheorem inf_inf_sdiff (x y : α) : x ⊓ y ⊓ x \\ y = ⊥ :=\n  GeneralizedBooleanAlgebra.inf_inf_sdiff _ _\n\n"}
{"name":"sup_sdiff_inf","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y : α\n⊢ Eq (Max.max (SDiff.sdiff x y) (Min.min x y)) x","decl":"@[simp]\ntheorem sup_sdiff_inf (x y : α) : x \\ y ⊔ x ⊓ y = x := by rw [sup_comm, sup_inf_sdiff]\n\n"}
{"name":"inf_sdiff_inf","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y : α\n⊢ Eq (Min.min (SDiff.sdiff x y) (Min.min x y)) Bot.bot","decl":"@[simp]\ntheorem inf_sdiff_inf (x y : α) : x \\ y ⊓ (x ⊓ y) = ⊥ := by rw [inf_comm, inf_inf_sdiff]\n\n-- see Note [lower instance priority]\n"}
{"name":"disjoint_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Disjoint (Min.min x y) (SDiff.sdiff x y)","decl":"theorem disjoint_inf_sdiff : Disjoint (x ⊓ y) (x \\ y) :=\n  disjoint_iff_inf_le.mpr (inf_inf_sdiff x y).le\n\n-- TODO: in distributive lattices, relative complements are unique when they exist\n"}
{"name":"sdiff_unique","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\ns : Eq (Max.max (Min.min x y) z) x\ni : Eq (Min.min (Min.min x y) z) Bot.bot\n⊢ Eq (SDiff.sdiff x y) z","decl":"theorem sdiff_unique (s : x ⊓ y ⊔ z = x) (i : x ⊓ y ⊓ z = ⊥) : x \\ y = z := by\n  conv_rhs at s => rw [← sup_inf_sdiff x y, sup_comm]\n  rw [sup_comm] at s\n  conv_rhs at i => rw [← inf_inf_sdiff x y, inf_comm]\n  rw [inf_comm] at i\n  exact (eq_of_inf_eq_sup_eq i s).symm\n\n-- Use `sdiff_le`\n"}
{"name":"sdiff_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (Min.min (SDiff.sdiff x y) (SDiff.sdiff y x)) Bot.bot","decl":"@[simp]\ntheorem sdiff_inf_sdiff : x \\ y ⊓ y \\ x = ⊥ :=\n  Eq.symm <|\n    calc\n      ⊥ = x ⊓ y ⊓ x \\ y := by rw [inf_inf_sdiff]\n      _ = x ⊓ (y ⊓ x ⊔ y \\ x) ⊓ x \\ y := by rw [sup_inf_sdiff]\n      _ = (x ⊓ (y ⊓ x) ⊔ x ⊓ y \\ x) ⊓ x \\ y := by rw [inf_sup_left]\n      _ = (y ⊓ (x ⊓ x) ⊔ x ⊓ y \\ x) ⊓ x \\ y := by ac_rfl\n      _ = (y ⊓ x ⊔ x ⊓ y \\ x) ⊓ x \\ y := by rw [inf_idem]\n      _ = x ⊓ y ⊓ x \\ y ⊔ x ⊓ y \\ x ⊓ x \\ y := by rw [inf_sup_right, inf_comm x y]\n      _ = x ⊓ y \\ x ⊓ x \\ y := by rw [inf_inf_sdiff, bot_sup_eq]\n      _ = x ⊓ x \\ y ⊓ y \\ x := by ac_rfl\n      _ = x \\ y ⊓ y \\ x := by rw [inf_of_le_right sdiff_le']\n\n"}
{"name":"disjoint_sdiff_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Disjoint (SDiff.sdiff x y) (SDiff.sdiff y x)","decl":"theorem disjoint_sdiff_sdiff : Disjoint (x \\ y) (y \\ x) :=\n  disjoint_iff_inf_le.mpr sdiff_inf_sdiff.le\n\n"}
{"name":"inf_sdiff_self_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (Min.min x (SDiff.sdiff y x)) Bot.bot","decl":"@[simp]\ntheorem inf_sdiff_self_right : x ⊓ y \\ x = ⊥ :=\n  calc\n    x ⊓ y \\ x = (x ⊓ y ⊔ x \\ y) ⊓ y \\ x := by rw [sup_inf_sdiff]\n    _ = x ⊓ y ⊓ y \\ x ⊔ x \\ y ⊓ y \\ x := by rw [inf_sup_right]\n    _ = ⊥ := by rw [inf_comm x y, inf_inf_sdiff, sdiff_inf_sdiff, bot_sup_eq]\n\n"}
{"name":"inf_sdiff_self_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (Min.min (SDiff.sdiff y x) x) Bot.bot","decl":"@[simp]\ntheorem inf_sdiff_self_left : y \\ x ⊓ x = ⊥ := by rw [inf_comm, inf_sdiff_self_right]\n\n-- see Note [lower instance priority]\n"}
{"name":"disjoint_sdiff_self_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Disjoint (SDiff.sdiff y x) x","decl":"theorem disjoint_sdiff_self_left : Disjoint (y \\ x) x :=\n  disjoint_iff_inf_le.mpr inf_sdiff_self_left.le\n\n"}
{"name":"disjoint_sdiff_self_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Disjoint x (SDiff.sdiff y x)","decl":"theorem disjoint_sdiff_self_right : Disjoint x (y \\ x) :=\n  disjoint_iff_inf_le.mpr inf_sdiff_self_right.le\n\n"}
{"name":"le_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (LE.le x (SDiff.sdiff y z)) (And (LE.le x y) (Disjoint x z))","decl":"lemma le_sdiff : x ≤ y \\ z ↔ x ≤ y ∧ Disjoint x z :=\n  ⟨fun h ↦ ⟨h.trans sdiff_le, disjoint_sdiff_self_left.mono_left h⟩, fun h ↦\n    by rw [← h.2.sdiff_eq_left]; exact sdiff_le_sdiff_right h.1⟩\n\n"}
{"name":"sdiff_eq_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Eq (SDiff.sdiff x y) x) (Disjoint x y)","decl":"@[simp] lemma sdiff_eq_left : x \\ y = x ↔ Disjoint x y :=\n  ⟨fun h ↦ disjoint_sdiff_self_left.mono_left h.ge, Disjoint.sdiff_eq_left⟩\n\n/- TODO: we could make an alternative constructor for `GeneralizedBooleanAlgebra` using\n`Disjoint x (y \\ x)` and `x ⊔ (y \\ x) = y` as axioms. -/\n"}
{"name":"Disjoint.sdiff_eq_of_sup_eq","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhi : Disjoint x z\nhs : Eq (Max.max x z) y\n⊢ Eq (SDiff.sdiff y x) z","decl":"theorem Disjoint.sdiff_eq_of_sup_eq (hi : Disjoint x z) (hs : x ⊔ z = y) : y \\ x = z :=\n  have h : y ⊓ x = x := inf_eq_right.2 <| le_sup_left.trans hs.le\n  sdiff_unique (by rw [h, hs]) (by rw [h, hi.eq_bot])\n\n"}
{"name":"Disjoint.sdiff_unique","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhd : Disjoint x z\nhz : LE.le z y\nhs : LE.le y (Max.max x z)\n⊢ Eq (SDiff.sdiff y x) z","decl":"protected theorem Disjoint.sdiff_unique (hd : Disjoint x z) (hz : z ≤ y) (hs : y ≤ x ⊔ z) :\n    y \\ x = z :=\n  sdiff_unique\n    (by\n      rw [← inf_eq_right] at hs\n      rwa [sup_inf_right, inf_sup_right, sup_comm x, inf_sup_self, inf_comm, sup_comm z,\n        hs, sup_eq_left])\n    (by rw [inf_assoc, hd.eq_bot, inf_bot_eq])\n\n-- cf. `IsCompl.disjoint_left_iff` and `IsCompl.disjoint_right_iff`\n"}
{"name":"disjoint_sdiff_iff_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhz : LE.le z y\nhx : LE.le x y\n⊢ Iff (Disjoint z (SDiff.sdiff y x)) (LE.le z x)","decl":"theorem disjoint_sdiff_iff_le (hz : z ≤ y) (hx : x ≤ y) : Disjoint z (y \\ x) ↔ z ≤ x :=\n  ⟨fun H =>\n    le_of_inf_le_sup_le (le_trans H.le_bot bot_le)\n      (by\n        rw [sup_sdiff_cancel_right hx]\n        refine le_trans (sup_le_sup_left sdiff_le z) ?_\n        rw [sup_eq_right.2 hz]),\n    fun H => disjoint_sdiff_self_right.mono_left H⟩\n\n-- cf. `IsCompl.le_left_iff` and `IsCompl.le_right_iff`\n"}
{"name":"le_iff_disjoint_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhz : LE.le z y\nhx : LE.le x y\n⊢ Iff (LE.le z x) (Disjoint z (SDiff.sdiff y x))","decl":"theorem le_iff_disjoint_sdiff (hz : z ≤ y) (hx : x ≤ y) : z ≤ x ↔ Disjoint z (y \\ x) :=\n  (disjoint_sdiff_iff_le hz hx).symm\n\n-- cf. `IsCompl.inf_left_eq_bot_iff` and `IsCompl.inf_right_eq_bot_iff`\n"}
{"name":"inf_sdiff_eq_bot_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhz : LE.le z y\nhx : LE.le x y\n⊢ Iff (Eq (Min.min z (SDiff.sdiff y x)) Bot.bot) (LE.le z x)","decl":"theorem inf_sdiff_eq_bot_iff (hz : z ≤ y) (hx : x ≤ y) : z ⊓ y \\ x = ⊥ ↔ z ≤ x := by\n  rw [← disjoint_iff]\n  exact disjoint_sdiff_iff_le hz hx\n\n-- cf. `IsCompl.left_le_iff` and `IsCompl.right_le_iff`\n"}
{"name":"le_iff_eq_sup_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhz : LE.le z y\nhx : LE.le x y\n⊢ Iff (LE.le x z) (Eq y (Max.max z (SDiff.sdiff y x)))","decl":"theorem le_iff_eq_sup_sdiff (hz : z ≤ y) (hx : x ≤ y) : x ≤ z ↔ y = z ⊔ y \\ x :=\n  ⟨fun H => by\n    apply le_antisymm\n    · conv_lhs => rw [← sup_inf_sdiff y x]\n      apply sup_le_sup_right\n      rwa [inf_eq_right.2 hx]\n    · apply le_trans\n      · apply sup_le_sup_right hz\n      · rw [sup_sdiff_left],\n    fun H => by\n    conv_lhs at H => rw [← sup_sdiff_cancel_right hx]\n    refine le_of_inf_le_sup_le ?_ H.le\n    rw [inf_sdiff_self_right]\n    exact bot_le⟩\n\n-- cf. `IsCompl.sup_inf`\n"}
{"name":"sdiff_sup","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff y (Max.max x z)) (Min.min (SDiff.sdiff y x) (SDiff.sdiff y z))","decl":"theorem sdiff_sup : y \\ (x ⊔ z) = y \\ x ⊓ y \\ z :=\n  sdiff_unique\n    (calc\n      y ⊓ (x ⊔ z) ⊔ y \\ x ⊓ y \\ z = (y ⊓ (x ⊔ z) ⊔ y \\ x) ⊓ (y ⊓ (x ⊔ z) ⊔ y \\ z) := by\n          rw [sup_inf_left]\n      _ = (y ⊓ x ⊔ y ⊓ z ⊔ y \\ x) ⊓ (y ⊓ x ⊔ y ⊓ z ⊔ y \\ z) := by rw [@inf_sup_left _ _ y]\n      _ = (y ⊓ z ⊔ (y ⊓ x ⊔ y \\ x)) ⊓ (y ⊓ x ⊔ (y ⊓ z ⊔ y \\ z)) := by ac_rfl\n      _ = (y ⊓ z ⊔ y) ⊓ (y ⊓ x ⊔ y) := by rw [sup_inf_sdiff, sup_inf_sdiff]\n      _ = (y ⊔ y ⊓ z) ⊓ (y ⊔ y ⊓ x) := by ac_rfl\n      _ = y := by rw [sup_inf_self, sup_inf_self, inf_idem])\n    (calc\n      y ⊓ (x ⊔ z) ⊓ (y \\ x ⊓ y \\ z) = (y ⊓ x ⊔ y ⊓ z) ⊓ (y \\ x ⊓ y \\ z) := by rw [inf_sup_left]\n      _ = y ⊓ x ⊓ (y \\ x ⊓ y \\ z) ⊔ y ⊓ z ⊓ (y \\ x ⊓ y \\ z) := by rw [inf_sup_right]\n      _ = y ⊓ x ⊓ y \\ x ⊓ y \\ z ⊔ y \\ x ⊓ (y \\ z ⊓ (y ⊓ z)) := by ac_rfl\n      _ = ⊥ := by rw [inf_inf_sdiff, bot_inf_eq, bot_sup_eq, inf_comm (y \\ z),\n                      inf_inf_sdiff, inf_bot_eq])\n\n"}
{"name":"sdiff_eq_sdiff_iff_inf_eq_inf","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Eq (SDiff.sdiff y x) (SDiff.sdiff y z)) (Eq (Min.min y x) (Min.min y z))","decl":"theorem sdiff_eq_sdiff_iff_inf_eq_inf : y \\ x = y \\ z ↔ y ⊓ x = y ⊓ z :=\n  ⟨fun h => eq_of_inf_eq_sup_eq (a := y \\ x) (by rw [inf_inf_sdiff, h, inf_inf_sdiff])\n    (by rw [sup_inf_sdiff, h, sup_inf_sdiff]),\n    fun h => by rw [← sdiff_inf_self_right, ← sdiff_inf_self_right z y, inf_comm, h, inf_comm]⟩\n\n"}
{"name":"sdiff_eq_self_iff_disjoint","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Eq (SDiff.sdiff x y) x) (Disjoint y x)","decl":"theorem sdiff_eq_self_iff_disjoint : x \\ y = x ↔ Disjoint y x :=\n  calc\n    x \\ y = x ↔ x \\ y = x \\ ⊥ := by rw [sdiff_bot]\n    _ ↔ x ⊓ y = x ⊓ ⊥ := sdiff_eq_sdiff_iff_inf_eq_inf\n    _ ↔ Disjoint y x := by rw [inf_bot_eq, inf_comm, disjoint_iff]\n\n"}
{"name":"sdiff_eq_self_iff_disjoint'","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Eq (SDiff.sdiff x y) x) (Disjoint x y)","decl":"theorem sdiff_eq_self_iff_disjoint' : x \\ y = x ↔ Disjoint x y := by\n  rw [sdiff_eq_self_iff_disjoint, disjoint_comm]\n\n"}
{"name":"sdiff_lt","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\nhx : LE.le y x\nhy : Ne y Bot.bot\n⊢ LT.lt (SDiff.sdiff x y) x","decl":"theorem sdiff_lt (hx : y ≤ x) (hy : y ≠ ⊥) : x \\ y < x := by\n  refine sdiff_le.lt_of_ne fun h => hy ?_\n  rw [sdiff_eq_self_iff_disjoint', disjoint_iff] at h\n  rw [← h, inf_eq_right.mpr hx]\n\n"}
{"name":"le_sdiff_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (LE.le x (SDiff.sdiff y x)) (Eq x Bot.bot)","decl":"@[simp]\ntheorem le_sdiff_iff : x ≤ y \\ x ↔ x = ⊥ :=\n  ⟨fun h => disjoint_self.1 (disjoint_sdiff_self_right.mono_right h), fun h => h.le.trans bot_le⟩\n\n"}
{"name":"sdiff_eq_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Eq (SDiff.sdiff x y) y) (And (Eq x Bot.bot) (Eq y Bot.bot))","decl":"@[simp] lemma sdiff_eq_right : x \\ y = y ↔ x = ⊥ ∧ y = ⊥ := by\n  rw [disjoint_sdiff_self_left.eq_iff]; aesop\n\n"}
{"name":"sdiff_ne_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Ne (SDiff.sdiff x y) y) (Or (Ne x Bot.bot) (Ne y Bot.bot))","decl":"lemma sdiff_ne_right : x \\ y ≠ y ↔ x ≠ ⊥ ∨ y ≠ ⊥ := sdiff_eq_right.not.trans not_and_or\n\n"}
{"name":"sdiff_lt_sdiff_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nh : LT.lt x y\nhz : LE.le z x\n⊢ LT.lt (SDiff.sdiff x z) (SDiff.sdiff y z)","decl":"theorem sdiff_lt_sdiff_right (h : x < y) (hz : z ≤ x) : x \\ z < y \\ z :=\n  (sdiff_le_sdiff_right h.le).lt_of_not_le\n    fun h' => h.not_le <| le_sdiff_sup.trans <| sup_le_of_le_sdiff_right h' hz\n\n"}
{"name":"sup_inf_inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (Max.max (Min.min (Min.min x y) z) (SDiff.sdiff y z)) (Max.max (Min.min x y) (SDiff.sdiff y z))","decl":"theorem sup_inf_inf_sdiff : x ⊓ y ⊓ z ⊔ y \\ z = x ⊓ y ⊔ y \\ z :=\n  calc\n    x ⊓ y ⊓ z ⊔ y \\ z = x ⊓ (y ⊓ z) ⊔ y \\ z := by rw [inf_assoc]\n    _ = (x ⊔ y \\ z) ⊓ y := by rw [sup_inf_right, sup_inf_sdiff]\n    _ = x ⊓ y ⊔ y \\ z := by rw [inf_sup_right, inf_sdiff_left]\n\n"}
{"name":"sdiff_sdiff_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff x (SDiff.sdiff y z)) (Max.max (SDiff.sdiff x y) (Min.min (Min.min x y) z))","decl":"theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y ⊔ x ⊓ y ⊓ z := by\n  rw [sup_comm, inf_comm, ← inf_assoc, sup_inf_inf_sdiff]\n  apply sdiff_unique\n  · calc\n      x ⊓ y \\ z ⊔ (z ⊓ x ⊔ x \\ y) = (x ⊔ (z ⊓ x ⊔ x \\ y)) ⊓ (y \\ z ⊔ (z ⊓ x ⊔ x \\ y)) := by\n          rw [sup_inf_right]\n      _ = (x ⊔ x ⊓ z ⊔ x \\ y) ⊓ (y \\ z ⊔ (x ⊓ z ⊔ x \\ y)) := by ac_rfl\n      _ = x ⊓ (y \\ z ⊔ x ⊓ z ⊔ x \\ y) := by rw [sup_inf_self, sup_sdiff_left, ← sup_assoc]\n      _ = x ⊓ (y \\ z ⊓ (z ⊔ y) ⊔ x ⊓ (z ⊔ y) ⊔ x \\ y) := by\n          rw [sup_inf_left, sdiff_sup_self', inf_sup_right, sup_comm y]\n      _ = x ⊓ (y \\ z ⊔ (x ⊓ z ⊔ x ⊓ y) ⊔ x \\ y) := by\n          rw [inf_sdiff_sup_right, @inf_sup_left _ _ x z y]\n      _ = x ⊓ (y \\ z ⊔ (x ⊓ z ⊔ (x ⊓ y ⊔ x \\ y))) := by ac_rfl\n      _ = x ⊓ (y \\ z ⊔ (x ⊔ x ⊓ z)) := by rw [sup_inf_sdiff, sup_comm (x ⊓ z)]\n      _ = x := by rw [sup_inf_self, sup_comm, inf_sup_self]\n  · calc\n      x ⊓ y \\ z ⊓ (z ⊓ x ⊔ x \\ y) = x ⊓ y \\ z ⊓ (z ⊓ x) ⊔ x ⊓ y \\ z ⊓ x \\ y := by rw [inf_sup_left]\n      _ = x ⊓ (y \\ z ⊓ z ⊓ x) ⊔ x ⊓ y \\ z ⊓ x \\ y := by ac_rfl\n      _ = x ⊓ y \\ z ⊓ x \\ y := by rw [inf_sdiff_self_left, bot_inf_eq, inf_bot_eq, bot_sup_eq]\n      _ = x ⊓ (y \\ z ⊓ y) ⊓ x \\ y := by conv_lhs => rw [← inf_sdiff_left]\n      _ = x ⊓ (y \\ z ⊓ (y ⊓ x \\ y)) := by ac_rfl\n      _ = ⊥ := by rw [inf_sdiff_self_right, inf_bot_eq, inf_bot_eq]\n\n"}
{"name":"sdiff_sdiff_right'","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff x (SDiff.sdiff y z)) (Max.max (SDiff.sdiff x y) (Min.min x z))","decl":"theorem sdiff_sdiff_right' : x \\ (y \\ z) = x \\ y ⊔ x ⊓ z :=\n  calc\n    x \\ (y \\ z) = x \\ y ⊔ x ⊓ y ⊓ z := sdiff_sdiff_right\n    _ = z ⊓ x ⊓ y ⊔ x \\ y := by ac_rfl\n    _ = x \\ y ⊔ x ⊓ z := by rw [sup_inf_inf_sdiff, sup_comm, inf_comm]\n\n"}
{"name":"sdiff_sdiff_eq_sdiff_sup","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nh : LE.le z x\n⊢ Eq (SDiff.sdiff x (SDiff.sdiff y z)) (Max.max (SDiff.sdiff x y) z)","decl":"theorem sdiff_sdiff_eq_sdiff_sup (h : z ≤ x) : x \\ (y \\ z) = x \\ y ⊔ z := by\n  rw [sdiff_sdiff_right', inf_eq_right.2 h]\n\n"}
{"name":"sdiff_sdiff_right_self","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff x (SDiff.sdiff x y)) (Min.min x y)","decl":"@[simp]\ntheorem sdiff_sdiff_right_self : x \\ (x \\ y) = x ⊓ y := by\n  rw [sdiff_sdiff_right, inf_idem, sdiff_self, bot_sup_eq]\n\n"}
{"name":"sdiff_sdiff_eq_self","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\nh : LE.le y x\n⊢ Eq (SDiff.sdiff x (SDiff.sdiff x y)) y","decl":"theorem sdiff_sdiff_eq_self (h : y ≤ x) : x \\ (x \\ y) = y := by\n  rw [sdiff_sdiff_right_self, inf_of_le_right h]\n\n"}
{"name":"sdiff_eq_symm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhy : LE.le y x\nh : Eq (SDiff.sdiff x y) z\n⊢ Eq (SDiff.sdiff x z) y","decl":"theorem sdiff_eq_symm (hy : y ≤ x) (h : x \\ y = z) : x \\ z = y := by\n  rw [← h, sdiff_sdiff_eq_self hy]\n\n"}
{"name":"sdiff_eq_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhy : LE.le y x\nhz : LE.le z x\n⊢ Iff (Eq (SDiff.sdiff x y) z) (Eq (SDiff.sdiff x z) y)","decl":"theorem sdiff_eq_comm (hy : y ≤ x) (hz : z ≤ x) : x \\ y = z ↔ x \\ z = y :=\n  ⟨sdiff_eq_symm hy, sdiff_eq_symm hz⟩\n\n"}
{"name":"eq_of_sdiff_eq_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhxz : LE.le x z\nhyz : LE.le y z\nh : Eq (SDiff.sdiff z x) (SDiff.sdiff z y)\n⊢ Eq x y","decl":"theorem eq_of_sdiff_eq_sdiff (hxz : x ≤ z) (hyz : y ≤ z) (h : z \\ x = z \\ y) : x = y := by\n  rw [← sdiff_sdiff_eq_self hxz, h, sdiff_sdiff_eq_self hyz]\n\n"}
{"name":"sdiff_le_sdiff_iff_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhx : LE.le x z\nhy : LE.le y z\n⊢ Iff (LE.le (SDiff.sdiff z x) (SDiff.sdiff z y)) (LE.le y x)","decl":"theorem sdiff_le_sdiff_iff_le (hx : x ≤ z) (hy : y ≤ z) : z \\ x ≤ z \\ y ↔ y ≤ x := by\n  refine ⟨fun h ↦ ?_, sdiff_le_sdiff_left⟩\n  rw [← sdiff_sdiff_eq_self hx, ← sdiff_sdiff_eq_self hy]\n  exact sdiff_le_sdiff_left h\n\n"}
{"name":"sdiff_sdiff_left'","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff (SDiff.sdiff x y) z) (Min.min (SDiff.sdiff x y) (SDiff.sdiff x z))","decl":"theorem sdiff_sdiff_left' : (x \\ y) \\ z = x \\ y ⊓ x \\ z := by rw [sdiff_sdiff_left, sdiff_sup]\n\n"}
{"name":"sdiff_sdiff_sup_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff z (Max.max (SDiff.sdiff x y) (SDiff.sdiff y x))) (Min.min (Min.min z (Max.max (SDiff.sdiff z x) y)) (Max.max (SDiff.sdiff z y) x))","decl":"theorem sdiff_sdiff_sup_sdiff : z \\ (x \\ y ⊔ y \\ x) = z ⊓ (z \\ x ⊔ y) ⊓ (z \\ y ⊔ x) :=\n  calc\n    z \\ (x \\ y ⊔ y \\ x) = (z \\ x ⊔ z ⊓ x ⊓ y) ⊓ (z \\ y ⊔ z ⊓ y ⊓ x) := by\n        rw [sdiff_sup, sdiff_sdiff_right, sdiff_sdiff_right]\n    _ = z ⊓ (z \\ x ⊔ y) ⊓ (z \\ y ⊔ z ⊓ y ⊓ x) := by rw [sup_inf_left, sup_comm, sup_inf_sdiff]\n    _ = z ⊓ (z \\ x ⊔ y) ⊓ (z ⊓ (z \\ y ⊔ x)) := by\n        rw [sup_inf_left, sup_comm (z \\ y), sup_inf_sdiff]\n    _ = z ⊓ z ⊓ (z \\ x ⊔ y) ⊓ (z \\ y ⊔ x) := by ac_rfl\n    _ = z ⊓ (z \\ x ⊔ y) ⊓ (z \\ y ⊔ x) := by rw [inf_idem]\n\n"}
{"name":"sdiff_sdiff_sup_sdiff'","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff z (Max.max (SDiff.sdiff x y) (SDiff.sdiff y x))) (Max.max (Min.min (Min.min z x) y) (Min.min (SDiff.sdiff z x) (SDiff.sdiff z y)))","decl":"theorem sdiff_sdiff_sup_sdiff' : z \\ (x \\ y ⊔ y \\ x) = z ⊓ x ⊓ y ⊔ z \\ x ⊓ z \\ y :=\n  calc\n    z \\ (x \\ y ⊔ y \\ x) = z \\ (x \\ y) ⊓ z \\ (y \\ x) := sdiff_sup\n    _ = (z \\ x ⊔ z ⊓ x ⊓ y) ⊓ (z \\ y ⊔ z ⊓ y ⊓ x) := by rw [sdiff_sdiff_right, sdiff_sdiff_right]\n    _ = (z \\ x ⊔ z ⊓ y ⊓ x) ⊓ (z \\ y ⊔ z ⊓ y ⊓ x) := by ac_rfl\n    _ = z \\ x ⊓ z \\ y ⊔ z ⊓ y ⊓ x := by rw [← sup_inf_right]\n    _ = z ⊓ x ⊓ y ⊔ z \\ x ⊓ z \\ y := by ac_rfl\n\n"}
{"name":"sdiff_sdiff_sdiff_cancel_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhca : LE.le z x\n⊢ Eq (SDiff.sdiff (SDiff.sdiff x y) (SDiff.sdiff x z)) (SDiff.sdiff z y)","decl":"lemma sdiff_sdiff_sdiff_cancel_left (hca : z ≤ x) : (x \\ y) \\ (x \\ z) = z \\ y :=\n  sdiff_sdiff_sdiff_le_sdiff.antisymm <|\n    (disjoint_sdiff_self_right.mono_left sdiff_le).le_sdiff_of_le_left <| sdiff_le_sdiff_right hca\n\n"}
{"name":"sdiff_sdiff_sdiff_cancel_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nhcb : LE.le z y\n⊢ Eq (SDiff.sdiff (SDiff.sdiff x z) (SDiff.sdiff y z)) (SDiff.sdiff x y)","decl":"lemma sdiff_sdiff_sdiff_cancel_right (hcb : z ≤ y) : (x \\ z) \\ (y \\ z) = x \\ y := by\n  rw [le_antisymm_iff, sdiff_le_comm]\n  exact ⟨sdiff_sdiff_sdiff_le_sdiff,\n    (disjoint_sdiff_self_left.mono_right sdiff_le).le_sdiff_of_le_left <| sdiff_le_sdiff_left hcb⟩\n\n"}
{"name":"inf_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (SDiff.sdiff (Min.min x y) z) (Min.min (SDiff.sdiff x z) (SDiff.sdiff y z))","decl":"theorem inf_sdiff : (x ⊓ y) \\ z = x \\ z ⊓ y \\ z :=\n  sdiff_unique\n    (calc\n      x ⊓ y ⊓ z ⊔ x \\ z ⊓ y \\ z = (x ⊓ y ⊓ z ⊔ x \\ z) ⊓ (x ⊓ y ⊓ z ⊔ y \\ z) := by rw [sup_inf_left]\n      _ = (x ⊓ y ⊓ (z ⊔ x) ⊔ x \\ z) ⊓ (x ⊓ y ⊓ z ⊔ y \\ z) := by\n          rw [sup_inf_right, sup_sdiff_self_right, inf_sup_right, inf_sdiff_sup_right]\n      _ = (y ⊓ (x ⊓ (x ⊔ z)) ⊔ x \\ z) ⊓ (x ⊓ y ⊓ z ⊔ y \\ z) := by ac_rfl\n      _ = (y ⊓ x ⊔ x \\ z) ⊓ (x ⊓ y ⊔ y \\ z) := by rw [inf_sup_self, sup_inf_inf_sdiff]\n      _ = x ⊓ y ⊔ x \\ z ⊓ y \\ z := by rw [inf_comm y, sup_inf_left]\n      _ = x ⊓ y := sup_eq_left.2 (inf_le_inf sdiff_le sdiff_le))\n    (calc\n      x ⊓ y ⊓ z ⊓ (x \\ z ⊓ y \\ z) = x ⊓ y ⊓ (z ⊓ x \\ z) ⊓ y \\ z := by ac_rfl\n      _ = ⊥ := by rw [inf_sdiff_self_right, inf_bot_eq, bot_inf_eq])\n\n"}
{"name":"inf_sdiff_assoc","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y z : α\n⊢ Eq (SDiff.sdiff (Min.min x y) z) (Min.min x (SDiff.sdiff y z))","decl":"/-- See also `sdiff_inf_right_comm`. -/\ntheorem inf_sdiff_assoc (x y z : α) : (x ⊓ y) \\ z = x ⊓ y \\ z :=\n  sdiff_unique\n    (calc\n      x ⊓ y ⊓ z ⊔ x ⊓ y \\ z = x ⊓ (y ⊓ z) ⊔ x ⊓ y \\ z := by rw [inf_assoc]\n      _ = x ⊓ (y ⊓ z ⊔ y \\ z) := by rw [← inf_sup_left]\n      _ = x ⊓ y := by rw [sup_inf_sdiff])\n    (calc\n      x ⊓ y ⊓ z ⊓ (x ⊓ y \\ z) = x ⊓ x ⊓ (y ⊓ z ⊓ y \\ z) := by ac_rfl\n      _ = ⊥ := by rw [inf_inf_sdiff, inf_bot_eq])\n\n"}
{"name":"sdiff_inf_right_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y z : α\n⊢ Eq (Min.min (SDiff.sdiff x z) y) (SDiff.sdiff (Min.min x y) z)","decl":"/-- See also `inf_sdiff_assoc`. -/\ntheorem sdiff_inf_right_comm (x y z : α) : x \\ z ⊓ y = (x ⊓ y) \\ z := by\n  rw [inf_comm x, inf_comm, inf_sdiff_assoc]\n\n"}
{"name":"inf_sdiff_left_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\na b c : α\n⊢ Eq (Min.min a (SDiff.sdiff b c)) (Min.min b (SDiff.sdiff a c))","decl":"lemma inf_sdiff_left_comm (a b c : α) : a ⊓ (b \\ c) = b ⊓ (a \\ c) := by\n  simp_rw [← inf_sdiff_assoc, inf_comm]\n\n"}
{"name":"inf_sdiff_right_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\nx y z : α\n⊢ Eq (Min.min (SDiff.sdiff x z) y) (SDiff.sdiff (Min.min x y) z)","decl":"@[deprecated (since := \"2025-01-08\")] alias inf_sdiff_right_comm := sdiff_inf_right_comm\n\n"}
{"name":"inf_sdiff_distrib_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\na b c : α\n⊢ Eq (Min.min a (SDiff.sdiff b c)) (SDiff.sdiff (Min.min a b) (Min.min a c))","decl":"theorem inf_sdiff_distrib_left (a b c : α) : a ⊓ b \\ c = (a ⊓ b) \\ (a ⊓ c) := by\n  rw [sdiff_inf, sdiff_eq_bot_iff.2 inf_le_left, bot_sup_eq, inf_sdiff_assoc]\n\n"}
{"name":"inf_sdiff_distrib_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : GeneralizedBooleanAlgebra α\na b c : α\n⊢ Eq (Min.min (SDiff.sdiff a b) c) (SDiff.sdiff (Min.min a c) (Min.min b c))","decl":"theorem inf_sdiff_distrib_right (a b c : α) : a \\ b ⊓ c = (a ⊓ c) \\ (b ⊓ c) := by\n  simp_rw [inf_comm _ c, inf_sdiff_distrib_left]\n\n"}
{"name":"disjoint_sdiff_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Iff (Disjoint (SDiff.sdiff x z) y) (Disjoint x (SDiff.sdiff y z))","decl":"theorem disjoint_sdiff_comm : Disjoint (x \\ z) y ↔ Disjoint x (y \\ z) := by\n  simp_rw [disjoint_iff, sdiff_inf_right_comm, inf_sdiff_assoc]\n\n"}
{"name":"sup_eq_sdiff_sup_sdiff_sup_inf","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : GeneralizedBooleanAlgebra α\n⊢ Eq (Max.max x y) (Max.max (Max.max (SDiff.sdiff x y) (SDiff.sdiff y x)) (Min.min x y))","decl":"theorem sup_eq_sdiff_sup_sdiff_sup_inf : x ⊔ y = x \\ y ⊔ y \\ x ⊔ x ⊓ y :=\n  Eq.symm <|\n    calc\n      x \\ y ⊔ y \\ x ⊔ x ⊓ y = (x \\ y ⊔ y \\ x ⊔ x) ⊓ (x \\ y ⊔ y \\ x ⊔ y) := by rw [sup_inf_left]\n      _ = (x \\ y ⊔ x ⊔ y \\ x) ⊓ (x \\ y ⊔ (y \\ x ⊔ y)) := by ac_rfl\n      _ = (x ⊔ y \\ x) ⊓ (x \\ y ⊔ y) := by rw [sup_sdiff_right, sup_sdiff_right]\n      _ = x ⊔ y := by rw [sup_sdiff_self_right, sup_sdiff_self_left, inf_idem]\n\n"}
{"name":"sup_lt_of_lt_sdiff_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nh : LT.lt y (SDiff.sdiff z x)\nhxz : LE.le x z\n⊢ LT.lt (Max.max x y) z","decl":"theorem sup_lt_of_lt_sdiff_left (h : y < z \\ x) (hxz : x ≤ z) : x ⊔ y < z := by\n  rw [← sup_sdiff_cancel_right hxz]\n  refine (sup_le_sup_left h.le _).lt_of_not_le fun h' => h.not_le ?_\n  rw [← sdiff_idem]\n  exact (sdiff_le_sdiff_of_sup_le_sup_left h').trans sdiff_le\n\n"}
{"name":"sup_lt_of_lt_sdiff_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : GeneralizedBooleanAlgebra α\nh : LT.lt x (SDiff.sdiff z y)\nhyz : LE.le y z\n⊢ LT.lt (Max.max x y) z","decl":"theorem sup_lt_of_lt_sdiff_right (h : x < z \\ y) (hyz : y ≤ z) : x ⊔ y < z := by\n  rw [← sdiff_sup_cancel hyz]\n  refine (sup_le_sup_right h.le _).lt_of_not_le fun h' => h.not_le ?_\n  rw [← sdiff_idem]\n  exact (sdiff_le_sdiff_of_sup_le_sup_right h').trans sdiff_le\n\n"}
{"name":"BooleanAlgebra.bot_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\na : α\n⊢ LE.le Bot.bot a","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"BooleanAlgebra.top_le_sup_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\nx : α\n⊢ LE.le Top.top (Max.max x (HasCompl.compl x))","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"BooleanAlgebra.inf_compl_le_bot","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\nx : α\n⊢ LE.le (Min.min x (HasCompl.compl x)) Bot.bot","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"BooleanAlgebra.sdiff_eq","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\nx y : α\n⊢ Eq (SDiff.sdiff x y) (Min.min x (HasCompl.compl y))","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"BooleanAlgebra.le_top","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\na : α\n⊢ LE.le a Top.top","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"BooleanAlgebra.himp_eq","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nself : BooleanAlgebra α\nx y : α\n⊢ Eq (HImp.himp x y) (Max.max y (HasCompl.compl x))","decl":"/-- A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that\n`x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\`\nand a Heyting implication `⇨` satisfying `x \\ y = x ⊓ yᶜ` and `x ⇨ y = y ⊔ xᶜ`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `BoundedOrder`, `OrderBot`, and `OrderTop` are mixins that require `LE`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `Bot` and `Top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `BoundedOrder` is provided.\n-/\nclass BooleanAlgebra (α : Type u) extends\n    DistribLattice α, HasCompl α, SDiff α, HImp α, Top α, Bot α where\n  /-- The infimum of `x` and `xᶜ` is at most `⊥` -/\n  inf_compl_le_bot : ∀ x : α, x ⊓ xᶜ ≤ ⊥\n  /-- The supremum of `x` and `xᶜ` is at least `⊤` -/\n  top_le_sup_compl : ∀ x : α, ⊤ ≤ x ⊔ xᶜ\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff := fun x y => x ⊓ yᶜ\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp := fun x y => y ⊔ xᶜ\n  /-- `x \\ y` is equal to `x ⊓ yᶜ` -/\n  sdiff_eq : ∀ x y : α, x \\ y = x ⊓ yᶜ := by aesop\n  /-- `x ⇨ y` is equal to `y ⊔ xᶜ` -/\n  himp_eq : ∀ x y : α, x ⇨ y = y ⊔ xᶜ := by aesop\n\n-- see Note [lower instance priority]\n"}
{"name":"inf_compl_eq_bot'","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (Min.min x (HasCompl.compl x)) Bot.bot","decl":"theorem inf_compl_eq_bot' : x ⊓ xᶜ = ⊥ :=\n  bot_unique <| BooleanAlgebra.inf_compl_le_bot x\n\n"}
{"name":"sup_compl_eq_top","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (Max.max x (HasCompl.compl x)) Top.top","decl":"@[simp]\ntheorem sup_compl_eq_top : x ⊔ xᶜ = ⊤ :=\n  top_unique <| BooleanAlgebra.top_le_sup_compl x\n\n"}
{"name":"compl_sup_eq_top","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (Max.max (HasCompl.compl x) x) Top.top","decl":"@[simp]\ntheorem compl_sup_eq_top : xᶜ ⊔ x = ⊤ := by rw [sup_comm, sup_compl_eq_top]\n\n"}
{"name":"isCompl_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ IsCompl x (HasCompl.compl x)","decl":"theorem isCompl_compl : IsCompl x xᶜ :=\n  IsCompl.of_eq inf_compl_eq_bot' sup_compl_eq_top\n\n"}
{"name":"sdiff_eq","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (SDiff.sdiff x y) (Min.min x (HasCompl.compl y))","decl":"theorem sdiff_eq : x \\ y = x ⊓ yᶜ :=\n  BooleanAlgebra.sdiff_eq x y\n\n"}
{"name":"himp_eq","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HImp.himp x y) (Max.max y (HasCompl.compl x))","decl":"theorem himp_eq : x ⇨ y = y ⊔ xᶜ :=\n  BooleanAlgebra.himp_eq x y\n\n"}
{"name":"BooleanAlgebra.toComplementedLattice","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ ComplementedLattice α","decl":"instance (priority := 100) BooleanAlgebra.toComplementedLattice : ComplementedLattice α :=\n  ⟨fun x => ⟨xᶜ, isCompl_compl⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"hnot_eq_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HNot.hnot x) (HasCompl.compl x)","decl":"@[simp]\ntheorem hnot_eq_compl : ￢x = xᶜ :=\n  rfl\n\n/- NOTE: Is this theorem needed at all or can we use `top_sdiff'`. -/\n"}
{"name":"top_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (SDiff.sdiff Top.top x) (HasCompl.compl x)","decl":"theorem top_sdiff : ⊤ \\ x = xᶜ :=\n  top_sdiff' x\n\n"}
{"name":"eq_compl_iff_isCompl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq x (HasCompl.compl y)) (IsCompl x y)","decl":"theorem eq_compl_iff_isCompl : x = yᶜ ↔ IsCompl x y :=\n  ⟨fun h => by\n    rw [h]\n    exact isCompl_compl.symm, IsCompl.eq_compl⟩\n\n"}
{"name":"compl_eq_iff_isCompl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HasCompl.compl x) y) (IsCompl x y)","decl":"theorem compl_eq_iff_isCompl : xᶜ = y ↔ IsCompl x y :=\n  ⟨fun h => by\n    rw [← h]\n    exact isCompl_compl, IsCompl.compl_eq⟩\n\n"}
{"name":"compl_eq_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HasCompl.compl x) y) (Eq (HasCompl.compl y) x)","decl":"theorem compl_eq_comm : xᶜ = y ↔ yᶜ = x := by\n  rw [eq_comm, compl_eq_iff_isCompl, eq_compl_iff_isCompl]\n\n"}
{"name":"eq_compl_comm","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq x (HasCompl.compl y)) (Eq y (HasCompl.compl x))","decl":"theorem eq_compl_comm : x = yᶜ ↔ y = xᶜ := by\n  rw [eq_comm, compl_eq_iff_isCompl, eq_compl_iff_isCompl]\n\n"}
{"name":"compl_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\nx : α\n⊢ Eq (HasCompl.compl (HasCompl.compl x)) x","decl":"@[simp]\ntheorem compl_compl (x : α) : xᶜᶜ = x :=\n  (@isCompl_compl _ x _).symm.compl_eq\n\n"}
{"name":"compl_comp_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ Eq (Function.comp HasCompl.compl HasCompl.compl) id","decl":"theorem compl_comp_compl : compl ∘ compl = @id α :=\n  funext compl_compl\n\n"}
{"name":"compl_involutive","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ Function.Involutive HasCompl.compl","decl":"@[simp]\ntheorem compl_involutive : Function.Involutive (compl : α → α) :=\n  compl_compl\n\n"}
{"name":"compl_bijective","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ Function.Bijective HasCompl.compl","decl":"theorem compl_bijective : Function.Bijective (compl : α → α) :=\n  compl_involutive.bijective\n\n"}
{"name":"compl_surjective","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ Function.Surjective HasCompl.compl","decl":"theorem compl_surjective : Function.Surjective (compl : α → α) :=\n  compl_involutive.surjective\n\n"}
{"name":"compl_injective","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\ninst✝ : BooleanAlgebra α\n⊢ Function.Injective HasCompl.compl","decl":"theorem compl_injective : Function.Injective (compl : α → α) :=\n  compl_involutive.injective\n\n"}
{"name":"compl_inj_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HasCompl.compl x) (HasCompl.compl y)) (Eq x y)","decl":"@[simp]\ntheorem compl_inj_iff : xᶜ = yᶜ ↔ x = y :=\n  compl_injective.eq_iff\n\n"}
{"name":"IsCompl.compl_eq_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : BooleanAlgebra α\nh : IsCompl x y\n⊢ Iff (Eq (HasCompl.compl z) y) (Eq z x)","decl":"theorem IsCompl.compl_eq_iff (h : IsCompl x y) : zᶜ = y ↔ z = x :=\n  h.compl_eq ▸ compl_inj_iff\n\n"}
{"name":"compl_eq_top","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HasCompl.compl x) Top.top) (Eq x Bot.bot)","decl":"@[simp]\ntheorem compl_eq_top : xᶜ = ⊤ ↔ x = ⊥ :=\n  isCompl_bot_top.compl_eq_iff\n\n"}
{"name":"compl_eq_bot","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HasCompl.compl x) Bot.bot) (Eq x Top.top)","decl":"@[simp]\ntheorem compl_eq_bot : xᶜ = ⊥ ↔ x = ⊤ :=\n  isCompl_top_bot.compl_eq_iff\n\n"}
{"name":"compl_inf","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HasCompl.compl (Min.min x y)) (Max.max (HasCompl.compl x) (HasCompl.compl y))","decl":"@[simp]\ntheorem compl_inf : (x ⊓ y)ᶜ = xᶜ ⊔ yᶜ :=\n  hnot_inf_distrib _ _\n\n"}
{"name":"compl_le_compl_iff_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LE.le (HasCompl.compl y) (HasCompl.compl x)) (LE.le x y)","decl":"@[simp]\ntheorem compl_le_compl_iff_le : yᶜ ≤ xᶜ ↔ x ≤ y :=\n  ⟨fun h => by have h := compl_le_compl h; simpa using h, compl_le_compl⟩\n\n"}
{"name":"compl_lt_compl_iff_lt","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LT.lt (HasCompl.compl y) (HasCompl.compl x)) (LT.lt x y)","decl":"@[simp] lemma compl_lt_compl_iff_lt : yᶜ < xᶜ ↔ x < y :=\n  lt_iff_lt_of_le_iff_le' compl_le_compl_iff_le compl_le_compl_iff_le\n\n"}
{"name":"compl_le_of_compl_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\nh : LE.le (HasCompl.compl y) x\n⊢ LE.le (HasCompl.compl x) y","decl":"theorem compl_le_of_compl_le (h : yᶜ ≤ x) : xᶜ ≤ y := by\n  simpa only [compl_compl] using compl_le_compl h\n\n"}
{"name":"compl_le_iff_compl_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LE.le (HasCompl.compl x) y) (LE.le (HasCompl.compl y) x)","decl":"theorem compl_le_iff_compl_le : xᶜ ≤ y ↔ yᶜ ≤ x :=\n  ⟨compl_le_of_compl_le, compl_le_of_compl_le⟩\n\n"}
{"name":"compl_le_self","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LE.le (HasCompl.compl x) x) (Eq x Top.top)","decl":"@[simp] theorem compl_le_self : xᶜ ≤ x ↔ x = ⊤ := by simpa using le_compl_self (a := xᶜ)\n\n"}
{"name":"compl_lt_self","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx : α\ninst✝¹ : BooleanAlgebra α\ninst✝ : Nontrivial α\n⊢ Iff (LT.lt (HasCompl.compl x) x) (Eq x Top.top)","decl":"@[simp] theorem compl_lt_self [Nontrivial α] : xᶜ < x ↔ x = ⊤ := by\n  simpa using lt_compl_self (a := xᶜ)\n\n"}
{"name":"sdiff_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (SDiff.sdiff x (HasCompl.compl y)) (Min.min x y)","decl":"@[simp]\ntheorem sdiff_compl : x \\ yᶜ = x ⊓ y := by rw [sdiff_eq, compl_compl]\n\n"}
{"name":"sup_inf_inf_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (Max.max (Min.min x y) (Min.min x (HasCompl.compl y))) x","decl":"@[simp]\ntheorem sup_inf_inf_compl : x ⊓ y ⊔ x ⊓ yᶜ = x := by rw [← sdiff_eq, sup_inf_sdiff _ _]\n\n"}
{"name":"compl_sdiff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HasCompl.compl (SDiff.sdiff x y)) (HImp.himp x y)","decl":"theorem compl_sdiff : (x \\ y)ᶜ = x ⇨ y := by\n  rw [sdiff_eq, himp_eq, compl_inf, compl_compl, sup_comm]\n\n"}
{"name":"compl_himp","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HasCompl.compl (HImp.himp x y)) (SDiff.sdiff x y)","decl":"@[simp]\ntheorem compl_himp : (x ⇨ y)ᶜ = x \\ y :=\n  @compl_sdiff αᵒᵈ _ _ _\n\n"}
{"name":"compl_sdiff_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (SDiff.sdiff (HasCompl.compl x) (HasCompl.compl y)) (SDiff.sdiff y x)","decl":"theorem compl_sdiff_compl : xᶜ \\ yᶜ = y \\ x := by rw [sdiff_compl, sdiff_eq, inf_comm]\n\n"}
{"name":"compl_himp_compl","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Eq (HImp.himp (HasCompl.compl x) (HasCompl.compl y)) (HImp.himp y x)","decl":"@[simp]\ntheorem compl_himp_compl : xᶜ ⇨ yᶜ = y ⇨ x :=\n  @compl_sdiff_compl αᵒᵈ _ _ _\n\n"}
{"name":"disjoint_compl_left_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Disjoint (HasCompl.compl x) y) (LE.le y x)","decl":"theorem disjoint_compl_left_iff : Disjoint xᶜ y ↔ y ≤ x := by\n  rw [← le_compl_iff_disjoint_left, compl_compl]\n\n"}
{"name":"disjoint_compl_right_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Disjoint x (HasCompl.compl y)) (LE.le x y)","decl":"theorem disjoint_compl_right_iff : Disjoint x yᶜ ↔ x ≤ y := by\n  rw [← le_compl_iff_disjoint_right, compl_compl]\n\n"}
{"name":"codisjoint_himp_self_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Codisjoint (HImp.himp x y) x","decl":"theorem codisjoint_himp_self_left : Codisjoint (x ⇨ y) x :=\n  @disjoint_sdiff_self_left αᵒᵈ _ _ _\n\n"}
{"name":"codisjoint_himp_self_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Codisjoint x (HImp.himp x y)","decl":"theorem codisjoint_himp_self_right : Codisjoint x (x ⇨ y) :=\n  @disjoint_sdiff_self_right αᵒᵈ _ _ _\n\n"}
{"name":"himp_le","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y z : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LE.le (HImp.himp x y) z) (And (LE.le y z) (Codisjoint x z))","decl":"theorem himp_le : x ⇨ y ≤ z ↔ y ≤ z ∧ Codisjoint x z :=\n  (@le_sdiff αᵒᵈ _ _ _ _).trans <| and_congr_right' <| @codisjoint_comm _ (_) _ _ _\n\n"}
{"name":"himp_le_iff","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (LE.le (HImp.himp x y) x) (Eq x Top.top)","decl":"@[simp] lemma himp_le_iff : x ⇨ y ≤ x ↔ x = ⊤ :=\n  ⟨fun h ↦ codisjoint_self.1 <| codisjoint_himp_self_right.mono_right h, fun h ↦ le_top.trans h.ge⟩\n\n"}
{"name":"himp_eq_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Eq (HImp.himp x y) x) (And (Eq x Top.top) (Eq y Top.top))","decl":"@[simp] lemma himp_eq_left : x ⇨ y = x ↔ x = ⊤ ∧ y = ⊤ := by\n  rw [codisjoint_himp_self_left.eq_iff]; aesop\n\n"}
{"name":"himp_ne_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Ne (HImp.himp x y) x) (Or (Ne x Top.top) (Ne y Top.top))","decl":"lemma himp_ne_right : x ⇨ y ≠ x ↔ x ≠ ⊤ ∨ y ≠ ⊤ := himp_eq_left.not.trans not_and_or\n\n"}
{"name":"codisjoint_iff_compl_le_left","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Codisjoint x y) (LE.le (HasCompl.compl y) x)","decl":"lemma codisjoint_iff_compl_le_left : Codisjoint x y ↔ yᶜ ≤ x :=\n  hnot_le_iff_codisjoint_left.symm\n\n"}
{"name":"codisjoint_iff_compl_le_right","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"α : Type u\nx y : α\ninst✝ : BooleanAlgebra α\n⊢ Iff (Codisjoint x y) (LE.le (HasCompl.compl x) y)","decl":"lemma codisjoint_iff_compl_le_right : Codisjoint x y ↔ xᶜ ≤ y :=\n  hnot_le_iff_codisjoint_right.symm\n\n"}
{"name":"Bool.sup_eq_bor","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"⊢ Eq (fun x1 x2 => Max.max x1 x2) Bool.or","decl":"theorem Bool.sup_eq_bor : (· ⊔ ·) = or := by dsimp\n\n"}
{"name":"Bool.inf_eq_band","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"⊢ Eq (fun x1 x2 => Min.min x1 x2) Bool.and","decl":"theorem Bool.inf_eq_band : (· ⊓ ·) = and := by dsimp\n\n"}
{"name":"Bool.compl_eq_bnot","module":"Mathlib.Order.BooleanAlgebra","initialProofState":"⊢ Eq HasCompl.compl Bool.not","decl":"@[simp]\ntheorem Bool.compl_eq_bnot : HasCompl.compl = not :=\n  rfl\n\n"}
