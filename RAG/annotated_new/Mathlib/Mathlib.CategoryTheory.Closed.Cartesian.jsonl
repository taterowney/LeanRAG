{"name":"CategoryTheory.exp.ev_coev_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.exp.coev A).app B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B)) h)) h","decl":"@[reassoc]\ntheorem ev_coev : (A â— (coev A).app B) â‰« (ev A).app (A âŠ— B) = ğŸ™ (A âŠ— B : C) :=\n  ihom.ev_coev A B\n\n"}
{"name":"CategoryTheory.exp.ev_coev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.exp.coev A).app B)) ((CategoryTheory.exp.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))","decl":"@[reassoc]\ntheorem ev_coev : (A â— (coev A).app B) â‰« (ev A).app (A âŠ— B) = ğŸ™ (A âŠ— B : C) :=\n  ihom.ev_coev A B\n\n"}
{"name":"CategoryTheory.exp.coev_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app ((CategoryTheory.exp A).obj B)) ((CategoryTheory.exp A).map ((CategoryTheory.exp.ev A).app B))) (CategoryTheory.CategoryStruct.id ((CategoryTheory.exp A).obj B))","decl":"@[reassoc]\ntheorem coev_ev : (coev A).app (A âŸ¹ B) â‰« (exp A).map ((ev A).app B) = ğŸ™ (A âŸ¹ B) :=\n  ihom.coev_ev A B\n\n"}
{"name":"CategoryTheory.exp.coev_ev_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj B) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app ((CategoryTheory.exp A).obj B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp A).map ((CategoryTheory.exp.ev A).app B)) h)) h","decl":"@[reassoc]\ntheorem coev_ev : (coev A).app (A âŸ¹ B) â‰« (exp A).map ((ev A).app B) = ğŸ™ (A âŸ¹ B) :=\n  ihom.coev_ev A B\n\n"}
{"name":"CategoryTheory.instPreservesColimitsTensorLeft_1","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.MonoidalCategory.tensorLeft A)","decl":"instance : PreservesColimits (tensorLeft A) :=\n  (ihom.adjunction A).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.CartesianClosed.homEquiv_apply_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\nâŠ¢ Eq (((CategoryTheory.exp.adjunction A).homEquiv Y X) f) (CategoryTheory.CartesianClosed.curry f)","decl":"theorem homEquiv_apply_eq (f : A âŠ— Y âŸ¶ X) : (exp.adjunction A).homEquiv _ _ f = curry f :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.homEquiv_symm_apply_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\nâŠ¢ Eq (((CategoryTheory.exp.adjunction A).homEquiv Y X).symm f) (CategoryTheory.CartesianClosed.uncurry f)","decl":"theorem homEquiv_symm_apply_eq (f : Y âŸ¶ A âŸ¹ X) :\n    ((exp.adjunction A).homEquiv _ _).symm f = uncurry f :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry g) h))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X âŸ¶ X') (g : A âŠ— X' âŸ¶ Y) :\n    curry (_ â— f â‰« g) = f â‰« curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_left","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\nâŠ¢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CartesianClosed.curry g))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X âŸ¶ X') (g : A âŠ— X' âŸ¶ Y) :\n    curry (_ â— f â‰« g) = f â‰« curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj Y') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp A).map g) h))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A âŠ— X âŸ¶ Y) (g : Y âŸ¶ Y') :\n    curry (f â‰« g) = curry f â‰« (exp _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_right","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\nâŠ¢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry f) ((CategoryTheory.exp A).map g))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A âŠ— X âŸ¶ Y) (g : Y âŸ¶ Y') :\n    curry (f â‰« g) = curry f â‰« (exp _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_right","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\ng : Quiver.Hom Y Y'\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.exp A).map g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry f) g)","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X âŸ¶ A âŸ¹ Y) (g : Y âŸ¶ Y') :\n    uncurry (f â‰« (exp _).map g) = uncurry f â‰« g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom Y' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.exp A).map g))) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry f) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X âŸ¶ A âŸ¹ Y) (g : Y âŸ¶ Y') :\n    uncurry (f â‰« (exp _).map g) = uncurry f â‰« g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.exp A).obj Y)\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry g) h))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X âŸ¶ X') (g : X' âŸ¶ A âŸ¹ Y) :\n    uncurry (f â‰« g) = _ â— f â‰« uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_left","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.exp A).obj Y)\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.CartesianClosed.uncurry g))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X âŸ¶ X') (g : X' âŸ¶ A âŸ¹ Y) :\n    uncurry (f â‰« g) = _ â— f â‰« uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_curry","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CartesianClosed.curry f)) f","decl":"@[simp]\ntheorem uncurry_curry (f : A âŠ— X âŸ¶ Y) : uncurry (curry f) = f :=\n  (Closed.adj.homEquiv _ _).left_inv f\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_uncurry","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\nâŠ¢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CartesianClosed.uncurry f)) f","decl":"@[simp]\ntheorem curry_uncurry (f : X âŸ¶ A âŸ¹ Y) : curry (uncurry f) = f :=\n  (Closed.adj.homEquiv _ _).right_inv f\n\n-- Porting note: extra `(exp.adjunction A)` argument was needed for elaboration to succeed.\n"}
{"name":"CategoryTheory.CartesianClosed.curry_eq_iff","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\nâŠ¢ Iff (Eq (CategoryTheory.CartesianClosed.curry f) g) (Eq f (CategoryTheory.CartesianClosed.uncurry g))","decl":"theorem curry_eq_iff (f : A âŠ— Y âŸ¶ X) (g : Y âŸ¶ A âŸ¹ X) : curry f = g â†” f = uncurry g :=\n  Adjunction.homEquiv_apply_eq (exp.adjunction A) f g\n\n-- Porting note: extra `(exp.adjunction A)` argument was needed for elaboration to succeed.\n"}
{"name":"CategoryTheory.CartesianClosed.eq_curry_iff","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\nâŠ¢ Iff (Eq g (CategoryTheory.CartesianClosed.curry f)) (Eq (CategoryTheory.CartesianClosed.uncurry g) f)","decl":"theorem eq_curry_iff (f : A âŠ— Y âŸ¶ X) (g : Y âŸ¶ A âŸ¹ X) : g = curry f â†” uncurry g = f :=\n  Adjunction.eq_homEquiv_apply (exp.adjunction A) f g\n\n-- I don't think these two should be simp.\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g) ((CategoryTheory.exp.ev A).app X))","decl":"theorem uncurry_eq (g : Y âŸ¶ A âŸ¹ X) : uncurry g = (A â— g) â‰« (exp.ev A).app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\nâŠ¢ Eq (CategoryTheory.CartesianClosed.curry g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app Y) ((CategoryTheory.exp A).map g))","decl":"theorem curry_eq (g : A âŠ— Y âŸ¶ X) : curry g = (exp.coev A).app Y â‰« (exp A).map g :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_id_eq_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\nA X : C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.id ((CategoryTheory.exp A).obj X))) ((CategoryTheory.exp.ev A).app X)","decl":"theorem uncurry_id_eq_ev (A X : C) [Exponentiable A] : uncurry (ğŸ™ (A âŸ¹ X)) = (exp.ev A).app X := by\n  rw [uncurry_eq, whiskerLeft_id_assoc]\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_id_eq_coev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\nA X : C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A ((CategoryTheory.Functor.id C).obj X)))) ((CategoryTheory.exp.coev A).app X)","decl":"theorem curry_id_eq_coev (A X : C) [Exponentiable A] : curry (ğŸ™ _) = (exp.coev A).app X := by\n  rw [curry_eq, (exp A).map_id (A âŠ— _)]; apply comp_id\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_injective","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Function.Injective CategoryTheory.CartesianClosed.curry","decl":"theorem curry_injective : Function.Injective (curry : (A âŠ— Y âŸ¶ X) â†’ (Y âŸ¶ A âŸ¹ X)) :=\n  (Closed.adj.homEquiv _ _).injective\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_injective","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Function.Injective CategoryTheory.CartesianClosed.uncurry","decl":"theorem uncurry_injective : Function.Injective (uncurry : (Y âŸ¶ A âŸ¹ X) â†’ (A âŠ— Y âŸ¶ X)) :=\n  (Closed.adj.homEquiv _ _).symm.injective\n\n"}
{"name":"CategoryTheory.prod_map_pre_app_comp_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ² : CategoryTheory.ChosenFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninstâœ : CategoryTheory.Exponentiable B\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft B ((CategoryTheory.pre f).app X)) ((CategoryTheory.exp.ev B).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.exp A).obj X)) ((CategoryTheory.exp.ev A).app X))","decl":"theorem prod_map_pre_app_comp_ev (f : B âŸ¶ A) [Exponentiable B] (X : C) :\n    (B â— (pre f).app X) â‰« (exp.ev B).app X =\n      f â–· (A âŸ¹ X) â‰« (exp.ev A).app X :=\n  conjugateEquiv_counit _ _ ((tensoringLeft _).map f) X\n\n"}
{"name":"CategoryTheory.uncurry_pre","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nA B : C\ninstâœÂ² : CategoryTheory.ChosenFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninstâœ : CategoryTheory.Exponentiable B\nX : C\nâŠ¢ Eq (CategoryTheory.CartesianClosed.uncurry ((CategoryTheory.pre f).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.exp A).obj X)) ((CategoryTheory.exp.ev A).app X))","decl":"theorem uncurry_pre (f : B âŸ¶ A) [Exponentiable B] (X : C) :\n    CartesianClosed.uncurry ((pre f).app X) = f â–· _ â‰« (exp.ev A).app X := by\n  rw [uncurry_eq, prod_map_pre_app_comp_ev]\n\n"}
{"name":"CategoryTheory.coev_app_comp_pre_app","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nA B X : C\ninstâœÂ² : CategoryTheory.ChosenFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninstâœ : CategoryTheory.Exponentiable B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app X) ((CategoryTheory.pre f).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev B).app X) ((CategoryTheory.exp B).map (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id X))))","decl":"theorem coev_app_comp_pre_app (f : B âŸ¶ A) [Exponentiable B] :\n    (exp.coev A).app X â‰« (pre f).app (A âŠ— X) =\n      (exp.coev B).app X â‰« (exp B).map (f âŠ— ğŸ™ _) :=\n  unit_conjugateEquiv _ _ ((tensoringLeft _).map f) X\n\n"}
{"name":"CategoryTheory.pre_id","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\nA : C\ninstâœ : CategoryTheory.Exponentiable A\nâŠ¢ Eq (CategoryTheory.pre (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.id (CategoryTheory.exp A))","decl":"@[simp]\ntheorem pre_id (A : C) [Exponentiable A] : pre (ğŸ™ A) = ğŸ™ _ := by\n  simp only [pre, Functor.map_id]\n  aesop_cat\n\n"}
{"name":"CategoryTheory.pre_map","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.ChosenFiniteProducts C\nAâ‚ Aâ‚‚ Aâ‚ƒ : C\ninstâœÂ² : CategoryTheory.Exponentiable Aâ‚\ninstâœÂ¹ : CategoryTheory.Exponentiable Aâ‚‚\ninstâœ : CategoryTheory.Exponentiable Aâ‚ƒ\nf : Quiver.Hom Aâ‚ Aâ‚‚\ng : Quiver.Hom Aâ‚‚ Aâ‚ƒ\nâŠ¢ Eq (CategoryTheory.pre (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.pre g) (CategoryTheory.pre f))","decl":"@[simp]\ntheorem pre_map {Aâ‚ Aâ‚‚ Aâ‚ƒ : C} [Exponentiable Aâ‚] [Exponentiable Aâ‚‚] [Exponentiable Aâ‚ƒ]\n    (f : Aâ‚ âŸ¶ Aâ‚‚) (g : Aâ‚‚ âŸ¶ Aâ‚ƒ) : pre (f â‰« g) = pre g â‰« pre f := by\n  rw [pre, pre, pre, conjugateEquiv_comp]\n  simp\n\n"}
{"name":"CategoryTheory.zeroMul_hom","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nA : C\ninstâœ : CategoryTheory.ChosenFiniteProducts C\nI : C\nt : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.zeroMul t).hom (CategoryTheory.ChosenFiniteProducts.snd A I)","decl":"/-- If an initial object `I` exists in a CCC, then `A â¨¯ I â‰… I`. -/\n@[simps]\ndef zeroMul {I : C} (t : IsInitial I) : A âŠ— I â‰… I where\n  hom := ChosenFiniteProducts.snd _ _\n  inv := t.to _\n  hom_inv_id := by\n    have : ChosenFiniteProducts.snd A I = CartesianClosed.uncurry (t.to _) := by\n      rw [â† curry_eq_iff]\n      apply t.hom_ext\n    rw [this, â† uncurry_natural_right, â† eq_curry_iff]\n    apply t.hom_ext\n  inv_hom_id := t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.zeroMul_inv","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nA : C\ninstâœ : CategoryTheory.ChosenFiniteProducts C\nI : C\nt : CategoryTheory.Limits.IsInitial I\nâŠ¢ Eq (CategoryTheory.zeroMul t).inv (t.to (CategoryTheory.MonoidalCategoryStruct.tensorObj A I))","decl":"/-- If an initial object `I` exists in a CCC, then `A â¨¯ I â‰… I`. -/\n@[simps]\ndef zeroMul {I : C} (t : IsInitial I) : A âŠ— I â‰… I where\n  hom := ChosenFiniteProducts.snd _ _\n  inv := t.to _\n  hom_inv_id := by\n    have : ChosenFiniteProducts.snd A I = CartesianClosed.uncurry (t.to _) := by\n      rw [â† curry_eq_iff]\n      apply t.hom_ext\n    rw [this, â† uncurry_natural_right, â† eq_curry_iff]\n    apply t.hom_ext\n  inv_hom_id := t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.strict_initial","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nA : C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\ninstâœ : CategoryTheory.Exponentiable A\nI : C\nt : CategoryTheory.Limits.IsInitial I\nf : Quiver.Hom A I\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- If an initial object `I` exists in a CCC then it is a strict initial object,\ni.e. any morphism to `I` is an iso.\nThis actually shows a slightly stronger version: any morphism to an initial object from an\nexponentiable object is an isomorphism.\n-/\ntheorem strict_initial {I : C} (t : IsInitial I) (f : A âŸ¶ I) : IsIso f := by\n  haveI : Mono f := by\n    rw [â† ChosenFiniteProducts.lift_snd (ğŸ™ A) f, â† zeroMul_hom t]\n    exact mono_comp _ _\n  haveI : IsSplitEpi f := IsSplitEpi.mk' âŸ¨t.to _, t.hom_ext _ _âŸ©\n  apply isIso_of_mono_of_isSplitEpi\n\n"}
{"name":"CategoryTheory.to_initial_isIso","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nA : C\ninstâœÂ² : CategoryTheory.ChosenFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Exponentiable A\ninstâœ : CategoryTheory.Limits.HasInitial C\nf : Quiver.Hom A (CategoryTheory.Limits.initial C)\nâŠ¢ CategoryTheory.IsIso f","decl":"instance to_initial_isIso [HasInitial C] (f : A âŸ¶ âŠ¥_ C) : IsIso f :=\n  strict_initial initialIsInitial _\n\n"}
{"name":"CategoryTheory.initial_mono","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.ChosenFiniteProducts C\nI B : C\nt : CategoryTheory.Limits.IsInitial I\ninstâœ : CategoryTheory.CartesianClosed C\nâŠ¢ CategoryTheory.Mono (t.to B)","decl":"/-- If an initial object `0` exists in a CCC then every morphism from it is monic. -/\ntheorem initial_mono {I : C} (B : C) (t : IsInitial I) [CartesianClosed C] : Mono (t.to B) :=\n  âŸ¨fun g h _ => by\n    haveI := strict_initial t g\n    haveI := strict_initial t h\n    exact eq_of_inv_eq_inv (t.hom_ext _ _)âŸ©\n\n"}
{"name":"CategoryTheory.Initial.mono_to","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.ChosenFiniteProducts C\ninstâœÂ¹ : CategoryTheory.Limits.HasInitial C\nB : C\ninstâœ : CategoryTheory.CartesianClosed C\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.initial.to B)","decl":"instance Initial.mono_to [HasInitial C] (B : C) [CartesianClosed C] : Mono (initial.to B) :=\n  initial_mono B initialIsInitial\n\n"}
