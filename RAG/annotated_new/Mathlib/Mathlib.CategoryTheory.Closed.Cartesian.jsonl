{"name":"CategoryTheory.exp.ev_coev_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.exp.coev A).app B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B)) h)) h","decl":"@[reassoc]\ntheorem ev_coev : (A ◁ (coev A).app B) ≫ (ev A).app (A ⊗ B) = 𝟙 (A ⊗ B : C) :=\n  ihom.ev_coev A B\n\n"}
{"name":"CategoryTheory.exp.ev_coev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.exp.coev A).app B)) ((CategoryTheory.exp.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))","decl":"@[reassoc]\ntheorem ev_coev : (A ◁ (coev A).app B) ≫ (ev A).app (A ⊗ B) = 𝟙 (A ⊗ B : C) :=\n  ihom.ev_coev A B\n\n"}
{"name":"CategoryTheory.exp.coev_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app ((CategoryTheory.exp A).obj B)) ((CategoryTheory.exp A).map ((CategoryTheory.exp.ev A).app B))) (CategoryTheory.CategoryStruct.id ((CategoryTheory.exp A).obj B))","decl":"@[reassoc]\ntheorem coev_ev : (coev A).app (A ⟹ B) ≫ (exp A).map ((ev A).app B) = 𝟙 (A ⟹ B) :=\n  ihom.coev_ev A B\n\n"}
{"name":"CategoryTheory.exp.coev_ev_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app ((CategoryTheory.exp A).obj B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp A).map ((CategoryTheory.exp.ev A).app B)) h)) h","decl":"@[reassoc]\ntheorem coev_ev : (coev A).app (A ⟹ B) ≫ (exp A).map ((ev A).app B) = 𝟙 (A ⟹ B) :=\n  ihom.coev_ev A B\n\n"}
{"name":"CategoryTheory.instPreservesColimitsTensorLeft_1","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.MonoidalCategory.tensorLeft A)","decl":"instance : PreservesColimits (tensorLeft A) :=\n  (ihom.adjunction A).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.CartesianClosed.homEquiv_apply_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\n⊢ Eq (((CategoryTheory.exp.adjunction A).homEquiv Y X) f) (CategoryTheory.CartesianClosed.curry f)","decl":"theorem homEquiv_apply_eq (f : A ⊗ Y ⟶ X) : (exp.adjunction A).homEquiv _ _ f = curry f :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.homEquiv_symm_apply_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\n⊢ Eq (((CategoryTheory.exp.adjunction A).homEquiv Y X).symm f) (CategoryTheory.CartesianClosed.uncurry f)","decl":"theorem homEquiv_symm_apply_eq (f : Y ⟶ A ⟹ X) :\n    ((exp.adjunction A).homEquiv _ _).symm f = uncurry f :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry g) h))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X ⟶ X') (g : A ⊗ X' ⟶ Y) :\n    curry (_ ◁ f ≫ g) = f ≫ curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_left","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\n⊢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CartesianClosed.curry g))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X ⟶ X') (g : A ⊗ X' ⟶ Y) :\n    curry (_ ◁ f ≫ g) = f ≫ curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom ((CategoryTheory.exp A).obj Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp A).map g) h))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A ⊗ X ⟶ Y) (g : Y ⟶ Y') :\n    curry (f ≫ g) = curry f ≫ (exp _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_natural_right","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.curry f) ((CategoryTheory.exp A).map g))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A ⊗ X ⟶ Y) (g : Y ⟶ Y') :\n    curry (f ≫ g) = curry f ≫ (exp _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_right","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.exp A).map g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry f) g)","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X ⟶ A ⟹ Y) (g : Y ⟶ Y') :\n    uncurry (f ≫ (exp _).map g) = uncurry f ≫ g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y Y' : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom Y' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.exp A).map g))) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry f) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X ⟶ A ⟹ Y) (g : Y ⟶ Y') :\n    uncurry (f ≫ (exp _).map g) = uncurry f ≫ g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.exp A).obj Y)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CartesianClosed.uncurry g) h))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X ⟶ X') (g : X' ⟶ A ⟹ Y) :\n    uncurry (f ≫ g) = _ ◁ f ≫ uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_natural_left","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X X' Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.exp A).obj Y)\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.CartesianClosed.uncurry g))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X ⟶ X') (g : X' ⟶ A ⟹ Y) :\n    uncurry (f ≫ g) = _ ◁ f ≫ uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_curry","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CartesianClosed.curry f)) f","decl":"@[simp]\ntheorem uncurry_curry (f : A ⊗ X ⟶ Y) : uncurry (curry f) = f :=\n  (Closed.adj.homEquiv _ _).left_inv f\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_uncurry","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom X ((CategoryTheory.exp A).obj Y)\n⊢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CartesianClosed.uncurry f)) f","decl":"@[simp]\ntheorem curry_uncurry (f : X ⟶ A ⟹ Y) : curry (uncurry f) = f :=\n  (Closed.adj.homEquiv _ _).right_inv f\n\n-- Porting note: extra `(exp.adjunction A)` argument was needed for elaboration to succeed.\n"}
{"name":"CategoryTheory.CartesianClosed.curry_eq_iff","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\n⊢ Iff (Eq (CategoryTheory.CartesianClosed.curry f) g) (Eq f (CategoryTheory.CartesianClosed.uncurry g))","decl":"theorem curry_eq_iff (f : A ⊗ Y ⟶ X) (g : Y ⟶ A ⟹ X) : curry f = g ↔ f = uncurry g :=\n  Adjunction.homEquiv_apply_eq (exp.adjunction A) f g\n\n-- Porting note: extra `(exp.adjunction A)` argument was needed for elaboration to succeed.\n"}
{"name":"CategoryTheory.CartesianClosed.eq_curry_iff","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\n⊢ Iff (Eq g (CategoryTheory.CartesianClosed.curry f)) (Eq (CategoryTheory.CartesianClosed.uncurry g) f)","decl":"theorem eq_curry_iff (f : A ⊗ Y ⟶ X) (g : Y ⟶ A ⟹ X) : g = curry f ↔ uncurry g = f :=\n  Adjunction.eq_homEquiv_apply (exp.adjunction A) f g\n\n-- I don't think these two should be simp.\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\ng : Quiver.Hom Y ((CategoryTheory.exp A).obj X)\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g) ((CategoryTheory.exp.ev A).app X))","decl":"theorem uncurry_eq (g : Y ⟶ A ⟹ X) : uncurry g = (A ◁ g) ≫ (exp.ev A).app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_eq","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\n⊢ Eq (CategoryTheory.CartesianClosed.curry g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app Y) ((CategoryTheory.exp A).map g))","decl":"theorem curry_eq (g : A ⊗ Y ⟶ X) : curry g = (exp.coev A).app Y ≫ (exp A).map g :=\n  rfl\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_id_eq_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\nA X : C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry (CategoryTheory.CategoryStruct.id ((CategoryTheory.exp A).obj X))) ((CategoryTheory.exp.ev A).app X)","decl":"theorem uncurry_id_eq_ev (A X : C) [Exponentiable A] : uncurry (𝟙 (A ⟹ X)) = (exp.ev A).app X := by\n  rw [uncurry_eq, whiskerLeft_id_assoc]\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_id_eq_coev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\nA X : C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Eq (CategoryTheory.CartesianClosed.curry (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A ((CategoryTheory.Functor.id C).obj X)))) ((CategoryTheory.exp.coev A).app X)","decl":"theorem curry_id_eq_coev (A X : C) [Exponentiable A] : curry (𝟙 _) = (exp.coev A).app X := by\n  rw [curry_eq, (exp A).map_id (A ⊗ _)]; apply comp_id\n\n"}
{"name":"CategoryTheory.CartesianClosed.curry_injective","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Function.Injective CategoryTheory.CartesianClosed.curry","decl":"theorem curry_injective : Function.Injective (curry : (A ⊗ Y ⟶ X) → (Y ⟶ A ⟹ X)) :=\n  (Closed.adj.homEquiv _ _).injective\n\n"}
{"name":"CategoryTheory.CartesianClosed.uncurry_injective","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA X Y : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Function.Injective CategoryTheory.CartesianClosed.uncurry","decl":"theorem uncurry_injective : Function.Injective (uncurry : (Y ⟶ A ⟹ X) → (A ⊗ Y ⟶ X)) :=\n  (Closed.adj.homEquiv _ _).symm.injective\n\n"}
{"name":"CategoryTheory.prod_map_pre_app_comp_ev","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝² : CategoryTheory.ChosenFiniteProducts C\ninst✝¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninst✝ : CategoryTheory.Exponentiable B\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft B ((CategoryTheory.pre f).app X)) ((CategoryTheory.exp.ev B).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.exp A).obj X)) ((CategoryTheory.exp.ev A).app X))","decl":"theorem prod_map_pre_app_comp_ev (f : B ⟶ A) [Exponentiable B] (X : C) :\n    (B ◁ (pre f).app X) ≫ (exp.ev B).app X =\n      f ▷ (A ⟹ X) ≫ (exp.ev A).app X :=\n  conjugateEquiv_counit _ _ ((tensoringLeft _).map f) X\n\n"}
{"name":"CategoryTheory.uncurry_pre","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA B : C\ninst✝² : CategoryTheory.ChosenFiniteProducts C\ninst✝¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninst✝ : CategoryTheory.Exponentiable B\nX : C\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry ((CategoryTheory.pre f).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.exp A).obj X)) ((CategoryTheory.exp.ev A).app X))","decl":"theorem uncurry_pre (f : B ⟶ A) [Exponentiable B] (X : C) :\n    CartesianClosed.uncurry ((pre f).app X) = f ▷ _ ≫ (exp.ev A).app X := by\n  rw [uncurry_eq, prod_map_pre_app_comp_ev]\n\n"}
{"name":"CategoryTheory.coev_app_comp_pre_app","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA B X : C\ninst✝² : CategoryTheory.ChosenFiniteProducts C\ninst✝¹ : CategoryTheory.Exponentiable A\nf : Quiver.Hom B A\ninst✝ : CategoryTheory.Exponentiable B\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev A).app X) ((CategoryTheory.pre f).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev B).app X) ((CategoryTheory.exp B).map (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id X))))","decl":"theorem coev_app_comp_pre_app (f : B ⟶ A) [Exponentiable B] :\n    (exp.coev A).app X ≫ (pre f).app (A ⊗ X) =\n      (exp.coev B).app X ≫ (exp B).map (f ⊗ 𝟙 _) :=\n  unit_conjugateEquiv _ _ ((tensoringLeft _).map f) X\n\n"}
{"name":"CategoryTheory.pre_id","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\nA : C\ninst✝ : CategoryTheory.Exponentiable A\n⊢ Eq (CategoryTheory.pre (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.id (CategoryTheory.exp A))","decl":"@[simp]\ntheorem pre_id (A : C) [Exponentiable A] : pre (𝟙 A) = 𝟙 _ := by\n  simp only [pre, Functor.map_id]\n  aesop_cat\n\n"}
{"name":"CategoryTheory.pre_map","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.ChosenFiniteProducts C\nA₁ A₂ A₃ : C\ninst✝² : CategoryTheory.Exponentiable A₁\ninst✝¹ : CategoryTheory.Exponentiable A₂\ninst✝ : CategoryTheory.Exponentiable A₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom A₂ A₃\n⊢ Eq (CategoryTheory.pre (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.pre g) (CategoryTheory.pre f))","decl":"@[simp]\ntheorem pre_map {A₁ A₂ A₃ : C} [Exponentiable A₁] [Exponentiable A₂] [Exponentiable A₃]\n    (f : A₁ ⟶ A₂) (g : A₂ ⟶ A₃) : pre (f ≫ g) = pre g ≫ pre f := by\n  rw [pre, pre, pre, conjugateEquiv_comp]\n  simp\n\n"}
{"name":"CategoryTheory.zeroMul_hom","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nI : C\nt : CategoryTheory.Limits.IsInitial I\n⊢ Eq (CategoryTheory.zeroMul t).hom (CategoryTheory.ChosenFiniteProducts.snd A I)","decl":"/-- If an initial object `I` exists in a CCC, then `A ⨯ I ≅ I`. -/\n@[simps]\ndef zeroMul {I : C} (t : IsInitial I) : A ⊗ I ≅ I where\n  hom := ChosenFiniteProducts.snd _ _\n  inv := t.to _\n  hom_inv_id := by\n    have : ChosenFiniteProducts.snd A I = CartesianClosed.uncurry (t.to _) := by\n      rw [← curry_eq_iff]\n      apply t.hom_ext\n    rw [this, ← uncurry_natural_right, ← eq_curry_iff]\n    apply t.hom_ext\n  inv_hom_id := t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.zeroMul_inv","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nI : C\nt : CategoryTheory.Limits.IsInitial I\n⊢ Eq (CategoryTheory.zeroMul t).inv (t.to (CategoryTheory.MonoidalCategoryStruct.tensorObj A I))","decl":"/-- If an initial object `I` exists in a CCC, then `A ⨯ I ≅ I`. -/\n@[simps]\ndef zeroMul {I : C} (t : IsInitial I) : A ⊗ I ≅ I where\n  hom := ChosenFiniteProducts.snd _ _\n  inv := t.to _\n  hom_inv_id := by\n    have : ChosenFiniteProducts.snd A I = CartesianClosed.uncurry (t.to _) := by\n      rw [← curry_eq_iff]\n      apply t.hom_ext\n    rw [this, ← uncurry_natural_right, ← eq_curry_iff]\n    apply t.hom_ext\n  inv_hom_id := t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.strict_initial","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\ninst✝ : CategoryTheory.Exponentiable A\nI : C\nt : CategoryTheory.Limits.IsInitial I\nf : Quiver.Hom A I\n⊢ CategoryTheory.IsIso f","decl":"/-- If an initial object `I` exists in a CCC then it is a strict initial object,\ni.e. any morphism to `I` is an iso.\nThis actually shows a slightly stronger version: any morphism to an initial object from an\nexponentiable object is an isomorphism.\n-/\ntheorem strict_initial {I : C} (t : IsInitial I) (f : A ⟶ I) : IsIso f := by\n  haveI : Mono f := by\n    rw [← ChosenFiniteProducts.lift_snd (𝟙 A) f, ← zeroMul_hom t]\n    exact mono_comp _ _\n  haveI : IsSplitEpi f := IsSplitEpi.mk' ⟨t.to _, t.hom_ext _ _⟩\n  apply isIso_of_mono_of_isSplitEpi\n\n"}
{"name":"CategoryTheory.to_initial_isIso","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA : C\ninst✝² : CategoryTheory.ChosenFiniteProducts C\ninst✝¹ : CategoryTheory.Exponentiable A\ninst✝ : CategoryTheory.Limits.HasInitial C\nf : Quiver.Hom A (CategoryTheory.Limits.initial C)\n⊢ CategoryTheory.IsIso f","decl":"instance to_initial_isIso [HasInitial C] (f : A ⟶ ⊥_ C) : IsIso f :=\n  strict_initial initialIsInitial _\n\n"}
{"name":"CategoryTheory.initial_mono","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.ChosenFiniteProducts C\nI B : C\nt : CategoryTheory.Limits.IsInitial I\ninst✝ : CategoryTheory.CartesianClosed C\n⊢ CategoryTheory.Mono (t.to B)","decl":"/-- If an initial object `0` exists in a CCC then every morphism from it is monic. -/\ntheorem initial_mono {I : C} (B : C) (t : IsInitial I) [CartesianClosed C] : Mono (t.to B) :=\n  ⟨fun g h _ => by\n    haveI := strict_initial t g\n    haveI := strict_initial t h\n    exact eq_of_inv_eq_inv (t.hom_ext _ _)⟩\n\n"}
{"name":"CategoryTheory.Initial.mono_to","module":"Mathlib.CategoryTheory.Closed.Cartesian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.ChosenFiniteProducts C\ninst✝¹ : CategoryTheory.Limits.HasInitial C\nB : C\ninst✝ : CategoryTheory.CartesianClosed C\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.initial.to B)","decl":"instance Initial.mono_to [HasInitial C] (B : C) [CartesianClosed C] : Mono (initial.to B) :=\n  initial_mono B initialIsInitial\n\n"}
