{"name":"IsLinearTopology.hasBasis_submodule'","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : TopologicalSpace M\nself : IsLinearTopology R M\n⊢ (nhds 0).HasBasis (fun N => Membership.mem (nhds 0) ↑N) fun N => ↑N","decl":"variable (R M) in\n/-- Consider a (left-)module `M` over a ring `R`. A topology on `M` is *`R`-linear*\nif the open sub-`R`-modules of `M` form a basis of neighborhoods of zero.\n\nTypically one would also that the topology is invariant by translation (`ContinuousConstVAdd M M`),\nor equivalently that `M` is a topological group, but we do not assume it for the definition.\n\nIn particular, we say that a topology on the ring `R` is *linear* if it is both\n`R`-linear and `Rᵐᵒᵖ`-linear for the obvious module structures. To spell this in Lean,\nsimply use `[IsLinearTopology R R] [IsLinearTopology Rᵐᵒᵖ R]`. -/\nclass _root_.IsLinearTopology where\n  hasBasis_submodule' : (𝓝 (0 : M)).HasBasis\n    (fun N : Submodule R M ↦ (N : Set M) ∈ 𝓝 0) (fun N : Submodule R M ↦ (N : Set M))\n\n"}
{"name":"IsLinearTopology.hasBasis_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\ninst✝ : IsLinearTopology R M\n⊢ (nhds 0).HasBasis (fun N => Membership.mem (nhds 0) ↑N) fun N => ↑N","decl":"variable (R) in\nlemma hasBasis_submodule [IsLinearTopology R M] : (𝓝 (0 : M)).HasBasis\n    (fun N : Submodule R M ↦ (N : Set M) ∈ 𝓝 0) (fun N : Submodule R M ↦ (N : Set M)) :=\n  IsLinearTopology.hasBasis_submodule'\n\n"}
{"name":"IsLinearTopology.hasBasis_open_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : IsLinearTopology R M\n⊢ (nhds 0).HasBasis (fun N => IsOpen ↑N) fun N => ↑N","decl":"variable (R) in\nlemma hasBasis_open_submodule [ContinuousAdd M] [IsLinearTopology R M] :\n    (𝓝 (0 : M)).HasBasis\n      (fun N : Submodule R M ↦ IsOpen (N : Set M)) (fun N : Submodule R M ↦ (N : Set M)) :=\n  hasBasis_submodule R |>.congr\n    (fun N ↦ ⟨N.toAddSubgroup.isOpen_of_mem_nhds, fun hN ↦ hN.mem_nhds (zero_mem N)⟩)\n    (fun _ _ ↦ rfl)\n\n"}
{"name":"IsLinearTopology.mk_of_hasBasis'","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\nι : Sort u_4\nS : Type u_5\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\np : ι → Prop\ns : ι → S\nh : (nhds 0).HasBasis p fun i => ↑(s i)\nhsmul : ∀ (s : S) (r : R) (m : M), Membership.mem s m → Membership.mem s (HSMul.hSMul r m)\n⊢ IsLinearTopology R M","decl":"variable (R) in\n/-- A variant of `IsLinearTopology.mk_of_hasBasis` asking for an explicit proof that `S`\nis a class of submodules instead of relying on (fragile) typeclass inference of `SMulCommClass`. -/\nlemma mk_of_hasBasis' {ι : Sort*} {S : Type*} [SetLike S M]\n    [AddSubmonoidClass S M]\n    {p : ι → Prop} {s : ι → S}\n    (h : (𝓝 0).HasBasis p (fun i ↦ (s i : Set M)))\n    (hsmul : ∀ s : S, ∀ r : R, ∀ m ∈ s, r • m ∈ s) :\n    IsLinearTopology R M where\n  hasBasis_submodule' := h.to_hasBasis\n    (fun i hi ↦ ⟨\n      { carrier := s i,\n        add_mem' := add_mem,\n        zero_mem' := zero_mem _,\n        smul_mem' := hsmul _},\n      h.mem_of_mem hi, subset_rfl⟩)\n    (fun _ ↦ h.mem_iff.mp)\n\n"}
{"name":"IsLinearTopology.mk_of_hasBasis","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nι : Sort u_4\nS : Type u_5\ninst✝² : SetLike S M\ninst✝¹ : SMulMemClass S R M\ninst✝ : AddSubmonoidClass S M\np : ι → Prop\ns : ι → S\nh : (nhds 0).HasBasis p fun i => ↑(s i)\n⊢ IsLinearTopology R M","decl":"variable (R) in\n/-- To show that `M` is linearly-topologized as an `R`-module, it suffices to show\nthat it has a basis of neighborhoods of zero made of `R`-submodules.\n\nNote: for technical reasons detailed in the module docstring, Lean sometimes struggle to find the\nright `SMulMemClass` instance. See `IsLinearTopology.mk_of_hasBasis'` for a more\nexplicit variant. -/\nlemma mk_of_hasBasis {ι : Sort*} {S : Type*} [SetLike S M]\n    [SMulMemClass S R M] [AddSubmonoidClass S M]\n    {p : ι → Prop} {s : ι → S}\n    (h : (𝓝 0).HasBasis p (fun i ↦ (s i : Set M))) :\n    IsLinearTopology R M :=\n  mk_of_hasBasis' R h fun _ ↦ SMulMemClass.smul_mem\n\n"}
{"name":"isLinearTopology_iff_hasBasis_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : TopologicalSpace M\n⊢ Iff (IsLinearTopology R M) ((nhds 0).HasBasis (fun N => Membership.mem (nhds 0) ↑N) fun N => ↑N)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_submodule :\n    IsLinearTopology R M ↔ (𝓝 0).HasBasis\n      (fun N : Submodule R M ↦ (N : Set M) ∈ 𝓝 0) (fun N : Submodule R M ↦ (N : Set M)) :=\n  ⟨fun _ ↦ hasBasis_submodule R, fun h ↦ .mk_of_hasBasis R h⟩\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\n⊢ Iff (IsLinearTopology R M) ((nhds 0).HasBasis (fun N => IsOpen ↑N) fun N => ↑N)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_submodule [ContinuousAdd M] :\n    IsLinearTopology R M ↔ (𝓝 0).HasBasis\n      (fun N : Submodule R M ↦ IsOpen (N : Set M)) (fun N : Submodule R M ↦ (N : Set M)) :=\n  ⟨fun _ ↦ hasBasis_open_submodule R, fun h ↦ .mk_of_hasBasis R h⟩\n\n"}
{"name":"IsLinearTopology.instOfDiscreteTopology","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\ninst✝ : DiscreteTopology M\n⊢ IsLinearTopology R M","decl":"/-- The discrete topology on any `R`-module is `R`-linear. -/\ninstance [DiscreteTopology M] : IsLinearTopology R M :=\n  have : HasBasis (𝓝 0 : Filter M) (fun _ ↦ True) (fun (_ : Unit) ↦ (⊥ : Submodule R M)) := by\n    rw [nhds_discrete]\n    exact hasBasis_pure _\n  mk_of_hasBasis R this\n\n"}
{"name":"IsLinearTopology.hasBasis_subbimodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninst✝⁸ : Ring R\ninst✝⁷ : Ring R'\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : Module R' M\ninst✝³ : SMulCommClass R R' M\ninst✝² : TopologicalSpace M\ninst✝¹ : IsLinearTopology R M\ninst✝ : IsLinearTopology R' M\n⊢ (nhds 0).HasBasis (fun I => And (Membership.mem (nhds 0) ↑I) (And (∀ (r : R) (x : M), Membership.mem I x → Membership.mem I (HSMul.hSMul r x)) (∀ (r' : R') (x : M), Membership.mem I x → Membership.mem I (HSMul.hSMul r' x)))) fun I => ↑I","decl":"variable (R R') in\nopen Set Pointwise in\n/-- Assume that `M` is a module over two rings `R` and `R'`, and that its topology\nis linear with respect to each of these rings. Then, it has a basis of neighborhoods of zero\nmade of sub-`(R, R')`-bimodules.\n\nThe proof is inspired by lemma 9 in [I. Kaplansky, *Topological Rings*](kaplansky_topological_1947).\nTODO: Formalize the lemma in its full strength.\n\nNote: due to the lack of a satisfying theory of sub-bimodules, we use `AddSubgroup`s with\nextra conditions. -/\nlemma hasBasis_subbimodule [IsLinearTopology R M] [IsLinearTopology R' M] :\n    (𝓝 (0 : M)).HasBasis\n      (fun I : AddSubgroup M ↦ (I : Set M) ∈ 𝓝 0 ∧\n        (∀ r : R, ∀ x ∈ I, r • x ∈ I) ∧ (∀ r' : R', ∀ x ∈ I, r' • x ∈ I))\n      (fun I : AddSubgroup M ↦ (I : Set M)) := by\n  -- Start from a neighborhood `V`. It contains some open sub-`R`-module `I`.\n  refine IsLinearTopology.hasBasis_submodule R |>.to_hasBasis (fun I hI ↦ ?_)\n    (fun I hI ↦ ⟨{I with smul_mem' := fun r x hx ↦ hI.2.1 r x hx}, hI.1, subset_rfl⟩)\n  -- `I` itself is a neighborhood of zero, so it contains some open sub-`R'`-module `J`.\n  rcases (hasBasis_submodule R').mem_iff.mp hI with ⟨J, hJ, J_sub_I⟩\n  set uR : Set R := univ -- Convenient to avoid type ascriptions\n  set uR' : Set R' := univ\n  have hRR : uR * uR ⊆ uR := subset_univ _\n  have hRI : uR • (I : Set M) ⊆ I := smul_subset_iff.mpr fun x _ i hi ↦ I.smul_mem x hi\n  have hR'J : uR' • (J : Set M) ⊆ J := smul_subset_iff.mpr fun x _ j hj ↦ J.smul_mem x hj\n  have hRJ : uR • (J : Set M) ⊆ I := subset_trans (smul_subset_smul_left J_sub_I) hRI\n  -- Note that, on top of the obvious `R • I ⊆ I` and `R' • J ⊆ J`, we have `R • J ⊆ R • I ⊆ I`.\n  -- Now set `S := J ∪ (R • J)`. We have:\n  -- 1. `R • S = (R • J) ∪ (R • R • J) ⊆ R • J ⊆ S`.\n  -- 2. `R' • S = (R' • J) ∪ (R' • R • J) ⊆ J ∪ (R • R' • J) ⊆ J ∪ (R • J) = S`.\n  -- Hence the subgroup `A` generated by `S` is a sub-`(R, R')`-bimodule,\n  -- which we claim is open and contained in `I`.\n  -- Indeed, we have `J ⊆ S ⊆ I`, hence `J ⊆ A ⊆ I`, and `J` is open by hypothesis.\n  set S : Set M := J ∪ uR • J\n  have S_sub_I : S ⊆ I := union_subset J_sub_I hRJ\n  have hRS : uR • S ⊆ S := calc\n    uR • S = uR • (J : Set M) ∪ (uR * uR) • (J : Set M) := by simp_rw [S, smul_union, mul_smul]\n    _ ⊆ uR • (J : Set M) ∪ uR • (J : Set M) := by gcongr\n    _ = uR • (J : Set M) := union_self _\n    _ ⊆ S := subset_union_right\n  have hR'S : uR' • S ⊆ S := calc\n    uR' • S = uR' • (J : Set M) ∪ uR • uR' • (J : Set M) := by simp_rw [S, smul_union, smul_comm]\n    _ ⊆ J ∪ uR • J := by gcongr\n    _ = S := rfl\n  set A : AddSubgroup M := .closure S\n  have hRA : ∀ r : R, ∀ i ∈ A, r • i ∈ A := fun r i hi ↦ by\n    refine AddSubgroup.closure_induction (fun x hx => ?base) ?zero (fun x y _ _ hx hy ↦ ?add)\n      (fun x _ hx ↦ ?neg) hi\n    case base => exact AddSubgroup.subset_closure <| hRS <| Set.smul_mem_smul trivial hx\n    case zero => simp_rw [smul_zero]; exact zero_mem _\n    case add => simp_rw [smul_add]; exact add_mem hx hy\n    case neg => simp_rw [smul_neg]; exact neg_mem hx\n  have hR'A : ∀ r' : R', ∀ i ∈ A, r' • i ∈ A := fun r' i hi ↦ by\n    refine AddSubgroup.closure_induction (fun x hx => ?base) ?zero (fun x y _ _ hx hy ↦ ?add)\n      (fun x _ hx ↦ ?neg) hi\n    case base => exact AddSubgroup.subset_closure <| hR'S <| Set.smul_mem_smul trivial hx\n    case zero => simp_rw [smul_zero]; exact zero_mem _\n    case add => simp_rw [smul_add]; exact add_mem hx hy\n    case neg => simp_rw [smul_neg]; exact neg_mem hx\n  have A_sub_I : (A : Set M) ⊆ I := I.toAddSubgroup.closure_le.mpr S_sub_I\n  have J_sub_A : (J : Set M) ⊆ A := subset_trans subset_union_left AddSubgroup.subset_closure\n  exact ⟨A, ⟨mem_of_superset hJ J_sub_A, hRA, hR'A⟩, A_sub_I⟩\n\n"}
{"name":"IsLinearTopology.hasBasis_open_subbimodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninst✝⁹ : Ring R\ninst✝⁸ : Ring R'\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module R' M\ninst✝⁴ : SMulCommClass R R' M\ninst✝³ : TopologicalSpace M\ninst✝² : ContinuousAdd M\ninst✝¹ : IsLinearTopology R M\ninst✝ : IsLinearTopology R' M\n⊢ (nhds 0).HasBasis (fun I => And (IsOpen ↑I) (And (∀ (r : R) (x : M), Membership.mem I x → Membership.mem I (HSMul.hSMul r x)) (∀ (r' : R') (x : M), Membership.mem I x → Membership.mem I (HSMul.hSMul r' x)))) fun I => ↑I","decl":"variable (R R') in\nopen Set Pointwise in\n/-- A variant of `IsLinearTopology.hasBasis_subbimodule` using `IsOpen I` instead of `I ∈ 𝓝 0`. -/\nlemma hasBasis_open_subbimodule [ContinuousAdd M] [IsLinearTopology R M] [IsLinearTopology R' M] :\n    (𝓝 (0 : M)).HasBasis\n      (fun I : AddSubgroup M ↦ IsOpen (I : Set M) ∧\n        (∀ r : R, ∀ x ∈ I, r • x ∈ I) ∧ (∀ r' : R', ∀ x ∈ I, r' • x ∈ I))\n      (fun I : AddSubgroup M ↦ (I : Set M)) :=\n  hasBasis_subbimodule R R' |>.congr\n    (fun N ↦ and_congr_left' ⟨N.isOpen_of_mem_nhds, fun hN ↦ hN.mem_nhds (zero_mem N)⟩)\n    (fun _ _ ↦ rfl)\n\n-- Even though `R` can be recovered from `a`, the nature of this lemma means that `a` will\n-- often be left for Lean to infer, so making `R` explicit is useful in practice.\n"}
{"name":"IsLinearTopology.tendsto_smul_zero","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace M\ninst✝ : IsLinearTopology R M\nι : Type u_4\nf : Filter ι\na : ι → R\nm : ι → M\nha : Filter.Tendsto m f (nhds 0)\n⊢ Filter.Tendsto (HSMul.hSMul a m) f (nhds 0)","decl":"variable (R) in\n/-- If `M` is a linearly topologized `R`-module and `i ↦ m i` tends to zero,\nthen `i ↦ a i • m i` still tends to zero for any family `a : ι → R`. -/\ntheorem tendsto_smul_zero [IsLinearTopology R M] {ι : Type*} {f : Filter ι}\n    (a : ι → R) (m : ι → M) (ha : Tendsto m f (𝓝 0)) :\n    Tendsto (a • m) f (𝓝 0) := by\n  rw [hasBasis_submodule R |>.tendsto_right_iff] at ha ⊢\n  intro I hI\n  filter_upwards [ha I hI] with i ai_mem\n  exact I.smul_mem _ ai_mem\n\n"}
{"name":"IsCentralScalar.isLinearTopology_iff","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : IsCentralScalar R M\n⊢ Iff (IsLinearTopology (MulOpposite R) M) (IsLinearTopology R M)","decl":"variable (R) in\n/-- If the left and right actions of `R` on `M` coincide, then a topology is `Rᵐᵒᵖ`-linear\nif and only if it is `R`-linear. -/\ntheorem _root_.IsCentralScalar.isLinearTopology_iff [Module Rᵐᵒᵖ M] [IsCentralScalar R M] :\n    IsLinearTopology Rᵐᵒᵖ M ↔ IsLinearTopology R M := by\n  constructor <;> intro H\n  · exact mk_of_hasBasis' R (IsLinearTopology.hasBasis_submodule Rᵐᵒᵖ)\n      fun S r m hm ↦ op_smul_eq_smul r m ▸ S.smul_mem _ hm\n  · exact mk_of_hasBasis' Rᵐᵒᵖ (IsLinearTopology.hasBasis_submodule R)\n      fun S r m hm ↦ unop_smul_eq_smul r m ▸ S.smul_mem _ hm\n\n"}
{"name":"IsLinearTopology.hasBasis_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : TopologicalSpace R\ninst✝ : IsLinearTopology R R\n⊢ (nhds 0).HasBasis (fun I => Membership.mem (nhds 0) ↑I) fun I => ↑I","decl":"theorem hasBasis_ideal [IsLinearTopology R R] :\n    (𝓝 0).HasBasis (fun I : Ideal R ↦ (I : Set R) ∈ 𝓝 0) (fun I : Ideal R ↦ (I : Set R)) :=\n  hasBasis_submodule R\n\n"}
{"name":"IsLinearTopology.hasBasis_open_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousAdd R\ninst✝ : IsLinearTopology R R\n⊢ (nhds 0).HasBasis (fun I => IsOpen ↑I) fun I => ↑I","decl":"theorem hasBasis_open_ideal [ContinuousAdd R] [IsLinearTopology R R] :\n    (𝓝 0).HasBasis (fun I : Ideal R ↦ IsOpen (I : Set R)) (fun I : Ideal R ↦ (I : Set R)) :=\n  hasBasis_open_submodule R\n\n"}
{"name":"isLinearTopology_iff_hasBasis_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : TopologicalSpace R\n⊢ Iff (IsLinearTopology R R) ((nhds 0).HasBasis (fun I => Membership.mem (nhds 0) ↑I) fun I => ↑I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_ideal :\n    IsLinearTopology R R ↔ (𝓝 0).HasBasis\n      (fun I : Ideal R ↦ (I : Set R) ∈ 𝓝 0) (fun I : Ideal R ↦ (I : Set R)) :=\n  isLinearTopology_iff_hasBasis_submodule\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalRing R\n⊢ Iff (IsLinearTopology R R) ((nhds 0).HasBasis (fun I => IsOpen ↑I) fun I => ↑I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_ideal [TopologicalRing R] :\n    IsLinearTopology R R ↔ (𝓝 0).HasBasis\n      (fun I : Ideal R ↦ IsOpen (I : Set R)) (fun I : Ideal R ↦ (I : Set R)) :=\n  isLinearTopology_iff_hasBasis_open_submodule\n\n"}
{"name":"IsLinearTopology.hasBasis_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : TopologicalSpace R\ninst✝¹ : IsLinearTopology R R\ninst✝ : IsLinearTopology (MulOpposite R) R\n⊢ (nhds 0).HasBasis (fun I => Membership.mem (nhds 0) ↑I) fun I => ↑I","decl":"open Set Pointwise in\n/-- If a ring `R` is linearly ordered as a left *and* right module over itself,\nthen it has a basis of neighborhoods of zero made of *two-sided* ideals.\n\nThis is usually called a *linearly topologized ring*, but we do not add a specific spelling:\nyou should use `[IsLinearTopology R R] [IsLinearTopology Rᵐᵒᵖ R]` instead. -/\nlemma hasBasis_twoSidedIdeal [IsLinearTopology R R] [IsLinearTopology Rᵐᵒᵖ R] :\n    (𝓝 (0 : R)).HasBasis (fun I : TwoSidedIdeal R ↦ (I : Set R) ∈ 𝓝 0)\n      (fun I : TwoSidedIdeal R ↦ (I : Set R)) :=\n  hasBasis_subbimodule R Rᵐᵒᵖ |>.to_hasBasis\n    (fun I ⟨hI, hRI, hRI'⟩ ↦ ⟨.mk' I (zero_mem _) add_mem neg_mem (hRI _ _) (hRI' _ _),\n      by simpa using hI, by simp⟩)\n    (fun I hI ↦ ⟨I.asIdeal.toAddSubgroup,\n      ⟨hI, I.mul_mem_left, fun r x hx ↦ I.mul_mem_right x (r.unop) hx⟩, subset_rfl⟩)\n\n"}
{"name":"IsLinearTopology.hasBasis_open_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\ninst✝³ : TopologicalSpace R\ninst✝² : ContinuousAdd R\ninst✝¹ : IsLinearTopology R R\ninst✝ : IsLinearTopology (MulOpposite R) R\n⊢ (nhds 0).HasBasis (fun I => IsOpen ↑I) fun I => ↑I","decl":"lemma hasBasis_open_twoSidedIdeal [ContinuousAdd R]\n    [IsLinearTopology R R] [IsLinearTopology Rᵐᵒᵖ R] :\n    (𝓝 (0 : R)).HasBasis\n      (fun I : TwoSidedIdeal R ↦ IsOpen (I : Set R)) (fun I : TwoSidedIdeal R ↦ (I : Set R)) :=\n  hasBasis_twoSidedIdeal.congr\n    (fun I ↦ ⟨I.asIdeal.toAddSubgroup.isOpen_of_mem_nhds, fun hI ↦ hI.mem_nhds (zero_mem I)⟩)\n    (fun _ _ ↦ rfl)\n\n"}
{"name":"isLinearTopology_iff_hasBasis_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : TopologicalSpace R\n⊢ Iff (And (IsLinearTopology R R) (IsLinearTopology (MulOpposite R) R)) ((nhds 0).HasBasis (fun I => Membership.mem (nhds 0) ↑I) fun I => ↑I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_twoSidedIdeal :\n    IsLinearTopology R R ∧ IsLinearTopology Rᵐᵒᵖ R ↔\n      (𝓝 0).HasBasis\n        (fun I : TwoSidedIdeal R ↦ (I : Set R) ∈ 𝓝 0) (fun I : TwoSidedIdeal R ↦ (I : Set R)) :=\n  ⟨fun ⟨_, _⟩ ↦ hasBasis_twoSidedIdeal, fun h ↦\n    ⟨.mk_of_hasBasis' R h fun I r x hx ↦ I.mul_mem_left r x hx,\n      .mk_of_hasBasis' Rᵐᵒᵖ h fun I r x hx ↦ I.mul_mem_right x r.unop hx⟩⟩\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : TopologicalSpace R\ninst✝ : ContinuousAdd R\n⊢ Iff (And (IsLinearTopology R R) (IsLinearTopology (MulOpposite R) R)) ((nhds 0).HasBasis (fun I => IsOpen ↑I) fun I => ↑I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_twoSidedIdeal [ContinuousAdd R] :\n    IsLinearTopology R R ∧ IsLinearTopology Rᵐᵒᵖ R ↔ (𝓝 0).HasBasis\n      (fun I : TwoSidedIdeal R ↦ IsOpen (I : Set R)) (fun I : TwoSidedIdeal R ↦ (I : Set R)) :=\n  ⟨fun ⟨_, _⟩ ↦ hasBasis_open_twoSidedIdeal, fun h ↦\n    ⟨.mk_of_hasBasis' R h fun I r x hx ↦ I.mul_mem_left r x hx,\n      .mk_of_hasBasis' Rᵐᵒᵖ h fun I r x hx ↦ I.mul_mem_right x r.unop hx⟩⟩\n\n"}
{"name":"IsLinearTopology.tendsto_mul_zero_of_left","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : TopologicalSpace R\ninst✝ : IsLinearTopology (MulOpposite R) R\nι : Type u_2\nf : Filter ι\na b : ι → R\nha : Filter.Tendsto a f (nhds 0)\n⊢ Filter.Tendsto (HMul.hMul a b) f (nhds 0)","decl":"theorem tendsto_mul_zero_of_left [IsLinearTopology Rᵐᵒᵖ R] {ι : Type*} {f : Filter ι}\n    (a b : ι → R) (ha : Tendsto a f (𝓝 0)) :\n    Tendsto (a * b) f (𝓝 0) :=\n  tendsto_smul_zero (R := Rᵐᵒᵖ) _ _ ha\n\n"}
{"name":"IsLinearTopology.tendsto_mul_zero_of_right","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : TopologicalSpace R\ninst✝ : IsLinearTopology R R\nι : Type u_2\nf : Filter ι\na b : ι → R\nhb : Filter.Tendsto b f (nhds 0)\n⊢ Filter.Tendsto (HMul.hMul a b) f (nhds 0)","decl":"theorem tendsto_mul_zero_of_right [IsLinearTopology R R] {ι : Type*} {f : Filter ι}\n    (a b : ι → R) (hb : Tendsto b f (𝓝 0)) :\n    Tendsto (a * b) f (𝓝 0) :=\n  tendsto_smul_zero (R := R) _ _ hb\n\n"}
{"name":"IsLinearTopology.instMulOpposite","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : TopologicalSpace R\ninst✝ : IsLinearTopology R R\n⊢ IsLinearTopology (MulOpposite R) R","decl":"/-- If `R` is commutative and left-linearly topologized, it is also right-linearly topologized. -/\ninstance (priority := 100) [IsLinearTopology R R] :\n    IsLinearTopology Rᵐᵒᵖ R := by\n  rwa [IsCentralScalar.isLinearTopology_iff]\n\n"}
