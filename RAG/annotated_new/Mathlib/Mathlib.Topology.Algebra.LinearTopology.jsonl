{"name":"IsLinearTopology.hasBasis_submodule'","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœÂ³ : Ring R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : TopologicalSpace M\nself : IsLinearTopology R M\nâŠ¢ (nhds 0).HasBasis (fun N => Membership.mem (nhds 0) â†‘N) fun N => â†‘N","decl":"variable (R M) in\n/-- Consider a (left-)module `M` over a ring `R`. A topology on `M` is *`R`-linear*\nif the open sub-`R`-modules of `M` form a basis of neighborhoods of zero.\n\nTypically one would also that the topology is invariant by translation (`ContinuousConstVAdd M M`),\nor equivalently that `M` is a topological group, but we do not assume it for the definition.\n\nIn particular, we say that a topology on the ring `R` is *linear* if it is both\n`R`-linear and `Ráµáµ’áµ–`-linear for the obvious module structures. To spell this in Lean,\nsimply use `[IsLinearTopology R R] [IsLinearTopology Ráµáµ’áµ– R]`. -/\nclass _root_.IsLinearTopology where\n  hasBasis_submodule' : (ğ“ (0 : M)).HasBasis\n    (fun N : Submodule R M â†¦ (N : Set M) âˆˆ ğ“ 0) (fun N : Submodule R M â†¦ (N : Set M))\n\n"}
{"name":"IsLinearTopology.hasBasis_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : IsLinearTopology R M\nâŠ¢ (nhds 0).HasBasis (fun N => Membership.mem (nhds 0) â†‘N) fun N => â†‘N","decl":"variable (R) in\nlemma hasBasis_submodule [IsLinearTopology R M] : (ğ“ (0 : M)).HasBasis\n    (fun N : Submodule R M â†¦ (N : Set M) âˆˆ ğ“ 0) (fun N : Submodule R M â†¦ (N : Set M)) :=\n  IsLinearTopology.hasBasis_submodule'\n\n"}
{"name":"IsLinearTopology.hasBasis_open_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : IsLinearTopology R M\nâŠ¢ (nhds 0).HasBasis (fun N => IsOpen â†‘N) fun N => â†‘N","decl":"variable (R) in\nlemma hasBasis_open_submodule [ContinuousAdd M] [IsLinearTopology R M] :\n    (ğ“ (0 : M)).HasBasis\n      (fun N : Submodule R M â†¦ IsOpen (N : Set M)) (fun N : Submodule R M â†¦ (N : Set M)) :=\n  hasBasis_submodule R |>.congr\n    (fun N â†¦ âŸ¨N.toAddSubgroup.isOpen_of_mem_nhds, fun hN â†¦ hN.mem_nhds (zero_mem N)âŸ©)\n    (fun _ _ â†¦ rfl)\n\n"}
{"name":"IsLinearTopology.mk_of_hasBasis'","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : TopologicalSpace M\nÎ¹ : Sort u_4\nS : Type u_5\ninstâœÂ¹ : SetLike S M\ninstâœ : AddSubmonoidClass S M\np : Î¹ â†’ Prop\ns : Î¹ â†’ S\nh : (nhds 0).HasBasis p fun i => â†‘(s i)\nhsmul : âˆ€ (s : S) (r : R) (m : M), Membership.mem s m â†’ Membership.mem s (HSMul.hSMul r m)\nâŠ¢ IsLinearTopology R M","decl":"variable (R) in\n/-- A variant of `IsLinearTopology.mk_of_hasBasis` asking for an explicit proof that `S`\nis a class of submodules instead of relying on (fragile) typeclass inference of `SMulCommClass`. -/\nlemma mk_of_hasBasis' {Î¹ : Sort*} {S : Type*} [SetLike S M]\n    [AddSubmonoidClass S M]\n    {p : Î¹ â†’ Prop} {s : Î¹ â†’ S}\n    (h : (ğ“ 0).HasBasis p (fun i â†¦ (s i : Set M)))\n    (hsmul : âˆ€ s : S, âˆ€ r : R, âˆ€ m âˆˆ s, r â€¢ m âˆˆ s) :\n    IsLinearTopology R M where\n  hasBasis_submodule' := h.to_hasBasis\n    (fun i hi â†¦ âŸ¨\n      { carrier := s i,\n        add_mem' := add_mem,\n        zero_mem' := zero_mem _,\n        smul_mem' := hsmul _},\n      h.mem_of_mem hi, subset_rflâŸ©)\n    (fun _ â†¦ h.mem_iff.mp)\n\n"}
{"name":"IsLinearTopology.mk_of_hasBasis","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâ¶ : Ring R\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : TopologicalSpace M\nÎ¹ : Sort u_4\nS : Type u_5\ninstâœÂ² : SetLike S M\ninstâœÂ¹ : SMulMemClass S R M\ninstâœ : AddSubmonoidClass S M\np : Î¹ â†’ Prop\ns : Î¹ â†’ S\nh : (nhds 0).HasBasis p fun i => â†‘(s i)\nâŠ¢ IsLinearTopology R M","decl":"variable (R) in\n/-- To show that `M` is linearly-topologized as an `R`-module, it suffices to show\nthat it has a basis of neighborhoods of zero made of `R`-submodules.\n\nNote: for technical reasons detailed in the module docstring, Lean sometimes struggle to find the\nright `SMulMemClass` instance. See `IsLinearTopology.mk_of_hasBasis'` for a more\nexplicit variant. -/\nlemma mk_of_hasBasis {Î¹ : Sort*} {S : Type*} [SetLike S M]\n    [SMulMemClass S R M] [AddSubmonoidClass S M]\n    {p : Î¹ â†’ Prop} {s : Î¹ â†’ S}\n    (h : (ğ“ 0).HasBasis p (fun i â†¦ (s i : Set M))) :\n    IsLinearTopology R M :=\n  mk_of_hasBasis' R h fun _ â†¦ SMulMemClass.smul_mem\n\n"}
{"name":"isLinearTopology_iff_hasBasis_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœÂ³ : Ring R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : TopologicalSpace M\nâŠ¢ Iff (IsLinearTopology R M) ((nhds 0).HasBasis (fun N => Membership.mem (nhds 0) â†‘N) fun N => â†‘N)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_submodule :\n    IsLinearTopology R M â†” (ğ“ 0).HasBasis\n      (fun N : Submodule R M â†¦ (N : Set M) âˆˆ ğ“ 0) (fun N : Submodule R M â†¦ (N : Set M)) :=\n  âŸ¨fun _ â†¦ hasBasis_submodule R, fun h â†¦ .mk_of_hasBasis R hâŸ©\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_submodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nâŠ¢ Iff (IsLinearTopology R M) ((nhds 0).HasBasis (fun N => IsOpen â†‘N) fun N => â†‘N)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_submodule [ContinuousAdd M] :\n    IsLinearTopology R M â†” (ğ“ 0).HasBasis\n      (fun N : Submodule R M â†¦ IsOpen (N : Set M)) (fun N : Submodule R M â†¦ (N : Set M)) :=\n  âŸ¨fun _ â†¦ hasBasis_open_submodule R, fun h â†¦ .mk_of_hasBasis R hâŸ©\n\n"}
{"name":"IsLinearTopology.instOfDiscreteTopology","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : DiscreteTopology M\nâŠ¢ IsLinearTopology R M","decl":"/-- The discrete topology on any `R`-module is `R`-linear. -/\ninstance [DiscreteTopology M] : IsLinearTopology R M :=\n  have : HasBasis (ğ“ 0 : Filter M) (fun _ â†¦ True) (fun (_ : Unit) â†¦ (âŠ¥ : Submodule R M)) := by\n    rw [nhds_discrete]\n    exact hasBasis_pure _\n  mk_of_hasBasis R this\n\n"}
{"name":"IsLinearTopology.hasBasis_subbimodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninstâœâ¸ : Ring R\ninstâœâ· : Ring R'\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\ninstâœâ´ : Module R' M\ninstâœÂ³ : SMulCommClass R R' M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : IsLinearTopology R M\ninstâœ : IsLinearTopology R' M\nâŠ¢ (nhds 0).HasBasis (fun I => And (Membership.mem (nhds 0) â†‘I) (And (âˆ€ (r : R) (x : M), Membership.mem I x â†’ Membership.mem I (HSMul.hSMul r x)) (âˆ€ (r' : R') (x : M), Membership.mem I x â†’ Membership.mem I (HSMul.hSMul r' x)))) fun I => â†‘I","decl":"variable (R R') in\nopen Set Pointwise in\n/-- Assume that `M` is a module over two rings `R` and `R'`, and that its topology\nis linear with respect to each of these rings. Then, it has a basis of neighborhoods of zero\nmade of sub-`(R, R')`-bimodules.\n\nThe proof is inspired by lemma 9 in [I. Kaplansky, *Topological Rings*](kaplansky_topological_1947).\nTODO: Formalize the lemma in its full strength.\n\nNote: due to the lack of a satisfying theory of sub-bimodules, we use `AddSubgroup`s with\nextra conditions. -/\nlemma hasBasis_subbimodule [IsLinearTopology R M] [IsLinearTopology R' M] :\n    (ğ“ (0 : M)).HasBasis\n      (fun I : AddSubgroup M â†¦ (I : Set M) âˆˆ ğ“ 0 âˆ§\n        (âˆ€ r : R, âˆ€ x âˆˆ I, r â€¢ x âˆˆ I) âˆ§ (âˆ€ r' : R', âˆ€ x âˆˆ I, r' â€¢ x âˆˆ I))\n      (fun I : AddSubgroup M â†¦ (I : Set M)) := by\n  -- Start from a neighborhood `V`. It contains some open sub-`R`-module `I`.\n  refine IsLinearTopology.hasBasis_submodule R |>.to_hasBasis (fun I hI â†¦ ?_)\n    (fun I hI â†¦ âŸ¨{I with smul_mem' := fun r x hx â†¦ hI.2.1 r x hx}, hI.1, subset_rflâŸ©)\n  -- `I` itself is a neighborhood of zero, so it contains some open sub-`R'`-module `J`.\n  rcases (hasBasis_submodule R').mem_iff.mp hI with âŸ¨J, hJ, J_sub_IâŸ©\n  set uR : Set R := univ -- Convenient to avoid type ascriptions\n  set uR' : Set R' := univ\n  have hRR : uR * uR âŠ† uR := subset_univ _\n  have hRI : uR â€¢ (I : Set M) âŠ† I := smul_subset_iff.mpr fun x _ i hi â†¦ I.smul_mem x hi\n  have hR'J : uR' â€¢ (J : Set M) âŠ† J := smul_subset_iff.mpr fun x _ j hj â†¦ J.smul_mem x hj\n  have hRJ : uR â€¢ (J : Set M) âŠ† I := subset_trans (smul_subset_smul_left J_sub_I) hRI\n  -- Note that, on top of the obvious `R â€¢ I âŠ† I` and `R' â€¢ J âŠ† J`, we have `R â€¢ J âŠ† R â€¢ I âŠ† I`.\n  -- Now set `S := J âˆª (R â€¢ J)`. We have:\n  -- 1. `R â€¢ S = (R â€¢ J) âˆª (R â€¢ R â€¢ J) âŠ† R â€¢ J âŠ† S`.\n  -- 2. `R' â€¢ S = (R' â€¢ J) âˆª (R' â€¢ R â€¢ J) âŠ† J âˆª (R â€¢ R' â€¢ J) âŠ† J âˆª (R â€¢ J) = S`.\n  -- Hence the subgroup `A` generated by `S` is a sub-`(R, R')`-bimodule,\n  -- which we claim is open and contained in `I`.\n  -- Indeed, we have `J âŠ† S âŠ† I`, hence `J âŠ† A âŠ† I`, and `J` is open by hypothesis.\n  set S : Set M := J âˆª uR â€¢ J\n  have S_sub_I : S âŠ† I := union_subset J_sub_I hRJ\n  have hRS : uR â€¢ S âŠ† S := calc\n    uR â€¢ S = uR â€¢ (J : Set M) âˆª (uR * uR) â€¢ (J : Set M) := by simp_rw [S, smul_union, mul_smul]\n    _ âŠ† uR â€¢ (J : Set M) âˆª uR â€¢ (J : Set M) := by gcongr\n    _ = uR â€¢ (J : Set M) := union_self _\n    _ âŠ† S := subset_union_right\n  have hR'S : uR' â€¢ S âŠ† S := calc\n    uR' â€¢ S = uR' â€¢ (J : Set M) âˆª uR â€¢ uR' â€¢ (J : Set M) := by simp_rw [S, smul_union, smul_comm]\n    _ âŠ† J âˆª uR â€¢ J := by gcongr\n    _ = S := rfl\n  set A : AddSubgroup M := .closure S\n  have hRA : âˆ€ r : R, âˆ€ i âˆˆ A, r â€¢ i âˆˆ A := fun r i hi â†¦ by\n    refine AddSubgroup.closure_induction (fun x hx => ?base) ?zero (fun x y _ _ hx hy â†¦ ?add)\n      (fun x _ hx â†¦ ?neg) hi\n    case base => exact AddSubgroup.subset_closure <| hRS <| Set.smul_mem_smul trivial hx\n    case zero => simp_rw [smul_zero]; exact zero_mem _\n    case add => simp_rw [smul_add]; exact add_mem hx hy\n    case neg => simp_rw [smul_neg]; exact neg_mem hx\n  have hR'A : âˆ€ r' : R', âˆ€ i âˆˆ A, r' â€¢ i âˆˆ A := fun r' i hi â†¦ by\n    refine AddSubgroup.closure_induction (fun x hx => ?base) ?zero (fun x y _ _ hx hy â†¦ ?add)\n      (fun x _ hx â†¦ ?neg) hi\n    case base => exact AddSubgroup.subset_closure <| hR'S <| Set.smul_mem_smul trivial hx\n    case zero => simp_rw [smul_zero]; exact zero_mem _\n    case add => simp_rw [smul_add]; exact add_mem hx hy\n    case neg => simp_rw [smul_neg]; exact neg_mem hx\n  have A_sub_I : (A : Set M) âŠ† I := I.toAddSubgroup.closure_le.mpr S_sub_I\n  have J_sub_A : (J : Set M) âŠ† A := subset_trans subset_union_left AddSubgroup.subset_closure\n  exact âŸ¨A, âŸ¨mem_of_superset hJ J_sub_A, hRA, hR'AâŸ©, A_sub_IâŸ©\n\n"}
{"name":"IsLinearTopology.hasBasis_open_subbimodule","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\ninstâœâ¹ : Ring R\ninstâœâ¸ : Ring R'\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : Module R' M\ninstâœâ´ : SMulCommClass R R' M\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ContinuousAdd M\ninstâœÂ¹ : IsLinearTopology R M\ninstâœ : IsLinearTopology R' M\nâŠ¢ (nhds 0).HasBasis (fun I => And (IsOpen â†‘I) (And (âˆ€ (r : R) (x : M), Membership.mem I x â†’ Membership.mem I (HSMul.hSMul r x)) (âˆ€ (r' : R') (x : M), Membership.mem I x â†’ Membership.mem I (HSMul.hSMul r' x)))) fun I => â†‘I","decl":"variable (R R') in\nopen Set Pointwise in\n/-- A variant of `IsLinearTopology.hasBasis_subbimodule` using `IsOpen I` instead of `I âˆˆ ğ“ 0`. -/\nlemma hasBasis_open_subbimodule [ContinuousAdd M] [IsLinearTopology R M] [IsLinearTopology R' M] :\n    (ğ“ (0 : M)).HasBasis\n      (fun I : AddSubgroup M â†¦ IsOpen (I : Set M) âˆ§\n        (âˆ€ r : R, âˆ€ x âˆˆ I, r â€¢ x âˆˆ I) âˆ§ (âˆ€ r' : R', âˆ€ x âˆˆ I, r' â€¢ x âˆˆ I))\n      (fun I : AddSubgroup M â†¦ (I : Set M)) :=\n  hasBasis_subbimodule R R' |>.congr\n    (fun N â†¦ and_congr_left' âŸ¨N.isOpen_of_mem_nhds, fun hN â†¦ hN.mem_nhds (zero_mem N)âŸ©)\n    (fun _ _ â†¦ rfl)\n\n-- Even though `R` can be recovered from `a`, the nature of this lemma means that `a` will\n-- often be left for Lean to infer, so making `R` explicit is useful in practice.\n"}
{"name":"IsLinearTopology.tendsto_smul_zero","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâ´ : Ring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : IsLinearTopology R M\nÎ¹ : Type u_4\nf : Filter Î¹\na : Î¹ â†’ R\nm : Î¹ â†’ M\nha : Filter.Tendsto m f (nhds 0)\nâŠ¢ Filter.Tendsto (HSMul.hSMul a m) f (nhds 0)","decl":"variable (R) in\n/-- If `M` is a linearly topologized `R`-module and `i â†¦ m i` tends to zero,\nthen `i â†¦ a i â€¢ m i` still tends to zero for any family `a : Î¹ â†’ R`. -/\ntheorem tendsto_smul_zero [IsLinearTopology R M] {Î¹ : Type*} {f : Filter Î¹}\n    (a : Î¹ â†’ R) (m : Î¹ â†’ M) (ha : Tendsto m f (ğ“ 0)) :\n    Tendsto (a â€¢ m) f (ğ“ 0) := by\n  rw [hasBasis_submodule R |>.tendsto_right_iff] at ha âŠ¢\n  intro I hI\n  filter_upwards [ha I hI] with i ai_mem\n  exact I.smul_mem _ ai_mem\n\n"}
{"name":"IsCentralScalar.isLinearTopology_iff","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\nM : Type u_3\ninstâœâµ : Ring R\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Module (MulOpposite R) M\ninstâœ : IsCentralScalar R M\nâŠ¢ Iff (IsLinearTopology (MulOpposite R) M) (IsLinearTopology R M)","decl":"variable (R) in\n/-- If the left and right actions of `R` on `M` coincide, then a topology is `Ráµáµ’áµ–`-linear\nif and only if it is `R`-linear. -/\ntheorem _root_.IsCentralScalar.isLinearTopology_iff [Module Ráµáµ’áµ– M] [IsCentralScalar R M] :\n    IsLinearTopology Ráµáµ’áµ– M â†” IsLinearTopology R M := by\n  constructor <;> intro H\n  Â· exact mk_of_hasBasis' R (IsLinearTopology.hasBasis_submodule Ráµáµ’áµ–)\n      fun S r m hm â†¦ op_smul_eq_smul r m â–¸ S.smul_mem _ hm\n  Â· exact mk_of_hasBasis' Ráµáµ’áµ– (IsLinearTopology.hasBasis_submodule R)\n      fun S r m hm â†¦ unop_smul_eq_smul r m â–¸ S.smul_mem _ hm\n\n"}
{"name":"IsLinearTopology.hasBasis_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : Ring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : IsLinearTopology R R\nâŠ¢ (nhds 0).HasBasis (fun I => Membership.mem (nhds 0) â†‘I) fun I => â†‘I","decl":"theorem hasBasis_ideal [IsLinearTopology R R] :\n    (ğ“ 0).HasBasis (fun I : Ideal R â†¦ (I : Set R) âˆˆ ğ“ 0) (fun I : Ideal R â†¦ (I : Set R)) :=\n  hasBasis_submodule R\n\n"}
{"name":"IsLinearTopology.hasBasis_open_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ³ : Ring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : ContinuousAdd R\ninstâœ : IsLinearTopology R R\nâŠ¢ (nhds 0).HasBasis (fun I => IsOpen â†‘I) fun I => â†‘I","decl":"theorem hasBasis_open_ideal [ContinuousAdd R] [IsLinearTopology R R] :\n    (ğ“ 0).HasBasis (fun I : Ideal R â†¦ IsOpen (I : Set R)) (fun I : Ideal R â†¦ (I : Set R)) :=\n  hasBasis_open_submodule R\n\n"}
{"name":"isLinearTopology_iff_hasBasis_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : TopologicalSpace R\nâŠ¢ Iff (IsLinearTopology R R) ((nhds 0).HasBasis (fun I => Membership.mem (nhds 0) â†‘I) fun I => â†‘I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_ideal :\n    IsLinearTopology R R â†” (ğ“ 0).HasBasis\n      (fun I : Ideal R â†¦ (I : Set R) âˆˆ ğ“ 0) (fun I : Ideal R â†¦ (I : Set R)) :=\n  isLinearTopology_iff_hasBasis_submodule\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_ideal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : Ring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalRing R\nâŠ¢ Iff (IsLinearTopology R R) ((nhds 0).HasBasis (fun I => IsOpen â†‘I) fun I => â†‘I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_ideal [TopologicalRing R] :\n    IsLinearTopology R R â†” (ğ“ 0).HasBasis\n      (fun I : Ideal R â†¦ IsOpen (I : Set R)) (fun I : Ideal R â†¦ (I : Set R)) :=\n  isLinearTopology_iff_hasBasis_open_submodule\n\n"}
{"name":"IsLinearTopology.hasBasis_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ³ : Ring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : IsLinearTopology R R\ninstâœ : IsLinearTopology (MulOpposite R) R\nâŠ¢ (nhds 0).HasBasis (fun I => Membership.mem (nhds 0) â†‘I) fun I => â†‘I","decl":"open Set Pointwise in\n/-- If a ring `R` is linearly ordered as a left *and* right module over itself,\nthen it has a basis of neighborhoods of zero made of *two-sided* ideals.\n\nThis is usually called a *linearly topologized ring*, but we do not add a specific spelling:\nyou should use `[IsLinearTopology R R] [IsLinearTopology Ráµáµ’áµ– R]` instead. -/\nlemma hasBasis_twoSidedIdeal [IsLinearTopology R R] [IsLinearTopology Ráµáµ’áµ– R] :\n    (ğ“ (0 : R)).HasBasis (fun I : TwoSidedIdeal R â†¦ (I : Set R) âˆˆ ğ“ 0)\n      (fun I : TwoSidedIdeal R â†¦ (I : Set R)) :=\n  hasBasis_subbimodule R Ráµáµ’áµ– |>.to_hasBasis\n    (fun I âŸ¨hI, hRI, hRI'âŸ© â†¦ âŸ¨.mk' I (zero_mem _) add_mem neg_mem (hRI _ _) (hRI' _ _),\n      by simpa using hI, by simpâŸ©)\n    (fun I hI â†¦ âŸ¨I.asIdeal.toAddSubgroup,\n      âŸ¨hI, I.mul_mem_left, fun r x hx â†¦ I.mul_mem_right x (r.unop) hxâŸ©, subset_rflâŸ©)\n\n"}
{"name":"IsLinearTopology.hasBasis_open_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœâ´ : Ring R\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : ContinuousAdd R\ninstâœÂ¹ : IsLinearTopology R R\ninstâœ : IsLinearTopology (MulOpposite R) R\nâŠ¢ (nhds 0).HasBasis (fun I => IsOpen â†‘I) fun I => â†‘I","decl":"lemma hasBasis_open_twoSidedIdeal [ContinuousAdd R]\n    [IsLinearTopology R R] [IsLinearTopology Ráµáµ’áµ– R] :\n    (ğ“ (0 : R)).HasBasis\n      (fun I : TwoSidedIdeal R â†¦ IsOpen (I : Set R)) (fun I : TwoSidedIdeal R â†¦ (I : Set R)) :=\n  hasBasis_twoSidedIdeal.congr\n    (fun I â†¦ âŸ¨I.asIdeal.toAddSubgroup.isOpen_of_mem_nhds, fun hI â†¦ hI.mem_nhds (zero_mem I)âŸ©)\n    (fun _ _ â†¦ rfl)\n\n"}
{"name":"isLinearTopology_iff_hasBasis_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : TopologicalSpace R\nâŠ¢ Iff (And (IsLinearTopology R R) (IsLinearTopology (MulOpposite R) R)) ((nhds 0).HasBasis (fun I => Membership.mem (nhds 0) â†‘I) fun I => â†‘I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_twoSidedIdeal :\n    IsLinearTopology R R âˆ§ IsLinearTopology Ráµáµ’áµ– R â†”\n      (ğ“ 0).HasBasis\n        (fun I : TwoSidedIdeal R â†¦ (I : Set R) âˆˆ ğ“ 0) (fun I : TwoSidedIdeal R â†¦ (I : Set R)) :=\n  âŸ¨fun âŸ¨_, _âŸ© â†¦ hasBasis_twoSidedIdeal, fun h â†¦\n    âŸ¨.mk_of_hasBasis' R h fun I r x hx â†¦ I.mul_mem_left r x hx,\n      .mk_of_hasBasis' Ráµáµ’áµ– h fun I r x hx â†¦ I.mul_mem_right x r.unop hxâŸ©âŸ©\n\n"}
{"name":"isLinearTopology_iff_hasBasis_open_twoSidedIdeal","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : Ring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : ContinuousAdd R\nâŠ¢ Iff (And (IsLinearTopology R R) (IsLinearTopology (MulOpposite R) R)) ((nhds 0).HasBasis (fun I => IsOpen â†‘I) fun I => â†‘I)","decl":"theorem _root_.isLinearTopology_iff_hasBasis_open_twoSidedIdeal [ContinuousAdd R] :\n    IsLinearTopology R R âˆ§ IsLinearTopology Ráµáµ’áµ– R â†” (ğ“ 0).HasBasis\n      (fun I : TwoSidedIdeal R â†¦ IsOpen (I : Set R)) (fun I : TwoSidedIdeal R â†¦ (I : Set R)) :=\n  âŸ¨fun âŸ¨_, _âŸ© â†¦ hasBasis_open_twoSidedIdeal, fun h â†¦\n    âŸ¨.mk_of_hasBasis' R h fun I r x hx â†¦ I.mul_mem_left r x hx,\n      .mk_of_hasBasis' Ráµáµ’áµ– h fun I r x hx â†¦ I.mul_mem_right x r.unop hxâŸ©âŸ©\n\n"}
{"name":"IsLinearTopology.tendsto_mul_zero_of_left","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : Ring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : IsLinearTopology (MulOpposite R) R\nÎ¹ : Type u_2\nf : Filter Î¹\na b : Î¹ â†’ R\nha : Filter.Tendsto a f (nhds 0)\nâŠ¢ Filter.Tendsto (HMul.hMul a b) f (nhds 0)","decl":"theorem tendsto_mul_zero_of_left [IsLinearTopology Ráµáµ’áµ– R] {Î¹ : Type*} {f : Filter Î¹}\n    (a b : Î¹ â†’ R) (ha : Tendsto a f (ğ“ 0)) :\n    Tendsto (a * b) f (ğ“ 0) :=\n  tendsto_smul_zero (R := Ráµáµ’áµ–) _ _ ha\n\n"}
{"name":"IsLinearTopology.tendsto_mul_zero_of_right","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : Ring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : IsLinearTopology R R\nÎ¹ : Type u_2\nf : Filter Î¹\na b : Î¹ â†’ R\nhb : Filter.Tendsto b f (nhds 0)\nâŠ¢ Filter.Tendsto (HMul.hMul a b) f (nhds 0)","decl":"theorem tendsto_mul_zero_of_right [IsLinearTopology R R] {Î¹ : Type*} {f : Filter Î¹}\n    (a b : Î¹ â†’ R) (hb : Tendsto b f (ğ“ 0)) :\n    Tendsto (a * b) f (ğ“ 0) :=\n  tendsto_smul_zero (R := R) _ _ hb\n\n"}
{"name":"IsLinearTopology.instMulOpposite","module":"Mathlib.Topology.Algebra.LinearTopology","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : IsLinearTopology R R\nâŠ¢ IsLinearTopology (MulOpposite R) R","decl":"/-- If `R` is commutative and left-linearly topologized, it is also right-linearly topologized. -/\ninstance (priority := 100) [IsLinearTopology R R] :\n    IsLinearTopology Ráµáµ’áµ– R := by\n  rwa [IsCentralScalar.isLinearTopology_iff]\n\n"}
