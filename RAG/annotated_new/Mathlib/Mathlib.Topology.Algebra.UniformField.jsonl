{"name":"CompletableTopField.nice","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : UniformSpace K\nself : CompletableTopField K\nF : Filter K\naâœÂ¹ : Cauchy F\naâœ : Eq (Min.min (nhds 0) F) Bot.bot\nâŠ¢ Cauchy (Filter.map (fun x => Inv.inv x) F)","decl":"/-- A topological field is completable if it is separated and the image under\nthe mapping x â†¦ xâ»Â¹ of every Cauchy filter (with respect to the additive uniform structure)\nwhich does not have a cluster point at 0 is a Cauchy filter\n(with respect to the additive uniform structure). This ensures the completion is\na field.\n-/\nclass CompletableTopField extends T0Space K : Prop where\n  nice : âˆ€ F : Filter K, Cauchy F â†’ ğ“ 0 âŠ“ F = âŠ¥ â†’ Cauchy (map (fun x => xâ»Â¹) F)\n\n"}
{"name":"CompletableTopField.toT0Space","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : UniformSpace K\nself : CompletableTopField K\nâŠ¢ T0Space K","decl":"/-- A topological field is completable if it is separated and the image under\nthe mapping x â†¦ xâ»Â¹ of every Cauchy filter (with respect to the additive uniform structure)\nwhich does not have a cluster point at 0 is a Cauchy filter\n(with respect to the additive uniform structure). This ensures the completion is\na field.\n-/\nclass CompletableTopField extends T0Space K : Prop where\n  nice : âˆ€ F : Filter K, Cauchy F â†’ ğ“ 0 âŠ“ F = âŠ¥ â†’ Cauchy (map (fun x => xâ»Â¹) F)\n\n"}
{"name":"UniformSpace.Completion.instNontrivialOfT0Space","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\ninstâœÂ¹ : UniformSpace K\ninstâœ : T0Space K\nâŠ¢ Nontrivial (UniformSpace.Completion K)","decl":"instance (priority := 100) [T0Space K] : Nontrivial (hat K) :=\n  âŸ¨âŸ¨0, 1, fun h => zero_ne_one <| (isUniformEmbedding_coe K).injective hâŸ©âŸ©\n\n"}
{"name":"UniformSpace.Completion.continuous_hatInv","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\ninstâœÂ¹ : UniformSpace K\ninstâœ : CompletableTopField K\nx : UniformSpace.Completion K\nh : Ne x 0\nâŠ¢ ContinuousAt UniformSpace.Completion.hatInv x","decl":"theorem continuous_hatInv [CompletableTopField K] {x : hat K} (h : x â‰  0) :\n    ContinuousAt hatInv x := by\n  refine isDenseInducing_coe.continuousAt_extend ?_\n  apply mem_of_superset (compl_singleton_mem_nhds h)\n  intro y y_ne\n  rw [mem_compl_singleton_iff] at y_ne\n  apply CompleteSpace.complete\n  have : (fun (x : K) => (â†‘xâ»Â¹ : hat K)) =\n      ((fun (y : K) => (â†‘y : hat K))âˆ˜(fun (x : K) => (xâ»Â¹ : K))) := by\n    unfold Function.comp\n    simp\n  rw [this, â† Filter.map_map]\n  apply Cauchy.map _ (Completion.uniformContinuous_coe K)\n  apply CompletableTopField.nice\n  Â· haveI := isDenseInducing_coe.comap_nhds_neBot y\n    apply cauchy_nhds.comap\n    rw [Completion.comap_coe_eq_uniformity]\n  Â· have eq_bot : ğ“ (0 : hat K) âŠ“ ğ“ y = âŠ¥ := by\n      by_contra h\n      exact y_ne (eq_of_nhds_neBot <| neBot_iff.mpr h).symm\n    erw [isDenseInducing_coe.nhds_eq_comap (0 : K), â† Filter.comap_inf, eq_bot]\n    exact comap_bot\n\n"}
{"name":"UniformSpace.Completion.hatInv_extends","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\ninstâœÂ¹ : UniformSpace K\ninstâœ : TopologicalDivisionRing K\nx : K\nh : Ne x 0\nâŠ¢ Eq (â†‘x).hatInv â†‘(Inv.inv x)","decl":"theorem hatInv_extends {x : K} (h : x â‰  0) : hatInv (x : hat K) = â†‘(xâ»Â¹ : K) :=\n  isDenseInducing_coe.extend_eq_at ((continuous_coe K).continuousAt.comp (continuousAt_invâ‚€ h))\n\n"}
{"name":"UniformSpace.Completion.coe_inv","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœÂ³ : Field K\ninstâœÂ² : UniformSpace K\ninstâœÂ¹ : TopologicalDivisionRing K\ninstâœ : CompletableTopField K\nx : K\nâŠ¢ Eq (Inv.inv â†‘x) â†‘(Inv.inv x)","decl":"@[norm_cast]\ntheorem coe_inv (x : K) : (x : hat K)â»Â¹ = ((xâ»Â¹ : K) : hat K) := by\n  by_cases h : x = 0\n  Â· rw [h, inv_zero]\n    dsimp [Inv.inv]\n    norm_cast\n    simp\n  Â· conv_lhs => dsimp [Inv.inv]\n    rw [if_neg]\n    Â· exact hatInv_extends h\n    Â· exact fun H => h (isDenseEmbedding_coe.injective H)\n\n"}
{"name":"UniformSpace.Completion.mul_hatInv_cancel","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : UniformSpace K\ninstâœÂ² : TopologicalDivisionRing K\ninstâœÂ¹ : CompletableTopField K\ninstâœ : UniformAddGroup K\nx : UniformSpace.Completion K\nx_ne : Ne x 0\nâŠ¢ Eq (HMul.hMul x x.hatInv) 1","decl":"theorem mul_hatInv_cancel {x : hat K} (x_ne : x â‰  0) : x * hatInv x = 1 := by\n  haveI : T1Space (hat K) := T2Space.t1Space\n  let f := fun x : hat K => x * hatInv x\n  let c := (fun (x : K) => (x : hat K))\n  change f x = 1\n  have cont : ContinuousAt f x := by\n    letI : TopologicalSpace (hat K Ã— hat K) := instTopologicalSpaceProd\n    have : ContinuousAt (fun y : hat K => ((y, hatInv y) : hat K Ã— hat K)) x :=\n      continuous_id.continuousAt.prod (continuous_hatInv x_ne)\n    exact (_root_.continuous_mul.continuousAt.comp this :)\n  have clo : x âˆˆ closure (c '' {0}á¶œ) := by\n    have := isDenseInducing_coe.dense x\n    rw [â† image_univ, show (univ : Set K) = {0} âˆª {0}á¶œ from (union_compl_self _).symm,\n      image_union] at this\n    apply mem_closure_of_mem_closure_union this\n    rw [image_singleton]\n    exact compl_singleton_mem_nhds x_ne\n  have fxclo : f x âˆˆ closure (f '' (c '' {0}á¶œ)) := mem_closure_image cont clo\n  have : f '' (c '' {0}á¶œ) âŠ† {1} := by\n    rw [image_image]\n    rintro _ âŸ¨z, z_ne, rflâŸ©\n    rw [mem_singleton_iff]\n    rw [mem_compl_singleton_iff] at z_ne\n    dsimp [f]\n    rw [hatInv_extends z_ne, â† coe_mul]\n    rw [mul_inv_cancelâ‚€ z_ne, coe_one]\n  replace fxclo := closure_mono this fxclo\n  rwa [closure_singleton, mem_singleton_iff] at fxclo\n\n"}
{"name":"UniformSpace.Completion.instTopologicalDivisionRing","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : UniformSpace K\ninstâœÂ² : TopologicalDivisionRing K\ninstâœÂ¹ : CompletableTopField K\ninstâœ : UniformAddGroup K\nâŠ¢ TopologicalDivisionRing (UniformSpace.Completion K)","decl":"instance : TopologicalDivisionRing (hat K) :=\n  { Completion.topologicalRing with\n    continuousAt_invâ‚€ := by\n      intro x x_ne\n      have : { y | hatInv y = yâ»Â¹ } âˆˆ ğ“ x :=\n        haveI : {(0 : hat K)}á¶œ âŠ† { y : hat K | hatInv y = yâ»Â¹ } := by\n          intro y y_ne\n          rw [mem_compl_singleton_iff] at y_ne\n          dsimp [Inv.inv]\n          rw [if_neg y_ne]\n        mem_of_superset (compl_singleton_mem_nhds x_ne) this\n      exact ContinuousAt.congr (continuous_hatInv x_ne) this }\n\n"}
{"name":"Subfield.completableTopField","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"L : Type u_2\ninstâœÂ² : Field L\ninstâœÂ¹ : UniformSpace L\ninstâœ : CompletableTopField L\nK : Subfield L\nâŠ¢ CompletableTopField (Subtype fun x => Membership.mem K x)","decl":"instance Subfield.completableTopField (K : Subfield L) : CompletableTopField K where\n  nice F F_cau inf_F := by\n    let i : K â†’+* L := K.subtype\n    have hi : IsUniformInducing i := isUniformEmbedding_subtype_val.isUniformInducing\n    rw [â† hi.cauchy_map_iff] at F_cau âŠ¢\n    rw [map_comm (show (i âˆ˜ fun x => xâ»Â¹) = (fun x => xâ»Â¹) âˆ˜ i by ext; rfl)]\n    apply CompletableTopField.nice _ F_cau\n    rw [â† Filter.push_pull', â† map_zero i, â† hi.isInducing.nhds_eq_comap, inf_F, Filter.map_bot]\n\n"}
{"name":"completableTopField_of_complete","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"L : Type u_3\ninstâœâ´ : Field L\ninstâœÂ³ : UniformSpace L\ninstâœÂ² : TopologicalDivisionRing L\ninstâœÂ¹ : T0Space L\ninstâœ : CompleteSpace L\nâŠ¢ CompletableTopField L","decl":"instance (priority := 100) completableTopField_of_complete (L : Type*) [Field L] [UniformSpace L]\n    [TopologicalDivisionRing L] [T0Space L] [CompleteSpace L] : CompletableTopField L where\n  nice F cau_F hF := by\n    haveI : NeBot F := cau_F.1\n    rcases CompleteSpace.complete cau_F with âŸ¨x, hxâŸ©\n    have hx' : x â‰  0 := by\n      rintro rfl\n      rw [inf_eq_right.mpr hx] at hF\n      exact cau_F.1.ne hF\n    exact Filter.Tendsto.cauchy_map <|\n      calc\n        map (fun x => xâ»Â¹) F â‰¤ map (fun x => xâ»Â¹) (ğ“ x) := map_mono hx\n        _ â‰¤ ğ“ xâ»Â¹ := continuousAt_invâ‚€ hx'\n\n"}
{"name":"IsUniformInducing.completableTopField","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"Î± : Type u_3\nÎ² : Type u_4\ninstâœâ´ : Field Î²\nb : UniformSpace Î²\ninstâœÂ³ : CompletableTopField Î²\ninstâœÂ² : Field Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : T0Space Î±\nf : RingHom Î± Î²\nhf : IsUniformInducing â‡‘f\nâŠ¢ CompletableTopField Î±","decl":"/-- The pullback of a completable topological field along a uniform inducing\nring homomorphism is a completable topological field. -/\ntheorem IsUniformInducing.completableTopField\n    [UniformSpace Î±] [T0Space Î±]\n    {f : Î± â†’+* Î²} (hf : IsUniformInducing f) :\n    CompletableTopField Î± := by\n  refine CompletableTopField.mk (fun F F_cau inf_F => ?_)\n  rw [â† IsUniformInducing.cauchy_map_iff hf] at F_cau âŠ¢\n  have h_comm : (f âˆ˜ fun x => xâ»Â¹) = (fun x => xâ»Â¹) âˆ˜ f := by\n    ext; simp only [Function.comp_apply, map_invâ‚€, Subfield.coe_inv]\n  rw [Filter.map_comm h_comm]\n  apply CompletableTopField.nice _ F_cau\n  rw [â† Filter.push_pull', â† map_zero f, â† hf.isInducing.nhds_eq_comap, inf_F, Filter.map_bot]\n"}
