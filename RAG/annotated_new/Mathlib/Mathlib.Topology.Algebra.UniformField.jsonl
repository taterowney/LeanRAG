{"name":"CompletableTopField.nice","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : UniformSpace K\nself : CompletableTopField K\nF : Filter K\na✝¹ : Cauchy F\na✝ : Eq (Min.min (nhds 0) F) Bot.bot\n⊢ Cauchy (Filter.map (fun x => Inv.inv x) F)","decl":"/-- A topological field is completable if it is separated and the image under\nthe mapping x ↦ x⁻¹ of every Cauchy filter (with respect to the additive uniform structure)\nwhich does not have a cluster point at 0 is a Cauchy filter\n(with respect to the additive uniform structure). This ensures the completion is\na field.\n-/\nclass CompletableTopField extends T0Space K : Prop where\n  nice : ∀ F : Filter K, Cauchy F → 𝓝 0 ⊓ F = ⊥ → Cauchy (map (fun x => x⁻¹) F)\n\n"}
{"name":"CompletableTopField.toT0Space","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : UniformSpace K\nself : CompletableTopField K\n⊢ T0Space K","decl":"/-- A topological field is completable if it is separated and the image under\nthe mapping x ↦ x⁻¹ of every Cauchy filter (with respect to the additive uniform structure)\nwhich does not have a cluster point at 0 is a Cauchy filter\n(with respect to the additive uniform structure). This ensures the completion is\na field.\n-/\nclass CompletableTopField extends T0Space K : Prop where\n  nice : ∀ F : Filter K, Cauchy F → 𝓝 0 ⊓ F = ⊥ → Cauchy (map (fun x => x⁻¹) F)\n\n"}
{"name":"UniformSpace.Completion.instNontrivialOfT0Space","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : UniformSpace K\ninst✝ : T0Space K\n⊢ Nontrivial (UniformSpace.Completion K)","decl":"instance (priority := 100) [T0Space K] : Nontrivial (hat K) :=\n  ⟨⟨0, 1, fun h => zero_ne_one <| (isUniformEmbedding_coe K).injective h⟩⟩\n\n"}
{"name":"UniformSpace.Completion.continuous_hatInv","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : UniformSpace K\ninst✝ : CompletableTopField K\nx : UniformSpace.Completion K\nh : Ne x 0\n⊢ ContinuousAt UniformSpace.Completion.hatInv x","decl":"theorem continuous_hatInv [CompletableTopField K] {x : hat K} (h : x ≠ 0) :\n    ContinuousAt hatInv x := by\n  refine isDenseInducing_coe.continuousAt_extend ?_\n  apply mem_of_superset (compl_singleton_mem_nhds h)\n  intro y y_ne\n  rw [mem_compl_singleton_iff] at y_ne\n  apply CompleteSpace.complete\n  have : (fun (x : K) => (↑x⁻¹ : hat K)) =\n      ((fun (y : K) => (↑y : hat K))∘(fun (x : K) => (x⁻¹ : K))) := by\n    unfold Function.comp\n    simp\n  rw [this, ← Filter.map_map]\n  apply Cauchy.map _ (Completion.uniformContinuous_coe K)\n  apply CompletableTopField.nice\n  · haveI := isDenseInducing_coe.comap_nhds_neBot y\n    apply cauchy_nhds.comap\n    rw [Completion.comap_coe_eq_uniformity]\n  · have eq_bot : 𝓝 (0 : hat K) ⊓ 𝓝 y = ⊥ := by\n      by_contra h\n      exact y_ne (eq_of_nhds_neBot <| neBot_iff.mpr h).symm\n    erw [isDenseInducing_coe.nhds_eq_comap (0 : K), ← Filter.comap_inf, eq_bot]\n    exact comap_bot\n\n"}
{"name":"UniformSpace.Completion.hatInv_extends","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : UniformSpace K\ninst✝ : TopologicalDivisionRing K\nx : K\nh : Ne x 0\n⊢ Eq (↑x).hatInv ↑(Inv.inv x)","decl":"theorem hatInv_extends {x : K} (h : x ≠ 0) : hatInv (x : hat K) = ↑(x⁻¹ : K) :=\n  isDenseInducing_coe.extend_eq_at ((continuous_coe K).continuousAt.comp (continuousAt_inv₀ h))\n\n"}
{"name":"UniformSpace.Completion.coe_inv","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝³ : Field K\ninst✝² : UniformSpace K\ninst✝¹ : TopologicalDivisionRing K\ninst✝ : CompletableTopField K\nx : K\n⊢ Eq (Inv.inv ↑x) ↑(Inv.inv x)","decl":"@[norm_cast]\ntheorem coe_inv (x : K) : (x : hat K)⁻¹ = ((x⁻¹ : K) : hat K) := by\n  by_cases h : x = 0\n  · rw [h, inv_zero]\n    dsimp [Inv.inv]\n    norm_cast\n    simp\n  · conv_lhs => dsimp [Inv.inv]\n    rw [if_neg]\n    · exact hatInv_extends h\n    · exact fun H => h (isDenseEmbedding_coe.injective H)\n\n"}
{"name":"UniformSpace.Completion.mul_hatInv_cancel","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : UniformSpace K\ninst✝² : TopologicalDivisionRing K\ninst✝¹ : CompletableTopField K\ninst✝ : UniformAddGroup K\nx : UniformSpace.Completion K\nx_ne : Ne x 0\n⊢ Eq (HMul.hMul x x.hatInv) 1","decl":"theorem mul_hatInv_cancel {x : hat K} (x_ne : x ≠ 0) : x * hatInv x = 1 := by\n  haveI : T1Space (hat K) := T2Space.t1Space\n  let f := fun x : hat K => x * hatInv x\n  let c := (fun (x : K) => (x : hat K))\n  change f x = 1\n  have cont : ContinuousAt f x := by\n    letI : TopologicalSpace (hat K × hat K) := instTopologicalSpaceProd\n    have : ContinuousAt (fun y : hat K => ((y, hatInv y) : hat K × hat K)) x :=\n      continuous_id.continuousAt.prod (continuous_hatInv x_ne)\n    exact (_root_.continuous_mul.continuousAt.comp this :)\n  have clo : x ∈ closure (c '' {0}ᶜ) := by\n    have := isDenseInducing_coe.dense x\n    rw [← image_univ, show (univ : Set K) = {0} ∪ {0}ᶜ from (union_compl_self _).symm,\n      image_union] at this\n    apply mem_closure_of_mem_closure_union this\n    rw [image_singleton]\n    exact compl_singleton_mem_nhds x_ne\n  have fxclo : f x ∈ closure (f '' (c '' {0}ᶜ)) := mem_closure_image cont clo\n  have : f '' (c '' {0}ᶜ) ⊆ {1} := by\n    rw [image_image]\n    rintro _ ⟨z, z_ne, rfl⟩\n    rw [mem_singleton_iff]\n    rw [mem_compl_singleton_iff] at z_ne\n    dsimp [f]\n    rw [hatInv_extends z_ne, ← coe_mul]\n    rw [mul_inv_cancel₀ z_ne, coe_one]\n  replace fxclo := closure_mono this fxclo\n  rwa [closure_singleton, mem_singleton_iff] at fxclo\n\n"}
{"name":"UniformSpace.Completion.instTopologicalDivisionRing","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : UniformSpace K\ninst✝² : TopologicalDivisionRing K\ninst✝¹ : CompletableTopField K\ninst✝ : UniformAddGroup K\n⊢ TopologicalDivisionRing (UniformSpace.Completion K)","decl":"instance : TopologicalDivisionRing (hat K) :=\n  { Completion.topologicalRing with\n    continuousAt_inv₀ := by\n      intro x x_ne\n      have : { y | hatInv y = y⁻¹ } ∈ 𝓝 x :=\n        haveI : {(0 : hat K)}ᶜ ⊆ { y : hat K | hatInv y = y⁻¹ } := by\n          intro y y_ne\n          rw [mem_compl_singleton_iff] at y_ne\n          dsimp [Inv.inv]\n          rw [if_neg y_ne]\n        mem_of_superset (compl_singleton_mem_nhds x_ne) this\n      exact ContinuousAt.congr (continuous_hatInv x_ne) this }\n\n"}
{"name":"Subfield.completableTopField","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"L : Type u_2\ninst✝² : Field L\ninst✝¹ : UniformSpace L\ninst✝ : CompletableTopField L\nK : Subfield L\n⊢ CompletableTopField (Subtype fun x => Membership.mem K x)","decl":"instance Subfield.completableTopField (K : Subfield L) : CompletableTopField K where\n  nice F F_cau inf_F := by\n    let i : K →+* L := K.subtype\n    have hi : IsUniformInducing i := isUniformEmbedding_subtype_val.isUniformInducing\n    rw [← hi.cauchy_map_iff] at F_cau ⊢\n    rw [map_comm (show (i ∘ fun x => x⁻¹) = (fun x => x⁻¹) ∘ i by ext; rfl)]\n    apply CompletableTopField.nice _ F_cau\n    rw [← Filter.push_pull', ← map_zero i, ← hi.isInducing.nhds_eq_comap, inf_F, Filter.map_bot]\n\n"}
{"name":"completableTopField_of_complete","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"L : Type u_3\ninst✝⁴ : Field L\ninst✝³ : UniformSpace L\ninst✝² : TopologicalDivisionRing L\ninst✝¹ : T0Space L\ninst✝ : CompleteSpace L\n⊢ CompletableTopField L","decl":"instance (priority := 100) completableTopField_of_complete (L : Type*) [Field L] [UniformSpace L]\n    [TopologicalDivisionRing L] [T0Space L] [CompleteSpace L] : CompletableTopField L where\n  nice F cau_F hF := by\n    haveI : NeBot F := cau_F.1\n    rcases CompleteSpace.complete cau_F with ⟨x, hx⟩\n    have hx' : x ≠ 0 := by\n      rintro rfl\n      rw [inf_eq_right.mpr hx] at hF\n      exact cau_F.1.ne hF\n    exact Filter.Tendsto.cauchy_map <|\n      calc\n        map (fun x => x⁻¹) F ≤ map (fun x => x⁻¹) (𝓝 x) := map_mono hx\n        _ ≤ 𝓝 x⁻¹ := continuousAt_inv₀ hx'\n\n"}
{"name":"IsUniformInducing.completableTopField","module":"Mathlib.Topology.Algebra.UniformField","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝⁴ : Field β\nb : UniformSpace β\ninst✝³ : CompletableTopField β\ninst✝² : Field α\ninst✝¹ : UniformSpace α\ninst✝ : T0Space α\nf : RingHom α β\nhf : IsUniformInducing ⇑f\n⊢ CompletableTopField α","decl":"/-- The pullback of a completable topological field along a uniform inducing\nring homomorphism is a completable topological field. -/\ntheorem IsUniformInducing.completableTopField\n    [UniformSpace α] [T0Space α]\n    {f : α →+* β} (hf : IsUniformInducing f) :\n    CompletableTopField α := by\n  refine CompletableTopField.mk (fun F F_cau inf_F => ?_)\n  rw [← IsUniformInducing.cauchy_map_iff hf] at F_cau ⊢\n  have h_comm : (f ∘ fun x => x⁻¹) = (fun x => x⁻¹) ∘ f := by\n    ext; simp only [Function.comp_apply, map_inv₀, Subfield.coe_inv]\n  rw [Filter.map_comm h_comm]\n  apply CompletableTopField.nice _ F_cau\n  rw [← Filter.push_pull', ← map_zero f, ← hf.isInducing.nhds_eq_comap, inf_F, Filter.map_bot]\n"}
