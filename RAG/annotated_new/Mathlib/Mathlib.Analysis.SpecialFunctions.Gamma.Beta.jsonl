{"name":"Complex.betaIntegral_convergent_left","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\nv : Complex\n⊢ IntervalIntegrable (fun x => HMul.hMul (HPow.hPow (↑x) (HSub.hSub u 1)) (HPow.hPow (HSub.hSub 1 ↑x) (HSub.hSub v 1))) MeasureTheory.MeasureSpace.volume 0 (1 / 2)","decl":"/-- Auxiliary lemma for `betaIntegral_convergent`, showing convergence at the left endpoint. -/\ntheorem betaIntegral_convergent_left {u : ℂ} (hu : 0 < re u) (v : ℂ) :\n    IntervalIntegrable (fun x =>\n      (x : ℂ) ^ (u - 1) * (1 - (x : ℂ)) ^ (v - 1) : ℝ → ℂ) volume 0 (1 / 2) := by\n  apply IntervalIntegrable.mul_continuousOn\n  · refine intervalIntegral.intervalIntegrable_cpow' ?_\n    rwa [sub_re, one_re, ← zero_sub, sub_lt_sub_iff_right]\n  · apply continuousOn_of_forall_continuousAt\n    intro x hx\n    rw [uIcc_of_le (by positivity : (0 : ℝ) ≤ 1 / 2)] at hx\n    apply ContinuousAt.cpow\n    · exact (continuous_const.sub continuous_ofReal).continuousAt\n    · exact continuousAt_const\n    · norm_cast\n      exact ofReal_mem_slitPlane.2 <| by linarith only [hx.2]\n\n"}
{"name":"Complex.betaIntegral_convergent","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\nhu : LT.lt 0 u.re\nhv : LT.lt 0 v.re\n⊢ IntervalIntegrable (fun x => HMul.hMul (HPow.hPow (↑x) (HSub.hSub u 1)) (HPow.hPow (HSub.hSub 1 ↑x) (HSub.hSub v 1))) MeasureTheory.MeasureSpace.volume 0 1","decl":"/-- The Beta integral is convergent for all `u, v` of positive real part. -/\ntheorem betaIntegral_convergent {u v : ℂ} (hu : 0 < re u) (hv : 0 < re v) :\n    IntervalIntegrable (fun x =>\n      (x : ℂ) ^ (u - 1) * (1 - (x : ℂ)) ^ (v - 1) : ℝ → ℂ) volume 0 1 := by\n  refine (betaIntegral_convergent_left hu v).trans ?_\n  rw [IntervalIntegrable.iff_comp_neg]\n  convert ((betaIntegral_convergent_left hv u).comp_add_right 1).symm using 1\n  · ext1 x\n    conv_lhs => rw [mul_comm]\n    congr 2 <;> · push_cast; ring\n  · norm_num\n  · norm_num\n\n"}
{"name":"Complex.betaIntegral_symm","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\n⊢ Eq (v.betaIntegral u) (u.betaIntegral v)","decl":"theorem betaIntegral_symm (u v : ℂ) : betaIntegral v u = betaIntegral u v := by\n  rw [betaIntegral, betaIntegral]\n  have := intervalIntegral.integral_comp_mul_add (a := 0) (b := 1) (c := -1)\n    (fun x : ℝ => (x : ℂ) ^ (u - 1) * (1 - (x : ℂ)) ^ (v - 1)) neg_one_lt_zero.ne 1\n  rw [inv_neg, inv_one, neg_one_smul, ← intervalIntegral.integral_symm] at this\n  simp? at this says\n    simp only [neg_mul, one_mul, ofReal_add, ofReal_neg, ofReal_one, sub_add_cancel_right, neg_neg,\n      mul_one, neg_add_cancel, mul_zero, zero_add] at this\n  conv_lhs at this => arg 1; intro x; rw [add_comm, ← sub_eq_add_neg, mul_comm]\n  exact this\n\n"}
{"name":"Complex.betaIntegral_eval_one_right","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\n⊢ Eq (u.betaIntegral 1) (HDiv.hDiv 1 u)","decl":"theorem betaIntegral_eval_one_right {u : ℂ} (hu : 0 < re u) : betaIntegral u 1 = 1 / u := by\n  simp_rw [betaIntegral, sub_self, cpow_zero, mul_one]\n  rw [integral_cpow (Or.inl _)]\n  · rw [ofReal_zero, ofReal_one, one_cpow, zero_cpow, sub_zero, sub_add_cancel]\n    rw [sub_add_cancel]\n    contrapose! hu; rw [hu, zero_re]\n  · rwa [sub_re, one_re, ← sub_pos, sub_neg_eq_add, sub_add_cancel]\n\n"}
{"name":"Complex.betaIntegral_scaled","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s t : Complex\na : Real\nha : LT.lt 0 a\n⊢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (↑x) (HSub.hSub s 1)) (HPow.hPow (HSub.hSub ↑a ↑x) (HSub.hSub t 1))) 0 a MeasureTheory.MeasureSpace.volume) (HMul.hMul (HPow.hPow (↑a) (HSub.hSub (HAdd.hAdd s t) 1)) (s.betaIntegral t))","decl":"theorem betaIntegral_scaled (s t : ℂ) {a : ℝ} (ha : 0 < a) :\n    ∫ x in (0)..a, (x : ℂ) ^ (s - 1) * ((a : ℂ) - x) ^ (t - 1) =\n    (a : ℂ) ^ (s + t - 1) * betaIntegral s t := by\n  have ha' : (a : ℂ) ≠ 0 := ofReal_ne_zero.mpr ha.ne'\n  rw [betaIntegral]\n  have A : (a : ℂ) ^ (s + t - 1) = a * ((a : ℂ) ^ (s - 1) * (a : ℂ) ^ (t - 1)) := by\n    rw [(by abel : s + t - 1 = 1 + (s - 1) + (t - 1)), cpow_add _ _ ha', cpow_add 1 _ ha', cpow_one,\n      mul_assoc]\n  rw [A, mul_assoc, ← intervalIntegral.integral_const_mul, ← real_smul, ← zero_div a, ←\n    div_self ha.ne', ← intervalIntegral.integral_comp_div _ ha.ne', zero_div]\n  simp_rw [intervalIntegral.integral_of_le ha.le]\n  refine setIntegral_congr_fun measurableSet_Ioc fun x hx => ?_\n  rw [mul_mul_mul_comm]\n  congr 1\n  · rw [← mul_cpow_ofReal_nonneg ha.le (div_pos hx.1 ha).le, ofReal_div, mul_div_cancel₀ _ ha']\n  · rw [(by norm_cast : (1 : ℂ) - ↑(x / a) = ↑(1 - x / a)), ←\n      mul_cpow_ofReal_nonneg ha.le (sub_nonneg.mpr <| (div_le_one ha).mpr hx.2)]\n    push_cast\n    rw [mul_sub, mul_one, mul_div_cancel₀ _ ha']\n\n"}
{"name":"Complex.Gamma_mul_Gamma_eq_betaIntegral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s t : Complex\nhs : LT.lt 0 s.re\nht : LT.lt 0 t.re\n⊢ Eq (HMul.hMul (Complex.Gamma s) (Complex.Gamma t)) (HMul.hMul (Complex.Gamma (HAdd.hAdd s t)) (s.betaIntegral t))","decl":"/-- Relation between Beta integral and Gamma function. -/\ntheorem Gamma_mul_Gamma_eq_betaIntegral {s t : ℂ} (hs : 0 < re s) (ht : 0 < re t) :\n    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t := by\n  -- Note that we haven't proved (yet) that the Gamma function has no zeroes, so we can't formulate\n  -- this as a formula for the Beta function.\n  have conv_int := integral_posConvolution\n    (GammaIntegral_convergent hs) (GammaIntegral_convergent ht) (ContinuousLinearMap.mul ℝ ℂ)\n  simp_rw [ContinuousLinearMap.mul_apply'] at conv_int\n  have hst : 0 < re (s + t) := by rw [add_re]; exact add_pos hs ht\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst, GammaIntegral,\n    GammaIntegral, GammaIntegral, ← conv_int, ← integral_mul_right (betaIntegral _ _)]\n  refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n  rw [mul_assoc, ← betaIntegral_scaled s t hx, ← intervalIntegral.integral_const_mul]\n  congr 1 with y : 1\n  push_cast\n  suffices Complex.exp (-x) = Complex.exp (-y) * Complex.exp (-(x - y)) by rw [this]; ring\n  rw [← Complex.exp_add]; congr 1; abel\n\n"}
{"name":"Complex.betaIntegral_recurrence","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\nhu : LT.lt 0 u.re\nhv : LT.lt 0 v.re\n⊢ Eq (HMul.hMul u (u.betaIntegral (HAdd.hAdd v 1))) (HMul.hMul v ((HAdd.hAdd u 1).betaIntegral v))","decl":"/-- Recurrence formula for the Beta function. -/\ntheorem betaIntegral_recurrence {u v : ℂ} (hu : 0 < re u) (hv : 0 < re v) :\n    u * betaIntegral u (v + 1) = v * betaIntegral (u + 1) v := by\n  -- NB: If we knew `Gamma (u + v + 1) ≠ 0` this would be an easy consequence of\n  -- `Gamma_mul_Gamma_eq_betaIntegral`; but we don't know that yet. We will prove it later, but\n  -- this lemma is needed in the proof. So we give a (somewhat laborious) direct argument.\n  let F : ℝ → ℂ := fun x => (x : ℂ) ^ u * (1 - (x : ℂ)) ^ v\n  have hu' : 0 < re (u + 1) := by rw [add_re, one_re]; positivity\n  have hv' : 0 < re (v + 1) := by rw [add_re, one_re]; positivity\n  have hc : ContinuousOn F (Icc 0 1) := by\n    refine (continuousOn_of_forall_continuousAt fun x hx => ?_).mul\n        (continuousOn_of_forall_continuousAt fun x hx => ?_)\n    · refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hu).comp continuous_ofReal.continuousAt\n      rw [ofReal_re]; exact hx.1\n    · refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hv).comp\n        (continuous_const.sub continuous_ofReal).continuousAt\n      rw [sub_re, one_re, ofReal_re, sub_nonneg]\n      exact hx.2\n  have hder : ∀ x : ℝ, x ∈ Ioo (0 : ℝ) 1 →\n      HasDerivAt F (u * ((x : ℂ) ^ (u - 1) * (1 - (x : ℂ)) ^ v) -\n        v * ((x : ℂ) ^ u * (1 - (x : ℂ)) ^ (v - 1))) x := by\n    intro x hx\n    have U : HasDerivAt (fun y : ℂ => y ^ u) (u * (x : ℂ) ^ (u - 1)) ↑x := by\n      have := @HasDerivAt.cpow_const _ _ _ u (hasDerivAt_id (x : ℂ)) (Or.inl ?_)\n      · simp only [id_eq, mul_one] at this\n        exact this\n      · rw [id_eq, ofReal_re]; exact hx.1\n    have V : HasDerivAt (fun y : ℂ => (1 - y) ^ v) (-v * (1 - (x : ℂ)) ^ (v - 1)) ↑x := by\n      have A := @HasDerivAt.cpow_const _ _ _ v (hasDerivAt_id (1 - (x : ℂ))) (Or.inl ?_)\n      swap; · rw [id, sub_re, one_re, ofReal_re, sub_pos]; exact hx.2\n      simp_rw [id] at A\n      have B : HasDerivAt (fun y : ℂ => 1 - y) (-1) ↑x := by\n        apply HasDerivAt.const_sub; apply hasDerivAt_id\n      convert HasDerivAt.comp (↑x) A B using 1\n      ring\n    convert (U.mul V).comp_ofReal using 1\n    ring\n  have h_int := ((betaIntegral_convergent hu hv').const_mul u).sub\n    ((betaIntegral_convergent hu' hv).const_mul v)\n  rw [add_sub_cancel_right, add_sub_cancel_right] at h_int\n  have int_ev := intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le zero_le_one hc hder h_int\n  have hF0 : F 0 = 0 := by\n    simp only [F, mul_eq_zero, ofReal_zero, cpow_eq_zero_iff, eq_self_iff_true, Ne,\n      true_and, sub_zero, one_cpow, one_ne_zero, or_false]\n    contrapose! hu; rw [hu, zero_re]\n  have hF1 : F 1 = 0 := by\n    simp only [F, mul_eq_zero, ofReal_one, one_cpow, one_ne_zero, sub_self, cpow_eq_zero_iff,\n      eq_self_iff_true, Ne, true_and, false_or]\n    contrapose! hv; rw [hv, zero_re]\n  rw [hF0, hF1, sub_zero, intervalIntegral.integral_sub, intervalIntegral.integral_const_mul,\n    intervalIntegral.integral_const_mul] at int_ev\n  · rw [betaIntegral, betaIntegral, ← sub_eq_zero]\n    convert int_ev <;> ring\n  · apply IntervalIntegrable.const_mul\n    convert betaIntegral_convergent hu hv'; ring\n  · apply IntervalIntegrable.const_mul\n    convert betaIntegral_convergent hu' hv; ring\n\n"}
{"name":"Complex.betaIntegral_eval_nat_add_one_right","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\nn : Nat\n⊢ Eq (u.betaIntegral (HAdd.hAdd (↑n) 1)) (HDiv.hDiv (↑n.factorial) ((Finset.range (HAdd.hAdd n 1)).prod fun j => HAdd.hAdd u ↑j))","decl":"/-- Explicit formula for the Beta function when second argument is a positive integer. -/\ntheorem betaIntegral_eval_nat_add_one_right {u : ℂ} (hu : 0 < re u) (n : ℕ) :\n    betaIntegral u (n + 1) = n ! / ∏ j ∈ Finset.range (n + 1), (u + j) := by\n  induction' n with n IH generalizing u\n  · rw [Nat.cast_zero, zero_add, betaIntegral_eval_one_right hu, Nat.factorial_zero, Nat.cast_one]\n    simp\n  · have := betaIntegral_recurrence hu (?_ : 0 < re n.succ)\n    swap; · rw [← ofReal_natCast, ofReal_re]; positivity\n    rw [mul_comm u _, ← eq_div_iff] at this\n    swap; · contrapose! hu; rw [hu, zero_re]\n    rw [this, Finset.prod_range_succ', Nat.cast_succ, IH]\n    swap; · rw [add_re, one_re]; positivity\n    rw [Nat.factorial_succ, Nat.cast_mul, Nat.cast_add, Nat.cast_one, Nat.cast_zero, add_zero, ←\n      mul_div_assoc, ← div_div]\n    congr 3 with j : 1\n    push_cast; abel\n\n"}
{"name":"Complex.GammaSeq_eq_betaIntegral_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\nn : Nat\n⊢ Eq (s.GammaSeq n) (HMul.hMul (HPow.hPow (↑n) s) (s.betaIntegral (HAdd.hAdd (↑n) 1)))","decl":"theorem GammaSeq_eq_betaIntegral_of_re_pos {s : ℂ} (hs : 0 < re s) (n : ℕ) :\n    GammaSeq s n = (n : ℂ) ^ s * betaIntegral s (n + 1) := by\n  rw [GammaSeq, betaIntegral_eval_nat_add_one_right hs n, ← mul_div_assoc]\n\n"}
{"name":"Complex.GammaSeq_add_one_left","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nn : Nat\nhn : Ne n 0\n⊢ Eq (HDiv.hDiv ((HAdd.hAdd s 1).GammaSeq n) s) (HMul.hMul (HDiv.hDiv (↑n) (HAdd.hAdd (HAdd.hAdd (↑n) 1) s)) (s.GammaSeq n))","decl":"theorem GammaSeq_add_one_left (s : ℂ) {n : ℕ} (hn : n ≠ 0) :\n    GammaSeq (s + 1) n / s = n / (n + 1 + s) * GammaSeq s n := by\n  conv_lhs => rw [GammaSeq, Finset.prod_range_succ, div_div]\n  conv_rhs =>\n    rw [GammaSeq, Finset.prod_range_succ', Nat.cast_zero, add_zero, div_mul_div_comm, ← mul_assoc,\n      ← mul_assoc, mul_comm _ (Finset.prod _ _)]\n  congr 3\n  · rw [cpow_add _ _ (Nat.cast_ne_zero.mpr hn), cpow_one, mul_comm]\n  · refine Finset.prod_congr (by rfl) fun x _ => ?_\n    push_cast; ring\n  · abel\n\n"}
{"name":"Complex.GammaSeq_eq_approx_Gamma_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\nn : Nat\nhn : Ne n 0\n⊢ Eq (s.GammaSeq n) (intervalIntegral (fun x => HMul.hMul (↑(HPow.hPow (HSub.hSub 1 (HDiv.hDiv x ↑n)) n)) (HPow.hPow (↑x) (HSub.hSub s 1))) 0 (↑n) MeasureTheory.MeasureSpace.volume)","decl":"theorem GammaSeq_eq_approx_Gamma_integral {s : ℂ} (hs : 0 < re s) {n : ℕ} (hn : n ≠ 0) :\n    GammaSeq s n = ∫ x : ℝ in (0)..n, ↑((1 - x / n) ^ n) * (x : ℂ) ^ (s - 1) := by\n  have : ∀ x : ℝ, x = x / n * n := by intro x; rw [div_mul_cancel₀]; exact Nat.cast_ne_zero.mpr hn\n  conv_rhs => enter [1, x, 2, 1]; rw [this x]\n  rw [GammaSeq_eq_betaIntegral_of_re_pos hs]\n  have := intervalIntegral.integral_comp_div (a := 0) (b := n)\n    (fun x => ↑((1 - x) ^ n) * ↑(x * ↑n) ^ (s - 1) : ℝ → ℂ) (Nat.cast_ne_zero.mpr hn)\n  dsimp only at this\n  rw [betaIntegral, this, real_smul, zero_div, div_self, add_sub_cancel_right,\n    ← intervalIntegral.integral_const_mul, ← intervalIntegral.integral_const_mul]\n  swap; · exact Nat.cast_ne_zero.mpr hn\n  simp_rw [intervalIntegral.integral_of_le zero_le_one]\n  refine setIntegral_congr_fun measurableSet_Ioc fun x hx => ?_\n  push_cast\n  have hn' : (n : ℂ) ≠ 0 := Nat.cast_ne_zero.mpr hn\n  have A : (n : ℂ) ^ s = (n : ℂ) ^ (s - 1) * n := by\n    conv_lhs => rw [(by ring : s = s - 1 + 1), cpow_add _ _ hn']\n    simp\n  have B : ((x : ℂ) * ↑n) ^ (s - 1) = (x : ℂ) ^ (s - 1) * (n : ℂ) ^ (s - 1) := by\n    rw [← ofReal_natCast,\n      mul_cpow_ofReal_nonneg hx.1.le (Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)).le]\n  rw [A, B, cpow_natCast]; ring\n\n"}
{"name":"Complex.approx_Gamma_integral_tendsto_Gamma_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n⊢ Filter.Tendsto (fun n => intervalIntegral (fun x => HMul.hMul (↑(HPow.hPow (HSub.hSub 1 (HDiv.hDiv x ↑n)) n)) (HPow.hPow (↑x) (HSub.hSub s 1))) 0 (↑n) MeasureTheory.MeasureSpace.volume) Filter.atTop (nhds (Complex.Gamma s))","decl":"/-- The main technical lemma for `GammaSeq_tendsto_Gamma`, expressing the integral defining the\nGamma function for `0 < re s` as the limit of a sequence of integrals over finite intervals. -/\ntheorem approx_Gamma_integral_tendsto_Gamma_integral {s : ℂ} (hs : 0 < re s) :\n    Tendsto (fun n : ℕ => ∫ x : ℝ in (0)..n, ((1 - x / n) ^ n : ℝ) * (x : ℂ) ^ (s - 1)) atTop\n      (𝓝 <| Gamma s) := by\n  rw [Gamma_eq_integral hs]\n  -- We apply dominated convergence to the following function, which we will show is uniformly\n  -- bounded above by the Gamma integrand `exp (-x) * x ^ (re s - 1)`.\n  let f : ℕ → ℝ → ℂ := fun n =>\n    indicator (Ioc 0 (n : ℝ)) fun x : ℝ => ((1 - x / n) ^ n : ℝ) * (x : ℂ) ^ (s - 1)\n  -- integrability of f\n  have f_ible : ∀ n : ℕ, Integrable (f n) (volume.restrict (Ioi 0)) := by\n    intro n\n    rw [integrable_indicator_iff (measurableSet_Ioc : MeasurableSet (Ioc (_ : ℝ) _)), IntegrableOn,\n      Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self, ← IntegrableOn, ←\n      intervalIntegrable_iff_integrableOn_Ioc_of_le (by positivity : (0 : ℝ) ≤ n)]\n    apply IntervalIntegrable.continuousOn_mul\n    · refine intervalIntegral.intervalIntegrable_cpow' ?_\n      rwa [sub_re, one_re, ← zero_sub, sub_lt_sub_iff_right]\n    · apply Continuous.continuousOn\n      exact RCLike.continuous_ofReal.comp -- Porting note: was `continuity`\n        ((continuous_const.sub (continuous_id'.div_const (n : ℝ))).pow n)\n  -- pointwise limit of f\n  have f_tends : ∀ x : ℝ, x ∈ Ioi (0 : ℝ) →\n      Tendsto (fun n : ℕ => f n x) atTop (𝓝 <| ↑(Real.exp (-x)) * (x : ℂ) ^ (s - 1)) := by\n    intro x hx\n    apply Tendsto.congr'\n    · show ∀ᶠ n : ℕ in atTop, ↑((1 - x / n) ^ n) * (x : ℂ) ^ (s - 1) = f n x\n      filter_upwards [eventually_ge_atTop ⌈x⌉₊] with n hn\n      rw [Nat.ceil_le] at hn\n      dsimp only [f]\n      rw [indicator_of_mem]\n      exact ⟨hx, hn⟩\n    · simp_rw [mul_comm]\n      refine (Tendsto.comp (continuous_ofReal.tendsto _) ?_).const_mul _\n      convert tendsto_one_plus_div_pow_exp (-x) using 1\n      ext1 n\n      rw [neg_div, ← sub_eq_add_neg]\n  -- let `convert` identify the remaining goals\n  convert tendsto_integral_of_dominated_convergence _ (fun n => (f_ible n).1)\n    (Real.GammaIntegral_convergent hs) _\n    ((ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ f_tends)) using 1\n  -- limit of f is the integrand we want\n  · ext1 n\n    rw [MeasureTheory.integral_indicator (measurableSet_Ioc : MeasurableSet (Ioc (_ : ℝ) _)),\n      intervalIntegral.integral_of_le (by positivity : 0 ≤ (n : ℝ)),\n      Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]\n  -- f is uniformly bounded by the Gamma integrand\n  · intro n\n    rw [ae_restrict_iff' measurableSet_Ioi]\n    filter_upwards with x hx\n    dsimp only [f]\n    rcases lt_or_le (n : ℝ) x with (hxn | hxn)\n    · rw [indicator_of_not_mem (not_mem_Ioc_of_gt hxn), norm_zero,\n        mul_nonneg_iff_right_nonneg_of_pos (exp_pos _)]\n      exact rpow_nonneg (le_of_lt hx) _\n    · rw [indicator_of_mem (mem_Ioc.mpr ⟨mem_Ioi.mp hx, hxn⟩), norm_mul, Complex.norm_eq_abs,\n        Complex.abs_of_nonneg\n          (pow_nonneg (sub_nonneg.mpr <| div_le_one_of_le₀ hxn <| by positivity) _),\n        Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re,\n        mul_le_mul_right (rpow_pos_of_pos hx _)]\n      exact one_sub_div_pow_le_exp_neg hxn\n\n"}
{"name":"Complex.GammaSeq_tendsto_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n⊢ Filter.Tendsto s.GammaSeq Filter.atTop (nhds (Complex.Gamma s))","decl":"/-- Euler's limit formula for the complex Gamma function. -/\ntheorem GammaSeq_tendsto_Gamma (s : ℂ) : Tendsto (GammaSeq s) atTop (𝓝 <| Gamma s) := by\n  suffices ∀ m : ℕ, -↑m < re s → Tendsto (GammaSeq s) atTop (𝓝 <| GammaAux m s) by\n    rw [Gamma]\n    apply this\n    rw [neg_lt]\n    rcases lt_or_le 0 (re s) with (hs | hs)\n    · exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)\n    · refine (Nat.lt_floor_add_one _).trans_le ?_\n      rw [sub_eq_neg_add, Nat.floor_add_one (neg_nonneg.mpr hs), Nat.cast_add_one]\n  intro m\n  induction' m with m IH generalizing s\n  · -- Base case: `0 < re s`, so Gamma is given by the integral formula\n    intro hs\n    rw [Nat.cast_zero, neg_zero] at hs\n    rw [← Gamma_eq_GammaAux]\n    · refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)\n      refine (eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)\n      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm\n    · rwa [Nat.cast_zero, neg_lt_zero]\n  · -- Induction step: use recurrence formulae in `s` for Gamma and GammaSeq\n    intro hs\n    rw [Nat.cast_succ, neg_add, ← sub_eq_add_neg, sub_lt_iff_lt_add, ← one_re, ← add_re] at hs\n    rw [GammaAux]\n    have := @Tendsto.congr' _ _ _ ?_ _ _\n      ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)) ((IH _ hs).div_const s)\n    pick_goal 3; · exact GammaSeq_add_one_left s hn -- doesn't work if inlined?\n    conv at this => arg 1; intro n; rw [mul_comm]\n    rwa [← mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' ℂ)] at this\n    simp_rw [add_assoc]\n    exact tendsto_natCast_div_add_atTop (1 + s)\n\n"}
{"name":"Complex.GammaSeq_mul","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"z : Complex\nn : Nat\nhn : Ne n 0\n⊢ Eq (HMul.hMul (z.GammaSeq n) ((HSub.hSub 1 z).GammaSeq n)) (HMul.hMul (HDiv.hDiv (↑n) (HSub.hSub (HAdd.hAdd (↑n) 1) z)) (HDiv.hDiv 1 (HMul.hMul z ((Finset.range n).prod fun j => HSub.hSub 1 (HDiv.hDiv (HPow.hPow z 2) (HPow.hPow (HAdd.hAdd (↑j) 1) 2))))))","decl":"theorem GammaSeq_mul (z : ℂ) {n : ℕ} (hn : n ≠ 0) :\n    GammaSeq z n * GammaSeq (1 - z) n =\n      n / (n + ↑1 - z) * (↑1 / (z * ∏ j ∈ Finset.range n, (↑1 - z ^ 2 / ((j : ℂ) + 1) ^ 2))) := by\n  -- also true for n = 0 but we don't need it\n  have aux : ∀ a b c d : ℂ, a * b * (c * d) = a * c * (b * d) := by intros; ring\n  rw [GammaSeq, GammaSeq, div_mul_div_comm, aux, ← pow_two]\n  have : (n : ℂ) ^ z * (n : ℂ) ^ (1 - z) = n := by\n    rw [← cpow_add _ _ (Nat.cast_ne_zero.mpr hn), add_sub_cancel, cpow_one]\n  rw [this, Finset.prod_range_succ', Finset.prod_range_succ, aux, ← Finset.prod_mul_distrib,\n    Nat.cast_zero, add_zero, add_comm (1 - z) n, ← add_sub_assoc]\n  have : ∀ j : ℕ, (z + ↑(j + 1)) * (↑1 - z + ↑j) =\n      ((j + 1) ^ 2 :) * (↑1 - z ^ 2 / ((j : ℂ) + 1) ^ 2) := by\n    intro j\n    push_cast\n    have : (j : ℂ) + 1 ≠ 0 := by rw [← Nat.cast_succ, Nat.cast_ne_zero]; exact Nat.succ_ne_zero j\n    field_simp; ring\n  simp_rw [this]\n  rw [Finset.prod_mul_distrib, ← Nat.cast_prod, Finset.prod_pow,\n    Finset.prod_range_add_one_eq_factorial, Nat.cast_pow,\n    (by intros; ring : ∀ a b c d : ℂ, a * b * (c * d) = a * (d * (b * c))), ← div_div,\n    mul_div_cancel_right₀, ← div_div, mul_comm z _, mul_one_div]\n  exact pow_ne_zero 2 (Nat.cast_ne_zero.mpr <| Nat.factorial_ne_zero n)\n\n"}
{"name":"Complex.Gamma_mul_Gamma_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul (Complex.Gamma z) (Complex.Gamma (HSub.hSub 1 z))) (HDiv.hDiv (↑Real.pi) (Complex.sin (HMul.hMul (↑Real.pi) z)))","decl":"/-- Euler's reflection formula for the complex Gamma function. -/\ntheorem Gamma_mul_Gamma_one_sub (z : ℂ) : Gamma z * Gamma (1 - z) = π / sin (π * z) := by\n  have pi_ne : (π : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero\n  by_cases hs : sin (↑π * z) = 0\n  · -- first deal with silly case z = integer\n    rw [hs, div_zero]\n    rw [← neg_eq_zero, ← Complex.sin_neg, ← mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs\n    obtain ⟨k, hk⟩ := hs\n    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false,\n      neg_eq_iff_eq_neg] at hk\n    rw [hk]\n    cases k\n    · rw [Int.ofNat_eq_coe, Int.cast_natCast, Complex.Gamma_neg_nat_eq_zero, zero_mul]\n    · rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,\n        Complex.Gamma_neg_nat_eq_zero, mul_zero]\n  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_\n  have : ↑π / sin (↑π * z) = 1 * (π / sin (π * z)) := by rw [one_mul]\n  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn =>\n    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)\n  · convert tendsto_natCast_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]\n  · have : ↑π / sin (↑π * z) = 1 / (sin (π * z) / π) := by field_simp\n    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)\n    rw [← tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel₀ _ pi_ne]\n    convert tendsto_euler_sin_prod z using 1\n    ext1 n; rw [mul_comm, ← mul_assoc]\n\n"}
{"name":"Complex.Gamma_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : ∀ (m : Nat), Ne s (Neg.neg ↑m)\n⊢ Ne (Complex.Gamma s) 0","decl":"/-- The Gamma function does not vanish on `ℂ` (except at non-positive integers, where the function\nis mathematically undefined and we set it to `0` by convention). -/\ntheorem Gamma_ne_zero {s : ℂ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 := by\n  by_cases h_im : s.im = 0\n  · have : s = ↑s.re := by\n      conv_lhs => rw [← Complex.re_add_im s]\n      rw [h_im, ofReal_zero, zero_mul, add_zero]\n    rw [this, Gamma_ofReal, ofReal_ne_zero]\n    refine Real.Gamma_ne_zero fun n => ?_\n    specialize hs n\n    contrapose! hs\n    rwa [this, ← ofReal_natCast, ← ofReal_neg, ofReal_inj]\n  · have : sin (↑π * s) ≠ 0 := by\n      rw [Complex.sin_ne_zero_iff]\n      intro k\n      apply_fun im\n      rw [im_ofReal_mul, ← ofReal_intCast, ← ofReal_mul, ofReal_im]\n      exact mul_ne_zero Real.pi_pos.ne' h_im\n    have A := div_ne_zero (ofReal_ne_zero.mpr Real.pi_pos.ne') this\n    rw [← Complex.Gamma_mul_Gamma_one_sub s, mul_ne_zero_iff] at A\n    exact A.1\n\n"}
{"name":"Complex.Gamma_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n⊢ Iff (Eq (Complex.Gamma s) 0) (Exists fun m => Eq s (Neg.neg ↑m))","decl":"theorem Gamma_eq_zero_iff (s : ℂ) : Gamma s = 0 ↔ ∃ m : ℕ, s = -m := by\n  constructor\n  · contrapose!; exact Gamma_ne_zero\n  · rintro ⟨m, rfl⟩; exact Gamma_neg_nat_eq_zero m\n\n"}
{"name":"Complex.Gamma_ne_zero_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n⊢ Ne (Complex.Gamma s) 0","decl":"/-- A weaker, but easier-to-apply, version of `Complex.Gamma_ne_zero`. -/\ntheorem Gamma_ne_zero_of_re_pos {s : ℂ} (hs : 0 < re s) : Gamma s ≠ 0 := by\n  refine Gamma_ne_zero fun m => ?_\n  contrapose! hs\n  simpa only [hs, neg_re, ← ofReal_natCast, ofReal_re, neg_nonpos] using Nat.cast_nonneg _\n\n"}
{"name":"Real.GammaSeq_tendsto_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n⊢ Filter.Tendsto s.GammaSeq Filter.atTop (nhds (Real.Gamma s))","decl":"/-- Euler's limit formula for the real Gamma function. -/\ntheorem GammaSeq_tendsto_Gamma (s : ℝ) : Tendsto (GammaSeq s) atTop (𝓝 <| Gamma s) := by\n  suffices Tendsto ((↑) ∘ GammaSeq s : ℕ → ℂ) atTop (𝓝 <| Complex.Gamma s) by\n    exact (Complex.continuous_re.tendsto (Complex.Gamma ↑s)).comp this\n  convert Complex.GammaSeq_tendsto_Gamma s\n  ext1 n\n  dsimp only [GammaSeq, Function.comp_apply, Complex.GammaSeq]\n  push_cast\n  rw [Complex.ofReal_cpow n.cast_nonneg, Complex.ofReal_natCast]\n\n"}
{"name":"Real.Gamma_mul_Gamma_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n⊢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HSub.hSub 1 s))) (HDiv.hDiv Real.pi (Real.sin (HMul.hMul Real.pi s)))","decl":"/-- Euler's reflection formula for the real Gamma function. -/\ntheorem Gamma_mul_Gamma_one_sub (s : ℝ) : Gamma s * Gamma (1 - s) = π / sin (π * s) := by\n  simp_rw [← Complex.ofReal_inj, Complex.ofReal_div, Complex.ofReal_sin, Complex.ofReal_mul, ←\n    Complex.Gamma_ofReal, Complex.ofReal_sub, Complex.ofReal_one]\n  exact Complex.Gamma_mul_Gamma_one_sub s\n\n"}
{"name":"Complex.one_div_Gamma_eq_self_mul_one_div_Gamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n⊢ Eq (Inv.inv (Complex.Gamma s)) (HMul.hMul s (Inv.inv (Complex.Gamma (HAdd.hAdd s 1))))","decl":"/-- A reformulation of the Gamma recurrence relation which is true for `s = 0` as well. -/\ntheorem one_div_Gamma_eq_self_mul_one_div_Gamma_add_one (s : ℂ) :\n    (Gamma s)⁻¹ = s * (Gamma (s + 1))⁻¹ := by\n  rcases ne_or_eq s 0 with (h | rfl)\n  · rw [Gamma_add_one s h, mul_inv, mul_inv_cancel_left₀ h]\n  · rw [zero_add, Gamma_zero, inv_zero, zero_mul]\n\n"}
{"name":"Complex.differentiable_one_div_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"⊢ Differentiable Complex fun s => Inv.inv (Complex.Gamma s)","decl":"/-- The reciprocal of the Gamma function is differentiable everywhere\n(including the points where Gamma itself is not). -/\ntheorem differentiable_one_div_Gamma : Differentiable ℂ fun s : ℂ => (Gamma s)⁻¹ := fun s ↦ by\n  rcases exists_nat_gt (-s.re) with ⟨n, hs⟩\n  induction n generalizing s with\n  | zero =>\n    rw [Nat.cast_zero, neg_lt_zero] at hs\n    suffices ∀ m : ℕ, s ≠ -↑m from (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)\n    rintro m rfl\n    apply hs.not_le\n    simp\n  | succ n ihn =>\n    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]\n    specialize ihn (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ← Nat.cast_succ])\n    exact differentiableAt_id.mul (ihn.comp s (f := fun s => s + 1) <|\n      differentiableAt_id.add_const (1 : ℂ))\n\n"}
{"name":"Complex.Gamma_mul_Gamma_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n⊢ Eq (HMul.hMul (Complex.Gamma s) (Complex.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Complex.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) ↑Real.pi.sqrt)","decl":"theorem Gamma_mul_Gamma_add_half (s : ℂ) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : ℂ) ^ (1 - 2 * s) * ↑(√π) := by\n  suffices (fun z => (Gamma z)⁻¹ * (Gamma (z + 1 / 2))⁻¹) = fun z =>\n      (Gamma (2 * z))⁻¹ * (2 : ℂ) ^ (2 * z - 1) / ↑(√π) by\n    convert congr_arg Inv.inv (congr_fun this s) using 1\n    · rw [mul_inv, inv_inv, inv_inv]\n    · rw [div_eq_mul_inv, mul_inv, mul_inv, inv_inv, inv_inv, ← cpow_neg, neg_sub]\n  have h1 : AnalyticOnNhd ℂ (fun z : ℂ => (Gamma z)⁻¹ * (Gamma (z + 1 / 2))⁻¹) univ := by\n    refine DifferentiableOn.analyticOnNhd ?_ isOpen_univ\n    refine (differentiable_one_div_Gamma.mul ?_).differentiableOn\n    exact differentiable_one_div_Gamma.comp (differentiable_id.add (differentiable_const _))\n  have h2 : AnalyticOnNhd ℂ\n      (fun z => (Gamma (2 * z))⁻¹ * (2 : ℂ) ^ (2 * z - 1) / ↑(√π)) univ := by\n    refine DifferentiableOn.analyticOnNhd ?_ isOpen_univ\n    refine (Differentiable.mul ?_ (differentiable_const _)).differentiableOn\n    apply Differentiable.mul\n    · exact differentiable_one_div_Gamma.comp (differentiable_id'.const_mul _)\n    · refine fun t => DifferentiableAt.const_cpow ?_ (Or.inl two_ne_zero)\n      exact DifferentiableAt.sub_const (differentiableAt_id.const_mul _) _\n  have h3 : Tendsto ((↑) : ℝ → ℂ) (𝓝[≠] 1) (𝓝[≠] 1) := by\n    rw [tendsto_nhdsWithin_iff]; constructor\n    · exact tendsto_nhdsWithin_of_tendsto_nhds continuous_ofReal.continuousAt\n    · exact eventually_nhdsWithin_iff.mpr (Eventually.of_forall fun t ht => ofReal_ne_one.mpr ht)\n  refine AnalyticOnNhd.eq_of_frequently_eq h1 h2 (h3.frequently ?_)\n  refine ((Eventually.filter_mono nhdsWithin_le_nhds) ?_).frequently\n  refine (eventually_gt_nhds zero_lt_one).mp (Eventually.of_forall fun t ht => ?_)\n  rw [← mul_inv, Gamma_ofReal, (by norm_num : (t : ℂ) + 1 / 2 = ↑(t + 1 / 2)), Gamma_ofReal, ←\n    ofReal_mul, Gamma_mul_Gamma_add_half_of_pos ht, ofReal_mul, ofReal_mul, ← Gamma_ofReal,\n    mul_inv, mul_inv, (by norm_num : 2 * (t : ℂ) = ↑(2 * t)), Gamma_ofReal,\n    ofReal_cpow zero_le_two, show (2 : ℝ) = (2 : ℂ) by norm_cast, ← cpow_neg, ofReal_sub,\n    ofReal_one, neg_sub, ← div_eq_mul_inv]\n\n"}
{"name":"Real.Gamma_mul_Gamma_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n⊢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Real.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) Real.pi.sqrt)","decl":"theorem Gamma_mul_Gamma_add_half (s : ℝ) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : ℝ) ^ (1 - 2 * s) * √π := by\n  rw [← ofReal_inj]\n  simpa only [← Gamma_ofReal, ofReal_cpow zero_le_two, ofReal_mul, ofReal_add, ofReal_div,\n    ofReal_sub] using Complex.Gamma_mul_Gamma_add_half ↑s\n\n"}
