{"name":"Complex.betaIntegral_convergent_left","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\nv : Complex\n‚ä¢ IntervalIntegrable (fun x => HMul.hMul (HPow.hPow (‚Üëx) (HSub.hSub u 1)) (HPow.hPow (HSub.hSub 1 ‚Üëx) (HSub.hSub v 1))) MeasureTheory.MeasureSpace.volume 0 (1 / 2)","decl":"/-- Auxiliary lemma for `betaIntegral_convergent`, showing convergence at the left endpoint. -/\ntheorem betaIntegral_convergent_left {u : ‚ÑÇ} (hu : 0 < re u) (v : ‚ÑÇ) :\n    IntervalIntegrable (fun x =>\n      (x : ‚ÑÇ) ^ (u - 1) * (1 - (x : ‚ÑÇ)) ^ (v - 1) : ‚Ñù ‚Üí ‚ÑÇ) volume 0 (1 / 2) := by\n  apply IntervalIntegrable.mul_continuousOn\n  ¬∑ refine intervalIntegral.intervalIntegrable_cpow' ?_\n    rwa [sub_re, one_re, ‚Üê zero_sub, sub_lt_sub_iff_right]\n  ¬∑ apply continuousOn_of_forall_continuousAt\n    intro x hx\n    rw [uIcc_of_le (by positivity : (0 : ‚Ñù) ‚â§ 1 / 2)] at hx\n    apply ContinuousAt.cpow\n    ¬∑ exact (continuous_const.sub continuous_ofReal).continuousAt\n    ¬∑ exact continuousAt_const\n    ¬∑ norm_cast\n      exact ofReal_mem_slitPlane.2 <| by linarith only [hx.2]\n\n"}
{"name":"Complex.betaIntegral_convergent","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\nhu : LT.lt 0 u.re\nhv : LT.lt 0 v.re\n‚ä¢ IntervalIntegrable (fun x => HMul.hMul (HPow.hPow (‚Üëx) (HSub.hSub u 1)) (HPow.hPow (HSub.hSub 1 ‚Üëx) (HSub.hSub v 1))) MeasureTheory.MeasureSpace.volume 0 1","decl":"/-- The Beta integral is convergent for all `u, v` of positive real part. -/\ntheorem betaIntegral_convergent {u v : ‚ÑÇ} (hu : 0 < re u) (hv : 0 < re v) :\n    IntervalIntegrable (fun x =>\n      (x : ‚ÑÇ) ^ (u - 1) * (1 - (x : ‚ÑÇ)) ^ (v - 1) : ‚Ñù ‚Üí ‚ÑÇ) volume 0 1 := by\n  refine (betaIntegral_convergent_left hu v).trans ?_\n  rw [IntervalIntegrable.iff_comp_neg]\n  convert ((betaIntegral_convergent_left hv u).comp_add_right 1).symm using 1\n  ¬∑ ext1 x\n    conv_lhs => rw [mul_comm]\n    congr 2 <;> ¬∑ push_cast; ring\n  ¬∑ norm_num\n  ¬∑ norm_num\n\n"}
{"name":"Complex.betaIntegral_symm","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\n‚ä¢ Eq (v.betaIntegral u) (u.betaIntegral v)","decl":"theorem betaIntegral_symm (u v : ‚ÑÇ) : betaIntegral v u = betaIntegral u v := by\n  rw [betaIntegral, betaIntegral]\n  have := intervalIntegral.integral_comp_mul_add (a := 0) (b := 1) (c := -1)\n    (fun x : ‚Ñù => (x : ‚ÑÇ) ^ (u - 1) * (1 - (x : ‚ÑÇ)) ^ (v - 1)) neg_one_lt_zero.ne 1\n  rw [inv_neg, inv_one, neg_one_smul, ‚Üê intervalIntegral.integral_symm] at this\n  simp? at this says\n    simp only [neg_mul, one_mul, ofReal_add, ofReal_neg, ofReal_one, sub_add_cancel_right, neg_neg,\n      mul_one, neg_add_cancel, mul_zero, zero_add] at this\n  conv_lhs at this => arg 1; intro x; rw [add_comm, ‚Üê sub_eq_add_neg, mul_comm]\n  exact this\n\n"}
{"name":"Complex.betaIntegral_eval_one_right","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\n‚ä¢ Eq (u.betaIntegral 1) (HDiv.hDiv 1 u)","decl":"theorem betaIntegral_eval_one_right {u : ‚ÑÇ} (hu : 0 < re u) : betaIntegral u 1 = 1 / u := by\n  simp_rw [betaIntegral, sub_self, cpow_zero, mul_one]\n  rw [integral_cpow (Or.inl _)]\n  ¬∑ rw [ofReal_zero, ofReal_one, one_cpow, zero_cpow, sub_zero, sub_add_cancel]\n    rw [sub_add_cancel]\n    contrapose! hu; rw [hu, zero_re]\n  ¬∑ rwa [sub_re, one_re, ‚Üê sub_pos, sub_neg_eq_add, sub_add_cancel]\n\n"}
{"name":"Complex.betaIntegral_scaled","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s t : Complex\na : Real\nha : LT.lt 0 a\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (‚Üëx) (HSub.hSub s 1)) (HPow.hPow (HSub.hSub ‚Üëa ‚Üëx) (HSub.hSub t 1))) 0 a MeasureTheory.MeasureSpace.volume) (HMul.hMul (HPow.hPow (‚Üëa) (HSub.hSub (HAdd.hAdd s t) 1)) (s.betaIntegral t))","decl":"theorem betaIntegral_scaled (s t : ‚ÑÇ) {a : ‚Ñù} (ha : 0 < a) :\n    ‚à´ x in (0)..a, (x : ‚ÑÇ) ^ (s - 1) * ((a : ‚ÑÇ) - x) ^ (t - 1) =\n    (a : ‚ÑÇ) ^ (s + t - 1) * betaIntegral s t := by\n  have ha' : (a : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr ha.ne'\n  rw [betaIntegral]\n  have A : (a : ‚ÑÇ) ^ (s + t - 1) = a * ((a : ‚ÑÇ) ^ (s - 1) * (a : ‚ÑÇ) ^ (t - 1)) := by\n    rw [(by abel : s + t - 1 = 1 + (s - 1) + (t - 1)), cpow_add _ _ ha', cpow_add 1 _ ha', cpow_one,\n      mul_assoc]\n  rw [A, mul_assoc, ‚Üê intervalIntegral.integral_const_mul, ‚Üê real_smul, ‚Üê zero_div a, ‚Üê\n    div_self ha.ne', ‚Üê intervalIntegral.integral_comp_div _ ha.ne', zero_div]\n  simp_rw [intervalIntegral.integral_of_le ha.le]\n  refine setIntegral_congr_fun measurableSet_Ioc fun x hx => ?_\n  rw [mul_mul_mul_comm]\n  congr 1\n  ¬∑ rw [‚Üê mul_cpow_ofReal_nonneg ha.le (div_pos hx.1 ha).le, ofReal_div, mul_div_cancel‚ÇÄ _ ha']\n  ¬∑ rw [(by norm_cast : (1 : ‚ÑÇ) - ‚Üë(x / a) = ‚Üë(1 - x / a)), ‚Üê\n      mul_cpow_ofReal_nonneg ha.le (sub_nonneg.mpr <| (div_le_one ha).mpr hx.2)]\n    push_cast\n    rw [mul_sub, mul_one, mul_div_cancel‚ÇÄ _ ha']\n\n"}
{"name":"Complex.Gamma_mul_Gamma_eq_betaIntegral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s t : Complex\nhs : LT.lt 0 s.re\nht : LT.lt 0 t.re\n‚ä¢ Eq (HMul.hMul (Complex.Gamma s) (Complex.Gamma t)) (HMul.hMul (Complex.Gamma (HAdd.hAdd s t)) (s.betaIntegral t))","decl":"/-- Relation between Beta integral and Gamma function. -/\ntheorem Gamma_mul_Gamma_eq_betaIntegral {s t : ‚ÑÇ} (hs : 0 < re s) (ht : 0 < re t) :\n    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t := by\n  -- Note that we haven't proved (yet) that the Gamma function has no zeroes, so we can't formulate\n  -- this as a formula for the Beta function.\n  have conv_int := integral_posConvolution\n    (GammaIntegral_convergent hs) (GammaIntegral_convergent ht) (ContinuousLinearMap.mul ‚Ñù ‚ÑÇ)\n  simp_rw [ContinuousLinearMap.mul_apply'] at conv_int\n  have hst : 0 < re (s + t) := by rw [add_re]; exact add_pos hs ht\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst, GammaIntegral,\n    GammaIntegral, GammaIntegral, ‚Üê conv_int, ‚Üê integral_mul_right (betaIntegral _ _)]\n  refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n  rw [mul_assoc, ‚Üê betaIntegral_scaled s t hx, ‚Üê intervalIntegral.integral_const_mul]\n  congr 1 with y : 1\n  push_cast\n  suffices Complex.exp (-x) = Complex.exp (-y) * Complex.exp (-(x - y)) by rw [this]; ring\n  rw [‚Üê Complex.exp_add]; congr 1; abel\n\n"}
{"name":"Complex.betaIntegral_recurrence","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u v : Complex\nhu : LT.lt 0 u.re\nhv : LT.lt 0 v.re\n‚ä¢ Eq (HMul.hMul u (u.betaIntegral (HAdd.hAdd v 1))) (HMul.hMul v ((HAdd.hAdd u 1).betaIntegral v))","decl":"/-- Recurrence formula for the Beta function. -/\ntheorem betaIntegral_recurrence {u v : ‚ÑÇ} (hu : 0 < re u) (hv : 0 < re v) :\n    u * betaIntegral u (v + 1) = v * betaIntegral (u + 1) v := by\n  -- NB: If we knew `Gamma (u + v + 1) ‚â† 0` this would be an easy consequence of\n  -- `Gamma_mul_Gamma_eq_betaIntegral`; but we don't know that yet. We will prove it later, but\n  -- this lemma is needed in the proof. So we give a (somewhat laborious) direct argument.\n  let F : ‚Ñù ‚Üí ‚ÑÇ := fun x => (x : ‚ÑÇ) ^ u * (1 - (x : ‚ÑÇ)) ^ v\n  have hu' : 0 < re (u + 1) := by rw [add_re, one_re]; positivity\n  have hv' : 0 < re (v + 1) := by rw [add_re, one_re]; positivity\n  have hc : ContinuousOn F (Icc 0 1) := by\n    refine (continuousOn_of_forall_continuousAt fun x hx => ?_).mul\n        (continuousOn_of_forall_continuousAt fun x hx => ?_)\n    ¬∑ refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hu).comp continuous_ofReal.continuousAt\n      rw [ofReal_re]; exact hx.1\n    ¬∑ refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hv).comp\n        (continuous_const.sub continuous_ofReal).continuousAt\n      rw [sub_re, one_re, ofReal_re, sub_nonneg]\n      exact hx.2\n  have hder : ‚àÄ x : ‚Ñù, x ‚àà Ioo (0 : ‚Ñù) 1 ‚Üí\n      HasDerivAt F (u * ((x : ‚ÑÇ) ^ (u - 1) * (1 - (x : ‚ÑÇ)) ^ v) -\n        v * ((x : ‚ÑÇ) ^ u * (1 - (x : ‚ÑÇ)) ^ (v - 1))) x := by\n    intro x hx\n    have U : HasDerivAt (fun y : ‚ÑÇ => y ^ u) (u * (x : ‚ÑÇ) ^ (u - 1)) ‚Üëx := by\n      have := @HasDerivAt.cpow_const _ _ _ u (hasDerivAt_id (x : ‚ÑÇ)) (Or.inl ?_)\n      ¬∑ simp only [id_eq, mul_one] at this\n        exact this\n      ¬∑ rw [id_eq, ofReal_re]; exact hx.1\n    have V : HasDerivAt (fun y : ‚ÑÇ => (1 - y) ^ v) (-v * (1 - (x : ‚ÑÇ)) ^ (v - 1)) ‚Üëx := by\n      have A := @HasDerivAt.cpow_const _ _ _ v (hasDerivAt_id (1 - (x : ‚ÑÇ))) (Or.inl ?_)\n      swap; ¬∑ rw [id, sub_re, one_re, ofReal_re, sub_pos]; exact hx.2\n      simp_rw [id] at A\n      have B : HasDerivAt (fun y : ‚ÑÇ => 1 - y) (-1) ‚Üëx := by\n        apply HasDerivAt.const_sub; apply hasDerivAt_id\n      convert HasDerivAt.comp (‚Üëx) A B using 1\n      ring\n    convert (U.mul V).comp_ofReal using 1\n    ring\n  have h_int := ((betaIntegral_convergent hu hv').const_mul u).sub\n    ((betaIntegral_convergent hu' hv).const_mul v)\n  rw [add_sub_cancel_right, add_sub_cancel_right] at h_int\n  have int_ev := intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le zero_le_one hc hder h_int\n  have hF0 : F 0 = 0 := by\n    simp only [F, mul_eq_zero, ofReal_zero, cpow_eq_zero_iff, eq_self_iff_true, Ne,\n      true_and, sub_zero, one_cpow, one_ne_zero, or_false]\n    contrapose! hu; rw [hu, zero_re]\n  have hF1 : F 1 = 0 := by\n    simp only [F, mul_eq_zero, ofReal_one, one_cpow, one_ne_zero, sub_self, cpow_eq_zero_iff,\n      eq_self_iff_true, Ne, true_and, false_or]\n    contrapose! hv; rw [hv, zero_re]\n  rw [hF0, hF1, sub_zero, intervalIntegral.integral_sub, intervalIntegral.integral_const_mul,\n    intervalIntegral.integral_const_mul] at int_ev\n  ¬∑ rw [betaIntegral, betaIntegral, ‚Üê sub_eq_zero]\n    convert int_ev <;> ring\n  ¬∑ apply IntervalIntegrable.const_mul\n    convert betaIntegral_convergent hu hv'; ring\n  ¬∑ apply IntervalIntegrable.const_mul\n    convert betaIntegral_convergent hu' hv; ring\n\n"}
{"name":"Complex.betaIntegral_eval_nat_add_one_right","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"u : Complex\nhu : LT.lt 0 u.re\nn : Nat\n‚ä¢ Eq (u.betaIntegral (HAdd.hAdd (‚Üën) 1)) (HDiv.hDiv (‚Üën.factorial) ((Finset.range (HAdd.hAdd n 1)).prod fun j => HAdd.hAdd u ‚Üëj))","decl":"/-- Explicit formula for the Beta function when second argument is a positive integer. -/\ntheorem betaIntegral_eval_nat_add_one_right {u : ‚ÑÇ} (hu : 0 < re u) (n : ‚Ñï) :\n    betaIntegral u (n + 1) = n ! / ‚àè j ‚àà Finset.range (n + 1), (u + j) := by\n  induction' n with n IH generalizing u\n  ¬∑ rw [Nat.cast_zero, zero_add, betaIntegral_eval_one_right hu, Nat.factorial_zero, Nat.cast_one]\n    simp\n  ¬∑ have := betaIntegral_recurrence hu (?_ : 0 < re n.succ)\n    swap; ¬∑ rw [‚Üê ofReal_natCast, ofReal_re]; positivity\n    rw [mul_comm u _, ‚Üê eq_div_iff] at this\n    swap; ¬∑ contrapose! hu; rw [hu, zero_re]\n    rw [this, Finset.prod_range_succ', Nat.cast_succ, IH]\n    swap; ¬∑ rw [add_re, one_re]; positivity\n    rw [Nat.factorial_succ, Nat.cast_mul, Nat.cast_add, Nat.cast_one, Nat.cast_zero, add_zero, ‚Üê\n      mul_div_assoc, ‚Üê div_div]\n    congr 3 with j : 1\n    push_cast; abel\n\n"}
{"name":"Complex.GammaSeq_eq_betaIntegral_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\nn : Nat\n‚ä¢ Eq (s.GammaSeq n) (HMul.hMul (HPow.hPow (‚Üën) s) (s.betaIntegral (HAdd.hAdd (‚Üën) 1)))","decl":"theorem GammaSeq_eq_betaIntegral_of_re_pos {s : ‚ÑÇ} (hs : 0 < re s) (n : ‚Ñï) :\n    GammaSeq s n = (n : ‚ÑÇ) ^ s * betaIntegral s (n + 1) := by\n  rw [GammaSeq, betaIntegral_eval_nat_add_one_right hs n, ‚Üê mul_div_assoc]\n\n"}
{"name":"Complex.GammaSeq_add_one_left","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nn : Nat\nhn : Ne n 0\n‚ä¢ Eq (HDiv.hDiv ((HAdd.hAdd s 1).GammaSeq n) s) (HMul.hMul (HDiv.hDiv (‚Üën) (HAdd.hAdd (HAdd.hAdd (‚Üën) 1) s)) (s.GammaSeq n))","decl":"theorem GammaSeq_add_one_left (s : ‚ÑÇ) {n : ‚Ñï} (hn : n ‚â† 0) :\n    GammaSeq (s + 1) n / s = n / (n + 1 + s) * GammaSeq s n := by\n  conv_lhs => rw [GammaSeq, Finset.prod_range_succ, div_div]\n  conv_rhs =>\n    rw [GammaSeq, Finset.prod_range_succ', Nat.cast_zero, add_zero, div_mul_div_comm, ‚Üê mul_assoc,\n      ‚Üê mul_assoc, mul_comm _ (Finset.prod _ _)]\n  congr 3\n  ¬∑ rw [cpow_add _ _ (Nat.cast_ne_zero.mpr hn), cpow_one, mul_comm]\n  ¬∑ refine Finset.prod_congr (by rfl) fun x _ => ?_\n    push_cast; ring\n  ¬∑ abel\n\n"}
{"name":"Complex.GammaSeq_eq_approx_Gamma_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\nn : Nat\nhn : Ne n 0\n‚ä¢ Eq (s.GammaSeq n) (intervalIntegral (fun x => HMul.hMul (‚Üë(HPow.hPow (HSub.hSub 1 (HDiv.hDiv x ‚Üën)) n)) (HPow.hPow (‚Üëx) (HSub.hSub s 1))) 0 (‚Üën) MeasureTheory.MeasureSpace.volume)","decl":"theorem GammaSeq_eq_approx_Gamma_integral {s : ‚ÑÇ} (hs : 0 < re s) {n : ‚Ñï} (hn : n ‚â† 0) :\n    GammaSeq s n = ‚à´ x : ‚Ñù in (0)..n, ‚Üë((1 - x / n) ^ n) * (x : ‚ÑÇ) ^ (s - 1) := by\n  have : ‚àÄ x : ‚Ñù, x = x / n * n := by intro x; rw [div_mul_cancel‚ÇÄ]; exact Nat.cast_ne_zero.mpr hn\n  conv_rhs => enter [1, x, 2, 1]; rw [this x]\n  rw [GammaSeq_eq_betaIntegral_of_re_pos hs]\n  have := intervalIntegral.integral_comp_div (a := 0) (b := n)\n    (fun x => ‚Üë((1 - x) ^ n) * ‚Üë(x * ‚Üën) ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) (Nat.cast_ne_zero.mpr hn)\n  dsimp only at this\n  rw [betaIntegral, this, real_smul, zero_div, div_self, add_sub_cancel_right,\n    ‚Üê intervalIntegral.integral_const_mul, ‚Üê intervalIntegral.integral_const_mul]\n  swap; ¬∑ exact Nat.cast_ne_zero.mpr hn\n  simp_rw [intervalIntegral.integral_of_le zero_le_one]\n  refine setIntegral_congr_fun measurableSet_Ioc fun x hx => ?_\n  push_cast\n  have hn' : (n : ‚ÑÇ) ‚â† 0 := Nat.cast_ne_zero.mpr hn\n  have A : (n : ‚ÑÇ) ^ s = (n : ‚ÑÇ) ^ (s - 1) * n := by\n    conv_lhs => rw [(by ring : s = s - 1 + 1), cpow_add _ _ hn']\n    simp\n  have B : ((x : ‚ÑÇ) * ‚Üën) ^ (s - 1) = (x : ‚ÑÇ) ^ (s - 1) * (n : ‚ÑÇ) ^ (s - 1) := by\n    rw [‚Üê ofReal_natCast,\n      mul_cpow_ofReal_nonneg hx.1.le (Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)).le]\n  rw [A, B, cpow_natCast]; ring\n\n"}
{"name":"Complex.approx_Gamma_integral_tendsto_Gamma_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Filter.Tendsto (fun n => intervalIntegral (fun x => HMul.hMul (‚Üë(HPow.hPow (HSub.hSub 1 (HDiv.hDiv x ‚Üën)) n)) (HPow.hPow (‚Üëx) (HSub.hSub s 1))) 0 (‚Üën) MeasureTheory.MeasureSpace.volume) Filter.atTop (nhds (Complex.Gamma s))","decl":"/-- The main technical lemma for `GammaSeq_tendsto_Gamma`, expressing the integral defining the\nGamma function for `0 < re s` as the limit of a sequence of integrals over finite intervals. -/\ntheorem approx_Gamma_integral_tendsto_Gamma_integral {s : ‚ÑÇ} (hs : 0 < re s) :\n    Tendsto (fun n : ‚Ñï => ‚à´ x : ‚Ñù in (0)..n, ((1 - x / n) ^ n : ‚Ñù) * (x : ‚ÑÇ) ^ (s - 1)) atTop\n      (ùìù <| Gamma s) := by\n  rw [Gamma_eq_integral hs]\n  -- We apply dominated convergence to the following function, which we will show is uniformly\n  -- bounded above by the Gamma integrand `exp (-x) * x ^ (re s - 1)`.\n  let f : ‚Ñï ‚Üí ‚Ñù ‚Üí ‚ÑÇ := fun n =>\n    indicator (Ioc 0 (n : ‚Ñù)) fun x : ‚Ñù => ((1 - x / n) ^ n : ‚Ñù) * (x : ‚ÑÇ) ^ (s - 1)\n  -- integrability of f\n  have f_ible : ‚àÄ n : ‚Ñï, Integrable (f n) (volume.restrict (Ioi 0)) := by\n    intro n\n    rw [integrable_indicator_iff (measurableSet_Ioc : MeasurableSet (Ioc (_ : ‚Ñù) _)), IntegrableOn,\n      Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self, ‚Üê IntegrableOn, ‚Üê\n      intervalIntegrable_iff_integrableOn_Ioc_of_le (by positivity : (0 : ‚Ñù) ‚â§ n)]\n    apply IntervalIntegrable.continuousOn_mul\n    ¬∑ refine intervalIntegral.intervalIntegrable_cpow' ?_\n      rwa [sub_re, one_re, ‚Üê zero_sub, sub_lt_sub_iff_right]\n    ¬∑ apply Continuous.continuousOn\n      exact RCLike.continuous_ofReal.comp -- Porting note: was `continuity`\n        ((continuous_const.sub (continuous_id'.div_const (n : ‚Ñù))).pow n)\n  -- pointwise limit of f\n  have f_tends : ‚àÄ x : ‚Ñù, x ‚àà Ioi (0 : ‚Ñù) ‚Üí\n      Tendsto (fun n : ‚Ñï => f n x) atTop (ùìù <| ‚Üë(Real.exp (-x)) * (x : ‚ÑÇ) ^ (s - 1)) := by\n    intro x hx\n    apply Tendsto.congr'\n    ¬∑ show ‚àÄ·∂† n : ‚Ñï in atTop, ‚Üë((1 - x / n) ^ n) * (x : ‚ÑÇ) ^ (s - 1) = f n x\n      filter_upwards [eventually_ge_atTop ‚åàx‚åâ‚Çä] with n hn\n      rw [Nat.ceil_le] at hn\n      dsimp only [f]\n      rw [indicator_of_mem]\n      exact ‚ü®hx, hn‚ü©\n    ¬∑ simp_rw [mul_comm]\n      refine (Tendsto.comp (continuous_ofReal.tendsto _) ?_).const_mul _\n      convert tendsto_one_plus_div_pow_exp (-x) using 1\n      ext1 n\n      rw [neg_div, ‚Üê sub_eq_add_neg]\n  -- let `convert` identify the remaining goals\n  convert tendsto_integral_of_dominated_convergence _ (fun n => (f_ible n).1)\n    (Real.GammaIntegral_convergent hs) _\n    ((ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ f_tends)) using 1\n  -- limit of f is the integrand we want\n  ¬∑ ext1 n\n    rw [MeasureTheory.integral_indicator (measurableSet_Ioc : MeasurableSet (Ioc (_ : ‚Ñù) _)),\n      intervalIntegral.integral_of_le (by positivity : 0 ‚â§ (n : ‚Ñù)),\n      Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]\n  -- f is uniformly bounded by the Gamma integrand\n  ¬∑ intro n\n    rw [ae_restrict_iff' measurableSet_Ioi]\n    filter_upwards with x hx\n    dsimp only [f]\n    rcases lt_or_le (n : ‚Ñù) x with (hxn | hxn)\n    ¬∑ rw [indicator_of_not_mem (not_mem_Ioc_of_gt hxn), norm_zero,\n        mul_nonneg_iff_right_nonneg_of_pos (exp_pos _)]\n      exact rpow_nonneg (le_of_lt hx) _\n    ¬∑ rw [indicator_of_mem (mem_Ioc.mpr ‚ü®mem_Ioi.mp hx, hxn‚ü©), norm_mul, Complex.norm_eq_abs,\n        Complex.abs_of_nonneg\n          (pow_nonneg (sub_nonneg.mpr <| div_le_one_of_le‚ÇÄ hxn <| by positivity) _),\n        Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re,\n        mul_le_mul_right (rpow_pos_of_pos hx _)]\n      exact one_sub_div_pow_le_exp_neg hxn\n\n"}
{"name":"Complex.GammaSeq_tendsto_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n‚ä¢ Filter.Tendsto s.GammaSeq Filter.atTop (nhds (Complex.Gamma s))","decl":"/-- Euler's limit formula for the complex Gamma function. -/\ntheorem GammaSeq_tendsto_Gamma (s : ‚ÑÇ) : Tendsto (GammaSeq s) atTop (ùìù <| Gamma s) := by\n  suffices ‚àÄ m : ‚Ñï, -‚Üëm < re s ‚Üí Tendsto (GammaSeq s) atTop (ùìù <| GammaAux m s) by\n    rw [Gamma]\n    apply this\n    rw [neg_lt]\n    rcases lt_or_le 0 (re s) with (hs | hs)\n    ¬∑ exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)\n    ¬∑ refine (Nat.lt_floor_add_one _).trans_le ?_\n      rw [sub_eq_neg_add, Nat.floor_add_one (neg_nonneg.mpr hs), Nat.cast_add_one]\n  intro m\n  induction' m with m IH generalizing s\n  ¬∑ -- Base case: `0 < re s`, so Gamma is given by the integral formula\n    intro hs\n    rw [Nat.cast_zero, neg_zero] at hs\n    rw [‚Üê Gamma_eq_GammaAux]\n    ¬∑ refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)\n      refine (eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)\n      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm\n    ¬∑ rwa [Nat.cast_zero, neg_lt_zero]\n  ¬∑ -- Induction step: use recurrence formulae in `s` for Gamma and GammaSeq\n    intro hs\n    rw [Nat.cast_succ, neg_add, ‚Üê sub_eq_add_neg, sub_lt_iff_lt_add, ‚Üê one_re, ‚Üê add_re] at hs\n    rw [GammaAux]\n    have := @Tendsto.congr' _ _ _ ?_ _ _\n      ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)) ((IH _ hs).div_const s)\n    pick_goal 3; ¬∑ exact GammaSeq_add_one_left s hn -- doesn't work if inlined?\n    conv at this => arg 1; intro n; rw [mul_comm]\n    rwa [‚Üê mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' ‚ÑÇ)] at this\n    simp_rw [add_assoc]\n    exact tendsto_natCast_div_add_atTop (1 + s)\n\n"}
{"name":"Complex.GammaSeq_mul","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"z : Complex\nn : Nat\nhn : Ne n 0\n‚ä¢ Eq (HMul.hMul (z.GammaSeq n) ((HSub.hSub 1 z).GammaSeq n)) (HMul.hMul (HDiv.hDiv (‚Üën) (HSub.hSub (HAdd.hAdd (‚Üën) 1) z)) (HDiv.hDiv 1 (HMul.hMul z ((Finset.range n).prod fun j => HSub.hSub 1 (HDiv.hDiv (HPow.hPow z 2) (HPow.hPow (HAdd.hAdd (‚Üëj) 1) 2))))))","decl":"theorem GammaSeq_mul (z : ‚ÑÇ) {n : ‚Ñï} (hn : n ‚â† 0) :\n    GammaSeq z n * GammaSeq (1 - z) n =\n      n / (n + ‚Üë1 - z) * (‚Üë1 / (z * ‚àè j ‚àà Finset.range n, (‚Üë1 - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2))) := by\n  -- also true for n = 0 but we don't need it\n  have aux : ‚àÄ a b c d : ‚ÑÇ, a * b * (c * d) = a * c * (b * d) := by intros; ring\n  rw [GammaSeq, GammaSeq, div_mul_div_comm, aux, ‚Üê pow_two]\n  have : (n : ‚ÑÇ) ^ z * (n : ‚ÑÇ) ^ (1 - z) = n := by\n    rw [‚Üê cpow_add _ _ (Nat.cast_ne_zero.mpr hn), add_sub_cancel, cpow_one]\n  rw [this, Finset.prod_range_succ', Finset.prod_range_succ, aux, ‚Üê Finset.prod_mul_distrib,\n    Nat.cast_zero, add_zero, add_comm (1 - z) n, ‚Üê add_sub_assoc]\n  have : ‚àÄ j : ‚Ñï, (z + ‚Üë(j + 1)) * (‚Üë1 - z + ‚Üëj) =\n      ((j + 1) ^ 2 :) * (‚Üë1 - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2) := by\n    intro j\n    push_cast\n    have : (j : ‚ÑÇ) + 1 ‚â† 0 := by rw [‚Üê Nat.cast_succ, Nat.cast_ne_zero]; exact Nat.succ_ne_zero j\n    field_simp; ring\n  simp_rw [this]\n  rw [Finset.prod_mul_distrib, ‚Üê Nat.cast_prod, Finset.prod_pow,\n    Finset.prod_range_add_one_eq_factorial, Nat.cast_pow,\n    (by intros; ring : ‚àÄ a b c d : ‚ÑÇ, a * b * (c * d) = a * (d * (b * c))), ‚Üê div_div,\n    mul_div_cancel_right‚ÇÄ, ‚Üê div_div, mul_comm z _, mul_one_div]\n  exact pow_ne_zero 2 (Nat.cast_ne_zero.mpr <| Nat.factorial_ne_zero n)\n\n"}
{"name":"Complex.Gamma_mul_Gamma_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"z : Complex\n‚ä¢ Eq (HMul.hMul (Complex.Gamma z) (Complex.Gamma (HSub.hSub 1 z))) (HDiv.hDiv (‚ÜëReal.pi) (Complex.sin (HMul.hMul (‚ÜëReal.pi) z)))","decl":"/-- Euler's reflection formula for the complex Gamma function. -/\ntheorem Gamma_mul_Gamma_one_sub (z : ‚ÑÇ) : Gamma z * Gamma (1 - z) = œÄ / sin (œÄ * z) := by\n  have pi_ne : (œÄ : ‚ÑÇ) ‚â† 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero\n  by_cases hs : sin (‚ÜëœÄ * z) = 0\n  ¬∑ -- first deal with silly case z = integer\n    rw [hs, div_zero]\n    rw [‚Üê neg_eq_zero, ‚Üê Complex.sin_neg, ‚Üê mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs\n    obtain ‚ü®k, hk‚ü© := hs\n    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false,\n      neg_eq_iff_eq_neg] at hk\n    rw [hk]\n    cases k\n    ¬∑ rw [Int.ofNat_eq_coe, Int.cast_natCast, Complex.Gamma_neg_nat_eq_zero, zero_mul]\n    ¬∑ rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,\n        Complex.Gamma_neg_nat_eq_zero, mul_zero]\n  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_\n  have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 * (œÄ / sin (œÄ * z)) := by rw [one_mul]\n  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn =>\n    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)\n  ¬∑ convert tendsto_natCast_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]\n  ¬∑ have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 / (sin (œÄ * z) / œÄ) := by field_simp\n    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)\n    rw [‚Üê tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel‚ÇÄ _ pi_ne]\n    convert tendsto_euler_sin_prod z using 1\n    ext1 n; rw [mul_comm, ‚Üê mul_assoc]\n\n"}
{"name":"Complex.Gamma_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : ‚àÄ (m : Nat), Ne s (Neg.neg ‚Üëm)\n‚ä¢ Ne (Complex.Gamma s) 0","decl":"/-- The Gamma function does not vanish on `‚ÑÇ` (except at non-positive integers, where the function\nis mathematically undefined and we set it to `0` by convention). -/\ntheorem Gamma_ne_zero {s : ‚ÑÇ} (hs : ‚àÄ m : ‚Ñï, s ‚â† -m) : Gamma s ‚â† 0 := by\n  by_cases h_im : s.im = 0\n  ¬∑ have : s = ‚Üës.re := by\n      conv_lhs => rw [‚Üê Complex.re_add_im s]\n      rw [h_im, ofReal_zero, zero_mul, add_zero]\n    rw [this, Gamma_ofReal, ofReal_ne_zero]\n    refine Real.Gamma_ne_zero fun n => ?_\n    specialize hs n\n    contrapose! hs\n    rwa [this, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ofReal_inj]\n  ¬∑ have : sin (‚ÜëœÄ * s) ‚â† 0 := by\n      rw [Complex.sin_ne_zero_iff]\n      intro k\n      apply_fun im\n      rw [im_ofReal_mul, ‚Üê ofReal_intCast, ‚Üê ofReal_mul, ofReal_im]\n      exact mul_ne_zero Real.pi_pos.ne' h_im\n    have A := div_ne_zero (ofReal_ne_zero.mpr Real.pi_pos.ne') this\n    rw [‚Üê Complex.Gamma_mul_Gamma_one_sub s, mul_ne_zero_iff] at A\n    exact A.1\n\n"}
{"name":"Complex.Gamma_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n‚ä¢ Iff (Eq (Complex.Gamma s) 0) (Exists fun m => Eq s (Neg.neg ‚Üëm))","decl":"theorem Gamma_eq_zero_iff (s : ‚ÑÇ) : Gamma s = 0 ‚Üî ‚àÉ m : ‚Ñï, s = -m := by\n  constructor\n  ¬∑ contrapose!; exact Gamma_ne_zero\n  ¬∑ rintro ‚ü®m, rfl‚ü©; exact Gamma_neg_nat_eq_zero m\n\n"}
{"name":"Complex.Gamma_ne_zero_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Ne (Complex.Gamma s) 0","decl":"/-- A weaker, but easier-to-apply, version of `Complex.Gamma_ne_zero`. -/\ntheorem Gamma_ne_zero_of_re_pos {s : ‚ÑÇ} (hs : 0 < re s) : Gamma s ‚â† 0 := by\n  refine Gamma_ne_zero fun m => ?_\n  contrapose! hs\n  simpa only [hs, neg_re, ‚Üê ofReal_natCast, ofReal_re, neg_nonpos] using Nat.cast_nonneg _\n\n"}
{"name":"Real.GammaSeq_tendsto_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n‚ä¢ Filter.Tendsto s.GammaSeq Filter.atTop (nhds (Real.Gamma s))","decl":"/-- Euler's limit formula for the real Gamma function. -/\ntheorem GammaSeq_tendsto_Gamma (s : ‚Ñù) : Tendsto (GammaSeq s) atTop (ùìù <| Gamma s) := by\n  suffices Tendsto ((‚Üë) ‚àò GammaSeq s : ‚Ñï ‚Üí ‚ÑÇ) atTop (ùìù <| Complex.Gamma s) by\n    exact (Complex.continuous_re.tendsto (Complex.Gamma ‚Üës)).comp this\n  convert Complex.GammaSeq_tendsto_Gamma s\n  ext1 n\n  dsimp only [GammaSeq, Function.comp_apply, Complex.GammaSeq]\n  push_cast\n  rw [Complex.ofReal_cpow n.cast_nonneg, Complex.ofReal_natCast]\n\n"}
{"name":"Real.Gamma_mul_Gamma_one_sub","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n‚ä¢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HSub.hSub 1 s))) (HDiv.hDiv Real.pi (Real.sin (HMul.hMul Real.pi s)))","decl":"/-- Euler's reflection formula for the real Gamma function. -/\ntheorem Gamma_mul_Gamma_one_sub (s : ‚Ñù) : Gamma s * Gamma (1 - s) = œÄ / sin (œÄ * s) := by\n  simp_rw [‚Üê Complex.ofReal_inj, Complex.ofReal_div, Complex.ofReal_sin, Complex.ofReal_mul, ‚Üê\n    Complex.Gamma_ofReal, Complex.ofReal_sub, Complex.ofReal_one]\n  exact Complex.Gamma_mul_Gamma_one_sub s\n\n"}
{"name":"Complex.one_div_Gamma_eq_self_mul_one_div_Gamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n‚ä¢ Eq (Inv.inv (Complex.Gamma s)) (HMul.hMul s (Inv.inv (Complex.Gamma (HAdd.hAdd s 1))))","decl":"/-- A reformulation of the Gamma recurrence relation which is true for `s = 0` as well. -/\ntheorem one_div_Gamma_eq_self_mul_one_div_Gamma_add_one (s : ‚ÑÇ) :\n    (Gamma s)‚Åª¬π = s * (Gamma (s + 1))‚Åª¬π := by\n  rcases ne_or_eq s 0 with (h | rfl)\n  ¬∑ rw [Gamma_add_one s h, mul_inv, mul_inv_cancel_left‚ÇÄ h]\n  ¬∑ rw [zero_add, Gamma_zero, inv_zero, zero_mul]\n\n"}
{"name":"Complex.differentiable_one_div_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"‚ä¢ Differentiable Complex fun s => Inv.inv (Complex.Gamma s)","decl":"/-- The reciprocal of the Gamma function is differentiable everywhere\n(including the points where Gamma itself is not). -/\ntheorem differentiable_one_div_Gamma : Differentiable ‚ÑÇ fun s : ‚ÑÇ => (Gamma s)‚Åª¬π := fun s ‚Ü¶ by\n  rcases exists_nat_gt (-s.re) with ‚ü®n, hs‚ü©\n  induction n generalizing s with\n  | zero =>\n    rw [Nat.cast_zero, neg_lt_zero] at hs\n    suffices ‚àÄ m : ‚Ñï, s ‚â† -‚Üëm from (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)\n    rintro m rfl\n    apply hs.not_le\n    simp\n  | succ n ihn =>\n    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]\n    specialize ihn (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ‚Üê Nat.cast_succ])\n    exact differentiableAt_id.mul (ihn.comp s (f := fun s => s + 1) <|\n      differentiableAt_id.add_const (1 : ‚ÑÇ))\n\n"}
{"name":"Complex.Gamma_mul_Gamma_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Complex\n‚ä¢ Eq (HMul.hMul (Complex.Gamma s) (Complex.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Complex.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) ‚ÜëReal.pi.sqrt)","decl":"theorem Gamma_mul_Gamma_add_half (s : ‚ÑÇ) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : ‚ÑÇ) ^ (1 - 2 * s) * ‚Üë(‚àöœÄ) := by\n  suffices (fun z => (Gamma z)‚Åª¬π * (Gamma (z + 1 / 2))‚Åª¬π) = fun z =>\n      (Gamma (2 * z))‚Åª¬π * (2 : ‚ÑÇ) ^ (2 * z - 1) / ‚Üë(‚àöœÄ) by\n    convert congr_arg Inv.inv (congr_fun this s) using 1\n    ¬∑ rw [mul_inv, inv_inv, inv_inv]\n    ¬∑ rw [div_eq_mul_inv, mul_inv, mul_inv, inv_inv, inv_inv, ‚Üê cpow_neg, neg_sub]\n  have h1 : AnalyticOnNhd ‚ÑÇ (fun z : ‚ÑÇ => (Gamma z)‚Åª¬π * (Gamma (z + 1 / 2))‚Åª¬π) univ := by\n    refine DifferentiableOn.analyticOnNhd ?_ isOpen_univ\n    refine (differentiable_one_div_Gamma.mul ?_).differentiableOn\n    exact differentiable_one_div_Gamma.comp (differentiable_id.add (differentiable_const _))\n  have h2 : AnalyticOnNhd ‚ÑÇ\n      (fun z => (Gamma (2 * z))‚Åª¬π * (2 : ‚ÑÇ) ^ (2 * z - 1) / ‚Üë(‚àöœÄ)) univ := by\n    refine DifferentiableOn.analyticOnNhd ?_ isOpen_univ\n    refine (Differentiable.mul ?_ (differentiable_const _)).differentiableOn\n    apply Differentiable.mul\n    ¬∑ exact differentiable_one_div_Gamma.comp (differentiable_id'.const_mul _)\n    ¬∑ refine fun t => DifferentiableAt.const_cpow ?_ (Or.inl two_ne_zero)\n      exact DifferentiableAt.sub_const (differentiableAt_id.const_mul _) _\n  have h3 : Tendsto ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) (ùìù[‚â†] 1) (ùìù[‚â†] 1) := by\n    rw [tendsto_nhdsWithin_iff]; constructor\n    ¬∑ exact tendsto_nhdsWithin_of_tendsto_nhds continuous_ofReal.continuousAt\n    ¬∑ exact eventually_nhdsWithin_iff.mpr (Eventually.of_forall fun t ht => ofReal_ne_one.mpr ht)\n  refine AnalyticOnNhd.eq_of_frequently_eq h1 h2 (h3.frequently ?_)\n  refine ((Eventually.filter_mono nhdsWithin_le_nhds) ?_).frequently\n  refine (eventually_gt_nhds zero_lt_one).mp (Eventually.of_forall fun t ht => ?_)\n  rw [‚Üê mul_inv, Gamma_ofReal, (by norm_num : (t : ‚ÑÇ) + 1 / 2 = ‚Üë(t + 1 / 2)), Gamma_ofReal, ‚Üê\n    ofReal_mul, Gamma_mul_Gamma_add_half_of_pos ht, ofReal_mul, ofReal_mul, ‚Üê Gamma_ofReal,\n    mul_inv, mul_inv, (by norm_num : 2 * (t : ‚ÑÇ) = ‚Üë(2 * t)), Gamma_ofReal,\n    ofReal_cpow zero_le_two, show (2 : ‚Ñù) = (2 : ‚ÑÇ) by norm_cast, ‚Üê cpow_neg, ofReal_sub,\n    ofReal_one, neg_sub, ‚Üê div_eq_mul_inv]\n\n"}
{"name":"Real.Gamma_mul_Gamma_add_half","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Beta","initialProofState":"s : Real\n‚ä¢ Eq (HMul.hMul (Real.Gamma s) (Real.Gamma (HAdd.hAdd s (1 / 2)))) (HMul.hMul (HMul.hMul (Real.Gamma (HMul.hMul 2 s)) (HPow.hPow 2 (HSub.hSub 1 (HMul.hMul 2 s)))) Real.pi.sqrt)","decl":"theorem Gamma_mul_Gamma_add_half (s : ‚Ñù) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : ‚Ñù) ^ (1 - 2 * s) * ‚àöœÄ := by\n  rw [‚Üê ofReal_inj]\n  simpa only [‚Üê Gamma_ofReal, ofReal_cpow zero_le_two, ofReal_mul, ofReal_add, ofReal_div,\n    ofReal_sub] using Complex.Gamma_mul_Gamma_add_half ‚Üës\n\n"}
