{"name":"emultiplicity_eq_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Eq (emultiplicity a b) Top.top) (Not (FiniteMultiplicity a b))","decl":"@[simp]\ntheorem emultiplicity_eq_top :\n    emultiplicity a b = ⊤ ↔ ¬FiniteMultiplicity a b := by\n  simp [emultiplicity]\n\n"}
{"name":"emultiplicity_lt_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (LT.lt (emultiplicity a b) Top.top) (FiniteMultiplicity a b)","decl":"theorem emultiplicity_lt_top {a b : α} : emultiplicity a b < ⊤ ↔ FiniteMultiplicity a b := by\n  simp [lt_top_iff_ne_top, emultiplicity_eq_top]\n\n"}
{"name":"finiteMultiplicity_iff_emultiplicity_ne_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (FiniteMultiplicity a b) (Ne (emultiplicity a b) Top.top)","decl":"theorem finiteMultiplicity_iff_emultiplicity_ne_top :\n    FiniteMultiplicity a b ↔ emultiplicity a b ≠ ⊤ := by simp\n\n"}
{"name":"finite_iff_emultiplicity_ne_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (FiniteMultiplicity a b) (Ne (emultiplicity a b) Top.top)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias finite_iff_emultiplicity_ne_top := finiteMultiplicity_iff_emultiplicity_ne_top\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_ne_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\na✝ : FiniteMultiplicity a b\n⊢ Ne (emultiplicity a b) Top.top","decl":"alias ⟨FiniteMultiplicity.emultiplicity_ne_top, _⟩ := finite_iff_emultiplicity_ne_top\n\n"}
{"name":"multiplicity.Finite.emultiplicity_ne_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\na✝ : FiniteMultiplicity a b\n⊢ Ne (emultiplicity a b) Top.top","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_ne_top := FiniteMultiplicity.emultiplicity_ne_top\n\n"}
{"name":"Finite.emultiplicity_ne_top","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\na✝ : FiniteMultiplicity a b\n⊢ Ne (emultiplicity a b) Top.top","decl":"@[deprecated (since := \"2024-11-08\")]\nalias Finite.emultiplicity_ne_top := FiniteMultiplicity.emultiplicity_ne_top\n\n"}
{"name":"finiteMultiplicity_of_emultiplicity_eq_natCast","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : Eq (emultiplicity a b) ↑n\n⊢ FiniteMultiplicity a b","decl":"theorem finiteMultiplicity_of_emultiplicity_eq_natCast {n : ℕ} (h : emultiplicity a b = n) :\n    FiniteMultiplicity a b := by\n  by_contra! nh\n  rw [← emultiplicity_eq_top, h] at nh\n  trivial\n\n"}
{"name":"finite_of_emultiplicity_eq_natCast","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : Eq (emultiplicity a b) ↑n\n⊢ FiniteMultiplicity a b","decl":"@[deprecated (since := \"2024-11-30\")]\nalias finite_of_emultiplicity_eq_natCast := finiteMultiplicity_of_emultiplicity_eq_natCast\n\n"}
{"name":"multiplicity_eq_of_emultiplicity_eq_some","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : Eq (emultiplicity a b) ↑n\n⊢ Eq (multiplicity a b) n","decl":"theorem multiplicity_eq_of_emultiplicity_eq_some {n : ℕ} (h : emultiplicity a b = n) :\n    multiplicity a b = n := by\n  simp [multiplicity, h]\n  rfl\n\n"}
{"name":"emultiplicity_ne_of_multiplicity_ne","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\na✝ : Ne (multiplicity a b) n\n⊢ Ne (emultiplicity a b) ↑n","decl":"theorem emultiplicity_ne_of_multiplicity_ne {n : ℕ} :\n    multiplicity a b ≠ n → emultiplicity a b ≠ n :=\n  mt multiplicity_eq_of_emultiplicity_eq_some\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_eq_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : FiniteMultiplicity a b\n⊢ Eq (emultiplicity a b) ↑(multiplicity a b)","decl":"theorem FiniteMultiplicity.emultiplicity_eq_multiplicity (h : FiniteMultiplicity a b) :\n    emultiplicity a b = multiplicity a b := by\n  cases hm : emultiplicity a b\n  · simp [h] at hm\n  rw [multiplicity_eq_of_emultiplicity_eq_some hm]\n\n"}
{"name":"multiplicity.Finite.emultiplicity_eq_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : FiniteMultiplicity a b\n⊢ Eq (emultiplicity a b) ↑(multiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_eq_multiplicity :=\n  FiniteMultiplicity.emultiplicity_eq_multiplicity\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_eq_iff_multiplicity_eq","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : FiniteMultiplicity a b\n⊢ Iff (Eq (emultiplicity a b) ↑n) (Eq (multiplicity a b) n)","decl":"theorem FiniteMultiplicity.emultiplicity_eq_iff_multiplicity_eq {n : ℕ}\n    (h : FiniteMultiplicity a b) : emultiplicity a b = n ↔ multiplicity a b = n := by\n  simp [h.emultiplicity_eq_multiplicity]\n\n"}
{"name":"multiplicity.Finite.emultiplicity_eq_iff_multiplicity_eq","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : FiniteMultiplicity a b\n⊢ Iff (Eq (emultiplicity a b) ↑n) (Eq (multiplicity a b) n)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_eq_iff_multiplicity_eq :=\n  FiniteMultiplicity.emultiplicity_eq_iff_multiplicity_eq\n\n"}
{"name":"emultiplicity_eq_iff_multiplicity_eq_of_ne_one","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : Ne n 1\n⊢ Iff (Eq (emultiplicity a b) ↑n) (Eq (multiplicity a b) n)","decl":"theorem emultiplicity_eq_iff_multiplicity_eq_of_ne_one {n : ℕ} (h : n ≠ 1) :\n    emultiplicity a b = n ↔ multiplicity a b = n := by\n  constructor\n  · exact multiplicity_eq_of_emultiplicity_eq_some\n  · intro h₂\n    simpa [multiplicity, WithTop.untop'_eq_iff, h] using h₂\n\n"}
{"name":"emultiplicity_eq_zero_iff_multiplicity_eq_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Eq (emultiplicity a b) 0) (Eq (multiplicity a b) 0)","decl":"theorem emultiplicity_eq_zero_iff_multiplicity_eq_zero :\n    emultiplicity a b = 0 ↔ multiplicity a b = 0 :=\n  emultiplicity_eq_iff_multiplicity_eq_of_ne_one zero_ne_one\n\n"}
{"name":"multiplicity_eq_one_of_not_finiteMultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : Not (FiniteMultiplicity a b)\n⊢ Eq (multiplicity a b) 1","decl":"@[simp]\ntheorem multiplicity_eq_one_of_not_finiteMultiplicity (h : ¬FiniteMultiplicity a b) :\n    multiplicity a b = 1 := by\n  simp [multiplicity, emultiplicity_eq_top.2 h]\n\n"}
{"name":"multiplicity_eq_one_of_not_finite","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : Not (FiniteMultiplicity a b)\n⊢ Eq (multiplicity a b) 1","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity_eq_one_of_not_finite :=\n  multiplicity_eq_one_of_not_finiteMultiplicity\n\n"}
{"name":"multiplicity_le_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ LE.le (↑(multiplicity a b)) (emultiplicity a b)","decl":"@[simp]\ntheorem multiplicity_le_emultiplicity :\n    multiplicity a b ≤ emultiplicity a b := by\n  by_cases hf : FiniteMultiplicity a b\n  · simp [hf.emultiplicity_eq_multiplicity]\n  · simp [hf, emultiplicity_eq_top.2]\n\n"}
{"name":"multiplicity_eq_of_emultiplicity_eq","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na b : α\nc d : β\nh : Eq (emultiplicity a b) (emultiplicity c d)\n⊢ Eq (multiplicity a b) (multiplicity c d)","decl":"@[simp]\ntheorem multiplicity_eq_of_emultiplicity_eq {c d : β}\n    (h : emultiplicity a b = emultiplicity c d) : multiplicity a b = multiplicity c d := by\n  unfold multiplicity\n  rw [h]\n\n"}
{"name":"multiplicity_le_of_emultiplicity_le","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : LE.le (emultiplicity a b) ↑n\n⊢ LE.le (multiplicity a b) n","decl":"theorem multiplicity_le_of_emultiplicity_le {n : ℕ} (h : emultiplicity a b ≤ n) :\n    multiplicity a b ≤ n := by\n  exact_mod_cast multiplicity_le_emultiplicity.trans h\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_le_of_multiplicity_le","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LE.le (multiplicity a b) n\n⊢ LE.le (emultiplicity a b) ↑n","decl":"theorem FiniteMultiplicity.emultiplicity_le_of_multiplicity_le (hfin : FiniteMultiplicity a b)\n    {n : ℕ} (h : multiplicity a b ≤ n) : emultiplicity a b ≤ n := by\n  rw [emultiplicity_eq_multiplicity hfin]\n  assumption_mod_cast\n\n"}
{"name":"multiplicity.Finite.emultiplicity_le_of_multiplicity_le","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LE.le (multiplicity a b) n\n⊢ LE.le (emultiplicity a b) ↑n","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_le_of_multiplicity_le :=\n  FiniteMultiplicity.emultiplicity_le_of_multiplicity_le\n\n"}
{"name":"le_emultiplicity_of_le_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : LE.le n (multiplicity a b)\n⊢ LE.le (↑n) (emultiplicity a b)","decl":"theorem le_emultiplicity_of_le_multiplicity {n : ℕ} (h : n ≤ multiplicity a b) :\n    n ≤ emultiplicity a b := by\n  exact_mod_cast (WithTop.coe_mono h).trans multiplicity_le_emultiplicity\n\n"}
{"name":"FiniteMultiplicity.le_multiplicity_of_le_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LE.le (↑n) (emultiplicity a b)\n⊢ LE.le n (multiplicity a b)","decl":"theorem FiniteMultiplicity.le_multiplicity_of_le_emultiplicity (hfin : FiniteMultiplicity a b)\n    {n : ℕ} (h : n ≤ emultiplicity a b) : n ≤ multiplicity a b := by\n  rw [emultiplicity_eq_multiplicity hfin] at h\n  assumption_mod_cast\n\n"}
{"name":"multiplicity.Finite.le_multiplicity_of_le_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LE.le (↑n) (emultiplicity a b)\n⊢ LE.le n (multiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.le_multiplicity_of_le_emultiplicity :=\n  FiniteMultiplicity.le_multiplicity_of_le_emultiplicity\n\n"}
{"name":"multiplicity_lt_of_emultiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : LT.lt (emultiplicity a b) ↑n\n⊢ LT.lt (multiplicity a b) n","decl":"theorem multiplicity_lt_of_emultiplicity_lt {n : ℕ} (h : emultiplicity a b < n) :\n    multiplicity a b < n := by\n  exact_mod_cast multiplicity_le_emultiplicity.trans_lt h\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_lt_of_multiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LT.lt (multiplicity a b) n\n⊢ LT.lt (emultiplicity a b) ↑n","decl":"theorem FiniteMultiplicity.emultiplicity_lt_of_multiplicity_lt (hfin : FiniteMultiplicity a b)\n    {n : ℕ} (h : multiplicity a b < n) : emultiplicity a b < n := by\n  rw [emultiplicity_eq_multiplicity hfin]\n  assumption_mod_cast\n\n"}
{"name":"multiplicity.Finite.emultiplicity_lt_of_multiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LT.lt (multiplicity a b) n\n⊢ LT.lt (emultiplicity a b) ↑n","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_lt_of_multiplicity_lt :=\n  FiniteMultiplicity.emultiplicity_lt_of_multiplicity_lt\n\n"}
{"name":"lt_emultiplicity_of_lt_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\nh : LT.lt n (multiplicity a b)\n⊢ LT.lt (↑n) (emultiplicity a b)","decl":"theorem lt_emultiplicity_of_lt_multiplicity {n : ℕ} (h : n < multiplicity a b) :\n    n < emultiplicity a b := by\n  exact_mod_cast (WithTop.coe_strictMono h).trans_le multiplicity_le_emultiplicity\n\n"}
{"name":"FiniteMultiplicity.lt_multiplicity_of_lt_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LT.lt (↑n) (emultiplicity a b)\n⊢ LT.lt n (multiplicity a b)","decl":"theorem FiniteMultiplicity.lt_multiplicity_of_lt_emultiplicity (hfin : FiniteMultiplicity a b)\n    {n : ℕ} (h : n < emultiplicity a b) : n < multiplicity a b := by\n  rw [emultiplicity_eq_multiplicity hfin] at h\n  assumption_mod_cast\n\n"}
{"name":"multiplicity.Finite.lt_multiplicity_of_lt_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\nn : Nat\nh : LT.lt (↑n) (emultiplicity a b)\n⊢ LT.lt n (multiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.lt_multiplicity_of_lt_emultiplicity :=\n  FiniteMultiplicity.lt_multiplicity_of_lt_emultiplicity\n\n"}
{"name":"emultiplicity_pos_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (LT.lt 0 (emultiplicity a b)) (LT.lt 0 (multiplicity a b))","decl":"theorem emultiplicity_pos_iff :\n    0 < emultiplicity a b ↔ 0 < multiplicity a b := by\n  simp [pos_iff_ne_zero, pos_iff_ne_zero, emultiplicity_eq_zero_iff_multiplicity_eq_zero]\n\n"}
{"name":"FiniteMultiplicity.def","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (FiniteMultiplicity a b) (Exists fun n => Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd n 1)) b))","decl":"theorem FiniteMultiplicity.def : FiniteMultiplicity a b ↔ ∃ n : ℕ, ¬a ^ (n + 1) ∣ b :=\n  Iff.rfl\n\n"}
{"name":"multiplicity.Finite.def","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (FiniteMultiplicity a b) (Exists fun n => Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd n 1)) b))","decl":"@[deprecated (since := \"2024-11-30\")] alias multiplicity.Finite.def := FiniteMultiplicity.def\n\n"}
{"name":"FiniteMultiplicity.not_dvd_of_one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\na✝ : FiniteMultiplicity a 1\n⊢ Not (Dvd.dvd a 1)","decl":"theorem FiniteMultiplicity.not_dvd_of_one_right : FiniteMultiplicity a 1 → ¬a ∣ 1 :=\n  fun ⟨n, hn⟩ ⟨d, hd⟩ => hn ⟨d ^ (n + 1), (pow_mul_pow_eq_one (n + 1) hd.symm).symm⟩\n\n"}
{"name":"multiplicity.Finite.not_dvd_of_one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\na✝ : FiniteMultiplicity a 1\n⊢ Not (Dvd.dvd a 1)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_dvd_of_one_right := FiniteMultiplicity.not_dvd_of_one_right\n\n"}
{"name":"Int.natCast_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Nat\n⊢ Eq (emultiplicity ↑a ↑b) (emultiplicity a b)","decl":"@[norm_cast]\ntheorem Int.natCast_emultiplicity (a b : ℕ) :\n    emultiplicity (a : ℤ) (b : ℤ) = emultiplicity a b := by\n  unfold emultiplicity FiniteMultiplicity\n  congr! <;> norm_cast\n\n"}
{"name":"Int.natCast_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Nat\n⊢ Eq (multiplicity ↑a ↑b) (multiplicity a b)","decl":"@[norm_cast]\ntheorem Int.natCast_multiplicity (a b : ℕ) : multiplicity (a : ℤ) (b : ℤ) = multiplicity a b :=\n  multiplicity_eq_of_emultiplicity_eq (natCast_emultiplicity a b)\n\n"}
{"name":"FiniteMultiplicity.not_iff_forall","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Not (FiniteMultiplicity a b)) (∀ (n : Nat), Dvd.dvd (HPow.hPow a n) b)","decl":"theorem FiniteMultiplicity.not_iff_forall : ¬FiniteMultiplicity a b ↔ ∀ n : ℕ, a ^ n ∣ b :=\n  ⟨fun h n =>\n    Nat.casesOn n\n      (by\n        rw [_root_.pow_zero]\n        exact one_dvd _)\n      (by simpa [FiniteMultiplicity] using h),\n    by simp [FiniteMultiplicity, multiplicity]; tauto⟩\n\n"}
{"name":"multiplicity.Finite.not_iff_forall","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Not (FiniteMultiplicity a b)) (∀ (n : Nat), Dvd.dvd (HPow.hPow a n) b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_iff_forall := FiniteMultiplicity.not_iff_forall\n\n"}
{"name":"FiniteMultiplicity.not_unit","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : FiniteMultiplicity a b\n⊢ Not (IsUnit a)","decl":"theorem FiniteMultiplicity.not_unit (h : FiniteMultiplicity a b) : ¬IsUnit a :=\n  let ⟨n, hn⟩ := h\n  hn ∘ IsUnit.dvd ∘ IsUnit.pow (n + 1)\n\n"}
{"name":"multiplicity.Finite.not_unit","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : FiniteMultiplicity a b\n⊢ Not (IsUnit a)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_unit := FiniteMultiplicity.not_unit\n\n"}
{"name":"FiniteMultiplicity.mul_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b c : α\na✝ : FiniteMultiplicity a (HMul.hMul b c)\n⊢ FiniteMultiplicity a b","decl":"theorem FiniteMultiplicity.mul_left {c : α} :\n    FiniteMultiplicity a (b * c) → FiniteMultiplicity a b := fun ⟨n, hn⟩ =>\n  ⟨n, fun h => hn (h.trans (dvd_mul_right _ _))⟩\n\n"}
{"name":"multiplicity.Finite.mul_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b c : α\na✝ : FiniteMultiplicity a (HMul.hMul b c)\n⊢ FiniteMultiplicity a b","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.mul_left := FiniteMultiplicity.mul_left\n\n"}
{"name":"pow_dvd_of_le_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhk : LE.le (↑k) (emultiplicity a b)\n⊢ Dvd.dvd (HPow.hPow a k) b","decl":"theorem pow_dvd_of_le_emultiplicity {k : ℕ} (hk : k ≤ emultiplicity a b) :\n    a ^ k ∣ b := by classical\n  cases k\n  · simp\n  unfold emultiplicity at hk\n  split at hk\n  · norm_cast at hk\n    simpa using (Nat.find_min _ (lt_of_succ_le hk))\n  · apply FiniteMultiplicity.not_iff_forall.mp ‹_›\n\n"}
{"name":"pow_dvd_of_le_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhk : LE.le k (multiplicity a b)\n⊢ Dvd.dvd (HPow.hPow a k) b","decl":"theorem pow_dvd_of_le_multiplicity {k : ℕ} (hk : k ≤ multiplicity a b) :\n    a ^ k ∣ b := pow_dvd_of_le_emultiplicity (le_emultiplicity_of_le_multiplicity hk)\n\n"}
{"name":"pow_multiplicity_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Dvd.dvd (HPow.hPow a (multiplicity a b)) b","decl":"@[simp]\ntheorem pow_multiplicity_dvd (a b : α) : a ^ (multiplicity a b) ∣ b :=\n  pow_dvd_of_le_multiplicity le_rfl\n\n"}
{"name":"not_pow_dvd_of_emultiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nm : Nat\nhm : LT.lt (emultiplicity a b) ↑m\n⊢ Not (Dvd.dvd (HPow.hPow a m) b)","decl":"theorem not_pow_dvd_of_emultiplicity_lt {m : ℕ} (hm : emultiplicity a b < m) :\n    ¬a ^ m ∣ b := fun nh => by\n  unfold emultiplicity at hm\n  split at hm\n  · simp only [cast_lt, find_lt_iff] at hm\n    obtain ⟨n, hn1, hn2⟩ := hm\n    exact hn2 ((pow_dvd_pow _ hn1).trans nh)\n  · simp at hm\n\n"}
{"name":"FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nm : Nat\nhm : LT.lt (multiplicity a b) m\n⊢ Not (Dvd.dvd (HPow.hPow a m) b)","decl":"theorem FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt (hf : FiniteMultiplicity a b) {m : ℕ}\n    (hm : multiplicity a b < m) : ¬a ^ m ∣ b := by\n  apply not_pow_dvd_of_emultiplicity_lt\n  rw [hf.emultiplicity_eq_multiplicity]\n  norm_cast\n\n"}
{"name":"multiplicity.Finite.not_pow_dvd_of_multiplicity_lt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nm : Nat\nhm : LT.lt (multiplicity a b) m\n⊢ Not (Dvd.dvd (HPow.hPow a m) b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_pow_dvd_of_multiplicity_lt :=\n  FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt\n\n"}
{"name":"multiplicity_pos_of_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhdiv : Dvd.dvd a b\n⊢ LT.lt 0 (multiplicity a b)","decl":"theorem multiplicity_pos_of_dvd (hdiv : a ∣ b) : 0 < multiplicity a b := by\n  refine Nat.pos_iff_ne_zero.2 fun h => ?_\n  simpa [hdiv] using FiniteMultiplicity.not_pow_dvd_of_multiplicity_lt\n    (by by_contra! nh; simp [nh] at h) (lt_one_iff.mpr h)\n\n"}
{"name":"emultiplicity_pos_of_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhdiv : Dvd.dvd a b\n⊢ LT.lt 0 (emultiplicity a b)","decl":"theorem emultiplicity_pos_of_dvd (hdiv : a ∣ b) : 0 < emultiplicity a b :=\n  lt_emultiplicity_of_lt_multiplicity (multiplicity_pos_of_dvd hdiv)\n\n"}
{"name":"emultiplicity_eq_of_dvd_of_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhk : Dvd.dvd (HPow.hPow a k) b\nhsucc : Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd k 1)) b)\n⊢ Eq (emultiplicity a b) ↑k","decl":"theorem emultiplicity_eq_of_dvd_of_not_dvd {k : ℕ} (hk : a ^ k ∣ b) (hsucc : ¬a ^ (k + 1) ∣ b) :\n    emultiplicity a b = k := by classical\n  have : FiniteMultiplicity a b := ⟨k, hsucc⟩\n  simp only [emultiplicity, this, ↓reduceDIte, Nat.cast_inj, find_eq_iff, hsucc, not_false_eq_true,\n    Decidable.not_not, true_and]\n  exact fun n hn ↦ (pow_dvd_pow _ hn).trans hk\n\n"}
{"name":"multiplicity_eq_of_dvd_of_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhk : Dvd.dvd (HPow.hPow a k) b\nhsucc : Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd k 1)) b)\n⊢ Eq (multiplicity a b) k","decl":"theorem multiplicity_eq_of_dvd_of_not_dvd {k : ℕ} (hk : a ^ k ∣ b) (hsucc : ¬a ^ (k + 1) ∣ b) :\n    multiplicity a b = k :=\n  multiplicity_eq_of_emultiplicity_eq_some (emultiplicity_eq_of_dvd_of_not_dvd hk hsucc)\n\n"}
{"name":"le_emultiplicity_of_pow_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhk : Dvd.dvd (HPow.hPow a k) b\n⊢ LE.le (↑k) (emultiplicity a b)","decl":"theorem le_emultiplicity_of_pow_dvd {k : ℕ} (hk : a ^ k ∣ b) :\n    k ≤ emultiplicity a b :=\n  le_of_not_gt fun hk' => not_pow_dvd_of_emultiplicity_lt hk' hk\n\n"}
{"name":"FiniteMultiplicity.le_multiplicity_of_pow_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nk : Nat\nhk : Dvd.dvd (HPow.hPow a k) b\n⊢ LE.le k (multiplicity a b)","decl":"theorem FiniteMultiplicity.le_multiplicity_of_pow_dvd (hf : FiniteMultiplicity a b)\n    {k : ℕ} (hk : a ^ k ∣ b) : k ≤ multiplicity a b :=\n  hf.le_multiplicity_of_le_emultiplicity (le_emultiplicity_of_pow_dvd hk)\n\n"}
{"name":"multiplicity.Finite.le_multiplicity_of_pow_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nk : Nat\nhk : Dvd.dvd (HPow.hPow a k) b\n⊢ LE.le k (multiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.le_multiplicity_of_pow_dvd :=\n  FiniteMultiplicity.le_multiplicity_of_pow_dvd\n\n"}
{"name":"pow_dvd_iff_le_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow a k) b) (LE.le (↑k) (emultiplicity a b))","decl":"theorem pow_dvd_iff_le_emultiplicity {k : ℕ} :\n    a ^ k ∣ b ↔ k ≤ emultiplicity a b :=\n  ⟨le_emultiplicity_of_pow_dvd, pow_dvd_of_le_emultiplicity⟩\n\n"}
{"name":"FiniteMultiplicity.pow_dvd_iff_le_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nk : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow a k) b) (LE.le k (multiplicity a b))","decl":"theorem FiniteMultiplicity.pow_dvd_iff_le_multiplicity (hf : FiniteMultiplicity a b) {k : ℕ} :\n    a ^ k ∣ b ↔ k ≤ multiplicity a b := by\n  exact_mod_cast hf.emultiplicity_eq_multiplicity ▸ pow_dvd_iff_le_emultiplicity\n\n"}
{"name":"multiplicity.Finite.pow_dvd_iff_le_multiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nk : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow a k) b) (LE.le k (multiplicity a b))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.pow_dvd_iff_le_multiplicity :=\n  FiniteMultiplicity.pow_dvd_iff_le_multiplicity\n\n"}
{"name":"emultiplicity_lt_iff_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\n⊢ Iff (LT.lt (emultiplicity a b) ↑k) (Not (Dvd.dvd (HPow.hPow a k) b))","decl":"theorem emultiplicity_lt_iff_not_dvd {k : ℕ} :\n    emultiplicity a b < k ↔ ¬a ^ k ∣ b := by rw [pow_dvd_iff_le_emultiplicity, not_le]\n\n"}
{"name":"FiniteMultiplicity.multiplicity_lt_iff_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhf : FiniteMultiplicity a b\n⊢ Iff (LT.lt (multiplicity a b) k) (Not (Dvd.dvd (HPow.hPow a k) b))","decl":"theorem FiniteMultiplicity.multiplicity_lt_iff_not_dvd {k : ℕ} (hf : FiniteMultiplicity a b) :\n    multiplicity a b < k ↔ ¬a ^ k ∣ b := by rw [hf.pow_dvd_iff_le_multiplicity, not_le]\n\n"}
{"name":"multiplicity.Finite.multiplicity_lt_iff_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nk : Nat\nhf : FiniteMultiplicity a b\n⊢ Iff (LT.lt (multiplicity a b) k) (Not (Dvd.dvd (HPow.hPow a k) b))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.multiplicity_lt_iff_not_dvd :=\n  FiniteMultiplicity.multiplicity_lt_iff_not_dvd\n\n"}
{"name":"emultiplicity_eq_coe","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nn : Nat\n⊢ Iff (Eq (emultiplicity a b) ↑n) (And (Dvd.dvd (HPow.hPow a n) b) (Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd n 1)) b)))","decl":"theorem emultiplicity_eq_coe {n : ℕ} :\n    emultiplicity a b = n ↔ a ^ n ∣ b ∧ ¬a ^ (n + 1) ∣ b := by\n  constructor\n  · intro h\n    constructor\n    · apply pow_dvd_of_le_emultiplicity\n      simp [h]\n    · apply not_pow_dvd_of_emultiplicity_lt\n      rw [h]\n      norm_cast\n      simp\n  · rw [and_imp]\n    apply emultiplicity_eq_of_dvd_of_not_dvd\n\n"}
{"name":"FiniteMultiplicity.multiplicity_eq_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nn : Nat\n⊢ Iff (Eq (multiplicity a b) n) (And (Dvd.dvd (HPow.hPow a n) b) (Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd n 1)) b)))","decl":"theorem FiniteMultiplicity.multiplicity_eq_iff (hf : FiniteMultiplicity a b) {n : ℕ} :\n    multiplicity a b = n ↔ a ^ n ∣ b ∧ ¬a ^ (n + 1) ∣ b := by\n  simp [← emultiplicity_eq_coe, hf.emultiplicity_eq_multiplicity]\n\n"}
{"name":"emultiplicity_eq_ofNat","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (emultiplicity a b) (OfNat.ofNat n)) (And (Dvd.dvd (HPow.hPow a (OfNat.ofNat n)) b) (Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd (OfNat.ofNat n) 1)) b)))","decl":"theorem emultiplicity_eq_ofNat {a b n : ℕ} [n.AtLeastTwo] :\n    emultiplicity a b = (ofNat(n) : ℕ∞) ↔ a ^ ofNat(n) ∣ b ∧ ¬a ^ (ofNat(n) + 1) ∣ b :=\n  emultiplicity_eq_coe\n\n"}
{"name":"multiplicity.Finite.multiplicity_eq_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhf : FiniteMultiplicity a b\nn : Nat\n⊢ Iff (Eq (multiplicity a b) n) (And (Dvd.dvd (HPow.hPow a n) b) (Not (Dvd.dvd (HPow.hPow a (HAdd.hAdd n 1)) b)))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.multiplicity_eq_iff := FiniteMultiplicity.multiplicity_eq_iff\n\n"}
{"name":"FiniteMultiplicity.not_of_isUnit_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nha : IsUnit a\n⊢ Not (FiniteMultiplicity a b)","decl":"@[simp]\ntheorem FiniteMultiplicity.not_of_isUnit_left (b : α) (ha : IsUnit a) : ¬FiniteMultiplicity a b :=\n  (·.not_unit ha)\n\n"}
{"name":"multiplicity.Finite.not_of_isUnit_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nha : IsUnit a\n⊢ Not (FiniteMultiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_of_isUnit_left := FiniteMultiplicity.not_of_isUnit_left\n\n"}
{"name":"FiniteMultiplicity.not_of_one_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nb : α\n⊢ Not (FiniteMultiplicity 1 b)","decl":"theorem FiniteMultiplicity.not_of_one_left (b : α) : ¬ FiniteMultiplicity 1 b := by simp\n\n"}
{"name":"multiplicity.Finite.not_of_one_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nb : α\n⊢ Not (FiniteMultiplicity 1 b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_of_one_left := FiniteMultiplicity.not_of_one_left\n\n"}
{"name":"emultiplicity_one_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nb : α\n⊢ Eq (emultiplicity 1 b) Top.top","decl":"@[simp]\ntheorem emultiplicity_one_left (b : α) : emultiplicity 1 b = ⊤ :=\n  emultiplicity_eq_top.2 (FiniteMultiplicity.not_of_one_left _)\n\n"}
{"name":"FiniteMultiplicity.one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nha : FiniteMultiplicity a 1\n⊢ Eq (multiplicity a 1) 0","decl":"@[simp]\ntheorem FiniteMultiplicity.one_right (ha : FiniteMultiplicity a 1) : multiplicity a 1 = 0 := by\n  simp [ha.multiplicity_eq_iff, ha.not_dvd_of_one_right]\n\n"}
{"name":"multiplicity.Finite.one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nha : FiniteMultiplicity a 1\n⊢ Eq (multiplicity a 1) 0","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.one_right := FiniteMultiplicity.one_right\n\n"}
{"name":"FiniteMultiplicity.not_of_unit_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Not (FiniteMultiplicity (↑u) a)","decl":"theorem FiniteMultiplicity.not_of_unit_left (a : α) (u : αˣ) : ¬ FiniteMultiplicity (u : α) a :=\n  FiniteMultiplicity.not_of_isUnit_left a u.isUnit\n\n"}
{"name":"multiplicity.Finite.not_of_unit_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nu : Units α\n⊢ Not (FiniteMultiplicity (↑u) a)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.not_of_unit_left := FiniteMultiplicity.not_of_unit_left\n\n"}
{"name":"emultiplicity_eq_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Eq (emultiplicity a b) 0) (Not (Dvd.dvd a b))","decl":"theorem emultiplicity_eq_zero :\n    emultiplicity a b = 0 ↔ ¬a ∣ b := by\n  by_cases hf : FiniteMultiplicity a b\n  · rw [← ENat.coe_zero, emultiplicity_eq_coe]\n    simp\n  · simpa [emultiplicity_eq_top.2 hf] using FiniteMultiplicity.not_iff_forall.1 hf 1\n\n"}
{"name":"multiplicity_eq_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Eq (multiplicity a b) 0) (Not (Dvd.dvd a b))","decl":"theorem multiplicity_eq_zero :\n    multiplicity a b = 0 ↔ ¬a ∣ b :=\n  (emultiplicity_eq_iff_multiplicity_eq_of_ne_one zero_ne_one).symm.trans emultiplicity_eq_zero\n\n"}
{"name":"emultiplicity_ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Ne (emultiplicity a b) 0) (Dvd.dvd a b)","decl":"theorem emultiplicity_ne_zero :\n    emultiplicity a b ≠ 0 ↔ a ∣ b := by\n  simp [emultiplicity_eq_zero]\n\n"}
{"name":"multiplicity_ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (Ne (multiplicity a b) 0) (Dvd.dvd a b)","decl":"theorem multiplicity_ne_zero :\n    multiplicity a b ≠ 0 ↔ a ∣ b := by\n  simp [multiplicity_eq_zero]\n\n"}
{"name":"FiniteMultiplicity.exists_eq_pow_mul_and_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\n⊢ Exists fun c => And (Eq b (HMul.hMul (HPow.hPow a (multiplicity a b)) c)) (Not (Dvd.dvd a c))","decl":"theorem FiniteMultiplicity.exists_eq_pow_mul_and_not_dvd (hfin : FiniteMultiplicity a b) :\n    ∃ c : α, b = a ^ multiplicity a b * c ∧ ¬a ∣ c := by\n  obtain ⟨c, hc⟩ := pow_multiplicity_dvd a b\n  refine ⟨c, hc, ?_⟩\n  rintro ⟨k, hk⟩\n  rw [hk, ← mul_assoc, ← _root_.pow_succ] at hc\n  have h₁ : a ^ (multiplicity a b + 1) ∣ b := ⟨k, hc⟩\n  exact (hfin.multiplicity_eq_iff.1 (by simp)).2 h₁\n\n"}
{"name":"multiplicity.Finite.exists_eq_pow_mul_and_not_dvd","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhfin : FiniteMultiplicity a b\n⊢ Exists fun c => And (Eq b (HMul.hMul (HPow.hPow a (multiplicity a b)) c)) (Not (Dvd.dvd a c))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.exists_eq_pow_mul_and_not_dvd :=\n  FiniteMultiplicity.exists_eq_pow_mul_and_not_dvd\n\n"}
{"name":"emultiplicity_le_emultiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na b : α\nc d : β\n⊢ Iff (LE.le (emultiplicity a b) (emultiplicity c d)) (∀ (n : Nat), Dvd.dvd (HPow.hPow a n) b → Dvd.dvd (HPow.hPow c n) d)","decl":"theorem emultiplicity_le_emultiplicity_iff {c d : β} :\n    emultiplicity a b ≤ emultiplicity c d ↔ ∀ n : ℕ, a ^ n ∣ b → c ^ n ∣ d := by classical\n  constructor\n  · exact fun h n hab ↦ pow_dvd_of_le_emultiplicity (le_trans (le_emultiplicity_of_pow_dvd hab) h)\n  · intro h\n    unfold emultiplicity\n    -- aesop? says\n    split\n    next h_1 =>\n      obtain ⟨w, h_1⟩ := h_1\n      split\n      next h_2 =>\n        simp_all only [cast_le, le_find_iff, lt_find_iff, Decidable.not_not, le_refl,\n          not_true_eq_false, not_false_eq_true, implies_true]\n      next h_2 => simp_all only [not_exists, Decidable.not_not, le_top]\n    next h_1 =>\n      simp_all only [not_exists, Decidable.not_not, not_true_eq_false, top_le_iff,\n        dite_eq_right_iff, ENat.coe_ne_top, imp_false, not_false_eq_true, implies_true]\n\n"}
{"name":"FiniteMultiplicity.multiplicity_le_multiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na b : α\nc d : β\nhab : FiniteMultiplicity a b\nhcd : FiniteMultiplicity c d\n⊢ Iff (LE.le (multiplicity a b) (multiplicity c d)) (∀ (n : Nat), Dvd.dvd (HPow.hPow a n) b → Dvd.dvd (HPow.hPow c n) d)","decl":"theorem FiniteMultiplicity.multiplicity_le_multiplicity_iff {c d : β} (hab : FiniteMultiplicity a b)\n    (hcd : FiniteMultiplicity c d) :\n    multiplicity a b ≤ multiplicity c d ↔ ∀ n : ℕ, a ^ n ∣ b → c ^ n ∣ d := by\n  rw [← WithTop.coe_le_coe, ENat.some_eq_coe, ← hab.emultiplicity_eq_multiplicity,\n    ← hcd.emultiplicity_eq_multiplicity]\n  apply emultiplicity_le_emultiplicity_iff\n\n"}
{"name":"multiplicity.Finite.multiplicity_le_multiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na b : α\nc d : β\nhab : FiniteMultiplicity a b\nhcd : FiniteMultiplicity c d\n⊢ Iff (LE.le (multiplicity a b) (multiplicity c d)) (∀ (n : Nat), Dvd.dvd (HPow.hPow a n) b → Dvd.dvd (HPow.hPow c n) d)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.multiplicity_le_multiplicity_iff :=\n  FiniteMultiplicity.multiplicity_le_multiplicity_iff\n\n"}
{"name":"emultiplicity_eq_emultiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na b : α\nc d : β\n⊢ Iff (Eq (emultiplicity a b) (emultiplicity c d)) (∀ (n : Nat), Iff (Dvd.dvd (HPow.hPow a n) b) (Dvd.dvd (HPow.hPow c n) d))","decl":"theorem emultiplicity_eq_emultiplicity_iff {c d : β} :\n    emultiplicity a b = emultiplicity c d ↔ ∀ n : ℕ, a ^ n ∣ b ↔ c ^ n ∣ d :=\n  ⟨fun h n =>\n    ⟨emultiplicity_le_emultiplicity_iff.1 h.le n, emultiplicity_le_emultiplicity_iff.1 h.ge n⟩,\n    fun h => le_antisymm (emultiplicity_le_emultiplicity_iff.2 fun n => (h n).mp)\n      (emultiplicity_le_emultiplicity_iff.2 fun n => (h n).mpr)⟩\n\n"}
{"name":"le_emultiplicity_map","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Monoid α\ninst✝² : Monoid β\nF : Type u_3\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\na b : α\n⊢ LE.le (emultiplicity a b) (emultiplicity (f a) (f b))","decl":"theorem le_emultiplicity_map {F : Type*} [FunLike F α β] [MonoidHomClass F α β]\n    (f : F) {a b : α} :\n    emultiplicity a b ≤ emultiplicity (f a) (f b) :=\n  emultiplicity_le_emultiplicity_iff.2 fun n ↦ by rw [← map_pow]; exact map_dvd f\n\n"}
{"name":"emultiplicity_map_eq","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Monoid α\ninst✝² : Monoid β\nF : Type u_3\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\nf : F\na b : α\n⊢ Eq (emultiplicity (f a) (f b)) (emultiplicity a b)","decl":"theorem emultiplicity_map_eq {F : Type*} [EquivLike F α β] [MulEquivClass F α β]\n    (f : F) {a b : α} : emultiplicity (f a) (f b) = emultiplicity a b := by\n  simp [emultiplicity_eq_emultiplicity_iff, ← map_pow, map_dvd_iff]\n\n"}
{"name":"multiplicity_map_eq","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Monoid α\ninst✝² : Monoid β\nF : Type u_3\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\nf : F\na b : α\n⊢ Eq (multiplicity (f a) (f b)) (multiplicity a b)","decl":"theorem multiplicity_map_eq {F : Type*} [EquivLike F α β] [MulEquivClass F α β]\n    (f : F) {a b : α} : multiplicity (f a) (f b) = multiplicity a b :=\n  multiplicity_eq_of_emultiplicity_eq (emultiplicity_map_eq f)\n\n"}
{"name":"emultiplicity_le_emultiplicity_of_dvd_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b c : α\nh : Dvd.dvd b c\n⊢ LE.le (emultiplicity a b) (emultiplicity a c)","decl":"theorem emultiplicity_le_emultiplicity_of_dvd_right {a b c : α} (h : b ∣ c) :\n    emultiplicity a b ≤ emultiplicity a c :=\n  emultiplicity_le_emultiplicity_iff.2 fun _ hb => hb.trans h\n\n"}
{"name":"emultiplicity_eq_of_associated_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b c : α\nh : Associated b c\n⊢ Eq (emultiplicity a b) (emultiplicity a c)","decl":"theorem emultiplicity_eq_of_associated_right {a b c : α} (h : Associated b c) :\n    emultiplicity a b = emultiplicity a c :=\n  le_antisymm (emultiplicity_le_emultiplicity_of_dvd_right h.dvd)\n    (emultiplicity_le_emultiplicity_of_dvd_right h.symm.dvd)\n\n"}
{"name":"multiplicity_eq_of_associated_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b c : α\nh : Associated b c\n⊢ Eq (multiplicity a b) (multiplicity a c)","decl":"theorem multiplicity_eq_of_associated_right {a b c : α} (h : Associated b c) :\n    multiplicity a b = multiplicity a c :=\n  multiplicity_eq_of_emultiplicity_eq (emultiplicity_eq_of_associated_right h)\n\n"}
{"name":"dvd_of_emultiplicity_pos","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : LT.lt 0 (emultiplicity a b)\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_emultiplicity_pos {a b : α} (h : 0 < emultiplicity a b) : a ∣ b :=\n  pow_one a ▸ pow_dvd_of_le_emultiplicity (Order.add_one_le_of_lt h)\n\n"}
{"name":"dvd_of_multiplicity_pos","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : LT.lt 0 (multiplicity a b)\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_multiplicity_pos {a b : α} (h : 0 < multiplicity a b) : a ∣ b :=\n  dvd_of_emultiplicity_pos (lt_emultiplicity_of_lt_multiplicity h)\n\n"}
{"name":"dvd_iff_multiplicity_pos","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (LT.lt 0 (multiplicity a b)) (Dvd.dvd a b)","decl":"theorem dvd_iff_multiplicity_pos {a b : α} : 0 < multiplicity a b ↔ a ∣ b :=\n  ⟨dvd_of_multiplicity_pos, fun hdvd => Nat.pos_of_ne_zero (by simpa [multiplicity_eq_zero])⟩\n\n"}
{"name":"dvd_iff_emultiplicity_pos","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\n⊢ Iff (LT.lt 0 (emultiplicity a b)) (Dvd.dvd a b)","decl":"theorem dvd_iff_emultiplicity_pos {a b : α} : 0 < emultiplicity a b ↔ a ∣ b :=\n  emultiplicity_pos_iff.trans dvd_iff_multiplicity_pos\n\n"}
{"name":"Nat.finiteMultiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Nat\n⊢ Iff (FiniteMultiplicity a b) (And (Ne a 1) (LT.lt 0 b))","decl":"theorem Nat.finiteMultiplicity_iff {a b : ℕ} : FiniteMultiplicity a b ↔ a ≠ 1 ∧ 0 < b := by\n  rw [← not_iff_not, FiniteMultiplicity.not_iff_forall, not_and_or, not_ne_iff, not_lt,\n    Nat.le_zero]\n  exact\n    ⟨fun h =>\n      or_iff_not_imp_right.2 fun hb =>\n        have ha : a ≠ 0 := fun ha => hb <| zero_dvd_iff.mp <| by rw [ha] at h; exact h 1\n        Classical.by_contradiction fun ha1 : a ≠ 1 =>\n          have ha_gt_one : 1 < a :=\n            lt_of_not_ge fun _ =>\n              match a with\n              | 0 => ha rfl\n              | 1 => ha1 rfl\n              | b+2 => by omega\n          not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero hb) (h b)) (b.lt_pow_self ha_gt_one),\n      fun h => by cases h <;> simp [*]⟩\n\n"}
{"name":"Nat.multiplicity_finite_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Nat\n⊢ Iff (FiniteMultiplicity a b) (And (Ne a 1) (LT.lt 0 b))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias Nat.multiplicity_finite_iff := Nat.finiteMultiplicity_iff\n\n"}
{"name":"Dvd.multiplicity_pos","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\na✝ : Dvd.dvd a b\n⊢ LT.lt 0 (multiplicity a b)","decl":"alias ⟨_, Dvd.multiplicity_pos⟩ := dvd_iff_multiplicity_pos\n\n"}
{"name":"FiniteMultiplicity.mul_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b c : α\nhf : FiniteMultiplicity a (HMul.hMul b c)\n⊢ FiniteMultiplicity a c","decl":"theorem FiniteMultiplicity.mul_right {a b c : α} (hf : FiniteMultiplicity a (b * c)) :\n    FiniteMultiplicity a c := (mul_comm b c ▸ hf).mul_left\n\n"}
{"name":"multiplicity.Finite.mul_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b c : α\nhf : FiniteMultiplicity a (HMul.hMul b c)\n⊢ FiniteMultiplicity a c","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.mul_right := FiniteMultiplicity.mul_right\n\n"}
{"name":"emultiplicity_of_isUnit_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\nha : Not (IsUnit a)\nhb : IsUnit b\n⊢ Eq (emultiplicity a b) 0","decl":"theorem emultiplicity_of_isUnit_right {a b : α} (ha : ¬IsUnit a)\n    (hb : IsUnit b) : emultiplicity a b = 0 :=\n  emultiplicity_eq_zero.mpr fun h ↦ ha (isUnit_of_dvd_unit h hb)\n\n"}
{"name":"multiplicity_of_isUnit_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\nha : Not (IsUnit a)\nhb : IsUnit b\n⊢ Eq (multiplicity a b) 0","decl":"theorem multiplicity_of_isUnit_right {a b : α} (ha : ¬IsUnit a)\n    (hb : IsUnit b) : multiplicity a b = 0 :=\n  multiplicity_eq_zero.mpr fun h ↦ ha (isUnit_of_dvd_unit h hb)\n\n"}
{"name":"emultiplicity_of_one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na : α\nha : Not (IsUnit a)\n⊢ Eq (emultiplicity a 1) 0","decl":"theorem emultiplicity_of_one_right {a : α} (ha : ¬IsUnit a) : emultiplicity a 1 = 0 :=\n  emultiplicity_of_isUnit_right ha isUnit_one\n\n"}
{"name":"multiplicity_of_one_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na : α\nha : Not (IsUnit a)\n⊢ Eq (multiplicity a 1) 0","decl":"theorem multiplicity_of_one_right {a : α} (ha : ¬IsUnit a) : multiplicity a 1 = 0 :=\n  multiplicity_of_isUnit_right ha isUnit_one\n\n"}
{"name":"emultiplicity_of_unit_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na : α\nha : Not (IsUnit a)\nu : Units α\n⊢ Eq (emultiplicity a ↑u) 0","decl":"theorem emultiplicity_of_unit_right {a : α} (ha : ¬IsUnit a) (u : αˣ) : emultiplicity a u = 0 :=\n  emultiplicity_of_isUnit_right ha u.isUnit\n\n"}
{"name":"multiplicity_of_unit_right","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na : α\nha : Not (IsUnit a)\nu : Units α\n⊢ Eq (multiplicity a ↑u) 0","decl":"theorem multiplicity_of_unit_right {a : α} (ha : ¬IsUnit a) (u : αˣ) : multiplicity a u = 0 :=\n  multiplicity_of_isUnit_right ha u.isUnit\n\n"}
{"name":"emultiplicity_le_emultiplicity_of_dvd_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b c : α\nhdvd : Dvd.dvd a b\n⊢ LE.le (emultiplicity b c) (emultiplicity a c)","decl":"theorem emultiplicity_le_emultiplicity_of_dvd_left {a b c : α} (hdvd : a ∣ b) :\n    emultiplicity b c ≤ emultiplicity a c :=\n  emultiplicity_le_emultiplicity_iff.2 fun n h => (pow_dvd_pow_of_dvd hdvd n).trans h\n\n"}
{"name":"emultiplicity_eq_of_associated_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b c : α\nh : Associated a b\n⊢ Eq (emultiplicity b c) (emultiplicity a c)","decl":"theorem emultiplicity_eq_of_associated_left {a b c : α} (h : Associated a b) :\n    emultiplicity b c = emultiplicity a c :=\n  le_antisymm (emultiplicity_le_emultiplicity_of_dvd_left h.dvd)\n    (emultiplicity_le_emultiplicity_of_dvd_left h.symm.dvd)\n\n"}
{"name":"multiplicity_eq_of_associated_left","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b c : α\nh : Associated a b\n⊢ Eq (multiplicity b c) (multiplicity a c)","decl":"theorem multiplicity_eq_of_associated_left {a b c : α} (h : Associated a b) :\n    multiplicity b c = multiplicity a c :=\n  multiplicity_eq_of_emultiplicity_eq (emultiplicity_eq_of_associated_left h)\n\n"}
{"name":"emultiplicity_mk_eq_emultiplicity","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\n⊢ Eq (emultiplicity (Associates.mk a) (Associates.mk b)) (emultiplicity a b)","decl":"theorem emultiplicity_mk_eq_emultiplicity {a b : α} :\n    emultiplicity (Associates.mk a) (Associates.mk b) = emultiplicity a b := by\n  simp [emultiplicity_eq_emultiplicity_iff, ← Associates.mk_pow, Associates.mk_dvd_mk]\n\n"}
{"name":"FiniteMultiplicity.ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\na b : α\nh : FiniteMultiplicity a b\n⊢ Ne b 0","decl":"theorem FiniteMultiplicity.ne_zero {a b : α} (h : FiniteMultiplicity a b) : b ≠ 0 :=\n  let ⟨n, hn⟩ := h\n  fun hb => by simp [hb] at hn\n\n"}
{"name":"multiplicity.Finite.ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\na b : α\nh : FiniteMultiplicity a b\n⊢ Ne b 0","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.ne_zero := FiniteMultiplicity.ne_zero\n\n"}
{"name":"emultiplicity_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\na : α\n⊢ Eq (emultiplicity a 0) Top.top","decl":"@[simp]\ntheorem emultiplicity_zero (a : α) : emultiplicity a 0 = ⊤ :=\n  emultiplicity_eq_top.2 (fun v ↦ v.ne_zero rfl)\n\n"}
{"name":"emultiplicity_zero_eq_zero_of_ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\na : α\nha : Ne a 0\n⊢ Eq (emultiplicity 0 a) 0","decl":"@[simp]\ntheorem emultiplicity_zero_eq_zero_of_ne_zero (a : α) (ha : a ≠ 0) : emultiplicity 0 a = 0 :=\n  emultiplicity_eq_zero.2 <| mt zero_dvd_iff.1 ha\n\n"}
{"name":"multiplicity_zero_eq_zero_of_ne_zero","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\na : α\nha : Ne a 0\n⊢ Eq (multiplicity 0 a) 0","decl":"@[simp]\ntheorem multiplicity_zero_eq_zero_of_ne_zero (a : α) (ha : a ≠ 0) : multiplicity 0 a = 0 :=\n  multiplicity_eq_zero.2 <| mt zero_dvd_iff.1 ha\n\n"}
{"name":"FiniteMultiplicity.or_of_add","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Semiring α\np a b : α\nhf : FiniteMultiplicity p (HAdd.hAdd a b)\n⊢ Or (FiniteMultiplicity p a) (FiniteMultiplicity p b)","decl":"theorem FiniteMultiplicity.or_of_add {p a b : α} (hf : FiniteMultiplicity p (a + b)) :\n    FiniteMultiplicity p a ∨ FiniteMultiplicity p b := by\n  by_contra! nh\n  obtain ⟨c, hc⟩ := hf\n  simp_all [dvd_add]\n\n"}
{"name":"multiplicity.Finite.or_of_add","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Semiring α\np a b : α\nhf : FiniteMultiplicity p (HAdd.hAdd a b)\n⊢ Or (FiniteMultiplicity p a) (FiniteMultiplicity p b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.or_of_add := FiniteMultiplicity.or_of_add\n\n"}
{"name":"min_le_emultiplicity_add","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Semiring α\np a b : α\n⊢ LE.le (Min.min (emultiplicity p a) (emultiplicity p b)) (emultiplicity p (HAdd.hAdd a b))","decl":"theorem min_le_emultiplicity_add {p a b : α} :\n    min (emultiplicity p a) (emultiplicity p b) ≤ emultiplicity p (a + b) := by\n  cases hm : min (emultiplicity p a) (emultiplicity p b)\n  · simp only [top_le_iff, min_eq_top, emultiplicity_eq_top] at hm ⊢\n    contrapose hm\n    simp only [not_and_or, not_not] at hm ⊢\n    exact hm.or_of_add\n  · apply le_emultiplicity_of_pow_dvd\n    simp [dvd_add, pow_dvd_of_le_emultiplicity, ← hm]\n\n"}
{"name":"FiniteMultiplicity.neg_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (FiniteMultiplicity a (Neg.neg b)) (FiniteMultiplicity a b)","decl":"@[simp]\ntheorem FiniteMultiplicity.neg_iff {a b : α} :\n    FiniteMultiplicity a (-b) ↔ FiniteMultiplicity a b := by\n  unfold FiniteMultiplicity\n  congr! 3\n  simp only [dvd_neg]\n\n"}
{"name":"multiplicity.Finite.neg_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (FiniteMultiplicity a (Neg.neg b)) (FiniteMultiplicity a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.neg_iff := FiniteMultiplicity.neg_iff\n\n"}
{"name":"FiniteMultiplicity.neg","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\na✝ : FiniteMultiplicity a b\n⊢ FiniteMultiplicity a (Neg.neg b)","decl":"alias ⟨_, FiniteMultiplicity.neg⟩ := FiniteMultiplicity.neg_iff\n\n"}
{"name":"multiplicity.Finite.neg","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\na✝ : FiniteMultiplicity a b\n⊢ FiniteMultiplicity a (Neg.neg b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.neg := FiniteMultiplicity.neg\n\n"}
{"name":"emultiplicity_neg","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Eq (emultiplicity a (Neg.neg b)) (emultiplicity a b)","decl":"@[simp]\ntheorem emultiplicity_neg (a b : α) : emultiplicity a (-b) = emultiplicity a b := by\n  rw [emultiplicity_eq_emultiplicity_iff]\n  simp\n\n"}
{"name":"multiplicity_neg","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Eq (multiplicity a (Neg.neg b)) (multiplicity a b)","decl":"@[simp]\ntheorem multiplicity_neg (a b : α) : multiplicity a (-b) = multiplicity a b :=\n  multiplicity_eq_of_emultiplicity_eq (emultiplicity_neg a b)\n\n"}
{"name":"Int.emultiplicity_natAbs","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a : Nat\nb : Int\n⊢ Eq (emultiplicity a b.natAbs) (emultiplicity (↑a) b)","decl":"theorem Int.emultiplicity_natAbs (a : ℕ) (b : ℤ) :\n    emultiplicity a b.natAbs = emultiplicity (a : ℤ) b := by\n  cases' Int.natAbs_eq b with h h <;> conv_rhs => rw [h]\n  · rw [Int.natCast_emultiplicity]\n  · rw [emultiplicity_neg, Int.natCast_emultiplicity]\n\n"}
{"name":"Int.multiplicity_natAbs","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a : Nat\nb : Int\n⊢ Eq (multiplicity a b.natAbs) (multiplicity (↑a) b)","decl":"theorem Int.multiplicity_natAbs (a : ℕ) (b : ℤ) :\n    multiplicity a b.natAbs = multiplicity (a : ℤ) b :=\n  multiplicity_eq_of_emultiplicity_eq (Int.emultiplicity_natAbs a b)\n\n"}
{"name":"emultiplicity_add_of_gt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nh : LT.lt (emultiplicity p b) (emultiplicity p a)\n⊢ Eq (emultiplicity p (HAdd.hAdd a b)) (emultiplicity p b)","decl":"theorem emultiplicity_add_of_gt {p a b : α} (h : emultiplicity p b < emultiplicity p a) :\n    emultiplicity p (a + b) = emultiplicity p b := by\n  have : FiniteMultiplicity p b := finiteMultiplicity_iff_emultiplicity_ne_top.2 (by simp [·] at h)\n  rw [this.emultiplicity_eq_multiplicity] at *\n  apply emultiplicity_eq_of_dvd_of_not_dvd\n  · apply dvd_add\n    · apply pow_dvd_of_le_emultiplicity\n      exact h.le\n    · simp\n  · rw [dvd_add_right]\n    · apply this.not_pow_dvd_of_multiplicity_lt\n      simp\n    apply pow_dvd_of_le_emultiplicity\n    exact Order.add_one_le_of_lt h\n\n"}
{"name":"FiniteMultiplicity.multiplicity_add_of_gt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nhf : FiniteMultiplicity p b\nh : LT.lt (multiplicity p b) (multiplicity p a)\n⊢ Eq (multiplicity p (HAdd.hAdd a b)) (multiplicity p b)","decl":"theorem FiniteMultiplicity.multiplicity_add_of_gt {p a b : α} (hf : FiniteMultiplicity p b)\n    (h : multiplicity p b < multiplicity p a) :\n    multiplicity p (a + b) = multiplicity p b :=\n  multiplicity_eq_of_emultiplicity_eq <| emultiplicity_add_of_gt (hf.emultiplicity_eq_multiplicity ▸\n      (WithTop.coe_strictMono h).trans_le multiplicity_le_emultiplicity)\n\n"}
{"name":"multiplicity.Finite.multiplicity_add_of_gt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nhf : FiniteMultiplicity p b\nh : LT.lt (multiplicity p b) (multiplicity p a)\n⊢ Eq (multiplicity p (HAdd.hAdd a b)) (multiplicity p b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.multiplicity_add_of_gt := FiniteMultiplicity.multiplicity_add_of_gt\n\n"}
{"name":"emultiplicity_sub_of_gt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nh : LT.lt (emultiplicity p b) (emultiplicity p a)\n⊢ Eq (emultiplicity p (HSub.hSub a b)) (emultiplicity p b)","decl":"theorem emultiplicity_sub_of_gt {p a b : α} (h : emultiplicity p b < emultiplicity p a) :\n    emultiplicity p (a - b) = emultiplicity p b := by\n  rw [sub_eq_add_neg, emultiplicity_add_of_gt] <;> rw [emultiplicity_neg]; assumption\n\n"}
{"name":"multiplicity_sub_of_gt","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nh : LT.lt (multiplicity p b) (multiplicity p a)\nhfin : FiniteMultiplicity p b\n⊢ Eq (multiplicity p (HSub.hSub a b)) (multiplicity p b)","decl":"theorem multiplicity_sub_of_gt {p a b : α} (h : multiplicity p b < multiplicity p a)\n    (hfin : FiniteMultiplicity p b) : multiplicity p (a - b) = multiplicity p b := by\n  rw [sub_eq_add_neg, hfin.neg.multiplicity_add_of_gt] <;> rw [multiplicity_neg]; assumption\n\n"}
{"name":"emultiplicity_add_eq_min","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nh : Ne (emultiplicity p a) (emultiplicity p b)\n⊢ Eq (emultiplicity p (HAdd.hAdd a b)) (Min.min (emultiplicity p a) (emultiplicity p b))","decl":"theorem emultiplicity_add_eq_min {p a b : α}\n    (h : emultiplicity p a ≠ emultiplicity p b) :\n    emultiplicity p (a + b) = min (emultiplicity p a) (emultiplicity p b) := by\n  rcases lt_trichotomy (emultiplicity p a) (emultiplicity p b) with (hab | _ | hab)\n  · rw [add_comm, emultiplicity_add_of_gt hab, min_eq_left]\n    exact le_of_lt hab\n  · contradiction\n  · rw [emultiplicity_add_of_gt hab, min_eq_right]\n    exact le_of_lt hab\n\n"}
{"name":"multiplicity_add_eq_min","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : Ring α\np a b : α\nha : FiniteMultiplicity p a\nhb : FiniteMultiplicity p b\nh : Ne (multiplicity p a) (multiplicity p b)\n⊢ Eq (multiplicity p (HAdd.hAdd a b)) (Min.min (multiplicity p a) (multiplicity p b))","decl":"theorem multiplicity_add_eq_min {p a b : α} (ha : FiniteMultiplicity p a)\n    (hb : FiniteMultiplicity p b) (h : multiplicity p a ≠ multiplicity p b) :\n    multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b) := by\n  rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with (hab | _ | hab)\n  · rw [add_comm, ha.multiplicity_add_of_gt hab, min_eq_left]\n    exact le_of_lt hab\n  · contradiction\n  · rw [hb.multiplicity_add_of_gt hab, min_eq_right]\n    exact le_of_lt hab\n\n"}
{"name":"finiteMultiplicity_mul_aux","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nhp : Prime p\na b : α\nn m : Nat\na✝¹ : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) a)\na✝ : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd m 1)) b)\n⊢ Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd (HAdd.hAdd n m) 1)) (HMul.hMul a b))","decl":"theorem finiteMultiplicity_mul_aux {p : α} (hp : Prime p) {a b : α} :\n    ∀ {n m : ℕ}, ¬p ^ (n + 1) ∣ a → ¬p ^ (m + 1) ∣ b → ¬p ^ (n + m + 1) ∣ a * b\n  | n, m => fun ha hb ⟨s, hs⟩ =>\n    have : p ∣ a * b := ⟨p ^ (n + m) * s, by simp [hs, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩\n    (hp.2.2 a b this).elim\n      (fun ⟨x, hx⟩ =>\n        have hn0 : 0 < n :=\n          Nat.pos_of_ne_zero fun hn0 => by simp [hx, hn0] at ha\n        have hpx : ¬p ^ (n - 1 + 1) ∣ x := fun ⟨y, hy⟩ =>\n          ha (hx.symm ▸ ⟨y, mul_right_cancel₀ hp.1 <| by\n            rw [tsub_add_cancel_of_le (succ_le_of_lt hn0)] at hy\n            simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩)\n        have : 1 ≤ n + m := le_trans hn0 (Nat.le_add_right n m)\n        finiteMultiplicity_mul_aux hp hpx hb\n          ⟨s, mul_right_cancel₀ hp.1 (by\n                rw [tsub_add_eq_add_tsub (succ_le_of_lt hn0), tsub_add_cancel_of_le this]\n                simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add])⟩)\n      fun ⟨x, hx⟩ =>\n        have hm0 : 0 < m :=\n          Nat.pos_of_ne_zero fun hm0 => by simp [hx, hm0] at hb\n        have hpx : ¬p ^ (m - 1 + 1) ∣ x := fun ⟨y, hy⟩ =>\n          hb\n            (hx.symm ▸\n              ⟨y,\n                mul_right_cancel₀ hp.1 <| by\n                  rw [tsub_add_cancel_of_le (succ_le_of_lt hm0)] at hy\n                  simp [hy, pow_add, mul_comm, mul_assoc, mul_left_comm]⟩)\n        finiteMultiplicity_mul_aux hp ha hpx\n        ⟨s, mul_right_cancel₀ hp.1 (by\n              rw [add_assoc, tsub_add_cancel_of_le (succ_le_of_lt hm0)]\n              simp_all [mul_comm, mul_assoc, mul_left_comm, pow_add])⟩\n\n"}
{"name":"multiplicity.finite_mul_aux","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nhp : Prime p\na b : α\nn m : Nat\na✝¹ : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) a)\na✝ : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd m 1)) b)\n⊢ Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd (HAdd.hAdd n m) 1)) (HMul.hMul a b))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.finite_mul_aux := finiteMultiplicity_mul_aux\n\n"}
{"name":"Prime.finiteMultiplicity_mul","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\na✝¹ : FiniteMultiplicity p a\na✝ : FiniteMultiplicity p b\n⊢ FiniteMultiplicity p (HMul.hMul a b)","decl":"theorem Prime.finiteMultiplicity_mul {p a b : α} (hp : Prime p) :\n    FiniteMultiplicity p a → FiniteMultiplicity p b → FiniteMultiplicity p (a * b) :=\n  fun ⟨n, hn⟩ ⟨m, hm⟩ => ⟨n + m, finiteMultiplicity_mul_aux hp hn hm⟩\n\n"}
{"name":"Prime.multiplicity_finite_mul","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\na✝¹ : FiniteMultiplicity p a\na✝ : FiniteMultiplicity p b\n⊢ FiniteMultiplicity p (HMul.hMul a b)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias Prime.multiplicity_finite_mul := Prime.finiteMultiplicity_mul\n\n"}
{"name":"FiniteMultiplicity.mul_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\n⊢ Iff (FiniteMultiplicity p (HMul.hMul a b)) (And (FiniteMultiplicity p a) (FiniteMultiplicity p b))","decl":"theorem FiniteMultiplicity.mul_iff {p a b : α} (hp : Prime p) :\n    FiniteMultiplicity p (a * b) ↔ FiniteMultiplicity p a ∧ FiniteMultiplicity p b :=\n  ⟨fun h => ⟨h.mul_left, h.mul_right⟩, fun h =>\n    hp.finiteMultiplicity_mul h.1 h.2⟩\n\n"}
{"name":"multiplicity.Finite.mul_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\n⊢ Iff (FiniteMultiplicity p (HMul.hMul a b)) (And (FiniteMultiplicity p a) (FiniteMultiplicity p b))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.mul_iff := FiniteMultiplicity.mul_iff\n\n"}
{"name":"FiniteMultiplicity.pow","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a : α\nhp : Prime p\nhfin : FiniteMultiplicity p a\nk : Nat\n⊢ FiniteMultiplicity p (HPow.hPow a k)","decl":"theorem FiniteMultiplicity.pow {p a : α} (hp : Prime p)\n    (hfin : FiniteMultiplicity p a) {k : ℕ} : FiniteMultiplicity p (a ^ k) :=\n  match k, hfin with\n  | 0, _ => ⟨0, by simp [mt isUnit_iff_dvd_one.2 hp.2.1]⟩\n  | k + 1, ha => by rw [_root_.pow_succ']; exact hp.finiteMultiplicity_mul ha (ha.pow hp)\n\n"}
{"name":"multiplicity.Finite.pow","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a : α\nhp : Prime p\nhfin : FiniteMultiplicity p a\nk : Nat\n⊢ FiniteMultiplicity p (HPow.hPow a k)","decl":"@[deprecated (since := \"2024-11-30\")] alias multiplicity.Finite.pow := FiniteMultiplicity.pow\n\n"}
{"name":"multiplicity_self","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na : α\n⊢ Eq (multiplicity a a) 1","decl":"@[simp]\ntheorem multiplicity_self {a : α} : multiplicity a a = 1 := by\n  by_cases ha : FiniteMultiplicity a a\n  · rw [ha.multiplicity_eq_iff]\n    simp only [pow_one, dvd_refl, reduceAdd, true_and]\n    rintro ⟨v, hv⟩\n    nth_rw 1 [← mul_one a] at hv\n    simp only [sq, mul_assoc, mul_eq_mul_left_iff] at hv\n    obtain hv | rfl := hv\n    · have : IsUnit a := isUnit_of_mul_eq_one a v hv.symm\n      simpa [this] using ha.not_unit\n    · simpa using ha.ne_zero\n  · simp [ha]\n\n"}
{"name":"FiniteMultiplicity.emultiplicity_self","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na : α\nhfin : FiniteMultiplicity a a\n⊢ Eq (emultiplicity a a) 1","decl":"@[simp]\ntheorem FiniteMultiplicity.emultiplicity_self {a : α} (hfin : FiniteMultiplicity a a) :\n    emultiplicity a a = 1 := by\n  simp [hfin.emultiplicity_eq_multiplicity]\n\n"}
{"name":"multiplicity.Finite.emultiplicity_self","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na : α\nhfin : FiniteMultiplicity a a\n⊢ Eq (emultiplicity a a) 1","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.emultiplicity_self := FiniteMultiplicity.emultiplicity_self\n\n"}
{"name":"multiplicity_mul","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\nhfin : FiniteMultiplicity p (HMul.hMul a b)\n⊢ Eq (multiplicity p (HMul.hMul a b)) (HAdd.hAdd (multiplicity p a) (multiplicity p b))","decl":"theorem multiplicity_mul {p a b : α} (hp : Prime p) (hfin : FiniteMultiplicity p (a * b)) :\n    multiplicity p (a * b) = multiplicity p a + multiplicity p b := by\n  have hdiva : p ^ multiplicity p a ∣ a := pow_multiplicity_dvd ..\n  have hdivb : p ^ multiplicity p b ∣ b := pow_multiplicity_dvd ..\n  have hdiv : p ^ (multiplicity p a + multiplicity p b) ∣ a * b := by\n    rw [pow_add]; apply mul_dvd_mul <;> assumption\n  have hsucc : ¬p ^ (multiplicity p a + multiplicity p b + 1) ∣ a * b :=\n    fun h =>\n    not_or_intro (hfin.mul_left.not_pow_dvd_of_multiplicity_lt (lt_succ_self _))\n      (hfin.mul_right.not_pow_dvd_of_multiplicity_lt (lt_succ_self _))\n      (_root_.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul hp hdiva hdivb h)\n  rw [hfin.multiplicity_eq_iff]\n  exact ⟨hdiv, hsucc⟩\n\n"}
{"name":"emultiplicity_mul","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a b : α\nhp : Prime p\n⊢ Eq (emultiplicity p (HMul.hMul a b)) (HAdd.hAdd (emultiplicity p a) (emultiplicity p b))","decl":"theorem emultiplicity_mul {p a b : α} (hp : Prime p) :\n    emultiplicity p (a * b) = emultiplicity p a + emultiplicity p b := by\n  by_cases hfin : FiniteMultiplicity p (a * b)\n  · rw [hfin.emultiplicity_eq_multiplicity, hfin.mul_left.emultiplicity_eq_multiplicity,\n      hfin.mul_right.emultiplicity_eq_multiplicity]\n    norm_cast\n    exact multiplicity_mul hp hfin\n  · rw [emultiplicity_eq_top.2 hfin, eq_comm, WithTop.add_eq_top, emultiplicity_eq_top,\n      emultiplicity_eq_top]\n    simpa only [FiniteMultiplicity.mul_iff hp, not_and_or] using hfin\n\n"}
{"name":"Finset.emultiplicity_prod","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nβ : Type u_3\np : α\nhp : Prime p\ns : Finset β\nf : β → α\n⊢ Eq (emultiplicity p (s.prod fun x => f x)) (s.sum fun x => emultiplicity p (f x))","decl":"theorem Finset.emultiplicity_prod {β : Type*} {p : α} (hp : Prime p) (s : Finset β) (f : β → α) :\n    emultiplicity p (∏ x ∈ s, f x) = ∑ x ∈ s, emultiplicity p (f x) := by classical\n    induction' s using Finset.induction with a s has ih h\n    · simp only [Finset.sum_empty, Finset.prod_empty]\n      exact emultiplicity_of_one_right hp.not_unit\n    · simpa [has, ← ih] using emultiplicity_mul hp\n\n"}
{"name":"emultiplicity_pow","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a : α\nhp : Prime p\nk : Nat\n⊢ Eq (emultiplicity p (HPow.hPow a k)) (HMul.hMul (↑k) (emultiplicity p a))","decl":"theorem emultiplicity_pow {p a : α} (hp : Prime p) {k : ℕ} :\n    emultiplicity p (a ^ k) = k * emultiplicity p a := by\n  induction' k with k hk\n  · simp [emultiplicity_of_one_right hp.not_unit]\n  · simp [pow_succ, emultiplicity_mul hp, hk, add_mul]\n\n"}
{"name":"FiniteMultiplicity.multiplicity_pow","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a : α\nhp : Prime p\nha : FiniteMultiplicity p a\nk : Nat\n⊢ Eq (multiplicity p (HPow.hPow a k)) (HMul.hMul k (multiplicity p a))","decl":"protected theorem FiniteMultiplicity.multiplicity_pow {p a : α} (hp : Prime p)\n    (ha : FiniteMultiplicity p a) {k : ℕ} : multiplicity p (a ^ k) = k * multiplicity p a := by\n  exact_mod_cast (ha.pow hp).emultiplicity_eq_multiplicity ▸\n    ha.emultiplicity_eq_multiplicity ▸ emultiplicity_pow hp\n\n"}
{"name":"multiplicity.Finite.multiplicity_pow","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np a : α\nhp : Prime p\nha : FiniteMultiplicity p a\nk : Nat\n⊢ Eq (multiplicity p (HPow.hPow a k)) (HMul.hMul k (multiplicity p a))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Finite.multiplicity_pow := FiniteMultiplicity.multiplicity_pow\n\n"}
{"name":"emultiplicity_pow_self","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nh0 : Ne p 0\nhu : Not (IsUnit p)\nn : Nat\n⊢ Eq (emultiplicity p (HPow.hPow p n)) ↑n","decl":"theorem emultiplicity_pow_self {p : α} (h0 : p ≠ 0) (hu : ¬IsUnit p) (n : ℕ) :\n    emultiplicity p (p ^ n) = n := by\n  apply emultiplicity_eq_of_dvd_of_not_dvd\n  · rfl\n  · rw [pow_dvd_pow_iff h0 hu]\n    apply Nat.not_succ_le_self\n\n"}
{"name":"multiplicity_pow_self","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nh0 : Ne p 0\nhu : Not (IsUnit p)\nn : Nat\n⊢ Eq (multiplicity p (HPow.hPow p n)) n","decl":"theorem multiplicity_pow_self {p : α} (h0 : p ≠ 0) (hu : ¬IsUnit p) (n : ℕ) :\n    multiplicity p (p ^ n) = n :=\n  multiplicity_eq_of_emultiplicity_eq_some (emultiplicity_pow_self h0 hu n)\n\n"}
{"name":"emultiplicity_pow_self_of_prime","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nhp : Prime p\nn : Nat\n⊢ Eq (emultiplicity p (HPow.hPow p n)) ↑n","decl":"theorem emultiplicity_pow_self_of_prime {p : α} (hp : Prime p) (n : ℕ) :\n    emultiplicity p (p ^ n) = n :=\n  emultiplicity_pow_self hp.ne_zero hp.not_unit n\n\n"}
{"name":"multiplicity_pow_self_of_prime","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nhp : Prime p\nn : Nat\n⊢ Eq (multiplicity p (HPow.hPow p n)) n","decl":"theorem multiplicity_pow_self_of_prime {p : α} (hp : Prime p) (n : ℕ) :\n    multiplicity p (p ^ n) = n :=\n  multiplicity_pow_self hp.ne_zero hp.not_unit n\n\n"}
{"name":"multiplicity_eq_zero_of_coprime","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"p a b : Nat\nhp : Ne p 1\nhle : LE.le (multiplicity p a) (multiplicity p b)\nhab : a.Coprime b\n⊢ Eq (multiplicity p a) 0","decl":"theorem multiplicity_eq_zero_of_coprime {p a b : ℕ} (hp : p ≠ 1)\n    (hle : multiplicity p a ≤ multiplicity p b) (hab : Nat.Coprime a b) : multiplicity p a = 0 := by\n  apply Nat.eq_zero_of_not_pos\n  intro nh\n  have da : p ∣ a := by simpa [multiplicity_eq_zero] using nh.ne.symm\n  have db : p ∣ b := by simpa [multiplicity_eq_zero] using (nh.trans_le hle).ne.symm\n  have := Nat.dvd_gcd da db\n  rw [Coprime.gcd_eq_one hab, Nat.dvd_one] at this\n  exact hp this\n\n"}
{"name":"Int.finiteMultiplicity_iff_finiteMultiplicity_natAbs","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Int\n⊢ Iff (FiniteMultiplicity a b) (FiniteMultiplicity a.natAbs b.natAbs)","decl":"theorem Int.finiteMultiplicity_iff_finiteMultiplicity_natAbs {a b : ℤ} :\n    FiniteMultiplicity a b ↔ FiniteMultiplicity a.natAbs b.natAbs := by\n  simp only [FiniteMultiplicity.def, ← Int.natAbs_dvd_natAbs, Int.natAbs_pow]\n\n"}
{"name":"Int.multiplicity_finite_iff_natAbs_finite","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Int\n⊢ Iff (FiniteMultiplicity a b) (FiniteMultiplicity a.natAbs b.natAbs)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias Int.multiplicity_finite_iff_natAbs_finite :=\n  Int.finiteMultiplicity_iff_finiteMultiplicity_natAbs\n\n"}
{"name":"Int.finiteMultiplicity_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Int\n⊢ Iff (FiniteMultiplicity a b) (And (Ne a.natAbs 1) (Ne b 0))","decl":"theorem Int.finiteMultiplicity_iff {a b : ℤ} : FiniteMultiplicity a b ↔ a.natAbs ≠ 1 ∧ b ≠ 0 := by\n  rw [finiteMultiplicity_iff_finiteMultiplicity_natAbs, Nat.finiteMultiplicity_iff,\n    pos_iff_ne_zero, Int.natAbs_ne_zero]\n\n"}
{"name":"Int.multiplicity_finite_iff","module":"Mathlib.RingTheory.Multiplicity","initialProofState":"a b : Int\n⊢ Iff (FiniteMultiplicity a b) (And (Ne a.natAbs 1) (Ne b 0))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias Int.multiplicity_finite_iff := Int.finiteMultiplicity_iff\n\n"}
