{"name":"CategoryTheory.Functor.PreservesMonomorphisms.preserves","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.PreservesMonomorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (F.map f)","decl":"/-- A functor preserves monomorphisms if it maps monomorphisms to monomorphisms. -/\nclass PreservesMonomorphisms (F : C ⥤ D) : Prop where\n  /-- A functor preserves monomorphisms if it maps monomorphisms to monomorphisms. -/\n  preserves : ∀ {X Y : C} (f : X ⟶ Y) [Mono f], Mono (F.map f)\n\n"}
{"name":"CategoryTheory.Functor.map_mono","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesMonomorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (F.map f)","decl":"instance map_mono (F : C ⥤ D) [PreservesMonomorphisms F] {X Y : C} (f : X ⟶ Y) [Mono f] :\n    Mono (F.map f) :=\n  PreservesMonomorphisms.preserves f\n\n"}
{"name":"CategoryTheory.Functor.PreservesEpimorphisms.preserves","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.PreservesEpimorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (F.map f)","decl":"/-- A functor preserves epimorphisms if it maps epimorphisms to epimorphisms. -/\nclass PreservesEpimorphisms (F : C ⥤ D) : Prop where\n  /-- A functor preserves epimorphisms if it maps epimorphisms to epimorphisms. -/\n  preserves : ∀ {X Y : C} (f : X ⟶ Y) [Epi f], Epi (F.map f)\n\n"}
{"name":"CategoryTheory.Functor.map_epi","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesEpimorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (F.map f)","decl":"instance map_epi (F : C ⥤ D) [PreservesEpimorphisms F] {X Y : C} (f : X ⟶ Y) [Epi f] :\n    Epi (F.map f) :=\n  PreservesEpimorphisms.preserves f\n\n"}
{"name":"CategoryTheory.Functor.ReflectsMonomorphisms.reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.ReflectsMonomorphisms\nX Y : C\nf : Quiver.Hom X Y\na✝ : CategoryTheory.Mono (F.map f)\n⊢ CategoryTheory.Mono f","decl":"/-- A functor reflects monomorphisms if morphisms that are mapped to monomorphisms are themselves\n    monomorphisms. -/\nclass ReflectsMonomorphisms (F : C ⥤ D) : Prop where\n   /-- A functor reflects monomorphisms if morphisms that are mapped to monomorphisms are themselves\n    monomorphisms. -/\n  reflects : ∀ {X Y : C} (f : X ⟶ Y), Mono (F.map f) → Mono f\n\n"}
{"name":"CategoryTheory.Functor.mono_of_mono_map","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsMonomorphisms\nX Y : C\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono (F.map f)\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_mono_map (F : C ⥤ D) [ReflectsMonomorphisms F] {X Y : C} {f : X ⟶ Y}\n    (h : Mono (F.map f)) : Mono f :=\n  ReflectsMonomorphisms.reflects f h\n\n"}
{"name":"CategoryTheory.Functor.ReflectsEpimorphisms.reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.ReflectsEpimorphisms\nX Y : C\nf : Quiver.Hom X Y\na✝ : CategoryTheory.Epi (F.map f)\n⊢ CategoryTheory.Epi f","decl":"/-- A functor reflects epimorphisms if morphisms that are mapped to epimorphisms are themselves\n    epimorphisms. -/\nclass ReflectsEpimorphisms (F : C ⥤ D) : Prop where\n  /-- A functor reflects epimorphisms if morphisms that are mapped to epimorphisms are themselves\n      epimorphisms. -/\n  reflects : ∀ {X Y : C} (f : X ⟶ Y), Epi (F.map f) → Epi f\n\n"}
{"name":"CategoryTheory.Functor.epi_of_epi_map","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEpimorphisms\nX Y : C\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi (F.map f)\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_epi_map (F : C ⥤ D) [ReflectsEpimorphisms F] {X Y : C} {f : X ⟶ Y}\n    (h : Epi (F.map f)) : Epi f :=\n  ReflectsEpimorphisms.reflects f h\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_comp","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.PreservesMonomorphisms\ninst✝ : G.PreservesMonomorphisms\n⊢ (F.comp G).PreservesMonomorphisms","decl":"instance preservesMonomorphisms_comp (F : C ⥤ D) (G : D ⥤ E) [PreservesMonomorphisms F]\n    [PreservesMonomorphisms G] : PreservesMonomorphisms (F ⋙ G) where\n  preserves f h := by\n    rw [comp_map]\n    exact inferInstance\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_comp","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.PreservesEpimorphisms\ninst✝ : G.PreservesEpimorphisms\n⊢ (F.comp G).PreservesEpimorphisms","decl":"instance preservesEpimorphisms_comp (F : C ⥤ D) (G : D ⥤ E) [PreservesEpimorphisms F]\n    [PreservesEpimorphisms G] : PreservesEpimorphisms (F ⋙ G) where\n  preserves f h := by\n    rw [comp_map]\n    exact inferInstance\n\n"}
{"name":"CategoryTheory.Functor.reflectsMonomorphisms_comp","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.ReflectsMonomorphisms\ninst✝ : G.ReflectsMonomorphisms\n⊢ (F.comp G).ReflectsMonomorphisms","decl":"instance reflectsMonomorphisms_comp (F : C ⥤ D) (G : D ⥤ E) [ReflectsMonomorphisms F]\n    [ReflectsMonomorphisms G] : ReflectsMonomorphisms (F ⋙ G) where\n  reflects _ h := F.mono_of_mono_map (G.mono_of_mono_map h)\n\n"}
{"name":"CategoryTheory.Functor.reflectsEpimorphisms_comp","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.ReflectsEpimorphisms\ninst✝ : G.ReflectsEpimorphisms\n⊢ (F.comp G).ReflectsEpimorphisms","decl":"instance reflectsEpimorphisms_comp (F : C ⥤ D) (G : D ⥤ E) [ReflectsEpimorphisms F]\n    [ReflectsEpimorphisms G] : ReflectsEpimorphisms (F ⋙ G) where\n  reflects _ h := F.epi_of_epi_map (G.epi_of_epi_map h)\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_of_preserves_of_reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : (F.comp G).PreservesEpimorphisms\ninst✝ : G.ReflectsEpimorphisms\n⊢ F.PreservesEpimorphisms","decl":"theorem preservesEpimorphisms_of_preserves_of_reflects (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesEpimorphisms (F ⋙ G)] [ReflectsEpimorphisms G] : PreservesEpimorphisms F :=\n  ⟨fun f _ => G.epi_of_epi_map <| show Epi ((F ⋙ G).map f) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_preserves_of_reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : (F.comp G).PreservesMonomorphisms\ninst✝ : G.ReflectsMonomorphisms\n⊢ F.PreservesMonomorphisms","decl":"theorem preservesMonomorphisms_of_preserves_of_reflects (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesMonomorphisms (F ⋙ G)] [ReflectsMonomorphisms G] : PreservesMonomorphisms F :=\n  ⟨fun f _ => G.mono_of_mono_map <| show Mono ((F ⋙ G).map f) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.reflectsEpimorphisms_of_preserves_of_reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : G.PreservesEpimorphisms\ninst✝ : (F.comp G).ReflectsEpimorphisms\n⊢ F.ReflectsEpimorphisms","decl":"theorem reflectsEpimorphisms_of_preserves_of_reflects (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesEpimorphisms G] [ReflectsEpimorphisms (F ⋙ G)] : ReflectsEpimorphisms F :=\n  ⟨fun f _ => (F ⋙ G).epi_of_epi_map <| show Epi (G.map (F.map f)) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.reflectsMonomorphisms_of_preserves_of_reflects","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : G.PreservesMonomorphisms\ninst✝ : (F.comp G).ReflectsMonomorphisms\n⊢ F.ReflectsMonomorphisms","decl":"theorem reflectsMonomorphisms_of_preserves_of_reflects (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesMonomorphisms G] [ReflectsMonomorphisms (F ⋙ G)] : ReflectsMonomorphisms F :=\n  ⟨fun f _ => (F ⋙ G).mono_of_mono_map <| show Mono (G.map (F.map f)) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms.of_iso","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\ninst✝ : F.PreservesMonomorphisms\nα : CategoryTheory.Iso F G\n⊢ G.PreservesMonomorphisms","decl":"theorem preservesMonomorphisms.of_iso {F G : C ⥤ D} [PreservesMonomorphisms F] (α : F ≅ G) :\n    PreservesMonomorphisms G :=\n  { preserves := fun {X} {Y} f h => by\n      suffices G.map f = (α.app X).inv ≫ F.map f ≫ (α.app Y).hom from this ▸ mono_comp _ _\n      rw [Iso.eq_inv_comp, Iso.app_hom, Iso.app_hom, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms.iso_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nα : CategoryTheory.Iso F G\n⊢ Iff F.PreservesMonomorphisms G.PreservesMonomorphisms","decl":"theorem preservesMonomorphisms.iso_iff {F G : C ⥤ D} (α : F ≅ G) :\n    PreservesMonomorphisms F ↔ PreservesMonomorphisms G :=\n  ⟨fun _ => preservesMonomorphisms.of_iso α, fun _ => preservesMonomorphisms.of_iso α.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms.of_iso","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\ninst✝ : F.PreservesEpimorphisms\nα : CategoryTheory.Iso F G\n⊢ G.PreservesEpimorphisms","decl":"theorem preservesEpimorphisms.of_iso {F G : C ⥤ D} [PreservesEpimorphisms F] (α : F ≅ G) :\n    PreservesEpimorphisms G :=\n  { preserves := fun {X} {Y} f h => by\n      suffices G.map f = (α.app X).inv ≫ F.map f ≫ (α.app Y).hom from this ▸ epi_comp _ _\n      rw [Iso.eq_inv_comp, Iso.app_hom, Iso.app_hom, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms.iso_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nα : CategoryTheory.Iso F G\n⊢ Iff F.PreservesEpimorphisms G.PreservesEpimorphisms","decl":"theorem preservesEpimorphisms.iso_iff {F G : C ⥤ D} (α : F ≅ G) :\n    PreservesEpimorphisms F ↔ PreservesEpimorphisms G :=\n  ⟨fun _ => preservesEpimorphisms.of_iso α, fun _ => preservesEpimorphisms.of_iso α.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.reflectsMonomorphisms.of_iso","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\ninst✝ : F.ReflectsMonomorphisms\nα : CategoryTheory.Iso F G\n⊢ G.ReflectsMonomorphisms","decl":"theorem reflectsMonomorphisms.of_iso {F G : C ⥤ D} [ReflectsMonomorphisms F] (α : F ≅ G) :\n    ReflectsMonomorphisms G :=\n  { reflects := fun {X} {Y} f h => by\n      apply F.mono_of_mono_map\n      suffices F.map f = (α.app X).hom ≫ G.map f ≫ (α.app Y).inv from this ▸ mono_comp _ _\n      rw [← Category.assoc, Iso.eq_comp_inv, Iso.app_hom, Iso.app_hom, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.Functor.reflectsMonomorphisms.iso_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nα : CategoryTheory.Iso F G\n⊢ Iff F.ReflectsMonomorphisms G.ReflectsMonomorphisms","decl":"theorem reflectsMonomorphisms.iso_iff {F G : C ⥤ D} (α : F ≅ G) :\n    ReflectsMonomorphisms F ↔ ReflectsMonomorphisms G :=\n  ⟨fun _ => reflectsMonomorphisms.of_iso α, fun _ => reflectsMonomorphisms.of_iso α.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.reflectsEpimorphisms.of_iso","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEpimorphisms\nα : CategoryTheory.Iso F G\n⊢ G.ReflectsEpimorphisms","decl":"theorem reflectsEpimorphisms.of_iso {F G : C ⥤ D} [ReflectsEpimorphisms F] (α : F ≅ G) :\n    ReflectsEpimorphisms G :=\n  { reflects := fun {X} {Y} f h => by\n      apply F.epi_of_epi_map\n      suffices F.map f = (α.app X).hom ≫ G.map f ≫ (α.app Y).inv from this ▸ epi_comp _ _\n      rw [← Category.assoc, Iso.eq_comp_inv, Iso.app_hom, Iso.app_hom, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.Functor.reflectsEpimorphisms.iso_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nα : CategoryTheory.Iso F G\n⊢ Iff F.ReflectsEpimorphisms G.ReflectsEpimorphisms","decl":"theorem reflectsEpimorphisms.iso_iff {F G : C ⥤ D} (α : F ≅ G) :\n    ReflectsEpimorphisms F ↔ ReflectsEpimorphisms G :=\n  ⟨fun _ => reflectsEpimorphisms.of_iso α, fun _ => reflectsEpimorphisms.of_iso α.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphsisms_of_adjunction","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ F.PreservesEpimorphisms","decl":"theorem preservesEpimorphsisms_of_adjunction {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    PreservesEpimorphisms F :=\n  { preserves := fun {X} {Y} f hf =>\n      ⟨by\n        intro Z g h H\n        replace H := congr_arg (adj.homEquiv X Z) H\n        rwa [adj.homEquiv_naturality_left, adj.homEquiv_naturality_left, cancel_epi,\n          Equiv.apply_eq_iff_eq] at H⟩ }\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsLeftAdjoint\n⊢ F.PreservesEpimorphisms","decl":"instance (priority := 100) preservesEpimorphisms_of_isLeftAdjoint (F : C ⥤ D) [IsLeftAdjoint F] :\n    PreservesEpimorphisms F :=\n  preservesEpimorphsisms_of_adjunction (Adjunction.ofIsLeftAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_adjunction","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ G.PreservesMonomorphisms","decl":"theorem preservesMonomorphisms_of_adjunction {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    PreservesMonomorphisms G :=\n  { preserves := fun {X} {Y} f hf =>\n      ⟨by\n        intro Z g h H\n        replace H := congr_arg (adj.homEquiv Z Y).symm H\n        rwa [adj.homEquiv_naturality_right_symm, adj.homEquiv_naturality_right_symm, cancel_mono,\n          Equiv.apply_eq_iff_eq] at H⟩ }\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsRightAdjoint\n⊢ F.PreservesMonomorphisms","decl":"instance (priority := 100) preservesMonomorphisms_of_isRightAdjoint (F : C ⥤ D) [IsRightAdjoint F] :\n    PreservesMonomorphisms F :=\n  preservesMonomorphisms_of_adjunction (Adjunction.ofIsRightAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.reflectsMonomorphisms_of_faithful","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Faithful\n⊢ F.ReflectsMonomorphisms","decl":"instance (priority := 100) reflectsMonomorphisms_of_faithful (F : C ⥤ D) [Faithful F] :\n    ReflectsMonomorphisms F where\n  reflects {X} {Y} f _ :=\n    ⟨fun {Z} g h hgh =>\n      F.map_injective ((cancel_mono (F.map f)).1 (by rw [← F.map_comp, hgh, F.map_comp]))⟩\n\n"}
{"name":"CategoryTheory.Functor.reflectsEpimorphisms_of_faithful","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Faithful\n⊢ F.ReflectsEpimorphisms","decl":"instance (priority := 100) reflectsEpimorphisms_of_faithful (F : C ⥤ D) [Faithful F] :\n    ReflectsEpimorphisms F where\n  reflects {X} {Y} f _ :=\n    ⟨fun {Z} g h hgh =>\n      F.map_injective ((cancel_epi (F.map f)).1 (by rw [← F.map_comp, hgh, F.map_comp]))⟩\n\n"}
{"name":"CategoryTheory.Functor.isSplitEpi_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Iff (CategoryTheory.IsSplitEpi (F.map f)) (CategoryTheory.IsSplitEpi f)","decl":"@[simp]\ntheorem isSplitEpi_iff [Full F] [Faithful F] : IsSplitEpi (F.map f) ↔ IsSplitEpi f := by\n  constructor\n  · intro h\n    exact IsSplitEpi.mk' ((splitEpiEquiv F f).invFun h.exists_splitEpi.some)\n  · intro h\n    exact IsSplitEpi.mk' ((splitEpiEquiv F f).toFun h.exists_splitEpi.some)\n\n"}
{"name":"CategoryTheory.Functor.isSplitMono_iff","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Iff (CategoryTheory.IsSplitMono (F.map f)) (CategoryTheory.IsSplitMono f)","decl":"@[simp]\ntheorem isSplitMono_iff [Full F] [Faithful F] : IsSplitMono (F.map f) ↔ IsSplitMono f := by\n  constructor\n  · intro h\n    exact IsSplitMono.mk' ((splitMonoEquiv F f).invFun h.exists_splitMono.some)\n  · intro h\n    exact IsSplitMono.mk' ((splitMonoEquiv F f).toFun h.exists_splitMono.some)\n\n"}
{"name":"CategoryTheory.Functor.epi_map_iff_epi","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nhF₁ : F.PreservesEpimorphisms\nhF₂ : F.ReflectsEpimorphisms\n⊢ Iff (CategoryTheory.Epi (F.map f)) (CategoryTheory.Epi f)","decl":"@[simp]\ntheorem epi_map_iff_epi [hF₁ : PreservesEpimorphisms F] [hF₂ : ReflectsEpimorphisms F] :\n    Epi (F.map f) ↔ Epi f := by\n  constructor\n  · exact F.epi_of_epi_map\n  · intro h\n    exact F.map_epi f\n\n"}
{"name":"CategoryTheory.Functor.mono_map_iff_mono","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nhF₁ : F.PreservesMonomorphisms\nhF₂ : F.ReflectsMonomorphisms\n⊢ Iff (CategoryTheory.Mono (F.map f)) (CategoryTheory.Mono f)","decl":"@[simp]\ntheorem mono_map_iff_mono [hF₁ : PreservesMonomorphisms F] [hF₂ : ReflectsMonomorphisms F] :\n    Mono (F.map f) ↔ Mono f := by\n  constructor\n  · exact F.mono_of_mono_map\n  · intro h\n    exact F.map_mono f\n\n"}
{"name":"CategoryTheory.Functor.splitEpiCategoryImpOfIsEquivalence","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.IsEquivalence\ninst✝ : CategoryTheory.SplitEpiCategory C\n⊢ CategoryTheory.SplitEpiCategory D","decl":"/-- If `F : C ⥤ D` is an equivalence of categories and `C` is a `split_epi_category`,\nthen `D` also is. -/\ntheorem splitEpiCategoryImpOfIsEquivalence [IsEquivalence F] [SplitEpiCategory C] :\n    SplitEpiCategory D :=\n  ⟨fun {X} {Y} f => by\n    intro\n    rw [← F.inv.isSplitEpi_iff f]\n    apply isSplitEpi_of_epi⟩\n\n"}
{"name":"CategoryTheory.Adjunction.strongEpi_map_of_strongEpi","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nF' : CategoryTheory.Functor D C\nA B : C\nadj : CategoryTheory.Adjunction F F'\nf : Quiver.Hom A B\ninst✝² : F'.PreservesMonomorphisms\ninst✝¹ : F.PreservesEpimorphisms\ninst✝ : CategoryTheory.StrongEpi f\n⊢ CategoryTheory.StrongEpi (F.map f)","decl":"theorem strongEpi_map_of_strongEpi (adj : F ⊣ F') (f : A ⟶ B) [F'.PreservesMonomorphisms]\n    [F.PreservesEpimorphisms] [StrongEpi f] : StrongEpi (F.map f) :=\n  ⟨inferInstance, fun X Y Z => by\n    intro\n    rw [adj.hasLiftingProperty_iff]\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.Adjunction.strongEpi_map_of_isEquivalence","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝ : F.IsEquivalence\nf : Quiver.Hom A B\n_h : CategoryTheory.StrongEpi f\n⊢ CategoryTheory.StrongEpi (F.map f)","decl":"instance strongEpi_map_of_isEquivalence [F.IsEquivalence] (f : A ⟶ B) [_h : StrongEpi f] :\n    StrongEpi (F.map f) :=\n  F.asEquivalence.toAdjunction.strongEpi_map_of_strongEpi f\n\n"}
{"name":"CategoryTheory.Adjunction.instMonoCoeEquivHomObjHomEquivOfReflectsMonomorphisms","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nF' : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F F'\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\nhf : CategoryTheory.Mono f\ninst✝ : F.ReflectsMonomorphisms\n⊢ CategoryTheory.Mono ((adj.homEquiv X Y) f)","decl":"instance (adj : F ⊣ F') {X : C} {Y : D} (f : F.obj X ⟶ Y) [hf : Mono f] [F.ReflectsMonomorphisms] :\n    Mono (adj.homEquiv _ _ f) :=\n  F.mono_of_mono_map <| by\n    rw [← (homEquiv adj X Y).symm_apply_apply f] at hf\n    exact mono_of_mono_fac (adj.homEquiv_counit _ _ _).symm\n\n"}
{"name":"CategoryTheory.Functor.strongEpi_map_iff_strongEpi_of_isEquivalence","module":"Mathlib.CategoryTheory.Functor.EpiMono","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nA B : C\nf : Quiver.Hom A B\ninst✝ : F.IsEquivalence\n⊢ Iff (CategoryTheory.StrongEpi (F.map f)) (CategoryTheory.StrongEpi f)","decl":"@[simp]\ntheorem strongEpi_map_iff_strongEpi_of_isEquivalence [IsEquivalence F] :\n    StrongEpi (F.map f) ↔ StrongEpi f := by\n  constructor\n  · intro\n    have e : Arrow.mk f ≅ Arrow.mk (F.inv.map (F.map f)) :=\n      Arrow.isoOfNatIso F.asEquivalence.unitIso (Arrow.mk f)\n    rw [StrongEpi.iff_of_arrow_iso e]\n    infer_instance\n  · intro\n    infer_instance\n\n"}
