{"name":"CategoryTheory.CommSq.cone_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ Eq s.cone.fst f","decl":"@[simp]\ntheorem cone_fst (s : CommSq f g h i) : s.cone.fst = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.CommSq.cone_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ Eq s.cone.snd g","decl":"@[simp]\ntheorem cone_snd (s : CommSq f g h i) : s.cone.snd = g :=\n  rfl\n\n"}
{"name":"CategoryTheory.CommSq.cocone_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ Eq s.cocone.inl h","decl":"@[simp]\ntheorem cocone_inl (s : CommSq f g h i) : s.cocone.inl = h :=\n  rfl\n\n"}
{"name":"CategoryTheory.CommSq.cocone_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ Eq s.cocone.inr i","decl":"@[simp]\ntheorem cocone_inr (s : CommSq f g h i) : s.cocone.inr = i :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsPullback.toCommSq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nself : CategoryTheory.IsPullback fst snd f g\n⊢ CategoryTheory.CommSq fst snd f g","decl":"/-- The proposition that a square\n```\n  P --fst--> X\n  |          |\n snd         f\n  |          |\n  v          v\n  Y ---g---> Z\n\n```\nis a pullback square. (Also known as a fibered product or cartesian square.)\n-/\nstructure IsPullback {P X Y Z : C} (fst : P ⟶ X) (snd : P ⟶ Y) (f : X ⟶ Z) (g : Y ⟶ Z) extends\n  CommSq fst snd f g : Prop where\n  /-- the pullback cone is a limit -/\n  isLimit' : Nonempty (IsLimit (PullbackCone.mk _ _ w))\n\n"}
{"name":"CategoryTheory.IsPullback.isLimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nself : CategoryTheory.IsPullback fst snd f g\n⊢ Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk fst snd ⋯))","decl":"/-- The proposition that a square\n```\n  P --fst--> X\n  |          |\n snd         f\n  |          |\n  v          v\n  Y ---g---> Z\n\n```\nis a pullback square. (Also known as a fibered product or cartesian square.)\n-/\nstructure IsPullback {P X Y Z : C} (fst : P ⟶ X) (snd : P ⟶ Y) (f : X ⟶ Z) (g : Y ⟶ Z) extends\n  CommSq fst snd f g : Prop where\n  /-- the pullback cone is a limit -/\n  isLimit' : Nonempty (IsLimit (PullbackCone.mk _ _ w))\n\n"}
{"name":"CategoryTheory.IsPushout.isColimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nself : CategoryTheory.IsPushout f g inl inr\n⊢ Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk inl inr ⋯))","decl":"/-- The proposition that a square\n```\n  Z ---f---> X\n  |          |\n  g         inl\n  |          |\n  v          v\n  Y --inr--> P\n\n```\nis a pushout square. (Also known as a fiber coproduct or cocartesian square.)\n-/\nstructure IsPushout {Z X Y P : C} (f : Z ⟶ X) (g : Z ⟶ Y) (inl : X ⟶ P) (inr : Y ⟶ P) extends\n  CommSq f g inl inr : Prop where\n  /-- the pushout cocone is a colimit -/\n  isColimit' : Nonempty (IsColimit (PushoutCocone.mk _ _ w))\n\n"}
{"name":"CategoryTheory.IsPushout.toCommSq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nself : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.CommSq f g inl inr","decl":"/-- The proposition that a square\n```\n  Z ---f---> X\n  |          |\n  g         inl\n  |          |\n  v          v\n  Y --inr--> P\n\n```\nis a pushout square. (Also known as a fiber coproduct or cocartesian square.)\n-/\nstructure IsPushout {Z X Y P : C} (f : Z ⟶ X) (g : Z ⟶ Y) (inl : X ⟶ P) (inr : Y ⟶ P) extends\n  CommSq f g inl inr : Prop where\n  /-- the pushout cocone is a colimit -/\n  isColimit' : Nonempty (IsColimit (PushoutCocone.mk _ _ w))\n\n"}
{"name":"CategoryTheory.BicartesianSq.toIsPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nself : CategoryTheory.BicartesianSq f g h i\n⊢ CategoryTheory.IsPullback f g h i","decl":"/-- A *bicartesian* square is a commutative square\n```\n  W ---f---> X\n  |          |\n  g          h\n  |          |\n  v          v\n  Y ---i---> Z\n\n```\nthat is both a pullback square and a pushout square.\n-/\nstructure BicartesianSq {W X Y Z : C} (f : W ⟶ X) (g : W ⟶ Y) (h : X ⟶ Z) (i : Y ⟶ Z) extends\n  IsPullback f g h i, IsPushout f g h i : Prop\n\n-- Lean should make these parent projections as `lemma`, not `def`.\n"}
{"name":"CategoryTheory.BicartesianSq.isColimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nself : CategoryTheory.BicartesianSq f g h i\n⊢ Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk h i ⋯))","decl":"/-- A *bicartesian* square is a commutative square\n```\n  W ---f---> X\n  |          |\n  g          h\n  |          |\n  v          v\n  Y ---i---> Z\n\n```\nthat is both a pullback square and a pushout square.\n-/\nstructure BicartesianSq {W X Y Z : C} (f : W ⟶ X) (g : W ⟶ Y) (h : X ⟶ Z) (i : Y ⟶ Z) extends\n  IsPullback f g h i, IsPushout f g h i : Prop\n\n-- Lean should make these parent projections as `lemma`, not `def`.\n"}
{"name":"CategoryTheory.BicartesianSq.toIsPushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nself : CategoryTheory.BicartesianSq f g h i\n⊢ CategoryTheory.IsPushout f g h i","decl":"/-- A *bicartesian* square is a commutative square\n```\n  W ---f---> X\n  |          |\n  g          h\n  |          |\n  v          v\n  Y ---i---> Z\n\n```\nthat is both a pullback square and a pushout square.\n-/\nstructure BicartesianSq {W X Y Z : C} (f : W ⟶ X) (g : W ⟶ Y) (h : X ⟶ Z) (i : Y ⟶ Z) extends\n  IsPullback f g h i, IsPushout f g h i : Prop\n\n-- Lean should make these parent projections as `lemma`, not `def`.\n"}
{"name":"CategoryTheory.IsPullback.cone_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ Eq h.cone.fst fst","decl":"@[simp]\ntheorem cone_fst (h : IsPullback fst snd f g) : h.cone.fst = fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsPullback.cone_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ Eq h.cone.snd snd","decl":"@[simp]\ntheorem cone_snd (h : IsPullback fst snd f g) : h.cone.snd = snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsPullback.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nhP : CategoryTheory.IsPullback fst snd f g\nW : C\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.lift h✝ k w) (CategoryTheory.CategoryStruct.comp fst h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst (hP : IsPullback fst snd f g) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : hP.lift h k w ≫ fst = h :=\n  PullbackCone.IsLimit.lift_fst hP.isLimit h k w\n\n"}
{"name":"CategoryTheory.IsPullback.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nhP : CategoryTheory.IsPullback fst snd f g\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.lift h k w) fst) h","decl":"@[reassoc (attr := simp)]\nlemma lift_fst (hP : IsPullback fst snd f g) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : hP.lift h k w ≫ fst = h :=\n  PullbackCone.IsLimit.lift_fst hP.isLimit h k w\n\n"}
{"name":"CategoryTheory.IsPullback.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nhP : CategoryTheory.IsPullback fst snd f g\nW : C\nh✝ : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.lift h✝ k w) (CategoryTheory.CategoryStruct.comp snd h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd (hP : IsPullback fst snd f g) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : hP.lift h k w ≫ snd = k :=\n  PullbackCone.IsLimit.lift_snd hP.isLimit h k w\n\n"}
{"name":"CategoryTheory.IsPullback.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nhP : CategoryTheory.IsPullback fst snd f g\nW : C\nh : Quiver.Hom W X\nk : Quiver.Hom W Y\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.lift h k w) snd) k","decl":"@[reassoc (attr := simp)]\nlemma lift_snd (hP : IsPullback fst snd f g) {W : C} (h : W ⟶ X) (k : W ⟶ Y)\n    (w : h ≫ f = k ≫ g) : hP.lift h k w ≫ snd = k :=\n  PullbackCone.IsLimit.lift_snd hP.isLimit h k w\n\n"}
{"name":"CategoryTheory.IsPullback.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nhP : CategoryTheory.IsPullback fst snd f g\nW : C\nk l : Quiver.Hom W P\nh₀ : Eq (CategoryTheory.CategoryStruct.comp k fst) (CategoryTheory.CategoryStruct.comp l fst)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp k snd) (CategoryTheory.CategoryStruct.comp l snd)\n⊢ Eq k l","decl":"lemma hom_ext (hP : IsPullback fst snd f g) {W : C} {k l : W ⟶ P}\n    (h₀ : k ≫ fst = l ≫ fst) (h₁ : k ≫ snd = l ≫ snd) : k = l :=\n  PullbackCone.IsLimit.hom_ext hP.isLimit h₀ h₁\n\n"}
{"name":"CategoryTheory.IsPullback.of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\nh : CategoryTheory.Limits.IsLimit c\n⊢ CategoryTheory.IsPullback c.fst c.snd f g","decl":"/-- If `c` is a limiting pullback cone, then we have an `IsPullback c.fst c.snd f g`. -/\ntheorem of_isLimit {c : PullbackCone f g} (h : Limits.IsLimit c) : IsPullback c.fst c.snd f g :=\n  { w := c.condition\n    isLimit' := ⟨IsLimit.ofIsoLimit h (Limits.PullbackCone.ext (Iso.refl _)\n      (by simp) (by simp))⟩ }\n\n"}
{"name":"CategoryTheory.IsPullback.of_isLimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nw : CategoryTheory.CommSq fst snd f g\nh : CategoryTheory.Limits.IsLimit w.cone\n⊢ CategoryTheory.IsPullback fst snd f g","decl":"/-- A variant of `of_isLimit` that is more useful with `apply`. -/\ntheorem of_isLimit' (w : CommSq fst snd f g) (h : Limits.IsLimit w.cone) :\n    IsPullback fst snd f g :=\n  of_isLimit h\n\n"}
{"name":"CategoryTheory.IsPullback.of_isLimit_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nD : CategoryTheory.Functor CategoryTheory.Limits.WalkingCospan C\nc : CategoryTheory.Limits.Cone D\nhc : CategoryTheory.Limits.IsLimit c\n⊢ CategoryTheory.IsPullback (c.π.app CategoryTheory.Limits.WalkingCospan.left) (c.π.app CategoryTheory.Limits.WalkingCospan.right) (D.map CategoryTheory.Limits.WalkingCospan.Hom.inl) (D.map CategoryTheory.Limits.WalkingCospan.Hom.inr)","decl":"/-- Variant of `of_isLimit` for an arbitrary cone on a diagram `WalkingCospan ⥤ C`. -/\nlemma of_isLimit_cone {D : WalkingCospan ⥤ C} {c : Cone D} (hc : IsLimit c) :\n    IsPullback (c.π.app .left) (c.π.app .right) (D.map WalkingCospan.Hom.inl)\n      (D.map WalkingCospan.Hom.inr) where\n  w := by simp_rw [Cone.w]\n  isLimit' := ⟨IsLimit.equivOfNatIsoOfIso _ _ _ (PullbackCone.isoMk c) hc⟩\n\n"}
{"name":"CategoryTheory.IsPullback.hasPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"lemma hasPullback (h : IsPullback fst snd f g) : HasPullback f g where\n  exists_limit := ⟨⟨h.cone, h.isLimit⟩⟩\n\n"}
{"name":"CategoryTheory.IsPullback.of_hasPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ CategoryTheory.IsPullback (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g) f g","decl":"/-- The pullback provided by `HasPullback f g` fits into an `IsPullback`. -/\ntheorem of_hasPullback (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g] :\n    IsPullback (pullback.fst f g) (pullback.snd f g) f g :=\n  of_isLimit (limit.isLimit (cospan f g))\n\n"}
{"name":"CategoryTheory.IsPullback.of_is_product","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nc : CategoryTheory.Limits.BinaryFan X Y\nh : CategoryTheory.Limits.IsLimit c\nt : CategoryTheory.Limits.IsTerminal Z\n⊢ CategoryTheory.IsPullback c.fst c.snd (t.from ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left })) (t.from ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right }))","decl":"/-- If `c` is a limiting binary product cone, and we have a terminal object,\nthen we have `IsPullback c.fst c.snd 0 0`\n(where each `0` is the unique morphism to the terminal object). -/\ntheorem of_is_product {c : BinaryFan X Y} (h : Limits.IsLimit c) (t : IsTerminal Z) :\n    IsPullback c.fst c.snd (t.from _) (t.from _) :=\n  of_isLimit\n    (isPullbackOfIsTerminalIsProduct _ _ _ _ t\n      (IsLimit.ofIsoLimit h\n        (Limits.Cones.ext (Iso.refl c.pt)\n          (by\n            rintro ⟨⟨⟩⟩ <;>\n              · dsimp\n                simp))))\n\n"}
{"name":"CategoryTheory.IsPullback.of_is_product'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nh : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk fst snd)\nt : CategoryTheory.Limits.IsTerminal Z\n⊢ CategoryTheory.IsPullback fst snd (t.from X) (t.from Y)","decl":"/-- A variant of `of_is_product` that is more useful with `apply`. -/\ntheorem of_is_product' (h : Limits.IsLimit (BinaryFan.mk fst snd)) (t : IsTerminal Z) :\n    IsPullback fst snd (t.from _) (t.from _) :=\n  of_is_product h t\n\n"}
{"name":"CategoryTheory.IsPullback.of_hasBinaryProduct'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.IsPullback CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.terminal.from X) (CategoryTheory.Limits.terminal.from Y)","decl":"theorem of_hasBinaryProduct' [HasBinaryProduct X Y] [HasTerminal C] :\n    IsPullback Limits.prod.fst Limits.prod.snd (terminal.from X) (terminal.from Y) :=\n  of_is_product (limit.isLimit _) terminalIsTerminal\n\n"}
{"name":"CategoryTheory.IsPullback.of_hasBinaryProduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\n⊢ CategoryTheory.IsPullback CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd 0 0","decl":"theorem of_hasBinaryProduct [HasBinaryProduct X Y] [HasZeroObject C] [HasZeroMorphisms C] :\n    IsPullback Limits.prod.fst Limits.prod.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) := by\n  convert @of_is_product _ _ X Y 0 _ (limit.isLimit _) HasZeroObject.zeroIsTerminal\n    <;> subsingleton\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh✝ : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h✝ h').hom (CategoryTheory.CategoryStruct.comp fst' h)) (CategoryTheory.CategoryStruct.comp fst h)","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_hom_fst (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').hom ≫ fst' = fst :=\n  IsLimit.conePointUniqueUpToIso_hom_comp h.isLimit h'.isLimit WalkingCospan.left\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h h').hom fst') fst","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_hom_fst (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').hom ≫ fst' = fst :=\n  IsLimit.conePointUniqueUpToIso_hom_comp h.isLimit h'.isLimit WalkingCospan.left\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh✝ : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h✝ h').hom (CategoryTheory.CategoryStruct.comp snd' h)) (CategoryTheory.CategoryStruct.comp snd h)","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_hom_snd (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').hom ≫ snd' = snd :=\n  IsLimit.conePointUniqueUpToIso_hom_comp h.isLimit h'.isLimit WalkingCospan.right\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h h').hom snd') snd","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_hom_snd (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').hom ≫ snd' = snd :=\n  IsLimit.conePointUniqueUpToIso_hom_comp h.isLimit h'.isLimit WalkingCospan.right\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h h').inv fst) fst'","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_inv_fst (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').inv ≫ fst = fst' := by\n  simp only [Iso.inv_comp_eq, isoIsPullback_hom_fst]\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh✝ : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h✝ h').inv (CategoryTheory.CategoryStruct.comp fst h)) (CategoryTheory.CategoryStruct.comp fst' h)","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_inv_fst (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').inv ≫ fst = fst' := by\n  simp only [Iso.inv_comp_eq, isoIsPullback_hom_fst]\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh✝ : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h✝ h').inv (CategoryTheory.CategoryStruct.comp snd h)) (CategoryTheory.CategoryStruct.comp snd' h)","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_inv_snd (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').inv ≫ snd = snd' := by\n  simp only [Iso.inv_comp_eq, isoIsPullback_hom_snd]\n\n"}
{"name":"CategoryTheory.IsPullback.isoIsPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nP' : C\nfst' : Quiver.Hom P' X\nsnd' : Quiver.Hom P' Y\nh : CategoryTheory.IsPullback fst snd f g\nh' : CategoryTheory.IsPullback fst' snd' f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPullback.isoIsPullback X Y h h').inv snd) snd'","decl":"@[reassoc (attr := simp)]\ntheorem isoIsPullback_inv_snd (h : IsPullback fst snd f g) (h' : IsPullback fst' snd' f g) :\n    (h.isoIsPullback _ _ h').inv ≫ snd = snd' := by\n  simp only [Iso.inv_comp_eq, isoIsPullback_hom_snd]\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoPullback.hom (CategoryTheory.Limits.pullback.fst f g)) fst","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_hom_fst (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.hom ≫ pullback.fst _ _ = fst := by\n  dsimp [isoPullback, cone, CommSq.cone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nh✝ : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoPullback.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp fst h)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_hom_fst (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.hom ≫ pullback.fst _ _ = fst := by\n  dsimp [isoPullback, cone, CommSq.cone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nh✝ : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoPullback.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp snd h)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_hom_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.hom ≫ pullback.snd _ _ = snd := by\n  dsimp [isoPullback, cone, CommSq.cone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoPullback.hom (CategoryTheory.Limits.pullback.snd f g)) snd","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_hom_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.hom ≫ pullback.snd _ _ = snd := by\n  dsimp [isoPullback, cone, CommSq.cone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoPullback.inv fst) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_inv_fst (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv ≫ fst = pullback.fst _ _ := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nh✝ : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoPullback.inv (CategoryTheory.CategoryStruct.comp fst h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_inv_fst (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv ≫ fst = pullback.fst _ _ := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoPullback.inv snd) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_inv_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv ≫ snd = pullback.snd _ _ := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.IsPullback.isoPullback_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z✝ : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nh✝ : CategoryTheory.IsPullback fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoPullback.inv (CategoryTheory.CategoryStruct.comp snd h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem isoPullback_inv_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.inv ≫ snd = pullback.snd _ _ := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.IsPullback.of_iso_pullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.CommSq fst snd f g\ninst✝ : CategoryTheory.Limits.HasPullback f g\ni : CategoryTheory.Iso P (CategoryTheory.Limits.pullback f g)\nw₁ : Eq (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.pullback.fst f g)) fst\nw₂ : Eq (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.pullback.snd f g)) snd\n⊢ CategoryTheory.IsPullback fst snd f g","decl":"theorem of_iso_pullback (h : CommSq fst snd f g) [HasPullback f g] (i : P ≅ pullback f g)\n    (w₁ : i.hom ≫ pullback.fst _ _ = fst) (w₂ : i.hom ≫ pullback.snd _ _ = snd) :\n      IsPullback fst snd f g :=\n  of_isLimit' h\n    (Limits.IsLimit.ofIsoLimit (limit.isLimit _)\n      (@PullbackCone.ext _ _ _ _ _ _ _ (PullbackCone.mk _ _ _) _ i w₁.symm w₂.symm).symm)\n\n"}
{"name":"CategoryTheory.IsPullback.of_horiz_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.IsIso fst\ninst✝ : CategoryTheory.IsIso g\nsq : CategoryTheory.CommSq fst snd f g\n⊢ CategoryTheory.IsPullback fst snd f g","decl":"theorem of_horiz_isIso [IsIso fst] [IsIso g] (sq : CommSq fst snd f g) : IsPullback fst snd f g :=\n  of_isLimit' sq\n    (by\n      refine\n        PullbackCone.IsLimit.mk _ (fun s => s.fst ≫ inv fst) (by simp)\n          (fun s => ?_) (by aesop_cat)\n      simp only [← cancel_mono g, Category.assoc, ← sq.w, IsIso.inv_hom_id_assoc, s.condition])\n\n"}
{"name":"CategoryTheory.IsPullback.of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\nP' X' Y' Z' : C\nfst' : Quiver.Hom P' X'\nsnd' : Quiver.Hom P' Y'\nf' : Quiver.Hom X' Z'\ng' : Quiver.Hom Y' Z'\ne₁ : CategoryTheory.Iso P P'\ne₂ : CategoryTheory.Iso X X'\ne₃ : CategoryTheory.Iso Y Y'\ne₄ : CategoryTheory.Iso Z Z'\ncommfst : Eq (CategoryTheory.CategoryStruct.comp fst e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom fst')\ncommsnd : Eq (CategoryTheory.CategoryStruct.comp snd e₃.hom) (CategoryTheory.CategoryStruct.comp e₁.hom snd')\ncommf : Eq (CategoryTheory.CategoryStruct.comp f e₄.hom) (CategoryTheory.CategoryStruct.comp e₂.hom f')\ncommg : Eq (CategoryTheory.CategoryStruct.comp g e₄.hom) (CategoryTheory.CategoryStruct.comp e₃.hom g')\n⊢ CategoryTheory.IsPullback fst' snd' f' g'","decl":"lemma of_iso (h : IsPullback fst snd f g)\n    {P' X' Y' Z' : C} {fst' : P' ⟶ X'} {snd' : P' ⟶ Y'} {f' : X' ⟶ Z'} {g' : Y' ⟶ Z'}\n    (e₁ : P ≅ P') (e₂ : X ≅ X') (e₃ : Y ≅ Y') (e₄ : Z ≅ Z')\n    (commfst : fst ≫ e₂.hom = e₁.hom ≫ fst')\n    (commsnd : snd ≫ e₃.hom = e₁.hom ≫ snd')\n    (commf : f ≫ e₄.hom = e₂.hom ≫ f')\n    (commg : g ≫ e₄.hom = e₃.hom ≫ g') :\n    IsPullback fst' snd' f' g' where\n  w := by\n    rw [← cancel_epi e₁.hom, ← reassoc_of% commfst, ← commf,\n      ← reassoc_of% commsnd, ← commg, h.w_assoc]\n  isLimit' :=\n    ⟨(IsLimit.postcomposeInvEquiv\n        (cospanExt e₂ e₃ e₄ commf.symm commg.symm) _).1\n          (IsLimit.ofIsoLimit h.isLimit (by\n            refine PullbackCone.ext e₁ ?_ ?_\n            · change fst = e₁.hom ≫ fst' ≫ e₂.inv\n              rw [← reassoc_of% commfst, e₂.hom_inv_id, Category.comp_id]\n            · change snd = e₁.hom ≫ snd' ≫ e₃.inv\n              rw [← reassoc_of% commsnd, e₃.hom_inv_id, Category.comp_id]))⟩\n"}
{"name":"CategoryTheory.IsPullback.isIso_fst_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y : C\nfst snd : Quiver.Hom P X\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nh : CategoryTheory.IsPullback fst snd f f\n⊢ CategoryTheory.IsIso fst","decl":"lemma isIso_fst_of_mono (h : IsPullback fst snd f f) : IsIso fst :=\n  h.cone.isIso_fst_of_mono_of_isLimit h.isLimit\n\n"}
{"name":"CategoryTheory.IsPullback.isIso_snd_iso_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y : C\nfst snd : Quiver.Hom P X\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nh : CategoryTheory.IsPullback fst snd f f\n⊢ CategoryTheory.IsIso snd","decl":"lemma isIso_snd_iso_of_mono {P X Y : C} {fst : P ⟶ X} {snd : P ⟶ X} {f : X ⟶ Y} [Mono f]\n    (h : IsPullback fst snd f f) : IsIso snd :=\n  h.cone.isIso_snd_of_mono_of_isLimit h.isLimit\n\n"}
{"name":"CategoryTheory.IsPushout.cocone_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ Eq h.cocone.inl inl","decl":"@[simp]\ntheorem cocone_inl (h : IsPushout f g inl inr) : h.cocone.inl = inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsPushout.cocone_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ Eq h.cocone.inr inr","decl":"@[simp]\ntheorem cocone_inr (h : IsPushout f g inl inr) : h.cocone.inr = inr :=\n  rfl\n\n"}
{"name":"CategoryTheory.IsPushout.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nhP : CategoryTheory.IsPushout f g inl inr\nW : C\nh : Quiver.Hom X W\nk : Quiver.Hom Y W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl (hP.desc h k w)) h","decl":"@[reassoc (attr := simp)]\nlemma inl_desc (hP : IsPushout f g inl inr) {W : C} (h : X ⟶ W) (k : Y ⟶ W)\n    (w : f ≫ h = g ≫ k) : inl ≫ hP.desc h k w = h :=\n  PushoutCocone.IsColimit.inl_desc hP.isColimit h k w\n\n"}
{"name":"CategoryTheory.IsPushout.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nhP : CategoryTheory.IsPushout f g inl inr\nW : C\nh✝ : Quiver.Hom X W\nk : Quiver.Hom Y W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl (CategoryTheory.CategoryStruct.comp (hP.desc h✝ k w) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma inl_desc (hP : IsPushout f g inl inr) {W : C} (h : X ⟶ W) (k : Y ⟶ W)\n    (w : f ≫ h = g ≫ k) : inl ≫ hP.desc h k w = h :=\n  PushoutCocone.IsColimit.inl_desc hP.isColimit h k w\n\n"}
{"name":"CategoryTheory.IsPushout.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nhP : CategoryTheory.IsPushout f g inl inr\nW : C\nh✝ : Quiver.Hom X W\nk : Quiver.Hom Y W\nw : Eq (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr (CategoryTheory.CategoryStruct.comp (hP.desc h✝ k w) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma inr_desc (hP : IsPushout f g inl inr) {W : C} (h : X ⟶ W) (k : Y ⟶ W)\n    (w : f ≫ h = g ≫ k) : inr ≫ hP.desc h k w = k :=\n  PushoutCocone.IsColimit.inr_desc hP.isColimit h k w\n\n"}
{"name":"CategoryTheory.IsPushout.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nhP : CategoryTheory.IsPushout f g inl inr\nW : C\nh : Quiver.Hom X W\nk : Quiver.Hom Y W\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr (hP.desc h k w)) k","decl":"@[reassoc (attr := simp)]\nlemma inr_desc (hP : IsPushout f g inl inr) {W : C} (h : X ⟶ W) (k : Y ⟶ W)\n    (w : f ≫ h = g ≫ k) : inr ≫ hP.desc h k w = k :=\n  PushoutCocone.IsColimit.inr_desc hP.isColimit h k w\n\n"}
{"name":"CategoryTheory.IsPushout.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nhP : CategoryTheory.IsPushout f g inl inr\nW : C\nk l : Quiver.Hom P W\nh₀ : Eq (CategoryTheory.CategoryStruct.comp inl k) (CategoryTheory.CategoryStruct.comp inl l)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp inr k) (CategoryTheory.CategoryStruct.comp inr l)\n⊢ Eq k l","decl":"lemma hom_ext (hP : IsPushout f g inl inr) {W : C} {k l : P ⟶ W}\n    (h₀ : inl ≫ k = inl ≫ l) (h₁ : inr ≫ k = inr ≫ l) : k = l :=\n  PushoutCocone.IsColimit.hom_ext hP.isColimit h₀ h₁\n\n"}
{"name":"CategoryTheory.IsPushout.of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\nc : CategoryTheory.Limits.PushoutCocone f g\nh : CategoryTheory.Limits.IsColimit c\n⊢ CategoryTheory.IsPushout f g c.inl c.inr","decl":"/-- If `c` is a colimiting pushout cocone, then we have an `IsPushout f g c.inl c.inr`. -/\ntheorem of_isColimit {c : PushoutCocone f g} (h : Limits.IsColimit c) : IsPushout f g c.inl c.inr :=\n  { w := c.condition\n    isColimit' :=\n      ⟨IsColimit.ofIsoColimit h (Limits.PushoutCocone.ext (Iso.refl _)\n        (by simp) (by simp))⟩ }\n\n"}
{"name":"CategoryTheory.IsPushout.of_isColimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nw : CategoryTheory.CommSq f g inl inr\nh : CategoryTheory.Limits.IsColimit w.cocone\n⊢ CategoryTheory.IsPushout f g inl inr","decl":"/-- A variant of `of_isColimit` that is more useful with `apply`. -/\ntheorem of_isColimit' (w : CommSq f g inl inr) (h : Limits.IsColimit w.cocone) :\n    IsPushout f g inl inr :=\n  of_isColimit h\n\n"}
{"name":"CategoryTheory.IsPushout.of_isColimit_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nD : CategoryTheory.Functor CategoryTheory.Limits.WalkingSpan C\nc : CategoryTheory.Limits.Cocone D\nhc : CategoryTheory.Limits.IsColimit c\n⊢ CategoryTheory.IsPushout (D.map CategoryTheory.Limits.WalkingSpan.Hom.fst) (D.map CategoryTheory.Limits.WalkingSpan.Hom.snd) (c.ι.app CategoryTheory.Limits.WalkingSpan.left) (c.ι.app CategoryTheory.Limits.WalkingSpan.right)","decl":"/-- Variant of `of_isColimit` for an arbitrary cocone on a diagram `WalkingSpan ⥤ C`. -/\nlemma of_isColimit_cocone {D : WalkingSpan ⥤ C} {c : Cocone D} (hc : IsColimit c) :\n    IsPushout (D.map WalkingSpan.Hom.fst) (D.map WalkingSpan.Hom.snd)\n      (c.ι.app .left) (c.ι.app .right) where\n  w := by simp_rw [Cocone.w]\n  isColimit' := ⟨IsColimit.equivOfNatIsoOfIso _ _ _ (PushoutCocone.isoMk c) hc⟩\n\n"}
{"name":"CategoryTheory.IsPushout.hasPushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.Limits.HasPushout f g","decl":"lemma hasPushout (h : IsPushout f g inl inr) : HasPushout f g where\n  exists_colimit := ⟨⟨h.cocone, h.isColimit⟩⟩\n\n"}
{"name":"CategoryTheory.IsPushout.of_hasPushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ CategoryTheory.IsPushout f g (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.inr f g)","decl":"/-- The pushout provided by `HasPushout f g` fits into an `IsPushout`. -/\ntheorem of_hasPushout (f : Z ⟶ X) (g : Z ⟶ Y) [HasPushout f g] :\n    IsPushout f g (pushout.inl f g) (pushout.inr f g) :=\n  of_isColimit (colimit.isColimit (span f g))\n\n"}
{"name":"CategoryTheory.IsPushout.of_is_coproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.Limits.IsColimit c\nt : CategoryTheory.Limits.IsInitial Z\n⊢ CategoryTheory.IsPushout (t.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left })) (t.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right })) c.inl c.inr","decl":"/-- If `c` is a colimiting binary coproduct cocone, and we have an initial object,\nthen we have `IsPushout 0 0 c.inl c.inr`\n(where each `0` is the unique morphism from the initial object). -/\ntheorem of_is_coproduct {c : BinaryCofan X Y} (h : Limits.IsColimit c) (t : IsInitial Z) :\n    IsPushout (t.to _) (t.to _) c.inl c.inr :=\n  of_isColimit\n    (isPushoutOfIsInitialIsCoproduct _ _ _ _ t\n      (IsColimit.ofIsoColimit h\n        (Limits.Cocones.ext (Iso.refl c.pt)\n          (by\n            rintro ⟨⟨⟩⟩ <;>\n              · dsimp\n                simp))))\n\n"}
{"name":"CategoryTheory.IsPushout.of_is_coproduct'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk inl inr)\nt : CategoryTheory.Limits.IsInitial Z\n⊢ CategoryTheory.IsPushout (t.to X) (t.to Y) inl inr","decl":"/-- A variant of `of_is_coproduct` that is more useful with `apply`. -/\ntheorem of_is_coproduct' (h : Limits.IsColimit (BinaryCofan.mk inl inr)) (t : IsInitial Z) :\n    IsPushout (t.to _) (t.to _) inl inr :=\n  of_is_coproduct h t\n\n"}
{"name":"CategoryTheory.IsPushout.of_hasBinaryCoproduct'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.IsPushout (CategoryTheory.Limits.initial.to X) (CategoryTheory.Limits.initial.to Y) CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr","decl":"theorem of_hasBinaryCoproduct' [HasBinaryCoproduct X Y] [HasInitial C] :\n    IsPushout (initial.to _) (initial.to _) (coprod.inl : X ⟶ _) (coprod.inr : Y ⟶ _) :=\n  of_is_coproduct (colimit.isColimit _) initialIsInitial\n\n"}
{"name":"CategoryTheory.IsPushout.of_hasBinaryCoproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\n⊢ CategoryTheory.IsPushout 0 0 CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr","decl":"theorem of_hasBinaryCoproduct [HasBinaryCoproduct X Y] [HasZeroObject C] [HasZeroMorphisms C] :\n    IsPushout (0 : 0 ⟶ X) (0 : 0 ⟶ Y) coprod.inl coprod.inr := by\n  convert @of_is_coproduct _ _ 0 X Y _ (colimit.isColimit _) HasZeroObject.zeroIsInitial\n    <;> subsingleton\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoIsPushout_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl (CategoryTheory.IsPushout.isoIsPushout X Y h h').hom) inl'","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoIsPushout_hom (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inl ≫ (h.isoIsPushout _ _ h').hom = inl' :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom h.isColimit h'.isColimit WalkingSpan.left\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoIsPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh✝ : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\nZ : C\nh : Quiver.Hom P' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPushout.isoIsPushout X Y h✝ h').hom h)) (CategoryTheory.CategoryStruct.comp inl' h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoIsPushout_hom (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inl ≫ (h.isoIsPushout _ _ h').hom = inl' :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom h.isColimit h'.isColimit WalkingSpan.left\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoIsPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh✝ : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\nZ : C\nh : Quiver.Hom P' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPushout.isoIsPushout X Y h✝ h').hom h)) (CategoryTheory.CategoryStruct.comp inr' h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoIsPushout_hom (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inr ≫ (h.isoIsPushout _ _ h').hom = inr' :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom h.isColimit h'.isColimit WalkingSpan.right\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoIsPushout_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr (CategoryTheory.IsPushout.isoIsPushout X Y h h').hom) inr'","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoIsPushout_hom (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inr ≫ (h.isoIsPushout _ _ h').hom = inr' :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom h.isColimit h'.isColimit WalkingSpan.right\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoIsPushout_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl' (CategoryTheory.IsPushout.isoIsPushout X Y h h').inv) inl","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoIsPushout_inv (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inl' ≫ (h.isoIsPushout _ _ h').inv = inl := by\n  simp only [Iso.comp_inv_eq, inl_isoIsPushout_hom]\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoIsPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh✝ : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl' (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPushout.isoIsPushout X Y h✝ h').inv h)) (CategoryTheory.CategoryStruct.comp inl h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoIsPushout_inv (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inl' ≫ (h.isoIsPushout _ _ h').inv = inl := by\n  simp only [Iso.comp_inv_eq, inl_isoIsPushout_hom]\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoIsPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh✝ : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr' (CategoryTheory.CategoryStruct.comp (CategoryTheory.IsPushout.isoIsPushout X Y h✝ h').inv h)) (CategoryTheory.CategoryStruct.comp inr h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoIsPushout_inv (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inr' ≫ (h.isoIsPushout _ _ h').inv = inr := by\n  simp only [Iso.comp_inv_eq, inr_isoIsPushout_hom]\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoIsPushout_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nP' : C\ninl' : Quiver.Hom X P'\ninr' : Quiver.Hom Y P'\nh : CategoryTheory.IsPushout f g inl inr\nh' : CategoryTheory.IsPushout f g inl' inr'\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr' (CategoryTheory.IsPushout.isoIsPushout X Y h h').inv) inr","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoIsPushout_inv (h : IsPushout f g inl inr) (h' : IsPushout f g inl' inr') :\n    inr' ≫ (h.isoIsPushout _ _ h').inv = inr := by\n  simp only [Iso.comp_inv_eq, inr_isoIsPushout_hom]\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoPushout_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h.isoPushout.inv) inl","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoPushout_inv (h : IsPushout f g inl inr) [HasPushout f g] :\n    pushout.inl _ _ ≫ h.isoPushout.inv = inl := by\n  dsimp [isoPushout, cocone, CommSq.cocone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh✝ : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp h✝.isoPushout.inv h)) (CategoryTheory.CategoryStruct.comp inl h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoPushout_inv (h : IsPushout f g inl inr) [HasPushout f g] :\n    pushout.inl _ _ ≫ h.isoPushout.inv = inl := by\n  dsimp [isoPushout, cocone, CommSq.cocone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoPushout_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh✝ : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp h✝.isoPushout.inv h)) (CategoryTheory.CategoryStruct.comp inr h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoPushout_inv (h : IsPushout f g inl inr) [HasPushout f g] :\n    pushout.inr _ _ ≫ h.isoPushout.inv = inr := by\n  dsimp [isoPushout, cocone, CommSq.cocone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoPushout_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h.isoPushout.inv) inr","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoPushout_inv (h : IsPushout f g inl inr) [HasPushout f g] :\n    pushout.inr _ _ ≫ h.isoPushout.inv = inr := by\n  dsimp [isoPushout, cocone, CommSq.cocone]\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoPushout_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl h.isoPushout.hom) (CategoryTheory.Limits.pushout.inl f g)","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inl ≫ h.isoPushout.hom = pushout.inl _ _ := by simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.IsPushout.inl_isoPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh✝ : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inl (CategoryTheory.CategoryStruct.comp h✝.isoPushout.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inl ≫ h.isoPushout.hom = pushout.inl _ _ := by simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoPushout_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ✝ X Y P : C\nf : Quiver.Hom Z✝ X\ng : Quiver.Hom Z✝ Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh✝ : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr (CategoryTheory.CategoryStruct.comp h✝.isoPushout.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inr ≫ h.isoPushout.hom = pushout.inr _ _ := by simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.IsPushout.inr_isoPushout_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp inr h.isoPushout.hom) (CategoryTheory.Limits.pushout.inr f g)","decl":"@[reassoc (attr := simp)]\ntheorem inr_isoPushout_hom (h : IsPushout f g inl inr) [HasPushout f g] :\n    inr ≫ h.isoPushout.hom = pushout.inr _ _ := by simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.IsPushout.of_iso_pushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.CommSq f g inl inr\ninst✝ : CategoryTheory.Limits.HasPushout f g\ni : CategoryTheory.Iso P (CategoryTheory.Limits.pushout f g)\nw₁ : Eq (CategoryTheory.CategoryStruct.comp inl i.hom) (CategoryTheory.Limits.pushout.inl f g)\nw₂ : Eq (CategoryTheory.CategoryStruct.comp inr i.hom) (CategoryTheory.Limits.pushout.inr f g)\n⊢ CategoryTheory.IsPushout f g inl inr","decl":"theorem of_iso_pushout (h : CommSq f g inl inr) [HasPushout f g] (i : P ≅ pushout f g)\n    (w₁ : inl ≫ i.hom = pushout.inl _ _) (w₂ : inr ≫ i.hom = pushout.inr _ _) :\n      IsPushout f g inl inr :=\n  of_isColimit' h\n    (Limits.IsColimit.ofIsoColimit (colimit.isColimit _)\n      (PushoutCocone.ext (s := PushoutCocone.mk ..) i w₁ w₂).symm)\n\n"}
{"name":"CategoryTheory.IsPushout.of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\nZ' X' Y' P' : C\nf' : Quiver.Hom Z' X'\ng' : Quiver.Hom Z' Y'\ninl' : Quiver.Hom X' P'\ninr' : Quiver.Hom Y' P'\ne₁ : CategoryTheory.Iso Z Z'\ne₂ : CategoryTheory.Iso X X'\ne₃ : CategoryTheory.Iso Y Y'\ne₄ : CategoryTheory.Iso P P'\ncommf : Eq (CategoryTheory.CategoryStruct.comp f e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom f')\ncommg : Eq (CategoryTheory.CategoryStruct.comp g e₃.hom) (CategoryTheory.CategoryStruct.comp e₁.hom g')\ncomminl : Eq (CategoryTheory.CategoryStruct.comp inl e₄.hom) (CategoryTheory.CategoryStruct.comp e₂.hom inl')\ncomminr : Eq (CategoryTheory.CategoryStruct.comp inr e₄.hom) (CategoryTheory.CategoryStruct.comp e₃.hom inr')\n⊢ CategoryTheory.IsPushout f' g' inl' inr'","decl":"lemma of_iso (h : IsPushout f g inl inr)\n    {Z' X' Y' P' : C} {f' : Z' ⟶ X'} {g' : Z' ⟶ Y'} {inl' : X' ⟶ P'} {inr' : Y' ⟶ P'}\n    (e₁ : Z ≅ Z') (e₂ : X ≅ X') (e₃ : Y ≅ Y') (e₄ : P ≅ P')\n    (commf : f ≫ e₂.hom = e₁.hom ≫ f')\n    (commg : g ≫ e₃.hom = e₁.hom ≫ g')\n    (comminl : inl ≫ e₄.hom = e₂.hom ≫ inl')\n    (comminr : inr ≫ e₄.hom = e₃.hom ≫ inr') :\n    IsPushout f' g' inl' inr' where\n  w := by\n    rw [← cancel_epi e₁.hom, ← reassoc_of% commf, ← comminl,\n      ← reassoc_of% commg, ← comminr, h.w_assoc]\n  isColimit' :=\n    ⟨(IsColimit.precomposeHomEquiv\n        (spanExt e₁ e₂ e₃ commf.symm commg.symm) _).1\n          (IsColimit.ofIsoColimit h.isColimit\n            (PushoutCocone.ext e₄ comminl comminr))⟩\n\n"}
{"name":"CategoryTheory.IsPushout.isIso_inl_iso_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y : C\ninl inr : Quiver.Hom X P\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.Epi f\nh : CategoryTheory.IsPushout f f inl inr\n⊢ CategoryTheory.IsIso inl","decl":"lemma isIso_inl_iso_of_epi (h : IsPushout f f inl inr) : IsIso inl :=\n  h.cocone.isIso_inl_of_epi_of_isColimit h.isColimit\n\n"}
{"name":"CategoryTheory.IsPushout.isIso_inr_iso_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP X Y : C\ninl inr : Quiver.Hom X P\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.Epi f\nh : CategoryTheory.IsPushout f f inl inr\n⊢ CategoryTheory.IsIso inr","decl":"lemma isIso_inr_iso_of_epi (h : IsPushout f f inl inr) : IsIso inr :=\n  h.cocone.isIso_inr_of_epi_of_isColimit h.isColimit\n\n"}
{"name":"CategoryTheory.IsPullback.flip","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ CategoryTheory.IsPullback snd fst g f","decl":"theorem flip (h : IsPullback fst snd f g) : IsPullback snd fst g f :=\n  of_isLimit (PullbackCone.flipIsLimit h.isLimit)\n\n"}
{"name":"CategoryTheory.IsPullback.flip_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Iff (CategoryTheory.IsPullback fst snd f g) (CategoryTheory.IsPullback snd fst g f)","decl":"theorem flip_iff : IsPullback fst snd f g ↔ IsPullback snd fst g f :=\n  ⟨flip, flip⟩\n\n"}
{"name":"CategoryTheory.IsPullback.zero_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPullback 0 0 (CategoryTheory.CategoryStruct.id X) 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the left and `𝟙 X` on the right is a pullback square. -/\n@[simp]\ntheorem zero_left (X : C) : IsPullback (0 : 0 ⟶ X) (0 : (0 : C) ⟶ 0) (𝟙 X) (0 : 0 ⟶ X) :=\n  { w := by simp\n    isLimit' :=\n      ⟨{  lift := fun _ => 0\n          fac := fun s => by\n            simpa [eq_iff_true_of_subsingleton] using\n              @PullbackCone.equalizer_ext _ _ _ _ _ _ _ s _ 0 (𝟙 _)\n                (by simpa using (PullbackCone.condition s).symm) }⟩ }\n\n"}
{"name":"CategoryTheory.IsPullback.zero_top","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPullback 0 0 0 (CategoryTheory.CategoryStruct.id X)","decl":"/-- The square with `0 : 0 ⟶ 0` on the top and `𝟙 X` on the bottom is a pullback square. -/\n@[simp]\ntheorem zero_top (X : C) : IsPullback (0 : (0 : C) ⟶ 0) (0 : 0 ⟶ X) (0 : 0 ⟶ X) (𝟙 X) :=\n  (zero_left X).flip\n\n"}
{"name":"CategoryTheory.IsPullback.zero_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPullback 0 (CategoryTheory.CategoryStruct.id X) 0 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the right and `𝟙 X` on the left is a pullback square. -/\n@[simp]\ntheorem zero_right (X : C) : IsPullback (0 : X ⟶ 0) (𝟙 X) (0 : (0 : C) ⟶ 0) (0 : X ⟶ 0) :=\n  of_iso_pullback (by simp) ((zeroProdIso X).symm ≪≫ (pullbackZeroZeroIso _ _).symm)\n    (by simp [eq_iff_true_of_subsingleton]) (by simp)\n\n"}
{"name":"CategoryTheory.IsPullback.zero_bot","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.id X) 0 0 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the bottom and `𝟙 X` on the top is a pullback square. -/\n@[simp]\ntheorem zero_bot (X : C) : IsPullback (𝟙 X) (0 : X ⟶ 0) (0 : X ⟶ 0) (0 : (0 : C) ⟶ 0) :=\n  (zero_right X).flip\n\n"}
{"name":"CategoryTheory.IsPullback.paste_vert","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁\nt : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁\n⊢ CategoryTheory.IsPullback h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁","decl":"/-- Paste two pullback squares \"vertically\" to obtain another pullback square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem paste_vert {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : IsPullback h₂₁ v₂₁ v₂₂ h₃₁) :\n    IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁ :=\n  of_isLimit (pasteHorizIsPullback rfl t.isLimit s.isLimit)\n\n"}
{"name":"CategoryTheory.IsPullback.paste_horiz","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁\nt : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)","decl":"/-- Paste two pullback squares \"horizontally\" to obtain another pullback square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem paste_horiz {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃}\n    {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : IsPullback h₁₂ v₁₂ v₁₃ h₂₂) :\n    IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂) :=\n  (paste_vert s.flip t.flip).flip\n\n"}
{"name":"CategoryTheory.IsPullback.of_bot","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPullback h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁\np : Eq (CategoryTheory.CategoryStruct.comp h₁₁ v₁₂) (CategoryTheory.CategoryStruct.comp v₁₁ h₂₁)\nt : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁\n⊢ CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁","decl":"/-- Given a pullback square assembled from a commuting square on the top and\na pullback square on the bottom, the top square is a pullback square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem of_bot {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂}\n    {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁)\n    (t : IsPullback h₂₁ v₂₁ v₂₂ h₃₁) : IsPullback h₁₁ v₁₁ v₁₂ h₂₁ :=\n  of_isLimit (leftSquareIsPullback (PullbackCone.mk h₁₁ _ p) rfl t.isLimit s.isLimit)\n\n"}
{"name":"CategoryTheory.IsPullback.of_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)\np : Eq (CategoryTheory.CategoryStruct.comp h₁₁ v₁₂) (CategoryTheory.CategoryStruct.comp v₁₁ h₂₁)\nt : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂\n⊢ CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁","decl":"/-- Given a pullback square assembled from a commuting square on the left and\na pullback square on the right, the left square is a pullback square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem of_right {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁)\n    (t : IsPullback h₁₂ v₁₂ v₁₃ h₂₂) : IsPullback h₁₁ v₁₁ v₁₂ h₂₁ :=\n  (of_bot s.flip p.symm t.flip).flip\n\n"}
{"name":"CategoryTheory.IsPullback.paste_vert_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁\ne : Eq (CategoryTheory.CategoryStruct.comp h₁₁ v₁₂) (CategoryTheory.CategoryStruct.comp v₁₁ h₂₁)\n⊢ Iff (CategoryTheory.IsPullback h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁) (CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁)","decl":"theorem paste_vert_iff {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPullback h₂₁ v₂₁ v₂₂ h₃₁) (e : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) :\n    IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁ ↔ IsPullback h₁₁ v₁₁ v₁₂ h₂₁ :=\n  ⟨fun h => h.of_bot e s, fun h => h.paste_vert s⟩\n\n"}
{"name":"CategoryTheory.IsPullback.paste_horiz_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂\ne : Eq (CategoryTheory.CategoryStruct.comp h₁₁ v₁₂) (CategoryTheory.CategoryStruct.comp v₁₁ h₂₁)\n⊢ Iff (CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)) (CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁)","decl":"theorem paste_horiz_iff {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃}\n    {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPullback h₁₂ v₁₂ v₁₃ h₂₂) (e : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) :\n    IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂) ↔ IsPullback h₁₁ v₁₁ v₁₂ h₂₁ :=\n  ⟨fun h => h.of_right e s, fun h => h.paste_horiz s⟩\n\n"}
{"name":"CategoryTheory.IsPullback.of_right'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nh₁₃ : Quiver.Hom X₁₁ X₁₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPullback h₁₃ v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)\nt : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂\n⊢ CategoryTheory.IsPullback (t.lift h₁₃ (CategoryTheory.CategoryStruct.comp v₁₁ h₂₁) ⋯) v₁₁ v₁₂ h₂₁","decl":"/-- Variant of `IsPullback.of_right` where `h₁₁` is induced from a morphism `h₁₃ : X₁₁ ⟶ X₁₃`, and\nthe universal property of the right square.\n\nThe objects fit in the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem of_right' {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₂₂ : X₂₂ ⟶ X₂₃} {h₁₃ : X₁₁ ⟶ X₁₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPullback h₁₃ v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (t : IsPullback h₁₂ v₁₂ v₁₃ h₂₂) :\n    IsPullback (t.lift h₁₃ (v₁₁ ≫ h₂₁) (by rw [s.w, Category.assoc])) v₁₁ v₁₂ h₂₁ :=\n  of_right ((t.lift_fst _ _ _) ▸ s) (t.lift_snd _ _ _) t\n\n"}
{"name":"CategoryTheory.IsPullback.of_bot'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₃₁ : Quiver.Hom X₁₁ X₃₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPullback h₁₁ v₃₁ (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁\nt : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁\n⊢ CategoryTheory.IsPullback h₁₁ (t.lift (CategoryTheory.CategoryStruct.comp h₁₁ v₁₂) v₃₁ ⋯) v₁₂ h₂₁","decl":"/-- Variant of `IsPullback.of_bot`, where `v₁₁` is induced from a morphism `v₃₁ : X₁₁ ⟶ X₃₁`, and\nthe universal property of the bottom square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem of_bot' {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₃₁ : X₃₁ ⟶ X₃₂} {v₃₁ : X₁₁ ⟶ X₃₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPullback h₁₁ v₃₁ (v₁₂ ≫ v₂₂) h₃₁) (t : IsPullback h₂₁ v₂₁ v₂₂ h₃₁) :\n    IsPullback h₁₁ (t.lift (h₁₁ ≫ v₁₂) v₃₁ (by rw [Category.assoc, s.w])) v₁₂ h₂₁ :=\n  of_bot ((t.lift_snd _ _ _) ▸ s) (by simp only [lift_fst]) t\n\n"}
{"name":"CategoryTheory.IsPullback.of_isBilimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPullback b.fst b.snd 0 0","decl":"theorem of_isBilimit {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback b.fst b.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) := by\n  convert IsPullback.of_is_product' h.isLimit HasZeroObject.zeroIsTerminal\n    <;> subsingleton\n\n"}
{"name":"CategoryTheory.IsPullback.of_has_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPullback CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd 0 0","decl":"@[simp]\ntheorem of_has_biproduct (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPullback biprod.fst biprod.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) :=\n  of_isBilimit (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPullback.inl_snd'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPullback b.inl 0 b.snd 0","decl":"theorem inl_snd' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback b.inl (0 : X ⟶ 0) b.snd (0 : 0 ⟶ Y) := by\n  refine of_right ?_ (by simp) (of_isBilimit h)\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPullback CategoryTheory.Limits.biprod.inl 0 CategoryTheory.Limits.biprod.snd 0","decl":"/-- The square\n```\n  X --inl--> X ⊞ Y\n  |            |\n  0           snd\n  |            |\n  v            v\n  0 ---0-----> Y\n```\nis a pullback square.\n-/\n@[simp]\ntheorem inl_snd (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPullback biprod.inl (0 : X ⟶ 0) biprod.snd (0 : 0 ⟶ Y) :=\n  inl_snd' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPullback.inr_fst'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPullback b.inr 0 b.fst 0","decl":"theorem inr_fst' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback b.inr (0 : Y ⟶ 0) b.fst (0 : 0 ⟶ X) := by\n  apply flip\n  refine of_bot ?_ (by simp) (of_isBilimit h)\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPullback CategoryTheory.Limits.biprod.inr 0 CategoryTheory.Limits.biprod.fst 0","decl":"/-- The square\n```\n  Y --inr--> X ⊞ Y\n  |            |\n  0           fst\n  |            |\n  v            v\n  0 ---0-----> X\n```\nis a pullback square.\n-/\n@[simp]\ntheorem inr_fst (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPullback biprod.inr (0 : Y ⟶ 0) biprod.fst (0 : 0 ⟶ X) :=\n  inr_fst' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPullback.of_is_bilimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPullback 0 0 b.inl b.inr","decl":"theorem of_is_bilimit' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback (0 : 0 ⟶ X) (0 : 0 ⟶ Y) b.inl b.inr := by\n  refine IsPullback.of_right ?_ (by simp) (IsPullback.inl_snd' h).flip\n  simp\n\n"}
{"name":"CategoryTheory.IsPullback.of_hasBinaryBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPullback 0 0 CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr","decl":"theorem of_hasBinaryBiproduct (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPullback (0 : 0 ⟶ X) (0 : 0 ⟶ Y) biprod.inl biprod.inr :=\n  of_is_bilimit' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPullback.hasPullback_biprod_fst_biprod_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasPullback CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr","decl":"instance hasPullback_biprod_fst_biprod_snd [HasBinaryBiproduct X Y] :\n    HasPullback (biprod.inl : X ⟶ _) (biprod.inr : Y ⟶ _) :=\n  HasLimit.mk ⟨_, (of_hasBinaryBiproduct X Y).isLimit⟩\n\n"}
{"name":"CategoryTheory.IsPullback.op","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ CategoryTheory.IsPushout g.op f.op snd.op fst.op","decl":"theorem op (h : IsPullback fst snd f g) : IsPushout g.op f.op snd.op fst.op :=\n  IsPushout.of_isColimit\n    (IsColimit.ofIsoColimit (Limits.PullbackCone.isLimitEquivIsColimitOp h.flip.cone h.flip.isLimit)\n      h.toCommSq.flip.coneOp)\n\n"}
{"name":"CategoryTheory.IsPullback.unop","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : Opposite C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nh : CategoryTheory.IsPullback fst snd f g\n⊢ CategoryTheory.IsPushout g.unop f.unop snd.unop fst.unop","decl":"theorem unop {P X Y Z : Cᵒᵖ} {fst : P ⟶ X} {snd : P ⟶ Y} {f : X ⟶ Z} {g : Y ⟶ Z}\n    (h : IsPullback fst snd f g) : IsPushout g.unop f.unop snd.unop fst.unop :=\n  IsPushout.of_isColimit\n    (IsColimit.ofIsoColimit\n      (Limits.PullbackCone.isLimitEquivIsColimitUnop h.flip.cone h.flip.isLimit)\n      h.toCommSq.flip.coneUnop)\n\n"}
{"name":"CategoryTheory.IsPullback.of_vert_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nP X Y Z : C\nfst : Quiver.Hom P X\nsnd : Quiver.Hom P Y\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.IsIso snd\ninst✝ : CategoryTheory.IsIso f\nsq : CategoryTheory.CommSq fst snd f g\n⊢ CategoryTheory.IsPullback fst snd f g","decl":"theorem of_vert_isIso [IsIso snd] [IsIso f] (sq : CommSq fst snd f g) : IsPullback fst snd f g :=\n  IsPullback.flip (of_horiz_isIso sq.flip)\n\n"}
{"name":"CategoryTheory.IsPullback.of_id_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Z : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.id X) f f (CategoryTheory.CategoryStruct.id Z)","decl":"lemma of_id_fst : IsPullback (𝟙 _) f f (𝟙 _) := IsPullback.of_horiz_isIso ⟨by simp⟩\n\n"}
{"name":"CategoryTheory.IsPullback.of_id_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Z : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPullback f (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Z) f","decl":"lemma of_id_snd : IsPullback f (𝟙 _) (𝟙 _) f := IsPullback.of_vert_isIso ⟨by simp⟩\n\n"}
{"name":"CategoryTheory.IsPullback.id_vert","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Z : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPullback f (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Z) f","decl":"/-- The following diagram is a pullback\n```\nX --f--> Z\n|        |\nid       id\nv        v\nX --f--> Z\n```\n-/\nlemma id_vert (f : X ⟶ Z) : IsPullback f (𝟙 X) (𝟙 Z) f :=\n  of_vert_isIso ⟨by simp only [Category.id_comp, Category.comp_id]⟩\n\n"}
{"name":"CategoryTheory.IsPullback.id_horiz","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Z : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.id X) f f (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The following diagram is a pullback\n```\nX --id--> X\n|         |\nf         f\nv         v\nZ --id--> Z\n```\n-/\nlemma id_horiz (f : X ⟶ Z) : IsPullback (𝟙 X) f f (𝟙 Z) :=\n  of_horiz_isIso ⟨by simp only [Category.id_comp, Category.comp_id]⟩\n\n"}
{"name":"CategoryTheory.IsPushout.flip","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.IsPushout g f inr inl","decl":"theorem flip (h : IsPushout f g inl inr) : IsPushout g f inr inl :=\n  of_isColimit (PushoutCocone.flipIsColimit h.isColimit)\n\n"}
{"name":"CategoryTheory.IsPushout.flip_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\n⊢ Iff (CategoryTheory.IsPushout f g inl inr) (CategoryTheory.IsPushout g f inr inl)","decl":"theorem flip_iff : IsPushout f g inl inr ↔ IsPushout g f inr inl :=\n  ⟨flip, flip⟩\n\n"}
{"name":"CategoryTheory.IsPushout.zero_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPushout 0 (CategoryTheory.CategoryStruct.id X) 0 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the right and `𝟙 X` on the left is a pushout square. -/\n@[simp]\ntheorem zero_right (X : C) : IsPushout (0 : X ⟶ 0) (𝟙 X) (0 : (0 : C) ⟶ 0) (0 : X ⟶ 0) :=\n  { w := by simp\n    isColimit' :=\n      ⟨{  desc := fun _ => 0\n          fac := fun s => by\n            have c :=\n              @PushoutCocone.coequalizer_ext _ _ _ _ _ _ _ s _ 0 (𝟙 _)\n                (by simp [eq_iff_true_of_subsingleton]) (by simpa using PushoutCocone.condition s)\n            dsimp at c\n            simpa using c }⟩ }\n\n"}
{"name":"CategoryTheory.IsPushout.zero_bot","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.id X) 0 0 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the bottom and `𝟙 X` on the top is a pushout square. -/\n@[simp]\ntheorem zero_bot (X : C) : IsPushout (𝟙 X) (0 : X ⟶ 0) (0 : X ⟶ 0) (0 : (0 : C) ⟶ 0) :=\n  (zero_right X).flip\n\n"}
{"name":"CategoryTheory.IsPushout.zero_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPushout 0 0 (CategoryTheory.CategoryStruct.id X) 0","decl":"/-- The square with `0 : 0 ⟶ 0` on the right left `𝟙 X` on the right is a pushout square. -/\n@[simp]\ntheorem zero_left (X : C) : IsPushout (0 : 0 ⟶ X) (0 : (0 : C) ⟶ 0) (𝟙 X) (0 : 0 ⟶ X) :=\n  of_iso_pushout (by simp) ((coprodZeroIso X).symm ≪≫ (pushoutZeroZeroIso _ _).symm) (by simp)\n    (by simp [eq_iff_true_of_subsingleton])\n\n"}
{"name":"CategoryTheory.IsPushout.zero_top","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n⊢ CategoryTheory.IsPushout 0 0 0 (CategoryTheory.CategoryStruct.id X)","decl":"/-- The square with `0 : 0 ⟶ 0` on the top and `𝟙 X` on the bottom is a pushout square. -/\n@[simp]\ntheorem zero_top (X : C) : IsPushout (0 : (0 : C) ⟶ 0) (0 : 0 ⟶ X) (0 : 0 ⟶ X) (𝟙 X) :=\n  (zero_left X).flip\n\n"}
{"name":"CategoryTheory.IsPushout.paste_vert","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\nt : CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁\n⊢ CategoryTheory.IsPushout h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁","decl":"/-- Paste two pushout squares \"vertically\" to obtain another pushout square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem paste_vert {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : IsPushout h₂₁ v₂₁ v₂₂ h₃₁) :\n    IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁ :=\n  of_isColimit (pasteHorizIsPushout rfl s.isColimit t.isColimit)\n\n"}
{"name":"CategoryTheory.IsPushout.paste_horiz","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\nt : CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂\n⊢ CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)","decl":"/-- Paste two pushout squares \"horizontally\" to obtain another pushout square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem paste_horiz {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃}\n    {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : IsPushout h₁₂ v₁₂ v₁₃ h₂₂) :\n    IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂) :=\n  (paste_vert s.flip t.flip).flip\n\n"}
{"name":"CategoryTheory.IsPushout.of_top","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPushout h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁\np : Eq (CategoryTheory.CategoryStruct.comp h₂₁ v₂₂) (CategoryTheory.CategoryStruct.comp v₂₁ h₃₁)\nt : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\n⊢ CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁","decl":"/-- Given a pushout square assembled from a pushout square on the top and\na commuting square on the bottom, the bottom square is a pushout square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem of_top {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂}\n    {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₂₁ ≫ v₂₂ = v₂₁ ≫ h₃₁)\n    (t : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : IsPushout h₂₁ v₂₁ v₂₂ h₃₁ :=\n  of_isColimit <| rightSquareIsPushout\n    (PushoutCocone.mk _ _ p) (cocone_inr _) t.isColimit s.isColimit\n\n"}
{"name":"CategoryTheory.IsPushout.of_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)\np : Eq (CategoryTheory.CategoryStruct.comp h₁₂ v₁₃) (CategoryTheory.CategoryStruct.comp v₁₂ h₂₂)\nt : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\n⊢ CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂","decl":"/-- Given a pushout square assembled from a pushout square on the left and\na commuting square on the right, the right square is a pushout square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem of_left {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₂ ≫ v₁₃ = v₁₂ ≫ h₂₂)\n    (t : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : IsPushout h₁₂ v₁₂ v₁₃ h₂₂ :=\n  (of_top s.flip p.symm t.flip).flip\n\n"}
{"name":"CategoryTheory.IsPushout.paste_vert_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\nv₂₂ : Quiver.Hom X₂₂ X₃₂\ns : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\ne : Eq (CategoryTheory.CategoryStruct.comp h₂₁ v₂₂) (CategoryTheory.CategoryStruct.comp v₂₁ h₃₁)\n⊢ Iff (CategoryTheory.IsPushout h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) (CategoryTheory.CategoryStruct.comp v₁₂ v₂₂) h₃₁) (CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁)","decl":"theorem paste_vert_iff {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂}\n    (s : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (e : h₂₁ ≫ v₂₂ = v₂₁ ≫ h₃₁) :\n    IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁ ↔ IsPushout h₂₁ v₂₁ v₂₂ h₃₁ :=\n  ⟨fun h => h.of_top e s, s.paste_vert⟩\n\n"}
{"name":"CategoryTheory.IsPushout.paste_horiz_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₂ : Quiver.Hom X₂₂ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\ne : Eq (CategoryTheory.CategoryStruct.comp h₁₂ v₁₃) (CategoryTheory.CategoryStruct.comp v₁₂ h₂₂)\n⊢ Iff (CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂)) (CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂)","decl":"theorem paste_horiz_iff {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃}\n    {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (e : h₁₂ ≫ v₁₃ = v₁₂ ≫ h₂₂) :\n    IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂) ↔ IsPushout h₁₂ v₁₂ v₁₃ h₂₂ :=\n  ⟨fun h => h.of_left e s, s.paste_horiz⟩\n\n"}
{"name":"CategoryTheory.IsPushout.of_top'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₃₁ : Quiver.Hom X₃₁ X₃₂\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₂ X₃₂\nv₂₁ : Quiver.Hom X₂₁ X₃₁\ns : CategoryTheory.IsPushout h₁₁ (CategoryTheory.CategoryStruct.comp v₁₁ v₂₁) v₁₃ h₃₁\nt : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\n⊢ CategoryTheory.IsPushout h₂₁ v₂₁ (t.desc v₁₃ (CategoryTheory.CategoryStruct.comp v₂₁ h₃₁) ⋯) h₃₁","decl":"/-- Variant of `IsPushout.of_top` where `v₂₂` is induced from a morphism `v₁₃ : X₁₂ ⟶ X₃₂`, and\nthe universal property of the top square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂\n|            |\nv₁₁          v₁₂\n↓            ↓\nX₂₁ - h₂₁ -> X₂₂\n|            |\nv₂₁          v₂₂\n↓            ↓\nX₃₁ - h₃₁ -> X₃₂\n```\n-/\ntheorem of_top' {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂}\n    {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₂ ⟶ X₃₂} {v₂₁ : X₂₁ ⟶ X₃₁}\n    (s : IsPushout h₁₁ (v₁₁ ≫ v₂₁) v₁₃ h₃₁) (t : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) :\n      IsPushout h₂₁ v₂₁ (t.desc v₁₃ (v₂₁ ≫ h₃₁) (by rw [s.w, Category.assoc])) h₃₁ :=\n  of_top ((t.inl_desc _ _ _).symm ▸ s) (t.inr_desc _ _ _) t\n\n"}
{"name":"CategoryTheory.IsPushout.of_left'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C\nh₁₁ : Quiver.Hom X₁₁ X₁₂\nh₁₂ : Quiver.Hom X₁₂ X₁₃\nh₂₁ : Quiver.Hom X₂₁ X₂₂\nh₂₃ : Quiver.Hom X₂₁ X₂₃\nv₁₁ : Quiver.Hom X₁₁ X₂₁\nv₁₂ : Quiver.Hom X₁₂ X₂₂\nv₁₃ : Quiver.Hom X₁₃ X₂₃\ns : CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃ h₂₃\nt : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁\n⊢ CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ (t.desc (CategoryTheory.CategoryStruct.comp h₁₂ v₁₃) h₂₃ ⋯)","decl":"/-- Variant of `IsPushout.of_right` where `h₂₂` is induced from a morphism `h₂₃ : X₂₁ ⟶ X₂₃`, and\nthe universal property of the left square.\n\nThe objects in the statement fit into the following diagram:\n```\nX₁₁ - h₁₁ -> X₁₂ - h₁₂ -> X₁₃\n|            |            |\nv₁₁          v₁₂          v₁₃\n↓            ↓            ↓\nX₂₁ - h₂₁ -> X₂₂ - h₂₂ -> X₂₃\n```\n-/\ntheorem of_left' {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂}\n    {h₂₃ : X₂₁ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃}\n    (s : IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ h₂₃) (t : IsPushout h₁₁ v₁₁ v₁₂ h₂₁) :\n    IsPushout h₁₂ v₁₂ v₁₃ (t.desc (h₁₂ ≫ v₁₃) h₂₃ (by rw [← Category.assoc, s.w])) :=\n  of_left ((t.inr_desc _ _ _).symm ▸ s) (by simp only [inl_desc]) t\n\n"}
{"name":"CategoryTheory.IsPushout.of_isBilimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPushout 0 0 b.inl b.inr","decl":"theorem of_isBilimit {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPushout (0 : 0 ⟶ X) (0 : 0 ⟶ Y) b.inl b.inr := by\n  convert IsPushout.of_is_coproduct' h.isColimit HasZeroObject.zeroIsInitial\n    <;> subsingleton\n\n"}
{"name":"CategoryTheory.IsPushout.of_has_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPushout 0 0 CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr","decl":"@[simp]\ntheorem of_has_biproduct (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPushout (0 : 0 ⟶ X) (0 : 0 ⟶ Y) biprod.inl biprod.inr :=\n  of_isBilimit (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPushout.inl_snd'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPushout b.inl 0 b.snd 0","decl":"theorem inl_snd' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPushout b.inl (0 : X ⟶ 0) b.snd (0 : 0 ⟶ Y) := by\n  apply flip\n  refine of_left ?_ (by simp) (of_isBilimit h)\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPushout CategoryTheory.Limits.biprod.inl 0 CategoryTheory.Limits.biprod.snd 0","decl":"/-- The square\n```\n  X --inl--> X ⊞ Y\n  |            |\n  0           snd\n  |            |\n  v            v\n  0 ---0-----> Y\n```\nis a pushout square.\n-/\ntheorem inl_snd (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPushout biprod.inl (0 : X ⟶ 0) biprod.snd (0 : 0 ⟶ Y) :=\n  inl_snd' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPushout.inr_fst'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPushout b.inr 0 b.fst 0","decl":"theorem inr_fst' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPushout b.inr (0 : Y ⟶ 0) b.fst (0 : 0 ⟶ X) := by\n  refine of_top ?_ (by simp) (of_isBilimit h)\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPushout CategoryTheory.Limits.biprod.inr 0 CategoryTheory.Limits.biprod.fst 0","decl":"/-- The square\n```\n  Y --inr--> X ⊞ Y\n  |            |\n  0           fst\n  |            |\n  v            v\n  0 ---0-----> X\n```\nis a pushout square.\n-/\ntheorem inr_fst (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPushout biprod.inr (0 : Y ⟶ 0) biprod.fst (0 : 0 ⟶ X) :=\n  inr_fst' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPushout.of_is_bilimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.IsPushout b.fst b.snd 0 0","decl":"theorem of_is_bilimit' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPushout b.fst b.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) := by\n  refine IsPushout.of_left ?_ (by simp) (IsPushout.inl_snd' h)\n  simp\n\n"}
{"name":"CategoryTheory.IsPushout.of_hasBinaryBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsPushout CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd 0 0","decl":"theorem of_hasBinaryBiproduct (X Y : C) [HasBinaryBiproduct X Y] :\n    IsPushout biprod.fst biprod.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) :=\n  of_is_bilimit' (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.IsPushout.hasPushout_biprod_fst_biprod_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasPushout CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd","decl":"instance hasPushout_biprod_fst_biprod_snd [HasBinaryBiproduct X Y] :\n    HasPushout (biprod.fst : _ ⟶ X) (biprod.snd : _ ⟶ Y) :=\n  HasColimit.mk ⟨_, (of_hasBinaryBiproduct X Y).isColimit⟩\n\n"}
{"name":"CategoryTheory.IsPushout.op","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.IsPullback inr.op inl.op g.op f.op","decl":"theorem op (h : IsPushout f g inl inr) : IsPullback inr.op inl.op g.op f.op :=\n  IsPullback.of_isLimit\n    (IsLimit.ofIsoLimit\n      (Limits.PushoutCocone.isColimitEquivIsLimitOp h.flip.cocone h.flip.isColimit)\n      h.toCommSq.flip.coconeOp)\n\n"}
{"name":"CategoryTheory.IsPushout.unop","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : Opposite C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.IsPullback inr.unop inl.unop g.unop f.unop","decl":"theorem unop {Z X Y P : Cᵒᵖ} {f : Z ⟶ X} {g : Z ⟶ Y} {inl : X ⟶ P} {inr : Y ⟶ P}\n    (h : IsPushout f g inl inr) : IsPullback inr.unop inl.unop g.unop f.unop :=\n  IsPullback.of_isLimit\n    (IsLimit.ofIsoLimit\n      (Limits.PushoutCocone.isColimitEquivIsLimitUnop h.flip.cocone h.flip.isColimit)\n      h.toCommSq.flip.coconeUnop)\n\n"}
{"name":"CategoryTheory.IsPushout.of_horiz_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.IsIso inr\nsq : CategoryTheory.CommSq f g inl inr\n⊢ CategoryTheory.IsPushout f g inl inr","decl":"theorem of_horiz_isIso [IsIso f] [IsIso inr] (sq : CommSq f g inl inr) : IsPushout f g inl inr :=\n  of_isColimit' sq\n    (by\n      refine\n        PushoutCocone.IsColimit.mk _ (fun s => inv inr ≫ s.inr) (fun s => ?_)\n          (by simp) (by simp)\n      simp only [← cancel_epi f, s.condition, sq.w_assoc, IsIso.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.IsPushout.of_vert_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nZ X Y P : C\nf : Quiver.Hom Z X\ng : Quiver.Hom Z Y\ninl : Quiver.Hom X P\ninr : Quiver.Hom Y P\ninst✝¹ : CategoryTheory.IsIso g\ninst✝ : CategoryTheory.IsIso inl\nsq : CategoryTheory.CommSq f g inl inr\n⊢ CategoryTheory.IsPushout f g inl inr","decl":"theorem of_vert_isIso [IsIso g] [IsIso inl] (sq : CommSq f g inl inr) : IsPushout f g inl inr :=\n  (of_horiz_isIso sq.flip).flip\n\n"}
{"name":"CategoryTheory.IsPushout.of_id_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X : C\nf : Quiver.Hom Z X\n⊢ CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.id Z) f f (CategoryTheory.CategoryStruct.id X)","decl":"lemma of_id_fst : IsPushout (𝟙 _) f f (𝟙 _) := IsPushout.of_horiz_isIso ⟨by simp⟩\n\n"}
{"name":"CategoryTheory.IsPushout.of_id_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X : C\nf : Quiver.Hom Z X\n⊢ CategoryTheory.IsPushout f (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.id X) f","decl":"lemma of_id_snd : IsPushout f (𝟙 _) (𝟙 _) f := IsPushout.of_vert_isIso ⟨by simp⟩\n\n"}
{"name":"CategoryTheory.IsPushout.id_vert","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPushout f (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Z) f","decl":"/-- The following diagram is a pullback\n```\nX --f--> Z\n|        |\nid       id\nv        v\nX --f--> Z\n```\n-/\nlemma id_vert (f : X ⟶ Z) : IsPushout f (𝟙 X) (𝟙 Z) f :=\n  of_vert_isIso ⟨by simp only [Category.id_comp, Category.comp_id]⟩\n\n"}
{"name":"CategoryTheory.IsPushout.id_horiz","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nZ X : C\nf : Quiver.Hom X Z\n⊢ CategoryTheory.IsPushout (CategoryTheory.CategoryStruct.id X) f f (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The following diagram is a pullback\n```\nX --id--> X\n|         |\nf         f\nv         v\nZ --id--> Z\n```\n-/\nlemma id_horiz (f : X ⟶ Z) : IsPushout (𝟙 X) f f (𝟙 Z) :=\n  of_horiz_isIso ⟨by simp only [Category.id_comp, Category.comp_id]⟩\n\n"}
{"name":"CategoryTheory.BicartesianSq.of_isPullback_isPushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\np₁ : CategoryTheory.IsPullback f g h i\np₂ : CategoryTheory.IsPushout f g h i\n⊢ CategoryTheory.BicartesianSq f g h i","decl":"theorem of_isPullback_isPushout (p₁ : IsPullback f g h i) (p₂ : IsPushout f g h i) :\n    BicartesianSq f g h i :=\n  BicartesianSq.mk p₁ p₂.isColimit'\n\n"}
{"name":"CategoryTheory.BicartesianSq.flip","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\np : CategoryTheory.BicartesianSq f g h i\n⊢ CategoryTheory.BicartesianSq g f i h","decl":"theorem flip (p : BicartesianSq f g h i) : BicartesianSq g f i h :=\n  of_isPullback_isPushout p.toIsPullback.flip p.toIsPushout.flip\n\n"}
{"name":"CategoryTheory.BicartesianSq.of_is_biproduct₁","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.BicartesianSq b.fst b.snd 0 0","decl":"/-- ```\n X ⊞ Y --fst--> X\n   |            |\n  snd           0\n   |            |\n   v            v\n   Y -----0---> 0\n```\nis a bicartesian square.\n-/\ntheorem of_is_biproduct₁ {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    BicartesianSq b.fst b.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) :=\n  of_isPullback_isPushout (IsPullback.of_isBilimit h) (IsPushout.of_is_bilimit' h)\n\n"}
{"name":"CategoryTheory.BicartesianSq.of_is_biproduct₂","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nb : CategoryTheory.Limits.BinaryBicone X Y\nh : b.IsBilimit\n⊢ CategoryTheory.BicartesianSq 0 0 b.inl b.inr","decl":"/-- ```\n   0 -----0---> X\n   |            |\n   0           inl\n   |            |\n   v            v\n   Y --inr--> X ⊞ Y\n```\nis a bicartesian square.\n-/\ntheorem of_is_biproduct₂ {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    BicartesianSq (0 : 0 ⟶ X) (0 : 0 ⟶ Y) b.inl b.inr :=\n  of_isPullback_isPushout (IsPullback.of_is_bilimit' h) (IsPushout.of_isBilimit h)\n\n"}
{"name":"CategoryTheory.BicartesianSq.of_has_biproduct₁","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.BicartesianSq CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd 0 0","decl":"/-- ```\n X ⊞ Y --fst--> X\n   |            |\n  snd           0\n   |            |\n   v            v\n   Y -----0---> 0\n```\nis a bicartesian square.\n-/\n@[simp]\ntheorem of_has_biproduct₁ [HasBinaryBiproduct X Y] :\n    BicartesianSq biprod.fst biprod.snd (0 : X ⟶ 0) (0 : Y ⟶ 0) := by\n  convert of_is_biproduct₁ (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.BicartesianSq.of_has_biproduct₂","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.BicartesianSq 0 0 CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr","decl":"/-- ```\n   0 -----0---> X\n   |            |\n   0           inl\n   |            |\n   v            v\n   Y --inr--> X ⊞ Y\n```\nis a bicartesian square.\n-/\n@[simp]\ntheorem of_has_biproduct₂ [HasBinaryBiproduct X Y] :\n    BicartesianSq (0 : 0 ⟶ X) (0 : 0 ⟶ Y) biprod.inl biprod.inr := by\n  convert of_is_biproduct₂ (BinaryBiproduct.isBilimit X Y)\n\n"}
{"name":"CategoryTheory.Functor.map_isPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan h i) F\ns : CategoryTheory.IsPullback f g h i\n⊢ CategoryTheory.IsPullback (F.map f) (F.map g) (F.map h) (F.map i)","decl":"theorem Functor.map_isPullback [PreservesLimit (cospan h i) F] (s : IsPullback f g h i) :\n    IsPullback (F.map f) (F.map g) (F.map h) (F.map i) := by\n  -- This is made slightly awkward because `C` and `D` have different universes,\n  -- and so the relevant `WalkingCospan` diagrams live in different universes too!\n  refine\n    IsPullback.of_isLimit' (F.map_commSq s.toCommSq)\n      (IsLimit.equivOfNatIsoOfIso (cospanCompIso F h i) _ _ (WalkingCospan.ext ?_ ?_ ?_)\n        (isLimitOfPreserves F s.isLimit))\n  · rfl\n  · simp\n  · simp\n\n"}
{"name":"CategoryTheory.Functor.map_isPushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) F\ns : CategoryTheory.IsPushout f g h i\n⊢ CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)","decl":"theorem Functor.map_isPushout [PreservesColimit (span f g) F] (s : IsPushout f g h i) :\n    IsPushout (F.map f) (F.map g) (F.map h) (F.map i) := by\n  refine\n    IsPushout.of_isColimit' (F.map_commSq s.toCommSq)\n      (IsColimit.equivOfNatIsoOfIso (spanCompIso F f g) _ _ (WalkingSpan.ext ?_ ?_ ?_)\n        (isColimitOfPreserves F s.isColimit))\n  · rfl\n  · simp\n  · simp\n\n"}
{"name":"CategoryTheory.IsPullback.map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan h i) F\ns : CategoryTheory.IsPullback f g h i\n⊢ CategoryTheory.IsPullback (F.map f) (F.map g) (F.map h) (F.map i)","decl":"alias IsPullback.map := Functor.map_isPullback\n\n"}
{"name":"CategoryTheory.IsPushout.map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) F\ns : CategoryTheory.IsPushout f g h i\n⊢ CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)","decl":"alias IsPushout.map := Functor.map_isPushout\n\n"}
{"name":"CategoryTheory.IsPullback.of_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan h i) F\ne : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i)\nH : CategoryTheory.IsPullback (F.map f) (F.map g) (F.map h) (F.map i)\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPullback.of_map [ReflectsLimit (cospan h i) F] (e : f ≫ h = g ≫ i)\n    (H : IsPullback (F.map f) (F.map g) (F.map h) (F.map i)) : IsPullback f g h i := by\n  refine ⟨⟨e⟩, ⟨isLimitOfReflects F <| ?_⟩⟩\n  refine\n    (IsLimit.equivOfNatIsoOfIso (cospanCompIso F h i) _ _ (WalkingCospan.ext ?_ ?_ ?_)).symm\n      H.isLimit\n  exacts [Iso.refl _, (Category.comp_id _).trans (Category.id_comp _).symm,\n    (Category.comp_id _).trans (Category.id_comp _).symm]\n\n"}
{"name":"CategoryTheory.IsPullback.of_map_of_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan h i) F\ninst✝ : F.Faithful\nH : CategoryTheory.IsPullback (F.map f) (F.map g) (F.map h) (F.map i)\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPullback.of_map_of_faithful [ReflectsLimit (cospan h i) F] [F.Faithful]\n    (H : IsPullback (F.map f) (F.map g) (F.map h) (F.map i)) : IsPullback f g h i :=\n  H.of_map F (F.map_injective <| by simpa only [F.map_comp] using H.w)\n\n"}
{"name":"CategoryTheory.IsPullback.map_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nD : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan h i) F\ninst✝ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan h i) F\ne : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i)\n⊢ Iff (CategoryTheory.IsPullback (F.map f) (F.map g) (F.map h) (F.map i)) (CategoryTheory.IsPullback f g h i)","decl":"theorem IsPullback.map_iff {D : Type*} [Category D] (F : C ⥤ D) [PreservesLimit (cospan h i) F]\n    [ReflectsLimit (cospan h i) F] (e : f ≫ h = g ≫ i) :\n    IsPullback (F.map f) (F.map g) (F.map h) (F.map i) ↔ IsPullback f g h i :=\n  ⟨fun h => h.of_map F e, fun h => h.map F⟩\n\n"}
{"name":"CategoryTheory.IsPushout.of_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f g) F\ne : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i)\nH : CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)\n⊢ CategoryTheory.IsPushout f g h i","decl":"theorem IsPushout.of_map [ReflectsColimit (span f g) F] (e : f ≫ h = g ≫ i)\n    (H : IsPushout (F.map f) (F.map g) (F.map h) (F.map i)) : IsPushout f g h i := by\n  refine ⟨⟨e⟩, ⟨isColimitOfReflects F <| ?_⟩⟩\n  refine\n    (IsColimit.equivOfNatIsoOfIso (spanCompIso F f g) _ _ (WalkingSpan.ext ?_ ?_ ?_)).symm\n      H.isColimit\n  exacts [Iso.refl _, (Category.comp_id _).trans (Category.id_comp _),\n    (Category.comp_id _).trans (Category.id_comp _)]\n\n"}
{"name":"CategoryTheory.IsPushout.of_map_of_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f g) F\ninst✝ : F.Faithful\nH : CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)\n⊢ CategoryTheory.IsPushout f g h i","decl":"theorem IsPushout.of_map_of_faithful [ReflectsColimit (span f g) F] [F.Faithful]\n    (H : IsPushout (F.map f) (F.map g) (F.map h) (F.map i)) : IsPushout f g h i :=\n  H.of_map F (F.map_injective <| by simpa only [F.map_comp] using H.w)\n\n"}
{"name":"CategoryTheory.IsPushout.map_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nD : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) F\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f g) F\ne : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i)\n⊢ Iff (CategoryTheory.IsPushout (F.map f) (F.map g) (F.map h) (F.map i)) (CategoryTheory.IsPushout f g h i)","decl":"theorem IsPushout.map_iff {D : Type*} [Category D] (F : C ⥤ D) [PreservesColimit (span f g) F]\n    [ReflectsColimit (span f g) F] (e : f ≫ h = g ≫ i) :\n    IsPushout (F.map f) (F.map g) (F.map h) (F.map i) ↔ IsPushout f g h i :=\n  ⟨fun h => h.of_map F e, fun h => h.map F⟩\n\n"}
