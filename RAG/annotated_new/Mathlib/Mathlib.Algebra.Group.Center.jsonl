{"name":"IsAddCentral.left_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\nself : IsAddCentral z\nb c : M\n⊢ Eq (HAdd.hAdd z (HAdd.hAdd b c)) (HAdd.hAdd (HAdd.hAdd z b) c)","decl":"/-- Conditions for an element to be additively central -/\nstructure IsAddCentral [Add M] (z : M) : Prop where\n  /-- addition commutes -/\n  comm (a : M) : z + a = a + z\n  /-- associative property for left addition -/\n  left_assoc (b c : M) : z + (b + c) = (z + b) + c\n  /-- middle associative addition property -/\n  mid_assoc (a c : M) : (a + z) + c = a + (z + c)\n  /-- associative property for right addition -/\n  right_assoc (a b : M) : (a + b) + z = a + (b + z)\n\n"}
{"name":"IsAddCentral.right_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\nself : IsAddCentral z\na b : M\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) z) (HAdd.hAdd a (HAdd.hAdd b z))","decl":"/-- Conditions for an element to be additively central -/\nstructure IsAddCentral [Add M] (z : M) : Prop where\n  /-- addition commutes -/\n  comm (a : M) : z + a = a + z\n  /-- associative property for left addition -/\n  left_assoc (b c : M) : z + (b + c) = (z + b) + c\n  /-- middle associative addition property -/\n  mid_assoc (a c : M) : (a + z) + c = a + (z + c)\n  /-- associative property for right addition -/\n  right_assoc (a b : M) : (a + b) + z = a + (b + z)\n\n"}
{"name":"IsAddCentral.comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\nself : IsAddCentral z\na : M\n⊢ Eq (HAdd.hAdd z a) (HAdd.hAdd a z)","decl":"/-- Conditions for an element to be additively central -/\nstructure IsAddCentral [Add M] (z : M) : Prop where\n  /-- addition commutes -/\n  comm (a : M) : z + a = a + z\n  /-- associative property for left addition -/\n  left_assoc (b c : M) : z + (b + c) = (z + b) + c\n  /-- middle associative addition property -/\n  mid_assoc (a c : M) : (a + z) + c = a + (z + c)\n  /-- associative property for right addition -/\n  right_assoc (a b : M) : (a + b) + z = a + (b + z)\n\n"}
{"name":"IsAddCentral.mid_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\nself : IsAddCentral z\na c : M\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a z) c) (HAdd.hAdd a (HAdd.hAdd z c))","decl":"/-- Conditions for an element to be additively central -/\nstructure IsAddCentral [Add M] (z : M) : Prop where\n  /-- addition commutes -/\n  comm (a : M) : z + a = a + z\n  /-- associative property for left addition -/\n  left_assoc (b c : M) : z + (b + c) = (z + b) + c\n  /-- middle associative addition property -/\n  mid_assoc (a c : M) : (a + z) + c = a + (z + c)\n  /-- associative property for right addition -/\n  right_assoc (a b : M) : (a + b) + z = a + (b + z)\n\n"}
{"name":"IsMulCentral.right_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\nself : IsMulCentral z\na b : M\n⊢ Eq (HMul.hMul (HMul.hMul a b) z) (HMul.hMul a (HMul.hMul b z))","decl":"/-- Conditions for an element to be multiplicatively central -/\n@[to_additive]\nstructure IsMulCentral [Mul M] (z : M) : Prop where\n  /-- multiplication commutes -/\n  comm (a : M) : z * a = a * z\n  /-- associative property for left multiplication -/\n  left_assoc (b c : M) : z * (b * c) = (z * b) * c\n  /-- middle associative multiplication property -/\n  mid_assoc (a c : M) : (a * z) * c = a * (z * c)\n  /-- associative property for right multiplication -/\n  right_assoc (a b : M) : (a * b) * z = a * (b * z)\n\n"}
{"name":"IsMulCentral.left_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\nself : IsMulCentral z\nb c : M\n⊢ Eq (HMul.hMul z (HMul.hMul b c)) (HMul.hMul (HMul.hMul z b) c)","decl":"/-- Conditions for an element to be multiplicatively central -/\n@[to_additive]\nstructure IsMulCentral [Mul M] (z : M) : Prop where\n  /-- multiplication commutes -/\n  comm (a : M) : z * a = a * z\n  /-- associative property for left multiplication -/\n  left_assoc (b c : M) : z * (b * c) = (z * b) * c\n  /-- middle associative multiplication property -/\n  mid_assoc (a c : M) : (a * z) * c = a * (z * c)\n  /-- associative property for right multiplication -/\n  right_assoc (a b : M) : (a * b) * z = a * (b * z)\n\n"}
{"name":"IsMulCentral.comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\nself : IsMulCentral z\na : M\n⊢ Eq (HMul.hMul z a) (HMul.hMul a z)","decl":"/-- Conditions for an element to be multiplicatively central -/\n@[to_additive]\nstructure IsMulCentral [Mul M] (z : M) : Prop where\n  /-- multiplication commutes -/\n  comm (a : M) : z * a = a * z\n  /-- associative property for left multiplication -/\n  left_assoc (b c : M) : z * (b * c) = (z * b) * c\n  /-- middle associative multiplication property -/\n  mid_assoc (a c : M) : (a * z) * c = a * (z * c)\n  /-- associative property for right multiplication -/\n  right_assoc (a b : M) : (a * b) * z = a * (b * z)\n\n"}
{"name":"IsMulCentral.mid_assoc","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\nself : IsMulCentral z\na c : M\n⊢ Eq (HMul.hMul (HMul.hMul a z) c) (HMul.hMul a (HMul.hMul z c))","decl":"/-- Conditions for an element to be multiplicatively central -/\n@[to_additive]\nstructure IsMulCentral [Mul M] (z : M) : Prop where\n  /-- multiplication commutes -/\n  comm (a : M) : z * a = a * z\n  /-- associative property for left multiplication -/\n  left_assoc (b c : M) : z * (b * c) = (z * b) * c\n  /-- middle associative multiplication property -/\n  mid_assoc (a c : M) : (a * z) * c = a * (z * c)\n  /-- associative property for right multiplication -/\n  right_assoc (a b : M) : (a * b) * z = a * (b * z)\n\n"}
{"name":"isMulCentral_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\n⊢ Iff (IsMulCentral z) (And (∀ (a : M), Eq (HMul.hMul z a) (HMul.hMul a z)) (And (∀ (b c : M), Eq (HMul.hMul z (HMul.hMul b c)) (HMul.hMul (HMul.hMul z b) c)) (And (∀ (a c : M), Eq (HMul.hMul (HMul.hMul a z) c) (HMul.hMul a (HMul.hMul z c))) (∀ (a b : M), Eq (HMul.hMul (HMul.hMul a b) z) (HMul.hMul a (HMul.hMul b z))))))","decl":"attribute [mk_iff] IsMulCentral IsAddCentral\n"}
{"name":"isAddCentral_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\n⊢ Iff (IsAddCentral z) (And (∀ (a : M), Eq (HAdd.hAdd z a) (HAdd.hAdd a z)) (And (∀ (b c : M), Eq (HAdd.hAdd z (HAdd.hAdd b c)) (HAdd.hAdd (HAdd.hAdd z b) c)) (And (∀ (a c : M), Eq (HAdd.hAdd (HAdd.hAdd a z) c) (HAdd.hAdd a (HAdd.hAdd z c))) (∀ (a b : M), Eq (HAdd.hAdd (HAdd.hAdd a b) z) (HAdd.hAdd a (HAdd.hAdd b z))))))","decl":"attribute [mk_iff] IsMulCentral IsAddCentral\n"}
{"name":"IsMulCentral.left_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\na : M\ninst✝ : Mul M\nh : IsMulCentral a\nb c : M\n⊢ Eq (HMul.hMul a (HMul.hMul b c)) (HMul.hMul b (HMul.hMul a c))","decl":"@[to_additive]\nprotected theorem left_comm (h : IsMulCentral a) (b c) : a * (b * c) = b * (a * c) := by\n  simp only [h.comm, h.right_assoc]\n\n-- cf. `Commute.right_comm`\n"}
{"name":"IsAddCentral.left_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\na : M\ninst✝ : Add M\nh : IsAddCentral a\nb c : M\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b c)) (HAdd.hAdd b (HAdd.hAdd a c))","decl":"@[to_additive]\nprotected theorem left_comm (h : IsMulCentral a) (b c) : a * (b * c) = b * (a * c) := by\n  simp only [h.comm, h.right_assoc]\n\n-- cf. `Commute.right_comm`\n"}
{"name":"IsMulCentral.right_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nc : M\ninst✝ : Mul M\nh : IsMulCentral c\na b : M\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul (HMul.hMul a c) b)","decl":"@[to_additive]\nprotected theorem right_comm (h : IsMulCentral c) (a b) : a * b * c = a * c * b := by\n  simp only [h.right_assoc, h.mid_assoc, h.comm]\n\n"}
{"name":"IsAddCentral.right_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nc : M\ninst✝ : Add M\nh : IsAddCentral c\na b : M\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd a c) b)","decl":"@[to_additive]\nprotected theorem right_comm (h : IsMulCentral c) (a b) : a * b * c = a * c * b := by\n  simp only [h.right_assoc, h.mid_assoc, h.comm]\n\n"}
{"name":"Set.mem_center_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz : M\n⊢ Iff (Membership.mem (Set.center M) z) (IsMulCentral z)","decl":"@[to_additive mem_addCenter_iff]\ntheorem mem_center_iff {z : M} : z ∈ center M ↔ IsMulCentral z :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_addCenter_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz : M\n⊢ Iff (Membership.mem (Set.addCenter M) z) (IsAddCentral z)","decl":"@[to_additive mem_addCenter_iff]\ntheorem mem_center_iff {z : M} : z ∈ center M ↔ IsMulCentral z :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_centralizer_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Mul M\nc : M\n⊢ Iff (Membership.mem S.centralizer c) (∀ (m : M), Membership.mem S m → Eq (HMul.hMul m c) (HMul.hMul c m))","decl":"@[to_additive mem_addCentralizer]\nlemma mem_centralizer_iff {c : M} : c ∈ centralizer S ↔ ∀ m ∈ S, m * c = c * m := Iff.rfl\n\n"}
{"name":"Set.mem_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Add M\nc : M\n⊢ Iff (Membership.mem S.addCentralizer c) (∀ (m : M), Membership.mem S m → Eq (HAdd.hAdd m c) (HAdd.hAdd c m))","decl":"@[to_additive mem_addCentralizer]\nlemma mem_centralizer_iff {c : M} : c ∈ centralizer S ↔ ∀ m ∈ S, m * c = c * m := Iff.rfl\n\n"}
{"name":"Set.mul_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nz₁ z₂ : M\nhz₁ : Membership.mem (Set.center M) z₁\nhz₂ : Membership.mem (Set.center M) z₂\n⊢ Membership.mem (Set.center M) (HMul.hMul z₁ z₂)","decl":"@[to_additive (attr := simp) add_mem_addCenter]\ntheorem mul_mem_center {z₁ z₂ : M} (hz₁ : z₁ ∈ Set.center M) (hz₂ : z₂ ∈ Set.center M) :\n    z₁ * z₂ ∈ Set.center M where\n  comm a := calc\n    z₁ * z₂ * a = z₂ * z₁ * a := by rw [hz₁.comm]\n    _ = z₂ * (z₁ * a) := by rw [hz₁.mid_assoc z₂]\n    _ = (a * z₁) * z₂ := by rw [hz₁.comm, hz₂.comm]\n    _ = a * (z₁ * z₂) := by rw [hz₂.right_assoc a z₁]\n  left_assoc (b c : M) := calc\n    z₁ * z₂ * (b * c) = z₁ * (z₂ * (b * c)) := by rw [hz₂.mid_assoc]\n    _ = z₁ * ((z₂ * b) * c) := by rw [hz₂.left_assoc]\n    _ = (z₁ * (z₂ * b)) * c := by rw [hz₁.left_assoc]\n    _ = z₁ * z₂ * b * c := by rw [hz₂.mid_assoc]\n  mid_assoc (a c : M) := calc\n    a * (z₁ * z₂) * c = ((a * z₁) * z₂) * c := by rw [hz₁.mid_assoc]\n    _ = (a * z₁) * (z₂ * c) := by rw [hz₂.mid_assoc]\n    _ = a * (z₁ * (z₂ * c)) := by rw [hz₁.mid_assoc]\n    _ = a * (z₁ * z₂ * c) := by rw [hz₂.mid_assoc]\n  right_assoc (a b : M) := calc\n    a * b * (z₁ * z₂) = ((a * b) * z₁) * z₂ := by rw [hz₂.right_assoc]\n    _ = (a * (b * z₁)) * z₂ := by rw [hz₁.right_assoc]\n    _ =  a * ((b * z₁) * z₂) := by rw [hz₂.right_assoc]\n    _ = a * (b * (z₁ * z₂)) := by rw [hz₁.mid_assoc]\n\n"}
{"name":"Set.add_mem_addCenter","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nz₁ z₂ : M\nhz₁ : Membership.mem (Set.addCenter M) z₁\nhz₂ : Membership.mem (Set.addCenter M) z₂\n⊢ Membership.mem (Set.addCenter M) (HAdd.hAdd z₁ z₂)","decl":"@[to_additive (attr := simp) add_mem_addCenter]\ntheorem mul_mem_center {z₁ z₂ : M} (hz₁ : z₁ ∈ Set.center M) (hz₂ : z₂ ∈ Set.center M) :\n    z₁ * z₂ ∈ Set.center M where\n  comm a := calc\n    z₁ * z₂ * a = z₂ * z₁ * a := by rw [hz₁.comm]\n    _ = z₂ * (z₁ * a) := by rw [hz₁.mid_assoc z₂]\n    _ = (a * z₁) * z₂ := by rw [hz₁.comm, hz₂.comm]\n    _ = a * (z₁ * z₂) := by rw [hz₂.right_assoc a z₁]\n  left_assoc (b c : M) := calc\n    z₁ * z₂ * (b * c) = z₁ * (z₂ * (b * c)) := by rw [hz₂.mid_assoc]\n    _ = z₁ * ((z₂ * b) * c) := by rw [hz₂.left_assoc]\n    _ = (z₁ * (z₂ * b)) * c := by rw [hz₁.left_assoc]\n    _ = z₁ * z₂ * b * c := by rw [hz₂.mid_assoc]\n  mid_assoc (a c : M) := calc\n    a * (z₁ * z₂) * c = ((a * z₁) * z₂) * c := by rw [hz₁.mid_assoc]\n    _ = (a * z₁) * (z₂ * c) := by rw [hz₂.mid_assoc]\n    _ = a * (z₁ * (z₂ * c)) := by rw [hz₁.mid_assoc]\n    _ = a * (z₁ * z₂ * c) := by rw [hz₂.mid_assoc]\n  right_assoc (a b : M) := calc\n    a * b * (z₁ * z₂) = ((a * b) * z₁) * z₂ := by rw [hz₂.right_assoc]\n    _ = (a * (b * z₁)) * z₂ := by rw [hz₁.right_assoc]\n    _ =  a * ((b * z₁) * z₂) := by rw [hz₂.right_assoc]\n    _ = a * (b * (z₁ * z₂)) := by rw [hz₁.mid_assoc]\n\n"}
{"name":"Set.addCenter_subset_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set M\n⊢ HasSubset.Subset (Set.addCenter M) S.addCentralizer","decl":"@[to_additive addCenter_subset_addCentralizer]\nlemma center_subset_centralizer (S : Set M) : Set.center M ⊆ S.centralizer :=\n  fun _ hx m _ ↦ (hx.comm m).symm\n\n"}
{"name":"Set.center_subset_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set M\n⊢ HasSubset.Subset (Set.center M) S.centralizer","decl":"@[to_additive addCenter_subset_addCentralizer]\nlemma center_subset_centralizer (S : Set M) : Set.center M ⊆ S.centralizer :=\n  fun _ hx m _ ↦ (hx.comm m).symm\n\n"}
{"name":"Set.addCentralizer_union","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS T : Set M\ninst✝ : Add M\n⊢ Eq (Union.union S T).addCentralizer (Inter.inter S.addCentralizer T.addCentralizer)","decl":"@[to_additive addCentralizer_union]\nlemma centralizer_union : centralizer (S ∪ T) = centralizer S ∩ centralizer T := by\n  simp [centralizer, or_imp, forall_and, setOf_and]\n\n"}
{"name":"Set.centralizer_union","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS T : Set M\ninst✝ : Mul M\n⊢ Eq (Union.union S T).centralizer (Inter.inter S.centralizer T.centralizer)","decl":"@[to_additive addCentralizer_union]\nlemma centralizer_union : centralizer (S ∪ T) = centralizer S ∩ centralizer T := by\n  simp [centralizer, or_imp, forall_and, setOf_and]\n\n"}
{"name":"Set.centralizer_subset","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS T : Set M\ninst✝ : Mul M\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset T.centralizer S.centralizer","decl":"@[to_additive (attr := gcongr) addCentralizer_subset]\nlemma centralizer_subset (h : S ⊆ T) : centralizer T ⊆ centralizer S := fun _ ht s hs ↦ ht s (h hs)\n\n"}
{"name":"Set.addCentralizer_subset","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS T : Set M\ninst✝ : Add M\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset T.addCentralizer S.addCentralizer","decl":"@[to_additive (attr := gcongr) addCentralizer_subset]\nlemma centralizer_subset (h : S ⊆ T) : centralizer T ⊆ centralizer S := fun _ ht s hs ↦ ht s (h hs)\n\n"}
{"name":"Set.subset_centralizer_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Mul M\n⊢ HasSubset.Subset S S.centralizer.centralizer","decl":"@[to_additive subset_addCentralizer_addCentralizer]\nlemma subset_centralizer_centralizer : S ⊆ S.centralizer.centralizer := by\n  intro x hx\n  simp only [Set.mem_centralizer_iff]\n  exact fun y hy => (hy x hx).symm\n\n"}
{"name":"Set.subset_addCentralizer_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Add M\n⊢ HasSubset.Subset S S.addCentralizer.addCentralizer","decl":"@[to_additive subset_addCentralizer_addCentralizer]\nlemma subset_centralizer_centralizer : S ⊆ S.centralizer.centralizer := by\n  intro x hx\n  simp only [Set.mem_centralizer_iff]\n  exact fun y hy => (hy x hx).symm\n\n"}
{"name":"Set.centralizer_centralizer_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set M\n⊢ Eq S.centralizer.centralizer.centralizer S.centralizer","decl":"@[to_additive (attr := simp) addCentralizer_addCentralizer_addCentralizer]\nlemma centralizer_centralizer_centralizer (S : Set M) :\n    S.centralizer.centralizer.centralizer = S.centralizer := by\n  refine Set.Subset.antisymm ?_ Set.subset_centralizer_centralizer\n  intro x hx\n  rw [Set.mem_centralizer_iff]\n  intro y hy\n  rw [Set.mem_centralizer_iff] at hx\n  exact hx y <| Set.subset_centralizer_centralizer hy\n\n"}
{"name":"Set.addCentralizer_addCentralizer_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set M\n⊢ Eq S.addCentralizer.addCentralizer.addCentralizer S.addCentralizer","decl":"@[to_additive (attr := simp) addCentralizer_addCentralizer_addCentralizer]\nlemma centralizer_centralizer_centralizer (S : Set M) :\n    S.centralizer.centralizer.centralizer = S.centralizer := by\n  refine Set.Subset.antisymm ?_ Set.subset_centralizer_centralizer\n  intro x hx\n  rw [Set.mem_centralizer_iff]\n  intro y hy\n  rw [Set.mem_centralizer_iff] at hx\n  exact hx y <| Set.subset_centralizer_centralizer hy\n\n"}
{"name":"Set.centralizer_centralizer_comm_of_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Mul M\nh_comm : ∀ (x : M), Membership.mem S x → ∀ (y : M), Membership.mem S y → Eq (HMul.hMul x y) (HMul.hMul y x)\nx : M\na✝¹ : Membership.mem S.centralizer.centralizer x\ny : M\na✝ : Membership.mem S.centralizer.centralizer y\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"@[to_additive addCentralizer_addCentralizer_comm_of_comm]\nlemma centralizer_centralizer_comm_of_comm (h_comm : ∀ x ∈ S, ∀ y ∈ S, x * y = y * x) :\n    ∀ x ∈ S.centralizer.centralizer, ∀ y ∈ S.centralizer.centralizer, x * y = y * x :=\n  fun _ h₁ _ h₂ ↦ h₂ _ fun _ h₃ ↦ h₁ _ fun _ h₄ ↦ h_comm _ h₄ _ h₃\n\n"}
{"name":"Set.addCentralizer_addCentralizer_comm_of_comm","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Add M\nh_comm : ∀ (x : M), Membership.mem S x → ∀ (y : M), Membership.mem S y → Eq (HAdd.hAdd x y) (HAdd.hAdd y x)\nx : M\na✝¹ : Membership.mem S.addCentralizer.addCentralizer x\ny : M\na✝ : Membership.mem S.addCentralizer.addCentralizer y\n⊢ Eq (HAdd.hAdd x y) (HAdd.hAdd y x)","decl":"@[to_additive addCentralizer_addCentralizer_comm_of_comm]\nlemma centralizer_centralizer_comm_of_comm (h_comm : ∀ x ∈ S, ∀ y ∈ S, x * y = y * x) :\n    ∀ x ∈ S.centralizer.centralizer, ∀ y ∈ S.centralizer.centralizer, x * y = y * x :=\n  fun _ h₁ _ h₂ ↦ h₂ _ fun _ h₃ ↦ h₁ _ fun _ h₄ ↦ h_comm _ h₄ _ h₃\n\n"}
{"name":"Semigroup.mem_center_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\nz : M\n⊢ Iff (Membership.mem (Set.center M) z) (∀ (g : M), Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"@[to_additive]\ntheorem _root_.Semigroup.mem_center_iff {z : M} :\n    z ∈ Set.center M ↔ ∀ g, g * z = z * g := ⟨fun a g ↦ by rw [IsMulCentral.comm a g],\n  fun h ↦ ⟨fun _ ↦ (Commute.eq (h _)).symm, fun _ _ ↦ (mul_assoc z _ _).symm,\n  fun _ _ ↦ mul_assoc _ z _, fun _ _ ↦ mul_assoc _ _ z⟩ ⟩\n\n"}
{"name":"AddSemigroup.mem_center_iff","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\nz : M\n⊢ Iff (Membership.mem (Set.addCenter M) z) (∀ (g : M), Eq (HAdd.hAdd g z) (HAdd.hAdd z g))","decl":"@[to_additive]\ntheorem _root_.Semigroup.mem_center_iff {z : M} :\n    z ∈ Set.center M ↔ ∀ g, g * z = z * g := ⟨fun a g ↦ by rw [IsMulCentral.comm a g],\n  fun h ↦ ⟨fun _ ↦ (Commute.eq (h _)).symm, fun _ _ ↦ (mul_assoc z _ _).symm,\n  fun _ _ ↦ mul_assoc _ z _, fun _ _ ↦ mul_assoc _ _ z⟩ ⟩\n\n"}
{"name":"Set.add_mem_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddSemigroup M\na b : M\nha : Membership.mem S.addCentralizer a\nhb : Membership.mem S.addCentralizer b\n⊢ Membership.mem S.addCentralizer (HAdd.hAdd a b)","decl":"@[to_additive (attr := simp) add_mem_addCentralizer]\nlemma mul_mem_centralizer (ha : a ∈ centralizer S) (hb : b ∈ centralizer S) :\n    a * b ∈ centralizer S := fun g hg ↦ by\n  rw [mul_assoc, ← hb g hg, ← mul_assoc, ha g hg, mul_assoc]\n\n"}
{"name":"Set.mul_mem_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Semigroup M\na b : M\nha : Membership.mem S.centralizer a\nhb : Membership.mem S.centralizer b\n⊢ Membership.mem S.centralizer (HMul.hMul a b)","decl":"@[to_additive (attr := simp) add_mem_addCentralizer]\nlemma mul_mem_centralizer (ha : a ∈ centralizer S) (hb : b ∈ centralizer S) :\n    a * b ∈ centralizer S := fun g hg ↦ by\n  rw [mul_assoc, ← hb g hg, ← mul_assoc, ha g hg, mul_assoc]\n\n"}
{"name":"Set.centralizer_eq_top_iff_subset","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Semigroup M\n⊢ Iff (Eq S.centralizer Set.univ) (HasSubset.Subset S (Set.center M))","decl":"@[to_additive (attr := simp) addCentralizer_eq_top_iff_subset]\ntheorem centralizer_eq_top_iff_subset : centralizer S = Set.univ ↔ S ⊆ center M :=\n  eq_top_iff.trans <| ⟨\n    fun h _ hx ↦ Semigroup.mem_center_iff.mpr fun _ ↦ by rw [h trivial _ hx],\n    fun h _ _ _ hm ↦ (h hm).comm _⟩\n\n"}
{"name":"Set.addCentralizer_eq_top_iff_subset","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddSemigroup M\n⊢ Iff (Eq S.addCentralizer Set.univ) (HasSubset.Subset S (Set.addCenter M))","decl":"@[to_additive (attr := simp) addCentralizer_eq_top_iff_subset]\ntheorem centralizer_eq_top_iff_subset : centralizer S = Set.univ ↔ S ⊆ center M :=\n  eq_top_iff.trans <| ⟨\n    fun h _ hx ↦ Semigroup.mem_center_iff.mpr fun _ ↦ by rw [h trivial _ hx],\n    fun h _ _ _ hm ↦ (h hm).comm _⟩\n\n"}
{"name":"Set.centralizer_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\n⊢ Eq Set.univ.centralizer (Set.center M)","decl":"variable (M) in\n@[to_additive (attr := simp) addCentralizer_univ]\nlemma centralizer_univ : centralizer univ = center M :=\n  Subset.antisymm (fun _ ha ↦ Semigroup.mem_center_iff.mpr fun b ↦ ha b (Set.mem_univ b))\n  fun _ ha b _ ↦ (ha.comm b).symm\n\n-- TODO Add `instance : Decidable (IsMulCentral a)` for `instance decidableMemCenter [Mul M]`\n"}
{"name":"Set.addCentralizer_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\n⊢ Eq Set.univ.addCentralizer (Set.addCenter M)","decl":"variable (M) in\n@[to_additive (attr := simp) addCentralizer_univ]\nlemma centralizer_univ : centralizer univ = center M :=\n  Subset.antisymm (fun _ ha ↦ Semigroup.mem_center_iff.mpr fun b ↦ ha b (Set.mem_univ b))\n  fun _ ha b _ ↦ (ha.comm b).symm\n\n-- TODO Add `instance : Decidable (IsMulCentral a)` for `instance decidableMemCenter [Mul M]`\n"}
{"name":"Set.addCenter_eq_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddCommSemigroup M\n⊢ Eq (Set.addCenter M) Set.univ","decl":"@[to_additive (attr := simp) addCenter_eq_univ]\ntheorem center_eq_univ : center M = univ :=\n  (Subset.antisymm (subset_univ _)) fun _ _ => Semigroup.mem_center_iff.mpr (fun _ => mul_comm _ _)\n\n"}
{"name":"Set.center_eq_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : CommSemigroup M\n⊢ Eq (Set.center M) Set.univ","decl":"@[to_additive (attr := simp) addCenter_eq_univ]\ntheorem center_eq_univ : center M = univ :=\n  (Subset.antisymm (subset_univ _)) fun _ _ => Semigroup.mem_center_iff.mpr (fun _ => mul_comm _ _)\n\n"}
{"name":"Set.addCentralizer_eq_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddCommSemigroup M\n⊢ Eq S.addCentralizer Set.univ","decl":"@[to_additive (attr := simp) addCentralizer_eq_univ]\nlemma centralizer_eq_univ : centralizer S = univ :=\n  eq_univ_of_forall fun _ _ _ ↦ mul_comm _ _\n\n"}
{"name":"Set.centralizer_eq_univ","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : CommSemigroup M\n⊢ Eq S.centralizer Set.univ","decl":"@[to_additive (attr := simp) addCentralizer_eq_univ]\nlemma centralizer_eq_univ : centralizer S = univ :=\n  eq_univ_of_forall fun _ _ _ ↦ mul_comm _ _\n\n"}
{"name":"Set.zero_mem_addCenter","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Membership.mem (Set.addCenter M) 0","decl":"@[to_additive (attr := simp) zero_mem_addCenter]\ntheorem one_mem_center : (1 : M) ∈ Set.center M where\n  comm _  := by rw [one_mul, mul_one]\n  left_assoc _ _ := by rw [one_mul, one_mul]\n  mid_assoc _ _ := by rw [mul_one, one_mul]\n  right_assoc _ _ := by rw [mul_one, mul_one]\n\n"}
{"name":"Set.one_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Membership.mem (Set.center M) 1","decl":"@[to_additive (attr := simp) zero_mem_addCenter]\ntheorem one_mem_center : (1 : M) ∈ Set.center M where\n  comm _  := by rw [one_mul, mul_one]\n  left_assoc _ _ := by rw [one_mul, one_mul]\n  mid_assoc _ _ := by rw [mul_one, one_mul]\n  right_assoc _ _ := by rw [mul_one, mul_one]\n\n"}
{"name":"Set.zero_mem_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddZeroClass M\n⊢ Membership.mem S.addCentralizer 0","decl":"@[to_additive (attr := simp) zero_mem_addCentralizer]\nlemma one_mem_centralizer : (1 : M) ∈ centralizer S := by simp [mem_centralizer_iff]\n\n"}
{"name":"Set.one_mem_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : MulOneClass M\n⊢ Membership.mem S.centralizer 1","decl":"@[to_additive (attr := simp) zero_mem_addCentralizer]\nlemma one_mem_centralizer : (1 : M) ∈ centralizer S := by simp [mem_centralizer_iff]\n\n"}
{"name":"Set.subset_addCenter_add_units","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ HasSubset.Subset (Set.preimage AddUnits.val (Set.addCenter M)) (Set.addCenter (AddUnits M))","decl":"@[to_additive subset_addCenter_add_units]\ntheorem subset_center_units : ((↑) : Mˣ → M) ⁻¹' center M ⊆ Set.center Mˣ :=\n  fun _ ha => by\n  rw [_root_.Semigroup.mem_center_iff]\n  intro _\n  rw [← Units.eq_iff, Units.val_mul, Units.val_mul, ha.comm]\n\n"}
{"name":"Set.subset_center_units","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ HasSubset.Subset (Set.preimage Units.val (Set.center M)) (Set.center (Units M))","decl":"@[to_additive subset_addCenter_add_units]\ntheorem subset_center_units : ((↑) : Mˣ → M) ⁻¹' center M ⊆ Set.center Mˣ :=\n  fun _ ha => by\n  rw [_root_.Semigroup.mem_center_iff]\n  intro _\n  rw [← Units.eq_iff, Units.val_mul, Units.val_mul, ha.comm]\n\n"}
{"name":"Set.addUnits_neg_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : AddUnits M\nha : Membership.mem (Set.addCenter M) ↑a\n⊢ Membership.mem (Set.addCenter M) ↑(Neg.neg a)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_mem_center {a : Mˣ} (ha : ↑a ∈ Set.center M) : ↑a⁻¹ ∈ Set.center M := by\n  rw [Semigroup.mem_center_iff] at *\n  exact (Commute.units_inv_right <| ha ·)\n\n"}
{"name":"Set.units_inv_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nha : Membership.mem (Set.center M) ↑a\n⊢ Membership.mem (Set.center M) ↑(Inv.inv a)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_mem_center {a : Mˣ} (ha : ↑a ∈ Set.center M) : ↑a⁻¹ ∈ Set.center M := by\n  rw [Semigroup.mem_center_iff] at *\n  exact (Commute.units_inv_right <| ha ·)\n\n"}
{"name":"Set.invOf_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\na : M\ninst✝ : Invertible a\nha : Membership.mem (Set.center M) a\n⊢ Membership.mem (Set.center M) (Invertible.invOf a)","decl":"@[simp]\ntheorem invOf_mem_center {a : M} [Invertible a] (ha : a ∈ Set.center M) : ⅟a ∈ Set.center M := by\n  rw [Semigroup.mem_center_iff] at *\n  exact (Commute.invOf_right <| ha ·)\n\n"}
{"name":"Set.inv_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : DivisionMonoid M\na : M\nha : Membership.mem (Set.center M) a\n⊢ Membership.mem (Set.center M) (Inv.inv a)","decl":"@[to_additive (attr := simp) neg_mem_addCenter]\ntheorem inv_mem_center (ha : a ∈ Set.center M) : a⁻¹ ∈ Set.center M := by\n  rw [_root_.Semigroup.mem_center_iff]\n  intro _\n  rw [← inv_inj, mul_inv_rev, inv_inv, ha.comm, mul_inv_rev, inv_inv]\n\n"}
{"name":"Set.neg_mem_addCenter","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : SubtractionMonoid M\na : M\nha : Membership.mem (Set.addCenter M) a\n⊢ Membership.mem (Set.addCenter M) (Neg.neg a)","decl":"@[to_additive (attr := simp) neg_mem_addCenter]\ntheorem inv_mem_center (ha : a ∈ Set.center M) : a⁻¹ ∈ Set.center M := by\n  rw [_root_.Semigroup.mem_center_iff]\n  intro _\n  rw [← inv_inj, mul_inv_rev, inv_inv, ha.comm, mul_inv_rev, inv_inv]\n\n"}
{"name":"Set.sub_mem_addCenter","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : SubtractionMonoid M\na b : M\nha : Membership.mem (Set.addCenter M) a\nhb : Membership.mem (Set.addCenter M) b\n⊢ Membership.mem (Set.addCenter M) (HSub.hSub a b)","decl":"@[to_additive (attr := simp) sub_mem_addCenter]\ntheorem div_mem_center (ha : a ∈ Set.center M) (hb : b ∈ Set.center M) : a / b ∈ Set.center M := by\n  rw [div_eq_mul_inv]\n  exact mul_mem_center ha (inv_mem_center hb)\n\n"}
{"name":"Set.div_mem_center","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\ninst✝ : DivisionMonoid M\na b : M\nha : Membership.mem (Set.center M) a\nhb : Membership.mem (Set.center M) b\n⊢ Membership.mem (Set.center M) (HDiv.hDiv a b)","decl":"@[to_additive (attr := simp) sub_mem_addCenter]\ntheorem div_mem_center (ha : a ∈ Set.center M) (hb : b ∈ Set.center M) : a / b ∈ Set.center M := by\n  rw [div_eq_mul_inv]\n  exact mul_mem_center ha (inv_mem_center hb)\n\n"}
{"name":"Set.inv_mem_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Group M\na : M\nha : Membership.mem S.centralizer a\n⊢ Membership.mem S.centralizer (Inv.inv a)","decl":"@[to_additive (attr := simp) neg_mem_addCentralizer]\nlemma inv_mem_centralizer (ha : a ∈ centralizer S) : a⁻¹ ∈ centralizer S :=\n  fun g hg ↦ by rw [mul_inv_eq_iff_eq_mul, mul_assoc, eq_inv_mul_iff_mul_eq, ha g hg]\n\n"}
{"name":"Set.neg_mem_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddGroup M\na : M\nha : Membership.mem S.addCentralizer a\n⊢ Membership.mem S.addCentralizer (Neg.neg a)","decl":"@[to_additive (attr := simp) neg_mem_addCentralizer]\nlemma inv_mem_centralizer (ha : a ∈ centralizer S) : a⁻¹ ∈ centralizer S :=\n  fun g hg ↦ by rw [mul_inv_eq_iff_eq_mul, mul_assoc, eq_inv_mul_iff_mul_eq, ha g hg]\n\n"}
{"name":"Set.sub_mem_addCentralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : AddGroup M\na b : M\nha : Membership.mem S.addCentralizer a\nhb : Membership.mem S.addCentralizer b\n⊢ Membership.mem S.addCentralizer (HSub.hSub a b)","decl":"@[to_additive (attr := simp) sub_mem_addCentralizer]\nlemma div_mem_centralizer (ha : a ∈ centralizer S) (hb : b ∈ centralizer S) :\n    a / b ∈ centralizer S := by\n  simpa only [div_eq_mul_inv] using mul_mem_centralizer ha (inv_mem_centralizer hb)\n\n"}
{"name":"Set.div_mem_centralizer","module":"Mathlib.Algebra.Group.Center","initialProofState":"M : Type u_1\nS : Set M\ninst✝ : Group M\na b : M\nha : Membership.mem S.centralizer a\nhb : Membership.mem S.centralizer b\n⊢ Membership.mem S.centralizer (HDiv.hDiv a b)","decl":"@[to_additive (attr := simp) sub_mem_addCentralizer]\nlemma div_mem_centralizer (ha : a ∈ centralizer S) (hb : b ∈ centralizer S) :\n    a / b ∈ centralizer S := by\n  simpa only [div_eq_mul_inv] using mul_mem_centralizer ha (inv_mem_centralizer hb)\n\n"}
