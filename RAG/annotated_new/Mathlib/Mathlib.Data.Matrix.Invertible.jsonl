{"name":"Matrix.invOf_mul_cancel_left","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (Invertible.invOf A) (HMul.hMul A B)) B","decl":"/-- A copy of `invOf_mul_cancel_left` for rectangular matrices. -/\nprotected theorem invOf_mul_cancel_left (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :\n    ⅟ A * (A * B) = B := by rw [← Matrix.mul_assoc, invOf_mul_self, Matrix.one_mul]\n\n"}
{"name":"Matrix.mul_invOf_cancel_left","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul A (HMul.hMul (Invertible.invOf A) B)) B","decl":"/-- A copy of `mul_invOf_cancel_left` for rectangular matrices. -/\nprotected theorem mul_invOf_cancel_left (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :\n    A * (⅟ A * B) = B := by rw [← Matrix.mul_assoc, mul_invOf_self, Matrix.one_mul]\n\n"}
{"name":"Matrix.invOf_mul_cancel_right","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix m n α\nB : Matrix n n α\ninst✝ : Invertible B\n⊢ Eq (HMul.hMul (HMul.hMul A (Invertible.invOf B)) B) A","decl":"/-- A copy of `invOf_mul_cancel_right` for rectangular matrices. -/\nprotected theorem invOf_mul_cancel_right (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :\n    A * ⅟ B * B = A := by rw [Matrix.mul_assoc, invOf_mul_self, Matrix.mul_one]\n\n"}
{"name":"Matrix.mul_invOf_cancel_right","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix m n α\nB : Matrix n n α\ninst✝ : Invertible B\n⊢ Eq (HMul.hMul (HMul.hMul A B) (Invertible.invOf B)) A","decl":"/-- A copy of `mul_invOf_cancel_right` for rectangular matrices. -/\nprotected theorem mul_invOf_cancel_right (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :\n    A * B * ⅟ B = A := by rw [Matrix.mul_assoc, mul_invOf_self, Matrix.mul_one]\n\n"}
{"name":"Matrix.invOf_mul_self_assoc","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (Invertible.invOf A) (HMul.hMul A B)) B","decl":"@[deprecated (since := \"2024-09-07\")]\nprotected alias invOf_mul_self_assoc := Matrix.invOf_mul_cancel_left\n"}
{"name":"Matrix.mul_invOf_self_assoc","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul A (HMul.hMul (Invertible.invOf A) B)) B","decl":"@[deprecated (since := \"2024-09-07\")]\nprotected alias mul_invOf_self_assoc := Matrix.mul_invOf_cancel_left\n"}
{"name":"Matrix.mul_invOf_mul_self_cancel","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix m n α\nB : Matrix n n α\ninst✝ : Invertible B\n⊢ Eq (HMul.hMul (HMul.hMul A (Invertible.invOf B)) B) A","decl":"@[deprecated (since := \"2024-09-07\")]\nprotected alias mul_invOf_mul_self_cancel := Matrix.invOf_mul_cancel_right\n"}
{"name":"Matrix.mul_mul_invOf_self_cancel","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\nA : Matrix m n α\nB : Matrix n n α\ninst✝ : Invertible B\n⊢ Eq (HMul.hMul (HMul.hMul A B) (Invertible.invOf B)) A","decl":"@[deprecated (since := \"2024-09-07\")]\nprotected alias mul_mul_invOf_self_cancel := Matrix.mul_invOf_cancel_right\n\n"}
{"name":"Matrix.conjTranspose_invOf","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝⁵ : Fintype n\ninst✝⁴ : DecidableEq n\ninst✝³ : Semiring α\ninst✝² : StarRing α\nA : Matrix n n α\ninst✝¹ : Invertible A\ninst✝ : Invertible A.conjTranspose\n⊢ Eq (Invertible.invOf A).conjTranspose (Invertible.invOf A.conjTranspose)","decl":"lemma conjTranspose_invOf [Invertible A] [Invertible Aᴴ] : (⅟A)ᴴ = ⅟(Aᴴ) := star_invOf _\n\n"}
{"name":"Matrix.isUnit_conjTranspose","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nA : Matrix n n α\n⊢ Iff (IsUnit A.conjTranspose) (IsUnit A)","decl":"@[simp] lemma isUnit_conjTranspose : IsUnit Aᴴ ↔ IsUnit A := isUnit_star\n\n"}
{"name":"Matrix.transpose_invOf","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommSemiring α\nA : Matrix n n α\ninst✝¹ : Invertible A\ninst✝ : Invertible A.transpose\n⊢ Eq (Invertible.invOf A).transpose (Invertible.invOf A.transpose)","decl":"lemma transpose_invOf [Invertible A] [Invertible Aᵀ] : (⅟A)ᵀ = ⅟(Aᵀ) := by\n  letI := invertibleTranspose A\n  convert (rfl : _ = ⅟(Aᵀ))\n\n"}
{"name":"Matrix.transposeInvertibleEquivInvertible_apply","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommSemiring α\nA : Matrix n n α\ninst✝ : Invertible A.transpose\n⊢ Eq (A.transposeInvertibleEquivInvertible inst✝) A.invertibleOfInvertibleTranspose","decl":"/-- Together `Matrix.invertibleTranspose` and `Matrix.invertibleOfInvertibleTranspose` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef transposeInvertibleEquivInvertible : Invertible Aᵀ ≃ Invertible A where\n  toFun := @invertibleOfInvertibleTranspose _ _ _ _ _ _\n  invFun := @invertibleTranspose _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.transposeInvertibleEquivInvertible_symm_apply","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommSemiring α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (A.transposeInvertibleEquivInvertible.symm inst✝) A.invertibleTranspose","decl":"/-- Together `Matrix.invertibleTranspose` and `Matrix.invertibleOfInvertibleTranspose` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef transposeInvertibleEquivInvertible : Invertible Aᵀ ≃ Invertible A where\n  toFun := @invertibleOfInvertibleTranspose _ _ _ _ _ _\n  invFun := @invertibleTranspose _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.isUnit_transpose","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"n : Type u_2\nα : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring α\nA : Matrix n n α\n⊢ Iff (IsUnit A.transpose) (IsUnit A)","decl":"@[simp] lemma isUnit_transpose : IsUnit Aᵀ ↔ IsUnit A := by\n  simp only [← nonempty_invertible_iff_isUnit,\n    (transposeInvertibleEquivInvertible A).nonempty_congr]\n\n"}
{"name":"Matrix.add_mul_mul_invOf_mul_eq_one","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝⁷ : Fintype n\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Ring α\nA : Matrix n n α\nU : Matrix n m α\nC : Matrix m m α\nV : Matrix m n α\ninst✝² : Invertible A\ninst✝¹ : Invertible C\ninst✝ : Invertible (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U))\n⊢ Eq (HMul.hMul (HAdd.hAdd A (HMul.hMul (HMul.hMul U C) V)) (HSub.hSub (Invertible.invOf A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf A) U) (Invertible.invOf (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U)))) V) (Invertible.invOf A)))) 1","decl":"lemma add_mul_mul_invOf_mul_eq_one :\n    (A + U*C*V)*(⅟A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A) = 1 := by\n  calc\n    (A + U*C*V)*(⅟A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A)\n    _ = A*⅟A - A*⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A + U*C*V*⅟A - U*C*V*⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A := by\n      simp_rw [add_sub_assoc, add_mul, mul_sub, Matrix.mul_assoc]\n    _ = (1 + U*C*V*⅟A) - (U*⅟(⅟C + V*⅟A*U)*V*⅟A + U*C*V*⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A) := by\n      rw [mul_invOf_self, Matrix.one_mul]\n      abel\n    _ = 1 + U*C*V*⅟A - (U + U*C*V*⅟A*U)*⅟(⅟C + V*⅟A*U)*V*⅟A := by\n      rw [sub_right_inj, Matrix.add_mul, Matrix.add_mul, Matrix.add_mul]\n    _ = 1 + U*C*V*⅟A - U*C*(⅟C + V*⅟A*U)*⅟(⅟C + V*⅟A*U)*V*⅟A := by\n      congr\n      simp only [Matrix.mul_add, Matrix.mul_invOf_cancel_right, ← Matrix.mul_assoc]\n    _ = 1 := by\n      rw [Matrix.mul_invOf_cancel_right]\n      abel\n\n"}
{"name":"Matrix.add_mul_mul_invOf_mul_eq_one'","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝⁷ : Fintype n\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Ring α\nA : Matrix n n α\nU : Matrix n m α\nC : Matrix m m α\nV : Matrix m n α\ninst✝² : Invertible A\ninst✝¹ : Invertible C\ninst✝ : Invertible (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U))\n⊢ Eq (HMul.hMul (HSub.hSub (Invertible.invOf A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf A) U) (Invertible.invOf (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U)))) V) (Invertible.invOf A))) (HAdd.hAdd A (HMul.hMul (HMul.hMul U C) V))) 1","decl":"/-- Like `add_mul_mul_invOf_mul_eq_one`, but with multiplication reversed. -/\nlemma add_mul_mul_invOf_mul_eq_one' :\n    (⅟A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A)*(A + U*C*V) = 1 := by\n  calc\n    (⅟A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A)*(A + U*C*V)\n    _ = ⅟A*A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A*A + ⅟A*U*C*V - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A*U*C*V := by\n      simp_rw [add_sub_assoc, _root_.mul_add, _root_.sub_mul, Matrix.mul_assoc]\n    _ = (1 + ⅟A*U*C*V) - (⅟A*U*⅟(⅟C + V*⅟A*U)*V + ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A*U*C*V) := by\n      rw [invOf_mul_self, Matrix.invOf_mul_cancel_right]\n      abel\n    _ = 1 + ⅟A*U*C*V - ⅟A*U*⅟(⅟C + V*⅟A*U)*(V + V*⅟A*U*C*V) := by\n      rw [sub_right_inj, Matrix.mul_add]\n      simp_rw [Matrix.mul_assoc]\n    _ = 1 + ⅟A*U*C*V - ⅟A*U*⅟(⅟C + V*⅟A*U)*(⅟C + V*⅟A*U)*C*V := by\n      congr 1\n      simp only [Matrix.mul_add, Matrix.add_mul, ← Matrix.mul_assoc,\n        Matrix.invOf_mul_cancel_right]\n    _ = 1 := by\n      rw [Matrix.invOf_mul_cancel_right]\n      abel\n\n"}
{"name":"Matrix.invOf_add_mul_mul","module":"Mathlib.Data.Matrix.Invertible","initialProofState":"m : Type u_1\nn : Type u_2\nα : Type u_3\ninst✝⁸ : Fintype n\ninst✝⁷ : DecidableEq n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Ring α\nA : Matrix n n α\nU : Matrix n m α\nC : Matrix m m α\nV : Matrix m n α\ninst✝³ : Invertible A\ninst✝² : Invertible C\ninst✝¹ : Invertible (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U))\ninst✝ : Invertible (HAdd.hAdd A (HMul.hMul (HMul.hMul U C) V))\n⊢ Eq (Invertible.invOf (HAdd.hAdd A (HMul.hMul (HMul.hMul U C) V))) (HSub.hSub (Invertible.invOf A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf A) U) (Invertible.invOf (HAdd.hAdd (Invertible.invOf C) (HMul.hMul (HMul.hMul V (Invertible.invOf A)) U)))) V) (Invertible.invOf A)))","decl":"/-- The **Woodbury Identity** (`⅟` version). -/\ntheorem invOf_add_mul_mul [Invertible (A + U*C*V)] :\n    ⅟(A + U*C*V) = ⅟A - ⅟A*U*⅟(⅟C + V*⅟A*U)*V*⅟A := by\n  letI := invertibleAddMulMul A U C V\n  convert (rfl : ⅟(A + U*C*V) = _)\n\n"}
