{"name":"ContinuousLinearMap.norm_fst_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.fst ğ•œ E F)) 1","decl":"/-- The operator norm of the first projection `E Ã— F â†’ E` is at most 1. (It is 0 if `E` is zero, so\nthe inequality cannot be improved without further assumptions.) -/\nlemma norm_fst_le : â€–fst ğ•œ E Fâ€– â‰¤ 1 :=\n  opNorm_le_bound _ zero_le_one (fun âŸ¨e, fâŸ© â†¦ by simpa only [one_mul] using le_max_left â€–eâ€– â€–fâ€–)\n\n"}
{"name":"ContinuousLinearMap.norm_snd_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.snd ğ•œ E F)) 1","decl":"/-- The operator norm of the second projection `E Ã— F â†’ F` is at most 1. (It is 0 if `F` is zero, so\nthe inequality cannot be improved without further assumptions.) -/\nlemma norm_snd_le : â€–snd ğ•œ E Fâ€– â‰¤ 1 :=\n  opNorm_le_bound _ zero_le_one (fun âŸ¨e, fâŸ© â†¦ by simpa only [one_mul] using le_max_right â€–eâ€– â€–fâ€–)\n\n"}
{"name":"ContinuousLinearMap.opNorm_prod","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : ContinuousLinearMap (RingHom.id ğ•œ) E G\nâŠ¢ Eq (Norm.norm (f.prod g)) (Norm.norm { fst := f, snd := g })","decl":"@[simp]\ntheorem opNorm_prod (f : E â†’L[ğ•œ] F) (g : E â†’L[ğ•œ] G) : â€–f.prod gâ€– = â€–(f, g)â€– :=\n  le_antisymm\n      (opNorm_le_bound _ (norm_nonneg _) fun x => by\n        simpa only [prod_apply, Prod.norm_def, max_mul_of_nonneg, norm_nonneg] using\n          max_le_max (le_opNorm f x) (le_opNorm g x)) <|\n    max_le\n      (opNorm_le_bound _ (norm_nonneg _) fun x =>\n        (le_max_left _ _).trans ((f.prod g).le_opNorm x))\n      (opNorm_le_bound _ (norm_nonneg _) fun x =>\n        (le_max_right _ _).trans ((f.prod g).le_opNorm x))\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_prod","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : ContinuousLinearMap (RingHom.id ğ•œ) E G\nâŠ¢ Eq (NNNorm.nnnorm (f.prod g)) (NNNorm.nnnorm { fst := f, snd := g })","decl":"@[simp]\ntheorem opNNNorm_prod (f : E â†’L[ğ•œ] F) (g : E â†’L[ğ•œ] G) : â€–f.prod gâ€–â‚Š = â€–(f, g)â€–â‚Š :=\n  Subtype.ext <| opNorm_prod f g\n\n\n"}
{"name":"ContinuousLinearMap.prodMapL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\nMâ‚„ : Type u_8\ninstâœâ· : SeminormedAddCommGroup Mâ‚\ninstâœâ¶ : NormedSpace ğ•œ Mâ‚\ninstâœâµ : SeminormedAddCommGroup Mâ‚‚\ninstâœâ´ : NormedSpace ğ•œ Mâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup Mâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ Mâ‚ƒ\ninstâœÂ¹ : SeminormedAddCommGroup Mâ‚„\ninstâœ : NormedSpace ğ•œ Mâ‚„\np : Prod (ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ Mâ‚‚) (ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ƒ Mâ‚„)\nâŠ¢ Eq ((ContinuousLinearMap.prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„) p) (p.1.prodMap p.2)","decl":"@[simp]\ntheorem prodMapL_apply (p : (Mâ‚ â†’L[ğ•œ] Mâ‚‚) Ã— (Mâ‚ƒ â†’L[ğ•œ] Mâ‚„)) :\n    ContinuousLinearMap.prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„ p = p.1.prodMap p.2 :=\n  rfl\n\n"}
{"name":"Continuous.prod_mapL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\nMâ‚„ : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : NormedSpace ğ•œ Mâ‚\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚‚\ninstâœâµ : NormedSpace ğ•œ Mâ‚‚\ninstâœâ´ : SeminormedAddCommGroup Mâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ Mâ‚ƒ\ninstâœÂ² : SeminormedAddCommGroup Mâ‚„\ninstâœÂ¹ : NormedSpace ğ•œ Mâ‚„\nX : Type u_9\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ Mâ‚‚\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ƒ Mâ‚„\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => (f x).prodMap (g x)","decl":"theorem _root_.Continuous.prod_mapL {f : X â†’ Mâ‚ â†’L[ğ•œ] Mâ‚‚} {g : X â†’ Mâ‚ƒ â†’L[ğ•œ] Mâ‚„} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => (f x).prodMap (g x) :=\n  (prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„).continuous.comp (hf.prod_mk hg)\n\n"}
{"name":"Continuous.prod_map_equivL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\nMâ‚„ : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : NormedSpace ğ•œ Mâ‚\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚‚\ninstâœâµ : NormedSpace ğ•œ Mâ‚‚\ninstâœâ´ : SeminormedAddCommGroup Mâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ Mâ‚ƒ\ninstâœÂ² : SeminormedAddCommGroup Mâ‚„\ninstâœÂ¹ : NormedSpace ğ•œ Mâ‚„\nX : Type u_9\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) Mâ‚ Mâ‚‚\ng : X â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) Mâ‚ƒ Mâ‚„\nhf : Continuous fun x => â†‘(f x)\nhg : Continuous fun x => â†‘(g x)\nâŠ¢ Continuous fun x => â†‘((f x).prod (g x))","decl":"theorem _root_.Continuous.prod_map_equivL {f : X â†’ Mâ‚ â‰ƒL[ğ•œ] Mâ‚‚} {g : X â†’ Mâ‚ƒ â‰ƒL[ğ•œ] Mâ‚„}\n    (hf : Continuous fun x => (f x : Mâ‚ â†’L[ğ•œ] Mâ‚‚)) (hg : Continuous fun x => (g x : Mâ‚ƒ â†’L[ğ•œ] Mâ‚„)) :\n    Continuous fun x => ((f x).prod (g x) : Mâ‚ Ã— Mâ‚ƒ â†’L[ğ•œ] Mâ‚‚ Ã— Mâ‚„) :=\n  (prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„).continuous.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousOn.prod_mapL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\nMâ‚„ : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : NormedSpace ğ•œ Mâ‚\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚‚\ninstâœâµ : NormedSpace ğ•œ Mâ‚‚\ninstâœâ´ : SeminormedAddCommGroup Mâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ Mâ‚ƒ\ninstâœÂ² : SeminormedAddCommGroup Mâ‚„\ninstâœÂ¹ : NormedSpace ğ•œ Mâ‚„\nX : Type u_9\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ Mâ‚‚\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) Mâ‚ƒ Mâ‚„\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => (f x).prodMap (g x)) s","decl":"theorem _root_.ContinuousOn.prod_mapL {f : X â†’ Mâ‚ â†’L[ğ•œ] Mâ‚‚} {g : X â†’ Mâ‚ƒ â†’L[ğ•œ] Mâ‚„} {s : Set X}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => (f x).prodMap (g x)) s :=\n  ((prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„).continuous.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"ContinuousOn.prod_map_equivL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚ƒ : Type u_7\nMâ‚„ : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : NormedSpace ğ•œ Mâ‚\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚‚\ninstâœâµ : NormedSpace ğ•œ Mâ‚‚\ninstâœâ´ : SeminormedAddCommGroup Mâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ Mâ‚ƒ\ninstâœÂ² : SeminormedAddCommGroup Mâ‚„\ninstâœÂ¹ : NormedSpace ğ•œ Mâ‚„\nX : Type u_9\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) Mâ‚ Mâ‚‚\ng : X â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) Mâ‚ƒ Mâ‚„\ns : Set X\nhf : ContinuousOn (fun x => â†‘(f x)) s\nhg : ContinuousOn (fun x => â†‘(g x)) s\nâŠ¢ ContinuousOn (fun x => â†‘((f x).prod (g x))) s","decl":"theorem _root_.ContinuousOn.prod_map_equivL {f : X â†’ Mâ‚ â‰ƒL[ğ•œ] Mâ‚‚} {g : X â†’ Mâ‚ƒ â‰ƒL[ğ•œ] Mâ‚„} {s : Set X}\n    (hf : ContinuousOn (fun x => (f x : Mâ‚ â†’L[ğ•œ] Mâ‚‚)) s)\n    (hg : ContinuousOn (fun x => (g x : Mâ‚ƒ â†’L[ğ•œ] Mâ‚„)) s) :\n    ContinuousOn (fun x => ((f x).prod (g x) : Mâ‚ Ã— Mâ‚ƒ â†’L[ğ•œ] Mâ‚‚ Ã— Mâ‚„)) s :=\n  (prodMapL ğ•œ Mâ‚ Mâ‚‚ Mâ‚ƒ Mâ‚„).continuous.comp_continuousOn (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.norm_fst","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : Nontrivial E\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.fst ğ•œ E F)) 1","decl":"/-- The operator norm of the first projection `E Ã— F â†’ E` is exactly 1 if `E` is nontrivial. -/\n@[simp] lemma norm_fst [NormedAddCommGroup E] [NormedSpace ğ•œ E]\n    [SeminormedAddCommGroup F] [NormedSpace ğ•œ F] [Nontrivial E] :\n    â€–fst ğ•œ E Fâ€– = 1 := by\n  refine le_antisymm (norm_fst_le ..) ?_\n  let âŸ¨e, heâŸ© := exists_ne (0 : E)\n  have : â€–eâ€– â‰¤ _ * max â€–eâ€– â€–(0 : F)â€– := (fst ğ•œ E F).le_opNorm (e, 0)\n  rw [norm_zero, max_eq_left (norm_nonneg e)] at this\n  rwa [â† mul_le_mul_iff_of_pos_right (norm_pos_iff.mpr he), one_mul]\n\n"}
{"name":"ContinuousLinearMap.norm_snd","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : Nontrivial F\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.snd ğ•œ E F)) 1","decl":"/-- The operator norm of the second projection `E Ã— F â†’ F` is exactly 1 if `F` is nontrivial. -/\n@[simp] lemma norm_snd [SeminormedAddCommGroup E] [NormedSpace ğ•œ E]\n    [NormedAddCommGroup F] [NormedSpace ğ•œ F] [Nontrivial F]  :\n    â€–snd ğ•œ E Fâ€– = 1 := by\n  refine le_antisymm (norm_snd_le ..) ?_\n  let âŸ¨f, hfâŸ© := exists_ne (0 : F)\n  have : â€–fâ€– â‰¤ _ * max â€–(0 : E)â€– â€–fâ€– := (snd ğ•œ E F).le_opNorm (0, f)\n  rw [norm_zero, max_eq_right (norm_nonneg f)] at this\n  rwa [â† mul_le_mul_iff_of_pos_right (norm_pos_iff.mpr hf), one_mul]\n\n"}
