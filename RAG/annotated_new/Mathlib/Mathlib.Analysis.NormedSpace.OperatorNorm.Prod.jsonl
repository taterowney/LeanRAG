{"name":"ContinuousLinearMap.norm_fst_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\n⊢ LE.le (Norm.norm (ContinuousLinearMap.fst 𝕜 E F)) 1","decl":"/-- The operator norm of the first projection `E × F → E` is at most 1. (It is 0 if `E` is zero, so\nthe inequality cannot be improved without further assumptions.) -/\nlemma norm_fst_le : ‖fst 𝕜 E F‖ ≤ 1 :=\n  opNorm_le_bound _ zero_le_one (fun ⟨e, f⟩ ↦ by simpa only [one_mul] using le_max_left ‖e‖ ‖f‖)\n\n"}
{"name":"ContinuousLinearMap.norm_snd_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 F\n⊢ LE.le (Norm.norm (ContinuousLinearMap.snd 𝕜 E F)) 1","decl":"/-- The operator norm of the second projection `E × F → F` is at most 1. (It is 0 if `F` is zero, so\nthe inequality cannot be improved without further assumptions.) -/\nlemma norm_snd_le : ‖snd 𝕜 E F‖ ≤ 1 :=\n  opNorm_le_bound _ zero_le_one (fun ⟨e, f⟩ ↦ by simpa only [one_mul] using le_max_right ‖e‖ ‖f‖)\n\n"}
{"name":"ContinuousLinearMap.opNorm_prod","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ng : ContinuousLinearMap (RingHom.id 𝕜) E G\n⊢ Eq (Norm.norm (f.prod g)) (Norm.norm { fst := f, snd := g })","decl":"@[simp]\ntheorem opNorm_prod (f : E →L[𝕜] F) (g : E →L[𝕜] G) : ‖f.prod g‖ = ‖(f, g)‖ :=\n  le_antisymm\n      (opNorm_le_bound _ (norm_nonneg _) fun x => by\n        simpa only [prod_apply, Prod.norm_def, max_mul_of_nonneg, norm_nonneg] using\n          max_le_max (le_opNorm f x) (le_opNorm g x)) <|\n    max_le\n      (opNorm_le_bound _ (norm_nonneg _) fun x =>\n        (le_max_left _ _).trans ((f.prod g).le_opNorm x))\n      (opNorm_le_bound _ (norm_nonneg _) fun x =>\n        (le_max_right _ _).trans ((f.prod g).le_opNorm x))\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_prod","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ng : ContinuousLinearMap (RingHom.id 𝕜) E G\n⊢ Eq (NNNorm.nnnorm (f.prod g)) (NNNorm.nnnorm { fst := f, snd := g })","decl":"@[simp]\ntheorem opNNNorm_prod (f : E →L[𝕜] F) (g : E →L[𝕜] G) : ‖f.prod g‖₊ = ‖(f, g)‖₊ :=\n  Subtype.ext <| opNorm_prod f g\n\n\n"}
{"name":"ContinuousLinearMap.prodMapL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\nM₄ : Type u_8\ninst✝⁷ : SeminormedAddCommGroup M₁\ninst✝⁶ : NormedSpace 𝕜 M₁\ninst✝⁵ : SeminormedAddCommGroup M₂\ninst✝⁴ : NormedSpace 𝕜 M₂\ninst✝³ : SeminormedAddCommGroup M₃\ninst✝² : NormedSpace 𝕜 M₃\ninst✝¹ : SeminormedAddCommGroup M₄\ninst✝ : NormedSpace 𝕜 M₄\np : Prod (ContinuousLinearMap (RingHom.id 𝕜) M₁ M₂) (ContinuousLinearMap (RingHom.id 𝕜) M₃ M₄)\n⊢ Eq ((ContinuousLinearMap.prodMapL 𝕜 M₁ M₂ M₃ M₄) p) (p.1.prodMap p.2)","decl":"@[simp]\ntheorem prodMapL_apply (p : (M₁ →L[𝕜] M₂) × (M₃ →L[𝕜] M₄)) :\n    ContinuousLinearMap.prodMapL 𝕜 M₁ M₂ M₃ M₄ p = p.1.prodMap p.2 :=\n  rfl\n\n"}
{"name":"Continuous.prod_mapL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\nM₄ : Type u_8\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : NormedSpace 𝕜 M₁\ninst✝⁶ : SeminormedAddCommGroup M₂\ninst✝⁵ : NormedSpace 𝕜 M₂\ninst✝⁴ : SeminormedAddCommGroup M₃\ninst✝³ : NormedSpace 𝕜 M₃\ninst✝² : SeminormedAddCommGroup M₄\ninst✝¹ : NormedSpace 𝕜 M₄\nX : Type u_9\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearMap (RingHom.id 𝕜) M₁ M₂\ng : X → ContinuousLinearMap (RingHom.id 𝕜) M₃ M₄\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => (f x).prodMap (g x)","decl":"theorem _root_.Continuous.prod_mapL {f : X → M₁ →L[𝕜] M₂} {g : X → M₃ →L[𝕜] M₄} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => (f x).prodMap (g x) :=\n  (prodMapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp (hf.prod_mk hg)\n\n"}
{"name":"Continuous.prod_map_equivL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\nM₄ : Type u_8\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : NormedSpace 𝕜 M₁\ninst✝⁶ : SeminormedAddCommGroup M₂\ninst✝⁵ : NormedSpace 𝕜 M₂\ninst✝⁴ : SeminormedAddCommGroup M₃\ninst✝³ : NormedSpace 𝕜 M₃\ninst✝² : SeminormedAddCommGroup M₄\ninst✝¹ : NormedSpace 𝕜 M₄\nX : Type u_9\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearEquiv (RingHom.id 𝕜) M₁ M₂\ng : X → ContinuousLinearEquiv (RingHom.id 𝕜) M₃ M₄\nhf : Continuous fun x => ↑(f x)\nhg : Continuous fun x => ↑(g x)\n⊢ Continuous fun x => ↑((f x).prod (g x))","decl":"theorem _root_.Continuous.prod_map_equivL {f : X → M₁ ≃L[𝕜] M₂} {g : X → M₃ ≃L[𝕜] M₄}\n    (hf : Continuous fun x => (f x : M₁ →L[𝕜] M₂)) (hg : Continuous fun x => (g x : M₃ →L[𝕜] M₄)) :\n    Continuous fun x => ((f x).prod (g x) : M₁ × M₃ →L[𝕜] M₂ × M₄) :=\n  (prodMapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousOn.prod_mapL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\nM₄ : Type u_8\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : NormedSpace 𝕜 M₁\ninst✝⁶ : SeminormedAddCommGroup M₂\ninst✝⁵ : NormedSpace 𝕜 M₂\ninst✝⁴ : SeminormedAddCommGroup M₃\ninst✝³ : NormedSpace 𝕜 M₃\ninst✝² : SeminormedAddCommGroup M₄\ninst✝¹ : NormedSpace 𝕜 M₄\nX : Type u_9\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearMap (RingHom.id 𝕜) M₁ M₂\ng : X → ContinuousLinearMap (RingHom.id 𝕜) M₃ M₄\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => (f x).prodMap (g x)) s","decl":"theorem _root_.ContinuousOn.prod_mapL {f : X → M₁ →L[𝕜] M₂} {g : X → M₃ →L[𝕜] M₄} {s : Set X}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => (f x).prodMap (g x)) s :=\n  ((prodMapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp_continuousOn (hf.prod hg) :)\n\n"}
{"name":"ContinuousOn.prod_map_equivL","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nM₁ : Type u_5\nM₂ : Type u_6\nM₃ : Type u_7\nM₄ : Type u_8\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : NormedSpace 𝕜 M₁\ninst✝⁶ : SeminormedAddCommGroup M₂\ninst✝⁵ : NormedSpace 𝕜 M₂\ninst✝⁴ : SeminormedAddCommGroup M₃\ninst✝³ : NormedSpace 𝕜 M₃\ninst✝² : SeminormedAddCommGroup M₄\ninst✝¹ : NormedSpace 𝕜 M₄\nX : Type u_9\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearEquiv (RingHom.id 𝕜) M₁ M₂\ng : X → ContinuousLinearEquiv (RingHom.id 𝕜) M₃ M₄\ns : Set X\nhf : ContinuousOn (fun x => ↑(f x)) s\nhg : ContinuousOn (fun x => ↑(g x)) s\n⊢ ContinuousOn (fun x => ↑((f x).prod (g x))) s","decl":"theorem _root_.ContinuousOn.prod_map_equivL {f : X → M₁ ≃L[𝕜] M₂} {g : X → M₃ ≃L[𝕜] M₄} {s : Set X}\n    (hf : ContinuousOn (fun x => (f x : M₁ →L[𝕜] M₂)) s)\n    (hg : ContinuousOn (fun x => (g x : M₃ →L[𝕜] M₄)) s) :\n    ContinuousOn (fun x => ((f x).prod (g x) : M₁ × M₃ →L[𝕜] M₂ × M₄)) s :=\n  (prodMapL 𝕜 M₁ M₂ M₃ M₄).continuous.comp_continuousOn (hf.prod hg)\n\n"}
{"name":"ContinuousLinearMap.norm_fst","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : Nontrivial E\n⊢ Eq (Norm.norm (ContinuousLinearMap.fst 𝕜 E F)) 1","decl":"/-- The operator norm of the first projection `E × F → E` is exactly 1 if `E` is nontrivial. -/\n@[simp] lemma norm_fst [NormedAddCommGroup E] [NormedSpace 𝕜 E]\n    [SeminormedAddCommGroup F] [NormedSpace 𝕜 F] [Nontrivial E] :\n    ‖fst 𝕜 E F‖ = 1 := by\n  refine le_antisymm (norm_fst_le ..) ?_\n  let ⟨e, he⟩ := exists_ne (0 : E)\n  have : ‖e‖ ≤ _ * max ‖e‖ ‖(0 : F)‖ := (fst 𝕜 E F).le_opNorm (e, 0)\n  rw [norm_zero, max_eq_left (norm_nonneg e)] at this\n  rwa [← mul_le_mul_iff_of_pos_right (norm_pos_iff.mpr he), one_mul]\n\n"}
{"name":"ContinuousLinearMap.norm_snd","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Prod","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : Nontrivial F\n⊢ Eq (Norm.norm (ContinuousLinearMap.snd 𝕜 E F)) 1","decl":"/-- The operator norm of the second projection `E × F → F` is exactly 1 if `F` is nontrivial. -/\n@[simp] lemma norm_snd [SeminormedAddCommGroup E] [NormedSpace 𝕜 E]\n    [NormedAddCommGroup F] [NormedSpace 𝕜 F] [Nontrivial F]  :\n    ‖snd 𝕜 E F‖ = 1 := by\n  refine le_antisymm (norm_snd_le ..) ?_\n  let ⟨f, hf⟩ := exists_ne (0 : F)\n  have : ‖f‖ ≤ _ * max ‖(0 : E)‖ ‖f‖ := (snd 𝕜 E F).le_opNorm (0, f)\n  rw [norm_zero, max_eq_right (norm_nonneg f)] at this\n  rwa [← mul_le_mul_iff_of_pos_right (norm_pos_iff.mpr hf), one_mul]\n\n"}
