{"name":"isCyclotomicExtension_iff","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\n⊢ Iff (IsCyclotomicExtension S A B) (And (∀ {n : PNat}, Membership.mem S n → Exists fun r => IsPrimitiveRoot r ↑n) (∀ (x : B), Membership.mem (Algebra.adjoin A (setOf fun b => Exists fun n => And (Membership.mem S n) (Eq (HPow.hPow b ↑n) 1))) x))","decl":"/-- Given an `A`-algebra `B` and `S : Set ℕ+`, we define `IsCyclotomicExtension S A B` requiring\nthat there is an `n`-th primitive root of unity in `B` for all `n ∈ S` and that `B` is generated\nover `A` by the roots of `X ^ n - 1`. -/\n\n@[mk_iff]\nclass IsCyclotomicExtension : Prop where\n  /-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\n  exists_prim_root {n : ℕ+} (ha : n ∈ S) : ∃ r : B, IsPrimitiveRoot r n\n  /-- The `n`-th roots of unity, for `n ∈ S`, generate `B` as an `A`-algebra. -/\n  adjoin_roots : ∀ x : B, x ∈ adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}\n\n"}
{"name":"IsCyclotomicExtension.adjoin_roots","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nself : IsCyclotomicExtension S A B\nx : B\n⊢ Membership.mem (Algebra.adjoin A (setOf fun b => Exists fun n => And (Membership.mem S n) (Eq (HPow.hPow b ↑n) 1))) x","decl":"/-- Given an `A`-algebra `B` and `S : Set ℕ+`, we define `IsCyclotomicExtension S A B` requiring\nthat there is an `n`-th primitive root of unity in `B` for all `n ∈ S` and that `B` is generated\nover `A` by the roots of `X ^ n - 1`. -/\n\n@[mk_iff]\nclass IsCyclotomicExtension : Prop where\n  /-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\n  exists_prim_root {n : ℕ+} (ha : n ∈ S) : ∃ r : B, IsPrimitiveRoot r n\n  /-- The `n`-th roots of unity, for `n ∈ S`, generate `B` as an `A`-algebra. -/\n  adjoin_roots : ∀ x : B, x ∈ adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}\n\n"}
{"name":"IsCyclotomicExtension.exists_prim_root","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nself : IsCyclotomicExtension S A B\nn : PNat\nha : Membership.mem S n\n⊢ Exists fun r => IsPrimitiveRoot r ↑n","decl":"/-- Given an `A`-algebra `B` and `S : Set ℕ+`, we define `IsCyclotomicExtension S A B` requiring\nthat there is an `n`-th primitive root of unity in `B` for all `n ∈ S` and that `B` is generated\nover `A` by the roots of `X ^ n - 1`. -/\n\n@[mk_iff]\nclass IsCyclotomicExtension : Prop where\n  /-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\n  exists_prim_root {n : ℕ+} (ha : n ∈ S) : ∃ r : B, IsPrimitiveRoot r n\n  /-- The `n`-th roots of unity, for `n ∈ S`, generate `B` as an `A`-algebra. -/\n  adjoin_roots : ∀ x : B, x ∈ adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}\n\n"}
{"name":"IsCyclotomicExtension.iff_adjoin_eq_top","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\n⊢ Iff (IsCyclotomicExtension S A B) (And (∀ (n : PNat), Membership.mem S n → Exists fun r => IsPrimitiveRoot r ↑n) (Eq (Algebra.adjoin A (setOf fun b => Exists fun n => And (Membership.mem S n) (Eq (HPow.hPow b ↑n) 1))) Top.top))","decl":"/-- A reformulation of `IsCyclotomicExtension` that uses `⊤`. -/\ntheorem iff_adjoin_eq_top :\n    IsCyclotomicExtension S A B ↔\n      (∀ n : ℕ+, n ∈ S → ∃ r : B, IsPrimitiveRoot r n) ∧\n        adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ :=\n  ⟨fun h => ⟨fun _ => h.exists_prim_root, Algebra.eq_top_iff.2 h.adjoin_roots⟩, fun h =>\n    ⟨h.1 _, Algebra.eq_top_iff.1 h.2⟩⟩\n\n"}
{"name":"IsCyclotomicExtension.iff_singleton","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\n⊢ Iff (IsCyclotomicExtension (Singleton.singleton n) A B) (And (Exists fun r => IsPrimitiveRoot r ↑n) (∀ (x : B), Membership.mem (Algebra.adjoin A (setOf fun b => Eq (HPow.hPow b ↑n) 1)) x))","decl":"/-- A reformulation of `IsCyclotomicExtension` in the case `S` is a singleton. -/\ntheorem iff_singleton :\n    IsCyclotomicExtension {n} A B ↔\n      (∃ r : B, IsPrimitiveRoot r n) ∧ ∀ x, x ∈ adjoin A {b : B | b ^ (n : ℕ) = 1} := by\n  simp [isCyclotomicExtension_iff]\n\n"}
{"name":"IsCyclotomicExtension.empty","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : IsCyclotomicExtension EmptyCollection.emptyCollection A B\n⊢ Eq Bot.bot Top.top","decl":"/-- If `IsCyclotomicExtension ∅ A B`, then the image of `A` in `B` equals `B`. -/\ntheorem empty [h : IsCyclotomicExtension ∅ A B] : (⊥ : Subalgebra A B) = ⊤ := by\n  simpa [Algebra.eq_top_iff, isCyclotomicExtension_iff] using h\n\n"}
{"name":"IsCyclotomicExtension.singleton_one","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : IsCyclotomicExtension (Singleton.singleton 1) A B\n⊢ Eq Bot.bot Top.top","decl":"/-- If `IsCyclotomicExtension {1} A B`, then the image of `A` in `B` equals `B`. -/\ntheorem singleton_one [h : IsCyclotomicExtension {1} A B] : (⊥ : Subalgebra A B) = ⊤ :=\n  Algebra.eq_top_iff.2 fun x => by\n    simpa [adjoin_singleton_one] using ((isCyclotomicExtension_iff _ _ _).1 h).2 x\n\n"}
{"name":"IsCyclotomicExtension.singleton_zero_of_bot_eq_top","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : Eq Bot.bot Top.top\n⊢ IsCyclotomicExtension EmptyCollection.emptyCollection A B","decl":"/-- If `(⊥ : SubAlgebra A B) = ⊤`, then `IsCyclotomicExtension ∅ A B`. -/\ntheorem singleton_zero_of_bot_eq_top (h : (⊥ : Subalgebra A B) = ⊤) :\n    IsCyclotomicExtension ∅ A B := by\n-- Porting note: Lean3 is able to infer `A`.\n  refine (iff_adjoin_eq_top _ A _).2\n    ⟨fun s hs => by simp at hs, _root_.eq_top_iff.2 fun x hx => ?_⟩\n  rw [← h] at hx\n  simpa using hx\n\n"}
{"name":"IsCyclotomicExtension.trans","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S T : Set PNat\nA : Type u\nB : Type v\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra A B\nC : Type w\ninst✝³ : CommRing C\ninst✝² : Algebra A C\ninst✝¹ : Algebra B C\ninst✝ : IsScalarTower A B C\nhS : IsCyclotomicExtension S A B\nhT : IsCyclotomicExtension T B C\nh : Function.Injective ⇑(algebraMap B C)\n⊢ IsCyclotomicExtension (Union.union S T) A C","decl":"/-- Transitivity of cyclotomic extensions. -/\ntheorem trans (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C]\n    [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C]\n    (h : Function.Injective (algebraMap B C)) : IsCyclotomicExtension (S ∪ T) A C := by\n  refine ⟨fun hn => ?_, fun x => ?_⟩\n  · cases' hn with hn hn\n    · obtain ⟨b, hb⟩ := ((isCyclotomicExtension_iff _ _ _).1 hS).1 hn\n      refine ⟨algebraMap B C b, ?_⟩\n      exact hb.map_of_injective h\n    · exact ((isCyclotomicExtension_iff _ _ _).1 hT).1 hn\n  · refine adjoin_induction (hx := ((isCyclotomicExtension_iff T B _).1 hT).2 x)\n      (fun c ⟨n, hn⟩ => subset_adjoin ⟨n, Or.inr hn.1, hn.2⟩) (fun b => ?_)\n      (fun x y _ _ hx hy => Subalgebra.add_mem _ hx hy)\n      fun x y _ _ hx hy => Subalgebra.mul_mem _ hx hy\n    let f := IsScalarTower.toAlgHom A B C\n    have hb : f b ∈ (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}).map f :=\n      ⟨b, ((isCyclotomicExtension_iff _ _ _).1 hS).2 b, rfl⟩\n    rw [IsScalarTower.toAlgHom_apply, ← adjoin_image] at hb\n    refine adjoin_mono (fun y hy => ?_) hb\n    obtain ⟨b₁, ⟨⟨n, hn⟩, h₁⟩⟩ := hy\n    exact ⟨n, ⟨mem_union_left T hn.1, by rw [← h₁, ← map_pow, hn.2, map_one]⟩⟩\n\n"}
{"name":"IsCyclotomicExtension.subsingleton_iff","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Subsingleton B\n⊢ Iff (IsCyclotomicExtension S A B) (Or (Eq S EmptyCollection.emptyCollection) (Eq S (Singleton.singleton 1)))","decl":"@[nontriviality]\ntheorem subsingleton_iff [Subsingleton B] : IsCyclotomicExtension S A B ↔ S = { } ∨ S = {1} := by\n  have : Subsingleton (Subalgebra A B) := inferInstance\n  constructor\n  · rintro ⟨hprim, -⟩\n    rw [← subset_singleton_iff_eq]\n    intro t ht\n    obtain ⟨ζ, hζ⟩ := hprim ht\n    rw [mem_singleton_iff, ← PNat.coe_eq_one_iff]\n    exact mod_cast hζ.unique (IsPrimitiveRoot.of_subsingleton ζ)\n  · rintro (rfl | rfl)\n-- Porting note: `R := A` was not needed.\n    · exact ⟨fun h => h.elim, fun x => by convert (mem_top (R := A) : x ∈ ⊤)⟩\n    · rw [iff_singleton]\n      exact ⟨⟨0, IsPrimitiveRoot.of_subsingleton 0⟩,\n        fun x => by convert (mem_top (R := A) : x ∈ ⊤)⟩\n\n"}
{"name":"IsCyclotomicExtension.union_right","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S T : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : IsCyclotomicExtension (Union.union S T) A B\n⊢ IsCyclotomicExtension T (Subtype fun x => Membership.mem (Algebra.adjoin A (setOf fun b => Exists fun a => And (Membership.mem S a) (Eq (HPow.hPow b ↑a) 1))) x) B","decl":"/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `S ∪ T`, then `B`\nis a cyclotomic extension of `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 }` given by\nroots of unity of order in `T`. -/\ntheorem union_right [h : IsCyclotomicExtension (S ∪ T) A B] :\n    IsCyclotomicExtension T (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}) B := by\n  have : {b : B | ∃ n : ℕ+, n ∈ S ∪ T ∧ b ^ (n : ℕ) = 1} =\n      {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1} ∪\n        {b : B | ∃ n : ℕ+, n ∈ T ∧ b ^ (n : ℕ) = 1} := by\n    refine le_antisymm ?_ ?_\n    · rintro x ⟨n, hn₁ | hn₂, hnpow⟩\n      · left; exact ⟨n, hn₁, hnpow⟩\n      · right; exact ⟨n, hn₂, hnpow⟩\n    · rintro x (⟨n, hn⟩ | ⟨n, hn⟩)\n      · exact ⟨n, Or.inl hn.1, hn.2⟩\n      · exact ⟨n, Or.inr hn.1, hn.2⟩\n  refine ⟨fun hn => ((isCyclotomicExtension_iff _ A _).1 h).1 (mem_union_right S hn), fun b => ?_⟩\n  replace h := ((isCyclotomicExtension_iff _ _ _).1 h).2 b\n  rwa [this, adjoin_union_eq_adjoin_adjoin, Subalgebra.mem_restrictScalars] at h\n\n"}
{"name":"IsCyclotomicExtension.union_left","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S T : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : IsCyclotomicExtension T A B\nhS : HasSubset.Subset S T\n⊢ IsCyclotomicExtension S A (Subtype fun x => Membership.mem (Algebra.adjoin A (setOf fun b => Exists fun a => And (Membership.mem S a) (Eq (HPow.hPow b ↑a) 1))) x)","decl":"/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `T` and `S ⊆ T`,\nthen `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 }` is a cyclotomic extension of `B`\ngiven by roots of unity of order in `S`. -/\ntheorem union_left [h : IsCyclotomicExtension T A B] (hS : S ⊆ T) :\n    IsCyclotomicExtension S A (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}) := by\n  refine ⟨@fun n hn => ?_, fun b => ?_⟩\n  · obtain ⟨b, hb⟩ := ((isCyclotomicExtension_iff _ _ _).1 h).1 (hS hn)\n    refine ⟨⟨b, subset_adjoin ⟨n, hn, hb.pow_eq_one⟩⟩, ?_⟩\n    rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]\n  · convert mem_top (R := A) (x := b)\n    rw [← adjoin_adjoin_coe_preimage, preimage_setOf_eq]\n    norm_cast\n\n"}
{"name":"IsCyclotomicExtension.of_union_of_dvd","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nS : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : ∀ (s : PNat), Membership.mem S s → Dvd.dvd n s\nhS : S.Nonempty\nH : IsCyclotomicExtension S A B\n⊢ IsCyclotomicExtension (Union.union S (Singleton.singleton n)) A B","decl":"/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `IsCyclotomicExtension S A B` implies\n`IsCyclotomicExtension (S ∪ {n}) A B`. -/\ntheorem of_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) [H : IsCyclotomicExtension S A B] :\n    IsCyclotomicExtension (S ∪ {n}) A B := by\n  refine (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => ?_, ?_⟩\n  · rw [mem_union, mem_singleton_iff] at hs\n    obtain hs | rfl := hs\n    · exact H.exists_prim_root hs\n    · obtain ⟨m, hm⟩ := hS\n      obtain ⟨x, rfl⟩ := h m hm\n      obtain ⟨ζ, hζ⟩ := H.exists_prim_root hm\n      refine ⟨ζ ^ (x : ℕ), ?_⟩\n      convert hζ.pow_of_dvd x.ne_zero (dvd_mul_left (x : ℕ) s)\n      simp only [PNat.mul_coe, Nat.mul_div_left, PNat.pos]\n  · refine _root_.eq_top_iff.2 ?_\n    rw [← ((iff_adjoin_eq_top S A B).1 H).2]\n    refine adjoin_mono fun x hx => ?_\n    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ⊢\n    obtain ⟨m, hm⟩ := hx\n    exact ⟨m, ⟨Or.inr hm.1, hm.2⟩⟩\n\n"}
{"name":"IsCyclotomicExtension.iff_union_of_dvd","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nS : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : ∀ (s : PNat), Membership.mem S s → Dvd.dvd n s\nhS : S.Nonempty\n⊢ Iff (IsCyclotomicExtension S A B) (IsCyclotomicExtension (Union.union S (Singleton.singleton n)) A B)","decl":"/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `IsCyclotomicExtension S A B` if and only if\n`IsCyclotomicExtension (S ∪ {n}) A B`. -/\ntheorem iff_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) :\n    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {n}) A B := by\n  refine\n    ⟨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => ?_, ?_⟩⟩\n  · exact H.exists_prim_root (subset_union_left hs)\n  · rw [_root_.eq_top_iff, ← ((iff_adjoin_eq_top _ A B).1 H).2]\n    refine adjoin_mono fun x hx => ?_\n    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ⊢\n    obtain ⟨m, rfl | hm, hxpow⟩ := hx\n    · obtain ⟨y, hy⟩ := hS\n      refine ⟨y, ⟨hy, ?_⟩⟩\n      obtain ⟨z, rfl⟩ := h y hy\n      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]\n    · exact ⟨m, ⟨hm, hxpow⟩⟩\n\n"}
{"name":"IsCyclotomicExtension.iff_union_singleton_one","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\n⊢ Iff (IsCyclotomicExtension S A B) (IsCyclotomicExtension (Union.union S (Singleton.singleton 1)) A B)","decl":"/-- `IsCyclotomicExtension S A B` is equivalent to `IsCyclotomicExtension (S ∪ {1}) A B`. -/\ntheorem iff_union_singleton_one :\n    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {1}) A B := by\n  obtain hS | rfl := S.eq_empty_or_nonempty.symm\n  · exact iff_union_of_dvd _ _ (fun s _ => one_dvd _) hS\n  rw [empty_union]\n  refine ⟨fun H => ?_, fun H => ?_⟩\n  · refine (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => ⟨1, by simp [mem_singleton_iff.1 hs]⟩, ?_⟩\n    simp [adjoin_singleton_one, empty]\n  · refine (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => (not_mem_empty s hs).elim, ?_⟩\n    simp [@singleton_one A B _ _ _ H]\n\n"}
{"name":"IsCyclotomicExtension.singleton_one_of_bot_eq_top","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : Eq Bot.bot Top.top\n⊢ IsCyclotomicExtension (Singleton.singleton 1) A B","decl":"/-- If `(⊥ : SubAlgebra A B) = ⊤`, then `IsCyclotomicExtension {1} A B`. -/\ntheorem singleton_one_of_bot_eq_top (h : (⊥ : Subalgebra A B) = ⊤) :\n    IsCyclotomicExtension {1} A B := by\n  convert (iff_union_singleton_one _ A _).1 (singleton_zero_of_bot_eq_top h)\n  simp\n\n"}
{"name":"IsCyclotomicExtension.singleton_one_of_algebraMap_bijective","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ IsCyclotomicExtension (Singleton.singleton 1) A B","decl":"/-- If `Function.Surjective (algebraMap A B)`, then `IsCyclotomicExtension {1} A B`. -/\ntheorem singleton_one_of_algebraMap_bijective (h : Function.Surjective (algebraMap A B)) :\n    IsCyclotomicExtension {1} A B :=\n  singleton_one_of_bot_eq_top (surjective_algebraMap_iff.1 h).symm\n\n"}
{"name":"IsCyclotomicExtension.equiv","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\nC : Type u_1\ninst✝¹ : CommRing C\ninst✝ : Algebra A C\nh : IsCyclotomicExtension S A B\nf : AlgEquiv A B C\n⊢ IsCyclotomicExtension S A C","decl":"/-- Given `(f : B ≃ₐ[A] C)`, if `IsCyclotomicExtension S A B` then\n`IsCyclotomicExtension S A C`. -/\nprotected\ntheorem equiv {C : Type*} [CommRing C] [Algebra A C] [h : IsCyclotomicExtension S A B]\n    (f : B ≃ₐ[A] C) : IsCyclotomicExtension S A C := by\n  letI : Algebra B C := f.toAlgHom.toRingHom.toAlgebra\n  haveI : IsCyclotomicExtension {1} B C := singleton_one_of_algebraMap_bijective f.surjective\n  haveI : IsScalarTower A B C := IsScalarTower.of_algHom f.toAlgHom\n  exact (iff_union_singleton_one _ _ _).2 (trans S {1} A B C f.injective)\n\n"}
{"name":"IsCyclotomicExtension.neZero","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\nh : IsCyclotomicExtension (Singleton.singleton n) A B\ninst✝ : IsDomain B\n⊢ NeZero ↑↑n","decl":"protected\ntheorem neZero [h : IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : B) := by\n  obtain ⟨⟨r, hr⟩, -⟩ := (iff_singleton n A B).1 h\n  exact hr.neZero'\n\n"}
{"name":"IsCyclotomicExtension.neZero'","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nB : Type v\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : IsCyclotomicExtension (Singleton.singleton n) A B\ninst✝ : IsDomain B\n⊢ NeZero ↑↑n","decl":"protected\ntheorem neZero' [IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : A) := by\n  haveI := IsCyclotomicExtension.neZero n A B\n  exact NeZero.nat_of_neZero (algebraMap A B)\n\n"}
{"name":"IsCyclotomicExtension.finite_of_singleton","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsDomain B\nh : IsCyclotomicExtension (Singleton.singleton n) A B\n⊢ Module.Finite A B","decl":"theorem finite_of_singleton [IsDomain B] [h : IsCyclotomicExtension {n} A B] :\n    Module.Finite A B := by\n  classical\n  rw [Module.finite_def, ← top_toSubmodule, ← ((iff_adjoin_eq_top _ _ _).1 h).2]\n  refine fg_adjoin_of_finite ?_ fun b hb => ?_\n  · simp only [mem_singleton_iff, exists_eq_left]\n    have : {b : B | b ^ (n : ℕ) = 1} = (nthRoots n (1 : B)).toFinset :=\n      Set.ext fun x => ⟨fun h => by simpa using h, fun h => by simpa using h⟩\n    rw [this]\n    exact (nthRoots (↑n) 1).toFinset.finite_toSet\n  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hb\n    exact ⟨X ^ (n : ℕ) - 1, ⟨monic_X_pow_sub_C _ n.pos.ne.symm, by simp [hb]⟩⟩\n\n"}
{"name":"IsCyclotomicExtension.finite","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsDomain B\nh₁ : Finite ↑S\nh₂ : IsCyclotomicExtension S A B\n⊢ Module.Finite A B","decl":"/-- If `S` is finite and `IsCyclotomicExtension S A B`, then `B` is a finite `A`-algebra. -/\nprotected theorem finite [IsDomain B] [h₁ : Finite S] [h₂ : IsCyclotomicExtension S A B] :\n    Module.Finite A B := by\n  cases' nonempty_fintype S with h\n  revert h₂ A B\n  refine Set.Finite.induction_on _ h₁ (fun A B => ?_) @fun n S _ _ H A B => ?_\n  · intro _ _ _ _ _\n    refine Module.finite_def.2 ⟨({1} : Finset B), ?_⟩\n    simp [← top_toSubmodule, ← empty, toSubmodule_bot, Submodule.one_eq_span]\n  · intro _ _ _ _ h\n    haveI : IsCyclotomicExtension S A (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) :=\n      union_left _ (insert n S) _ _ (subset_insert n S)\n    haveI := H A (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1})\n    have : Module.Finite (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) B := by\n      rw [← union_singleton] at h\n      letI := @union_right S {n} A B _ _ _ h\n      exact finite_of_singleton n _ _\n    exact Module.Finite.trans (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) _\n\n"}
{"name":"IsCyclotomicExtension.numberField","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nK : Type w\nL : Type z\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nh : NumberField K\ninst✝¹ : Finite ↑S\ninst✝ : IsCyclotomicExtension S K L\n⊢ NumberField L","decl":"/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem numberField [h : NumberField K] [Finite S] [IsCyclotomicExtension S K L] : NumberField L :=\n  { to_charZero := charZero_of_injective_algebraMap (algebraMap K L).injective\n    to_finiteDimensional := by\n      haveI := charZero_of_injective_algebraMap (algebraMap K L).injective\n      haveI := IsCyclotomicExtension.finite S K L\n      exact Module.Finite.trans K _ }\n\n"}
{"name":"IsCyclotomicExtension.integral","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nA : Type u\nB : Type v\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra A B\ninst✝³ : IsDomain B\ninst✝² : IsNoetherianRing A\ninst✝¹ : Finite ↑S\ninst✝ : IsCyclotomicExtension S A B\n⊢ Algebra.IsIntegral A B","decl":"/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem integral [IsDomain B] [IsNoetherianRing A] [Finite S] [IsCyclotomicExtension S A B] :\n    Algebra.IsIntegral A B :=\n  have := IsCyclotomicExtension.finite S A B\n  ⟨isIntegral_of_noetherian inferInstance⟩\n\n"}
{"name":"IsCyclotomicExtension.finiteDimensional","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nK : Type w\ninst✝⁵ : Field K\nC : Type z\ninst✝⁴ : Finite ↑S\ninst✝³ : CommRing C\ninst✝² : Algebra K C\ninst✝¹ : IsDomain C\ninst✝ : IsCyclotomicExtension S K C\n⊢ FiniteDimensional K C","decl":"/-- If `S` is finite and `IsCyclotomicExtension S K A`, then `finiteDimensional K A`. -/\ntheorem finiteDimensional (C : Type z) [Finite S] [CommRing C] [Algebra K C] [IsDomain C]\n    [IsCyclotomicExtension S K C] : FiniteDimensional K C :=\n  IsCyclotomicExtension.finite S K C\n\n"}
{"name":"IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsDomain B\nζ : B\nn : PNat\nhζ : IsPrimitiveRoot ζ ↑n\n⊢ Eq (Algebra.adjoin A ((Polynomial.cyclotomic (↑n) A).rootSet B)) (Algebra.adjoin A (setOf fun b => Exists fun a => And (Membership.mem (Singleton.singleton n) a) (Eq (HPow.hPow b ↑a) 1)))","decl":"theorem adjoin_roots_cyclotomic_eq_adjoin_nth_roots [IsDomain B] {ζ : B} {n : ℕ+}\n    (hζ : IsPrimitiveRoot ζ n) :\n    adjoin A ((cyclotomic n A).rootSet B) =\n      adjoin A {b : B | ∃ a : ℕ+, a ∈ ({n} : Set ℕ+) ∧ b ^ (a : ℕ) = 1} := by\n  simp only [mem_singleton_iff, exists_eq_left, map_cyclotomic]\n  refine le_antisymm (adjoin_mono fun x hx => ?_) (adjoin_le fun x hx => ?_)\n  · rw [mem_rootSet'] at hx\n    simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]\n    rw [isRoot_of_unity_iff n.pos]\n    refine ⟨n, Nat.mem_divisors_self n n.ne_zero, ?_⟩\n    rw [IsRoot.def, ← map_cyclotomic n (algebraMap A B), eval_map, ← aeval_def]\n    exact hx.2\n  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx\n    obtain ⟨i, _, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx\n    refine SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin ?_) _)\n    rw [mem_rootSet', map_cyclotomic, aeval_def, ← eval_map, map_cyclotomic, ← IsRoot]\n    exact ⟨cyclotomic_ne_zero n B, hζ.isRoot_cyclotomic n.pos⟩\n\n"}
{"name":"IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\nn : PNat\ninst✝ : IsDomain B\nζ : B\nhζ : IsPrimitiveRoot ζ ↑n\n⊢ Eq (Algebra.adjoin A ((Polynomial.cyclotomic (↑n) A).rootSet B)) (Algebra.adjoin A (Singleton.singleton ζ))","decl":"theorem adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic {n : ℕ+} [IsDomain B] {ζ : B}\n    (hζ : IsPrimitiveRoot ζ n) : adjoin A ((cyclotomic n A).rootSet B) = adjoin A {ζ} := by\n  refine le_antisymm (adjoin_le fun x hx => ?_) (adjoin_mono fun x hx => ?_)\n  · suffices hx : x ^ n.1 = 1 by\n      obtain ⟨i, _, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx\n      exact SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin <| mem_singleton ζ) _)\n    refine (isRoot_of_unity_iff n.pos B).2 ?_\n    refine ⟨n, Nat.mem_divisors_self n n.ne_zero, ?_⟩\n    rw [mem_rootSet', aeval_def, ← eval_map, map_cyclotomic, ← IsRoot] at hx\n    exact hx.2\n  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx\n    simpa only [hx, mem_rootSet', map_cyclotomic, aeval_def, ← eval_map, IsRoot] using\n      And.intro (cyclotomic_ne_zero n B) (hζ.isRoot_cyclotomic n.pos)\n\n"}
{"name":"IsCyclotomicExtension.adjoin_primitive_root_eq_top","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\nn : PNat\ninst✝ : IsDomain B\nh : IsCyclotomicExtension (Singleton.singleton n) A B\nζ : B\nhζ : IsPrimitiveRoot ζ ↑n\n⊢ Eq (Algebra.adjoin A (Singleton.singleton ζ)) Top.top","decl":"theorem adjoin_primitive_root_eq_top {n : ℕ+} [IsDomain B] [h : IsCyclotomicExtension {n} A B]\n    {ζ : B} (hζ : IsPrimitiveRoot ζ n) : adjoin A ({ζ} : Set B) = ⊤ := by\n  classical\n  rw [← adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic hζ]\n  rw [adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ]\n  exact ((iff_adjoin_eq_top {n} A B).mp h).2\n\n"}
{"name":"IsPrimitiveRoot.adjoin_isCyclotomicExtension","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"A : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nζ : B\nn : PNat\nh : IsPrimitiveRoot ζ ↑n\n⊢ IsCyclotomicExtension (Singleton.singleton n) A (Subtype fun x => Membership.mem (Algebra.adjoin A (Singleton.singleton ζ)) x)","decl":"theorem _root_.IsPrimitiveRoot.adjoin_isCyclotomicExtension {ζ : B} {n : ℕ+}\n    (h : IsPrimitiveRoot ζ n) : IsCyclotomicExtension {n} A (adjoin A ({ζ} : Set B)) :=\n  { exists_prim_root := fun hi => by\n      rw [Set.mem_singleton_iff] at hi\n      refine ⟨⟨ζ, subset_adjoin <| Set.mem_singleton ζ⟩, ?_⟩\n      rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk, hi]\n    adjoin_roots := fun ⟨x, hx⟩ => by\n      refine\n        adjoin_induction\n          (hx := hx) (fun b hb => ?_) (fun a => ?_) (fun b₁ b₂ _ _ hb₁ hb₂ => ?_)\n          (fun b₁ b₂ _ _ hb₁ hb₂ => ?_)\n      · rw [Set.mem_singleton_iff] at hb\n        refine subset_adjoin ?_\n        simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq, hb]\n        rw [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]\n        exact ((IsPrimitiveRoot.iff_def ζ n).1 h).1\n      · exact Subalgebra.algebraMap_mem _ _\n      · exact Subalgebra.add_mem _ hb₁ hb₂\n      · exact Subalgebra.mul_mem _ hb₁ hb₂ }\n\n"}
{"name":"IsCyclotomicExtension.splits_X_pow_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nS : Set PNat\nK : Type w\nL : Type z\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nH : IsCyclotomicExtension S K L\nhS : Membership.mem S n\n⊢ Polynomial.Splits (algebraMap K L) (HSub.hSub (HPow.hPow Polynomial.X ↑n) 1)","decl":"/-- A cyclotomic extension splits `X ^ n - 1` if `n ∈ S`. -/\ntheorem splits_X_pow_sub_one [H : IsCyclotomicExtension S K L] (hS : n ∈ S) :\n    Splits (algebraMap K L) (X ^ (n : ℕ) - 1) := by\n  rw [← splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,\n    Polynomial.map_X]\n  obtain ⟨z, hz⟩ := ((isCyclotomicExtension_iff _ _ _).1 H).1 hS\n  exact X_pow_sub_one_splits hz\n\n"}
{"name":"IsCyclotomicExtension.splits_cyclotomic","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nS : Set PNat\nK : Type w\nL : Type z\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension S K L\nhS : Membership.mem S n\n⊢ Polynomial.Splits (algebraMap K L) (Polynomial.cyclotomic (↑n) K)","decl":"/-- A cyclotomic extension splits `cyclotomic n K` if `n ∈ S`. -/\ntheorem splits_cyclotomic [IsCyclotomicExtension S K L] (hS : n ∈ S) :\n    Splits (algebraMap K L) (cyclotomic n K) := by\n  refine splits_of_splits_of_dvd _ (X_pow_sub_C_ne_zero n.pos _) (splits_X_pow_sub_one K L hS) ?_\n  use ∏ i ∈ (n : ℕ).properDivisors, Polynomial.cyclotomic i K\n  rw [(eq_cyclotomic_iff n.pos _).1 rfl, RingHom.map_one]\n\n"}
{"name":"IsCyclotomicExtension.isSplittingField_X_pow_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\nL : Type z\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\n⊢ Polynomial.IsSplittingField K L (HSub.hSub (HPow.hPow Polynomial.X ↑n) 1)","decl":"/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `X ^ n - 1`. -/\ntheorem isSplittingField_X_pow_sub_one : IsSplittingField K L (X ^ (n : ℕ) - 1) :=\n  { splits' := splits_X_pow_sub_one K L (mem_singleton n)\n    adjoin_rootSet' := by\n      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]\n      congr\n      refine Set.ext fun x => ?_\n      simp only [Polynomial.map_pow, mem_singleton_iff, Multiset.mem_toFinset, exists_eq_left,\n        mem_setOf_eq, Polynomial.map_X, Polynomial.map_one, Finset.mem_coe, Polynomial.map_sub]\n      simp only [mem_rootSet', map_sub, map_pow, aeval_one, aeval_X, sub_eq_zero, map_X,\n        and_iff_right_iff_imp, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one]\n      exact fun _ => X_pow_sub_C_ne_zero n.pos (1 : L) }\n\n"}
{"name":"IsCyclotomicExtension.isGalois","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\nL : Type z\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\n⊢ IsGalois K L","decl":"include n in\ntheorem isGalois : IsGalois K L :=\n  letI := isSplittingField_X_pow_sub_one n K L\n  IsGalois.of_separable_splitting_field (X_pow_sub_one_separable_iff.2\n    (IsCyclotomicExtension.neZero' n K L).1)\n\n"}
{"name":"IsCyclotomicExtension.splitting_field_cyclotomic","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\nL : Type z\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton n) K L\n⊢ Polynomial.IsSplittingField K L (Polynomial.cyclotomic (↑n) K)","decl":"/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `cyclotomic n K`. -/\ntheorem splitting_field_cyclotomic : IsSplittingField K L (cyclotomic n K) :=\n  { splits' := splits_cyclotomic K L (mem_singleton n)\n    adjoin_rootSet' := by\n      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]\n      letI := Classical.decEq L\n      -- todo: make `exists_prim_root` take an explicit `L`\n      obtain ⟨ζ : L, hζ⟩ := IsCyclotomicExtension.exists_prim_root K (B := L) (mem_singleton n)\n      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ }\n\n"}
{"name":"CyclotomicField.instCharZero","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\ninst✝¹ : Field K\ninst✝ : CharZero K\n⊢ CharZero (CyclotomicField n K)","decl":"instance [CharZero K] : CharZero (CyclotomicField n K) :=\n  charZero_of_injective_algebraMap (algebraMap K _).injective\n\n"}
{"name":"CyclotomicField.isCyclotomicExtension","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\ninst✝¹ : Field K\ninst✝ : NeZero ↑↑n\n⊢ IsCyclotomicExtension (Singleton.singleton n) K (CyclotomicField n K)","decl":"instance isCyclotomicExtension [NeZero ((n : ℕ) : K)] :\n    IsCyclotomicExtension {n} K (CyclotomicField n K) := by\n  haveI : NeZero ((n : ℕ) : CyclotomicField n K) :=\n    NeZero.nat_of_injective (algebraMap K _).injective\n  letI := Classical.decEq (CyclotomicField n K)\n  obtain ⟨ζ, hζ⟩ :=\n    exists_root_of_splits (algebraMap K (CyclotomicField n K)) (SplittingField.splits _)\n      (degree_cyclotomic_pos n K n.pos).ne'\n  rw [← eval_map, ← IsRoot.def, map_cyclotomic, isRoot_cyclotomic_iff] at hζ\n-- Porting note: the first `?_` was `forall_eq.2 ⟨ζ, hζ⟩` that now fails.\n  refine ⟨?_, ?_⟩\n  · simp only [mem_singleton_iff, forall_eq]\n    exact ⟨ζ, hζ⟩\n  · rw [← Algebra.eq_top_iff, ← SplittingField.adjoin_rootSet, eq_comm]\n    exact IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ\n\n"}
{"name":"instIsScalarTowerCyclotomicField","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nK : Type w\ninst✝² : Field K\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Algebra R K\n⊢ IsScalarTower R K (CyclotomicField n K)","decl":"instance {R : Type*} [CommRing R] [Algebra R K] : IsScalarTower R K (CyclotomicField n K) :=\n  SplittingField.isScalarTower _\n\n"}
{"name":"CyclotomicField.noZeroSMulDivisors","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ NoZeroSMulDivisors A (CyclotomicField n K)","decl":"instance CyclotomicField.noZeroSMulDivisors [IsFractionRing A K] :\n    NoZeroSMulDivisors A (CyclotomicField n K) := by\n  refine NoZeroSMulDivisors.of_algebraMap_injective ?_\n  rw [IsScalarTower.algebraMap_eq A K (CyclotomicField n K)]\n  exact\n    (Function.Injective.comp (NoZeroSMulDivisors.algebraMap_injective K (CyclotomicField n K))\n      (IsFractionRing.injective A K) :)\n\n"}
{"name":"CyclotomicRing.instIsDomain","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝² : CommRing A\ninst✝¹ : Field K\ninst✝ : Algebra A K\n⊢ IsDomain (CyclotomicRing n A K)","decl":"instance : IsDomain (CyclotomicRing n A K) := by\n  delta CyclotomicRing; infer_instance\n\n-- Porting note: could not be derived\n"}
{"name":"CyclotomicRing.instNoZeroSMulDivisorsOfIsFractionRing","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ NoZeroSMulDivisors A (CyclotomicRing n A K)","decl":"instance [IsFractionRing A K] :\n    NoZeroSMulDivisors A (CyclotomicRing n A K) :=\n  (adjoin A _).noZeroSMulDivisors_bot\n\n"}
{"name":"CyclotomicRing.algebraBase_injective","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Function.Injective ⇑(algebraMap A (CyclotomicRing n A K))","decl":"theorem algebraBase_injective [IsFractionRing A K] :\n    Function.Injective <| algebraMap A (CyclotomicRing n A K) :=\n  NoZeroSMulDivisors.algebraMap_injective _ _\n\n"}
{"name":"CyclotomicRing.adjoin_algebra_injective","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝² : CommRing A\ninst✝¹ : Field K\ninst✝ : Algebra A K\n⊢ Function.Injective ⇑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K))","decl":"theorem adjoin_algebra_injective :\n    Function.Injective <| algebraMap (CyclotomicRing n A K) (CyclotomicField n K) :=\n  Subtype.val_injective\n\n"}
{"name":"CyclotomicRing.instNoZeroSMulDivisorsCyclotomicField","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝² : CommRing A\ninst✝¹ : Field K\ninst✝ : Algebra A K\n⊢ NoZeroSMulDivisors (CyclotomicRing n A K) (CyclotomicField n K)","decl":"instance : NoZeroSMulDivisors (CyclotomicRing n A K) (CyclotomicField n K) :=\n  NoZeroSMulDivisors.of_algebraMap_injective (adjoin_algebra_injective n A K)\n\n"}
{"name":"CyclotomicRing.instIsScalarTowerCyclotomicField","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝² : CommRing A\ninst✝¹ : Field K\ninst✝ : Algebra A K\n⊢ IsScalarTower A (CyclotomicRing n A K) (CyclotomicField n K)","decl":"instance : IsScalarTower A (CyclotomicRing n A K) (CyclotomicField n K) :=\n  IsScalarTower.subalgebra' _ _ _ _\n\n"}
{"name":"CyclotomicRing.isCyclotomicExtension","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : NeZero ↑↑n\n⊢ IsCyclotomicExtension (Singleton.singleton n) A (CyclotomicRing n A K)","decl":"instance isCyclotomicExtension [IsFractionRing A K] [NeZero ((n : ℕ) : A)] :\n    IsCyclotomicExtension {n} A (CyclotomicRing n A K) where\n  exists_prim_root := @fun a han => by\n    rw [mem_singleton_iff] at han\n    subst a\n    haveI := NeZero.of_noZeroSMulDivisors A K n\n    haveI := NeZero.of_noZeroSMulDivisors A (CyclotomicField n K) n\n    obtain ⟨μ, hμ⟩ := (CyclotomicField.isCyclotomicExtension n K).exists_prim_root (mem_singleton n)\n    refine ⟨⟨μ, subset_adjoin ?_⟩, ?_⟩\n    · apply (isRoot_of_unity_iff n.pos (CyclotomicField n K)).mpr\n      refine ⟨n, Nat.mem_divisors_self _ n.ne_zero, ?_⟩\n      rwa [← isRoot_cyclotomic_iff] at hμ\n    · rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]\n  adjoin_roots x := by\n    obtain ⟨x, hx⟩ := x\n    refine\n      adjoin_induction (fun y hy => ?_) (fun a => ?_) (fun y z _ _ hy hz => ?_)\n        (fun y z  _ _ hy hz => ?_) hx\n    · refine subset_adjoin ?_\n      simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]\n      rwa [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]\n    · exact Subalgebra.algebraMap_mem _ a\n    · exact Subalgebra.add_mem _ hy hz\n    · exact Subalgebra.mul_mem _ hy hz\n\n"}
{"name":"CyclotomicRing.instIsFractionRingCyclotomicFieldOfIsDomainOfNeZeroCastVal","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝⁵ : CommRing A\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsFractionRing A K\ninst✝¹ : IsDomain A\ninst✝ : NeZero ↑↑n\n⊢ IsFractionRing (CyclotomicRing n A K) (CyclotomicField n K)","decl":"instance [IsFractionRing A K] [IsDomain A] [NeZero ((n : ℕ) : A)] :\n    IsFractionRing (CyclotomicRing n A K) (CyclotomicField n K) where\n  map_units' := fun ⟨x, hx⟩ => by\n    rw [isUnit_iff_ne_zero]\n    apply map_ne_zero_of_mem_nonZeroDivisors\n    · apply adjoin_algebra_injective\n    · exact hx\n  surj' x := by\n    letI : NeZero ((n : ℕ) : K) := NeZero.nat_of_injective (IsFractionRing.injective A K)\n    refine\n      Algebra.adjoin_induction\n        (hx := ((IsCyclotomicExtension.iff_singleton n K (CyclotomicField n K)).1\n            (CyclotomicField.isCyclotomicExtension n K)).2 x)\n        (fun y hy => ?_) (fun k => ?_) ?_ ?_\n-- Porting note: the last goal was `by simpa` that now fails.\n    · exact ⟨⟨⟨y, subset_adjoin hy⟩, 1⟩, by simp; rfl⟩\n    · have : IsLocalization (nonZeroDivisors A) K := inferInstance\n      replace := this.surj\n      obtain ⟨⟨z, w⟩, hw⟩ := this k\n      refine ⟨⟨algebraMap A (CyclotomicRing n A K) z, algebraMap A (CyclotomicRing n A K) w,\n        map_mem_nonZeroDivisors _ (algebraBase_injective n A K) w.2⟩, ?_⟩\n      letI : IsScalarTower A K (CyclotomicField n K) :=\n        IsScalarTower.of_algebraMap_eq (congr_fun rfl)\n      rw [← IsScalarTower.algebraMap_apply, ← IsScalarTower.algebraMap_apply,\n        @IsScalarTower.algebraMap_apply A K _ _ _ _ _ (_root_.CyclotomicField.algebra n K) _ _ w,\n        ← RingHom.map_mul, hw, ← IsScalarTower.algebraMap_apply]\n    · rintro y z - - ⟨a, ha⟩ ⟨b, hb⟩\n      refine ⟨⟨a.1 * b.2 + b.1 * a.2, a.2 * b.2, mul_mem_nonZeroDivisors.2 ⟨a.2.2, b.2.2⟩⟩, ?_⟩\n      rw [RingHom.map_mul, add_mul, ← mul_assoc, ha,\n        mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), ← mul_assoc, hb]\n      simp only [map_add, map_mul]\n    · rintro y z - - ⟨a, ha⟩ ⟨b, hb⟩\n      refine ⟨⟨a.1 * b.1, a.2 * b.2, mul_mem_nonZeroDivisors.2 ⟨a.2.2, b.2.2⟩⟩, ?_⟩\n      rw [RingHom.map_mul, mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), mul_assoc, ←\n        mul_assoc z, hb, ← mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), ← mul_assoc, ha]\n      simp only [map_mul]\n  exists_of_eq {x y} h := ⟨1, by rw [adjoin_algebra_injective n A K h]⟩\n\n"}
{"name":"CyclotomicRing.eq_adjoin_primitive_root","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"n : PNat\nA : Type u\nK : Type w\ninst✝² : CommRing A\ninst✝¹ : Field K\ninst✝ : Algebra A K\nμ : CyclotomicField n K\nh : IsPrimitiveRoot μ ↑n\n⊢ Eq (CyclotomicRing n A K) (Subtype fun x => Membership.mem (Algebra.adjoin A (Singleton.singleton μ)) x)","decl":"theorem eq_adjoin_primitive_root {μ : CyclotomicField n K} (h : IsPrimitiveRoot μ n) :\n    CyclotomicRing n A K = adjoin A ({μ} : Set (CyclotomicField n K)) := by\n  rw [← IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic h,\n    IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots h]\n  simp [CyclotomicRing]\n\n"}
{"name":"IsAlgClosed.isCyclotomicExtension","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"S : Set PNat\nK : Type w\ninst✝¹ : Field K\ninst✝ : IsAlgClosed K\nh : ∀ (a : PNat), Membership.mem S a → NeZero ↑↑a\n⊢ IsCyclotomicExtension S K K","decl":"/-- Algebraically closed fields are `S`-cyclotomic extensions over themselves if\n`NeZero ((a : ℕ) : K))` for all `a ∈ S`. -/\ntheorem IsAlgClosed.isCyclotomicExtension (h : ∀ a ∈ S, NeZero ((a : ℕ) : K)) :\n    IsCyclotomicExtension S K K := by\n  refine ⟨@fun a ha => ?_, Algebra.eq_top_iff.mp <| Subsingleton.elim _ _⟩\n  obtain ⟨r, hr⟩ := IsAlgClosed.exists_aeval_eq_zero K _ (degree_cyclotomic_pos a K a.pos).ne'\n  refine ⟨r, ?_⟩\n  haveI := h a ha\n  rwa [coe_aeval_eq_eval, ← IsRoot.def, isRoot_cyclotomic_iff] at hr\n\n"}
{"name":"IsAlgClosedOfCharZero.isCyclotomicExtension","module":"Mathlib.NumberTheory.Cyclotomic.Basic","initialProofState":"K : Type w\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : CharZero K\nS : Set PNat\n⊢ IsCyclotomicExtension S K K","decl":"instance IsAlgClosedOfCharZero.isCyclotomicExtension [CharZero K] :\n    ∀ S, IsCyclotomicExtension S K K := fun S =>\n  IsAlgClosed.isCyclotomicExtension S K fun _ _ => inferInstance\n\n"}
