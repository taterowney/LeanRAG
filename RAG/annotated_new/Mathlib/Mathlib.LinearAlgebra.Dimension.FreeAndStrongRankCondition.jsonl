{"name":"Basis.ofRankEqZero_apply","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\nι : Type u_1\ninst✝ : IsEmpty ι\nhV : Eq (Module.rank K V) 0\ni : ι\n⊢ Eq ((Basis.ofRankEqZero hV) i) 0","decl":"@[simp]\ntheorem Basis.ofRankEqZero_apply [Module.Free K V] {ι : Type*} [IsEmpty ι]\n    (hV : Module.rank K V = 0) (i : ι) : Basis.ofRankEqZero hV i = 0 := rfl\n\n"}
{"name":"le_rank_iff_exists_linearIndependent","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\nc : Cardinal.{v}\n⊢ Iff (LE.le c (Module.rank K V)) (Exists fun s => And (Eq (Cardinal.mk ↑s) c) (LinearIndependent K Subtype.val))","decl":"theorem le_rank_iff_exists_linearIndependent [Module.Free K V] {c : Cardinal} :\n    c ≤ Module.rank K V ↔ ∃ s : Set V, #s = c ∧ LinearIndependent K ((↑) : s → V) := by\n  haveI := nontrivial_of_invariantBasisNumber K\n  constructor\n  · intro h\n    obtain ⟨κ, t'⟩ := Module.Free.exists_basis (R := K) (M := V)\n    let t := t'.reindexRange\n    have : LinearIndependent K ((↑) : Set.range t' → V) := by\n      convert t.linearIndependent\n      ext; exact (Basis.reindexRange_apply _ _).symm\n    rw [← t.mk_eq_rank'', le_mk_iff_exists_subset] at h\n    rcases h with ⟨s, hst, hsc⟩\n    exact ⟨s, hsc, this.mono hst⟩\n  · rintro ⟨s, rfl, si⟩\n    exact si.cardinal_le_rank\n\n"}
{"name":"le_rank_iff_exists_linearIndependent_finset","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\nn : Nat\n⊢ Iff (LE.le (↑n) (Module.rank K V)) (Exists fun s => And (Eq s.card n) (LinearIndependent K Subtype.val))","decl":"theorem le_rank_iff_exists_linearIndependent_finset\n    [Module.Free K V] {n : ℕ} : ↑n ≤ Module.rank K V ↔\n    ∃ s : Finset V, s.card = n ∧ LinearIndependent K ((↑) : ↥(s : Set V) → V) := by\n  simp only [le_rank_iff_exists_linearIndependent, mk_set_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩\n    exact ⟨t, rfl, si⟩\n  · rintro ⟨s, rfl, si⟩\n    exact ⟨s, ⟨s, rfl, rfl⟩, si⟩\n\n"}
{"name":"rank_le_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\n⊢ Iff (LE.le (Module.rank K V) 1) (Exists fun v₀ => ∀ (v : V), Exists fun r => Eq (HSMul.hSMul r v₀) v)","decl":"/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem rank_le_one_iff [Module.Free K V] :\n    Module.rank K V ≤ 1 ↔ ∃ v₀ : V, ∀ v, ∃ r : K, r • v₀ = v := by\n  obtain ⟨κ, b⟩ := Module.Free.exists_basis (R := K) (M := V)\n  constructor\n  · intro hd\n    rw [← b.mk_eq_rank'', le_one_iff_subsingleton] at hd\n    rcases isEmpty_or_nonempty κ with hb | ⟨⟨i⟩⟩\n    · use 0\n      have h' : ∀ v : V, v = 0 := by\n        simpa [range_eq_empty, Submodule.eq_bot_iff] using b.span_eq.symm\n      intro v\n      simp [h' v]\n    · use b i\n      have h' : (K ∙ b i) = ⊤ :=\n        (subsingleton_range b).eq_singleton_of_mem (mem_range_self i) ▸ b.span_eq\n      intro v\n      have hv : v ∈ (⊤ : Submodule K V) := mem_top\n      rwa [← h', mem_span_singleton] at hv\n  · rintro ⟨v₀, hv₀⟩\n    have h : (K ∙ v₀) = ⊤ := by\n      ext\n      simp [mem_span_singleton, hv₀]\n    rw [← rank_top, ← h]\n    refine (rank_span_le _).trans_eq ?_\n    simp\n\n"}
{"name":"rank_eq_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\n⊢ Iff (Eq (Module.rank K V) 1) (Exists fun v₀ => And (Ne v₀ 0) (∀ (v : V), Exists fun r => Eq (HSMul.hSMul r v₀) v))","decl":"/-- A vector space has dimension `1` if and only if there is a\nsingle non-zero vector of which all vectors are multiples. -/\ntheorem rank_eq_one_iff [Module.Free K V] :\n    Module.rank K V = 1 ↔ ∃ v₀ : V, v₀ ≠ 0 ∧ ∀ v, ∃ r : K, r • v₀ = v := by\n  haveI := nontrivial_of_invariantBasisNumber K\n  refine ⟨fun h ↦ ?_, fun ⟨v₀, h, hv⟩ ↦ (rank_le_one_iff.2 ⟨v₀, hv⟩).antisymm ?_⟩\n  · obtain ⟨v₀, hv⟩ := rank_le_one_iff.1 h.le\n    refine ⟨v₀, fun hzero ↦ ?_, hv⟩\n    simp_rw [hzero, smul_zero, exists_const] at hv\n    haveI : Subsingleton V := .intro fun _ _ ↦ by simp_rw [← hv]\n    exact one_ne_zero (h ▸ rank_subsingleton' K V)\n  · by_contra H\n    rw [not_le, lt_one_iff_zero] at H\n    obtain ⟨κ, b⟩ := Module.Free.exists_basis (R := K) (M := V)\n    haveI := mk_eq_zero_iff.1 (H ▸ b.mk_eq_rank'')\n    haveI := b.repr.toEquiv.subsingleton\n    exact h (Subsingleton.elim _ _)\n\n"}
{"name":"rank_submodule_le_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ns : Submodule K V\ninst✝ : Module.Free K (Subtype fun x => Membership.mem s x)\n⊢ Iff (LE.le (Module.rank K (Subtype fun x => Membership.mem s x)) 1) (Exists fun v₀ => And (Membership.mem s v₀) (LE.le s (Submodule.span K (Singleton.singleton v₀))))","decl":"/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector in the submodule such that the submodule is contained in\nits span. -/\ntheorem rank_submodule_le_one_iff (s : Submodule K V) [Module.Free K s] :\n    Module.rank K s ≤ 1 ↔ ∃ v₀ ∈ s, s ≤ K ∙ v₀ := by\n  simp_rw [rank_le_one_iff, le_span_singleton_iff]\n  constructor\n  · rintro ⟨⟨v₀, hv₀⟩, h⟩\n    use v₀, hv₀\n    intro v hv\n    obtain ⟨r, hr⟩ := h ⟨v, hv⟩\n    use r\n    rwa [Subtype.ext_iff, coe_smul] at hr\n  · rintro ⟨v₀, hv₀, h⟩\n    use ⟨v₀, hv₀⟩\n    rintro ⟨v, hv⟩\n    obtain ⟨r, hr⟩ := h v hv\n    use r\n    rwa [Subtype.ext_iff, coe_smul]\n\n"}
{"name":"rank_submodule_eq_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ns : Submodule K V\ninst✝ : Module.Free K (Subtype fun x => Membership.mem s x)\n⊢ Iff (Eq (Module.rank K (Subtype fun x => Membership.mem s x)) 1) (Exists fun v₀ => And (Membership.mem s v₀) (And (Ne v₀ 0) (LE.le s (Submodule.span K (Singleton.singleton v₀)))))","decl":"/-- A submodule has dimension `1` if and only if there is a\nsingle non-zero vector in the submodule such that the submodule is contained in\nits span. -/\ntheorem rank_submodule_eq_one_iff (s : Submodule K V) [Module.Free K s] :\n    Module.rank K s = 1 ↔ ∃ v₀ ∈ s, v₀ ≠ 0 ∧ s ≤ K ∙ v₀ := by\n  simp_rw [rank_eq_one_iff, le_span_singleton_iff]\n  refine ⟨fun ⟨⟨v₀, hv₀⟩, H, h⟩ ↦ ⟨v₀, hv₀, fun h' ↦ by\n    simp only [h', ne_eq] at H; exact H rfl, fun v hv ↦ ?_⟩,\n    fun ⟨v₀, hv₀, H, h⟩ ↦ ⟨⟨v₀, hv₀⟩,\n      fun h' ↦ H (by rwa [AddSubmonoid.mk_eq_zero] at h'), fun ⟨v, hv⟩ ↦ ?_⟩⟩\n  · obtain ⟨r, hr⟩ := h ⟨v, hv⟩\n    exact ⟨r, by rwa [Subtype.ext_iff, coe_smul] at hr⟩\n  · obtain ⟨r, hr⟩ := h v hv\n    exact ⟨r, by rwa [Subtype.ext_iff, coe_smul]⟩\n\n"}
{"name":"rank_submodule_le_one_iff'","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ns : Submodule K V\ninst✝ : Module.Free K (Subtype fun x => Membership.mem s x)\n⊢ Iff (LE.le (Module.rank K (Subtype fun x => Membership.mem s x)) 1) (Exists fun v₀ => LE.le s (Submodule.span K (Singleton.singleton v₀)))","decl":"/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector, not necessarily in the submodule, such that the\nsubmodule is contained in its span. -/\ntheorem rank_submodule_le_one_iff' (s : Submodule K V) [Module.Free K s] :\n    Module.rank K s ≤ 1 ↔ ∃ v₀, s ≤ K ∙ v₀ := by\n  haveI := nontrivial_of_invariantBasisNumber K\n  constructor\n  · rw [rank_submodule_le_one_iff]\n    rintro ⟨v₀, _, h⟩\n    exact ⟨v₀, h⟩\n  · rintro ⟨v₀, h⟩\n    obtain ⟨κ, b⟩ := Module.Free.exists_basis (R := K) (M := s)\n    simpa [b.mk_eq_rank''] using b.linearIndependent.map' _ (ker_inclusion _ _ h)\n      |>.cardinal_le_rank.trans (rank_span_le {v₀})\n\n"}
{"name":"Submodule.rank_le_one_iff_isPrincipal","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Submodule K V\ninst✝ : Module.Free K (Subtype fun x => Membership.mem W x)\n⊢ Iff (LE.le (Module.rank K (Subtype fun x => Membership.mem W x)) 1) W.IsPrincipal","decl":"theorem Submodule.rank_le_one_iff_isPrincipal (W : Submodule K V) [Module.Free K W] :\n    Module.rank K W ≤ 1 ↔ W.IsPrincipal := by\n  simp only [rank_le_one_iff, Submodule.isPrincipal_iff, le_antisymm_iff, le_span_singleton_iff,\n    span_singleton_le_iff_mem]\n  constructor\n  · rintro ⟨⟨m, hm⟩, hm'⟩\n    choose f hf using hm'\n    exact ⟨m, ⟨fun v hv => ⟨f ⟨v, hv⟩, congr_arg ((↑) : W → V) (hf ⟨v, hv⟩)⟩, hm⟩⟩\n  · rintro ⟨a, ⟨h, ha⟩⟩\n    choose f hf using h\n    exact ⟨⟨a, ha⟩, fun v => ⟨f v.1 v.2, Subtype.ext (hf v.1 v.2)⟩⟩\n\n"}
{"name":"Module.rank_le_one_iff_top_isPrincipal","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\n⊢ Iff (LE.le (Module.rank K V) 1) Top.top.IsPrincipal","decl":"theorem Module.rank_le_one_iff_top_isPrincipal [Module.Free K V] :\n    Module.rank K V ≤ 1 ↔ (⊤ : Submodule K V).IsPrincipal := by\n  haveI := Module.Free.of_equiv (topEquiv (R := K) (M := V)).symm\n  rw [← Submodule.rank_le_one_iff_isPrincipal, rank_top]\n\n"}
{"name":"finrank_eq_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\nι : Type u_1\ninst✝ : Unique ι\n⊢ Iff (Eq (Module.finrank K V) 1) (Nonempty (Basis ι K V))","decl":"/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis.\n-/\ntheorem finrank_eq_one_iff [Module.Free K V] (ι : Type*) [Unique ι] :\n    finrank K V = 1 ↔ Nonempty (Basis ι K V) := by\n  constructor\n  · intro h\n    exact ⟨Module.basisUnique ι h⟩\n  · rintro ⟨b⟩\n    simpa using finrank_eq_card_basis b\n\n"}
{"name":"finrank_eq_one_iff'","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : Ring K\ninst✝³ : StrongRankCondition K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\n⊢ Iff (Eq (Module.finrank K V) 1) (Exists fun v => And (Ne v 0) (∀ (w : V), Exists fun c => Eq (HSMul.hSMul c v) w))","decl":"/-- A module has dimension 1 iff there is some nonzero `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff' [Module.Free K V] :\n    finrank K V = 1 ↔ ∃ v ≠ 0, ∀ w : V, ∃ c : K, c • v = w := by\n  rw [← rank_eq_one_iff]\n  exact toNat_eq_iff one_ne_zero\n\n"}
{"name":"finrank_le_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Iff (LE.le (Module.finrank K V) 1) (Exists fun v => ∀ (w : V), Exists fun c => Eq (HSMul.hSMul c v) w)","decl":"/-- A finite dimensional module has dimension at most 1 iff\nthere is some `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_le_one_iff [Module.Free K V] [Module.Finite K V] :\n    finrank K V ≤ 1 ↔ ∃ v : V, ∀ w : V, ∃ c : K, c • v = w := by\n  rw [← rank_le_one_iff, ← finrank_eq_rank, Nat.cast_le_one]\n\n"}
{"name":"Submodule.finrank_le_one_iff_isPrincipal","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nW : Submodule K V\ninst✝¹ : Module.Free K (Subtype fun x => Membership.mem W x)\ninst✝ : Module.Finite K (Subtype fun x => Membership.mem W x)\n⊢ Iff (LE.le (Module.finrank K (Subtype fun x => Membership.mem W x)) 1) W.IsPrincipal","decl":"theorem Submodule.finrank_le_one_iff_isPrincipal\n    (W : Submodule K V) [Module.Free K W] [Module.Finite K W] :\n    finrank K W ≤ 1 ↔ W.IsPrincipal := by\n  rw [← W.rank_le_one_iff_isPrincipal, ← finrank_eq_rank, Nat.cast_le_one]\n\n"}
{"name":"Module.finrank_le_one_iff_top_isPrincipal","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Iff (LE.le (Module.finrank K V) 1) Top.top.IsPrincipal","decl":"theorem Module.finrank_le_one_iff_top_isPrincipal [Module.Free K V] [Module.Finite K V] :\n    finrank K V ≤ 1 ↔ (⊤ : Submodule K V).IsPrincipal := by\n  rw [← Module.rank_le_one_iff_top_isPrincipal, ← finrank_eq_rank, Nat.cast_le_one]\n\n"}
{"name":"lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk V)) (HPow.hPow (Cardinal.lift.{v, u} (Cardinal.mk K)) (Cardinal.lift.{u, v} (Module.rank K V)))","decl":"variable (K V) in\ntheorem lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank [Module.Free K V]\n    [Module.Finite K V] : lift.{u} #V = lift.{v} #K ^ lift.{u} (Module.rank K V) := by\n  haveI := nontrivial_of_invariantBasisNumber K\n  obtain ⟨s, hs⟩ := Module.Free.exists_basis (R := K) (M := V)\n  -- `Module.Finite.finite_basis` is in a much later file, so we copy its proof to here\n  haveI : Finite s := by\n    obtain ⟨t, ht⟩ := ‹Module.Finite K V›\n    exact basis_finite_of_finite_spans _ t.finite_toSet ht hs\n  have := lift_mk_eq'.2 ⟨hs.repr.toEquiv⟩\n  rwa [Finsupp.equivFunOnFinite.cardinal_eq, mk_arrow, hs.mk_eq_rank'', lift_power, lift_lift,\n    lift_lift, lift_umax] at this\n\n"}
{"name":"lift_cardinal_mk_eq_lift_cardinal_mk_field_pow_lift_rank","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk V)) (HPow.hPow (Cardinal.lift.{v, u} (Cardinal.mk K)) (Cardinal.lift.{u, v} (Module.rank K V)))","decl":"@[deprecated (since := \"2024-11-10\")]\nalias lift_cardinal_mk_eq_lift_cardinal_mk_field_pow_lift_rank :=\n  lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank\n\n"}
{"name":"cardinalMk_eq_cardinalMk_field_pow_rank","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K V : Type u\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Eq (Cardinal.mk V) (HPow.hPow (Cardinal.mk K) (Module.rank K V))","decl":"theorem cardinalMk_eq_cardinalMk_field_pow_rank (K V : Type u) [Ring K] [StrongRankCondition K]\n    [AddCommGroup V] [Module K V] [Module.Free K V] [Module.Finite K V] :\n    #V = #K ^ Module.rank K V := by\n  simpa using lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank K V\n\n"}
{"name":"cardinal_mk_eq_cardinal_mk_field_pow_rank","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K V : Type u\ninst✝⁵ : Ring K\ninst✝⁴ : StrongRankCondition K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Eq (Cardinal.mk V) (HPow.hPow (Cardinal.mk K) (Module.rank K V))","decl":"@[deprecated (since := \"2024-11-10\")]\nalias cardinal_mk_eq_cardinal_mk_field_pow_rank := cardinalMk_eq_cardinalMk_field_pow_rank\n\n"}
{"name":"cardinal_lt_aleph0_of_finiteDimensional","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : Ring K\ninst✝⁵ : StrongRankCondition K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\ninst✝² : Finite K\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ LT.lt (Cardinal.mk V) Cardinal.aleph0","decl":"variable (K V) in\ntheorem cardinal_lt_aleph0_of_finiteDimensional [Finite K] [Module.Free K V] [Module.Finite K V] :\n    #V < ℵ₀ := by\n  rw [← lift_lt_aleph0.{v, u}, lift_cardinalMk_eq_lift_cardinalMk_field_pow_lift_rank K V]\n  exact power_lt_aleph0 (lift_lt_aleph0.2 (lt_aleph0_of_finite K))\n    (lift_lt_aleph0.2 (rank_lt_aleph0 K V))\n\n"}
{"name":"Subalgebra.eq_bot_of_rank_le_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : StrongRankCondition F\ninst✝² : Ring E\ninst✝¹ : Algebra F E\nS : Subalgebra F E\nh : LE.le (Module.rank F (Subtype fun x => Membership.mem S x)) 1\ninst✝ : Module.Free F (Subtype fun x => Membership.mem S x)\n⊢ Eq S Bot.bot","decl":"theorem eq_bot_of_rank_le_one (h : Module.rank F S ≤ 1) [Module.Free F S] : S = ⊥ := by\n  nontriviality E\n  obtain ⟨κ, b⟩ := Module.Free.exists_basis (R := F) (M := S)\n  by_cases h1 : Module.rank F S = 1\n  · refine bot_unique fun x hx ↦ Algebra.mem_bot.2 ?_\n    rw [← b.mk_eq_rank'', eq_one_iff_unique, ← unique_iff_subsingleton_and_nonempty] at h1\n    obtain ⟨h1⟩ := h1\n    obtain ⟨y, hy⟩ := (bijective_algebraMap_of_linearEquiv (b.repr ≪≫ₗ\n      Finsupp.LinearEquiv.finsuppUnique _ _ _).symm).surjective ⟨x, hx⟩\n    exact ⟨y, congr(Subtype.val $(hy))⟩\n  haveI := mk_eq_zero_iff.1 (b.mk_eq_rank''.symm ▸ lt_one_iff_zero.1 (h.lt_of_ne h1))\n  haveI := b.repr.toEquiv.subsingleton\n  exact False.elim <| one_ne_zero congr(S.val $(Subsingleton.elim 1 0))\n\n"}
{"name":"Subalgebra.eq_bot_of_finrank_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : CommRing F\ninst✝³ : StrongRankCondition F\ninst✝² : Ring E\ninst✝¹ : Algebra F E\nS : Subalgebra F E\nh : Eq (Module.finrank F (Subtype fun x => Membership.mem S x)) 1\ninst✝ : Module.Free F (Subtype fun x => Membership.mem S x)\n⊢ Eq S Bot.bot","decl":"theorem eq_bot_of_finrank_one (h : finrank F S = 1) [Module.Free F S] : S = ⊥ := by\n  refine Subalgebra.eq_bot_of_rank_le_one ?_\n  rw [finrank, toNat_eq_one] at h\n  rw [h]\n\n"}
{"name":"Subalgebra.rank_eq_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\nS : Subalgebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq (Module.rank F (Subtype fun x => Membership.mem S x)) 1) (Eq S Bot.bot)","decl":"@[simp]\ntheorem rank_eq_one_iff [Nontrivial E] [Module.Free F S] : Module.rank F S = 1 ↔ S = ⊥ := by\n  refine ⟨fun h ↦ Subalgebra.eq_bot_of_rank_le_one h.le, ?_⟩\n  rintro rfl\n  obtain ⟨κ, b⟩ := Module.Free.exists_basis (R := F) (M := (⊥ : Subalgebra F E))\n  refine le_antisymm ?_ ?_\n  · have := lift_rank_range_le (Algebra.linearMap F E)\n    rwa [← one_eq_range, rank_self, lift_one, lift_le_one_iff,\n      ← Algebra.toSubmodule_bot, rank_toSubmodule] at this\n  · by_contra H\n    rw [not_le, lt_one_iff_zero] at H\n    haveI := mk_eq_zero_iff.1 (H ▸ b.mk_eq_rank'')\n    haveI := b.repr.toEquiv.subsingleton\n    exact one_ne_zero congr((⊥ : Subalgebra F E).val $(Subsingleton.elim 1 0))\n\n"}
{"name":"Subalgebra.finrank_eq_one_iff","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\nS : Subalgebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq (Module.finrank F (Subtype fun x => Membership.mem S x)) 1) (Eq S Bot.bot)","decl":"@[simp]\ntheorem finrank_eq_one_iff [Nontrivial E] [Module.Free F S] : finrank F S = 1 ↔ S = ⊥ := by\n  rw [← Subalgebra.rank_eq_one_iff]\n  exact toNat_eq_iff one_ne_zero\n\n"}
{"name":"Subalgebra.bot_eq_top_iff_rank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F E\n⊢ Iff (Eq Bot.bot Top.top) (Eq (Module.rank F E) 1)","decl":"theorem bot_eq_top_iff_rank_eq_one [Nontrivial E] [Module.Free F E] :\n    (⊥ : Subalgebra F E) = ⊤ ↔ Module.rank F E = 1 := by\n  haveI := Module.Free.of_equiv (Subalgebra.topEquiv (R := F) (A := E)).toLinearEquiv.symm\n  -- Porting note: removed `subalgebra_top_rank_eq_submodule_top_rank`\n  rw [← rank_top, Subalgebra.rank_eq_one_iff, eq_comm]\n\n"}
{"name":"Subalgebra.bot_eq_top_iff_finrank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F E\n⊢ Iff (Eq Bot.bot Top.top) (Eq (Module.finrank F E) 1)","decl":"theorem bot_eq_top_iff_finrank_eq_one [Nontrivial E] [Module.Free F E] :\n    (⊥ : Subalgebra F E) = ⊤ ↔ finrank F E = 1 := by\n  haveI := Module.Free.of_equiv (Subalgebra.topEquiv (R := F) (A := E)).toLinearEquiv.symm\n  rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank,\n    Subalgebra.finrank_eq_one_iff, eq_comm]\n\n"}
{"name":"Subalgebra.bot_eq_top_of_rank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F E\na✝ : Eq (Module.rank F E) 1\n⊢ Eq Bot.bot Top.top","decl":"alias ⟨_, bot_eq_top_of_rank_eq_one⟩ := bot_eq_top_iff_rank_eq_one\n\n"}
{"name":"Subalgebra.bot_eq_top_of_finrank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁵ : CommRing F\ninst✝⁴ : StrongRankCondition F\ninst✝³ : Ring E\ninst✝² : Algebra F E\ninst✝¹ : Nontrivial E\ninst✝ : Module.Free F E\na✝ : Eq (Module.finrank F E) 1\n⊢ Eq Bot.bot Top.top","decl":"alias ⟨_, bot_eq_top_of_finrank_eq_one⟩ := bot_eq_top_iff_finrank_eq_one\n\n"}
