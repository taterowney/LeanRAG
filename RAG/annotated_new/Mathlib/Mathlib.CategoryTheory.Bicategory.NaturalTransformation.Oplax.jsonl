{"name":"CategoryTheory.OplaxNatTrans.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\napp✝ : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (app✝ b)) (CategoryTheory.CategoryStruct.comp (app✝ a) (G.map f))\nnaturality_naturality✝ : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app✝ b)) (naturality✝ g)) (CategoryTheory.CategoryStruct.comp (naturality✝ f) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.map₂ η)))) _auto✝\nnaturality_id✝ : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app✝ a)).hom (CategoryTheory.Bicategory.rightUnitor (app✝ a)).inv))) _auto✝\nnaturality_comp✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app✝ c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app✝ c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality✝ g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app✝ b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality✝ f) (G.map g)) (CategoryTheory.Bicategory.associator (app✝ a) (G.map f) (G.map g)).hom)))))) _auto✝\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g)) (CategoryTheory.CategoryStruct.comp (naturality f) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f) (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\nx✝ : Eq { app := app✝, naturality := naturality✝, naturality_naturality := naturality_naturality✝, naturality_id := naturality_id✝, naturality_comp := naturality_comp✝ } { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }\n⊢ And (Eq app✝ app) (HEq naturality✝ naturality)","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\napp✝ : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (app✝ b)) (CategoryTheory.CategoryStruct.comp (app✝ a) (G.map f))\nnaturality_naturality✝ : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app✝ b)) (naturality✝ g)) (CategoryTheory.CategoryStruct.comp (naturality✝ f) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.map₂ η)))) _auto✝\nnaturality_id✝ : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app✝ a)).hom (CategoryTheory.Bicategory.rightUnitor (app✝ a)).inv))) _auto✝\nnaturality_comp✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app✝ c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app✝ c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality✝ g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app✝ b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality✝ f) (G.map g)) (CategoryTheory.Bicategory.associator (app✝ a) (G.map f) (G.map g)).hom)))))) _auto✝\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g)) (CategoryTheory.CategoryStruct.comp (naturality f) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f) (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\n⊢ Eq (Eq { app := app✝, naturality := naturality✝, naturality_naturality := naturality_naturality✝, naturality_id := naturality_id✝, naturality_comp := naturality_comp✝ } { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }) (And (Eq app✝ app) (HEq naturality✝ naturality))","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na : B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (self.app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.app a)).hom (CategoryTheory.Bicategory.rightUnitor (self.app a)).inv))","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (self.app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (self.app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (self.app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.naturality f) (G.map g)) (CategoryTheory.Bicategory.associator (self.app a) (G.map f) (G.map g)).hom)))))","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g)) (CategoryTheory.CategoryStruct.comp (naturality f) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f) (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\n⊢ Eq (SizeOf.sizeOf { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }) 1","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (self.app b)) (self.naturality g)) (CategoryTheory.CategoryStruct.comp (self.naturality f) (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.map₂ η)))","decl":"/-- If `η` is an oplax natural transformation between `F` and `G`, we have a 1-morphism\n`η.app a : F.obj a ⟶ G.obj a` for each object `a : B`. We also have a 2-morphism\n`η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism `f : a ⟶ b`.\nThese 2-morphisms satisfies the naturality condition, and preserve the identities and\nthe compositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ⟶ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ naturality g = naturality f ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      naturality (𝟙 a) ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      naturality (f ≫ g) ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ naturality g ≫ (α_ _ _ _).inv ≫ naturality f ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nZ : Quiver.Hom (F.obj a) (G.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapComp f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (self.app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (self.app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (self.app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.naturality f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.app a) (G.map f) (G.map g)).hom h))))))","decl":"attribute [reassoc (attr := simp)] OplaxNatTrans.naturality_naturality OplaxNatTrans.naturality_id\n  OplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na : B\nZ : Quiver.Hom (F.obj a) (G.obj a)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (CategoryTheory.CategoryStruct.id (G.obj a))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapId a)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (self.app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.app a)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.app a)).inv h)))","decl":"attribute [reassoc (attr := simp)] OplaxNatTrans.naturality_naturality OplaxNatTrans.naturality_id\n  OplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.OplaxNatTrans F G\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\nZ : Quiver.Hom (F.obj a) (G.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (self.app b)) (CategoryTheory.CategoryStruct.comp (self.naturality g) h)) (CategoryTheory.CategoryStruct.comp (self.naturality f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.map₂ η)) h))","decl":"attribute [reassoc (attr := simp)] OplaxNatTrans.naturality_naturality OplaxNatTrans.naturality_id\n  OplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.id_app","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na : B\n⊢ Eq ((CategoryTheory.OplaxNatTrans.id F).app a) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"/-- The identity oplax natural transformation. -/\n@[simps]\ndef id : OplaxNatTrans F F where\n  app a := 𝟙 (F.obj a)\n  naturality {_ _} f := (ρ_ (F.map f)).hom ≫ (λ_ (F.map f)).inv\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.id_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nx✝¹ x✝ : B\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.OplaxNatTrans.id F).naturality f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv)","decl":"/-- The identity oplax natural transformation. -/\n@[simps]\ndef id : OplaxNatTrans F F where\n  app a := 𝟙 (F.obj a)\n  naturality {_ _} f := (ρ_ (F.map f)).hom ≫ (λ_ (F.map f)).inv\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na b : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng h : Quiver.Hom a b\nβ : Quiver.Hom g h\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) (θ.app b))) (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality g)) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.map₂ β))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_naturality (f : a' ⟶ G.obj a) {g h : a ⟶ b} (β : g ⟶ h) :\n    f ◁ G.map₂ β ▷ θ.app b ≫ f ◁ θ.naturality h =\n      f ◁ θ.naturality g ≫ f ◁ θ.app a ◁ H.map₂ β := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_naturality]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na b : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng h✝ : Quiver.Hom a b\nβ : Quiver.Hom g h✝\nZ : Quiver.Hom a' (H.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (H.map h✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) (θ.app b))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality h✝)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.map₂ β))) h))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_naturality (f : a' ⟶ G.obj a) {g h : a ⟶ b} (β : g ⟶ h) :\n    f ◁ G.map₂ β ▷ θ.app b ≫ f ◁ θ.naturality h =\n      f ◁ θ.naturality g ≫ f ◁ θ.app a ◁ H.map₂ β := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_naturality]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na b : B\na' : C\nf g : Quiver.Hom a b\nβ : Quiver.Hom f g\nh✝ : Quiver.Hom (G.obj b) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (η.app a) (G.map g)) h✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.map₂ β) (η.app b)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality g) h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map f) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map g) h✝).inv h))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_naturality {f g : a ⟶ b} (β : f ⟶ g) (h : G.obj b ⟶ a') :\n    F.map₂ β ▷ η.app b ▷ h ≫ η.naturality g ▷ h =\n      η.naturality f ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.map₂ β ▷ h ≫ (α_ _ _ _).inv := by\n  rw [← comp_whiskerRight, naturality_naturality, comp_whiskerRight, whisker_assoc]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na b : B\na' : C\nf g : Quiver.Hom a b\nβ : Quiver.Hom f g\nh : Quiver.Hom (G.obj b) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.map₂ β) (η.app b)) h) (CategoryTheory.Bicategory.whiskerRight (η.naturality g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map f) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) h)) (CategoryTheory.Bicategory.associator (η.app a) (G.map g) h).inv)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_naturality {f g : a ⟶ b} (β : f ⟶ g) (h : G.obj b ⟶ a') :\n    F.map₂ β ▷ η.app b ▷ h ≫ η.naturality g ▷ h =\n      η.naturality f ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.map₂ β ▷ h ≫ (α_ _ _ _).inv := by\n  rw [← comp_whiskerRight, naturality_naturality, comp_whiskerRight, whisker_assoc]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na b c : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng : Quiver.Hom a b\nh✝ : Quiver.Hom b c\nZ : Quiver.Hom a' (H.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (CategoryTheory.CategoryStruct.comp (H.map g) (H.map h✝)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.comp g h✝))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapComp g h✝))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapComp g h✝) (θ.app c))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (G.map h✝) (θ.app c)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (G.map g) (θ.naturality h✝))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (θ.app b) (H.map h✝)).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (θ.naturality g) (H.map h✝))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (θ.app a) (H.map g) (H.map h✝)).hom) h))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_comp (f : a' ⟶ G.obj a) (g : a ⟶ b) (h : b ⟶ c) :\n    f ◁ θ.naturality (g ≫ h) ≫ f ◁ θ.app a ◁ H.mapComp g h =\n      f ◁ G.mapComp g h ▷ θ.app c ≫\n        f ◁ (α_ _ _ _).hom ≫\n          f ◁ G.map g ◁ θ.naturality h ≫\n            f ◁ (α_ _ _ _).inv ≫ f ◁ θ.naturality g ▷ H.map h ≫ f ◁ (α_ _ _ _).hom := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_comp]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na b c : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng : Quiver.Hom a b\nh : Quiver.Hom b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.comp g h))) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapComp g h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapComp g h) (θ.app c))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (G.map h) (θ.app c)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (G.map g) (θ.naturality h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (θ.app b) (H.map h)).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (θ.naturality g) (H.map h))) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (θ.app a) (H.map g) (H.map h)).hom))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_comp (f : a' ⟶ G.obj a) (g : a ⟶ b) (h : b ⟶ c) :\n    f ◁ θ.naturality (g ≫ h) ≫ f ◁ θ.app a ◁ H.mapComp g h =\n      f ◁ G.mapComp g h ▷ θ.app c ≫\n        f ◁ (α_ _ _ _).hom ≫\n          f ◁ G.map g ◁ θ.naturality h ≫\n            f ◁ (α_ _ _ _).inv ≫ f ◁ θ.naturality g ▷ H.map h ≫ f ◁ (α_ _ _ _).hom := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_comp]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na b c : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh✝ : Quiver.Hom (G.obj c) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (η.app a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.comp f g)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.comp f g)) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapComp f g) h✝)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (η.app c)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (η.app c)).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (η.app c)) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (η.naturality g) h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (η.app b) (G.map g)) h✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (η.app b) (G.map g)).inv h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (η.naturality f) (G.map g)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (η.app a) (G.map f) (G.map g)).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h✝).hom h)))))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_comp (f : a ⟶ b) (g : b ⟶ c) (h : G.obj c ⟶ a') :\n    η.naturality (f ≫ g) ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapComp f g ▷ h =\n      F.mapComp f g ▷ η.app c ▷ h ≫\n        (α_ _ _ _).hom ▷ h ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ η.naturality g ▷ h ≫\n              (α_ _ _ _).inv ≫\n                (α_ _ _ _).inv ▷ h ≫\n                  η.naturality f ▷ G.map g ▷ h ≫ (α_ _ _ _).hom ▷ h ≫ (α_ _ _ _).hom := by\n  rw [← associator_naturality_middle, ← comp_whiskerRight_assoc, naturality_comp]; simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na b c : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom (G.obj c) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.comp f g)) h).hom (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapComp f g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (η.app c)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (η.app c)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (η.app c)) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (η.naturality g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (η.app b) (G.map g)) h).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (η.app b) (G.map g)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (η.naturality f) (G.map g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (η.app a) (G.map f) (G.map g)).hom h) (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h).hom))))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_comp (f : a ⟶ b) (g : b ⟶ c) (h : G.obj c ⟶ a') :\n    η.naturality (f ≫ g) ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapComp f g ▷ h =\n      F.mapComp f g ▷ η.app c ▷ h ≫\n        (α_ _ _ _).hom ▷ h ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ η.naturality g ▷ h ≫\n              (α_ _ _ _).inv ≫\n                (α_ _ _ _).inv ▷ h ≫\n                  η.naturality f ▷ G.map g ▷ h ≫ (α_ _ _ _).hom ▷ h ≫ (α_ _ _ _).hom := by\n  rw [← associator_naturality_middle, ← comp_whiskerRight_assoc, naturality_comp]; simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na : B\na' : C\nf : Quiver.Hom a' (G.obj a)\nZ : Quiver.Hom a' (H.obj a)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (CategoryTheory.CategoryStruct.id (H.obj a)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.id a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapId a))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapId a) (θ.app a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.leftUnitor (θ.app a)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.rightUnitor (θ.app a)).inv) h)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_id (f : a' ⟶ G.obj a) :\n    f ◁ θ.naturality (𝟙 a) ≫ f ◁ θ.app a ◁ H.mapId a =\n      f ◁ G.mapId a ▷ θ.app a ≫ f ◁ (λ_ (θ.app a)).hom ≫ f ◁ (ρ_ (θ.app a)).inv := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_id]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.OplaxNatTrans G H\na : B\na' : C\nf : Quiver.Hom a' (G.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.id a))) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapId a)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapId a) (θ.app a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.leftUnitor (θ.app a)).hom) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.rightUnitor (θ.app a)).inv)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_id (f : a' ⟶ G.obj a) :\n    f ◁ θ.naturality (𝟙 a) ≫ f ◁ θ.app a ◁ H.mapId a =\n      f ◁ G.mapId a ▷ θ.app a ≫ f ◁ (λ_ (θ.app a)).hom ≫ f ◁ (ρ_ (θ.app a)).inv := by\n  simp_rw [← Bicategory.whiskerLeft_comp, naturality_id]\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na : B\na' : C\nf : Quiver.Hom (G.obj a) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (η.app a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id (G.obj a)) f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.id a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.id a)) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapId a) f)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (η.app a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.leftUnitor (η.app a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (η.app a)).inv f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.id (G.obj a)) f).hom h))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_id (f : G.obj a ⟶ a') :\n    η.naturality (𝟙 a) ▷ f ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapId a ▷ f =\n    F.mapId a ▷ η.app a ▷ f ≫ (λ_ (η.app a)).hom ▷ f ≫ (ρ_ (η.app a)).inv ▷ f ≫ (α_ _ _ _).hom := by\n  rw [← associator_naturality_middle, ← comp_whiskerRight_assoc, naturality_id]; simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.whiskerRight_naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\na : B\na' : C\nf : Quiver.Hom (G.obj a) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.id a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.id a)) f).hom (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapId a) f)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (η.app a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.leftUnitor (η.app a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (η.app a)).inv f) (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.id (G.obj a)) f).hom)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_id (f : G.obj a ⟶ a') :\n    η.naturality (𝟙 a) ▷ f ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapId a ▷ f =\n    F.mapId a ▷ η.app a ▷ f ≫ (λ_ (η.app a)).hom ▷ f ≫ (ρ_ (η.app a)).inv ▷ f ≫ (α_ _ _ _).hom := by\n  rw [← associator_naturality_middle, ← comp_whiskerRight_assoc, naturality_id]; simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.vcomp_app","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G H : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\nθ : CategoryTheory.OplaxNatTrans G H\na : B\n⊢ Eq ((η.vcomp θ).app a) (CategoryTheory.CategoryStruct.comp (η.app a) (θ.app a))","decl":"/-- Vertical composition of oplax natural transformations. -/\n@[simps]\ndef vcomp (η : OplaxNatTrans F G) (θ : OplaxNatTrans G H) : OplaxNatTrans F H where\n  app a := η.app a ≫ θ.app a\n  naturality {a b} f :=\n    (α_ _ _ _).inv ≫\n      η.naturality f ▷ θ.app b ≫ (α_ _ _ _).hom ≫ η.app a ◁ θ.naturality f ≫ (α_ _ _ _).inv\n  naturality_comp {a b c} f g := by\n    calc\n      _ =\n          ?_ ≫\n            F.mapComp f g ▷ η.app c ▷ θ.app c ≫\n              ?_ ≫\n                F.map f ◁ η.naturality g ▷ θ.app c ≫\n                  ?_ ≫\n                    (F.map f ≫ η.app b) ◁ θ.naturality g ≫\n                      η.naturality f ▷ (θ.app b ≫ H.map g) ≫\n                        ?_ ≫ η.app a ◁ θ.naturality f ▷ H.map g ≫ ?_ :=\n        ?_\n      _ = _ := ?_\n    · exact (α_ _ _ _).inv\n    · exact (α_ _ _ _).hom ▷ _ ≫ (α_ _ _ _).hom\n    · exact _ ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv\n    · exact (α_ _ _ _).hom ≫ _ ◁ (α_ _ _ _).inv\n    · exact _ ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv\n    · rw [whisker_exchange_assoc]\n      simp\n    · simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.vcomp_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G H : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\nθ : CategoryTheory.OplaxNatTrans G H\na b : B\nf : Quiver.Hom a b\n⊢ Eq ((η.vcomp θ).naturality f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (η.app b) (θ.app b)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f) (θ.app b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map f) (θ.app b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (θ.naturality f)) (CategoryTheory.Bicategory.associator (η.app a) (θ.app a) (H.map f)).inv))))","decl":"/-- Vertical composition of oplax natural transformations. -/\n@[simps]\ndef vcomp (η : OplaxNatTrans F G) (θ : OplaxNatTrans G H) : OplaxNatTrans F H where\n  app a := η.app a ≫ θ.app a\n  naturality {a b} f :=\n    (α_ _ _ _).inv ≫\n      η.naturality f ▷ θ.app b ≫ (α_ _ _ _).hom ≫ η.app a ◁ θ.naturality f ≫ (α_ _ _ _).inv\n  naturality_comp {a b c} f g := by\n    calc\n      _ =\n          ?_ ≫\n            F.mapComp f g ▷ η.app c ▷ θ.app c ≫\n              ?_ ≫\n                F.map f ◁ η.naturality g ▷ θ.app c ≫\n                  ?_ ≫\n                    (F.map f ≫ η.app b) ◁ θ.naturality g ≫\n                      η.naturality f ▷ (θ.app b ≫ H.map g) ≫\n                        ?_ ≫ η.app a ◁ θ.naturality f ▷ H.map g ≫ ?_ :=\n        ?_\n      _ = _ := ?_\n    · exact (α_ _ _ _).inv\n    · exact (α_ _ _ _).hom ▷ _ ≫ (α_ _ _ _).hom\n    · exact _ ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv\n    · exact (α_ _ _ _).hom ≫ _ ◁ (α_ _ _ _).inv\n    · exact _ ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv\n    · rw [whisker_exchange_assoc]\n      simp\n    · simp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.instCategoryStructOplaxFunctor_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nX✝ Y✝ Z✝ : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans X✝ Y✝\nθ : CategoryTheory.OplaxNatTrans Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp η θ) (η.vcomp θ)","decl":"@[simps id comp]\ninstance : CategoryStruct (OplaxFunctor B C) where\n  Hom := OplaxNatTrans\n  id := OplaxNatTrans.id\n  comp := OplaxNatTrans.vcomp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.instCategoryStructOplaxFunctor_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\n⊢ Eq (CategoryTheory.CategoryStruct.id F) (CategoryTheory.OplaxNatTrans.id F)","decl":"@[simps id comp]\ninstance : CategoryStruct (OplaxFunctor B C) where\n  Hom := OplaxNatTrans\n  id := OplaxNatTrans.id\n  comp := OplaxNatTrans.vcomp\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.StrongCore.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (η.app b)) (CategoryTheory.CategoryStruct.comp (η.app a) (G.map f))\nnaturality_hom✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (naturality✝ f).hom (η.naturality f)) _auto✝\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (η.app b)) (CategoryTheory.CategoryStruct.comp (η.app a) (G.map f))\nnaturality_hom : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (naturality f).hom (η.naturality f)) _auto✝\n⊢ Eq (Eq { naturality := naturality✝, naturality_hom := naturality_hom✝ } { naturality := naturality, naturality_hom := naturality_hom }) (Eq naturality✝ naturality)","decl":"/-- A structure on an Oplax natural transformation that promotes it to a strong natural\ntransformation.\n\nSee `StrongNatTrans.mkOfOplax`. -/\nstructure StrongCore {F G : OplaxFunctor B C} (η : OplaxNatTrans F G) where\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ η.app b ≅ η.app a ≫ G.map f\n  naturality_hom {a b : B} (f : a ⟶ b) : (naturality f).hom = η.naturality f := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.StrongCore.naturality_hom","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\nself : η.StrongCore\na b : B\nf : Quiver.Hom a b\n⊢ Eq (self.naturality f).hom (η.naturality f)","decl":"/-- A structure on an Oplax natural transformation that promotes it to a strong natural\ntransformation.\n\nSee `StrongNatTrans.mkOfOplax`. -/\nstructure StrongCore {F G : OplaxFunctor B C} (η : OplaxNatTrans F G) where\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ η.app b ≅ η.app a ≫ G.map f\n  naturality_hom {a b : B} (f : a ⟶ b) : (naturality f).hom = η.naturality f := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.StrongCore.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (η.app b)) (CategoryTheory.CategoryStruct.comp (η.app a) (G.map f))\nnaturality_hom✝ : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (naturality✝ f).hom (η.naturality f)) _auto✝\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (η.app b)) (CategoryTheory.CategoryStruct.comp (η.app a) (G.map f))\nnaturality_hom : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (naturality f).hom (η.naturality f)) _auto✝\nx✝ : Eq { naturality := naturality✝, naturality_hom := naturality_hom✝ } { naturality := naturality, naturality_hom := naturality_hom }\n⊢ Eq naturality✝ naturality","decl":"/-- A structure on an Oplax natural transformation that promotes it to a strong natural\ntransformation.\n\nSee `StrongNatTrans.mkOfOplax`. -/\nstructure StrongCore {F G : OplaxFunctor B C} (η : OplaxNatTrans F G) where\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ η.app b ≅ η.app a ≫ G.map f\n  naturality_hom {a b : B} (f : a ⟶ b) : (naturality f).hom = η.naturality f := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxNatTrans.StrongCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.OplaxNatTrans F G\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (η.app b)) (CategoryTheory.CategoryStruct.comp (η.app a) (G.map f))\nnaturality_hom : autoParam (∀ {a b : B} (f : Quiver.Hom a b), Eq (naturality f).hom (η.naturality f)) _auto✝\n⊢ Eq (SizeOf.sizeOf { naturality := naturality, naturality_hom := naturality_hom }) 1","decl":"/-- A structure on an Oplax natural transformation that promotes it to a strong natural\ntransformation.\n\nSee `StrongNatTrans.mkOfOplax`. -/\nstructure StrongCore {F G : OplaxFunctor B C} (η : OplaxNatTrans F G) where\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ η.app b ≅ η.app a ≫ G.map f\n  naturality_hom {a b : B} (f : a ⟶ b) : (naturality f).hom = η.naturality f := by aesop_cat\n\n"}
