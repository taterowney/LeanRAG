{"name":"AddCircle.instIsAddHaarMeasureRealHaarAddCircle","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ AddCircle.haarAddCircle.IsAddHaarMeasure","decl":"instance : IsAddHaarMeasure (@haarAddCircle T _) :=\n  Measure.isAddHaarMeasure_addHaarMeasure ⊤\n\n"}
{"name":"AddCircle.instIsProbabilityMeasureRealHaarAddCircle","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ MeasureTheory.IsProbabilityMeasure AddCircle.haarAddCircle","decl":"instance : IsProbabilityMeasure (@haarAddCircle T _) :=\n  IsProbabilityMeasure.mk addHaarMeasure_self\n\n"}
{"name":"AddCircle.volume_eq_smul_haarAddCircle","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Eq MeasureTheory.MeasureSpace.volume (HSMul.hSMul (ENNReal.ofReal T) AddCircle.haarAddCircle)","decl":"theorem volume_eq_smul_haarAddCircle :\n    (volume : Measure (AddCircle T)) = ENNReal.ofReal T • (@haarAddCircle T _) :=\n  rfl\n\n"}
{"name":"fourier_apply","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : AddCircle T\n⊢ Eq ((fourier n) x) ↑(HSMul.hSMul n x).toCircle","decl":"@[simp]\ntheorem fourier_apply {n : ℤ} {x : AddCircle T} : fourier n x = toCircle (n • x :) :=\n  rfl\n\n-- simp normal form is `fourier_coe_apply'`\n"}
{"name":"fourier_coe_apply","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : Real\n⊢ Eq ((fourier n) ↑x) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑n) ↑x) ↑T))","decl":"theorem fourier_coe_apply {n : ℤ} {x : ℝ} :\n    fourier n (x : AddCircle T) = Complex.exp (2 * π * Complex.I * n * x / T) := by\n  rw [fourier_apply, ← QuotientAddGroup.mk_zsmul, toCircle, Function.Periodic.lift_coe,\n    Circle.coe_exp, Complex.ofReal_mul, Complex.ofReal_div, Complex.ofReal_mul, zsmul_eq_mul,\n    Complex.ofReal_mul, Complex.ofReal_intCast]\n  norm_num\n  congr 1; ring\n\n"}
{"name":"fourier_coe_apply'","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : Real\n⊢ Eq (↑(AddCircle.toCircle (HSMul.hSMul n ↑x))) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑n) ↑x) ↑T))","decl":"@[simp]\ntheorem fourier_coe_apply' {n : ℤ} {x : ℝ} :\n    toCircle (n • (x : AddCircle T) :) = Complex.exp (2 * π * Complex.I * n * x / T) := by\n  rw [← fourier_apply]; exact fourier_coe_apply\n\n-- simp normal form is `fourier_zero'`\n"}
{"name":"fourier_zero","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nx : AddCircle T\n⊢ Eq ((fourier 0) x) 1","decl":"theorem fourier_zero {x : AddCircle T} : fourier 0 x = 1 := by\n  induction x using QuotientAddGroup.induction_on\n  simp only [fourier_coe_apply]\n  norm_num\n\n"}
{"name":"fourier_zero'","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nx : AddCircle T\n⊢ Eq (↑(AddCircle.toCircle 0)) 1","decl":"theorem fourier_zero' {x : AddCircle T} : @toCircle T 0 = (1 : ℂ) := by\n  have : fourier 0 x = @toCircle T 0 := by rw [fourier_apply, zero_smul]\n  rw [← this]; exact fourier_zero\n\n-- simp normal form is *also* `fourier_zero'`\n"}
{"name":"fourier_eval_zero","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\n⊢ Eq ((fourier n) 0) 1","decl":"theorem fourier_eval_zero (n : ℤ) : fourier n (0 : AddCircle T) = 1 := by\n  rw [← QuotientAddGroup.mk_zero, fourier_coe_apply, Complex.ofReal_zero, mul_zero,\n    zero_div, Complex.exp_zero]\n\n"}
{"name":"fourier_one","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nx : AddCircle T\n⊢ Eq ((fourier 1) x) ↑x.toCircle","decl":"theorem fourier_one {x : AddCircle T} : fourier 1 x = toCircle x := by rw [fourier_apply, one_zsmul]\n\n-- simp normal form is `fourier_neg'`\n"}
{"name":"fourier_neg","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : AddCircle T\n⊢ Eq ((fourier (Neg.neg n)) x) ((starRingEnd Complex) ((fourier n) x))","decl":"theorem fourier_neg {n : ℤ} {x : AddCircle T} : fourier (-n) x = conj (fourier n x) := by\n  induction x using QuotientAddGroup.induction_on\n  simp_rw [fourier_apply, toCircle]\n  rw [← QuotientAddGroup.mk_zsmul, ← QuotientAddGroup.mk_zsmul]\n  simp_rw [Function.Periodic.lift_coe, ← Circle.coe_inv_eq_conj, ← Circle.exp_neg,\n    neg_smul, mul_neg]\n\n"}
{"name":"fourier_neg'","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : AddCircle T\n⊢ Eq (↑(Neg.neg (HSMul.hSMul n x)).toCircle) ((starRingEnd Complex) ((fourier n) x))","decl":"@[simp]\ntheorem fourier_neg' {n : ℤ} {x : AddCircle T} : @toCircle T (-(n • x)) = conj (fourier n x) := by\n  rw [← neg_smul, ← fourier_apply]; exact fourier_neg\n\n-- simp normal form is `fourier_add'`\n"}
{"name":"fourier_add","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nm n : Int\nx : AddCircle T\n⊢ Eq ((fourier (HAdd.hAdd m n)) x) (HMul.hMul ((fourier m) x) ((fourier n) x))","decl":"theorem fourier_add {m n : ℤ} {x : AddCircle T} : fourier (m+n) x = fourier m x * fourier n x := by\n  simp_rw [fourier_apply, add_zsmul, toCircle_add, Circle.coe_mul]\n\n"}
{"name":"fourier_add'","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nm n : Int\nx : AddCircle T\n⊢ Eq (↑(HSMul.hSMul (HAdd.hAdd m n) x).toCircle) (HMul.hMul ((fourier m) x) ((fourier n) x))","decl":"@[simp]\ntheorem fourier_add' {m n : ℤ} {x : AddCircle T} :\n    toCircle ((m + n) • x :) = fourier m x * fourier n x := by\n  rw [← fourier_apply]; exact fourier_add\n\n"}
{"name":"fourier_norm","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\ninst✝ : Fact (LT.lt 0 T)\nn : Int\n⊢ Eq (Norm.norm (fourier n)) 1","decl":"theorem fourier_norm [Fact (0 < T)] (n : ℤ) : ‖@fourier T n‖ = 1 := by\n  rw [ContinuousMap.norm_eq_iSup_norm]\n  have : ∀ x : AddCircle T, ‖fourier n x‖ = 1 := fun x => Circle.abs_coe _\n  simp_rw [this]\n  exact @ciSup_const _ _ _ Zero.instNonempty _\n\n"}
{"name":"fourier_add_half_inv_index","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nhn : Ne n 0\nhT : LT.lt 0 T\nx : AddCircle T\n⊢ Eq ((fourier n) (HAdd.hAdd x ↑(HDiv.hDiv (HDiv.hDiv T 2) ↑n))) (Neg.neg ((fourier n) x))","decl":"/-- For `n ≠ 0`, a translation by `T / 2 / n` negates the function `fourier n`. -/\ntheorem fourier_add_half_inv_index {n : ℤ} (hn : n ≠ 0) (hT : 0 < T) (x : AddCircle T) :\n    @fourier T n (x + ↑(T / 2 / n)) = -fourier n x := by\n  rw [fourier_apply, zsmul_add, ← QuotientAddGroup.mk_zsmul, toCircle_add, coe_mul_unitSphere]\n  have : (n : ℂ) ≠ 0 := by simpa using hn\n  have : (@toCircle T (n • (T / 2 / n) : ℝ) : ℂ) = -1 := by\n    rw [zsmul_eq_mul, toCircle, Function.Periodic.lift_coe, Circle.coe_exp]\n    replace hT := Complex.ofReal_ne_zero.mpr hT.ne'\n    convert Complex.exp_pi_mul_I using 3\n    field_simp; ring\n  rw [this]; simp\n\n"}
{"name":"fourierSubalgebra_coe","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\n⊢ Eq (Subalgebra.toSubmodule fourierSubalgebra.toSubalgebra) (Submodule.span Complex (Set.range fourier))","decl":"/-- The star subalgebra of `C(AddCircle T, ℂ)` generated by `fourier n` for `n ∈ ℤ` is in fact the\nlinear span of these functions. -/\ntheorem fourierSubalgebra_coe :\n    Subalgebra.toSubmodule (@fourierSubalgebra T).toSubalgebra = span ℂ (range (@fourier T)) := by\n  apply adjoin_eq_span_of_subset\n  refine Subset.trans ?_ Submodule.subset_span\n  intro x hx\n  refine Submonoid.closure_induction (fun _ => id) ⟨0, ?_⟩ ?_ hx\n  · ext1 z; exact fourier_zero\n  · rintro - - - - ⟨m, rfl⟩ ⟨n, rfl⟩\n    refine ⟨m + n, ?_⟩\n    ext1 z\n    exact fourier_add\n\n/- a post-port refactor made `fourierSubalgebra` into a `StarSubalgebra`, and eliminated\n`conjInvariantSubalgebra` entirely, making this lemma irrelevant. -/\n\n"}
{"name":"fourierSubalgebra_separatesPoints","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ fourierSubalgebra.SeparatesPoints","decl":"/-- The subalgebra of `C(AddCircle T, ℂ)` generated by `fourier n` for `n ∈ ℤ`\nseparates points. -/\ntheorem fourierSubalgebra_separatesPoints : (@fourierSubalgebra T).SeparatesPoints := by\n  intro x y hxy\n  refine ⟨_, ⟨fourier 1, subset_adjoin ⟨1, rfl⟩, rfl⟩, ?_⟩\n  dsimp only; rw [fourier_one, fourier_one]\n  contrapose! hxy\n  rw [Subtype.coe_inj] at hxy\n  exact injective_toCircle hT.elim.ne' hxy\n\n"}
{"name":"fourierSubalgebra_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Eq fourierSubalgebra.topologicalClosure Top.top","decl":"/-- The subalgebra of `C(AddCircle T, ℂ)` generated by `fourier n` for `n ∈ ℤ` is dense. -/\ntheorem fourierSubalgebra_closure_eq_top : (@fourierSubalgebra T).topologicalClosure = ⊤ :=\n  ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints fourierSubalgebra\n    fourierSubalgebra_separatesPoints\n\n"}
{"name":"span_fourier_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Eq (Submodule.span Complex (Set.range fourier)).topologicalClosure Top.top","decl":"/-- The linear span of the monomials `fourier n` is dense in `C(AddCircle T, ℂ)`. -/\ntheorem span_fourier_closure_eq_top : (span ℂ (range <| @fourier T)).topologicalClosure = ⊤ := by\n  rw [← fourierSubalgebra_coe]\n  exact congr_arg (Subalgebra.toSubmodule <| StarSubalgebra.toSubalgebra ·)\n    fourierSubalgebra_closure_eq_top\n\n"}
{"name":"coeFn_fourierLp","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nn : Int\n⊢ (MeasureTheory.ae AddCircle.haarAddCircle).EventuallyEq ↑↑(fourierLp p n) ⇑(fourier n)","decl":"theorem coeFn_fourierLp (p : ℝ≥0∞) [Fact (1 ≤ p)] (n : ℤ) :\n    @fourierLp T hT p _ n =ᵐ[haarAddCircle] fourier n :=\n  coeFn_toLp haarAddCircle (fourier n)\n\n"}
{"name":"span_fourierLp_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nhp : Ne p Top.top\n⊢ Eq (Submodule.span Complex (Set.range (fourierLp p))).topologicalClosure Top.top","decl":"/-- For each `1 ≤ p < ∞`, the linear span of the monomials `fourier n` is dense in\n`Lp ℂ p haarAddCircle`. -/\ntheorem span_fourierLp_closure_eq_top {p : ℝ≥0∞} [Fact (1 ≤ p)] (hp : p ≠ ∞) :\n    (span ℂ (range (@fourierLp T _ p _))).topologicalClosure = ⊤ := by\n  convert\n    (ContinuousMap.toLp_denseRange ℂ (@haarAddCircle T hT) ℂ hp).topologicalClosure_map_submodule\n      span_fourier_closure_eq_top\n  erw [map_span, range_comp]\n  simp only [ContinuousLinearMap.coe_coe]\n\n"}
{"name":"orthonormal_fourier","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Orthonormal Complex (fourierLp 2)","decl":"/-- The monomials `fourier n` are an orthonormal set with respect to normalised Haar measure. -/\ntheorem orthonormal_fourier : Orthonormal ℂ (@fourierLp T _ 2 _) := by\n  rw [orthonormal_iff_ite]\n  intro i j\n  rw [ContinuousMap.inner_toLp (@haarAddCircle T hT) (fourier i) (fourier j)]\n  simp_rw [← fourier_neg, ← fourier_add]\n  split_ifs with h\n  · simp_rw [h, neg_add_cancel]\n    have : ⇑(@fourier T 0) = (fun _ => 1 : AddCircle T → ℂ) := by ext1; exact fourier_zero\n    rw [this, integral_const, measure_univ, ENNReal.one_toReal, Complex.real_smul,\n      Complex.ofReal_one, mul_one]\n  have hij : -i + j ≠ 0 := by\n    rw [add_comm]\n    exact sub_ne_zero.mpr (Ne.symm h)\n  convert integral_eq_zero_of_add_right_eq_neg (μ := haarAddCircle)\n    (fourier_add_half_inv_index hij hT.elim)\n\n"}
{"name":"fourierCoeff_eq_intervalIntegral","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : AddCircle T → E\nn : Int\na : Real\n⊢ Eq (fourierCoeff f n) (HSMul.hSMul (HDiv.hDiv 1 T) (intervalIntegral (fun x => HSMul.hSMul ((fourier (Neg.neg n)) ↑x) (f ↑x)) a (HAdd.hAdd a T) MeasureTheory.MeasureSpace.volume))","decl":"/-- The Fourier coefficients of a function on `AddCircle T` can be computed as an integral\nover `[a, a + T]`, for any real `a`. -/\ntheorem fourierCoeff_eq_intervalIntegral (f : AddCircle T → E) (n : ℤ) (a : ℝ) :\n    fourierCoeff f n = (1 / T) • ∫ x in a..a + T, @fourier T (-n) x • f x := by\n  have : ∀ x : ℝ, @fourier T (-n) x • f x = (fun z : AddCircle T => @fourier T (-n) z • f z) x := by\n    intro x; rfl\n  -- After https://github.com/leanprover/lean4/pull/3124, we need to add `singlePass := true` to avoid an infinite loop.\n  simp_rw (config := {singlePass := true}) [this]\n  rw [fourierCoeff, AddCircle.intervalIntegral_preimage T a (fun z => _ • _),\n    volume_eq_smul_haarAddCircle, integral_smul_measure, ENNReal.toReal_ofReal hT.out.le,\n    ← smul_assoc, smul_eq_mul, one_div_mul_cancel hT.out.ne', one_smul]\n\n"}
{"name":"fourierCoeff.const_smul","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : AddCircle T → E\nc : Complex\nn : Int\n⊢ Eq (fourierCoeff (HSMul.hSMul c f) n) (HSMul.hSMul c (fourierCoeff f n))","decl":"theorem fourierCoeff.const_smul (f : AddCircle T → E) (c : ℂ) (n : ℤ) :\n    fourierCoeff (c • f :) n = c • fourierCoeff f n := by\n  simp_rw [fourierCoeff, Pi.smul_apply, ← smul_assoc, smul_eq_mul, mul_comm, ← smul_eq_mul,\n    smul_assoc, integral_smul]\n\n"}
{"name":"fourierCoeff.const_mul","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : AddCircle T → Complex\nc : Complex\nn : Int\n⊢ Eq (fourierCoeff (fun x => HMul.hMul c (f x)) n) (HMul.hMul c (fourierCoeff f n))","decl":"theorem fourierCoeff.const_mul (f : AddCircle T → ℂ) (c : ℂ) (n : ℤ) :\n    fourierCoeff (fun x => c * f x) n = c * fourierCoeff f n :=\n  fourierCoeff.const_smul f c n\n\n"}
{"name":"fourierCoeffOn_eq_integral","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"E : Type\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\na b : Real\nf : Real → E\nn : Int\nhab : LT.lt a b\n⊢ Eq (fourierCoeffOn hab f n) (HSMul.hSMul (HDiv.hDiv 1 (HSub.hSub b a)) (intervalIntegral (fun x => HSMul.hSMul ((fourier (Neg.neg n)) ↑x) (f x)) a b MeasureTheory.MeasureSpace.volume))","decl":"theorem fourierCoeffOn_eq_integral {a b : ℝ} (f : ℝ → E) (n : ℤ) (hab : a < b) :\n    fourierCoeffOn hab f n =\n      (1 / (b - a)) • ∫ x in a..b, fourier (-n) (x : AddCircle (b - a)) • f x := by\n  haveI := Fact.mk (by linarith : 0 < b - a)\n  rw [fourierCoeffOn, fourierCoeff_eq_intervalIntegral _ _ a, add_sub, add_sub_cancel_left]\n  congr 1\n  simp_rw [intervalIntegral.integral_of_le hab.le]\n  refine setIntegral_congr_fun measurableSet_Ioc fun x hx => ?_\n  rw [liftIoc_coe_apply]\n  rwa [add_sub, add_sub_cancel_left]\n\n"}
{"name":"fourierCoeffOn.const_smul","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"E : Type\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\na b : Real\nf : Real → E\nc : Complex\nn : Int\nhab : LT.lt a b\n⊢ Eq (fourierCoeffOn hab (HSMul.hSMul c f) n) (HSMul.hSMul c (fourierCoeffOn hab f n))","decl":"theorem fourierCoeffOn.const_smul {a b : ℝ} (f : ℝ → E) (c : ℂ) (n : ℤ) (hab : a < b) :\n    fourierCoeffOn hab (c • f) n = c • fourierCoeffOn hab f n := by\n  haveI := Fact.mk (by linarith : 0 < b - a)\n  apply fourierCoeff.const_smul\n\n"}
{"name":"fourierCoeffOn.const_mul","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"a b : Real\nf : Real → Complex\nc : Complex\nn : Int\nhab : LT.lt a b\n⊢ Eq (fourierCoeffOn hab (fun x => HMul.hMul c (f x)) n) (HMul.hMul c (fourierCoeffOn hab f n))","decl":"theorem fourierCoeffOn.const_mul {a b : ℝ} (f : ℝ → ℂ) (c : ℂ) (n : ℤ) (hab : a < b) :\n    fourierCoeffOn hab (fun x => c * f x) n = c * fourierCoeffOn hab f n :=\n  fourierCoeffOn.const_smul _ _ _ _\n\n"}
{"name":"fourierCoeff_liftIoc_eq","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\na : Real\nf : Real → Complex\nn : Int\n⊢ Eq (fourierCoeff (AddCircle.liftIoc T a f) n) (fourierCoeffOn ⋯ f n)","decl":"theorem fourierCoeff_liftIoc_eq {a : ℝ} (f : ℝ → ℂ) (n : ℤ) :\n    fourierCoeff (AddCircle.liftIoc T a f) n =\n    fourierCoeffOn (lt_add_of_pos_right a hT.out) f n := by\n  rw [fourierCoeffOn_eq_integral, fourierCoeff_eq_intervalIntegral, add_sub_cancel_left a T]\n  · congr 1\n    refine intervalIntegral.integral_congr_ae (ae_of_all _ fun x hx => ?_)\n    rw [liftIoc_coe_apply]\n    rwa [uIoc_of_le (lt_add_of_pos_right a hT.out).le] at hx\n\n"}
{"name":"fourierCoeff_liftIco_eq","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\na : Real\nf : Real → Complex\nn : Int\n⊢ Eq (fourierCoeff (AddCircle.liftIco T a f) n) (fourierCoeffOn ⋯ f n)","decl":"theorem fourierCoeff_liftIco_eq {a : ℝ} (f : ℝ → ℂ) (n : ℤ) :\n    fourierCoeff (AddCircle.liftIco T a f) n =\n    fourierCoeffOn (lt_add_of_pos_right a hT.out) f n := by\n  rw [fourierCoeffOn_eq_integral, fourierCoeff_eq_intervalIntegral _ _ a, add_sub_cancel_left a T]\n  congr 1\n  simp_rw [intervalIntegral.integral_of_le (lt_add_of_pos_right a hT.out).le]\n  iterate 2 rw [integral_Ioc_eq_integral_Ioo]\n  refine setIntegral_congr_fun measurableSet_Ioo fun x hx => ?_\n  rw [liftIco_coe_apply (Ioo_subset_Ico_self hx)]\n\n"}
{"name":"coe_fourierBasis","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Eq (fun i => fourierBasis.repr.symm (lp.single 2 i 1)) (fourierLp 2)","decl":"/-- The elements of the Hilbert basis `fourierBasis` are the functions `fourierLp 2`, i.e. the\nmonomials `fourier n` on the circle considered as elements of `L²`. -/\n@[simp]\ntheorem coe_fourierBasis : ⇑(@fourierBasis T hT) = @fourierLp T hT 2 _ :=\n  HilbertBasis.coe_mk _ _\n\n"}
{"name":"fourierBasis_repr","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 AddCircle.haarAddCircle) x\ni : Int\n⊢ Eq (↑(fourierBasis.repr f) i) (fourierCoeff (↑↑f) i)","decl":"/-- Under the isometric isomorphism `fourierBasis` from `Lp ℂ 2 haarAddCircle` to `ℓ²(ℤ, ℂ)`, the\n`i`-th coefficient is `fourierCoeff f i`, i.e., the integral over `AddCircle T` of\n`fun t => fourier (-i) t * f t` with respect to the Haar measure of total mass 1. -/\ntheorem fourierBasis_repr (f : Lp ℂ 2 <| @haarAddCircle T hT) (i : ℤ) :\n    fourierBasis.repr f i = fourierCoeff f i := by\n  trans ∫ t : AddCircle T, conj ((@fourierLp T hT 2 _ i : AddCircle T → ℂ) t) * f t ∂haarAddCircle\n  · rw [fourierBasis.repr_apply_apply f i, MeasureTheory.L2.inner_def, coe_fourierBasis]\n    simp only [RCLike.inner_apply]\n  · apply integral_congr_ae\n    filter_upwards [coeFn_fourierLp 2 i] with _ ht\n    rw [ht, ← fourier_neg, smul_eq_mul]\n\n"}
{"name":"hasSum_fourier_series_L2","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 AddCircle.haarAddCircle) x\n⊢ HasSum (fun i => HSMul.hSMul (fourierCoeff (↑↑f) i) (fourierLp 2 i)) f","decl":"/-- The Fourier series of an `L2` function `f` sums to `f`, in the `L²` space of `AddCircle T`. -/\ntheorem hasSum_fourier_series_L2 (f : Lp ℂ 2 <| @haarAddCircle T hT) :\n    HasSum (fun i => fourierCoeff f i • fourierLp 2 i) f := by\n  simp_rw [← fourierBasis_repr]; rw [← coe_fourierBasis]\n  exact HilbertBasis.hasSum_repr fourierBasis f\n\n"}
{"name":"tsum_sq_fourierCoeff","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 AddCircle.haarAddCircle) x\n⊢ Eq (tsum fun i => HPow.hPow (Norm.norm (fourierCoeff (↑↑f) i)) 2) (MeasureTheory.integral AddCircle.haarAddCircle fun t => HPow.hPow (Norm.norm (↑↑f t)) 2)","decl":"/-- **Parseval's identity**: for an `L²` function `f` on `AddCircle T`, the sum of the squared\nnorms of the Fourier coefficients equals the `L²` norm of `f`. -/\ntheorem tsum_sq_fourierCoeff (f : Lp ℂ 2 <| @haarAddCircle T hT) :\n    ∑' i : ℤ, ‖fourierCoeff f i‖ ^ 2 = ∫ t : AddCircle T, ‖f t‖ ^ 2 ∂haarAddCircle := by\n  simp_rw [← fourierBasis_repr]\n  have H₁ : ‖fourierBasis.repr f‖ ^ 2 = ∑' i, ‖fourierBasis.repr f i‖ ^ 2 := by\n    apply_mod_cast lp.norm_rpow_eq_tsum ?_ (fourierBasis.repr f)\n    norm_num\n  have H₂ : ‖fourierBasis.repr f‖ ^ 2 = ‖f‖ ^ 2 := by simp\n  have H₃ := congr_arg RCLike.re (@L2.inner_def (AddCircle T) ℂ ℂ _ _ _ _ _ f f)\n  rw [← integral_re] at H₃\n  · simp only [← norm_sq_eq_inner] at H₃\n    rw [← H₁, H₂, H₃]\n  · exact L2.integrable_inner f f\n\n"}
{"name":"fourierCoeff_toLp","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : ContinuousMap (AddCircle T) Complex\nn : Int\n⊢ Eq (fourierCoeff (↑↑((ContinuousMap.toLp 2 AddCircle.haarAddCircle Complex) f)) n) (fourierCoeff (⇑f) n)","decl":"theorem fourierCoeff_toLp (n : ℤ) :\n    fourierCoeff (toLp (E := ℂ) 2 haarAddCircle ℂ f) n = fourierCoeff f n :=\n  integral_congr_ae (Filter.EventuallyEq.mul (Filter.Eventually.of_forall (by tauto))\n    (ContinuousMap.coeFn_toAEEqFun haarAddCircle f))\n\n"}
{"name":"hasSum_fourier_series_of_summable","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : ContinuousMap (AddCircle T) Complex\nh : Summable (fourierCoeff ⇑f)\n⊢ HasSum (fun i => HSMul.hSMul (fourierCoeff (⇑f) i) (fourier i)) f","decl":"/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\nuniformly to `f`. -/\ntheorem hasSum_fourier_series_of_summable (h : Summable (fourierCoeff f)) :\n    HasSum (fun i => fourierCoeff f i • fourier i) f := by\n  have sum_L2 := hasSum_fourier_series_L2 (toLp (E := ℂ) 2 haarAddCircle ℂ f)\n  simp_rw [fourierCoeff_toLp] at sum_L2\n  refine ContinuousMap.hasSum_of_hasSum_Lp (.of_norm ?_) sum_L2\n  simp_rw [norm_smul, fourier_norm, mul_one]\n  exact h.norm\n\n"}
{"name":"has_pointwise_sum_fourier_series_of_summable","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nf : ContinuousMap (AddCircle T) Complex\nh : Summable (fourierCoeff ⇑f)\nx : AddCircle T\n⊢ HasSum (fun i => HSMul.hSMul (fourierCoeff (⇑f) i) ((fourier i) x)) (f x)","decl":"/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series of `f`\nconverges everywhere pointwise to `f`. -/\ntheorem has_pointwise_sum_fourier_series_of_summable (h : Summable (fourierCoeff f))\n    (x : AddCircle T) : HasSum (fun i => fourierCoeff f i • fourier i x) (f x) := by\n  convert (ContinuousMap.evalCLM ℂ x).hasSum (hasSum_fourier_series_of_summable h)\n\n"}
{"name":"hasDerivAt_fourier","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : Real\n⊢ HasDerivAt (fun y => (fourier n) ↑y) (HMul.hMul (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑n) ↑T) ((fourier n) ↑x)) x","decl":"theorem hasDerivAt_fourier (n : ℤ) (x : ℝ) :\n    HasDerivAt (fun y : ℝ => fourier n (y : AddCircle T))\n      (2 * π * I * n / T * fourier n (x : AddCircle T)) x := by\n  simp_rw [fourier_coe_apply]\n  refine (?_ : HasDerivAt (fun y => exp (2 * π * I * n * y / T)) _ _).comp_ofReal\n  rw [(fun α β => by ring : ∀ α β : ℂ, α * exp β = exp β * α)]\n  refine (hasDerivAt_exp _).comp (x : ℂ) ?_\n  convert hasDerivAt_mul_const (2 * ↑π * I * ↑n / T) using 1\n  ext1 y; ring\n\n"}
{"name":"hasDerivAt_fourier_neg","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nn : Int\nx : Real\n⊢ HasDerivAt (fun y => (fourier (Neg.neg n)) ↑y) (HMul.hMul (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑n) ↑T) ((fourier (Neg.neg n)) ↑x)) x","decl":"theorem hasDerivAt_fourier_neg (n : ℤ) (x : ℝ) :\n    HasDerivAt (fun y : ℝ => fourier (-n) (y : AddCircle T))\n      (-2 * π * I * n / T * fourier (-n) (x : AddCircle T)) x := by\n  simpa using hasDerivAt_fourier T (-n) x\n\n"}
{"name":"has_antideriv_at_fourier_neg","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nn : Int\nhn : Ne n 0\nx : Real\n⊢ HasDerivAt (fun y => HMul.hMul (HDiv.hDiv (↑T) (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑n)) ((fourier (Neg.neg n)) ↑y)) ((fourier (Neg.neg n)) ↑x) x","decl":"theorem has_antideriv_at_fourier_neg (hT : Fact (0 < T)) {n : ℤ} (hn : n ≠ 0) (x : ℝ) :\n    HasDerivAt (fun y : ℝ => (T : ℂ) / (-2 * π * I * n) * fourier (-n) (y : AddCircle T))\n      (fourier (-n) (x : AddCircle T)) x := by\n  convert (hasDerivAt_fourier_neg T n x).div_const (-2 * π * I * n / T) using 1\n  · ext1 y; rw [div_div_eq_mul_div]; ring\n  · simp [mul_div_cancel_left₀, hn, (Fact.out : 0 < T).ne', Real.pi_pos.ne']\n\n"}
{"name":"fourierCoeffOn_of_hasDeriv_right","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"a b : Real\nhab : LT.lt a b\nf f' : Real → Complex\nn : Int\nhn : Ne n 0\nhf : ContinuousOn f (Set.uIcc a b)\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo (Min.min a b) (Max.max a b)) x → HasDerivWithinAt f (f' x) (Set.Ioi x) x\nhf' : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b\n⊢ Eq (fourierCoeffOn hab f n) (HMul.hMul (HDiv.hDiv 1 (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑n)) (HSub.hSub (HMul.hMul ((fourier (Neg.neg n)) ↑a) (HSub.hSub (f b) (f a))) (HMul.hMul (HSub.hSub ↑b ↑a) (fourierCoeffOn hab f' n))))","decl":"/-- Express Fourier coefficients of `f` on an interval in terms of those of its derivative. -/\ntheorem fourierCoeffOn_of_hasDeriv_right {a b : ℝ} (hab : a < b) {f f' : ℝ → ℂ}\n    {n : ℤ} (hn : n ≠ 0)\n    (hf : ContinuousOn f [[a, b]])\n    (hff' : ∀ x, x ∈ Ioo (min a b) (max a b) → HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : IntervalIntegrable f' volume a b) :\n    fourierCoeffOn hab f n = 1 / (-2 * π * I * n) *\n      (fourier (-n) (a : AddCircle (b - a)) * (f b - f a) - (b - a) * fourierCoeffOn hab f' n) := by\n  rw [← ofReal_sub]\n  have hT : Fact (0 < b - a) := ⟨by linarith⟩\n  simp_rw [fourierCoeffOn_eq_integral, smul_eq_mul, real_smul, ofReal_div, ofReal_one]\n  conv => pattern (occs := 1 2 3) fourier _ _ * _ <;> (rw [mul_comm])\n  rw [integral_mul_deriv_eq_deriv_mul_of_hasDeriv_right hf\n    (fun x _ ↦ has_antideriv_at_fourier_neg hT hn x |>.continuousAt |>.continuousWithinAt) hff'\n    (fun x _ ↦ has_antideriv_at_fourier_neg hT hn x |>.hasDerivWithinAt) hf'\n    (((map_continuous (fourier (-n))).comp (AddCircle.continuous_mk' _)).intervalIntegrable _ _)]\n  have : ∀ u v w : ℂ, u * ((b - a : ℝ) / v * w) = (b - a : ℝ) / v * (u * w) := by intros; ring\n  conv in intervalIntegral _ _ _ _ => congr; ext; rw [this]\n  rw [(by ring : ((b - a : ℝ) : ℂ) / (-2 * π * I * n) = ((b - a : ℝ) : ℂ) * (1 / (-2 * π * I * n)))]\n  have s2 : (b : AddCircle (b - a)) = (a : AddCircle (b - a)) := by\n    simpa using coe_add_period (b - a) a\n  rw [s2, integral_const_mul, ← sub_mul, mul_sub, mul_sub]\n  congr 1\n  · conv_lhs => rw [mul_comm, mul_div, mul_one]\n    rw [div_eq_iff (ofReal_ne_zero.mpr hT.out.ne')]\n    ring\n  · ring\n\n"}
{"name":"fourierCoeffOn_of_hasDerivAt_Ioo","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"a b : Real\nhab : LT.lt a b\nf f' : Real → Complex\nn : Int\nhn : Ne n 0\nhf : ContinuousOn f (Set.uIcc a b)\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo (Min.min a b) (Max.max a b)) x → HasDerivAt f (f' x) x\nhf' : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b\n⊢ Eq (fourierCoeffOn hab f n) (HMul.hMul (HDiv.hDiv 1 (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑n)) (HSub.hSub (HMul.hMul ((fourier (Neg.neg n)) ↑a) (HSub.hSub (f b) (f a))) (HMul.hMul (HSub.hSub ↑b ↑a) (fourierCoeffOn hab f' n))))","decl":"/-- Express Fourier coefficients of `f` on an interval in terms of those of its derivative. -/\ntheorem fourierCoeffOn_of_hasDerivAt_Ioo {a b : ℝ} (hab : a < b) {f f' : ℝ → ℂ}\n    {n : ℤ} (hn : n ≠ 0)\n    (hf : ContinuousOn f [[a, b]])\n    (hff' : ∀ x, x ∈ Ioo (min a b) (max a b) → HasDerivAt f (f' x) x)\n    (hf' : IntervalIntegrable f' volume a b) :\n    fourierCoeffOn hab f n = 1 / (-2 * π * I * n) *\n      (fourier (-n) (a : AddCircle (b - a)) * (f b - f a) - (b - a) * fourierCoeffOn hab f' n) :=\n  fourierCoeffOn_of_hasDeriv_right hab hn hf (fun x hx ↦ hff' x hx |>.hasDerivWithinAt) hf'\n\n"}
{"name":"fourierCoeffOn_of_hasDerivAt","module":"Mathlib.Analysis.Fourier.AddCircle","initialProofState":"a b : Real\nhab : LT.lt a b\nf f' : Real → Complex\nn : Int\nhn : Ne n 0\nhf : ∀ (x : Real), Membership.mem (Set.uIcc a b) x → HasDerivAt f (f' x) x\nhf' : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b\n⊢ Eq (fourierCoeffOn hab f n) (HMul.hMul (HDiv.hDiv 1 (HMul.hMul (HMul.hMul (HMul.hMul (-2) ↑Real.pi) Complex.I) ↑n)) (HSub.hSub (HMul.hMul ((fourier (Neg.neg n)) ↑a) (HSub.hSub (f b) (f a))) (HMul.hMul (HSub.hSub ↑b ↑a) (fourierCoeffOn hab f' n))))","decl":"/-- Express Fourier coefficients of `f` on an interval in terms of those of its derivative. -/\ntheorem fourierCoeffOn_of_hasDerivAt {a b : ℝ} (hab : a < b) {f f' : ℝ → ℂ} {n : ℤ} (hn : n ≠ 0)\n    (hf : ∀ x, x ∈ [[a, b]] → HasDerivAt f (f' x) x) (hf' : IntervalIntegrable f' volume a b) :\n    fourierCoeffOn hab f n = 1 / (-2 * π * I * n) *\n      (fourier (-n) (a : AddCircle (b - a)) * (f b - f a) - (b - a) * fourierCoeffOn hab f' n) :=\n  fourierCoeffOn_of_hasDerivAt_Ioo hab hn\n    (fun x hx ↦ hf x hx |>.continuousAt.continuousWithinAt)\n    (fun x hx ↦ hf x <| mem_Icc_of_Ioo hx)\n    hf'\n\n"}
