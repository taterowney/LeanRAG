{"name":"CategoryTheory.Iso.eHomCongr_hom","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\n⊢ Eq (CategoryTheory.Iso.eHomCongr V α β).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V α.inv Y) (CategoryTheory.eHomWhiskerLeft V X₁ β.hom))","decl":"/-- Given isomorphisms `α : X ≅ X₁` and `β : Y ≅ Y₁` in `C`, we can construct\nan isomorphism between `V` objects `X ⟶[V] Y` and `X₁ ⟶[V] Y₁`. -/\n@[simps]\ndef eHomCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) :\n    (X ⟶[V] Y) ≅ (X₁ ⟶[V] Y₁) where\n  hom := eHomWhiskerRight V α.inv Y ≫ eHomWhiskerLeft V X₁ β.hom\n  inv := eHomWhiskerRight V α.hom Y₁ ≫ eHomWhiskerLeft V X β.inv\n  hom_inv_id := by\n    rw [← eHom_whisker_exchange]\n    slice_lhs 2 3 => rw [← eHomWhiskerRight_comp]\n    simp [← eHomWhiskerLeft_comp]\n  inv_hom_id := by\n    rw [← eHom_whisker_exchange]\n    slice_lhs 2 3 => rw [← eHomWhiskerRight_comp]\n    simp [← eHomWhiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_inv","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\n⊢ Eq (CategoryTheory.Iso.eHomCongr V α β).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V α.hom Y₁) (CategoryTheory.eHomWhiskerLeft V X β.inv))","decl":"/-- Given isomorphisms `α : X ≅ X₁` and `β : Y ≅ Y₁` in `C`, we can construct\nan isomorphism between `V` objects `X ⟶[V] Y` and `X₁ ⟶[V] Y₁`. -/\n@[simps]\ndef eHomCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) :\n    (X ⟶[V] Y) ≅ (X₁ ⟶[V] Y₁) where\n  hom := eHomWhiskerRight V α.inv Y ≫ eHomWhiskerLeft V X₁ β.hom\n  inv := eHomWhiskerRight V α.hom Y₁ ≫ eHomWhiskerLeft V X β.inv\n  hom_inv_id := by\n    rw [← eHom_whisker_exchange]\n    slice_lhs 2 3 => rw [← eHomWhiskerRight_comp]\n    simp [← eHomWhiskerLeft_comp]\n  inv_hom_id := by\n    rw [← eHom_whisker_exchange]\n    slice_lhs 2 3 => rw [← eHomWhiskerRight_comp]\n    simp [← eHomWhiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_refl","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.Iso.eHomCongr V (CategoryTheory.Iso.refl X) (CategoryTheory.Iso.refl Y)) (CategoryTheory.Iso.refl (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"lemma eHomCongr_refl (X Y : C) :\n    eHomCongr V (Iso.refl X) (Iso.refl Y) = Iso.refl (X ⟶[V] Y) := by aesop\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_trans","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX₁ Y₁ X₂ Y₂ X₃ Y₃ : C\nα₁ : CategoryTheory.Iso X₁ X₂\nβ₁ : CategoryTheory.Iso Y₁ Y₂\nα₂ : CategoryTheory.Iso X₂ X₃\nβ₂ : CategoryTheory.Iso Y₂ Y₃\n⊢ Eq (CategoryTheory.Iso.eHomCongr V (α₁.trans α₂) (β₁.trans β₂)) ((CategoryTheory.Iso.eHomCongr V α₁ β₁).trans (CategoryTheory.Iso.eHomCongr V α₂ β₂))","decl":"lemma eHomCongr_trans {X₁ Y₁ X₂ Y₂ X₃ Y₃ : C} (α₁ : X₁ ≅ X₂) (β₁ : Y₁ ≅ Y₂)\n    (α₂ : X₂ ≅ X₃) (β₂ : Y₂ ≅ Y₃) :\n    eHomCongr V (α₁ ≪≫ α₂) (β₁ ≪≫ β₂) =\n      eHomCongr V α₁ β₁ ≪≫ eHomCongr V α₂ β₂ := by\n  ext; simp [eHom_whisker_exchange_assoc]\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_symm","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\n⊢ Eq (CategoryTheory.Iso.eHomCongr V α β).symm (CategoryTheory.Iso.eHomCongr V α.symm β.symm)","decl":"lemma eHomCongr_symm {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) :\n    (eHomCongr V α β).symm = eHomCongr V α.symm β.symm := rfl\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z✝ X₁ Y₁ Z₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nγ : CategoryTheory.Iso Z✝ Z₁\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X₁ Z₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Iso.eHomCongr V α γ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) f) (CategoryTheory.Iso.eHomCongr V α β).hom) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X₁ Y₁) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) g) (CategoryTheory.Iso.eHomCongr V β γ).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X₁ Y₁ Z₁) h))))","decl":"/-- `eHomCongr` respects composition of morphisms. Recall that for any\ncomposable pair of arrows `f : X ⟶ Y` and `g : Y ⟶ Z` in `C`, the composite\n`f ≫ g` in `C` defines a morphism `𝟙_ V ⟶ (X ⟶[V] Z)` in `V`. Composing with\nthe isomorphism `eHomCongr V α γ` yields a morphism in `V` that can be factored\nthrough the enriched composition map as shown:\n`𝟙_ V ⟶ 𝟙_ V ⊗ 𝟙_ V ⟶ (X₁ ⟶[V] Y₁) ⊗ (Y₁ ⟶[V] Z₁) ⟶ (X₁ ⟶[V] Z₁)`. -/\n@[reassoc]\nlemma eHomCongr_comp {X Y Z X₁ Y₁ Z₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) (γ : Z ≅ Z₁)\n    (f : X ⟶ Y) (g : Y ⟶ Z) :\n    eHomEquiv V (f ≫ g) ≫ (eHomCongr V α γ).hom =\n      (λ_ _).inv ≫ (eHomEquiv V f ≫ (eHomCongr V α β).hom) ▷ _ ≫\n        _ ◁ (eHomEquiv V g ≫ (eHomCongr V β γ).hom) ≫ eComp V X₁ Y₁ Z₁ := by\n  simp only [eHomCongr, MonoidalCategory.whiskerRight_id, assoc,\n    MonoidalCategory.whiskerLeft_comp]\n  rw [rightUnitor_inv_naturality_assoc, rightUnitor_inv_naturality_assoc,\n    rightUnitor_inv_naturality_assoc, hom_inv_id_assoc, ← whisker_exchange_assoc,\n    ← whisker_exchange_assoc, ← eComp_eHomWhiskerLeft, eHom_whisker_cancel_assoc,\n    ← eComp_eHomWhiskerRight_assoc, ← tensorHom_def_assoc,\n    ← eHomEquiv_comp_assoc]\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_comp","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z X₁ Y₁ Z₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nγ : CategoryTheory.Iso Z Z₁\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Iso.eHomCongr V α γ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) f) (CategoryTheory.Iso.eHomCongr V α β).hom) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X₁ Y₁) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) g) (CategoryTheory.Iso.eHomCongr V β γ).hom)) (CategoryTheory.eComp V X₁ Y₁ Z₁))))","decl":"/-- `eHomCongr` respects composition of morphisms. Recall that for any\ncomposable pair of arrows `f : X ⟶ Y` and `g : Y ⟶ Z` in `C`, the composite\n`f ≫ g` in `C` defines a morphism `𝟙_ V ⟶ (X ⟶[V] Z)` in `V`. Composing with\nthe isomorphism `eHomCongr V α γ` yields a morphism in `V` that can be factored\nthrough the enriched composition map as shown:\n`𝟙_ V ⟶ 𝟙_ V ⊗ 𝟙_ V ⟶ (X₁ ⟶[V] Y₁) ⊗ (Y₁ ⟶[V] Z₁) ⟶ (X₁ ⟶[V] Z₁)`. -/\n@[reassoc]\nlemma eHomCongr_comp {X Y Z X₁ Y₁ Z₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) (γ : Z ≅ Z₁)\n    (f : X ⟶ Y) (g : Y ⟶ Z) :\n    eHomEquiv V (f ≫ g) ≫ (eHomCongr V α γ).hom =\n      (λ_ _).inv ≫ (eHomEquiv V f ≫ (eHomCongr V α β).hom) ▷ _ ≫\n        _ ◁ (eHomEquiv V g ≫ (eHomCongr V β γ).hom) ≫ eComp V X₁ Y₁ Z₁ := by\n  simp only [eHomCongr, MonoidalCategory.whiskerRight_id, assoc,\n    MonoidalCategory.whiskerLeft_comp]\n  rw [rightUnitor_inv_naturality_assoc, rightUnitor_inv_naturality_assoc,\n    rightUnitor_inv_naturality_assoc, hom_inv_id_assoc, ← whisker_exchange_assoc,\n    ← whisker_exchange_assoc, ← eComp_eHomWhiskerLeft, eHom_whisker_cancel_assoc,\n    ← eComp_eHomWhiskerRight_assoc, ← tensorHom_def_assoc,\n    ← eHomEquiv_comp_assoc]\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_inv_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z✝ X₁ Y₁ Z₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nγ : CategoryTheory.Iso Z✝ Z₁\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom Y₁ Z₁\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Iso.eHomCongr V α γ).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) f) (CategoryTheory.Iso.eHomCongr V α β).inv) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) g) (CategoryTheory.Iso.eHomCongr V β γ).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) h))))","decl":"/-- The inverse map defined by `eHomCongr` respects composition of morphisms. -/\n@[reassoc]\nlemma eHomCongr_inv_comp {X Y Z X₁ Y₁ Z₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁)\n    (γ : Z ≅ Z₁) (f : X₁ ⟶ Y₁) (g : Y₁ ⟶ Z₁) :\n    eHomEquiv V (f ≫ g) ≫ (eHomCongr V α γ).inv =\n      (λ_ _).inv ≫ (eHomEquiv V f ≫ (eHomCongr V α β).inv) ▷ _ ≫\n        _ ◁ (eHomEquiv V g ≫ (eHomCongr V β γ).inv) ≫ eComp V X Y Z :=\n  eHomCongr_comp V α.symm β.symm γ.symm f g\n\n"}
{"name":"CategoryTheory.Iso.eHomCongr_inv_comp","module":"Mathlib.CategoryTheory.Enriched.HomCongr","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z X₁ Y₁ Z₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nγ : CategoryTheory.Iso Z Z₁\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom Y₁ Z₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Iso.eHomCongr V α γ).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) f) (CategoryTheory.Iso.eHomCongr V α β).inv) CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) g) (CategoryTheory.Iso.eHomCongr V β γ).inv)) (CategoryTheory.eComp V X Y Z))))","decl":"/-- The inverse map defined by `eHomCongr` respects composition of morphisms. -/\n@[reassoc]\nlemma eHomCongr_inv_comp {X Y Z X₁ Y₁ Z₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁)\n    (γ : Z ≅ Z₁) (f : X₁ ⟶ Y₁) (g : Y₁ ⟶ Z₁) :\n    eHomEquiv V (f ≫ g) ≫ (eHomCongr V α γ).inv =\n      (λ_ _).inv ≫ (eHomEquiv V f ≫ (eHomCongr V α β).inv) ▷ _ ≫\n        _ ◁ (eHomEquiv V g ≫ (eHomCongr V β γ).inv) ≫ eComp V X Y Z :=\n  eHomCongr_comp V α.symm β.symm γ.symm f g\n\n"}
