{"name":"CategoryTheory.Functor.mapConnectedComponents_mk","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J K\nj : J\n⊢ Eq (F.mapConnectedComponents (Quotient.mk (CategoryTheory.Zigzag.setoid J) j)) (Quotient.mk (CategoryTheory.Zigzag.setoid K) (F.obj j))","decl":"@[simp]\nlemma Functor.mapConnectedComponents_mk {K : Type u₂} [Category.{v₂} K] (F : J ⥤ K) (j : J) :\n    F.mapConnectedComponents (Quotient.mk _ j) = Quotient.mk _ (F.obj j) := rfl\n\n"}
{"name":"CategoryTheory.Component.ι_obj","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\nself : CategoryTheory.FullSubcategory fun k => Eq (Quotient.mk'' k) j\n⊢ Eq ((CategoryTheory.Component.ι j).obj self) self.obj","decl":"/-- The inclusion functor from a connected component to the whole category. -/\n@[simps!]\ndef Component.ι (j : ConnectedComponents J) : Component j ⥤ J :=\n  fullSubcategoryInclusion _\n\n"}
{"name":"CategoryTheory.Component.ι_map","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\nX✝ Y✝ : CategoryTheory.InducedCategory J CategoryTheory.FullSubcategory.obj\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Component.ι j).map f) f","decl":"/-- The inclusion functor from a connected component to the whole category. -/\n@[simps!]\ndef Component.ι (j : ConnectedComponents J) : Component j ⥤ J :=\n  fullSubcategoryInclusion _\n\n"}
{"name":"CategoryTheory.instFullComponentι","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\n⊢ (CategoryTheory.Component.ι j).Full","decl":"instance {j : ConnectedComponents J} : Functor.Full (Component.ι j) :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.instFaithfulComponentι","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\n⊢ (CategoryTheory.Component.ι j).Faithful","decl":"instance {j : ConnectedComponents J} : Functor.Faithful (Component.ι j) :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.instNonemptyComponent","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\n⊢ Nonempty (CategoryTheory.Component j)","decl":"/-- Each connected component of the category is nonempty. -/\ninstance (j : ConnectedComponents J) : Nonempty (Component j) := by\n  induction j using Quotient.inductionOn'\n  exact ⟨⟨_, rfl⟩⟩\n\n"}
{"name":"CategoryTheory.instIsConnectedComponent","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\n⊢ CategoryTheory.IsConnected (CategoryTheory.Component j)","decl":"/-- Each connected component of the category is connected. -/\ninstance (j : ConnectedComponents J) : IsConnected (Component j) := by\n  -- Show it's connected by constructing a zigzag (in `Component j`) between any two objects\n  apply isConnected_of_zigzag\n  rintro ⟨j₁, hj₁⟩ ⟨j₂, rfl⟩\n  -- We know that the underlying objects j₁ j₂ have some zigzag between them in `J`\n  have h₁₂ : Zigzag j₁ j₂ := Quotient.exact' hj₁\n  -- Get an explicit zigzag as a list\n  rcases List.exists_chain_of_relationReflTransGen h₁₂ with ⟨l, hl₁, hl₂⟩\n  -- Everything which has a zigzag to j₂ can be lifted to the same component as `j₂`.\n  let f : ∀ x, Zigzag x j₂ → Component (Quotient.mk'' j₂) := fun x h => ⟨x, Quotient.sound' h⟩\n  -- Everything in our chosen zigzag from `j₁` to `j₂` has a zigzag to `j₂`.\n  have hf : ∀ a : J, a ∈ l → Zigzag a j₂ := by\n    intro i hi\n    apply hl₁.backwards_induction (fun t => Zigzag t j₂) _ hl₂ _ _ _ (List.mem_of_mem_tail hi)\n    · intro j k\n      apply Relation.ReflTransGen.head\n    · apply Relation.ReflTransGen.refl\n  -- Now lift the zigzag from `j₁` to `j₂` in `J` to the same thing in `component j`.\n  refine ⟨l.pmap f hf, ?_, ?_⟩\n  · refine @List.chain_pmap_of_chain _ _ _ _ _ f (fun x y _ _ h => ?_) _ _ hl₁ h₁₂ _\n    exact zag_of_zag_obj (Component.ι _) h\n  · erw [List.getLast_pmap f (j₁ :: l) (by simpa [h₁₂] using hf) (List.cons_ne_nil _ _)]\n    exact FullSubcategory.ext hl₂\n\n"}
{"name":"CategoryTheory.decomposedTo_map","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nX✝ Y✝ : Sigma fun i => CategoryTheory.Component i\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.decomposedTo J).map g) (CategoryTheory.Sigma.descMap CategoryTheory.Component.ι X✝ Y✝ g)","decl":"/-- The forward direction of the equivalence between the decomposed category and the original. -/\n@[simps!]\ndef decomposedTo (J : Type u₁) [Category.{v₁} J] : Decomposed J ⥤ J :=\n  Sigma.desc Component.ι\n\n"}
{"name":"CategoryTheory.decomposedTo_obj","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nX : Sigma fun i => CategoryTheory.Component i\n⊢ Eq ((CategoryTheory.decomposedTo J).obj X) X.snd.obj","decl":"/-- The forward direction of the equivalence between the decomposed category and the original. -/\n@[simps!]\ndef decomposedTo (J : Type u₁) [Category.{v₁} J] : Decomposed J ⥤ J :=\n  Sigma.desc Component.ι\n\n"}
{"name":"CategoryTheory.inclusion_comp_decomposedTo","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.ConnectedComponents J\n⊢ Eq ((CategoryTheory.inclusion j).comp (CategoryTheory.decomposedTo J)) (CategoryTheory.Component.ι j)","decl":"@[simp]\ntheorem inclusion_comp_decomposedTo (j : ConnectedComponents J) :\n    inclusion j ⋙ decomposedTo J = Component.ι j :=\n  rfl\n\n"}
{"name":"CategoryTheory.instFullDecomposedDecomposedTo","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ (CategoryTheory.decomposedTo J).Full","decl":"instance : (decomposedTo J).Full where\n  map_surjective := by\n    rintro ⟨j', X, hX⟩ ⟨k', Y, hY⟩ f\n    dsimp at f\n    have : j' = k' := by\n      rw [← hX, ← hY, Quotient.eq'']\n      exact Relation.ReflTransGen.single (Or.inl ⟨f⟩)\n    subst this\n    exact ⟨Sigma.SigmaHom.mk f, rfl⟩\n\n"}
{"name":"CategoryTheory.instFaithfulDecomposedDecomposedTo","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ (CategoryTheory.decomposedTo J).Faithful","decl":"instance : (decomposedTo J).Faithful where\n  map_injective := by\n    rintro ⟨_, j, rfl⟩ ⟨_, k, hY⟩ ⟨f⟩ ⟨_⟩ rfl\n    rfl\n\n"}
{"name":"CategoryTheory.instEssSurjDecomposedDecomposedTo","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ (CategoryTheory.decomposedTo J).EssSurj","decl":"instance : (decomposedTo J).EssSurj where mem_essImage j := ⟨⟨_, j, rfl⟩, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"CategoryTheory.instIsEquivalenceDecomposedDecomposedTo","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ (CategoryTheory.decomposedTo J).IsEquivalence","decl":"instance : (decomposedTo J).IsEquivalence where\n\n"}
{"name":"CategoryTheory.decomposedEquiv_functor","module":"Mathlib.CategoryTheory.ConnectedComponents","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ Eq CategoryTheory.decomposedEquiv.functor (CategoryTheory.decomposedTo J)","decl":"/-- This gives that any category is equivalent to a disjoint union of connected categories. -/\n@[simps! functor]\ndef decomposedEquiv : Decomposed J ≌ J :=\n  (decomposedTo J).asEquivalence\n\n"}
