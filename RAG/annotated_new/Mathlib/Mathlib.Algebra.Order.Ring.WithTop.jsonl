{"name":"WithTop.coe_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : α\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_mul (a b : α) : (↑(a * b) : WithTop α) = a * b := rfl\n\n"}
{"name":"WithTop.mul_top'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : WithTop α\n⊢ Eq (HMul.hMul a Top.top) (ite (Eq a 0) 0 Top.top)","decl":"lemma mul_top' : ∀ (a : WithTop α), a * ⊤ = if a = 0 then 0 else ⊤\n  | (a : α) => if_congr coe_eq_zero.symm rfl rfl\n  | ⊤ => (if_neg top_ne_zero).symm\n\n"}
{"name":"WithTop.mul_top","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : WithTop α\nh : Ne a 0\n⊢ Eq (HMul.hMul a Top.top) Top.top","decl":"@[simp] lemma mul_top (h : a ≠ 0) : a * ⊤ = ⊤ := by rw [mul_top', if_neg h]\n\n"}
{"name":"WithTop.top_mul'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : WithTop α\n⊢ Eq (HMul.hMul Top.top b) (ite (Eq b 0) 0 Top.top)","decl":"lemma top_mul' : ∀ (b : WithTop α), ⊤ * b = if b = 0 then 0 else ⊤\n  | (b : α) => if_congr coe_eq_zero.symm rfl rfl\n  | ⊤ => (if_neg top_ne_zero).symm\n\n"}
{"name":"WithTop.top_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : WithTop α\nhb : Ne b 0\n⊢ Eq (HMul.hMul Top.top b) Top.top","decl":"@[simp] lemma top_mul (hb : b ≠ 0) : ⊤ * b = ⊤ := by rw [top_mul', if_neg hb]\n\n"}
{"name":"WithTop.top_mul_top","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\n⊢ Eq (HMul.hMul Top.top Top.top) Top.top","decl":"@[simp] lemma top_mul_top : (⊤ * ⊤ : WithTop α) = ⊤ := rfl\n\n"}
{"name":"WithTop.mul_def","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithTop α\n⊢ Eq (HMul.hMul a b) (ite (Or (Eq a 0) (Eq b 0)) 0 (WithTop.map₂ (fun x1 x2 => HMul.hMul x1 x2) a b))","decl":"lemma mul_def (a b : WithTop α) :\n    a * b = if a = 0 ∨ b = 0 then 0 else WithTop.map₂ (· * ·) a b := by\n  cases a <;> cases b <;> aesop\n\n"}
{"name":"WithTop.mul_eq_top_iff","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithTop α\n⊢ Iff (Eq (HMul.hMul a b) Top.top) (Or (And (Ne a 0) (Eq b Top.top)) (And (Eq a Top.top) (Ne b 0)))","decl":"lemma mul_eq_top_iff : a * b = ⊤ ↔ a ≠ 0 ∧ b = ⊤ ∨ a = ⊤ ∧ b ≠ 0 := by rw [mul_def]; aesop\n\n"}
{"name":"WithTop.mul_coe_eq_bind","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : α\nhb : Ne b 0\na : WithTop α\n⊢ Eq (HMul.hMul a ↑b) (Option.bind a fun a => Option.some (HMul.hMul a b))","decl":"lemma mul_coe_eq_bind {b : α} (hb : b ≠ 0) : ∀ a, (a * b : WithTop α) = a.bind fun a ↦ ↑(a * b)\n  | ⊤ => by simp [top_mul, hb]; rfl\n  | (a : α) => rfl\n\n"}
{"name":"WithTop.coe_mul_eq_bind","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : α\nha : Ne a 0\nb : WithTop α\n⊢ Eq (HMul.hMul (↑a) b) (Option.bind b fun b => Option.some (HMul.hMul a b))","decl":"lemma coe_mul_eq_bind {a : α} (ha : a ≠ 0) : ∀ b, (a * b : WithTop α) = b.bind fun b ↦ ↑(a * b)\n  | ⊤ => by simp [top_mul, ha]; rfl\n  | (b : α) => rfl\n\n"}
{"name":"WithTop.untop'_zero_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithTop α\n⊢ Eq (WithTop.untop' 0 (HMul.hMul a b)) (HMul.hMul (WithTop.untop' 0 a) (WithTop.untop' 0 b))","decl":"@[simp] lemma untop'_zero_mul (a b : WithTop α) : (a * b).untop' 0 = a.untop' 0 * b.untop' 0 := by\n  by_cases ha : a = 0; · rw [ha, zero_mul, ← coe_zero, untop'_coe, zero_mul]\n  by_cases hb : b = 0; · rw [hb, mul_zero, ← coe_zero, untop'_coe, mul_zero]\n  induction a; · rw [top_mul hb, untop'_top, zero_mul]\n  induction b; · rw [mul_top ha, untop'_top, mul_zero]\n  rw [← coe_mul, untop'_coe, untop'_coe, untop'_coe]\n\n"}
{"name":"WithTop.mul_ne_top","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithTop α\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Ne (HMul.hMul a b) Top.top","decl":"theorem mul_ne_top {a b : WithTop α} (ha : a ≠ ⊤) (hb : b ≠ ⊤) : a * b ≠ ⊤ := by\n  simp [mul_eq_top_iff, *]\n\n"}
{"name":"WithTop.mul_lt_top","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : LT α\na b : WithTop α\nha : LT.lt a Top.top\nhb : LT.lt b Top.top\n⊢ LT.lt (HMul.hMul a b) Top.top","decl":"theorem mul_lt_top [LT α] {a b : WithTop α} (ha : a < ⊤) (hb : b < ⊤) : a * b < ⊤ := by\n  rw [WithTop.lt_top_iff_ne_top] at *\n  exact mul_ne_top ha hb\n\n"}
{"name":"WithTop.mul_lt_top'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : LT α\na b : WithTop α\nha : LT.lt a Top.top\nhb : LT.lt b Top.top\n⊢ LT.lt (HMul.hMul a b) Top.top","decl":"@[deprecated (since := \"2024-08-25\")] alias mul_lt_top' := mul_lt_top\n\n"}
{"name":"WithTop.instNoZeroDivisors","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : NoZeroDivisors α\n⊢ NoZeroDivisors (WithTop α)","decl":"instance instNoZeroDivisors [NoZeroDivisors α] : NoZeroDivisors (WithTop α) := by\n  refine ⟨fun h₁ => Decidable.byContradiction fun h₂ => ?_⟩\n  rw [mul_def, if_neg h₂] at h₁\n  rcases Option.mem_map₂_iff.1 h₁ with ⟨a, b, (rfl : _ = _), (rfl : _ = _), hab⟩\n  exact h₂ ((eq_zero_or_eq_zero_of_mul_eq_zero hab).imp (congr_arg some) (congr_arg some))\n\n"}
{"name":"MonoidWithZeroHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁵ : MulZeroOneClass R\ninst✝⁴ : DecidableEq R\ninst✝³ : Nontrivial R\ninst✝² : MulZeroOneClass S\ninst✝¹ : DecidableEq S\ninst✝ : Nontrivial S\nf : MonoidWithZeroHom R S\nhf : Function.Injective ⇑f\n⊢ Eq (⇑(f.withTopMap hf)) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for `MonoidWithZeroHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.MonoidWithZeroHom.withTopMap {R S : Type*} [MulZeroOneClass R] [DecidableEq R]\n    [Nontrivial R] [MulZeroOneClass S] [DecidableEq S] [Nontrivial S] (f : R →*₀ S)\n    (hf : Function.Injective f) : WithTop R →*₀ WithTop S :=\n  { f.toZeroHom.withTopMap, f.toMonoidHom.toOneHom.withTopMap with\n    toFun := WithTop.map f\n    map_mul' := fun x y => by\n      have : ∀ z, map f z = 0 ↔ z = 0 := fun z =>\n        (Option.map_injective hf).eq_iff' f.toZeroHom.withTopMap.map_zero\n      rcases Decidable.eq_or_ne x 0 with (rfl | hx)\n      · simp\n      rcases Decidable.eq_or_ne y 0 with (rfl | hy)\n      · simp\n      induction' x with x\n      · simp [hy, this]\n      induction' y with y\n      · have : (f x : WithTop S) ≠ 0 := by simpa [hf.eq_iff' (map_zero f)] using hx\n        simp [mul_top hx, mul_top this]\n      · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `simp [← coe_mul]` times out\n        simp only [map_coe, ← coe_mul, map_mul] }\n\n"}
{"name":"WithTop.coe_pow","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MonoidWithZero α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\na : α\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[simp, norm_cast] lemma coe_pow (a : α) (n : ℕ) : (↑(a ^ n) : WithTop α) = a ^ n := rfl\n\n"}
{"name":"WithTop.top_pow","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MonoidWithZero α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\nn : Nat\nn_pos : LT.lt 0 n\n⊢ Eq (HPow.hPow Top.top n) Top.top","decl":"theorem top_pow {n : ℕ} (n_pos : 0 < n) : (⊤ : WithTop α) ^ n = ⊤ :=\n  Nat.le_induction (pow_one _) (fun m _ hm => by rw [pow_succ, hm, top_mul_top]) _\n    (Nat.succ_le_of_lt n_pos)\n\n"}
{"name":"RingHom.withTopMap_apply","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁹ : NonAssocSemiring R\ninst✝⁸ : PartialOrder R\ninst✝⁷ : CanonicallyOrderedAdd R\ninst✝⁶ : DecidableEq R\ninst✝⁵ : Nontrivial R\ninst✝⁴ : NonAssocSemiring S\ninst✝³ : PartialOrder S\ninst✝² : CanonicallyOrderedAdd S\ninst✝¹ : DecidableEq S\ninst✝ : Nontrivial S\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq (⇑(f.withTopMap hf)) (↑(f.toMonoidWithZeroHom.withTopMap hf)).toFun","decl":"/-- A version of `WithTop.map` for `RingHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.RingHom.withTopMap {R S : Type*}\n    [NonAssocSemiring R] [PartialOrder R] [CanonicallyOrderedAdd R]\n    [DecidableEq R] [Nontrivial R]\n    [NonAssocSemiring S] [PartialOrder S] [CanonicallyOrderedAdd S]\n    [DecidableEq S] [Nontrivial S]\n    (f : R →+* S) (hf : Function.Injective f) : WithTop R →+* WithTop S :=\n  {MonoidWithZeroHom.withTopMap f.toMonoidWithZeroHom hf, f.toAddMonoidHom.withTopMap with}\n\n"}
{"name":"WithTop.mul_lt_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝⁴ : DecidableEq α\ninst✝³ : CommSemiring α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : PosMulStrictMono α\na₁ a₂ b₁ b₂ : WithTop α\nha : LT.lt a₁ a₂\nhb : LT.lt b₁ b₂\n⊢ LT.lt (HMul.hMul a₁ b₁) (HMul.hMul a₂ b₂)","decl":"@[gcongr]\nprotected lemma mul_lt_mul (ha : a₁ < a₂) (hb : b₁ < b₂) : a₁ * b₁ < a₂ * b₂ := by\n  have := posMulStrictMono_iff_mulPosStrictMono.1 ‹_›\n  lift a₁ to α using ha.lt_top.ne\n  lift b₁ to α using hb.lt_top.ne\n  obtain rfl | ha₂ := eq_or_ne a₂ ⊤\n  · rw [top_mul (by simpa [bot_eq_zero] using hb.bot_lt.ne')]\n    exact coe_lt_top _\n  obtain rfl | hb₂ := eq_or_ne b₂ ⊤\n  · rw [mul_top (by simpa [bot_eq_zero] using ha.bot_lt.ne')]\n    exact coe_lt_top _\n  lift a₂ to α using ha₂\n  lift b₂ to α using hb₂\n  norm_cast at *\n  obtain rfl | hb₁ := eq_zero_or_pos b₁\n  · rw [mul_zero]\n    exact mul_pos (by simpa [bot_eq_zero] using ha.bot_lt) hb\n  · exact mul_lt_mul ha hb.le hb₁ (zero_le _)\n\n"}
{"name":"WithTop.pow_right_strictMono","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝⁶ : DecidableEq α\ninst✝⁵ : CommSemiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : PosMulStrictMono α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\nn : Nat\na✝ : Ne n 0\n⊢ StrictMono fun a => HPow.hPow a n","decl":"protected lemma pow_right_strictMono : ∀ {n : ℕ}, n ≠ 0 → StrictMono fun a : WithTop α ↦ a ^ n\n  | 0, h => absurd rfl h\n  | 1, _ => by simpa only [pow_one] using strictMono_id\n  | n + 2, _ => fun x y h ↦ by\n    simp_rw [pow_succ _ (n + 1)]\n    exact WithTop.mul_lt_mul (WithTop.pow_right_strictMono n.succ_ne_zero h) h\n\n"}
{"name":"WithTop.pow_lt_pow_left","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝⁶ : DecidableEq α\ninst✝⁵ : CommSemiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : PosMulStrictMono α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\na b : WithTop α\nhab : LT.lt a b\nn : Nat\nhn : Ne n 0\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow b n)","decl":"@[gcongr] protected lemma pow_lt_pow_left (hab : a < b) {n : ℕ} (hn : n ≠ 0) : a ^ n < b ^ n :=\n  WithTop.pow_right_strictMono hn hab\n\n"}
{"name":"WithBot.coe_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : α\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[simp, norm_cast] lemma coe_mul (a b : α) : (↑(a * b) : WithBot α) = a * b := rfl\n\n"}
{"name":"WithBot.mul_bot'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : WithBot α\n⊢ Eq (HMul.hMul a Bot.bot) (ite (Eq a 0) 0 Bot.bot)","decl":"lemma mul_bot' : ∀ (a : WithBot α), a * ⊥ = if a = 0 then 0 else ⊥\n  | (a : α) => if_congr coe_eq_zero.symm rfl rfl\n  | ⊥ => (if_neg bot_ne_zero).symm\n\n"}
{"name":"WithBot.mul_bot","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : WithBot α\nh : Ne a 0\n⊢ Eq (HMul.hMul a Bot.bot) Bot.bot","decl":"@[simp] lemma mul_bot (h : a ≠ 0) : a * ⊥ = ⊥ := by rw [mul_bot', if_neg h]\n\n"}
{"name":"WithBot.bot_mul'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : WithBot α\n⊢ Eq (HMul.hMul Bot.bot b) (ite (Eq b 0) 0 Bot.bot)","decl":"lemma bot_mul' : ∀ (b : WithBot α), ⊥ * b = if b = 0 then 0 else ⊥\n  | (b : α) => if_congr coe_eq_zero.symm rfl rfl\n  | ⊥ => (if_neg bot_ne_zero).symm\n\n"}
{"name":"WithBot.bot_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : WithBot α\nhb : Ne b 0\n⊢ Eq (HMul.hMul Bot.bot b) Bot.bot","decl":"@[simp] lemma bot_mul (hb : b ≠ 0) : ⊥ * b = ⊥ := by rw [bot_mul', if_neg hb]\n\n"}
{"name":"WithBot.bot_mul_bot","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\n⊢ Eq (HMul.hMul Bot.bot Bot.bot) Bot.bot","decl":"@[simp] lemma bot_mul_bot : (⊥ * ⊥ : WithBot α) = ⊥ := rfl\n\n"}
{"name":"WithBot.mul_def","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithBot α\n⊢ Eq (HMul.hMul a b) (ite (Or (Eq a 0) (Eq b 0)) 0 (WithBot.map₂ (fun x1 x2 => HMul.hMul x1 x2) a b))","decl":"lemma mul_def (a b : WithBot α) :\n    a * b = if a = 0 ∨ b = 0 then 0 else WithBot.map₂ (· * ·) a b := by\n  cases a <;> cases b <;> aesop\n\n"}
{"name":"WithBot.mul_eq_bot_iff","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithBot α\n⊢ Iff (Eq (HMul.hMul a b) Bot.bot) (Or (And (Ne a 0) (Eq b Bot.bot)) (And (Eq a Bot.bot) (Ne b 0)))","decl":"lemma mul_eq_bot_iff : a * b = ⊥ ↔ a ≠ 0 ∧ b = ⊥ ∨ a = ⊥ ∧ b ≠ 0 := by rw [mul_def]; aesop\n\n"}
{"name":"WithBot.mul_coe_eq_bind","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\nb : α\nhb : Ne b 0\na : WithBot α\n⊢ Eq (HMul.hMul a ↑b) (Option.bind a fun a => Option.some (HMul.hMul a b))","decl":"lemma mul_coe_eq_bind {b : α} (hb : b ≠ 0) : ∀ a, (a * b : WithBot α) = a.bind fun a ↦ ↑(a * b)\n  | ⊥ => by simp only [ne_eq, coe_eq_zero, hb, not_false_eq_true, bot_mul]; rfl\n  | (a : α) => rfl\n\n"}
{"name":"WithBot.coe_mul_eq_bind","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na : α\nha : Ne a 0\nb : WithBot α\n⊢ Eq (HMul.hMul (↑a) b) (Option.bind b fun b => Option.some (HMul.hMul a b))","decl":"lemma coe_mul_eq_bind {a : α} (ha : a ≠ 0) : ∀ b, (a * b : WithBot α) = b.bind fun b ↦ ↑(a * b)\n  | ⊥ => by simp only [ne_eq, coe_eq_zero, ha, not_false_eq_true, mul_bot]; rfl\n  | (b : α) => rfl\n\n"}
{"name":"WithBot.unbot'_zero_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithBot α\n⊢ Eq (WithBot.unbot' 0 (HMul.hMul a b)) (HMul.hMul (WithBot.unbot' 0 a) (WithBot.unbot' 0 b))","decl":"@[simp]\nlemma unbot'_zero_mul (a b : WithBot α) : (a * b).unbot' 0 = a.unbot' 0 * b.unbot' 0 := by\n  by_cases ha : a = 0; · rw [ha, zero_mul, ← coe_zero, unbot'_coe, zero_mul]\n  by_cases hb : b = 0; · rw [hb, mul_zero, ← coe_zero, unbot'_coe, mul_zero]\n  induction a; · rw [bot_mul hb, unbot'_bot, zero_mul]\n  induction b; · rw [mul_bot ha, unbot'_bot, mul_zero]\n  rw [← coe_mul, unbot'_coe, unbot'_coe, unbot'_coe]\n\n"}
{"name":"WithBot.mul_ne_bot","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : MulZeroClass α\na b : WithBot α\nha : Ne a Bot.bot\nhb : Ne b Bot.bot\n⊢ Ne (HMul.hMul a b) Bot.bot","decl":"theorem mul_ne_bot {a b : WithBot α} (ha : a ≠ ⊥) (hb : b ≠ ⊥) : a * b ≠ ⊥ :=\n  WithTop.mul_ne_top (α := αᵒᵈ) ha hb\n\n"}
{"name":"WithBot.bot_lt_mul","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : LT α\na b : WithBot α\nha : LT.lt Bot.bot a\nhb : LT.lt Bot.bot b\n⊢ LT.lt Bot.bot (HMul.hMul a b)","decl":"theorem bot_lt_mul [LT α] {a b : WithBot α} (ha : ⊥ < a) (hb : ⊥ < b) : ⊥ < a * b :=\n  WithTop.mul_lt_top (α := αᵒᵈ) ha hb\n\n"}
{"name":"WithBot.bot_lt_mul'","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : LT α\na b : WithBot α\nha : LT.lt Bot.bot a\nhb : LT.lt Bot.bot b\n⊢ LT.lt Bot.bot (HMul.hMul a b)","decl":"@[deprecated (since := \"2024-08-25\")] alias bot_lt_mul' := bot_lt_mul\n\n"}
{"name":"WithBot.instNoZeroDivisors","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : MulZeroClass α\ninst✝ : NoZeroDivisors α\n⊢ NoZeroDivisors (WithBot α)","decl":"instance instNoZeroDivisors [NoZeroDivisors α] : NoZeroDivisors (WithBot α) :=\n  WithTop.instNoZeroDivisors\n\n"}
{"name":"WithBot.coe_pow","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MonoidWithZero α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\na : α\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[simp, norm_cast] lemma coe_pow (a : α) (n : ℕ) : (↑(a ^ n) : WithBot α) = a ^ n := rfl\n\n"}
{"name":"WithBot.instPosMulMono","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulMono α\n⊢ PosMulMono (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [PosMulMono α] : PosMulMono (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk]\n    rcases eq_or_ne x 0 with rfl | x0'\n    · simp\n    lift x to α\n    · rintro rfl\n      exact (WithBot.bot_lt_coe (0 : α)).not_le x0\n    induction a\n    · simp_rw [mul_bot x0', bot_le]\n    induction b\n    · exact absurd h (bot_lt_coe _).not_le\n    simp only [← coe_mul, coe_le_coe] at *\n    norm_cast at x0\n    exact mul_le_mul_of_nonneg_left h x0 ⟩\n\n"}
{"name":"WithBot.instMulPosMono","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : MulPosMono α\n⊢ MulPosMono (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [MulPosMono α] : MulPosMono (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk]\n    rcases eq_or_ne x 0 with rfl | x0'\n    · simp\n    lift x to α\n    · rintro rfl\n      exact (WithBot.bot_lt_coe (0 : α)).not_le x0\n    induction a\n    · simp_rw [bot_mul x0', bot_le]\n    induction b\n    · exact absurd h (bot_lt_coe _).not_le\n    simp only [← coe_mul, coe_le_coe] at *\n    norm_cast at x0\n    exact mul_le_mul_of_nonneg_right h x0 ⟩\n\n"}
{"name":"WithBot.instPosMulStrictMono","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulStrictMono α\n⊢ PosMulStrictMono (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [PosMulStrictMono α] : PosMulStrictMono (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk]\n    lift x to α using x0.ne_bot\n    induction b\n    · exact absurd h not_lt_bot\n    induction a\n    · simp_rw [mul_bot x0.ne.symm, ← coe_mul, bot_lt_coe]\n    simp only [← coe_mul, coe_lt_coe] at *\n    norm_cast at x0\n    exact mul_lt_mul_of_pos_left h x0 ⟩\n\n"}
{"name":"WithBot.instMulPosStrictMono","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : MulPosStrictMono α\n⊢ MulPosStrictMono (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [MulPosStrictMono α] : MulPosStrictMono (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk]\n    lift x to α using x0.ne_bot\n    induction b\n    · exact absurd h not_lt_bot\n    induction a\n    · simp_rw [bot_mul x0.ne.symm, ← coe_mul, bot_lt_coe]\n    simp only [← coe_mul, coe_lt_coe] at *\n    norm_cast at x0\n    exact mul_lt_mul_of_pos_right h x0 ⟩\n\n"}
{"name":"WithBot.instPosMulReflectLT","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulReflectLT α\n⊢ PosMulReflectLT (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [PosMulReflectLT α] : PosMulReflectLT (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk] at h\n    rcases eq_or_ne x 0 with rfl | x0'\n    · simp at h\n    lift x to α\n    · rintro rfl\n      exact (WithBot.bot_lt_coe (0 : α)).not_le x0\n    induction b\n    · rw [mul_bot x0'] at h\n      exact absurd h bot_le.not_lt\n    induction a\n    · exact WithBot.bot_lt_coe _\n    simp only [← coe_mul, coe_lt_coe] at *\n    norm_cast at x0\n    exact lt_of_mul_lt_mul_left h x0 ⟩\n\n"}
{"name":"WithBot.instMulPosReflectLT","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : MulPosReflectLT α\n⊢ MulPosReflectLT (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [MulPosReflectLT α] : MulPosReflectLT (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk] at h\n    rcases eq_or_ne x 0 with rfl | x0'\n    · simp at h\n    lift x to α\n    · rintro rfl\n      exact (WithBot.bot_lt_coe (0 : α)).not_le x0\n    induction b\n    · rw [bot_mul x0'] at h\n      exact absurd h bot_le.not_lt\n    induction a\n    · exact WithBot.bot_lt_coe _\n    simp only [← coe_mul, coe_lt_coe] at *\n    norm_cast at x0\n    exact lt_of_mul_lt_mul_right h x0 ⟩\n\n"}
{"name":"WithBot.instPosMulReflectLE","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulReflectLE α\n⊢ PosMulReflectLE (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [PosMulReflectLE α] : PosMulReflectLE (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk] at h\n    lift x to α using x0.ne_bot\n    induction a\n    · exact bot_le\n    induction b\n    · rw [mul_bot x0.ne.symm, ← coe_mul] at h\n      exact absurd h (bot_lt_coe _).not_le\n    simp only [← coe_mul, coe_le_coe] at *\n    norm_cast at x0\n    exact le_of_mul_le_mul_left h x0 ⟩\n\n"}
{"name":"WithBot.instMulPosReflectLE","module":"Mathlib.Algebra.Order.Ring.WithTop","initialProofState":"α : Type u_1\ninst✝³ : DecidableEq α\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : MulPosReflectLE α\n⊢ MulPosReflectLE (WithBot α)","decl":"instance [MulZeroClass α] [Preorder α] [MulPosReflectLE α] : MulPosReflectLE (WithBot α) :=\n  ⟨by\n    intro ⟨x, x0⟩ a b h\n    simp only [Subtype.coe_mk] at h\n    lift x to α using x0.ne_bot\n    induction a\n    · exact bot_le\n    induction b\n    · rw [bot_mul x0.ne.symm, ← coe_mul] at h\n      exact absurd h (bot_lt_coe _).not_le\n    simp only [← coe_mul, coe_le_coe] at *\n    norm_cast at x0\n    exact le_of_mul_le_mul_right h x0 ⟩\n\n"}
