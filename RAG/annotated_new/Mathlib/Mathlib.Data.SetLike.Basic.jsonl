{"name":"SetLike.coe_injective'","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : outParam (Type u_2)\nself : SetLike A B\n⊢ Function.Injective SetLike.coe","decl":"/-- A class to indicate that there is a canonical injection between `A` and `Set B`.\n\nThis has the effect of giving terms of `A` elements of type `B` (through a `Membership`\ninstance) and a compatible coercion to `Type*` as a subtype.\n\nNote: if `SetLike.coe` is a projection, implementers should create a simp lemma such as\n```\n@[simp] lemma mem_carrier {p : MySubobject X} : x ∈ p.carrier ↔ x ∈ (p : Set X) := Iff.rfl\n```\nto normalize terms.\n\nIf you declare an unbundled subclass of `SetLike`, for example:\n```\nclass MulMemClass (S : Type*) (M : Type*) [Mul M] [SetLike S M] where\n  ...\n```\nThen you should *not* repeat the `outParam` declaration so `SetLike` will supply the value instead.\nThis ensures your subclass will not have issues with synthesis of the `[Mul M]` parameter starting\nbefore the value of `M` is known.\n-/\n@[notation_class * carrier Simps.findCoercionArgs]\nclass SetLike (A : Type*) (B : outParam Type*) where\n  /-- The coercion from a term of a `SetLike` to its corresponding `Set`. -/\n  protected coe : A → Set B\n  /-- The coercion from a term of a `SetLike` to its corresponding `Set` is injective. -/\n  protected coe_injective' : Function.Injective coe\n\n"}
{"name":"SetLike.coe_sort_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\n⊢ Eq (↑↑p) (Subtype fun x => Membership.mem p x)","decl":"@[simp, norm_cast]\ntheorem coe_sort_coe : ((p : Set B) : Type _) = p :=\n  rfl\n\n"}
{"name":"SetLike.exists","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nq : (Subtype fun x => Membership.mem p x) → Prop\n⊢ Iff (Exists fun x => q x) (Exists fun x => Exists fun h => q ⟨x, h⟩)","decl":"protected theorem «exists» {q : p → Prop} : (∃ x, q x) ↔ ∃ (x : B) (h : x ∈ p), q ⟨x, ‹_›⟩ :=\n  SetCoe.exists\n\n"}
{"name":"SetLike.forall","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nq : (Subtype fun x => Membership.mem p x) → Prop\n⊢ Iff (∀ (x : Subtype fun x => Membership.mem p x), q x) (∀ (x : B) (h : Membership.mem p x), q ⟨x, h⟩)","decl":"protected theorem «forall» {q : p → Prop} : (∀ x, q x) ↔ ∀ (x : B) (h : x ∈ p), q ⟨x, ‹_›⟩ :=\n  SetCoe.forall\n\n"}
{"name":"SetLike.coe_injective","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\n⊢ Function.Injective SetLike.coe","decl":"theorem coe_injective : Function.Injective (SetLike.coe : A → Set B) := fun _ _ h =>\n  SetLike.coe_injective' h\n\n"}
{"name":"SetLike.coe_set_eq","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (Eq ↑p ↑q) (Eq p q)","decl":"@[simp, norm_cast]\ntheorem coe_set_eq : (p : Set B) = q ↔ p = q :=\n  coe_injective.eq_iff\n\n"}
{"name":"SetLike.coe_ne_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (Ne ↑p ↑q) (Ne p q)","decl":"@[norm_cast] lemma coe_ne_coe : (p : Set B) ≠ q ↔ p ≠ q := coe_injective.ne_iff\n\n"}
{"name":"SetLike.ext'","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\nh : Eq ↑p ↑q\n⊢ Eq p q","decl":"theorem ext' (h : (p : Set B) = q) : p = q :=\n  coe_injective h\n\n"}
{"name":"SetLike.ext'_iff","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (Eq p q) (Eq ↑p ↑q)","decl":"theorem ext'_iff : p = q ↔ (p : Set B) = q :=\n  coe_set_eq.symm\n\n"}
{"name":"SetLike.ext","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\nh : ∀ (x : B), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"/-- Note: implementers of `SetLike` must copy this lemma in order to tag it with `@[ext]`. -/\ntheorem ext (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  coe_injective <| Set.ext h\n\n"}
{"name":"SetLike.ext_iff","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (Eq p q) (∀ (x : B), Iff (Membership.mem p x) (Membership.mem q x))","decl":"theorem ext_iff : p = q ↔ ∀ x, x ∈ p ↔ x ∈ q :=\n  coe_injective.eq_iff.symm.trans Set.ext_iff\n\n"}
{"name":"SetLike.mem_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nx : B\n⊢ Iff (Membership.mem (↑p) x) (Membership.mem p x)","decl":"@[simp]\ntheorem mem_coe {x : B} : x ∈ (p : Set B) ↔ x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"SetLike.coe_eq_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nx y : Subtype fun x => Membership.mem p x\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[simp, norm_cast]\ntheorem coe_eq_coe {x y : p} : (x : B) = y ↔ x = y :=\n  Subtype.ext_iff_val.symm\n\n-- Porting note: this is not necessary anymore due to the way coercions work\n\n"}
{"name":"SetLike.coe_mem","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nx : Subtype fun x => Membership.mem p x\n⊢ Membership.mem p ↑x","decl":"@[simp]\ntheorem coe_mem (x : p) : (x : B) ∈ p :=\n  x.2\n\n"}
{"name":"SetLike.mem_of_subset","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\ns : Set B\nhp : HasSubset.Subset s ↑p\nx : B\nhx : Membership.mem s x\n⊢ Membership.mem p x","decl":"@[aesop 5% apply (rule_sets := [SetLike])]\nlemma mem_of_subset {s : Set B} (hp : s ⊆ p) {x : B} (hx : x ∈ s) : x ∈ p := hp hx\n\n"}
{"name":"SetLike.eta","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np : A\nx : Subtype fun x => Membership.mem p x\nhx : Membership.mem p ↑x\n⊢ Eq ⟨↑x, hx⟩ x","decl":"@[simp]\nprotected theorem eta (x : p) (hx : (x : B) ∈ p) : (⟨x, hx⟩ : p) = x := rfl\n\n"}
{"name":"SetLike.setOf_mem_eq","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\na : A\n⊢ Eq (setOf fun b => Membership.mem a b) ↑a","decl":"@[simp] lemma setOf_mem_eq (a : A) : {b | b ∈ a} = a := rfl\n\n"}
{"name":"SetLike.le_def","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\nS T : A\n⊢ Iff (LE.le S T) (∀ ⦃x : B⦄, Membership.mem S x → Membership.mem T x)","decl":"theorem le_def {S T : A} : S ≤ T ↔ ∀ ⦃x : B⦄, x ∈ S → x ∈ T :=\n  Iff.rfl\n\n"}
{"name":"SetLike.coe_subset_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\nS T : A\n⊢ Iff (HasSubset.Subset ↑S ↑T) (LE.le S T)","decl":"@[simp, norm_cast] lemma coe_subset_coe {S T : A} : (S : Set B) ⊆ T ↔ S ≤ T := .rfl\n"}
{"name":"SetLike.coe_ssubset_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\nS T : A\n⊢ Iff (HasSSubset.SSubset ↑S ↑T) (LT.lt S T)","decl":"@[simp, norm_cast] lemma coe_ssubset_coe {S T : A} : (S : Set B) ⊂ T ↔ S < T := .rfl\n\n"}
{"name":"SetLike.GCongr.coe_subset_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\nS T : A\na✝ : LE.le S T\n⊢ HasSubset.Subset ↑S ↑T","decl":"@[gcongr] protected alias ⟨_, GCongr.coe_subset_coe⟩ := coe_subset_coe\n"}
{"name":"SetLike.GCongr.coe_ssubset_coe","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\nS T : A\na✝ : LT.lt S T\n⊢ HasSSubset.SSubset ↑S ↑T","decl":"@[gcongr] protected alias ⟨_, GCongr.coe_ssubset_coe⟩ := coe_ssubset_coe\n\n"}
{"name":"SetLike.coe_mono","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\n⊢ Monotone SetLike.coe","decl":"@[mono]\ntheorem coe_mono : Monotone (SetLike.coe : A → Set B) := fun _ _ => coe_subset_coe.mpr\n\n"}
{"name":"SetLike.coe_strictMono","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\n⊢ StrictMono SetLike.coe","decl":"@[mono]\ntheorem coe_strictMono : StrictMono (SetLike.coe : A → Set B) := fun _ _ => coe_ssubset_coe.mpr\n\n"}
{"name":"SetLike.not_le_iff_exists","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (Not (LE.le p q)) (Exists fun x => And (Membership.mem p x) (Not (Membership.mem q x)))","decl":"theorem not_le_iff_exists : ¬p ≤ q ↔ ∃ x ∈ p, x ∉ q :=\n  Set.not_subset\n\n"}
{"name":"SetLike.exists_of_lt","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\na✝ : LT.lt p q\n⊢ Exists fun x => And (Membership.mem q x) (Not (Membership.mem p x))","decl":"theorem exists_of_lt : p < q → ∃ x ∈ q, x ∉ p :=\n  Set.exists_of_ssubset\n\n"}
{"name":"SetLike.lt_iff_le_and_exists","module":"Mathlib.Data.SetLike.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ni : SetLike A B\np q : A\n⊢ Iff (LT.lt p q) (And (LE.le p q) (Exists fun x => And (Membership.mem q x) (Not (Membership.mem p x))))","decl":"theorem lt_iff_le_and_exists : p < q ↔ p ≤ q ∧ ∃ x ∈ q, x ∉ p := by\n  rw [lt_iff_le_not_le, not_le_iff_exists]\n\n"}
