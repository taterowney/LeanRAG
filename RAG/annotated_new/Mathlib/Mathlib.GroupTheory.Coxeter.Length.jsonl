{"name":"CoxeterSystem.exists_reduced_word","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Exists fun ω => And (Eq ω.length (cs.length w)) (Eq w (cs.wordProd ω))","decl":"theorem exists_reduced_word (w : W) : ∃ ω, ω.length = ℓ w ∧ w = π ω := by\n  classical\n  have := Nat.find_spec (cs.exists_word_with_prod w)\n  tauto\n\n"}
{"name":"CoxeterSystem.length_wordProd_le","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ LE.le (cs.length (cs.wordProd ω)) ω.length","decl":"open scoped Classical in\ntheorem length_wordProd_le (ω : List B) : ℓ (π ω) ≤ ω.length :=\n  Nat.find_min' (cs.exists_word_with_prod (π ω)) ⟨ω, by tauto⟩\n\n"}
{"name":"CoxeterSystem.length_one","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (cs.length 1) 0","decl":"@[simp] theorem length_one : ℓ (1 : W) = 0 := Nat.eq_zero_of_le_zero (cs.length_wordProd_le [])\n\n"}
{"name":"CoxeterSystem.length_eq_zero_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Iff (Eq (cs.length w) 0) (Eq w 1)","decl":"@[simp]\ntheorem length_eq_zero_iff {w : W} : ℓ w = 0 ↔ w = 1 := by\n  constructor\n  · intro h\n    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩\n    have : ω = [] := eq_nil_of_length_eq_zero (hω.trans h)\n    rw [this, wordProd_nil]\n  · rintro rfl\n    exact cs.length_one\n\n"}
{"name":"CoxeterSystem.length_inv","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Eq (cs.length (Inv.inv w)) (cs.length w)","decl":"@[simp]\ntheorem length_inv (w : W) : ℓ (w⁻¹) = ℓ w := by\n  apply Nat.le_antisymm\n  · rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩\n    have := cs.length_wordProd_le (List.reverse ω)\n    rwa [wordProd_reverse, length_reverse, hω] at this\n  · rcases cs.exists_reduced_word w⁻¹ with ⟨ω, hω, h'ω⟩\n    have := cs.length_wordProd_le (List.reverse ω)\n    rwa [wordProd_reverse, length_reverse, ← h'ω, hω, inv_inv] at this\n\n"}
{"name":"CoxeterSystem.length_mul_le","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw₁ w₂ : W\n⊢ LE.le (cs.length (HMul.hMul w₁ w₂)) (HAdd.hAdd (cs.length w₁) (cs.length w₂))","decl":"theorem length_mul_le (w₁ w₂ : W) :\n    ℓ (w₁ * w₂) ≤ ℓ w₁ + ℓ w₂ := by\n  rcases cs.exists_reduced_word w₁ with ⟨ω₁, hω₁, rfl⟩\n  rcases cs.exists_reduced_word w₂ with ⟨ω₂, hω₂, rfl⟩\n  have := cs.length_wordProd_le (ω₁ ++ ω₂)\n  simpa [hω₁, hω₂, wordProd_append] using this\n\n"}
{"name":"CoxeterSystem.length_mul_ge_length_sub_length","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw₁ w₂ : W\n⊢ LE.le (HSub.hSub (cs.length w₁) (cs.length w₂)) (cs.length (HMul.hMul w₁ w₂))","decl":"theorem length_mul_ge_length_sub_length (w₁ w₂ : W) :\n    ℓ w₁ - ℓ w₂ ≤ ℓ (w₁ * w₂) := by\n  simpa [Nat.sub_le_of_le_add] using cs.length_mul_le (w₁ * w₂) w₂⁻¹\n\n"}
{"name":"CoxeterSystem.length_mul_ge_length_sub_length'","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw₁ w₂ : W\n⊢ LE.le (HSub.hSub (cs.length w₂) (cs.length w₁)) (cs.length (HMul.hMul w₁ w₂))","decl":"theorem length_mul_ge_length_sub_length' (w₁ w₂ : W) :\n    ℓ w₂ - ℓ w₁ ≤ ℓ (w₁ * w₂) := by\n  simpa [Nat.sub_le_of_le_add, add_comm] using cs.length_mul_le w₁⁻¹ (w₁ * w₂)\n\n"}
{"name":"CoxeterSystem.length_mul_ge_max","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw₁ w₂ : W\n⊢ LE.le (Max.max (HSub.hSub (cs.length w₁) (cs.length w₂)) (HSub.hSub (cs.length w₂) (cs.length w₁))) (cs.length (HMul.hMul w₁ w₂))","decl":"theorem length_mul_ge_max (w₁ w₂ : W) :\n    max (ℓ w₁ - ℓ w₂) (ℓ w₂ - ℓ w₁) ≤ ℓ (w₁ * w₂) :=\n  max_le_iff.mpr ⟨length_mul_ge_length_sub_length _ _ _, length_mul_ge_length_sub_length' _ _ _⟩\n\n"}
{"name":"CoxeterSystem.lengthParity_simple","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (cs.lengthParity (cs.simple i)) (Multiplicative.ofAdd 1)","decl":"theorem lengthParity_simple (i : B) :\n    cs.lengthParity (s i) = Multiplicative.ofAdd 1 := cs.lift_apply_simple _ _\n\n"}
{"name":"CoxeterSystem.lengthParity_comp_simple","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (Function.comp (⇑cs.lengthParity) cs.simple) fun x => Multiplicative.ofAdd 1","decl":"theorem lengthParity_comp_simple :\n    cs.lengthParity ∘ cs.simple = fun _ ↦ Multiplicative.ofAdd 1 := funext cs.lengthParity_simple\n\n"}
{"name":"CoxeterSystem.lengthParity_eq_ofAdd_length","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Eq (cs.lengthParity w) (Multiplicative.ofAdd ↑(cs.length w))","decl":"theorem lengthParity_eq_ofAdd_length (w : W) :\n    cs.lengthParity w = Multiplicative.ofAdd (↑(ℓ w)) := by\n  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩\n  rw [← hω, wordProd, map_list_prod, List.map_map, lengthParity_comp_simple, map_const',\n    prod_replicate, ← ofAdd_nsmul, nsmul_one]\n\n"}
{"name":"CoxeterSystem.length_mul_mod_two","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw₁ w₂ : W\n⊢ Eq (HMod.hMod (cs.length (HMul.hMul w₁ w₂)) 2) (HMod.hMod (HAdd.hAdd (cs.length w₁) (cs.length w₂)) 2)","decl":"theorem length_mul_mod_two (w₁ w₂ : W) : ℓ (w₁ * w₂) % 2 = (ℓ w₁ + ℓ w₂) % 2 := by\n  rw [← ZMod.natCast_eq_natCast_iff', Nat.cast_add]\n  simpa only [lengthParity_eq_ofAdd_length, ofAdd_add] using map_mul cs.lengthParity w₁ w₂\n\n"}
{"name":"CoxeterSystem.length_simple","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (cs.length (cs.simple i)) 1","decl":"@[simp]\ntheorem length_simple (i : B) : ℓ (s i) = 1 := by\n  apply Nat.le_antisymm\n  · simpa using cs.length_wordProd_le [i]\n  · by_contra! length_lt_one\n    have : cs.lengthParity (s i) = Multiplicative.ofAdd 0 := by\n      rw [lengthParity_eq_ofAdd_length, Nat.lt_one_iff.mp length_lt_one, Nat.cast_zero]\n    have : Multiplicative.ofAdd (0 : ZMod 2) = Multiplicative.ofAdd 1 :=\n      this.symm.trans (cs.lengthParity_simple i)\n    contradiction\n\n"}
{"name":"CoxeterSystem.length_eq_one_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Iff (Eq (cs.length w) 1) (Exists fun i => Eq w (cs.simple i))","decl":"theorem length_eq_one_iff {w : W} : ℓ w = 1 ↔ ∃ i : B, w = s i := by\n  constructor\n  · intro h\n    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩\n    rcases List.length_eq_one.mp (hω.trans h) with ⟨i, rfl⟩\n    exact ⟨i, cs.wordProd_singleton i⟩\n  · rintro ⟨i, rfl⟩\n    exact cs.length_simple i\n\n"}
{"name":"CoxeterSystem.length_mul_simple_ne","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Ne (cs.length (HMul.hMul w (cs.simple i))) (cs.length w)","decl":"theorem length_mul_simple_ne (w : W) (i : B) : ℓ (w * s i) ≠ ℓ w := by\n  intro eq\n  have length_mod_two := cs.length_mul_mod_two w (s i)\n  rw [eq, length_simple] at length_mod_two\n  rcases Nat.mod_two_eq_zero_or_one (ℓ w) with even | odd\n  · rw [even, Nat.succ_mod_two_eq_one_iff.mpr even] at length_mod_two\n    contradiction\n  · rw [odd, Nat.succ_mod_two_eq_zero_iff.mpr odd] at length_mod_two\n    contradiction\n\n"}
{"name":"CoxeterSystem.length_simple_mul_ne","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Ne (cs.length (HMul.hMul (cs.simple i) w)) (cs.length w)","decl":"theorem length_simple_mul_ne (w : W) (i : B) : ℓ (s i * w) ≠ ℓ w := by\n  convert cs.length_mul_simple_ne w⁻¹ i using 1\n  · convert cs.length_inv ?_ using 2\n    simp\n  · simp\n\n"}
{"name":"CoxeterSystem.length_mul_simple","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Or (Eq (cs.length (HMul.hMul w (cs.simple i))) (HAdd.hAdd (cs.length w) 1)) (Eq (HAdd.hAdd (cs.length (HMul.hMul w (cs.simple i))) 1) (cs.length w))","decl":"theorem length_mul_simple (w : W) (i : B) :\n    ℓ (w * s i) = ℓ w + 1 ∨ ℓ (w * s i) + 1 = ℓ w := by\n  rcases Nat.lt_or_gt_of_ne (cs.length_mul_simple_ne w i) with lt | gt\n  · -- lt : ℓ (w * s i) < ℓ w\n    right\n    have length_ge := cs.length_mul_ge_length_sub_length w (s i)\n    simp only [length_simple, tsub_le_iff_right] at length_ge\n    -- length_ge : ℓ w ≤ ℓ (w * s i) + 1\n    omega\n  · -- gt : ℓ w < ℓ (w * s i)\n    left\n    have length_le := cs.length_mul_le w (s i)\n    simp only [length_simple] at length_le\n    -- length_le : ℓ (w * s i) ≤ ℓ w + 1\n    omega\n\n"}
{"name":"CoxeterSystem.length_simple_mul","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Or (Eq (cs.length (HMul.hMul (cs.simple i) w)) (HAdd.hAdd (cs.length w) 1)) (Eq (HAdd.hAdd (cs.length (HMul.hMul (cs.simple i) w)) 1) (cs.length w))","decl":"theorem length_simple_mul (w : W) (i : B) :\n    ℓ (s i * w) = ℓ w + 1 ∨ ℓ (s i * w) + 1 = ℓ w := by\n  have := cs.length_mul_simple w⁻¹ i\n  rwa [(by simp : w⁻¹ * (s i) = ((s i) * w)⁻¹), length_inv, length_inv] at this\n\n"}
{"name":"CoxeterSystem.isReduced_reverse_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Iff (cs.IsReduced ω.reverse) (cs.IsReduced ω)","decl":"@[simp]\ntheorem isReduced_reverse_iff (ω : List B) : cs.IsReduced (ω.reverse) ↔ cs.IsReduced ω := by\n  simp [IsReduced]\n\n"}
{"name":"CoxeterSystem.IsReduced.reverse","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nhω : cs.IsReduced ω\n⊢ cs.IsReduced ω.reverse","decl":"theorem IsReduced.reverse {cs : CoxeterSystem M W} {ω : List B}\n    (hω : cs.IsReduced ω) : cs.IsReduced (ω.reverse) :=\n  (cs.isReduced_reverse_iff ω).mpr hω\n\n"}
{"name":"CoxeterSystem.exists_reduced_word'","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n⊢ Exists fun ω => And (cs.IsReduced ω) (Eq w (cs.wordProd ω))","decl":"theorem exists_reduced_word' (w : W) : ∃ ω : List B, cs.IsReduced ω ∧ w = π ω := by\n  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩\n  use ω\n  tauto\n\n"}
{"name":"CoxeterSystem.IsReduced.take","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nhω : cs.IsReduced ω\nj : Nat\n⊢ cs.IsReduced (List.take j ω)","decl":"theorem IsReduced.take {cs : CoxeterSystem M W} {ω : List B} (hω : cs.IsReduced ω) (j : ℕ) :\n    cs.IsReduced (ω.take j) :=\n  (isReduced_take_and_drop _ hω _).1\n\n"}
{"name":"CoxeterSystem.IsReduced.drop","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nhω : cs.IsReduced ω\nj : Nat\n⊢ cs.IsReduced (List.drop j ω)","decl":"theorem IsReduced.drop {cs : CoxeterSystem M W} {ω : List B} (hω : cs.IsReduced ω) (j : ℕ) :\n    cs.IsReduced (ω.drop j) :=\n  (isReduced_take_and_drop _ hω _).2\n\n"}
{"name":"CoxeterSystem.not_isReduced_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nm : Nat\nhM : Ne (M.M i i') 0\nhm : GT.gt m (M.M i i')\n⊢ Not (cs.IsReduced (CoxeterSystem.alternatingWord i i' m))","decl":"theorem not_isReduced_alternatingWord (i i' : B) {m : ℕ} (hM : M i i' ≠ 0) (hm : m > M i i') :\n    ¬cs.IsReduced (alternatingWord i i' m) := by\n  induction' hm with m _ ih\n  · -- Base case; m = M i i' + 1\n    suffices h : ℓ (π (alternatingWord i i' (M i i' + 1))) < M i i' + 1 by\n      unfold IsReduced\n      rw [Nat.succ_eq_add_one, length_alternatingWord]\n      omega\n    have : M i i' + 1 ≤ M i i' * 2 := by linarith [Nat.one_le_iff_ne_zero.mpr hM]\n    rw [cs.prod_alternatingWord_eq_prod_alternatingWord_sub i i' _ this]\n    have : M i i' * 2 - (M i i' + 1) = M i i' - 1 := by omega\n    rw [this]\n    calc\n      ℓ (π (alternatingWord i' i (M i i' - 1)))\n      _ ≤ (alternatingWord i' i (M i i' - 1)).length  := cs.length_wordProd_le _\n      _ = M i i' - 1                                  := length_alternatingWord _ _ _\n      _ ≤ M i i'                                      := Nat.sub_le _ _\n      _ < M i i' + 1                                  := Nat.lt_succ_self _\n  · -- Inductive step\n    contrapose! ih\n    rw [alternatingWord_succ'] at ih\n    apply IsReduced.drop (j := 1) at ih\n    simpa using ih\n\n"}
{"name":"CoxeterSystem.not_isLeftDescent_one","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Not (cs.IsLeftDescent 1 i)","decl":"theorem not_isLeftDescent_one (i : B) : ¬cs.IsLeftDescent 1 i := by simp [IsLeftDescent]\n\n"}
{"name":"CoxeterSystem.not_isRightDescent_one","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Not (cs.IsRightDescent 1 i)","decl":"theorem not_isRightDescent_one (i : B) : ¬cs.IsRightDescent 1 i := by simp [IsRightDescent]\n\n"}
{"name":"CoxeterSystem.isLeftDescent_inv_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsLeftDescent (Inv.inv w) i) (cs.IsRightDescent w i)","decl":"theorem isLeftDescent_inv_iff {w : W} {i : B} :\n    cs.IsLeftDescent w⁻¹ i ↔ cs.IsRightDescent w i := by\n  unfold IsLeftDescent IsRightDescent\n  nth_rw 1 [← length_inv]\n  simp\n\n"}
{"name":"CoxeterSystem.isRightDescent_inv_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsRightDescent (Inv.inv w) i) (cs.IsLeftDescent w i)","decl":"theorem isRightDescent_inv_iff {w : W} {i : B} :\n    cs.IsRightDescent w⁻¹ i ↔ cs.IsLeftDescent w i := by\n  simpa using (cs.isLeftDescent_inv_iff (w := w⁻¹)).symm\n\n"}
{"name":"CoxeterSystem.exists_leftDescent_of_ne_one","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\nhw : Ne w 1\n⊢ Exists fun i => cs.IsLeftDescent w i","decl":"theorem exists_leftDescent_of_ne_one {w : W} (hw : w ≠ 1) : ∃ i : B, cs.IsLeftDescent w i := by\n  rcases cs.exists_reduced_word w with ⟨ω, h, rfl⟩\n  have h₁ : ω ≠ [] := by rintro rfl; simp at hw\n  rcases List.exists_cons_of_ne_nil h₁ with ⟨i, ω', rfl⟩\n  use i\n  rw [IsLeftDescent, ← h, wordProd_cons, simple_mul_simple_cancel_left]\n  calc\n    ℓ (π ω') ≤ ω'.length                := cs.length_wordProd_le ω'\n    _        < (i :: ω').length         := by simp\n\n"}
{"name":"CoxeterSystem.exists_rightDescent_of_ne_one","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\nhw : Ne w 1\n⊢ Exists fun i => cs.IsRightDescent w i","decl":"theorem exists_rightDescent_of_ne_one {w : W} (hw : w ≠ 1) : ∃ i : B, cs.IsRightDescent w i := by\n  simp only [← isLeftDescent_inv_iff]\n  apply exists_leftDescent_of_ne_one\n  simpa\n\n"}
{"name":"CoxeterSystem.isLeftDescent_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsLeftDescent w i) (Eq (HAdd.hAdd (cs.length (HMul.hMul (cs.simple i) w)) 1) (cs.length w))","decl":"theorem isLeftDescent_iff {w : W} {i : B} :\n    cs.IsLeftDescent w i ↔ ℓ (s i * w) + 1 = ℓ w := by\n  unfold IsLeftDescent\n  constructor\n  · intro _\n    exact (cs.length_simple_mul w i).resolve_left (by omega)\n  · omega\n\n"}
{"name":"CoxeterSystem.not_isLeftDescent_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (Not (cs.IsLeftDescent w i)) (Eq (cs.length (HMul.hMul (cs.simple i) w)) (HAdd.hAdd (cs.length w) 1))","decl":"theorem not_isLeftDescent_iff {w : W} {i : B} :\n    ¬cs.IsLeftDescent w i ↔ ℓ (s i * w) = ℓ w + 1 := by\n  unfold IsLeftDescent\n  constructor\n  · intro _\n    exact (cs.length_simple_mul w i).resolve_right (by omega)\n  · omega\n\n"}
{"name":"CoxeterSystem.isRightDescent_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsRightDescent w i) (Eq (HAdd.hAdd (cs.length (HMul.hMul w (cs.simple i))) 1) (cs.length w))","decl":"theorem isRightDescent_iff {w : W} {i : B} :\n    cs.IsRightDescent w i ↔ ℓ (w * s i) + 1 = ℓ w := by\n  unfold IsRightDescent\n  constructor\n  · intro _\n    exact (cs.length_mul_simple w i).resolve_left (by omega)\n  · omega\n\n"}
{"name":"CoxeterSystem.not_isRightDescent_iff","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (Not (cs.IsRightDescent w i)) (Eq (cs.length (HMul.hMul w (cs.simple i))) (HAdd.hAdd (cs.length w) 1))","decl":"theorem not_isRightDescent_iff {w : W} {i : B} :\n    ¬cs.IsRightDescent w i ↔ ℓ (w * s i) = ℓ w + 1 := by\n  unfold IsRightDescent\n  constructor\n  · intro _\n    exact (cs.length_mul_simple w i).resolve_right (by omega)\n  · omega\n\n"}
{"name":"CoxeterSystem.isLeftDescent_iff_not_isLeftDescent_mul","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsLeftDescent w i) (Not (cs.IsLeftDescent (HMul.hMul (cs.simple i) w) i))","decl":"theorem isLeftDescent_iff_not_isLeftDescent_mul {w : W} {i : B} :\n    cs.IsLeftDescent w i ↔ ¬cs.IsLeftDescent (s i * w) i := by\n  rw [isLeftDescent_iff, not_isLeftDescent_iff, simple_mul_simple_cancel_left]\n  tauto\n\n"}
{"name":"CoxeterSystem.isRightDescent_iff_not_isRightDescent_mul","module":"Mathlib.GroupTheory.Coxeter.Length","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsRightDescent w i) (Not (cs.IsRightDescent (HMul.hMul w (cs.simple i)) i))","decl":"theorem isRightDescent_iff_not_isRightDescent_mul {w : W} {i : B} :\n    cs.IsRightDescent w i ↔ ¬cs.IsRightDescent (w * s i) i := by\n  rw [isRightDescent_iff, not_isRightDescent_iff, simple_mul_simple_cancel_right]\n  tauto\n\n"}
