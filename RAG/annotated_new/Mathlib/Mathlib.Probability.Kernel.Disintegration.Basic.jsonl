{"name":"MeasureTheory.Measure.IsCondKernel.disintegrate","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\nself : ρ.IsCondKernel ρCond\n⊢ Eq (ρ.fst.compProd ρCond) ρ","decl":"/-- A kernel `ρCond` is a conditional kernel for a measure `ρ` if it disintegrates it in the sense\nthat `ρ.fst ⊗ₘ ρCond = ρ`. -/\nclass IsCondKernel : Prop where\n  disintegrate : ρ.fst ⊗ₘ ρCond = ρ\n\n"}
{"name":"MeasureTheory.Measure.disintegrate","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\ninst✝ : ρ.IsCondKernel ρCond\n⊢ Eq (ρ.fst.compProd ρCond) ρ","decl":"lemma disintegrate : ρ.fst ⊗ₘ ρCond = ρ := IsCondKernel.disintegrate\n\n"}
{"name":"MeasureTheory.Measure.IsCondKernel.isSFiniteKernel","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\ninst✝ : ρ.IsCondKernel ρCond\nhρ : Ne ρ 0\n⊢ ProbabilityTheory.IsSFiniteKernel ρCond","decl":"lemma IsCondKernel.isSFiniteKernel (hρ : ρ ≠ 0) : IsSFiniteKernel ρCond := by\n  contrapose! hρ; rwa [← ρ.disintegrate ρCond, Measure.compProd_of_not_isSFiniteKernel]\n\n"}
{"name":"MeasureTheory.Measure.IsCondKernel.apply_of_ne_zero","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\ninst✝² : ρ.IsCondKernel ρCond\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\ninst✝ : MeasurableSingletonClass α\nx : α\nhx : Ne (ρ.fst (Singleton.singleton x)) 0\ns : Set Ω\n⊢ Eq ((ρCond x) s) (HMul.hMul (Inv.inv (ρ.fst (Singleton.singleton x))) (ρ (SProd.sprod (Singleton.singleton x) s)))","decl":"/-- If the singleton `{x}` has non-zero mass for `ρ.fst`, then for all `s : Set Ω`,\n`ρCond x s = (ρ.fst {x})⁻¹ * ρ ({x} ×ˢ s)` . -/\nlemma IsCondKernel.apply_of_ne_zero [MeasurableSingletonClass α] {x : α}\n    (hx : ρ.fst {x} ≠ 0) (s : Set Ω) : ρCond x s = (ρ.fst {x})⁻¹ * ρ ({x} ×ˢ s) := by\n  have : ρCond x s = ((ρ.fst {x})⁻¹ • ρ).comap (fun (y : Ω) ↦ (x, y)) s := by\n    congr 2 with s hs\n    simp [IsCondKernel.apply_of_ne_zero_of_measurableSet _ _ hx hs,\n      (measurableEmbedding_prod_mk_left x).comap_apply]\n  simp [this, (measurableEmbedding_prod_mk_left x).comap_apply, hx]\n\n"}
{"name":"MeasureTheory.Measure.IsCondKernel.isProbabilityMeasure","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\ninst✝² : ρ.IsCondKernel ρCond\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\ninst✝ : MeasurableSingletonClass α\na : α\nha : Ne (ρ.fst (Singleton.singleton a)) 0\n⊢ MeasureTheory.IsProbabilityMeasure (ρCond a)","decl":"lemma IsCondKernel.isProbabilityMeasure [MeasurableSingletonClass α] {a : α} (ha : ρ.fst {a} ≠ 0) :\n    IsProbabilityMeasure (ρCond a) := by\n  constructor\n  rw [IsCondKernel.apply_of_ne_zero _ _ ha, prod_univ, ← Measure.fst_apply\n    (measurableSet_singleton _), ENNReal.inv_mul_cancel ha (measure_ne_top _ _)]\n\n"}
{"name":"MeasureTheory.Measure.IsCondKernel.isMarkovKernel","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\nmΩ : MeasurableSpace Ω\nρ : MeasureTheory.Measure (Prod α Ω)\nρCond : ProbabilityTheory.Kernel α Ω\ninst✝² : ρ.IsCondKernel ρCond\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\ninst✝ : MeasurableSingletonClass α\nhρ : ∀ (a : α), Ne (ρ.fst (Singleton.singleton a)) 0\n⊢ ProbabilityTheory.IsMarkovKernel ρCond","decl":"lemma IsCondKernel.isMarkovKernel [MeasurableSingletonClass α] (hρ : ∀ a, ρ.fst {a} ≠ 0) :\n    IsMarkovKernel ρCond := ⟨fun _ ↦ isProbabilityMeasure _ _ (hρ _)⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IsCondKernel.disintegrate","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\nκCond : ProbabilityTheory.Kernel (Prod α β) Ω\nself : κ.IsCondKernel κCond\n⊢ Eq (κ.fst.compProd κCond) κ","decl":"/-- A kernel `κCond` is a conditional kernel for a kernel `κ` if it disintegrates it in the sense\nthat `κ.fst ⊗ₖ κCond = κ`. -/\nclass IsCondKernel : Prop where\n  protected disintegrate : κ.fst ⊗ₖ κCond = κ\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsCondKernel_zero","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκCond : ProbabilityTheory.Kernel (Prod α β) Ω\n⊢ ProbabilityTheory.Kernel.IsCondKernel 0 κCond","decl":"instance instIsCondKernel_zero (κCond : Kernel (α × β) Ω) : IsCondKernel 0 κCond where\n  disintegrate := by simp\n\n"}
{"name":"ProbabilityTheory.Kernel.disintegrate","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\nκCond : ProbabilityTheory.Kernel (Prod α β) Ω\ninst✝ : κ.IsCondKernel κCond\n⊢ Eq (κ.fst.compProd κCond) κ","decl":"lemma disintegrate [κ.IsCondKernel κCond] : κ.fst ⊗ₖ κCond = κ := IsCondKernel.disintegrate\n\n"}
{"name":"ProbabilityTheory.Kernel.IsCondKernel.isProbabilityMeasure_ae","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\nκCond : ProbabilityTheory.Kernel (Prod α β) Ω\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ.fst\ninst✝ : κ.IsCondKernel κCond\na : α\n⊢ Filter.Eventually (fun b => MeasureTheory.IsProbabilityMeasure (κCond { fst := a, snd := b })) (MeasureTheory.ae (κ.fst a))","decl":"/-- A conditional kernel is almost everywhere a probability measure. -/\nlemma IsCondKernel.isProbabilityMeasure_ae [IsFiniteKernel κ.fst] [κ.IsCondKernel κCond] (a : α) :\n    ∀ᵐ b ∂(κ.fst a), IsProbabilityMeasure (κCond (a, b)) := by\n  have h := disintegrate κ κCond\n  by_cases h_sfin : IsSFiniteKernel κCond\n  swap; · rw [Kernel.compProd_of_not_isSFiniteKernel_right _ _ h_sfin] at h; simp [h.symm]\n  suffices ∀ᵐ b ∂(κ.fst a), κCond (a, b) Set.univ = 1 by\n    convert this with b\n    exact ⟨fun _ ↦ measure_univ, fun h ↦ ⟨h⟩⟩\n  suffices (∀ᵐ b ∂(κ.fst a), κCond (a, b) Set.univ ≤ 1)\n      ∧ (∀ᵐ b ∂(κ.fst a), 1 ≤ κCond (a, b) Set.univ) by\n    filter_upwards [this.1, this.2] with b h1 h2 using le_antisymm h1 h2\n  have h_eq s (hs : MeasurableSet s) :\n      ∫⁻ b, s.indicator (fun b ↦ κCond (a, b) Set.univ) b ∂κ.fst a = κ.fst a s := by\n    conv_rhs => rw [← h]\n    rw [fst_compProd_apply _ _ _ hs]\n  have h_meas : Measurable fun b ↦ κCond (a, b) Set.univ :=\n    (κCond.measurable_coe MeasurableSet.univ).comp measurable_prod_mk_left\n  constructor\n  · rw [ae_le_const_iff_forall_gt_measure_zero]\n    intro r hr\n    let s := {b | r ≤ κCond (a, b) Set.univ}\n    have hs : MeasurableSet s := h_meas measurableSet_Ici\n    have h_2_le : s.indicator (fun _ ↦ r) ≤ s.indicator (fun b ↦ (κCond (a, b)) Set.univ) := by\n      intro b\n      by_cases hbs : b ∈ s\n      · simpa [hbs]\n      · simp [hbs]\n    have : ∫⁻ b, s.indicator (fun _ ↦ r) b ∂(κ.fst a) ≤ κ.fst a s :=\n      (lintegral_mono h_2_le).trans_eq (h_eq s hs)\n    rw [lintegral_indicator_const hs] at this\n    by_contra h_ne_zero\n    rw [← not_lt] at this\n    refine this ?_\n    conv_lhs => rw [← one_mul (κ.fst a s)]\n    exact ENNReal.mul_lt_mul_right' h_ne_zero (measure_ne_top _ _) hr\n  · rw [ae_const_le_iff_forall_lt_measure_zero]\n    intro r hr\n    let s := {b | κCond (a, b) Set.univ ≤ r}\n    have hs : MeasurableSet s := h_meas measurableSet_Iic\n    have h_2_le : s.indicator (fun b ↦ (κCond (a, b)) Set.univ) ≤ s.indicator (fun _ ↦ r) := by\n      intro b\n      by_cases hbs : b ∈ s\n      · simpa [hbs]\n      · simp [hbs]\n    have : κ.fst a s ≤ ∫⁻ b, s.indicator (fun _ ↦ r) b ∂(κ.fst a) :=\n      (h_eq s hs).symm.trans_le (lintegral_mono h_2_le)\n    rw [lintegral_indicator_const hs] at this\n    by_contra h_ne_zero\n    rw [← not_lt] at this\n    refine this ?_\n    conv_rhs => rw [← one_mul (κ.fst a s)]\n    exact ENNReal.mul_lt_mul_right' h_ne_zero (measure_ne_top _ _) hr\n\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelCountable_apply","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\ninst✝ : Countable α\nκCond : α → ProbabilityTheory.Kernel β Ω\nh_atom : ∀ (x y : α), Membership.mem (measurableAtom y) x → Eq (κCond x) (κCond y)\np : Prod α β\n⊢ Eq ((ProbabilityTheory.Kernel.condKernelCountable κCond h_atom) p) ((κCond p.1) p.2)","decl":"lemma condKernelCountable_apply (h_atom : ∀ x y, x ∈ measurableAtom y → κCond x = κCond y)\n    (p : α × β) : condKernelCountable κCond h_atom p = κCond p.1 p.2 := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelCountable.instIsMarkovKernel","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκCond : α → ProbabilityTheory.Kernel β Ω\ninst✝ : ∀ (a : α), ProbabilityTheory.IsMarkovKernel (κCond a)\nh_atom : ∀ (x y : α), Membership.mem (measurableAtom y) x → Eq (κCond x) (κCond y)\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.condKernelCountable κCond h_atom)","decl":"instance condKernelCountable.instIsMarkovKernel [∀ a, IsMarkovKernel (κCond a)]\n     (h_atom : ∀ x y, x ∈ measurableAtom y → κCond x = κCond y) :\n    IsMarkovKernel (condKernelCountable κCond h_atom) where\n  isProbabilityMeasure p := (‹∀ a, IsMarkovKernel (κCond a)› p.1).isProbabilityMeasure p.2\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelCountable.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmΩ : MeasurableSpace Ω\nκCond : α → ProbabilityTheory.Kernel β Ω\ninst✝² : ∀ (a : α), ProbabilityTheory.IsMarkovKernel (κCond a)\nh_atom : ∀ (x y : α), Membership.mem (measurableAtom y) x → Eq (κCond x) (κCond y)\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ∀ (a : α), (κ a).IsCondKernel (κCond a)\n⊢ κ.IsCondKernel (ProbabilityTheory.Kernel.condKernelCountable κCond h_atom)","decl":"instance condKernelCountable.instIsCondKernel [∀ a, IsMarkovKernel (κCond a)]\n    (h_atom : ∀ x y, x ∈ measurableAtom y → κCond x = κCond y) (κ : Kernel α (β × Ω))\n    [IsSFiniteKernel κ] [∀ a, (κ a).IsCondKernel (κCond a)] :\n    κ.IsCondKernel (condKernelCountable κCond h_atom) := by\n  constructor\n  ext a s hs\n  conv_rhs => rw [← (κ a).disintegrate (κCond a)]\n  simp_rw [compProd_apply hs, condKernelCountable_apply, Measure.compProd_apply hs]\n  congr\n\n"}
