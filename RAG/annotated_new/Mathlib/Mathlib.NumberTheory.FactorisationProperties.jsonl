{"name":"Nat.not_pseudoperfect_iff_forall","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\n⊢ Iff (Not n.Pseudoperfect) (Or (Eq n 0) (∀ (s : Finset Nat), HasSubset.Subset s n.properDivisors → Ne (s.sum fun i => i) n))","decl":"theorem not_pseudoperfect_iff_forall :\n    ¬ Pseudoperfect n ↔ n = 0 ∨ ∀ s ⊆ properDivisors n, ∑ i ∈ s, i ≠ n := by\n  rw [Pseudoperfect, not_and_or]\n  simp only [not_lt, nonpos_iff_eq_zero, mem_powerset, not_exists, not_and, ne_eq]\n\n"}
{"name":"Nat.deficient_one","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ Nat.Deficient 1","decl":"theorem deficient_one : Deficient 1 := zero_lt_one\n"}
{"name":"Nat.deficient_two","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ Nat.Deficient 2","decl":"theorem deficient_two : Deficient 2 := one_lt_two\n"}
{"name":"Nat.deficient_three","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ Nat.Deficient 3","decl":"theorem deficient_three : Deficient 3 := by norm_num [Deficient]\n\n"}
{"name":"Nat.abundant_twelve","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ Nat.Abundant 12","decl":"theorem abundant_twelve : Abundant 12 := by\n  rw [Abundant, show properDivisors 12 = {1,2,3,4,6} by rfl]\n  norm_num\n\n"}
{"name":"Nat.weird_seventy","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ Nat.Weird 70","decl":"set_option maxRecDepth 1730 in\ntheorem weird_seventy : Weird 70 := by\n  rw [Weird, Abundant, not_pseudoperfect_iff_forall]\n  have h : properDivisors 70 = {1, 2, 5, 7, 10, 14, 35} := by rfl\n  constructor\n  · rw [h]\n    repeat norm_num\n  · rw [h]\n    right\n    intro s hs\n    have hs' := mem_powerset.mpr hs\n    fin_cases hs' <;> decide\n\n"}
{"name":"Nat.deficient_iff_not_abundant_and_not_perfect","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Iff n.Deficient (And (Not n.Abundant) (Not n.Perfect))","decl":"lemma deficient_iff_not_abundant_and_not_perfect (hn : n ≠ 0) :\n    Deficient n ↔ ¬ Abundant n ∧ ¬ Perfect n := by\n  dsimp only [Perfect, Abundant, Deficient]\n  omega\n\n"}
{"name":"Nat.perfect_iff_not_abundant_and_not_deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nhn : Ne 0 n\n⊢ Iff n.Perfect (And (Not n.Abundant) (Not n.Deficient))","decl":"lemma perfect_iff_not_abundant_and_not_deficient (hn : 0 ≠ n) :\n    Perfect n ↔ ¬ Abundant n ∧ ¬ Deficient n := by\n  dsimp only [Perfect, Abundant, Deficient]\n  omega\n\n"}
{"name":"Nat.abundant_iff_not_perfect_and_not_deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nhn : Ne 0 n\n⊢ Iff n.Abundant (And (Not n.Perfect) (Not n.Deficient))","decl":"lemma abundant_iff_not_perfect_and_not_deficient (hn : 0 ≠ n) :\n    Abundant n ↔ ¬ Perfect n ∧ ¬ Deficient n := by\n  dsimp only [Perfect, Abundant, Deficient]\n  omega\n\n"}
{"name":"Nat.deficient_or_perfect_or_abundant","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nhn : Ne 0 n\n⊢ Or n.Deficient (Or n.Abundant n.Perfect)","decl":"/-- A positive natural number is either deficient, perfect, or abundant -/\ntheorem deficient_or_perfect_or_abundant (hn : 0 ≠ n) :\n    Deficient n ∨ Abundant n ∨ Perfect n := by\n  dsimp only [Perfect, Abundant, Deficient]\n  omega\n\n"}
{"name":"Nat.Perfect.pseudoperfect","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nh : n.Perfect\n⊢ n.Pseudoperfect","decl":"theorem Perfect.pseudoperfect (h : Perfect n) : Pseudoperfect n :=\n  ⟨h.2, ⟨properDivisors n, ⟨fun ⦃_⦄ a ↦ a, h.1⟩⟩⟩\n\n"}
{"name":"Nat.Prime.not_abundant","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nh : Nat.Prime n\n⊢ Not n.Abundant","decl":"theorem Prime.not_abundant (h : Prime n) : ¬ Abundant n :=\n  fun h1 ↦ (h.one_lt.trans h1).ne' (sum_properDivisors_eq_one_iff_prime.mpr h)\n\n"}
{"name":"Nat.Prime.not_weird","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nh : Nat.Prime n\n⊢ Not n.Weird","decl":"theorem Prime.not_weird (h : Prime n) : ¬ Weird n := by\n  simp only [Nat.Weird, not_and_or]\n  left\n  exact h.not_abundant\n\n"}
{"name":"Nat.Prime.not_pseudoperfect","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"p : Nat\nh : Nat.Prime p\n⊢ Not p.Pseudoperfect","decl":"theorem Prime.not_pseudoperfect (h : Prime p) : ¬ Pseudoperfect p := by\n  simp_rw [not_pseudoperfect_iff_forall, ← mem_powerset,\n    show p.properDivisors.powerset = {∅, {1}} by rw [Prime.properDivisors h]; rfl]\n  refine Or.inr (fun s hs ↦ ?_)\n  fin_cases hs <;>\n  simp only [sum_empty, sum_singleton] <;>\n  linarith [Prime.one_lt h]\n\n"}
{"name":"Nat.Prime.not_perfect","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"p : Nat\nh : Nat.Prime p\n⊢ Not p.Perfect","decl":"theorem Prime.not_perfect (h : Prime p) : ¬ Perfect p := by\n  have h1 := Prime.not_pseudoperfect h\n  revert h1\n  exact not_imp_not.mpr (Perfect.pseudoperfect)\n\n"}
{"name":"Nat.Prime.deficient_pow","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n m : Nat\nh : Nat.Prime n\n⊢ (HPow.hPow n m).Deficient","decl":"/-- Any natural number power of a prime is deficient -/\ntheorem Prime.deficient_pow  (h : Prime n) : Deficient (n ^ m) := by\n  rcases Nat.eq_zero_or_pos m with (rfl | _)\n  · simpa using deficient_one\n  · have h1 : (n ^ m).properDivisors = image (n ^ ·) (range m) := by\n      apply subset_antisymm <;> intro a\n      · simp only [mem_properDivisors, mem_image, mem_range, dvd_prime_pow h]\n        rintro ⟨⟨t, ht, rfl⟩, ha'⟩\n        exact ⟨t, lt_of_le_of_ne ht (fun ht' ↦ lt_irrefl _ (ht' ▸ ha')), rfl⟩\n      · simp only [mem_image, mem_range, mem_properDivisors, forall_exists_index, and_imp]\n        intro x hx hy\n        constructor\n        · rw [← hy, dvd_prime_pow h]\n          exact ⟨x, Nat.le_of_succ_le hx, rfl⟩\n        · rw [← hy]\n          exact (Nat.pow_lt_pow_iff_right (Prime.two_le h)).mpr hx\n    have h2 : ∑ i ∈ image (fun x => n ^ x) (range m), i = ∑ i ∈ range m, n^i := by\n      rw [Finset.sum_image]\n      rintro x _ y _\n      apply pow_injective_of_not_isUnit h.not_unit <| Prime.ne_zero h\n    rw [Deficient, h1, h2]\n    calc\n      ∑ i ∈ range m, n ^ i\n        = (n ^ m - 1) / (n - 1) := (Nat.geomSum_eq (Prime.two_le h) _)\n      _ ≤ (n ^ m - 1) := Nat.div_le_self (n ^ m - 1) (n - 1)\n      _ < n ^ m := sub_lt (pow_pos (Prime.pos h) m) (Nat.one_pos)\n\n"}
{"name":"IsPrimePow.deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nh : IsPrimePow n\n⊢ n.Deficient","decl":"theorem _root_.IsPrimePow.deficient (h : IsPrimePow n) : Deficient n := by\n  obtain ⟨p, k, hp, -, rfl⟩ := h\n  exact hp.nat_prime.deficient_pow\n\n"}
{"name":"Nat.Prime.deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"n : Nat\nh : Nat.Prime n\n⊢ n.Deficient","decl":"theorem Prime.deficient (h : Prime n) : Deficient n := by\n  rw [← pow_one n]\n  exact h.deficient_pow\n\n"}
{"name":"Nat.infinite_deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ (setOf fun n => n.Deficient).Infinite","decl":"/-- There exists infinitely many deficient numbers -/\ntheorem infinite_deficient : {n : ℕ | n.Deficient}.Infinite := by\n  rw [Set.infinite_iff_exists_gt]\n  intro a\n  obtain ⟨b, h1, h2⟩ := exists_infinite_primes a.succ\n  exact ⟨b, h2.deficient, h1⟩\n\n"}
{"name":"Nat.infinite_even_deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ (setOf fun n => And (Even n) n.Deficient).Infinite","decl":"theorem infinite_even_deficient : {n : ℕ | Even n ∧ n.Deficient}.Infinite := by\n  rw [Set.infinite_iff_exists_gt]\n  intro n\n  use 2 ^ (n + 1)\n  constructor\n  · exact ⟨⟨2 ^ n, by ring⟩, prime_two.deficient_pow⟩\n  · calc\n      n ≤ 2 ^ n := Nat.le_of_lt n.lt_two_pow_self\n      _ < 2 ^ (n + 1) := (Nat.pow_lt_pow_iff_right (Nat.one_lt_two)).mpr (lt_add_one n)\n\n"}
{"name":"Nat.infinite_odd_deficient","module":"Mathlib.NumberTheory.FactorisationProperties","initialProofState":"⊢ (setOf fun n => And (Odd n) n.Deficient).Infinite","decl":"theorem infinite_odd_deficient : {n : ℕ | Odd n ∧ n.Deficient}.Infinite := by\n  rw [Set.infinite_iff_exists_gt]\n  intro n\n  obtain ⟨p, ⟨_, h2⟩⟩ := exists_infinite_primes (max (n + 1) 3)\n  exact ⟨p, Set.mem_setOf.mpr ⟨Prime.odd_of_ne_two h2 (Ne.symm (ne_of_lt (by omega))),\n    Prime.deficient h2⟩, by omega⟩\n\n"}
