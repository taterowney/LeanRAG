{"name":"polarCoord_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (‚ÜëpolarCoord.symm p) { fst := HMul.hMul p.1 (Real.cos p.2), snd := HMul.hMul p.1 (Real.sin p.2) }","decl":"/-- The polar coordinates partial homeomorphism in `‚Ñù^2`, mapping `(r cos Œ∏, r sin Œ∏)` to `(r, Œ∏)`.\nIt is a homeomorphism between `‚Ñù^2 - (-‚àû, 0]` and `(0, +‚àû) √ó (-œÄ, œÄ)`. -/\n@[simps]\ndef polarCoord : PartialHomeomorph (‚Ñù √ó ‚Ñù) (‚Ñù √ó ‚Ñù) where\n  toFun q := (‚àö(q.1 ^ 2 + q.2 ^ 2), Complex.arg (Complex.equivRealProd.symm q))\n  invFun p := (p.1 * cos p.2, p.1 * sin p.2)\n  source := {q | 0 < q.1} ‚à™ {q | q.2 ‚â† 0}\n  target := Ioi (0 : ‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ\n  map_target' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    rcases eq_or_ne Œ∏ 0 with (rfl | h'Œ∏)\n    ¬∑ simpa using hr\n    ¬∑ right\n      simp at hr\n      simpa only [ne_of_gt hr, Ne, mem_setOf_eq, mul_eq_zero, false_or,\n        sin_eq_zero_iff_of_lt_of_lt hŒ∏.1 hŒ∏.2] using h'Œ∏\n  map_source' := by\n    rintro ‚ü®x, y‚ü© hxy\n    simp only [prod_mk_mem_set_prod_eq, mem_Ioi, sqrt_pos, mem_Ioo, Complex.neg_pi_lt_arg,\n      true_and, Complex.arg_lt_pi_iff]\n    constructor\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ dsimp at hxy; linarith [sq_pos_of_ne_zero hxy.ne', sq_nonneg y]\n      ¬∑ linarith [sq_nonneg x, sq_pos_of_ne_zero hxy]\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ exact Or.inl (le_of_lt hxy)\n      ¬∑ exact Or.inr hxy\n  right_inv' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    simp only [Prod.mk.inj_iff]\n    constructor\n    ¬∑ conv_rhs => rw [‚Üê sqrt_sq (le_of_lt hr), ‚Üê one_mul (r ^ 2), ‚Üê sin_sq_add_cos_sq Œ∏]\n      congr 1\n      ring\n    ¬∑ convert Complex.arg_mul_cos_add_sin_mul_I hr ‚ü®hŒ∏.1, hŒ∏.2.le‚ü©\n      simp only [Complex.equivRealProd_symm_apply, Complex.ofReal_mul, Complex.ofReal_cos,\n        Complex.ofReal_sin]\n      ring\n  left_inv' := by\n    rintro ‚ü®x, y‚ü© _\n    have A : ‚àö(x ^ 2 + y ^ 2) = Complex.abs (x + y * Complex.I) := by\n      rw [Complex.abs_apply, Complex.normSq_add_mul_I]\n    have Z := Complex.abs_mul_cos_add_sin_mul_I (x + y * Complex.I)\n    simp only [‚Üê Complex.ofReal_cos, ‚Üê Complex.ofReal_sin, mul_add, ‚Üê Complex.ofReal_mul, ‚Üê\n      mul_assoc] at Z\n    simp [A]\n  open_target := isOpen_Ioi.prod isOpen_Ioo\n  open_source :=\n    (isOpen_lt continuous_const continuous_fst).union\n      (isOpen_ne_fun continuous_snd continuous_const)\n  continuousOn_invFun :=\n    ((continuous_fst.mul (continuous_cos.comp continuous_snd)).prod_mk\n        (continuous_fst.mul (continuous_sin.comp continuous_snd))).continuousOn\n  continuousOn_toFun := by\n    apply ((continuous_fst.pow 2).add (continuous_snd.pow 2)).sqrt.continuousOn.prod\n    have A : MapsTo Complex.equivRealProd.symm ({q : ‚Ñù √ó ‚Ñù | 0 < q.1} ‚à™ {q : ‚Ñù √ó ‚Ñù | q.2 ‚â† 0})\n        Complex.slitPlane := by\n      rintro ‚ü®x, y‚ü© hxy; simpa only using hxy\n    refine ContinuousOn.comp (f := Complex.equivRealProd.symm)\n      (g := Complex.arg) (fun z hz => ?_) ?_ A\n    ¬∑ exact (Complex.continuousAt_arg hz).continuousWithinAt\n    ¬∑ exact Complex.equivRealProdCLM.symm.continuous.continuousOn\n\n"}
{"name":"polarCoord_source","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ Eq polarCoord.source (Union.union (setOf fun q => LT.lt 0 q.1) (setOf fun q => Ne q.2 0))","decl":"/-- The polar coordinates partial homeomorphism in `‚Ñù^2`, mapping `(r cos Œ∏, r sin Œ∏)` to `(r, Œ∏)`.\nIt is a homeomorphism between `‚Ñù^2 - (-‚àû, 0]` and `(0, +‚àû) √ó (-œÄ, œÄ)`. -/\n@[simps]\ndef polarCoord : PartialHomeomorph (‚Ñù √ó ‚Ñù) (‚Ñù √ó ‚Ñù) where\n  toFun q := (‚àö(q.1 ^ 2 + q.2 ^ 2), Complex.arg (Complex.equivRealProd.symm q))\n  invFun p := (p.1 * cos p.2, p.1 * sin p.2)\n  source := {q | 0 < q.1} ‚à™ {q | q.2 ‚â† 0}\n  target := Ioi (0 : ‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ\n  map_target' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    rcases eq_or_ne Œ∏ 0 with (rfl | h'Œ∏)\n    ¬∑ simpa using hr\n    ¬∑ right\n      simp at hr\n      simpa only [ne_of_gt hr, Ne, mem_setOf_eq, mul_eq_zero, false_or,\n        sin_eq_zero_iff_of_lt_of_lt hŒ∏.1 hŒ∏.2] using h'Œ∏\n  map_source' := by\n    rintro ‚ü®x, y‚ü© hxy\n    simp only [prod_mk_mem_set_prod_eq, mem_Ioi, sqrt_pos, mem_Ioo, Complex.neg_pi_lt_arg,\n      true_and, Complex.arg_lt_pi_iff]\n    constructor\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ dsimp at hxy; linarith [sq_pos_of_ne_zero hxy.ne', sq_nonneg y]\n      ¬∑ linarith [sq_nonneg x, sq_pos_of_ne_zero hxy]\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ exact Or.inl (le_of_lt hxy)\n      ¬∑ exact Or.inr hxy\n  right_inv' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    simp only [Prod.mk.inj_iff]\n    constructor\n    ¬∑ conv_rhs => rw [‚Üê sqrt_sq (le_of_lt hr), ‚Üê one_mul (r ^ 2), ‚Üê sin_sq_add_cos_sq Œ∏]\n      congr 1\n      ring\n    ¬∑ convert Complex.arg_mul_cos_add_sin_mul_I hr ‚ü®hŒ∏.1, hŒ∏.2.le‚ü©\n      simp only [Complex.equivRealProd_symm_apply, Complex.ofReal_mul, Complex.ofReal_cos,\n        Complex.ofReal_sin]\n      ring\n  left_inv' := by\n    rintro ‚ü®x, y‚ü© _\n    have A : ‚àö(x ^ 2 + y ^ 2) = Complex.abs (x + y * Complex.I) := by\n      rw [Complex.abs_apply, Complex.normSq_add_mul_I]\n    have Z := Complex.abs_mul_cos_add_sin_mul_I (x + y * Complex.I)\n    simp only [‚Üê Complex.ofReal_cos, ‚Üê Complex.ofReal_sin, mul_add, ‚Üê Complex.ofReal_mul, ‚Üê\n      mul_assoc] at Z\n    simp [A]\n  open_target := isOpen_Ioi.prod isOpen_Ioo\n  open_source :=\n    (isOpen_lt continuous_const continuous_fst).union\n      (isOpen_ne_fun continuous_snd continuous_const)\n  continuousOn_invFun :=\n    ((continuous_fst.mul (continuous_cos.comp continuous_snd)).prod_mk\n        (continuous_fst.mul (continuous_sin.comp continuous_snd))).continuousOn\n  continuousOn_toFun := by\n    apply ((continuous_fst.pow 2).add (continuous_snd.pow 2)).sqrt.continuousOn.prod\n    have A : MapsTo Complex.equivRealProd.symm ({q : ‚Ñù √ó ‚Ñù | 0 < q.1} ‚à™ {q : ‚Ñù √ó ‚Ñù | q.2 ‚â† 0})\n        Complex.slitPlane := by\n      rintro ‚ü®x, y‚ü© hxy; simpa only using hxy\n    refine ContinuousOn.comp (f := Complex.equivRealProd.symm)\n      (g := Complex.arg) (fun z hz => ?_) ?_ A\n    ¬∑ exact (Complex.continuousAt_arg hz).continuousWithinAt\n    ¬∑ exact Complex.equivRealProdCLM.symm.continuous.continuousOn\n\n"}
{"name":"polarCoord_target","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ Eq polarCoord.target (SProd.sprod (Set.Ioi 0) (Set.Ioo (Neg.neg Real.pi) Real.pi))","decl":"/-- The polar coordinates partial homeomorphism in `‚Ñù^2`, mapping `(r cos Œ∏, r sin Œ∏)` to `(r, Œ∏)`.\nIt is a homeomorphism between `‚Ñù^2 - (-‚àû, 0]` and `(0, +‚àû) √ó (-œÄ, œÄ)`. -/\n@[simps]\ndef polarCoord : PartialHomeomorph (‚Ñù √ó ‚Ñù) (‚Ñù √ó ‚Ñù) where\n  toFun q := (‚àö(q.1 ^ 2 + q.2 ^ 2), Complex.arg (Complex.equivRealProd.symm q))\n  invFun p := (p.1 * cos p.2, p.1 * sin p.2)\n  source := {q | 0 < q.1} ‚à™ {q | q.2 ‚â† 0}\n  target := Ioi (0 : ‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ\n  map_target' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    rcases eq_or_ne Œ∏ 0 with (rfl | h'Œ∏)\n    ¬∑ simpa using hr\n    ¬∑ right\n      simp at hr\n      simpa only [ne_of_gt hr, Ne, mem_setOf_eq, mul_eq_zero, false_or,\n        sin_eq_zero_iff_of_lt_of_lt hŒ∏.1 hŒ∏.2] using h'Œ∏\n  map_source' := by\n    rintro ‚ü®x, y‚ü© hxy\n    simp only [prod_mk_mem_set_prod_eq, mem_Ioi, sqrt_pos, mem_Ioo, Complex.neg_pi_lt_arg,\n      true_and, Complex.arg_lt_pi_iff]\n    constructor\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ dsimp at hxy; linarith [sq_pos_of_ne_zero hxy.ne', sq_nonneg y]\n      ¬∑ linarith [sq_nonneg x, sq_pos_of_ne_zero hxy]\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ exact Or.inl (le_of_lt hxy)\n      ¬∑ exact Or.inr hxy\n  right_inv' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    simp only [Prod.mk.inj_iff]\n    constructor\n    ¬∑ conv_rhs => rw [‚Üê sqrt_sq (le_of_lt hr), ‚Üê one_mul (r ^ 2), ‚Üê sin_sq_add_cos_sq Œ∏]\n      congr 1\n      ring\n    ¬∑ convert Complex.arg_mul_cos_add_sin_mul_I hr ‚ü®hŒ∏.1, hŒ∏.2.le‚ü©\n      simp only [Complex.equivRealProd_symm_apply, Complex.ofReal_mul, Complex.ofReal_cos,\n        Complex.ofReal_sin]\n      ring\n  left_inv' := by\n    rintro ‚ü®x, y‚ü© _\n    have A : ‚àö(x ^ 2 + y ^ 2) = Complex.abs (x + y * Complex.I) := by\n      rw [Complex.abs_apply, Complex.normSq_add_mul_I]\n    have Z := Complex.abs_mul_cos_add_sin_mul_I (x + y * Complex.I)\n    simp only [‚Üê Complex.ofReal_cos, ‚Üê Complex.ofReal_sin, mul_add, ‚Üê Complex.ofReal_mul, ‚Üê\n      mul_assoc] at Z\n    simp [A]\n  open_target := isOpen_Ioi.prod isOpen_Ioo\n  open_source :=\n    (isOpen_lt continuous_const continuous_fst).union\n      (isOpen_ne_fun continuous_snd continuous_const)\n  continuousOn_invFun :=\n    ((continuous_fst.mul (continuous_cos.comp continuous_snd)).prod_mk\n        (continuous_fst.mul (continuous_sin.comp continuous_snd))).continuousOn\n  continuousOn_toFun := by\n    apply ((continuous_fst.pow 2).add (continuous_snd.pow 2)).sqrt.continuousOn.prod\n    have A : MapsTo Complex.equivRealProd.symm ({q : ‚Ñù √ó ‚Ñù | 0 < q.1} ‚à™ {q : ‚Ñù √ó ‚Ñù | q.2 ‚â† 0})\n        Complex.slitPlane := by\n      rintro ‚ü®x, y‚ü© hxy; simpa only using hxy\n    refine ContinuousOn.comp (f := Complex.equivRealProd.symm)\n      (g := Complex.arg) (fun z hz => ?_) ?_ A\n    ¬∑ exact (Complex.continuousAt_arg hz).continuousWithinAt\n    ¬∑ exact Complex.equivRealProdCLM.symm.continuous.continuousOn\n\n"}
{"name":"polarCoord_apply","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"q : Prod Real Real\n‚ä¢ Eq (‚ÜëpolarCoord q) { fst := (HAdd.hAdd (HPow.hPow q.1 2) (HPow.hPow q.2 2)).sqrt, snd := (Complex.equivRealProd.symm q).arg }","decl":"/-- The polar coordinates partial homeomorphism in `‚Ñù^2`, mapping `(r cos Œ∏, r sin Œ∏)` to `(r, Œ∏)`.\nIt is a homeomorphism between `‚Ñù^2 - (-‚àû, 0]` and `(0, +‚àû) √ó (-œÄ, œÄ)`. -/\n@[simps]\ndef polarCoord : PartialHomeomorph (‚Ñù √ó ‚Ñù) (‚Ñù √ó ‚Ñù) where\n  toFun q := (‚àö(q.1 ^ 2 + q.2 ^ 2), Complex.arg (Complex.equivRealProd.symm q))\n  invFun p := (p.1 * cos p.2, p.1 * sin p.2)\n  source := {q | 0 < q.1} ‚à™ {q | q.2 ‚â† 0}\n  target := Ioi (0 : ‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ\n  map_target' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    rcases eq_or_ne Œ∏ 0 with (rfl | h'Œ∏)\n    ¬∑ simpa using hr\n    ¬∑ right\n      simp at hr\n      simpa only [ne_of_gt hr, Ne, mem_setOf_eq, mul_eq_zero, false_or,\n        sin_eq_zero_iff_of_lt_of_lt hŒ∏.1 hŒ∏.2] using h'Œ∏\n  map_source' := by\n    rintro ‚ü®x, y‚ü© hxy\n    simp only [prod_mk_mem_set_prod_eq, mem_Ioi, sqrt_pos, mem_Ioo, Complex.neg_pi_lt_arg,\n      true_and, Complex.arg_lt_pi_iff]\n    constructor\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ dsimp at hxy; linarith [sq_pos_of_ne_zero hxy.ne', sq_nonneg y]\n      ¬∑ linarith [sq_nonneg x, sq_pos_of_ne_zero hxy]\n    ¬∑ cases' hxy with hxy hxy\n      ¬∑ exact Or.inl (le_of_lt hxy)\n      ¬∑ exact Or.inr hxy\n  right_inv' := by\n    rintro ‚ü®r, Œ∏‚ü© ‚ü®hr, hŒ∏‚ü©\n    dsimp at hr hŒ∏\n    simp only [Prod.mk.inj_iff]\n    constructor\n    ¬∑ conv_rhs => rw [‚Üê sqrt_sq (le_of_lt hr), ‚Üê one_mul (r ^ 2), ‚Üê sin_sq_add_cos_sq Œ∏]\n      congr 1\n      ring\n    ¬∑ convert Complex.arg_mul_cos_add_sin_mul_I hr ‚ü®hŒ∏.1, hŒ∏.2.le‚ü©\n      simp only [Complex.equivRealProd_symm_apply, Complex.ofReal_mul, Complex.ofReal_cos,\n        Complex.ofReal_sin]\n      ring\n  left_inv' := by\n    rintro ‚ü®x, y‚ü© _\n    have A : ‚àö(x ^ 2 + y ^ 2) = Complex.abs (x + y * Complex.I) := by\n      rw [Complex.abs_apply, Complex.normSq_add_mul_I]\n    have Z := Complex.abs_mul_cos_add_sin_mul_I (x + y * Complex.I)\n    simp only [‚Üê Complex.ofReal_cos, ‚Üê Complex.ofReal_sin, mul_add, ‚Üê Complex.ofReal_mul, ‚Üê\n      mul_assoc] at Z\n    simp [A]\n  open_target := isOpen_Ioi.prod isOpen_Ioo\n  open_source :=\n    (isOpen_lt continuous_const continuous_fst).union\n      (isOpen_ne_fun continuous_snd continuous_const)\n  continuousOn_invFun :=\n    ((continuous_fst.mul (continuous_cos.comp continuous_snd)).prod_mk\n        (continuous_fst.mul (continuous_sin.comp continuous_snd))).continuousOn\n  continuousOn_toFun := by\n    apply ((continuous_fst.pow 2).add (continuous_snd.pow 2)).sqrt.continuousOn.prod\n    have A : MapsTo Complex.equivRealProd.symm ({q : ‚Ñù √ó ‚Ñù | 0 < q.1} ‚à™ {q : ‚Ñù √ó ‚Ñù | q.2 ‚â† 0})\n        Complex.slitPlane := by\n      rintro ‚ü®x, y‚ü© hxy; simpa only using hxy\n    refine ContinuousOn.comp (f := Complex.equivRealProd.symm)\n      (g := Complex.arg) (fun z hz => ?_) ?_ A\n    ¬∑ exact (Complex.continuousAt_arg hz).continuousWithinAt\n    ¬∑ exact Complex.equivRealProdCLM.symm.continuous.continuousOn\n\n"}
{"name":"hasFDerivAt_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ HasFDerivAt (‚ÜëpolarCoord.symm) (fderivPolarCoordSymm p) p","decl":"theorem hasFDerivAt_polarCoord_symm (p : ‚Ñù √ó ‚Ñù) :\n    HasFDerivAt polarCoord.symm (fderivPolarCoordSymm p) p := by\n  unfold fderivPolarCoordSymm\n  rw [Matrix.toLin_finTwoProd_toContinuousLinearMap]\n  convert HasFDerivAt.prod (ùïú := ‚Ñù)\n    (hasFDerivAt_fst.mul ((hasDerivAt_cos p.2).comp_hasFDerivAt p hasFDerivAt_snd))\n    (hasFDerivAt_fst.mul ((hasDerivAt_sin p.2).comp_hasFDerivAt p hasFDerivAt_snd)) using 2 <;>\n  simp [smul_smul, add_comm, neg_mul, smul_neg, neg_smul _ (ContinuousLinearMap.snd ‚Ñù ‚Ñù ‚Ñù)]\n\n"}
{"name":"det_fderivPolarCoordSymm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (fderivPolarCoordSymm p).det p.1","decl":"theorem det_fderivPolarCoordSymm (p : ‚Ñù √ó ‚Ñù) :\n    (fderivPolarCoordSymm p).det = p.1 := by\n  conv_rhs => rw [‚Üê one_mul p.1, ‚Üê cos_sq_add_sin_sq p.2]\n  unfold fderivPolarCoordSymm\n  simp only [neg_mul, LinearMap.det_toContinuousLinearMap, LinearMap.det_toLin,\n    Matrix.det_fin_two_of, sub_neg_eq_add]\n  ring\n\n-- Porting note: this instance is needed but not automatically synthesised\n"}
{"name":"instIsAddHaarMeasureProdRealVolume","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance : Measure.IsAddHaarMeasure volume (G := ‚Ñù √ó ‚Ñù) :=\n  Measure.prod.instIsAddHaarMeasure _ _\n\n"}
{"name":"polarCoord_source_ae_eq_univ","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq polarCoord.source Set.univ","decl":"theorem polarCoord_source_ae_eq_univ : polarCoord.source =·µê[volume] univ := by\n  have A : polarCoord.source·∂ú ‚äÜ LinearMap.ker (LinearMap.snd ‚Ñù ‚Ñù ‚Ñù) := by\n    intro x hx\n    simp only [polarCoord_source, compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_lt,\n      Classical.not_not] at hx\n    exact hx.2\n  have B : volume (LinearMap.ker (LinearMap.snd ‚Ñù ‚Ñù ‚Ñù) : Set (‚Ñù √ó ‚Ñù)) = 0 := by\n    apply Measure.addHaar_submodule\n    rw [Ne, LinearMap.ker_eq_top]\n    intro h\n    have : (LinearMap.snd ‚Ñù ‚Ñù ‚Ñù) (0, 1) = (0 : ‚Ñù √ó ‚Ñù ‚Üí‚Çó[‚Ñù] ‚Ñù) (0, 1) := by rw [h]\n    simp at this\n  simp only [ae_eq_univ]\n  exact le_antisymm ((measure_mono A).trans (le_of_eq B)) bot_le\n\n"}
{"name":"integral_comp_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Prod Real Real ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict polarCoord.target) fun p => HSMul.hSMul p.1 (f (‚ÜëpolarCoord.symm p))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"theorem integral_comp_polarCoord_symm {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]\n    (f : ‚Ñù √ó ‚Ñù ‚Üí E) :\n    (‚à´ p in polarCoord.target, p.1 ‚Ä¢ f (polarCoord.symm p)) = ‚à´ p, f p := by\n  symm\n  calc\n    ‚à´ p, f p = ‚à´ p in polarCoord.source, f p := by\n      rw [‚Üê setIntegral_univ]\n      apply setIntegral_congr_set\n      exact polarCoord_source_ae_eq_univ.symm\n    _ = ‚à´ p in polarCoord.target, |p.1| ‚Ä¢ f (polarCoord.symm p) := by\n      rw [‚Üê PartialHomeomorph.symm_target, integral_target_eq_integral_abs_det_fderiv_smul volume\n      (fun p _ ‚Ü¶ hasFDerivAt_polarCoord_symm p), PartialHomeomorph.symm_source]\n      simp_rw [det_fderivPolarCoordSymm]\n    _ = ‚à´ p in polarCoord.target, p.1 ‚Ä¢ f (polarCoord.symm p) := by\n      apply setIntegral_congr_fun polarCoord.open_target.measurableSet fun x hx => ?_\n      rw [abs_of_pos hx.1]\n\n"}
{"name":"lintegral_comp_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"f : Prod Real Real ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict polarCoord.target) fun p => HSMul.hSMul (ENNReal.ofReal p.1) (f (‚ÜëpolarCoord.symm p))) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"theorem lintegral_comp_polarCoord_symm (f : ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù‚â•0‚àû) :\n    ‚à´‚Åª (p : ‚Ñù √ó ‚Ñù) in polarCoord.target, ENNReal.ofReal p.1 ‚Ä¢ f (polarCoord.symm p) =\n      ‚à´‚Åª (p : ‚Ñù √ó ‚Ñù), f p := by\n  symm\n  calc\n    _ = ‚à´‚Åª p in polarCoord.symm '' polarCoord.target, f p := by\n      rw [‚Üê setLIntegral_univ, setLIntegral_congr polarCoord_source_ae_eq_univ.symm,\n        polarCoord.symm_image_target_eq_source ]\n    _ = ‚à´‚Åª (p : ‚Ñù √ó ‚Ñù) in polarCoord.target, ENNReal.ofReal |p.1| ‚Ä¢ f (polarCoord.symm p) := by\n      rw [lintegral_image_eq_lintegral_abs_det_fderiv_mul volume _\n        (fun p _ ‚Ü¶ (hasFDerivAt_polarCoord_symm p).hasFDerivWithinAt)]\n      ¬∑ simp_rw [det_fderivPolarCoordSymm]; rfl\n      exacts [polarCoord.symm.injOn, measurableSet_Ioi.prod measurableSet_Ioo]\n    _ = ‚à´‚Åª (p : ‚Ñù √ó ‚Ñù) in polarCoord.target, ENNReal.ofReal p.1 ‚Ä¢ f (polarCoord.symm p) := by\n      refine setLIntegral_congr_fun polarCoord.open_target.measurableSet ?_\n      filter_upwards with _ hx using by rw [abs_of_pos hx.1]\n\n"}
{"name":"Complex.polarCoord_apply","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"a : Complex\n‚ä¢ Eq (‚ÜëComplex.polarCoord a) { fst := Complex.abs a, snd := a.arg }","decl":"protected theorem polarCoord_apply (a : ‚ÑÇ) :\n    Complex.polarCoord a = (Complex.abs a, Complex.arg a) := by\n  simp_rw [Complex.abs_def, Complex.normSq_apply, ‚Üê pow_two]\n  rfl\n\n"}
{"name":"Complex.polarCoord_source","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ Eq Complex.polarCoord.source Complex.slitPlane","decl":"protected theorem polarCoord_source : Complex.polarCoord.source = slitPlane := rfl\n\n"}
{"name":"Complex.polarCoord_target","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"‚ä¢ Eq Complex.polarCoord.target (SProd.sprod (Set.Ioi 0) (Set.Ioo (Neg.neg Real.pi) Real.pi))","decl":"protected theorem polarCoord_target :\n    Complex.polarCoord.target = Set.Ioi (0 : ‚Ñù) √óÀ¢ Set.Ioo (-œÄ) œÄ := rfl\n\n"}
{"name":"Complex.polarCoord_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (‚ÜëComplex.polarCoord.symm p) (HMul.hMul (‚Üëp.1) (HAdd.hAdd (‚Üë(Real.cos p.2)) (HMul.hMul (‚Üë(Real.sin p.2)) Complex.I)))","decl":"@[simp]\nprotected theorem polarCoord_symm_apply (p : ‚Ñù √ó ‚Ñù) :\n    Complex.polarCoord.symm p = p.1 * (Real.cos p.2 + Real.sin p.2 * Complex.I) := by\n  simp [Complex.polarCoord, equivRealProdCLM_symm_apply, mul_add, mul_assoc]\n\n"}
{"name":"Complex.measurableEquivRealProd_symm_polarCoord_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (Complex.measurableEquivRealProd.symm (‚ÜëpolarCoord.symm p)) (‚ÜëComplex.polarCoord.symm p)","decl":"theorem measurableEquivRealProd_symm_polarCoord_symm_apply (p : ‚Ñù √ó ‚Ñù) :\n    (measurableEquivRealProd.symm (polarCoord.symm p)) = Complex.polarCoord.symm p := rfl\n\n"}
{"name":"Complex.polarCoord_symm_abs","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (Complex.abs (‚ÜëComplex.polarCoord.symm p)) (abs p.1)","decl":"theorem polarCoord_symm_abs (p : ‚Ñù √ó ‚Ñù) :\n    Complex.abs (Complex.polarCoord.symm p) = |p.1| := by simp\n\n"}
{"name":"Complex.integral_comp_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Complex ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict polarCoord.target) fun p => HSMul.hSMul p.1 (f (‚ÜëComplex.polarCoord.symm p))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"protected theorem integral_comp_polarCoord_symm {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] (f : ‚ÑÇ ‚Üí E) :\n    (‚à´ p in polarCoord.target, p.1 ‚Ä¢ f (Complex.polarCoord.symm p)) = ‚à´ p, f p := by\n  rw [‚Üê (Complex.volume_preserving_equiv_real_prod.symm).integral_comp\n    measurableEquivRealProd.symm.measurableEmbedding, ‚Üê integral_comp_polarCoord_symm]\n  simp_rw [measurableEquivRealProd_symm_polarCoord_symm_apply]\n\n"}
{"name":"Complex.lintegral_comp_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"f : Complex ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict polarCoord.target) fun p => HSMul.hSMul (ENNReal.ofReal p.1) (f (‚ÜëComplex.polarCoord.symm p))) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"protected theorem lintegral_comp_polarCoord_symm (f : ‚ÑÇ ‚Üí ‚Ñù‚â•0‚àû) :\n    (‚à´‚Åª p in polarCoord.target, ENNReal.ofReal p.1 ‚Ä¢ f (Complex.polarCoord.symm p)) =\n      ‚à´‚Åª p, f p := by\n  rw [‚Üê (volume_preserving_equiv_real_prod.symm).lintegral_comp_emb\n    measurableEquivRealProd.symm.measurableEmbedding, ‚Üê lintegral_comp_polarCoord_symm]\n  simp_rw [measurableEquivRealProd_symm_polarCoord_symm_apply]\n\n"}
{"name":"injOn_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\n‚ä¢ Set.InjOn (fun p i => ‚ÜëpolarCoord.symm (p i)) (Set.univ.pi fun x => polarCoord.target)","decl":"theorem injOn_pi_polarCoord_symm :\n    Set.InjOn (fun p (i : Œπ) ‚Ü¶ polarCoord.symm (p i)) (Set.univ.pi fun _ ‚Ü¶ polarCoord.target) :=\n  fun _ hx _ hy h ‚Ü¶ funext fun i ‚Ü¶ polarCoord.symm.injOn (hx i trivial) (hy i trivial)\n    ((funext_iff.mp h) i)\n\n"}
{"name":"abs_fst_of_mem_pi_polarCoord_target","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\np : Œπ ‚Üí Prod Real Real\nhp : Membership.mem (Set.univ.pi fun x => polarCoord.target) p\ni : Œπ\n‚ä¢ Eq (abs (p i).1) (p i).1","decl":"theorem abs_fst_of_mem_pi_polarCoord_target {p : Œπ ‚Üí ‚Ñù √ó ‚Ñù}\n    (hp : p ‚àà (Set.univ.pi fun _ : Œπ ‚Ü¶ polarCoord.target)) (i : Œπ) :\n    |(p i).1| = (p i).1 :=\n  abs_of_pos ((Set.mem_univ_pi.mp hp) i).1\n\n"}
{"name":"hasFDerivAt_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\np : Œπ ‚Üí Prod Real Real\n‚ä¢ HasFDerivAt (fun x i => ‚ÜëpolarCoord.symm (x i)) (fderivPiPolarCoordSymm p) p","decl":"theorem hasFDerivAt_pi_polarCoord_symm (p : Œπ ‚Üí ‚Ñù √ó ‚Ñù) :\n    HasFDerivAt (fun x i ‚Ü¶ polarCoord.symm (x i)) (fderivPiPolarCoordSymm p) p := by\n  rw [fderivPiPolarCoordSymm, hasFDerivAt_pi]\n  exact fun i ‚Ü¶ HasFDerivAt.comp _ (hasFDerivAt_polarCoord_symm _) (hasFDerivAt_apply i _)\n\n"}
{"name":"det_fderivPiPolarCoordSymm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\np : Œπ ‚Üí Prod Real Real\n‚ä¢ Eq (fderivPiPolarCoordSymm p).det (Finset.univ.prod fun i => (p i).1)","decl":"theorem det_fderivPiPolarCoordSymm (p : Œπ ‚Üí ‚Ñù √ó ‚Ñù) :\n    (fderivPiPolarCoordSymm p).det = ‚àè i, (p i).1 := by\n  simp_rw [fderivPiPolarCoordSymm, ContinuousLinearMap.det_pi, det_fderivPolarCoordSymm]\n\n"}
{"name":"pi_polarCoord_symm_target_ae_eq_univ","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (Set.image (Pi.map fun x => ‚ÜëpolarCoord.symm) (Set.univ.pi fun x => polarCoord.target)) Set.univ","decl":"theorem pi_polarCoord_symm_target_ae_eq_univ :\n    (Pi.map (fun _ : Œπ ‚Ü¶ polarCoord.symm) '' Set.univ.pi fun _ ‚Ü¶ polarCoord.target)\n        =·µê[volume] Set.univ := by\n  rw [Set.piMap_image_univ_pi, polarCoord.symm_image_target_eq_source, volume_pi, ‚Üê Set.pi_univ]\n  exact ae_eq_set_pi fun _ _ ‚Ü¶ polarCoord_source_ae_eq_univ\n\n"}
{"name":"measurableSet_pi_polarCoord_target","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\n‚ä¢ MeasurableSet (Set.univ.pi fun x => polarCoord.target)","decl":"theorem measurableSet_pi_polarCoord_target :\n    MeasurableSet (Set.univ.pi fun _ : Œπ ‚Ü¶ polarCoord.target) :=\n  MeasurableSet.univ_pi fun _ ‚Ü¶ polarCoord.open_target.measurableSet\n\n"}
{"name":"integral_comp_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù¬≤ : Fintype Œπ\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : (Œπ ‚Üí Prod Real Real) ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.univ.pi fun x => polarCoord.target)) fun p => HSMul.hSMul (Finset.univ.prod fun i => (p i).1) (f fun i => ‚ÜëpolarCoord.symm (p i))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"theorem integral_comp_pi_polarCoord_symm {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]\n    (f : (Œπ ‚Üí ‚Ñù √ó ‚Ñù) ‚Üí E) :\n    (‚à´ p in (Set.univ.pi fun _ : Œπ ‚Ü¶ polarCoord.target),\n      (‚àè i, (p i).1) ‚Ä¢ f (fun i ‚Ü¶ polarCoord.symm (p i))) = ‚à´ p, f p := by\n  rw [‚Üê setIntegral_univ (f := f), ‚Üê setIntegral_congr_set pi_polarCoord_symm_target_ae_eq_univ]\n  convert (integral_image_eq_integral_abs_det_fderiv_smul volume measurableSet_pi_polarCoord_target\n    (fun p _ ‚Ü¶ (hasFDerivAt_pi_polarCoord_symm p).hasFDerivWithinAt)\n      injOn_pi_polarCoord_symm f).symm using 1\n  refine setIntegral_congr_fun measurableSet_pi_polarCoord_target fun x hx ‚Ü¶ ?_\n  simp_rw [det_fderivPiPolarCoordSymm, Finset.abs_prod, abs_fst_of_mem_pi_polarCoord_target hx]\n\n"}
{"name":"Complex.integral_comp_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù¬≤ : Fintype Œπ\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : (Œπ ‚Üí Complex) ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.univ.pi fun x => Complex.polarCoord.target)) fun p => HSMul.hSMul (Finset.univ.prod fun i => (p i).1) (f fun i => ‚ÜëComplex.polarCoord.symm (p i))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"protected theorem Complex.integral_comp_pi_polarCoord_symm {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ‚Ñù E] (f : (Œπ ‚Üí ‚ÑÇ) ‚Üí E) :\n    (‚à´ p in (Set.univ.pi fun _ : Œπ ‚Ü¶ Complex.polarCoord.target),\n      (‚àè i, (p i).1) ‚Ä¢ f (fun i ‚Ü¶ Complex.polarCoord.symm (p i))) = ‚à´ p, f p := by\n  let e := MeasurableEquiv.piCongrRight (fun _ : Œπ ‚Ü¶ measurableEquivRealProd.symm)\n  have := volume_preserving_pi (fun _ : Œπ ‚Ü¶ Complex.volume_preserving_equiv_real_prod.symm)\n  rw [‚Üê MeasurePreserving.integral_comp this e.measurableEmbedding f]\n  exact integral_comp_pi_polarCoord_symm (f ‚àò e)\n\n"}
{"name":"lintegral_comp_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nf : (Œπ ‚Üí Prod Real Real) ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.univ.pi fun x => polarCoord.target)) fun p => HMul.hMul (Finset.univ.prod fun i => ENNReal.ofReal (p i).1) (f fun i => ‚ÜëpolarCoord.symm (p i))) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"theorem lintegral_comp_pi_polarCoord_symm (f : (Œπ ‚Üí ‚Ñù √ó ‚Ñù) ‚Üí ‚Ñù‚â•0‚àû) :\n    ‚à´‚Åª p in (Set.univ.pi fun _ : Œπ ‚Ü¶ polarCoord.target),\n      (‚àè i, .ofReal (p i).1) * f (fun i ‚Ü¶ polarCoord.symm (p i)) = ‚à´‚Åª p, f p := by\n  rw [‚Üê setLIntegral_univ f, ‚Üê setLIntegral_congr pi_polarCoord_symm_target_ae_eq_univ]\n  convert (lintegral_image_eq_lintegral_abs_det_fderiv_mul volume measurableSet_pi_polarCoord_target\n    (fun p _ ‚Ü¶ (hasFDerivAt_pi_polarCoord_symm p).hasFDerivWithinAt)\n      injOn_pi_polarCoord_symm f).symm using 1\n  refine setLIntegral_congr_fun measurableSet_pi_polarCoord_target ?_\n  filter_upwards with x hx\n  simp_rw [det_fderivPiPolarCoordSymm, Finset.abs_prod, ENNReal.ofReal_prod_of_nonneg (fun _ _ ‚Ü¶\n    abs_nonneg _), abs_fst_of_mem_pi_polarCoord_target hx]\n\n"}
{"name":"Complex.lintegral_comp_pi_polarCoord_symm","module":"Mathlib.Analysis.SpecialFunctions.PolarCoord","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nf : (Œπ ‚Üí Complex) ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.univ.pi fun x => Complex.polarCoord.target)) fun p => HMul.hMul (Finset.univ.prod fun i => ENNReal.ofReal (p i).1) (f fun i => ‚ÜëComplex.polarCoord.symm (p i))) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun p => f p)","decl":"protected theorem Complex.lintegral_comp_pi_polarCoord_symm (f : (Œπ ‚Üí ‚ÑÇ) ‚Üí ‚Ñù‚â•0‚àû) :\n    ‚à´‚Åª p in (Set.univ.pi fun _ : Œπ ‚Ü¶ Complex.polarCoord.target),\n      (‚àè i, .ofReal (p i).1) * f (fun i ‚Ü¶ Complex.polarCoord.symm (p i)) = ‚à´‚Åª p, f p := by\n  let e := MeasurableEquiv.piCongrRight (fun _ : Œπ ‚Ü¶ measurableEquivRealProd.symm)\n  have := volume_preserving_pi (fun _ : Œπ ‚Ü¶ Complex.volume_preserving_equiv_real_prod.symm)\n  rw [‚Üê MeasurePreserving.lintegral_comp_emb this e.measurableEmbedding]\n  exact lintegral_comp_pi_polarCoord_symm (f ‚àò e)\n\n"}
