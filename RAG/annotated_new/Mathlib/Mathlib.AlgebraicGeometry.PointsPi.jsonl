{"name":"AlgebraicGeometry.Ideal.span_eq_top_of_span_image_evalRingHom","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u_2\nR : Î¹ â†’ Type u_1\ninstâœ : (i : Î¹) â†’ CommRing (R i)\ns : Set ((i : Î¹) â†’ R i)\nhs : s.Finite\nhs' : âˆ€ (i : Î¹), Eq (Ideal.span (Set.image (â‡‘(Pi.evalRingHom (fun x => R x) i)) s)) Top.top\nâŠ¢ Eq (Ideal.span s) Top.top","decl":"lemma Ideal.span_eq_top_of_span_image_evalRingHom\n    {Î¹} {R : Î¹ â†’ Type*} [âˆ€ i, CommRing (R i)] (s : Set (Î  i, R i))\n    (hs : s.Finite) (hs' : âˆ€ i, Ideal.span (Pi.evalRingHom (R Â·) i '' s) = âŠ¤) :\n    Ideal.span s = âŠ¤ := by\n  simp only [Ideal.eq_top_iff_one, â† Subtype.range_val (s := s), â† Set.range_comp,\n    Finsupp.mem_ideal_span_range_iff_exists_finsupp] at hs' âŠ¢\n  choose f hf using hs'\n  have : Fintype s := hs.fintype\n  refine âŸ¨Finsupp.equivFunOnFinite.symm fun i x â†¦ f x i, ?_âŸ©\n  ext i\n  simpa [Finsupp.sum_fintype] using hf i\n\n"}
{"name":"AlgebraicGeometry.eq_top_of_sigmaSpec_subset_of_isCompact","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nU : (AlgebraicGeometry.Spec (CommRingCat.of ((i : Î¹) â†’ â†‘(R i)))).Opens\nV : Set â†‘â†‘(AlgebraicGeometry.Spec (CommRingCat.of ((i : Î¹) â†’ â†‘(R i)))).toPresheafedSpace\nhV : HasSubset.Subset (â†‘(AlgebraicGeometry.Scheme.Hom.opensRange (AlgebraicGeometry.sigmaSpec R))) V\nhV' : IsCompact V\nhVU : HasSubset.Subset V â†‘U\nâŠ¢ Eq U Top.top","decl":"lemma eq_top_of_sigmaSpec_subset_of_isCompact\n    (U : (Spec (.of (Î  i, R i))).Opens) (V : Set (Spec (.of (Î  i, R i))))\n    (hV : â†‘(sigmaSpec R).opensRange âŠ† V)\n    (hV' : IsCompact (X := Spec (.of (Î  i, R i))) V)\n    (hVU : V âŠ† U) : U = âŠ¤ := by\n  obtain âŸ¨s, hsâŸ© := (PrimeSpectrum.isOpen_iff _).mp U.2\n  obtain âŸ¨t, hts, ht, ht'âŸ© : âˆƒ t âŠ† s, t.Finite âˆ§ V âŠ† â‹ƒ i âˆˆ t, (basicOpen i).1 := by\n    obtain âŸ¨t, htâŸ© := hV'.elim_finite_subcover\n      (fun i : s â†¦ (basicOpen i.1).1) (fun _ â†¦ (basicOpen _).2)\n      (by simpa [â† Set.compl_iInter, â† zeroLocus_iUnionâ‚‚ (Îº := (Â· âˆˆ s)), â† hs])\n    exact âŸ¨t.map (Function.Embedding.subtype _), by simp, Finset.finite_toSet _, by simpa using htâŸ©\n  replace ht' : V âŠ† (zeroLocus t)á¶œ := by\n    simpa [â† Set.compl_iInter, â† zeroLocus_iUnionâ‚‚ (Îº := (Â· âˆˆ t))] using ht'\n  have (i) : Ideal.span (Pi.evalRingHom (R Â·) i '' t) = âŠ¤ := by\n    rw [â† zeroLocus_empty_iff_eq_top, zeroLocus_span, â† preimage_comap_zeroLocus,\n      â† Set.compl_univ_iff, â† Set.preimage_compl, Set.preimage_eq_univ_iff]\n    trans (Sigma.Î¹ _ i â‰« sigmaSpec R).opensRange.1\n    Â· simp; rfl\n    Â· rw [Scheme.Hom.opensRange_comp]\n      exact (Set.image_subset_range _ _).trans (hV.trans ht')\n  have : Ideal.span s = âŠ¤ := top_le_iff.mp\n    ((Ideal.span_eq_top_of_span_image_evalRingHom _ ht this).ge.trans (Ideal.span_mono hts))\n  simpa [â† zeroLocus_span s, zeroLocus_empty_iff_eq_top.mpr this] using hs\n\n"}
{"name":"AlgebraicGeometry.eq_bot_of_comp_quotientMk_eq_sigmaSpec","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nI : Ideal ((i : Î¹) â†’ â†‘(R i))\nf : Quiver.Hom (CategoryTheory.Limits.sigmaObj fun i => AlgebraicGeometry.Spec (R i)) (AlgebraicGeometry.Spec (CommRingCat.of (HasQuotient.Quotient ((i : Î¹) â†’ â†‘(R i)) I)))\nhf : Eq (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)))) (AlgebraicGeometry.sigmaSpec R)\nâŠ¢ Eq I Bot.bot","decl":"lemma eq_bot_of_comp_quotientMk_eq_sigmaSpec (I : Ideal (Î  i, R i))\n    (f : (âˆ fun i â†¦ Spec (R i)) âŸ¶ Spec (.of ((Î  i, R i) â§¸ I)))\n    (hf : f â‰« Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)) = sigmaSpec R) :\n    I = âŠ¥ := by\n  refine le_bot_iff.mp fun x hx â†¦ ?_\n  ext i\n  simpa [â† Category.assoc, Ideal.Quotient.eq_zero_iff_mem.mpr hx] using\n    congr((Spec.preimage (Sigma.Î¹ (Spec <| R Â·) i â‰« $hf)).hom x).symm\n\n"}
{"name":"AlgebraicGeometry.isIso_of_comp_eq_sigmaSpec","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nV : AlgebraicGeometry.Scheme\nf : Quiver.Hom (CategoryTheory.Limits.sigmaObj fun i => AlgebraicGeometry.Spec (R i)) V\ng : Quiver.Hom V (AlgebraicGeometry.Spec (CommRingCat.of ((i : Î¹) â†’ â†‘(R i))))\ninstâœÂ¹ : AlgebraicGeometry.IsImmersion g\ninstâœ : CompactSpace â†‘â†‘V.toPresheafedSpace\nhU' : Eq (CategoryTheory.CategoryStruct.comp f g) (AlgebraicGeometry.sigmaSpec R)\nâŠ¢ CategoryTheory.IsIso g","decl":"/-- If `V` is a locally closed subscheme of `Spec (Î  Ráµ¢)` containing `âˆ Spec Ráµ¢`, then\n`V = Spec (Î  Ráµ¢)`. -/\nlemma isIso_of_comp_eq_sigmaSpec {V : Scheme}\n    (f : (âˆ fun i â†¦ Spec (R i)) âŸ¶ V) (g : V âŸ¶ Spec (.of (Î  i, R i)))\n    [IsImmersion g] [CompactSpace V]\n    (hU' : f â‰« g = sigmaSpec R) : IsIso g := by\n  have : g.coborderRange = âŠ¤ := by\n    apply eq_top_of_sigmaSpec_subset_of_isCompact (hVU := subset_coborder)\n    Â· simpa only [â† hU'] using Set.range_comp_subset_range f.base g.base\n    Â· exact isCompact_range g.base.2\n  have : IsClosedImmersion g := by\n    have : IsIso g.coborderRange.Î¹ := by rw [this, â† Scheme.topIso_hom]; infer_instance\n    rw [â† g.liftCoborder_Î¹]\n    infer_instance\n  obtain âŸ¨I, e, rflâŸ© := IsClosedImmersion.Spec_iff.mp this\n  obtain rfl := eq_bot_of_comp_quotientMk_eq_sigmaSpec R I (f â‰« e.hom) (by rwa [Category.assoc])\n  show IsIso (e.hom â‰« Spec.map (RingEquiv.quotientBot _).toCommRingCatIso.inv)\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.pointsPi_injective","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nX : AlgebraicGeometry.Scheme\ninstâœ : QuasiSeparatedSpace â†‘â†‘X.toPresheafedSpace\nâŠ¢ Function.Injective (AlgebraicGeometry.pointsPi R X)","decl":"lemma pointsPi_injective [QuasiSeparatedSpace X] : Function.Injective (pointsPi R X) := by\n  rintro f g e\n  have := isIso_of_comp_eq_sigmaSpec R (V := equalizer f g)\n    (equalizer.lift (sigmaSpec R) (by ext1 i; simpa using congr_fun e i))\n    (equalizer.Î¹ f g) (by simp)\n  rw [â† cancel_epi (equalizer.Î¹ f g), equalizer.condition]\n\n"}
{"name":"AlgebraicGeometry.pointsPi_surjective_of_isAffine","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nX : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsAffine X\nâŠ¢ Function.Surjective (AlgebraicGeometry.pointsPi R X)","decl":"lemma pointsPi_surjective_of_isAffine [IsAffine X] : Function.Surjective (pointsPi R X) := by\n  rintro f\n  refine âŸ¨Spec.map (CommRingCat.ofHom\n    (Pi.ringHom fun i â†¦ (Spec.preimage (f i â‰« X.isoSpec.hom)).1)) â‰« X.isoSpec.inv, ?_âŸ©\n  ext i : 1\n  simp only [pointsPi, â† Spec.map_comp_assoc, Iso.comp_inv_eq]\n  exact Spec.map_preimage _\n\n"}
{"name":"AlgebraicGeometry.pointsPi_surjective","module":"Mathlib.AlgebraicGeometry.PointsPi","initialProofState":"Î¹ : Type u\nR : Î¹ â†’ CommRingCat\nX : AlgebraicGeometry.Scheme\ninstâœÂ¹ : CompactSpace â†‘â†‘X.toPresheafedSpace\ninstâœ : âˆ€ (i : Î¹), IsLocalRing â†‘(R i)\nâŠ¢ Function.Surjective (AlgebraicGeometry.pointsPi R X)","decl":"lemma pointsPi_surjective [CompactSpace X] [âˆ€ i, IsLocalRing (R i)] :\n    Function.Surjective (pointsPi R X) := by\n  intro f\n  let ğ’° : X.OpenCover := X.affineCover.finiteSubcover\n  have (i) : IsAffine (ğ’°.obj i) := isAffine_Spec _\n  have (i) : âˆƒ j, Set.range (f i).base âŠ† (ğ’°.map j).opensRange := by\n    refine âŸ¨ğ’°.f ((f i).base (IsLocalRing.closedPoint (R i))), ?_âŸ©\n    rintro _ âŸ¨x, rflâŸ©\n    exact ((IsLocalRing.specializes_closedPoint x).map (f i).base.2).mem_open\n      (ğ’°.map _).opensRange.2 (ğ’°.covers _)\n  choose j hj using this\n  have (jâ‚€) := pointsPi_surjective_of_isAffine (Î¹ := { i // j i = jâ‚€ }) (R Â·) (ğ’°.obj jâ‚€)\n    (fun i â†¦ IsOpenImmersion.lift (ğ’°.map jâ‚€) (f i.1) (by rcases i with âŸ¨i, rflâŸ©; exact hj i))\n  choose g hg using this\n  simp_rw [funext_iff, pointsPi] at hg\n  let R' (jâ‚€) := CommRingCat.of (Î  i : { i // j i = jâ‚€ }, R i)\n  let e : (Î  i, R i) â‰ƒ+* Î  jâ‚€, R' jâ‚€ :=\n  { toFun f _ i := f i\n    invFun f i := f _ âŸ¨i, rflâŸ©\n    left_inv _ := rfl\n    right_inv _ := funextâ‚‚ fun jâ‚€ i â†¦ by rcases i with âŸ¨i, rflâŸ©; rfl\n    map_mul' _ _ := rfl\n    map_add' _ _ := rfl }\n  refine âŸ¨Spec.map (CommRingCat.ofHom e.symm.toRingHom) â‰« inv (sigmaSpec R') â‰«\n    Sigma.desc fun jâ‚€ â†¦ g jâ‚€ â‰« ğ’°.map jâ‚€, ?_âŸ©\n  ext i : 1\n  have : (Pi.evalRingHom (R Â·) i).comp e.symm.toRingHom =\n    (Pi.evalRingHom _ âŸ¨i, rflâŸ©).comp (Pi.evalRingHom (R' Â·) (j i)) := rfl\n  rw [pointsPi, â† Spec.map_comp_assoc, â† CommRingCat.ofHom_comp, this, CommRingCat.ofHom_comp,\n    Spec.map_comp_assoc, â† Î¹_sigmaSpec R', Category.assoc, IsIso.hom_inv_id_assoc,\n    Sigma.Î¹_desc, â† Category.assoc, hg, IsOpenImmersion.lift_fac]\n\n"}
