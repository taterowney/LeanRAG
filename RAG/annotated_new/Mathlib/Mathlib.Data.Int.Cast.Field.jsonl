{"name":"Int.cast_neg_natCast","module":"Mathlib.Data.Int.Cast.Field","initialProofState":"R : Type u_2\ninst✝ : DivisionRing R\nn : Nat\n⊢ Eq (↑(Neg.neg ↑n)) (Neg.neg ↑n)","decl":"/-- Auxiliary lemma for norm_cast to move the cast `-↑n` upwards to `↑-↑n`.\n\n(The restriction to `DivisionRing` is necessary, otherwise this would also apply in the case where\n`R = ℤ` and cause nontermination.)\n-/\n@[norm_cast]\ntheorem cast_neg_natCast {R} [DivisionRing R] (n : ℕ) : ((-n : ℤ) : R) = -n := by simp\n\n"}
{"name":"Int.cast_div","module":"Mathlib.Data.Int.Cast.Field","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\nm n : Int\nn_dvd : Dvd.dvd n m\nhn : Ne (↑n) 0\n⊢ Eq (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp]\ntheorem cast_div [DivisionRing α] {m n : ℤ} (n_dvd : n ∣ m) (hn : (n : α) ≠ 0) :\n    ((m / n : ℤ) : α) = m / n := by\n  rcases n_dvd with ⟨k, rfl⟩\n  have : n ≠ 0 := by rintro rfl; simp at hn\n  rw [Int.mul_ediv_cancel_left _ this, mul_comm n, Int.cast_mul, mul_div_cancel_right₀ _ hn]\n\n"}
