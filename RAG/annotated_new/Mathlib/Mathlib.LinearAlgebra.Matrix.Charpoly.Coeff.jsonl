{"name":"Matrix.charmatrix_apply_natDegree","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝³ : CommRing R\nn : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nM : Matrix n n R\ninst✝ : Nontrivial R\ni j : n\n⊢ Eq (M.charmatrix i j).natDegree (ite (Eq i j) 1 0)","decl":"theorem charmatrix_apply_natDegree [Nontrivial R] (i j : n) :\n    (charmatrix M i j).natDegree = ite (i = j) 1 0 := by\n  by_cases h : i = j <;> simp [h, ← degree_eq_iff_natDegree_eq_of_pos (Nat.succ_pos 0)]\n\n"}
{"name":"Matrix.charmatrix_apply_natDegree_le","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\ni j : n\n⊢ LE.le (M.charmatrix i j).natDegree (ite (Eq i j) 1 0)","decl":"theorem charmatrix_apply_natDegree_le (i j : n) :\n    (charmatrix M i j).natDegree ≤ ite (i = j) 1 0 := by\n  split_ifs with h <;> simp [h, natDegree_X_le]\n\n"}
{"name":"Matrix.charpoly_sub_diagonal_degree_lt","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ LT.lt (HSub.hSub M.charpoly (Finset.univ.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (M i i)))).degree ↑(HSub.hSub (Fintype.card n) 1)","decl":"theorem charpoly_sub_diagonal_degree_lt :\n    (M.charpoly - ∏ i : n, (X - C (M i i))).degree < ↑(Fintype.card n - 1) := by\n  rw [charpoly, det_apply', ← insert_erase (mem_univ (Equiv.refl n)),\n    sum_insert (not_mem_erase (Equiv.refl n) univ), add_comm]\n  simp only [charmatrix_apply_eq, one_mul, Equiv.Perm.sign_refl, id, Int.cast_one,\n    Units.val_one, add_sub_cancel_right, Equiv.coe_refl]\n  rw [← mem_degreeLT]\n  apply Submodule.sum_mem (degreeLT R (Fintype.card n - 1))\n  intro c hc; rw [← C_eq_intCast, C_mul']\n  apply Submodule.smul_mem (degreeLT R (Fintype.card n - 1)) ↑↑(Equiv.Perm.sign c)\n  rw [mem_degreeLT]\n  apply lt_of_le_of_lt degree_le_natDegree _\n  rw [Nat.cast_lt]\n  apply lt_of_le_of_lt _ (Equiv.Perm.fixed_point_card_lt_of_ne_one (ne_of_mem_erase hc))\n  apply le_trans (Polynomial.natDegree_prod_le univ fun i : n => charmatrix M (c i) i) _\n  rw [card_eq_sum_ones]; rw [sum_filter]; apply sum_le_sum\n  intros\n  apply charmatrix_apply_natDegree_le\n\n"}
{"name":"Matrix.charpoly_coeff_eq_prod_coeff_of_le","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nk : Nat\nh : LE.le (HSub.hSub (Fintype.card n) 1) k\n⊢ Eq (M.charpoly.coeff k) ((Finset.univ.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (M i i))).coeff k)","decl":"theorem charpoly_coeff_eq_prod_coeff_of_le {k : ℕ} (h : Fintype.card n - 1 ≤ k) :\n    M.charpoly.coeff k = (∏ i : n, (X - C (M i i))).coeff k := by\n  apply eq_of_sub_eq_zero; rw [← coeff_sub]\n  apply Polynomial.coeff_eq_zero_of_degree_lt\n  apply lt_of_lt_of_le (charpoly_sub_diagonal_degree_lt M) ?_\n  rw [Nat.cast_le]; apply h\n\n"}
{"name":"Matrix.det_of_card_zero","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nh : Eq (Fintype.card n) 0\nM : Matrix n n R\n⊢ Eq M.det 1","decl":"theorem det_of_card_zero (h : Fintype.card n = 0) (M : Matrix n n R) : M.det = 1 := by\n  rw [Fintype.card_eq_zero_iff] at h\n  suffices M = 1 by simp [this]\n  ext i\n  exact h.elim i\n\n"}
{"name":"Matrix.charpoly_degree_eq_dim","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝³ : CommRing R\nn : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Nontrivial R\nM : Matrix n n R\n⊢ Eq M.charpoly.degree ↑(Fintype.card n)","decl":"theorem charpoly_degree_eq_dim [Nontrivial R] (M : Matrix n n R) :\n    M.charpoly.degree = Fintype.card n := by\n  by_cases h : Fintype.card n = 0\n  · rw [h]\n    unfold charpoly\n    rw [det_of_card_zero]\n    · simp\n    · assumption\n  rw [← sub_add_cancel M.charpoly (∏ i : n, (X - C (M i i)))]\n  -- Porting note: added `↑` in front of `Fintype.card n`\n  have h1 : (∏ i : n, (X - C (M i i))).degree = ↑(Fintype.card n) := by\n    rw [degree_eq_iff_natDegree_eq_of_pos (Nat.pos_of_ne_zero h), natDegree_prod']\n    · simp_rw [natDegree_X_sub_C]\n      rw [← Finset.card_univ, sum_const, smul_eq_mul, mul_one]\n    simp_rw [(monic_X_sub_C _).leadingCoeff]\n    simp\n  rw [degree_add_eq_right_of_degree_lt]\n  · exact h1\n  rw [h1]\n  apply lt_trans (charpoly_sub_diagonal_degree_lt M)\n  rw [Nat.cast_lt]\n  rw [← Nat.pred_eq_sub_one]\n  apply Nat.pred_lt\n  apply h\n\n"}
{"name":"Matrix.charpoly_natDegree_eq_dim","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝³ : CommRing R\nn : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Nontrivial R\nM : Matrix n n R\n⊢ Eq M.charpoly.natDegree (Fintype.card n)","decl":"@[simp] theorem charpoly_natDegree_eq_dim [Nontrivial R] (M : Matrix n n R) :\n    M.charpoly.natDegree = Fintype.card n :=\n  natDegree_eq_of_degree_eq_some (charpoly_degree_eq_dim M)\n\n"}
{"name":"Matrix.charpoly_monic","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ M.charpoly.Monic","decl":"theorem charpoly_monic (M : Matrix n n R) : M.charpoly.Monic := by\n  nontriviality R -- Porting note: was simply `nontriviality`\n  by_cases h : Fintype.card n = 0\n  · rw [charpoly, det_of_card_zero h]\n    apply monic_one\n  have mon : (∏ i : n, (X - C (M i i))).Monic := by\n    apply monic_prod_of_monic univ fun i : n => X - C (M i i)\n    simp [monic_X_sub_C]\n  rw [← sub_add_cancel (∏ i : n, (X - C (M i i))) M.charpoly] at mon\n  rw [Monic] at *\n  rwa [leadingCoeff_add_of_degree_lt] at mon\n  rw [charpoly_degree_eq_dim]\n  rw [← neg_sub]\n  rw [degree_neg]\n  apply lt_trans (charpoly_sub_diagonal_degree_lt M)\n  rw [Nat.cast_lt]\n  rw [← Nat.pred_eq_sub_one]\n  apply Nat.pred_lt\n  apply h\n\n"}
{"name":"Matrix.trace_eq_neg_charpoly_coeff","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝³ : CommRing R\nn : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : Nonempty n\nM : Matrix n n R\n⊢ Eq M.trace (Neg.neg (M.charpoly.coeff (HSub.hSub (Fintype.card n) 1)))","decl":"/-- See also `Matrix.coeff_charpolyRev_eq_neg_trace`. -/\ntheorem trace_eq_neg_charpoly_coeff [Nonempty n] (M : Matrix n n R) :\n    trace M = -M.charpoly.coeff (Fintype.card n - 1) := by\n  rw [charpoly_coeff_eq_prod_coeff_of_le _ le_rfl, Fintype.card,\n    prod_X_sub_C_coeff_card_pred univ (fun i : n => M i i) Fintype.card_pos, neg_neg, trace]\n  simp_rw [diag_apply]\n\n"}
{"name":"Matrix.matPolyEquiv_symm_map_eval","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Polynomial (Matrix n n R)\nr : R\n⊢ Eq ((matPolyEquiv.symm M).map (Polynomial.eval r)) (Polynomial.eval ((Matrix.scalar n) r) M)","decl":"theorem matPolyEquiv_symm_map_eval (M : (Matrix n n R)[X]) (r : R) :\n    (matPolyEquiv.symm M).map (eval r) = M.eval (scalar n r) := by\n  suffices ((aeval r).mapMatrix.comp matPolyEquiv.symm.toAlgHom : (Matrix n n R)[X] →ₐ[R] _) =\n      (eval₂AlgHom' (AlgHom.id R _) (scalar n r)\n        fun x => (scalar_commute _ (Commute.all _) _).symm) from\n    DFunLike.congr_fun this M\n  ext : 1\n  · ext M : 1\n    simp [Function.comp_def]\n  · simp [smul_eq_diagonal_mul]\n\n"}
{"name":"Matrix.matPolyEquiv_eval_eq_map","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n⊢ Eq (Polynomial.eval ((Matrix.scalar n) r) (matPolyEquiv M)) (M.map (Polynomial.eval r))","decl":"theorem matPolyEquiv_eval_eq_map (M : Matrix n n R[X]) (r : R) :\n    (matPolyEquiv M).eval (scalar n r) = M.map (eval r) := by\n  simpa only [AlgEquiv.symm_apply_apply] using (matPolyEquiv_symm_map_eval (matPolyEquiv M) r).symm\n\n-- I feel like this should use `Polynomial.algHom_eval₂_algebraMap`\n"}
{"name":"Matrix.matPolyEquiv_eval","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\ni j : n\n⊢ Eq (Polynomial.eval ((Matrix.scalar n) r) (matPolyEquiv M) i j) (Polynomial.eval r (M i j))","decl":"theorem matPolyEquiv_eval (M : Matrix n n R[X]) (r : R) (i j : n) :\n    (matPolyEquiv M).eval (scalar n r) i j = (M i j).eval r := by\n  rw [matPolyEquiv_eval_eq_map, map_apply]\n\n"}
{"name":"Matrix.eval_det","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n (Polynomial R)\nr : R\n⊢ Eq (Polynomial.eval r M.det) (Polynomial.eval ((Matrix.scalar n) r) (matPolyEquiv M)).det","decl":"theorem eval_det (M : Matrix n n R[X]) (r : R) :\n    Polynomial.eval r M.det = (Polynomial.eval (scalar n r) (matPolyEquiv M)).det := by\n  rw [Polynomial.eval, ← coe_eval₂RingHom, RingHom.map_det]\n  apply congr_arg det\n  ext\n  symm\n  -- Porting note: `exact` was `convert`\n  exact matPolyEquiv_eval _ _ _ _\n\n"}
{"name":"Matrix.det_eq_sign_charpoly_coeff","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq M.det (HMul.hMul (HPow.hPow (-1) (Fintype.card n)) (M.charpoly.coeff 0))","decl":"theorem det_eq_sign_charpoly_coeff (M : Matrix n n R) :\n    M.det = (-1) ^ Fintype.card n * M.charpoly.coeff 0 := by\n  rw [coeff_zero_eq_eval_zero, charpoly, eval_det, matPolyEquiv_charmatrix, ← det_smul]\n  simp\n\n"}
{"name":"Matrix.eval_det_add_X_smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nA : Matrix n n (Polynomial R)\nM : Matrix n n R\n⊢ Eq (Polynomial.eval 0 (HAdd.hAdd A (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det) (Polynomial.eval 0 A.det)","decl":"lemma eval_det_add_X_smul (A : Matrix n n R[X]) (M : Matrix n n R) :\n    (det (A + (X : R[X]) • M.map C)).eval 0 = (det A).eval 0 := by\n  simp only [eval_det, map_zero, map_add, eval_add, Algebra.smul_def, _root_.map_mul]\n  simp only [Algebra.algebraMap_eq_smul_one, matPolyEquiv_smul_one, map_X, X_mul, eval_mul_X,\n    mul_zero, add_zero]\n\n"}
{"name":"Matrix.derivative_det_one_add_X_smul_aux","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝ : CommRing R\nn : Nat\nM : Matrix (Fin n) (Fin n) R\n⊢ Eq (Polynomial.eval 0 (Polynomial.derivative (HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det)) M.trace","decl":"lemma derivative_det_one_add_X_smul_aux {n} (M : Matrix (Fin n) (Fin n) R) :\n    (derivative <| det (1 + (X : R[X]) • M.map C)).eval 0 = trace M := by\n  induction n with\n  | zero => simp\n  | succ n IH =>\n    rw [det_succ_row_zero, map_sum, eval_finset_sum]\n    simp only [add_apply, smul_apply, map_apply, smul_eq_mul, X_mul_C, submatrix_add,\n      submatrix_smul, Pi.add_apply, Pi.smul_apply, submatrix_map, derivative_mul, map_add,\n      derivative_C, zero_mul, derivative_X, mul_one, zero_add, eval_add, eval_mul, eval_C, eval_X,\n      mul_zero, add_zero, eval_det_add_X_smul, eval_pow, eval_neg, eval_one]\n    rw [Finset.sum_eq_single 0]\n    · simp only [Fin.val_zero, pow_zero, derivative_one, eval_zero, one_apply_eq, eval_one,\n        mul_one, zero_add, one_mul, Fin.succAbove_zero, submatrix_one _ (Fin.succ_injective _),\n        det_one, IH, trace_submatrix_succ]\n    · intro i _ hi\n      cases n with\n      | zero => exact (hi (Subsingleton.elim i 0)).elim\n      | succ n =>\n        simp only [one_apply_ne' hi, eval_zero, mul_zero, zero_add, zero_mul, add_zero]\n        rw [det_eq_zero_of_column_eq_zero 0, eval_zero, mul_zero]\n        intro j\n        rw [submatrix_apply, Fin.succAbove_of_castSucc_lt, one_apply_ne]\n        · exact (bne_iff_ne (a := Fin.succ j) (b := Fin.castSucc 0)).mp rfl\n        · rw [Fin.castSucc_zero]; exact lt_of_le_of_ne (Fin.zero_le _) hi.symm\n    · exact fun H ↦ (H <| Finset.mem_univ _).elim\n\n"}
{"name":"Matrix.derivative_det_one_add_X_smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (Polynomial.eval 0 (Polynomial.derivative (HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det)) M.trace","decl":"/-- The derivative of `det (1 + M X)` at `0` is the trace of `M`. -/\nlemma derivative_det_one_add_X_smul (M : Matrix n n R) :\n    (derivative <| det (1 + (X : R[X]) • M.map C)).eval 0 = trace M := by\n  let e := Matrix.reindexLinearEquiv R R (Fintype.equivFin n) (Fintype.equivFin n)\n  rw [← Matrix.det_reindexLinearEquiv_self R[X] (Fintype.equivFin n)]\n  convert derivative_det_one_add_X_smul_aux (e M)\n  · ext; simp [map_add, e]\n  · delta trace\n    rw [← (Fintype.equivFin n).symm.sum_comp]\n    simp_rw [e, reindexLinearEquiv_apply, reindex_apply, diag_apply, submatrix_apply]\n\n"}
{"name":"Matrix.coeff_det_one_add_X_smul_one","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq ((HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det.coeff 1) M.trace","decl":"lemma coeff_det_one_add_X_smul_one (M : Matrix n n R) :\n    (det (1 + (X : R[X]) • M.map C)).coeff 1 = trace M := by\n  simp only [← derivative_det_one_add_X_smul, ← coeff_zero_eq_eval_zero,\n    coeff_derivative, zero_add, Nat.cast_zero, mul_one]\n\n"}
{"name":"Matrix.det_one_add_X_smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det (HAdd.hAdd (HAdd.hAdd 1 (HSMul.hSMul M.trace Polynomial.X)) (HMul.hMul (HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det.divX.divX (HPow.hPow Polynomial.X 2)))","decl":"lemma det_one_add_X_smul (M : Matrix n n R) :\n    det (1 + (X : R[X]) • M.map C) =\n      (1 : R[X]) + trace M • X + (det (1 + (X : R[X]) • M.map C)).divX.divX * X ^ 2 := by\n  rw [Algebra.smul_def (trace M), ← C_eq_algebraMap, pow_two, ← mul_assoc, add_assoc,\n    ← add_mul, ← coeff_det_one_add_X_smul_one, ← coeff_divX, add_comm (C _), divX_mul_X_add,\n    add_comm (1 : R[X]), ← C.map_one]\n  convert (divX_mul_X_add _).symm\n  rw [coeff_zero_eq_eval_zero, eval_det_add_X_smul, det_one, eval_one]\n\n"}
{"name":"Matrix.det_one_add_smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nr : R\nM : Matrix n n R\n⊢ Eq (HAdd.hAdd 1 (HSMul.hSMul r M)).det (HAdd.hAdd (HAdd.hAdd 1 (HMul.hMul M.trace r)) (HMul.hMul (Polynomial.eval r (HAdd.hAdd 1 (HSMul.hSMul Polynomial.X (M.map ⇑Polynomial.C))).det.divX.divX) (HPow.hPow r 2)))","decl":"/-- The first two terms of the taylor expansion of `det (1 + r • M)` at `r = 0`. -/\nlemma det_one_add_smul (r : R) (M : Matrix n n R) :\n    det (1 + r • M) =\n      1 + trace M * r + (det (1 + (X : R[X]) • M.map C)).divX.divX.eval r * r ^ 2 := by\n  simpa [eval_det, ← smul_eq_mul_diagonal] using congr_arg (eval r) (Matrix.det_one_add_X_smul M)\n\n"}
{"name":"matPolyEquiv_eq_X_pow_sub_C","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"n : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nK : Type u_1\nk : Nat\ninst✝ : Field K\nM : Matrix n n K\n⊢ Eq (matPolyEquiv ((↑(Polynomial.expand K k)).mapMatrix (HPow.hPow M k).charmatrix)) (HSub.hSub (HPow.hPow Polynomial.X k) (Polynomial.C (HPow.hPow M k)))","decl":"theorem matPolyEquiv_eq_X_pow_sub_C {K : Type*} (k : ℕ) [Field K] (M : Matrix n n K) :\n    matPolyEquiv ((expand K k : K[X] →+* K[X]).mapMatrix (charmatrix (M ^ k))) =\n      X ^ k - C (M ^ k) := by\n  -- Porting note: `i` and `j` are used later on, but were not mentioned in mathlib3\n  ext m i j\n  rw [coeff_sub, coeff_C, matPolyEquiv_coeff_apply, RingHom.mapMatrix_apply, Matrix.map_apply,\n    AlgHom.coe_toRingHom, DMatrix.sub_apply, coeff_X_pow]\n  by_cases hij : i = j\n  · rw [hij, charmatrix_apply_eq, map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C]\n                             -- Porting note: the second `Matrix.` was `DMatrix.`\n    split_ifs with mp m0 <;> simp only [Matrix.one_apply_eq, Matrix.zero_apply]\n  · rw [charmatrix_apply_ne _ _ _ hij, map_neg, expand_C, coeff_neg, coeff_C]\n    split_ifs with m0 mp <;>\n      -- Porting note: again, the first `Matrix.` that was `DMatrix.`\n      simp only [hij, zero_sub, Matrix.zero_apply, sub_zero, neg_zero, Matrix.one_apply_ne, Ne,\n        not_false_iff]\n\n"}
{"name":"Matrix.aeval_eq_aeval_mod_charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\np : Polynomial R\n⊢ Eq ((Polynomial.aeval M) p) ((Polynomial.aeval M) (p.modByMonic M.charpoly))","decl":"/-- Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. -/\ntheorem aeval_eq_aeval_mod_charpoly (M : Matrix n n R) (p : R[X]) :\n    aeval M p = aeval M (p %ₘ M.charpoly) :=\n  (aeval_modByMonic_eq_self_of_root M.charpoly_monic M.aeval_self_charpoly).symm\n\n"}
{"name":"Matrix.pow_eq_aeval_mod_charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nk : Nat\n⊢ Eq (HPow.hPow M k) ((Polynomial.aeval M) ((HPow.hPow Polynomial.X k).modByMonic M.charpoly))","decl":"/-- Any matrix power can be computed as the sum of matrix powers less than `Fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. -/\ntheorem pow_eq_aeval_mod_charpoly (M : Matrix n n R) (k : ℕ) :\n    M ^ k = aeval M (X ^ k %ₘ M.charpoly) := by rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]\n\n"}
{"name":"Matrix.coeff_charpoly_mem_ideal_pow","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nI : Ideal R\nh : ∀ (i j : n), Membership.mem I (M i j)\nk : Nat\n⊢ Membership.mem (HPow.hPow I (HSub.hSub (Fintype.card n) k)) (M.charpoly.coeff k)","decl":"theorem coeff_charpoly_mem_ideal_pow {I : Ideal R} (h : ∀ i j, M i j ∈ I) (k : ℕ) :\n    M.charpoly.coeff k ∈ I ^ (Fintype.card n - k) := by\n  delta charpoly\n  rw [Matrix.det_apply, finset_sum_coeff]\n  apply sum_mem\n  rintro c -\n  rw [coeff_smul, Submodule.smul_mem_iff']\n  have : ∑ x : n, 1 = Fintype.card n := by rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]\n  rw [← this]\n  apply coeff_prod_mem_ideal_pow_tsub\n  rintro i - (_ | k)\n  · rw [tsub_zero, pow_one, charmatrix_apply, coeff_sub, ← smul_one_eq_diagonal, smul_apply,\n      smul_eq_mul, coeff_X_mul_zero, coeff_C_zero, zero_sub]\n    apply neg_mem  -- Porting note: was `rw [neg_mem_iff]`, but Lean could not synth `NegMemClass`\n    exact h (c i) i\n  · rw [add_comm, tsub_self_add, pow_zero, Ideal.one_eq_top]\n    exact Submodule.mem_top\n\n"}
{"name":"Matrix.reverse_charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq M.charpoly.reverse M.charpolyRev","decl":"lemma reverse_charpoly (M : Matrix n n R) :\n    M.charpoly.reverse = M.charpolyRev := by\n  nontriviality R\n  let t : R[T;T⁻¹] := T 1\n  let t_inv : R[T;T⁻¹] := T (-1)\n  let p : R[T;T⁻¹] := det (scalar n t - M.map LaurentPolynomial.C)\n  let q : R[T;T⁻¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)\n  have ht : t_inv * t = 1 := by rw [← T_add, neg_add_cancel, T_zero]\n  have hp : toLaurentAlg M.charpoly = p := by\n    simp [p, t, charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']\n  have hq : toLaurentAlg M.charpolyRev = q := by\n    simp [q, t, charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]\n  suffices t_inv ^ Fintype.card n * p = invert q by\n    apply toLaurent_injective\n    rwa [toLaurent_reverse, ← coe_toLaurentAlg, hp, hq, ← involutive_invert.injective.eq_iff,\n      _root_.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,\n      ← mul_one (Fintype.card n : ℤ), ← T_pow, map_pow, invert_T, mul_comm]\n  rw [← det_smul, smul_sub, scalar_apply, ← diagonal_smul, Pi.smul_def, smul_eq_mul, ht,\n    diagonal_one, invert.map_det]\n  simp [t_inv, map_sub, _root_.map_one, _root_.map_mul, t, map_smul', smul_eq_diagonal_mul]\n\n\n"}
{"name":"Matrix.eval_charpolyRev","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (Polynomial.eval 0 M.charpolyRev) 1","decl":"@[simp] lemma eval_charpolyRev :\n    eval 0 M.charpolyRev = 1 := by\n  rw [charpolyRev, ← coe_evalRingHom, RingHom.map_det, ← det_one (R := R) (n := n)]\n  have : (1 - (X : R[X]) • M.map C).map (eval 0) = 1 := by\n    ext i j; rcases eq_or_ne i j with hij | hij <;> simp [hij, one_apply]\n  congr\n\n"}
{"name":"Matrix.coeff_charpolyRev_eq_neg_trace","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (M.charpolyRev.coeff 1) (Neg.neg M.trace)","decl":"@[simp] lemma coeff_charpolyRev_eq_neg_trace (M : Matrix n n R) :\n    coeff M.charpolyRev 1 = - trace M := by\n  nontriviality R\n  cases isEmpty_or_nonempty n\n  · simp [charpolyRev, coeff_one]\n  · simp [trace_eq_neg_charpoly_coeff M, ← M.reverse_charpoly, nextCoeff]\n\n"}
{"name":"Matrix.isUnit_charpolyRev_of_isNilpotent","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nhM : IsNilpotent M\n⊢ IsUnit M.charpolyRev","decl":"lemma isUnit_charpolyRev_of_isNilpotent (hM : IsNilpotent M) :\n    IsUnit M.charpolyRev := by\n  obtain ⟨k, hk⟩ := hM\n  replace hk : 1 - (X : R[X]) • M.map C ∣ 1 := by\n    convert one_sub_dvd_one_sub_pow ((X : R[X]) • M.map C) k\n    rw [← C.mapMatrix_apply, smul_pow, ← map_pow, hk, map_zero, smul_zero, sub_zero]\n  apply isUnit_of_dvd_one\n  rw [← det_one (R := R[X]) (n := n)]\n  exact map_dvd detMonoidHom hk\n\n"}
{"name":"Matrix.isNilpotent_trace_of_isNilpotent","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nhM : IsNilpotent M\n⊢ IsNilpotent M.trace","decl":"lemma isNilpotent_trace_of_isNilpotent (hM : IsNilpotent M) :\n    IsNilpotent (trace M) := by\n  cases isEmpty_or_nonempty n\n  · simp\n  suffices IsNilpotent (coeff (charpolyRev M) 1) by simpa using this\n  exact (isUnit_iff_coeff_isUnit_isNilpotent.mp (isUnit_charpolyRev_of_isNilpotent hM)).2\n    _ one_ne_zero\n\n"}
{"name":"Matrix.isNilpotent_charpoly_sub_pow_of_isNilpotent","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff","initialProofState":"R : Type u\ninst✝² : CommRing R\nn : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nhM : IsNilpotent M\n⊢ IsNilpotent (HSub.hSub M.charpoly (HPow.hPow Polynomial.X (Fintype.card n)))","decl":"lemma isNilpotent_charpoly_sub_pow_of_isNilpotent (hM : IsNilpotent M) :\n    IsNilpotent (M.charpoly - X ^ (Fintype.card n)) := by\n  nontriviality R\n  let p : R[X] := M.charpolyRev\n  have hp : p - 1 = X * (p /ₘ X) := by\n    conv_lhs => rw [← modByMonic_add_div p monic_X]\n    simp [p, modByMonic_X]\n  have : IsNilpotent (p /ₘ X) :=\n    (Polynomial.isUnit_iff'.mp (isUnit_charpolyRev_of_isNilpotent hM)).2\n  have aux : (M.charpoly - X ^ (Fintype.card n)).natDegree ≤ M.charpoly.natDegree :=\n    le_trans (natDegree_sub_le _ _) (by simp)\n  rw [← isNilpotent_reflect_iff aux, reflect_sub, ← reverse, M.reverse_charpoly]\n  simpa [p, hp]\n\n"}
