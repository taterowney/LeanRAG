{"name":"Submodule.finrank_lt","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\ns : Submodule K V\nh : LT.lt s Top.top\n⊢ LT.lt (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K V)","decl":"/-- The dimension of a strict submodule is strictly bounded by the dimension of the ambient\nspace. -/\ntheorem finrank_lt [FiniteDimensional K V] {s : Submodule K V} (h : s < ⊤) :\n    finrank K s < finrank K V := by\n  rw [← s.finrank_quotient_add_finrank, add_comm]\n  exact Nat.lt_add_of_pos_right (finrank_pos_iff.mpr (Quotient.nontrivial_of_lt_top _ h))\n\n"}
{"name":"Submodule.finrank_sup_add_finrank_inf_eq","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ns t : Submodule K V\ninst✝¹ : FiniteDimensional K (Subtype fun x => Membership.mem s x)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem t x)\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem (Max.max s t) x)) (Module.finrank K (Subtype fun x => Membership.mem (Min.min s t) x))) (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x)))","decl":"/-- The sum of the dimensions of s + t and s ∩ t is the sum of the dimensions of s and t -/\ntheorem finrank_sup_add_finrank_inf_eq (s t : Submodule K V) [FiniteDimensional K s]\n    [FiniteDimensional K t] :\n    finrank K ↑(s ⊔ t) + finrank K ↑(s ⊓ t) = finrank K ↑s + finrank K ↑t := by\n  have key : Module.rank K ↑(s ⊔ t) + Module.rank K ↑(s ⊓ t) = Module.rank K s + Module.rank K t :=\n    rank_sup_add_rank_inf_eq s t\n  repeat rw [← finrank_eq_rank] at key\n  norm_cast at key\n\n"}
{"name":"Submodule.finrank_add_le_finrank_add_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ns t : Submodule K V\ninst✝¹ : FiniteDimensional K (Subtype fun x => Membership.mem s x)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem t x)\n⊢ LE.le (Module.finrank K (Subtype fun x => Membership.mem (Max.max s t) x)) (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x)))","decl":"theorem finrank_add_le_finrank_add_finrank (s t : Submodule K V) [FiniteDimensional K s]\n    [FiniteDimensional K t] : finrank K (s ⊔ t : Submodule K V) ≤ finrank K s + finrank K t := by\n  rw [← finrank_sup_add_finrank_inf_eq]\n  exact self_le_add_right _ _\n\n"}
{"name":"Submodule.finrank_add_finrank_le_of_disjoint","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\ns t : Submodule K V\nhdisjoint : Disjoint s t\n⊢ LE.le (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x))) (Module.finrank K V)","decl":"theorem finrank_add_finrank_le_of_disjoint [FiniteDimensional K V]\n    {s t : Submodule K V} (hdisjoint : Disjoint s t) :\n    finrank K s + finrank K t ≤ finrank K V := by\n  rw [← Submodule.finrank_sup_add_finrank_inf_eq s t, hdisjoint.eq_bot, finrank_bot, add_zero]\n  exact Submodule.finrank_le _\n\n"}
{"name":"Submodule.eq_top_of_disjoint","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\ns t : Submodule K V\nhdim : LE.le (Module.finrank K V) (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x)))\nhdisjoint : Disjoint s t\n⊢ Eq (Max.max s t) Top.top","decl":"theorem eq_top_of_disjoint [FiniteDimensional K V] (s t : Submodule K V)\n    (hdim : finrank K V ≤ finrank K s + finrank K t) (hdisjoint : Disjoint s t) : s ⊔ t = ⊤ := by\n  have h_finrank_inf : finrank K ↑(s ⊓ t) = 0 := by\n    rw [disjoint_iff_inf_le, le_bot_iff] at hdisjoint\n    rw [hdisjoint, finrank_bot]\n  apply eq_top_of_finrank_eq\n  replace hdim : finrank K V = finrank K s + finrank K t :=\n    le_antisymm hdim (finrank_add_finrank_le_of_disjoint hdisjoint)\n  rw [hdim]\n  convert s.finrank_sup_add_finrank_inf_eq t\n  rw [h_finrank_inf]\n  rfl\n\n"}
{"name":"Submodule.isCompl_iff_disjoint","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\ns t : Submodule K V\nhdim : LE.le (Module.finrank K V) (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x)))\n⊢ Iff (IsCompl s t) (Disjoint s t)","decl":"theorem isCompl_iff_disjoint [FiniteDimensional K V] (s t : Submodule K V)\n    (hdim : finrank K V ≤ finrank K s + finrank K t) :\n    IsCompl s t ↔ Disjoint s t :=\n  ⟨fun h ↦ h.1, fun h ↦ ⟨h, codisjoint_iff.mpr <| eq_top_of_disjoint s t hdim h⟩⟩\n\n"}
{"name":"LinearMap.finrank_range_add_finrank_ker","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V₂\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.finrank K (Subtype fun x => Membership.mem (LinearMap.ker f) x))) (Module.finrank K V)","decl":"/-- rank-nullity theorem : the dimensions of the kernel and the range of a linear map add up to\nthe dimension of the source space. -/\ntheorem finrank_range_add_finrank_ker [FiniteDimensional K V] (f : V →ₗ[K] V₂) :\n    finrank K (LinearMap.range f) + finrank K (LinearMap.ker f) = finrank K V := by\n  rw [← f.quotKerEquivRange.finrank_eq]\n  exact Submodule.finrank_quotient_add_finrank _\n\n"}
{"name":"LinearMap.ker_ne_bot_of_finrank_lt","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nV₂ : Type v'\ninst✝³ : AddCommGroup V₂\ninst✝² : Module K V₂\ninst✝¹ : FiniteDimensional K V\ninst✝ : FiniteDimensional K V₂\nf : LinearMap (RingHom.id K) V V₂\nh : LT.lt (Module.finrank K V₂) (Module.finrank K V)\n⊢ Ne (LinearMap.ker f) Bot.bot","decl":"lemma ker_ne_bot_of_finrank_lt [FiniteDimensional K V] [FiniteDimensional K V₂] {f : V →ₗ[K] V₂}\n    (h : finrank K V₂ < finrank K V) :\n    LinearMap.ker f ≠ ⊥ := by\n  have h₁ := f.finrank_range_add_finrank_ker\n  have h₂ : finrank K (LinearMap.range f) ≤ finrank K V₂ := (LinearMap.range f).finrank_le\n  suffices 0 < finrank K (LinearMap.ker f) from Submodule.one_le_finrank_iff.mp this\n  omega\n\n"}
{"name":"LinearMap.injective_iff_surjective_of_finrank_eq_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nV₂ : Type v'\ninst✝³ : AddCommGroup V₂\ninst✝² : Module K V₂\ninst✝¹ : FiniteDimensional K V\ninst✝ : FiniteDimensional K V₂\nH : Eq (Module.finrank K V) (Module.finrank K V₂)\nf : LinearMap (RingHom.id K) V V₂\n⊢ Iff (Function.Injective ⇑f) (Function.Surjective ⇑f)","decl":"theorem injective_iff_surjective_of_finrank_eq_finrank [FiniteDimensional K V]\n    [FiniteDimensional K V₂] (H : finrank K V = finrank K V₂) {f : V →ₗ[K] V₂} :\n    Function.Injective f ↔ Function.Surjective f := by\n  have := finrank_range_add_finrank_ker f\n  rw [← ker_eq_bot, ← range_eq_top]; refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [h, finrank_bot, add_zero, H] at this\n    exact eq_top_of_finrank_eq this\n  · rw [h, finrank_top, H] at this\n    exact Submodule.finrank_eq_zero.1 (add_right_injective _ this)\n\n"}
{"name":"LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nV₂ : Type v'\ninst✝³ : AddCommGroup V₂\ninst✝² : Module K V₂\ninst✝¹ : FiniteDimensional K V\ninst✝ : FiniteDimensional K V₂\nH : Eq (Module.finrank K V) (Module.finrank K V₂)\nf : LinearMap (RingHom.id K) V V₂\n⊢ Iff (Eq (LinearMap.ker f) Bot.bot) (Eq (LinearMap.range f) Top.top)","decl":"theorem ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank [FiniteDimensional K V]\n    [FiniteDimensional K V₂] (H : finrank K V = finrank K V₂) {f : V →ₗ[K] V₂} :\n    LinearMap.ker f = ⊥ ↔ LinearMap.range f = ⊤ := by\n  rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]\n\n"}
{"name":"LinearMap.linearEquivOfInjective_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nV₂ : Type v'\ninst✝³ : AddCommGroup V₂\ninst✝² : Module K V₂\ninst✝¹ : FiniteDimensional K V\ninst✝ : FiniteDimensional K V₂\nf : LinearMap (RingHom.id K) V V₂\nhf : Function.Injective ⇑f\nhdim : Eq (Module.finrank K V) (Module.finrank K V₂)\nx : V\n⊢ Eq ((f.linearEquivOfInjective hf hdim) x) (f x)","decl":"@[simp]\ntheorem linearEquivOfInjective_apply [FiniteDimensional K V] [FiniteDimensional K V₂]\n    {f : V →ₗ[K] V₂} (hf : Injective f) (hdim : finrank K V = finrank K V₂) (x : V) :\n    f.linearEquivOfInjective hf hdim x = f x :=\n  rfl\n\n"}
{"name":"Submodule.finrank_lt_finrank_of_lt","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ns t : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem t x)\nhst : LT.lt s t\n⊢ LT.lt (Module.finrank K (Subtype fun x => Membership.mem s x)) (Module.finrank K (Subtype fun x => Membership.mem t x))","decl":"theorem finrank_lt_finrank_of_lt {s t : Submodule K V} [FiniteDimensional K t] (hst : s < t) :\n    finrank K s < finrank K t :=\n  (comapSubtypeEquivOfLe hst.le).finrank_eq.symm.trans_lt <|\n    finrank_lt (le_top.lt_of_ne <| hst.not_le ∘ comap_subtype_eq_top.1)\n\n"}
{"name":"Submodule.finrank_strictMono","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ StrictMono fun s => Module.finrank K (Subtype fun x => Membership.mem s x)","decl":"theorem finrank_strictMono [FiniteDimensional K V] :\n    StrictMono fun s : Submodule K V => finrank K s := fun _ _ => finrank_lt_finrank_of_lt\n\n"}
{"name":"Submodule.finrank_add_eq_of_isCompl","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nU W : Submodule K V\nh : IsCompl U W\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem U x)) (Module.finrank K (Subtype fun x => Membership.mem W x))) (Module.finrank K V)","decl":"theorem finrank_add_eq_of_isCompl [FiniteDimensional K V] {U W : Submodule K V} (h : IsCompl U W) :\n    finrank K U + finrank K W = finrank K V := by\n  rw [← finrank_sup_add_finrank_inf_eq, h.codisjoint.eq_top, h.disjoint.eq_bot, finrank_bot,\n    add_zero]\n  exact finrank_top _ _\n\n"}
{"name":"LinearIndependent.span_eq_top_of_card_eq_finrank'","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional K V\nb : ι → V\nlin_ind : LinearIndependent K b\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\n⊢ Eq (Submodule.span K (Set.range b)) Top.top","decl":"theorem LinearIndependent.span_eq_top_of_card_eq_finrank' {ι : Type*}\n    [Fintype ι] [FiniteDimensional K V] {b : ι → V} (lin_ind : LinearIndependent K b)\n    (card_eq : Fintype.card ι = finrank K V) : span K (Set.range b) = ⊤ := by\n  by_contra ne_top\n  rw [← finrank_span_eq_card lin_ind] at card_eq\n  exact ne_of_lt (Submodule.finrank_lt <| lt_top_iff_ne_top.2 ne_top) card_eq\n\n"}
{"name":"LinearIndependent.span_eq_top_of_card_eq_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_1\ninst✝¹ : Nonempty ι\ninst✝ : Fintype ι\nb : ι → V\nlin_ind : LinearIndependent K b\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\n⊢ Eq (Submodule.span K (Set.range b)) Top.top","decl":"theorem LinearIndependent.span_eq_top_of_card_eq_finrank {ι : Type*} [Nonempty ι]\n    [Fintype ι] {b : ι → V} (lin_ind : LinearIndependent K b)\n    (card_eq : Fintype.card ι = finrank K V) : span K (Set.range b) = ⊤ :=\n  have : FiniteDimensional K V := .of_finrank_pos <| card_eq ▸ Fintype.card_pos\n  lin_ind.span_eq_top_of_card_eq_finrank' card_eq\n\n"}
{"name":"basisOfLinearIndependentOfCardEqFinrank_repr_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_1\ninst✝¹ : Nonempty ι\ninst✝ : Fintype ι\nb : ι → V\nlin_ind : LinearIndependent K b\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\na✝ : V\n⊢ Eq ((basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq).repr a✝) (lin_ind.repr ((LinearMap.codRestrict (Submodule.span K (Set.range b)) LinearMap.id ⋯) a✝))","decl":"/-- A linear independent family of `finrank K V` vectors forms a basis. -/\n@[simps! repr_apply]\nnoncomputable def basisOfLinearIndependentOfCardEqFinrank {ι : Type*} [Nonempty ι] [Fintype ι]\n    {b : ι → V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) :\n    Basis ι K V :=\n  Basis.mk lin_ind <| (lin_ind.span_eq_top_of_card_eq_finrank card_eq).ge\n\n"}
{"name":"coe_basisOfLinearIndependentOfCardEqFinrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_1\ninst✝¹ : Nonempty ι\ninst✝ : Fintype ι\nb : ι → V\nlin_ind : LinearIndependent K b\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\n⊢ Eq (⇑(basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq)) b","decl":"@[simp]\ntheorem coe_basisOfLinearIndependentOfCardEqFinrank {ι : Type*} [Nonempty ι] [Fintype ι]\n    {b : ι → V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) :\n    ⇑(basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = b :=\n  Basis.coe_mk _ _\n\n"}
{"name":"finsetBasisOfLinearIndependentOfCardEqFinrank_repr_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : Eq s.card (Module.finrank K V)\na✝ : V\n⊢ Eq ((finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq).repr a✝) (lin_ind.repr ((LinearMap.codRestrict (Submodule.span K (Set.range Subtype.val)) LinearMap.id ⋯) a✝))","decl":"/-- A linear independent finset of `finrank K V` vectors forms a basis. -/\n@[simps! repr_apply]\nnoncomputable def finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)\n    (lin_ind : LinearIndependent K ((↑) : s → V)) (card_eq : s.card = finrank K V) : Basis s K V :=\n  @basisOfLinearIndependentOfCardEqFinrank _ _ _ _ _ _\n    ⟨(⟨hs.choose, hs.choose_spec⟩ : s)⟩ _ _ lin_ind (_root_.trans (Fintype.card_coe _) card_eq)\n\n"}
{"name":"coe_finsetBasisOfLinearIndependentOfCardEqFinrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : Eq s.card (Module.finrank K V)\n⊢ Eq (⇑(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq)) Subtype.val","decl":"@[simp]\ntheorem coe_finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)\n    (lin_ind : LinearIndependent K ((↑) : s → V)) (card_eq : s.card = finrank K V) :\n    ⇑(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = ((↑) : s → V) := by\n  -- Porting note: added to make the next line unify the `_`s\n  rw [finsetBasisOfLinearIndependentOfCardEqFinrank]\n  exact Basis.coe_mk _ _\n\n"}
{"name":"setBasisOfLinearIndependentOfCardEqFinrank_repr_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ns : Set V\ninst✝¹ : Nonempty ↑s\ninst✝ : Fintype ↑s\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : Eq s.toFinset.card (Module.finrank K V)\na✝ : V\n⊢ Eq ((setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq).repr a✝) (lin_ind.repr ((LinearMap.codRestrict (Submodule.span K (Set.range Subtype.val)) LinearMap.id ⋯) a✝))","decl":"/-- A linear independent set of `finrank K V` vectors forms a basis. -/\n@[simps! repr_apply]\nnoncomputable def setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K ((↑) : s → V)) (card_eq : s.toFinset.card = finrank K V) :\n    Basis s K V :=\n  basisOfLinearIndependentOfCardEqFinrank lin_ind (_root_.trans s.toFinset_card.symm card_eq)\n\n"}
{"name":"coe_setBasisOfLinearIndependentOfCardEqFinrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ns : Set V\ninst✝¹ : Nonempty ↑s\ninst✝ : Fintype ↑s\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : Eq s.toFinset.card (Module.finrank K V)\n⊢ Eq (⇑(setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq)) Subtype.val","decl":"@[simp]\ntheorem coe_setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K ((↑) : s → V)) (card_eq : s.toFinset.card = finrank K V) :\n    ⇑(setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = ((↑) : s → V) := by\n  -- Porting note: added to make the next line unify the `_`s\n  rw [setBasisOfLinearIndependentOfCardEqFinrank]\n  exact Basis.coe_mk _ _\n\n"}
{"name":"is_simple_module_of_finrank_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nA : Type u_1\ninst✝³ : Semiring A\ninst✝² : Module A V\ninst✝¹ : SMul K A\ninst✝ : IsScalarTower K A V\nh : Eq (Module.finrank K V) 1\n⊢ IsSimpleOrder (Submodule A V)","decl":"/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]\n    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) := by\n  haveI := nontrivial_of_finrank_eq_succ h\n  refine ⟨fun S => or_iff_not_imp_left.2 fun hn => ?_⟩\n  rw [← restrictScalars_inj K] at hn ⊢\n  haveI : FiniteDimensional _ _ := .of_finrank_eq_succ h\n  refine eq_top_of_finrank_eq ((Submodule.finrank_le _).antisymm ?_)\n  simpa only [h, finrank_bot] using Submodule.finrank_strictMono (Ne.bot_lt hn)\n\n"}
{"name":"Subalgebra.isSimpleOrder_of_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nhr : Eq (Module.finrank F E) 2\n⊢ IsSimpleOrder (Subalgebra F E)","decl":"theorem Subalgebra.isSimpleOrder_of_finrank (hr : finrank F E = 2) :\n    IsSimpleOrder (Subalgebra F E) :=\n  let i := nontrivial_of_finrank_pos (zero_lt_two.trans_eq hr.symm)\n  { toNontrivial :=\n      ⟨⟨⊥, ⊤, fun h => by cases hr.symm.trans (Subalgebra.bot_eq_top_iff_finrank_eq_one.1 h)⟩⟩\n    eq_bot_or_eq_top := by\n      intro S\n      haveI : FiniteDimensional F E := .of_finrank_eq_succ hr\n      haveI : FiniteDimensional F S :=\n        FiniteDimensional.finiteDimensional_submodule (Subalgebra.toSubmodule S)\n      have : finrank F S ≤ 2 := hr ▸ S.toSubmodule.finrank_le\n      have : 0 < finrank F S := finrank_pos_iff.mpr inferInstance\n      interval_cases h : finrank F { x // x ∈ S }\n      · left\n        exact Subalgebra.eq_bot_of_finrank_one h\n      · right\n        rw [← hr] at h\n        rw [← Algebra.toSubmodule_eq_top]\n        exact eq_top_of_finrank_eq h }\n\n"}
{"name":"Module.End.exists_ker_pow_eq_ker_pow_succ","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\n⊢ Exists fun k => And (LE.le k (Module.finrank K V)) (Eq (LinearMap.ker (HPow.hPow f k)) (LinearMap.ker (HPow.hPow f k.succ)))","decl":"theorem exists_ker_pow_eq_ker_pow_succ [FiniteDimensional K V] (f : End K V) :\n    ∃ k : ℕ, k ≤ finrank K V ∧ LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) := by\n  classical\n    by_contra h_contra\n    simp_rw [not_exists, not_and] at h_contra\n    have h_le_ker_pow : ∀ n : ℕ, n ≤ (finrank K V).succ →\n        n ≤ finrank K (LinearMap.ker (f ^ n)) := by\n      intro n hn\n      induction' n with n ih\n      · exact zero_le (finrank _ _)\n      · have h_ker_lt_ker : LinearMap.ker (f ^ n) < LinearMap.ker (f ^ n.succ) := by\n          refine lt_of_le_of_ne ?_ (h_contra n (Nat.le_of_succ_le_succ hn))\n          rw [pow_succ']\n          apply LinearMap.ker_le_ker_comp\n        have h_finrank_lt_finrank :\n            finrank K (LinearMap.ker (f ^ n)) < finrank K (LinearMap.ker (f ^ n.succ)) := by\n          apply Submodule.finrank_lt_finrank_of_lt h_ker_lt_ker\n        calc\n          n.succ ≤ (finrank K ↑(LinearMap.ker (f ^ n))).succ :=\n            Nat.succ_le_succ (ih (Nat.le_of_succ_le hn))\n          _ ≤ finrank K ↑(LinearMap.ker (f ^ n.succ)) := Nat.succ_le_of_lt h_finrank_lt_finrank\n    have h_any_n_lt : ∀ n, n ≤ (finrank K V).succ → n ≤ finrank K V := fun n hn =>\n      (h_le_ker_pow n hn).trans (Submodule.finrank_le _)\n    show False\n    exact Nat.not_succ_le_self _ (h_any_n_lt (finrank K V).succ (finrank K V).succ.le_refl)\n\n"}
{"name":"Module.End.ker_pow_eq_ker_pow_finrank_of_le","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nm : Nat\nhm : LE.le (Module.finrank K V) m\n⊢ Eq (LinearMap.ker (HPow.hPow f m)) (LinearMap.ker (HPow.hPow f (Module.finrank K V)))","decl":"theorem ker_pow_eq_ker_pow_finrank_of_le [FiniteDimensional K V] {f : End K V} {m : ℕ}\n    (hm : finrank K V ≤ m) : LinearMap.ker (f ^ m) = LinearMap.ker (f ^ finrank K V) := by\n  obtain ⟨k, h_k_le, hk⟩ :\n    ∃ k, k ≤ finrank K V ∧ LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) :=\n    exists_ker_pow_eq_ker_pow_succ f\n  calc\n    LinearMap.ker (f ^ m) = LinearMap.ker (f ^ (k + (m - k))) := by\n      rw [add_tsub_cancel_of_le (h_k_le.trans hm)]\n    _ = LinearMap.ker (f ^ k) := by rw [ker_pow_constant hk _]\n    _ = LinearMap.ker (f ^ (k + (finrank K V - k))) := ker_pow_constant hk (finrank K V - k)\n    _ = LinearMap.ker (f ^ finrank K V) := by rw [add_tsub_cancel_of_le h_k_le]\n\n"}
{"name":"Module.End.ker_pow_le_ker_pow_finrank","module":"Mathlib.LinearAlgebra.FiniteDimensional","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nm : Nat\n⊢ LE.le (LinearMap.ker (HPow.hPow f m)) (LinearMap.ker (HPow.hPow f (Module.finrank K V)))","decl":"theorem ker_pow_le_ker_pow_finrank [FiniteDimensional K V] (f : End K V) (m : ℕ) :\n    LinearMap.ker (f ^ m) ≤ LinearMap.ker (f ^ finrank K V) := by\n  by_cases h_cases : m < finrank K V\n  · rw [← add_tsub_cancel_of_le (Nat.le_of_lt h_cases), add_comm, pow_add]\n    apply LinearMap.ker_le_ker_comp\n  · rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]\n\n"}
