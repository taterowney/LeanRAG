{"name":"CategoryTheory.PreGaloisCategory.instPreservesColimitsOfShapeFintypeCatSingleObjInclOfFinite","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"G : Type v\ninstâœÂ¹ : Group G\ninstâœ : Finite G\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.SingleObj G) FintypeCat.incl","decl":"noncomputable instance {G : Type v} [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) FintypeCat.incl.{w} := by\n  choose G' hg hf e using Finite.exists_type_univ_nonempty_mulEquiv G\n  exact Limits.preservesColimitsOfShape_of_equiv (Classical.choice e).toSingleObjEquiv.symm _\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsGalois.quotientByAutTerminal","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœ : CategoryTheory.GaloisCategory C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsGalois X\nâŠ¢ Nonempty (CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (CategoryTheory.SingleObj.functor (CategoryTheory.Aut.toEnd X))))","decl":"/-- A connected object `X` of `C` is Galois if the quotient `X / Aut X` is terminal. -/\nclass IsGalois {C : Type uâ‚} [Category.{uâ‚‚, uâ‚} C] [GaloisCategory C] (X : C)\n    extends IsConnected X : Prop where\n  quotientByAutTerminal : Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsGalois.toIsConnected","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœ : CategoryTheory.GaloisCategory C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsGalois X\nâŠ¢ CategoryTheory.PreGaloisCategory.IsConnected X","decl":"/-- A connected object `X` of `C` is Galois if the quotient `X / Aut X` is terminal. -/\nclass IsGalois {C : Type uâ‚} [Category.{uâ‚‚, uâ‚} C] [GaloisCategory C] (X : C)\n    extends IsConnected X : Prop where\n  quotientByAutTerminal : Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isGalois_iff_aux","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.GaloisCategory C\nX : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsConnected X\nâŠ¢ Iff (CategoryTheory.PreGaloisCategory.IsGalois X) (Nonempty (CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (CategoryTheory.SingleObj.functor (CategoryTheory.Aut.toEnd X)))))","decl":"lemma isGalois_iff_aux (X : C) [IsConnected X] :\n    IsGalois X â†” Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X) :=\n  âŸ¨fun h â†¦ h.quotientByAutTerminal, fun h â†¦ âŸ¨hâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isGalois_iff_pretransitive","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsConnected X\nâŠ¢ Iff (CategoryTheory.PreGaloisCategory.IsGalois X) (MulAction.IsPretransitive (CategoryTheory.Aut X) â†‘(F.obj X))","decl":"/-- Given a fiber functor `F` and a connected object `X` of `C`. Then `X` is Galois if and only if\nthe natural action of `Aut X` on `F.obj X` is transitive. -/\ntheorem isGalois_iff_pretransitive (X : C) [IsConnected X] :\n    IsGalois X â†” MulAction.IsPretransitive (Aut X) (F.obj X) := by\n  rw [isGalois_iff_aux, Equiv.nonempty_congr <| quotientByAutTerminalEquivUniqueQuotient F X]\n  exact (MulAction.pretransitive_iff_unique_quotient_of_nonempty (Aut X) (F.obj X)).symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isPretransitive_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nX : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois X\nâŠ¢ MulAction.IsPretransitive (CategoryTheory.Aut X) â†‘(F.obj X)","decl":"/-- If `X` is Galois, then the action of `Aut X` on `F.obj X` is\ntransitive for every fiber functor `F`. -/\ninstance isPretransitive_of_isGalois (X : C) [IsGalois X] :\n    MulAction.IsPretransitive (Aut X) (F.obj X) := by\n  rw [â† isGalois_iff_pretransitive]\n  infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.stabilizer_normal_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois X\nx : â†‘(F.obj X)\nâŠ¢ (MulAction.stabilizer (CategoryTheory.Aut F) x).Normal","decl":"lemma stabilizer_normal_of_isGalois (X : C) [IsGalois X] (x : F.obj X) :\n    Subgroup.Normal (MulAction.stabilizer (Aut F) x) where\n  conj_mem n ninstab g := by\n    rw [MulAction.mem_stabilizer_iff]\n    show g â€¢ n â€¢ (gâ»Â¹ â€¢ x) = x\n    have : âˆƒ (Ï† : Aut X), F.map Ï†.hom x = gâ»Â¹ â€¢ x :=\n      MulAction.IsPretransitive.exists_smul_eq x (gâ»Â¹ â€¢ x)\n    obtain âŸ¨Ï†, hâŸ© := this\n    rw [â† h, mulAction_naturality, ninstab, h]\n    simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_aut_surjective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois A\na : â†‘(F.obj A)\nâŠ¢ Function.Surjective fun f => F.map f.hom a","decl":"theorem evaluation_aut_surjective_of_isGalois (A : C) [IsGalois A] (a : F.obj A) :\n    Function.Surjective (fun f : Aut A â†¦ F.map f.hom a) :=\n  MulAction.IsPretransitive.exists_smul_eq a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_aut_bijective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois A\na : â†‘(F.obj A)\nâŠ¢ Function.Bijective fun f => F.map f.hom a","decl":"theorem evaluation_aut_bijective_of_isGalois (A : C) [IsGalois A] (a : F.obj A) :\n    Function.Bijective (fun f : Aut A â†¦ F.map f.hom a) :=\n  âŸ¨evaluation_aut_injective_of_isConnected F A a, evaluation_aut_surjective_of_isGalois F A aâŸ©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois A\na : â†‘(F.obj A)\nÏ† : CategoryTheory.Aut A\nâŠ¢ Eq ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A a) Ï†) (F.map Ï†.hom a)","decl":"@[simp]\nlemma evaluationEquivOfIsGalois_apply (A : C) [IsGalois A] (a : F.obj A) (Ï† : Aut A) :\n    evaluationEquivOfIsGalois F A a Ï† = F.map Ï†.hom a :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois_symm_fiber","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois A\na b : â†‘(F.obj A)\nâŠ¢ Eq (F.map ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A a).symm b).hom a) b","decl":"@[simp]\nlemma evaluationEquivOfIsGalois_symm_fiber (A : C) [IsGalois A] (a b : F.obj A) :\n    F.map ((evaluationEquivOfIsGalois F A a).symm b).hom a = b := by\n  change (evaluationEquivOfIsGalois F A a) _ = _\n  simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_autMap","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\nf : Quiver.Hom A B\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nÏƒ : CategoryTheory.Aut A\nâŠ¢ ExistsUnique fun Ï„ => Eq (CategoryTheory.CategoryStruct.comp f Ï„.hom) (CategoryTheory.CategoryStruct.comp Ïƒ.hom f)","decl":"/-- For a morphism from a connected object `A` to a Galois object `B` and an automorphism\nof `A`, there exists a unique automorphism of `B` making the canonical diagram commute. -/\nlemma exists_autMap {A B : C} (f : A âŸ¶ B) [IsConnected A] [IsGalois B] (Ïƒ : Aut A) :\n    âˆƒ! (Ï„ : Aut B), f â‰« Ï„.hom = Ïƒ.hom â‰« f := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain âŸ¨aâŸ© := nonempty_fiber_of_isConnected F A\n  refine âŸ¨?_, ?_, ?_âŸ©\n  Â· exact (evaluationEquivOfIsGalois F B (F.map f a)).symm (F.map (Ïƒ.hom â‰« f) a)\n  Â· apply evaluation_injective_of_isConnected F A B a\n    simp\n  Â· intro Ï„ hÏ„\n    apply evaluation_aut_injective_of_isConnected F B (F.map f a)\n    simpa using congr_fun (F.congr_map hÏ„) a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.comp_autMap","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nÏƒ : CategoryTheory.Aut A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.PreGaloisCategory.autMap f Ïƒ).hom) (CategoryTheory.CategoryStruct.comp Ïƒ.hom f)","decl":"@[simp]\nlemma comp_autMap {A B : C} [IsConnected A] [IsGalois B] (f : A âŸ¶ B) (Ïƒ : Aut A) :\n    f â‰« (autMap f Ïƒ).hom = Ïƒ.hom â‰« f :=\n  (exists_autMap f Ïƒ).choose_spec.left\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.comp_autMap_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nÏƒ : CategoryTheory.Aut A\na : â†‘(F.obj A)\nâŠ¢ Eq (F.map (CategoryTheory.PreGaloisCategory.autMap f Ïƒ).hom (F.map f a)) (F.map f (F.map Ïƒ.hom a))","decl":"@[simp]\nlemma comp_autMap_apply (F : C â¥¤ FintypeCat.{w}) {A B : C} [IsConnected A] [IsGalois B]\n    (f : A âŸ¶ B) (Ïƒ : Aut A) (a : F.obj A) :\n    F.map (autMap f Ïƒ).hom (F.map f a) = F.map f (F.map Ïƒ.hom a) := by\n  simpa [-comp_autMap] using congrFun (F.congr_map (comp_autMap f Ïƒ)) a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_unique","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nÏƒ : CategoryTheory.Aut A\nÏ„ : CategoryTheory.Aut B\nh : Eq (CategoryTheory.CategoryStruct.comp f Ï„.hom) (CategoryTheory.CategoryStruct.comp Ïƒ.hom f)\nâŠ¢ Eq (CategoryTheory.PreGaloisCategory.autMap f Ïƒ) Ï„","decl":"/-- `autMap` is uniquely characterized by making the canonical diagram commute. -/\nlemma autMap_unique {A B : C} [IsConnected A] [IsGalois B] (f : A âŸ¶ B) (Ïƒ : Aut A)\n    (Ï„ : Aut B) (h : f â‰« Ï„.hom = Ïƒ.hom â‰« f) :\n    autMap f Ïƒ = Ï„ :=\n  ((exists_autMap f Ïƒ).choose_spec.right Ï„ h).symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_id","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.GaloisCategory C\nA : C\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois A\nâŠ¢ Eq (CategoryTheory.PreGaloisCategory.autMap (CategoryTheory.CategoryStruct.id A)) id","decl":"@[simp]\nlemma autMap_id {A : C} [IsGalois A] : autMap (ğŸ™ A) = id :=\n  funext fun Ïƒ â†¦ autMap_unique (ğŸ™ A) Ïƒ _ (by simp)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_comp","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.GaloisCategory C\nX Y Z : C\ninstâœÂ² : CategoryTheory.PreGaloisCategory.IsConnected X\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsGalois Y\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.PreGaloisCategory.autMap (CategoryTheory.CategoryStruct.comp f g)) (Function.comp (CategoryTheory.PreGaloisCategory.autMap g) (CategoryTheory.PreGaloisCategory.autMap f))","decl":"@[simp]\nlemma autMap_comp {X Y Z : C} [IsConnected X] [IsGalois Y] [IsGalois Z] (f : X âŸ¶ Y)\n    (g : Y âŸ¶ Z) : autMap (f â‰« g) = autMap g âˆ˜ autMap f := by\n  refine funext fun Ïƒ â†¦ autMap_unique _ Ïƒ _ ?_\n  rw [Function.comp_apply, Category.assoc, comp_autMap, â† Category.assoc]\n  simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_surjective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsGalois A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nâŠ¢ Function.Surjective (CategoryTheory.PreGaloisCategory.autMap f)","decl":"/-- `autMap` is surjective, if the source is also Galois. -/\nlemma autMap_surjective_of_isGalois {A B : C} [IsGalois A] [IsGalois B] (f : A âŸ¶ B) :\n    Function.Surjective (autMap f) := by\n  intro Ïƒ\n  let F := GaloisCategory.getFiberFunctor C\n  obtain âŸ¨aâŸ© := nonempty_fiber_of_isConnected F A\n  obtain âŸ¨a', ha'âŸ© := surjective_of_nonempty_fiber_of_isConnected F f (F.map Ïƒ.hom (F.map f a))\n  obtain âŸ¨Ï„, (hÏ„ : F.map Ï„.hom a = a')âŸ© := MulAction.exists_smul_eq (Aut A) a a'\n  use Ï„\n  apply evaluation_aut_injective_of_isConnected F B (F.map f a)\n  simp [hÏ„, ha']\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_apply_mul","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nÏƒ Ï„ : CategoryTheory.Aut A\nâŠ¢ Eq (CategoryTheory.PreGaloisCategory.autMap f (HMul.hMul Ïƒ Ï„)) (HMul.hMul (CategoryTheory.PreGaloisCategory.autMap f Ïƒ) (CategoryTheory.PreGaloisCategory.autMap f Ï„))","decl":"@[simp]\nlemma autMap_apply_mul {A B : C} [IsConnected A] [IsGalois B] (f : A âŸ¶ B) (Ïƒ Ï„ : Aut A) :\n    autMap f (Ïƒ * Ï„) = autMap f Ïƒ * autMap f Ï„ := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain âŸ¨aâŸ© := nonempty_fiber_of_isConnected F A\n  apply evaluation_aut_injective_of_isConnected F (B : C) (F.map f a)\n  simp [Aut.Aut_mul_def]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMapHom_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{uâ‚‚, uâ‚} C\ninstâœÂ² : CategoryTheory.GaloisCategory C\nA B : C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninstâœ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nÏƒ : CategoryTheory.Aut A\nâŠ¢ Eq ((CategoryTheory.PreGaloisCategory.autMapHom f) Ïƒ) (CategoryTheory.PreGaloisCategory.autMap f Ïƒ)","decl":"/-- `MonoidHom` version of `autMap`. -/\n@[simps!]\nnoncomputable def autMapHom {A B : C} [IsConnected A] [IsGalois B] (f : A âŸ¶ B) :\n     Aut A â†’* Aut B :=\n  MonoidHom.mk' (autMap f) (autMap_apply_mul f)\n\n"}
