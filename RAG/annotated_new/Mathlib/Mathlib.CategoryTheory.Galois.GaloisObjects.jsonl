{"name":"CategoryTheory.PreGaloisCategory.instPreservesColimitsOfShapeFintypeCatSingleObjInclOfFinite","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"G : Type v\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.SingleObj G) FintypeCat.incl","decl":"noncomputable instance {G : Type v} [Group G] [Finite G] :\n    PreservesColimitsOfShape (SingleObj G) FintypeCat.incl.{w} := by\n  choose G' hg hf e using Finite.exists_type_univ_nonempty_mulEquiv G\n  exact Limits.preservesColimitsOfShape_of_equiv (Classical.choice e).toSingleObjEquiv.symm _\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsGalois.quotientByAutTerminal","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsGalois X\n⊢ Nonempty (CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (CategoryTheory.SingleObj.functor (CategoryTheory.Aut.toEnd X))))","decl":"/-- A connected object `X` of `C` is Galois if the quotient `X / Aut X` is terminal. -/\nclass IsGalois {C : Type u₁} [Category.{u₂, u₁} C] [GaloisCategory C] (X : C)\n    extends IsConnected X : Prop where\n  quotientByAutTerminal : Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.IsGalois.toIsConnected","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nX : C\nself : CategoryTheory.PreGaloisCategory.IsGalois X\n⊢ CategoryTheory.PreGaloisCategory.IsConnected X","decl":"/-- A connected object `X` of `C` is Galois if the quotient `X / Aut X` is terminal. -/\nclass IsGalois {C : Type u₁} [Category.{u₂, u₁} C] [GaloisCategory C] (X : C)\n    extends IsConnected X : Prop where\n  quotientByAutTerminal : Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isGalois_iff_aux","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ Iff (CategoryTheory.PreGaloisCategory.IsGalois X) (Nonempty (CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (CategoryTheory.SingleObj.functor (CategoryTheory.Aut.toEnd X)))))","decl":"lemma isGalois_iff_aux (X : C) [IsConnected X] :\n    IsGalois X ↔ Nonempty (IsTerminal <| colimit <| SingleObj.functor <| Aut.toEnd X) :=\n  ⟨fun h ↦ h.quotientByAutTerminal, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isGalois_iff_pretransitive","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ Iff (CategoryTheory.PreGaloisCategory.IsGalois X) (MulAction.IsPretransitive (CategoryTheory.Aut X) ↑(F.obj X))","decl":"/-- Given a fiber functor `F` and a connected object `X` of `C`. Then `X` is Galois if and only if\nthe natural action of `Aut X` on `F.obj X` is transitive. -/\ntheorem isGalois_iff_pretransitive (X : C) [IsConnected X] :\n    IsGalois X ↔ MulAction.IsPretransitive (Aut X) (F.obj X) := by\n  rw [isGalois_iff_aux, Equiv.nonempty_congr <| quotientByAutTerminalEquivUniqueQuotient F X]\n  exact (MulAction.pretransitive_iff_unique_quotient_of_nonempty (Aut X) (F.obj X)).symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.isPretransitive_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois X\n⊢ MulAction.IsPretransitive (CategoryTheory.Aut X) ↑(F.obj X)","decl":"/-- If `X` is Galois, then the action of `Aut X` on `F.obj X` is\ntransitive for every fiber functor `F`. -/\ninstance isPretransitive_of_isGalois (X : C) [IsGalois X] :\n    MulAction.IsPretransitive (Aut X) (F.obj X) := by\n  rw [← isGalois_iff_pretransitive]\n  infer_instance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.stabilizer_normal_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois X\nx : ↑(F.obj X)\n⊢ (MulAction.stabilizer (CategoryTheory.Aut F) x).Normal","decl":"lemma stabilizer_normal_of_isGalois (X : C) [IsGalois X] (x : F.obj X) :\n    Subgroup.Normal (MulAction.stabilizer (Aut F) x) where\n  conj_mem n ninstab g := by\n    rw [MulAction.mem_stabilizer_iff]\n    show g • n • (g⁻¹ • x) = x\n    have : ∃ (φ : Aut X), F.map φ.hom x = g⁻¹ • x :=\n      MulAction.IsPretransitive.exists_smul_eq x (g⁻¹ • x)\n    obtain ⟨φ, h⟩ := this\n    rw [← h, mulAction_naturality, ninstab, h]\n    simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_aut_surjective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na : ↑(F.obj A)\n⊢ Function.Surjective fun f => F.map f.hom a","decl":"theorem evaluation_aut_surjective_of_isGalois (A : C) [IsGalois A] (a : F.obj A) :\n    Function.Surjective (fun f : Aut A ↦ F.map f.hom a) :=\n  MulAction.IsPretransitive.exists_smul_eq a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluation_aut_bijective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na : ↑(F.obj A)\n⊢ Function.Bijective fun f => F.map f.hom a","decl":"theorem evaluation_aut_bijective_of_isGalois (A : C) [IsGalois A] (a : F.obj A) :\n    Function.Bijective (fun f : Aut A ↦ F.map f.hom a) :=\n  ⟨evaluation_aut_injective_of_isConnected F A a, evaluation_aut_surjective_of_isGalois F A a⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na : ↑(F.obj A)\nφ : CategoryTheory.Aut A\n⊢ Eq ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A a) φ) (F.map φ.hom a)","decl":"@[simp]\nlemma evaluationEquivOfIsGalois_apply (A : C) [IsGalois A] (a : F.obj A) (φ : Aut A) :\n    evaluationEquivOfIsGalois F A a φ = F.map φ.hom a :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois_symm_fiber","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\na b : ↑(F.obj A)\n⊢ Eq (F.map ((CategoryTheory.PreGaloisCategory.evaluationEquivOfIsGalois F A a).symm b).hom a) b","decl":"@[simp]\nlemma evaluationEquivOfIsGalois_symm_fiber (A : C) [IsGalois A] (a b : F.obj A) :\n    F.map ((evaluationEquivOfIsGalois F A a).symm b).hom a = b := by\n  change (evaluationEquivOfIsGalois F A a) _ = _\n  simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_autMap","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\nf : Quiver.Hom A B\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nσ : CategoryTheory.Aut A\n⊢ ExistsUnique fun τ => Eq (CategoryTheory.CategoryStruct.comp f τ.hom) (CategoryTheory.CategoryStruct.comp σ.hom f)","decl":"/-- For a morphism from a connected object `A` to a Galois object `B` and an automorphism\nof `A`, there exists a unique automorphism of `B` making the canonical diagram commute. -/\nlemma exists_autMap {A B : C} (f : A ⟶ B) [IsConnected A] [IsGalois B] (σ : Aut A) :\n    ∃! (τ : Aut B), f ≫ τ.hom = σ.hom ≫ f := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain ⟨a⟩ := nonempty_fiber_of_isConnected F A\n  refine ⟨?_, ?_, ?_⟩\n  · exact (evaluationEquivOfIsGalois F B (F.map f a)).symm (F.map (σ.hom ≫ f) a)\n  · apply evaluation_injective_of_isConnected F A B a\n    simp\n  · intro τ hτ\n    apply evaluation_aut_injective_of_isConnected F B (F.map f a)\n    simpa using congr_fun (F.congr_map hτ) a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.comp_autMap","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nσ : CategoryTheory.Aut A\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.PreGaloisCategory.autMap f σ).hom) (CategoryTheory.CategoryStruct.comp σ.hom f)","decl":"@[simp]\nlemma comp_autMap {A B : C} [IsConnected A] [IsGalois B] (f : A ⟶ B) (σ : Aut A) :\n    f ≫ (autMap f σ).hom = σ.hom ≫ f :=\n  (exists_autMap f σ).choose_spec.left\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.comp_autMap_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nσ : CategoryTheory.Aut A\na : ↑(F.obj A)\n⊢ Eq (F.map (CategoryTheory.PreGaloisCategory.autMap f σ).hom (F.map f a)) (F.map f (F.map σ.hom a))","decl":"@[simp]\nlemma comp_autMap_apply (F : C ⥤ FintypeCat.{w}) {A B : C} [IsConnected A] [IsGalois B]\n    (f : A ⟶ B) (σ : Aut A) (a : F.obj A) :\n    F.map (autMap f σ).hom (F.map f a) = F.map f (F.map σ.hom a) := by\n  simpa [-comp_autMap] using congrFun (F.congr_map (comp_autMap f σ)) a\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_unique","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nσ : CategoryTheory.Aut A\nτ : CategoryTheory.Aut B\nh : Eq (CategoryTheory.CategoryStruct.comp f τ.hom) (CategoryTheory.CategoryStruct.comp σ.hom f)\n⊢ Eq (CategoryTheory.PreGaloisCategory.autMap f σ) τ","decl":"/-- `autMap` is uniquely characterized by making the canonical diagram commute. -/\nlemma autMap_unique {A B : C} [IsConnected A] [IsGalois B] (f : A ⟶ B) (σ : Aut A)\n    (τ : Aut B) (h : f ≫ τ.hom = σ.hom ≫ f) :\n    autMap f σ = τ :=\n  ((exists_autMap f σ).choose_spec.right τ h).symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_id","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nA : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois A\n⊢ Eq (CategoryTheory.PreGaloisCategory.autMap (CategoryTheory.CategoryStruct.id A)) id","decl":"@[simp]\nlemma autMap_id {A : C} [IsGalois A] : autMap (𝟙 A) = id :=\n  funext fun σ ↦ autMap_unique (𝟙 A) σ _ (by simp)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_comp","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{u₂, u₁} C\ninst✝³ : CategoryTheory.GaloisCategory C\nX Y Z : C\ninst✝² : CategoryTheory.PreGaloisCategory.IsConnected X\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsGalois Y\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois Z\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.PreGaloisCategory.autMap (CategoryTheory.CategoryStruct.comp f g)) (Function.comp (CategoryTheory.PreGaloisCategory.autMap g) (CategoryTheory.PreGaloisCategory.autMap f))","decl":"@[simp]\nlemma autMap_comp {X Y Z : C} [IsConnected X] [IsGalois Y] [IsGalois Z] (f : X ⟶ Y)\n    (g : Y ⟶ Z) : autMap (f ≫ g) = autMap g ∘ autMap f := by\n  refine funext fun σ ↦ autMap_unique _ σ _ ?_\n  rw [Function.comp_apply, Category.assoc, comp_autMap, ← Category.assoc]\n  simp\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_surjective_of_isGalois","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsGalois A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\n⊢ Function.Surjective (CategoryTheory.PreGaloisCategory.autMap f)","decl":"/-- `autMap` is surjective, if the source is also Galois. -/\nlemma autMap_surjective_of_isGalois {A B : C} [IsGalois A] [IsGalois B] (f : A ⟶ B) :\n    Function.Surjective (autMap f) := by\n  intro σ\n  let F := GaloisCategory.getFiberFunctor C\n  obtain ⟨a⟩ := nonempty_fiber_of_isConnected F A\n  obtain ⟨a', ha'⟩ := surjective_of_nonempty_fiber_of_isConnected F f (F.map σ.hom (F.map f a))\n  obtain ⟨τ, (hτ : F.map τ.hom a = a')⟩ := MulAction.exists_smul_eq (Aut A) a a'\n  use τ\n  apply evaluation_aut_injective_of_isConnected F B (F.map f a)\n  simp [hτ, ha']\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMap_apply_mul","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nσ τ : CategoryTheory.Aut A\n⊢ Eq (CategoryTheory.PreGaloisCategory.autMap f (HMul.hMul σ τ)) (HMul.hMul (CategoryTheory.PreGaloisCategory.autMap f σ) (CategoryTheory.PreGaloisCategory.autMap f τ))","decl":"@[simp]\nlemma autMap_apply_mul {A B : C} [IsConnected A] [IsGalois B] (f : A ⟶ B) (σ τ : Aut A) :\n    autMap f (σ * τ) = autMap f σ * autMap f τ := by\n  let F := GaloisCategory.getFiberFunctor C\n  obtain ⟨a⟩ := nonempty_fiber_of_isConnected F A\n  apply evaluation_aut_injective_of_isConnected F (B : C) (F.map f a)\n  simp [Aut.Aut_mul_def]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autMapHom_apply","module":"Mathlib.CategoryTheory.Galois.GaloisObjects","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nA B : C\ninst✝¹ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝ : CategoryTheory.PreGaloisCategory.IsGalois B\nf : Quiver.Hom A B\nσ : CategoryTheory.Aut A\n⊢ Eq ((CategoryTheory.PreGaloisCategory.autMapHom f) σ) (CategoryTheory.PreGaloisCategory.autMap f σ)","decl":"/-- `MonoidHom` version of `autMap`. -/\n@[simps!]\nnoncomputable def autMapHom {A B : C} [IsConnected A] [IsGalois B] (f : A ⟶ B) :\n     Aut A →* Aut B :=\n  MonoidHom.mk' (autMap f) (autMap_apply_mul f)\n\n"}
