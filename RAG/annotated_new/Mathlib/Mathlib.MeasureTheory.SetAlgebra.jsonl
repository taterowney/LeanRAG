{"name":"MeasureTheory.IsSetAlgebra.compl_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nself : MeasureTheory.IsSetAlgebra 𝒜\ns : Set α\na✝ : Membership.mem 𝒜 s\n⊢ Membership.mem 𝒜 (HasCompl.compl s)","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (𝒜 : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ 𝒜\n  compl_mem : ∀ ⦃s⦄, s ∈ 𝒜 → sᶜ ∈ 𝒜\n  union_mem : ∀ ⦃s t⦄, s ∈ 𝒜 → t ∈ 𝒜 → s ∪ t ∈ 𝒜\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.union_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nself : MeasureTheory.IsSetAlgebra 𝒜\ns t : Set α\na✝¹ : Membership.mem 𝒜 s\na✝ : Membership.mem 𝒜 t\n⊢ Membership.mem 𝒜 (Union.union s t)","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (𝒜 : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ 𝒜\n  compl_mem : ∀ ⦃s⦄, s ∈ 𝒜 → sᶜ ∈ 𝒜\n  union_mem : ∀ ⦃s t⦄, s ∈ 𝒜 → t ∈ 𝒜 → s ∪ t ∈ 𝒜\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.empty_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nself : MeasureTheory.IsSetAlgebra 𝒜\n⊢ Membership.mem 𝒜 EmptyCollection.emptyCollection","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (𝒜 : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ 𝒜\n  compl_mem : ∀ ⦃s⦄, s ∈ 𝒜 → sᶜ ∈ 𝒜\n  union_mem : ∀ ⦃s t⦄, s ∈ 𝒜 → t ∈ 𝒜 → s ∪ t ∈ 𝒜\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.univ_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\n⊢ Membership.mem 𝒜 Set.univ","decl":"/-- An algebra of sets contains the whole set. -/\ntheorem univ_mem (h𝒜 : IsSetAlgebra 𝒜) : univ ∈ 𝒜 :=\n  compl_empty ▸ h𝒜.compl_mem h𝒜.empty_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.inter_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\ns t : Set α\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\ns_mem : Membership.mem 𝒜 s\nt_mem : Membership.mem 𝒜 t\n⊢ Membership.mem 𝒜 (Inter.inter s t)","decl":"/-- An algebra of sets is closed by intersection. -/\ntheorem inter_mem (h𝒜 : IsSetAlgebra 𝒜) (s_mem : s ∈ 𝒜) (t_mem : t ∈ 𝒜) :\n    s ∩ t ∈ 𝒜 :=\n  inter_eq_compl_compl_union_compl .. ▸\n    h𝒜.compl_mem (h𝒜.union_mem (h𝒜.compl_mem s_mem) (h𝒜.compl_mem t_mem))\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.diff_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\ns t : Set α\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\ns_mem : Membership.mem 𝒜 s\nt_mem : Membership.mem 𝒜 t\n⊢ Membership.mem 𝒜 (SDiff.sdiff s t)","decl":"/-- An algebra of sets is closed by difference. -/\ntheorem diff_mem (h𝒜 : IsSetAlgebra 𝒜) (s_mem : s ∈ 𝒜) (t_mem : t ∈ 𝒜) :\n    s \\ t ∈ 𝒜 := h𝒜.inter_mem s_mem (h𝒜.compl_mem t_mem)\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.isSetRing","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\n⊢ MeasureTheory.IsSetRing 𝒜","decl":"/-- An algebra of sets is a ring of sets. -/\ntheorem isSetRing (h𝒜 : IsSetAlgebra 𝒜) : IsSetRing 𝒜 where\n  empty_mem := h𝒜.empty_mem\n  union_mem := h𝒜.union_mem\n  diff_mem := fun _ _ ↦ h𝒜.diff_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.biUnion_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nι : Type u_2\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\ns : ι → Set α\nS : Finset ι\nhs : ∀ (i : ι), Membership.mem S i → Membership.mem 𝒜 (s i)\n⊢ Membership.mem 𝒜 (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"/-- An algebra of sets is closed by finite unions. -/\ntheorem biUnion_mem {ι : Type*} (h𝒜 : IsSetAlgebra 𝒜) {s : ι → Set α} (S : Finset ι)\n    (hs : ∀ i ∈ S, s i ∈ 𝒜) : ⋃ i ∈ S, s i ∈ 𝒜 := h𝒜.isSetRing.biUnion_mem S hs\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.biInter_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nι : Type u_2\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\ns : ι → Set α\nS : Finset ι\nhs : ∀ (i : ι), Membership.mem S i → Membership.mem 𝒜 (s i)\n⊢ Membership.mem 𝒜 (Set.iInter fun i => Set.iInter fun h => s i)","decl":"/-- An algebra of sets is closed by finite intersections. -/\ntheorem biInter_mem {ι : Type*} (h𝒜 : IsSetAlgebra 𝒜) {s : ι → Set α} (S : Finset ι)\n    (hs : ∀ i ∈ S, s i ∈ 𝒜) : ⋂ i ∈ S, s i ∈ 𝒜 := by\n  by_cases h : S = ∅\n  · rw [h, ← Finset.set_biInter_coe, Finset.coe_empty, biInter_empty]\n    exact h𝒜.univ_mem\n  · rw [← ne_eq, ← Finset.nonempty_iff_ne_empty] at h\n    exact h𝒜.isSetRing.biInter_mem S h hs\n\n"}
{"name":"MeasureTheory.generateSetAlgebra.brecOn","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_2\n𝒜 : Set (Set α)\nmotive✝ : (a : Set α) → MeasureTheory.generateSetAlgebra 𝒜 a → Prop\na✝ : Set α\nx✝ : MeasureTheory.generateSetAlgebra 𝒜 a✝\nih✝ : ∀ (a : Set α) (x : MeasureTheory.generateSetAlgebra 𝒜 a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- `generateSetAlgebra 𝒜` is the smallest algebra of sets containing `𝒜`. -/\ninductive generateSetAlgebra {α : Type*} (𝒜 : Set (Set α)) : Set (Set α)\n  | base (s : Set α) (s_mem : s ∈ 𝒜) : generateSetAlgebra 𝒜 s\n  | empty : generateSetAlgebra 𝒜 ∅\n  | compl (s : Set α) (hs : generateSetAlgebra 𝒜 s) : generateSetAlgebra 𝒜 sᶜ\n  | union (s t : Set α) (hs : generateSetAlgebra 𝒜 s) (ht : generateSetAlgebra 𝒜 t) :\n      generateSetAlgebra 𝒜 (s ∪ t)\n\n"}
{"name":"MeasureTheory.isSetAlgebra_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\n⊢ MeasureTheory.IsSetAlgebra (MeasureTheory.generateSetAlgebra 𝒜)","decl":"/-- The algebra of sets generated by a family of sets is an algebra of sets. -/\ntheorem isSetAlgebra_generateSetAlgebra :\n    IsSetAlgebra (generateSetAlgebra 𝒜) where\n  empty_mem := generateSetAlgebra.empty\n  compl_mem := fun _ hs ↦ generateSetAlgebra.compl _ hs\n  union_mem := fun _ _ hs ht ↦ generateSetAlgebra.union _ _ hs ht\n\n"}
{"name":"MeasureTheory.self_subset_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\n⊢ HasSubset.Subset 𝒜 (MeasureTheory.generateSetAlgebra 𝒜)","decl":"/-- The algebra of sets generated by `𝒜` contains `𝒜`. -/\ntheorem self_subset_generateSetAlgebra : 𝒜 ⊆ generateSetAlgebra 𝒜 :=\n  fun _ ↦ generateSetAlgebra.base _\n\n"}
{"name":"MeasureTheory.generateFrom_generateSetAlgebra_eq","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\n⊢ Eq (MeasurableSpace.generateFrom (MeasureTheory.generateSetAlgebra 𝒜)) (MeasurableSpace.generateFrom 𝒜)","decl":"/-- The measurable space generated by a family of sets `𝒜` is the same as the one generated\nby the algebra of sets generated by `𝒜`. -/\n@[simp]\ntheorem generateFrom_generateSetAlgebra_eq :\n    generateFrom (generateSetAlgebra 𝒜) = generateFrom 𝒜 := by\n  refine le_antisymm (fun s ms ↦ ?_) (generateFrom_mono self_subset_generateSetAlgebra)\n  induction s, ms using generateFrom_induction with\n  | hC t ht h =>\n    clear h\n    induction ht with\n    | base u u_mem => exact measurableSet_generateFrom u_mem\n    | empty => exact @MeasurableSet.empty _ (generateFrom 𝒜)\n    | compl u _ mu => exact mu.compl\n    | union u v _ _ mu mv  => exact MeasurableSet.union mu mv\n  | empty => exact MeasurableSpace.measurableSet_empty _\n  | compl t _ ht => exact ht.compl\n  | iUnion t _ ht => exact .iUnion ht\n\n"}
{"name":"MeasureTheory.generateSetAlgebra_mono","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 ℬ : Set (Set α)\nh : HasSubset.Subset 𝒜 ℬ\n⊢ HasSubset.Subset (MeasureTheory.generateSetAlgebra 𝒜) (MeasureTheory.generateSetAlgebra ℬ)","decl":"/-- If a family of sets `𝒜` is contained in `ℬ`, then the algebra of sets generated by `𝒜`\nis contained in the one generated by `ℬ`. -/\ntheorem generateSetAlgebra_mono {ℬ : Set (Set α)} (h : 𝒜 ⊆ ℬ) :\n    generateSetAlgebra 𝒜 ⊆ generateSetAlgebra ℬ := by\n  intro s hs\n  induction hs with\n  | base t t_mem => exact self_subset_generateSetAlgebra (h t_mem)\n  | empty => exact isSetAlgebra_generateSetAlgebra.empty_mem\n  | compl t _ t_mem => exact isSetAlgebra_generateSetAlgebra.compl_mem t_mem\n  | union t u _ _ t_mem u_mem => exact isSetAlgebra_generateSetAlgebra.union_mem t_mem u_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_subset","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 ℬ : Set (Set α)\nh : HasSubset.Subset 𝒜 ℬ\nhℬ : MeasureTheory.IsSetAlgebra ℬ\n⊢ HasSubset.Subset (MeasureTheory.generateSetAlgebra 𝒜) ℬ","decl":"/-- If a family of sets `𝒜` is contained in an algebra of sets `ℬ`, then so is the algebra of sets\ngenerated by `𝒜`. -/\ntheorem generateSetAlgebra_subset {ℬ : Set (Set α)} (h : 𝒜 ⊆ ℬ)\n    (hℬ : IsSetAlgebra ℬ) : generateSetAlgebra 𝒜 ⊆ ℬ := by\n  intro s hs\n  induction hs with\n  | base t t_mem => exact h t_mem\n  | empty => exact hℬ.empty_mem\n  | compl t _ t_mem => exact hℬ.compl_mem t_mem\n  | union t u _ _ t_mem u_mem => exact hℬ.union_mem t_mem u_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_subset_self","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\n⊢ HasSubset.Subset (MeasureTheory.generateSetAlgebra 𝒜) 𝒜","decl":"/-- If `𝒜` is an algebra of sets, then it contains the algebra generated by itself. -/\ntheorem generateSetAlgebra_subset_self (h𝒜 : IsSetAlgebra 𝒜) :\n    generateSetAlgebra 𝒜 ⊆ 𝒜 := h𝒜.generateSetAlgebra_subset subset_rfl\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_eq","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\n⊢ Eq (MeasureTheory.generateSetAlgebra 𝒜) 𝒜","decl":"/-- If `𝒜` is an algebra of sets, then it is equal to the algebra generated by itself. -/\ntheorem generateSetAlgebra_eq (h𝒜 : IsSetAlgebra 𝒜) : generateSetAlgebra 𝒜 = 𝒜 :=\n  Subset.antisymm h𝒜.generateSetAlgebra_subset_self self_subset_generateSetAlgebra\n\n"}
{"name":"MeasureTheory.mem_generateSetAlgebra_elim","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\ns : Set α\ns_mem : Membership.mem (MeasureTheory.generateSetAlgebra 𝒜) s\n⊢ Exists fun A => And A.Finite (And (∀ (a : Set (Set α)), Membership.mem A a → a.Finite) (And (∀ (a : Set (Set α)), Membership.mem A a → ∀ (t : Set α), Membership.mem a t → Or (Membership.mem 𝒜 t) (Membership.mem 𝒜 (HasCompl.compl t))) (Eq s (Set.iUnion fun a => Set.iUnion fun h => Set.iInter fun t => Set.iInter fun h => t))))","decl":"/-- If a set belongs to the algebra of sets generated by `𝒜` then it can be written as a finite\nunion of finite intersections of sets which are in `𝒜` or have their complement in `𝒜`. -/\ntheorem mem_generateSetAlgebra_elim (s_mem : s ∈ generateSetAlgebra 𝒜) :\n    ∃ A : Set (Set (Set α)), A.Finite ∧ (∀ a ∈ A, a.Finite) ∧\n    (∀ᵉ (a ∈ A) (t ∈ a), t ∈ 𝒜 ∨ tᶜ ∈ 𝒜) ∧ s = ⋃ a ∈ A, ⋂ t ∈ a, t := by\n  induction s_mem with\n  | base u u_mem =>\n    refine ⟨{{u}}, finite_singleton {u},\n      fun a ha ↦ eq_of_mem_singleton ha ▸ finite_singleton u,\n      fun a ha t ht ↦ ?_, by simp⟩\n    rw [eq_of_mem_singleton ha, ha, eq_of_mem_singleton ht, ht] at *\n    exact Or.inl u_mem\n  | empty => exact ⟨∅, finite_empty, fun _ h ↦ (not_mem_empty _ h).elim,\n    fun _ ha _ _ ↦ (not_mem_empty _ ha).elim, by simp⟩\n  | compl u _ u_ind =>\n    rcases u_ind with ⟨A, A_fin, mem_A, hA, u_eq⟩\n    have := finite_coe_iff.2 A_fin\n    have := fun a : A ↦ finite_coe_iff.2 <| mem_A a.1 a.2\n    refine ⟨{{(f a).1ᶜ | a : A} | f : (Π a : A, ↑a)}, finite_coe_iff.1 inferInstance,\n      fun a ⟨f, hf⟩ ↦ hf ▸ finite_coe_iff.1 inferInstance, fun a ha t ht ↦ ?_, ?_⟩\n    · rcases ha with ⟨f, rfl⟩\n      rcases ht with ⟨a, rfl⟩\n      rw [compl_compl, or_comm]\n      exact hA a.1 a.2 (f a).1 (f a).2\n    · ext x\n      simp only [u_eq, compl_iUnion, compl_iInter, mem_iInter, mem_iUnion, mem_compl_iff,\n        exists_prop, Subtype.exists, mem_setOf_eq, iUnion_exists, iUnion_iUnion_eq',\n        iInter_exists]\n      constructor <;> intro hx\n      · choose f hf using hx\n        exact ⟨fun ⟨a, ha⟩ ↦ ⟨f a ha, (hf a ha).1⟩, fun _ a ha h ↦ by rw [← h]; exact (hf a ha).2⟩\n      · rcases hx with ⟨f, hf⟩\n        exact fun a ha ↦ ⟨f ⟨a, ha⟩, (f ⟨a, ha⟩).2, hf (f ⟨a, ha⟩)ᶜ a ha rfl⟩\n  | union u v _ _ u_ind v_ind =>\n    rcases u_ind with ⟨Au, Au_fin, mem_Au, hAu, u_eq⟩\n    rcases v_ind with ⟨Av, Av_fin, mem_Av, hAv, v_eq⟩\n    refine ⟨Au ∪ Av, Au_fin.union Av_fin, ?_, ?_, by rw [u_eq, v_eq, ← biUnion_union]⟩\n    · rintro a (ha | ha)\n      · exact mem_Au a ha\n      · exact mem_Av a ha\n    · rintro a (ha | ha) t ht\n      · exact hAu a ha t ht\n      · exact hAv a ha t ht\n\n"}
{"name":"MeasureTheory.countable_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh : 𝒜.Countable\n⊢ (MeasureTheory.generateSetAlgebra 𝒜).Countable","decl":"/-- If a family of sets is countable then so is the algebra of sets generated by it. -/\ntheorem countable_generateSetAlgebra (h : 𝒜.Countable) :\n    (generateSetAlgebra 𝒜).Countable := by\n  let ℬ := {s | s ∈ 𝒜} ∪ {s | sᶜ ∈ 𝒜}\n  have count_ℬ : ℬ.Countable := by\n    apply h.union\n    have : compl '' 𝒜 = {s | sᶜ ∈ 𝒜} := by\n      ext s\n      simpa using ⟨fun ⟨x, x_mem, hx⟩ ↦ by simp [← hx, x_mem], fun hs ↦ ⟨sᶜ, hs, by simp⟩⟩\n    exact this ▸ h.image compl\n  let f : Set (Set (Set α)) → Set α := fun A ↦ ⋃ a ∈ A, ⋂ t ∈ a, t\n  let 𝒞 := {a | a.Finite ∧ a ⊆ ℬ}\n  have count_𝒞 : 𝒞.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_ℬ)\n  let 𝒟 := {A | A.Finite ∧ A ⊆ 𝒞}\n  have count_𝒟 : 𝒟.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_𝒞)\n  have : generateSetAlgebra 𝒜 ⊆ f '' 𝒟 := by\n    intro s s_mem\n    rcases mem_generateSetAlgebra_elim s_mem with ⟨A, A_fin, mem_A, hA, rfl⟩\n    exact ⟨A, ⟨A_fin, fun a ha ↦ ⟨mem_A a ha, hA a ha⟩⟩, rfl⟩\n  exact (count_𝒟.image f).mono this\n\n"}
