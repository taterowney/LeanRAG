{"name":"MeasureTheory.IsSetAlgebra.compl_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nself : MeasureTheory.IsSetAlgebra ğ’œ\ns : Set Î±\naâœ : Membership.mem ğ’œ s\nâŠ¢ Membership.mem ğ’œ (HasCompl.compl s)","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (ğ’œ : Set (Set Î±)) : Prop where\n  empty_mem : âˆ… âˆˆ ğ’œ\n  compl_mem : âˆ€ â¦ƒsâ¦„, s âˆˆ ğ’œ â†’ sá¶œ âˆˆ ğ’œ\n  union_mem : âˆ€ â¦ƒs tâ¦„, s âˆˆ ğ’œ â†’ t âˆˆ ğ’œ â†’ s âˆª t âˆˆ ğ’œ\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.union_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nself : MeasureTheory.IsSetAlgebra ğ’œ\ns t : Set Î±\naâœÂ¹ : Membership.mem ğ’œ s\naâœ : Membership.mem ğ’œ t\nâŠ¢ Membership.mem ğ’œ (Union.union s t)","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (ğ’œ : Set (Set Î±)) : Prop where\n  empty_mem : âˆ… âˆˆ ğ’œ\n  compl_mem : âˆ€ â¦ƒsâ¦„, s âˆˆ ğ’œ â†’ sá¶œ âˆˆ ğ’œ\n  union_mem : âˆ€ â¦ƒs tâ¦„, s âˆˆ ğ’œ â†’ t âˆˆ ğ’œ â†’ s âˆª t âˆˆ ğ’œ\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.empty_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nself : MeasureTheory.IsSetAlgebra ğ’œ\nâŠ¢ Membership.mem ğ’œ EmptyCollection.emptyCollection","decl":"/-- An algebra of sets is a family of sets containing the empty set and closed by complement and\nunion. Consequently it is also closed by difference (see `IsSetAlgebra.diff_mem`) and intersection\n(see `IsSetAlgebra.inter_mem`). -/\nstructure IsSetAlgebra (ğ’œ : Set (Set Î±)) : Prop where\n  empty_mem : âˆ… âˆˆ ğ’œ\n  compl_mem : âˆ€ â¦ƒsâ¦„, s âˆˆ ğ’œ â†’ sá¶œ âˆˆ ğ’œ\n  union_mem : âˆ€ â¦ƒs tâ¦„, s âˆˆ ğ’œ â†’ t âˆˆ ğ’œ â†’ s âˆª t âˆˆ ğ’œ\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.univ_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nâŠ¢ Membership.mem ğ’œ Set.univ","decl":"/-- An algebra of sets contains the whole set. -/\ntheorem univ_mem (hğ’œ : IsSetAlgebra ğ’œ) : univ âˆˆ ğ’œ :=\n  compl_empty â–¸ hğ’œ.compl_mem hğ’œ.empty_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.inter_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\ns t : Set Î±\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\ns_mem : Membership.mem ğ’œ s\nt_mem : Membership.mem ğ’œ t\nâŠ¢ Membership.mem ğ’œ (Inter.inter s t)","decl":"/-- An algebra of sets is closed by intersection. -/\ntheorem inter_mem (hğ’œ : IsSetAlgebra ğ’œ) (s_mem : s âˆˆ ğ’œ) (t_mem : t âˆˆ ğ’œ) :\n    s âˆ© t âˆˆ ğ’œ :=\n  inter_eq_compl_compl_union_compl .. â–¸\n    hğ’œ.compl_mem (hğ’œ.union_mem (hğ’œ.compl_mem s_mem) (hğ’œ.compl_mem t_mem))\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.diff_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\ns t : Set Î±\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\ns_mem : Membership.mem ğ’œ s\nt_mem : Membership.mem ğ’œ t\nâŠ¢ Membership.mem ğ’œ (SDiff.sdiff s t)","decl":"/-- An algebra of sets is closed by difference. -/\ntheorem diff_mem (hğ’œ : IsSetAlgebra ğ’œ) (s_mem : s âˆˆ ğ’œ) (t_mem : t âˆˆ ğ’œ) :\n    s \\ t âˆˆ ğ’œ := hğ’œ.inter_mem s_mem (hğ’œ.compl_mem t_mem)\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.isSetRing","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nâŠ¢ MeasureTheory.IsSetRing ğ’œ","decl":"/-- An algebra of sets is a ring of sets. -/\ntheorem isSetRing (hğ’œ : IsSetAlgebra ğ’œ) : IsSetRing ğ’œ where\n  empty_mem := hğ’œ.empty_mem\n  union_mem := hğ’œ.union_mem\n  diff_mem := fun _ _ â†¦ hğ’œ.diff_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.biUnion_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nÎ¹ : Type u_2\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\ns : Î¹ â†’ Set Î±\nS : Finset Î¹\nhs : âˆ€ (i : Î¹), Membership.mem S i â†’ Membership.mem ğ’œ (s i)\nâŠ¢ Membership.mem ğ’œ (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"/-- An algebra of sets is closed by finite unions. -/\ntheorem biUnion_mem {Î¹ : Type*} (hğ’œ : IsSetAlgebra ğ’œ) {s : Î¹ â†’ Set Î±} (S : Finset Î¹)\n    (hs : âˆ€ i âˆˆ S, s i âˆˆ ğ’œ) : â‹ƒ i âˆˆ S, s i âˆˆ ğ’œ := hğ’œ.isSetRing.biUnion_mem S hs\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.biInter_mem","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nÎ¹ : Type u_2\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\ns : Î¹ â†’ Set Î±\nS : Finset Î¹\nhs : âˆ€ (i : Î¹), Membership.mem S i â†’ Membership.mem ğ’œ (s i)\nâŠ¢ Membership.mem ğ’œ (Set.iInter fun i => Set.iInter fun h => s i)","decl":"/-- An algebra of sets is closed by finite intersections. -/\ntheorem biInter_mem {Î¹ : Type*} (hğ’œ : IsSetAlgebra ğ’œ) {s : Î¹ â†’ Set Î±} (S : Finset Î¹)\n    (hs : âˆ€ i âˆˆ S, s i âˆˆ ğ’œ) : â‹‚ i âˆˆ S, s i âˆˆ ğ’œ := by\n  by_cases h : S = âˆ…\n  Â· rw [h, â† Finset.set_biInter_coe, Finset.coe_empty, biInter_empty]\n    exact hğ’œ.univ_mem\n  Â· rw [â† ne_eq, â† Finset.nonempty_iff_ne_empty] at h\n    exact hğ’œ.isSetRing.biInter_mem S h hs\n\n"}
{"name":"MeasureTheory.generateSetAlgebra.brecOn","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_2\nğ’œ : Set (Set Î±)\nmotiveâœ : (a : Set Î±) â†’ MeasureTheory.generateSetAlgebra ğ’œ a â†’ Prop\naâœ : Set Î±\nxâœ : MeasureTheory.generateSetAlgebra ğ’œ aâœ\nihâœ : âˆ€ (a : Set Î±) (x : MeasureTheory.generateSetAlgebra ğ’œ a), x.below â†’ motiveâœ a x\nâŠ¢ motiveâœ aâœ xâœ","decl":"/-- `generateSetAlgebra ğ’œ` is the smallest algebra of sets containing `ğ’œ`. -/\ninductive generateSetAlgebra {Î± : Type*} (ğ’œ : Set (Set Î±)) : Set (Set Î±)\n  | base (s : Set Î±) (s_mem : s âˆˆ ğ’œ) : generateSetAlgebra ğ’œ s\n  | empty : generateSetAlgebra ğ’œ âˆ…\n  | compl (s : Set Î±) (hs : generateSetAlgebra ğ’œ s) : generateSetAlgebra ğ’œ sá¶œ\n  | union (s t : Set Î±) (hs : generateSetAlgebra ğ’œ s) (ht : generateSetAlgebra ğ’œ t) :\n      generateSetAlgebra ğ’œ (s âˆª t)\n\n"}
{"name":"MeasureTheory.isSetAlgebra_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nâŠ¢ MeasureTheory.IsSetAlgebra (MeasureTheory.generateSetAlgebra ğ’œ)","decl":"/-- The algebra of sets generated by a family of sets is an algebra of sets. -/\ntheorem isSetAlgebra_generateSetAlgebra :\n    IsSetAlgebra (generateSetAlgebra ğ’œ) where\n  empty_mem := generateSetAlgebra.empty\n  compl_mem := fun _ hs â†¦ generateSetAlgebra.compl _ hs\n  union_mem := fun _ _ hs ht â†¦ generateSetAlgebra.union _ _ hs ht\n\n"}
{"name":"MeasureTheory.self_subset_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nâŠ¢ HasSubset.Subset ğ’œ (MeasureTheory.generateSetAlgebra ğ’œ)","decl":"/-- The algebra of sets generated by `ğ’œ` contains `ğ’œ`. -/\ntheorem self_subset_generateSetAlgebra : ğ’œ âŠ† generateSetAlgebra ğ’œ :=\n  fun _ â†¦ generateSetAlgebra.base _\n\n"}
{"name":"MeasureTheory.generateFrom_generateSetAlgebra_eq","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nâŠ¢ Eq (MeasurableSpace.generateFrom (MeasureTheory.generateSetAlgebra ğ’œ)) (MeasurableSpace.generateFrom ğ’œ)","decl":"/-- The measurable space generated by a family of sets `ğ’œ` is the same as the one generated\nby the algebra of sets generated by `ğ’œ`. -/\n@[simp]\ntheorem generateFrom_generateSetAlgebra_eq :\n    generateFrom (generateSetAlgebra ğ’œ) = generateFrom ğ’œ := by\n  refine le_antisymm (fun s ms â†¦ ?_) (generateFrom_mono self_subset_generateSetAlgebra)\n  induction s, ms using generateFrom_induction with\n  | hC t ht h =>\n    clear h\n    induction ht with\n    | base u u_mem => exact measurableSet_generateFrom u_mem\n    | empty => exact @MeasurableSet.empty _ (generateFrom ğ’œ)\n    | compl u _ mu => exact mu.compl\n    | union u v _ _ mu mv  => exact MeasurableSet.union mu mv\n  | empty => exact MeasurableSpace.measurableSet_empty _\n  | compl t _ ht => exact ht.compl\n  | iUnion t _ ht => exact .iUnion ht\n\n"}
{"name":"MeasureTheory.generateSetAlgebra_mono","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ â„¬ : Set (Set Î±)\nh : HasSubset.Subset ğ’œ â„¬\nâŠ¢ HasSubset.Subset (MeasureTheory.generateSetAlgebra ğ’œ) (MeasureTheory.generateSetAlgebra â„¬)","decl":"/-- If a family of sets `ğ’œ` is contained in `â„¬`, then the algebra of sets generated by `ğ’œ`\nis contained in the one generated by `â„¬`. -/\ntheorem generateSetAlgebra_mono {â„¬ : Set (Set Î±)} (h : ğ’œ âŠ† â„¬) :\n    generateSetAlgebra ğ’œ âŠ† generateSetAlgebra â„¬ := by\n  intro s hs\n  induction hs with\n  | base t t_mem => exact self_subset_generateSetAlgebra (h t_mem)\n  | empty => exact isSetAlgebra_generateSetAlgebra.empty_mem\n  | compl t _ t_mem => exact isSetAlgebra_generateSetAlgebra.compl_mem t_mem\n  | union t u _ _ t_mem u_mem => exact isSetAlgebra_generateSetAlgebra.union_mem t_mem u_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_subset","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ â„¬ : Set (Set Î±)\nh : HasSubset.Subset ğ’œ â„¬\nhâ„¬ : MeasureTheory.IsSetAlgebra â„¬\nâŠ¢ HasSubset.Subset (MeasureTheory.generateSetAlgebra ğ’œ) â„¬","decl":"/-- If a family of sets `ğ’œ` is contained in an algebra of sets `â„¬`, then so is the algebra of sets\ngenerated by `ğ’œ`. -/\ntheorem generateSetAlgebra_subset {â„¬ : Set (Set Î±)} (h : ğ’œ âŠ† â„¬)\n    (hâ„¬ : IsSetAlgebra â„¬) : generateSetAlgebra ğ’œ âŠ† â„¬ := by\n  intro s hs\n  induction hs with\n  | base t t_mem => exact h t_mem\n  | empty => exact hâ„¬.empty_mem\n  | compl t _ t_mem => exact hâ„¬.compl_mem t_mem\n  | union t u _ _ t_mem u_mem => exact hâ„¬.union_mem t_mem u_mem\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_subset_self","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nâŠ¢ HasSubset.Subset (MeasureTheory.generateSetAlgebra ğ’œ) ğ’œ","decl":"/-- If `ğ’œ` is an algebra of sets, then it contains the algebra generated by itself. -/\ntheorem generateSetAlgebra_subset_self (hğ’œ : IsSetAlgebra ğ’œ) :\n    generateSetAlgebra ğ’œ âŠ† ğ’œ := hğ’œ.generateSetAlgebra_subset subset_rfl\n\n"}
{"name":"MeasureTheory.IsSetAlgebra.generateSetAlgebra_eq","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nâŠ¢ Eq (MeasureTheory.generateSetAlgebra ğ’œ) ğ’œ","decl":"/-- If `ğ’œ` is an algebra of sets, then it is equal to the algebra generated by itself. -/\ntheorem generateSetAlgebra_eq (hğ’œ : IsSetAlgebra ğ’œ) : generateSetAlgebra ğ’œ = ğ’œ :=\n  Subset.antisymm hğ’œ.generateSetAlgebra_subset_self self_subset_generateSetAlgebra\n\n"}
{"name":"MeasureTheory.mem_generateSetAlgebra_elim","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\ns : Set Î±\ns_mem : Membership.mem (MeasureTheory.generateSetAlgebra ğ’œ) s\nâŠ¢ Exists fun A => And A.Finite (And (âˆ€ (a : Set (Set Î±)), Membership.mem A a â†’ a.Finite) (And (âˆ€ (a : Set (Set Î±)), Membership.mem A a â†’ âˆ€ (t : Set Î±), Membership.mem a t â†’ Or (Membership.mem ğ’œ t) (Membership.mem ğ’œ (HasCompl.compl t))) (Eq s (Set.iUnion fun a => Set.iUnion fun h => Set.iInter fun t => Set.iInter fun h => t))))","decl":"/-- If a set belongs to the algebra of sets generated by `ğ’œ` then it can be written as a finite\nunion of finite intersections of sets which are in `ğ’œ` or have their complement in `ğ’œ`. -/\ntheorem mem_generateSetAlgebra_elim (s_mem : s âˆˆ generateSetAlgebra ğ’œ) :\n    âˆƒ A : Set (Set (Set Î±)), A.Finite âˆ§ (âˆ€ a âˆˆ A, a.Finite) âˆ§\n    (âˆ€áµ‰ (a âˆˆ A) (t âˆˆ a), t âˆˆ ğ’œ âˆ¨ tá¶œ âˆˆ ğ’œ) âˆ§ s = â‹ƒ a âˆˆ A, â‹‚ t âˆˆ a, t := by\n  induction s_mem with\n  | base u u_mem =>\n    refine âŸ¨{{u}}, finite_singleton {u},\n      fun a ha â†¦ eq_of_mem_singleton ha â–¸ finite_singleton u,\n      fun a ha t ht â†¦ ?_, by simpâŸ©\n    rw [eq_of_mem_singleton ha, ha, eq_of_mem_singleton ht, ht] at *\n    exact Or.inl u_mem\n  | empty => exact âŸ¨âˆ…, finite_empty, fun _ h â†¦ (not_mem_empty _ h).elim,\n    fun _ ha _ _ â†¦ (not_mem_empty _ ha).elim, by simpâŸ©\n  | compl u _ u_ind =>\n    rcases u_ind with âŸ¨A, A_fin, mem_A, hA, u_eqâŸ©\n    have := finite_coe_iff.2 A_fin\n    have := fun a : A â†¦ finite_coe_iff.2 <| mem_A a.1 a.2\n    refine âŸ¨{{(f a).1á¶œ | a : A} | f : (Î  a : A, â†‘a)}, finite_coe_iff.1 inferInstance,\n      fun a âŸ¨f, hfâŸ© â†¦ hf â–¸ finite_coe_iff.1 inferInstance, fun a ha t ht â†¦ ?_, ?_âŸ©\n    Â· rcases ha with âŸ¨f, rflâŸ©\n      rcases ht with âŸ¨a, rflâŸ©\n      rw [compl_compl, or_comm]\n      exact hA a.1 a.2 (f a).1 (f a).2\n    Â· ext x\n      simp only [u_eq, compl_iUnion, compl_iInter, mem_iInter, mem_iUnion, mem_compl_iff,\n        exists_prop, Subtype.exists, mem_setOf_eq, iUnion_exists, iUnion_iUnion_eq',\n        iInter_exists]\n      constructor <;> intro hx\n      Â· choose f hf using hx\n        exact âŸ¨fun âŸ¨a, haâŸ© â†¦ âŸ¨f a ha, (hf a ha).1âŸ©, fun _ a ha h â†¦ by rw [â† h]; exact (hf a ha).2âŸ©\n      Â· rcases hx with âŸ¨f, hfâŸ©\n        exact fun a ha â†¦ âŸ¨f âŸ¨a, haâŸ©, (f âŸ¨a, haâŸ©).2, hf (f âŸ¨a, haâŸ©)á¶œ a ha rflâŸ©\n  | union u v _ _ u_ind v_ind =>\n    rcases u_ind with âŸ¨Au, Au_fin, mem_Au, hAu, u_eqâŸ©\n    rcases v_ind with âŸ¨Av, Av_fin, mem_Av, hAv, v_eqâŸ©\n    refine âŸ¨Au âˆª Av, Au_fin.union Av_fin, ?_, ?_, by rw [u_eq, v_eq, â† biUnion_union]âŸ©\n    Â· rintro a (ha | ha)\n      Â· exact mem_Au a ha\n      Â· exact mem_Av a ha\n    Â· rintro a (ha | ha) t ht\n      Â· exact hAu a ha t ht\n      Â· exact hAv a ha t ht\n\n"}
{"name":"MeasureTheory.countable_generateSetAlgebra","module":"Mathlib.MeasureTheory.SetAlgebra","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nh : ğ’œ.Countable\nâŠ¢ (MeasureTheory.generateSetAlgebra ğ’œ).Countable","decl":"/-- If a family of sets is countable then so is the algebra of sets generated by it. -/\ntheorem countable_generateSetAlgebra (h : ğ’œ.Countable) :\n    (generateSetAlgebra ğ’œ).Countable := by\n  let â„¬ := {s | s âˆˆ ğ’œ} âˆª {s | sá¶œ âˆˆ ğ’œ}\n  have count_â„¬ : â„¬.Countable := by\n    apply h.union\n    have : compl '' ğ’œ = {s | sá¶œ âˆˆ ğ’œ} := by\n      ext s\n      simpa using âŸ¨fun âŸ¨x, x_mem, hxâŸ© â†¦ by simp [â† hx, x_mem], fun hs â†¦ âŸ¨sá¶œ, hs, by simpâŸ©âŸ©\n    exact this â–¸ h.image compl\n  let f : Set (Set (Set Î±)) â†’ Set Î± := fun A â†¦ â‹ƒ a âˆˆ A, â‹‚ t âˆˆ a, t\n  let ğ’ := {a | a.Finite âˆ§ a âŠ† â„¬}\n  have count_ğ’ : ğ’.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_â„¬)\n  let ğ’Ÿ := {A | A.Finite âˆ§ A âŠ† ğ’}\n  have count_ğ’Ÿ : ğ’Ÿ.Countable := countable_setOf_finite_subset (countable_coe_iff.1 count_ğ’)\n  have : generateSetAlgebra ğ’œ âŠ† f '' ğ’Ÿ := by\n    intro s s_mem\n    rcases mem_generateSetAlgebra_elim s_mem with âŸ¨A, A_fin, mem_A, hA, rflâŸ©\n    exact âŸ¨A, âŸ¨A_fin, fun a ha â†¦ âŸ¨mem_A a ha, hA a haâŸ©âŸ©, rflâŸ©\n  exact (count_ğ’Ÿ.image f).mono this\n\n"}
