{"name":"MonomialOrder.degree_zero","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (m.degree 0) 0","decl":"@[simp]\ntheorem degree_zero : m.degree (0 : MvPolynomial σ R) = 0 := by\n  simp [degree]\n\n"}
{"name":"MonomialOrder.leadingCoeff_zero","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (m.leadingCoeff 0) 0","decl":"@[simp]\ntheorem leadingCoeff_zero : m.leadingCoeff (0 : MvPolynomial σ R) = 0 := by\n  simp [degree, leadingCoeff]\n\n"}
{"name":"MonomialOrder.lCoeff_zero","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (m.leadingCoeff 0) 0","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_zero := leadingCoeff_zero\n\n"}
{"name":"MonomialOrder.degree_monomial_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nd : Finsupp σ Nat\nc : R\n⊢ LE.le (m.toSyn (m.degree ((MvPolynomial.monomial d) c))) (m.toSyn d)","decl":"theorem degree_monomial_le {d : σ →₀ ℕ} (c : R) :\n    m.degree (monomial d c) ≼[m] d := by\n  simp only [degree, AddEquiv.apply_symm_apply]\n  apply le_trans (Finset.sup_mono support_monomial_subset)\n  simp only [Finset.sup_singleton, le_refl]\n\n"}
{"name":"MonomialOrder.degree_monomial","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\nd : Finsupp σ Nat\nc : R\ninst✝ : Decidable (Eq c 0)\n⊢ Eq (m.degree ((MvPolynomial.monomial d) c)) (ite (Eq c 0) 0 d)","decl":"theorem degree_monomial {d : σ →₀ ℕ} (c : R) [Decidable (c = 0)] :\n    m.degree (monomial d c) = if c = 0 then 0 else d := by\n  simp only [degree, support_monomial]\n  split_ifs with hc <;> simp\n\n"}
{"name":"MonomialOrder.degree_X_le_single","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\ns : σ\n⊢ LE.le (m.toSyn (m.degree (MvPolynomial.X s))) (m.toSyn (Finsupp.single s 1))","decl":"theorem degree_X_le_single {s : σ} : m.degree (X s : MvPolynomial σ R) ≼[m] Finsupp.single s 1 :=\n  degree_monomial_le 1\n\n"}
{"name":"MonomialOrder.degree_X","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\ns : σ\n⊢ Eq (m.degree (MvPolynomial.X s)) (Finsupp.single s 1)","decl":"theorem degree_X [Nontrivial R] {s : σ} :\n    m.degree (X s : MvPolynomial σ R) = Finsupp.single s 1 := by\n  classical\n  change m.degree (monomial (Finsupp.single s 1) (1 : R)) = _\n  rw [degree_monomial, if_neg one_ne_zero]\n\n"}
{"name":"MonomialOrder.leadingCoeff_monomial","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nd : Finsupp σ Nat\nc : R\n⊢ Eq (m.leadingCoeff ((MvPolynomial.monomial d) c)) c","decl":"@[simp]\ntheorem leadingCoeff_monomial {d : σ →₀ ℕ} (c : R) :\n    m.leadingCoeff (monomial d c) = c := by\n  classical\n  simp only [leadingCoeff, degree_monomial]\n  split_ifs with hc <;> simp [hc]\n\n"}
{"name":"MonomialOrder.lCoeff_monomial","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nd : Finsupp σ Nat\nc : R\n⊢ Eq (m.leadingCoeff ((MvPolynomial.monomial d) c)) c","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_monomial := leadingCoeff_monomial\n\n"}
{"name":"MonomialOrder.degree_le_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nd : Finsupp σ Nat\n⊢ Iff (LE.le (m.toSyn (m.degree f)) (m.toSyn d)) (∀ (c : Finsupp σ Nat), Membership.mem f.support c → LE.le (m.toSyn c) (m.toSyn d))","decl":"theorem degree_le_iff {f : MvPolynomial σ R} {d : σ →₀ ℕ} :\n    m.degree f ≼[m] d ↔ ∀ c ∈ f.support, c ≼[m] d := by\n  unfold degree\n  simp only [AddEquiv.apply_symm_apply, Finset.sup_le_iff, mem_support_iff, ne_eq]\n\n"}
{"name":"MonomialOrder.degree_lt_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nd : Finsupp σ Nat\nhd : LT.lt (m.toSyn 0) (m.toSyn d)\n⊢ Iff (LT.lt (m.toSyn (m.degree f)) (m.toSyn d)) (∀ (c : Finsupp σ Nat), Membership.mem f.support c → LT.lt (m.toSyn c) (m.toSyn d))","decl":"theorem degree_lt_iff {f : MvPolynomial σ R} {d : σ →₀ ℕ} (hd : 0 ≺[m] d) :\n    m.degree f ≺[m] d ↔ ∀ c ∈ f.support, c ≺[m] d := by\n  simp only [map_zero] at hd\n  unfold degree\n  simp only [AddEquiv.apply_symm_apply]\n  exact Finset.sup_lt_iff hd\n\n"}
{"name":"MonomialOrder.le_degree","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nd : Finsupp σ Nat\nhd : Membership.mem f.support d\n⊢ LE.le (m.toSyn d) (m.toSyn (m.degree f))","decl":"theorem le_degree {f : MvPolynomial σ R} {d : σ →₀ ℕ} (hd : d ∈ f.support) :\n    d ≼[m] m.degree f := by\n  unfold degree\n  simp only [AddEquiv.apply_symm_apply, Finset.le_sup hd]\n\n"}
{"name":"MonomialOrder.coeff_eq_zero_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nd : Finsupp σ Nat\nhd : LT.lt (m.toSyn (m.degree f)) (m.toSyn d)\n⊢ Eq (MvPolynomial.coeff d f) 0","decl":"theorem coeff_eq_zero_of_lt {f : MvPolynomial σ R} {d : σ →₀ ℕ} (hd : m.degree f ≺[m] d) :\n    f.coeff d = 0 := by\n  rw [← not_le] at hd\n  by_contra hf\n  apply hd (m.le_degree (mem_support_iff.mpr hf))\n"}
{"name":"MonomialOrder.leadingCoeff_ne_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Ne (m.leadingCoeff f) 0) (Ne f 0)","decl":"theorem leadingCoeff_ne_zero_iff {f : MvPolynomial σ R} :\n    m.leadingCoeff f ≠ 0 ↔ f ≠ 0 := by\n  constructor\n  · rw [not_imp_not]\n    intro hf\n    rw [hf, leadingCoeff_zero]\n  · intro hf\n    rw [← support_nonempty] at hf\n    rw [leadingCoeff, ← mem_support_iff, degree]\n    suffices f.support.sup m.toSyn ∈ m.toSyn '' f.support by\n      obtain ⟨d, hd, hd'⟩ := this\n      rw [← hd', AddEquiv.symm_apply_apply]\n      exact hd\n    exact Finset.sup_mem_of_nonempty hf\n\n"}
{"name":"MonomialOrder.lCoeff_ne_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Ne (m.leadingCoeff f) 0) (Ne f 0)","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_ne_zero_iff := leadingCoeff_ne_zero_iff\n\n"}
{"name":"MonomialOrder.leadingCoeff_eq_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Eq (m.leadingCoeff f) 0) (Eq f 0)","decl":"@[simp]\ntheorem leadingCoeff_eq_zero_iff {f : MvPolynomial σ R} :\n    leadingCoeff m f = 0 ↔ f = 0 := by\n  simp only [← not_iff_not, leadingCoeff_ne_zero_iff]\n\n"}
{"name":"MonomialOrder.lCoeff_eq_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Eq (m.leadingCoeff f) 0) (Eq f 0)","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_eq_zero_iff := leadingCoeff_eq_zero_iff\n\n"}
{"name":"MonomialOrder.coeff_degree_ne_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Ne (MvPolynomial.coeff (m.degree f) f) 0) (Ne f 0)","decl":"theorem coeff_degree_ne_zero_iff {f : MvPolynomial σ R} :\n    f.coeff (m.degree f) ≠ 0 ↔ f ≠ 0 :=\n  m.leadingCoeff_ne_zero_iff\n\n"}
{"name":"MonomialOrder.coeff_degree_eq_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Eq (MvPolynomial.coeff (m.degree f) f) 0) (Eq f 0)","decl":"@[simp]\ntheorem coeff_degree_eq_zero_iff {f : MvPolynomial σ R} :\n    f.coeff (m.degree f) = 0 ↔ f = 0 :=\n  m.leadingCoeff_eq_zero_iff\n\n"}
{"name":"MonomialOrder.degree_eq_zero_iff_totalDegree_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\n⊢ Iff (Eq (m.degree f) 0) (Eq f.totalDegree 0)","decl":"theorem degree_eq_zero_iff_totalDegree_eq_zero {f : MvPolynomial σ R} :\n    m.degree f = 0 ↔ f.totalDegree = 0 := by\n  rw [← m.toSyn.injective.eq_iff]\n  rw [map_zero, ← m.bot_eq_zero, eq_bot_iff, m.bot_eq_zero, ← m.toSyn.map_zero]\n  rw [degree_le_iff]\n  rw [totalDegree_eq_zero_iff]\n  apply forall_congr'\n  intro d\n  apply imp_congr (rfl.to_iff)\n  rw [map_zero, ← m.bot_eq_zero, ← eq_bot_iff, m.bot_eq_zero]\n  simp only [EmbeddingLike.map_eq_zero_iff]\n  exact Finsupp.ext_iff\n\n"}
{"name":"MonomialOrder.degree_C","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (m.degree (MvPolynomial.C r)) 0","decl":"@[simp]\ntheorem degree_C (r : R) :\n    m.degree (C r) = 0 := by\n  rw [degree_eq_zero_iff_totalDegree_eq_zero, totalDegree_C]\n\n"}
{"name":"MonomialOrder.eq_C_of_degree_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\nhf : Eq (m.degree f) 0\n⊢ Eq f (MvPolynomial.C (m.leadingCoeff f))","decl":"theorem eq_C_of_degree_eq_zero {f : MvPolynomial σ R} (hf : m.degree f = 0) :\n    f = C (m.leadingCoeff f) := by\n  ext d\n  simp only [leadingCoeff, hf]\n  classical\n  by_cases hd : d = 0\n  · simp [hd]\n  · rw [coeff_C, if_neg (Ne.symm hd)]\n    apply coeff_eq_zero_of_lt (m := m)\n    rw [hf, map_zero, lt_iff_le_and_ne, ne_eq, eq_comm, EmbeddingLike.map_eq_zero_iff]\n    exact ⟨bot_le, hd⟩\n\n"}
{"name":"MonomialOrder.degree_add_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\n⊢ LE.le (m.toSyn (m.degree (HAdd.hAdd f g))) (Max.max (m.toSyn (m.degree f)) (m.toSyn (m.degree g)))","decl":"theorem degree_add_le {f g : MvPolynomial σ R} :\n    m.toSyn (m.degree (f + g)) ≤ m.toSyn (m.degree f) ⊔ m.toSyn (m.degree g) := by\n  conv_rhs => rw [← m.toSyn.apply_symm_apply (_ ⊔ _)]\n  rw [degree_le_iff]\n  simp only [AddEquiv.apply_symm_apply, le_sup_iff]\n  intro b hb\n  by_cases hf : b ∈ f.support\n  · left\n    exact m.le_degree hf\n  · right\n    apply m.le_degree\n    simp only [not_mem_support_iff] at hf\n    simpa only [mem_support_iff, coeff_add, hf, zero_add] using hb\n\n"}
{"name":"MonomialOrder.degree_add_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.degree (HAdd.hAdd f g)) (m.degree f)","decl":"theorem degree_add_of_lt {f g : MvPolynomial σ R} (h : m.degree g ≺[m] m.degree f) :\n    m.degree (f + g) = m.degree f := by\n  apply m.toSyn.injective\n  apply le_antisymm\n  · apply le_trans degree_add_le\n    simp only [sup_le_iff, le_refl, true_and, le_of_lt h]\n  · apply le_degree\n    rw [mem_support_iff, coeff_add, m.coeff_eq_zero_of_lt h, add_zero,\n      ← leadingCoeff, leadingCoeff_ne_zero_iff]\n    intro hf\n    rw [← not_le, hf] at h\n    apply h\n    simp only [degree_zero, map_zero]\n    apply bot_le\n\n"}
{"name":"MonomialOrder.leadingCoeff_add_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.leadingCoeff (HAdd.hAdd f g)) (m.leadingCoeff f)","decl":"theorem leadingCoeff_add_of_lt {f g : MvPolynomial σ R} (h : m.degree g ≺[m] m.degree f) :\n    m.leadingCoeff (f + g) = m.leadingCoeff f := by\n  simp only [leadingCoeff, m.degree_add_of_lt h, coeff_add, coeff_eq_zero_of_lt h, add_zero]\n\n"}
{"name":"MonomialOrder.lCoeff_add_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.leadingCoeff (HAdd.hAdd f g)) (m.leadingCoeff f)","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_add_of_lt := leadingCoeff_add_of_lt\n\n"}
{"name":"MonomialOrder.degree_add_of_ne","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nh : Ne (m.degree f) (m.degree g)\n⊢ Eq (m.toSyn (m.degree (HAdd.hAdd f g))) (Max.max (m.toSyn (m.degree f)) (m.toSyn (m.degree g)))","decl":"theorem degree_add_of_ne {f g : MvPolynomial σ R}\n    (h : m.degree f ≠ m.degree g) :\n    m.toSyn (m.degree (f + g)) = m.toSyn (m.degree f) ⊔ m.toSyn (m.degree g) := by\n  by_cases h' : m.degree g ≺[m] m.degree f\n  · simp [degree_add_of_lt h', left_eq_sup, le_of_lt h']\n  · rw [not_lt, le_iff_eq_or_lt, Classical.or_iff_not_imp_left, EmbeddingLike.apply_eq_iff_eq] at h'\n    rw [add_comm, degree_add_of_lt (h' h), right_eq_sup]\n    simp only [le_of_lt (h' h)]\n\n"}
{"name":"MonomialOrder.degree_mul_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\n⊢ LE.le (m.toSyn (m.degree (HMul.hMul f g))) (m.toSyn (HAdd.hAdd (m.degree f) (m.degree g)))","decl":"theorem degree_mul_le {f g : MvPolynomial σ R} :\n    m.degree (f * g) ≼[m] m.degree f + m.degree g := by\n  classical\n  rw [degree_le_iff]\n  intro c\n  rw [← not_lt, mem_support_iff, not_imp_not]\n  intro hc\n  rw [coeff_mul]\n  apply Finset.sum_eq_zero\n  rintro ⟨d, e⟩ hde\n  simp only [Finset.mem_antidiagonal] at hde\n  dsimp only\n  by_cases hd : m.degree f ≺[m] d\n  · rw [m.coeff_eq_zero_of_lt hd, zero_mul]\n  · suffices m.degree g ≺[m] e by\n      rw [m.coeff_eq_zero_of_lt this, mul_zero]\n    simp only [not_lt] at hd\n    apply lt_of_add_lt_add_left (a := m.toSyn d)\n    simp only [← map_add, hde]\n    apply lt_of_le_of_lt _ hc\n    simp only [map_add]\n    exact add_le_add_right hd _\n\n"}
{"name":"MonomialOrder.coeff_mul_of_add_of_degree_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\na b : Finsupp σ Nat\nha : LE.le (m.toSyn (m.degree f)) (m.toSyn a)\nhb : LE.le (m.toSyn (m.degree g)) (m.toSyn b)\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd a b) (HMul.hMul f g)) (HMul.hMul (MvPolynomial.coeff a f) (MvPolynomial.coeff b g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem coeff_mul_of_add_of_degree_le {f g : MvPolynomial σ R} {a b : σ →₀ ℕ}\n    (ha : m.degree f ≼[m] a) (hb : m.degree g ≼[m] b) :\n    (f * g).coeff (a + b) = f.coeff a * g.coeff b := by\n  classical\n  rw [coeff_mul, Finset.sum_eq_single (a,b)]\n  · rintro ⟨c, d⟩ hcd h\n    simp only [Finset.mem_antidiagonal] at hcd\n    by_cases hf : m.degree f ≺[m] c\n    · rw [m.coeff_eq_zero_of_lt hf, zero_mul]\n    · suffices m.degree g ≺[m] d by\n        rw [coeff_eq_zero_of_lt this, mul_zero]\n      rw [not_lt] at hf\n      rw [← not_le]\n      intro hf'\n      apply h\n      suffices c = a by\n        simpa [Prod.mk.injEq, this] using hcd\n      apply m.toSyn.injective\n      apply le_antisymm (le_trans hf ha)\n      apply le_of_add_le_add_right (a := m.toSyn b)\n      rw [← map_add, ← hcd, map_add]\n      simp only [add_le_add_iff_left]\n      exact le_trans hf' hb\n  · simp\n\n"}
{"name":"MonomialOrder.coeff_mul_of_degree_add","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\n⊢ Eq (MvPolynomial.coeff (HAdd.hAdd (m.degree f) (m.degree g)) (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem coeff_mul_of_degree_add {f g : MvPolynomial σ R} :\n    (f * g).coeff (m.degree f + m.degree g) = m.leadingCoeff f * m.leadingCoeff g :=\n  coeff_mul_of_add_of_degree_le (le_of_eq rfl) (le_of_eq rfl)\n\n"}
{"name":"MonomialOrder.degree_mul_of_isRegular_left","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : IsRegular (m.leadingCoeff f)\nhg : Ne g 0\n⊢ Eq (m.degree (HMul.hMul f g)) (HAdd.hAdd (m.degree f) (m.degree g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem degree_mul_of_isRegular_left {f g : MvPolynomial σ R}\n    (hf : IsRegular (m.leadingCoeff f)) (hg : g ≠ 0) :\n    m.degree (f * g) = m.degree f + m.degree g := by\n  apply m.toSyn.injective\n  apply le_antisymm degree_mul_le\n  apply le_degree\n  rw [mem_support_iff, coeff_mul_of_degree_add]\n  simp only [ne_eq, hf, IsRegular.left, IsLeftRegular.mul_left_eq_zero_iff,\n    leadingCoeff_eq_zero_iff]\n  exact hg\n\n"}
{"name":"MonomialOrder.leadingCoeff_mul_of_isRegular_left","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : IsRegular (m.leadingCoeff f)\nhg : Ne g 0\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem leadingCoeff_mul_of_isRegular_left {f g : MvPolynomial σ R}\n    (hf : IsRegular (m.leadingCoeff f)) (hg : g ≠ 0) :\n    m.leadingCoeff (f * g) = m.leadingCoeff f * m.leadingCoeff g := by\n  simp only [leadingCoeff, degree_mul_of_isRegular_left hf hg, coeff_mul_of_degree_add]\n\n"}
{"name":"MonomialOrder.lCoeff_mul_of_isRegular_left","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : IsRegular (m.leadingCoeff f)\nhg : Ne g 0\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"@[deprecated (since := \"2025-01-31\")]\nalias lCoeff_mul_of_isRegular_left := leadingCoeff_mul_of_isRegular_left\n\n"}
{"name":"MonomialOrder.degree_mul_of_isRegular_right","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : IsRegular (m.leadingCoeff g)\n⊢ Eq (m.degree (HMul.hMul f g)) (HAdd.hAdd (m.degree f) (m.degree g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem degree_mul_of_isRegular_right {f g : MvPolynomial σ R}\n    (hf : f ≠ 0) (hg : IsRegular (m.leadingCoeff g)) :\n    m.degree (f * g) = m.degree f + m.degree g := by\n  rw [mul_comm, m.degree_mul_of_isRegular_left hg hf, add_comm]\n\n"}
{"name":"MonomialOrder.leadingCoeff_mul_of_isRegular_right","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : IsRegular (m.leadingCoeff g)\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem leadingCoeff_mul_of_isRegular_right {f g : MvPolynomial σ R}\n    (hf : f ≠ 0) (hg : IsRegular (m.leadingCoeff g)) :\n    m.leadingCoeff (f * g) = m.leadingCoeff f * m.leadingCoeff g := by\n  simp only [leadingCoeff, degree_mul_of_isRegular_right hf hg, coeff_mul_of_degree_add]\n\n"}
{"name":"MonomialOrder.lCoeff_mul_of_isRegular_right","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : IsRegular (m.leadingCoeff g)\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"@[deprecated (since := \"2025-01-31\")]\nalias lCoeff_mul_of_isRegular_right := leadingCoeff_mul_of_isRegular_right\n\n"}
{"name":"MonomialOrder.degree_mul","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : Ne g 0\n⊢ Eq (m.degree (HMul.hMul f g)) (HAdd.hAdd (m.degree f) (m.degree g))","decl":"/-- Degree of product -/\ntheorem degree_mul [IsDomain R] {f g : MvPolynomial σ R} (hf : f ≠ 0) (hg : g ≠ 0) :\n    m.degree (f * g) = m.degree f + m.degree g :=\n  degree_mul_of_isRegular_left (isRegular_of_ne_zero (leadingCoeff_ne_zero_iff.mpr hf)) hg\n\n"}
{"name":"MonomialOrder.degree_mul_of_nonzero_mul","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nf g : MvPolynomial σ R\nhfg : Ne (HMul.hMul f g) 0\n⊢ Eq (m.degree (HMul.hMul f g)) (HAdd.hAdd (m.degree f) (m.degree g))","decl":"/-- Degree of of product -/\ntheorem degree_mul_of_nonzero_mul [IsDomain R] {f g : MvPolynomial σ R} (hfg : f * g ≠ 0) :\n    m.degree (f * g) = m.degree f + m.degree g :=\n  degree_mul (left_ne_zero_of_mul hfg) (right_ne_zero_of_mul hfg)\n\n"}
{"name":"MonomialOrder.leadingCoeff_mul","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : Ne g 0\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"/-- Multiplicativity of leading coefficients -/\ntheorem leadingCoeff_mul [IsDomain R] {f g : MvPolynomial σ R}\n    (hf : f ≠ 0) (hg : g ≠ 0) :\n    m.leadingCoeff (f * g) = m.leadingCoeff f * m.leadingCoeff g := by\n  rw [leadingCoeff, degree_mul hf hg, ← coeff_mul_of_degree_add]\n\n"}
{"name":"MonomialOrder.lCoeff_mul","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nf g : MvPolynomial σ R\nhf : Ne f 0\nhg : Ne g 0\n⊢ Eq (m.leadingCoeff (HMul.hMul f g)) (HMul.hMul (m.leadingCoeff f) (m.leadingCoeff g))","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_mul := leadingCoeff_mul\n\n"}
{"name":"MonomialOrder.degree_smul_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nr : R\nf : MvPolynomial σ R\n⊢ LE.le (m.toSyn (m.degree (HSMul.hSMul r f))) (m.toSyn (m.degree f))","decl":"theorem degree_smul_le {r : R} {f : MvPolynomial σ R} :\n    m.degree (r • f) ≼[m] m.degree f := by\n  rw [smul_eq_C_mul]\n  apply le_of_le_of_eq degree_mul_le\n  simp\n\n"}
{"name":"MonomialOrder.degree_smul","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nr : R\nhr : IsRegular r\nf : MvPolynomial σ R\n⊢ Eq (m.degree (HSMul.hSMul r f)) (m.degree f)","decl":"theorem degree_smul {r : R} (hr : IsRegular r) {f : MvPolynomial σ R} :\n    m.degree (r • f) = m.degree f := by\n  by_cases hf : f = 0\n  · simp [hf]\n  apply m.toSyn.injective\n  apply le_antisymm degree_smul_le\n  apply le_degree\n  simp only [mem_support_iff, smul_eq_C_mul]\n  rw [← zero_add (degree m f), ← degree_C r, coeff_mul_of_degree_add]\n  simp [leadingCoeff, hr.left.mul_left_eq_zero_iff, hf]\n\n"}
{"name":"MonomialOrder.degree_prod_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nι : Type u_3\nP : ι → MvPolynomial σ R\ns : Finset ι\n⊢ LE.le (m.toSyn (m.degree (s.prod fun i => P i))) (m.toSyn (s.sum fun i => m.degree (P i)))","decl":"theorem degree_prod_le {ι : Type*} {P : ι → MvPolynomial σ R} {s : Finset ι} :\n    m.degree (∏ i ∈ s, P i) ≼[m] ∑ i ∈ s, m.degree (P i) := by\n  classical\n  induction s using Finset.induction_on with\n  | empty =>\n    simp only [Finset.prod_empty, Finset.sum_empty]\n    rw [← C_1, m.degree_C, map_zero]\n  | @insert a s has hrec =>\n    rw [Finset.prod_insert has, Finset.sum_insert has]\n    apply le_trans degree_mul_le\n    simp only [map_add, add_le_add_iff_left, hrec]\n\n"}
{"name":"MonomialOrder.coeff_prod_sum_degree","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nι : Type u_3\nP : ι → MvPolynomial σ R\ns : Finset ι\n⊢ Eq (MvPolynomial.coeff (s.sum fun i => m.degree (P i)) (s.prod fun i => P i)) (s.prod fun i => m.leadingCoeff (P i))","decl":"theorem coeff_prod_sum_degree {ι : Type*} (P : ι → MvPolynomial σ R) (s : Finset ι) :\n    coeff (∑ i ∈ s, m.degree (P i)) (∏ i ∈ s, P i) = ∏ i ∈ s, m.leadingCoeff (P i) := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp\n  | @insert a s has hrec =>\n    simp only [Finset.prod_insert has, Finset.sum_insert has]\n    rw [coeff_mul_of_add_of_degree_le (le_of_eq rfl) degree_prod_le]\n    exact congr_arg₂ _ rfl hrec\n\n-- TODO : it suffices that all leading coefficients but one are regular\n"}
{"name":"MonomialOrder.degree_prod_of_regular","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nι : Type u_3\nP : ι → MvPolynomial σ R\ns : Finset ι\nH : ∀ (i : ι), Membership.mem s i → IsRegular (m.leadingCoeff (P i))\n⊢ Eq (m.degree (s.prod fun i => P i)) (s.sum fun i => m.degree (P i))","decl":"theorem degree_prod_of_regular {ι : Type*}\n    {P : ι → MvPolynomial σ R} {s : Finset ι} (H : ∀ i ∈ s, IsRegular (m.leadingCoeff (P i))) :\n    m.degree (∏ i ∈ s, P i) = ∑ i ∈ s, m.degree (P i) := by\n  cases subsingleton_or_nontrivial R with\n  | inl _ => simp [Subsingleton.elim _ (0 : MvPolynomial σ R)]\n  | inr _ =>\n    apply m.toSyn.injective\n    refine le_antisymm degree_prod_le (m.le_degree ?_)\n    rw [mem_support_iff, m.coeff_prod_sum_degree]\n    exact (IsRegular.prod H).ne_zero\n\n"}
{"name":"MonomialOrder.degree_prod","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nι : Type u_3\nP : ι → MvPolynomial σ R\ns : Finset ι\nH : ∀ (i : ι), Membership.mem s i → Ne (P i) 0\n⊢ Eq (m.degree (s.prod fun i => P i)) (s.sum fun i => m.degree (P i))","decl":"theorem degree_prod [IsDomain R] {ι : Type*} {P : ι → MvPolynomial σ R} {s : Finset ι}\n    (H : ∀ i ∈ s, P i ≠ 0) :\n    m.degree (∏ i ∈ s, P i) = ∑ i ∈ s, m.degree (P i) := by\n  apply degree_prod_of_regular\n  intro i hi\n  apply isRegular_of_ne_zero\n  rw [leadingCoeff_ne_zero_iff]\n  exact H i hi\n\n-- TODO : it suffices that all leading coefficients but one are regular\n"}
{"name":"MonomialOrder.leadingCoeff_prod_of_regular","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommSemiring R\nι : Type u_3\nP : ι → MvPolynomial σ R\ns : Finset ι\nH : ∀ (i : ι), Membership.mem s i → IsRegular (m.leadingCoeff (P i))\n⊢ Eq (m.leadingCoeff (s.prod fun i => P i)) (s.prod fun i => m.leadingCoeff (P i))","decl":"theorem leadingCoeff_prod_of_regular {ι : Type*}\n    {P : ι → MvPolynomial σ R} {s : Finset ι} (H : ∀ i ∈ s, IsRegular (m.leadingCoeff (P i))) :\n    m.leadingCoeff (∏ i ∈ s, P i) = ∏ i ∈ s, m.leadingCoeff (P i) := by\n  simp only [leadingCoeff, degree_prod_of_regular H, coeff_prod_sum_degree]\n\n"}
{"name":"MonomialOrder.degree_neg","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf : MvPolynomial σ R\n⊢ Eq (m.degree (Neg.neg f)) (m.degree f)","decl":"@[simp]\ntheorem degree_neg {f : MvPolynomial σ R} :\n    m.degree (-f) = m.degree f := by\n  unfold degree\n  rw [support_neg]\n\n"}
{"name":"MonomialOrder.degree_sub_le","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf g : MvPolynomial σ R\n⊢ LE.le (m.toSyn (m.degree (HSub.hSub f g))) (Max.max (m.toSyn (m.degree f)) (m.toSyn (m.degree g)))","decl":"theorem degree_sub_le {f g : MvPolynomial σ R} :\n    m.toSyn (m.degree (f - g)) ≤ m.toSyn (m.degree f) ⊔ m.toSyn (m.degree g) := by\n  rw [sub_eq_add_neg]\n  apply le_of_le_of_eq m.degree_add_le\n  rw [degree_neg]\n\n"}
{"name":"MonomialOrder.degree_sub_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.degree (HSub.hSub f g)) (m.degree f)","decl":"theorem degree_sub_of_lt {f g : MvPolynomial σ R} (h : m.degree g ≺[m] m.degree f) :\n    m.degree (f - g) = m.degree f := by\n  rw [sub_eq_add_neg]\n  apply degree_add_of_lt\n  simp only [degree_neg, h]\n\n"}
{"name":"MonomialOrder.leadingCoeff_sub_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.leadingCoeff (HSub.hSub f g)) (m.leadingCoeff f)","decl":"theorem leadingCoeff_sub_of_lt {f g : MvPolynomial σ R} (h : m.degree g ≺[m] m.degree f) :\n    m.leadingCoeff (f - g) = m.leadingCoeff f := by\n  rw [sub_eq_add_neg]\n  apply leadingCoeff_add_of_lt\n  simp only [degree_neg, h]\n\n"}
{"name":"MonomialOrder.lCoeff_sub_of_lt","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : CommRing R\nf g : MvPolynomial σ R\nh : LT.lt (m.toSyn (m.degree g)) (m.toSyn (m.degree f))\n⊢ Eq (m.leadingCoeff (HSub.hSub f g)) (m.leadingCoeff f)","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_sub_of_lt := leadingCoeff_sub_of_lt\n\n"}
{"name":"MonomialOrder.isUnit_leadingCoeff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : Field R\nf : MvPolynomial σ R\n⊢ Iff (IsUnit (m.leadingCoeff f)) (Ne f 0)","decl":"theorem isUnit_leadingCoeff {f : MvPolynomial σ R} :\n    IsUnit (m.leadingCoeff f) ↔ f ≠ 0 := by\n  simp only [isUnit_iff_ne_zero, ne_eq, leadingCoeff_eq_zero_iff]\n\n"}
{"name":"MonomialOrder.lCoeff_is_unit_iff","module":"Mathlib.RingTheory.MvPolynomial.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\nR : Type u_2\ninst✝ : Field R\nf : MvPolynomial σ R\n⊢ Iff (IsUnit (m.leadingCoeff f)) (Ne f 0)","decl":"@[deprecated (since := \"2025-01-31\")] alias lCoeff_is_unit_iff := isUnit_leadingCoeff\n\n"}
