{"name":"CategoryTheory.IsFiltered.iff_nonempty_limit","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsFiltered C) (∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Exists fun X => Nonempty (CategoryTheory.Limits.limit (F.op.comp (CategoryTheory.yoneda.obj X))))","decl":"/-- `C` is filtered if and only if for every functor `F : J ⥤ C` from a finite category there is\n    some `X : C` such that `lim Hom(F·, X)` is nonempty.\n\n    Lemma 3.1.2 of [Kashiwara2006] -/\ntheorem IsFiltered.iff_nonempty_limit : IsFiltered C ↔\n    ∀ {J : Type v} [SmallCategory J] [FinCategory J] (F : J ⥤ C),\n      ∃ (X : C), Nonempty (limit (F.op ⋙ yoneda.obj X)) := by\n  rw [IsFiltered.iff_cocone_nonempty.{v}]\n  refine ⟨fun h J _ _ F => ?_, fun h J _ _ F => ?_⟩\n  · obtain ⟨c⟩ := h F\n    exact ⟨c.pt, ⟨(limitCompYonedaIsoCocone F c.pt).inv c.ι⟩⟩\n  · obtain ⟨pt, ⟨ι⟩⟩ := h F\n    exact ⟨⟨pt, (limitCompYonedaIsoCocone F pt).hom ι⟩⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.iff_nonempty_limit","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsCofiltered C) (∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J C), Exists fun X => Nonempty (CategoryTheory.Limits.limit (F.comp (CategoryTheory.coyoneda.obj { unop := X }))))","decl":"/-- `C` is cofiltered if and only if for every functor `F : J ⥤ C` from a finite category there is\n    some `X : C` such that `lim Hom(X, F·)` is nonempty. -/\ntheorem IsCofiltered.iff_nonempty_limit : IsCofiltered C ↔\n    ∀ {J : Type v} [SmallCategory J] [FinCategory J] (F : J ⥤ C),\n      ∃ (X : C), Nonempty (limit (F ⋙ coyoneda.obj (op X))) := by\n  rw [IsCofiltered.iff_cone_nonempty.{v}]\n  refine ⟨fun h J _ _ F => ?_, fun h J _ _ F => ?_⟩\n  · obtain ⟨c⟩ := h F\n    exact ⟨c.pt, ⟨(limitCompCoyonedaIsoCone F c.pt).inv c.π⟩⟩\n  · obtain ⟨pt, ⟨π⟩⟩ := h F\n    exact ⟨⟨pt, (limitCompCoyonedaIsoCone F pt).hom π⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.HasCofilteredLimitsOfSize.HasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w', w, v, u} C\nI : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} I\ninst✝ : CategoryTheory.IsCofiltered I\n⊢ CategoryTheory.Limits.HasLimitsOfShape I C","decl":"/-- Class for having all cofiltered limits of a given size. -/\n@[pp_with_univ]\nclass HasCofilteredLimitsOfSize : Prop where\n  /-- For all filtered types of size `w`, we have limits -/\n  HasLimitsOfShape : ∀ (I : Type w) [Category.{w'} I] [IsCofiltered I], HasLimitsOfShape I C\n\n"}
{"name":"CategoryTheory.Limits.HasFilteredColimitsOfSize.HasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w', w, v, u} C\nI : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} I\ninst✝ : CategoryTheory.IsFiltered I\n⊢ CategoryTheory.Limits.HasColimitsOfShape I C","decl":"/-- Class for having all filtered colimits of a given size. -/\n@[pp_with_univ]\nclass HasFilteredColimitsOfSize : Prop where\n  /-- For all filtered types of a size `w`, we have colimits -/\n  HasColimitsOfShape : ∀ (I : Type w) [Category.{w'} I] [IsFiltered I], HasColimitsOfShape I C\n\n"}
{"name":"CategoryTheory.Limits.hasFilteredColimitsOfSize_of_hasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w', w, v, u} C\n⊢ CategoryTheory.Limits.HasFilteredColimitsOfSize.{w', w, v, u} C","decl":"instance (priority := 100) hasFilteredColimitsOfSize_of_hasColimitsOfSize\n    [HasColimitsOfSize.{w', w} C] : HasFilteredColimitsOfSize.{w', w} C where\n  HasColimitsOfShape _ _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCofilteredLimitsOfSize_of_hasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w', w, v, u} C\n⊢ CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w', w, v, u} C","decl":"instance (priority := 100) hasCofilteredLimitsOfSize_of_hasLimitsOfSize\n    [HasLimitsOfSize.{w', w} C] : HasCofilteredLimitsOfSize.{w', w} C where\n  HasLimitsOfShape _ _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_has_cofiltered_limits","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w', w, v, u} C\nI : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} I\ninst✝ : CategoryTheory.IsCofiltered I\n⊢ CategoryTheory.Limits.HasLimitsOfShape I C","decl":"instance (priority := 100) hasLimitsOfShape_of_has_cofiltered_limits\n    [HasCofilteredLimitsOfSize.{w', w} C] (I : Type w) [Category.{w'} I] [IsCofiltered I] :\n    HasLimitsOfShape I C :=\n  HasCofilteredLimitsOfSize.HasLimitsOfShape _\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_has_filtered_colimits","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w', w, v, u} C\nI : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} I\ninst✝ : CategoryTheory.IsFiltered I\n⊢ CategoryTheory.Limits.HasColimitsOfShape I C","decl":"instance (priority := 100) hasColimitsOfShape_of_has_filtered_colimits\n    [HasFilteredColimitsOfSize.{w', w} C] (I : Type w) [Category.{w'} I] [IsFiltered I] :\n    HasColimitsOfShape I C :=\n  HasFilteredColimitsOfSize.HasColimitsOfShape _\n\n"}
{"name":"CategoryTheory.Limits.hasCofilteredLimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : UnivLE.{w, w₂}\ninst✝¹ : UnivLE.{w', w₂'}\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w₂', w₂, v, u} C\n⊢ CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w', w, v, u} C","decl":"lemma hasCofilteredLimitsOfSize_of_univLE [UnivLE.{w, w₂}] [UnivLE.{w', w₂'}]\n    [HasCofilteredLimitsOfSize.{w₂', w₂} C] :\n    HasCofilteredLimitsOfSize.{w', w} C where\n  HasLimitsOfShape J :=\n    haveI := IsCofiltered.of_equivalence ((ShrinkHoms.equivalence.{w₂'} J).trans <|\n      Shrink.equivalence.{w₂} (ShrinkHoms.{w} J))\n    hasLimitsOfShape_of_equivalence ((ShrinkHoms.equivalence.{w₂'} J).trans <|\n      Shrink.equivalence.{w₂} (ShrinkHoms.{w} J)).symm\n\n"}
{"name":"CategoryTheory.Limits.hasCofilteredLimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{max w' w₂', max w w₂, v, u} C\n⊢ CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w', w, v, u} C","decl":"lemma hasCofilteredLimitsOfSize_shrink [HasCofilteredLimitsOfSize.{max w' w₂', max w w₂} C] :\n    HasCofilteredLimitsOfSize.{w', w} C :=\n  hasCofilteredLimitsOfSize_of_univLE.{w', w, max w' w₂', max w w₂}\n\n"}
{"name":"CategoryTheory.Limits.hasFilteredColimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : UnivLE.{w, w₂}\ninst✝¹ : UnivLE.{w', w₂'}\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w₂', w₂, v, u} C\n⊢ CategoryTheory.Limits.HasFilteredColimitsOfSize.{w', w, v, u} C","decl":"lemma hasFilteredColimitsOfSize_of_univLE [UnivLE.{w, w₂}] [UnivLE.{w', w₂'}]\n    [HasFilteredColimitsOfSize.{w₂', w₂} C] :\n    HasFilteredColimitsOfSize.{w', w} C where\n  HasColimitsOfShape J :=\n    haveI := IsFiltered.of_equivalence ((ShrinkHoms.equivalence.{w₂'} J).trans <|\n      Shrink.equivalence.{w₂} (ShrinkHoms.{w} J))\n    hasColimitsOfShape_of_equivalence ((ShrinkHoms.equivalence.{w₂'} J).trans <|\n      Shrink.equivalence.{w₂} (ShrinkHoms.{w} J)).symm\n\n"}
{"name":"CategoryTheory.Limits.hasFilteredColimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{max w' w₂', max w w₂, v, u} C\n⊢ CategoryTheory.Limits.HasFilteredColimitsOfSize.{w', w, v, u} C","decl":"lemma hasFilteredColimitsOfSize_shrink [HasFilteredColimitsOfSize.{max w' w₂', max w w₂} C] :\n    HasFilteredColimitsOfSize.{w', w} C :=\n  hasFilteredColimitsOfSize_of_univLE.{w', w, max w' w₂', max w w₂}\n\n"}
