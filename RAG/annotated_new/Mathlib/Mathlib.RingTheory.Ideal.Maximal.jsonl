{"name":"Ideal.IsMaximal.out","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nself : I.IsMaximal\n⊢ IsCoatom I","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals. -/\nclass IsMaximal (I : Ideal α) : Prop where\n  /-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\n  and there are no other proper ideals strictly containing it. -/\n  out : IsCoatom I\n\n"}
{"name":"Ideal.isMaximal_def","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\n⊢ Iff I.IsMaximal (IsCoatom I)","decl":"theorem isMaximal_def {I : Ideal α} : I.IsMaximal ↔ IsCoatom I :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Ideal.IsMaximal.ne_top","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nh : I.IsMaximal\n⊢ Ne I Top.top","decl":"theorem IsMaximal.ne_top {I : Ideal α} (h : I.IsMaximal) : I ≠ ⊤ :=\n  (isMaximal_def.1 h).1\n\n"}
{"name":"Ideal.isMaximal_iff","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\n⊢ Iff I.IsMaximal (And (Not (Membership.mem I 1)) (∀ (J : Ideal α) (x : α), LE.le I J → Not (Membership.mem I x) → Membership.mem J x → Membership.mem J 1))","decl":"theorem isMaximal_iff {I : Ideal α} :\n    I.IsMaximal ↔ (1 : α) ∉ I ∧ ∀ (J : Ideal α) (x), I ≤ J → x ∉ I → x ∈ J → (1 : α) ∈ J := by\n  simp_rw [isMaximal_def, SetLike.isCoatom_iff, Ideal.ne_top_iff_one, ← Ideal.eq_top_iff_one]\n\n"}
{"name":"Ideal.IsMaximal.eq_of_le","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI J : Ideal α\nhI : I.IsMaximal\nhJ : Ne J Top.top\nIJ : LE.le I J\n⊢ Eq I J","decl":"theorem IsMaximal.eq_of_le {I J : Ideal α} (hI : I.IsMaximal) (hJ : J ≠ ⊤) (IJ : I ≤ J) : I = J :=\n  eq_iff_le_not_lt.2 ⟨IJ, fun h => hJ (hI.1.2 _ h)⟩\n\n"}
{"name":"Ideal.instIsCoatomic","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ IsCoatomic (Ideal α)","decl":"instance : IsCoatomic (Ideal α) := by\n  apply CompleteLattice.coatomic_of_top_compact\n  rw [← span_singleton_one]\n  exact Submodule.singleton_span_isCompactElement 1\n\n"}
{"name":"Ideal.IsMaximal.coprime_of_ne","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nM M' : Ideal α\nhM : M.IsMaximal\nhM' : M'.IsMaximal\nhne : Ne M M'\n⊢ Eq (Max.max M M') Top.top","decl":"theorem IsMaximal.coprime_of_ne {M M' : Ideal α} (hM : M.IsMaximal) (hM' : M'.IsMaximal)\n    (hne : M ≠ M') : M ⊔ M' = ⊤ := by\n  contrapose! hne with h\n  exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)\n\n"}
{"name":"Ideal.exists_le_maximal","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nhI : Ne I Top.top\n⊢ Exists fun M => And M.IsMaximal (LE.le I M)","decl":"/-- **Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some\n    maximal ideal. -/\ntheorem exists_le_maximal (I : Ideal α) (hI : I ≠ ⊤) : ∃ M : Ideal α, M.IsMaximal ∧ I ≤ M :=\n  let ⟨m, hm⟩ := (eq_top_or_exists_le_coatom I).resolve_left hI\n  ⟨m, ⟨⟨hm.1⟩, hm.2⟩⟩\n\n"}
{"name":"Ideal.exists_maximal","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝¹ : Semiring α\ninst✝ : Nontrivial α\n⊢ Exists fun M => M.IsMaximal","decl":"/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem exists_maximal [Nontrivial α] : ∃ M : Ideal α, M.IsMaximal :=\n  let ⟨I, ⟨hI, _⟩⟩ := exists_le_maximal (⊥ : Ideal α) bot_ne_top\n  ⟨I, hI⟩\n\n"}
{"name":"Ideal.instNontrivial","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝¹ : Semiring α\ninst✝ : Nontrivial α\n⊢ Nontrivial (Ideal α)","decl":"instance [Nontrivial α] : Nontrivial (Ideal α) := by\n  rcases@exists_maximal α _ _ with ⟨M, hM, _⟩\n  exact nontrivial_of_ne M ⊤ hM\n\n"}
{"name":"Ideal.maximal_of_no_maximal","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nP : Ideal α\nhmax : ∀ (m : Ideal α), LT.lt P m → Not m.IsMaximal\nJ : Ideal α\nhPJ : LT.lt P J\n⊢ Eq J Top.top","decl":"/-- If P is not properly contained in any maximal ideal then it is not properly contained\n  in any proper ideal -/\ntheorem maximal_of_no_maximal {P : Ideal α}\n    (hmax : ∀ m : Ideal α, P < m → ¬IsMaximal m) (J : Ideal α) (hPJ : P < J) : J = ⊤ := by\n  by_contra hnonmax\n  rcases exists_le_maximal J hnonmax with ⟨M, hM1, hM2⟩\n  exact hmax M (lt_of_lt_of_le hPJ hM2) hM1\n\n"}
{"name":"Ideal.IsMaximal.exists_inv","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nhI : I.IsMaximal\nx : α\nhx : Not (Membership.mem I x)\n⊢ Exists fun y => Exists fun i => And (Membership.mem I i) (Eq (HAdd.hAdd (HMul.hMul y x) i) 1)","decl":"theorem IsMaximal.exists_inv {I : Ideal α} (hI : I.IsMaximal) {x} (hx : x ∉ I) :\n    ∃ y, ∃ i ∈ I, y * x + i = 1 := by\n  cases' isMaximal_iff.1 hI with H₁ H₂\n  rcases mem_span_insert.1\n      (H₂ (span (insert x I)) x (Set.Subset.trans (subset_insert _ _) subset_span) hx\n        (subset_span (mem_insert _ _))) with\n    ⟨y, z, hz, hy⟩\n  refine ⟨y, z, ?_, hy.symm⟩\n  rwa [← span_eq I]\n\n"}
{"name":"Ideal.sInf_isPrime_of_isChain","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set (Ideal α)\nhs : s.Nonempty\nhs' : IsChain (fun x1 x2 => LE.le x1 x2) s\nH : ∀ (p : Ideal α), Membership.mem s p → p.IsPrime\n⊢ (InfSet.sInf s).IsPrime","decl":"theorem sInf_isPrime_of_isChain {s : Set (Ideal α)} (hs : s.Nonempty) (hs' : IsChain (· ≤ ·) s)\n    (H : ∀ p ∈ s, Ideal.IsPrime p) : (sInf s).IsPrime :=\n  ⟨fun e =>\n    let ⟨x, hx⟩ := hs\n    (H x hx).ne_top (eq_top_iff.mpr (e.symm.trans_le (sInf_le hx))),\n    fun e =>\n    or_iff_not_imp_left.mpr fun hx => by\n      rw [Ideal.mem_sInf] at hx e ⊢\n      push_neg at hx\n      obtain ⟨I, hI, hI'⟩ := hx\n      intro J hJ\n      cases' hs'.total hI hJ with h h\n      · exact h (((H I hI).mem_or_mem (e hI)).resolve_left hI')\n      · exact ((H J hJ).mem_or_mem (e hJ)).resolve_left fun x => hI' <| h x⟩\n\n"}
{"name":"Ideal.span_singleton_prime","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\np : α\nhp : Ne p 0\n⊢ Iff (Ideal.span (Singleton.singleton p)).IsPrime (Prime p)","decl":"theorem span_singleton_prime {p : α} (hp : p ≠ 0) : IsPrime (span ({p} : Set α)) ↔ Prime p := by\n  simp [isPrime_iff, Prime, span_singleton_eq_top, hp, mem_span_singleton]\n\n"}
{"name":"Ideal.IsMaximal.isPrime","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\nH : I.IsMaximal\n⊢ I.IsPrime","decl":"theorem IsMaximal.isPrime {I : Ideal α} (H : I.IsMaximal) : I.IsPrime :=\n  ⟨H.1.1, @fun x y hxy =>\n    or_iff_not_imp_left.2 fun hx => by\n      let J : Ideal α := Submodule.span α (insert x ↑I)\n      have IJ : I ≤ J := Set.Subset.trans (subset_insert _ _) subset_span\n      have xJ : x ∈ J := Ideal.subset_span (Set.mem_insert x I)\n      cases' isMaximal_iff.1 H with _ oJ\n      specialize oJ J x IJ hx xJ\n      rcases Submodule.mem_span_insert.mp oJ with ⟨a, b, h, oe⟩\n      obtain F : y * 1 = y * (a • x + b) := congr_arg (fun g : α => y * g) oe\n      rw [← mul_one y, F, mul_add, mul_comm, smul_eq_mul, mul_assoc]\n      refine Submodule.add_mem I (I.mul_mem_left a hxy) (Submodule.smul_mem I y ?_)\n      rwa [Submodule.span_eq] at h⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"Ideal.IsMaximal.isPrime'","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\n_H : I.IsMaximal\n⊢ I.IsPrime","decl":"instance (priority := 100) IsMaximal.isPrime' (I : Ideal α) : ∀ [_H : I.IsMaximal], I.IsPrime :=\n  @IsMaximal.isPrime _ _ _\n\n"}
{"name":"Ideal.exists_disjoint_powers_of_span_eq_top","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\ns : Set α\nhs : Eq (Ideal.span s) Top.top\nI : Ideal α\nhI : Ne I Top.top\n⊢ Exists fun r => And (Membership.mem s r) (Disjoint ↑I ↑(Submonoid.powers r))","decl":"theorem exists_disjoint_powers_of_span_eq_top (s : Set α) (hs : span s = ⊤) (I : Ideal α)\n    (hI : I ≠ ⊤) : ∃ r ∈ s, Disjoint (I : Set α) (Submonoid.powers r) := by\n  have ⟨M, hM, le⟩ := exists_le_maximal I hI\n  have := hM.1.1\n  rw [Ne, eq_top_iff, ← hs, span_le, Set.not_subset] at this\n  have ⟨a, has, haM⟩ := this\n  exact ⟨a, has, Set.disjoint_left.mpr fun x hx ⟨n, hn⟩ ↦\n    haM (hM.isPrime.mem_of_pow_mem _ (le <| hn ▸ hx))⟩\n\n"}
{"name":"Ideal.span_singleton_lt_span_singleton","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝¹ : CommSemiring α\ninst✝ : IsDomain α\nx y : α\n⊢ Iff (LT.lt (Ideal.span (Singleton.singleton x)) (Ideal.span (Singleton.singleton y))) (DvdNotUnit y x)","decl":"theorem span_singleton_lt_span_singleton [IsDomain α] {x y : α} :\n    span ({x} : Set α) < span ({y} : Set α) ↔ DvdNotUnit y x := by\n  rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton,\n    dvd_and_not_dvd_iff]\n\n"}
{"name":"Ideal.isPrime_of_maximally_disjoint","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\nS : Submonoid α\ndisjoint : Disjoint ↑I ↑S\nmaximally_disjoint : ∀ (J : Ideal α), LT.lt I J → Not (Disjoint ↑J ↑S)\n⊢ I.IsPrime","decl":"lemma isPrime_of_maximally_disjoint (I : Ideal α)\n    (S : Submonoid α)\n    (disjoint : Disjoint (I : Set α) S)\n    (maximally_disjoint : ∀ (J : Ideal α), I < J → ¬ Disjoint (J : Set α) S) :\n    I.IsPrime where\n  ne_top' := by\n    rintro rfl\n    have : 1 ∈ (S : Set α) := S.one_mem\n    aesop\n  mem_or_mem' {x y} hxy := by\n    by_contra! rid\n    have hx := maximally_disjoint (I ⊔ span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)\n    have hy := maximally_disjoint (I ⊔ span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)\n    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,\n      mem_span_singleton] at hx hy\n    obtain ⟨s₁, ⟨i₁, hi₁, ⟨_, ⟨r₁, rfl⟩, hr₁⟩⟩, hs₁⟩ := hx\n    obtain ⟨s₂, ⟨i₂, hi₂, ⟨_, ⟨r₂, rfl⟩, hr₂⟩⟩, hs₂⟩ := hy\n    refine disjoint.ne_of_mem\n      (I.add_mem (I.mul_mem_left (i₁ + x * r₁) hi₂) <| I.add_mem (I.mul_mem_right (y * r₂) hi₁) <|\n        I.mul_mem_right (r₁ * r₂) hxy)\n      (S.mul_mem hs₁ hs₂) ?_\n    rw [← hr₁, ← hr₂]\n    ring\n\n"}
{"name":"Ideal.exists_le_prime_disjoint","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\nS : Submonoid α\ndisjoint : Disjoint ↑I ↑S\n⊢ Exists fun p => And p.IsPrime (And (LE.le I p) (Disjoint ↑p ↑S))","decl":"theorem exists_le_prime_disjoint (S : Submonoid α) (disjoint : Disjoint (I : Set α) S) :\n    ∃ p : Ideal α, p.IsPrime ∧ I ≤ p ∧ Disjoint (p : Set α) S := by\n  have ⟨p, hIp, hp⟩ := zorn_le_nonempty₀ {p : Ideal α | Disjoint (p : Set α) S}\n    (fun c hc hc' x hx ↦ ?_) I disjoint\n  · exact ⟨p, isPrime_of_maximally_disjoint _ _ hp.1 (fun _ ↦ hp.not_prop_of_gt), hIp, hp.1⟩\n  cases isEmpty_or_nonempty c\n  · exact ⟨I, disjoint, fun J hJ ↦ isEmptyElim (⟨J, hJ⟩ : c)⟩\n  refine ⟨sSup c, Set.disjoint_left.mpr fun x hx ↦ ?_, fun _ ↦ le_sSup⟩\n  have ⟨p, hp⟩ := (Submodule.mem_iSup_of_directed _ hc'.directed).mp (sSup_eq_iSup' c ▸ hx)\n  exact Set.disjoint_left.mp (hc p.2) hp\n\n"}
{"name":"Ideal.exists_le_prime_nmem_of_isIdempotentElem","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\na : α\nha : IsIdempotentElem a\nhaI : Not (Membership.mem I a)\n⊢ Exists fun p => And p.IsPrime (And (LE.le I p) (Not (Membership.mem p a)))","decl":"theorem exists_le_prime_nmem_of_isIdempotentElem (a : α) (ha : IsIdempotentElem a) (haI : a ∉ I) :\n    ∃ p : Ideal α, p.IsPrime ∧ I ≤ p ∧ a ∉ p :=\n  have : Disjoint (I : Set α) (Submonoid.powers a) := Set.disjoint_right.mpr <| by\n    rw [ha.coe_powers]\n    rintro _ (rfl|rfl)\n    exacts [I.ne_top_iff_one.mp (ne_of_mem_of_not_mem' Submodule.mem_top haI).symm, haI]\n  have ⟨p, h1, h2, h3⟩ := exists_le_prime_disjoint _ _ this\n  ⟨p, h1, h2, Set.disjoint_right.mp h3 (Submonoid.mem_powers a)⟩\n\n"}
{"name":"Ideal.bot_isMaximal","module":"Mathlib.RingTheory.Ideal.Maximal","initialProofState":"K : Type u\ninst✝ : DivisionSemiring K\n⊢ Bot.bot.IsMaximal","decl":"theorem bot_isMaximal : IsMaximal (⊥ : Ideal K) :=\n  ⟨⟨fun h => absurd ((eq_top_iff_one (⊤ : Ideal K)).mp rfl) (by rw [← h]; simp), fun I hI =>\n      or_iff_not_imp_left.mp (eq_bot_or_top I) (ne_of_gt hI)⟩⟩\n\n"}
