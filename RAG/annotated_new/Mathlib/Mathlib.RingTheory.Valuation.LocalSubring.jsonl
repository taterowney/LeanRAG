{"name":"ValuationSubring.toLocalSubring_injective","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\n⊢ Function.Injective ValuationSubring.toLocalSubring","decl":"lemma ValuationSubring.toLocalSubring_injective :\n    Function.Injective (ValuationSubring.toLocalSubring (K := K)) :=\n  fun _ _ h ↦ ValuationSubring.toSubring_injective congr(($h).toSubring)\n\n"}
{"name":"LocalSubring.map_maximalIdeal_eq_top_of_isMax","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nR : LocalSubring K\nhR : IsMax R\nS : Subring K\nhS : LT.lt R.toSubring S\n⊢ Eq (Ideal.map (Subring.inclusion ⋯) (IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem R.toSubring x))) Top.top","decl":"lemma LocalSubring.map_maximalIdeal_eq_top_of_isMax {R : LocalSubring K}\n    (hR : IsMax R) {S : Subring K} (hS : R.toSubring < S) :\n    (maximalIdeal R.toSubring).map (Subring.inclusion hS.le) = ⊤ := by\n  let mR := (maximalIdeal R.toSubring).map (Subring.inclusion hS.le)\n  by_contra h_is_not_top\n  obtain ⟨M, h_is_max, h_incl⟩ := Ideal.exists_le_maximal _ h_is_not_top\n  let fSₘ : LocalSubring K := LocalSubring.ofPrime S M\n  have h_RleSₘ : R ≤ fSₘ := by\n    refine ⟨hS.le.trans (LocalSubring.le_ofPrime _ _), ⟨?_⟩⟩\n    rintro ⟨a, h_a_inR⟩ h_fa_isUnit\n    apply (IsLocalization.AtPrime.isUnit_to_map_iff _ M ⟨a, hS.le h_a_inR⟩).mp at h_fa_isUnit\n    by_contra h\n    rw [← mem_nonunits_iff, ← mem_maximalIdeal] at h\n    apply Ideal.mem_map_of_mem (Subring.inclusion hS.le) at h\n    exact h_fa_isUnit (h_incl h)\n  have h_RneSₘ : R ≠ fSₘ :=\n    fun e ↦ (hS.trans_le (LocalSubring.le_ofPrime S M)).ne congr(($e).toSubring)\n  exact h_RneSₘ (hR.eq_of_le h_RleSₘ)\n\n"}
{"name":"LocalSubring.mem_of_isMax_of_isIntegral","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nR : LocalSubring K\nhR : IsMax R\nx : K\nhx : IsIntegral (Subtype fun x => Membership.mem R.toSubring x) x\n⊢ Membership.mem R.toSubring x","decl":"@[stacks 00IC]\nlemma LocalSubring.mem_of_isMax_of_isIntegral {R : LocalSubring K}\n    (hR : IsMax R) {x : K} (hx : IsIntegral R.toSubring x) : x ∈ R.toSubring := by\n  let S := Algebra.adjoin R.toSubring {x}\n  have : Algebra.IsIntegral R.toSubring S := Algebra.IsIntegral.adjoin (by simpa)\n  obtain ⟨Q : Ideal S.toSubring, hQ, e⟩ := Ideal.exists_ideal_over_maximal_of_isIntegral\n    (R := R.toSubring) (S := S) (maximalIdeal _) (le_maximalIdeal (by simp [Ideal.eq_top_iff_one]))\n  have : R = .ofPrime S.toSubring Q := by\n    have hRS : R.toSubring ≤ S.toSubring := fun r hr ↦ algebraMap_mem S ⟨r, hr⟩\n    apply hR.eq_of_le ⟨hRS.trans (LocalSubring.le_ofPrime _ _), ⟨?_⟩⟩\n    intro r hr\n    have := (IsLocalization.AtPrime.isUnit_to_map_iff (R := S.toSubring) _ Q ⟨_, hRS r.2⟩).mp hr\n    by_contra h\n    rw [← mem_nonunits_iff, ← mem_maximalIdeal, ← e] at h\n    exact this h\n  rw [this]\n  exact LocalSubring.le_ofPrime _ _ (Algebra.self_mem_adjoin_singleton _ _)\n\n"}
{"name":"ValuationSubring.isMax_toLocalSubring","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nR : ValuationSubring K\n⊢ IsMax R.toLocalSubring","decl":"@[stacks 052K]\nlemma ValuationSubring.isMax_toLocalSubring (R : ValuationSubring K) :\n    IsMax R.toLocalSubring := by\n  intro S hS\n  suffices R.toLocalSubring = S from this.ge\n  refine LocalSubring.toSubring_injective (le_antisymm hS.1 ?_)\n  intro x hx\n  refine (R.2 x).elim id fun h ↦ ?_\n  by_contra h'\n  have hx0 : x ≠ 0 := by rintro rfl; exact h' (zero_mem R)\n  have : IsUnit (Subring.inclusion hS.1 ⟨x⁻¹, h⟩) :=\n    isUnit_iff_exists_inv.mpr ⟨⟨x, hx⟩, Subtype.ext (inv_mul_cancel₀ hx0)⟩\n  obtain ⟨x', hx'⟩ := isUnit_iff_exists_inv.mp (hS.2.1 _ this)\n  have : x'.1 = x := by simpa [Subtype.ext_iff, inv_mul_eq_iff_eq_mul₀ hx0] using hx'\n  exact h' (this ▸ x'.2)\n\n"}
{"name":"LocalSubring.exists_valuationRing_of_isMax","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nR : LocalSubring K\nhR : IsMax R\n⊢ Exists fun R' => Eq R'.toLocalSubring R","decl":"@[stacks 00IB]\nlemma LocalSubring.exists_valuationRing_of_isMax {R : LocalSubring K} (hR : IsMax R) :\n    ∃ R' : ValuationSubring K, R'.toLocalSubring = R := by\n  suffices ∀ x ∉ R.toSubring, x⁻¹ ∈ R.toSubring from\n    ⟨⟨R.toSubring, fun x ↦ or_iff_not_imp_left.mpr (this x)⟩, rfl⟩\n  intros x hx\n  have hx0 : x ≠ 0 := fun e ↦ hx (e ▸ zero_mem _)\n  apply mem_of_isMax_of_isIntegral hR\n  let S := Algebra.adjoin R.toSubring {x}\n  have : R.toSubring < S.toSubring := SetLike.lt_iff_le_and_exists.mpr\n    ⟨fun r hr ↦ algebraMap_mem S ⟨r, hr⟩, ⟨x, Algebra.self_mem_adjoin_singleton _ _, hx⟩⟩\n  have := map_maximalIdeal_eq_top_of_isMax hR this\n  rw [Ideal.eq_top_iff_one] at this\n  obtain ⟨p, hp, hp'⟩ := (Algebra.mem_ideal_map_adjoin _ _).mp this\n  have := IsUnit.invertible (isUnit_iff_ne_zero.mpr hx0)\n  have : Polynomial.aeval (⅟x) (p - 1).reverse = 0 := by\n    simpa [← Polynomial.aeval_def, hp'] using\n      Polynomial.eval₂_reverse_eq_zero_iff (algebraMap R.toSubring K) x (p - 1)\n  rw [invOf_eq_right_inv (mul_inv_cancel₀ hx0)] at this\n  have H : IsUnit ((p - 1).coeff 0) := by\n    by_contra h\n    simpa using sub_mem (hp 0) h\n  refine ⟨.C (H.unit⁻¹).1 * (p - 1).reverse, ?_, ?_⟩\n  · have : (p - 1).natTrailingDegree = 0 := by\n      simp only [Polynomial.natTrailingDegree_eq_zero,\n        Polynomial.coeff_sub, Polynomial.coeff_one_zero, ne_eq, sub_eq_zero]\n      exact .inr fun h ↦ (IsLocalRing.not_mem_maximalIdeal.mpr isUnit_one (h ▸ hp 0))\n    rw [Polynomial.Monic.def, Polynomial.leadingCoeff_mul', Polynomial.reverse_leadingCoeff,\n      Polynomial.trailingCoeff, this]\n    · simp\n    · have : p - 1 ≠ 0 := fun e ↦ by simp [e] at H\n      simpa\n  · simp [← Polynomial.aeval_def, this]\n\n"}
{"name":"LocalSubring.isMax_iff","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nA : LocalSubring K\n⊢ Iff (IsMax A) (Exists fun B => Eq B.toLocalSubring A)","decl":"/-- A local subring is maximal with respect to the domination order\n  if and only if it is a valuation ring. -/\nlemma LocalSubring.isMax_iff {A : LocalSubring K} :\n    IsMax A ↔ ∃ B : ValuationSubring K, B.toLocalSubring = A :=\n  ⟨exists_valuationRing_of_isMax, fun ⟨B, e⟩ ↦ e ▸ B.isMax_toLocalSubring⟩\n\n"}
{"name":"LocalSubring.exists_le_valuationSubring","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"K : Type u_3\ninst✝ : Field K\nA : LocalSubring K\n⊢ Exists fun B => LE.le A B.toLocalSubring","decl":"@[stacks 00IA]\nlemma LocalSubring.exists_le_valuationSubring (A : LocalSubring K) :\n    ∃ B : ValuationSubring K, A ≤ B.toLocalSubring := by\n  suffices ∃ B, A ≤ B ∧ IsMax B by\n    obtain ⟨B, hB, hB'⟩ := this\n    obtain ⟨B, rfl⟩ := B.exists_valuationRing_of_isMax hB'\n    exact ⟨B, hB⟩\n  refine zorn_le_nonempty_Ici₀ _ ?_ _ le_rfl\n  intro s hs H y hys\n  have inst : Nonempty s := ⟨⟨y, hys⟩⟩\n  have hdir := H.directed.mono_comp _ LocalSubring.toSubring_mono\n  refine ⟨@LocalSubring.mk _ _ (⨆ i : s, i.1.toSubring) ⟨?_⟩, ?_⟩\n  · intro ⟨a, ha⟩ ⟨b, hb⟩ e\n    obtain ⟨A, haA : a ∈ A.1.toSubring⟩ := (Subring.mem_iSup_of_directed hdir).mp ha\n    obtain ⟨B, hbB : b ∈ B.1.toSubring⟩ := (Subring.mem_iSup_of_directed hdir).mp hb\n    obtain ⟨C, hCA, hCB⟩ := hdir A B\n    refine (C.1.2.2 (a := ⟨a, hCA haA⟩) (b := ⟨b, hCB hbB⟩) (Subtype.ext congr(($e).1))).imp ?_ ?_\n    · exact fun h ↦ h.map (Subring.inclusion (le_iSup (fun i : s ↦ i.1.toSubring) C))\n    · exact fun h ↦ h.map (Subring.inclusion (le_iSup (fun i : s ↦ i.1.toSubring) C))\n  · intro A hA\n    refine ⟨le_iSup (fun i : s ↦ i.1.toSubring) ⟨A, hA⟩, ⟨?_⟩⟩\n    rintro ⟨a, haA⟩ h\n    obtain ⟨⟨b, hb⟩, e⟩ := isUnit_iff_exists_inv.mp h\n    obtain ⟨B, hbB : b ∈ B.1.toSubring⟩ := (Subring.mem_iSup_of_directed hdir).mp hb\n    obtain ⟨C, hCA, hCB⟩ := H.directed ⟨A, hA⟩ B\n    apply hCA.2.1\n    exact isUnit_iff_exists_inv.mpr ⟨⟨b, hCB.1 hbB⟩, Subtype.ext congr(($e).1)⟩\n\n"}
{"name":"bijective_rangeRestrict_comp_of_valuationRing","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"R : Type u_1\nS : Type u_2\nK : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Field K\ninst✝⁵ : IsDomain R\ninst✝⁴ : ValuationRing R\ninst✝³ : IsLocalRing S\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\nf : RingHom R S\ng : RingHom S K\nh : Eq (g.comp f) (algebraMap R K)\ninst✝ : IsLocalHom f\n⊢ Function.Bijective ⇑(g.rangeRestrict.comp f)","decl":"lemma bijective_rangeRestrict_comp_of_valuationRing [IsDomain R] [ValuationRing R]\n    [IsLocalRing S] [Algebra R K] [IsFractionRing R K]\n    (f : R →+* S) (g : S →+* K) (h : g.comp f = algebraMap R K) [IsLocalHom f] :\n    Function.Bijective (g.rangeRestrict.comp f) := by\n  refine ⟨?_, ?_⟩\n  · exact .of_comp (f := Subtype.val) (by convert (IsFractionRing.injective R K); rw [← h]; rfl)\n  · let V : ValuationSubring K :=\n      ⟨(algebraMap R K).range, ValuationRing.isInteger_or_isInteger R⟩\n    suffices LocalSubring.range g ≤ V.toLocalSubring by\n      rintro ⟨_, x, rfl⟩\n      obtain ⟨y, hy⟩ := this.1 ⟨x, rfl⟩\n      exact ⟨y, Subtype.ext (by simpa [← h] using hy)⟩\n    apply V.isMax_toLocalSubring\n    have H : (algebraMap R K).range ≤ g.range := fun x ⟨a, ha⟩ ↦ ⟨f a, by simp [← ha, ← h]⟩\n    refine ⟨H, ⟨?_⟩⟩\n    rintro ⟨_, a, rfl⟩ (ha : IsUnit (M := g.range) ⟨algebraMap R K a, _⟩)\n    suffices IsUnit a from this.map (algebraMap R K).rangeRestrict\n    apply IsUnit.of_map f\n    apply (IsLocalHom.of_surjective g.rangeRestrict g.rangeRestrict_surjective).1\n    convert ha\n    simp [← h]\n\n"}
{"name":"IsLocalRing.exists_factor_valuationRing","module":"Mathlib.RingTheory.Valuation.LocalSubring","initialProofState":"R : Type u_1\nK : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Field K\ninst✝ : IsLocalRing R\nf : RingHom R K\n⊢ Exists fun A => Exists fun h => IsLocalHom (f.codRestrict A.toSubring h)","decl":"lemma IsLocalRing.exists_factor_valuationRing [IsLocalRing R] (f : R →+* K) :\n    ∃ (A : ValuationSubring K) (h : _), IsLocalHom (f.codRestrict A.toSubring h) := by\n  obtain ⟨B, hB⟩  := (LocalSubring.range f).exists_le_valuationSubring\n  refine ⟨B, fun x ↦ hB.1 ⟨x, rfl⟩, ?_⟩\n  exact @RingHom.isLocalHom_comp _ _ _ _ _ _ _ _\n    hB.2 (.of_surjective _ f.rangeRestrict_surjective)\n"}
