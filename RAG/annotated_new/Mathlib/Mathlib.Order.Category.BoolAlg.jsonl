{"name":"BoolAlg.coe_of","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\n⊢ Eq (↑(BoolAlg.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [BooleanAlgebra α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"BoolAlg.coe_toBddDistLat","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X : BoolAlg\n⊢ Eq ↑X.toBddDistLat.toDistLat ↑X","decl":"@[simp]\ntheorem coe_toBddDistLat (X : BoolAlg) : ↥X.toBddDistLat = ↥X :=\n  rfl\n\n"}
{"name":"BoolAlg.hasForgetToHeytAlg_forget₂_obj_α","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X : BoolAlg\n⊢ Eq ↑(CategoryTheory.HasForget₂.forget₂.obj X) ↑X","decl":"@[simps]\ninstance hasForgetToHeytAlg : HasForget₂ BoolAlg HeytAlg where\n  forget₂ :=\n    { obj := fun X => {α := X}\n      -- Porting note: was `fun {X Y} f => show BoundedLatticeHom X Y from f`\n      -- which already looks like a hack, but I don't understand why this hack works now and\n      -- the old one didn't\n      map := fun {X Y} (f : BoundedLatticeHom X Y) => show HeytingHom X Y from f }\n\n"}
{"name":"BoolAlg.hasForgetToHeytAlg_forget₂_map_toFun","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X Y : BoolAlg\nf : BoundedLatticeHom ↑X ↑Y\na : ↑X\n⊢ Eq ((CategoryTheory.HasForget₂.forget₂.map f) a) (f a)","decl":"@[simps]\ninstance hasForgetToHeytAlg : HasForget₂ BoolAlg HeytAlg where\n  forget₂ :=\n    { obj := fun X => {α := X}\n      -- Porting note: was `fun {X Y} f => show BoundedLatticeHom X Y from f`\n      -- which already looks like a hack, but I don't understand why this hack works now and\n      -- the old one didn't\n      map := fun {X Y} (f : BoundedLatticeHom X Y) => show HeytingHom X Y from f }\n\n"}
{"name":"BoolAlg.hasForgetToHeytAlg_forget₂_obj_str","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X : BoolAlg\n⊢ Eq (CategoryTheory.HasForget₂.forget₂.obj X).str inferInstance","decl":"@[simps]\ninstance hasForgetToHeytAlg : HasForget₂ BoolAlg HeytAlg where\n  forget₂ :=\n    { obj := fun X => {α := X}\n      -- Porting note: was `fun {X Y} f => show BoundedLatticeHom X Y from f`\n      -- which already looks like a hack, but I don't understand why this hack works now and\n      -- the old one didn't\n      map := fun {X Y} (f : BoundedLatticeHom X Y) => show HeytingHom X Y from f }\n\n"}
{"name":"BoolAlg.Iso.mk_hom_toLatticeHom_toSupHom_toFun","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"α β : BoolAlg\ne : OrderIso ↑α ↑β\na : ↑α\n⊢ Eq ((BoolAlg.Iso.mk e).hom.toSupHom a) (e a)","decl":"/-- Constructs an equivalence between Boolean algebras from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : BoolAlg.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedLatticeHom α β)\n  inv := (e.symm : BoundedLatticeHom β α)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"BoolAlg.Iso.mk_inv_toLatticeHom_toSupHom_toFun","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"α β : BoolAlg\ne : OrderIso ↑α ↑β\na : ↑β\n⊢ Eq ((BoolAlg.Iso.mk e).inv.toSupHom a) (e.symm a)","decl":"/-- Constructs an equivalence between Boolean algebras from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : BoolAlg.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedLatticeHom α β)\n  inv := (e.symm : BoundedLatticeHom β α)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"BoolAlg.dual_obj","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X : BoolAlg\n⊢ Eq (BoolAlg.dual.obj X) (BoolAlg.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : BoolAlg ⥤ BoolAlg where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedLatticeHom.dual\n\n"}
{"name":"BoolAlg.dual_map","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"x✝¹ x✝ : BoolAlg\na : BoundedLatticeHom ↑x✝¹.toBddDistLat.toBddLat.toLat ↑x✝.toBddDistLat.toBddLat.toLat\n⊢ Eq (BoolAlg.dual.map a) (BoundedLatticeHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : BoolAlg ⥤ BoolAlg where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedLatticeHom.dual\n\n"}
{"name":"BoolAlg.dualEquiv_inverse","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"⊢ Eq BoolAlg.dualEquiv.inverse BoolAlg.dual","decl":"/-- The equivalence between `BoolAlg` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : BoolAlg ≌ BoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"BoolAlg.dualEquiv_functor","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"⊢ Eq BoolAlg.dualEquiv.functor BoolAlg.dual","decl":"/-- The equivalence between `BoolAlg` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : BoolAlg ≌ BoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"boolAlg_dual_comp_forget_to_bddDistLat","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"⊢ Eq (BoolAlg.dual.comp (CategoryTheory.forget₂ BoolAlg BddDistLat)) ((CategoryTheory.forget₂ BoolAlg BddDistLat).comp BddDistLat.dual)","decl":"theorem boolAlg_dual_comp_forget_to_bddDistLat :\n    BoolAlg.dual ⋙ forget₂ BoolAlg BddDistLat =\n    forget₂ BoolAlg BddDistLat ⋙ BddDistLat.dual :=\n  rfl\n\n"}
{"name":"typeToBoolAlgOp_obj","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X : Type u\n⊢ Eq (typeToBoolAlgOp.obj X) { unop := BoolAlg.of (Set X) }","decl":"/-- The powerset functor. `Set` as a contravariant functor. -/\n@[simps]\ndef typeToBoolAlgOp : Type u ⥤ BoolAlgᵒᵖ where\n  obj X := op <| BoolAlg.of (Set X)\n  map {X Y} f := Quiver.Hom.op\n    (CompleteLatticeHom.setPreimage f : BoundedLatticeHom (Set Y) (Set X))\n"}
{"name":"typeToBoolAlgOp_map","module":"Mathlib.Order.Category.BoolAlg","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n⊢ Eq (typeToBoolAlgOp.map f)\n    (Quiver.Hom.op\n      (let __src := { toFun := ⇑(CompleteLatticeHom.setPreimage f), map_sup' := ⋯, map_inf' := ⋯ };\n      { toFun := ⇑(CompleteLatticeHom.setPreimage f), map_sup' := ⋯, map_inf' := ⋯, map_top' := ⋯, map_bot' := ⋯ }))","decl":"/-- The powerset functor. `Set` as a contravariant functor. -/\n@[simps]\ndef typeToBoolAlgOp : Type u ⥤ BoolAlgᵒᵖ where\n  obj X := op <| BoolAlg.of (Set X)\n  map {X Y} f := Quiver.Hom.op\n    (CompleteLatticeHom.setPreimage f : BoundedLatticeHom (Set Y) (Set X))\n"}
