{"name":"ProbabilityTheory.iIndepFun.indep_comap_natural_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¹ : Type u_2\nÎ² : Type u_3\ninstâœÂ² : LinearOrder Î¹\nmÎ² : MeasurableSpace Î²\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : BorelSpace Î²\nf : Î¹ â†’ Î© â†’ Î²\ni j : Î¹\nhf : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mÎ²) f Î¼\nhij : LT.lt i j\nâŠ¢ ProbabilityTheory.Indep (MeasurableSpace.comap (f j) mÎ²) (â†‘(MeasureTheory.Filtration.natural f hf) i) Î¼","decl":"theorem iIndepFun.indep_comap_natural_of_lt (hf : âˆ€ i, StronglyMeasurable (f i))\n    (hfi : iIndepFun (fun _ => mÎ²) f Î¼) (hij : i < j) :\n    Indep (MeasurableSpace.comap (f j) mÎ²) (Filtration.natural f hf i) Î¼ := by\n  suffices Indep (â¨† k âˆˆ ({j} : Set Î¹), MeasurableSpace.comap (f k) mÎ²)\n      (â¨† k âˆˆ {k | k â‰¤ i}, MeasurableSpace.comap (f k) mÎ²) Î¼ by rwa [iSup_singleton] at this\n  exact indep_iSup_of_disjoint (fun k => (hf k).measurable.comap_le) hfi (by simpa)\n\n"}
{"name":"ProbabilityTheory.iIndepFun.condExp_natural_ae_eq_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¹ : Type u_2\nÎ² : Type u_3\ninstâœâµ : LinearOrder Î¹\nmÎ² : MeasurableSpace Î²\ninstâœâ´ : NormedAddCommGroup Î²\ninstâœÂ³ : BorelSpace Î²\nf : Î¹ â†’ Î© â†’ Î²\ni j : Î¹\ninstâœÂ² : SecondCountableTopology Î²\ninstâœÂ¹ : CompleteSpace Î²\ninstâœ : NormedSpace Real Î²\nhf : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mÎ²) f Î¼\nhij : LT.lt i j\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp (â†‘(MeasureTheory.Filtration.natural f hf) i) Î¼ (f j)) fun x => MeasureTheory.integral Î¼ fun x => f j x","decl":"theorem iIndepFun.condExp_natural_ae_eq_of_lt [SecondCountableTopology Î²] [CompleteSpace Î²]\n    [NormedSpace â„ Î²] (hf : âˆ€ i, StronglyMeasurable (f i)) (hfi : iIndepFun (fun _ => mÎ²) f Î¼)\n    (hij : i < j) : Î¼[f j|Filtration.natural f hf i] =áµ[Î¼] fun _ => Î¼[f j] := by\n  have : IsProbabilityMeasure Î¼ := hfi.isProbabilityMeasure\n  exact condExp_indep_eq (hf j).measurable.comap_le (Filtration.le _ _)\n    (comap_measurable <| f j).stronglyMeasurable (hfi.indep_comap_natural_of_lt hf hij)\n\n"}
{"name":"ProbabilityTheory.iIndepFun.condexp_natural_ae_eq_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¹ : Type u_2\nÎ² : Type u_3\ninstâœâµ : LinearOrder Î¹\nmÎ² : MeasurableSpace Î²\ninstâœâ´ : NormedAddCommGroup Î²\ninstâœÂ³ : BorelSpace Î²\nf : Î¹ â†’ Î© â†’ Î²\ni j : Î¹\ninstâœÂ² : SecondCountableTopology Î²\ninstâœÂ¹ : CompleteSpace Î²\ninstâœ : NormedSpace Real Î²\nhf : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mÎ²) f Î¼\nhij : LT.lt i j\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp (â†‘(MeasureTheory.Filtration.natural f hf) i) Î¼ (f j)) fun x => MeasureTheory.integral Î¼ fun x => f j x","decl":"@[deprecated (since := \"2025-01-21\")]\nalias iIndepFun.condexp_natural_ae_eq_of_lt := iIndepFun.condExp_natural_ae_eq_of_lt\n\n"}
{"name":"ProbabilityTheory.iIndepSet.condExp_indicator_filtrationOfSet_ae_eq","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¹ : Type u_2\ninstâœ : LinearOrder Î¹\ni j : Î¹\ns : Î¹ â†’ Set Î©\nhsm : âˆ€ (n : Î¹), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s Î¼\nhij : LT.lt i j\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp (â†‘(MeasureTheory.filtrationOfSet hsm) i) Î¼ ((s j).indicator fun x => 1)) fun x => (Î¼ (s j)).toReal","decl":"theorem iIndepSet.condExp_indicator_filtrationOfSet_ae_eq (hsm : âˆ€ n, MeasurableSet (s n))\n    (hs : iIndepSet s Î¼) (hij : i < j) :\n    Î¼[(s j).indicator (fun _ => 1 : Î© â†’ â„)|filtrationOfSet hsm i] =áµ[Î¼]\n    fun _ => (Î¼ (s j)).toReal := by\n  rw [Filtration.filtrationOfSet_eq_natural (Î² := â„) hsm]\n  refine (iIndepFun.condExp_natural_ae_eq_of_lt _ hs.iIndepFun_indicator hij).trans ?_\n  simp only [integral_indicator_const _ (hsm _), Algebra.id.smul_eq_mul, mul_one]; rfl\n\n"}
{"name":"ProbabilityTheory.iIndepSet.condexp_indicator_filtrationOfSet_ae_eq","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¹ : Type u_2\ninstâœ : LinearOrder Î¹\ni j : Î¹\ns : Î¹ â†’ Set Î©\nhsm : âˆ€ (n : Î¹), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s Î¼\nhij : LT.lt i j\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp (â†‘(MeasureTheory.filtrationOfSet hsm) i) Î¼ ((s j).indicator fun x => 1)) fun x => (Î¼ (s j)).toReal","decl":"@[deprecated (since := \"2025-01-21\")]\nalias iIndepSet.condexp_indicator_filtrationOfSet_ae_eq :=\n  iIndepSet.condExp_indicator_filtrationOfSet_ae_eq\n\n"}
{"name":"ProbabilityTheory.measure_limsup_eq_one","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ns : Nat â†’ Set Î©\nhsm : âˆ€ (n : Nat), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s Î¼\nhs' : Eq (tsum fun n => Î¼ (s n)) Top.top\nâŠ¢ Eq (Î¼ (Filter.limsup s Filter.atTop)) 1","decl":"/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sâ‚™)` such that\n`âˆ‘ n, Î¼ sâ‚™ = âˆž`, `limsup sâ‚™` has measure 1. -/\ntheorem measure_limsup_eq_one {s : â„• â†’ Set Î©} (hsm : âˆ€ n, MeasurableSet (s n)) (hs : iIndepSet s Î¼)\n    (hs' : (âˆ‘' n, Î¼ (s n)) = âˆž) : Î¼ (limsup s atTop) = 1 := by\n  have : IsProbabilityMeasure Î¼ := hs.isProbabilityMeasure\n  rw [measure_congr (eventuallyEq_set.2 (ae_mem_limsup_atTop_iff Î¼ <|\n    measurableSet_filtrationOfSet' hsm) : (limsup s atTop : Set Î©) =áµ[Î¼]\n      {Ï‰ | Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n,\n        (Î¼[(s (k + 1)).indicator (1 : Î© â†’ â„)|filtrationOfSet hsm k]) Ï‰) atTop atTop})]\n  suffices {Ï‰ | Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n,\n      (Î¼[(s (k + 1)).indicator (1 : Î© â†’ â„)|filtrationOfSet hsm k]) Ï‰) atTop atTop} =áµ[Î¼] Set.univ by\n    rw [measure_congr this, measure_univ]\n  have : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ n, (Î¼[(s (n + 1)).indicator (1 : Î© â†’ â„)|filtrationOfSet hsm n]) Ï‰ = _ :=\n    ae_all_iff.2 fun n => hs.condExp_indicator_filtrationOfSet_ae_eq hsm n.lt_succ_self\n  filter_upwards [this] with Ï‰ hÏ‰\n  refine eq_true (?_ : Tendsto _ _ _)\n  simp_rw [hÏ‰]\n  have htends : Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n, Î¼ (s (k + 1))) atTop (ð“ âˆž) := by\n    rw [â† ENNReal.tsum_add_one_eq_top hs' (measure_ne_top _ _)]\n    exact ENNReal.tendsto_nat_tsum _\n  rw [ENNReal.tendsto_nhds_top_iff_nnreal] at htends\n  refine tendsto_atTop_atTop_of_monotone' ?_ ?_\n  Â· refine monotone_nat_of_le_succ fun n => ?_\n    rw [â† sub_nonneg, Finset.sum_range_succ_sub_sum]\n    exact ENNReal.toReal_nonneg\n  Â· rintro âŸ¨B, hBâŸ©\n    refine not_eventually.2 (Frequently.of_forall fun n => ?_) (htends B.toNNReal)\n    rw [mem_upperBounds] at hB\n    specialize hB (âˆ‘ k âˆˆ Finset.range n, Î¼ (s (k + 1))).toReal _\n    Â· refine âŸ¨n, ?_âŸ©\n      rw [ENNReal.toReal_sum]\n      exact fun _ _ => measure_ne_top _ _\n    Â· rwa [not_lt, ENNReal.ofNNReal_toNNReal, ENNReal.le_ofReal_iff_toReal_le]\n      Â· simp\n      Â· exact le_trans (by positivity) hB\n\n"}
