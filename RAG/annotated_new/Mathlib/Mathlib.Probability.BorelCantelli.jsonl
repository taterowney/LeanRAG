{"name":"ProbabilityTheory.iIndepFun.indep_comap_natural_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\nβ : Type u_3\ninst✝² : LinearOrder ι\nmβ : MeasurableSpace β\ninst✝¹ : NormedAddCommGroup β\ninst✝ : BorelSpace β\nf : ι → Ω → β\ni j : ι\nhf : ∀ (i : ι), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mβ) f μ\nhij : LT.lt i j\n⊢ ProbabilityTheory.Indep (MeasurableSpace.comap (f j) mβ) (↑(MeasureTheory.Filtration.natural f hf) i) μ","decl":"theorem iIndepFun.indep_comap_natural_of_lt (hf : ∀ i, StronglyMeasurable (f i))\n    (hfi : iIndepFun (fun _ => mβ) f μ) (hij : i < j) :\n    Indep (MeasurableSpace.comap (f j) mβ) (Filtration.natural f hf i) μ := by\n  suffices Indep (⨆ k ∈ ({j} : Set ι), MeasurableSpace.comap (f k) mβ)\n      (⨆ k ∈ {k | k ≤ i}, MeasurableSpace.comap (f k) mβ) μ by rwa [iSup_singleton] at this\n  exact indep_iSup_of_disjoint (fun k => (hf k).measurable.comap_le) hfi (by simpa)\n\n"}
{"name":"ProbabilityTheory.iIndepFun.condExp_natural_ae_eq_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrder ι\nmβ : MeasurableSpace β\ninst✝⁴ : NormedAddCommGroup β\ninst✝³ : BorelSpace β\nf : ι → Ω → β\ni j : ι\ninst✝² : SecondCountableTopology β\ninst✝¹ : CompleteSpace β\ninst✝ : NormedSpace Real β\nhf : ∀ (i : ι), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mβ) f μ\nhij : LT.lt i j\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (↑(MeasureTheory.Filtration.natural f hf) i) μ (f j)) fun x => MeasureTheory.integral μ fun x => f j x","decl":"theorem iIndepFun.condExp_natural_ae_eq_of_lt [SecondCountableTopology β] [CompleteSpace β]\n    [NormedSpace ℝ β] (hf : ∀ i, StronglyMeasurable (f i)) (hfi : iIndepFun (fun _ => mβ) f μ)\n    (hij : i < j) : μ[f j|Filtration.natural f hf i] =ᵐ[μ] fun _ => μ[f j] := by\n  have : IsProbabilityMeasure μ := hfi.isProbabilityMeasure\n  exact condExp_indep_eq (hf j).measurable.comap_le (Filtration.le _ _)\n    (comap_measurable <| f j).stronglyMeasurable (hfi.indep_comap_natural_of_lt hf hij)\n\n"}
{"name":"ProbabilityTheory.iIndepFun.condexp_natural_ae_eq_of_lt","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrder ι\nmβ : MeasurableSpace β\ninst✝⁴ : NormedAddCommGroup β\ninst✝³ : BorelSpace β\nf : ι → Ω → β\ni j : ι\ninst✝² : SecondCountableTopology β\ninst✝¹ : CompleteSpace β\ninst✝ : NormedSpace Real β\nhf : ∀ (i : ι), MeasureTheory.StronglyMeasurable (f i)\nhfi : ProbabilityTheory.iIndepFun (fun x => mβ) f μ\nhij : LT.lt i j\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (↑(MeasureTheory.Filtration.natural f hf) i) μ (f j)) fun x => MeasureTheory.integral μ fun x => f j x","decl":"@[deprecated (since := \"2025-01-21\")]\nalias iIndepFun.condexp_natural_ae_eq_of_lt := iIndepFun.condExp_natural_ae_eq_of_lt\n\n"}
{"name":"ProbabilityTheory.iIndepSet.condExp_indicator_filtrationOfSet_ae_eq","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\ninst✝ : LinearOrder ι\ni j : ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s μ\nhij : LT.lt i j\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (↑(MeasureTheory.filtrationOfSet hsm) i) μ ((s j).indicator fun x => 1)) fun x => (μ (s j)).toReal","decl":"theorem iIndepSet.condExp_indicator_filtrationOfSet_ae_eq (hsm : ∀ n, MeasurableSet (s n))\n    (hs : iIndepSet s μ) (hij : i < j) :\n    μ[(s j).indicator (fun _ => 1 : Ω → ℝ)|filtrationOfSet hsm i] =ᵐ[μ]\n    fun _ => (μ (s j)).toReal := by\n  rw [Filtration.filtrationOfSet_eq_natural (β := ℝ) hsm]\n  refine (iIndepFun.condExp_natural_ae_eq_of_lt _ hs.iIndepFun_indicator hij).trans ?_\n  simp only [integral_indicator_const _ (hsm _), Algebra.id.smul_eq_mul, mul_one]; rfl\n\n"}
{"name":"ProbabilityTheory.iIndepSet.condexp_indicator_filtrationOfSet_ae_eq","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\ninst✝ : LinearOrder ι\ni j : ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s μ\nhij : LT.lt i j\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (↑(MeasureTheory.filtrationOfSet hsm) i) μ ((s j).indicator fun x => 1)) fun x => (μ (s j)).toReal","decl":"@[deprecated (since := \"2025-01-21\")]\nalias iIndepSet.condexp_indicator_filtrationOfSet_ae_eq :=\n  iIndepSet.condExp_indicator_filtrationOfSet_ae_eq\n\n"}
{"name":"ProbabilityTheory.measure_limsup_eq_one","module":"Mathlib.Probability.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Nat → Set Ω\nhsm : ∀ (n : Nat), MeasurableSet (s n)\nhs : ProbabilityTheory.iIndepSet s μ\nhs' : Eq (tsum fun n => μ (s n)) Top.top\n⊢ Eq (μ (Filter.limsup s Filter.atTop)) 1","decl":"/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sₙ)` such that\n`∑ n, μ sₙ = ∞`, `limsup sₙ` has measure 1. -/\ntheorem measure_limsup_eq_one {s : ℕ → Set Ω} (hsm : ∀ n, MeasurableSet (s n)) (hs : iIndepSet s μ)\n    (hs' : (∑' n, μ (s n)) = ∞) : μ (limsup s atTop) = 1 := by\n  have : IsProbabilityMeasure μ := hs.isProbabilityMeasure\n  rw [measure_congr (eventuallyEq_set.2 (ae_mem_limsup_atTop_iff μ <|\n    measurableSet_filtrationOfSet' hsm) : (limsup s atTop : Set Ω) =ᵐ[μ]\n      {ω | Tendsto (fun n => ∑ k ∈ Finset.range n,\n        (μ[(s (k + 1)).indicator (1 : Ω → ℝ)|filtrationOfSet hsm k]) ω) atTop atTop})]\n  suffices {ω | Tendsto (fun n => ∑ k ∈ Finset.range n,\n      (μ[(s (k + 1)).indicator (1 : Ω → ℝ)|filtrationOfSet hsm k]) ω) atTop atTop} =ᵐ[μ] Set.univ by\n    rw [measure_congr this, measure_univ]\n  have : ∀ᵐ ω ∂μ, ∀ n, (μ[(s (n + 1)).indicator (1 : Ω → ℝ)|filtrationOfSet hsm n]) ω = _ :=\n    ae_all_iff.2 fun n => hs.condExp_indicator_filtrationOfSet_ae_eq hsm n.lt_succ_self\n  filter_upwards [this] with ω hω\n  refine eq_true (?_ : Tendsto _ _ _)\n  simp_rw [hω]\n  have htends : Tendsto (fun n => ∑ k ∈ Finset.range n, μ (s (k + 1))) atTop (𝓝 ∞) := by\n    rw [← ENNReal.tsum_add_one_eq_top hs' (measure_ne_top _ _)]\n    exact ENNReal.tendsto_nat_tsum _\n  rw [ENNReal.tendsto_nhds_top_iff_nnreal] at htends\n  refine tendsto_atTop_atTop_of_monotone' ?_ ?_\n  · refine monotone_nat_of_le_succ fun n => ?_\n    rw [← sub_nonneg, Finset.sum_range_succ_sub_sum]\n    exact ENNReal.toReal_nonneg\n  · rintro ⟨B, hB⟩\n    refine not_eventually.2 (Frequently.of_forall fun n => ?_) (htends B.toNNReal)\n    rw [mem_upperBounds] at hB\n    specialize hB (∑ k ∈ Finset.range n, μ (s (k + 1))).toReal _\n    · refine ⟨n, ?_⟩\n      rw [ENNReal.toReal_sum]\n      exact fun _ _ => measure_ne_top _ _\n    · rwa [not_lt, ENNReal.ofNNReal_toNNReal, ENNReal.le_ofReal_iff_toReal_le]\n      · simp\n      · exact le_trans (by positivity) hB\n\n"}
