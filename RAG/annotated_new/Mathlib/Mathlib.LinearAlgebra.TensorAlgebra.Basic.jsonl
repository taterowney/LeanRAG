{"name":"instSMulCommClassTensorAlgebra","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra S A\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : Module A M\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower S A M\n⊢ SMulCommClass R S (TensorAlgebra A M)","decl":"instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommMonoid M] [CommSemiring A]\n    [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M]\n    [IsScalarTower R A M] [IsScalarTower S A M] :\n    SMulCommClass R S (TensorAlgebra A M) :=\n  RingQuot.instSMulCommClass _\n\n"}
{"name":"instIsScalarTowerTensorAlgebra","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : CommSemiring A\ninst✝⁸ : SMul R S\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra S A\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower S A M\ninst✝ : IsScalarTower R S A\n⊢ IsScalarTower R S (TensorAlgebra A M)","decl":"instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommMonoid M] [CommSemiring A]\n    [SMul R S] [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M]\n    [IsScalarTower R A M] [IsScalarTower S A M] [IsScalarTower R S A] :\n    IsScalarTower R S (TensorAlgebra A M) :=\n  RingQuot.instIsScalarTower _\n\n"}
{"name":"TensorAlgebra.ι_def","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_3\ninst✝² : CommSemiring R\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorAlgebra.ι R) { toFun := fun m => (RingQuot.mkAlgHom R (TensorAlgebra.Rel R M)) (FreeAlgebra.ι R m), map_add' := ⋯, map_smul' := ⋯ }","decl":"/-- The canonical linear map `M →ₗ[R] TensorAlgebra R M`.\n-/\nirreducible_def ι : M →ₗ[R] TensorAlgebra R M :=\n  { toFun := fun m => RingQuot.mkAlgHom R _ (FreeAlgebra.ι R m)\n    map_add' := fun x y => by\n      rw [← map_add (RingQuot.mkAlgHom R (Rel R M))]\n      exact RingQuot.mkAlgHom_rel R Rel.add\n    map_smul' := fun r x => by\n      rw [← map_smul (RingQuot.mkAlgHom R (Rel R M))]\n      exact RingQuot.mkAlgHom_rel R Rel.smul }\n\n"}
{"name":"TensorAlgebra.ringQuot_mkAlgHom_freeAlgebra_ι_eq_ι","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq ((RingQuot.mkAlgHom R (TensorAlgebra.Rel R M)) (FreeAlgebra.ι R m)) ((TensorAlgebra.ι R) m)","decl":"theorem ringQuot_mkAlgHom_freeAlgebra_ι_eq_ι (m : M) :\n    RingQuot.mkAlgHom R (Rel R M) (FreeAlgebra.ι R m) = ι R m := by\n  rw [ι]\n  rfl\n\n-- Porting note: Changed `irreducible_def` to `def` to get `@[simps symm_apply]` to work\n"}
{"name":"TensorAlgebra.lift_symm_apply","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nF : AlgHom R (TensorAlgebra R M) A\n⊢ Eq ((TensorAlgebra.lift R).symm F) (F.toLinearMap.comp (TensorAlgebra.ι R))","decl":"/-- Given a linear map `f : M → A` where `A` is an `R`-algebra, `lift R f` is the unique lift\nof `f` to a morphism of `R`-algebras `TensorAlgebra R M → A`.\n-/\n@[simps symm_apply]\ndef lift {A : Type*} [Semiring A] [Algebra R A] : (M →ₗ[R] A) ≃ (TensorAlgebra R M →ₐ[R] A) :=\n  { toFun :=\n      RingQuot.liftAlgHom R ∘ fun f =>\n        ⟨FreeAlgebra.lift R (⇑f), fun x y (h : Rel R M x y) => by\n          induction h <;>\n            simp only [Algebra.smul_def, FreeAlgebra.lift_ι_apply, LinearMap.map_smulₛₗ,\n              RingHom.id_apply, map_mul, AlgHom.commutes, map_add]⟩\n    invFun := fun F => F.toLinearMap.comp (ι R)\n    left_inv := fun f => by\n      rw [ι]\n      ext1 x\n      exact (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (FreeAlgebra.lift_ι_apply f x)\n    right_inv := fun F =>\n      RingQuot.ringQuot_ext' _ _ _ <|\n        FreeAlgebra.hom_ext <|\n          funext fun x => by\n            rw [ι]\n            exact\n              (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (FreeAlgebra.lift_ι_apply _ _) }\n\n"}
{"name":"TensorAlgebra.ι_comp_lift","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\n⊢ Eq (((TensorAlgebra.lift R) f).toLinearMap.comp (TensorAlgebra.ι R)) f","decl":"@[simp]\ntheorem ι_comp_lift {A : Type*} [Semiring A] [Algebra R A] (f : M →ₗ[R] A) :\n    (lift R f).toLinearMap.comp (ι R) = f := by\n  convert (lift R).symm_apply_apply f\n\n"}
{"name":"TensorAlgebra.lift_ι_apply","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\nx : M\n⊢ Eq (((TensorAlgebra.lift R) f) ((TensorAlgebra.ι R) x)) (f x)","decl":"@[simp]\ntheorem lift_ι_apply {A : Type*} [Semiring A] [Algebra R A] (f : M →ₗ[R] A) (x) :\n    lift R f (ι R x) = f x := by\n  conv_rhs => rw [← ι_comp_lift f]\n  rfl\n\n"}
{"name":"TensorAlgebra.lift_unique","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ng : AlgHom R (TensorAlgebra R M) A\n⊢ Iff (Eq (g.toLinearMap.comp (TensorAlgebra.ι R)) f) (Eq g ((TensorAlgebra.lift R) f))","decl":"@[simp]\ntheorem lift_unique {A : Type*} [Semiring A] [Algebra R A] (f : M →ₗ[R] A)\n    (g : TensorAlgebra R M →ₐ[R] A) : g.toLinearMap.comp (ι R) = f ↔ g = lift R f := by\n  rw [← (lift R).symm_apply_eq]\n  simp only [lift, Equiv.coe_fn_symm_mk]\n\n-- Marking `TensorAlgebra` irreducible makes `Ring` instances inaccessible on quotients.\n-- https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/212580241\n-- For now, we avoid this by not marking it irreducible.\n"}
{"name":"TensorAlgebra.lift_comp_ι","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (TensorAlgebra R M) A\n⊢ Eq ((TensorAlgebra.lift R) (g.toLinearMap.comp (TensorAlgebra.ι R))) g","decl":"@[simp]\ntheorem lift_comp_ι {A : Type*} [Semiring A] [Algebra R A] (g : TensorAlgebra R M →ₐ[R] A) :\n    lift R (g.toLinearMap.comp (ι R)) = g := by\n  rw [← lift_symm_apply]\n  exact (lift R).apply_symm_apply g\n\n"}
{"name":"TensorAlgebra.hom_ext_iff","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (TensorAlgebra R M) A\n⊢ Iff (Eq f g) (Eq (f.toLinearMap.comp (TensorAlgebra.ι R)) (g.toLinearMap.comp (TensorAlgebra.ι R)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : TensorAlgebra R M →ₐ[R] A}\n    (w : f.toLinearMap.comp (ι R) = g.toLinearMap.comp (ι R)) : f = g := by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n\n-- This proof closely follows `FreeAlgebra.induction`\n"}
{"name":"TensorAlgebra.hom_ext","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (TensorAlgebra R M) A\nw : Eq (f.toLinearMap.comp (TensorAlgebra.ι R)) (g.toLinearMap.comp (TensorAlgebra.ι R))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : TensorAlgebra R M →ₐ[R] A}\n    (w : f.toLinearMap.comp (ι R) = g.toLinearMap.comp (ι R)) : f = g := by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n\n-- This proof closely follows `FreeAlgebra.induction`\n"}
{"name":"TensorAlgebra.induction","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nC : TensorAlgebra R M → Prop\nalgebraMap : ∀ (r : R), C ((_root_.algebraMap R (TensorAlgebra R M)) r)\nι : ∀ (x : M), C ((TensorAlgebra.ι R) x)\nmul : ∀ (a b : TensorAlgebra R M), C a → C b → C (HMul.hMul a b)\nadd : ∀ (a b : TensorAlgebra R M), C a → C b → C (HAdd.hAdd a b)\na : TensorAlgebra R M\n⊢ C a","decl":"/-- If `C` holds for the `algebraMap` of `r : R` into `TensorAlgebra R M`, the `ι` of `x : M`,\nand is preserved under addition and multiplication, then it holds for all of `TensorAlgebra R M`.\n-/\n@[elab_as_elim]\ntheorem induction {C : TensorAlgebra R M → Prop}\n    (algebraMap : ∀ r, C (algebraMap R (TensorAlgebra R M) r)) (ι : ∀ x, C (ι R x))\n    (mul : ∀ a b, C a → C b → C (a * b)) (add : ∀ a b, C a → C b → C (a + b))\n    (a : TensorAlgebra R M) : C a := by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from M\n  let s : Subalgebra R (TensorAlgebra R M) :=\n    { carrier := C\n      mul_mem' := @mul\n      add_mem' := @add\n      algebraMap_mem' := algebraMap }\n  -- Porting note: Added `h`. `h` is needed for `of`.\n  let h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))\n  let of : M →ₗ[R] s := (TensorAlgebra.ι R).codRestrict (Subalgebra.toSubmodule s) ι\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (TensorAlgebra R M) = s.val.comp (lift R of) := by\n    ext\n    simp only [AlgHom.toLinearMap_id, LinearMap.id_comp, AlgHom.comp_toLinearMap,\n      LinearMap.coe_comp, Function.comp_apply, AlgHom.toLinearMap_apply, lift_ι_apply,\n      Subalgebra.coe_val]\n    erw [LinearMap.codRestrict_apply]\n  -- finding a proof is finding an element of the subalgebra\n  rw [← AlgHom.id_apply (R := R) a, of_id]\n  exact Subtype.prop (lift R of a)\n\n"}
{"name":"TensorAlgebra.algebraMap_leftInverse","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.LeftInverse ⇑TensorAlgebra.algebraMapInv ⇑(algebraMap R (TensorAlgebra R M))","decl":"theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| TensorAlgebra R M) := fun x => by\n  simp [algebraMapInv]\n\n"}
{"name":"TensorAlgebra.algebraMap_inj","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : R\n⊢ Iff (Eq ((algebraMap R (TensorAlgebra R M)) x) ((algebraMap R (TensorAlgebra R M)) y)) (Eq x y)","decl":"@[simp]\ntheorem algebraMap_inj (x y : R) :\n    algebraMap R (TensorAlgebra R M) x = algebraMap R (TensorAlgebra R M) y ↔ x = y :=\n  (algebraMap_leftInverse M).injective.eq_iff\n\n"}
{"name":"TensorAlgebra.algebraMap_eq_zero_iff","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : R\n⊢ Iff (Eq ((algebraMap R (TensorAlgebra R M)) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem algebraMap_eq_zero_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ↔ x = 0 :=\n  map_eq_zero_iff (algebraMap _ _) (algebraMap_leftInverse _).injective\n\n"}
{"name":"TensorAlgebra.algebraMap_eq_one_iff","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : R\n⊢ Iff (Eq ((algebraMap R (TensorAlgebra R M)) x) 1) (Eq x 1)","decl":"@[simp]\ntheorem algebraMap_eq_one_iff (x : R) : algebraMap R (TensorAlgebra R M) x = 1 ↔ x = 1 :=\n  map_eq_one_iff (algebraMap _ _) (algebraMap_leftInverse _).injective\n\n"}
{"name":"TensorAlgebra.instNontrivial","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\n⊢ Nontrivial (TensorAlgebra R M)","decl":"/-- A `TensorAlgebra` over a nontrivial semiring is nontrivial. -/\ninstance [Nontrivial R] : Nontrivial (TensorAlgebra R M) :=\n  (algebraMap_leftInverse M).injective.nontrivial\n\n"}
{"name":"TensorAlgebra.toTrivSqZeroExt_ι","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nx : M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : IsCentralScalar R M\n⊢ Eq (TensorAlgebra.toTrivSqZeroExt ((TensorAlgebra.ι R) x)) (TrivSqZeroExt.inr x)","decl":"@[simp]\ntheorem toTrivSqZeroExt_ι (x : M) [Module Rᵐᵒᵖ M] [IsCentralScalar R M] :\n    toTrivSqZeroExt (ι R x) = TrivSqZeroExt.inr x :=\n  lift_ι_apply _ _\n\n"}
{"name":"TensorAlgebra.ι_leftInverse","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.LeftInverse ⇑TensorAlgebra.ιInv ⇑(TensorAlgebra.ι R)","decl":"theorem ι_leftInverse : Function.LeftInverse ιInv (ι R : M → TensorAlgebra R M) := fun x ↦ by\n  simp [ιInv]\n\n"}
{"name":"TensorAlgebra.ι_inj","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\n⊢ Iff (Eq ((TensorAlgebra.ι R) x) ((TensorAlgebra.ι R) y)) (Eq x y)","decl":"@[simp]\ntheorem ι_inj (x y : M) : ι R x = ι R y ↔ x = y :=\n  ι_leftInverse.injective.eq_iff\n\n"}
{"name":"TensorAlgebra.ι_eq_zero_iff","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Eq ((TensorAlgebra.ι R) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem ι_eq_zero_iff (x : M) : ι R x = 0 ↔ x = 0 := by rw [← ι_inj R x 0, LinearMap.map_zero]\n\n"}
{"name":"TensorAlgebra.ι_eq_algebraMap_iff","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\nr : R\n⊢ Iff (Eq ((TensorAlgebra.ι R) x) ((algebraMap R (TensorAlgebra R M)) r)) (And (Eq x 0) (Eq r 0))","decl":"@[simp]\ntheorem ι_eq_algebraMap_iff (x : M) (r : R) : ι R x = algebraMap R _ r ↔ x = 0 ∧ r = 0 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · letI : Module Rᵐᵒᵖ M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n    haveI : IsCentralScalar R M := ⟨fun r m => rfl⟩\n    have hf0 : toTrivSqZeroExt (ι R x) = (0, x) := lift_ι_apply _ _\n    rw [h, AlgHom.commutes] at hf0\n    have : r = 0 ∧ 0 = x := Prod.ext_iff.1 hf0\n    exact this.symm.imp_left Eq.symm\n  · rintro ⟨rfl, rfl⟩\n    rw [LinearMap.map_zero, RingHom.map_zero]\n\n"}
{"name":"TensorAlgebra.ι_ne_one","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nx : M\n⊢ Ne ((TensorAlgebra.ι R) x) 1","decl":"@[simp]\ntheorem ι_ne_one [Nontrivial R] (x : M) : ι R x ≠ 1 := by\n  rw [← (algebraMap R (TensorAlgebra R M)).map_one, Ne, ι_eq_algebraMap_iff]\n  exact one_ne_zero ∘ And.right\n\n"}
{"name":"TensorAlgebra.ι_range_disjoint_one","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Disjoint (LinearMap.range (TensorAlgebra.ι R)) 1","decl":"/-- The generators of the tensor algebra are disjoint from its scalars. -/\ntheorem ι_range_disjoint_one :\n    Disjoint (LinearMap.range (ι R : M →ₗ[R] TensorAlgebra R M))\n      (1 : Submodule R (TensorAlgebra R M)) := by\n  rw [Submodule.disjoint_def, Submodule.one_eq_range]\n  rintro _ ⟨x, hx⟩ ⟨r, rfl⟩\n  rw [Algebra.linearMap_apply, ι_eq_algebraMap_iff] at hx\n  rw [hx.2, map_zero]\n\n"}
{"name":"TensorAlgebra.tprod_apply","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nx : Fin n → M\n⊢ Eq ((TensorAlgebra.tprod R M n) x) (List.ofFn fun i => (TensorAlgebra.ι R) (x i)).prod","decl":"@[simp]\ntheorem tprod_apply {n : ℕ} (x : Fin n → M) : tprod R M n x = (List.ofFn fun i => ι R (x i)).prod :=\n  rfl\n\n"}
{"name":"FreeAlgebra.toTensor_ι","module":"Mathlib.LinearAlgebra.TensorAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq (FreeAlgebra.toTensor (FreeAlgebra.ι R m)) ((TensorAlgebra.ι R) m)","decl":"@[simp]\ntheorem toTensor_ι (m : M) : FreeAlgebra.toTensor (FreeAlgebra.ι R m) = TensorAlgebra.ι R m := by\n  simp [toTensor]\n\n"}
