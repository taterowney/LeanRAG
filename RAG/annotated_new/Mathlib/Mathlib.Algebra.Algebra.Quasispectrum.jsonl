{"name":"PreQuasiregular.mk.sizeOf_spec","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : SizeOf R\nval : R\n⊢ Eq (SizeOf.sizeOf { val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y ↦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.mk.injEq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nval✝ val : R\n⊢ Eq (Eq { val := val✝ } { val := val }) (Eq val✝ val)","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y ↦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.mk.inj","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nval✝ val : R\nx✝ : Eq { val := val✝ } { val := val }\n⊢ Eq val✝ val","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y ↦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.equiv_apply_val","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nval : R\n⊢ Eq (PreQuasiregular.equiv val).val val","decl":"/-- The identity map between `R` and `PreQuasiregular R`. -/\n@[simps]\ndef equiv : R ≃ PreQuasiregular R where\n  toFun := .mk\n  invFun := PreQuasiregular.val\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PreQuasiregular.equiv_symm_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nself : PreQuasiregular R\n⊢ Eq (PreQuasiregular.equiv.symm self) self.val","decl":"/-- The identity map between `R` and `PreQuasiregular R`. -/\n@[simps]\ndef equiv : R ≃ PreQuasiregular R where\n  toFun := .mk\n  invFun := PreQuasiregular.val\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PreQuasiregular.val_one","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\n⊢ Eq (PreQuasiregular.val 1) 0","decl":"@[simp]\nlemma val_one : (1 : PreQuasiregular R).val = 0 := rfl\n\n"}
{"name":"PreQuasiregular.val_mul","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\nx y : PreQuasiregular R\n⊢ Eq (HMul.hMul x y).val (HAdd.hAdd (HAdd.hAdd y.val x.val) (HMul.hMul x.val y.val))","decl":"@[simp]\nlemma val_mul (x y : PreQuasiregular R) : (x * y).val = y.val + x.val + x.val * y.val := rfl\n\n"}
{"name":"PreQuasiregular.inv_add_add_mul_eq_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\nu : Units (PreQuasiregular R)\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (↑(Inv.inv u)).val (↑u).val) (HMul.hMul (↑u).val (↑(Inv.inv u)).val)) 0","decl":"@[simp]\nlemma inv_add_add_mul_eq_zero (u : (PreQuasiregular R)ˣ) :\n    u⁻¹.val.val + u.val.val + u.val.val * u⁻¹.val.val = 0 := by\n  simpa [-Units.mul_inv] using congr($(u.mul_inv).val)\n\n"}
{"name":"PreQuasiregular.add_inv_add_mul_eq_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\nu : Units (PreQuasiregular R)\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (↑u).val (↑(Inv.inv u)).val) (HMul.hMul (↑(Inv.inv u)).val (↑u).val)) 0","decl":"@[simp]\nlemma add_inv_add_mul_eq_zero (u : (PreQuasiregular R)ˣ) :\n    u.val.val + u⁻¹.val.val + u⁻¹.val.val * u.val.val = 0 := by\n  simpa [-Units.inv_mul] using congr($(u.inv_mul).val)\n\n"}
{"name":"Unitization.mem_unitsFstOne","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Units (Unitization R A)\n⊢ Iff (Membership.mem (Unitization.unitsFstOne R A) x) (Eq (↑x).fst 1)","decl":"@[simp]\nlemma mem_unitsFstOne {x : (Unitization R A)ˣ} : x ∈ unitsFstOne R A ↔ x.val.fst = 1 := Iff.rfl\n\n"}
{"name":"Unitization.unitsFstOne_val_val_fst","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\n⊢ Eq (↑↑x).fst 1","decl":"@[simp]\nlemma unitsFstOne_val_val_fst (x : (unitsFstOne R A)) : x.val.val.fst = 1 :=\n  mem_unitsFstOne.mp x.property\n\n"}
{"name":"Unitization.unitsFstOne_val_inv_val_fst","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\n⊢ Eq (↑(Inv.inv ↑x)).fst 1","decl":"@[simp]\nlemma unitsFstOne_val_inv_val_fst (x : (unitsFstOne R A)) : x.val⁻¹.val.fst = 1 :=\n  mem_unitsFstOne.mp x⁻¹.property\n\n"}
{"name":"Unitization.val_inv_unitsFstOne_mulEquiv_quasiregular_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\n⊢ Eq (↑(Inv.inv ((Unitization.unitsFstOne_mulEquiv_quasiregular R) x))) (PreQuasiregular.equiv (↑↑(Inv.inv x)).snd)","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A ≃* (PreQuasiregular A)ˣ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv x⁻¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm x⁻¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_inv_unitsFstOne_mulEquiv_quasiregular_symm_apply_coe","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Units (PreQuasiregular A)\n⊢ Eq (↑(Inv.inv ↑((Unitization.unitsFstOne_mulEquiv_quasiregular R).symm x))) (HAdd.hAdd 1 ↑(PreQuasiregular.equiv.symm ↑(Inv.inv x)))","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A ≃* (PreQuasiregular A)ˣ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv x⁻¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm x⁻¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_unitsFstOne_mulEquiv_quasiregular_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\n⊢ Eq (↑((Unitization.unitsFstOne_mulEquiv_quasiregular R) x)) (PreQuasiregular.equiv (↑↑x).snd)","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A ≃* (PreQuasiregular A)ˣ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv x⁻¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm x⁻¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_unitsFstOne_mulEquiv_quasiregular_symm_apply_coe","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : Units (PreQuasiregular A)\n⊢ Eq (↑↑((Unitization.unitsFstOne_mulEquiv_quasiregular R).symm x)) (HAdd.hAdd 1 ↑(PreQuasiregular.equiv.symm ↑x))","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A ≃* (PreQuasiregular A)ˣ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv x⁻¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm x⁻¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          · simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          · simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"isQuasiregular_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"⊢ IsQuasiregular 0","decl":"@[simp]\nlemma isQuasiregular_zero : IsQuasiregular 0 := ⟨1, rfl⟩\n\n"}
{"name":"isQuasiregular_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\nx : R\n⊢ Iff (IsQuasiregular x) (Exists fun y => And (Eq (HAdd.hAdd (HAdd.hAdd y x) (HMul.hMul x y)) 0) (Eq (HAdd.hAdd (HAdd.hAdd x y) (HMul.hMul y x)) 0))","decl":"lemma isQuasiregular_iff {x : R} :\n    IsQuasiregular x ↔ ∃ y, y + x + x * y = 0 ∧ x + y + y * x = 0 := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    exact ⟨equiv.symm u⁻¹.val, by simp⟩\n  · rintro ⟨y, hy₁, hy₂⟩\n    refine ⟨⟨equiv x, equiv y, ?_, ?_⟩, rfl⟩\n    all_goals\n      apply equiv.symm.injective\n      assumption\n\n"}
{"name":"IsQuasiregular.map","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : NonUnitalSemiring R\ninst✝² : NonUnitalSemiring S\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nx : R\nhx : IsQuasiregular x\n⊢ IsQuasiregular (f x)","decl":"lemma IsQuasiregular.map {F R S : Type*} [NonUnitalSemiring R] [NonUnitalSemiring S]\n    [FunLike F R S] [NonUnitalRingHomClass F R S] (f : F) {x : R} (hx : IsQuasiregular x) :\n    IsQuasiregular (f x) := by\n  rw [isQuasiregular_iff] at hx ⊢\n  obtain ⟨y, hy₁, hy₂⟩ := hx\n  exact ⟨f y, by simpa using And.intro congr(f $(hy₁)) congr(f $(hy₂))⟩\n\n"}
{"name":"IsQuasiregular.isUnit_one_add","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : R\nhx : IsQuasiregular x\n⊢ IsUnit (HAdd.hAdd 1 x)","decl":"lemma IsQuasiregular.isUnit_one_add {R : Type*} [Semiring R] {x : R} (hx : IsQuasiregular x) :\n    IsUnit (1 + x) := by\n  obtain ⟨y, hy₁, hy₂⟩ := isQuasiregular_iff.mp hx\n  refine ⟨⟨1 + x, 1 + y, ?_, ?_⟩, rfl⟩\n  · convert congr(1 + $(hy₁)) using 1 <;> [noncomm_ring; simp]\n  · convert congr(1 + $(hy₂)) using 1 <;> [noncomm_ring; simp]\n\n"}
{"name":"isQuasiregular_iff_isUnit","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx : R\n⊢ Iff (IsQuasiregular x) (IsUnit (HAdd.hAdd 1 x))","decl":"lemma isQuasiregular_iff_isUnit {R : Type*} [Ring R] {x : R} :\n    IsQuasiregular x ↔ IsUnit (1 + x) := by\n  refine ⟨IsQuasiregular.isUnit_one_add, fun hx ↦ ?_⟩\n  rw [isQuasiregular_iff]\n  use hx.unit⁻¹ - 1\n  constructor\n  case' h.left => have := congr($(hx.mul_val_inv) - 1)\n  case' h.right => have := congr($(hx.val_inv_mul) - 1)\n  all_goals\n    rw [← sub_add_cancel (↑hx.unit⁻¹ : R) 1, sub_self] at this\n    convert this using 1\n    noncomm_ring\n\n-- interestingly, this holds even in the semiring case.\n"}
{"name":"isQuasiregular_iff_isUnit'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nx : A\n⊢ Iff (IsQuasiregular x) (IsUnit (HAdd.hAdd 1 ↑x))","decl":"lemma isQuasiregular_iff_isUnit' (R : Type*) {A : Type*} [CommSemiring R] [NonUnitalSemiring A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] {x : A} :\n    IsQuasiregular x ↔ IsUnit (1 + x : Unitization R A) := by\n  refine ⟨?_, fun hx ↦ ?_⟩\n  · rintro ⟨u, rfl⟩\n    exact (Unitization.unitsFstOne_mulEquiv_quasiregular R).symm u |>.val.isUnit\n  · exact ⟨(Unitization.unitsFstOne_mulEquiv_quasiregular R) ⟨hx.unit, by simp⟩, by simp⟩\n\n"}
{"name":"quasispectrum.not_isUnit_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : NonUnitalRing A\ninst✝ : Module R A\na : A\nr : R\nhr : Not (IsUnit r)\n⊢ Membership.mem (quasispectrum R a) r","decl":"variable {R} in\nlemma quasispectrum.not_isUnit_mem (a : A) {r : R} (hr : ¬ IsUnit r) : r ∈ quasispectrum R a :=\n  fun hr' ↦ (hr hr').elim\n\n"}
{"name":"quasispectrum.zero_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : NonUnitalRing A\ninst✝¹ : Module R A\ninst✝ : Nontrivial R\na : A\n⊢ Membership.mem (quasispectrum R a) 0","decl":"@[simp]\nlemma quasispectrum.zero_mem [Nontrivial R] (a : A) : 0 ∈ quasispectrum R a :=\n  quasispectrum.not_isUnit_mem a <| by simp\n\n"}
{"name":"quasispectrum.nonempty","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : NonUnitalRing A\ninst✝¹ : Module R A\ninst✝ : Nontrivial R\na : A\n⊢ (quasispectrum R a).Nonempty","decl":"theorem quasispectrum.nonempty [Nontrivial R] (a : A) : (quasispectrum R a).Nonempty :=\n  Set.nonempty_of_mem <| quasispectrum.zero_mem R a\n\n"}
{"name":"NonUnitalAlgHom.quasispectrum_apply_subset'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\nA : Type u_6\nB : Type u_7\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : NonUnitalRing B\ninst✝⁸ : Module R S\ninst✝⁷ : Module S A\ninst✝⁶ : Module R A\ninst✝⁵ : Module S B\ninst✝⁴ : Module R B\ninst✝³ : IsScalarTower R S A\ninst✝² : IsScalarTower R S B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgHomClass F S A B\nφ : F\na : A\n⊢ HasSubset.Subset (quasispectrum R (φ a)) (quasispectrum R a)","decl":"/-- A version of `NonUnitalAlgHom.quasispectrum_apply_subset` which allows for `quasispectrum R`,\nwhere `R` is a *semi*ring, but `φ` must still function over a scalar ring `S`. In this case, we\nneed `S` to be explicit. The primary use case is, for instance, `R := ℝ≥0` and `S := ℝ` or\n`S := ℂ`. -/\nlemma NonUnitalAlgHom.quasispectrum_apply_subset' {F R : Type*} (S : Type*) {A B : Type*}\n    [CommSemiring R] [CommRing S] [NonUnitalRing A] [NonUnitalRing B] [Module R S]\n    [Module S A] [Module R A] [Module S B] [Module R B] [IsScalarTower R S A] [IsScalarTower R S B]\n    [FunLike F A B] [NonUnitalAlgHomClass F S A B] (φ : F) (a : A) :\n    quasispectrum R (φ a) ⊆ quasispectrum R a := by\n  refine Set.compl_subset_compl.mp fun x ↦ ?_\n  simp only [quasispectrum, Set.mem_compl_iff, Set.mem_setOf_eq, not_forall, not_not,\n    forall_exists_index]\n  refine fun hx this ↦ ⟨hx, ?_⟩\n  rw [Units.smul_def, ← smul_one_smul S] at this ⊢\n  simpa [- smul_assoc] using this.map φ\n\n"}
{"name":"NonUnitalAlgHom.quasispectrum_apply_subset","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_3\nR : Type u_4\nA : Type u_5\nB : Type u_6\ninst✝⁶ : CommRing R\ninst✝⁵ : NonUnitalRing A\ninst✝⁴ : NonUnitalRing B\ninst✝³ : Module R A\ninst✝² : Module R B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgHomClass F R A B\nφ : F\na : A\n⊢ HasSubset.Subset (quasispectrum R (φ a)) (quasispectrum R a)","decl":"/-- If `φ` is non-unital algebra homomorphism over a scalar ring `R`, then\n`quasispectrum R (φ a) ⊆ quasispectrum R a`. -/\nlemma NonUnitalAlgHom.quasispectrum_apply_subset {F R A B : Type*}\n    [CommRing R] [NonUnitalRing A] [NonUnitalRing B] [Module R A] [Module R B]\n    [FunLike F A B] [NonUnitalAlgHomClass F R A B] (φ : F) (a : A) :\n    quasispectrum R (φ a) ⊆ quasispectrum R a :=\n  NonUnitalAlgHom.quasispectrum_apply_subset' R φ a\n\n"}
{"name":"quasispectrum.coe_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : NonUnitalRing A\ninst✝¹ : Module R A\ninst✝ : Nontrivial R\na : A\n⊢ Eq (↑0) 0","decl":"@[simp]\nlemma quasispectrum.coe_zero [Nontrivial R] (a : A) : (0 : quasispectrum R a) = (0 : R) := rfl\n\n"}
{"name":"quasispectrum.mem_of_not_quasiregular","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : NonUnitalRing A\ninst✝ : Module R A\na : A\nr : Units R\nhr : Not (IsQuasiregular (Neg.neg (HSMul.hSMul (Inv.inv r) a)))\n⊢ Membership.mem (quasispectrum R a) ↑r","decl":"lemma quasispectrum.mem_of_not_quasiregular (a : A) {r : Rˣ}\n    (hr : ¬ IsQuasiregular (-(r⁻¹ • a))) : (r : R) ∈ quasispectrum R a :=\n  fun _ ↦ by simpa using hr\n\n"}
{"name":"quasispectrum_eq_spectrum_union","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ Eq (quasispectrum R a) (Union.union (spectrum R a) (setOf fun r => Not (IsUnit r)))","decl":"lemma quasispectrum_eq_spectrum_union (R : Type*) {A : Type*} [CommSemiring R]\n    [Ring A] [Algebra R A] (a : A) : quasispectrum R a = spectrum R a ∪ {r : R | ¬ IsUnit r} := by\n  ext r\n  rw [quasispectrum]\n  simp only [Set.mem_setOf_eq, Set.mem_union, ← imp_iff_or_not, spectrum.mem_iff]\n  congr! 1 with hr\n  rw [not_iff_not, isQuasiregular_iff_isUnit, ← sub_eq_add_neg, Algebra.algebraMap_eq_smul_one]\n  exact (IsUnit.smul_sub_iff_sub_inv_smul hr.unit a).symm\n\n"}
{"name":"spectrum_subset_quasispectrum","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ HasSubset.Subset (spectrum R a) (quasispectrum R a)","decl":"lemma spectrum_subset_quasispectrum (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]\n    (a : A) : spectrum R a ⊆ quasispectrum R a :=\n  quasispectrum_eq_spectrum_union R a ▸ Set.subset_union_left\n\n"}
{"name":"quasispectrum_eq_spectrum_union_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ Eq (quasispectrum R a) (Union.union (spectrum R a) (Singleton.singleton 0))","decl":"lemma quasispectrum_eq_spectrum_union_zero (R : Type*) {A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] (a : A) : quasispectrum R a = spectrum R a ∪ {0} := by\n  convert quasispectrum_eq_spectrum_union R a\n  ext x\n  simp\n\n"}
{"name":"mem_quasispectrum_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nx : R\n⊢ Iff (Membership.mem (quasispectrum R a) x) (Or (Eq x 0) (Membership.mem (spectrum R a) x))","decl":"lemma mem_quasispectrum_iff {R A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] {a : A} {x : R} :\n    x ∈ quasispectrum R a ↔ x = 0 ∨ x ∈ spectrum R a := by\n  simp [quasispectrum_eq_spectrum_union_zero]\n\n"}
{"name":"Unitization.isQuasiregular_inr_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\na : A\n⊢ Iff (IsQuasiregular ↑a) (IsQuasiregular a)","decl":"lemma isQuasiregular_inr_iff (a : A) :\n    IsQuasiregular (a : Unitization R A) ↔ IsQuasiregular a := by\n  refine ⟨fun ha ↦ ?_, IsQuasiregular.map (inrNonUnitalAlgHom R A)⟩\n  rw [isQuasiregular_iff] at ha ⊢\n  obtain ⟨y, hy₁, hy₂⟩ := ha\n  lift y to A using by simpa using congr(fstHom R A $(hy₁))\n  refine ⟨y, ?_, ?_⟩ <;> exact inr_injective (R := R) <| by simpa\n\n"}
{"name":"Unitization.zero_mem_spectrum_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommRing S\ninst✝⁷ : Nontrivial S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Membership.mem (spectrum R ↑a) 0","decl":"lemma zero_mem_spectrum_inr (R S : Type*) {A : Type*} [CommSemiring R]\n    [CommRing S] [Nontrivial S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    0 ∈ spectrum R (a : Unitization S A) := by\n  rw [spectrum.zero_mem_iff]\n  rintro ⟨u, hu⟩\n  simpa [-Units.mul_inv, hu] using congr($(u.mul_inv).fst)\n\n"}
{"name":"Unitization.mem_spectrum_inr_of_not_isUnit","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\na : A\nr : R\nhr : Not (IsUnit r)\n⊢ Membership.mem (spectrum R ↑a) r","decl":"lemma mem_spectrum_inr_of_not_isUnit {R A : Type*} [CommRing R]\n    [NonUnitalRing A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A]\n    (a : A) (r : R) (hr : ¬ IsUnit r) : r ∈ spectrum R (a : Unitization R A) :=\n  fun h ↦ hr <| by simpa [map_sub] using h.map (fstHom R A)\n\n"}
{"name":"Unitization.quasispectrum_eq_spectrum_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\na : A\n⊢ Eq (quasispectrum R a) (spectrum R ↑a)","decl":"lemma quasispectrum_eq_spectrum_inr (R : Type*) {A : Type*} [CommRing R] [NonUnitalRing A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] (a : A) :\n    quasispectrum R a = spectrum R (a : Unitization R A) := by\n  ext r\n  have : { r | ¬ IsUnit r} ⊆ spectrum R _ := mem_spectrum_inr_of_not_isUnit a\n  rw [← Set.union_eq_left.mpr this, ← quasispectrum_eq_spectrum_union]\n  apply forall_congr' fun hr ↦ ?_\n  rw [not_iff_not, Units.smul_def, Units.smul_def, ← inr_smul, ← inr_neg, isQuasiregular_inr_iff]\n\n"}
{"name":"Unitization.quasispectrum_eq_spectrum_inr'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Eq (quasispectrum R a) (spectrum R ↑a)","decl":"lemma quasispectrum_eq_spectrum_inr' (R S : Type*) {A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    quasispectrum R a = spectrum R (a : Unitization S A) := by\n  ext r\n  have := Set.singleton_subset_iff.mpr (zero_mem_spectrum_inr R S a)\n  rw [← Set.union_eq_self_of_subset_right this, ← quasispectrum_eq_spectrum_union_zero]\n  apply forall_congr' fun x ↦ ?_\n  rw [not_iff_not, Units.smul_def, Units.smul_def, ← inr_smul, ← inr_neg, isQuasiregular_inr_iff]\n\n"}
{"name":"Unitization.quasispectrum_inr_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Eq (quasispectrum R ↑a) (quasispectrum R a)","decl":"lemma quasispectrum_inr_eq (R S : Type*) {A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    quasispectrum R (a : Unitization S A) = quasispectrum R a := by\n  rw [quasispectrum_eq_spectrum_union_zero, quasispectrum_eq_spectrum_inr' R S]\n  apply Set.union_eq_self_of_subset_right\n  simpa using zero_mem_spectrum_inr _ _ _\n\n"}
{"name":"NonnegSpectrumClass.quasispectrum_nonneg_of_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\ninst✝³ : OrderedCommSemiring 𝕜\ninst✝² : NonUnitalRing A\ninst✝¹ : PartialOrder A\ninst✝ : Module 𝕜 A\nself : NonnegSpectrumClass 𝕜 A\na : A\na✝¹ : LE.le 0 a\nx : 𝕜\na✝ : Membership.mem (quasispectrum 𝕜 a) x\n⊢ LE.le 0 x","decl":"/-- A class for `𝕜`-algebras with a partial order where the ordering is compatible with the\n(quasi)spectrum. -/\nclass NonnegSpectrumClass (𝕜 A : Type*) [OrderedCommSemiring 𝕜] [NonUnitalRing A] [PartialOrder A]\n    [Module 𝕜 A] : Prop where\n  quasispectrum_nonneg_of_nonneg : ∀ a : A, 0 ≤ a → ∀ x ∈ quasispectrum 𝕜 a, 0 ≤ x\n\n"}
{"name":"NonnegSpectrumClass.iff_spectrum_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\ninst✝³ : LinearOrderedSemifield 𝕜\ninst✝² : Ring A\ninst✝¹ : PartialOrder A\ninst✝ : Algebra 𝕜 A\n⊢ Iff (NonnegSpectrumClass 𝕜 A) (∀ (a : A), LE.le 0 a → ∀ (x : 𝕜), Membership.mem (spectrum 𝕜 a) x → LE.le 0 x)","decl":"lemma iff_spectrum_nonneg {𝕜 A : Type*} [LinearOrderedSemifield 𝕜] [Ring A] [PartialOrder A]\n    [Algebra 𝕜 A] : NonnegSpectrumClass 𝕜 A ↔ ∀ a : A, 0 ≤ a → ∀ x ∈ spectrum 𝕜 a, 0 ≤ x := by\n  simp [show NonnegSpectrumClass 𝕜 A ↔ _ from ⟨fun ⟨h⟩ ↦ h, (⟨·⟩)⟩,\n    quasispectrum_eq_spectrum_union_zero]\n\n"}
{"name":"NonnegSpectrumClass.of_spectrum_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\ninst✝³ : LinearOrderedSemifield 𝕜\ninst✝² : Ring A\ninst✝¹ : PartialOrder A\ninst✝ : Algebra 𝕜 A\na✝ : ∀ (a : A), LE.le 0 a → ∀ (x : 𝕜), Membership.mem (spectrum 𝕜 a) x → LE.le 0 x\n⊢ NonnegSpectrumClass 𝕜 A","decl":"alias ⟨_, of_spectrum_nonneg⟩ := iff_spectrum_nonneg\n\n"}
{"name":"spectrum_nonneg_of_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\ninst✝⁴ : OrderedCommSemiring 𝕜\ninst✝³ : Ring A\ninst✝² : PartialOrder A\ninst✝¹ : Algebra 𝕜 A\ninst✝ : NonnegSpectrumClass 𝕜 A\na : A\nha : LE.le 0 a\nx : 𝕜\nhx : Membership.mem (spectrum 𝕜 a) x\n⊢ LE.le 0 x","decl":"lemma spectrum_nonneg_of_nonneg {𝕜 A : Type*} [OrderedCommSemiring 𝕜] [Ring A] [PartialOrder A]\n    [Algebra 𝕜 A] [NonnegSpectrumClass 𝕜 A] ⦃a : A⦄ (ha : 0 ≤ a) ⦃x : 𝕜⦄ (hx : x ∈ spectrum 𝕜 a) :\n    0 ≤ x :=\n  NonnegSpectrumClass.quasispectrum_nonneg_of_nonneg a ha x (spectrum_subset_quasispectrum 𝕜 a hx)\n\n"}
{"name":"QuasispectrumRestricts.rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na : A\nf : S → R\nself : QuasispectrumRestricts a f\n⊢ Set.RightInvOn f (⇑(algebraMap R S)) (quasispectrum S a)","decl":"/-- Given an element `a : A` of an `S`-algebra, where `S` is itself an `R`-algebra, we say that\nthe spectrum of `a` restricts via a function `f : S → R` if `f` is a left inverse of\n`algebraMap R S`, and `f` is a right inverse of `algebraMap R S` on `spectrum S a`.\n\nFor example, when `f = Complex.re` (so `S := ℂ` and `R := ℝ`), `SpectrumRestricts a f` means that\nthe `ℂ`-spectrum of `a` is contained within `ℝ`. This arises naturally when `a` is selfadjoint\nand `A` is a C⋆-algebra.\n\nThis is the property allows us to restrict a continuous functional calculus over `S` to a\ncontinuous functional calculus over `R`. -/\nstructure QuasispectrumRestricts\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S → R) : Prop where\n  /-- `f` is a right inverse of `algebraMap R S` when restricted to `quasispectrum S a`. -/\n  rightInvOn : (quasispectrum S a).RightInvOn f (algebraMap R S)\n  /-- `f` is a left inverse of `algebraMap R S`. -/\n  left_inv : Function.LeftInverse f (algebraMap R S)\n\n"}
{"name":"QuasispectrumRestricts.left_inv","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na : A\nf : S → R\nself : QuasispectrumRestricts a f\n⊢ Function.LeftInverse f ⇑(algebraMap R S)","decl":"/-- Given an element `a : A` of an `S`-algebra, where `S` is itself an `R`-algebra, we say that\nthe spectrum of `a` restricts via a function `f : S → R` if `f` is a left inverse of\n`algebraMap R S`, and `f` is a right inverse of `algebraMap R S` on `spectrum S a`.\n\nFor example, when `f = Complex.re` (so `S := ℂ` and `R := ℝ`), `SpectrumRestricts a f` means that\nthe `ℂ`-spectrum of `a` is contained within `ℝ`. This arises naturally when `a` is selfadjoint\nand `A` is a C⋆-algebra.\n\nThis is the property allows us to restrict a continuous functional calculus over `S` to a\ncontinuous functional calculus over `R`. -/\nstructure QuasispectrumRestricts\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S → R) : Prop where\n  /-- `f` is a right inverse of `algebraMap R S` when restricted to `quasispectrum S a`. -/\n  rightInvOn : (quasispectrum S a).RightInvOn f (algebraMap R S)\n  /-- `f` is a left inverse of `algebraMap R S`. -/\n  left_inv : Function.LeftInverse f (algebraMap R S)\n\n"}
{"name":"quasispectrumRestricts_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na : A\nf : S → R\n⊢ Iff (QuasispectrumRestricts a f) (And (Set.RightInvOn f (⇑(algebraMap R S)) (quasispectrum S a)) (Function.LeftInverse f ⇑(algebraMap R S)))","decl":"lemma quasispectrumRestricts_iff\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S → R) :\n    QuasispectrumRestricts a f ↔ (quasispectrum S a).RightInvOn f (algebraMap R S) ∧\n      Function.LeftInverse f (algebraMap R S) :=\n  ⟨fun ⟨h₁, h₂⟩ ↦ ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ ↦ ⟨h₁, h₂⟩⟩\n\n"}
{"name":"quasispectrum.algebraMap_mem_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\nr : R\n⊢ Iff (Membership.mem (quasispectrum S a) ((algebraMap R S) r)) (Membership.mem (quasispectrum R a) r)","decl":"@[simp]\ntheorem quasispectrum.algebraMap_mem_iff (S : Type*) {R A : Type*} [Semifield R] [Field S]\n    [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] {a : A} {r : R} :\n    algebraMap R S r ∈ quasispectrum S a ↔ r ∈ quasispectrum R a := by\n  simp_rw [Unitization.quasispectrum_eq_spectrum_inr' _ S a, spectrum.algebraMap_mem_iff]\n\n"}
{"name":"quasispectrum.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\nr : R\na✝ : Membership.mem (quasispectrum R a) r\n⊢ Membership.mem (quasispectrum S a) ((algebraMap R S) r)","decl":"protected alias ⟨quasispectrum.of_algebraMap_mem, quasispectrum.algebraMap_mem⟩ :=\n  quasispectrum.algebraMap_mem_iff\n\n"}
{"name":"quasispectrum.of_algebraMap_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\nr : R\na✝ : Membership.mem (quasispectrum S a) ((algebraMap R S) r)\n⊢ Membership.mem (quasispectrum R a) r","decl":"protected alias ⟨quasispectrum.of_algebraMap_mem, quasispectrum.algebraMap_mem⟩ :=\n  quasispectrum.algebraMap_mem_iff\n\n"}
{"name":"quasispectrum.preimage_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module S A\ninst✝³ : IsScalarTower S A A\ninst✝² : SMulCommClass S A A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Eq (Set.preimage (⇑(algebraMap R S)) (quasispectrum S a)) (quasispectrum R a)","decl":"@[simp]\ntheorem quasispectrum.preimage_algebraMap (S : Type*) {R A : Type*} [Semifield R] [Field S]\n    [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] {a : A} :\n    algebraMap R S ⁻¹' quasispectrum S a = quasispectrum R a :=\n  Set.ext fun _ => quasispectrum.algebraMap_mem_iff _\n\n"}
{"name":"QuasispectrumRestricts.map_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Field S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na : A\nf : S → R\nh : QuasispectrumRestricts a f\n⊢ Eq (f 0) 0","decl":"protected theorem map_zero (h : QuasispectrumRestricts a f) : f 0 = 0 := by\n  rw [← h.left_inv 0, map_zero (algebraMap R S)]\n\n"}
{"name":"QuasispectrumRestricts.of_subset_range_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Field S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na : A\nf : S → R\nhf : Function.LeftInverse f ⇑(algebraMap R S)\nh : HasSubset.Subset (quasispectrum S a) (Set.range ⇑(algebraMap R S))\n⊢ QuasispectrumRestricts a f","decl":"theorem of_subset_range_algebraMap (hf : f.LeftInverse (algebraMap R S))\n    (h : quasispectrum S a ⊆ Set.range (algebraMap R S)) : QuasispectrumRestricts a f where\n  rightInvOn := fun s hs => by obtain ⟨r, rfl⟩ := h hs; rw [hf r]\n  left_inv := hf\n\n"}
{"name":"QuasispectrumRestricts.of_quasispectrum_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Field S\ninst✝³ : NonUnitalRing A\ninst✝² : Module R A\ninst✝¹ : Module S A\ninst✝ : Algebra R S\na b : A\nf : S → R\nha : QuasispectrumRestricts a f\nh : Eq (quasispectrum S a) (quasispectrum S b)\n⊢ QuasispectrumRestricts b f","decl":"lemma of_quasispectrum_eq {a b : A} {f : S → R} (ha : QuasispectrumRestricts a f)\n    (h : quasispectrum S a = quasispectrum S b) : QuasispectrumRestricts b f where\n  rightInvOn := h ▸ ha.rightInvOn\n  left_inv := ha.left_inv\n\n"}
{"name":"QuasispectrumRestricts.algebraMap_image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Module R A\ninst✝⁴ : Module S A\ninst✝³ : Algebra R S\na : A\nf : S → R\ninst✝² : IsScalarTower S A A\ninst✝¹ : SMulCommClass S A A\ninst✝ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\n⊢ Eq (Set.image (⇑(algebraMap R S)) (quasispectrum R a)) (quasispectrum S a)","decl":"theorem algebraMap_image (h : QuasispectrumRestricts a f) :\n    algebraMap R S '' quasispectrum R a = quasispectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => ⟨f s, ?_⟩\n  · simpa only [quasispectrum.preimage_algebraMap] using\n      (quasispectrum S a).image_preimage_subset (algebraMap R S)\n  exact ⟨quasispectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm ▸ hs), h.rightInvOn hs⟩\n\n"}
{"name":"QuasispectrumRestricts.image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Module R A\ninst✝⁴ : Module S A\ninst✝³ : Algebra R S\na : A\nf : S → R\ninst✝² : IsScalarTower S A A\ninst✝¹ : SMulCommClass S A A\ninst✝ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\n⊢ Eq (Set.image f (quasispectrum S a)) (quasispectrum R a)","decl":"theorem image (h : QuasispectrumRestricts a f) : f '' quasispectrum S a = quasispectrum R a := by\n  simp only [← h.algebraMap_image, Set.image_image, h.left_inv _, Set.image_id']\n\n"}
{"name":"QuasispectrumRestricts.apply_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Module R A\ninst✝⁴ : Module S A\ninst✝³ : Algebra R S\na : A\nf : S → R\ninst✝² : IsScalarTower S A A\ninst✝¹ : SMulCommClass S A A\ninst✝ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\ns : S\nhs : Membership.mem (quasispectrum S a) s\n⊢ Membership.mem (quasispectrum R a) (f s)","decl":"theorem apply_mem (h : QuasispectrumRestricts a f) {s : S} (hs : s ∈ quasispectrum S a) :\n    f s ∈ quasispectrum R a :=\n  h.image ▸ ⟨s, hs, rfl⟩\n\n"}
{"name":"QuasispectrumRestricts.subset_preimage","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Module R A\ninst✝⁴ : Module S A\ninst✝³ : Algebra R S\na : A\nf : S → R\ninst✝² : IsScalarTower S A A\ninst✝¹ : SMulCommClass S A A\ninst✝ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\n⊢ HasSubset.Subset (quasispectrum S a) (Set.preimage f (quasispectrum R a))","decl":"theorem subset_preimage (h : QuasispectrumRestricts a f) :\n    quasispectrum S a ⊆ f ⁻¹' quasispectrum R a :=\n  h.image ▸ (quasispectrum S a).subset_preimage_image f\n\n"}
{"name":"QuasispectrumRestricts.comp","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R₁ : Type u_6\nR₂ : Type u_7\nR₃ : Type u_8\nA : Type u_9\ninst✝¹³ : Semifield R₁\ninst✝¹² : Field R₂\ninst✝¹¹ : Field R₃\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : Module R₁ A\ninst✝⁸ : Module R₂ A\ninst✝⁷ : Module R₃ A\ninst✝⁶ : Algebra R₁ R₂\ninst✝⁵ : Algebra R₂ R₃\ninst✝⁴ : Algebra R₁ R₃\ninst✝³ : IsScalarTower R₁ R₂ R₃\ninst✝² : IsScalarTower R₂ R₃ A\ninst✝¹ : IsScalarTower R₃ A A\ninst✝ : SMulCommClass R₃ A A\na : A\nf : R₃ → R₂\ng : R₂ → R₁\ne : R₃ → R₁\nhfge : Eq (Function.comp g f) e\nhf : QuasispectrumRestricts a f\nhg : QuasispectrumRestricts a g\n⊢ QuasispectrumRestricts a e","decl":"protected lemma comp {R₁ R₂ R₃ A : Type*} [Semifield R₁] [Field R₂] [Field R₃]\n    [NonUnitalRing A] [Module R₁ A] [Module R₂ A] [Module R₃ A] [Algebra R₁ R₂] [Algebra R₂ R₃]\n    [Algebra R₁ R₃] [IsScalarTower R₁ R₂ R₃] [IsScalarTower R₂ R₃ A] [IsScalarTower R₃ A A]\n    [SMulCommClass R₃ A A] {a : A} {f : R₃ → R₂} {g : R₂ → R₁} {e : R₃ → R₁} (hfge : g ∘ f = e)\n    (hf : QuasispectrumRestricts a f) (hg : QuasispectrumRestricts a g) :\n    QuasispectrumRestricts a e where\n  left_inv := by\n    convert hfge ▸ hf.left_inv.comp hg.left_inv\n    congrm(⇑$(IsScalarTower.algebraMap_eq R₁ R₂ R₃))\n  rightInvOn := by\n    convert hfge ▸ hg.rightInvOn.comp hf.rightInvOn fun _ ↦ hf.apply_mem\n    congrm(⇑$(IsScalarTower.algebraMap_eq R₁ R₂ R₃))\n\n"}
{"name":"SpectrumRestricts.rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na : A\nf : S → R\nh : SpectrumRestricts a f\n⊢ Set.RightInvOn f (⇑(algebraMap R S)) (spectrum S a)","decl":"theorem rightInvOn (h : SpectrumRestricts a f) : (spectrum S a).RightInvOn f (algebraMap R S) :=\n  (QuasispectrumRestricts.rightInvOn h).mono <| spectrum_subset_quasispectrum _ _\n\n"}
{"name":"SpectrumRestricts.of_rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na : A\nf : S → R\nh₁ : Function.LeftInverse f ⇑(algebraMap R S)\nh₂ : Set.RightInvOn f (⇑(algebraMap R S)) (spectrum S a)\n⊢ SpectrumRestricts a f","decl":"theorem of_rightInvOn (h₁ : Function.LeftInverse f (algebraMap R S))\n    (h₂ : (spectrum S a).RightInvOn f (algebraMap R S)) : SpectrumRestricts a f where\n  rightInvOn x hx := by\n    obtain (rfl | hx) := mem_quasispectrum_iff.mp hx\n    · simpa using h₁ 0\n    · exact h₂ hx\n  left_inv := h₁\n\n"}
{"name":"spectrumRestricts_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na : A\nf : S → R\n⊢ Iff (SpectrumRestricts a f) (And (Set.RightInvOn f (⇑(algebraMap R S)) (spectrum S a)) (Function.LeftInverse f ⇑(algebraMap R S)))","decl":"lemma _root_.spectrumRestricts_iff :\n    SpectrumRestricts a f ↔ (spectrum S a).RightInvOn f (algebraMap R S) ∧\n      Function.LeftInverse f (algebraMap R S) :=\n  ⟨fun h ↦ ⟨h.rightInvOn, h.left_inv⟩, fun h ↦ .of_rightInvOn h.2 h.1⟩\n\n"}
{"name":"SpectrumRestricts.of_subset_range_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na : A\nf : S → R\nhf : Function.LeftInverse f ⇑(algebraMap R S)\nh : HasSubset.Subset (spectrum S a) (Set.range ⇑(algebraMap R S))\n⊢ SpectrumRestricts a f","decl":"theorem of_subset_range_algebraMap (hf : f.LeftInverse (algebraMap R S))\n    (h : spectrum S a ⊆ Set.range (algebraMap R S)) : SpectrumRestricts a f where\n  rightInvOn := fun s hs => by\n    rw [mem_quasispectrum_iff] at hs\n    obtain (rfl | hs) := hs\n    · simpa using hf 0\n    · obtain ⟨r, rfl⟩ := h hs\n      rw [hf r]\n  left_inv := hf\n\n"}
{"name":"SpectrumRestricts.of_spectrum_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na b : A\nf : S → R\nha : SpectrumRestricts a f\nh : Eq (spectrum S a) (spectrum S b)\n⊢ SpectrumRestricts b f","decl":"lemma of_spectrum_eq {a b : A} {f : S → R} (ha : SpectrumRestricts a f)\n    (h : spectrum S a = spectrum S b) : SpectrumRestricts b f where\n  rightInvOn :=  by\n    rw [quasispectrum_eq_spectrum_union_zero, ← h, ← quasispectrum_eq_spectrum_union_zero]\n    exact QuasispectrumRestricts.rightInvOn ha\n  left_inv := ha.left_inv\n\n"}
{"name":"SpectrumRestricts.algebraMap_image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : Semifield R\ninst✝⁵ : Semifield S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\na : A\nf : S → R\ninst✝ : IsScalarTower R S A\nh : SpectrumRestricts a f\n⊢ Eq (Set.image (⇑(algebraMap R S)) (spectrum R a)) (spectrum S a)","decl":"theorem algebraMap_image (h : SpectrumRestricts a f) :\n    algebraMap R S '' spectrum R a = spectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => ⟨f s, ?_⟩\n  · simpa only [spectrum.preimage_algebraMap] using\n      (spectrum S a).image_preimage_subset (algebraMap R S)\n  exact ⟨spectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm ▸ hs), h.rightInvOn hs⟩\n\n"}
{"name":"SpectrumRestricts.image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : Semifield R\ninst✝⁵ : Semifield S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\na : A\nf : S → R\ninst✝ : IsScalarTower R S A\nh : SpectrumRestricts a f\n⊢ Eq (Set.image f (spectrum S a)) (spectrum R a)","decl":"theorem image (h : SpectrumRestricts a f) : f '' spectrum S a = spectrum R a := by\n  simp only [← h.algebraMap_image, Set.image_image, h.left_inv _, Set.image_id']\n\n"}
{"name":"SpectrumRestricts.apply_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : Semifield R\ninst✝⁵ : Semifield S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\na : A\nf : S → R\ninst✝ : IsScalarTower R S A\nh : SpectrumRestricts a f\ns : S\nhs : Membership.mem (spectrum S a) s\n⊢ Membership.mem (spectrum R a) (f s)","decl":"theorem apply_mem (h : SpectrumRestricts a f) {s : S} (hs : s ∈ spectrum S a) :\n    f s ∈ spectrum R a :=\n  h.image ▸ ⟨s, hs, rfl⟩\n\n"}
{"name":"SpectrumRestricts.subset_preimage","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : Semifield R\ninst✝⁵ : Semifield S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\na : A\nf : S → R\ninst✝ : IsScalarTower R S A\nh : SpectrumRestricts a f\n⊢ HasSubset.Subset (spectrum S a) (Set.preimage f (spectrum R a))","decl":"theorem subset_preimage (h : SpectrumRestricts a f) : spectrum S a ⊆ f ⁻¹' spectrum R a :=\n  h.image ▸ (spectrum S a).subset_preimage_image f\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninst✝⁸ : Semifield R\ninst✝⁷ : Field S\ninst✝⁶ : NonUnitalRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module R A\ninst✝³ : Module S A\ninst✝² : IsScalarTower S A A\ninst✝¹ : SMulCommClass S A A\ninst✝ : IsScalarTower R S A\na : A\nf : S → R\n⊢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts (↑a) f)","decl":"theorem quasispectrumRestricts_iff_spectrumRestricts_inr (S : Type*) {R A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [IsScalarTower R S A] {a : A} {f : S → R} :\n    QuasispectrumRestricts a f ↔ SpectrumRestricts (a : Unitization S A) f := by\n  rw [quasispectrumRestricts_iff, spectrumRestricts_iff,\n    ← Unitization.quasispectrum_eq_spectrum_inr']\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts_inr'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS' : Type u_4\nA : Type u_5\nS : Type u_6\ninst✝¹³ : Semifield R\ninst✝¹² : Semifield S'\ninst✝¹¹ : Field S\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : Module R A\ninst✝⁸ : Module S' A\ninst✝⁷ : Module S A\ninst✝⁶ : IsScalarTower S A A\ninst✝⁵ : SMulCommClass S A A\ninst✝⁴ : Algebra R S'\ninst✝³ : Algebra S' S\ninst✝² : Algebra R S\ninst✝¹ : IsScalarTower S' S A\ninst✝ : IsScalarTower R S A\na : A\nf : S' → R\n⊢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts (↑a) f)","decl":"/-- The difference from `quasispectrumRestricts_iff_spectrumRestricts_inr` is that the\n`Unitization` may be taken with respect to a different scalar field. -/\nlemma quasispectrumRestricts_iff_spectrumRestricts_inr'\n    {R S' A : Type*} (S : Type*) [Semifield R] [Semifield S'] [Field S] [NonUnitalRing A]\n    [Module R A] [Module S' A] [Module S A] [IsScalarTower S A A] [SMulCommClass S A A]\n    [Algebra R S'] [Algebra S' S] [Algebra R S] [IsScalarTower S' S A] [IsScalarTower R S A]\n    {a : A} {f : S' → R} :\n    QuasispectrumRestricts a f ↔ SpectrumRestricts (a : Unitization S A) f := by\n  simp only [quasispectrumRestricts_iff, SpectrumRestricts, Unitization.quasispectrum_inr_eq]\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁵ : Semifield R\ninst✝⁴ : Semifield S\ninst✝³ : Ring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\na : A\nf : S → R\n⊢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts a f)","decl":"theorem quasispectrumRestricts_iff_spectrumRestricts {R S A : Type*} [Semifield R] [Semifield S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S → R} :\n    QuasispectrumRestricts a f ↔ SpectrumRestricts a f := by rfl\n"}
