{"name":"PreQuasiregular.mk.sizeOf_spec","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : SizeOf R\nval : R\nâŠ¢ Eq (SizeOf.sizeOf { val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y â†¦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.mk.injEq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nvalâœ val : R\nâŠ¢ Eq (Eq { val := valâœ } { val := val }) (Eq valâœ val)","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y â†¦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.mk.inj","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nvalâœ val : R\nxâœ : Eq { val := valâœ } { val := val }\nâŠ¢ Eq valâœ val","decl":"/-- A type synonym for non-unital rings where an alternative monoid structure is introduced.\nIf `R` is a non-unital semiring, then `PreQuasiregular R` is equipped with the monoid structure\nwith binary operation `fun x y â†¦ y + x + x * y` and identity `0`. Elements of `R` which are\ninvertible in this monoid satisfy the predicate `IsQuasiregular`. -/\nstructure PreQuasiregular (R : Type*) where\n  /-- The value wrapped into a term of `PreQuasiregular`. -/\n  val : R\n\n"}
{"name":"PreQuasiregular.equiv_apply_val","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nval : R\nâŠ¢ Eq (PreQuasiregular.equiv val).val val","decl":"/-- The identity map between `R` and `PreQuasiregular R`. -/\n@[simps]\ndef equiv : R â‰ƒ PreQuasiregular R where\n  toFun := .mk\n  invFun := PreQuasiregular.val\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PreQuasiregular.equiv_symm_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nself : PreQuasiregular R\nâŠ¢ Eq (PreQuasiregular.equiv.symm self) self.val","decl":"/-- The identity map between `R` and `PreQuasiregular R`. -/\n@[simps]\ndef equiv : R â‰ƒ PreQuasiregular R where\n  toFun := .mk\n  invFun := PreQuasiregular.val\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"PreQuasiregular.val_one","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : NonUnitalSemiring R\nâŠ¢ Eq (PreQuasiregular.val 1) 0","decl":"@[simp]\nlemma val_one : (1 : PreQuasiregular R).val = 0 := rfl\n\n"}
{"name":"PreQuasiregular.val_mul","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : NonUnitalSemiring R\nx y : PreQuasiregular R\nâŠ¢ Eq (HMul.hMul x y).val (HAdd.hAdd (HAdd.hAdd y.val x.val) (HMul.hMul x.val y.val))","decl":"@[simp]\nlemma val_mul (x y : PreQuasiregular R) : (x * y).val = y.val + x.val + x.val * y.val := rfl\n\n"}
{"name":"PreQuasiregular.inv_add_add_mul_eq_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : NonUnitalSemiring R\nu : Units (PreQuasiregular R)\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (â†‘(Inv.inv u)).val (â†‘u).val) (HMul.hMul (â†‘u).val (â†‘(Inv.inv u)).val)) 0","decl":"@[simp]\nlemma inv_add_add_mul_eq_zero (u : (PreQuasiregular R)Ë£) :\n    uâ»Â¹.val.val + u.val.val + u.val.val * uâ»Â¹.val.val = 0 := by\n  simpa [-Units.mul_inv] using congr($(u.mul_inv).val)\n\n"}
{"name":"PreQuasiregular.add_inv_add_mul_eq_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : NonUnitalSemiring R\nu : Units (PreQuasiregular R)\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (â†‘u).val (â†‘(Inv.inv u)).val) (HMul.hMul (â†‘(Inv.inv u)).val (â†‘u).val)) 0","decl":"@[simp]\nlemma add_inv_add_mul_eq_zero (u : (PreQuasiregular R)Ë£) :\n    u.val.val + uâ»Â¹.val.val + uâ»Â¹.val.val * u.val.val = 0 := by\n  simpa [-Units.inv_mul] using congr($(u.inv_mul).val)\n\n"}
{"name":"Unitization.mem_unitsFstOne","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Units (Unitization R A)\nâŠ¢ Iff (Membership.mem (Unitization.unitsFstOne R A) x) (Eq (â†‘x).fst 1)","decl":"@[simp]\nlemma mem_unitsFstOne {x : (Unitization R A)Ë£} : x âˆˆ unitsFstOne R A â†” x.val.fst = 1 := Iff.rfl\n\n"}
{"name":"Unitization.unitsFstOne_val_val_fst","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\nâŠ¢ Eq (â†‘â†‘x).fst 1","decl":"@[simp]\nlemma unitsFstOne_val_val_fst (x : (unitsFstOne R A)) : x.val.val.fst = 1 :=\n  mem_unitsFstOne.mp x.property\n\n"}
{"name":"Unitization.unitsFstOne_val_inv_val_fst","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\nâŠ¢ Eq (â†‘(Inv.inv â†‘x)).fst 1","decl":"@[simp]\nlemma unitsFstOne_val_inv_val_fst (x : (unitsFstOne R A)) : x.valâ»Â¹.val.fst = 1 :=\n  mem_unitsFstOne.mp xâ»Â¹.property\n\n"}
{"name":"Unitization.val_inv_unitsFstOne_mulEquiv_quasiregular_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\nâŠ¢ Eq (â†‘(Inv.inv ((Unitization.unitsFstOne_mulEquiv_quasiregular R) x))) (PreQuasiregular.equiv (â†‘â†‘(Inv.inv x)).snd)","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A â‰ƒ* (PreQuasiregular A)Ë£ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv xâ»Â¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm xâ»Â¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_inv_unitsFstOne_mulEquiv_quasiregular_symm_apply_coe","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Units (PreQuasiregular A)\nâŠ¢ Eq (â†‘(Inv.inv â†‘((Unitization.unitsFstOne_mulEquiv_quasiregular R).symm x))) (HAdd.hAdd 1 â†‘(PreQuasiregular.equiv.symm â†‘(Inv.inv x)))","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A â‰ƒ* (PreQuasiregular A)Ë£ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv xâ»Â¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm xâ»Â¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_unitsFstOne_mulEquiv_quasiregular_apply","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Subtype fun x => Membership.mem (Unitization.unitsFstOne R A) x\nâŠ¢ Eq (â†‘((Unitization.unitsFstOne_mulEquiv_quasiregular R) x)) (PreQuasiregular.equiv (â†‘â†‘x).snd)","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A â‰ƒ* (PreQuasiregular A)Ë£ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv xâ»Â¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm xâ»Â¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"Unitization.val_unitsFstOne_mulEquiv_quasiregular_symm_apply_coe","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : Units (PreQuasiregular A)\nâŠ¢ Eq (â†‘â†‘((Unitization.unitsFstOne_mulEquiv_quasiregular R).symm x)) (HAdd.hAdd 1 â†‘(PreQuasiregular.equiv.symm â†‘x))","decl":"variable (R) in\n/-- If `A` is a non-unital `R`-algebra, then the subgroup of units of `Unitization R A` whose\nscalar part is `1 : R` (i.e., `Unitization.unitsFstOne`) is isomorphic to the group of units of\n`PreQuasiregular A`. -/\n@[simps]\ndef unitsFstOne_mulEquiv_quasiregular : unitsFstOne R A â‰ƒ* (PreQuasiregular A)Ë£ where\n  toFun x :=\n    { val := equiv x.val.val.snd\n      inv := equiv xâ»Â¹.val.val.snd\n      val_inv := equiv.symm.injective <| by\n        simpa [-Units.mul_inv] using congr(snd $(x.val.mul_inv))\n      inv_val := equiv.symm.injective <| by\n        simpa [-Units.inv_mul] using congr(snd $(x.val.inv_mul)) }\n  invFun x :=\n    { val :=\n      { val := 1 + equiv.symm x.val\n        inv := 1 + equiv.symm xâ»Â¹.val\n        val_inv := by\n          convert congr((1 + $(inv_add_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero]\n        inv_val := by\n          convert congr((1 + $(add_inv_add_mul_eq_zero x) : Unitization R A)) using 1\n          Â· simp only [mul_one, equiv_symm_apply, one_mul, inr_zero, add_zero, mul_add, add_mul,\n              inr_add, inr_mul]\n            abel\n          Â· simp only [inr_zero, add_zero] }\n      property := by simp }\n  left_inv x := Subtype.ext <| Units.ext <| by simpa using x.val.val.inl_fst_add_inr_snd_eq\n  right_inv x := Units.ext <| by simp [-equiv_symm_apply]\n  map_mul' x y := Units.ext <| equiv.symm.injective <| by simp\n\n"}
{"name":"isQuasiregular_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"âŠ¢ IsQuasiregular 0","decl":"@[simp]\nlemma isQuasiregular_zero : IsQuasiregular 0 := âŸ¨1, rflâŸ©\n\n"}
{"name":"isQuasiregular_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : NonUnitalSemiring R\nx : R\nâŠ¢ Iff (IsQuasiregular x) (Exists fun y => And (Eq (HAdd.hAdd (HAdd.hAdd y x) (HMul.hMul x y)) 0) (Eq (HAdd.hAdd (HAdd.hAdd x y) (HMul.hMul y x)) 0))","decl":"lemma isQuasiregular_iff {x : R} :\n    IsQuasiregular x â†” âˆƒ y, y + x + x * y = 0 âˆ§ x + y + y * x = 0 := by\n  constructor\n  Â· rintro âŸ¨u, rflâŸ©\n    exact âŸ¨equiv.symm uâ»Â¹.val, by simpâŸ©\n  Â· rintro âŸ¨y, hyâ‚, hyâ‚‚âŸ©\n    refine âŸ¨âŸ¨equiv x, equiv y, ?_, ?_âŸ©, rflâŸ©\n    all_goals\n      apply equiv.symm.injective\n      assumption\n\n"}
{"name":"IsQuasiregular.map","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\ninstâœÂ³ : NonUnitalSemiring R\ninstâœÂ² : NonUnitalSemiring S\ninstâœÂ¹ : FunLike F R S\ninstâœ : NonUnitalRingHomClass F R S\nf : F\nx : R\nhx : IsQuasiregular x\nâŠ¢ IsQuasiregular (f x)","decl":"lemma IsQuasiregular.map {F R S : Type*} [NonUnitalSemiring R] [NonUnitalSemiring S]\n    [FunLike F R S] [NonUnitalRingHomClass F R S] (f : F) {x : R} (hx : IsQuasiregular x) :\n    IsQuasiregular (f x) := by\n  rw [isQuasiregular_iff] at hx âŠ¢\n  obtain âŸ¨y, hyâ‚, hyâ‚‚âŸ© := hx\n  exact âŸ¨f y, by simpa using And.intro congr(f $(hyâ‚)) congr(f $(hyâ‚‚))âŸ©\n\n"}
{"name":"IsQuasiregular.isUnit_one_add","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : Semiring R\nx : R\nhx : IsQuasiregular x\nâŠ¢ IsUnit (HAdd.hAdd 1 x)","decl":"lemma IsQuasiregular.isUnit_one_add {R : Type*} [Semiring R] {x : R} (hx : IsQuasiregular x) :\n    IsUnit (1 + x) := by\n  obtain âŸ¨y, hyâ‚, hyâ‚‚âŸ© := isQuasiregular_iff.mp hx\n  refine âŸ¨âŸ¨1 + x, 1 + y, ?_, ?_âŸ©, rflâŸ©\n  Â· convert congr(1 + $(hyâ‚)) using 1 <;> [noncomm_ring; simp]\n  Â· convert congr(1 + $(hyâ‚‚)) using 1 <;> [noncomm_ring; simp]\n\n"}
{"name":"isQuasiregular_iff_isUnit","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\ninstâœ : Ring R\nx : R\nâŠ¢ Iff (IsQuasiregular x) (IsUnit (HAdd.hAdd 1 x))","decl":"lemma isQuasiregular_iff_isUnit {R : Type*} [Ring R] {x : R} :\n    IsQuasiregular x â†” IsUnit (1 + x) := by\n  refine âŸ¨IsQuasiregular.isUnit_one_add, fun hx â†¦ ?_âŸ©\n  rw [isQuasiregular_iff]\n  use hx.unitâ»Â¹ - 1\n  constructor\n  case' h.left => have := congr($(hx.mul_val_inv) - 1)\n  case' h.right => have := congr($(hx.val_inv_mul) - 1)\n  all_goals\n    rw [â† sub_add_cancel (â†‘hx.unitâ»Â¹ : R) 1, sub_self] at this\n    convert this using 1\n    noncomm_ring\n\n-- interestingly, this holds even in the semiring case.\n"}
{"name":"isQuasiregular_iff_isUnit'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalSemiring A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\nx : A\nâŠ¢ Iff (IsQuasiregular x) (IsUnit (HAdd.hAdd 1 â†‘x))","decl":"lemma isQuasiregular_iff_isUnit' (R : Type*) {A : Type*} [CommSemiring R] [NonUnitalSemiring A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] {x : A} :\n    IsQuasiregular x â†” IsUnit (1 + x : Unitization R A) := by\n  refine âŸ¨?_, fun hx â†¦ ?_âŸ©\n  Â· rintro âŸ¨u, rflâŸ©\n    exact (Unitization.unitsFstOne_mulEquiv_quasiregular R).symm u |>.val.isUnit\n  Â· exact âŸ¨(Unitization.unitsFstOne_mulEquiv_quasiregular R) âŸ¨hx.unit, by simpâŸ©, by simpâŸ©\n\n"}
{"name":"quasispectrum.not_isUnit_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : NonUnitalRing A\ninstâœ : Module R A\na : A\nr : R\nhr : Not (IsUnit r)\nâŠ¢ Membership.mem (quasispectrum R a) r","decl":"variable {R} in\nlemma quasispectrum.not_isUnit_mem (a : A) {r : R} (hr : Â¬ IsUnit r) : r âˆˆ quasispectrum R a :=\n  fun hr' â†¦ (hr hr').elim\n\n"}
{"name":"quasispectrum.zero_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : Module R A\ninstâœ : Nontrivial R\na : A\nâŠ¢ Membership.mem (quasispectrum R a) 0","decl":"@[simp]\nlemma quasispectrum.zero_mem [Nontrivial R] (a : A) : 0 âˆˆ quasispectrum R a :=\n  quasispectrum.not_isUnit_mem a <| by simp\n\n"}
{"name":"quasispectrum.nonempty","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : Module R A\ninstâœ : Nontrivial R\na : A\nâŠ¢ (quasispectrum R a).Nonempty","decl":"theorem quasispectrum.nonempty [Nontrivial R] (a : A) : (quasispectrum R a).Nonempty :=\n  Set.nonempty_of_mem <| quasispectrum.zero_mem R a\n\n"}
{"name":"NonUnitalAlgHom.quasispectrum_apply_subset'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\nA : Type u_6\nB : Type u_7\ninstâœÂ¹Â² : CommSemiring R\ninstâœÂ¹Â¹ : CommRing S\ninstâœÂ¹â° : NonUnitalRing A\ninstâœâ¹ : NonUnitalRing B\ninstâœâ¸ : Module R S\ninstâœâ· : Module S A\ninstâœâ¶ : Module R A\ninstâœâµ : Module S B\ninstâœâ´ : Module R B\ninstâœÂ³ : IsScalarTower R S A\ninstâœÂ² : IsScalarTower R S B\ninstâœÂ¹ : FunLike F A B\ninstâœ : NonUnitalAlgHomClass F S A B\nÏ† : F\na : A\nâŠ¢ HasSubset.Subset (quasispectrum R (Ï† a)) (quasispectrum R a)","decl":"/-- A version of `NonUnitalAlgHom.quasispectrum_apply_subset` which allows for `quasispectrum R`,\nwhere `R` is a *semi*ring, but `Ï†` must still function over a scalar ring `S`. In this case, we\nneed `S` to be explicit. The primary use case is, for instance, `R := â„â‰¥0` and `S := â„` or\n`S := â„‚`. -/\nlemma NonUnitalAlgHom.quasispectrum_apply_subset' {F R : Type*} (S : Type*) {A B : Type*}\n    [CommSemiring R] [CommRing S] [NonUnitalRing A] [NonUnitalRing B] [Module R S]\n    [Module S A] [Module R A] [Module S B] [Module R B] [IsScalarTower R S A] [IsScalarTower R S B]\n    [FunLike F A B] [NonUnitalAlgHomClass F S A B] (Ï† : F) (a : A) :\n    quasispectrum R (Ï† a) âŠ† quasispectrum R a := by\n  refine Set.compl_subset_compl.mp fun x â†¦ ?_\n  simp only [quasispectrum, Set.mem_compl_iff, Set.mem_setOf_eq, not_forall, not_not,\n    forall_exists_index]\n  refine fun hx this â†¦ âŸ¨hx, ?_âŸ©\n  rw [Units.smul_def, â† smul_one_smul S] at this âŠ¢\n  simpa [- smul_assoc] using this.map Ï†\n\n"}
{"name":"NonUnitalAlgHom.quasispectrum_apply_subset","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"F : Type u_3\nR : Type u_4\nA : Type u_5\nB : Type u_6\ninstâœâ¶ : CommRing R\ninstâœâµ : NonUnitalRing A\ninstâœâ´ : NonUnitalRing B\ninstâœÂ³ : Module R A\ninstâœÂ² : Module R B\ninstâœÂ¹ : FunLike F A B\ninstâœ : NonUnitalAlgHomClass F R A B\nÏ† : F\na : A\nâŠ¢ HasSubset.Subset (quasispectrum R (Ï† a)) (quasispectrum R a)","decl":"/-- If `Ï†` is non-unital algebra homomorphism over a scalar ring `R`, then\n`quasispectrum R (Ï† a) âŠ† quasispectrum R a`. -/\nlemma NonUnitalAlgHom.quasispectrum_apply_subset {F R A B : Type*}\n    [CommRing R] [NonUnitalRing A] [NonUnitalRing B] [Module R A] [Module R B]\n    [FunLike F A B] [NonUnitalAlgHomClass F R A B] (Ï† : F) (a : A) :\n    quasispectrum R (Ï† a) âŠ† quasispectrum R a :=\n  NonUnitalAlgHom.quasispectrum_apply_subset' R Ï† a\n\n"}
{"name":"quasispectrum.coe_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : Module R A\ninstâœ : Nontrivial R\na : A\nâŠ¢ Eq (â†‘0) 0","decl":"@[simp]\nlemma quasispectrum.coe_zero [Nontrivial R] (a : A) : (0 : quasispectrum R a) = (0 : R) := rfl\n\n"}
{"name":"quasispectrum.mem_of_not_quasiregular","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : NonUnitalRing A\ninstâœ : Module R A\na : A\nr : Units R\nhr : Not (IsQuasiregular (Neg.neg (HSMul.hSMul (Inv.inv r) a)))\nâŠ¢ Membership.mem (quasispectrum R a) â†‘r","decl":"lemma quasispectrum.mem_of_not_quasiregular (a : A) {r : RË£}\n    (hr : Â¬ IsQuasiregular (-(râ»Â¹ â€¢ a))) : (r : R) âˆˆ quasispectrum R a :=\n  fun _ â†¦ by simpa using hr\n\n"}
{"name":"quasispectrum_eq_spectrum_union","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ Eq (quasispectrum R a) (Union.union (spectrum R a) (setOf fun r => Not (IsUnit r)))","decl":"lemma quasispectrum_eq_spectrum_union (R : Type*) {A : Type*} [CommSemiring R]\n    [Ring A] [Algebra R A] (a : A) : quasispectrum R a = spectrum R a âˆª {r : R | Â¬ IsUnit r} := by\n  ext r\n  rw [quasispectrum]\n  simp only [Set.mem_setOf_eq, Set.mem_union, â† imp_iff_or_not, spectrum.mem_iff]\n  congr! 1 with hr\n  rw [not_iff_not, isQuasiregular_iff_isUnit, â† sub_eq_add_neg, Algebra.algebraMap_eq_smul_one]\n  exact (IsUnit.smul_sub_iff_sub_inv_smul hr.unit a).symm\n\n"}
{"name":"spectrum_subset_quasispectrum","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ HasSubset.Subset (spectrum R a) (quasispectrum R a)","decl":"lemma spectrum_subset_quasispectrum (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]\n    (a : A) : spectrum R a âŠ† quasispectrum R a :=\n  quasispectrum_eq_spectrum_union R a â–¸ Set.subset_union_left\n\n"}
{"name":"quasispectrum_eq_spectrum_union_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ Eq (quasispectrum R a) (Union.union (spectrum R a) (Singleton.singleton 0))","decl":"lemma quasispectrum_eq_spectrum_union_zero (R : Type*) {A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] (a : A) : quasispectrum R a = spectrum R a âˆª {0} := by\n  convert quasispectrum_eq_spectrum_union R a\n  ext x\n  simp\n\n"}
{"name":"mem_quasispectrum_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nx : R\nâŠ¢ Iff (Membership.mem (quasispectrum R a) x) (Or (Eq x 0) (Membership.mem (spectrum R a) x))","decl":"lemma mem_quasispectrum_iff {R A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] {a : A} {x : R} :\n    x âˆˆ quasispectrum R a â†” x = 0 âˆ¨ x âˆˆ spectrum R a := by\n  simp [quasispectrum_eq_spectrum_union_zero]\n\n"}
{"name":"Unitization.isQuasiregular_inr_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\na : A\nâŠ¢ Iff (IsQuasiregular â†‘a) (IsQuasiregular a)","decl":"lemma isQuasiregular_inr_iff (a : A) :\n    IsQuasiregular (a : Unitization R A) â†” IsQuasiregular a := by\n  refine âŸ¨fun ha â†¦ ?_, IsQuasiregular.map (inrNonUnitalAlgHom R A)âŸ©\n  rw [isQuasiregular_iff] at ha âŠ¢\n  obtain âŸ¨y, hyâ‚, hyâ‚‚âŸ© := ha\n  lift y to A using by simpa using congr(fstHom R A $(hyâ‚))\n  refine âŸ¨y, ?_, ?_âŸ© <;> exact inr_injective (R := R) <| by simpa\n\n"}
{"name":"Unitization.zero_mem_spectrum_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : CommRing S\ninstâœâ· : Nontrivial S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nâŠ¢ Membership.mem (spectrum R â†‘a) 0","decl":"lemma zero_mem_spectrum_inr (R S : Type*) {A : Type*} [CommSemiring R]\n    [CommRing S] [Nontrivial S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    0 âˆˆ spectrum R (a : Unitization S A) := by\n  rw [spectrum.zero_mem_iff]\n  rintro âŸ¨u, huâŸ©\n  simpa [-Units.mul_inv, hu] using congr($(u.mul_inv).fst)\n\n"}
{"name":"Unitization.mem_spectrum_inr_of_not_isUnit","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\na : A\nr : R\nhr : Not (IsUnit r)\nâŠ¢ Membership.mem (spectrum R â†‘a) r","decl":"lemma mem_spectrum_inr_of_not_isUnit {R A : Type*} [CommRing R]\n    [NonUnitalRing A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A]\n    (a : A) (r : R) (hr : Â¬ IsUnit r) : r âˆˆ spectrum R (a : Unitization R A) :=\n  fun h â†¦ hr <| by simpa [map_sub] using h.map (fstHom R A)\n\n"}
{"name":"Unitization.quasispectrum_eq_spectrum_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nA : Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : IsScalarTower R A A\ninstâœ : SMulCommClass R A A\na : A\nâŠ¢ Eq (quasispectrum R a) (spectrum R â†‘a)","decl":"lemma quasispectrum_eq_spectrum_inr (R : Type*) {A : Type*} [CommRing R] [NonUnitalRing A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] (a : A) :\n    quasispectrum R a = spectrum R (a : Unitization R A) := by\n  ext r\n  have : { r | Â¬ IsUnit r} âŠ† spectrum R _ := mem_spectrum_inr_of_not_isUnit a\n  rw [â† Set.union_eq_left.mpr this, â† quasispectrum_eq_spectrum_union]\n  apply forall_congr' fun hr â†¦ ?_\n  rw [not_iff_not, Units.smul_def, Units.smul_def, â† inr_smul, â† inr_neg, isQuasiregular_inr_iff]\n\n"}
{"name":"Unitization.quasispectrum_eq_spectrum_inr'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nâŠ¢ Eq (quasispectrum R a) (spectrum R â†‘a)","decl":"lemma quasispectrum_eq_spectrum_inr' (R S : Type*) {A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    quasispectrum R a = spectrum R (a : Unitization S A) := by\n  ext r\n  have := Set.singleton_subset_iff.mpr (zero_mem_spectrum_inr R S a)\n  rw [â† Set.union_eq_self_of_subset_right this, â† quasispectrum_eq_spectrum_union_zero]\n  apply forall_congr' fun x â†¦ ?_\n  rw [not_iff_not, Units.smul_def, Units.smul_def, â† inr_smul, â† inr_neg, isQuasiregular_inr_iff]\n\n"}
{"name":"Unitization.quasispectrum_inr_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nâŠ¢ Eq (quasispectrum R â†‘a) (quasispectrum R a)","decl":"lemma quasispectrum_inr_eq (R S : Type*) {A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    quasispectrum R (a : Unitization S A) = quasispectrum R a := by\n  rw [quasispectrum_eq_spectrum_union_zero, quasispectrum_eq_spectrum_inr' R S]\n  apply Set.union_eq_self_of_subset_right\n  simpa using zero_mem_spectrum_inr _ _ _\n\n"}
{"name":"NonnegSpectrumClass.quasispectrum_nonneg_of_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\ninstâœÂ³ : OrderedCommSemiring ğ•œ\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : PartialOrder A\ninstâœ : Module ğ•œ A\nself : NonnegSpectrumClass ğ•œ A\na : A\naâœÂ¹ : LE.le 0 a\nx : ğ•œ\naâœ : Membership.mem (quasispectrum ğ•œ a) x\nâŠ¢ LE.le 0 x","decl":"/-- A class for `ğ•œ`-algebras with a partial order where the ordering is compatible with the\n(quasi)spectrum. -/\nclass NonnegSpectrumClass (ğ•œ A : Type*) [OrderedCommSemiring ğ•œ] [NonUnitalRing A] [PartialOrder A]\n    [Module ğ•œ A] : Prop where\n  quasispectrum_nonneg_of_nonneg : âˆ€ a : A, 0 â‰¤ a â†’ âˆ€ x âˆˆ quasispectrum ğ•œ a, 0 â‰¤ x\n\n"}
{"name":"NonnegSpectrumClass.iff_spectrum_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\ninstâœÂ³ : LinearOrderedSemifield ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : PartialOrder A\ninstâœ : Algebra ğ•œ A\nâŠ¢ Iff (NonnegSpectrumClass ğ•œ A) (âˆ€ (a : A), LE.le 0 a â†’ âˆ€ (x : ğ•œ), Membership.mem (spectrum ğ•œ a) x â†’ LE.le 0 x)","decl":"lemma iff_spectrum_nonneg {ğ•œ A : Type*} [LinearOrderedSemifield ğ•œ] [Ring A] [PartialOrder A]\n    [Algebra ğ•œ A] : NonnegSpectrumClass ğ•œ A â†” âˆ€ a : A, 0 â‰¤ a â†’ âˆ€ x âˆˆ spectrum ğ•œ a, 0 â‰¤ x := by\n  simp [show NonnegSpectrumClass ğ•œ A â†” _ from âŸ¨fun âŸ¨hâŸ© â†¦ h, (âŸ¨Â·âŸ©)âŸ©,\n    quasispectrum_eq_spectrum_union_zero]\n\n"}
{"name":"NonnegSpectrumClass.of_spectrum_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\ninstâœÂ³ : LinearOrderedSemifield ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : PartialOrder A\ninstâœ : Algebra ğ•œ A\naâœ : âˆ€ (a : A), LE.le 0 a â†’ âˆ€ (x : ğ•œ), Membership.mem (spectrum ğ•œ a) x â†’ LE.le 0 x\nâŠ¢ NonnegSpectrumClass ğ•œ A","decl":"alias âŸ¨_, of_spectrum_nonnegâŸ© := iff_spectrum_nonneg\n\n"}
{"name":"spectrum_nonneg_of_nonneg","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\ninstâœâ´ : OrderedCommSemiring ğ•œ\ninstâœÂ³ : Ring A\ninstâœÂ² : PartialOrder A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : NonnegSpectrumClass ğ•œ A\na : A\nha : LE.le 0 a\nx : ğ•œ\nhx : Membership.mem (spectrum ğ•œ a) x\nâŠ¢ LE.le 0 x","decl":"lemma spectrum_nonneg_of_nonneg {ğ•œ A : Type*} [OrderedCommSemiring ğ•œ] [Ring A] [PartialOrder A]\n    [Algebra ğ•œ A] [NonnegSpectrumClass ğ•œ A] â¦ƒa : Aâ¦„ (ha : 0 â‰¤ a) â¦ƒx : ğ•œâ¦„ (hx : x âˆˆ spectrum ğ•œ a) :\n    0 â‰¤ x :=\n  NonnegSpectrumClass.quasispectrum_nonneg_of_nonneg a ha x (spectrum_subset_quasispectrum ğ•œ a hx)\n\n"}
{"name":"QuasispectrumRestricts.rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : CommSemiring S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na : A\nf : S â†’ R\nself : QuasispectrumRestricts a f\nâŠ¢ Set.RightInvOn f (â‡‘(algebraMap R S)) (quasispectrum S a)","decl":"/-- Given an element `a : A` of an `S`-algebra, where `S` is itself an `R`-algebra, we say that\nthe spectrum of `a` restricts via a function `f : S â†’ R` if `f` is a left inverse of\n`algebraMap R S`, and `f` is a right inverse of `algebraMap R S` on `spectrum S a`.\n\nFor example, when `f = Complex.re` (so `S := â„‚` and `R := â„`), `SpectrumRestricts a f` means that\nthe `â„‚`-spectrum of `a` is contained within `â„`. This arises naturally when `a` is selfadjoint\nand `A` is a Câ‹†-algebra.\n\nThis is the property allows us to restrict a continuous functional calculus over `S` to a\ncontinuous functional calculus over `R`. -/\nstructure QuasispectrumRestricts\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S â†’ R) : Prop where\n  /-- `f` is a right inverse of `algebraMap R S` when restricted to `quasispectrum S a`. -/\n  rightInvOn : (quasispectrum S a).RightInvOn f (algebraMap R S)\n  /-- `f` is a left inverse of `algebraMap R S`. -/\n  left_inv : Function.LeftInverse f (algebraMap R S)\n\n"}
{"name":"QuasispectrumRestricts.left_inv","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : CommSemiring S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na : A\nf : S â†’ R\nself : QuasispectrumRestricts a f\nâŠ¢ Function.LeftInverse f â‡‘(algebraMap R S)","decl":"/-- Given an element `a : A` of an `S`-algebra, where `S` is itself an `R`-algebra, we say that\nthe spectrum of `a` restricts via a function `f : S â†’ R` if `f` is a left inverse of\n`algebraMap R S`, and `f` is a right inverse of `algebraMap R S` on `spectrum S a`.\n\nFor example, when `f = Complex.re` (so `S := â„‚` and `R := â„`), `SpectrumRestricts a f` means that\nthe `â„‚`-spectrum of `a` is contained within `â„`. This arises naturally when `a` is selfadjoint\nand `A` is a Câ‹†-algebra.\n\nThis is the property allows us to restrict a continuous functional calculus over `S` to a\ncontinuous functional calculus over `R`. -/\nstructure QuasispectrumRestricts\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S â†’ R) : Prop where\n  /-- `f` is a right inverse of `algebraMap R S` when restricted to `quasispectrum S a`. -/\n  rightInvOn : (quasispectrum S a).RightInvOn f (algebraMap R S)\n  /-- `f` is a left inverse of `algebraMap R S`. -/\n  left_inv : Function.LeftInverse f (algebraMap R S)\n\n"}
{"name":"quasispectrumRestricts_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : CommSemiring S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na : A\nf : S â†’ R\nâŠ¢ Iff (QuasispectrumRestricts a f) (And (Set.RightInvOn f (â‡‘(algebraMap R S)) (quasispectrum S a)) (Function.LeftInverse f â‡‘(algebraMap R S)))","decl":"lemma quasispectrumRestricts_iff\n    {R S A : Type*} [CommSemiring R] [CommSemiring S] [NonUnitalRing A]\n    [Module R A] [Module S A] [Algebra R S] (a : A) (f : S â†’ R) :\n    QuasispectrumRestricts a f â†” (quasispectrum S a).RightInvOn f (algebraMap R S) âˆ§\n      Function.LeftInverse f (algebraMap R S) :=\n  âŸ¨fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ âŸ¨hâ‚, hâ‚‚âŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n\n"}
{"name":"quasispectrum.algebraMap_mem_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nr : R\nâŠ¢ Iff (Membership.mem (quasispectrum S a) ((algebraMap R S) r)) (Membership.mem (quasispectrum R a) r)","decl":"@[simp]\ntheorem quasispectrum.algebraMap_mem_iff (S : Type*) {R A : Type*} [Semifield R] [Field S]\n    [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] {a : A} {r : R} :\n    algebraMap R S r âˆˆ quasispectrum S a â†” r âˆˆ quasispectrum R a := by\n  simp_rw [Unitization.quasispectrum_eq_spectrum_inr' _ S a, spectrum.algebraMap_mem_iff]\n\n"}
{"name":"quasispectrum.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nr : R\naâœ : Membership.mem (quasispectrum R a) r\nâŠ¢ Membership.mem (quasispectrum S a) ((algebraMap R S) r)","decl":"protected alias âŸ¨quasispectrum.of_algebraMap_mem, quasispectrum.algebraMap_memâŸ© :=\n  quasispectrum.algebraMap_mem_iff\n\n"}
{"name":"quasispectrum.of_algebraMap_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nr : R\naâœ : Membership.mem (quasispectrum S a) ((algebraMap R S) r)\nâŠ¢ Membership.mem (quasispectrum R a) r","decl":"protected alias âŸ¨quasispectrum.of_algebraMap_mem, quasispectrum.algebraMap_memâŸ© :=\n  quasispectrum.algebraMap_mem_iff\n\n"}
{"name":"quasispectrum.preimage_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module S A\ninstâœÂ³ : IsScalarTower S A A\ninstâœÂ² : SMulCommClass S A A\ninstâœÂ¹ : Module R A\ninstâœ : IsScalarTower R S A\na : A\nâŠ¢ Eq (Set.preimage (â‡‘(algebraMap R S)) (quasispectrum S a)) (quasispectrum R a)","decl":"@[simp]\ntheorem quasispectrum.preimage_algebraMap (S : Type*) {R A : Type*} [Semifield R] [Field S]\n    [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] {a : A} :\n    algebraMap R S â»Â¹' quasispectrum S a = quasispectrum R a :=\n  Set.ext fun _ => quasispectrum.algebraMap_mem_iff _\n\n"}
{"name":"QuasispectrumRestricts.map_zero","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Field S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na : A\nf : S â†’ R\nh : QuasispectrumRestricts a f\nâŠ¢ Eq (f 0) 0","decl":"protected theorem map_zero (h : QuasispectrumRestricts a f) : f 0 = 0 := by\n  rw [â† h.left_inv 0, map_zero (algebraMap R S)]\n\n"}
{"name":"QuasispectrumRestricts.of_subset_range_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Field S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na : A\nf : S â†’ R\nhf : Function.LeftInverse f â‡‘(algebraMap R S)\nh : HasSubset.Subset (quasispectrum S a) (Set.range â‡‘(algebraMap R S))\nâŠ¢ QuasispectrumRestricts a f","decl":"theorem of_subset_range_algebraMap (hf : f.LeftInverse (algebraMap R S))\n    (h : quasispectrum S a âŠ† Set.range (algebraMap R S)) : QuasispectrumRestricts a f where\n  rightInvOn := fun s hs => by obtain âŸ¨r, rflâŸ© := h hs; rw [hf r]\n  left_inv := hf\n\n"}
{"name":"QuasispectrumRestricts.of_quasispectrum_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Field S\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module S A\ninstâœ : Algebra R S\na b : A\nf : S â†’ R\nha : QuasispectrumRestricts a f\nh : Eq (quasispectrum S a) (quasispectrum S b)\nâŠ¢ QuasispectrumRestricts b f","decl":"lemma of_quasispectrum_eq {a b : A} {f : S â†’ R} (ha : QuasispectrumRestricts a f)\n    (h : quasispectrum S a = quasispectrum S b) : QuasispectrumRestricts b f where\n  rightInvOn := h â–¸ ha.rightInvOn\n  left_inv := ha.left_inv\n\n"}
{"name":"QuasispectrumRestricts.algebraMap_image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Module R A\ninstâœâ´ : Module S A\ninstâœÂ³ : Algebra R S\na : A\nf : S â†’ R\ninstâœÂ² : IsScalarTower S A A\ninstâœÂ¹ : SMulCommClass S A A\ninstâœ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\nâŠ¢ Eq (Set.image (â‡‘(algebraMap R S)) (quasispectrum R a)) (quasispectrum S a)","decl":"theorem algebraMap_image (h : QuasispectrumRestricts a f) :\n    algebraMap R S '' quasispectrum R a = quasispectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => âŸ¨f s, ?_âŸ©\n  Â· simpa only [quasispectrum.preimage_algebraMap] using\n      (quasispectrum S a).image_preimage_subset (algebraMap R S)\n  exact âŸ¨quasispectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm â–¸ hs), h.rightInvOn hsâŸ©\n\n"}
{"name":"QuasispectrumRestricts.image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Module R A\ninstâœâ´ : Module S A\ninstâœÂ³ : Algebra R S\na : A\nf : S â†’ R\ninstâœÂ² : IsScalarTower S A A\ninstâœÂ¹ : SMulCommClass S A A\ninstâœ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\nâŠ¢ Eq (Set.image f (quasispectrum S a)) (quasispectrum R a)","decl":"theorem image (h : QuasispectrumRestricts a f) : f '' quasispectrum S a = quasispectrum R a := by\n  simp only [â† h.algebraMap_image, Set.image_image, h.left_inv _, Set.image_id']\n\n"}
{"name":"QuasispectrumRestricts.apply_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Module R A\ninstâœâ´ : Module S A\ninstâœÂ³ : Algebra R S\na : A\nf : S â†’ R\ninstâœÂ² : IsScalarTower S A A\ninstâœÂ¹ : SMulCommClass S A A\ninstâœ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\ns : S\nhs : Membership.mem (quasispectrum S a) s\nâŠ¢ Membership.mem (quasispectrum R a) (f s)","decl":"theorem apply_mem (h : QuasispectrumRestricts a f) {s : S} (hs : s âˆˆ quasispectrum S a) :\n    f s âˆˆ quasispectrum R a :=\n  h.image â–¸ âŸ¨s, hs, rflâŸ©\n\n"}
{"name":"QuasispectrumRestricts.subset_preimage","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Module R A\ninstâœâ´ : Module S A\ninstâœÂ³ : Algebra R S\na : A\nf : S â†’ R\ninstâœÂ² : IsScalarTower S A A\ninstâœÂ¹ : SMulCommClass S A A\ninstâœ : IsScalarTower R S A\nh : QuasispectrumRestricts a f\nâŠ¢ HasSubset.Subset (quasispectrum S a) (Set.preimage f (quasispectrum R a))","decl":"theorem subset_preimage (h : QuasispectrumRestricts a f) :\n    quasispectrum S a âŠ† f â»Â¹' quasispectrum R a :=\n  h.image â–¸ (quasispectrum S a).subset_preimage_image f\n\n"}
{"name":"QuasispectrumRestricts.comp","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"Râ‚ : Type u_6\nRâ‚‚ : Type u_7\nRâ‚ƒ : Type u_8\nA : Type u_9\ninstâœÂ¹Â³ : Semifield Râ‚\ninstâœÂ¹Â² : Field Râ‚‚\ninstâœÂ¹Â¹ : Field Râ‚ƒ\ninstâœÂ¹â° : NonUnitalRing A\ninstâœâ¹ : Module Râ‚ A\ninstâœâ¸ : Module Râ‚‚ A\ninstâœâ· : Module Râ‚ƒ A\ninstâœâ¶ : Algebra Râ‚ Râ‚‚\ninstâœâµ : Algebra Râ‚‚ Râ‚ƒ\ninstâœâ´ : Algebra Râ‚ Râ‚ƒ\ninstâœÂ³ : IsScalarTower Râ‚ Râ‚‚ Râ‚ƒ\ninstâœÂ² : IsScalarTower Râ‚‚ Râ‚ƒ A\ninstâœÂ¹ : IsScalarTower Râ‚ƒ A A\ninstâœ : SMulCommClass Râ‚ƒ A A\na : A\nf : Râ‚ƒ â†’ Râ‚‚\ng : Râ‚‚ â†’ Râ‚\ne : Râ‚ƒ â†’ Râ‚\nhfge : Eq (Function.comp g f) e\nhf : QuasispectrumRestricts a f\nhg : QuasispectrumRestricts a g\nâŠ¢ QuasispectrumRestricts a e","decl":"protected lemma comp {Râ‚ Râ‚‚ Râ‚ƒ A : Type*} [Semifield Râ‚] [Field Râ‚‚] [Field Râ‚ƒ]\n    [NonUnitalRing A] [Module Râ‚ A] [Module Râ‚‚ A] [Module Râ‚ƒ A] [Algebra Râ‚ Râ‚‚] [Algebra Râ‚‚ Râ‚ƒ]\n    [Algebra Râ‚ Râ‚ƒ] [IsScalarTower Râ‚ Râ‚‚ Râ‚ƒ] [IsScalarTower Râ‚‚ Râ‚ƒ A] [IsScalarTower Râ‚ƒ A A]\n    [SMulCommClass Râ‚ƒ A A] {a : A} {f : Râ‚ƒ â†’ Râ‚‚} {g : Râ‚‚ â†’ Râ‚} {e : Râ‚ƒ â†’ Râ‚} (hfge : g âˆ˜ f = e)\n    (hf : QuasispectrumRestricts a f) (hg : QuasispectrumRestricts a g) :\n    QuasispectrumRestricts a e where\n  left_inv := by\n    convert hfge â–¸ hf.left_inv.comp hg.left_inv\n    congrm(â‡‘$(IsScalarTower.algebraMap_eq Râ‚ Râ‚‚ Râ‚ƒ))\n  rightInvOn := by\n    convert hfge â–¸ hg.rightInvOn.comp hf.rightInvOn fun _ â†¦ hf.apply_mem\n    congrm(â‡‘$(IsScalarTower.algebraMap_eq Râ‚ Râ‚‚ Râ‚ƒ))\n\n"}
{"name":"SpectrumRestricts.rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nh : SpectrumRestricts a f\nâŠ¢ Set.RightInvOn f (â‡‘(algebraMap R S)) (spectrum S a)","decl":"theorem rightInvOn (h : SpectrumRestricts a f) : (spectrum S a).RightInvOn f (algebraMap R S) :=\n  (QuasispectrumRestricts.rightInvOn h).mono <| spectrum_subset_quasispectrum _ _\n\n"}
{"name":"SpectrumRestricts.of_rightInvOn","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nhâ‚ : Function.LeftInverse f â‡‘(algebraMap R S)\nhâ‚‚ : Set.RightInvOn f (â‡‘(algebraMap R S)) (spectrum S a)\nâŠ¢ SpectrumRestricts a f","decl":"theorem of_rightInvOn (hâ‚ : Function.LeftInverse f (algebraMap R S))\n    (hâ‚‚ : (spectrum S a).RightInvOn f (algebraMap R S)) : SpectrumRestricts a f where\n  rightInvOn x hx := by\n    obtain (rfl | hx) := mem_quasispectrum_iff.mp hx\n    Â· simpa using hâ‚ 0\n    Â· exact hâ‚‚ hx\n  left_inv := hâ‚\n\n"}
{"name":"spectrumRestricts_iff","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nâŠ¢ Iff (SpectrumRestricts a f) (And (Set.RightInvOn f (â‡‘(algebraMap R S)) (spectrum S a)) (Function.LeftInverse f â‡‘(algebraMap R S)))","decl":"lemma _root_.spectrumRestricts_iff :\n    SpectrumRestricts a f â†” (spectrum S a).RightInvOn f (algebraMap R S) âˆ§\n      Function.LeftInverse f (algebraMap R S) :=\n  âŸ¨fun h â†¦ âŸ¨h.rightInvOn, h.left_invâŸ©, fun h â†¦ .of_rightInvOn h.2 h.1âŸ©\n\n"}
{"name":"SpectrumRestricts.of_subset_range_algebraMap","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nhf : Function.LeftInverse f â‡‘(algebraMap R S)\nh : HasSubset.Subset (spectrum S a) (Set.range â‡‘(algebraMap R S))\nâŠ¢ SpectrumRestricts a f","decl":"theorem of_subset_range_algebraMap (hf : f.LeftInverse (algebraMap R S))\n    (h : spectrum S a âŠ† Set.range (algebraMap R S)) : SpectrumRestricts a f where\n  rightInvOn := fun s hs => by\n    rw [mem_quasispectrum_iff] at hs\n    obtain (rfl | hs) := hs\n    Â· simpa using hf 0\n    Â· obtain âŸ¨r, rflâŸ© := h hs\n      rw [hf r]\n  left_inv := hf\n\n"}
{"name":"SpectrumRestricts.of_spectrum_eq","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na b : A\nf : S â†’ R\nha : SpectrumRestricts a f\nh : Eq (spectrum S a) (spectrum S b)\nâŠ¢ SpectrumRestricts b f","decl":"lemma of_spectrum_eq {a b : A} {f : S â†’ R} (ha : SpectrumRestricts a f)\n    (h : spectrum S a = spectrum S b) : SpectrumRestricts b f where\n  rightInvOn :=  by\n    rw [quasispectrum_eq_spectrum_union_zero, â† h, â† quasispectrum_eq_spectrum_union_zero]\n    exact QuasispectrumRestricts.rightInvOn ha\n  left_inv := ha.left_inv\n\n"}
{"name":"SpectrumRestricts.algebraMap_image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¶ : Semifield R\ninstâœâµ : Semifield S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\na : A\nf : S â†’ R\ninstâœ : IsScalarTower R S A\nh : SpectrumRestricts a f\nâŠ¢ Eq (Set.image (â‡‘(algebraMap R S)) (spectrum R a)) (spectrum S a)","decl":"theorem algebraMap_image (h : SpectrumRestricts a f) :\n    algebraMap R S '' spectrum R a = spectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => âŸ¨f s, ?_âŸ©\n  Â· simpa only [spectrum.preimage_algebraMap] using\n      (spectrum S a).image_preimage_subset (algebraMap R S)\n  exact âŸ¨spectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm â–¸ hs), h.rightInvOn hsâŸ©\n\n"}
{"name":"SpectrumRestricts.image","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¶ : Semifield R\ninstâœâµ : Semifield S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\na : A\nf : S â†’ R\ninstâœ : IsScalarTower R S A\nh : SpectrumRestricts a f\nâŠ¢ Eq (Set.image f (spectrum S a)) (spectrum R a)","decl":"theorem image (h : SpectrumRestricts a f) : f '' spectrum S a = spectrum R a := by\n  simp only [â† h.algebraMap_image, Set.image_image, h.left_inv _, Set.image_id']\n\n"}
{"name":"SpectrumRestricts.apply_mem","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¶ : Semifield R\ninstâœâµ : Semifield S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\na : A\nf : S â†’ R\ninstâœ : IsScalarTower R S A\nh : SpectrumRestricts a f\ns : S\nhs : Membership.mem (spectrum S a) s\nâŠ¢ Membership.mem (spectrum R a) (f s)","decl":"theorem apply_mem (h : SpectrumRestricts a f) {s : S} (hs : s âˆˆ spectrum S a) :\n    f s âˆˆ spectrum R a :=\n  h.image â–¸ âŸ¨s, hs, rflâŸ©\n\n"}
{"name":"SpectrumRestricts.subset_preimage","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâ¶ : Semifield R\ninstâœâµ : Semifield S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\na : A\nf : S â†’ R\ninstâœ : IsScalarTower R S A\nh : SpectrumRestricts a f\nâŠ¢ HasSubset.Subset (spectrum S a) (Set.preimage f (spectrum R a))","decl":"theorem subset_preimage (h : SpectrumRestricts a f) : spectrum S a âŠ† f â»Â¹' spectrum R a :=\n  h.image â–¸ (spectrum S a).subset_preimage_image f\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts_inr","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"S : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœâ¸ : Semifield R\ninstâœâ· : Field S\ninstâœâ¶ : NonUnitalRing A\ninstâœâµ : Algebra R S\ninstâœâ´ : Module R A\ninstâœÂ³ : Module S A\ninstâœÂ² : IsScalarTower S A A\ninstâœÂ¹ : SMulCommClass S A A\ninstâœ : IsScalarTower R S A\na : A\nf : S â†’ R\nâŠ¢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts (â†‘a) f)","decl":"theorem quasispectrumRestricts_iff_spectrumRestricts_inr (S : Type*) {R A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [IsScalarTower R S A] {a : A} {f : S â†’ R} :\n    QuasispectrumRestricts a f â†” SpectrumRestricts (a : Unitization S A) f := by\n  rw [quasispectrumRestricts_iff, spectrumRestricts_iff,\n    â† Unitization.quasispectrum_eq_spectrum_inr']\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts_inr'","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS' : Type u_4\nA : Type u_5\nS : Type u_6\ninstâœÂ¹Â³ : Semifield R\ninstâœÂ¹Â² : Semifield S'\ninstâœÂ¹Â¹ : Field S\ninstâœÂ¹â° : NonUnitalRing A\ninstâœâ¹ : Module R A\ninstâœâ¸ : Module S' A\ninstâœâ· : Module S A\ninstâœâ¶ : IsScalarTower S A A\ninstâœâµ : SMulCommClass S A A\ninstâœâ´ : Algebra R S'\ninstâœÂ³ : Algebra S' S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : IsScalarTower S' S A\ninstâœ : IsScalarTower R S A\na : A\nf : S' â†’ R\nâŠ¢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts (â†‘a) f)","decl":"/-- The difference from `quasispectrumRestricts_iff_spectrumRestricts_inr` is that the\n`Unitization` may be taken with respect to a different scalar field. -/\nlemma quasispectrumRestricts_iff_spectrumRestricts_inr'\n    {R S' A : Type*} (S : Type*) [Semifield R] [Semifield S'] [Field S] [NonUnitalRing A]\n    [Module R A] [Module S' A] [Module S A] [IsScalarTower S A A] [SMulCommClass S A A]\n    [Algebra R S'] [Algebra S' S] [Algebra R S] [IsScalarTower S' S A] [IsScalarTower R S A]\n    {a : A} {f : S' â†’ R} :\n    QuasispectrumRestricts a f â†” SpectrumRestricts (a : Unitization S A) f := by\n  simp only [quasispectrumRestricts_iff, SpectrumRestricts, Unitization.quasispectrum_inr_eq]\n\n"}
{"name":"quasispectrumRestricts_iff_spectrumRestricts","module":"Mathlib.Algebra.Algebra.Quasispectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nâŠ¢ Iff (QuasispectrumRestricts a f) (SpectrumRestricts a f)","decl":"theorem quasispectrumRestricts_iff_spectrumRestricts {R S A : Type*} [Semifield R] [Semifield S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S â†’ R} :\n    QuasispectrumRestricts a f â†” SpectrumRestricts a f := by rfl\n"}
