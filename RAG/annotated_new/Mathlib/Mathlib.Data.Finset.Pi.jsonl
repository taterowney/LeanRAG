{"name":"Finset.pi_val","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ninst✝ : DecidableEq α\ns : Finset α\nt : (a : α) → Finset (β a)\n⊢ Eq (s.pi t).val (s.val.pi fun a => (t a).val)","decl":"@[simp]\ntheorem pi_val (s : Finset α) (t : ∀ a, Finset (β a)) : (s.pi t).1 = s.1.pi fun a => (t a).1 :=\n  rfl\n\n"}
{"name":"Finset.mem_pi","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ninst✝ : DecidableEq α\ns : Finset α\nt : (a : α) → Finset (β a)\nf : (a : α) → Membership.mem s a → β a\n⊢ Iff (Membership.mem (s.pi t) f) (∀ (a : α) (h : Membership.mem s a), Membership.mem (t a) (f a h))","decl":"@[simp]\ntheorem mem_pi {s : Finset α} {t : ∀ a, Finset (β a)} {f : ∀ a ∈ s, β a} :\n    f ∈ s.pi t ↔ ∀ (a) (h : a ∈ s), f a h ∈ t a :=\n  Multiset.mem_pi _ _ _\n\n"}
{"name":"Finset.Pi.cons_same","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nδ : α → Sort v\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : δ a\nf : (a : α) → Membership.mem s a → δ a\nh : Membership.mem (Insert.insert a s) a\n⊢ Eq (Finset.Pi.cons s a b f a h) b","decl":"@[simp]\ntheorem Pi.cons_same (s : Finset α) (a : α) (b : δ a) (f : ∀ a, a ∈ s → δ a) (h : a ∈ insert a s) :\n    Pi.cons s a b f a h = b :=\n  Multiset.Pi.cons_same _\n\n"}
{"name":"Finset.Pi.cons_ne","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nδ : α → Sort v\ninst✝ : DecidableEq α\ns : Finset α\na a' : α\nb : δ a\nf : (a : α) → Membership.mem s a → δ a\nh : Membership.mem (Insert.insert a s) a'\nha : Ne a a'\n⊢ Eq (Finset.Pi.cons s a b f a' h) (f a' ⋯)","decl":"theorem Pi.cons_ne {s : Finset α} {a a' : α} {b : δ a} {f : ∀ a, a ∈ s → δ a} {h : a' ∈ insert a s}\n    (ha : a ≠ a') : Pi.cons s a b f a' h = f a' ((mem_insert.1 h).resolve_left ha.symm) :=\n  Multiset.Pi.cons_ne _ (Ne.symm ha)\n\n"}
{"name":"Finset.Pi.cons_injective","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nδ : α → Sort v\ninst✝ : DecidableEq α\na : α\nb : δ a\ns : Finset α\nhs : Not (Membership.mem s a)\n⊢ Function.Injective (Finset.Pi.cons s a b)","decl":"theorem Pi.cons_injective {a : α} {b : δ a} {s : Finset α} (hs : a ∉ s) :\n    Function.Injective (Pi.cons s a b) := fun e₁ e₂ eq =>\n  @Multiset.Pi.cons_injective α _ δ a b s.1 hs _ _ <|\n    funext fun e =>\n      funext fun h =>\n        have :\n          Pi.cons s a b e₁ e (by simpa only [Multiset.mem_cons, mem_insert] using h) =\n            Pi.cons s a b e₂ e (by simpa only [Multiset.mem_cons, mem_insert] using h) := by\n          rw [eq]\n        this\n\n"}
{"name":"Finset.pi_empty","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ninst✝ : DecidableEq α\nt : (a : α) → Finset (β a)\n⊢ Eq (EmptyCollection.emptyCollection.pi t) (Singleton.singleton (Finset.Pi.empty β))","decl":"@[simp]\ntheorem pi_empty {t : ∀ a : α, Finset (β a)} : pi (∅ : Finset α) t = singleton (Pi.empty β) :=\n  rfl\n\n"}
{"name":"Finset.pi_nonempty","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ns : Finset α\nt : (a : α) → Finset (β a)\ninst✝ : DecidableEq α\n⊢ Iff (s.pi t).Nonempty (∀ (a : α), Membership.mem s a → (t a).Nonempty)","decl":"@[simp]\nlemma pi_nonempty : (s.pi t).Nonempty ↔ ∀ a ∈ s, (t a).Nonempty := by\n  simp [Finset.Nonempty, Classical.skolem]\n\n"}
{"name":"Finset.pi_nonempty_of_forall_nonempty","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ns : Finset α\nt : (a : α) → Finset (β a)\ninst✝ : DecidableEq α\na✝ : ∀ (a : α), Membership.mem s a → (t a).Nonempty\n⊢ (s.pi t).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, pi_nonempty_of_forall_nonempty⟩ := pi_nonempty\n\n"}
{"name":"Finset.pi_eq_empty","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ns : Finset α\nt : (a : α) → Finset (β a)\ninst✝ : DecidableEq α\n⊢ Iff (Eq (s.pi t) EmptyCollection.emptyCollection) (Exists fun a => And (Membership.mem s a) (Eq (t a) EmptyCollection.emptyCollection))","decl":"@[simp]\nlemma pi_eq_empty : s.pi t = ∅ ↔ ∃ a ∈ s, t a = ∅ := by\n  simp [← not_nonempty_iff_eq_empty]\n\n"}
{"name":"Finset.pi_insert","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ninst✝¹ : DecidableEq α\ninst✝ : (a : α) → DecidableEq (β a)\ns : Finset α\nt : (a : α) → Finset (β a)\na : α\nha : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).pi t) ((t a).biUnion fun b => Finset.image (Finset.Pi.cons s a b) (s.pi t))","decl":"@[simp]\ntheorem pi_insert [∀ a, DecidableEq (β a)] {s : Finset α} {t : ∀ a : α, Finset (β a)} {a : α}\n    (ha : a ∉ s) : pi (insert a s) t = (t a).biUnion fun b => (pi s t).image (Pi.cons s a b) := by\n  apply eq_of_veq\n  rw [← (pi (insert a s) t).2.dedup]\n  refine\n    (fun s' (h : s' = a ::ₘ s.1) =>\n        (?_ :\n          dedup (Multiset.pi s' fun a => (t a).1) =\n            dedup\n              ((t a).1.bind fun b =>\n                dedup <|\n                  (Multiset.pi s.1 fun a : α => (t a).val).map fun f a' h' =>\n                    Multiset.Pi.cons s.1 a b f a' (h ▸ h'))))\n      _ (insert_val_of_not_mem ha)\n  subst s'; rw [pi_cons]\n  congr; funext b\n  exact ((pi s t).nodup.map <| Multiset.Pi.cons_injective ha).dedup.symm\n\n"}
{"name":"Finset.pi_singletons","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : Type u_2\ns : Finset α\nf : α → β\n⊢ Eq (s.pi fun a => Singleton.singleton (f a)) (Singleton.singleton fun a x => f a)","decl":"theorem pi_singletons {β : Type*} (s : Finset α) (f : α → β) :\n    (s.pi fun a => ({f a} : Finset β)) = {fun a _ => f a} := by\n  rw [eq_singleton_iff_unique_mem]\n  constructor\n  · simp\n  intro a ha\n  ext i hi\n  rw [mem_pi] at ha\n  simpa using ha i hi\n\n"}
{"name":"Finset.pi_const_singleton","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : Type u_2\ns : Finset α\ni : β\n⊢ Eq (s.pi fun x => Singleton.singleton i) (Singleton.singleton fun x x => i)","decl":"theorem pi_const_singleton {β : Type*} (s : Finset α) (i : β) :\n    (s.pi fun _ => ({i} : Finset β)) = {fun _ _ => i} :=\n  pi_singletons s fun _ => i\n\n"}
{"name":"Finset.pi_subset","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nβ : α → Type u\ninst✝ : DecidableEq α\ns : Finset α\nt₁ t₂ : (a : α) → Finset (β a)\nh : ∀ (a : α), Membership.mem s a → HasSubset.Subset (t₁ a) (t₂ a)\n⊢ HasSubset.Subset (s.pi t₁) (s.pi t₂)","decl":"theorem pi_subset {s : Finset α} (t₁ t₂ : ∀ a, Finset (β a)) (h : ∀ a ∈ s, t₁ a ⊆ t₂ a) :\n    s.pi t₁ ⊆ s.pi t₂ := fun _ hg => mem_pi.2 fun a ha => h a ha (mem_pi.mp hg a ha)\n\n"}
{"name":"Finset.pi_disjoint_of_disjoint","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Type u_2\ns : Finset α\nt₁ t₂ : (a : α) → Finset (δ a)\na : α\nha : Membership.mem s a\nh : Disjoint (t₁ a) (t₂ a)\n⊢ Disjoint (s.pi t₁) (s.pi t₂)","decl":"theorem pi_disjoint_of_disjoint {δ : α → Type*} {s : Finset α} (t₁ t₂ : ∀ a, Finset (δ a)) {a : α}\n    (ha : a ∈ s) (h : Disjoint (t₁ a) (t₂ a)) : Disjoint (s.pi t₁) (s.pi t₂) :=\n  disjoint_iff_ne.2 fun f₁ hf₁ f₂ hf₂ eq₁₂ =>\n    disjoint_iff_ne.1 h (f₁ a ha) (mem_pi.mp hf₁ a ha) (f₂ a ha) (mem_pi.mp hf₂ a ha) <|\n      congr_fun (congr_fun eq₁₂ a) ha\n\n"}
{"name":"Finset.mem_piDiag","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : DecidableEq (ι → α)\ns : Finset α\nf : ι → α\n⊢ Iff (Membership.mem (s.piDiag ι) f) (Exists fun a => And (Membership.mem s a) (Eq (Function.const ι a) f))","decl":"@[simp] lemma mem_piDiag : f ∈ s.piDiag ι ↔ ∃ a ∈ s, const ι a = f := mem_image\n\n"}
{"name":"Finset.card_piDiag","module":"Mathlib.Data.Finset.Pi","initialProofState":"α : Type u_1\ns : Finset α\nι : Type u_3\ninst✝¹ : DecidableEq (ι → α)\ninst✝ : Nonempty ι\n⊢ Eq (s.piDiag ι).card s.card","decl":"@[simp] lemma card_piDiag (s : Finset α) (ι : Type*) [DecidableEq (ι → α)] [Nonempty ι] :\n    (s.piDiag ι).card = s.card := by rw [piDiag, card_image_of_injective _ const_injective]\n\n"}
{"name":"Finset.restrict_def","module":"Mathlib.Data.Finset.Pi","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\ns : Finset ι\n⊢ Eq s.restrict fun f x => f ↑x","decl":"theorem restrict_def (s : Finset ι) : s.restrict (π := π) = fun f x ↦ f x := rfl\n\n"}
{"name":"Finset.restrict₂_def","module":"Mathlib.Data.Finset.Pi","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\ns t : Finset ι\nhst : HasSubset.Subset s t\n⊢ Eq (Finset.restrict₂ hst) fun f x => f ⟨↑x, ⋯⟩","decl":"theorem restrict₂_def {s t : Finset ι} (hst : s ⊆ t) :\n    restrict₂ (π := π) hst = fun f x ↦ f ⟨x.1, hst x.2⟩ := rfl\n\n"}
{"name":"Finset.restrict₂_comp_restrict","module":"Mathlib.Data.Finset.Pi","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\ns t : Finset ι\nhst : HasSubset.Subset s t\n⊢ Eq (Function.comp (Finset.restrict₂ hst) t.restrict) s.restrict","decl":"theorem restrict₂_comp_restrict {s t : Finset ι} (hst : s ⊆ t) :\n    (restrict₂ (π := π) hst) ∘ t.restrict = s.restrict := rfl\n\n"}
{"name":"Finset.restrict₂_comp_restrict₂","module":"Mathlib.Data.Finset.Pi","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\ns t u : Finset ι\nhst : HasSubset.Subset s t\nhtu : HasSubset.Subset t u\n⊢ Eq (Function.comp (Finset.restrict₂ hst) (Finset.restrict₂ htu)) (Finset.restrict₂ ⋯)","decl":"theorem restrict₂_comp_restrict₂ {s t u : Finset ι} (hst : s ⊆ t) (htu : t ⊆ u) :\n    (restrict₂ (π := π) hst) ∘ (restrict₂ htu) = restrict₂ (hst.trans htu) := rfl\n\n"}
