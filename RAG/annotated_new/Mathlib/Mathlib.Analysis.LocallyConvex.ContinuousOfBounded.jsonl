{"name":"LinearMap.clmOfExistsBoundedImage_coe","module":"Mathlib.Analysis.LocallyConvex.ContinuousOfBounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : UniformSpace E\ninstâœâ· : UniformAddGroup E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : UniformSpace F\ninstâœâ´ : UniformAddGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : ContinuousSMul ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nh : Exists fun V => And (Membership.mem (nhds 0) V) (Bornology.IsVonNBounded ğ•œ (Set.image (â‡‘f) V))\nâŠ¢ Eq (â†‘(f.clmOfExistsBoundedImage h)) f","decl":"theorem LinearMap.clmOfExistsBoundedImage_coe {f : E â†’â‚—[ğ•œ] F}\n    {h : âˆƒ V âˆˆ ğ“ (0 : E), Bornology.IsVonNBounded ğ•œ (f '' V)} :\n    (f.clmOfExistsBoundedImage h : E â†’â‚—[ğ•œ] F) = f :=\n  rfl\n\n"}
{"name":"LinearMap.clmOfExistsBoundedImage_apply","module":"Mathlib.Analysis.LocallyConvex.ContinuousOfBounded","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : UniformSpace E\ninstâœâ· : UniformAddGroup E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : UniformSpace F\ninstâœâ´ : UniformAddGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : ContinuousSMul ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nh : Exists fun V => And (Membership.mem (nhds 0) V) (Bornology.IsVonNBounded ğ•œ (Set.image (â‡‘f) V))\nx : E\nâŠ¢ Eq ((f.clmOfExistsBoundedImage h) x) (f x)","decl":"@[simp]\ntheorem LinearMap.clmOfExistsBoundedImage_apply {f : E â†’â‚—[ğ•œ] F}\n    {h : âˆƒ V âˆˆ ğ“ (0 : E), Bornology.IsVonNBounded ğ•œ (f '' V)} {x : E} :\n    f.clmOfExistsBoundedImage h x = f x :=\n  rfl\n\n"}
{"name":"LinearMap.continuousAt_zero_of_locally_bounded","module":"Mathlib.Analysis.LocallyConvex.ContinuousOfBounded","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : AddCommGroup E\ninstâœÂ¹â° : UniformSpace E\ninstâœâ¹ : UniformAddGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : UniformSpace F\ninstâœâ¶ : FirstCountableTopology E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : RCLike ğ•œ'\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : ContinuousSMul ğ•œ' F\nÏƒ : RingHom ğ•œ ğ•œ'\nf : LinearMap Ïƒ E F\nhf : âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (Set.image (â‡‘f) s)\nâŠ¢ ContinuousAt (â‡‘f) 0","decl":"theorem LinearMap.continuousAt_zero_of_locally_bounded (f : E â†’â‚›â‚—[Ïƒ] F)\n    (hf : âˆ€ s, IsVonNBounded ğ•œ s â†’ IsVonNBounded ğ•œ' (f '' s)) : ContinuousAt f 0 := by\n  -- Assume that f is not continuous at 0\n  by_contra h\n  -- We use a decreasing balanced basis for 0 : E and a balanced basis for 0 : F\n  -- and reformulate non-continuity in terms of these bases\n  rcases (nhds_basis_balanced ğ•œ E).exists_antitone_subbasis with âŸ¨b, bE1, bEâŸ©\n  simp only [_root_.id] at bE\n  have bE' : (ğ“ (0 : E)).HasBasis (fun x : â„• => x â‰  0) fun n : â„• => (n : ğ•œ)â»Â¹ â€¢ b n := by\n    refine bE.1.to_hasBasis ?_ ?_\n    Â· intro n _\n      use n + 1\n      simp only [Ne, Nat.succ_ne_zero, not_false_iff, Nat.cast_add, Nat.cast_one, true_and]\n      -- `b (n + 1) âŠ† b n` follows from `Antitone`.\n      have h : b (n + 1) âŠ† b n := bE.2 (by simp)\n      refine _root_.trans ?_ h\n      rintro y âŸ¨x, hx, hyâŸ©\n      -- Since `b (n + 1)` is balanced `(n+1)â»Â¹ b (n + 1) âŠ† b (n + 1)`\n      rw [â† hy]\n      refine (bE1 (n + 1)).2.smul_mem ?_ hx\n      have h' : 0 < (n : â„) + 1 := n.cast_add_one_pos\n      rw [norm_inv, â† Nat.cast_one, â† Nat.cast_add, RCLike.norm_natCast, Nat.cast_add,\n        Nat.cast_one, inv_le_commâ‚€ h' zero_lt_one]\n      simp\n    intro n hn\n    -- The converse direction follows from continuity of the scalar multiplication\n    have hcont : ContinuousAt (fun x : E => (n : ğ•œ) â€¢ x) 0 :=\n      (continuous_const_smul (n : ğ•œ)).continuousAt\n    simp only [ContinuousAt, map_zero, smul_zero] at hcont\n    rw [bE.1.tendsto_left_iff] at hcont\n    rcases hcont (b n) (bE1 n).1 with âŸ¨i, _, hiâŸ©\n    refine âŸ¨i, trivial, fun x hx => âŸ¨(n : ğ•œ) â€¢ x, hi hx, ?_âŸ©âŸ©\n    simp [â† mul_smul, hn]\n  rw [ContinuousAt, map_zero, bE'.tendsto_iff (nhds_basis_balanced ğ•œ' F)] at h\n  push_neg at h\n  rcases h with âŸ¨V, âŸ¨hV, -âŸ©, hâŸ©\n  simp only [_root_.id, forall_true_left] at h\n  -- There exists `u : â„• â†’ E` such that for all `n : â„•` we have `u n âˆˆ nâ»Â¹ â€¢ b n` and `f (u n) âˆ‰ V`\n  choose! u hu hu' using h\n  -- The sequence `(fun n â†¦ n â€¢ u n)` converges to `0`\n  have h_tendsto : Tendsto (fun n : â„• => (n : ğ•œ) â€¢ u n) atTop (ğ“ (0 : E)) := by\n    apply bE.tendsto\n    intro n\n    by_cases h : n = 0\n    Â· rw [h, Nat.cast_zero, zero_smul]\n      exact mem_of_mem_nhds (bE.1.mem_of_mem <| by trivial)\n    rcases hu n h with âŸ¨y, hy, hu1âŸ©\n    convert hy\n    rw [â† hu1, â† mul_smul]\n    simp only [h, mul_inv_cancelâ‚€, Ne, Nat.cast_eq_zero, not_false_iff, one_smul]\n  -- The image `(fun n â†¦ n â€¢ u n)` is von Neumann bounded:\n  have h_bounded : IsVonNBounded ğ•œ (Set.range fun n : â„• => (n : ğ•œ) â€¢ u n) :=\n    h_tendsto.cauchySeq.totallyBounded_range.isVonNBounded ğ•œ\n  -- Since `range u` is bounded, `V` absorbs it\n  rcases (hf _ h_bounded hV).exists_pos with âŸ¨r, hr, h'âŸ©\n  cases' exists_nat_gt r with n hn\n  -- We now find a contradiction between `f (u n) âˆ‰ V` and the absorbing property\n  have h1 : r â‰¤ â€–(n : ğ•œ')â€– := by\n    rw [RCLike.norm_natCast]\n    exact hn.le\n  have hn' : 0 < â€–(n : ğ•œ')â€– := lt_of_lt_of_le hr h1\n  rw [norm_pos_iff, Ne, Nat.cast_eq_zero] at hn'\n  have h'' : f (u n) âˆˆ V := by\n    simp only [Set.image_subset_iff] at h'\n    specialize h' (n : ğ•œ') h1 (Set.mem_range_self n)\n    simp only [Set.mem_preimage, LinearMap.map_smulâ‚›â‚—, map_natCast] at h'\n    rcases h' with âŸ¨y, hy, h'âŸ©\n    apply_fun fun y : F => (n : ğ•œ')â»Â¹ â€¢ y at h'\n    simp only [hn', inv_smul_smulâ‚€, Ne, Nat.cast_eq_zero, not_false_iff] at h'\n    rwa [â† h']\n  exact hu' n hn' h''\n\n"}
{"name":"LinearMap.continuous_of_locally_bounded","module":"Mathlib.Analysis.LocallyConvex.ContinuousOfBounded","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : UniformSpace E\ninstâœÂ¹â° : UniformAddGroup E\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : FirstCountableTopology E\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : ContinuousSMul ğ•œ E\ninstâœÂ³ : RCLike ğ•œ'\ninstâœÂ² : Module ğ•œ' F\ninstâœÂ¹ : ContinuousSMul ğ•œ' F\nÏƒ : RingHom ğ•œ ğ•œ'\ninstâœ : UniformAddGroup F\nf : LinearMap Ïƒ E F\nhf : âˆ€ (s : Set E), Bornology.IsVonNBounded ğ•œ s â†’ Bornology.IsVonNBounded ğ•œ' (Set.image (â‡‘f) s)\nâŠ¢ Continuous â‡‘f","decl":"/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem LinearMap.continuous_of_locally_bounded [UniformAddGroup F] (f : E â†’â‚›â‚—[Ïƒ] F)\n    (hf : âˆ€ s, IsVonNBounded ğ•œ s â†’ IsVonNBounded ğ•œ' (f '' s)) : Continuous f :=\n  (uniformContinuous_of_continuousAt_zero f <| f.continuousAt_zero_of_locally_bounded hf).continuous\n\n"}
