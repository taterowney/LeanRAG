{"name":"Nat.find_spec","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nH : Exists fun n => p n\n⊢ p (Nat.find H)","decl":"protected theorem find_spec : p (Nat.find H) :=\n  (Nat.findX H).2.left\n\n"}
{"name":"Nat.find_min","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nH : Exists fun n => p n\nm : Nat\na✝ : LT.lt m (Nat.find H)\n⊢ Not (p m)","decl":"protected theorem find_min : ∀ {m : ℕ}, m < Nat.find H → ¬p m :=\n  @(Nat.findX H).2.right\n\n"}
{"name":"Nat.find_min'","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nH : Exists fun n => p n\nm : Nat\nh : p m\n⊢ LE.le (Nat.find H) m","decl":"protected theorem find_min' {m : ℕ} (h : p m) : Nat.find H ≤ m :=\n  Nat.le_of_not_lt fun l => Nat.find_min H l h\n\n"}
{"name":"Nat.find_eq_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"m : Nat\np : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Iff (Eq (Nat.find h) m) (And (p m) (∀ (n : Nat), LT.lt n m → Not (p n)))","decl":"lemma find_eq_iff (h : ∃ n : ℕ, p n) : Nat.find h = m ↔ p m ∧ ∀ n < m, ¬ p n := by\n  constructor\n  · rintro rfl\n    exact ⟨Nat.find_spec h, fun _ ↦ Nat.find_min h⟩\n  · rintro ⟨hm, hlt⟩\n    exact le_antisymm (Nat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| Nat.find_spec h)\n\n"}
{"name":"Nat.find_lt_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : Nat\n⊢ Iff (LT.lt (Nat.find h) n) (Exists fun m => And (LT.lt m n) (p m))","decl":"@[simp] lemma find_lt_iff (h : ∃ n : ℕ, p n) (n : ℕ) : Nat.find h < n ↔ ∃ m < n, p m :=\n  ⟨fun h2 ↦ ⟨Nat.find h, h2, Nat.find_spec h⟩,\n    fun ⟨_, hmn, hm⟩ ↦ Nat.lt_of_le_of_lt (Nat.find_min' h hm) hmn⟩\n\n"}
{"name":"Nat.find_le_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : Nat\n⊢ Iff (LE.le (Nat.find h) n) (Exists fun m => And (LE.le m n) (p m))","decl":"@[simp] lemma find_le_iff (h : ∃ n : ℕ, p n) (n : ℕ) : Nat.find h ≤ n ↔ ∃ m ≤ n, p m := by\n  simp only [exists_prop, ← Nat.lt_succ_iff, find_lt_iff]\n\n"}
{"name":"Nat.le_find_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : Nat\n⊢ Iff (LE.le n (Nat.find h)) (∀ (m : Nat), LT.lt m n → Not (p m))","decl":"@[simp] lemma le_find_iff (h : ∃ n : ℕ, p n) (n : ℕ) : n ≤ Nat.find h ↔ ∀ m < n, ¬ p m := by\n  simp only [← not_lt, find_lt_iff, not_exists, not_and]\n\n"}
{"name":"Nat.lt_find_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : Nat\n⊢ Iff (LT.lt n (Nat.find h)) (∀ (m : Nat), LE.le m n → Not (p m))","decl":"@[simp] lemma lt_find_iff (h : ∃ n : ℕ, p n) (n : ℕ) : n < Nat.find h ↔ ∀ m ≤ n, ¬ p m := by\n  simp only [← succ_le_iff, le_find_iff, succ_le_succ_iff]\n\n"}
{"name":"Nat.find_eq_zero","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Iff (Eq (Nat.find h) 0) (p 0)","decl":"@[simp] lemma find_eq_zero (h : ∃ n : ℕ, p n) : Nat.find h = 0 ↔ p 0 := by simp [find_eq_iff]\n\n"}
{"name":"Nat.find_mono","module":"Mathlib.Data.Nat.Find","initialProofState":"p q : Nat → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nh : ∀ (n : Nat), q n → p n\nhp : Exists fun n => p n\nhq : Exists fun n => q n\n⊢ LE.le (Nat.find hp) (Nat.find hq)","decl":"variable [DecidablePred q] in\nlemma find_mono (h : ∀ n, q n → p n) {hp : ∃ n, p n} {hq : ∃ n, q n} : Nat.find hp ≤ Nat.find hq :=\n  Nat.find_min' _ (h _ (Nat.find_spec hq))\n\n"}
{"name":"Nat.find_le","module":"Mathlib.Data.Nat.Find","initialProofState":"n : Nat\np : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nhn : p n\n⊢ LE.le (Nat.find h) n","decl":"lemma find_le {h : ∃ n, p n} (hn : p n) : Nat.find h ≤ n :=\n  (Nat.find_le_iff _ _).2 ⟨n, le_refl _, hn⟩\n\n"}
{"name":"Nat.find_comp_succ","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh₁ : Exists fun n => p n\nh₂ : Exists fun n => p (HAdd.hAdd n 1)\nh0 : Not (p 0)\n⊢ Eq (Nat.find h₁) (HAdd.hAdd (Nat.find h₂) 1)","decl":"lemma find_comp_succ (h₁ : ∃ n, p n) (h₂ : ∃ n, p (n + 1)) (h0 : ¬ p 0) :\n    Nat.find h₁ = Nat.find h₂ + 1 := by\n  refine (find_eq_iff _).2 ⟨Nat.find_spec h₂, fun n hn ↦ ?_⟩\n  cases n\n  exacts [h0, @Nat.find_min (fun n ↦ p (n + 1)) _ h₂ _ (succ_lt_succ_iff.1 hn)]\n\n"}
{"name":"Nat.find_pos","module":"Mathlib.Data.Nat.Find","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Iff (LT.lt 0 (Nat.find h)) (Not (p 0))","decl":"lemma find_pos (h : ∃ n : ℕ, p n) : 0 < Nat.find h ↔ ¬p 0 :=\n  Nat.pos_iff_ne_zero.trans (Nat.find_eq_zero _).not\n\n"}
{"name":"Nat.find_add","module":"Mathlib.Data.Nat.Find","initialProofState":"n : Nat\np : Nat → Prop\ninst✝ : DecidablePred p\nhₘ : Exists fun m => p (HAdd.hAdd m n)\nhₙ : Exists fun n => p n\nhn : LE.le n (Nat.find hₙ)\n⊢ Eq (HAdd.hAdd (Nat.find hₘ) n) (Nat.find hₙ)","decl":"lemma find_add {hₘ : ∃ m, p (m + n)} {hₙ : ∃ n, p n} (hn : n ≤ Nat.find hₙ) :\n    Nat.find hₘ + n = Nat.find hₙ := by\n  refine le_antisymm ((le_find_iff _ _).2 fun m hm hpm => Nat.not_le.2 hm ?_) ?_\n  · have hnm : n ≤ m := le_trans hn (find_le hpm)\n    refine Nat.add_le_of_le_sub hnm (find_le ?_)\n    rwa [Nat.sub_add_cancel hnm]\n  · rw [← Nat.sub_le_iff_le_add]\n    refine (le_find_iff _ _).2 fun m hm hpm => Nat.not_le.2 hm ?_\n    rw [Nat.sub_le_iff_le_add]\n    exact find_le hpm\n\n"}
{"name":"Nat.findGreatest_zero","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Nat.findGreatest P 0) 0","decl":"@[simp] lemma findGreatest_zero : Nat.findGreatest P 0 = 0 := rfl\n\n"}
{"name":"Nat.findGreatest_succ","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\n⊢ Eq (Nat.findGreatest P (HAdd.hAdd n 1)) (ite (P (HAdd.hAdd n 1)) (HAdd.hAdd n 1) (Nat.findGreatest P n))","decl":"lemma findGreatest_succ (n : ℕ) :\n    Nat.findGreatest P (n + 1) = if P (n + 1) then n + 1 else Nat.findGreatest P n := rfl\n\n"}
{"name":"Nat.findGreatest_eq","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\na✝ : P n\n⊢ Eq (Nat.findGreatest P n) n","decl":"@[simp] lemma findGreatest_eq : ∀ {n}, P n → Nat.findGreatest P n = n\n  | 0, _ => rfl\n  | n + 1, h => by simp [Nat.findGreatest, h]\n\n"}
{"name":"Nat.findGreatest_of_not","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nh : Not (P (HAdd.hAdd n 1))\n⊢ Eq (Nat.findGreatest P (HAdd.hAdd n 1)) (Nat.findGreatest P n)","decl":"@[simp]\nlemma findGreatest_of_not (h : ¬ P (n + 1)) : findGreatest P (n + 1) = findGreatest P n := by\n  simp [Nat.findGreatest, h]\n\n"}
{"name":"Nat.findGreatest_eq_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"m k : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\n⊢ Iff (Eq (Nat.findGreatest P k) m) (And (LE.le m k) (And (Ne m 0 → P m) (∀ ⦃n : Nat⦄, LT.lt m n → LE.le n k → Not (P n))))","decl":"lemma findGreatest_eq_iff :\n    Nat.findGreatest P k = m ↔ m ≤ k ∧ (m ≠ 0 → P m) ∧ ∀ ⦃n⦄, m < n → n ≤ k → ¬P n := by\n  induction k generalizing m with\n  | zero =>\n    rw [eq_comm, Iff.comm]\n    simp only [zero_eq, Nat.le_zero, ne_eq, findGreatest_zero, and_iff_left_iff_imp]\n    rintro rfl\n    exact ⟨fun h ↦ (h rfl).elim, fun n hlt heq ↦ by omega⟩\n  | succ k ihk =>\n    by_cases hk : P (k + 1)\n    · rw [findGreatest_eq hk]\n      constructor\n      · rintro rfl\n        exact ⟨le_refl _, fun _ ↦ hk, fun n hlt hle ↦ by omega⟩\n      · rintro ⟨hle, h0, hm⟩\n        rcases Decidable.eq_or_lt_of_le hle with (rfl | hlt)\n        exacts [rfl, (hm hlt (le_refl _) hk).elim]\n    · rw [findGreatest_of_not hk, ihk]\n      constructor\n      · rintro ⟨hle, hP, hm⟩\n        refine ⟨le_trans hle k.le_succ, hP, fun n hlt hle ↦ ?_⟩\n        rcases Decidable.eq_or_lt_of_le hle with (rfl | hlt')\n        exacts [hk, hm hlt <| Nat.lt_succ_iff.1 hlt']\n      · rintro ⟨hle, hP, hm⟩\n        refine ⟨Nat.lt_succ_iff.1 (lt_of_le_of_ne hle ?_), hP,\n          fun n hlt hle ↦ hm hlt (le_trans hle k.le_succ)⟩\n        rintro rfl\n        exact hk (hP k.succ_ne_zero)\n\n"}
{"name":"Nat.findGreatest_eq_zero_iff","module":"Mathlib.Data.Nat.Find","initialProofState":"k : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\n⊢ Iff (Eq (Nat.findGreatest P k) 0) (∀ ⦃n : Nat⦄, LT.lt 0 n → LE.le n k → Not (P n))","decl":"lemma findGreatest_eq_zero_iff : Nat.findGreatest P k = 0 ↔ ∀ ⦃n⦄, 0 < n → n ≤ k → ¬P n := by\n  simp [findGreatest_eq_iff]\n\n"}
{"name":"Nat.findGreatest_pos","module":"Mathlib.Data.Nat.Find","initialProofState":"k : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\n⊢ Iff (LT.lt 0 (Nat.findGreatest P k)) (Exists fun n => And (LT.lt 0 n) (And (LE.le n k) (P n)))","decl":"@[simp] lemma findGreatest_pos : 0 < Nat.findGreatest P k ↔ ∃ n, 0 < n ∧ n ≤ k ∧ P n := by\n  rw [Nat.pos_iff_ne_zero, Ne, findGreatest_eq_zero_iff]; push_neg; rfl\n\n"}
{"name":"Nat.findGreatest_spec","module":"Mathlib.Data.Nat.Find","initialProofState":"m : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nhmb : LE.le m n\nhm : P m\n⊢ P (Nat.findGreatest P n)","decl":"lemma findGreatest_spec (hmb : m ≤ n) (hm : P m) : P (Nat.findGreatest P n) := by\n  by_cases h : Nat.findGreatest P n = 0\n  · cases m\n    · rwa [h]\n    exact ((findGreatest_eq_zero_iff.1 h) (zero_lt_succ _) hmb hm).elim\n  · exact (findGreatest_eq_iff.1 rfl).2.1 h\n\n"}
{"name":"Nat.findGreatest_le","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\n⊢ LE.le (Nat.findGreatest P n) n","decl":"lemma findGreatest_le (n : ℕ) : Nat.findGreatest P n ≤ n :=\n  (findGreatest_eq_iff.1 rfl).1\n\n"}
{"name":"Nat.le_findGreatest","module":"Mathlib.Data.Nat.Find","initialProofState":"m : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nhmb : LE.le m n\nhm : P m\n⊢ LE.le m (Nat.findGreatest P n)","decl":"lemma le_findGreatest (hmb : m ≤ n) (hm : P m) : m ≤ Nat.findGreatest P n :=\n  le_of_not_lt fun hlt => (findGreatest_eq_iff.1 rfl).2.2 hlt hmb hm\n\n"}
{"name":"Nat.findGreatest_mono_right","module":"Mathlib.Data.Nat.Find","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nm n : Nat\nhmn : LE.le m n\n⊢ LE.le (Nat.findGreatest P m) (Nat.findGreatest P n)","decl":"lemma findGreatest_mono_right (P : ℕ → Prop) [DecidablePred P] {m n} (hmn : m ≤ n) :\n    Nat.findGreatest P m ≤ Nat.findGreatest P n := by\n  induction hmn with\n  | refl => simp\n  | step hmk ih =>\n    rw [findGreatest_succ]\n    split_ifs\n    · exact le_trans ih <| le_trans (findGreatest_le _) (le_succ _)\n    · exact ih\n\n"}
{"name":"Nat.findGreatest_mono_left","module":"Mathlib.Data.Nat.Find","initialProofState":"P Q : Nat → Prop\ninst✝¹ : DecidablePred P\ninst✝ : DecidablePred Q\nhPQ : ∀ (n : Nat), P n → Q n\nn : Nat\n⊢ LE.le (Nat.findGreatest P n) (Nat.findGreatest Q n)","decl":"lemma findGreatest_mono_left [DecidablePred Q] (hPQ : ∀ n, P n → Q n) (n : ℕ) :\n    Nat.findGreatest P n ≤ Nat.findGreatest Q n := by\n  induction n with\n  | zero => rfl\n  | succ n hn =>\n    by_cases h : P (n + 1)\n    · rw [findGreatest_eq h, findGreatest_eq (hPQ _ h)]\n    · rw [findGreatest_of_not h]\n      exact le_trans hn (Nat.findGreatest_mono_right _ <| le_succ _)\n\n"}
{"name":"Nat.findGreatest_mono","module":"Mathlib.Data.Nat.Find","initialProofState":"m : Nat\nP Q : Nat → Prop\ninst✝¹ : DecidablePred P\nn : Nat\ninst✝ : DecidablePred Q\nhPQ : ∀ (n : Nat), P n → Q n\nhmn : LE.le m n\n⊢ LE.le (Nat.findGreatest P m) (Nat.findGreatest Q n)","decl":"lemma findGreatest_mono [DecidablePred Q] (hPQ : ∀ n, P n → Q n) (hmn : m ≤ n) :\n    Nat.findGreatest P m ≤ Nat.findGreatest Q n :=\n  le_trans (Nat.findGreatest_mono_right _ hmn) (findGreatest_mono_left hPQ _)\n\n"}
{"name":"Nat.findGreatest_is_greatest","module":"Mathlib.Data.Nat.Find","initialProofState":"k : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nhk : LT.lt (Nat.findGreatest P n) k\nhkb : LE.le k n\n⊢ Not (P k)","decl":"theorem findGreatest_is_greatest (hk : Nat.findGreatest P n < k) (hkb : k ≤ n) : ¬P k :=\n  (findGreatest_eq_iff.1 rfl).2.2 hk hkb\n\n"}
{"name":"Nat.findGreatest_of_ne_zero","module":"Mathlib.Data.Nat.Find","initialProofState":"m : Nat\nP : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nh : Eq (Nat.findGreatest P n) m\nh0 : Ne m 0\n⊢ P m","decl":"theorem findGreatest_of_ne_zero (h : Nat.findGreatest P n = m) (h0 : m ≠ 0) : P m :=\n  (findGreatest_eq_iff.1 h).2.1 h0\n\n"}
