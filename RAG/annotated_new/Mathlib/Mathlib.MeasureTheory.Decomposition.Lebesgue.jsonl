{"name":"MeasureTheory.Measure.HaveLebesgueDecomposition.lebesgue_decomposition","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nself : μ.HaveLebesgueDecomposition ν\n⊢ Exists fun p => And (Measurable p.2) (And (p.1.MutuallySingular ν) (Eq μ (HAdd.hAdd p.1 (ν.withDensity p.2))))","decl":"/-- A pair of measures `μ` and `ν` is said to `HaveLebesgueDecomposition` if there exists a\nmeasure `ξ` and a measurable function `f`, such that `ξ` is mutually singular with respect to\n`ν` and `μ = ξ + ν.withDensity f`. -/\nclass HaveLebesgueDecomposition (μ ν : Measure α) : Prop where\n  lebesgue_decomposition :\n    ∃ p : Measure α × (α → ℝ≥0∞), Measurable p.2 ∧ p.1 ⟂ₘ ν ∧ μ = p.1 + ν.withDensity p.2\n\n"}
{"name":"MeasureTheory.Measure.singularPart_def","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (μ.singularPart ν) (dite (μ.HaveLebesgueDecomposition ν) (fun h => (Classical.choose ⋯).1) fun h => 0)","decl":"open Classical in\n/-- If a pair of measures `HaveLebesgueDecomposition`, then `singularPart` chooses the\nmeasure from `HaveLebesgueDecomposition`, otherwise it returns the zero measure. For sigma-finite\nmeasures, `μ = μ.singularPart ν + ν.withDensity (μ.rnDeriv ν)`. -/\nnoncomputable irreducible_def singularPart (μ ν : Measure α) : Measure α :=\n  if h : HaveLebesgueDecomposition μ ν then (Classical.choose h.lebesgue_decomposition).1 else 0\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_def","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (μ.rnDeriv ν) (dite (μ.HaveLebesgueDecomposition ν) (fun h => (Classical.choose ⋯).2) fun h => 0)","decl":"open Classical in\n/-- If a pair of measures `HaveLebesgueDecomposition`, then `rnDeriv` chooses the\nmeasurable function from `HaveLebesgueDecomposition`, otherwise it returns the zero function.\nFor sigma-finite measures, `μ = μ.singularPart ν + ν.withDensity (μ.rnDeriv ν)`. -/\nnoncomputable irreducible_def rnDeriv (μ ν : Measure α) : α → ℝ≥0∞ :=\n  if h : HaveLebesgueDecomposition μ ν then (Classical.choose h.lebesgue_decomposition).2 else 0\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecomposition_spec","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.HaveLebesgueDecomposition ν\n⊢ And (Measurable (μ.rnDeriv ν)) (And ((μ.singularPart ν).MutuallySingular ν) (Eq μ (HAdd.hAdd (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν)))))","decl":"theorem haveLebesgueDecomposition_spec (μ ν : Measure α) [h : HaveLebesgueDecomposition μ ν] :\n    Measurable (μ.rnDeriv ν) ∧\n      μ.singularPart ν ⟂ₘ ν ∧ μ = μ.singularPart ν + ν.withDensity (μ.rnDeriv ν) := by\n  rw [singularPart, rnDeriv, dif_pos h, dif_pos h]\n  exact Classical.choose_spec h.lebesgue_decomposition\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_of_not_haveLebesgueDecomposition","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : Not (μ.HaveLebesgueDecomposition ν)\n⊢ Eq (μ.rnDeriv ν) 0","decl":"lemma rnDeriv_of_not_haveLebesgueDecomposition (h : ¬ HaveLebesgueDecomposition μ ν) :\n    μ.rnDeriv ν = 0 := by\n  rw [rnDeriv, dif_neg h]\n\n"}
{"name":"MeasureTheory.Measure.singularPart_of_not_haveLebesgueDecomposition","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : Not (μ.HaveLebesgueDecomposition ν)\n⊢ Eq (μ.singularPart ν) 0","decl":"lemma singularPart_of_not_haveLebesgueDecomposition (h : ¬ HaveLebesgueDecomposition μ ν) :\n    μ.singularPart ν = 0 := by\n  rw [singularPart, dif_neg h]\n\n"}
{"name":"MeasureTheory.Measure.measurable_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Measurable (μ.rnDeriv ν)","decl":"@[measurability, fun_prop]\ntheorem measurable_rnDeriv (μ ν : Measure α) : Measurable <| μ.rnDeriv ν := by\n  by_cases h : HaveLebesgueDecomposition μ ν\n  · exact (haveLebesgueDecomposition_spec μ ν).1\n  · rw [rnDeriv_of_not_haveLebesgueDecomposition h]\n    exact measurable_zero\n\n"}
{"name":"MeasureTheory.Measure.mutuallySingular_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ (μ.singularPart ν).MutuallySingular ν","decl":"theorem mutuallySingular_singularPart (μ ν : Measure α) : μ.singularPart ν ⟂ₘ ν := by\n  by_cases h : HaveLebesgueDecomposition μ ν\n  · exact (haveLebesgueDecomposition_spec μ ν).2.1\n  · rw [singularPart_of_not_haveLebesgueDecomposition h]\n    exact MutuallySingular.zero_left\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecomposition_add","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Eq μ (HAdd.hAdd (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν)))","decl":"theorem haveLebesgueDecomposition_add (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] :\n    μ = μ.singularPart ν + ν.withDensity (μ.rnDeriv ν) :=\n  (haveLebesgueDecomposition_spec μ ν).2.2\n\n"}
{"name":"MeasureTheory.Measure.singularPart_add_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Eq (HAdd.hAdd (μ.singularPart ν) (ν.withDensity (μ.rnDeriv ν))) μ","decl":"/-- For the versions of this lemma where `ν.withDensity (μ.rnDeriv ν)` or `μ.singularPart ν` are\nisolated, see `MeasureTheory.Measure.measure_sub_singularPart` and\n`MeasureTheory.Measure.measure_sub_rnDeriv`. -/\nlemma singularPart_add_rnDeriv (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] :\n    μ.singularPart ν + ν.withDensity (μ.rnDeriv ν) = μ := (haveLebesgueDecomposition_add μ ν).symm\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Eq (HAdd.hAdd (ν.withDensity (μ.rnDeriv ν)) (μ.singularPart ν)) μ","decl":"/-- For the versions of this lemma where `μ.singularPart ν` or `ν.withDensity (μ.rnDeriv ν)` are\nisolated, see `MeasureTheory.Measure.measure_sub_singularPart` and\n`MeasureTheory.Measure.measure_sub_rnDeriv`. -/\nlemma rnDeriv_add_singularPart (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] :\n    ν.withDensity (μ.rnDeriv ν) + μ.singularPart ν = μ := by rw [add_comm, singularPart_add_rnDeriv]\n\n"}
{"name":"MeasureTheory.Measure.instHaveLebesgueDecompositionZeroLeft","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\n⊢ MeasureTheory.Measure.HaveLebesgueDecomposition 0 ν","decl":"instance instHaveLebesgueDecompositionZeroLeft : HaveLebesgueDecomposition 0 ν where\n  lebesgue_decomposition := ⟨⟨0, 0⟩, measurable_zero, MutuallySingular.zero_left, by simp⟩\n\n"}
{"name":"MeasureTheory.Measure.instHaveLebesgueDecompositionZeroRight","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ μ.HaveLebesgueDecomposition 0","decl":"instance instHaveLebesgueDecompositionZeroRight : HaveLebesgueDecomposition μ 0 where\n  lebesgue_decomposition := ⟨⟨μ, 0⟩, measurable_zero, MutuallySingular.zero_right, by simp⟩\n\n"}
{"name":"MeasureTheory.Measure.instHaveLebesgueDecompositionSelf","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ μ.HaveLebesgueDecomposition μ","decl":"instance instHaveLebesgueDecompositionSelf : HaveLebesgueDecomposition μ μ where\n  lebesgue_decomposition := ⟨⟨0, 1⟩, measurable_const, MutuallySingular.zero_left, by simp⟩\n\n"}
{"name":"MeasureTheory.Measure.HaveLebesgueDecomposition.sum_left","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\nι : Type u_2\ninst✝¹ : Countable ι\nμ : ι → MeasureTheory.Measure α\ninst✝ : ∀ (i : ι), (μ i).HaveLebesgueDecomposition ν\n⊢ (MeasureTheory.Measure.sum μ).HaveLebesgueDecomposition ν","decl":"instance HaveLebesgueDecomposition.sum_left {ι : Type*} [Countable ι] (μ : ι → Measure α)\n    [∀ i, HaveLebesgueDecomposition (μ i) ν] : HaveLebesgueDecomposition (.sum μ) ν :=\n  ⟨(.sum fun i ↦ (μ i).singularPart ν, ∑' i, rnDeriv (μ i) ν),\n    by dsimp only; fun_prop, by simp [mutuallySingular_singularPart], by\n      simp [withDensity_tsum, measurable_rnDeriv, Measure.sum_add_sum, singularPart_add_rnDeriv]⟩\n\n"}
{"name":"MeasureTheory.Measure.HaveLebesgueDecomposition.add_left","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν μ' : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : μ'.HaveLebesgueDecomposition ν\n⊢ (HAdd.hAdd μ μ').HaveLebesgueDecomposition ν","decl":"instance HaveLebesgueDecomposition.add_left {μ' : Measure α} [HaveLebesgueDecomposition μ ν]\n    [HaveLebesgueDecomposition μ' ν] : HaveLebesgueDecomposition (μ + μ') ν := by\n  have : ∀ b, HaveLebesgueDecomposition (cond b μ μ') ν := by simp [*]\n  simpa using sum_left (cond · μ μ')\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecompositionSMul'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nr : ENNReal\n⊢ (HSMul.hSMul r μ).HaveLebesgueDecomposition ν","decl":"instance haveLebesgueDecompositionSMul' (μ ν : Measure α) [HaveLebesgueDecomposition μ ν]\n    (r : ℝ≥0∞) : (r • μ).HaveLebesgueDecomposition ν where\n  lebesgue_decomposition := by\n    obtain ⟨hmeas, hsing, hadd⟩ := haveLebesgueDecomposition_spec μ ν\n    refine ⟨⟨r • μ.singularPart ν, r • μ.rnDeriv ν⟩, hmeas.const_smul _, hsing.smul _, ?_⟩\n    simp only [ENNReal.smul_def]\n    rw [withDensity_smul _ hmeas, ← smul_add, ← hadd]\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecompositionSMul","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nr : NNReal\n⊢ (HSMul.hSMul r μ).HaveLebesgueDecomposition ν","decl":"instance haveLebesgueDecompositionSMul (μ ν : Measure α) [HaveLebesgueDecomposition μ ν]\n    (r : ℝ≥0) : (r • μ).HaveLebesgueDecomposition ν := by\n  rw [ENNReal.smul_def]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecompositionSMulRight","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nr : NNReal\n⊢ μ.HaveLebesgueDecomposition (HSMul.hSMul r ν)","decl":"instance haveLebesgueDecompositionSMulRight (μ ν : Measure α) [HaveLebesgueDecomposition μ ν]\n    (r : ℝ≥0) :\n    μ.HaveLebesgueDecomposition (r • ν) where\n  lebesgue_decomposition := by\n    obtain ⟨hmeas, hsing, hadd⟩ := haveLebesgueDecomposition_spec μ ν\n    by_cases hr : r = 0\n    · exact ⟨⟨μ, 0⟩, measurable_const, by simp [hr], by simp⟩\n    refine ⟨⟨μ.singularPart ν, r⁻¹ • μ.rnDeriv ν⟩, hmeas.const_smul _,\n      hsing.mono_ac AbsolutelyContinuous.rfl smul_absolutelyContinuous, ?_⟩\n    have : r⁻¹ • rnDeriv μ ν = ((r⁻¹ : ℝ≥0) : ℝ≥0∞) • rnDeriv μ ν := by simp [ENNReal.smul_def]\n    rw [this, withDensity_smul _ hmeas, ENNReal.smul_def r, withDensity_smul_measure,\n      ← smul_assoc, smul_eq_mul, ENNReal.coe_inv hr, ENNReal.inv_mul_cancel, one_smul]\n    · exact hadd\n    · simp [hr]\n    · exact ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecomposition_withDensity","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\n⊢ (μ.withDensity f).HaveLebesgueDecomposition μ","decl":"theorem haveLebesgueDecomposition_withDensity (μ : Measure α) {f : α → ℝ≥0∞} (hf : Measurable f) :\n    (μ.withDensity f).HaveLebesgueDecomposition μ := ⟨⟨⟨0, f⟩, hf, .zero_left, (zero_add _).symm⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecompositionRnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ (ν.withDensity (μ.rnDeriv ν)).HaveLebesgueDecomposition ν","decl":"instance haveLebesgueDecompositionRnDeriv (μ ν : Measure α) :\n    HaveLebesgueDecomposition (ν.withDensity (μ.rnDeriv ν)) ν :=\n  haveLebesgueDecomposition_withDensity ν (measurable_rnDeriv _ _)\n\n"}
{"name":"MeasureTheory.Measure.instHaveLebesgueDecompositionSingularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ (μ.singularPart ν).HaveLebesgueDecomposition ν","decl":"instance instHaveLebesgueDecompositionSingularPart :\n    HaveLebesgueDecomposition (μ.singularPart ν) ν :=\n  ⟨⟨μ.singularPart ν, 0⟩, measurable_zero, mutuallySingular_singularPart μ ν, by simp⟩\n\n"}
{"name":"MeasureTheory.Measure.singularPart_le","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ LE.le (μ.singularPart ν) μ","decl":"theorem singularPart_le (μ ν : Measure α) : μ.singularPart ν ≤ μ := by\n  by_cases hl : HaveLebesgueDecomposition μ ν\n  · conv_rhs => rw [haveLebesgueDecomposition_add μ ν]\n    exact Measure.le_add_right le_rfl\n  · rw [singularPart, dif_neg hl]\n    exact Measure.zero_le μ\n\n"}
{"name":"MeasureTheory.Measure.withDensity_rnDeriv_le","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ LE.le (ν.withDensity (μ.rnDeriv ν)) μ","decl":"theorem withDensity_rnDeriv_le (μ ν : Measure α) : ν.withDensity (μ.rnDeriv ν) ≤ μ := by\n  by_cases hl : HaveLebesgueDecomposition μ ν\n  · conv_rhs => rw [haveLebesgueDecomposition_add μ ν]\n    exact Measure.le_add_left le_rfl\n  · rw [rnDeriv, dif_neg hl, withDensity_zero]\n    exact Measure.zero_le μ\n\n"}
{"name":"AEMeasurable.singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_2\nx✝ : MeasurableSpace β\nf : α → β\nhf : AEMeasurable f μ\nν : MeasureTheory.Measure α\n⊢ AEMeasurable f (μ.singularPart ν)","decl":"lemma _root_.AEMeasurable.singularPart {β : Type*} {_ : MeasurableSpace β} {f : α → β}\n    (hf : AEMeasurable f μ) (ν : Measure α) :\n    AEMeasurable f (μ.singularPart ν) :=\n  AEMeasurable.mono_measure hf (Measure.singularPart_le _ _)\n\n"}
{"name":"AEMeasurable.withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_2\nx✝ : MeasurableSpace β\nf : α → β\nhf : AEMeasurable f μ\nν : MeasureTheory.Measure α\n⊢ AEMeasurable f (ν.withDensity (μ.rnDeriv ν))","decl":"lemma _root_.AEMeasurable.withDensity_rnDeriv {β : Type*} {_ : MeasurableSpace β} {f : α → β}\n    (hf : AEMeasurable f μ) (ν : Measure α) :\n    AEMeasurable f (ν.withDensity (μ.rnDeriv ν)) :=\n  AEMeasurable.mono_measure hf (Measure.withDensity_rnDeriv_le _ _)\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.MutuallySingular ν\nν' : MeasureTheory.Measure α\n⊢ (μ.singularPart ν').MutuallySingular ν","decl":"lemma MutuallySingular.singularPart (h : μ ⟂ₘ ν) (ν' : Measure α) :\n    μ.singularPart ν' ⟂ₘ ν :=\n  h.mono (singularPart_le μ ν') le_rfl\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : ν.HaveLebesgueDecomposition μ\nhμν : μ.AbsolutelyContinuous ν\n⊢ μ.AbsolutelyContinuous (μ.withDensity (ν.rnDeriv μ))","decl":"lemma absolutelyContinuous_withDensity_rnDeriv [HaveLebesgueDecomposition ν μ] (hμν : μ ≪ ν) :\n    μ ≪ μ.withDensity (ν.rnDeriv μ) := by\n  rw [haveLebesgueDecomposition_add ν μ] at hμν\n  refine AbsolutelyContinuous.mk (fun s _ hνs ↦ ?_)\n  obtain ⟨t, _, ht1, ht2⟩ := mutuallySingular_singularPart ν μ\n  rw [← inter_union_compl s]\n  refine le_antisymm ((measure_union_le (s ∩ t) (s ∩ tᶜ)).trans ?_) (zero_le _)\n  simp only [nonpos_iff_eq_zero, add_eq_zero]\n  constructor\n  · refine hμν ?_\n    simp only [coe_add, Pi.add_apply, add_eq_zero]\n    constructor\n    · exact measure_mono_null Set.inter_subset_right ht1\n    · exact measure_mono_null Set.inter_subset_left hνs\n  · exact measure_mono_null Set.inter_subset_right ht2\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν ξ : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\nhξμ : ξ.AbsolutelyContinuous μ\nhξν : ξ.AbsolutelyContinuous ν\n⊢ ξ.AbsolutelyContinuous (ν.withDensity (μ.rnDeriv ν))","decl":"lemma AbsolutelyContinuous.withDensity_rnDeriv {ξ : Measure α} [μ.HaveLebesgueDecomposition ν]\n    (hξμ : ξ ≪ μ) (hξν : ξ ≪ ν) :\n    ξ ≪ ν.withDensity (μ.rnDeriv ν) := by\n  conv_rhs at hξμ => rw [μ.haveLebesgueDecomposition_add ν, add_comm]\n  refine absolutelyContinuous_of_add_of_mutuallySingular hξμ ?_\n  exact MutuallySingular.mono_ac (mutuallySingular_singularPart μ ν).symm hξν .rfl\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_withDensity_rnDeriv_swap","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : ν.HaveLebesgueDecomposition μ\n⊢ (ν.withDensity (μ.rnDeriv ν)).AbsolutelyContinuous (μ.withDensity (ν.rnDeriv μ))","decl":"lemma absolutelyContinuous_withDensity_rnDeriv_swap [ν.HaveLebesgueDecomposition μ] :\n    ν.withDensity (μ.rnDeriv ν) ≪ μ.withDensity (ν.rnDeriv μ) :=\n  (withDensity_absolutelyContinuous ν (μ.rnDeriv ν)).withDensity_rnDeriv\n    (absolutelyContinuous_of_le (withDensity_rnDeriv_le _ _))\n\n"}
{"name":"MeasureTheory.Measure.singularPart_eq_zero_of_ac","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.AbsolutelyContinuous ν\n⊢ Eq (μ.singularPart ν) 0","decl":"lemma singularPart_eq_zero_of_ac (h : μ ≪ ν) : μ.singularPart ν = 0 := by\n  rw [← MutuallySingular.self_iff]\n  exact MutuallySingular.mono_ac (mutuallySingular_singularPart _ _)\n    AbsolutelyContinuous.rfl ((absolutelyContinuous_of_le (singularPart_le _ _)).trans h)\n\n"}
{"name":"MeasureTheory.Measure.singularPart_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.singularPart 0 ν) 0","decl":"@[simp]\ntheorem singularPart_zero (ν : Measure α) : (0 : Measure α).singularPart ν = 0 :=\n  singularPart_eq_zero_of_ac (AbsolutelyContinuous.zero _)\n\n"}
{"name":"MeasureTheory.Measure.singularPart_zero_right","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.singularPart 0) μ","decl":"@[simp]\nlemma singularPart_zero_right (μ : Measure α) : μ.singularPart 0 = μ := by\n  conv_rhs => rw [haveLebesgueDecomposition_add μ 0]\n  simp\n\n"}
{"name":"MeasureTheory.Measure.singularPart_eq_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Iff (Eq (μ.singularPart ν) 0) (μ.AbsolutelyContinuous ν)","decl":"lemma singularPart_eq_zero (μ ν : Measure α) [μ.HaveLebesgueDecomposition ν] :\n    μ.singularPart ν = 0 ↔ μ ≪ ν := by\n  have h_dec := haveLebesgueDecomposition_add μ ν\n  refine ⟨fun h ↦ ?_, singularPart_eq_zero_of_ac⟩\n  rw [h, zero_add] at h_dec\n  rw [h_dec]\n  exact withDensity_absolutelyContinuous ν _\n\n"}
{"name":"MeasureTheory.Measure.withDensity_rnDeriv_eq_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Iff (Eq (ν.withDensity (μ.rnDeriv ν)) 0) (μ.MutuallySingular ν)","decl":"@[simp]\nlemma withDensity_rnDeriv_eq_zero (μ ν : Measure α) [μ.HaveLebesgueDecomposition ν] :\n    ν.withDensity (μ.rnDeriv ν) = 0 ↔ μ ⟂ₘ ν := by\n  have h_dec := haveLebesgueDecomposition_add μ ν\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [h, add_zero] at h_dec\n    rw [h_dec]\n    exact mutuallySingular_singularPart μ ν\n  · rw [← MutuallySingular.self_iff]\n    rw [h_dec, MutuallySingular.add_left_iff] at h\n    refine MutuallySingular.mono_ac h.2 AbsolutelyContinuous.rfl ?_\n    exact withDensity_absolutelyContinuous _ _\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_eq_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Iff ((MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv ν) 0) (μ.MutuallySingular ν)","decl":"@[simp]\nlemma rnDeriv_eq_zero (μ ν : Measure α) [μ.HaveLebesgueDecomposition ν] :\n    μ.rnDeriv ν =ᵐ[ν] 0 ↔ μ ⟂ₘ ν := by\n  rw [← withDensity_rnDeriv_eq_zero, withDensity_eq_zero_iff (measurable_rnDeriv _ _).aemeasurable]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\n⊢ (MeasureTheory.ae ν).EventuallyEq (MeasureTheory.Measure.rnDeriv 0 ν) 0","decl":"lemma rnDeriv_zero (ν : Measure α) : (0 : Measure α).rnDeriv ν =ᵐ[ν] 0 := by\n  rw [rnDeriv_eq_zero]\n  exact MutuallySingular.zero_left\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.rnDeriv_ae_eq_zero","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nhμν : μ.MutuallySingular ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv ν) 0","decl":"lemma MutuallySingular.rnDeriv_ae_eq_zero (hμν : μ ⟂ₘ ν) :\n    μ.rnDeriv ν =ᵐ[ν] 0 := by\n  by_cases h : μ.HaveLebesgueDecomposition ν\n  · rw [rnDeriv_eq_zero]\n    exact hμν\n  · rw [rnDeriv_of_not_haveLebesgueDecomposition h]\n\n"}
{"name":"MeasureTheory.Measure.singularPart_withDensity","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq ((ν.withDensity f).singularPart ν) 0","decl":"@[simp]\ntheorem singularPart_withDensity (ν : Measure α) (f : α → ℝ≥0∞) :\n    (ν.withDensity f).singularPart ν = 0 :=\n  singularPart_eq_zero_of_ac (withDensity_absolutelyContinuous _ _)\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ (MeasureTheory.ae ν).EventuallyEq ((μ.singularPart ν).rnDeriv ν) 0","decl":"lemma rnDeriv_singularPart (μ ν : Measure α) :\n    (μ.singularPart ν).rnDeriv ν =ᵐ[ν] 0 := by\n  rw [rnDeriv_eq_zero]\n  exact mutuallySingular_singularPart μ ν\n\n"}
{"name":"MeasureTheory.Measure.singularPart_self","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.singularPart μ) 0","decl":"@[simp]\nlemma singularPart_self (μ : Measure α) : μ.singularPart μ = 0 :=\n  singularPart_eq_zero_of_ac Measure.AbsolutelyContinuous.rfl\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_self","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (μ.rnDeriv μ) fun x => 1","decl":"lemma rnDeriv_self (μ : Measure α) [SigmaFinite μ] : μ.rnDeriv μ =ᵐ[μ] fun _ ↦ 1 := by\n  have h := rnDeriv_add_singularPart μ μ\n  rw [singularPart_self, add_zero] at h\n  have h_one : μ = μ.withDensity 1 := by simp\n  conv_rhs at h => rw [h_one]\n  rwa [withDensity_eq_iff_of_sigmaFinite (measurable_rnDeriv _ _).aemeasurable] at h\n  exact aemeasurable_const\n\n"}
{"name":"MeasureTheory.Measure.singularPart_eq_self","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\n⊢ Iff (Eq (μ.singularPart ν) μ) (μ.MutuallySingular ν)","decl":"lemma singularPart_eq_self [μ.HaveLebesgueDecomposition ν] : μ.singularPart ν = μ ↔ μ ⟂ₘ ν := by\n  have h_dec := haveLebesgueDecomposition_add μ ν\n  refine ⟨fun h ↦ ?_, fun  h ↦ ?_⟩\n  · rw [← h]\n    exact mutuallySingular_singularPart _ _\n  · conv_rhs => rw [h_dec]\n    rw [(withDensity_rnDeriv_eq_zero _ _).mpr h, add_zero]\n\n"}
{"name":"MeasureTheory.Measure.singularPart_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq ((μ.singularPart ν).singularPart ν) (μ.singularPart ν)","decl":"@[simp]\nlemma singularPart_singularPart (μ ν : Measure α) :\n    (μ.singularPart ν).singularPart ν = μ.singularPart ν := by\n  rw [Measure.singularPart_eq_self]\n  exact Measure.mutuallySingular_singularPart _ _\n\n"}
{"name":"MeasureTheory.Measure.singularPart.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure (μ.singularPart ν)","decl":"instance singularPart.instIsFiniteMeasure [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.singularPart ν) :=\n  isFiniteMeasure_of_le μ <| singularPart_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.singularPart.instSigmaFinite","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite (μ.singularPart ν)","decl":"instance singularPart.instSigmaFinite [SigmaFinite μ] : SigmaFinite (μ.singularPart ν) :=\n  sigmaFinite_of_le μ <| singularPart_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.singularPart.instIsLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ MeasureTheory.IsLocallyFiniteMeasure (μ.singularPart ν)","decl":"instance singularPart.instIsLocallyFiniteMeasure [TopologicalSpace α] [IsLocallyFiniteMeasure μ] :\n    IsLocallyFiniteMeasure (μ.singularPart ν) :=\n  isLocallyFiniteMeasure_of_le <| singularPart_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.withDensity.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure (ν.withDensity (μ.rnDeriv ν))","decl":"instance withDensity.instIsFiniteMeasure [IsFiniteMeasure μ] :\n    IsFiniteMeasure (ν.withDensity <| μ.rnDeriv ν) :=\n  isFiniteMeasure_of_le μ <| withDensity_rnDeriv_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.withDensity.instSigmaFinite","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite (ν.withDensity (μ.rnDeriv ν))","decl":"instance withDensity.instSigmaFinite [SigmaFinite μ] :\n    SigmaFinite (ν.withDensity <| μ.rnDeriv ν) :=\n  sigmaFinite_of_le μ <| withDensity_rnDeriv_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.withDensity.instIsLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ MeasureTheory.IsLocallyFiniteMeasure (ν.withDensity (μ.rnDeriv ν))","decl":"instance withDensity.instIsLocallyFiniteMeasure [TopologicalSpace α] [IsLocallyFiniteMeasure μ] :\n    IsLocallyFiniteMeasure (ν.withDensity <| μ.rnDeriv ν) :=\n  isLocallyFiniteMeasure_of_le <| withDensity_rnDeriv_le μ ν\n\n"}
{"name":"MeasureTheory.Measure.lintegral_rnDeriv_lt_top_of_measure_ne_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nhs : Ne (μ s) Top.top\n⊢ LT.lt (MeasureTheory.lintegral (ν.restrict s) fun x => μ.rnDeriv ν x) Top.top","decl":"theorem lintegral_rnDeriv_lt_top_of_measure_ne_top (ν : Measure α) {s : Set α} (hs : μ s ≠ ∞) :\n    ∫⁻ x in s, μ.rnDeriv ν x ∂ν < ∞ := by\n  by_cases hl : HaveLebesgueDecomposition μ ν\n  · suffices (∫⁻ x in toMeasurable μ s, μ.rnDeriv ν x ∂ν) < ∞ from\n      lt_of_le_of_lt (lintegral_mono_set (subset_toMeasurable _ _)) this\n    rw [← withDensity_apply _ (measurableSet_toMeasurable _ _)]\n    calc\n      _ ≤ (singularPart μ ν) (toMeasurable μ s) + _ := le_add_self\n      _ = μ s := by rw [← Measure.add_apply, ← haveLebesgueDecomposition_add, measure_toMeasurable]\n      _ < ⊤ := hs.lt_top\n  · simp only [Measure.rnDeriv, dif_neg hl, Pi.zero_apply, lintegral_zero, ENNReal.zero_lt_top]\n\n"}
{"name":"MeasureTheory.Measure.lintegral_rnDeriv_lt_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ LT.lt (MeasureTheory.lintegral ν fun x => μ.rnDeriv ν x) Top.top","decl":"theorem lintegral_rnDeriv_lt_top (μ ν : Measure α) [IsFiniteMeasure μ] :\n    ∫⁻ x, μ.rnDeriv ν x ∂ν < ∞ := by\n  rw [← setLIntegral_univ]\n  exact lintegral_rnDeriv_lt_top_of_measure_ne_top _ (measure_lt_top _ _).ne\n\n"}
{"name":"MeasureTheory.Measure.integrable_toReal_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.Integrable (fun x => (μ.rnDeriv ν x).toReal) ν","decl":"lemma integrable_toReal_rnDeriv [IsFiniteMeasure μ] :\n    Integrable (fun x ↦ (μ.rnDeriv ν x).toReal) ν :=\n  integrable_toReal_of_lintegral_ne_top (Measure.measurable_rnDeriv _ _).aemeasurable\n    (Measure.lintegral_rnDeriv_lt_top _ _).ne\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_lt_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Filter.Eventually (fun x => LT.lt (μ.rnDeriv ν x) Top.top) (MeasureTheory.ae ν)","decl":"/-- The Radon-Nikodym derivative of a sigma-finite measure `μ` with respect to another\nmeasure `ν` is `ν`-almost everywhere finite. -/\ntheorem rnDeriv_lt_top (μ ν : Measure α) [SigmaFinite μ] : ∀ᵐ x ∂ν, μ.rnDeriv ν x < ∞ := by\n  suffices ∀ n, ∀ᵐ x ∂ν, x ∈ spanningSets μ n → μ.rnDeriv ν x < ∞ by\n    filter_upwards [ae_all_iff.2 this] with _ hx using hx _ (mem_spanningSetsIndex _ _)\n  intro n\n  rw [← ae_restrict_iff' (measurableSet_spanningSets _ _)]\n  apply ae_lt_top (measurable_rnDeriv _ _)\n  refine (lintegral_rnDeriv_lt_top_of_measure_ne_top _ ?_).ne\n  exact (measure_spanningSets_lt_top _ _).ne\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_ne_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Filter.Eventually (fun x => Ne (μ.rnDeriv ν x) Top.top) (MeasureTheory.ae ν)","decl":"lemma rnDeriv_ne_top (μ ν : Measure α) [SigmaFinite μ] : ∀ᵐ x ∂ν, μ.rnDeriv ν x ≠ ∞ := by\n  filter_upwards [Measure.rnDeriv_lt_top μ ν] with x hx using hx.ne\n\n"}
{"name":"MeasureTheory.Measure.eq_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν s : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nhs : s.MutuallySingular ν\nhadd : Eq μ (HAdd.hAdd s (ν.withDensity f))\n⊢ Eq s (μ.singularPart ν)","decl":"/-- Given measures `μ` and `ν`, if `s` is a measure mutually singular to `ν` and `f` is a\nmeasurable function such that `μ = s + fν`, then `s = μ.singularPart μ`.\n\nThis theorem provides the uniqueness of the `singularPart` in the Lebesgue decomposition theorem,\nwhile `MeasureTheory.Measure.eq_rnDeriv` provides the uniqueness of the\n`rnDeriv`. -/\ntheorem eq_singularPart {s : Measure α} {f : α → ℝ≥0∞} (hf : Measurable f) (hs : s ⟂ₘ ν)\n    (hadd : μ = s + ν.withDensity f) : s = μ.singularPart ν := by\n  have : HaveLebesgueDecomposition μ ν := ⟨⟨⟨s, f⟩, hf, hs, hadd⟩⟩\n  obtain ⟨hmeas, hsing, hadd'⟩ := haveLebesgueDecomposition_spec μ ν\n  obtain ⟨⟨S, hS₁, hS₂, hS₃⟩, ⟨T, hT₁, hT₂, hT₃⟩⟩ := hs, hsing\n  rw [hadd'] at hadd\n  have hνinter : ν (S ∩ T)ᶜ = 0 := by\n    rw [compl_inter]\n    refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) ?_)\n    rw [hT₃, hS₃, add_zero]\n  have heq : s.restrict (S ∩ T)ᶜ = (μ.singularPart ν).restrict (S ∩ T)ᶜ := by\n    ext1 A hA\n    have hf : ν.withDensity f (A ∩ (S ∩ T)ᶜ) = 0 := by\n      refine withDensity_absolutelyContinuous ν _ ?_\n      rw [← nonpos_iff_eq_zero]\n      exact hνinter ▸ measure_mono inter_subset_right\n    have hrn : ν.withDensity (μ.rnDeriv ν) (A ∩ (S ∩ T)ᶜ) = 0 := by\n      refine withDensity_absolutelyContinuous ν _ ?_\n      rw [← nonpos_iff_eq_zero]\n      exact hνinter ▸ measure_mono inter_subset_right\n    rw [restrict_apply hA, restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hf, ← add_apply, ←\n      hadd, add_apply, hrn, add_zero]\n  have heq' : ∀ A : Set α, MeasurableSet A → s A = s.restrict (S ∩ T)ᶜ A := by\n    intro A hA\n    have hsinter : s (A ∩ (S ∩ T)) = 0 := by\n      rw [← nonpos_iff_eq_zero]\n      exact hS₂ ▸ measure_mono (inter_subset_right.trans inter_subset_left)\n    rw [restrict_apply hA, ← diff_eq, AEDisjoint.measure_diff_left hsinter]\n  ext1 A hA\n  have hμinter : μ.singularPart ν (A ∩ (S ∩ T)) = 0 := by\n    rw [← nonpos_iff_eq_zero]\n    exact hT₂ ▸ measure_mono (inter_subset_right.trans inter_subset_right)\n  rw [heq' A hA, heq, restrict_apply hA, ← diff_eq, AEDisjoint.measure_diff_left hμinter]\n\n"}
{"name":"MeasureTheory.Measure.singularPart_smul","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nr : NNReal\n⊢ Eq ((HSMul.hSMul r μ).singularPart ν) (HSMul.hSMul r (μ.singularPart ν))","decl":"theorem singularPart_smul (μ ν : Measure α) (r : ℝ≥0) :\n    (r • μ).singularPart ν = r • μ.singularPart ν := by\n  by_cases hr : r = 0\n  · rw [hr, zero_smul, zero_smul, singularPart_zero]\n  by_cases hl : HaveLebesgueDecomposition μ ν\n  · refine (eq_singularPart ((measurable_rnDeriv μ ν).const_smul (r : ℝ≥0∞))\n          (MutuallySingular.smul r (mutuallySingular_singularPart _ _)) ?_).symm\n    rw [withDensity_smul _ (measurable_rnDeriv _ _), ← smul_add,\n      ← haveLebesgueDecomposition_add μ ν, ENNReal.smul_def]\n  · rw [singularPart, singularPart, dif_neg hl, dif_neg, smul_zero]\n    refine fun hl' ↦ hl ?_\n    rw [← inv_smul_smul₀ hr μ]\n    infer_instance\n\n"}
{"name":"MeasureTheory.Measure.singularPart_smul_right","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nr : NNReal\nhr : Ne r 0\n⊢ Eq (μ.singularPart (HSMul.hSMul r ν)) (μ.singularPart ν)","decl":"theorem singularPart_smul_right (μ ν : Measure α) (r : ℝ≥0) (hr : r ≠ 0) :\n    μ.singularPart (r • ν) = μ.singularPart ν := by\n  by_cases hl : HaveLebesgueDecomposition μ ν\n  · refine (eq_singularPart ((measurable_rnDeriv μ ν).const_smul r⁻¹) ?_ ?_).symm\n    · exact (mutuallySingular_singularPart μ ν).mono_ac AbsolutelyContinuous.rfl\n        smul_absolutelyContinuous\n    · rw [ENNReal.smul_def r, withDensity_smul_measure, ← withDensity_smul]\n      swap; · exact (measurable_rnDeriv _ _).const_smul _\n      convert haveLebesgueDecomposition_add μ ν\n      ext x\n      simp only [Pi.smul_apply]\n      rw [← ENNReal.smul_def, smul_inv_smul₀ hr]\n  · rw [singularPart, singularPart, dif_neg hl, dif_neg]\n    refine fun hl' ↦ hl ?_\n    rw [← inv_smul_smul₀ hr ν]\n    infer_instance\n\n"}
{"name":"MeasureTheory.Measure.singularPart_add","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ₁ μ₂ ν : MeasureTheory.Measure α\ninst✝¹ : μ₁.HaveLebesgueDecomposition ν\ninst✝ : μ₂.HaveLebesgueDecomposition ν\n⊢ Eq ((HAdd.hAdd μ₁ μ₂).singularPart ν) (HAdd.hAdd (μ₁.singularPart ν) (μ₂.singularPart ν))","decl":"theorem singularPart_add (μ₁ μ₂ ν : Measure α) [HaveLebesgueDecomposition μ₁ ν]\n    [HaveLebesgueDecomposition μ₂ ν] :\n    (μ₁ + μ₂).singularPart ν = μ₁.singularPart ν + μ₂.singularPart ν := by\n  refine (eq_singularPart ((measurable_rnDeriv μ₁ ν).add (measurable_rnDeriv μ₂ ν))\n    ((mutuallySingular_singularPart _ _).add_left (mutuallySingular_singularPart _ _)) ?_).symm\n  erw [withDensity_add_left (measurable_rnDeriv μ₁ ν)]\n  conv_rhs => rw [add_assoc, add_comm (μ₂.singularPart ν), ← add_assoc, ← add_assoc]\n  rw [← haveLebesgueDecomposition_add μ₁ ν, add_assoc, add_comm (ν.withDensity (μ₂.rnDeriv ν)),\n    ← haveLebesgueDecomposition_add μ₂ ν]\n\n"}
{"name":"MeasureTheory.Measure.singularPart_restrict","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : μ.HaveLebesgueDecomposition ν\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.restrict s).singularPart ν) ((μ.singularPart ν).restrict s)","decl":"lemma singularPart_restrict (μ ν : Measure α) [HaveLebesgueDecomposition μ ν]\n    {s : Set α} (hs : MeasurableSet s) :\n    (μ.restrict s).singularPart ν = (μ.singularPart ν).restrict s := by\n  refine (Measure.eq_singularPart (f := s.indicator (μ.rnDeriv ν)) ?_ ?_ ?_).symm\n  · exact (μ.measurable_rnDeriv ν).indicator hs\n  · exact (Measure.mutuallySingular_singularPart μ ν).restrict s\n  · ext t\n    rw [withDensity_indicator hs, ← restrict_withDensity hs, ← Measure.restrict_add,\n      ← μ.haveLebesgueDecomposition_add ν]\n\n"}
{"name":"MeasureTheory.Measure.measure_sub_singularPart","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (HSub.hSub μ (μ.singularPart ν)) (ν.withDensity (μ.rnDeriv ν))","decl":"lemma measure_sub_singularPart (μ ν : Measure α) [HaveLebesgueDecomposition μ ν]\n    [IsFiniteMeasure μ] :\n    μ - μ.singularPart ν = ν.withDensity (μ.rnDeriv ν) := by\n  nth_rw 1 [← rnDeriv_add_singularPart μ ν]\n  exact Measure.add_sub_cancel\n\n"}
{"name":"MeasureTheory.Measure.measure_sub_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (HSub.hSub μ (ν.withDensity (μ.rnDeriv ν))) (μ.singularPart ν)","decl":"lemma measure_sub_rnDeriv (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] [IsFiniteMeasure μ] :\n    μ - ν.withDensity (μ.rnDeriv ν) = μ.singularPart ν := by\n  nth_rw 1 [← singularPart_add_rnDeriv μ ν]\n  exact Measure.add_sub_cancel\n\n"}
{"name":"MeasureTheory.Measure.eq_withDensity_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν s : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nhs : s.MutuallySingular ν\nhadd : Eq μ (HAdd.hAdd s (ν.withDensity f))\n⊢ Eq (ν.withDensity f) (ν.withDensity (μ.rnDeriv ν))","decl":"/-- Given measures `μ` and `ν`, if `s` is a measure mutually singular to `ν` and `f` is a\nmeasurable function such that `μ = s + fν`, then `f = μ.rnDeriv ν`.\n\nThis theorem provides the uniqueness of the `rnDeriv` in the Lebesgue decomposition\ntheorem, while `MeasureTheory.Measure.eq_singularPart` provides the uniqueness of the\n`singularPart`. Here, the uniqueness is given in terms of the measures, while the uniqueness in\nterms of the functions is given in `eq_rnDeriv`. -/\ntheorem eq_withDensity_rnDeriv {s : Measure α} {f : α → ℝ≥0∞} (hf : Measurable f) (hs : s ⟂ₘ ν)\n    (hadd : μ = s + ν.withDensity f) : ν.withDensity f = ν.withDensity (μ.rnDeriv ν) := by\n  have : HaveLebesgueDecomposition μ ν := ⟨⟨⟨s, f⟩, hf, hs, hadd⟩⟩\n  obtain ⟨hmeas, hsing, hadd'⟩ := haveLebesgueDecomposition_spec μ ν\n  obtain ⟨⟨S, hS₁, hS₂, hS₃⟩, ⟨T, hT₁, hT₂, hT₃⟩⟩ := hs, hsing\n  rw [hadd'] at hadd\n  have hνinter : ν (S ∩ T)ᶜ = 0 := by\n    rw [compl_inter]\n    refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) ?_)\n    rw [hT₃, hS₃, add_zero]\n  have heq :\n    (ν.withDensity f).restrict (S ∩ T) = (ν.withDensity (μ.rnDeriv ν)).restrict (S ∩ T) := by\n    ext1 A hA\n    have hs : s (A ∩ (S ∩ T)) = 0 := by\n      rw [← nonpos_iff_eq_zero]\n      exact hS₂ ▸ measure_mono (inter_subset_right.trans inter_subset_left)\n    have hsing : μ.singularPart ν (A ∩ (S ∩ T)) = 0 := by\n      rw [← nonpos_iff_eq_zero]\n      exact hT₂ ▸ measure_mono (inter_subset_right.trans inter_subset_right)\n    rw [restrict_apply hA, restrict_apply hA, ← add_zero (ν.withDensity f (A ∩ (S ∩ T))), ← hs, ←\n      add_apply, add_comm, ← hadd, add_apply, hsing, zero_add]\n  have heq' :\n    ∀ A : Set α, MeasurableSet A → ν.withDensity f A = (ν.withDensity f).restrict (S ∩ T) A := by\n    intro A hA\n    have hνfinter : ν.withDensity f (A ∩ (S ∩ T)ᶜ) = 0 := by\n      rw [← nonpos_iff_eq_zero]\n      exact withDensity_absolutelyContinuous ν f hνinter ▸ measure_mono inter_subset_right\n    rw [restrict_apply hA, ← add_zero (ν.withDensity f (A ∩ (S ∩ T))), ← hνfinter, ← diff_eq,\n      measure_inter_add_diff _ (hS₁.inter hT₁)]\n  ext1 A hA\n  have hνrn : ν.withDensity (μ.rnDeriv ν) (A ∩ (S ∩ T)ᶜ) = 0 := by\n    rw [← nonpos_iff_eq_zero]\n    exact\n      withDensity_absolutelyContinuous ν (μ.rnDeriv ν) hνinter ▸\n        measure_mono inter_subset_right\n  rw [heq' A hA, heq, ← add_zero ((ν.withDensity (μ.rnDeriv ν)).restrict (S ∩ T) A), ← hνrn,\n    restrict_apply hA, ← diff_eq, measure_inter_add_diff _ (hS₁.inter hT₁)]\n\n"}
{"name":"MeasureTheory.Measure.eq_withDensity_rnDeriv₀","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν s : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f ν\nhs : s.MutuallySingular ν\nhadd : Eq μ (HAdd.hAdd s (ν.withDensity f))\n⊢ Eq (ν.withDensity f) (ν.withDensity (μ.rnDeriv ν))","decl":"theorem eq_withDensity_rnDeriv₀ {s : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f ν) (hs : s ⟂ₘ ν) (hadd : μ = s + ν.withDensity f) :\n    ν.withDensity f = ν.withDensity (μ.rnDeriv ν) := by\n  rw [withDensity_congr_ae hf.ae_eq_mk] at hadd ⊢\n  exact eq_withDensity_rnDeriv hf.measurable_mk hs hadd\n\n"}
{"name":"MeasureTheory.Measure.eq_rnDeriv₀","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\ns : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f ν\nhs : s.MutuallySingular ν\nhadd : Eq μ (HAdd.hAdd s (ν.withDensity f))\n⊢ (MeasureTheory.ae ν).EventuallyEq f (μ.rnDeriv ν)","decl":"theorem eq_rnDeriv₀ [SigmaFinite ν] {s : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f ν) (hs : s ⟂ₘ ν) (hadd : μ = s + ν.withDensity f) :\n    f =ᵐ[ν] μ.rnDeriv ν :=\n  (withDensity_eq_iff_of_sigmaFinite hf (measurable_rnDeriv _ _).aemeasurable).mp\n    (eq_withDensity_rnDeriv₀ hf hs hadd)\n\n"}
{"name":"MeasureTheory.Measure.eq_rnDeriv","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\ns : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nhs : s.MutuallySingular ν\nhadd : Eq μ (HAdd.hAdd s (ν.withDensity f))\n⊢ (MeasureTheory.ae ν).EventuallyEq f (μ.rnDeriv ν)","decl":"/-- Given measures `μ` and `ν`, if `s` is a measure mutually singular to `ν` and `f` is a\nmeasurable function such that `μ = s + fν`, then `f = μ.rnDeriv ν`.\n\nThis theorem provides the uniqueness of the `rnDeriv` in the Lebesgue decomposition\ntheorem, while `MeasureTheory.Measure.eq_singularPart` provides the uniqueness of the\n`singularPart`. Here, the uniqueness is given in terms of the functions, while the uniqueness in\nterms of the functions is given in `eq_withDensity_rnDeriv`. -/\ntheorem eq_rnDeriv [SigmaFinite ν] {s : Measure α} {f : α → ℝ≥0∞} (hf : Measurable f) (hs : s ⟂ₘ ν)\n    (hadd : μ = s + ν.withDensity f) : f =ᵐ[ν] μ.rnDeriv ν :=\n  eq_rnDeriv₀ hf.aemeasurable hs hadd\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity₀","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\nf : α → ENNReal\nhf : AEMeasurable f ν\n⊢ (MeasureTheory.ae ν).EventuallyEq ((ν.withDensity f).rnDeriv ν) f","decl":"/-- The Radon-Nikodym derivative of `f ν` with respect to `ν` is `f`. -/\ntheorem rnDeriv_withDensity₀ (ν : Measure α) [SigmaFinite ν] {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f ν) :\n    (ν.withDensity f).rnDeriv ν =ᵐ[ν] f :=\n  have : ν.withDensity f = 0 + ν.withDensity f := by rw [zero_add]\n  (eq_rnDeriv₀ hf MutuallySingular.zero_left this).symm\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_withDensity","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\nf : α → ENNReal\nhf : Measurable f\n⊢ (MeasureTheory.ae ν).EventuallyEq ((ν.withDensity f).rnDeriv ν) f","decl":"/-- The Radon-Nikodym derivative of `f ν` with respect to `ν` is `f`. -/\ntheorem rnDeriv_withDensity (ν : Measure α) [SigmaFinite ν] {f : α → ℝ≥0∞} (hf : Measurable f) :\n    (ν.withDensity f).rnDeriv ν =ᵐ[ν] f :=\n  rnDeriv_withDensity₀ ν hf.aemeasurable\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_restrict","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : μ.HaveLebesgueDecomposition ν\ninst✝ : MeasureTheory.SigmaFinite ν\ns : Set α\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae ν).EventuallyEq ((μ.restrict s).rnDeriv ν) (s.indicator (μ.rnDeriv ν))","decl":"lemma rnDeriv_restrict (μ ν : Measure α) [HaveLebesgueDecomposition μ ν] [SigmaFinite ν]\n    {s : Set α} (hs : MeasurableSet s) :\n    (μ.restrict s).rnDeriv ν =ᵐ[ν] s.indicator (μ.rnDeriv ν) := by\n  refine (eq_rnDeriv (s := (μ.restrict s).singularPart ν)\n    ((measurable_rnDeriv _ _).indicator hs) (mutuallySingular_singularPart _ _) ?_).symm\n  rw [singularPart_restrict _ _ hs, withDensity_indicator hs, ← restrict_withDensity hs,\n    ← Measure.restrict_add, ← μ.haveLebesgueDecomposition_add ν]\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_restrict_self","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite ν\ns : Set α\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae ν).EventuallyEq ((ν.restrict s).rnDeriv ν) (s.indicator 1)","decl":"/-- The Radon-Nikodym derivative of the restriction of a measure to a measurable set is the\nindicator function of this set. -/\ntheorem rnDeriv_restrict_self (ν : Measure α) [SigmaFinite ν] {s : Set α} (hs : MeasurableSet s) :\n    (ν.restrict s).rnDeriv ν =ᵐ[ν] s.indicator 1 := by\n  rw [← withDensity_indicator_one hs]\n  exact rnDeriv_withDensity _ (measurable_one.indicator hs)\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_left","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure ν\ninst✝ : ν.HaveLebesgueDecomposition μ\nr : NNReal\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSMul.hSMul r ν).rnDeriv μ) (HSMul.hSMul r (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of the scalar multiple of a measure.\nSee also `rnDeriv_smul_left'`, which requires sigma-finite `ν` and `μ`. -/\ntheorem rnDeriv_smul_left (ν μ : Measure α) [IsFiniteMeasure ν]\n    [ν.HaveLebesgueDecomposition μ] (r : ℝ≥0) :\n    (r • ν).rnDeriv μ =ᵐ[μ] r • ν.rnDeriv μ := by\n  rw [← withDensity_eq_iff]\n  · simp_rw [ENNReal.smul_def]\n    rw [withDensity_smul _ (measurable_rnDeriv _ _)]\n    suffices (r • ν).singularPart μ + withDensity μ (rnDeriv (r • ν) μ)\n        = (r • ν).singularPart μ + r • withDensity μ (rnDeriv ν μ) by\n      rwa [Measure.add_right_inj] at this\n    rw [← (r • ν).haveLebesgueDecomposition_add μ, singularPart_smul, ← smul_add,\n      ← ν.haveLebesgueDecomposition_add μ]\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact (measurable_rnDeriv _ _).aemeasurable.const_smul _\n  · exact (lintegral_rnDeriv_lt_top (r • ν) μ).ne\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_left_of_ne_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure ν\ninst✝ : ν.HaveLebesgueDecomposition μ\nr : ENNReal\nhr : Ne r Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSMul.hSMul r ν).rnDeriv μ) (HSMul.hSMul r (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of the scalar multiple of a measure.\nSee also `rnDeriv_smul_left_of_ne_top'`, which requires sigma-finite `ν` and `μ`. -/\ntheorem rnDeriv_smul_left_of_ne_top (ν μ : Measure α) [IsFiniteMeasure ν]\n    [ν.HaveLebesgueDecomposition μ] {r : ℝ≥0∞} (hr : r ≠ ∞) :\n    (r • ν).rnDeriv μ =ᵐ[μ] r • ν.rnDeriv μ := by\n  have h : (r.toNNReal • ν).rnDeriv μ =ᵐ[μ] r.toNNReal • ν.rnDeriv μ :=\n    rnDeriv_smul_left ν μ r.toNNReal\n  simpa [ENNReal.smul_def, ENNReal.coe_toNNReal hr] using h\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_right","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure ν\ninst✝ : ν.HaveLebesgueDecomposition μ\nr : NNReal\nhr : Ne r 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (ν.rnDeriv (HSMul.hSMul r μ)) (HSMul.hSMul (Inv.inv r) (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative with respect to the scalar multiple of a measure.\nSee also `rnDeriv_smul_right'`, which requires sigma-finite `ν` and `μ`. -/\ntheorem rnDeriv_smul_right (ν μ : Measure α) [IsFiniteMeasure ν]\n    [ν.HaveLebesgueDecomposition μ] {r : ℝ≥0} (hr : r ≠ 0) :\n    ν.rnDeriv (r • μ) =ᵐ[μ] r⁻¹ • ν.rnDeriv μ := by\n  refine (absolutelyContinuous_smul <| ENNReal.coe_ne_zero.2 hr).ae_le\n    (?_ : ν.rnDeriv (r • μ) =ᵐ[r • μ] r⁻¹ • ν.rnDeriv μ)\n  rw [← withDensity_eq_iff]\n  rotate_left\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact (measurable_rnDeriv _ _).aemeasurable.const_smul _\n  · exact (lintegral_rnDeriv_lt_top ν _).ne\n  · simp_rw [ENNReal.smul_def]\n    rw [withDensity_smul _ (measurable_rnDeriv _ _)]\n    suffices ν.singularPart (r • μ) + withDensity (r • μ) (rnDeriv ν (r • μ))\n        = ν.singularPart (r • μ) + r⁻¹ • withDensity (r • μ) (rnDeriv ν μ) by\n      rwa [add_right_inj] at this\n    rw [← ν.haveLebesgueDecomposition_add (r • μ), singularPart_smul_right _ _ _ hr,\n      ENNReal.smul_def r, withDensity_smul_measure, ← ENNReal.smul_def, ← smul_assoc,\n      smul_eq_mul, inv_mul_cancel₀ hr, one_smul]\n    exact ν.haveLebesgueDecomposition_add μ\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure ν\ninst✝ : ν.HaveLebesgueDecomposition μ\nr : ENNReal\nhr : Ne r 0\nhr_ne_top : Ne r Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq (ν.rnDeriv (HSMul.hSMul r μ)) (HSMul.hSMul (Inv.inv r) (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative with respect to the scalar multiple of a measure.\nSee also `rnDeriv_smul_right_of_ne_top'`, which requires sigma-finite `ν` and `μ`. -/\ntheorem rnDeriv_smul_right_of_ne_top (ν μ : Measure α) [IsFiniteMeasure ν]\n    [ν.HaveLebesgueDecomposition μ] {r : ℝ≥0∞} (hr : r ≠ 0) (hr_ne_top : r ≠ ∞) :\n    ν.rnDeriv (r • μ) =ᵐ[μ] r⁻¹ • ν.rnDeriv μ := by\n  have h : ν.rnDeriv (r.toNNReal • μ) =ᵐ[μ] r.toNNReal⁻¹ • ν.rnDeriv μ := by\n    refine rnDeriv_smul_right ν μ ?_\n    rw [ne_eq, ENNReal.toNNReal_eq_zero_iff]\n    simp [hr, hr_ne_top]\n  have : (r.toNNReal)⁻¹ • rnDeriv ν μ = r⁻¹ • rnDeriv ν μ := by\n    ext x\n    simp only [Pi.smul_apply, ENNReal.smul_def, ne_eq, smul_eq_mul]\n    rw [ENNReal.coe_inv, ENNReal.coe_toNNReal hr_ne_top]\n    rw [ne_eq, ENNReal.toNNReal_eq_zero_iff]\n    simp [hr, hr_ne_top]\n  simp_rw [this, ENNReal.smul_def, ENNReal.coe_toNNReal hr_ne_top] at h\n  exact h\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν₁ ν₂ μ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.IsFiniteMeasure ν₁\ninst✝³ : MeasureTheory.IsFiniteMeasure ν₂\ninst✝² : ν₁.HaveLebesgueDecomposition μ\ninst✝¹ : ν₂.HaveLebesgueDecomposition μ\ninst✝ : (HAdd.hAdd ν₁ ν₂).HaveLebesgueDecomposition μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HAdd.hAdd ν₁ ν₂).rnDeriv μ) (HAdd.hAdd (ν₁.rnDeriv μ) (ν₂.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of a sum of two measures.\nSee also `rnDeriv_add'`, which requires sigma-finite `ν₁`, `ν₂` and `μ`. -/\nlemma rnDeriv_add (ν₁ ν₂ μ : Measure α) [IsFiniteMeasure ν₁] [IsFiniteMeasure ν₂]\n    [ν₁.HaveLebesgueDecomposition μ] [ν₂.HaveLebesgueDecomposition μ]\n    [(ν₁ + ν₂).HaveLebesgueDecomposition μ] :\n    (ν₁ + ν₂).rnDeriv μ =ᵐ[μ] ν₁.rnDeriv μ + ν₂.rnDeriv μ := by\n  rw [← withDensity_eq_iff]\n  · suffices (ν₁ + ν₂).singularPart μ + μ.withDensity ((ν₁ + ν₂).rnDeriv μ)\n        = (ν₁ + ν₂).singularPart μ + μ.withDensity (ν₁.rnDeriv μ + ν₂.rnDeriv μ) by\n      rwa [add_right_inj] at this\n    rw [← (ν₁ + ν₂).haveLebesgueDecomposition_add μ, singularPart_add,\n      withDensity_add_left (measurable_rnDeriv _ _), add_assoc,\n      add_comm (ν₂.singularPart μ), add_assoc, add_comm _ (ν₂.singularPart μ),\n      ← ν₂.haveLebesgueDecomposition_add μ, ← add_assoc, ← ν₁.haveLebesgueDecomposition_add μ]\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact ((measurable_rnDeriv _ _).add (measurable_rnDeriv _ _)).aemeasurable\n  · exact (lintegral_rnDeriv_lt_top (ν₁ + ν₂) μ).ne\n\n"}
{"name":"MeasureTheory.Measure.exists_positive_of_not_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nh : Not (μ.MutuallySingular ν)\n⊢ Exists fun ε => And (LT.lt 0 ε) (Exists fun E => And (MeasurableSet E) (And (LT.lt 0 (ν E)) (∀ (A : Set α), MeasurableSet A → LE.le (HMul.hMul (↑ε) (ν (Inter.inter A E))) (μ (Inter.inter A E)))))","decl":"/-- If two finite measures `μ` and `ν` are not mutually singular, there exists some `ε > 0` and\na measurable set `E`, such that `ν(E) > 0` and `E` is positive with respect to `μ - εν`.\n\nThis lemma is useful for the Lebesgue decomposition theorem. -/\ntheorem exists_positive_of_not_mutuallySingular (μ ν : Measure α) [IsFiniteMeasure μ]\n    [IsFiniteMeasure ν] (h : ¬ μ ⟂ₘ ν) :\n    ∃ ε : ℝ≥0, 0 < ε ∧\n      ∃ E : Set α, MeasurableSet E ∧ 0 < ν E\n        ∧ ∀ A, MeasurableSet A → ε * ν (A ∩ E) ≤ μ (A ∩ E) := by\n  -- for all `n : ℕ`, obtain the Hahn decomposition for `μ - (1 / n) ν`\n  have h_decomp (n : ℕ) : ∃ s : Set α, MeasurableSet s\n        ∧ (∀ t, MeasurableSet t → ((1 / (n + 1) : ℝ≥0) • ν) (t ∩ s) ≤ μ (t ∩ s))\n        ∧ (∀ t, MeasurableSet t → μ (t ∩ sᶜ) ≤ ((1 / (n + 1) : ℝ≥0) • ν) (t ∩ sᶜ)) := by\n    obtain ⟨s, hs, hs_le, hs_ge⟩ := hahn_decomposition μ ((1 / (n + 1) : ℝ≥0) • ν)\n    refine ⟨s, hs, fun t ht ↦ ?_, fun t ht ↦ ?_⟩\n    · exact hs_le (t ∩ s) (ht.inter hs) inter_subset_right\n    · exact hs_ge (t ∩ sᶜ) (ht.inter hs.compl) inter_subset_right\n  choose f hf₁ hf₂ hf₃ using h_decomp\n  -- set `A` to be the intersection of all the negative parts of obtained Hahn decompositions\n  -- and we show that `μ A = 0`\n  let A := ⋂ n, (f n)ᶜ\n  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n ↦ (hf₁ n).compl\n  have hA₂ (n : ℕ) (t : Set α) (ht : MeasurableSet t) :\n      μ (t ∩ A) ≤ ((1 / (n + 1) : ℝ≥0) • ν) (t ∩ A) := by\n    specialize hf₃ n (t ∩ A) (ht.inter hAmeas)\n    have : A ∩ (f n)ᶜ = A := inter_eq_left.mpr (iInter_subset _ n)\n    rwa [inter_assoc, this] at hf₃\n  have hA₃ (n : ℕ) : μ A ≤ (1 / (n + 1) : ℝ≥0) * ν A := by simpa using hA₂ n univ .univ\n  have hμ : μ A = 0 := by\n    lift μ A to ℝ≥0 using measure_ne_top _ _ with μA\n    lift ν A to ℝ≥0 using measure_ne_top _ _ with νA\n    rw [ENNReal.coe_eq_zero]\n    by_cases hb : 0 < νA\n    · suffices ∀ b, 0 < b → μA ≤ b by\n        by_contra h\n        have h' := this (μA / 2) (half_pos (zero_lt_iff.2 h))\n        rw [← @Classical.not_not (μA ≤ μA / 2)] at h'\n        exact h' (not_le.2 (NNReal.half_lt_self h))\n      intro c hc\n      have : ∃ n : ℕ, 1 / (n + 1 : ℝ) < c * (νA : ℝ)⁻¹ := by\n        refine exists_nat_one_div_lt ?_\n        positivity\n      rcases this with ⟨n, hn⟩\n      have hb₁ : (0 : ℝ) < (νA : ℝ)⁻¹ := by rw [_root_.inv_pos]; exact hb\n      have h' : 1 / (↑n + 1) * νA < c := by\n        rw [← NNReal.coe_lt_coe, ← mul_lt_mul_right hb₁, NNReal.coe_mul, mul_assoc, ←\n          NNReal.coe_inv, ← NNReal.coe_mul, mul_inv_cancel₀, ← NNReal.coe_mul, mul_one,\n          NNReal.coe_inv]\n        · exact hn\n        · exact hb.ne'\n      refine le_trans ?_ h'.le\n      rw [← ENNReal.coe_le_coe, ENNReal.coe_mul]\n      exact hA₃ n\n    · rw [not_lt, le_zero_iff] at hb\n      specialize hA₃ 0\n      simp? [hb] at hA₃ says\n        simp only [CharP.cast_eq_zero, zero_add, ne_eq, one_ne_zero, not_false_eq_true, div_self,\n          ENNReal.coe_one, hb, ENNReal.coe_zero, mul_zero, nonpos_iff_eq_zero,\n          ENNReal.coe_eq_zero] at hA₃\n      assumption\n  -- since `μ` and `ν` are not mutually singular, `μ A = 0` implies `ν Aᶜ > 0`\n  rw [MutuallySingular] at h; push_neg at h\n  have := h _ hAmeas hμ\n  simp_rw [A, compl_iInter, compl_compl] at this\n  -- as `Aᶜ = ⋃ n, f n`, `ν Aᶜ > 0` implies there exists some `n` such that `ν (f n) > 0`\n  obtain ⟨n, hn⟩ := exists_measure_pos_of_not_measure_iUnion_null this\n  -- thus, choosing `f n` as the set `E` suffices\n  exact ⟨1 / (n + 1), by simp, f n, hf₁ n, hn, hf₂ n⟩\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.zero_mem_measurableLE","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) 0","decl":"theorem zero_mem_measurableLE : (0 : α → ℝ≥0∞) ∈ measurableLE μ ν :=\n  ⟨measurable_zero, fun A _ ↦ by simp⟩\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.sup_mem_measurableLE","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) f\nhg : Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) g\n⊢ Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) fun a => Max.max (f a) (g a)","decl":"theorem sup_mem_measurableLE {f g : α → ℝ≥0∞} (hf : f ∈ measurableLE μ ν)\n    (hg : g ∈ measurableLE μ ν) : (fun a ↦ f a ⊔ g a) ∈ measurableLE μ ν := by\n  refine ⟨Measurable.max hf.1 hg.1, fun A hA ↦ ?_⟩\n  have h₁ := hA.inter (measurableSet_le hf.1 hg.1)\n  have h₂ := hA.inter (measurableSet_lt hg.1 hf.1)\n  rw [setLIntegral_max hf.1 hg.1]\n  refine (add_le_add (hg.2 _ h₁) (hf.2 _ h₂)).trans_eq ?_\n  simp only [← not_le, ← compl_setOf, ← diff_eq]\n  exact measure_inter_add_diff _ (measurableSet_le hf.1 hg.1)\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_succ_eq_sup","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Sort u_2\nf : Nat → α → ENNReal\nm : Nat\na : α\n⊢ Eq (iSup fun k => iSup fun x => f k a) (Max.max (f m.succ a) (iSup fun k => iSup fun x => f k a))","decl":"theorem iSup_succ_eq_sup {α} (f : ℕ → α → ℝ≥0∞) (m : ℕ) (a : α) :\n    ⨆ (k : ℕ) (_ : k ≤ m + 1), f k a = f m.succ a ⊔ ⨆ (k : ℕ) (_ : k ≤ m), f k a := by\n  set c := ⨆ (k : ℕ) (_ : k ≤ m + 1), f k a with hc\n  set d := f m.succ a ⊔ ⨆ (k : ℕ) (_ : k ≤ m), f k a with hd\n  rw [le_antisymm_iff, hc, hd]\n  constructor\n  · refine iSup₂_le fun n hn ↦ ?_\n    rcases Nat.of_le_succ hn with (h | h)\n    · exact le_sup_of_le_right (le_iSup₂ (f := fun k (_ : k ≤ m) ↦ f k a) n h)\n    · exact h ▸ le_sup_left\n  · refine sup_le ?_ (biSup_mono fun n hn ↦ hn.trans m.le_succ)\n    exact @le_iSup₂ ℝ≥0∞ ℕ (fun i ↦ i ≤ m + 1) _ _ (m + 1) le_rfl\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_mem_measurableLE","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nhf : ∀ (n : Nat), Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) (f n)\nn : Nat\n⊢ Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) fun x => iSup fun k => iSup fun x_1 => f k x","decl":"theorem iSup_mem_measurableLE (f : ℕ → α → ℝ≥0∞) (hf : ∀ n, f n ∈ measurableLE μ ν) (n : ℕ) :\n    (fun x ↦ ⨆ (k) (_ : k ≤ n), f k x) ∈ measurableLE μ ν := by\n  induction' n with m hm\n  · constructor\n    · simp [(hf 0).1]\n    · intro A hA; simp [(hf 0).2 A hA]\n  · have :\n      (fun a : α ↦ ⨆ (k : ℕ) (_ : k ≤ m + 1), f k a) = fun a ↦\n        f m.succ a ⊔ ⨆ (k : ℕ) (_ : k ≤ m), f k a :=\n      funext fun _ ↦ iSup_succ_eq_sup _ _ _\n    refine ⟨.iSup fun n ↦ Measurable.iSup_Prop _ (hf n).1, fun A hA ↦ ?_⟩\n    rw [this]; exact (sup_mem_measurableLE (hf m.succ) hm).2 A hA\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_mem_measurableLE'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nhf : ∀ (n : Nat), Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) (f n)\nn : Nat\n⊢ Membership.mem (MeasureTheory.Measure.LebesgueDecomposition.measurableLE μ ν) (iSup fun k => iSup fun x => f k)","decl":"theorem iSup_mem_measurableLE' (f : ℕ → α → ℝ≥0∞) (hf : ∀ n, f n ∈ measurableLE μ ν) (n : ℕ) :\n    (⨆ (k) (_ : k ≤ n), f k) ∈ measurableLE μ ν := by\n  convert iSup_mem_measurableLE f hf n\n  simp\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_monotone","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_2\nf : Nat → α → ENNReal\n⊢ Monotone fun n x => iSup fun k => iSup fun x_1 => f k x","decl":"theorem iSup_monotone {α : Type*} (f : ℕ → α → ℝ≥0∞) :\n    Monotone fun n x ↦ ⨆ (k) (_ : k ≤ n), f k x :=\n  fun _ _ hnm _ ↦ biSup_mono fun _ ↦ ge_trans hnm\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_monotone'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_2\nf : Nat → α → ENNReal\nx : α\n⊢ Monotone fun n => iSup fun k => iSup fun x_1 => f k x","decl":"theorem iSup_monotone' {α : Type*} (f : ℕ → α → ℝ≥0∞) (x : α) :\n    Monotone fun n ↦ ⨆ (k) (_ : k ≤ n), f k x := fun _ _ hnm ↦ iSup_monotone f hnm x\n\n"}
{"name":"MeasureTheory.Measure.LebesgueDecomposition.iSup_le_le","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_2\nf : Nat → α → ENNReal\nn k : Nat\nhk : LE.le k n\n⊢ LE.le (f k) fun x => iSup fun k => iSup fun x_1 => f k x","decl":"theorem iSup_le_le {α : Type*} (f : ℕ → α → ℝ≥0∞) (n k : ℕ) (hk : k ≤ n) :\n    f k ≤ fun x ↦ ⨆ (k) (_ : k ≤ n), f k x :=\n  fun x ↦ le_iSup₂ (f := fun k (_ : k ≤ n) ↦ f k x) k hk\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecomposition_of_finiteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ μ.HaveLebesgueDecomposition ν","decl":"/-- Any pair of finite measures `μ` and `ν`, `HaveLebesgueDecomposition`. That is to say,\nthere exist a measure `ξ` and a measurable function `f`, such that `ξ` is mutually singular\nwith respect to `ν` and `μ = ξ + ν.withDensity f`.\n\nThis is not an instance since this is also shown for the more general σ-finite measures with\n`MeasureTheory.Measure.haveLebesgueDecomposition_of_sigmaFinite`. -/\ntheorem haveLebesgueDecomposition_of_finiteMeasure [IsFiniteMeasure μ] [IsFiniteMeasure ν] :\n    HaveLebesgueDecomposition μ ν where\n  lebesgue_decomposition := by\n    have h := @exists_seq_tendsto_sSup _ _ _ _ _ (measurableLEEval ν μ)\n      ⟨0, 0, zero_mem_measurableLE, by simp⟩ (OrderTop.bddAbove _)\n    choose g _ hg₂ f hf₁ hf₂ using h\n    -- we set `ξ` to be the supremum of an increasing sequence of functions obtained from above\n    set ξ := ⨆ (n) (k) (_ : k ≤ n), f k with hξ\n    -- we see that `ξ` has the largest integral among all functions in `measurableLE`\n    have hξ₁ : sSup (measurableLEEval ν μ) = ∫⁻ a, ξ a ∂ν := by\n      have := @lintegral_tendsto_of_tendsto_of_monotone _ _ ν (fun n ↦ ⨆ (k) (_ : k ≤ n), f k)\n          (⨆ (n) (k) (_ : k ≤ n), f k) ?_ ?_ ?_\n      · refine tendsto_nhds_unique ?_ this\n        refine tendsto_of_tendsto_of_tendsto_of_le_of_le hg₂ tendsto_const_nhds (fun n ↦ ?_)\n          fun n ↦ ?_\n        · rw [← hf₂ n]\n          apply lintegral_mono\n          convert iSup_le_le f n n le_rfl\n          simp only [iSup_apply]\n        · exact le_sSup ⟨⨆ (k : ℕ) (_ : k ≤ n), f k, iSup_mem_measurableLE' _ hf₁ _, rfl⟩\n      · intro n\n        refine Measurable.aemeasurable ?_\n        convert (iSup_mem_measurableLE _ hf₁ n).1\n        simp\n      · refine Filter.Eventually.of_forall fun a ↦ ?_\n        simp [iSup_monotone' f _]\n      · refine Filter.Eventually.of_forall fun a ↦ ?_\n        simp [tendsto_atTop_iSup (iSup_monotone' f a)]\n    have hξm : Measurable ξ := by\n      convert Measurable.iSup fun n ↦ (iSup_mem_measurableLE _ hf₁ n).1\n      simp [hξ]\n    -- we see that `ξ` has the largest integral among all functions in `measurableLE`\n    have hξle A (hA : MeasurableSet A) : ∫⁻ a in A, ξ a ∂ν ≤ μ A := by\n        rw [hξ]\n        simp_rw [iSup_apply]\n        rw [lintegral_iSup (fun n ↦ (iSup_mem_measurableLE _ hf₁ n).1) (iSup_monotone _)]\n        exact iSup_le fun n ↦ (iSup_mem_measurableLE _ hf₁ n).2 A hA\n    have hle : ν.withDensity ξ ≤ μ := by\n      refine le_intro fun B hB _ ↦ ?_\n      rw [withDensity_apply _ hB]\n      exact hξle B hB\n    have : IsFiniteMeasure (ν.withDensity ξ) := by\n      refine isFiniteMeasure_withDensity ?_\n      have hle' := hle univ\n      rw [withDensity_apply _ MeasurableSet.univ, Measure.restrict_univ] at hle'\n      exact ne_top_of_le_ne_top (measure_ne_top _ _) hle'\n    -- `ξ` is the `f` in the theorem statement and we set `μ₁` to be `μ - ν.withDensity ξ`\n    -- since we need `μ₁ + ν.withDensity ξ = μ`\n    set μ₁ := μ - ν.withDensity ξ with hμ₁\n    refine ⟨⟨μ₁, ξ⟩, hξm, ?_, ?_⟩\n    · by_contra h\n      -- if they are not mutually singular, then from `exists_positive_of_not_mutuallySingular`,\n      -- there exists some `ε > 0` and a measurable set `E`, such that `μ(E) > 0` and `E` is\n      -- positive with respect to `ν - εμ`\n      obtain ⟨ε, hε₁, E, hE₁, hE₂, hE₃⟩ := exists_positive_of_not_mutuallySingular μ₁ ν h\n      simp_rw [hμ₁] at hE₃\n      -- since `E` is positive, we have `∫⁻ a in A ∩ E, ε + ξ a ∂ν ≤ μ (A ∩ E)` for all `A`\n      have hε₂ (A : Set α) (hA : MeasurableSet A) : ∫⁻ a in A ∩ E, ε + ξ a ∂ν ≤ μ (A ∩ E) := by\n        specialize hE₃ A hA\n        rw [lintegral_add_left measurable_const, lintegral_const, restrict_apply_univ]\n        rw [Measure.sub_apply (hA.inter hE₁) hle, withDensity_apply _ (hA.inter hE₁)] at hE₃\n        refine add_le_of_le_tsub_right_of_le (hξle _ (hA.inter hE₁)) hE₃\n      -- from this, we can show `ξ + ε * E.indicator` is a function in `measurableLE` with\n      -- integral greater than `ξ`\n      have hξε : (ξ + E.indicator fun _ ↦ (ε : ℝ≥0∞)) ∈ measurableLE ν μ := by\n        refine ⟨hξm.add (measurable_const.indicator hE₁), fun A hA ↦ ?_⟩\n        have : ∫⁻ a in A, (ξ + E.indicator fun _ ↦ (ε : ℝ≥0∞)) a ∂ν =\n            ∫⁻ a in A ∩ E, ε + ξ a ∂ν + ∫⁻ a in A \\ E, ξ a ∂ν := by\n          simp only [lintegral_add_left measurable_const, lintegral_add_left hξm,\n            setLIntegral_const, add_assoc, lintegral_inter_add_diff _ _ hE₁, Pi.add_apply,\n            lintegral_indicator hE₁, restrict_apply hE₁]\n          rw [inter_comm, add_comm]\n        rw [this, ← measure_inter_add_diff A hE₁]\n        exact add_le_add (hε₂ A hA) (hξle (A \\ E) (hA.diff hE₁))\n      have : (∫⁻ a, ξ a + E.indicator (fun _ ↦ (ε : ℝ≥0∞)) a ∂ν) ≤ sSup (measurableLEEval ν μ) :=\n        le_sSup ⟨ξ + E.indicator fun _ ↦ (ε : ℝ≥0∞), hξε, rfl⟩\n      -- but this contradicts the maximality of `∫⁻ x, ξ x ∂ν`\n      refine not_lt.2 this ?_\n      rw [hξ₁, lintegral_add_left hξm, lintegral_indicator hE₁, setLIntegral_const]\n      refine ENNReal.lt_add_right ?_ (ENNReal.mul_pos_iff.2 ⟨ENNReal.coe_pos.2 hε₁, hE₂⟩).ne'\n      have := measure_ne_top (ν.withDensity ξ) univ\n      rwa [withDensity_apply _ MeasurableSet.univ, Measure.restrict_univ] at this\n    -- since `ν.withDensity ξ ≤ μ`, it is clear that `μ = μ₁ + ν.withDensity ξ`\n    · rw [hμ₁]\n      ext1 A hA\n      rw [Measure.coe_add, Pi.add_apply, Measure.sub_apply hA hle, add_comm,\n        add_tsub_cancel_of_le (hle A)]\n\n"}
{"name":"MeasureTheory.Measure.HaveLebesgueDecomposition.sfinite_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\n_h : ∀ (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ], μ.HaveLebesgueDecomposition ν\n⊢ μ.HaveLebesgueDecomposition ν","decl":"/-- If any finite measure has a Lebesgue decomposition with respect to `ν`,\nthen the same is true for any s-finite measure. -/\ntheorem HaveLebesgueDecomposition.sfinite_of_isFiniteMeasure [SFinite μ]\n    (_h : ∀ (μ : Measure α) [IsFiniteMeasure μ], HaveLebesgueDecomposition μ ν) :\n    HaveLebesgueDecomposition μ ν :=\n  sum_sfiniteSeq μ ▸ sum_left _\n\n"}
{"name":"MeasureTheory.Measure.haveLebesgueDecomposition_of_sigmaFinite","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ μ.HaveLebesgueDecomposition ν","decl":"variable (μ ν) in\n/-- **The Lebesgue decomposition theorem**:\nAny s-finite measure `μ` has Lebesgue decomposition with respect to any σ-finite measure `ν`.\nThat is to say, there exist a measure `ξ` and a measurable function `f`,\nsuch that `ξ` is mutually singular with respect to `ν` and `μ = ξ + ν.withDensity f` -/\nnonrec instance (priority := 100) haveLebesgueDecomposition_of_sigmaFinite\n    [SFinite μ] [SigmaFinite ν] : HaveLebesgueDecomposition μ ν := by\n  wlog hμ : IsFiniteMeasure μ generalizing μ\n  · exact .sfinite_of_isFiniteMeasure fun μ _ ↦ this μ ‹_›\n  -- Take a disjoint cover that consists of sets of finite measure `ν`.\n  set s : ℕ → Set α := disjointed (spanningSets ν)\n  have hsm : ∀ n, MeasurableSet (s n) := .disjointed <| measurableSet_spanningSets _\n  have hs : ∀ n, Fact (ν (s n) < ⊤) := fun n ↦\n    ⟨lt_of_le_of_lt (measure_mono <| disjointed_le ..) (measure_spanningSets_lt_top ν n)⟩\n  -- Note that the restrictions of `μ` and `ν` to `s n` are finite measures.\n  -- Therefore, as we proved above, these restrictions have a Lebesgue decomposition.\n  -- Let `ξ n` and `f n` be the singular part and the Radon-Nikodym derivative\n  -- of these restrictions.\n  set ξ : ℕ → Measure α := fun n : ℕ ↦ singularPart (.restrict μ (s n)) (.restrict ν (s n))\n  set f : ℕ → α → ℝ≥0∞ := fun n ↦ (s n).indicator (rnDeriv (.restrict μ (s n)) (.restrict ν (s n)))\n  have hfm (n : ℕ) : Measurable (f n) := by measurability\n  -- Each `ξ n` is supported on `s n` and is mutually singular with the restriction of `ν` to `s n`.\n  -- Therefore, `ξ n` is mutually singular with `ν`, hence their sum is mutually singular with `ν`.\n  have hξ : .sum ξ ⟂ₘ ν := by\n    refine MutuallySingular.sum_left.2 fun n ↦ ?_\n    rw [← ν.restrict_add_restrict_compl (hsm n)]\n    refine (mutuallySingular_singularPart ..).add_right (.singularPart ?_ _)\n    refine ⟨(s n)ᶜ, (hsm n).compl, ?_⟩\n    simp [hsm]\n  -- Finally, the sum of all `ξ n` and measure `ν` with the density `∑' n, f n`\n  -- is equal to `μ`, thus `(Measure.sum ξ, ∑' n, f n)` is a Lebesgue decomposition for `μ` and `ν`.\n  have hadd : .sum ξ + ν.withDensity (∑' n, f n) = μ := calc\n    .sum ξ + ν.withDensity (∑' n, f n) = .sum fun n ↦ ξ n + ν.withDensity (f n) := by\n      rw [withDensity_tsum hfm, Measure.sum_add_sum]\n    _ = .sum fun n ↦ .restrict μ (s n) := by\n      simp_rw [ξ, f, withDensity_indicator (hsm _), singularPart_add_rnDeriv]\n    _ = μ := sum_restrict_disjointed_spanningSets ..\n  exact ⟨⟨(.sum ξ, ∑' n, f n), by measurability, hξ, hadd.symm⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_left'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite μ\nr : NNReal\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSMul.hSMul r ν).rnDeriv μ) (HSMul.hSMul r (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of the scalar multiple of a measure.\nSee also `rnDeriv_smul_left`, which has no hypothesis on `μ` but requires finite `ν`. -/\ntheorem rnDeriv_smul_left' (ν μ : Measure α) [SigmaFinite ν] [SigmaFinite μ] (r : ℝ≥0) :\n    (r • ν).rnDeriv μ =ᵐ[μ] r • ν.rnDeriv μ := by\n  rw [← withDensity_eq_iff_of_sigmaFinite]\n  · simp_rw [ENNReal.smul_def]\n    rw [withDensity_smul _ (measurable_rnDeriv _ _)]\n    suffices (r • ν).singularPart μ + withDensity μ (rnDeriv (r • ν) μ)\n        = (r • ν).singularPart μ + r • withDensity μ (rnDeriv ν μ) by\n      rwa [Measure.add_right_inj] at this\n    rw [← (r • ν).haveLebesgueDecomposition_add μ, singularPart_smul, ← smul_add,\n      ← ν.haveLebesgueDecomposition_add μ]\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact (measurable_rnDeriv _ _).aemeasurable.const_smul _\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_left_of_ne_top'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite μ\nr : ENNReal\nhr : Ne r Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HSMul.hSMul r ν).rnDeriv μ) (HSMul.hSMul r (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of the scalar multiple of a measure.\nSee also `rnDeriv_smul_left_of_ne_top`, which has no hypothesis on `μ` but requires finite `ν`. -/\ntheorem rnDeriv_smul_left_of_ne_top' (ν μ : Measure α) [SigmaFinite ν] [SigmaFinite μ]\n    {r : ℝ≥0∞} (hr : r ≠ ∞) :\n    (r • ν).rnDeriv μ =ᵐ[μ] r • ν.rnDeriv μ := by\n  have h : (r.toNNReal • ν).rnDeriv μ =ᵐ[μ] r.toNNReal • ν.rnDeriv μ :=\n    rnDeriv_smul_left' ν μ r.toNNReal\n  simpa [ENNReal.smul_def, ENNReal.coe_toNNReal hr] using h\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_right'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite μ\nr : NNReal\nhr : Ne r 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (ν.rnDeriv (HSMul.hSMul r μ)) (HSMul.hSMul (Inv.inv r) (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative with respect to the scalar multiple of a measure.\nSee also `rnDeriv_smul_right`, which has no hypothesis on `μ` but requires finite `ν`. -/\ntheorem rnDeriv_smul_right' (ν μ : Measure α) [SigmaFinite ν] [SigmaFinite μ]\n    {r : ℝ≥0} (hr : r ≠ 0) :\n    ν.rnDeriv (r • μ) =ᵐ[μ] r⁻¹ • ν.rnDeriv μ := by\n  refine (absolutelyContinuous_smul <| ENNReal.coe_ne_zero.2 hr).ae_le\n    (?_ : ν.rnDeriv (r • μ) =ᵐ[r • μ] r⁻¹ • ν.rnDeriv μ)\n  rw [← withDensity_eq_iff_of_sigmaFinite]\n  · simp_rw [ENNReal.smul_def]\n    rw [withDensity_smul _ (measurable_rnDeriv _ _)]\n    suffices ν.singularPart (r • μ) + withDensity (r • μ) (rnDeriv ν (r • μ))\n        = ν.singularPart (r • μ) + r⁻¹ • withDensity (r • μ) (rnDeriv ν μ) by\n      rwa [add_right_inj] at this\n    rw [← ν.haveLebesgueDecomposition_add (r • μ), singularPart_smul_right _ _ _ hr,\n      ENNReal.smul_def r, withDensity_smul_measure, ← ENNReal.smul_def, ← smul_assoc,\n      smul_eq_mul, inv_mul_cancel₀ hr, one_smul]\n    exact ν.haveLebesgueDecomposition_add μ\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact (measurable_rnDeriv _ _).aemeasurable.const_smul _\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν μ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.SigmaFinite μ\nr : ENNReal\nhr : Ne r 0\nhr_ne_top : Ne r Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq (ν.rnDeriv (HSMul.hSMul r μ)) (HSMul.hSMul (Inv.inv r) (ν.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative with respect to the scalar multiple of a measure.\nSee also `rnDeriv_smul_right_of_ne_top`, which has no hypothesis on `μ` but requires finite `ν`. -/\ntheorem rnDeriv_smul_right_of_ne_top' (ν μ : Measure α) [SigmaFinite ν] [SigmaFinite μ]\n    {r : ℝ≥0∞} (hr : r ≠ 0) (hr_ne_top : r ≠ ∞) :\n    ν.rnDeriv (r • μ) =ᵐ[μ] r⁻¹ • ν.rnDeriv μ := by\n  have h : ν.rnDeriv (r.toNNReal • μ) =ᵐ[μ] r.toNNReal⁻¹ • ν.rnDeriv μ := by\n    refine rnDeriv_smul_right' ν μ ?_\n    rw [ne_eq, ENNReal.toNNReal_eq_zero_iff]\n    simp [hr, hr_ne_top]\n  rwa [ENNReal.smul_def, ENNReal.coe_toNNReal hr_ne_top,\n    ← ENNReal.toNNReal_inv, ENNReal.smul_def, ENNReal.coe_toNNReal (ENNReal.inv_ne_top.mpr hr)] at h\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add'","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν₁ ν₂ μ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite ν₁\ninst✝¹ : MeasureTheory.SigmaFinite ν₂\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HAdd.hAdd ν₁ ν₂).rnDeriv μ) (HAdd.hAdd (ν₁.rnDeriv μ) (ν₂.rnDeriv μ))","decl":"/-- Radon-Nikodym derivative of a sum of two measures.\nSee also `rnDeriv_add`, which has no hypothesis on `μ` but requires finite `ν₁` and `ν₂`. -/\nlemma rnDeriv_add' (ν₁ ν₂ μ : Measure α) [SigmaFinite ν₁] [SigmaFinite ν₂] [SigmaFinite μ] :\n    (ν₁ + ν₂).rnDeriv μ =ᵐ[μ] ν₁.rnDeriv μ + ν₂.rnDeriv μ := by\n  rw [← withDensity_eq_iff_of_sigmaFinite]\n  · suffices (ν₁ + ν₂).singularPart μ + μ.withDensity ((ν₁ + ν₂).rnDeriv μ)\n        = (ν₁ + ν₂).singularPart μ + μ.withDensity (ν₁.rnDeriv μ + ν₂.rnDeriv μ) by\n      rwa [add_right_inj] at this\n    rw [← (ν₁ + ν₂).haveLebesgueDecomposition_add μ, singularPart_add,\n      withDensity_add_left (measurable_rnDeriv _ _), add_assoc,\n      add_comm (ν₂.singularPart μ), add_assoc, add_comm _ (ν₂.singularPart μ),\n      ← ν₂.haveLebesgueDecomposition_add μ, ← add_assoc, ← ν₁.haveLebesgueDecomposition_add μ]\n  · exact (measurable_rnDeriv _ _).aemeasurable\n  · exact ((measurable_rnDeriv _ _).add (measurable_rnDeriv _ _)).aemeasurable\n\n"}
{"name":"MeasureTheory.Measure.rnDeriv_add_of_mutuallySingular","module":"Mathlib.MeasureTheory.Decomposition.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nν₁ ν₂ μ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SigmaFinite ν₁\ninst✝¹ : MeasureTheory.SigmaFinite ν₂\ninst✝ : MeasureTheory.SigmaFinite μ\nh : ν₂.MutuallySingular μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((HAdd.hAdd ν₁ ν₂).rnDeriv μ) (ν₁.rnDeriv μ)","decl":"lemma rnDeriv_add_of_mutuallySingular (ν₁ ν₂ μ : Measure α)\n    [SigmaFinite ν₁] [SigmaFinite ν₂] [SigmaFinite μ] (h : ν₂ ⟂ₘ μ) :\n    (ν₁ + ν₂).rnDeriv μ =ᵐ[μ] ν₁.rnDeriv μ := by\n  filter_upwards [rnDeriv_add' ν₁ ν₂ μ, (rnDeriv_eq_zero ν₂ μ).mpr h] with x hx_add hx_zero\n  simp [hx_add, hx_zero]\n\n"}
