{"name":"BoxIntegral.Box.mem_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\ns : Set Î¹\ny : Î¹ â†’ Real\nâŠ¢ Iff (Membership.mem (I.splitCenterBox s) y) (And (Membership.mem I y) (âˆ€ (i : Î¹), Iff (LT.lt (HDiv.hDiv (HAdd.hAdd (I.lower i) (I.upper i)) 2) (y i)) (Membership.mem s i)))","decl":"theorem mem_splitCenterBox {s : Set Î¹} {y : Î¹ â†’ â„} :\n    y âˆˆ I.splitCenterBox s â†” y âˆˆ I âˆ§ âˆ€ i, (I.lower i + I.upper i) / 2 < y i â†” i âˆˆ s := by\n  simp only [splitCenterBox, mem_def, â† forall_and]\n  refine forall_congr' fun i â†¦ ?_\n  dsimp only [Set.piecewise]\n  split_ifs with hs <;> simp only [hs, iff_true, iff_false, not_lt]\n  exacts [âŸ¨fun H â†¦ âŸ¨âŸ¨(left_lt_add_div_two.2 (I.lower_lt_upper i)).trans H.1, H.2âŸ©, H.1âŸ©,\n      fun H â†¦ âŸ¨H.2, H.1.2âŸ©âŸ©,\n    âŸ¨fun H â†¦ âŸ¨âŸ¨H.1, H.2.trans (add_div_two_lt_right.2 (I.lower_lt_upper i)).leâŸ©, H.2âŸ©,\n      fun H â†¦ âŸ¨H.1.1, H.2âŸ©âŸ©]\n\n"}
{"name":"BoxIntegral.Box.splitCenterBox_le","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\ns : Set Î¹\nâŠ¢ LE.le (I.splitCenterBox s) I","decl":"theorem splitCenterBox_le (I : Box Î¹) (s : Set Î¹) : I.splitCenterBox s â‰¤ I :=\n  fun _ hx â†¦ (mem_splitCenterBox.1 hx).1\n\n"}
{"name":"BoxIntegral.Box.disjoint_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\ns t : Set Î¹\nh : Ne s t\nâŠ¢ Disjoint â†‘(I.splitCenterBox s) â†‘(I.splitCenterBox t)","decl":"theorem disjoint_splitCenterBox (I : Box Î¹) {s t : Set Î¹} (h : s â‰  t) :\n    Disjoint (I.splitCenterBox s : Set (Î¹ â†’ â„)) (I.splitCenterBox t) := by\n  rw [disjoint_iff_inf_le]\n  rintro y âŸ¨hs, htâŸ©; apply h\n  ext i\n  rw [mem_coe, mem_splitCenterBox] at hs ht\n  rw [â† hs.2, â† ht.2]\n\n"}
{"name":"BoxIntegral.Box.injective_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\nâŠ¢ Function.Injective I.splitCenterBox","decl":"theorem injective_splitCenterBox (I : Box Î¹) : Injective I.splitCenterBox := fun _ _ H â†¦\n  by_contra fun Hne â†¦ (I.disjoint_splitCenterBox Hne).ne (nonempty_coe _).ne_empty (H â–¸ rfl)\n\n"}
{"name":"BoxIntegral.Box.exists_mem_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\nx : Î¹ â†’ Real\nâŠ¢ Iff (Exists fun s => Membership.mem (I.splitCenterBox s) x) (Membership.mem I x)","decl":"@[simp]\ntheorem exists_mem_splitCenterBox {I : Box Î¹} {x : Î¹ â†’ â„} : (âˆƒ s, x âˆˆ I.splitCenterBox s) â†” x âˆˆ I :=\n  âŸ¨fun âŸ¨s, hsâŸ© â†¦ I.splitCenterBox_le s hs, fun hx â†¦\n    âŸ¨{ i | (I.lower i + I.upper i) / 2 < x i }, mem_splitCenterBox.2 âŸ¨hx, fun _ â†¦ Iff.rflâŸ©âŸ©âŸ©\n\n"}
{"name":"BoxIntegral.Box.splitCenterBoxEmb_apply","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\ns : Set Î¹\nâŠ¢ Eq (I.splitCenterBoxEmb s) (I.splitCenterBox s)","decl":"/-- `BoxIntegral.Box.splitCenterBox` bundled as a `Function.Embedding`. -/\n@[simps]\ndef splitCenterBoxEmb (I : Box Î¹) : Set Î¹ â†ª Box Î¹ :=\n  âŸ¨splitCenterBox I, injective_splitCenterBox IâŸ©\n\n"}
{"name":"BoxIntegral.Box.iUnion_coe_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\nâŠ¢ Eq (Set.iUnion fun s => â†‘(I.splitCenterBox s)) â†‘I","decl":"@[simp]\ntheorem iUnion_coe_splitCenterBox (I : Box Î¹) : â‹ƒ s, (I.splitCenterBox s : Set (Î¹ â†’ â„)) = I := by\n  ext x\n  simp\n\n"}
{"name":"BoxIntegral.Box.upper_sub_lower_splitCenterBox","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\nI : BoxIntegral.Box Î¹\ns : Set Î¹\ni : Î¹\nâŠ¢ Eq (HSub.hSub ((I.splitCenterBox s).upper i) ((I.splitCenterBox s).lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) 2)","decl":"@[simp]\ntheorem upper_sub_lower_splitCenterBox (I : Box Î¹) (s : Set Î¹) (i : Î¹) :\n    (I.splitCenterBox s).upper i - (I.splitCenterBox s).lower i = (I.upper i - I.lower i) / 2 := by\n  by_cases i âˆˆ s <;> field_simp [splitCenterBox] <;> field_simp [mul_two, two_mul]\n\n"}
{"name":"BoxIntegral.Box.subbox_induction_on'","module":"Mathlib.Analysis.BoxIntegral.Box.SubboxInduction","initialProofState":"Î¹ : Type u_1\np : BoxIntegral.Box Î¹ â†’ Prop\nI : BoxIntegral.Box Î¹\nH_ind : âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ (âˆ€ (s : Set Î¹), p (J.splitCenterBox s)) â†’ p J\nH_nhds : âˆ€ (z : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) z â†’ Exists fun U => And (Membership.mem (nhdsWithin z (BoxIntegral.Box.Icc I)) U) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ âˆ€ (m : Nat), Membership.mem (BoxIntegral.Box.Icc J) z â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) U â†’ (âˆ€ (i : Î¹), Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) (HPow.hPow 2 m))) â†’ p J)\nâŠ¢ p I","decl":"/-- Let `p` be a predicate on `Box Î¹`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* `H_ind` : Consider a smaller box `J â‰¤ I`. The hyperplanes passing through the center of `J` split\n  it into `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n\n* `H_nhds` : For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within\n  `I.Icc` such that for every box `J â‰¤ I` such that `z âˆˆ J.Icc âŠ† U`, if `J` is homothetic to `I`\n  with a coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `BoxIntegral.Box.subbox_induction_on` for a version using\n`BoxIntegral.Prepartition.splitCenter` instead of `BoxIntegral.Box.splitCenterBox`.\n\nThe proof still works if we assume `H_ind` only for subboxes `J â‰¤ I` that are homothetic to `I` with\na coefficient of the form `2â»áµ` but we do not need this generalization yet. -/\n@[elab_as_elim]\ntheorem subbox_induction_on' {p : Box Î¹ â†’ Prop} (I : Box Î¹)\n    (H_ind : âˆ€ J â‰¤ I, (âˆ€ s, p (splitCenterBox J s)) â†’ p J)\n    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•), z âˆˆ Box.Icc J â†’\n      Box.Icc J âŠ† U â†’ (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :\n    p I := by\n  by_contra hpI\n  -- First we use `H_ind` to construct a decreasing sequence of boxes such that `âˆ€ m, Â¬p (J m)`.\n  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)\n  simp only [exists_imp, not_forall] at H_ind\n  choose! s hs using H_ind\n  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I\n  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=\n    fun m â†¦ iterate_succ_apply' _ _ _\n  -- Now we prove some properties of `J`\n  have hJmono : Antitone J :=\n    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _\n  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)\n  have hJp : âˆ€ m, Â¬p (J m) :=\n    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)\n  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by\n    intro m i\n    induction' m with m ihm\n    Â· simp [J]\n    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]\n  have h0 : J 0 = I := rfl\n  clear_value J\n  clear hpI hs J_succ s\n  -- Let `z` be the unique common point of all `(J m).Icc`. Then `H_nhds` proves `p (J m)` for\n  -- sufficiently large `m`. This contradicts `hJp`.\n  set z : Î¹ â†’ â„ := â¨† m, (J m).lower\n  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=\n    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc\n      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)\n  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc\n  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc\n  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=\n    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©\n  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by\n    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this\n    refine tendsto_pi_nhds.2 fun i â†¦ ?_\n    simpa [hJsub] using\n      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)\n  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z) :=\n    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (Eventually.of_forall hJl_mem)\n  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z) :=\n    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (Eventually.of_forall hJu_mem)\n  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©\n  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©\n  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))\n\n"}
