{"name":"LinearMap.toMatrix_directSum_collectedBasis_eq_blockDiagonal'","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁹ : DecidableEq ι\nR : Type u_4\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nN₁ : ι → Submodule R M₁\nh₁ : DirectSum.IsInternal N₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\nN₂ : ι → Submodule R M₂\nh₂ : DirectSum.IsInternal N₂\nκ₁ : ι → Type u_7\nκ₂ : ι → Type u_8\ninst✝³ : (i : ι) → Fintype (κ₁ i)\ninst✝² : ∀ (i : ι), Finite (κ₂ i)\ninst✝¹ : (i : ι) → DecidableEq (κ₁ i)\ninst✝ : Fintype ι\nb₁ : (i : ι) → Basis (κ₁ i) R (Subtype fun x => Membership.mem (N₁ i) x)\nb₂ : (i : ι) → Basis (κ₂ i) R (Subtype fun x => Membership.mem (N₂ i) x)\nf : LinearMap (RingHom.id R) M₁ M₂\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N₁ i) ↑(N₂ i)\n⊢ Eq ((LinearMap.toMatrix (h₁.collectedBasis b₁) (h₂.collectedBasis b₂)) f) (Matrix.blockDiagonal' fun i => (LinearMap.toMatrix (b₁ i) (b₂ i)) (f.restrict ⋯))","decl":"/-- If a linear map `f : M₁ → M₂` respects direct sum decompositions of `M₁` and `M₂`, then it has a\nblock diagonal matrix with respect to bases compatible with the direct sum decompositions. -/\nlemma toMatrix_directSum_collectedBasis_eq_blockDiagonal' {R M₁ M₂ : Type*} [CommSemiring R]\n    [AddCommMonoid M₁] [Module R M₁] {N₁ : ι → Submodule R M₁} (h₁ : IsInternal N₁)\n    [AddCommMonoid M₂] [Module R M₂] {N₂ : ι → Submodule R M₂} (h₂ : IsInternal N₂)\n    {κ₁ κ₂ : ι → Type*} [∀ i, Fintype (κ₁ i)] [∀ i, Finite (κ₂ i)] [∀ i, DecidableEq (κ₁ i)]\n    [Fintype ι] (b₁ : (i : ι) → Basis (κ₁ i) R (N₁ i)) (b₂ : (i : ι) → Basis (κ₂ i) R (N₂ i))\n    {f : M₁ →ₗ[R] M₂} (hf : ∀ i, MapsTo f (N₁ i) (N₂ i)) :\n    toMatrix (h₁.collectedBasis b₁) (h₂.collectedBasis b₂) f =\n    Matrix.blockDiagonal' fun i ↦ toMatrix (b₁ i) (b₂ i) (f.restrict (hf i)) := by\n  ext ⟨i, _⟩ ⟨j, _⟩\n  simp only [toMatrix_apply, Matrix.blockDiagonal'_apply]\n  rcases eq_or_ne i j with rfl | hij\n  · simp [h₂.collectedBasis_repr_of_mem _ (hf _ (Subtype.mem _)), restrict_apply]\n  · simp [hij, h₂.collectedBasis_repr_of_mem_ne _ hij.symm (hf _ (Subtype.mem _))]\n\n"}
{"name":"LinearMap.diag_toMatrix_directSum_collectedBasis_eq_zero_of_mapsTo_ne","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : ι → Submodule R M\ninst✝² : DecidableEq ι\nκ : ι → Type u_4\ninst✝¹ : (i : ι) → Fintype (κ i)\ninst✝ : (i : ι) → DecidableEq (κ i)\ns : Finset ι\nh : DirectSum.IsInternal fun i => N ↑i\nb : (i : Subtype fun x => Membership.mem s x) → Basis (κ ↑i) R (Subtype fun x => Membership.mem (N ↑i) x)\nσ : ι → ι\nhσ : ∀ (i : ι), Ne (σ i) i\nf : Module.End R M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N (σ i))\nhN : ∀ (i : ι), Not (Membership.mem s i) → Eq (N i) Bot.bot\n⊢ Eq ((LinearMap.toMatrix (h.collectedBasis b) (h.collectedBasis b)) f).diag 0","decl":"lemma diag_toMatrix_directSum_collectedBasis_eq_zero_of_mapsTo_ne\n    {κ : ι → Type*} [∀ i, Fintype (κ i)] [∀ i, DecidableEq (κ i)]\n    {s : Finset ι} (h : IsInternal fun i : s ↦ N i)\n    (b : (i : s) → Basis (κ i) R (N i)) (σ : ι → ι) (hσ : ∀ i, σ i ≠ i)\n    {f : Module.End R M} (hf : ∀ i, MapsTo f (N i) (N <| σ i)) (hN : ∀ i, i ∉ s → N i = ⊥) :\n    Matrix.diag (toMatrix (h.collectedBasis b) (h.collectedBasis b) f) = 0 := by\n  ext ⟨i, k⟩\n  simp only [Matrix.diag_apply, Pi.zero_apply, toMatrix_apply, IsInternal.collectedBasis_coe]\n  by_cases hi : σ i ∈ s\n  · let j : s := ⟨σ i, hi⟩\n    replace hσ : j ≠ i := fun hij ↦ hσ i <| Subtype.ext_iff.mp hij\n    exact h.collectedBasis_repr_of_mem_ne b hσ <| hf _ <| Subtype.mem (b i k)\n  · suffices f (b i k) = 0 by simp [this]\n    simpa [hN _ hi] using hf i <| Subtype.mem (b i k)\n\n"}
{"name":"LinearMap.trace_eq_sum_trace_restrict","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : ι → Submodule R M\ninst✝³ : DecidableEq ι\ninst✝² : ∀ (i : ι), Module.Finite R (Subtype fun x => Membership.mem (N i) x)\ninst✝¹ : ∀ (i : ι), Module.Free R (Subtype fun x => Membership.mem (N i) x)\nh : DirectSum.IsInternal N\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id R) M M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N i)\n⊢ Eq ((LinearMap.trace R M) f) (Finset.univ.sum fun i => (LinearMap.trace R (Subtype fun x => Membership.mem (N i) x)) (f.restrict ⋯))","decl":"/-- The trace of an endomorphism of a direct sum is the sum of the traces on each component.\n\nSee also `LinearMap.trace_restrict_eq_sum_trace_restrict`. -/\nlemma trace_eq_sum_trace_restrict (h : IsInternal N) [Fintype ι]\n    {f : M →ₗ[R] M} (hf : ∀ i, MapsTo f (N i) (N i)) :\n    trace R M f = ∑ i, trace R (N i) (f.restrict (hf i)) := by\n  let b : (i : ι) → Basis _ R (N i) := fun i ↦ Module.Free.chooseBasis R (N i)\n  simp_rw [trace_eq_matrix_trace R (h.collectedBasis b),\n    toMatrix_directSum_collectedBasis_eq_blockDiagonal' h h b b hf, Matrix.trace_blockDiagonal',\n    ← trace_eq_matrix_trace]\n\n"}
{"name":"LinearMap.trace_eq_sum_trace_restrict'","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : ι → Submodule R M\ninst✝² : DecidableEq ι\ninst✝¹ : ∀ (i : ι), Module.Finite R (Subtype fun x => Membership.mem (N i) x)\ninst✝ : ∀ (i : ι), Module.Free R (Subtype fun x => Membership.mem (N i) x)\nh : DirectSum.IsInternal N\nhN : (setOf fun i => Ne (N i) Bot.bot).Finite\nf : LinearMap (RingHom.id R) M M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N i)\n⊢ Eq ((LinearMap.trace R M) f) (hN.toFinset.sum fun i => (LinearMap.trace R (Subtype fun x => Membership.mem (N i) x)) (f.restrict ⋯))","decl":"lemma trace_eq_sum_trace_restrict' (h : IsInternal N) (hN : {i | N i ≠ ⊥}.Finite)\n    {f : M →ₗ[R] M} (hf : ∀ i, MapsTo f (N i) (N i)) :\n    trace R M f = ∑ i ∈ hN.toFinset, trace R (N i) (f.restrict (hf i)) := by\n  let _ : Fintype {i // N i ≠ ⊥} := hN.fintype\n  let _ : Fintype {i | N i ≠ ⊥} := hN.fintype\n  rw [← Finset.sum_coe_sort, trace_eq_sum_trace_restrict (isInternal_ne_bot_iff.mpr h) _]\n  exact Fintype.sum_equiv hN.subtypeEquivToFinset _ _ (fun i ↦ rfl)\n\n"}
{"name":"LinearMap.trace_eq_zero_of_mapsTo_ne","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : ι → Submodule R M\ninst✝³ : DecidableEq ι\ninst✝² : ∀ (i : ι), Module.Finite R (Subtype fun x => Membership.mem (N i) x)\ninst✝¹ : ∀ (i : ι), Module.Free R (Subtype fun x => Membership.mem (N i) x)\nh : DirectSum.IsInternal N\ninst✝ : IsNoetherian R M\nσ : ι → ι\nhσ : ∀ (i : ι), Ne (σ i) i\nf : Module.End R M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N (σ i))\n⊢ Eq ((LinearMap.trace R M) f) 0","decl":"lemma trace_eq_zero_of_mapsTo_ne (h : IsInternal N) [IsNoetherian R M]\n    (σ : ι → ι) (hσ : ∀ i, σ i ≠ i) {f : Module.End R M}\n    (hf : ∀ i, MapsTo f (N i) (N <| σ i)) :\n    trace R M f = 0 := by\n  have hN : {i | N i ≠ ⊥}.Finite := WellFoundedGT.finite_ne_bot_of_iSupIndep\n    h.submodule_iSupIndep\n  let s := hN.toFinset\n  let κ := fun i ↦ Module.Free.ChooseBasisIndex R (N i)\n  let b : (i : s) → Basis (κ i) R (N i) := fun i ↦ Module.Free.chooseBasis R (N i)\n  replace h : IsInternal fun i : s ↦ N i := by\n    convert DirectSum.isInternal_ne_bot_iff.mpr h <;> simp [s]\n  simp_rw [trace_eq_matrix_trace R (h.collectedBasis b), Matrix.trace,\n    diag_toMatrix_directSum_collectedBasis_eq_zero_of_mapsTo_ne h b σ hσ hf (by simp [s]),\n    Pi.zero_apply, Finset.sum_const_zero]\n\n"}
{"name":"LinearMap.trace_comp_eq_zero_of_commute_of_trace_restrict_eq_zero","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf g : Module.End R M\nh_comm : Commute f g\nhf : Eq (iSup fun μ => f.maxGenEigenspace μ) Top.top\nhg : ∀ (μ : R), Eq ((LinearMap.trace R (Subtype fun x => Membership.mem (f.maxGenEigenspace μ) x)) (LinearMap.restrict g ⋯)) 0\n⊢ Eq ((LinearMap.trace R M) (LinearMap.comp g f)) 0","decl":"/-- If `f` and `g` are commuting endomorphisms of a finite, free `R`-module `M`, such that `f`\nis triangularizable, then to prove that the trace of `g ∘ f` vanishes, it is sufficient to prove\nthat the trace of `g` vanishes on each generalized eigenspace of `f`. -/\nlemma trace_comp_eq_zero_of_commute_of_trace_restrict_eq_zero\n    [IsDomain R] [IsPrincipalIdealRing R] [Module.Free R M] [Module.Finite R M]\n    {f g : Module.End R M}\n    (h_comm : Commute f g)\n    (hf : ⨆ μ, f.maxGenEigenspace μ = ⊤)\n    (hg : ∀ μ, trace R _ (g.restrict (f.mapsTo_maxGenEigenspace_of_comm h_comm μ)) = 0) :\n    trace R _ (g ∘ₗ f) = 0 := by\n  have hfg : ∀ μ,\n      MapsTo (g ∘ₗ f) ↑(f.maxGenEigenspace μ) ↑(f.maxGenEigenspace μ) :=\n    fun μ ↦ (f.mapsTo_maxGenEigenspace_of_comm h_comm μ).comp\n      (f.mapsTo_maxGenEigenspace_of_comm rfl μ)\n  suffices ∀ μ, trace R _ ((g ∘ₗ f).restrict (hfg μ)) = 0 by\n    classical\n    have hds := DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top\n      f.independent_maxGenEigenspace hf\n    have h_fin : {μ | f.maxGenEigenspace μ ≠ ⊥}.Finite :=\n      WellFoundedGT.finite_ne_bot_of_iSupIndep f.independent_maxGenEigenspace\n    simp [trace_eq_sum_trace_restrict' hds h_fin hfg, this]\n  intro μ\n  replace h_comm : Commute (g.restrict (f.mapsTo_maxGenEigenspace_of_comm h_comm μ))\n      (f.restrict (f.mapsTo_maxGenEigenspace_of_comm rfl μ)) :=\n    restrict_commute h_comm.symm _ _\n  rw [restrict_comp, trace_comp_eq_mul_of_commute_of_isNilpotent μ h_comm\n    (f.isNilpotent_restrict_maxGenEigenspace_sub_algebraMap μ), hg, mul_zero]\n\n"}
{"name":"LinearMap.mapsTo_biSup_of_mapsTo","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_4\nN : ι → Submodule R M\ns : Set ι\nf : Module.End R M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N i)\n⊢ Set.MapsTo ⇑f ↑(iSup fun i => iSup fun h => N i) ↑(iSup fun i => iSup fun h => N i)","decl":"lemma mapsTo_biSup_of_mapsTo {ι : Type*} {N : ι → Submodule R M}\n    (s : Set ι) {f : Module.End R M} (hf : ∀ i, MapsTo f (N i) (N i)) :\n    MapsTo f ↑(⨆ i ∈ s, N i) ↑(⨆ i ∈ s, N i) := by\n  replace hf : ∀ i, (N i).map f ≤ N i := fun i ↦ Submodule.map_le_iff_le_comap.mpr (hf i)\n  suffices (⨆ i ∈ s, N i).map f ≤ ⨆ i ∈ s, N i from Submodule.map_le_iff_le_comap.mp this\n  simpa only [Submodule.map_iSup] using iSup₂_mono <| fun i _ ↦ hf i\n\n"}
{"name":"LinearMap.trace_eq_sum_trace_restrict_of_eq_biSup","module":"Mathlib.Algebra.DirectSum.LinearMap","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : ι → Submodule R M\ninst✝¹ : ∀ (i : ι), Module.Finite R (Subtype fun x => Membership.mem (N i) x)\ninst✝ : ∀ (i : ι), Module.Free R (Subtype fun x => Membership.mem (N i) x)\ns : Finset ι\nh : iSupIndep fun i => N ↑i\nf : Module.End R M\nhf : ∀ (i : ι), Set.MapsTo ⇑f ↑(N i) ↑(N i)\np : Submodule R M\nhp : Eq p (iSup fun i => iSup fun h => N i)\nhp' : optParam (Set.MapsTo ⇑f ↑p ↑p) ⋯\n⊢ Eq ((LinearMap.trace R (Subtype fun x => Membership.mem p x)) (LinearMap.restrict f hp')) (s.sum fun i => (LinearMap.trace R (Subtype fun x => Membership.mem (N i) x)) (LinearMap.restrict f ⋯))","decl":"/-- The trace of an endomorphism of a direct sum is the sum of the traces on each component.\n\nNote that it is important the statement gives the user definitional control over `p` since the\n_type_ of the term `trace R p (f.restrict hp')` depends on `p`. -/\nlemma trace_eq_sum_trace_restrict_of_eq_biSup\n    [∀ i, Module.Finite R (N i)] [∀ i, Module.Free R (N i)]\n    (s : Finset ι) (h : iSupIndep <| fun i : s ↦ N i)\n    {f : Module.End R M} (hf : ∀ i, MapsTo f (N i) (N i))\n    (p : Submodule R M) (hp : p = ⨆ i ∈ s, N i)\n    (hp' : MapsTo f p p := hp ▸ mapsTo_biSup_of_mapsTo (s : Set ι) hf) :\n    trace R p (f.restrict hp') = ∑ i ∈ s, trace R (N i) (f.restrict (hf i)) := by\n  classical\n  let N' : s → Submodule R p := fun i ↦ (N i).comap p.subtype\n  replace h : IsInternal N' := hp ▸ isInternal_biSup_submodule_of_iSupIndep (s : Set ι) h\n  have hf' : ∀ i, MapsTo (restrict f hp') (N' i) (N' i) := fun i x hx' ↦ by simpa using hf i hx'\n  let e : (i : s) → N' i ≃ₗ[R] N i := fun ⟨i, hi⟩ ↦ (N i).comapSubtypeEquivOfLe (hp ▸ le_biSup N hi)\n  have _i1 : ∀ i, Module.Finite R (N' i) := fun i ↦ Module.Finite.equiv (e i).symm\n  have _i2 : ∀ i, Module.Free R (N' i) := fun i ↦ Module.Free.of_equiv (e i).symm\n  rw [trace_eq_sum_trace_restrict h hf', ← s.sum_coe_sort]\n  have : ∀ i : s, f.restrict (hf i) = (e i).conj ((f.restrict hp').restrict (hf' i)) := fun _ ↦ rfl\n  simp [this]\n\n"}
