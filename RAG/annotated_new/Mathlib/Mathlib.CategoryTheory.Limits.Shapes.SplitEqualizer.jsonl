{"name":"CategoryTheory.IsSplitEqualizer.Œπ_leftRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œπ self.leftRetraction) (CategoryTheory.CategoryStruct.id W)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nleftRetraction‚úù : Quiver.Hom X W\nrightRetraction‚úù : Quiver.Hom Y X\ncondition‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)) _auto‚úù\nŒπ_leftRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ leftRetraction‚úù) (CategoryTheory.CategoryStruct.id W)) _auto‚úù\nbottom_rightRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ntop_rightRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction‚úù) (CategoryTheory.CategoryStruct.comp leftRetraction‚úù Œπ)) _auto‚úù\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)) _auto‚úù\nŒπ_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto‚úù\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction Œπ)) _auto‚úù\nx‚úù : Eq { leftRetraction := leftRetraction‚úù, rightRetraction := rightRetraction‚úù, condition := condition‚úù, Œπ_leftRetraction := Œπ_leftRetraction‚úù, bottom_rightRetraction := bottom_rightRetraction‚úù, top_rightRetraction := top_rightRetraction‚úù } { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, Œπ_leftRetraction := Œπ_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }\n‚ä¢ And (Eq leftRetraction‚úù leftRetraction) (Eq rightRetraction‚úù rightRetraction)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\ninst‚úù : SizeOf C\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)) _auto‚úù\nŒπ_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto‚úù\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction Œπ)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, Œπ_leftRetraction := Œπ_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf leftRetraction)) (SizeOf.sizeOf rightRetraction)) (SizeOf.sizeOf condition)) (SizeOf.sizeOf Œπ_leftRetraction)) (SizeOf.sizeOf bottom_rightRetraction)) (SizeOf.sizeOf top_rightRetraction))","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nleftRetraction‚úù : Quiver.Hom X W\nrightRetraction‚úù : Quiver.Hom Y X\ncondition‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)) _auto‚úù\nŒπ_leftRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ leftRetraction‚úù) (CategoryTheory.CategoryStruct.id W)) _auto‚úù\nbottom_rightRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ntop_rightRetraction‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction‚úù) (CategoryTheory.CategoryStruct.comp leftRetraction‚úù Œπ)) _auto‚úù\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)) _auto‚úù\nŒπ_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp Œπ leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto‚úù\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction Œπ)) _auto‚úù\n‚ä¢ Eq (Eq { leftRetraction := leftRetraction‚úù, rightRetraction := rightRetraction‚úù, condition := condition‚úù, Œπ_leftRetraction := Œπ_leftRetraction‚úù, bottom_rightRetraction := bottom_rightRetraction‚úù, top_rightRetraction := top_rightRetraction‚úù } { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, Œπ_leftRetraction := Œπ_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }) (And (Eq leftRetraction‚úù leftRetraction) (Eq rightRetraction‚úù rightRetraction))","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.bottom_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g self.rightRetraction) (CategoryTheory.CategoryStruct.id X)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.top_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f self.rightRetraction) (CategoryTheory.CategoryStruct.comp self.leftRetraction Œπ)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      Œπ   f\n    W ‚Üí X ‚áâ Y\n          g\n```\n\nsatisfying `Œπ ‚â´ f = Œπ ‚â´ g` together with morphisms\n\n```\n      r   t\n    W ‚Üê X ‚Üê Y\n```\n\nsatisfying `Œπ ‚â´ r = ùüô W`, `g ‚â´ t = ùüô X` and `f ‚â´ t = r ‚â´ Œπ`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (Œπ : W ‚ü∂ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ‚ü∂ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ‚ü∂ X\n  /-- Composition of `Œπ` with `f` and with `g` agree -/\n  condition : Œπ ‚â´ f = Œπ ‚â´ g := by aesop_cat\n  /-- `leftRetraction` splits `Œπ` -/\n  Œπ_leftRetraction : Œπ ‚â´ leftRetraction = ùüô W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ‚â´ rightRetraction = ùüô X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `Œπ` -/\n  top_rightRetraction : f ‚â´ rightRetraction = leftRetraction ‚â´ Œπ := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œπ (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp Œπ (CategoryTheory.CategoryStruct.comp g h))","decl":"attribute [reassoc] condition\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.bottom_rightRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp self.rightRetraction h)) h","decl":"attribute [reassoc (attr := simp)] Œπ_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.Œπ_leftRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œπ (CategoryTheory.CategoryStruct.comp self.leftRetraction h)) h","decl":"attribute [reassoc (attr := simp)] Œπ_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.top_rightRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g Œπ\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp self.rightRetraction h)) (CategoryTheory.CategoryStruct.comp self.leftRetraction (CategoryTheory.CategoryStruct.comp Œπ h))","decl":"attribute [reassoc (attr := simp)] Œπ_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.map_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nq : CategoryTheory.IsSplitEqualizer f g Œπ\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (q.map F).rightRetraction (F.map q.rightRetraction)","decl":"/-- Split equalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitEqualizer.map {W : C} {Œπ : W ‚ü∂ X} (q : IsSplitEqualizer f g Œπ) (F : C ‚•§ D) :\n    IsSplitEqualizer (F.map f) (F.map g) (F.map Œπ) where\n  leftRetraction := F.map q.leftRetraction\n  rightRetraction := F.map q.rightRetraction\n  condition := by rw [‚Üê F.map_comp, q.condition, F.map_comp]\n  Œπ_leftRetraction := by rw [‚Üê F.map_comp, q.Œπ_leftRetraction, F.map_id]\n  bottom_rightRetraction := by rw [‚Üê F.map_comp, q.bottom_rightRetraction, F.map_id]\n  top_rightRetraction := by rw [‚Üê F.map_comp, q.top_rightRetraction, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.map_leftRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nŒπ : Quiver.Hom W X\nq : CategoryTheory.IsSplitEqualizer f g Œπ\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (q.map F).leftRetraction (F.map q.leftRetraction)","decl":"/-- Split equalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitEqualizer.map {W : C} {Œπ : W ‚ü∂ X} (q : IsSplitEqualizer f g Œπ) (F : C ‚•§ D) :\n    IsSplitEqualizer (F.map f) (F.map g) (F.map Œπ) where\n  leftRetraction := F.map q.leftRetraction\n  rightRetraction := F.map q.rightRetraction\n  condition := by rw [‚Üê F.map_comp, q.condition, F.map_comp]\n  Œπ_leftRetraction := by rw [‚Üê F.map_comp, q.Œπ_leftRetraction, F.map_id]\n  bottom_rightRetraction := by rw [‚Üê F.map_comp, q.bottom_rightRetraction, F.map_id]\n  top_rightRetraction := by rw [‚Üê F.map_comp, q.top_rightRetraction, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.asFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nh : Quiver.Hom W X\nt : CategoryTheory.IsSplitEqualizer f g h\n‚ä¢ Eq t.asFork.pt W","decl":"/-- A split equalizer clearly induces a fork. -/\n@[simps! pt]\ndef IsSplitEqualizer.asFork {W : C} {h : W ‚ü∂ X} (t : IsSplitEqualizer f g h) :\n    Fork f g := Fork.ofŒπ h t.condition\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.asFork_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nh : Quiver.Hom W X\nt : CategoryTheory.IsSplitEqualizer f g h\n‚ä¢ Eq t.asFork.Œπ h","decl":"@[simp]\ntheorem IsSplitEqualizer.asFork_Œπ {W : C} {h : W ‚ü∂ X} (t : IsSplitEqualizer f g h) :\n    t.asFork.Œπ = h := rfl\n\n"}
{"name":"CategoryTheory.HasSplitEqualizer.splittable","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nself : CategoryTheory.HasSplitEqualizer f g\n‚ä¢ Exists fun W => Exists fun h => Nonempty (CategoryTheory.IsSplitEqualizer f g h)","decl":"/--\nThe pair `f,g` is a cosplit pair if there is an `h : W ‚ü∂ X` so that `f, g, h` forms a split\nequalizer in `C`.\n-/\nclass HasSplitEqualizer : Prop where\n  /-- There is some split equalizer -/\n  splittable : ‚àÉ (W : C) (h : W ‚ü∂ X), Nonempty (IsSplitEqualizer f g h)\n\n"}
{"name":"CategoryTheory.map_is_cosplit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.HasSplitEqualizer f g\n‚ä¢ CategoryTheory.HasSplitEqualizer (G.map f) (G.map g)","decl":"/-- If `f, g` is cosplit, then `G f, G g` is cosplit. -/\ninstance map_is_cosplit_pair [HasSplitEqualizer f g] : HasSplitEqualizer (G.map f) (G.map g) where\n  splittable :=\n    ‚ü®_, _, ‚ü®IsSplitEqualizer.map (HasSplitEqualizer.isSplitEqualizer f g) _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_of_hasSplitEqualizer","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.HasSplitEqualizer f g\n‚ä¢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- If a pair has a split equalizer, it has a equalizer. -/\ninstance (priority := 1) hasEqualizer_of_hasSplitEqualizer [HasSplitEqualizer f g] :\n    HasEqualizer f g :=\n  HasLimit.mk ‚ü®_, (HasSplitEqualizer.isSplitEqualizer f g).isEqualizer‚ü©\n\n"}
