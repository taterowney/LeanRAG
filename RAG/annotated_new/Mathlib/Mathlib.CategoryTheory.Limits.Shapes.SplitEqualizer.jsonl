{"name":"CategoryTheory.IsSplitEqualizer.ι_leftRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp ι self.leftRetraction) (CategoryTheory.CategoryStruct.id W)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nleftRetraction✝ : Quiver.Hom X W\nrightRetraction✝ : Quiver.Hom Y X\ncondition✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)) _auto✝\nι_leftRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι leftRetraction✝) (CategoryTheory.CategoryStruct.id W)) _auto✝\nbottom_rightRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction✝) (CategoryTheory.CategoryStruct.id X)) _auto✝\ntop_rightRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction✝) (CategoryTheory.CategoryStruct.comp leftRetraction✝ ι)) _auto✝\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)) _auto✝\nι_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto✝\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto✝\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction ι)) _auto✝\nx✝ : Eq { leftRetraction := leftRetraction✝, rightRetraction := rightRetraction✝, condition := condition✝, ι_leftRetraction := ι_leftRetraction✝, bottom_rightRetraction := bottom_rightRetraction✝, top_rightRetraction := top_rightRetraction✝ } { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, ι_leftRetraction := ι_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }\n⊢ And (Eq leftRetraction✝ leftRetraction) (Eq rightRetraction✝ rightRetraction)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\ninst✝ : SizeOf C\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)) _auto✝\nι_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto✝\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto✝\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction ι)) _auto✝\n⊢ Eq (SizeOf.sizeOf { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, ι_leftRetraction := ι_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf leftRetraction)) (SizeOf.sizeOf rightRetraction)) (SizeOf.sizeOf condition)) (SizeOf.sizeOf ι_leftRetraction)) (SizeOf.sizeOf bottom_rightRetraction)) (SizeOf.sizeOf top_rightRetraction))","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nleftRetraction✝ : Quiver.Hom X W\nrightRetraction✝ : Quiver.Hom Y X\ncondition✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)) _auto✝\nι_leftRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι leftRetraction✝) (CategoryTheory.CategoryStruct.id W)) _auto✝\nbottom_rightRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction✝) (CategoryTheory.CategoryStruct.id X)) _auto✝\ntop_rightRetraction✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction✝) (CategoryTheory.CategoryStruct.comp leftRetraction✝ ι)) _auto✝\nleftRetraction : Quiver.Hom X W\nrightRetraction : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)) _auto✝\nι_leftRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp ι leftRetraction) (CategoryTheory.CategoryStruct.id W)) _auto✝\nbottom_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp g rightRetraction) (CategoryTheory.CategoryStruct.id X)) _auto✝\ntop_rightRetraction : autoParam (Eq (CategoryTheory.CategoryStruct.comp f rightRetraction) (CategoryTheory.CategoryStruct.comp leftRetraction ι)) _auto✝\n⊢ Eq (Eq { leftRetraction := leftRetraction✝, rightRetraction := rightRetraction✝, condition := condition✝, ι_leftRetraction := ι_leftRetraction✝, bottom_rightRetraction := bottom_rightRetraction✝, top_rightRetraction := top_rightRetraction✝ } { leftRetraction := leftRetraction, rightRetraction := rightRetraction, condition := condition, ι_leftRetraction := ι_leftRetraction, bottom_rightRetraction := bottom_rightRetraction, top_rightRetraction := top_rightRetraction }) (And (Eq leftRetraction✝ leftRetraction) (Eq rightRetraction✝ rightRetraction))","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp ι f) (CategoryTheory.CategoryStruct.comp ι g)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.bottom_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp g self.rightRetraction) (CategoryTheory.CategoryStruct.id X)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.top_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp f self.rightRetraction) (CategoryTheory.CategoryStruct.comp self.leftRetraction ι)","decl":"/-- A split equalizer diagram consists of morphisms\n\n```\n      ι   f\n    W → X ⇉ Y\n          g\n```\n\nsatisfying `ι ≫ f = ι ≫ g` together with morphisms\n\n```\n      r   t\n    W ← X ← Y\n```\n\nsatisfying `ι ≫ r = 𝟙 W`, `g ≫ t = 𝟙 X` and `f ≫ t = r ≫ ι`.\n\nThe name \"equalizer\" is appropriate, since any split equalizer is a equalizer, see\n`CategoryTheory.IsSplitEqualizer.isEqualizer`.\nSplit equalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitEqualizer {W : C} (ι : W ⟶ X) where\n  /-- A map from `X` to the equalizer -/\n  leftRetraction : X ⟶ W\n  /-- A map in the opposite direction to `f` and `g` -/\n  rightRetraction : Y ⟶ X\n  /-- Composition of `ι` with `f` and with `g` agree -/\n  condition : ι ≫ f = ι ≫ g := by aesop_cat\n  /-- `leftRetraction` splits `ι` -/\n  ι_leftRetraction : ι ≫ leftRetraction = 𝟙 W := by aesop_cat\n  /-- `rightRetraction` splits `g` -/\n  bottom_rightRetraction : g ≫ rightRetraction = 𝟙 X := by aesop_cat\n  /-- `f` composed with `rightRetraction` is `leftRetraction` composed with `ι` -/\n  top_rightRetraction : f ≫ rightRetraction = leftRetraction ≫ ι := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ι (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp ι (CategoryTheory.CategoryStruct.comp g h))","decl":"attribute [reassoc] condition\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.bottom_rightRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp self.rightRetraction h)) h","decl":"attribute [reassoc (attr := simp)] ι_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.ι_leftRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ι (CategoryTheory.CategoryStruct.comp self.leftRetraction h)) h","decl":"attribute [reassoc (attr := simp)] ι_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.top_rightRetraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nself : CategoryTheory.IsSplitEqualizer f g ι\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp self.rightRetraction h)) (CategoryTheory.CategoryStruct.comp self.leftRetraction (CategoryTheory.CategoryStruct.comp ι h))","decl":"attribute [reassoc (attr := simp)] ι_leftRetraction bottom_rightRetraction top_rightRetraction\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.map_rightRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nq : CategoryTheory.IsSplitEqualizer f g ι\nF : CategoryTheory.Functor C D\n⊢ Eq (q.map F).rightRetraction (F.map q.rightRetraction)","decl":"/-- Split equalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitEqualizer.map {W : C} {ι : W ⟶ X} (q : IsSplitEqualizer f g ι) (F : C ⥤ D) :\n    IsSplitEqualizer (F.map f) (F.map g) (F.map ι) where\n  leftRetraction := F.map q.leftRetraction\n  rightRetraction := F.map q.rightRetraction\n  condition := by rw [← F.map_comp, q.condition, F.map_comp]\n  ι_leftRetraction := by rw [← F.map_comp, q.ι_leftRetraction, F.map_id]\n  bottom_rightRetraction := by rw [← F.map_comp, q.bottom_rightRetraction, F.map_id]\n  top_rightRetraction := by rw [← F.map_comp, q.top_rightRetraction, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.map_leftRetraction","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nι : Quiver.Hom W X\nq : CategoryTheory.IsSplitEqualizer f g ι\nF : CategoryTheory.Functor C D\n⊢ Eq (q.map F).leftRetraction (F.map q.leftRetraction)","decl":"/-- Split equalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitEqualizer.map {W : C} {ι : W ⟶ X} (q : IsSplitEqualizer f g ι) (F : C ⥤ D) :\n    IsSplitEqualizer (F.map f) (F.map g) (F.map ι) where\n  leftRetraction := F.map q.leftRetraction\n  rightRetraction := F.map q.rightRetraction\n  condition := by rw [← F.map_comp, q.condition, F.map_comp]\n  ι_leftRetraction := by rw [← F.map_comp, q.ι_leftRetraction, F.map_id]\n  bottom_rightRetraction := by rw [← F.map_comp, q.bottom_rightRetraction, F.map_id]\n  top_rightRetraction := by rw [← F.map_comp, q.top_rightRetraction, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.asFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nh : Quiver.Hom W X\nt : CategoryTheory.IsSplitEqualizer f g h\n⊢ Eq t.asFork.pt W","decl":"/-- A split equalizer clearly induces a fork. -/\n@[simps! pt]\ndef IsSplitEqualizer.asFork {W : C} {h : W ⟶ X} (t : IsSplitEqualizer f g h) :\n    Fork f g := Fork.ofι h t.condition\n\n"}
{"name":"CategoryTheory.IsSplitEqualizer.asFork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nW : C\nh : Quiver.Hom W X\nt : CategoryTheory.IsSplitEqualizer f g h\n⊢ Eq t.asFork.ι h","decl":"@[simp]\ntheorem IsSplitEqualizer.asFork_ι {W : C} {h : W ⟶ X} (t : IsSplitEqualizer f g h) :\n    t.asFork.ι = h := rfl\n\n"}
{"name":"CategoryTheory.HasSplitEqualizer.splittable","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nself : CategoryTheory.HasSplitEqualizer f g\n⊢ Exists fun W => Exists fun h => Nonempty (CategoryTheory.IsSplitEqualizer f g h)","decl":"/--\nThe pair `f,g` is a cosplit pair if there is an `h : W ⟶ X` so that `f, g, h` forms a split\nequalizer in `C`.\n-/\nclass HasSplitEqualizer : Prop where\n  /-- There is some split equalizer -/\n  splittable : ∃ (W : C) (h : W ⟶ X), Nonempty (IsSplitEqualizer f g h)\n\n"}
{"name":"CategoryTheory.map_is_cosplit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitEqualizer f g\n⊢ CategoryTheory.HasSplitEqualizer (G.map f) (G.map g)","decl":"/-- If `f, g` is cosplit, then `G f, G g` is cosplit. -/\ninstance map_is_cosplit_pair [HasSplitEqualizer f g] : HasSplitEqualizer (G.map f) (G.map g) where\n  splittable :=\n    ⟨_, _, ⟨IsSplitEqualizer.map (HasSplitEqualizer.isSplitEqualizer f g) _⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_of_hasSplitEqualizer","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitEqualizer f g\n⊢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- If a pair has a split equalizer, it has a equalizer. -/\ninstance (priority := 1) hasEqualizer_of_hasSplitEqualizer [HasSplitEqualizer f g] :\n    HasEqualizer f g :=\n  HasLimit.mk ⟨_, (HasSplitEqualizer.isSplitEqualizer f g).isEqualizer⟩\n\n"}
