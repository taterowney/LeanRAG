{"name":"CategoryTheory.ShortComplex.add_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HAdd.hAdd φ φ').τ₁ (HAdd.hAdd φ.τ₁ φ'.τ₁)","decl":"@[simp] lemma add_τ₁ (φ φ' : S₁ ⟶ S₂) : (φ + φ').τ₁ = φ.τ₁ + φ'.τ₁ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.add_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HAdd.hAdd φ φ').τ₂ (HAdd.hAdd φ.τ₂ φ'.τ₂)","decl":"@[simp] lemma add_τ₂ (φ φ' : S₁ ⟶ S₂) : (φ + φ').τ₂ = φ.τ₂ + φ'.τ₂ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.add_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HAdd.hAdd φ φ').τ₃ (HAdd.hAdd φ.τ₃ φ'.τ₃)","decl":"@[simp] lemma add_τ₃ (φ φ' : S₁ ⟶ S₂) : (φ + φ').τ₃ = φ.τ₃ + φ'.τ₃ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.sub_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HSub.hSub φ φ').τ₁ (HSub.hSub φ.τ₁ φ'.τ₁)","decl":"@[simp] lemma sub_τ₁ (φ φ' : S₁ ⟶ S₂) : (φ - φ').τ₁ = φ.τ₁ - φ'.τ₁ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.sub_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HSub.hSub φ φ').τ₂ (HSub.hSub φ.τ₂ φ'.τ₂)","decl":"@[simp] lemma sub_τ₂ (φ φ' : S₁ ⟶ S₂) : (φ - φ').τ₂ = φ.τ₂ - φ'.τ₂ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.sub_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\n⊢ Eq (HSub.hSub φ φ').τ₃ (HSub.hSub φ.τ₃ φ'.τ₃)","decl":"@[simp] lemma sub_τ₃ (φ φ' : S₁ ⟶ S₂) : (φ - φ').τ₃ = φ.τ₃ - φ'.τ₃ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.neg_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (Neg.neg φ).τ₁ (Neg.neg φ.τ₁)","decl":"@[simp] lemma neg_τ₁ (φ : S₁ ⟶ S₂) : (-φ).τ₁ = -φ.τ₁ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.neg_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (Neg.neg φ).τ₂ (Neg.neg φ.τ₂)","decl":"@[simp] lemma neg_τ₂ (φ : S₁ ⟶ S₂) : (-φ).τ₂ = -φ.τ₂ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.neg_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (Neg.neg φ).τ₃ (Neg.neg φ.τ₃)","decl":"@[simp] lemma neg_τ₃ (φ : S₁ ⟶ S₂) : (-φ).τ₃ = -φ.τ₃ := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.neg_φK","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.φK (Neg.neg γ.φK)","decl":"/-- Given a left homology map data for morphism `φ`, this is the induced left homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : LeftHomologyMapData (-φ) h₁ h₂ where\n  φK := -γ.φK\n  φH := -γ.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.neg_φH","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.φH (Neg.neg γ.φH)","decl":"/-- Given a left homology map data for morphism `φ`, this is the induced left homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : LeftHomologyMapData (-φ) h₁ h₂ where\n  φK := -γ.φK\n  φH := -γ.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.add_φH","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.LeftHomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').φH (HAdd.hAdd γ.φH γ'.φH)","decl":"/-- Given left homology map data for morphisms `φ` and `φ'`, this is\nthe induced left homology map data for `φ + φ'`. -/\n@[simps]\ndef add : LeftHomologyMapData (φ + φ') h₁ h₂ where\n  φK := γ.φK + γ'.φK\n  φH := γ.φH + γ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.add_φK","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.LeftHomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').φK (HAdd.hAdd γ.φK γ'.φK)","decl":"/-- Given left homology map data for morphisms `φ` and `φ'`, this is\nthe induced left homology map data for `φ + φ'`. -/\n@[simps]\ndef add : LeftHomologyMapData (φ + φ') h₁ h₂ where\n  φK := γ.φK + γ'.φK\n  φH := γ.φH + γ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (Neg.neg φ) h₁ h₂) (Neg.neg (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂))","decl":"@[simp]\nlemma leftHomologyMap'_neg :\n    leftHomologyMap' (-φ) h₁ h₂ = -leftHomologyMap' φ h₁ h₂ := by\n  have γ : LeftHomologyMapData φ h₁ h₂ := default\n  simp only [γ.leftHomologyMap'_eq, γ.neg.leftHomologyMap'_eq, LeftHomologyMapData.neg_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' (Neg.neg φ) h₁ h₂) (Neg.neg (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂))","decl":"@[simp]\nlemma cyclesMap'_neg :\n    cyclesMap' (-φ) h₁ h₂ = -cyclesMap' φ h₁ h₂ := by\n  have γ : LeftHomologyMapData φ h₁ h₂ := default\n  simp only [γ.cyclesMap'_eq, γ.neg.cyclesMap'_eq, LeftHomologyMapData.neg_φK]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (HAdd.hAdd φ φ') h₁ h₂) (HAdd.hAdd (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.leftHomologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma leftHomologyMap'_add :\n    leftHomologyMap' (φ + φ') h₁ h₂ = leftHomologyMap' φ h₁ h₂ +\n      leftHomologyMap' φ' h₁ h₂ := by\n  have γ : LeftHomologyMapData φ h₁ h₂ := default\n  have γ' : LeftHomologyMapData φ' h₁ h₂ := default\n  simp only [γ.leftHomologyMap'_eq, γ'.leftHomologyMap'_eq,\n    (γ.add γ').leftHomologyMap'_eq, LeftHomologyMapData.add_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' (HAdd.hAdd φ φ') h₁ h₂) (HAdd.hAdd (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) (CategoryTheory.ShortComplex.cyclesMap' φ' h₁ h₂))","decl":"@[simp]\nlemma cyclesMap'_add :\n    cyclesMap' (φ + φ') h₁ h₂ = cyclesMap' φ h₁ h₂ +\n      cyclesMap' φ' h₁ h₂ := by\n  have γ : LeftHomologyMapData φ h₁ h₂ := default\n  have γ' : LeftHomologyMapData φ' h₁ h₂ := default\n  simp only [γ.cyclesMap'_eq, γ'.cyclesMap'_eq,\n    (γ.add γ').cyclesMap'_eq, LeftHomologyMapData.add_φK]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (HSub.hSub φ φ') h₁ h₂) (HSub.hSub (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.leftHomologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma leftHomologyMap'_sub :\n    leftHomologyMap' (φ - φ') h₁ h₂ = leftHomologyMap' φ h₁ h₂ -\n      leftHomologyMap' φ' h₁ h₂ := by\n  simp only [sub_eq_add_neg, leftHomologyMap'_add, leftHomologyMap'_neg]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' (HSub.hSub φ φ') h₁ h₂) (HSub.hSub (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) (CategoryTheory.ShortComplex.cyclesMap' φ' h₁ h₂))","decl":"@[simp]\nlemma cyclesMap'_sub :\n    cyclesMap' (φ - φ') h₁ h₂ = cyclesMap' φ h₁ h₂ -\n      cyclesMap' φ' h₁ h₂ := by\n  simp only [sub_eq_add_neg, cyclesMap'_add, cyclesMap'_neg]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (Neg.neg φ)) (Neg.neg (CategoryTheory.ShortComplex.leftHomologyMap φ))","decl":"@[simp]\nlemma leftHomologyMap_neg : leftHomologyMap (-φ) = -leftHomologyMap φ :=\n  leftHomologyMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap (Neg.neg φ)) (Neg.neg (CategoryTheory.ShortComplex.cyclesMap φ))","decl":"@[simp]\nlemma cyclesMap_neg : cyclesMap (-φ) = -cyclesMap φ :=\n  cyclesMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (HAdd.hAdd φ φ')) (HAdd.hAdd (CategoryTheory.ShortComplex.leftHomologyMap φ) (CategoryTheory.ShortComplex.leftHomologyMap φ'))","decl":"@[simp]\nlemma leftHomologyMap_add : leftHomologyMap (φ + φ') = leftHomologyMap φ + leftHomologyMap φ' :=\n  leftHomologyMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap (HAdd.hAdd φ φ')) (HAdd.hAdd (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.ShortComplex.cyclesMap φ'))","decl":"@[simp]\nlemma cyclesMap_add : cyclesMap (φ + φ') = cyclesMap φ + cyclesMap φ' :=\n  cyclesMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (HSub.hSub φ φ')) (HSub.hSub (CategoryTheory.ShortComplex.leftHomologyMap φ) (CategoryTheory.ShortComplex.leftHomologyMap φ'))","decl":"@[simp]\nlemma leftHomologyMap_sub : leftHomologyMap (φ - φ') = leftHomologyMap φ - leftHomologyMap φ' :=\n  leftHomologyMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap (HSub.hSub φ φ')) (HSub.hSub (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.ShortComplex.cyclesMap φ'))","decl":"@[simp]\nlemma cyclesMap_sub : cyclesMap (φ - φ') = cyclesMap φ - cyclesMap φ' :=\n  cyclesMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctor_additive","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ (CategoryTheory.ShortComplex.leftHomologyFunctor C).Additive","decl":"instance leftHomologyFunctor_additive [HasKernels C] [HasCokernels C] :\n  (leftHomologyFunctor C).Additive where\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesFunctor_additive","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ (CategoryTheory.ShortComplex.cyclesFunctor C).Additive","decl":"instance cyclesFunctor_additive [HasKernels C] [HasCokernels C] :\n  (cyclesFunctor C).Additive where\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.neg_φH","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.φH (Neg.neg γ.φH)","decl":"/-- Given a right homology map data for morphism `φ`, this is the induced right homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : RightHomologyMapData (-φ) h₁ h₂ where\n  φQ := -γ.φQ\n  φH := -γ.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.neg_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.φQ (Neg.neg γ.φQ)","decl":"/-- Given a right homology map data for morphism `φ`, this is the induced right homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : RightHomologyMapData (-φ) h₁ h₂ where\n  φQ := -γ.φQ\n  φH := -γ.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.add_φH","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.RightHomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').φH (HAdd.hAdd γ.φH γ'.φH)","decl":"/-- Given right homology map data for morphisms `φ` and `φ'`, this is the induced\nright homology map data for `φ + φ'`. -/\n@[simps]\ndef add : RightHomologyMapData (φ + φ') h₁ h₂ where\n  φQ := γ.φQ + γ'.φQ\n  φH := γ.φH + γ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.add_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.RightHomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').φQ (HAdd.hAdd γ.φQ γ'.φQ)","decl":"/-- Given right homology map data for morphisms `φ` and `φ'`, this is the induced\nright homology map data for `φ + φ'`. -/\n@[simps]\ndef add : RightHomologyMapData (φ + φ') h₁ h₂ where\n  φQ := γ.φQ + γ'.φQ\n  φH := γ.φH + γ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (Neg.neg φ) h₁ h₂) (Neg.neg (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂))","decl":"@[simp]\nlemma rightHomologyMap'_neg :\n    rightHomologyMap' (-φ) h₁ h₂ = -rightHomologyMap' φ h₁ h₂ := by\n  have γ : RightHomologyMapData φ h₁ h₂ := default\n  simp only [γ.rightHomologyMap'_eq, γ.neg.rightHomologyMap'_eq, RightHomologyMapData.neg_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' (Neg.neg φ) h₁ h₂) (Neg.neg (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂))","decl":"@[simp]\nlemma opcyclesMap'_neg :\n    opcyclesMap' (-φ) h₁ h₂ = -opcyclesMap' φ h₁ h₂ := by\n  have γ : RightHomologyMapData φ h₁ h₂ := default\n  simp only [γ.opcyclesMap'_eq, γ.neg.opcyclesMap'_eq, RightHomologyMapData.neg_φQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (HAdd.hAdd φ φ') h₁ h₂) (HAdd.hAdd (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.rightHomologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma rightHomologyMap'_add :\n    rightHomologyMap' (φ + φ') h₁ h₂ = rightHomologyMap' φ h₁ h₂ +\n      rightHomologyMap' φ' h₁ h₂ := by\n  have γ : RightHomologyMapData φ h₁ h₂ := default\n  have γ' : RightHomologyMapData φ' h₁ h₂ := default\n  simp only [γ.rightHomologyMap'_eq, γ'.rightHomologyMap'_eq,\n    (γ.add γ').rightHomologyMap'_eq, RightHomologyMapData.add_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' (HAdd.hAdd φ φ') h₁ h₂) (HAdd.hAdd (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) (CategoryTheory.ShortComplex.opcyclesMap' φ' h₁ h₂))","decl":"@[simp]\nlemma opcyclesMap'_add :\n    opcyclesMap' (φ + φ') h₁ h₂ = opcyclesMap' φ h₁ h₂ +\n      opcyclesMap' φ' h₁ h₂ := by\n  have γ : RightHomologyMapData φ h₁ h₂ := default\n  have γ' : RightHomologyMapData φ' h₁ h₂ := default\n  simp only [γ.opcyclesMap'_eq, γ'.opcyclesMap'_eq,\n    (γ.add γ').opcyclesMap'_eq, RightHomologyMapData.add_φQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (HSub.hSub φ φ') h₁ h₂) (HSub.hSub (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.rightHomologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma rightHomologyMap'_sub :\n    rightHomologyMap' (φ - φ') h₁ h₂ = rightHomologyMap' φ h₁ h₂ -\n      rightHomologyMap' φ' h₁ h₂ := by\n  simp only [sub_eq_add_neg, rightHomologyMap'_add, rightHomologyMap'_neg]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' (HSub.hSub φ φ') h₁ h₂) (HSub.hSub (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) (CategoryTheory.ShortComplex.opcyclesMap' φ' h₁ h₂))","decl":"@[simp]\nlemma opcyclesMap'_sub :\n    opcyclesMap' (φ - φ') h₁ h₂ = opcyclesMap' φ h₁ h₂ -\n      opcyclesMap' φ' h₁ h₂ := by\n  simp only [sub_eq_add_neg, opcyclesMap'_add, opcyclesMap'_neg]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (Neg.neg φ)) (Neg.neg (CategoryTheory.ShortComplex.rightHomologyMap φ))","decl":"@[simp]\nlemma rightHomologyMap_neg : rightHomologyMap (-φ) = -rightHomologyMap φ :=\n  rightHomologyMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap (Neg.neg φ)) (Neg.neg (CategoryTheory.ShortComplex.opcyclesMap φ))","decl":"@[simp]\nlemma opcyclesMap_neg : opcyclesMap (-φ) = -opcyclesMap φ :=\n  opcyclesMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (HAdd.hAdd φ φ')) (HAdd.hAdd (CategoryTheory.ShortComplex.rightHomologyMap φ) (CategoryTheory.ShortComplex.rightHomologyMap φ'))","decl":"@[simp]\nlemma rightHomologyMap_add :\n    rightHomologyMap (φ + φ') = rightHomologyMap φ + rightHomologyMap φ' :=\n  rightHomologyMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap (HAdd.hAdd φ φ')) (HAdd.hAdd (CategoryTheory.ShortComplex.opcyclesMap φ) (CategoryTheory.ShortComplex.opcyclesMap φ'))","decl":"@[simp]\nlemma opcyclesMap_add : opcyclesMap (φ + φ') = opcyclesMap φ + opcyclesMap φ' :=\n  opcyclesMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (HSub.hSub φ φ')) (HSub.hSub (CategoryTheory.ShortComplex.rightHomologyMap φ) (CategoryTheory.ShortComplex.rightHomologyMap φ'))","decl":"@[simp]\nlemma rightHomologyMap_sub :\n    rightHomologyMap (φ - φ') = rightHomologyMap φ - rightHomologyMap φ' :=\n  rightHomologyMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap (HSub.hSub φ φ')) (HSub.hSub (CategoryTheory.ShortComplex.opcyclesMap φ) (CategoryTheory.ShortComplex.opcyclesMap φ'))","decl":"@[simp]\nlemma opcyclesMap_sub : opcyclesMap (φ - φ') = opcyclesMap φ - opcyclesMap φ' :=\n  opcyclesMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyFunctor_additive","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ (CategoryTheory.ShortComplex.rightHomologyFunctor C).Additive","decl":"instance rightHomologyFunctor_additive [HasKernels C] [HasCokernels C] :\n  (rightHomologyFunctor C).Additive where\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesFunctor_additive","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ (CategoryTheory.ShortComplex.opcyclesFunctor C).Additive","decl":"instance opcyclesFunctor_additive [HasKernels C] [HasCokernels C] :\n  (opcyclesFunctor C).Additive where\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.neg_right","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.right γ.right.neg","decl":"/-- Given a homology map data for a morphism `φ`, this is the induced homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : HomologyMapData (-φ) h₁ h₂ where\n  left := γ.left.neg\n  right := γ.right.neg\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.neg_left","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq γ.neg.left γ.left.neg","decl":"/-- Given a homology map data for a morphism `φ`, this is the induced homology\nmap data for `-φ`. -/\n@[simps]\ndef neg : HomologyMapData (-φ) h₁ h₂ where\n  left := γ.left.neg\n  right := γ.right.neg\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.add_right","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.HomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').right (γ.right.add γ'.right)","decl":"/-- Given homology map data for morphisms `φ` and `φ'`, this is the induced homology\nmap data for `φ + φ'`. -/\n@[simps]\ndef add : HomologyMapData (φ + φ') h₁ h₂ where\n  left := γ.left.add γ'.left\n  right := γ.right.add γ'.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.add_left","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nγ' : CategoryTheory.ShortComplex.HomologyMapData φ' h₁ h₂\n⊢ Eq (γ.add γ').left (γ.left.add γ'.left)","decl":"/-- Given homology map data for morphisms `φ` and `φ'`, this is the induced homology\nmap data for `φ + φ'`. -/\n@[simps]\ndef add : HomologyMapData (φ + φ') h₁ h₂ where\n  left := γ.left.add γ'.left\n  right := γ.right.add γ'.right\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (Neg.neg φ) h₁ h₂) (Neg.neg (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂))","decl":"@[simp]\nlemma homologyMap'_neg :\n    homologyMap' (-φ) h₁ h₂ = -homologyMap' φ h₁ h₂ :=\n  leftHomologyMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (HAdd.hAdd φ φ') h₁ h₂) (HAdd.hAdd (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.homologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma homologyMap'_add :\n    homologyMap' (φ + φ') h₁ h₂ = homologyMap' φ h₁ h₂ + homologyMap' φ' h₁ h₂ :=\n  leftHomologyMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (HSub.hSub φ φ') h₁ h₂) (HSub.hSub (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂) (CategoryTheory.ShortComplex.homologyMap' φ' h₁ h₂))","decl":"@[simp]\nlemma homologyMap'_sub :\n    homologyMap' (φ - φ') h₁ h₂ = homologyMap' φ h₁ h₂ - homologyMap' φ' h₁ h₂ :=\n  leftHomologyMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_neg","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (Neg.neg φ)) (Neg.neg (CategoryTheory.ShortComplex.homologyMap φ))","decl":"@[simp]\nlemma homologyMap_neg : homologyMap (-φ) = -homologyMap φ :=\n  homologyMap'_neg _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_add","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (HAdd.hAdd φ φ')) (HAdd.hAdd (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.ShortComplex.homologyMap φ'))","decl":"@[simp]\nlemma homologyMap_add : homologyMap (φ + φ') = homologyMap φ + homologyMap φ' :=\n  homologyMap'_add _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_sub","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ φ' : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (HSub.hSub φ φ')) (HSub.hSub (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.ShortComplex.homologyMap φ'))","decl":"@[simp]\nlemma homologyMap_sub : homologyMap (φ - φ') = homologyMap φ - homologyMap φ' :=\n  homologyMap'_sub _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyFunctor_additive","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\n⊢ (CategoryTheory.ShortComplex.homologyFunctor C).Additive","decl":"instance homologyFunctor_additive [CategoryWithHomology C] :\n  (homologyFunctor C).Additive where\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\ninst✝ : SizeOf C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0) _auto✝\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0) _auto✝\ncomm₁ : autoParam (Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f h₁) h₀) φ₂.τ₁)) _auto✝\ncomm₂ : autoParam (Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g h₂) (CategoryTheory.CategoryStruct.comp h₁ S₂.f)) φ₂.τ₂)) _auto✝\ncomm₃ : autoParam (Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd h₃ (CategoryTheory.CategoryStruct.comp h₂ S₂.g)) φ₂.τ₃)) _auto✝\n⊢ Eq (SizeOf.sizeOf { h₀ := h₀, h₀_f := h₀_f, h₁ := h₁, h₂ := h₂, h₃ := h₃, g_h₃ := g_h₃, comm₁ := comm₁, comm₂ := comm₂, comm₃ := comm₃ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf h₀)) (SizeOf.sizeOf h₀_f)) (SizeOf.sizeOf h₁)) (SizeOf.sizeOf h₂)) (SizeOf.sizeOf h₃)) (SizeOf.sizeOf g_h₃)) (SizeOf.sizeOf comm₁)) (SizeOf.sizeOf comm₂)) (SizeOf.sizeOf comm₃))","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nx y : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Iff (Eq x y) (And (Eq x.h₀ y.h₀) (And (Eq x.h₁ y.h₁) (And (Eq x.h₂ y.h₂) (Eq x.h₃ y.h₃))))","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comm₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd self.h₃ (CategoryTheory.CategoryStruct.comp self.h₂ S₂.g)) φ₂.τ₃)","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.h₀_f","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.h₀ S₂.f) 0","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comm₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f self.h₁) self.h₀) φ₂.τ₁)","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh₀✝ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₀✝ S₂.f) 0) _auto✝\nh₁✝ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂✝ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃✝ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃✝) 0) _auto✝\ncomm₁✝ : autoParam (Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f h₁✝) h₀✝) φ₂.τ₁)) _auto✝\ncomm₂✝ : autoParam (Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g h₂✝) (CategoryTheory.CategoryStruct.comp h₁✝ S₂.f)) φ₂.τ₂)) _auto✝\ncomm₃✝ : autoParam (Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd h₃✝ (CategoryTheory.CategoryStruct.comp h₂✝ S₂.g)) φ₂.τ₃)) _auto✝\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0) _auto✝\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0) _auto✝\ncomm₁ : autoParam (Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f h₁) h₀) φ₂.τ₁)) _auto✝\ncomm₂ : autoParam (Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g h₂) (CategoryTheory.CategoryStruct.comp h₁ S₂.f)) φ₂.τ₂)) _auto✝\ncomm₃ : autoParam (Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd h₃ (CategoryTheory.CategoryStruct.comp h₂ S₂.g)) φ₂.τ₃)) _auto✝\n⊢ Eq (Eq { h₀ := h₀✝, h₀_f := h₀_f✝, h₁ := h₁✝, h₂ := h₂✝, h₃ := h₃✝, g_h₃ := g_h₃✝, comm₁ := comm₁✝, comm₂ := comm₂✝, comm₃ := comm₃✝ } { h₀ := h₀, h₀_f := h₀_f, h₁ := h₁, h₂ := h₂, h₃ := h₃, g_h₃ := g_h₃, comm₁ := comm₁, comm₂ := comm₂, comm₃ := comm₃ }) (And (Eq h₀✝ h₀) (And (Eq h₁✝ h₁) (And (Eq h₂✝ h₂) (Eq h₃✝ h₃))))","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh₀✝ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₀✝ S₂.f) 0) _auto✝\nh₁✝ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂✝ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃✝ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃✝) 0) _auto✝\ncomm₁✝ : autoParam (Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f h₁✝) h₀✝) φ₂.τ₁)) _auto✝\ncomm₂✝ : autoParam (Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g h₂✝) (CategoryTheory.CategoryStruct.comp h₁✝ S₂.f)) φ₂.τ₂)) _auto✝\ncomm₃✝ : autoParam (Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd h₃✝ (CategoryTheory.CategoryStruct.comp h₂✝ S₂.g)) φ₂.τ₃)) _auto✝\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0) _auto✝\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0) _auto✝\ncomm₁ : autoParam (Eq φ₁.τ₁ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.f h₁) h₀) φ₂.τ₁)) _auto✝\ncomm₂ : autoParam (Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g h₂) (CategoryTheory.CategoryStruct.comp h₁ S₂.f)) φ₂.τ₂)) _auto✝\ncomm₃ : autoParam (Eq φ₁.τ₃ (HAdd.hAdd (HAdd.hAdd h₃ (CategoryTheory.CategoryStruct.comp h₂ S₂.g)) φ₂.τ₃)) _auto✝\nx✝ : Eq { h₀ := h₀✝, h₀_f := h₀_f✝, h₁ := h₁✝, h₂ := h₂✝, h₃ := h₃✝, g_h₃ := g_h₃✝, comm₁ := comm₁✝, comm₂ := comm₂✝, comm₃ := comm₃✝ } { h₀ := h₀, h₀_f := h₀_f, h₁ := h₁, h₂ := h₂, h₃ := h₃, g_h₃ := g_h₃, comm₁ := comm₁, comm₂ := comm₂, comm₃ := comm₃ }\n⊢ And (Eq h₀✝ h₀) (And (Eq h₁✝ h₁) (And (Eq h₂✝ h₂) (Eq h₃✝ h₃)))","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.g_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.g self.h₃) 0","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ext","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nx y : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₀ : Eq x.h₀ y.h₀\nh₁ : Eq x.h₁ y.h₁\nh₂ : Eq x.h₂ y.h₂\nh₃ : Eq x.h₃ y.h₃\n⊢ Eq x y","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comm₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq φ₁.τ₂ (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp S₁.g self.h₂) (CategoryTheory.CategoryStruct.comp self.h₁ S₂.f)) φ₂.τ₂)","decl":"/-- A homotopy between two morphisms of short complexes `S₁ ⟶ S₂` consists of various\nmaps and conditions which will be sufficient to show that they induce the same morphism\nin homology. -/\n@[ext]\nstructure Homotopy where\n  /-- a morphism `S₁.X₁ ⟶ S₂.X₁` -/\n  h₀ : S₁.X₁ ⟶ S₂.X₁\n  h₀_f : h₀ ≫ S₂.f = 0 := by aesop_cat\n  /-- a morphism `S₁.X₂ ⟶ S₂.X₁` -/\n  h₁ : S₁.X₂ ⟶ S₂.X₁\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₂` -/\n  h₂ : S₁.X₃ ⟶ S₂.X₂\n  /-- a morphism `S₁.X₃ ⟶ S₂.X₃` -/\n  h₃ : S₁.X₃ ⟶ S₂.X₃\n  g_h₃ : S₁.g ≫ h₃ = 0 := by aesop_cat\n  comm₁ : φ₁.τ₁ = S₁.f ≫ h₁ + h₀ + φ₂.τ₁ := by aesop_cat\n  comm₂ : φ₁.τ₂ = S₁.g ≫ h₂ + h₁ ≫ S₂.f + φ₂.τ₂ := by aesop_cat\n  comm₃ : φ₁.τ₃ = h₃ + h₂ ≫ S₂.g + φ₂.τ₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.h₀_f_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nZ : C\nh : Quiver.Hom S₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.h₀ (CategoryTheory.CategoryStruct.comp S₂.f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] Homotopy.h₀_f Homotopy.g_h₃\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.g_h₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nself : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nZ : C\nh : Quiver.Hom S₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.g (CategoryTheory.CategoryStruct.comp self.h₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] Homotopy.h₀_f Homotopy.g_h₃\n\n"}
{"name":"CategoryTheory.ShortComplex.nullHomotopic_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).τ₃ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h₂ S₂.g) h₃)","decl":"/-- Constructor for null homotopic morphisms, see also `Homotopy.ofNullHomotopic`\nand `Homotopy.eq_add_nullHomotopic`. -/\n@[simps]\ndef nullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    S₁ ⟶ S₂ where\n  τ₁ := h₀ + S₁.f ≫ h₁\n  τ₂ := h₁ ≫ S₂.f + S₁.g ≫ h₂\n  τ₃ := h₂ ≫ S₂.g + h₃\n\n"}
{"name":"CategoryTheory.ShortComplex.nullHomotopic_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).τ₁ (HAdd.hAdd h₀ (CategoryTheory.CategoryStruct.comp S₁.f h₁))","decl":"/-- Constructor for null homotopic morphisms, see also `Homotopy.ofNullHomotopic`\nand `Homotopy.eq_add_nullHomotopic`. -/\n@[simps]\ndef nullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    S₁ ⟶ S₂ where\n  τ₁ := h₀ + S₁.f ≫ h₁\n  τ₂ := h₁ ≫ S₂.f + S₁.g ≫ h₂\n  τ₃ := h₂ ≫ S₂.g + h₃\n\n"}
{"name":"CategoryTheory.ShortComplex.nullHomotopic_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).τ₂ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h₁ S₂.f) (CategoryTheory.CategoryStruct.comp S₁.g h₂))","decl":"/-- Constructor for null homotopic morphisms, see also `Homotopy.ofNullHomotopic`\nand `Homotopy.eq_add_nullHomotopic`. -/\n@[simps]\ndef nullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    S₁ ⟶ S₂ where\n  τ₁ := h₀ + S₁.f ≫ h₁\n  τ₂ := h₁ ≫ S₂.f + S₁.g ≫ h₂\n  τ₃ := h₂ ≫ S₂.g + h₃\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofEq_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : Eq φ₁ φ₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofEq h).h₃ 0","decl":"/-- The obvious homotopy between two equal morphisms of short complexes. -/\n@[simps]\ndef ofEq (h : φ₁ = φ₂) : Homotopy φ₁ φ₂ where\n  h₀ := 0\n  h₁ := 0\n  h₂ := 0\n  h₃ := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofEq_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : Eq φ₁ φ₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofEq h).h₁ 0","decl":"/-- The obvious homotopy between two equal morphisms of short complexes. -/\n@[simps]\ndef ofEq (h : φ₁ = φ₂) : Homotopy φ₁ φ₂ where\n  h₀ := 0\n  h₁ := 0\n  h₂ := 0\n  h₃ := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofEq_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : Eq φ₁ φ₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofEq h).h₂ 0","decl":"/-- The obvious homotopy between two equal morphisms of short complexes. -/\n@[simps]\ndef ofEq (h : φ₁ = φ₂) : Homotopy φ₁ φ₂ where\n  h₀ := 0\n  h₁ := 0\n  h₂ := 0\n  h₃ := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofEq_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : Eq φ₁ φ₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofEq h).h₀ 0","decl":"/-- The obvious homotopy between two equal morphisms of short complexes. -/\n@[simps]\ndef ofEq (h : φ₁ = φ₂) : Homotopy φ₁ φ₂ where\n  h₀ := 0\n  h₁ := 0\n  h₂ := 0\n  h₃ := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.refl_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.refl φ).h₃ 0","decl":"/-- The obvious homotopy between a morphism of short complexes and itself. -/\n@[simps!]\ndef refl (φ : S₁ ⟶ S₂) : Homotopy φ φ := ofEq rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.refl_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.refl φ).h₀ 0","decl":"/-- The obvious homotopy between a morphism of short complexes and itself. -/\n@[simps!]\ndef refl (φ : S₁ ⟶ S₂) : Homotopy φ φ := ofEq rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.refl_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.refl φ).h₁ 0","decl":"/-- The obvious homotopy between a morphism of short complexes and itself. -/\n@[simps!]\ndef refl (φ : S₁ ⟶ S₂) : Homotopy φ φ := ofEq rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.refl_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.refl φ).h₂ 0","decl":"/-- The obvious homotopy between a morphism of short complexes and itself. -/\n@[simps!]\ndef refl (φ : S₁ ⟶ S₂) : Homotopy φ φ := ofEq rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.symm_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.symm.h₂ (Neg.neg h.h₂)","decl":"/-- The symmetry of homotopy between morphisms of short complexes. -/\n@[simps]\ndef symm (h : Homotopy φ₁ φ₂) : Homotopy φ₂ φ₁ where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [h.comm₁, comp_neg]; abel\n  comm₂ := by rw [h.comm₂, comp_neg, neg_comp]; abel\n  comm₃ := by rw [h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.symm_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.symm.h₁ (Neg.neg h.h₁)","decl":"/-- The symmetry of homotopy between morphisms of short complexes. -/\n@[simps]\ndef symm (h : Homotopy φ₁ φ₂) : Homotopy φ₂ φ₁ where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [h.comm₁, comp_neg]; abel\n  comm₂ := by rw [h.comm₂, comp_neg, neg_comp]; abel\n  comm₃ := by rw [h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.symm_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.symm.h₀ (Neg.neg h.h₀)","decl":"/-- The symmetry of homotopy between morphisms of short complexes. -/\n@[simps]\ndef symm (h : Homotopy φ₁ φ₂) : Homotopy φ₂ φ₁ where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [h.comm₁, comp_neg]; abel\n  comm₂ := by rw [h.comm₂, comp_neg, neg_comp]; abel\n  comm₃ := by rw [h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.symm_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.symm.h₃ (Neg.neg h.h₃)","decl":"/-- The symmetry of homotopy between morphisms of short complexes. -/\n@[simps]\ndef symm (h : Homotopy φ₁ φ₂) : Homotopy φ₂ φ₁ where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [h.comm₁, comp_neg]; abel\n  comm₂ := by rw [h.comm₂, comp_neg, neg_comp]; abel\n  comm₃ := by rw [h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.neg_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.neg.h₀ (Neg.neg h.h₀)","decl":"/-- If two maps of short complexes are homotopic, their opposites also are. -/\n@[simps]\ndef neg (h : Homotopy φ₁ φ₂) : Homotopy (-φ₁) (-φ₂) where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [neg_τ₁, neg_τ₁, h.comm₁, neg_add_rev, comp_neg]; abel\n  comm₂ := by rw [neg_τ₂, neg_τ₂, h.comm₂, neg_add_rev, comp_neg, neg_comp]; abel\n  comm₃ := by rw [neg_τ₃, neg_τ₃, h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.neg_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.neg.h₂ (Neg.neg h.h₂)","decl":"/-- If two maps of short complexes are homotopic, their opposites also are. -/\n@[simps]\ndef neg (h : Homotopy φ₁ φ₂) : Homotopy (-φ₁) (-φ₂) where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [neg_τ₁, neg_τ₁, h.comm₁, neg_add_rev, comp_neg]; abel\n  comm₂ := by rw [neg_τ₂, neg_τ₂, h.comm₂, neg_add_rev, comp_neg, neg_comp]; abel\n  comm₃ := by rw [neg_τ₃, neg_τ₃, h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.neg_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.neg.h₁ (Neg.neg h.h₁)","decl":"/-- If two maps of short complexes are homotopic, their opposites also are. -/\n@[simps]\ndef neg (h : Homotopy φ₁ φ₂) : Homotopy (-φ₁) (-φ₂) where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [neg_τ₁, neg_τ₁, h.comm₁, neg_add_rev, comp_neg]; abel\n  comm₂ := by rw [neg_τ₂, neg_τ₂, h.comm₂, neg_add_rev, comp_neg, neg_comp]; abel\n  comm₃ := by rw [neg_τ₃, neg_τ₃, h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.neg_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.neg.h₃ (Neg.neg h.h₃)","decl":"/-- If two maps of short complexes are homotopic, their opposites also are. -/\n@[simps]\ndef neg (h : Homotopy φ₁ φ₂) : Homotopy (-φ₁) (-φ₂) where\n  h₀ := -h.h₀\n  h₁ := -h.h₁\n  h₂ := -h.h₂\n  h₃ := -h.h₃\n  comm₁ := by rw [neg_τ₁, neg_τ₁, h.comm₁, neg_add_rev, comp_neg]; abel\n  comm₂ := by rw [neg_τ₂, neg_τ₂, h.comm₂, neg_add_rev, comp_neg, neg_comp]; abel\n  comm₃ := by rw [neg_τ₃, neg_τ₃, h.comm₃, neg_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.trans_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ : Quiver.Hom S₁ S₂\nh₁₂ : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₂₃ : CategoryTheory.ShortComplex.Homotopy φ₂ φ₃\n⊢ Eq (h₁₂.trans h₂₃).h₁ (HAdd.hAdd h₁₂.h₁ h₂₃.h₁)","decl":"/-- The transitivity of homotopy between morphisms of short complexes. -/\n@[simps]\ndef trans (h₁₂ : Homotopy φ₁ φ₂) (h₂₃ : Homotopy φ₂ φ₃) : Homotopy φ₁ φ₃ where\n  h₀ := h₁₂.h₀ + h₂₃.h₀\n  h₁ := h₁₂.h₁ + h₂₃.h₁\n  h₂ := h₁₂.h₂ + h₂₃.h₂\n  h₃ := h₁₂.h₃ + h₂₃.h₃\n  comm₁ := by rw [h₁₂.comm₁, h₂₃.comm₁, comp_add]; abel\n  comm₂ := by rw [h₁₂.comm₂, h₂₃.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [h₁₂.comm₃, h₂₃.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.trans_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ : Quiver.Hom S₁ S₂\nh₁₂ : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₂₃ : CategoryTheory.ShortComplex.Homotopy φ₂ φ₃\n⊢ Eq (h₁₂.trans h₂₃).h₀ (HAdd.hAdd h₁₂.h₀ h₂₃.h₀)","decl":"/-- The transitivity of homotopy between morphisms of short complexes. -/\n@[simps]\ndef trans (h₁₂ : Homotopy φ₁ φ₂) (h₂₃ : Homotopy φ₂ φ₃) : Homotopy φ₁ φ₃ where\n  h₀ := h₁₂.h₀ + h₂₃.h₀\n  h₁ := h₁₂.h₁ + h₂₃.h₁\n  h₂ := h₁₂.h₂ + h₂₃.h₂\n  h₃ := h₁₂.h₃ + h₂₃.h₃\n  comm₁ := by rw [h₁₂.comm₁, h₂₃.comm₁, comp_add]; abel\n  comm₂ := by rw [h₁₂.comm₂, h₂₃.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [h₁₂.comm₃, h₂₃.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.trans_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ : Quiver.Hom S₁ S₂\nh₁₂ : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₂₃ : CategoryTheory.ShortComplex.Homotopy φ₂ φ₃\n⊢ Eq (h₁₂.trans h₂₃).h₃ (HAdd.hAdd h₁₂.h₃ h₂₃.h₃)","decl":"/-- The transitivity of homotopy between morphisms of short complexes. -/\n@[simps]\ndef trans (h₁₂ : Homotopy φ₁ φ₂) (h₂₃ : Homotopy φ₂ φ₃) : Homotopy φ₁ φ₃ where\n  h₀ := h₁₂.h₀ + h₂₃.h₀\n  h₁ := h₁₂.h₁ + h₂₃.h₁\n  h₂ := h₁₂.h₂ + h₂₃.h₂\n  h₃ := h₁₂.h₃ + h₂₃.h₃\n  comm₁ := by rw [h₁₂.comm₁, h₂₃.comm₁, comp_add]; abel\n  comm₂ := by rw [h₁₂.comm₂, h₂₃.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [h₁₂.comm₃, h₂₃.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.trans_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ : Quiver.Hom S₁ S₂\nh₁₂ : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₂₃ : CategoryTheory.ShortComplex.Homotopy φ₂ φ₃\n⊢ Eq (h₁₂.trans h₂₃).h₂ (HAdd.hAdd h₁₂.h₂ h₂₃.h₂)","decl":"/-- The transitivity of homotopy between morphisms of short complexes. -/\n@[simps]\ndef trans (h₁₂ : Homotopy φ₁ φ₂) (h₂₃ : Homotopy φ₂ φ₃) : Homotopy φ₁ φ₃ where\n  h₀ := h₁₂.h₀ + h₂₃.h₀\n  h₁ := h₁₂.h₁ + h₂₃.h₁\n  h₂ := h₁₂.h₂ + h₂₃.h₂\n  h₃ := h₁₂.h₃ + h₂₃.h₃\n  comm₁ := by rw [h₁₂.comm₁, h₂₃.comm₁, comp_add]; abel\n  comm₂ := by rw [h₁₂.comm₂, h₂₃.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [h₁₂.comm₃, h₂₃.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.add_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.add h').h₀ (HAdd.hAdd h.h₀ h'.h₀)","decl":"/-- Homotopy between morphisms of short complexes is compatible with addition. -/\n@[simps]\ndef add (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ + φ₃) (φ₂ + φ₄) where\n  h₀ := h.h₀ + h'.h₀\n  h₁ := h.h₁ + h'.h₁\n  h₂ := h.h₂ + h'.h₂\n  h₃ := h.h₃ + h'.h₃\n  comm₁ := by rw [add_τ₁, add_τ₁, h.comm₁, h'.comm₁, comp_add]; abel\n  comm₂ := by rw [add_τ₂, add_τ₂, h.comm₂, h'.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [add_τ₃, add_τ₃, h.comm₃, h'.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.add_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.add h').h₁ (HAdd.hAdd h.h₁ h'.h₁)","decl":"/-- Homotopy between morphisms of short complexes is compatible with addition. -/\n@[simps]\ndef add (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ + φ₃) (φ₂ + φ₄) where\n  h₀ := h.h₀ + h'.h₀\n  h₁ := h.h₁ + h'.h₁\n  h₂ := h.h₂ + h'.h₂\n  h₃ := h.h₃ + h'.h₃\n  comm₁ := by rw [add_τ₁, add_τ₁, h.comm₁, h'.comm₁, comp_add]; abel\n  comm₂ := by rw [add_τ₂, add_τ₂, h.comm₂, h'.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [add_τ₃, add_τ₃, h.comm₃, h'.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.add_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.add h').h₂ (HAdd.hAdd h.h₂ h'.h₂)","decl":"/-- Homotopy between morphisms of short complexes is compatible with addition. -/\n@[simps]\ndef add (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ + φ₃) (φ₂ + φ₄) where\n  h₀ := h.h₀ + h'.h₀\n  h₁ := h.h₁ + h'.h₁\n  h₂ := h.h₂ + h'.h₂\n  h₃ := h.h₃ + h'.h₃\n  comm₁ := by rw [add_τ₁, add_τ₁, h.comm₁, h'.comm₁, comp_add]; abel\n  comm₂ := by rw [add_τ₂, add_τ₂, h.comm₂, h'.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [add_τ₃, add_τ₃, h.comm₃, h'.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.add_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.add h').h₃ (HAdd.hAdd h.h₃ h'.h₃)","decl":"/-- Homotopy between morphisms of short complexes is compatible with addition. -/\n@[simps]\ndef add (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ + φ₃) (φ₂ + φ₄) where\n  h₀ := h.h₀ + h'.h₀\n  h₁ := h.h₁ + h'.h₁\n  h₂ := h.h₂ + h'.h₂\n  h₃ := h.h₃ + h'.h₃\n  comm₁ := by rw [add_τ₁, add_τ₁, h.comm₁, h'.comm₁, comp_add]; abel\n  comm₂ := by rw [add_τ₂, add_τ₂, h.comm₂, h'.comm₂, comp_add, add_comp]; abel\n  comm₃ := by rw [add_τ₃, add_τ₃, h.comm₃, h'.comm₃, add_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.sub_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.sub h').h₀ (HSub.hSub h.h₀ h'.h₀)","decl":"/-- Homotopy between morphisms of short complexes is compatible with subtraction. -/\n@[simps]\ndef sub (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ - φ₃) (φ₂ - φ₄) where\n  h₀ := h.h₀ - h'.h₀\n  h₁ := h.h₁ - h'.h₁\n  h₂ := h.h₂ - h'.h₂\n  h₃ := h.h₃ - h'.h₃\n  comm₁ := by rw [sub_τ₁, sub_τ₁, h.comm₁, h'.comm₁, comp_sub]; abel\n  comm₂ := by rw [sub_τ₂, sub_τ₂, h.comm₂, h'.comm₂, comp_sub, sub_comp]; abel\n  comm₃ := by rw [sub_τ₃, sub_τ₃, h.comm₃, h'.comm₃, sub_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.sub_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.sub h').h₂ (HSub.hSub h.h₂ h'.h₂)","decl":"/-- Homotopy between morphisms of short complexes is compatible with subtraction. -/\n@[simps]\ndef sub (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ - φ₃) (φ₂ - φ₄) where\n  h₀ := h.h₀ - h'.h₀\n  h₁ := h.h₁ - h'.h₁\n  h₂ := h.h₂ - h'.h₂\n  h₃ := h.h₃ - h'.h₃\n  comm₁ := by rw [sub_τ₁, sub_τ₁, h.comm₁, h'.comm₁, comp_sub]; abel\n  comm₂ := by rw [sub_τ₂, sub_τ₂, h.comm₂, h'.comm₂, comp_sub, sub_comp]; abel\n  comm₃ := by rw [sub_τ₃, sub_τ₃, h.comm₃, h'.comm₃, sub_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.sub_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.sub h').h₁ (HSub.hSub h.h₁ h'.h₁)","decl":"/-- Homotopy between morphisms of short complexes is compatible with subtraction. -/\n@[simps]\ndef sub (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ - φ₃) (φ₂ - φ₄) where\n  h₀ := h.h₀ - h'.h₀\n  h₁ := h.h₁ - h'.h₁\n  h₂ := h.h₂ - h'.h₂\n  h₃ := h.h₃ - h'.h₃\n  comm₁ := by rw [sub_τ₁, sub_τ₁, h.comm₁, h'.comm₁, comp_sub]; abel\n  comm₂ := by rw [sub_τ₂, sub_τ₂, h.comm₂, h'.comm₂, comp_sub, sub_comp]; abel\n  comm₃ := by rw [sub_τ₃, sub_τ₃, h.comm₃, h'.comm₃, sub_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.sub_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ φ₃ φ₄ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh' : CategoryTheory.ShortComplex.Homotopy φ₃ φ₄\n⊢ Eq (h.sub h').h₃ (HSub.hSub h.h₃ h'.h₃)","decl":"/-- Homotopy between morphisms of short complexes is compatible with subtraction. -/\n@[simps]\ndef sub (h : Homotopy φ₁ φ₂) (h' : Homotopy φ₃ φ₄) : Homotopy (φ₁ - φ₃) (φ₂ - φ₄) where\n  h₀ := h.h₀ - h'.h₀\n  h₁ := h.h₁ - h'.h₁\n  h₂ := h.h₂ - h'.h₂\n  h₃ := h.h₃ - h'.h₃\n  comm₁ := by rw [sub_τ₁, sub_τ₁, h.comm₁, h'.comm₁, comp_sub]; abel\n  comm₂ := by rw [sub_τ₂, sub_τ₂, h.comm₂, h'.comm₂, comp_sub, sub_comp]; abel\n  comm₃ := by rw [sub_τ₃, sub_τ₃, h.comm₃, h'.comm₃, sub_comp]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compLeft_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₃ S₁\n⊢ Eq (h.compLeft ψ).h₀ (CategoryTheory.CategoryStruct.comp ψ.τ₁ h.h₀)","decl":"/-- Homotopy between morphisms of short complexes is compatible with precomposition. -/\n@[simps]\ndef compLeft (h : Homotopy φ₁ φ₂) (ψ : S₃ ⟶ S₁) : Homotopy (ψ ≫ φ₁) (ψ ≫ φ₂) where\n  h₀ := ψ.τ₁ ≫ h.h₀\n  h₁ := ψ.τ₂ ≫ h.h₁\n  h₂ := ψ.τ₃ ≫ h.h₂\n  h₃ := ψ.τ₃ ≫ h.h₃\n  g_h₃ := by rw [← ψ.comm₂₃_assoc, h.g_h₃, comp_zero]\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, comp_add, comp_add, add_left_inj, ψ.comm₁₂_assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, comp_add, comp_add, assoc, ψ.comm₂₃_assoc]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, comp_add, comp_add, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compLeft_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₃ S₁\n⊢ Eq (h.compLeft ψ).h₂ (CategoryTheory.CategoryStruct.comp ψ.τ₃ h.h₂)","decl":"/-- Homotopy between morphisms of short complexes is compatible with precomposition. -/\n@[simps]\ndef compLeft (h : Homotopy φ₁ φ₂) (ψ : S₃ ⟶ S₁) : Homotopy (ψ ≫ φ₁) (ψ ≫ φ₂) where\n  h₀ := ψ.τ₁ ≫ h.h₀\n  h₁ := ψ.τ₂ ≫ h.h₁\n  h₂ := ψ.τ₃ ≫ h.h₂\n  h₃ := ψ.τ₃ ≫ h.h₃\n  g_h₃ := by rw [← ψ.comm₂₃_assoc, h.g_h₃, comp_zero]\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, comp_add, comp_add, add_left_inj, ψ.comm₁₂_assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, comp_add, comp_add, assoc, ψ.comm₂₃_assoc]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, comp_add, comp_add, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compLeft_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₃ S₁\n⊢ Eq (h.compLeft ψ).h₃ (CategoryTheory.CategoryStruct.comp ψ.τ₃ h.h₃)","decl":"/-- Homotopy between morphisms of short complexes is compatible with precomposition. -/\n@[simps]\ndef compLeft (h : Homotopy φ₁ φ₂) (ψ : S₃ ⟶ S₁) : Homotopy (ψ ≫ φ₁) (ψ ≫ φ₂) where\n  h₀ := ψ.τ₁ ≫ h.h₀\n  h₁ := ψ.τ₂ ≫ h.h₁\n  h₂ := ψ.τ₃ ≫ h.h₂\n  h₃ := ψ.τ₃ ≫ h.h₃\n  g_h₃ := by rw [← ψ.comm₂₃_assoc, h.g_h₃, comp_zero]\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, comp_add, comp_add, add_left_inj, ψ.comm₁₂_assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, comp_add, comp_add, assoc, ψ.comm₂₃_assoc]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, comp_add, comp_add, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compLeft_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₃ S₁\n⊢ Eq (h.compLeft ψ).h₁ (CategoryTheory.CategoryStruct.comp ψ.τ₂ h.h₁)","decl":"/-- Homotopy between morphisms of short complexes is compatible with precomposition. -/\n@[simps]\ndef compLeft (h : Homotopy φ₁ φ₂) (ψ : S₃ ⟶ S₁) : Homotopy (ψ ≫ φ₁) (ψ ≫ φ₂) where\n  h₀ := ψ.τ₁ ≫ h.h₀\n  h₁ := ψ.τ₂ ≫ h.h₁\n  h₂ := ψ.τ₃ ≫ h.h₂\n  h₃ := ψ.τ₃ ≫ h.h₃\n  g_h₃ := by rw [← ψ.comm₂₃_assoc, h.g_h₃, comp_zero]\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, comp_add, comp_add, add_left_inj, ψ.comm₁₂_assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, comp_add, comp_add, assoc, ψ.comm₂₃_assoc]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, comp_add, comp_add, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compRight_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₂ S₃\n⊢ Eq (h.compRight ψ).h₂ (CategoryTheory.CategoryStruct.comp h.h₂ ψ.τ₂)","decl":"/-- Homotopy between morphisms of short complexes is compatible with postcomposition. -/\n@[simps]\ndef compRight (h : Homotopy φ₁ φ₂) (ψ : S₂ ⟶ S₃) : Homotopy (φ₁ ≫ ψ) (φ₂ ≫ ψ) where\n  h₀ := h.h₀ ≫ ψ.τ₁\n  h₁ := h.h₁ ≫ ψ.τ₁\n  h₂ := h.h₂ ≫ ψ.τ₂\n  h₃ := h.h₃ ≫ ψ.τ₃\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, add_comp, add_comp, assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, add_comp, add_comp, assoc, assoc, assoc, ψ.comm₁₂]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, add_comp, add_comp, assoc, assoc, ψ.comm₂₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compRight_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₂ S₃\n⊢ Eq (h.compRight ψ).h₃ (CategoryTheory.CategoryStruct.comp h.h₃ ψ.τ₃)","decl":"/-- Homotopy between morphisms of short complexes is compatible with postcomposition. -/\n@[simps]\ndef compRight (h : Homotopy φ₁ φ₂) (ψ : S₂ ⟶ S₃) : Homotopy (φ₁ ≫ ψ) (φ₂ ≫ ψ) where\n  h₀ := h.h₀ ≫ ψ.τ₁\n  h₁ := h.h₁ ≫ ψ.τ₁\n  h₂ := h.h₂ ≫ ψ.τ₂\n  h₃ := h.h₃ ≫ ψ.τ₃\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, add_comp, add_comp, assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, add_comp, add_comp, assoc, assoc, assoc, ψ.comm₁₂]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, add_comp, add_comp, assoc, assoc, ψ.comm₂₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compRight_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₂ S₃\n⊢ Eq (h.compRight ψ).h₁ (CategoryTheory.CategoryStruct.comp h.h₁ ψ.τ₁)","decl":"/-- Homotopy between morphisms of short complexes is compatible with postcomposition. -/\n@[simps]\ndef compRight (h : Homotopy φ₁ φ₂) (ψ : S₂ ⟶ S₃) : Homotopy (φ₁ ≫ ψ) (φ₂ ≫ ψ) where\n  h₀ := h.h₀ ≫ ψ.τ₁\n  h₁ := h.h₁ ≫ ψ.τ₁\n  h₂ := h.h₂ ≫ ψ.τ₂\n  h₃ := h.h₃ ≫ ψ.τ₃\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, add_comp, add_comp, assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, add_comp, add_comp, assoc, assoc, assoc, ψ.comm₁₂]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, add_comp, add_comp, assoc, assoc, ψ.comm₂₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.compRight_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ : Quiver.Hom S₂ S₃\n⊢ Eq (h.compRight ψ).h₀ (CategoryTheory.CategoryStruct.comp h.h₀ ψ.τ₁)","decl":"/-- Homotopy between morphisms of short complexes is compatible with postcomposition. -/\n@[simps]\ndef compRight (h : Homotopy φ₁ φ₂) (ψ : S₂ ⟶ S₃) : Homotopy (φ₁ ≫ ψ) (φ₂ ≫ ψ) where\n  h₀ := h.h₀ ≫ ψ.τ₁\n  h₁ := h.h₁ ≫ ψ.τ₁\n  h₂ := h.h₂ ≫ ψ.τ₂\n  h₃ := h.h₃ ≫ ψ.τ₃\n  comm₁ := by rw [comp_τ₁, comp_τ₁, h.comm₁, add_comp, add_comp, assoc]\n  comm₂ := by rw [comp_τ₂, comp_τ₂, h.comm₂, add_comp, add_comp, assoc, assoc, assoc, ψ.comm₁₂]\n  comm₃ := by rw [comp_τ₃, comp_τ₃, h.comm₃, add_comp, add_comp, assoc, assoc, ψ.comm₂₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comp_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ₁ ψ₂ : Quiver.Hom S₂ S₃\nh' : CategoryTheory.ShortComplex.Homotopy ψ₁ ψ₂\n⊢ Eq (h.comp h').h₂ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h.h₂ ψ₁.τ₂) (CategoryTheory.CategoryStruct.comp φ₂.τ₃ h'.h₂))","decl":"/-- Homotopy between morphisms of short complexes is compatible with composition. -/\n@[simps!]\ndef comp (h : Homotopy φ₁ φ₂) {ψ₁ ψ₂ : S₂ ⟶ S₃} (h' : Homotopy ψ₁ ψ₂) :\n    Homotopy (φ₁ ≫ ψ₁) (φ₂ ≫ ψ₂) :=\n  (h.compRight ψ₁).trans (h'.compLeft φ₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comp_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ₁ ψ₂ : Quiver.Hom S₂ S₃\nh' : CategoryTheory.ShortComplex.Homotopy ψ₁ ψ₂\n⊢ Eq (h.comp h').h₁ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h.h₁ ψ₁.τ₁) (CategoryTheory.CategoryStruct.comp φ₂.τ₂ h'.h₁))","decl":"/-- Homotopy between morphisms of short complexes is compatible with composition. -/\n@[simps!]\ndef comp (h : Homotopy φ₁ φ₂) {ψ₁ ψ₂ : S₂ ⟶ S₃} (h' : Homotopy ψ₁ ψ₂) :\n    Homotopy (φ₁ ≫ ψ₁) (φ₂ ≫ ψ₂) :=\n  (h.compRight ψ₁).trans (h'.compLeft φ₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comp_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ₁ ψ₂ : Quiver.Hom S₂ S₃\nh' : CategoryTheory.ShortComplex.Homotopy ψ₁ ψ₂\n⊢ Eq (h.comp h').h₀ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h.h₀ ψ₁.τ₁) (CategoryTheory.CategoryStruct.comp φ₂.τ₁ h'.h₀))","decl":"/-- Homotopy between morphisms of short complexes is compatible with composition. -/\n@[simps!]\ndef comp (h : Homotopy φ₁ φ₂) {ψ₁ ψ₂ : S₂ ⟶ S₃} (h' : Homotopy ψ₁ ψ₂) :\n    Homotopy (φ₁ ≫ ψ₁) (φ₂ ≫ ψ₂) :=\n  (h.compRight ψ₁).trans (h'.compLeft φ₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.comp_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nψ₁ ψ₂ : Quiver.Hom S₂ S₃\nh' : CategoryTheory.ShortComplex.Homotopy ψ₁ ψ₂\n⊢ Eq (h.comp h').h₃ (HAdd.hAdd (CategoryTheory.CategoryStruct.comp h.h₃ ψ₁.τ₃) (CategoryTheory.CategoryStruct.comp φ₂.τ₃ h'.h₃))","decl":"/-- Homotopy between morphisms of short complexes is compatible with composition. -/\n@[simps!]\ndef comp (h : Homotopy φ₁ φ₂) {ψ₁ ψ₂ : S₂ ⟶ S₃} (h' : Homotopy ψ₁ ψ₂) :\n    Homotopy (φ₁ ≫ ψ₁) (φ₂ ≫ ψ₂) :=\n  (h.compRight ψ₁).trans (h'.compLeft φ₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.op_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.op.h₀ h.h₃.op","decl":"/-- The homotopy between morphisms in `ShortComplex Cᵒᵖ` that is induced by a homotopy\nbetween morphisms in `ShortComplex C`. -/\n@[simps]\ndef op (h : Homotopy φ₁ φ₂) : Homotopy (opMap φ₁) (opMap φ₂) where\n  h₀ := h.h₃.op\n  h₁ := h.h₂.op\n  h₂ := h.h₁.op\n  h₃ := h.h₀.op\n  h₀_f := Quiver.Hom.unop_inj h.g_h₃\n  g_h₃ := Quiver.Hom.unop_inj h.h₀_f\n  comm₁ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.op_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.op.h₁ h.h₂.op","decl":"/-- The homotopy between morphisms in `ShortComplex Cᵒᵖ` that is induced by a homotopy\nbetween morphisms in `ShortComplex C`. -/\n@[simps]\ndef op (h : Homotopy φ₁ φ₂) : Homotopy (opMap φ₁) (opMap φ₂) where\n  h₀ := h.h₃.op\n  h₁ := h.h₂.op\n  h₂ := h.h₁.op\n  h₃ := h.h₀.op\n  h₀_f := Quiver.Hom.unop_inj h.g_h₃\n  g_h₃ := Quiver.Hom.unop_inj h.h₀_f\n  comm₁ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.op_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.op.h₃ h.h₀.op","decl":"/-- The homotopy between morphisms in `ShortComplex Cᵒᵖ` that is induced by a homotopy\nbetween morphisms in `ShortComplex C`. -/\n@[simps]\ndef op (h : Homotopy φ₁ φ₂) : Homotopy (opMap φ₁) (opMap φ₂) where\n  h₀ := h.h₃.op\n  h₁ := h.h₂.op\n  h₂ := h.h₁.op\n  h₃ := h.h₀.op\n  h₀_f := Quiver.Hom.unop_inj h.g_h₃\n  g_h₃ := Quiver.Hom.unop_inj h.h₀_f\n  comm₁ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.op_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.op.h₂ h.h₁.op","decl":"/-- The homotopy between morphisms in `ShortComplex Cᵒᵖ` that is induced by a homotopy\nbetween morphisms in `ShortComplex C`. -/\n@[simps]\ndef op (h : Homotopy φ₁ φ₂) : Homotopy (opMap φ₁) (opMap φ₂) where\n  h₀ := h.h₃.op\n  h₁ := h.h₂.op\n  h₂ := h.h₁.op\n  h₃ := h.h₀.op\n  h₀_f := Quiver.Hom.unop_inj h.g_h₃\n  g_h₃ := Quiver.Hom.unop_inj h.h₀_f\n  comm₁ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.unop_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.unop_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.unop.h₃ h.h₀.unop","decl":"/-- The homotopy between morphisms in `ShortComplex C` that is induced by a homotopy\nbetween morphisms in `ShortComplex Cᵒᵖ`. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ₁ φ₂ : S₁ ⟶ S₂} (h : Homotopy φ₁ φ₂) :\n    Homotopy (unopMap φ₁) (unopMap φ₂) where\n  h₀ := h.h₃.unop\n  h₁ := h.h₂.unop\n  h₂ := h.h₁.unop\n  h₃ := h.h₀.unop\n  h₀_f := Quiver.Hom.op_inj h.g_h₃\n  g_h₃ := Quiver.Hom.op_inj h.h₀_f\n  comm₁ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.unop_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.unop.h₀ h.h₃.unop","decl":"/-- The homotopy between morphisms in `ShortComplex C` that is induced by a homotopy\nbetween morphisms in `ShortComplex Cᵒᵖ`. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ₁ φ₂ : S₁ ⟶ S₂} (h : Homotopy φ₁ φ₂) :\n    Homotopy (unopMap φ₁) (unopMap φ₂) where\n  h₀ := h.h₃.unop\n  h₁ := h.h₂.unop\n  h₂ := h.h₁.unop\n  h₃ := h.h₀.unop\n  h₀_f := Quiver.Hom.op_inj h.g_h₃\n  g_h₃ := Quiver.Hom.op_inj h.h₀_f\n  comm₁ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.unop_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.unop.h₁ h.h₂.unop","decl":"/-- The homotopy between morphisms in `ShortComplex C` that is induced by a homotopy\nbetween morphisms in `ShortComplex Cᵒᵖ`. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ₁ φ₂ : S₁ ⟶ S₂} (h : Homotopy φ₁ φ₂) :\n    Homotopy (unopMap φ₁) (unopMap φ₂) where\n  h₀ := h.h₃.unop\n  h₁ := h.h₂.unop\n  h₂ := h.h₁.unop\n  h₃ := h.h₀.unop\n  h₀_f := Quiver.Hom.op_inj h.g_h₃\n  g_h₃ := Quiver.Hom.op_inj h.h₀_f\n  comm₁ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.unop_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq h.unop.h₂ h.h₁.unop","decl":"/-- The homotopy between morphisms in `ShortComplex C` that is induced by a homotopy\nbetween morphisms in `ShortComplex Cᵒᵖ`. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ₁ φ₂ : S₁ ⟶ S₂} (h : Homotopy φ₁ φ₂) :\n    Homotopy (unopMap φ₁) (unopMap φ₂) where\n  h₀ := h.h₃.unop\n  h₁ := h.h₂.unop\n  h₂ := h.h₁.unop\n  h₃ := h.h₀.unop\n  h₀_f := Quiver.Hom.op_inj h.g_h₃\n  g_h₃ := Quiver.Hom.op_inj h.h₀_f\n  comm₁ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₃]; abel)\n  comm₂ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₂]; abel)\n  comm₃ := Quiver.Hom.op_inj (by dsimp; rw [h.comm₁]; abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.equivSubZero_symm_apply","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy (HSub.hSub φ₁ φ₂) 0\n⊢ Eq ((CategoryTheory.ShortComplex.Homotopy.equivSubZero φ₁ φ₂).symm h) (((CategoryTheory.ShortComplex.Homotopy.ofEq ⋯).trans (h.add (CategoryTheory.ShortComplex.Homotopy.refl φ₂))).trans (CategoryTheory.ShortComplex.Homotopy.ofEq ⋯))","decl":"/-- Equivalence expressing that two morphisms are homotopic iff\ntheir difference is homotopic to zero. -/\n@[simps]\ndef equivSubZero : Homotopy φ₁ φ₂ ≃ Homotopy (φ₁ - φ₂) 0 where\n  toFun h := (h.sub (refl φ₂)).trans (ofEq (sub_self φ₂))\n  invFun h := ((ofEq (sub_add_cancel φ₁ φ₂).symm).trans\n    (h.add (refl φ₂))).trans (ofEq (zero_add φ₂))\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.equivSubZero_apply","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq ((CategoryTheory.ShortComplex.Homotopy.equivSubZero φ₁ φ₂) h) ((h.sub (CategoryTheory.ShortComplex.Homotopy.refl φ₂)).trans (CategoryTheory.ShortComplex.Homotopy.ofEq ⋯))","decl":"/-- Equivalence expressing that two morphisms are homotopic iff\ntheir difference is homotopic to zero. -/\n@[simps]\ndef equivSubZero : Homotopy φ₁ φ₂ ≃ Homotopy (φ₁ - φ₂) 0 where\n  toFun h := (h.sub (refl φ₂)).trans (ofEq (sub_self φ₂))\n  invFun h := ((ofEq (sub_add_cancel φ₁ φ₂).symm).trans\n    (h.add (refl φ₂))).trans (ofEq (zero_add φ₂))\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.eq_add_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\n⊢ Eq φ₁ (HAdd.hAdd φ₂ (S₁.nullHomotopic S₂ h.h₀ ⋯ h.h₁ h.h₂ h.h₃ ⋯))","decl":"lemma eq_add_nullHomotopic (h : Homotopy φ₁ φ₂) :\n    φ₁ = φ₂ + nullHomotopic _ _ h.h₀ h.h₀_f h.h₁ h.h₂ h.h₃ h.g_h₃ := by\n  ext\n  · dsimp; rw [h.comm₁]; abel\n  · dsimp; rw [h.comm₂]; abel\n  · dsimp; rw [h.comm₃]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic_h₃","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic S₁ S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).h₃ h₃","decl":"/-- A morphism constructed with `nullHomotopic` is homotopic to zero. -/\n@[simps]\ndef ofNullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n  Homotopy (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) 0 where\n  h₀ := h₀\n  h₁ := h₁\n  h₂ := h₂\n  h₃ := h₃\n  h₀_f := h₀_f\n  g_h₃ := g_h₃\n  comm₁ := by rw [nullHomotopic_τ₁, zero_τ₁, add_zero]; abel\n  comm₂ := by rw [nullHomotopic_τ₂, zero_τ₂, add_zero]; abel\n  comm₃ := by rw [nullHomotopic_τ₃, zero_τ₃, add_zero]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic_h₁","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic S₁ S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).h₁ h₁","decl":"/-- A morphism constructed with `nullHomotopic` is homotopic to zero. -/\n@[simps]\ndef ofNullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n  Homotopy (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) 0 where\n  h₀ := h₀\n  h₁ := h₁\n  h₂ := h₂\n  h₃ := h₃\n  h₀_f := h₀_f\n  g_h₃ := g_h₃\n  comm₁ := by rw [nullHomotopic_τ₁, zero_τ₁, add_zero]; abel\n  comm₂ := by rw [nullHomotopic_τ₂, zero_τ₂, add_zero]; abel\n  comm₃ := by rw [nullHomotopic_τ₃, zero_τ₃, add_zero]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic_h₀","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic S₁ S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).h₀ h₀","decl":"/-- A morphism constructed with `nullHomotopic` is homotopic to zero. -/\n@[simps]\ndef ofNullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n  Homotopy (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) 0 where\n  h₀ := h₀\n  h₁ := h₁\n  h₂ := h₂\n  h₃ := h₃\n  h₀_f := h₀_f\n  g_h₃ := g_h₃\n  comm₁ := by rw [nullHomotopic_τ₁, zero_τ₁, add_zero]; abel\n  comm₂ := by rw [nullHomotopic_τ₂, zero_τ₂, add_zero]; abel\n  comm₃ := by rw [nullHomotopic_τ₃, zero_τ₃, add_zero]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic_h₂","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.Homotopy.ofNullHomotopic S₁ S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).h₂ h₂","decl":"/-- A morphism constructed with `nullHomotopic` is homotopic to zero. -/\n@[simps]\ndef ofNullHomotopic (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n  Homotopy (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) 0 where\n  h₀ := h₀\n  h₁ := h₁\n  h₂ := h₂\n  h₃ := h₃\n  h₀_f := h₀_f\n  g_h₃ := g_h₃\n  comm₁ := by rw [nullHomotopic_τ₁, zero_τ₁, add_zero]; abel\n  comm₂ := by rw [nullHomotopic_τ₂, zero_τ₂, add_zero]; abel\n  comm₃ := by rw [nullHomotopic_τ₃, zero_τ₃, add_zero]; abel\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nH₁ : S₁.LeftHomologyData\nH₂ : S₂.LeftHomologyData\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂) 0","decl":"@[simp]\nlemma leftHomologyMap'_nullHomotopic\n    (H₁ : S₁.LeftHomologyData) (H₂ : S₂.LeftHomologyData)\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    leftHomologyMap' (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂ = 0 :=\n  (LeftHomologyMapData.ofNullHomotopic H₁ H₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).leftHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nH₁ : S₁.RightHomologyData\nH₂ : S₂.RightHomologyData\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂) 0","decl":"@[simp]\nlemma rightHomologyMap'_nullHomotopic\n    (H₁ : S₁.RightHomologyData) (H₂ : S₂.RightHomologyData)\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    rightHomologyMap' (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂ = 0 :=\n  (RightHomologyMapData.ofNullHomotopic H₁ H₂ h₀ h₀_f h₁ h₂ h₃ g_h₃).rightHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nH₁ : S₁.HomologyData\nH₂ : S₂.HomologyData\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂) 0","decl":"@[simp]\nlemma homologyMap'_nullHomotopic\n    (H₁ : S₁.HomologyData) (H₂ : S₂.HomologyData)\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    homologyMap' (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) H₁ H₂ = 0 := by\n  apply leftHomologyMap'_nullHomotopic\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃)) 0","decl":"@[simp]\nlemma leftHomologyMap_nullHomotopic [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    leftHomologyMap (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) = 0 := by\n  apply leftHomologyMap'_nullHomotopic\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃)) 0","decl":"@[simp]\nlemma rightHomologyMap_nullHomotopic [S₁.HasRightHomology] [S₂.HasRightHomology]\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    rightHomologyMap (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) = 0 := by\n  apply rightHomologyMap'_nullHomotopic\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_nullHomotopic","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh₀ : Quiver.Hom S₁.X₁ S₂.X₁\nh₀_f : Eq (CategoryTheory.CategoryStruct.comp h₀ S₂.f) 0\nh₁ : Quiver.Hom S₁.X₂ S₂.X₁\nh₂ : Quiver.Hom S₁.X₃ S₂.X₂\nh₃ : Quiver.Hom S₁.X₃ S₂.X₃\ng_h₃ : Eq (CategoryTheory.CategoryStruct.comp S₁.g h₃) 0\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (S₁.nullHomotopic S₂ h₀ h₀_f h₁ h₂ h₃ g_h₃)) 0","decl":"@[simp]\nlemma homologyMap_nullHomotopic [S₁.HasHomology] [S₂.HasHomology]\n    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)\n    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :\n    homologyMap (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) = 0 := by\n  apply homologyMap'_nullHomotopic\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.leftHomologyMap'_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.leftHomologyMap' φ₂ h₁ h₂)","decl":"lemma leftHomologyMap'_congr (h : Homotopy φ₁ φ₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₂.LeftHomologyData) : leftHomologyMap' φ₁ h₁ h₂ = leftHomologyMap' φ₂ h₁ h₂ := by\n  rw [h.eq_add_nullHomotopic, leftHomologyMap'_add, leftHomologyMap'_nullHomotopic, add_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.rightHomologyMap'_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.rightHomologyMap' φ₂ h₁ h₂)","decl":"lemma rightHomologyMap'_congr (h : Homotopy φ₁ φ₂) (h₁ : S₁.RightHomologyData)\n    (h₂ : S₂.RightHomologyData) : rightHomologyMap' φ₁ h₁ h₂ = rightHomologyMap' φ₂ h₁ h₂ := by\n  rw [h.eq_add_nullHomotopic, rightHomologyMap'_add, rightHomologyMap'_nullHomotopic, add_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.homologyMap'_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.homologyMap' φ₂ h₁ h₂)","decl":"lemma homologyMap'_congr (h : Homotopy φ₁ φ₂) (h₁ : S₁.HomologyData)\n    (h₂ : S₂.HomologyData) : homologyMap' φ₁ h₁ h₂ = homologyMap' φ₂ h₁ h₂ := by\n  rw [h.eq_add_nullHomotopic, homologyMap'_add, homologyMap'_nullHomotopic, add_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.leftHomologyMap_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap φ₁) (CategoryTheory.ShortComplex.leftHomologyMap φ₂)","decl":"lemma leftHomologyMap_congr (h : Homotopy φ₁ φ₂) [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    leftHomologyMap φ₁ = leftHomologyMap φ₂ :=\n  h.leftHomologyMap'_congr _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.rightHomologyMap_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap φ₁) (CategoryTheory.ShortComplex.rightHomologyMap φ₂)","decl":"lemma rightHomologyMap_congr (h : Homotopy φ₁ φ₂) [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    rightHomologyMap φ₁ = rightHomologyMap φ₂ :=\n  h.rightHomologyMap'_congr _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.Homotopy.homologyMap_congr","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ₁ φ₂ : Quiver.Hom S₁ S₂\nh : CategoryTheory.ShortComplex.Homotopy φ₁ φ₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap φ₁) (CategoryTheory.ShortComplex.homologyMap φ₂)","decl":"lemma homologyMap_congr (h : Homotopy φ₁ φ₂) [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap φ₁ = homologyMap φ₂ :=\n  h.homologyMap'_congr _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nhom✝ : Quiver.Hom S₁ S₂\ninv✝ : Quiver.Hom S₂ S₁\nhomotopyHomInvId✝ : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp hom✝ inv✝) (CategoryTheory.CategoryStruct.id S₁)\nhomotopyInvHomId✝ : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id S₂)\nhom : Quiver.Hom S₁ S₂\ninv : Quiver.Hom S₂ S₁\nhomotopyHomInvId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id S₁)\nhomotopyInvHomId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id S₂)\n⊢ Eq (Eq { hom := hom✝, inv := inv✝, homotopyHomInvId := homotopyHomInvId✝, homotopyInvHomId := homotopyInvHomId✝ } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq homotopyHomInvId✝ homotopyHomInvId) (HEq homotopyInvHomId✝ homotopyInvHomId))))","decl":"/-- An homotopy equivalence between two short complexes `S₁` and `S₂` consists\nof morphisms `hom : S₁ ⟶ S₂` and `inv : S₂ ⟶ S₁` such that both compositions\n`hom ≫ inv` and `inv ≫ hom` are homotopic to the identity. -/\n@[ext]\nstructure HomotopyEquiv where\n  /-- the forward direction of a homotopy equivalence. -/\n  hom : S₁ ⟶ S₂\n  /-- the backwards direction of a homotopy equivalence. -/\n  inv : S₂ ⟶ S₁\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the source -/\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 S₁)\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the target -/\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 S₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nhom✝ : Quiver.Hom S₁ S₂\ninv✝ : Quiver.Hom S₂ S₁\nhomotopyHomInvId✝ : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp hom✝ inv✝) (CategoryTheory.CategoryStruct.id S₁)\nhomotopyInvHomId✝ : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id S₂)\nhom : Quiver.Hom S₁ S₂\ninv : Quiver.Hom S₂ S₁\nhomotopyHomInvId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id S₁)\nhomotopyInvHomId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id S₂)\nx✝ : Eq { hom := hom✝, inv := inv✝, homotopyHomInvId := homotopyHomInvId✝, homotopyInvHomId := homotopyInvHomId✝ } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }\n⊢ And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq homotopyHomInvId✝ homotopyHomInvId) (HEq homotopyInvHomId✝ homotopyInvHomId)))","decl":"/-- An homotopy equivalence between two short complexes `S₁` and `S₂` consists\nof morphisms `hom : S₁ ⟶ S₂` and `inv : S₂ ⟶ S₁` such that both compositions\n`hom ≫ inv` and `inv ≫ hom` are homotopic to the identity. -/\n@[ext]\nstructure HomotopyEquiv where\n  /-- the forward direction of a homotopy equivalence. -/\n  hom : S₁ ⟶ S₂\n  /-- the backwards direction of a homotopy equivalence. -/\n  inv : S₂ ⟶ S₁\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the source -/\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 S₁)\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the target -/\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 S₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.ext","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nx y : S₁.HomotopyEquiv S₂\nhom : Eq x.hom y.hom\ninv : Eq x.inv y.inv\nhomotopyHomInvId : HEq x.homotopyHomInvId y.homotopyHomInvId\nhomotopyInvHomId : HEq x.homotopyInvHomId y.homotopyInvHomId\n⊢ Eq x y","decl":"/-- An homotopy equivalence between two short complexes `S₁` and `S₂` consists\nof morphisms `hom : S₁ ⟶ S₂` and `inv : S₂ ⟶ S₁` such that both compositions\n`hom ≫ inv` and `inv ≫ hom` are homotopic to the identity. -/\n@[ext]\nstructure HomotopyEquiv where\n  /-- the forward direction of a homotopy equivalence. -/\n  hom : S₁ ⟶ S₂\n  /-- the backwards direction of a homotopy equivalence. -/\n  inv : S₂ ⟶ S₁\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the source -/\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 S₁)\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the target -/\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 S₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nx y : S₁.HomotopyEquiv S₂\n⊢ Iff (Eq x y) (And (Eq x.hom y.hom) (And (Eq x.inv y.inv) (And (HEq x.homotopyHomInvId y.homotopyHomInvId) (HEq x.homotopyInvHomId y.homotopyInvHomId))))","decl":"/-- An homotopy equivalence between two short complexes `S₁` and `S₂` consists\nof morphisms `hom : S₁ ⟶ S₂` and `inv : S₂ ⟶ S₁` such that both compositions\n`hom ≫ inv` and `inv ≫ hom` are homotopic to the identity. -/\n@[ext]\nstructure HomotopyEquiv where\n  /-- the forward direction of a homotopy equivalence. -/\n  hom : S₁ ⟶ S₂\n  /-- the backwards direction of a homotopy equivalence. -/\n  inv : S₂ ⟶ S₁\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the source -/\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 S₁)\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the target -/\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 S₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝ : SizeOf C\nhom : Quiver.Hom S₁ S₂\ninv : Quiver.Hom S₂ S₁\nhomotopyHomInvId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id S₁)\nhomotopyInvHomId : CategoryTheory.ShortComplex.Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id S₂)\n⊢ Eq (SizeOf.sizeOf { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf homotopyHomInvId)) (SizeOf.sizeOf homotopyInvHomId))","decl":"/-- An homotopy equivalence between two short complexes `S₁` and `S₂` consists\nof morphisms `hom : S₁ ⟶ S₂` and `inv : S₂ ⟶ S₁` such that both compositions\n`hom ≫ inv` and `inv ≫ hom` are homotopic to the identity. -/\n@[ext]\nstructure HomotopyEquiv where\n  /-- the forward direction of a homotopy equivalence. -/\n  hom : S₁ ⟶ S₂\n  /-- the backwards direction of a homotopy equivalence. -/\n  inv : S₂ ⟶ S₁\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the source -/\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 S₁)\n  /-- the composition of the two directions of a homotopy equivalence is\n  homotopic to the identity of the target -/\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 S₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.refl_homotopyHomInvId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.HomotopyEquiv.refl S).homotopyHomInvId (CategoryTheory.ShortComplex.Homotopy.ofEq ⋯)","decl":"/-- The homotopy equivalence from a short complex to itself that is induced\nby the identity. -/\n@[simps]\ndef refl (S : ShortComplex C) : HomotopyEquiv S S where\n  hom := 𝟙 S\n  inv := 𝟙 S\n  homotopyHomInvId := Homotopy.ofEq (by simp)\n  homotopyInvHomId := Homotopy.ofEq (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.refl_homotopyInvHomId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.HomotopyEquiv.refl S).homotopyInvHomId (CategoryTheory.ShortComplex.Homotopy.ofEq ⋯)","decl":"/-- The homotopy equivalence from a short complex to itself that is induced\nby the identity. -/\n@[simps]\ndef refl (S : ShortComplex C) : HomotopyEquiv S S where\n  hom := 𝟙 S\n  inv := 𝟙 S\n  homotopyHomInvId := Homotopy.ofEq (by simp)\n  homotopyInvHomId := Homotopy.ofEq (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.refl_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.HomotopyEquiv.refl S).inv (CategoryTheory.CategoryStruct.id S)","decl":"/-- The homotopy equivalence from a short complex to itself that is induced\nby the identity. -/\n@[simps]\ndef refl (S : ShortComplex C) : HomotopyEquiv S S where\n  hom := 𝟙 S\n  inv := 𝟙 S\n  homotopyHomInvId := Homotopy.ofEq (by simp)\n  homotopyInvHomId := Homotopy.ofEq (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.refl_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.HomotopyEquiv.refl S).hom (CategoryTheory.CategoryStruct.id S)","decl":"/-- The homotopy equivalence from a short complex to itself that is induced\nby the identity. -/\n@[simps]\ndef refl (S : ShortComplex C) : HomotopyEquiv S S where\n  hom := 𝟙 S\n  inv := 𝟙 S\n  homotopyHomInvId := Homotopy.ofEq (by simp)\n  homotopyInvHomId := Homotopy.ofEq (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.symm_homotopyHomInvId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\n⊢ Eq e.symm.homotopyHomInvId e.homotopyInvHomId","decl":"/-- The inverse of a homotopy equivalence. -/\n@[simps]\ndef symm (e : HomotopyEquiv S₁ S₂) : HomotopyEquiv S₂ S₁ where\n  hom := e.inv\n  inv := e.hom\n  homotopyHomInvId := e.homotopyInvHomId\n  homotopyInvHomId := e.homotopyHomInvId\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.symm_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\n⊢ Eq e.symm.inv e.hom","decl":"/-- The inverse of a homotopy equivalence. -/\n@[simps]\ndef symm (e : HomotopyEquiv S₁ S₂) : HomotopyEquiv S₂ S₁ where\n  hom := e.inv\n  inv := e.hom\n  homotopyHomInvId := e.homotopyInvHomId\n  homotopyInvHomId := e.homotopyHomInvId\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.symm_homotopyInvHomId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\n⊢ Eq e.symm.homotopyInvHomId e.homotopyHomInvId","decl":"/-- The inverse of a homotopy equivalence. -/\n@[simps]\ndef symm (e : HomotopyEquiv S₁ S₂) : HomotopyEquiv S₂ S₁ where\n  hom := e.inv\n  inv := e.hom\n  homotopyHomInvId := e.homotopyInvHomId\n  homotopyInvHomId := e.homotopyHomInvId\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.symm_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\n⊢ Eq e.symm.hom e.inv","decl":"/-- The inverse of a homotopy equivalence. -/\n@[simps]\ndef symm (e : HomotopyEquiv S₁ S₂) : HomotopyEquiv S₂ S₁ where\n  hom := e.inv\n  inv := e.hom\n  homotopyHomInvId := e.homotopyInvHomId\n  homotopyInvHomId := e.homotopyHomInvId\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.trans_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\ne' : S₂.HomotopyEquiv S₃\n⊢ Eq (e.trans e').hom (CategoryTheory.CategoryStruct.comp e.hom e'.hom)","decl":"/-- The composition of homotopy equivalences. -/\n@[simps]\ndef trans (e : HomotopyEquiv S₁ S₂) (e' : HomotopyEquiv S₂ S₃) :\n    HomotopyEquiv S₁ S₃ where\n  hom := e.hom ≫ e'.hom\n  inv := e'.inv ≫ e.inv\n  homotopyHomInvId := (Homotopy.ofEq (by simp)).trans\n    (((e'.homotopyHomInvId.compRight e.inv).compLeft e.hom).trans\n      ((Homotopy.ofEq (by simp)).trans e.homotopyHomInvId))\n  homotopyInvHomId := (Homotopy.ofEq (by simp)).trans\n    (((e.homotopyInvHomId.compRight e'.hom).compLeft e'.inv).trans\n      ((Homotopy.ofEq (by simp)).trans e'.homotopyInvHomId))\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.trans_homotopyHomInvId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\ne' : S₂.HomotopyEquiv S₃\n⊢ Eq (e.trans e').homotopyHomInvId ((CategoryTheory.ShortComplex.Homotopy.ofEq ⋯).trans (((e'.homotopyHomInvId.compRight e.inv).compLeft e.hom).trans ((CategoryTheory.ShortComplex.Homotopy.ofEq ⋯).trans e.homotopyHomInvId)))","decl":"/-- The composition of homotopy equivalences. -/\n@[simps]\ndef trans (e : HomotopyEquiv S₁ S₂) (e' : HomotopyEquiv S₂ S₃) :\n    HomotopyEquiv S₁ S₃ where\n  hom := e.hom ≫ e'.hom\n  inv := e'.inv ≫ e.inv\n  homotopyHomInvId := (Homotopy.ofEq (by simp)).trans\n    (((e'.homotopyHomInvId.compRight e.inv).compLeft e.hom).trans\n      ((Homotopy.ofEq (by simp)).trans e.homotopyHomInvId))\n  homotopyInvHomId := (Homotopy.ofEq (by simp)).trans\n    (((e.homotopyInvHomId.compRight e'.hom).compLeft e'.inv).trans\n      ((Homotopy.ofEq (by simp)).trans e'.homotopyInvHomId))\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.trans_homotopyInvHomId","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\ne' : S₂.HomotopyEquiv S₃\n⊢ Eq (e.trans e').homotopyInvHomId ((CategoryTheory.ShortComplex.Homotopy.ofEq ⋯).trans (((e.homotopyInvHomId.compRight e'.hom).compLeft e'.inv).trans ((CategoryTheory.ShortComplex.Homotopy.ofEq ⋯).trans e'.homotopyInvHomId)))","decl":"/-- The composition of homotopy equivalences. -/\n@[simps]\ndef trans (e : HomotopyEquiv S₁ S₂) (e' : HomotopyEquiv S₂ S₃) :\n    HomotopyEquiv S₁ S₃ where\n  hom := e.hom ≫ e'.hom\n  inv := e'.inv ≫ e.inv\n  homotopyHomInvId := (Homotopy.ofEq (by simp)).trans\n    (((e'.homotopyHomInvId.compRight e.inv).compLeft e.hom).trans\n      ((Homotopy.ofEq (by simp)).trans e.homotopyHomInvId))\n  homotopyInvHomId := (Homotopy.ofEq (by simp)).trans\n    (((e.homotopyInvHomId.compRight e'.hom).compLeft e'.inv).trans\n      ((Homotopy.ofEq (by simp)).trans e'.homotopyInvHomId))\n\n"}
{"name":"CategoryTheory.ShortComplex.HomotopyEquiv.trans_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ne : S₁.HomotopyEquiv S₂\ne' : S₂.HomotopyEquiv S₃\n⊢ Eq (e.trans e').inv (CategoryTheory.CategoryStruct.comp e'.inv e.inv)","decl":"/-- The composition of homotopy equivalences. -/\n@[simps]\ndef trans (e : HomotopyEquiv S₁ S₂) (e' : HomotopyEquiv S₂ S₃) :\n    HomotopyEquiv S₁ S₃ where\n  hom := e.hom ≫ e'.hom\n  inv := e'.inv ≫ e.inv\n  homotopyHomInvId := (Homotopy.ofEq (by simp)).trans\n    (((e'.homotopyHomInvId.compRight e.inv).compLeft e.hom).trans\n      ((Homotopy.ofEq (by simp)).trans e.homotopyHomInvId))\n  homotopyInvHomId := (Homotopy.ofEq (by simp)).trans\n    (((e.homotopyInvHomId.compRight e'.hom).compLeft e'.inv).trans\n      ((Homotopy.ofEq (by simp)).trans e'.homotopyInvHomId))\n\n"}
