{"name":"Multiset.coe_sort","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\nl : List α\n⊢ Eq (Multiset.sort r ↑l) (l.mergeSort fun x1 x2 => Decidable.decide (r x1 x2))","decl":"@[simp]\ntheorem coe_sort (l : List α) : sort r l = mergeSort l (r · ·) :=\n  rfl\n\n"}
{"name":"Multiset.sort_sorted","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Multiset α\n⊢ List.Sorted r (Multiset.sort r s)","decl":"@[simp]\ntheorem sort_sorted (s : Multiset α) : Sorted r (sort r s) :=\n  Quot.inductionOn s fun l => by\n    simpa using sorted_mergeSort (le := (r · ·)) IsTrans.trans\n      (fun a b => by simpa using IsTotal.total a b) l\n\n"}
{"name":"Multiset.sort_eq","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Multiset α\n⊢ Eq (↑(Multiset.sort r s)) s","decl":"@[simp]\ntheorem sort_eq (s : Multiset α) : ↑(sort r s) = s :=\n  Quot.inductionOn s fun _ => Quot.sound <| mergeSort_perm _ _\n\n"}
{"name":"Multiset.mem_sort","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Multiset α\na : α\n⊢ Iff (Membership.mem (Multiset.sort r s) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_sort {s : Multiset α} {a : α} : a ∈ sort r s ↔ a ∈ s := by rw [← mem_coe, sort_eq]\n\n"}
{"name":"Multiset.length_sort","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Multiset α\n⊢ Eq (Multiset.sort r s).length s.card","decl":"@[simp]\ntheorem length_sort {s : Multiset α} : (sort r s).length = card s :=\n  Quot.inductionOn s <| length_mergeSort\n\n"}
{"name":"Multiset.sort_zero","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\n⊢ Eq (Multiset.sort r 0) List.nil","decl":"@[simp]\ntheorem sort_zero : sort r 0 = [] :=\n  List.mergeSort_nil\n\n"}
{"name":"Multiset.sort_singleton","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\na : α\n⊢ Eq (Multiset.sort r (Singleton.singleton a)) (List.cons a List.nil)","decl":"@[simp]\ntheorem sort_singleton (a : α) : sort r {a} = [a] :=\n  List.mergeSort_singleton a\n\n"}
{"name":"Multiset.map_sort","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ninst✝⁷ : DecidableRel r\ninst✝⁶ : IsTrans α r\ninst✝⁵ : IsAntisymm α r\ninst✝⁴ : IsTotal α r\nr' : β → β → Prop\ninst✝³ : DecidableRel r'\ninst✝² : IsTrans β r'\ninst✝¹ : IsAntisymm β r'\ninst✝ : IsTotal β r'\nf : α → β\ns : Multiset α\nhs : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → Iff (r a b) (r' (f a) (f b))\n⊢ Eq (List.map f (Multiset.sort r s)) (Multiset.sort r' (Multiset.map f s))","decl":"theorem map_sort (f : α → β) (s : Multiset α)\n    (hs : ∀ a ∈ s, ∀ b ∈ s, r a b ↔ r' (f a) (f b)) :\n    (s.sort r).map f = (s.map f).sort r' := by\n  revert s\n  exact Quot.ind fun l h => map_mergeSort (l := l) (by simpa using h)\n\n"}
{"name":"Multiset.sort_cons","module":"Mathlib.Data.Multiset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\na : α\ns : Multiset α\na✝ : ∀ (b : α), Membership.mem s b → r a b\n⊢ Eq (Multiset.sort r (Multiset.cons a s)) (List.cons a (Multiset.sort r s))","decl":"theorem sort_cons (a : α) (s : Multiset α) :\n    (∀ b ∈ s, r a b) → sort r (a ::ₘ s) = a :: sort r s := by\n  refine Quot.inductionOn s fun l => ?_\n  simpa [mergeSort_eq_insertionSort] using insertionSort_cons r (a := a) (l := l)\n\n"}
{"name":"Multiset.sort_range","module":"Mathlib.Data.Multiset.Sort","initialProofState":"n : Nat\n⊢ Eq (Multiset.sort (fun x1 x2 => LE.le x1 x2) (Multiset.range n)) (List.range n)","decl":"@[simp]\ntheorem sort_range (n : ℕ) : sort (· ≤ ·) (range n) = List.range n :=\n  List.mergeSort_eq_self (sorted_le_range n)\n\n"}
