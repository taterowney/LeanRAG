{"name":"CategoryTheory.Limits.asEmptyCone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nX_1 : CategoryTheory.Discrete PEmpty.{1}\n‚ä¢ Eq ((CategoryTheory.Limits.asEmptyCone X).œÄ.app X_1) (id (CategoryTheory.Discrete.casesOn X_1 fun as => ‚ãØ.elim))","decl":"/-- Construct a cone for the empty diagram given an object. -/\n@[simps]\ndef asEmptyCone (X : C) : Cone (Functor.empty.{0} C) :=\n  { pt := X\n    œÄ :=\n    { app := by aesop_cat } }\n\n"}
{"name":"CategoryTheory.Limits.asEmptyCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.Limits.asEmptyCone X).pt X","decl":"/-- Construct a cone for the empty diagram given an object. -/\n@[simps]\ndef asEmptyCone (X : C) : Cone (Functor.empty.{0} C) :=\n  { pt := X\n    œÄ :=\n    { app := by aesop_cat } }\n\n"}
{"name":"CategoryTheory.Limits.asEmptyCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nX_1 : CategoryTheory.Discrete PEmpty.{1}\n‚ä¢ Eq ((CategoryTheory.Limits.asEmptyCocone X).Œπ.app X_1) (id (CategoryTheory.Discrete.casesOn X_1 fun as => ‚ãØ.elim))","decl":"/-- Construct a cocone for the empty diagram given an object. -/\n@[simps]\ndef asEmptyCocone (X : C) : Cocone (Functor.empty.{0} C) :=\n  { pt := X\n    Œπ :=\n    { app := by aesop_cat } }\n\n"}
{"name":"CategoryTheory.Limits.asEmptyCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.Limits.asEmptyCocone X).pt X","decl":"/-- Construct a cocone for the empty diagram given an object. -/\n@[simps]\ndef asEmptyCocone (X : C) : Cocone (Functor.empty.{0} C) :=\n  { pt := X\n    Œπ :=\n    { app := by aesop_cat } }\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsTerminal X\nf g : Quiver.Hom Y X\n‚ä¢ Eq f g","decl":"/-- Any two morphisms to a terminal object are equal. -/\ntheorem IsTerminal.hom_ext {X Y : C} (t : IsTerminal X) (f g : Y ‚ü∂ X) : f = g :=\n  IsLimit.hom_ext t (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.comp_from","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nZ : C\nt : CategoryTheory.Limits.IsTerminal Z\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (t.from Y)) (t.from X)","decl":"@[simp]\ntheorem IsTerminal.comp_from {Z : C} (t : IsTerminal Z) {X Y : C} (f : X ‚ü∂ Y) :\n    f ‚â´ t.from Y = t.from X :=\n  t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.from_self","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nt : CategoryTheory.Limits.IsTerminal X\n‚ä¢ Eq (t.from X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem IsTerminal.from_self {X : C} (t : IsTerminal X) : t.from X = ùüô X :=\n  t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsInitial X\nf g : Quiver.Hom X Y\n‚ä¢ Eq f g","decl":"/-- Any two morphisms from an initial object are equal. -/\ntheorem IsInitial.hom_ext {X Y : C} (t : IsInitial X) (f g : X ‚ü∂ Y) : f = g :=\n  IsColimit.hom_ext t (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.to_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nt : CategoryTheory.Limits.IsInitial X\nY Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.to Y) f) (t.to Z)","decl":"@[simp]\ntheorem IsInitial.to_comp {X : C} (t : IsInitial X) {Y Z : C} (f : Y ‚ü∂ Z) : t.to Y ‚â´ f = t.to Z :=\n  t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.to_self","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nt : CategoryTheory.Limits.IsInitial X\n‚ä¢ Eq (t.to X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem IsInitial.to_self {X : C} (t : IsInitial X) : t.to X = ùüô X :=\n  t.hom_ext _ _\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.isSplitMono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsTerminal X\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsSplitMono f","decl":"/-- Any morphism from a terminal object is split mono. -/\ntheorem IsTerminal.isSplitMono_from {X Y : C} (t : IsTerminal X) (f : X ‚ü∂ Y) : IsSplitMono f :=\n  IsSplitMono.mk' ‚ü®t.from _, t.hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.isSplitEpi_to","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsInitial X\nf : Quiver.Hom Y X\n‚ä¢ CategoryTheory.IsSplitEpi f","decl":"/-- Any morphism to an initial object is split epi. -/\ntheorem IsInitial.isSplitEpi_to {X Y : C} (t : IsInitial X) (f : Y ‚ü∂ X) : IsSplitEpi f :=\n  IsSplitEpi.mk' ‚ü®t.to _, t.hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.mono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsTerminal X\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Mono f","decl":"/-- Any morphism from a terminal object is mono. -/\ntheorem IsTerminal.mono_from {X Y : C} (t : IsTerminal X) (f : X ‚ü∂ Y) : Mono f := by\n  haveI := t.isSplitMono_from f; infer_instance\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.epi_to","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nt : CategoryTheory.Limits.IsInitial X\nf : Quiver.Hom Y X\n‚ä¢ CategoryTheory.Epi f","decl":"/-- Any morphism to an initial object is epi. -/\ntheorem IsInitial.epi_to {X Y : C} (t : IsInitial X) (f : Y ‚ü∂ X) : Epi f := by\n  haveI := t.isSplitEpi_to f; infer_instance\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT T' : C\nhT : CategoryTheory.Limits.IsTerminal T\nhT' : CategoryTheory.Limits.IsTerminal T'\n‚ä¢ Eq (hT.uniqueUpToIso hT').hom (hT'.from T)","decl":"/-- If `T` and `T'` are terminal, they are isomorphic. -/\n@[simps]\ndef IsTerminal.uniqueUpToIso {T T' : C} (hT : IsTerminal T) (hT' : IsTerminal T') : T ‚âÖ T' where\n  hom := hT'.from _\n  inv := hT.from _\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT T' : C\nhT : CategoryTheory.Limits.IsTerminal T\nhT' : CategoryTheory.Limits.IsTerminal T'\n‚ä¢ Eq (hT.uniqueUpToIso hT').inv (hT.from T')","decl":"/-- If `T` and `T'` are terminal, they are isomorphic. -/\n@[simps]\ndef IsTerminal.uniqueUpToIso {T T' : C} (hT : IsTerminal T) (hT' : IsTerminal T') : T ‚âÖ T' where\n  hom := hT'.from _\n  inv := hT.from _\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI I' : C\nhI : CategoryTheory.Limits.IsInitial I\nhI' : CategoryTheory.Limits.IsInitial I'\n‚ä¢ Eq (hI.uniqueUpToIso hI').inv (hI'.to I)","decl":"/-- If `I` and `I'` are initial, they are isomorphic. -/\n@[simps]\ndef IsInitial.uniqueUpToIso {I I' : C} (hI : IsInitial I) (hI' : IsInitial I') : I ‚âÖ I' where\n  hom := hI.to _\n  inv := hI'.to _\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI I' : C\nhI : CategoryTheory.Limits.IsInitial I\nhI' : CategoryTheory.Limits.IsInitial I'\n‚ä¢ Eq (hI.uniqueUpToIso hI').hom (hI.to I')","decl":"/-- If `I` and `I'` are initial, they are isomorphic. -/\n@[simps]\ndef IsInitial.uniqueUpToIso {I I' : C} (hI : IsInitial I) (hI' : IsInitial I') : I ‚âÖ I' where\n  hom := hI.to _\n  inv := hI'.to _\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.isInitial_mono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Limits.InitialMonoClass C\nI X : C\nhI : CategoryTheory.Limits.IsInitial I\n‚ä¢ CategoryTheory.Mono (hI.to X)","decl":"/-- A category is an `InitialMonoClass` if the canonical morphism of an initial object is a\nmonomorphism.  In practice, this is most useful when given an arbitrary morphism out of the chosen\ninitial object, see `initial.mono_from`.\nGiven a terminal object, this is equivalent to the assumption that the unique morphism from initial\nto terminal is a monomorphism, which is the second of Freyd's axioms for an AT category.\n\nTODO: This is a condition satisfied by categories with zero objects and morphisms.\n-/\nclass InitialMonoClass (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] : Prop where\n  /-- The map from the (any as stated) initial object to any other object is a\n    monomorphism -/\n  isInitial_mono_from : ‚àÄ {I} (X : C) (hI : IsInitial I), Mono (hI.to X)\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.mono_from","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.InitialMonoClass C\nI X : C\nhI : CategoryTheory.Limits.IsInitial I\nf : Quiver.Hom I X\n‚ä¢ CategoryTheory.Mono f","decl":"theorem IsInitial.mono_from [InitialMonoClass C] {I} {X : C} (hI : IsInitial I) (f : I ‚ü∂ X) :\n    Mono f := by\n  rw [hI.hom_ext f (hI.to X)]\n  apply InitialMonoClass.isInitial_mono_from\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : C\nhI : CategoryTheory.Limits.IsInitial I\nh : ‚àÄ (X : C), CategoryTheory.Mono (hI.to X)\n‚ä¢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. -/\ntheorem InitialMonoClass.of_isInitial {I : C} (hI : IsInitial I) (h : ‚àÄ X, Mono (hI.to X)) :\n    InitialMonoClass C where\n  isInitial_mono_from {I'} X hI' := by\n    rw [hI'.hom_ext (hI'.to X) ((hI'.uniqueUpToIso hI).hom ‚â´ hI.to X)]\n    apply mono_comp\n\n"}
{"name":"CategoryTheory.Limits.InitialMonoClass.of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI T : C\nhI : CategoryTheory.Limits.IsInitial I\nhT : CategoryTheory.Limits.IsTerminal T\nx‚úù : CategoryTheory.Mono (hI.to T)\n‚ä¢ CategoryTheory.Limits.InitialMonoClass C","decl":"/-- To show a category is an `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. -/\ntheorem InitialMonoClass.of_isTerminal {I T : C} (hI : IsInitial I) (hT : IsTerminal T)\n    (_ : Mono (hI.to T)) : InitialMonoClass C :=\n  InitialMonoClass.of_isInitial hI fun X => mono_of_mono_fac (hI.hom_ext (_ ‚â´ hT.from X) (hI.to T))\n\n"}
{"name":"CategoryTheory.Limits.coneOfDiagramInitial_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nX : J\ntX : CategoryTheory.Limits.IsInitial X\nF : CategoryTheory.Functor J C\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.coneOfDiagramInitial tX F).œÄ.app j) (F.map (tX.to j))","decl":"/-- From a functor `F : J ‚•§ C`, given an initial object of `J`, construct a cone for `J`.\nIn `limitOfDiagramInitial` we show it is a limit cone. -/\n@[simps]\ndef coneOfDiagramInitial {X : J} (tX : IsInitial X) (F : J ‚•§ C) : Cone F where\n  pt := F.obj X\n  œÄ :=\n    { app := fun j => F.map (tX.to j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [‚Üê F.map_comp, Category.id_comp, tX.hom_ext (tX.to j ‚â´ k) (tX.to j')] }\n\n"}
{"name":"CategoryTheory.Limits.coneOfDiagramInitial_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nX : J\ntX : CategoryTheory.Limits.IsInitial X\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.coneOfDiagramInitial tX F).pt (F.obj X)","decl":"/-- From a functor `F : J ‚•§ C`, given an initial object of `J`, construct a cone for `J`.\nIn `limitOfDiagramInitial` we show it is a limit cone. -/\n@[simps]\ndef coneOfDiagramInitial {X : J} (tX : IsInitial X) (F : J ‚•§ C) : Cone F where\n  pt := F.obj X\n  œÄ :=\n    { app := fun j => F.map (tX.to j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [‚Üê F.map_comp, Category.id_comp, tX.hom_ext (tX.to j ‚â´ k) (tX.to j')] }\n\n"}
{"name":"CategoryTheory.Limits.coneOfDiagramTerminal_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\nX : J\nhX : CategoryTheory.Limits.IsTerminal X\nF : CategoryTheory.Functor J C\ninst‚úù : ‚àÄ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nx‚úù : J\n‚ä¢ Eq ((CategoryTheory.Limits.coneOfDiagramTerminal hX F).œÄ.app x‚úù) (CategoryTheory.inv (F.map (hX.from x‚úù)))","decl":"/-- From a functor `F : J ‚•§ C`, given a terminal object of `J`, construct a cone for `J`,\nprovided that the morphisms in the diagram are isomorphisms.\nIn `limitOfDiagramTerminal` we show it is a limit cone. -/\n@[simps]\ndef coneOfDiagramTerminal {X : J} (hX : IsTerminal X) (F : J ‚•§ C)\n    [‚àÄ (i j : J) (f : i ‚ü∂ j), IsIso (F.map f)] : Cone F where\n  pt := F.obj X\n  œÄ :=\n    { app := fun _ => inv (F.map (hX.from _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.id_comp, ‚Üê F.map_comp,\n          hX.hom_ext (hX.from i) (f ‚â´ hX.from j)] }\n\n"}
{"name":"CategoryTheory.Limits.coneOfDiagramTerminal_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\nX : J\nhX : CategoryTheory.Limits.IsTerminal X\nF : CategoryTheory.Functor J C\ninst‚úù : ‚àÄ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n‚ä¢ Eq (CategoryTheory.Limits.coneOfDiagramTerminal hX F).pt (F.obj X)","decl":"/-- From a functor `F : J ‚•§ C`, given a terminal object of `J`, construct a cone for `J`,\nprovided that the morphisms in the diagram are isomorphisms.\nIn `limitOfDiagramTerminal` we show it is a limit cone. -/\n@[simps]\ndef coneOfDiagramTerminal {X : J} (hX : IsTerminal X) (F : J ‚•§ C)\n    [‚àÄ (i j : J) (f : i ‚ü∂ j), IsIso (F.map f)] : Cone F where\n  pt := F.obj X\n  œÄ :=\n    { app := fun _ => inv (F.map (hX.from _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.id_comp, ‚Üê F.map_comp,\n          hX.hom_ext (hX.from i) (f ‚â´ hX.from j)] }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfDiagramTerminal_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nX : J\ntX : CategoryTheory.Limits.IsTerminal X\nF : CategoryTheory.Functor J C\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.coconeOfDiagramTerminal tX F).Œπ.app j) (F.map (tX.from j))","decl":"/-- From a functor `F : J ‚•§ C`, given a terminal object of `J`, construct a cocone for `J`.\nIn `colimitOfDiagramTerminal` we show it is a colimit cocone. -/\n@[simps]\ndef coconeOfDiagramTerminal {X : J} (tX : IsTerminal X) (F : J ‚•§ C) : Cocone F where\n  pt := F.obj X\n  Œπ :=\n    { app := fun j => F.map (tX.from j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [‚Üê F.map_comp, Category.comp_id, tX.hom_ext (k ‚â´ tX.from j') (tX.from j)] }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfDiagramTerminal_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nX : J\ntX : CategoryTheory.Limits.IsTerminal X\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfDiagramTerminal tX F).pt (F.obj X)","decl":"/-- From a functor `F : J ‚•§ C`, given a terminal object of `J`, construct a cocone for `J`.\nIn `colimitOfDiagramTerminal` we show it is a colimit cocone. -/\n@[simps]\ndef coconeOfDiagramTerminal {X : J} (tX : IsTerminal X) (F : J ‚•§ C) : Cocone F where\n  pt := F.obj X\n  Œπ :=\n    { app := fun j => F.map (tX.from j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [‚Üê F.map_comp, Category.comp_id, tX.hom_ext (k ‚â´ tX.from j') (tX.from j)] }\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.isIso_Œπ_app_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nX : J\nhX : CategoryTheory.Limits.IsTerminal X\n‚ä¢ CategoryTheory.IsIso (c.Œπ.app X)","decl":"lemma IsColimit.isIso_Œπ_app_of_isTerminal {F : J ‚•§ C} {c : Cocone F} (hc : IsColimit c)\n    (X : J) (hX : IsTerminal X) :\n    IsIso (c.Œπ.app X) := by\n  change IsIso (coconePointUniqueUpToIso (colimitOfDiagramTerminal hX F) hc).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.coconeOfDiagramInitial_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\nX : J\nhX : CategoryTheory.Limits.IsInitial X\nF : CategoryTheory.Functor J C\ninst‚úù : ‚àÄ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfDiagramInitial hX F).pt (F.obj X)","decl":"/-- From a functor `F : J ‚•§ C`, given an initial object of `J`, construct a cocone for `J`,\nprovided that the morphisms in the diagram are isomorphisms.\nIn `colimitOfDiagramInitial` we show it is a colimit cocone. -/\n@[simps]\ndef coconeOfDiagramInitial {X : J} (hX : IsInitial X) (F : J ‚•§ C)\n    [‚àÄ (i j : J) (f : i ‚ü∂ j), IsIso (F.map f)] : Cocone F where\n  pt := F.obj X\n  Œπ :=\n    { app := fun _ => inv (F.map (hX.to _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.comp_id, ‚Üê F.map_comp,\n          hX.hom_ext (hX.to i ‚â´ f) (hX.to j)] }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfDiagramInitial_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\nX : J\nhX : CategoryTheory.Limits.IsInitial X\nF : CategoryTheory.Functor J C\ninst‚úù : ‚àÄ (i j : J) (f : Quiver.Hom i j), CategoryTheory.IsIso (F.map f)\nx‚úù : J\n‚ä¢ Eq ((CategoryTheory.Limits.coconeOfDiagramInitial hX F).Œπ.app x‚úù) (CategoryTheory.inv (F.map (hX.to x‚úù)))","decl":"/-- From a functor `F : J ‚•§ C`, given an initial object of `J`, construct a cocone for `J`,\nprovided that the morphisms in the diagram are isomorphisms.\nIn `colimitOfDiagramInitial` we show it is a colimit cocone. -/\n@[simps]\ndef coconeOfDiagramInitial {X : J} (hX : IsInitial X) (F : J ‚•§ C)\n    [‚àÄ (i j : J) (f : i ‚ü∂ j), IsIso (F.map f)] : Cocone F where\n  pt := F.obj X\n  Œπ :=\n    { app := fun _ => inv (F.map (hX.to _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.comp_id, ‚Üê F.map_comp,\n          hX.hom_ext (hX.to i ‚â´ f) (hX.to j)] }\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.isIso_œÄ_app_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nX : J\nhX : CategoryTheory.Limits.IsInitial X\n‚ä¢ CategoryTheory.IsIso (c.œÄ.app X)","decl":"lemma IsLimit.isIso_œÄ_app_of_isInitial {F : J ‚•§ C} {c : Cone F} (hc : IsLimit c)\n    (X : J) (hX : IsInitial X) :\n    IsIso (c.œÄ.app X) := by\n  change IsIso (conePointUniqueUpToIso hc (limitOfDiagramInitial hX F)).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.isIso_of_isTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nhX : CategoryTheory.Limits.IsTerminal X\nhY : CategoryTheory.Limits.IsTerminal Y\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any morphism between terminal objects is an isomorphism. -/\nlemma isIso_of_isTerminal {X Y : C} (hX : IsTerminal X) (hY : IsTerminal Y) (f : X ‚ü∂ Y) :\n    IsIso f := by\n  refine ‚ü®‚ü®IsTerminal.from hX Y, ?_‚ü©‚ü©\n  simp only [IsTerminal.comp_from, IsTerminal.from_self, true_and]\n  apply IsTerminal.hom_ext hY\n\n"}
{"name":"CategoryTheory.Limits.isIso_of_isInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.IsTerminal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nhX : CategoryTheory.Limits.IsInitial X\nhY : CategoryTheory.Limits.IsInitial Y\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any morphism between initial objects is an isomorphism. -/\nlemma isIso_of_isInitial {X Y : C} (hX : IsInitial X) (hY : IsInitial Y) (f : X ‚ü∂ Y) :\n    IsIso f := by\n  refine ‚ü®‚ü®IsInitial.to hY X, ?_‚ü©‚ü©\n  simp only [IsInitial.to_comp, IsInitial.to_self, and_true]\n  apply IsInitial.hom_ext hX\n\n"}
