{"name":"Cardinal.canLiftCardinalType","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ CanLift Cardinal.{u} (Type u) Cardinal.mk fun x => True","decl":"instance canLiftCardinalType : CanLift Cardinal.{u} (Type u) mk fun _ => True :=\n  ‚ü®fun c _ => Quot.inductionOn c fun Œ± => ‚ü®Œ±, rfl‚ü©‚ü©\n\n"}
{"name":"Cardinal.inductionOn","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} ‚Üí Prop\nc : Cardinal.{u_1}\nh : ‚àÄ (Œ± : Type u_1), p (Cardinal.mk Œ±)\n‚ä¢ p c","decl":"@[elab_as_elim]\ntheorem inductionOn {p : Cardinal ‚Üí Prop} (c : Cardinal) (h : ‚àÄ Œ±, p #Œ±) : p c :=\n  Quotient.inductionOn c h\n\n"}
{"name":"Cardinal.inductionOn‚ÇÇ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} ‚Üí Cardinal.{u_2} ‚Üí Prop\nc‚ÇÅ : Cardinal.{u_1}\nc‚ÇÇ : Cardinal.{u_2}\nh : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2), p (Cardinal.mk Œ±) (Cardinal.mk Œ≤)\n‚ä¢ p c‚ÇÅ c‚ÇÇ","decl":"@[elab_as_elim]\ntheorem inductionOn‚ÇÇ {p : Cardinal ‚Üí Cardinal ‚Üí Prop} (c‚ÇÅ : Cardinal) (c‚ÇÇ : Cardinal)\n    (h : ‚àÄ Œ± Œ≤, p #Œ± #Œ≤) : p c‚ÇÅ c‚ÇÇ :=\n  Quotient.inductionOn‚ÇÇ c‚ÇÅ c‚ÇÇ h\n\n"}
{"name":"Cardinal.inductionOn‚ÇÉ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} ‚Üí Cardinal.{u_2} ‚Üí Cardinal.{u_3} ‚Üí Prop\nc‚ÇÅ : Cardinal.{u_1}\nc‚ÇÇ : Cardinal.{u_2}\nc‚ÇÉ : Cardinal.{u_3}\nh : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3), p (Cardinal.mk Œ±) (Cardinal.mk Œ≤) (Cardinal.mk Œ≥)\n‚ä¢ p c‚ÇÅ c‚ÇÇ c‚ÇÉ","decl":"@[elab_as_elim]\ntheorem inductionOn‚ÇÉ {p : Cardinal ‚Üí Cardinal ‚Üí Cardinal ‚Üí Prop} (c‚ÇÅ : Cardinal) (c‚ÇÇ : Cardinal)\n    (c‚ÇÉ : Cardinal) (h : ‚àÄ Œ± Œ≤ Œ≥, p #Œ± #Œ≤ #Œ≥) : p c‚ÇÅ c‚ÇÇ c‚ÇÉ :=\n  Quotient.inductionOn‚ÇÉ c‚ÇÅ c‚ÇÇ c‚ÇÉ h\n\n"}
{"name":"Cardinal.induction_on_pi","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\np : (Œπ ‚Üí Cardinal.{v}) ‚Üí Prop\nf : Œπ ‚Üí Cardinal.{v}\nh : ‚àÄ (f : Œπ ‚Üí Type v), p fun i => Cardinal.mk (f i)\n‚ä¢ p f","decl":"theorem induction_on_pi {Œπ : Type u} {p : (Œπ ‚Üí Cardinal.{v}) ‚Üí Prop}\n    (f : Œπ ‚Üí Cardinal.{v}) (h : ‚àÄ f : Œπ ‚Üí Type v, p fun i ‚Ü¶ #(f i)) : p f :=\n  Quotient.induction_on_pi f h\n\n"}
{"name":"Cardinal.eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) (Cardinal.mk Œ≤)) (Nonempty (Equiv Œ± Œ≤))","decl":"protected theorem eq : #Œ± = #Œ≤ ‚Üî Nonempty (Œ± ‚âÉ Œ≤) :=\n  Quotient.eq'\n\n"}
{"name":"Cardinal.mk'_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Quotient.mk Cardinal.isEquivalent Œ±) (Cardinal.mk Œ±)","decl":"/-- Avoid using `Quotient.mk` to construct a `Cardinal` directly -/\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-24\")]\ntheorem mk'_def (Œ± : Type u) : @Eq Cardinal ‚ü¶Œ±‚üß #Œ± :=\n  rfl\n\n"}
{"name":"Cardinal.mk_out","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Eq (Cardinal.mk (Quotient.out c)) c","decl":"@[simp]\ntheorem mk_out (c : Cardinal) : #c.out = c :=\n  Quotient.out_eq _\n\n"}
{"name":"Cardinal.mk_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (Cardinal.mk Œ±) (Cardinal.mk Œ≤)","decl":"theorem mk_congr (e : Œ± ‚âÉ Œ≤) : #Œ± = #Œ≤ :=\n  Quot.sound ‚ü®e‚ü©\n\n"}
{"name":"Equiv.cardinal_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (Cardinal.mk Œ±) (Cardinal.mk Œ≤)","decl":"alias _root_.Equiv.cardinal_eq := mk_congr\n\n"}
{"name":"Cardinal.map_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Type u ‚Üí Type v\nhf : (Œ± Œ≤ : Type u) ‚Üí Equiv Œ± Œ≤ ‚Üí Equiv (f Œ±) (f Œ≤)\nŒ± : Type u\n‚ä¢ Eq (Cardinal.map f hf (Cardinal.mk Œ±)) (Cardinal.mk (f Œ±))","decl":"@[simp]\ntheorem map_mk (f : Type u ‚Üí Type v) (hf : ‚àÄ Œ± Œ≤, Œ± ‚âÉ Œ≤ ‚Üí f Œ± ‚âÉ f Œ≤) (Œ± : Type u) :\n    map f hf #Œ± = #(f Œ±) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_uLift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (ULift.{v, u} Œ±)) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"@[simp]\ntheorem mk_uLift (Œ±) : #(ULift.{v, u} Œ±) = lift.{v} #Œ± :=\n  rfl\n\n"}
{"name":"Cardinal.lift_umax","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq Cardinal.lift.{max u v, u} Cardinal.lift.{v, u}","decl":"/-- `lift.{max u v, u}` equals `lift.{v, u}`.\n\nUnfortunately, the simp lemma doesn't work. -/\ntheorem lift_umax : lift.{max u v, u} = lift.{v, u} :=\n  funext fun a => inductionOn a fun _ => (Equiv.ulift.trans Equiv.ulift.symm).cardinal_eq\n\n"}
{"name":"Cardinal.lift_umax'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq Cardinal.lift.{max v u, u} Cardinal.lift.{v, u}","decl":"/-- `lift.{max v u, u}` equals `lift.{v, u}`. -/\n@[deprecated lift_umax (since := \"2024-10-24\")]\ntheorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=\n  lift_umax\n\n"}
{"name":"Cardinal.lift_id'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{max u v}\n‚ä¢ Eq (Cardinal.lift.{u, max u v} a) a","decl":"/-- A cardinal lifted to a lower or equal universe equals itself.\n\nUnfortunately, the simp lemma doesn't work. -/\ntheorem lift_id' (a : Cardinal.{max u v}) : lift.{u} a = a :=\n  inductionOn a fun _ => mk_congr Equiv.ulift\n\n"}
{"name":"Cardinal.lift_id","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{u, u} a) a","decl":"/-- A cardinal lifted to the same universe equals itself. -/\n@[simp]\ntheorem lift_id (a : Cardinal) : lift.{u, u} a = a :=\n  lift_id'.{u, u} a\n\n"}
{"name":"Cardinal.lift_uzero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{0, u} a) a","decl":"/-- A cardinal lifted to the zero universe equals itself. -/\n@[simp]\ntheorem lift_uzero (a : Cardinal.{u}) : lift.{0} a = a :=\n  lift_id'.{0, u} a\n\n"}
{"name":"Cardinal.lift_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Eq (Cardinal.lift.{w, max v u_1} (Cardinal.lift.{v, u_1} a)) (Cardinal.lift.{max v w, u_1} a)","decl":"@[simp]\ntheorem lift_lift.{u_1} (a : Cardinal.{u_1}) : lift.{w} (lift.{v} a) = lift.{max v w} a :=\n  inductionOn a fun _ => (Equiv.ulift.trans <| Equiv.ulift.trans Equiv.ulift.symm).cardinal_eq\n\n"}
{"name":"Cardinal.out_lift_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Nonempty (Equiv (Quotient.out (Cardinal.lift.{v, u} a)) (Quotient.out a))","decl":"theorem out_lift_equiv (a : Cardinal.{u}) : Nonempty ((lift.{v} a).out ‚âÉ a.out) := by\n  rw [‚Üê mk_out a, ‚Üê mk_uLift, mk_out]\n  exact ‚ü®outMkEquiv.trans Equiv.ulift‚ü©\n\n"}
{"name":"Cardinal.mk_preimage_down","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.preimage ULift.down s)) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üës))","decl":"@[simp]\nlemma mk_preimage_down {s : Set Œ±} : #(ULift.down.{v} ‚Åª¬π' s) = lift.{v} (#s) := by\n  rw [‚Üê mk_uLift, Cardinal.eq]\n  constructor\n  let f : ULift.down ‚Åª¬π' s ‚Üí ULift s := fun x ‚Ü¶ ULift.up (restrictPreimage s ULift.down x)\n  have : Function.Bijective f :=\n    ULift.up_bijective.comp (restrictPreimage_bijective _ (ULift.down_bijective))\n  exact Equiv.ofBijective f this\n\n"}
{"name":"Cardinal.lift_mk_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Iff (Eq (Cardinal.lift.{max v w, u} (Cardinal.mk Œ±)) (Cardinal.lift.{max u w, v} (Cardinal.mk Œ≤))) (Nonempty (Equiv Œ± Œ≤))","decl":"theorem lift_mk_eq {Œ± : Type u} {Œ≤ : Type v} :\n    lift.{max v w} #Œ± = lift.{max u w} #Œ≤ ‚Üî Nonempty (Œ± ‚âÉ Œ≤) :=\n  Quotient.eq'.trans\n    ‚ü®fun ‚ü®f‚ü© => ‚ü®Equiv.ulift.symm.trans <| f.trans Equiv.ulift‚ü©, fun ‚ü®f‚ü© =>\n      ‚ü®Equiv.ulift.trans <| f.trans Equiv.ulift.symm‚ü©‚ü©\n\n"}
{"name":"Cardinal.lift_mk_eq'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Iff (Eq (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))) (Nonempty (Equiv Œ± Œ≤))","decl":"/-- A variant of `Cardinal.lift_mk_eq` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_eq' {Œ± : Type u} {Œ≤ : Type v} : lift.{v} #Œ± = lift.{u} #Œ≤ ‚Üî Nonempty (Œ± ‚âÉ Œ≤) :=\n  lift_mk_eq.{u, v, 0}\n\n"}
{"name":"Cardinal.mk_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))","decl":"theorem mk_congr_lift {Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) : lift.{v} #Œ± = lift.{u} #Œ≤ :=\n  lift_mk_eq'.2 ‚ü®e‚ü©\n\n"}
{"name":"Equiv.lift_cardinal_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))","decl":"alias _root_.Equiv.lift_cardinal_eq := mk_congr_lift\n\n-- Porting note: simpNF is not happy with universe levels.\n"}
{"name":"Cardinal.lift_mk_shrink","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Small.{v, u} Œ±\n‚ä¢ Eq (Cardinal.lift.{max u w, v} (Cardinal.mk (Shrink.{v, u} Œ±))) (Cardinal.lift.{max v w, u} (Cardinal.mk Œ±))","decl":"@[simp, nolint simpNF]\ntheorem lift_mk_shrink (Œ± : Type u) [Small.{v} Œ±] :\n    Cardinal.lift.{max u w} #(Shrink.{v} Œ±) = Cardinal.lift.{max v w} #Œ± :=\n  lift_mk_eq.2 ‚ü®(equivShrink Œ±).symm‚ü©\n\n"}
{"name":"Cardinal.lift_mk_shrink'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Small.{v, u} Œ±\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, u} Œ±))) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"@[simp]\ntheorem lift_mk_shrink' (Œ± : Type u) [Small.{v} Œ±] :\n    Cardinal.lift.{u} #(Shrink.{v} Œ±) = Cardinal.lift.{v} #Œ± :=\n  lift_mk_shrink.{u, v, 0} Œ±\n\n"}
{"name":"Cardinal.lift_mk_shrink''","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type (max u v)\ninst‚úù : Small.{v, max u v} Œ±\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, max u v} Œ±))) (Cardinal.mk Œ±)","decl":"@[simp]\ntheorem lift_mk_shrink'' (Œ± : Type max u v) [Small.{v} Œ±] :\n    Cardinal.lift.{u} #(Shrink.{v} Œ±) = #Œ± := by\n  rw [‚Üê lift_umax, lift_mk_shrink.{max u v, v, 0} Œ±, ‚Üê lift_umax, lift_id]\n\n"}
{"name":"Cardinal.le_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Iff (LE.le (Cardinal.mk Œ±) (Cardinal.mk Œ≤)) (Nonempty (Function.Embedding Œ± Œ≤))","decl":"theorem le_def (Œ± Œ≤ : Type u) : #Œ± ‚â§ #Œ≤ ‚Üî Nonempty (Œ± ‚Ü™ Œ≤) :=\n  Iff.rfl\n\n"}
{"name":"Cardinal.mk_le_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ LE.le (Cardinal.mk Œ±) (Cardinal.mk Œ≤)","decl":"theorem mk_le_of_injective {Œ± Œ≤ : Type u} {f : Œ± ‚Üí Œ≤} (hf : Injective f) : #Œ± ‚â§ #Œ≤ :=\n  ‚ü®‚ü®f, hf‚ü©‚ü©\n\n"}
{"name":"Function.Embedding.cardinal_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Function.Embedding Œ± Œ≤\n‚ä¢ LE.le (Cardinal.mk Œ±) (Cardinal.mk Œ≤)","decl":"theorem _root_.Function.Embedding.cardinal_le {Œ± Œ≤ : Type u} (f : Œ± ‚Ü™ Œ≤) : #Œ± ‚â§ #Œ≤ :=\n  ‚ü®f‚ü©\n\n"}
{"name":"Cardinal.mk_le_of_surjective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\nhf : Function.Surjective f\n‚ä¢ LE.le (Cardinal.mk Œ≤) (Cardinal.mk Œ±)","decl":"theorem mk_le_of_surjective {Œ± Œ≤ : Type u} {f : Œ± ‚Üí Œ≤} (hf : Surjective f) : #Œ≤ ‚â§ #Œ± :=\n  ‚ü®Embedding.ofSurjective f hf‚ü©\n\n"}
{"name":"Cardinal.le_mk_iff_exists_set","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\nŒ± : Type u\n‚ä¢ Iff (LE.le c (Cardinal.mk Œ±)) (Exists fun p => Eq (Cardinal.mk ‚Üëp) c)","decl":"theorem le_mk_iff_exists_set {c : Cardinal} {Œ± : Type u} : c ‚â§ #Œ± ‚Üî ‚àÉ p : Set Œ±, #p = c :=\n  ‚ü®inductionOn c fun _ ‚ü®‚ü®f, hf‚ü©‚ü© => ‚ü®Set.range f, (Equiv.ofInjective f hf).cardinal_eq.symm‚ü©,\n    fun ‚ü®_, e‚ü© => e ‚ñ∏ ‚ü®‚ü®Subtype.val, fun _ _ => Subtype.eq‚ü©‚ü©‚ü©\n\n"}
{"name":"Cardinal.mk_subtype_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\np : Œ± ‚Üí Prop\n‚ä¢ LE.le (Cardinal.mk (Subtype p)) (Cardinal.mk Œ±)","decl":"theorem mk_subtype_le {Œ± : Type u} (p : Œ± ‚Üí Prop) : #(Subtype p) ‚â§ #Œ± :=\n  ‚ü®Embedding.subtype p‚ü©\n\n"}
{"name":"Cardinal.mk_set_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üës) (Cardinal.mk Œ±)","decl":"theorem mk_set_le (s : Set Œ±) : #s ‚â§ #Œ± :=\n  mk_subtype_le s\n\n"}
{"name":"Cardinal.out_embedding","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c c' : Cardinal.{u_1}\n‚ä¢ Iff (LE.le c c') (Nonempty (Function.Embedding (Quotient.out c) (Quotient.out c')))","decl":"theorem out_embedding {c c' : Cardinal} : c ‚â§ c' ‚Üî Nonempty (c.out ‚Ü™ c'.out) := by\n  conv_lhs => rw [‚Üê Cardinal.mk_out c, ‚Üê Cardinal.mk_out c', le_def]\n\n"}
{"name":"Cardinal.lift_mk_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type v\nŒ≤ : Type w\n‚ä¢ Iff (LE.le (Cardinal.lift.{max u w, v} (Cardinal.mk Œ±)) (Cardinal.lift.{max u v, w} (Cardinal.mk Œ≤))) (Nonempty (Function.Embedding Œ± Œ≤))","decl":"theorem lift_mk_le {Œ± : Type v} {Œ≤ : Type w} :\n    lift.{max u w} #Œ± ‚â§ lift.{max u v} #Œ≤ ‚Üî Nonempty (Œ± ‚Ü™ Œ≤) :=\n  ‚ü®fun ‚ü®f‚ü© => ‚ü®Embedding.congr Equiv.ulift Equiv.ulift f‚ü©, fun ‚ü®f‚ü© =>\n    ‚ü®Embedding.congr Equiv.ulift.symm Equiv.ulift.symm f‚ü©‚ü©\n\n"}
{"name":"Cardinal.lift_mk_le'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Iff (LE.le (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))) (Nonempty (Function.Embedding Œ± Œ≤))","decl":"/-- A variant of `Cardinal.lift_mk_le` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_le' {Œ± : Type u} {Œ≤ : Type v} : lift.{v} #Œ± ‚â§ lift.{u} #Œ≤ ‚Üî Nonempty (Œ± ‚Ü™ Œ≤) :=\n  lift_mk_le.{0}\n\n"}
{"name":"Cardinal.liftInitialSeg_toFun","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Eq (Cardinal.liftInitialSeg c) (Cardinal.lift.{v, u} c)","decl":"/-- `Cardinal.lift` as an `InitialSeg`. -/\n@[simps!]\ndef liftInitialSeg : Cardinal.{u} ‚â§i Cardinal.{max u v} := by\n  refine ‚ü®(OrderEmbedding.ofMapLEIff lift ?_).ltEmbedding, ?_‚ü© <;> intro a b\n  ¬∑ refine inductionOn‚ÇÇ a b fun _ _ ‚Ü¶ ?_\n    rw [‚Üê lift_umax, lift_mk_le.{v, u, u}, le_def]\n  ¬∑ refine inductionOn‚ÇÇ a b fun Œ± Œ≤ h ‚Ü¶ ?_\n    obtain ‚ü®e‚ü© := h.le\n    replace e := e.congr (Equiv.refl Œ≤) Equiv.ulift\n    refine ‚ü®#(range e), mk_congr (Equiv.ulift.trans <| Equiv.symm ?_)‚ü©\n    apply (e.codRestrict _ mem_range_self).equivOfSurjective\n    rintro ‚ü®a, ‚ü®b, rfl‚ü©‚ü©\n    exact ‚ü®b, rfl‚ü©\n\n"}
{"name":"Cardinal.mem_range_lift_of_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\na‚úù : LE.le b (Cardinal.lift.{v, u} a)\n‚ä¢ Membership.mem (Set.range Cardinal.lift.{v, u}) b","decl":"theorem mem_range_lift_of_le {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ‚â§ lift.{v, u} a ‚Üí b ‚àà Set.range lift.{v, u} :=\n  liftInitialSeg.mem_range_of_le\n\n"}
{"name":"Cardinal.lift_down","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\na‚úù : LE.le b (Cardinal.lift.{v, u} a)\n‚ä¢ Exists fun a' => Eq (Cardinal.lift.{v, u} a') b","decl":"@[deprecated mem_range_lift_of_le (since := \"2024-10-07\")]\ntheorem lift_down {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ‚â§ lift.{v, u} a ‚Üí ‚àÉ a', lift.{v, u} a' = b :=\n  mem_range_lift_of_le\n\n"}
{"name":"Cardinal.lift_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Function.Injective Cardinal.lift.{u, v}","decl":"theorem lift_injective : Injective lift.{u, v} :=\n  liftInitialSeg.injective\n\n"}
{"name":"Cardinal.lift_inj","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Iff (Eq (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b)) (Eq a b)","decl":"@[simp]\ntheorem lift_inj {a b : Cardinal.{u}} : lift.{v, u} a = lift.{v, u} b ‚Üî a = b :=\n  lift_injective.eq_iff\n\n"}
{"name":"Cardinal.lift_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n‚ä¢ Iff (LE.le (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b)) (LE.le a b)","decl":"@[simp]\ntheorem lift_le {a b : Cardinal.{v}} : lift.{u} a ‚â§ lift.{u} b ‚Üî a ‚â§ b :=\n  liftInitialSeg.le_iff_le\n\n"}
{"name":"Cardinal.lift_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Iff (LT.lt (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b)) (LT.lt a b)","decl":"@[simp]\ntheorem lift_lt {a b : Cardinal.{u}} : lift.{v, u} a < lift.{v, u} b ‚Üî a < b :=\n  liftInitialSeg.lt_iff_lt\n\n"}
{"name":"Cardinal.lift_strictMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ StrictMono Cardinal.lift.{u_2, u_1}","decl":"theorem lift_strictMono : StrictMono lift := fun _ _ => lift_lt.2\n\n"}
{"name":"Cardinal.lift_monotone","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Monotone Cardinal.lift.{u_2, u_1}","decl":"theorem lift_monotone : Monotone lift :=\n  lift_strictMono.monotone\n\n"}
{"name":"Cardinal.lift_min","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{u, v} (Min.min a b)) (Min.min (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_min {a b : Cardinal} : lift.{u, v} (min a b) = min (lift.{u, v} a) (lift.{u, v} b) :=\n  lift_monotone.map_min\n\n"}
{"name":"Cardinal.lift_max","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{u, v} (Max.max a b)) (Max.max (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_max {a b : Cardinal} : lift.{u, v} (max a b) = max (lift.{u, v} a) (lift.{u, v} b) :=\n  lift_monotone.map_max\n\n-- Porting note: simpNF is not happy with universe levels.\n"}
{"name":"Cardinal.lift_umax_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{v}\n‚ä¢ Iff (Eq (Cardinal.lift.{max v w, u} a) (Cardinal.lift.{max u w, v} b)) (Eq (Cardinal.lift.{v, u} a) (Cardinal.lift.{u, v} b))","decl":"@[simp, nolint simpNF]\ntheorem lift_umax_eq {a : Cardinal.{u}} {b : Cardinal.{v}} :\n    lift.{max v w} a = lift.{max u w} b ‚Üî lift.{v} a = lift.{u} b := by\n  rw [‚Üê lift_lift.{v, w, u}, ‚Üê lift_lift.{u, w, v}, lift_inj]\n\n"}
{"name":"Cardinal.le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\n‚ä¢ Iff (LE.le b (Cardinal.lift.{v, u} a)) (Exists fun a' => And (LE.le a' a) (Eq (Cardinal.lift.{v, u} a') b))","decl":"theorem le_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ‚â§ lift.{v, u} a ‚Üî ‚àÉ a' ‚â§ a, lift.{v, u} a' = b :=\n  liftInitialSeg.le_apply_iff\n\n"}
{"name":"Cardinal.lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\n‚ä¢ Iff (LT.lt b (Cardinal.lift.{v, u} a)) (Exists fun a' => And (LT.lt a' a) (Eq (Cardinal.lift.{v, u} a') b))","decl":"theorem lt_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b < lift.{v, u} a ‚Üî ‚àÉ a' < a, lift.{v, u} a' = b :=\n  liftInitialSeg.lt_apply_iff\n\n"}
{"name":"Cardinal.mk_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : IsEmpty Œ±\n‚ä¢ Eq (Cardinal.mk Œ±) 0","decl":"@[simp]\ntheorem mk_eq_zero (Œ± : Type u) [IsEmpty Œ±] : #Œ± = 0 :=\n  (Equiv.equivOfIsEmpty Œ± (ULift (Fin 0))).cardinal_eq\n\n"}
{"name":"Cardinal.lift_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.lift.{u_2, u_1} 0) 0","decl":"@[simp]\ntheorem lift_zero : lift 0 = 0 := mk_eq_zero _\n\n"}
{"name":"Cardinal.lift_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{v}\n‚ä¢ Iff (Eq (Cardinal.lift.{u, v} a) 0) (Eq a 0)","decl":"@[simp]\ntheorem lift_eq_zero {a : Cardinal.{v}} : lift.{u} a = 0 ‚Üî a = 0 :=\n  lift_injective.eq_iff' lift_zero\n\n"}
{"name":"Cardinal.mk_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) 0) (IsEmpty Œ±)","decl":"theorem mk_eq_zero_iff {Œ± : Type u} : #Œ± = 0 ‚Üî IsEmpty Œ± :=\n  ‚ü®fun e =>\n    let ‚ü®h‚ü© := Quotient.exact e\n    h.isEmpty,\n    @mk_eq_zero Œ±‚ü©\n\n"}
{"name":"Cardinal.mk_ne_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (Ne (Cardinal.mk Œ±) 0) (Nonempty Œ±)","decl":"theorem mk_ne_zero_iff {Œ± : Type u} : #Œ± ‚â† 0 ‚Üî Nonempty Œ± :=\n  (not_iff_not.2 mk_eq_zero_iff).trans not_isEmpty_iff\n\n"}
{"name":"Cardinal.mk_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Nonempty Œ±\n‚ä¢ Ne (Cardinal.mk Œ±) 0","decl":"@[simp]\ntheorem mk_ne_zero (Œ± : Type u) [Nonempty Œ±] : #Œ± ‚â† 0 :=\n  mk_ne_zero_iff.2 ‚Äπ_‚Ä∫\n\n"}
{"name":"Cardinal.instNontrivial","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Nontrivial Cardinal.{u}","decl":"instance : Nontrivial Cardinal.{u} :=\n  ‚ü®‚ü®1, 0, mk_ne_zero _‚ü©‚ü©\n\n"}
{"name":"Cardinal.mk_eq_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : Subsingleton Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Eq (Cardinal.mk Œ±) 1","decl":"theorem mk_eq_one (Œ± : Type u) [Subsingleton Œ±] [Nonempty Œ±] : #Œ± = 1 :=\n  let ‚ü®_‚ü© := nonempty_unique Œ±; (Equiv.ofUnique Œ± (ULift (Fin 1))).cardinal_eq\n\n"}
{"name":"Cardinal.le_one_iff_subsingleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LE.le (Cardinal.mk Œ±) 1) (Subsingleton Œ±)","decl":"theorem le_one_iff_subsingleton {Œ± : Type u} : #Œ± ‚â§ 1 ‚Üî Subsingleton Œ± :=\n  ‚ü®fun ‚ü®f‚ü© => ‚ü®fun _ _ => f.injective (Subsingleton.elim _ _)‚ü©, fun ‚ü®h‚ü© =>\n    ‚ü®fun _ => ULift.up 0, fun _ _ _ => h _ _‚ü©‚ü©\n\n"}
{"name":"Cardinal.mk_le_one_iff_set_subsingleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Iff (LE.le (Cardinal.mk ‚Üës) 1) s.Subsingleton","decl":"@[simp]\ntheorem mk_le_one_iff_set_subsingleton {s : Set Œ±} : #s ‚â§ 1 ‚Üî s.Subsingleton :=\n  le_one_iff_subsingleton.trans s.subsingleton_coe\n\n"}
{"name":"Set.Subsingleton.cardinalMk_le_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\na‚úù : s.Subsingleton\n‚ä¢ LE.le (Cardinal.mk ‚Üës) 1","decl":"alias ‚ü®_, _root_.Set.Subsingleton.cardinalMk_le_one‚ü© := mk_le_one_iff_set_subsingleton\n\n"}
{"name":"Set.Subsingleton.cardinal_mk_le_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\na‚úù : s.Subsingleton\n‚ä¢ LE.le (Cardinal.mk ‚Üës) 1","decl":"@[deprecated (since := \"2024-11-10\")]\nalias _root_.Set.Subsingleton.cardinal_mk_le_one := Set.Subsingleton.cardinalMk_le_one\n\n"}
{"name":"Cardinal.add_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Eq (HAdd.hAdd (Cardinal.mk Œ±) (Cardinal.mk Œ≤)) (Cardinal.mk (Sum Œ± Œ≤))","decl":"theorem add_def (Œ± Œ≤ : Type u) : #Œ± + #Œ≤ = #(Œ± ‚äï Œ≤) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk (Sum Œ± Œ≤)) (HAdd.hAdd (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)))","decl":"@[simp]\ntheorem mk_sum (Œ± : Type u) (Œ≤ : Type v) : #(Œ± ‚äï Œ≤) = lift.{v, u} #Œ± + lift.{u, v} #Œ≤ :=\n  mk_congr (Equiv.ulift.symm.sumCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.mk_option","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (Option Œ±)) (HAdd.hAdd (Cardinal.mk Œ±) 1)","decl":"@[simp]\ntheorem mk_option {Œ± : Type u} : #(Option Œ±) = #Œ± + 1 := by\n  rw [(Equiv.optionEquivSumPUnit.{u, u} Œ±).cardinal_eq, mk_sum, mk_eq_one PUnit, lift_id, lift_id]\n\n"}
{"name":"Cardinal.mk_psum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk (PSum Œ± Œ≤)) (HAdd.hAdd (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)))","decl":"@[simp]\ntheorem mk_psum (Œ± : Type u) (Œ≤ : Type v) : #(Œ± ‚äï' Œ≤) = lift.{v} #Œ± + lift.{u} #Œ≤ :=\n  (mk_congr (Equiv.psumEquivSum Œ± Œ≤)).trans (mk_sum Œ± Œ≤)\n\n"}
{"name":"Cardinal.mk_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nh : Fintype Œ±\n‚ä¢ Eq (Cardinal.mk Œ±) ‚Üë(Fintype.card Œ±)","decl":"@[simp]\ntheorem mk_fintype (Œ± : Type u) [h : Fintype Œ±] : #Œ± = Fintype.card Œ± :=\n  mk_congr (Fintype.equivOfCardEq (by simp))\n\n"}
{"name":"Cardinal.mul_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Eq (HMul.hMul (Cardinal.mk Œ±) (Cardinal.mk Œ≤)) (Cardinal.mk (Prod Œ± Œ≤))","decl":"theorem mul_def (Œ± Œ≤ : Type u) : #Œ± * #Œ≤ = #(Œ± √ó Œ≤) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk (Prod Œ± Œ≤)) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)))","decl":"@[simp]\ntheorem mk_prod (Œ± : Type u) (Œ≤ : Type v) : #(Œ± √ó Œ≤) = lift.{v, u} #Œ± * lift.{u, v} #Œ≤ :=\n  mk_congr (Equiv.ulift.symm.prodCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.power_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Eq (HPow.hPow (Cardinal.mk Œ±) (Cardinal.mk Œ≤)) (Cardinal.mk (Œ≤ ‚Üí Œ±))","decl":"theorem power_def (Œ± Œ≤ : Type u) : #Œ± ^ #Œ≤ = #(Œ≤ ‚Üí Œ±) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_arrow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk (Œ± ‚Üí Œ≤)) (HPow.hPow (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)) (Cardinal.lift.{v, u} (Cardinal.mk Œ±)))","decl":"theorem mk_arrow (Œ± : Type u) (Œ≤ : Type v) : #(Œ± ‚Üí Œ≤) = (lift.{u} #Œ≤^lift.{v} #Œ±) :=\n  mk_congr (Equiv.ulift.symm.arrowCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.lift_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{v, u} (HPow.hPow a b)) (HPow.hPow (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_power (a b : Cardinal.{u}) : lift.{v} (a ^ b) = lift.{v} a ^ lift.{v} b :=\n  inductionOn‚ÇÇ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.ulift.arrowCongr Equiv.ulift).symm\n\n"}
{"name":"Cardinal.power_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Eq (HPow.hPow a 0) 1","decl":"@[simp]\ntheorem power_zero (a : Cardinal) : a ^ (0 : Cardinal) = 1 :=\n  inductionOn a fun _ => mk_eq_one _\n\n"}
{"name":"Cardinal.power_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Eq (HPow.hPow a 1) a","decl":"@[simp]\ntheorem power_one (a : Cardinal.{u}) : a ^ (1 : Cardinal) = a :=\n  inductionOn a fun Œ± => mk_congr (Equiv.funUnique (ULift.{u} (Fin 1)) Œ±)\n\n"}
{"name":"Cardinal.power_add","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n‚ä¢ Eq (HPow.hPow a (HAdd.hAdd b c)) (HMul.hMul (HPow.hPow a b) (HPow.hPow a c))","decl":"theorem power_add (a b c : Cardinal) : a ^ (b + c) = a ^ b * a ^ c :=\n  inductionOn‚ÇÉ a b c fun Œ± Œ≤ Œ≥ => mk_congr <| Equiv.sumArrowEquivProdArrow Œ≤ Œ≥ Œ±\n\n"}
{"name":"Cardinal.one_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Eq (HPow.hPow 1 a) 1","decl":"@[simp]\ntheorem one_power {a : Cardinal} : (1 : Cardinal) ^ a = 1 :=\n  inductionOn a fun _ => mk_eq_one _\n\n"}
{"name":"Cardinal.mk_bool","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Bool) 2","decl":"theorem mk_bool : #Bool = 2 := by simp\n\n"}
{"name":"Cardinal.mk_Prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Prop) 2","decl":"theorem mk_Prop : #Prop = 2 := by simp\n\n"}
{"name":"Cardinal.zero_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\na‚úù : Ne a 0\n‚ä¢ Eq (HPow.hPow 0 a) 0","decl":"@[simp]\ntheorem zero_power {a : Cardinal} : a ‚â† 0 ‚Üí (0 : Cardinal) ^ a = 0 :=\n  inductionOn a fun _ heq =>\n    mk_eq_zero_iff.2 <|\n      isEmpty_pi.2 <|\n        let ‚ü®a‚ü© := mk_ne_zero_iff.1 heq\n        ‚ü®a, inferInstance‚ü©\n\n"}
{"name":"Cardinal.power_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\na‚úù : Ne a 0\n‚ä¢ Ne (HPow.hPow a b) 0","decl":"theorem power_ne_zero {a : Cardinal} (b : Cardinal) : a ‚â† 0 ‚Üí a ^ b ‚â† 0 :=\n  inductionOn‚ÇÇ a b fun _ _ h =>\n    let ‚ü®a‚ü© := mk_ne_zero_iff.1 h\n    mk_ne_zero_iff.2 ‚ü®fun _ => a‚ü©\n\n"}
{"name":"Cardinal.mul_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n‚ä¢ Eq (HPow.hPow (HMul.hMul a b) c) (HMul.hMul (HPow.hPow a c) (HPow.hPow b c))","decl":"theorem mul_power {a b c : Cardinal} : (a * b) ^ c = a ^ c * b ^ c :=\n  inductionOn‚ÇÉ a b c fun Œ± Œ≤ Œ≥ => mk_congr <| Equiv.arrowProdEquivProdArrow Œ± Œ≤ Œ≥\n\n"}
{"name":"Cardinal.power_mul","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n‚ä¢ Eq (HPow.hPow a (HMul.hMul b c)) (HPow.hPow (HPow.hPow a b) c)","decl":"theorem power_mul {a b c : Cardinal} : a ^ (b * c) = (a ^ b) ^ c := by\n  rw [mul_comm b c]\n  exact inductionOn‚ÇÉ a b c fun Œ± Œ≤ Œ≥ => mk_congr <| Equiv.curry Œ≥ Œ≤ Œ±\n\n"}
{"name":"Cardinal.power_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n‚ä¢ Eq (HPow.hPow a ‚Üën) (HPow.hPow a n)","decl":"@[simp, norm_cast]\ntheorem power_natCast (a : Cardinal.{u}) (n : ‚Ñï) : a ^ (‚Üën : Cardinal.{u}) = a ^ n :=\n  rfl\n\n"}
{"name":"Cardinal.power_cast_right","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n‚ä¢ Eq (HPow.hPow a ‚Üën) (HPow.hPow a n)","decl":"@[deprecated (since := \"2024-10-16\")]\nalias power_cast_right := power_natCast\n\n"}
{"name":"Cardinal.lift_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.lift.{u_2, u_1} 1) 1","decl":"@[simp]\ntheorem lift_one : lift 1 = 1 := mk_eq_one _\n\n"}
{"name":"Cardinal.lift_eq_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{v}\n‚ä¢ Iff (Eq (Cardinal.lift.{u, v} a) 1) (Eq a 1)","decl":"@[simp]\ntheorem lift_eq_one {a : Cardinal.{v}} : lift.{u} a = 1 ‚Üî a = 1 :=\n  lift_injective.eq_iff' lift_one\n\n"}
{"name":"Cardinal.lift_add","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{v, u} (HAdd.hAdd a b)) (HAdd.hAdd (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_add (a b : Cardinal.{u}) : lift.{v} (a + b) = lift.{v} a + lift.{v} b :=\n  inductionOn‚ÇÇ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.sumCongr Equiv.ulift Equiv.ulift).symm\n\n"}
{"name":"Cardinal.lift_mul","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{v, u} (HMul.hMul a b)) (HMul.hMul (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_mul (a b : Cardinal.{u}) : lift.{v} (a * b) = lift.{v} a * lift.{v} b :=\n  inductionOn‚ÇÇ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.prodCongr Equiv.ulift Equiv.ulift).symm\n\n"}
{"name":"Cardinal.lift_two","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.lift.{u, v} 2) 2","decl":"theorem lift_two : lift.{u, v} 2 = 2 := by simp [‚Üê one_add_one_eq_two]\n\n"}
{"name":"Cardinal.mk_set","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (Set Œ±)) (HPow.hPow 2 (Cardinal.mk Œ±))","decl":"@[simp]\ntheorem mk_set {Œ± : Type u} : #(Set Œ±) = 2 ^ #Œ± := by simp [‚Üê one_add_one_eq_two, Set, mk_arrow]\n\n"}
{"name":"Cardinal.mk_powerset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Eq (Cardinal.mk ‚Üës.powerset) (HPow.hPow 2 (Cardinal.mk ‚Üës))","decl":"/-- A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. -/\n@[simp]\ntheorem mk_powerset {Œ± : Type u} (s : Set Œ±) : #(‚Ü•(ùí´ s)) = 2 ^ #(‚Ü•s) :=\n  (mk_congr (Equiv.Set.powerset s)).trans mk_set\n\n"}
{"name":"Cardinal.lift_two_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Eq (Cardinal.lift.{v, u_1} (HPow.hPow 2 a)) (HPow.hPow 2 (Cardinal.lift.{v, u_1} a))","decl":"theorem lift_two_power (a : Cardinal) : lift.{v} (2 ^ a) = 2 ^ lift.{v} a := by\n  simp [‚Üê one_add_one_eq_two]\n\n"}
{"name":"Cardinal.zero_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ LE.le 0 a","decl":"protected theorem zero_le : ‚àÄ a : Cardinal, 0 ‚â§ a := by\n  rintro ‚ü®Œ±‚ü©\n  exact ‚ü®Embedding.ofIsEmpty‚ü©\n\n"}
{"name":"Cardinal.addLeftMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ AddLeftMono Cardinal.{u_1}","decl":"instance addLeftMono : AddLeftMono Cardinal :=\n  ‚ü®fun _ _ _ => add_le_add' le_rfl‚ü©\n\n"}
{"name":"Cardinal.addRightMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ AddRightMono Cardinal.{u_1}","decl":"instance addRightMono : AddRightMono Cardinal :=\n  ‚ü®fun _ _ _ h => add_le_add' h le_rfl‚ü©\n\n"}
{"name":"Cardinal.canonicallyOrderedAdd","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ CanonicallyOrderedAdd Cardinal.{u}","decl":"instance canonicallyOrderedAdd : CanonicallyOrderedAdd Cardinal.{u} where\n  exists_add_of_le {a b} :=\n    inductionOn‚ÇÇ a b fun Œ± Œ≤ ‚ü®‚ü®f, hf‚ü©‚ü© =>\n      have : Œ± ‚äï ((range f)·∂ú : Set Œ≤) ‚âÉ Œ≤ := by\n        classical\n        exact (Equiv.sumCongr (Equiv.ofInjective f hf) (Equiv.refl _)).trans <|\n          Equiv.Set.sumCompl (range f)\n      ‚ü®#(‚Ü•(range f)·∂ú), mk_congr this.symm‚ü©\n  le_self_add a _ := (add_zero a).ge.trans <| add_le_add_left (Cardinal.zero_le _) _\n\n"}
{"name":"Cardinal.noZeroDivisors","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ NoZeroDivisors Cardinal.{u}","decl":"instance noZeroDivisors : NoZeroDivisors Cardinal.{u} where\n  eq_zero_or_eq_zero_of_mul_eq_zero := fun {a b} =>\n    inductionOn‚ÇÇ a b fun Œ± Œ≤ => by\n      simpa only [mul_def, mk_eq_zero_iff, isEmpty_prod] using id\n\n"}
{"name":"Cardinal.zero_power_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ LE.le (HPow.hPow 0 c) 1","decl":"theorem zero_power_le (c : Cardinal.{u}) : (0 : Cardinal.{u}) ^ c ‚â§ 1 := by\n  by_cases h : c = 0\n  ¬∑ rw [h, power_zero]\n  ¬∑ rw [zero_power h]\n    apply zero_le\n\n"}
{"name":"Cardinal.power_le_power_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\na‚úù¬π : Ne a 0\na‚úù : LE.le b c\n‚ä¢ LE.le (HPow.hPow a b) (HPow.hPow a c)","decl":"theorem power_le_power_left : ‚àÄ {a b c : Cardinal}, a ‚â† 0 ‚Üí b ‚â§ c ‚Üí a ^ b ‚â§ a ^ c := by\n  rintro ‚ü®Œ±‚ü© ‚ü®Œ≤‚ü© ‚ü®Œ≥‚ü© hŒ± ‚ü®e‚ü©\n  let ‚ü®a‚ü© := mk_ne_zero_iff.1 hŒ±\n  exact ‚ü®@Function.Embedding.arrowCongrLeft _ _ _ ‚ü®a‚ü© e‚ü©\n\n"}
{"name":"Cardinal.self_le_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nhb : LE.le 1 b\n‚ä¢ LE.le a (HPow.hPow a b)","decl":"theorem self_le_power (a : Cardinal) {b : Cardinal} (hb : 1 ‚â§ b) : a ‚â§ a ^ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  ¬∑ exact zero_le _\n  ¬∑ convert power_le_power_left ha hb\n    exact (power_one a).symm\n\n"}
{"name":"Cardinal.cantor","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ LT.lt a (HPow.hPow 2 a)","decl":"/-- **Cantor's theorem** -/\ntheorem cantor (a : Cardinal.{u}) : a < 2 ^ a := by\n  induction' a using Cardinal.inductionOn with Œ±\n  rw [‚Üê mk_set]\n  refine ‚ü®‚ü®‚ü®singleton, fun a b => singleton_eq_singleton_iff.1‚ü©‚ü©, ?_‚ü©\n  rintro ‚ü®‚ü®f, hf‚ü©‚ü©\n  exact cantor_injective f hf\n\n"}
{"name":"Cardinal.instNoMaxOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ NoMaxOrder Cardinal.{u}","decl":"instance : NoMaxOrder Cardinal.{u} where exists_gt a := ‚ü®_, cantor a‚ü©\n\n-- short-circuit type class inference\n"}
{"name":"Cardinal.one_lt_iff_nontrivial","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LT.lt 1 (Cardinal.mk Œ±)) (Nontrivial Œ±)","decl":"theorem one_lt_iff_nontrivial {Œ± : Type u} : 1 < #Œ± ‚Üî Nontrivial Œ± := by\n  rw [‚Üê not_le, le_one_iff_subsingleton, ‚Üê not_nontrivial_iff_subsingleton, Classical.not_not]\n\n"}
{"name":"Cardinal.power_le_max_power_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\nh : LE.le b c\n‚ä¢ LE.le (HPow.hPow a b) (Max.max (HPow.hPow a c) 1)","decl":"theorem power_le_max_power_one {a b c : Cardinal} (h : b ‚â§ c) : a ^ b ‚â§ max (a ^ c) 1 := by\n  by_cases ha : a = 0\n  ¬∑ simp [ha, zero_power_le]\n  ¬∑ exact (power_le_power_left ha h).trans (le_max_left _ _)\n\n"}
{"name":"Cardinal.power_le_power_right","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\na‚úù : LE.le a b\n‚ä¢ LE.le (HPow.hPow a c) (HPow.hPow b c)","decl":"theorem power_le_power_right {a b c : Cardinal} : a ‚â§ b ‚Üí a ^ c ‚â§ b ^ c :=\n  inductionOn‚ÇÉ a b c fun _ _ _ ‚ü®e‚ü© => ‚ü®Embedding.arrowCongrRight e‚ü©\n\n"}
{"name":"Cardinal.power_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt 0 a\n‚ä¢ LT.lt 0 (HPow.hPow a b)","decl":"theorem power_pos {a : Cardinal} (b : Cardinal) (ha : 0 < a) : 0 < a ^ b :=\n  (power_ne_zero _ ha.ne').bot_lt\n\n"}
{"name":"Cardinal.lt_wf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"protected theorem lt_wf : @WellFounded Cardinal.{u} (¬∑ < ¬∑) :=\n  ‚ü®fun a =>\n    by_contradiction fun h => by\n      let Œπ := { c : Cardinal // ¬¨Acc (¬∑ < ¬∑) c }\n      let f : Œπ ‚Üí Cardinal := Subtype.val\n      haveI hŒπ : Nonempty Œπ := ‚ü®‚ü®_, h‚ü©‚ü©\n      obtain ‚ü®‚ü®c : Cardinal, hc : ¬¨Acc (¬∑ < ¬∑) c‚ü©, ‚ü®h_1 : ‚àÄ j, (f ‚ü®c, hc‚ü©).out ‚Ü™ (f j).out‚ü©‚ü© :=\n        Embedding.min_injective fun i => (f i).out\n      refine hc (Acc.intro _ fun j h' => by_contradiction fun hj => h'.2 ?_)\n      have : #_ ‚â§ #_ := ‚ü®h_1 ‚ü®j, hj‚ü©‚ü©\n      simpa only [mk_out] using this‚ü©\n\n"}
{"name":"Cardinal.instWellFoundedLT","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ WellFoundedLT Cardinal.{u}","decl":"instance : WellFoundedLT Cardinal.{u} :=\n  ‚ü®Cardinal.lt_wf‚ü©\n\n"}
{"name":"Cardinal.sInf_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf (‚àÖ : Set Cardinal.{u}) = 0 :=\n  dif_neg Set.not_nonempty_empty\n\n"}
{"name":"Cardinal.sInf_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u_1}\n‚ä¢ Iff (Eq (InfSet.sInf s) 0) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun a => And (Membership.mem s a) (Eq a 0)))","decl":"lemma sInf_eq_zero_iff {s : Set Cardinal} : sInf s = 0 ‚Üî s = ‚àÖ ‚à® ‚àÉ a ‚àà s, a = 0 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ rcases s.eq_empty_or_nonempty with rfl | hne\n    ¬∑ exact Or.inl rfl\n    ¬∑ exact Or.inr ‚ü®sInf s, csInf_mem hne, h‚ü©\n  ¬∑ rcases h with rfl | ‚ü®a, ha, rfl‚ü©\n    ¬∑ exact Cardinal.sInf_empty\n    ¬∑ exact eq_bot_iff.2 (csInf_le' ha)\n\n"}
{"name":"Cardinal.iInf_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Sort u_1\nf : Œπ ‚Üí Cardinal.{u_2}\n‚ä¢ Iff (Eq (iInf fun i => f i) 0) (Or (IsEmpty Œπ) (Exists fun i => Eq (f i) 0))","decl":"lemma iInf_eq_zero_iff {Œπ : Sort*} {f : Œπ ‚Üí Cardinal} :\n    (‚®Ö i, f i) = 0 ‚Üî IsEmpty Œπ ‚à® ‚àÉ i, f i = 0 := by\n  simp [iInf, sInf_eq_zero_iff]\n\n"}
{"name":"Cardinal.iSup_of_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Sort u_1\nf : Œπ ‚Üí Cardinal.{u_2}\ninst‚úù : IsEmpty Œπ\n‚ä¢ Eq (iSup f) 0","decl":"/-- A variant of `ciSup_of_empty` but with `0` on the RHS for convenience -/\nprotected theorem iSup_of_empty {Œπ} (f : Œπ ‚Üí Cardinal) [IsEmpty Œπ] : iSup f = 0 :=\n  ciSup_of_empty f\n\n"}
{"name":"Cardinal.lift_sInf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{u, v} (InfSet.sInf s)) (InfSet.sInf (Set.image Cardinal.lift.{u, v} s))","decl":"@[simp]\ntheorem lift_sInf (s : Set Cardinal) : lift.{u, v} (sInf s) = sInf (lift.{u, v} '' s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  ¬∑ simp\n  ¬∑ exact lift_monotone.map_csInf hs\n\n"}
{"name":"Cardinal.lift_iInf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Sort u_1\nf : Œπ ‚Üí Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{u, v} (iInf f)) (iInf fun i => Cardinal.lift.{u, v} (f i))","decl":"@[simp]\ntheorem lift_iInf {Œπ} (f : Œπ ‚Üí Cardinal) : lift.{u, v} (iInf f) = ‚®Ö i, lift.{u, v} (f i) := by\n  unfold iInf\n  convert lift_sInf (range f)\n  simp_rw [‚Üê comp_apply (f := lift), range_comp]\n\n"}
{"name":"Cardinal.succ_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Eq (Order.succ c) (InfSet.sInf (setOf fun c' => LT.lt c c'))","decl":"theorem succ_def (c : Cardinal) : succ c = sInf { c' | c < c' } :=\n  dif_neg <| not_isMax c\n\n"}
{"name":"Cardinal.succ_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ LT.lt 0 (Order.succ c)","decl":"theorem succ_pos : ‚àÄ c : Cardinal, 0 < succ c :=\n  bot_lt_succ\n\n"}
{"name":"Cardinal.succ_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Ne (Order.succ c) 0","decl":"theorem succ_ne_zero (c : Cardinal) : succ c ‚â† 0 :=\n  (succ_pos _).ne'\n\n"}
{"name":"Cardinal.add_one_le_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ LE.le (HAdd.hAdd c 1) (Order.succ c)","decl":"theorem add_one_le_succ (c : Cardinal.{u}) : c + 1 ‚â§ succ c := by\n  -- Porting note: rewrote the next three lines to avoid defeq abuse.\n  have : Set.Nonempty { c' | c < c' } := exists_gt c\n  simp_rw [succ_def, le_csInf_iff'' this, mem_setOf]\n  intro b hlt\n  rcases b, c with ‚ü®‚ü®Œ≤‚ü©, ‚ü®Œ≥‚ü©‚ü©\n  cases' le_of_lt hlt with f\n  have : ¬¨Surjective f := fun hn => (not_le_of_lt hlt) (mk_le_of_surjective hn)\n  simp only [Surjective, not_forall] at this\n  rcases this with ‚ü®b, hb‚ü©\n  calc\n    #Œ≥ + 1 = #(Option Œ≥) := mk_option.symm\n    _ ‚â§ #Œ≤ := (f.optionElim b hb).cardinal_le\n\n"}
{"name":"Cardinal.lift_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Eq (Cardinal.lift.{v, u} (Order.succ a)) (Order.succ (Cardinal.lift.{v, u} a))","decl":"@[simp]\ntheorem lift_succ (a) : lift.{v, u} (succ a) = succ (lift.{v, u} a) :=\n  le_antisymm\n    (le_of_not_gt fun h => by\n      rcases lt_lift_iff.1 h with ‚ü®b, h, e‚ü©\n      rw [lt_succ_iff, ‚Üê lift_le, e] at h\n      exact h.not_lt (lt_succ _))\n    (succ_le_of_lt <| lift_lt.2 <| lt_succ a)\n\n"}
{"name":"Cardinal.ne_zero_of_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Nat\nh : Order.IsSuccLimit c\n‚ä¢ Ne c 0","decl":"theorem ne_zero_of_isSuccLimit {c} (h : IsSuccLimit c) : c ‚â† 0 :=\n  h.ne_bot\n\n"}
{"name":"Cardinal.isSuccPrelimit_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Order.IsSuccPrelimit 0","decl":"theorem isSuccPrelimit_zero : IsSuccPrelimit (0 : Cardinal) :=\n  isSuccPrelimit_bot\n\n"}
{"name":"Cardinal.isSuccLimit_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (Order.IsSuccLimit c) (And (Ne c 0) (Order.IsSuccPrelimit c))","decl":"protected theorem isSuccLimit_iff {c : Cardinal} : IsSuccLimit c ‚Üî c ‚â† 0 ‚àß IsSuccPrelimit c :=\n  isSuccLimit_iff\n\n"}
{"name":"Cardinal.IsLimit.isSuccPrelimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n‚ä¢ Order.IsSuccPrelimit c","decl":"set_option linter.deprecated false in\n@[deprecated IsSuccLimit.isSuccPrelimit (since := \"2024-09-17\")]\nprotected theorem IsLimit.isSuccPrelimit {c} (h : IsLimit c) : IsSuccPrelimit c :=\n  h.2\n\n"}
{"name":"Cardinal.IsLimit.ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n‚ä¢ Ne c 0","decl":"set_option linter.deprecated false in\n@[deprecated ne_zero_of_isSuccLimit (since := \"2024-09-17\")]\nprotected theorem IsLimit.ne_zero {c} (h : IsLimit c) : c ‚â† 0 :=\n  h.1\n\n"}
{"name":"Cardinal.IsLimit.isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n‚ä¢ Order.IsSuccPrelimit c","decl":"set_option linter.deprecated false in\n@[deprecated IsLimit.isSuccPrelimit (since := \"2024-09-05\")]\nalias IsLimit.isSuccLimit := IsLimit.isSuccPrelimit\n\n"}
{"name":"Cardinal.IsLimit.succ_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"x c : Cardinal.{u_1}\nh : c.IsLimit\na‚úù : LT.lt x c\n‚ä¢ LT.lt (Order.succ x) c","decl":"set_option linter.deprecated false in\n@[deprecated IsSuccLimit.succ_lt (since := \"2024-09-17\")]\ntheorem IsLimit.succ_lt {x c} (h : IsLimit c) : x < c ‚Üí succ x < c :=\n  h.isSuccPrelimit.succ_lt\n\n"}
{"name":"Cardinal.isSuccLimit_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Order.IsSuccPrelimit 0","decl":"@[deprecated isSuccPrelimit_zero (since := \"2024-09-05\")]\nalias isSuccLimit_zero := isSuccPrelimit_zero\n\n"}
{"name":"Cardinal.le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Cardinal.{max u_1 u_2}\ni : Œπ\n‚ä¢ LE.le (f i) (Cardinal.sum f)","decl":"theorem le_sum {Œπ} (f : Œπ ‚Üí Cardinal) (i) : f i ‚â§ sum f := by\n  rw [‚Üê Quotient.out_eq (f i)]\n  exact ‚ü®‚ü®fun a => ‚ü®i, a‚ü©, fun a b h => by injection h‚ü©‚ü©\n\n"}
{"name":"Cardinal.iSup_le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Cardinal.{max u_1 u_2}\n‚ä¢ LE.le (iSup f) (Cardinal.sum f)","decl":"theorem iSup_le_sum {Œπ} (f : Œπ ‚Üí Cardinal) : iSup f ‚â§ sum f :=\n  ciSup_le' <| le_sum _\n\n"}
{"name":"Cardinal.mk_sigma","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Type u_1\n‚ä¢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.sum fun i => Cardinal.mk (f i))","decl":"@[simp]\ntheorem mk_sigma {Œπ} (f : Œπ ‚Üí Type*) : #(Œ£ i, f i) = sum fun i => #(f i) :=\n  mk_congr <| Equiv.sigmaCongrRight fun _ => outMkEquiv.symm\n\n"}
{"name":"Cardinal.mk_sigma_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nŒπ' : Type v'\nf : Œπ ‚Üí Type w\ng : Œπ' ‚Üí Type w'\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.lift.{w', w} (Cardinal.mk (f i))) (Cardinal.lift.{w, w'} (Cardinal.mk (g (e i))))\n‚ä¢ Eq (Cardinal.lift.{max v' w', max w v} (Cardinal.mk (Sigma fun i => f i))) (Cardinal.lift.{max v w, max w' v'} (Cardinal.mk (Sigma fun i => g i)))","decl":"theorem mk_sigma_congr_lift {Œπ : Type v} {Œπ' : Type v'} {f : Œπ ‚Üí Type w} {g : Œπ' ‚Üí Type w'}\n    (e : Œπ ‚âÉ Œπ') (h : ‚àÄ i, lift.{w'} #(f i) = lift.{w} #(g (e i))) :\n    lift.{max v' w'} #(Œ£ i, f i) = lift.{max v w} #(Œ£ i, g i) :=\n  Cardinal.lift_mk_eq'.2 ‚ü®.sigmaCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.lift_mk_eq'.1 (h i)‚ü©\n\n"}
{"name":"Cardinal.mk_sigma_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ Œπ' : Type u\nf : Œπ ‚Üí Type v\ng : Œπ' ‚Üí Type v\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n‚ä¢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"theorem mk_sigma_congr {Œπ Œπ' : Type u} {f : Œπ ‚Üí Type v} {g : Œπ' ‚Üí Type v} (e : Œπ ‚âÉ Œπ')\n    (h : ‚àÄ i, #(f i) = #(g (e i))) : #(Œ£ i, f i) = #(Œ£ i, g i) :=\n  mk_congr <| Equiv.sigmaCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_congr'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nŒπ' : Type v\nf : Œπ ‚Üí Type (max w u v)\ng : Œπ' ‚Üí Type (max w u v)\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n‚ä¢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"/-- Similar to `mk_sigma_congr` with indexing types in different universes. This is not a strict\ngeneralization. -/\ntheorem mk_sigma_congr' {Œπ : Type u} {Œπ' : Type v} {f : Œπ ‚Üí Type max w (max u v)}\n    {g : Œπ' ‚Üí Type max w (max u v)} (e : Œπ ‚âÉ Œπ')\n    (h : ‚àÄ i, #(f i) = #(g (e i))) : #(Œ£ i, f i) = #(Œ£ i, g i) :=\n  mk_congr <| Equiv.sigmaCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Type v\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n‚ä¢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"theorem mk_sigma_congrRight {Œπ : Type u} {f g : Œπ ‚Üí Type v} (h : ‚àÄ i, #(f i) = #(g i)) :\n    #(Œ£ i, f i) = #(Œ£ i, g i) :=\n  mk_sigma_congr (Equiv.refl Œπ) h\n\n"}
{"name":"Cardinal.mk_psigma_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Type v\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n‚ä¢ Eq (Cardinal.mk (PSigma fun i => f i)) (Cardinal.mk (PSigma fun i => g i))","decl":"theorem mk_psigma_congrRight {Œπ : Type u} {f g : Œπ ‚Üí Type v} (h : ‚àÄ i, #(f i) = #(g i)) :\n    #(Œ£' i, f i) = #(Œ£' i, g i) :=\n  mk_congr <| .psigmaCongrRight fun i => Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_psigma_congrRight_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Prop\nf g : Œπ ‚Üí Type v\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n‚ä¢ Eq (Cardinal.mk (PSigma fun i => f i)) (Cardinal.mk (PSigma fun i => g i))","decl":"theorem mk_psigma_congrRight_prop {Œπ : Prop} {f g : Œπ ‚Üí Type v} (h : ‚àÄ i, #(f i) = #(g i)) :\n    #(Œ£' i, f i) = #(Œ£' i, g i) :=\n  mk_congr <| .psigmaCongrRight fun i => Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_arrow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_3\nŒ± : Type u_1\nf : Œπ ‚Üí Type u_2\n‚ä¢ Eq (Cardinal.mk (Sigma f ‚Üí Œ±)) (Cardinal.mk ((i : Œπ) ‚Üí f i ‚Üí Œ±))","decl":"theorem mk_sigma_arrow {Œπ} (Œ± : Type*) (f : Œπ ‚Üí Type*) :\n    #(Sigma f ‚Üí Œ±) = #(Œ† i, f i ‚Üí Œ±) := mk_congr <| Equiv.piCurry fun _ _ ‚Ü¶ Œ±\n\n"}
{"name":"Cardinal.sum_const","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\na : Cardinal.{v}\n‚ä¢ Eq (Cardinal.sum fun x => a) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk Œπ)) (Cardinal.lift.{u, v} a))","decl":"@[simp]\ntheorem sum_const (Œπ : Type u) (a : Cardinal.{v}) :\n    (sum fun _ : Œπ => a) = lift.{v} #Œπ * lift.{u} a :=\n  inductionOn a fun Œ± =>\n    mk_congr <|\n      calc\n        (Œ£ _ : Œπ, Quotient.out #Œ±) ‚âÉ Œπ √ó Quotient.out #Œ± := Equiv.sigmaEquivProd _ _\n        _ ‚âÉ ULift Œπ √ó ULift Œ± := Equiv.ulift.symm.prodCongr (outMkEquiv.trans Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.sum_const'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\na : Cardinal.{u}\n‚ä¢ Eq (Cardinal.sum fun x => a) (HMul.hMul (Cardinal.mk Œπ) a)","decl":"theorem sum_const' (Œπ : Type u) (a : Cardinal.{u}) : (sum fun _ : Œπ => a) = #Œπ * a := by simp\n\n"}
{"name":"Cardinal.sum_add_distrib","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf g : Œπ ‚Üí Cardinal.{u_2}\n‚ä¢ Eq (Cardinal.sum (HAdd.hAdd f g)) (HAdd.hAdd (Cardinal.sum f) (Cardinal.sum g))","decl":"@[simp]\ntheorem sum_add_distrib {Œπ} (f g : Œπ ‚Üí Cardinal) : sum (f + g) = sum f + sum g := by\n  have := mk_congr (Equiv.sigmaSumDistrib (Quotient.out ‚àò f) (Quotient.out ‚àò g))\n  simp only [comp_apply, mk_sigma, mk_sum, mk_out, lift_id] at this\n  exact this\n\n"}
{"name":"Cardinal.sum_add_distrib'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf g : Œπ ‚Üí Cardinal.{u_2}\n‚ä¢ Eq (Cardinal.sum fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (Cardinal.sum f) (Cardinal.sum g))","decl":"@[simp]\ntheorem sum_add_distrib' {Œπ} (f g : Œπ ‚Üí Cardinal) :\n    (Cardinal.sum fun i => f i + g i) = sum f + sum g :=\n  sum_add_distrib f g\n\n"}
{"name":"Cardinal.lift_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{w, max v u} (Cardinal.sum f)) (Cardinal.sum fun i => Cardinal.lift.{w, v} (f i))","decl":"@[simp]\ntheorem lift_sum {Œπ : Type u} (f : Œπ ‚Üí Cardinal.{v}) :\n    Cardinal.lift.{w} (Cardinal.sum f) = Cardinal.sum fun i => Cardinal.lift.{w} (f i) :=\n  Equiv.cardinal_eq <|\n    Equiv.ulift.trans <|\n      Equiv.sigmaCongrRight fun a =>\n    -- Porting note: Inserted universe hint .{_,_,v} below\n        Nonempty.some <| by rw [‚Üê lift_mk_eq.{_,_,v}, mk_out, mk_out, lift_lift]\n\n"}
{"name":"Cardinal.sum_le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf g : Œπ ‚Üí Cardinal.{u_2}\nH : ‚àÄ (i : Œπ), LE.le (f i) (g i)\n‚ä¢ LE.le (Cardinal.sum f) (Cardinal.sum g)","decl":"theorem sum_le_sum {Œπ} (f g : Œπ ‚Üí Cardinal) (H : ‚àÄ i, f i ‚â§ g i) : sum f ‚â§ sum g :=\n  ‚ü®(Embedding.refl _).sigmaMap fun i =>\n      Classical.choice <| by have := H i; rwa [‚Üê Quot.out_eq (f i), ‚Üê Quot.out_eq (g i)] at this‚ü©\n\n"}
{"name":"Cardinal.mk_le_mk_mul_of_mk_preimage_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nc : Cardinal.{u}\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ (b : Œ≤), LE.le (Cardinal.mk ‚Üë(Set.preimage f (Singleton.singleton b))) c\n‚ä¢ LE.le (Cardinal.mk Œ±) (HMul.hMul (Cardinal.mk Œ≤) c)","decl":"theorem mk_le_mk_mul_of_mk_preimage_le {c : Cardinal} (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ b : Œ≤, #(f ‚Åª¬π' {b}) ‚â§ c) :\n    #Œ± ‚â§ #Œ≤ * c := by\n  simpa only [‚Üê mk_congr (@Equiv.sigmaFiberEquiv Œ± Œ≤ f), mk_sigma, ‚Üê sum_const'] using\n    sum_le_sum _ _ hf\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nc : Cardinal.{max u v}\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ (b : Œ≤), LE.le (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.preimage f (Singleton.singleton b)))) c\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)) c)","decl":"theorem lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le {Œ± : Type u} {Œ≤ : Type v} {c : Cardinal}\n    (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ b : Œ≤, lift.{v} #(f ‚Åª¬π' {b}) ‚â§ c) : lift.{v} #Œ± ‚â§ lift.{u} #Œ≤ * c :=\n  (mk_le_mk_mul_of_mk_preimage_le fun x : ULift.{v} Œ± => ULift.up.{u} (f x.1)) <|\n    ULift.forall.2 fun b =>\n      (mk_congr <|\n            (Equiv.ulift.image _).trans\n              (Equiv.trans\n                (by\n                  rw [Equiv.image_eq_preimage]\n                  /- Porting note: Need to insert the following `have` b/c bad fun coercion\n                   behaviour for Equivs -/\n                  have : DFunLike.coe (Equiv.symm (Equiv.ulift (Œ± := Œ±))) = ULift.up (Œ± := Œ±) := rfl\n                  rw [this]\n                  simp only [preimage, mem_singleton_iff, ULift.up_inj, mem_setOf_eq, coe_setOf]\n                  exact Equiv.refl _)\n                Equiv.ulift.symm)).trans_le\n        (hf b)\n\n"}
{"name":"Cardinal.sum_nat_eq_add_sum_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Nat ‚Üí Cardinal.{u}\n‚ä¢ Eq (Cardinal.sum f) (HAdd.hAdd (f 0) (Cardinal.sum fun i => f (HAdd.hAdd i 1)))","decl":"theorem sum_nat_eq_add_sum_succ (f : ‚Ñï ‚Üí Cardinal.{u}) :\n    Cardinal.sum f = f 0 + Cardinal.sum fun i => f (i + 1) := by\n  refine (Equiv.sigmaNatSucc fun i => Quotient.out (f i)).cardinal_eq.trans ?_\n  simp only [mk_sum, mk_out, lift_id, mk_sigma]\n\n"}
{"name":"nonempty_embedding_to_cardinal","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Nonempty (Function.Embedding Œ± Cardinal.{u})","decl":"open Cardinal in\ntheorem nonempty_embedding_to_cardinal : Nonempty (Œ± ‚Ü™ Cardinal.{u}) :=\n  (Embedding.total _ _).resolve_left fun ‚ü®‚ü®f, hf‚ü©‚ü© =>\n    let g : Œ± ‚Üí Cardinal.{u} := invFun f\n    let ‚ü®x, (hx : g x = 2 ^ sum g)‚ü© := invFun_surjective hf (2 ^ sum g)\n    have : g x ‚â§ sum g := le_sum.{u, u} g x\n    not_le_of_gt (by rw [hx]; exact cantor _) this\n\n"}
{"name":"WellOrderingRel.isWellOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ IsWellOrder Œ± WellOrderingRel","decl":"instance WellOrderingRel.isWellOrder : IsWellOrder Œ± WellOrderingRel :=\n  (RelEmbedding.preimage _ _).isWellOrder\n\n"}
{"name":"IsWellOrder.subtype_nonempty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Nonempty (Subtype fun r => IsWellOrder Œ± r)","decl":"instance IsWellOrder.subtype_nonempty : Nonempty { r // IsWellOrder Œ± r } :=\n  ‚ü®‚ü®WellOrderingRel, inferInstance‚ü©‚ü©\n\n"}
{"name":"exists_wellOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Exists fun x => WellFoundedLT Œ±","decl":"variable (Œ±) in\n/-- The **well-ordering theorem** (or **Zermelo's theorem**): every type has a well-order -/\ntheorem exists_wellOrder : ‚àÉ (_ : LinearOrder Œ±), WellFoundedLT Œ± := by\n  classical\n  exact ‚ü®linearOrderOfSTO WellOrderingRel, WellOrderingRel.isWellOrder.toIsWellFounded‚ü©\n\n"}
{"name":"Cardinal.small_Iic","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Iic a)","decl":"instance small_Iic (a : Cardinal.{u}) : Small.{u} (Iic a) := by\n  rw [‚Üê mk_out a]\n  apply @small_of_surjective (Set a.out) (Iic #a.out) _ fun x => ‚ü®#x, mk_set_le x‚ü©\n  rintro ‚ü®x, hx‚ü©\n  simpa using le_mk_iff_exists_set.1 hx\n\n"}
{"name":"Cardinal.small_Iio","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Iio a)","decl":"instance small_Iio (a : Cardinal.{u}) : Small.{u} (Iio a) := small_subset Iio_subset_Iic_self\n"}
{"name":"Cardinal.small_Icc","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Icc a b)","decl":"instance small_Icc (a b : Cardinal.{u}) : Small.{u} (Icc a b) := small_subset Icc_subset_Iic_self\n"}
{"name":"Cardinal.small_Ico","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Ico a b)","decl":"instance small_Ico (a b : Cardinal.{u}) : Small.{u} (Ico a b) := small_subset Ico_subset_Iio_self\n"}
{"name":"Cardinal.small_Ioc","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Ioc a b)","decl":"instance small_Ioc (a b : Cardinal.{u}) : Small.{u} (Ioc a b) := small_subset Ioc_subset_Iic_self\n"}
{"name":"Cardinal.small_Ioo","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Small.{u, u + 1} ‚Üë(Set.Ioo a b)","decl":"instance small_Ioo (a b : Cardinal.{u}) : Small.{u} (Ioo a b) := small_subset Ioo_subset_Iio_self\n\n"}
{"name":"Cardinal.bddAbove_iff_small","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u}\n‚ä¢ Iff (BddAbove s) (Small.{u, u + 1} ‚Üës)","decl":"/-- A set of cardinals is bounded above iff it's small, i.e. it corresponds to a usual ZFC set. -/\ntheorem bddAbove_iff_small {s : Set Cardinal.{u}} : BddAbove s ‚Üî Small.{u} s :=\n  ‚ü®fun ‚ü®a, ha‚ü© => @small_subset _ (Iic a) s (fun _ h => ha h) _, by\n    rintro ‚ü®Œπ, ‚ü®e‚ü©‚ü©\n    use sum.{u, u} fun x ‚Ü¶ e.symm x\n    intro a ha\n    simpa using le_sum (fun x ‚Ü¶ e.symm x) (e ‚ü®a, ha‚ü©)‚ü©\n\n"}
{"name":"Cardinal.bddAbove_of_small","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u}\nh : Small.{u, u + 1} ‚Üës\n‚ä¢ BddAbove s","decl":"theorem bddAbove_of_small (s : Set Cardinal.{u}) [h : Small.{u} s] : BddAbove s :=\n  bddAbove_iff_small.2 h\n\n"}
{"name":"Cardinal.bddAbove_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Small.{u, u_1} Œπ\nf : Œπ ‚Üí Cardinal.{u}\n‚ä¢ BddAbove (Set.range f)","decl":"theorem bddAbove_range {Œπ : Type*} [Small.{u} Œπ] (f : Œπ ‚Üí Cardinal.{u}) : BddAbove (Set.range f) :=\n  bddAbove_of_small _\n\n"}
{"name":"Cardinal.bddAbove_image","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Cardinal.{u} ‚Üí Cardinal.{max u v}\ns : Set Cardinal.{u}\nhs : BddAbove s\n‚ä¢ BddAbove (Set.image f s)","decl":"theorem bddAbove_image (f : Cardinal.{u} ‚Üí Cardinal.{max u v}) {s : Set Cardinal.{u}}\n    (hs : BddAbove s) : BddAbove (f '' s) := by\n  rw [bddAbove_iff_small] at hs ‚ä¢\n  exact small_lift _\n\n"}
{"name":"Cardinal.bddAbove_range_comp","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Cardinal.{v}\nhf : BddAbove (Set.range f)\ng : Cardinal.{v} ‚Üí Cardinal.{max v w}\n‚ä¢ BddAbove (Set.range (Function.comp g f))","decl":"theorem bddAbove_range_comp {Œπ : Type u} {f : Œπ ‚Üí Cardinal.{v}} (hf : BddAbove (range f))\n    (g : Cardinal.{v} ‚Üí Cardinal.{max v w}) : BddAbove (range (g ‚àò f)) := by\n  rw [range_comp]\n  exact bddAbove_image g hf\n\n"}
{"name":"Cardinal.sum_le_iSup_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Cardinal.{max u v}\n‚ä¢ LE.le (Cardinal.sum f) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk Œπ)) (iSup f))","decl":"theorem sum_le_iSup_lift {Œπ : Type u}\n    (f : Œπ ‚Üí Cardinal.{max u v}) : sum f ‚â§ Cardinal.lift #Œπ * iSup f := by\n  rw [‚Üê (iSup f).lift_id, ‚Üê lift_umax, lift_umax.{max u v, u}, ‚Üê sum_const]\n  exact sum_le_sum _ _ (le_ciSup <| bddAbove_of_small _)\n\n"}
{"name":"Cardinal.sum_le_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Cardinal.{u}\n‚ä¢ LE.le (Cardinal.sum f) (HMul.hMul (Cardinal.mk Œπ) (iSup f))","decl":"theorem sum_le_iSup {Œπ : Type u} (f : Œπ ‚Üí Cardinal.{u}) : sum f ‚â§ #Œπ * iSup f := by\n  rw [‚Üê lift_id #Œπ]\n  exact sum_le_iSup_lift f\n\n"}
{"name":"Cardinal.lift_sSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u_1}\nhs : BddAbove s\n‚ä¢ Eq (Cardinal.lift.{u, u_1} (SupSet.sSup s)) (SupSet.sSup (Set.image Cardinal.lift.{u, u_1} s))","decl":"/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_sSup {s : Set Cardinal} (hs : BddAbove s) :\n    lift.{u} (sSup s) = sSup (lift.{u} '' s) := by\n  apply ((le_csSup_iff' (bddAbove_image.{_,u} _ hs)).2 fun c hc => _).antisymm (csSup_le' _)\n  ¬∑ intro c hc\n    by_contra h\n    obtain ‚ü®d, rfl‚ü© := Cardinal.mem_range_lift_of_le (not_le.1 h).le\n    simp_rw [lift_le] at h hc\n    rw [csSup_le_iff' hs] at h\n    exact h fun a ha => lift_le.1 <| hc (mem_image_of_mem _ ha)\n  ¬∑ rintro i ‚ü®j, hj, rfl‚ü©\n    exact lift_le.2 (le_csSup hs hj)\n\n"}
{"name":"Cardinal.lift_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nf : Œπ ‚Üí Cardinal.{w}\nhf : BddAbove (Set.range f)\n‚ä¢ Eq (Cardinal.lift.{u, w} (iSup f)) (iSup fun i => Cardinal.lift.{u, w} (f i))","decl":"/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_iSup {Œπ : Type v} {f : Œπ ‚Üí Cardinal.{w}} (hf : BddAbove (range f)) :\n    lift.{u} (iSup f) = ‚®Ü i, lift.{u} (f i) := by\n  rw [iSup, iSup, lift_sSup hf, ‚Üê range_comp]\n  simp [Function.comp_def]\n\n"}
{"name":"Cardinal.lift_iSup_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nf : Œπ ‚Üí Cardinal.{w}\nt : Cardinal.{max u w}\nhf : BddAbove (Set.range f)\nw : ‚àÄ (i : Œπ), LE.le (Cardinal.lift.{u, w} (f i)) t\n‚ä¢ LE.le (Cardinal.lift.{u, w} (iSup f)) t","decl":"/-- To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. -/\ntheorem lift_iSup_le {Œπ : Type v} {f : Œπ ‚Üí Cardinal.{w}} {t : Cardinal} (hf : BddAbove (range f))\n    (w : ‚àÄ i, lift.{u} (f i) ‚â§ t) : lift.{u} (iSup f) ‚â§ t := by\n  rw [lift_iSup hf]\n  exact ciSup_le' w\n\n"}
{"name":"Cardinal.lift_iSup_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nf : Œπ ‚Üí Cardinal.{w}\nhf : BddAbove (Set.range f)\nt : Cardinal.{max u w}\n‚ä¢ Iff (LE.le (Cardinal.lift.{u, w} (iSup f)) t) (‚àÄ (i : Œπ), LE.le (Cardinal.lift.{u, w} (f i)) t)","decl":"@[simp]\ntheorem lift_iSup_le_iff {Œπ : Type v} {f : Œπ ‚Üí Cardinal.{w}} (hf : BddAbove (range f))\n    {t : Cardinal} : lift.{u} (iSup f) ‚â§ t ‚Üî ‚àÄ i, lift.{u} (f i) ‚â§ t := by\n  rw [lift_iSup hf]\n  exact ciSup_le_iff' (bddAbove_range_comp.{_,_,u} hf _)\n\n"}
{"name":"Cardinal.lift_iSup_le_lift_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nŒπ' : Type v'\nf : Œπ ‚Üí Cardinal.{w}\nf' : Œπ' ‚Üí Cardinal.{w'}\nhf : BddAbove (Set.range f)\nhf' : BddAbove (Set.range f')\ng : Œπ ‚Üí Œπ'\nh : ‚àÄ (i : Œπ), LE.le (Cardinal.lift.{w', w} (f i)) (Cardinal.lift.{w, w'} (f' (g i)))\n‚ä¢ LE.le (Cardinal.lift.{w', w} (iSup f)) (Cardinal.lift.{w, w'} (iSup f'))","decl":"/-- To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum.\n-/\ntheorem lift_iSup_le_lift_iSup {Œπ : Type v} {Œπ' : Type v'} {f : Œπ ‚Üí Cardinal.{w}}\n    {f' : Œπ' ‚Üí Cardinal.{w'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) {g : Œπ ‚Üí Œπ'}\n    (h : ‚àÄ i, lift.{w'} (f i) ‚â§ lift.{w} (f' (g i))) : lift.{w'} (iSup f) ‚â§ lift.{w} (iSup f') := by\n  rw [lift_iSup hf, lift_iSup hf']\n  exact ciSup_mono' (bddAbove_range_comp.{_,_,w} hf' _) fun i => ‚ü®_, h i‚ü©\n\n"}
{"name":"Cardinal.lift_iSup_le_lift_iSup'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nŒπ' : Type v'\nf : Œπ ‚Üí Cardinal.{v}\nf' : Œπ' ‚Üí Cardinal.{v'}\nhf : BddAbove (Set.range f)\nhf' : BddAbove (Set.range f')\ng : Œπ ‚Üí Œπ'\nh : ‚àÄ (i : Œπ), LE.le (Cardinal.lift.{v', v} (f i)) (Cardinal.lift.{v, v'} (f' (g i)))\n‚ä¢ LE.le (Cardinal.lift.{v', v} (iSup f)) (Cardinal.lift.{v, v'} (iSup f'))","decl":"/-- A variant of `lift_iSup_le_lift_iSup` with universes specialized via `w = v` and `w' = v'`.\nThis is sometimes necessary to avoid universe unification issues. -/\ntheorem lift_iSup_le_lift_iSup' {Œπ : Type v} {Œπ' : Type v'} {f : Œπ ‚Üí Cardinal.{v}}\n    {f' : Œπ' ‚Üí Cardinal.{v'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) (g : Œπ ‚Üí Œπ')\n    (h : ‚àÄ i, lift.{v'} (f i) ‚â§ lift.{v} (f' (g i))) : lift.{v'} (iSup f) ‚â§ lift.{v} (iSup f') :=\n  lift_iSup_le_lift_iSup hf hf' h\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf : Œπ ‚Üí Cardinal.{v}\nœâ : Cardinal.{v}\nhœâ : Not (Order.IsSuccPrelimit œâ)\nh : Eq (iSup fun i => f i) œâ\n‚ä¢ Exists fun i => Eq (f i) œâ","decl":"lemma exists_eq_of_iSup_eq_of_not_isSuccPrelimit\n    {Œπ : Type u} (f : Œπ ‚Üí Cardinal.{v}) (œâ : Cardinal.{v})\n    (hœâ : ¬¨ IsSuccPrelimit œâ)\n    (h : ‚®Ü i : Œπ, f i = œâ) : ‚àÉ i, f i = œâ := by\n  subst h\n  refine (isLUB_csSup' ?_).exists_of_not_isSuccPrelimit hœâ\n  contrapose! hœâ with hf\n  rw [iSup, csSup_of_not_bddAbove hf, csSup_empty]\n  exact isSuccPrelimit_bot\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nhŒπ : Nonempty Œπ\nf : Œπ ‚Üí Cardinal.{v}\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\nhc : Not (Order.IsSuccLimit c)\nh : Eq (iSup fun i => f i) c\n‚ä¢ Exists fun i => Eq (f i) c","decl":"lemma exists_eq_of_iSup_eq_of_not_isSuccLimit\n    {Œπ : Type u} [hŒπ : Nonempty Œπ] (f : Œπ ‚Üí Cardinal.{v}) (hf : BddAbove (range f))\n    {c : Cardinal.{v}} (hc : ¬¨ IsSuccLimit c)\n    (h : ‚®Ü i, f i = c) : ‚àÉ i, f i = c := by\n  rw [Cardinal.isSuccLimit_iff] at hc\n  refine (not_and_or.mp hc).elim (fun e ‚Ü¶ ‚ü®hŒπ.some, ?_‚ü©)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f c ¬∑ h)\n  cases not_not.mp e\n  rw [‚Üê le_zero_iff] at h ‚ä¢\n  exact (le_ciSup hf _).trans h\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nhŒπ : Nonempty Œπ\nf : Œπ ‚Üí Cardinal.{v}\nhf : BddAbove (Set.range f)\nœâ : Cardinal.{v}\nhœâ : Not œâ.IsLimit\nh : Eq (iSup fun i => f i) œâ\n‚ä¢ Exists fun i => Eq (f i) œâ","decl":"set_option linter.deprecated false in\n@[deprecated exists_eq_of_iSup_eq_of_not_isSuccLimit (since := \"2024-09-17\")]\nlemma exists_eq_of_iSup_eq_of_not_isLimit\n    {Œπ : Type u} [hŒπ : Nonempty Œπ] (f : Œπ ‚Üí Cardinal.{v}) (hf : BddAbove (range f))\n    (œâ : Cardinal.{v}) (hœâ : ¬¨ œâ.IsLimit)\n    (h : ‚®Ü i : Œπ, f i = œâ) : ‚àÉ i, f i = œâ := by\n  refine (not_and_or.mp hœâ).elim (fun e ‚Ü¶ ‚ü®hŒπ.some, ?_‚ü©)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f œâ ¬∑ h)\n  cases not_not.mp e\n  rw [‚Üê le_zero_iff] at h ‚ä¢\n  exact (le_ciSup hf _).trans h\n\n"}
{"name":"Cardinal.mk_pi","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nŒ± : Œπ ‚Üí Type v\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí Œ± i)) (Cardinal.prod fun i => Cardinal.mk (Œ± i))","decl":"@[simp]\ntheorem mk_pi {Œπ : Type u} (Œ± : Œπ ‚Üí Type v) : #(Œ† i, Œ± i) = prod fun i => #(Œ± i) :=\n  mk_congr <| Equiv.piCongrRight fun _ => outMkEquiv.symm\n\n"}
{"name":"Cardinal.mk_pi_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type v\nŒπ' : Type v'\nf : Œπ ‚Üí Type w\ng : Œπ' ‚Üí Type w'\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.lift.{w', w} (Cardinal.mk (f i))) (Cardinal.lift.{w, w'} (Cardinal.mk (g (e i))))\n‚ä¢ Eq (Cardinal.lift.{max v' w', max v w} (Cardinal.mk ((i : Œπ) ‚Üí f i))) (Cardinal.lift.{max v w, max v' w'} (Cardinal.mk ((i : Œπ') ‚Üí g i)))","decl":"theorem mk_pi_congr_lift {Œπ : Type v} {Œπ' : Type v'} {f : Œπ ‚Üí Type w} {g : Œπ' ‚Üí Type w'}\n    (e : Œπ ‚âÉ Œπ') (h : ‚àÄ i, lift.{w'} #(f i) = lift.{w} #(g (e i))) :\n    lift.{max v' w'} #(Œ† i, f i) = lift.{max v w} #(Œ† i, g i) :=\n  Cardinal.lift_mk_eq'.2 ‚ü®.piCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.lift_mk_eq'.1 (h i)‚ü©\n\n"}
{"name":"Cardinal.mk_pi_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ Œπ' : Type u\nf : Œπ ‚Üí Type v\ng : Œπ' ‚Üí Type v\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí f i)) (Cardinal.mk ((i : Œπ') ‚Üí g i))","decl":"theorem mk_pi_congr {Œπ Œπ' : Type u} {f : Œπ ‚Üí Type v} {g : Œπ' ‚Üí Type v} (e : Œπ ‚âÉ Œπ')\n    (h : ‚àÄ i, #(f i) = #(g (e i))) : #(Œ† i, f i) = #(Œ† i, g i) :=\n  mk_congr <| Equiv.piCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congr_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ Œπ' : Prop\nf : Œπ ‚Üí Type v\ng : Œπ' ‚Üí Type v\ne : Iff Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g ‚ãØ))\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí f i)) (Cardinal.mk ((i : Œπ') ‚Üí g i))","decl":"theorem mk_pi_congr_prop {Œπ Œπ' : Prop} {f : Œπ ‚Üí Type v} {g : Œπ' ‚Üí Type v} (e : Œπ ‚Üî Œπ')\n    (h : ‚àÄ i, #(f i) = #(g (e.mp i))) : #(Œ† i, f i) = #(Œ† i, g i) :=\n  mk_congr <| Equiv.piCongr (.ofIff e) fun i ‚Ü¶ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congr'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nŒπ' : Type v\nf : Œπ ‚Üí Type (max w u v)\ng : Œπ' ‚Üí Type (max w u v)\ne : Equiv Œπ Œπ'\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí f i)) (Cardinal.mk ((i : Œπ') ‚Üí g i))","decl":"/-- Similar to `mk_pi_congr` with indexing types in different universes. This is not a strict\ngeneralization. -/\ntheorem mk_pi_congr' {Œπ : Type u} {Œπ' : Type v} {f : Œπ ‚Üí Type max w (max u v)}\n    {g : Œπ' ‚Üí Type max w (max u v)} (e : Œπ ‚âÉ Œπ')\n    (h : ‚àÄ i, #(f i) = #(g (e i))) : #(Œ† i, f i) = #(Œ† i, g i) :=\n  mk_congr <| Equiv.piCongr e fun i ‚Ü¶ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Type v\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí f i)) (Cardinal.mk ((i : Œπ) ‚Üí g i))","decl":"theorem mk_pi_congrRight {Œπ : Type u} {f g : Œπ ‚Üí Type v} (h : ‚àÄ i, #(f i) = #(g i)) :\n    #(Œ† i, f i) = #(Œ† i, g i) :=\n  mk_pi_congr (Equiv.refl Œπ) h\n\n"}
{"name":"Cardinal.mk_pi_congrRight_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Prop\nf g : Œπ ‚Üí Type v\nh : ‚àÄ (i : Œπ), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n‚ä¢ Eq (Cardinal.mk ((i : Œπ) ‚Üí f i)) (Cardinal.mk ((i : Œπ) ‚Üí g i))","decl":"theorem mk_pi_congrRight_prop {Œπ : Prop} {f g : Œπ ‚Üí Type v} (h : ‚àÄ i, #(f i) = #(g i)) :\n    #(Œ† i, f i) = #(Œ† i, g i) :=\n  mk_pi_congr_prop Iff.rfl h\n\n"}
{"name":"Cardinal.prod_const","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\na : Cardinal.{v}\n‚ä¢ Eq (Cardinal.prod fun x => a) (HPow.hPow (Cardinal.lift.{u, v} a) (Cardinal.lift.{v, u} (Cardinal.mk Œπ)))","decl":"@[simp]\ntheorem prod_const (Œπ : Type u) (a : Cardinal.{v}) :\n    (prod fun _ : Œπ => a) = lift.{u} a ^ lift.{v} #Œπ :=\n  inductionOn a fun _ =>\n    mk_congr <| Equiv.piCongr Equiv.ulift.symm fun _ => outMkEquiv.trans Equiv.ulift.symm\n\n"}
{"name":"Cardinal.prod_const'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\na : Cardinal.{u}\n‚ä¢ Eq (Cardinal.prod fun x => a) (HPow.hPow a (Cardinal.mk Œπ))","decl":"theorem prod_const' (Œπ : Type u) (a : Cardinal.{u}) : (prod fun _ : Œπ => a) = a ^ #Œπ :=\n  inductionOn a fun _ => (mk_pi _).symm\n\n"}
{"name":"Cardinal.prod_le_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf g : Œπ ‚Üí Cardinal.{u_2}\nH : ‚àÄ (i : Œπ), LE.le (f i) (g i)\n‚ä¢ LE.le (Cardinal.prod f) (Cardinal.prod g)","decl":"theorem prod_le_prod {Œπ} (f g : Œπ ‚Üí Cardinal) (H : ‚àÄ i, f i ‚â§ g i) : prod f ‚â§ prod g :=\n  ‚ü®Embedding.piCongrRight fun i =>\n      Classical.choice <| by have := H i; rwa [‚Üê mk_out (f i), ‚Üê mk_out (g i)] at this‚ü©\n\n"}
{"name":"Cardinal.prod_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Cardinal.{u}\n‚ä¢ Iff (Eq (Cardinal.prod f) 0) (Exists fun i => Eq (f i) 0)","decl":"@[simp]\ntheorem prod_eq_zero {Œπ} (f : Œπ ‚Üí Cardinal.{u}) : prod f = 0 ‚Üî ‚àÉ i, f i = 0 := by\n  lift f to Œπ ‚Üí Type u using fun _ => trivial\n  simp only [mk_eq_zero_iff, ‚Üê mk_pi, isEmpty_pi]\n\n"}
{"name":"Cardinal.prod_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Cardinal.{u_2}\n‚ä¢ Iff (Ne (Cardinal.prod f) 0) (‚àÄ (i : Œπ), Ne (f i) 0)","decl":"theorem prod_ne_zero {Œπ} (f : Œπ ‚Üí Cardinal) : prod f ‚â† 0 ‚Üî ‚àÄ i, f i ‚â† 0 := by simp [prod_eq_zero]\n\n"}
{"name":"Cardinal.power_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\na : Cardinal.{max u_1 u_2}\nf : Œπ ‚Üí Cardinal.{max u_1 u_2}\n‚ä¢ Eq (HPow.hPow a (Cardinal.sum f)) (Cardinal.prod fun i => HPow.hPow a (f i))","decl":"theorem power_sum {Œπ} (a : Cardinal) (f : Œπ ‚Üí Cardinal) :\n    a ^ sum f = prod fun i ‚Ü¶ a ^ f i := by\n  induction a using Cardinal.inductionOn with | _ Œ± =>\n  induction f using induction_on_pi with | _ f =>\n  simp_rw [prod, sum, power_def]\n  apply mk_congr\n  refine (Equiv.piCurry fun _ _ => Œ±).trans ?_\n  refine Equiv.piCongrRight fun b => ?_\n  refine (Equiv.arrowCongr outMkEquiv (Equiv.refl Œ±)).trans ?_\n  exact outMkEquiv.symm\n\n"}
{"name":"Cardinal.lift_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\nc : Œπ ‚Üí Cardinal.{v}\n‚ä¢ Eq (Cardinal.lift.{w, max v u} (Cardinal.prod c)) (Cardinal.prod fun i => Cardinal.lift.{w, v} (c i))","decl":"@[simp]\ntheorem lift_prod {Œπ : Type u} (c : Œπ ‚Üí Cardinal.{v}) :\n    lift.{w} (prod c) = prod fun i => lift.{w} (c i) := by\n  lift c to Œπ ‚Üí Type v using fun _ => trivial\n  simp only [‚Üê mk_pi, ‚Üê mk_uLift]\n  exact mk_congr (Equiv.ulift.trans <| Equiv.piCongrRight fun i => Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.prod_eq_of_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nh : Fintype Œ±\nf : Œ± ‚Üí Cardinal.{v}\n‚ä¢ Eq (Cardinal.prod f) (Cardinal.lift.{u, v} (Finset.univ.prod fun i => f i))","decl":"theorem prod_eq_of_fintype {Œ± : Type u} [h : Fintype Œ±] (f : Œ± ‚Üí Cardinal.{v}) :\n    prod f = Cardinal.lift.{u} (‚àè i, f i) := by\n  revert f\n  refine Fintype.induction_empty_option ?_ ?_ ?_ Œ± (h_fintype := h)\n  ¬∑ intro Œ± Œ≤ hŒ≤ e h f\n    letI := Fintype.ofEquiv Œ≤ e.symm\n    rw [‚Üê e.prod_comp f, ‚Üê h]\n    exact mk_congr (e.piCongrLeft _).symm\n  ¬∑ intro f\n    rw [Fintype.univ_pempty, Finset.prod_empty, lift_one, Cardinal.prod, mk_eq_one]\n  ¬∑ intro Œ± hŒ± h f\n    rw [Cardinal.prod, mk_congr Equiv.piOptionEquivProd, mk_prod, lift_umax.{v, u}, mk_out, ‚Üê\n        Cardinal.prod, lift_prod, Fintype.prod_option, lift_mul, ‚Üê h fun a => f (some a)]\n    simp only [lift_id]\n\n"}
{"name":"Cardinal.sum_lt_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u_1\nf g : Œπ ‚Üí Cardinal.{u_2}\nH : ‚àÄ (i : Œπ), LT.lt (f i) (g i)\n‚ä¢ LT.lt (Cardinal.sum f) (Cardinal.prod g)","decl":"/-- **K√∂nig's theorem** -/\ntheorem sum_lt_prod {Œπ} (f g : Œπ ‚Üí Cardinal) (H : ‚àÄ i, f i < g i) : sum f < prod g :=\n  lt_of_not_ge fun ‚ü®F‚ü© => by\n    have : Inhabited (‚àÄ i : Œπ, (g i).out) := by\n      refine ‚ü®fun i => Classical.choice <| mk_ne_zero_iff.1 ?_‚ü©\n      rw [mk_out]\n      exact (H i).ne_bot\n    let G := invFun F\n    have sG : Surjective G := invFun_surjective F.2\n    choose C hc using\n      show ‚àÄ i, ‚àÉ b, ‚àÄ a, G ‚ü®i, a‚ü© i ‚â† b by\n        intro i\n        simp only [not_exists.symm, not_forall.symm]\n        refine fun h => (H i).not_le ?_\n        rw [‚Üê mk_out (f i), ‚Üê mk_out (g i)]\n        exact ‚ü®Embedding.ofSurjective _ h‚ü©\n    let ‚ü®‚ü®i, a‚ü©, h‚ü© := sG C\n    exact hc i a (congr_fun h _)\n\n"}
{"name":"Cardinal.mk_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Nat) Cardinal.aleph0","decl":"theorem mk_nat : #‚Ñï = ‚Ñµ‚ÇÄ :=\n  (lift_id _).symm\n\n"}
{"name":"Cardinal.aleph0_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Ne Cardinal.aleph0 0","decl":"theorem aleph0_ne_zero : ‚Ñµ‚ÇÄ ‚â† 0 :=\n  mk_ne_zero _\n\n"}
{"name":"Cardinal.aleph0_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ LT.lt 0 Cardinal.aleph0","decl":"theorem aleph0_pos : 0 < ‚Ñµ‚ÇÄ :=\n  pos_iff_ne_zero.2 aleph0_ne_zero\n\n"}
{"name":"Cardinal.lift_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.lift.{u_1, u_2} Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem lift_aleph0 : lift ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  lift_lift _\n\n"}
{"name":"Cardinal.aleph0_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (LE.le Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (LE.le Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_le_lift {c : Cardinal.{u}} : ‚Ñµ‚ÇÄ ‚â§ lift.{v} c ‚Üî ‚Ñµ‚ÇÄ ‚â§ c := by\n  simpa using lift_le (a := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.lift_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (LE.le (Cardinal.lift.{v, u} c) Cardinal.aleph0) (LE.le c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ‚â§ ‚Ñµ‚ÇÄ ‚Üî c ‚â§ ‚Ñµ‚ÇÄ := by\n  simpa using lift_le (b := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.aleph0_lt_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (LT.lt Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (LT.lt Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_lt_lift {c : Cardinal.{u}} : ‚Ñµ‚ÇÄ < lift.{v} c ‚Üî ‚Ñµ‚ÇÄ < c := by\n  simpa using lift_lt (a := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.lift_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (LT.lt (Cardinal.lift.{v, u} c) Cardinal.aleph0) (LT.lt c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_lt_aleph0 {c : Cardinal.{u}} : lift.{v} c < ‚Ñµ‚ÇÄ ‚Üî c < ‚Ñµ‚ÇÄ := by\n  simpa using lift_lt (b := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.aleph0_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (Eq Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (Eq Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_eq_lift {c : Cardinal.{u}} : ‚Ñµ‚ÇÄ = lift.{v} c ‚Üî ‚Ñµ‚ÇÄ = c := by\n  simpa using lift_inj (a := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.lift_eq_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n‚ä¢ Iff (Eq (Cardinal.lift.{v, u} c) Cardinal.aleph0) (Eq c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_eq_aleph0 {c : Cardinal.{u}} : lift.{v} c = ‚Ñµ‚ÇÄ ‚Üî c = ‚Ñµ‚ÇÄ := by\n  simpa using lift_inj (b := ‚Ñµ‚ÇÄ)\n\n"}
{"name":"Cardinal.mk_fin","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Cardinal.mk (Fin n)) ‚Üën","decl":"theorem mk_fin (n : ‚Ñï) : #(Fin n) = n := by simp\n\n"}
{"name":"Cardinal.lift_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Cardinal.lift.{u, v} ‚Üën) ‚Üën","decl":"@[simp]\ntheorem lift_natCast (n : ‚Ñï) : lift.{u} (n : Cardinal.{v}) = n := by induction n <;> simp [*]\n\n"}
{"name":"Cardinal.lift_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (Cardinal.lift.{u, v} (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem lift_ofNat (n : ‚Ñï) [n.AtLeastTwo] :\n    lift.{u} (ofNat(n) : Cardinal.{v}) = OfNat.ofNat n :=\n  lift_natCast n\n\n"}
{"name":"Cardinal.lift_eq_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n‚ä¢ Iff (Eq (Cardinal.lift.{v, u} a) ‚Üën) (Eq a ‚Üën)","decl":"@[simp]\ntheorem lift_eq_nat_iff {a : Cardinal.{u}} {n : ‚Ñï} : lift.{v} a = n ‚Üî a = n :=\n  lift_injective.eq_iff' (lift_natCast n)\n\n"}
{"name":"Cardinal.lift_eq_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (Eq (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (Eq a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_eq_ofNat_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    lift.{v} a = ofNat(n) ‚Üî a = OfNat.ofNat n :=\n  lift_eq_nat_iff\n\n"}
{"name":"Cardinal.nat_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n‚ä¢ Iff (Eq (‚Üën) (Cardinal.lift.{v, u} a)) (Eq (‚Üën) a)","decl":"@[simp]\ntheorem nat_eq_lift_iff {n : ‚Ñï} {a : Cardinal.{u}} :\n    (n : Cardinal) = lift.{v} a ‚Üî (n : Cardinal) = a := by\n  rw [‚Üê lift_natCast.{v,u} n, lift_inj]\n\n"}
{"name":"Cardinal.zero_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (Eq 0 (Cardinal.lift.{v, u} a)) (Eq 0 a)","decl":"@[simp]\ntheorem zero_eq_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) = lift.{v} a ‚Üî 0 = a := by\n  simpa using nat_eq_lift_iff (n := 0)\n\n"}
{"name":"Cardinal.one_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (Eq 1 (Cardinal.lift.{v, u} a)) (Eq 1 a)","decl":"@[simp]\ntheorem one_eq_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) = lift.{v} a ‚Üî 1 = a := by\n  simpa using nat_eq_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (Eq (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (Eq (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_eq_lift_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) = lift.{v} a ‚Üî (OfNat.ofNat n : Cardinal) = a :=\n  nat_eq_lift_iff\n\n"}
{"name":"Cardinal.lift_le_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n‚ä¢ Iff (LE.le (Cardinal.lift.{v, u} a) ‚Üën) (LE.le a ‚Üën)","decl":"@[simp]\ntheorem lift_le_nat_iff {a : Cardinal.{u}} {n : ‚Ñï} : lift.{v} a ‚â§ n ‚Üî a ‚â§ n := by\n  rw [‚Üê lift_natCast.{v,u}, lift_le]\n\n"}
{"name":"Cardinal.lift_le_one_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (LE.le (Cardinal.lift.{v, u} a) 1) (LE.le a 1)","decl":"@[simp]\ntheorem lift_le_one_iff {a : Cardinal.{u}} :\n    lift.{v} a ‚â§ 1 ‚Üî a ‚â§ 1 := by\n  simpa using lift_le_nat_iff (n := 1)\n\n"}
{"name":"Cardinal.lift_le_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (LE.le (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (LE.le a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_le_ofNat_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    lift.{v} a ‚â§ ofNat(n) ‚Üî a ‚â§ OfNat.ofNat n :=\n  lift_le_nat_iff\n\n"}
{"name":"Cardinal.nat_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n‚ä¢ Iff (LE.le (‚Üën) (Cardinal.lift.{v, u} a)) (LE.le (‚Üën) a)","decl":"@[simp]\ntheorem nat_le_lift_iff {n : ‚Ñï} {a : Cardinal.{u}} : n ‚â§ lift.{v} a ‚Üî n ‚â§ a := by\n  rw [‚Üê lift_natCast.{v,u}, lift_le]\n\n"}
{"name":"Cardinal.one_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (LE.le 1 (Cardinal.lift.{v, u} a)) (LE.le 1 a)","decl":"@[simp]\ntheorem one_le_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) ‚â§ lift.{v} a ‚Üî 1 ‚â§ a := by\n  simpa using nat_le_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (LE.le (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (LE.le (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_le_lift_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) ‚â§ lift.{v} a ‚Üî (OfNat.ofNat n : Cardinal) ‚â§ a :=\n  nat_le_lift_iff\n\n"}
{"name":"Cardinal.lift_lt_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n‚ä¢ Iff (LT.lt (Cardinal.lift.{v, u} a) ‚Üën) (LT.lt a ‚Üën)","decl":"@[simp]\ntheorem lift_lt_nat_iff {a : Cardinal.{u}} {n : ‚Ñï} : lift.{v} a < n ‚Üî a < n := by\n  rw [‚Üê lift_natCast.{v,u}, lift_lt]\n\n"}
{"name":"Cardinal.lift_lt_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (LT.lt (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (LT.lt a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_lt_ofNat_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    lift.{v} a < ofNat(n) ‚Üî a < OfNat.ofNat n :=\n  lift_lt_nat_iff\n\n"}
{"name":"Cardinal.nat_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n‚ä¢ Iff (LT.lt (‚Üën) (Cardinal.lift.{v, u} a)) (LT.lt (‚Üën) a)","decl":"@[simp]\ntheorem nat_lt_lift_iff {n : ‚Ñï} {a : Cardinal.{u}} : n < lift.{v} a ‚Üî n < a := by\n  rw [‚Üê lift_natCast.{v,u}, lift_lt]\n\n"}
{"name":"Cardinal.zero_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (LT.lt 0 (Cardinal.lift.{v, u} a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem zero_lt_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) < lift.{v} a ‚Üî 0 < a := by\n  simpa using nat_lt_lift_iff (n := 0)\n\n"}
{"name":"Cardinal.one_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n‚ä¢ Iff (LT.lt 1 (Cardinal.lift.{v, u} a)) (LT.lt 1 a)","decl":"@[simp]\ntheorem one_lt_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) < lift.{v} a ‚Üî 1 < a := by\n  simpa using nat_lt_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Iff (LT.lt (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (LT.lt (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_lt_lift_iff {a : Cardinal.{u}} {n : ‚Ñï} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) < lift.{v} a ‚Üî (OfNat.ofNat n : Cardinal) < a :=\n  nat_lt_lift_iff\n\n"}
{"name":"Cardinal.lift_mk_fin","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Cardinal.lift.{u_1, 0} (Cardinal.mk (Fin n))) ‚Üën","decl":"theorem lift_mk_fin (n : ‚Ñï) : lift #(Fin n) = n := rfl\n\n"}
{"name":"Cardinal.mk_coe_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Finset Œ±\n‚ä¢ Eq (Cardinal.mk (Subtype fun x => Membership.mem s x)) ‚Üës.card","decl":"theorem mk_coe_finset {Œ± : Type u} {s : Finset Œ±} : #s = ‚Üë(Finset.card s) := by simp\n\n"}
{"name":"Cardinal.mk_finset_of_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Fintype Œ±\n‚ä¢ Eq (Cardinal.mk (Finset Œ±)) (HPow.hPow 2 (Fintype.card Œ±))","decl":"theorem mk_finset_of_fintype [Fintype Œ±] : #(Finset Œ±) = 2 ^ Fintype.card Œ± := by\n  simp [Pow.pow]\n\n"}
{"name":"Cardinal.card_le_of_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ns : Finset Œ±\n‚ä¢ LE.le (‚Üës.card) (Cardinal.mk Œ±)","decl":"theorem card_le_of_finset {Œ±} (s : Finset Œ±) : (s.card : Cardinal) ‚â§ #Œ± :=\n  @mk_coe_finset _ s ‚ñ∏ mk_set_le _\n\n"}
{"name":"Cardinal.instCharZero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ CharZero Cardinal.{u_1}","decl":"instance : CharZero Cardinal := by\n  refine ‚ü®fun a b h ‚Ü¶ ?_‚ü©\n  rwa [‚Üê lift_mk_fin, ‚Üê lift_mk_fin, lift_inj, Cardinal.eq, ‚Üê Fintype.card_eq,\n    Fintype.card_fin, Fintype.card_fin] at h\n\n"}
{"name":"Cardinal.natCast_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n‚ä¢ Iff (LE.le ‚Üëm ‚Üën) (LE.le m n)","decl":"@[deprecated Nat.cast_le (since := \"2024-10-16\")]\ntheorem natCast_le {m n : ‚Ñï} : (m : Cardinal) ‚â§ n ‚Üî m ‚â§ n := Nat.cast_le\n\n"}
{"name":"Cardinal.natCast_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n‚ä¢ Iff (LT.lt ‚Üëm ‚Üën) (LT.lt m n)","decl":"@[deprecated Nat.cast_lt (since := \"2024-10-16\")]\ntheorem natCast_lt {m n : ‚Ñï} : (m : Cardinal) < n ‚Üî m < n := Nat.cast_lt\n\n"}
{"name":"Cardinal.natCast_inj","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n‚ä¢ Iff (Eq ‚Üëm ‚Üën) (Eq m n)","decl":"@[deprecated Nat.cast_inj (since := \"2024-10-16\")]\ntheorem natCast_inj {m n : ‚Ñï} : (m : Cardinal) = n ‚Üî m = n := Nat.cast_inj\n\n"}
{"name":"Cardinal.natCast_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Function.Injective Nat.cast","decl":"@[deprecated Nat.cast_injective (since := \"2024-10-16\")]\ntheorem natCast_injective : Injective ((‚Üë) : ‚Ñï ‚Üí Cardinal) := Nat.cast_injective\n\n"}
{"name":"Cardinal.natCast_pow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n‚ä¢ Eq (‚Üë(HPow.hPow m n)) (HPow.hPow ‚Üëm ‚Üën)","decl":"@[deprecated Nat.cast_pow (since := \"2024-10-16\")]\ntheorem natCast_pow {m n : ‚Ñï} : (‚Üë(m ^ n) : Cardinal) = (‚Üëm : Cardinal) ^ (‚Üën : Cardinal) :=\n  Nat.cast_pow m n\n\n"}
{"name":"Cardinal.nat_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (‚Üën.succ) (Order.succ ‚Üën)","decl":"@[norm_cast]\ntheorem nat_succ (n : ‚Ñï) : (n.succ : Cardinal) = succ ‚Üën := by\n  rw [Nat.cast_succ]\n  refine (add_one_le_succ _).antisymm (succ_le_of_lt ?_)\n  rw [‚Üê Nat.cast_succ]\n  exact Nat.cast_lt.2 (Nat.lt_succ_self _)\n\n"}
{"name":"Cardinal.succ_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Order.succ ‚Üën) (HAdd.hAdd (‚Üën) 1)","decl":"lemma succ_natCast (n : ‚Ñï) : Order.succ (n : Cardinal) = n + 1 := by\n  rw [‚Üê Cardinal.nat_succ]\n  norm_cast\n\n"}
{"name":"Cardinal.natCast_add_one_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nc : Cardinal.{u_1}\n‚ä¢ Iff (LE.le (HAdd.hAdd (‚Üën) 1) c) (LT.lt (‚Üën) c)","decl":"lemma natCast_add_one_le_iff {n : ‚Ñï} {c : Cardinal} : n + 1 ‚â§ c ‚Üî n < c := by\n  rw [‚Üê Order.succ_le_iff, Cardinal.succ_natCast]\n\n"}
{"name":"Cardinal.two_le_iff_one_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LE.le 2 c) (LT.lt 1 c)","decl":"lemma two_le_iff_one_lt {c : Cardinal} : 2 ‚â§ c ‚Üî 1 < c := by\n  convert natCast_add_one_le_iff\n  norm_cast\n\n"}
{"name":"Cardinal.succ_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Order.succ 0) 1","decl":"@[simp]\ntheorem succ_zero : succ (0 : Cardinal) = 1 := by norm_cast\n\n-- This works generally to prove inequalities between numeric cardinals.\n"}
{"name":"Cardinal.one_lt_two","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ LT.lt 1 2","decl":"theorem one_lt_two : (1 : Cardinal) < 2 := by norm_cast\n\n"}
{"name":"Cardinal.exists_finset_le_card","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\nn : Nat\nh : LE.le (‚Üën) (Cardinal.mk Œ±)\n‚ä¢ Exists fun s => LE.le n s.card","decl":"theorem exists_finset_le_card (Œ± : Type*) (n : ‚Ñï) (h : n ‚â§ #Œ±) :\n    ‚àÉ s : Finset Œ±, n ‚â§ s.card := by\n  obtain hŒ±|hŒ± := finite_or_infinite Œ±\n  ¬∑ let hŒ± := Fintype.ofFinite Œ±\n    use Finset.univ\n    simpa only [mk_fintype, Nat.cast_le] using h\n  ¬∑ obtain ‚ü®s, hs‚ü© := Infinite.exists_subset_card_eq Œ± n\n    exact ‚ü®s, hs.ge‚ü©\n\n"}
{"name":"Cardinal.card_le_of","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\nH : ‚àÄ (s : Finset Œ±), LE.le s.card n\n‚ä¢ LE.le (Cardinal.mk Œ±) ‚Üën","decl":"theorem card_le_of {Œ± : Type u} {n : ‚Ñï} (H : ‚àÄ s : Finset Œ±, s.card ‚â§ n) : #Œ± ‚â§ n := by\n  contrapose! H\n  apply exists_finset_le_card Œ± (n+1)\n  simpa only [nat_succ, succ_le_iff] using H\n\n"}
{"name":"Cardinal.cantor'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nhb : LT.lt 1 b\n‚ä¢ LT.lt a (HPow.hPow b a)","decl":"theorem cantor' (a) {b : Cardinal} (hb : 1 < b) : a < b ^ a := by\n  rw [‚Üê succ_le_iff, (by norm_cast : succ (1 : Cardinal) = 2)] at hb\n  exact (cantor a).trans_le (power_le_power_right hb)\n\n"}
{"name":"Cardinal.one_le_iff_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LE.le 1 c) (LT.lt 0 c)","decl":"theorem one_le_iff_pos {c : Cardinal} : 1 ‚â§ c ‚Üî 0 < c := by\n  rw [‚Üê succ_zero, succ_le_iff]\n\n"}
{"name":"Cardinal.one_le_iff_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LE.le 1 c) (Ne c 0)","decl":"theorem one_le_iff_ne_zero {c : Cardinal} : 1 ‚â§ c ‚Üî c ‚â† 0 := by\n  rw [one_le_iff_pos, pos_iff_ne_zero]\n\n"}
{"name":"Cardinal.lt_one_iff_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LT.lt c 1) (Eq c 0)","decl":"@[simp]\ntheorem lt_one_iff_zero {c : Cardinal} : c < 1 ‚Üî c = 0 := by\n  simpa using lt_succ_bot_iff (a := c)\n\n"}
{"name":"Cardinal.nat_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ LT.lt (‚Üën) Cardinal.aleph0","decl":"theorem nat_lt_aleph0 (n : ‚Ñï) : (n : Cardinal.{u}) < ‚Ñµ‚ÇÄ :=\n  succ_le_iff.1\n    (by\n      rw [‚Üê nat_succ, ‚Üê lift_mk_fin, aleph0, lift_mk_le.{u}]\n      exact ‚ü®‚ü®(‚Üë), fun a b => Fin.ext‚ü©‚ü©)\n\n"}
{"name":"Cardinal.one_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ LT.lt 1 Cardinal.aleph0","decl":"@[simp]\ntheorem one_lt_aleph0 : 1 < ‚Ñµ‚ÇÄ := by simpa using nat_lt_aleph0 1\n\n"}
{"name":"Cardinal.one_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ LE.le 1 Cardinal.aleph0","decl":"@[simp]\ntheorem one_le_aleph0 : 1 ‚â§ ‚Ñµ‚ÇÄ :=\n  one_lt_aleph0.le\n\n"}
{"name":"Cardinal.lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LT.lt c Cardinal.aleph0) (Exists fun n => Eq c ‚Üën)","decl":"theorem lt_aleph0 {c : Cardinal} : c < ‚Ñµ‚ÇÄ ‚Üî ‚àÉ n : ‚Ñï, c = n :=\n  ‚ü®fun h => by\n    rcases lt_lift_iff.1 h with ‚ü®c, h', rfl‚ü©\n    rcases le_mk_iff_exists_set.1 h'.1 with ‚ü®S, rfl‚ü©\n    suffices S.Finite by\n      lift S to Finset ‚Ñï using this\n      simp\n    contrapose! h'\n    haveI := Infinite.to_subtype h'\n    exact ‚ü®Infinite.natEmbedding S‚ü©, fun ‚ü®_, e‚ü© => e.symm ‚ñ∏ nat_lt_aleph0 _‚ü©\n\n"}
{"name":"Cardinal.succ_eq_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : LT.lt c Cardinal.aleph0\n‚ä¢ Eq (Order.succ c) (HAdd.hAdd c 1)","decl":"lemma succ_eq_of_lt_aleph0 {c : Cardinal} (h : c < ‚Ñµ‚ÇÄ) : Order.succ c = c + 1 := by\n  obtain ‚ü®n, hn‚ü© := Cardinal.lt_aleph0.mp h\n  rw [hn, succ_natCast]\n\n"}
{"name":"Cardinal.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n‚ä¢ Iff (LE.le Cardinal.aleph0 c) (‚àÄ (n : Nat), LE.le (‚Üën) c)","decl":"theorem aleph0_le {c : Cardinal} : ‚Ñµ‚ÇÄ ‚â§ c ‚Üî ‚àÄ n : ‚Ñï, ‚Üën ‚â§ c :=\n  ‚ü®fun h _ => (nat_lt_aleph0 _).le.trans h, fun h =>\n    le_of_not_lt fun hn => by\n      rcases lt_aleph0.1 hn with ‚ü®n, rfl‚ü©\n      exact (Nat.lt_succ_self _).not_le (Nat.cast_le.1 (h (n + 1)))‚ü©\n\n"}
{"name":"Cardinal.isSuccPrelimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Order.IsSuccPrelimit Cardinal.aleph0","decl":"theorem isSuccPrelimit_aleph0 : IsSuccPrelimit ‚Ñµ‚ÇÄ :=\n  isSuccPrelimit_of_succ_lt fun a ha => by\n    rcases lt_aleph0.1 ha with ‚ü®n, rfl‚ü©\n    rw [‚Üê nat_succ]\n    apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.isSuccLimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Order.IsSuccLimit Cardinal.aleph0","decl":"theorem isSuccLimit_aleph0 : IsSuccLimit ‚Ñµ‚ÇÄ := by\n  rw [Cardinal.isSuccLimit_iff]\n  exact ‚ü®aleph0_ne_zero, isSuccPrelimit_aleph0‚ü©\n\n"}
{"name":"Cardinal.not_isSuccLimit_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Not (Order.IsSuccLimit ‚Üën)","decl":"lemma not_isSuccLimit_natCast : (n : ‚Ñï) ‚Üí ¬¨ IsSuccLimit (n : Cardinal.{u})\n  | 0, e => e.1 isMin_bot\n  | Nat.succ n, e => Order.not_isSuccPrelimit_succ _ (nat_succ n ‚ñ∏ e.2)\n\n"}
{"name":"Cardinal.not_isSuccLimit_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : LT.lt c Cardinal.aleph0\n‚ä¢ Not (Order.IsSuccLimit c)","decl":"theorem not_isSuccLimit_of_lt_aleph0 {c : Cardinal} (h : c < ‚Ñµ‚ÇÄ) : ¬¨ IsSuccLimit c := by\n  obtain ‚ü®n, rfl‚ü© := lt_aleph0.1 h\n  exact not_isSuccLimit_natCast n\n\n"}
{"name":"Cardinal.aleph0_le_of_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : Order.IsSuccLimit c\n‚ä¢ LE.le Cardinal.aleph0 c","decl":"theorem aleph0_le_of_isSuccLimit {c : Cardinal} (h : IsSuccLimit c) : ‚Ñµ‚ÇÄ ‚â§ c := by\n  contrapose! h\n  exact not_isSuccLimit_of_lt_aleph0 h\n\n"}
{"name":"Cardinal.isLimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Cardinal.aleph0.IsLimit","decl":"set_option linter.deprecated false in\n@[deprecated isSuccLimit_aleph0 (since := \"2024-09-17\")]\ntheorem isLimit_aleph0 : IsLimit ‚Ñµ‚ÇÄ :=\n  ‚ü®aleph0_ne_zero, isSuccPrelimit_aleph0‚ü©\n\n"}
{"name":"Cardinal.not_isLimit_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Not (‚Üën).IsLimit","decl":"set_option linter.deprecated false in\n@[deprecated not_isSuccLimit_natCast (since := \"2024-09-17\")]\nlemma not_isLimit_natCast : (n : ‚Ñï) ‚Üí ¬¨ IsLimit (n : Cardinal.{u})\n  | 0, e => e.1 rfl\n  | Nat.succ n, e => Order.not_isSuccPrelimit_succ _ (nat_succ n ‚ñ∏ e.2)\n\n"}
{"name":"Cardinal.IsLimit.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n‚ä¢ LE.le Cardinal.aleph0 c","decl":"set_option linter.deprecated false in\n@[deprecated aleph0_le_of_isSuccLimit (since := \"2024-09-17\")]\ntheorem IsLimit.aleph0_le {c : Cardinal} (h : IsLimit c) : ‚Ñµ‚ÇÄ ‚â§ c := by\n  by_contra! h'\n  rcases lt_aleph0.1 h' with ‚ü®n, rfl‚ü©\n  exact not_isLimit_natCast n h\n\n"}
{"name":"Cardinal.exists_eq_natCast_of_iSup_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ : Type u\ninst‚úù : Nonempty Œπ\nf : Œπ ‚Üí Cardinal.{v}\nhf : BddAbove (Set.range f)\nn : Nat\nh : Eq (iSup fun i => f i) ‚Üën\n‚ä¢ Exists fun i => Eq (f i) ‚Üën","decl":"lemma exists_eq_natCast_of_iSup_eq {Œπ : Type u} [Nonempty Œπ] (f : Œπ ‚Üí Cardinal.{v})\n    (hf : BddAbove (range f)) (n : ‚Ñï) (h : ‚®Ü i, f i = n) : ‚àÉ i, f i = n :=\n  exists_eq_of_iSup_eq_of_not_isSuccLimit.{u, v} f hf (not_isSuccLimit_natCast n) h\n\n"}
{"name":"Cardinal.range_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Set.range Nat.cast) (Set.Iio Cardinal.aleph0)","decl":"@[simp]\ntheorem range_natCast : range ((‚Üë) : ‚Ñï ‚Üí Cardinal) = Iio ‚Ñµ‚ÇÄ :=\n  ext fun x => by simp only [mem_Iio, mem_range, eq_comm, lt_aleph0]\n\n"}
{"name":"Cardinal.mk_eq_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) ‚Üën) (Nonempty (Equiv Œ± (Fin n)))","decl":"theorem mk_eq_nat_iff {Œ± : Type u} {n : ‚Ñï} : #Œ± = n ‚Üî Nonempty (Œ± ‚âÉ Fin n) := by\n  rw [‚Üê lift_mk_fin, ‚Üê lift_uzero #Œ±, lift_mk_eq']\n\n"}
{"name":"Cardinal.lt_aleph0_iff_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LT.lt (Cardinal.mk Œ±) Cardinal.aleph0) (Finite Œ±)","decl":"theorem lt_aleph0_iff_finite {Œ± : Type u} : #Œ± < ‚Ñµ‚ÇÄ ‚Üî Finite Œ± := by\n  simp only [lt_aleph0, mk_eq_nat_iff, finite_iff_exists_equiv_fin]\n\n"}
{"name":"Cardinal.lt_aleph0_iff_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LT.lt (Cardinal.mk Œ±) Cardinal.aleph0) (Nonempty (Fintype Œ±))","decl":"theorem lt_aleph0_iff_fintype {Œ± : Type u} : #Œ± < ‚Ñµ‚ÇÄ ‚Üî Nonempty (Fintype Œ±) :=\n  lt_aleph0_iff_finite.trans (finite_iff_nonempty_fintype _)\n\n"}
{"name":"Cardinal.lt_aleph0_of_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Finite Œ±\n‚ä¢ LT.lt (Cardinal.mk Œ±) Cardinal.aleph0","decl":"theorem lt_aleph0_of_finite (Œ± : Type u) [Finite Œ±] : #Œ± < ‚Ñµ‚ÇÄ :=\n  lt_aleph0_iff_finite.2 ‚Äπ_‚Ä∫\n\n"}
{"name":"Cardinal.lt_aleph0_iff_set_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS : Set Œ±\n‚ä¢ Iff (LT.lt (Cardinal.mk ‚ÜëS) Cardinal.aleph0) S.Finite","decl":"theorem lt_aleph0_iff_set_finite {S : Set Œ±} : #S < ‚Ñµ‚ÇÄ ‚Üî S.Finite :=\n  lt_aleph0_iff_finite.trans finite_coe_iff\n\n"}
{"name":"Set.Finite.lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS : Set Œ±\na‚úù : S.Finite\n‚ä¢ LT.lt (Cardinal.mk ‚ÜëS) Cardinal.aleph0","decl":"alias ‚ü®_, _root_.Set.Finite.lt_aleph0‚ü© := lt_aleph0_iff_set_finite\n\n"}
{"name":"Cardinal.lt_aleph0_iff_subtype_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\np : Œ± ‚Üí Prop\n‚ä¢ Iff (LT.lt (Cardinal.mk (Subtype fun x => p x)) Cardinal.aleph0) (setOf fun x => p x).Finite","decl":"@[simp]\ntheorem lt_aleph0_iff_subtype_finite {p : Œ± ‚Üí Prop} : #{ x // p x } < ‚Ñµ‚ÇÄ ‚Üî { x | p x }.Finite :=\n  lt_aleph0_iff_set_finite\n\n"}
{"name":"Cardinal.mk_le_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LE.le (Cardinal.mk Œ±) Cardinal.aleph0) (Countable Œ±)","decl":"theorem mk_le_aleph0_iff : #Œ± ‚â§ ‚Ñµ‚ÇÄ ‚Üî Countable Œ± := by\n  rw [countable_iff_nonempty_embedding, aleph0, ‚Üê lift_uzero #Œ±, lift_mk_le']\n\n"}
{"name":"Cardinal.mk_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Countable Œ±\n‚ä¢ LE.le (Cardinal.mk Œ±) Cardinal.aleph0","decl":"@[simp]\ntheorem mk_le_aleph0 [Countable Œ±] : #Œ± ‚â§ ‚Ñµ‚ÇÄ :=\n  mk_le_aleph0_iff.mpr ‚Äπ_‚Ä∫\n\n"}
{"name":"Cardinal.le_aleph0_iff_set_countable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Iff (LE.le (Cardinal.mk ‚Üës) Cardinal.aleph0) s.Countable","decl":"theorem le_aleph0_iff_set_countable {s : Set Œ±} : #s ‚â§ ‚Ñµ‚ÇÄ ‚Üî s.Countable := mk_le_aleph0_iff\n\n"}
{"name":"Set.Countable.le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\na‚úù : s.Countable\n‚ä¢ LE.le (Cardinal.mk ‚Üës) Cardinal.aleph0","decl":"alias ‚ü®_, _root_.Set.Countable.le_aleph0‚ü© := le_aleph0_iff_set_countable\n\n"}
{"name":"Cardinal.le_aleph0_iff_subtype_countable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\np : Œ± ‚Üí Prop\n‚ä¢ Iff (LE.le (Cardinal.mk (Subtype fun x => p x)) Cardinal.aleph0) (setOf fun x => p x).Countable","decl":"@[simp]\ntheorem le_aleph0_iff_subtype_countable {p : Œ± ‚Üí Prop} :\n    #{ x // p x } ‚â§ ‚Ñµ‚ÇÄ ‚Üî { x | p x }.Countable :=\n  le_aleph0_iff_set_countable\n\n"}
{"name":"Cardinal.aleph0_lt_mk_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LT.lt Cardinal.aleph0 (Cardinal.mk Œ±)) (Uncountable Œ±)","decl":"theorem aleph0_lt_mk_iff : ‚Ñµ‚ÇÄ < #Œ± ‚Üî Uncountable Œ± := by\n  rw [‚Üê not_le, ‚Üê not_countable_iff, not_iff_not, mk_le_aleph0_iff]\n\n"}
{"name":"Cardinal.aleph0_lt_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Uncountable Œ±\n‚ä¢ LT.lt Cardinal.aleph0 (Cardinal.mk Œ±)","decl":"@[simp]\ntheorem aleph0_lt_mk [Uncountable Œ±] : ‚Ñµ‚ÇÄ < #Œ± :=\n  aleph0_lt_mk_iff.mpr ‚Äπ_‚Ä∫\n\n"}
{"name":"Cardinal.canLiftCardinalNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ CanLift Cardinal.{u_1} Nat Nat.cast fun x => LT.lt x Cardinal.aleph0","decl":"instance canLiftCardinalNat : CanLift Cardinal ‚Ñï (‚Üë) fun x => x < ‚Ñµ‚ÇÄ :=\n  ‚ü®fun _ hx =>\n    let ‚ü®n, hn‚ü© := lt_aleph0.mp hx\n    ‚ü®n, hn.symm‚ü©‚ü©\n\n"}
{"name":"Cardinal.add_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n‚ä¢ LT.lt (HAdd.hAdd a b) Cardinal.aleph0","decl":"theorem add_lt_aleph0 {a b : Cardinal} (ha : a < ‚Ñµ‚ÇÄ) (hb : b < ‚Ñµ‚ÇÄ) : a + b < ‚Ñµ‚ÇÄ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ‚ü®m, rfl‚ü©, ‚ü®n, rfl‚ü© => by rw [‚Üê Nat.cast_add]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.add_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n‚ä¢ Iff (LT.lt (HAdd.hAdd a b) Cardinal.aleph0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))","decl":"theorem add_lt_aleph0_iff {a b : Cardinal} : a + b < ‚Ñµ‚ÇÄ ‚Üî a < ‚Ñµ‚ÇÄ ‚àß b < ‚Ñµ‚ÇÄ :=\n  ‚ü®fun h => ‚ü®(self_le_add_right _ _).trans_lt h, (self_le_add_left _ _).trans_lt h‚ü©,\n   fun ‚ü®h1, h2‚ü© => add_lt_aleph0 h1 h2‚ü©\n\n"}
{"name":"Cardinal.aleph0_le_add_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n‚ä¢ Iff (LE.le Cardinal.aleph0 (HAdd.hAdd a b)) (Or (LE.le Cardinal.aleph0 a) (LE.le Cardinal.aleph0 b))","decl":"theorem aleph0_le_add_iff {a b : Cardinal} : ‚Ñµ‚ÇÄ ‚â§ a + b ‚Üî ‚Ñµ‚ÇÄ ‚â§ a ‚à® ‚Ñµ‚ÇÄ ‚â§ b := by\n  simp only [‚Üê not_lt, add_lt_aleph0_iff, not_and_or]\n\n"}
{"name":"Cardinal.nsmul_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u_1}\n‚ä¢ Iff (LT.lt (HSMul.hSMul n a) Cardinal.aleph0) (Or (Eq n 0) (LT.lt a Cardinal.aleph0))","decl":"/-- See also `Cardinal.nsmul_lt_aleph0_iff_of_ne_zero` if you already have `n ‚â† 0`. -/\ntheorem nsmul_lt_aleph0_iff {n : ‚Ñï} {a : Cardinal} : n ‚Ä¢ a < ‚Ñµ‚ÇÄ ‚Üî n = 0 ‚à® a < ‚Ñµ‚ÇÄ := by\n  cases n with\n  | zero => simpa using nat_lt_aleph0 0\n  | succ n =>\n      simp only [Nat.succ_ne_zero, false_or]\n      induction' n with n ih\n      ¬∑ simp\n      rw [succ_nsmul, add_lt_aleph0_iff, ih, and_self_iff]\n\n"}
{"name":"Cardinal.nsmul_lt_aleph0_iff_of_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u_1}\nh : Ne n 0\n‚ä¢ Iff (LT.lt (HSMul.hSMul n a) Cardinal.aleph0) (LT.lt a Cardinal.aleph0)","decl":"/-- See also `Cardinal.nsmul_lt_aleph0_iff` for a hypothesis-free version. -/\ntheorem nsmul_lt_aleph0_iff_of_ne_zero {n : ‚Ñï} {a : Cardinal} (h : n ‚â† 0) : n ‚Ä¢ a < ‚Ñµ‚ÇÄ ‚Üî a < ‚Ñµ‚ÇÄ :=\n  nsmul_lt_aleph0_iff.trans <| or_iff_right h\n\n"}
{"name":"Cardinal.mul_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n‚ä¢ LT.lt (HMul.hMul a b) Cardinal.aleph0","decl":"theorem mul_lt_aleph0 {a b : Cardinal} (ha : a < ‚Ñµ‚ÇÄ) (hb : b < ‚Ñµ‚ÇÄ) : a * b < ‚Ñµ‚ÇÄ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ‚ü®m, rfl‚ü©, ‚ü®n, rfl‚ü© => by rw [‚Üê Nat.cast_mul]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.mul_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n‚ä¢ Iff (LT.lt (HMul.hMul a b) Cardinal.aleph0) (Or (Eq a 0) (Or (Eq b 0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))))","decl":"theorem mul_lt_aleph0_iff {a b : Cardinal} : a * b < ‚Ñµ‚ÇÄ ‚Üî a = 0 ‚à® b = 0 ‚à® a < ‚Ñµ‚ÇÄ ‚àß b < ‚Ñµ‚ÇÄ := by\n  refine ‚ü®fun h => ?_, ?_‚ü©\n  ¬∑ by_cases ha : a = 0\n    ¬∑ exact Or.inl ha\n    right\n    by_cases hb : b = 0\n    ¬∑ exact Or.inl hb\n    right\n    rw [‚Üê Ne, ‚Üê one_le_iff_ne_zero] at ha hb\n    constructor\n    ¬∑ rw [‚Üê mul_one a]\n      exact (mul_le_mul' le_rfl hb).trans_lt h\n    ¬∑ rw [‚Üê one_mul b]\n      exact (mul_le_mul' ha le_rfl).trans_lt h\n  rintro (rfl | rfl | ‚ü®ha, hb‚ü©) <;> simp only [*, mul_lt_aleph0, aleph0_pos, zero_mul, mul_zero]\n\n"}
{"name":"Cardinal.aleph0_le_mul_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n‚ä¢ Iff (LE.le Cardinal.aleph0 (HMul.hMul a b)) (And (Ne a 0) (And (Ne b 0) (Or (LE.le Cardinal.aleph0 a) (LE.le Cardinal.aleph0 b))))","decl":"/-- See also `Cardinal.aleph0_le_mul_iff`. -/\ntheorem aleph0_le_mul_iff {a b : Cardinal} : ‚Ñµ‚ÇÄ ‚â§ a * b ‚Üî a ‚â† 0 ‚àß b ‚â† 0 ‚àß (‚Ñµ‚ÇÄ ‚â§ a ‚à® ‚Ñµ‚ÇÄ ‚â§ b) := by\n  let h := (@mul_lt_aleph0_iff a b).not\n  rwa [not_lt, not_or, not_or, not_and_or, not_lt, not_lt] at h\n\n"}
{"name":"Cardinal.aleph0_le_mul_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n‚ä¢ Iff (LE.le Cardinal.aleph0 (HMul.hMul a b)) (Or (And (Ne a 0) (LE.le Cardinal.aleph0 b)) (And (LE.le Cardinal.aleph0 a) (Ne b 0)))","decl":"/-- See also `Cardinal.aleph0_le_mul_iff'`. -/\ntheorem aleph0_le_mul_iff' {a b : Cardinal.{u}} : ‚Ñµ‚ÇÄ ‚â§ a * b ‚Üî a ‚â† 0 ‚àß ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ a ‚àß b ‚â† 0 := by\n  have : ‚àÄ {a : Cardinal.{u}}, ‚Ñµ‚ÇÄ ‚â§ a ‚Üí a ‚â† 0 := fun a => ne_bot_of_le_ne_bot aleph0_ne_zero a\n  simp only [aleph0_le_mul_iff, and_or_left, and_iff_right_of_imp this, @and_left_comm (a ‚â† 0)]\n  simp only [and_comm, or_comm]\n\n"}
{"name":"Cardinal.mul_lt_aleph0_iff_of_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : Ne a 0\nhb : Ne b 0\n‚ä¢ Iff (LT.lt (HMul.hMul a b) Cardinal.aleph0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))","decl":"theorem mul_lt_aleph0_iff_of_ne_zero {a b : Cardinal} (ha : a ‚â† 0) (hb : b ‚â† 0) :\n    a * b < ‚Ñµ‚ÇÄ ‚Üî a < ‚Ñµ‚ÇÄ ‚àß b < ‚Ñµ‚ÇÄ := by simp [mul_lt_aleph0_iff, ha, hb]\n\n"}
{"name":"Cardinal.power_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n‚ä¢ LT.lt (HPow.hPow a b) Cardinal.aleph0","decl":"theorem power_lt_aleph0 {a b : Cardinal} (ha : a < ‚Ñµ‚ÇÄ) (hb : b < ‚Ñµ‚ÇÄ) : a ^ b < ‚Ñµ‚ÇÄ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ‚ü®m, rfl‚ü©, ‚ü®n, rfl‚ü© => by rw [power_natCast, ‚Üê Nat.cast_pow]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.eq_one_iff_unique","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) 1) (And (Subsingleton Œ±) (Nonempty Œ±))","decl":"theorem eq_one_iff_unique {Œ± : Type*} : #Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=\n  calc\n    #Œ± = 1 ‚Üî #Œ± ‚â§ 1 ‚àß 1 ‚â§ #Œ± := le_antisymm_iff\n    _ ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=\n      le_one_iff_subsingleton.and (one_le_iff_ne_zero.trans mk_ne_zero_iff)\n\n"}
{"name":"Cardinal.infinite_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (Infinite Œ±) (LE.le Cardinal.aleph0 (Cardinal.mk Œ±))","decl":"theorem infinite_iff {Œ± : Type u} : Infinite Œ± ‚Üî ‚Ñµ‚ÇÄ ‚â§ #Œ± := by\n  rw [‚Üê not_lt, lt_aleph0_iff_finite, not_finite_iff_infinite]\n\n"}
{"name":"Cardinal.aleph0_le_mk_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LE.le Cardinal.aleph0 (Cardinal.mk Œ±)) (Infinite Œ±)","decl":"lemma aleph0_le_mk_iff : ‚Ñµ‚ÇÄ ‚â§ #Œ± ‚Üî Infinite Œ± := infinite_iff.symm\n"}
{"name":"Cardinal.mk_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LT.lt (Cardinal.mk Œ±) Cardinal.aleph0) (Finite Œ±)","decl":"lemma mk_lt_aleph0_iff : #Œ± < ‚Ñµ‚ÇÄ ‚Üî Finite Œ± := by simp [‚Üê not_le, aleph0_le_mk_iff]\n\n"}
{"name":"Cardinal.aleph0_le_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Infinite Œ±\n‚ä¢ LE.le Cardinal.aleph0 (Cardinal.mk Œ±)","decl":"@[simp]\ntheorem aleph0_le_mk (Œ± : Type u) [Infinite Œ±] : ‚Ñµ‚ÇÄ ‚â§ #Œ± :=\n  infinite_iff.1 ‚Äπ_‚Ä∫\n\n"}
{"name":"Cardinal.mk_eq_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Countable Œ±\ninst‚úù : Infinite Œ±\n‚ä¢ Eq (Cardinal.mk Œ±) Cardinal.aleph0","decl":"@[simp]\ntheorem mk_eq_aleph0 (Œ± : Type*) [Countable Œ±] [Infinite Œ±] : #Œ± = ‚Ñµ‚ÇÄ :=\n  mk_le_aleph0.antisymm <| aleph0_le_mk _\n\n"}
{"name":"Cardinal.denumerable_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (Nonempty (Denumerable Œ±)) (Eq (Cardinal.mk Œ±) Cardinal.aleph0)","decl":"theorem denumerable_iff {Œ± : Type u} : Nonempty (Denumerable Œ±) ‚Üî #Œ± = ‚Ñµ‚ÇÄ :=\n  ‚ü®fun ‚ü®h‚ü© => mk_congr ((@Denumerable.eqv Œ± h).trans Equiv.ulift.symm), fun h => by\n    cases' Quotient.exact h with f\n    exact ‚ü®Denumerable.mk' <| f.trans Equiv.ulift‚ü©‚ü©\n\n"}
{"name":"Cardinal.mk_denumerable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ninst‚úù : Denumerable Œ±\n‚ä¢ Eq (Cardinal.mk Œ±) Cardinal.aleph0","decl":"theorem mk_denumerable (Œ± : Type u) [Denumerable Œ±] : #Œ± = ‚Ñµ‚ÇÄ :=\n  denumerable_iff.1 ‚ü®‚Äπ_‚Ä∫‚ü©\n\n"}
{"name":"Set.countable_infinite_iff_nonempty_denumerable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ns : Set Œ±\n‚ä¢ Iff (And s.Countable s.Infinite) (Nonempty (Denumerable ‚Üës))","decl":"theorem _root_.Set.countable_infinite_iff_nonempty_denumerable {Œ± : Type*} {s : Set Œ±} :\n    s.Countable ‚àß s.Infinite ‚Üî Nonempty (Denumerable s) := by\n  rw [nonempty_denumerable_iff, ‚Üê Set.infinite_coe_iff, countable_coe_iff]\n\n"}
{"name":"Cardinal.aleph0_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (HAdd.hAdd Cardinal.aleph0 Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_aleph0 : ‚Ñµ‚ÇÄ + ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  mk_denumerable _\n\n"}
{"name":"Cardinal.aleph0_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (HMul.hMul Cardinal.aleph0 Cardinal.aleph0) Cardinal.aleph0","decl":"theorem aleph0_mul_aleph0 : ‚Ñµ‚ÇÄ * ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  mk_denumerable _\n\n"}
{"name":"Cardinal.nat_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n‚ä¢ Eq (HMul.hMul (‚Üën) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem nat_mul_aleph0 {n : ‚Ñï} (hn : n ‚â† 0) : ‚Üën * ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  le_antisymm (lift_mk_fin n ‚ñ∏ mk_le_aleph0) <|\n    le_mul_of_one_le_left (zero_le _) <| by\n      rwa [‚Üê Nat.cast_one, Nat.cast_le, Nat.one_le_iff_ne_zero]\n\n"}
{"name":"Cardinal.aleph0_mul_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n‚ä¢ Eq (HMul.hMul Cardinal.aleph0 ‚Üën) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_mul_nat {n : ‚Ñï} (hn : n ‚â† 0) : ‚Ñµ‚ÇÄ * n = ‚Ñµ‚ÇÄ := by rw [mul_comm, nat_mul_aleph0 hn]\n\n"}
{"name":"Cardinal.ofNat_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (HMul.hMul (OfNat.ofNat n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem ofNat_mul_aleph0 {n : ‚Ñï} [Nat.AtLeastTwo n] : ofNat(n) * ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  nat_mul_aleph0 (NeZero.ne n)\n\n"}
{"name":"Cardinal.aleph0_mul_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (HMul.hMul Cardinal.aleph0 (OfNat.ofNat n)) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_mul_ofNat {n : ‚Ñï} [Nat.AtLeastTwo n] : ‚Ñµ‚ÇÄ * ofNat(n) = ‚Ñµ‚ÇÄ :=\n  aleph0_mul_nat (NeZero.ne n)\n\n"}
{"name":"Cardinal.add_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c‚ÇÅ c‚ÇÇ : Cardinal.{u_1}\n‚ä¢ Iff (LE.le (HAdd.hAdd c‚ÇÅ c‚ÇÇ) Cardinal.aleph0) (And (LE.le c‚ÇÅ Cardinal.aleph0) (LE.le c‚ÇÇ Cardinal.aleph0))","decl":"@[simp]\ntheorem add_le_aleph0 {c‚ÇÅ c‚ÇÇ : Cardinal} : c‚ÇÅ + c‚ÇÇ ‚â§ ‚Ñµ‚ÇÄ ‚Üî c‚ÇÅ ‚â§ ‚Ñµ‚ÇÄ ‚àß c‚ÇÇ ‚â§ ‚Ñµ‚ÇÄ :=\n  ‚ü®fun h => ‚ü®le_self_add.trans h, le_add_self.trans h‚ü©, fun h =>\n    aleph0_add_aleph0 ‚ñ∏ add_le_add h.1 h.2‚ü©\n\n"}
{"name":"Cardinal.aleph0_add_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (HAdd.hAdd Cardinal.aleph0 ‚Üën) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_nat (n : ‚Ñï) : ‚Ñµ‚ÇÄ + n = ‚Ñµ‚ÇÄ :=\n  (add_le_aleph0.2 ‚ü®le_rfl, (nat_lt_aleph0 n).le‚ü©).antisymm le_self_add\n\n"}
{"name":"Cardinal.nat_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (HAdd.hAdd (‚Üën) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem nat_add_aleph0 (n : ‚Ñï) : ‚Üën + ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ := by rw [add_comm, aleph0_add_nat]\n\n"}
{"name":"Cardinal.ofNat_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (HAdd.hAdd (OfNat.ofNat n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem ofNat_add_aleph0 {n : ‚Ñï} [Nat.AtLeastTwo n] : ofNat(n) + ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ :=\n  nat_add_aleph0 n\n\n"}
{"name":"Cardinal.aleph0_add_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (HAdd.hAdd Cardinal.aleph0 (OfNat.ofNat n)) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_ofNat {n : ‚Ñï} [Nat.AtLeastTwo n] : ‚Ñµ‚ÇÄ + ofNat(n) = ‚Ñµ‚ÇÄ :=\n  aleph0_add_nat n\n\n"}
{"name":"Cardinal.exists_nat_eq_of_le_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nn : Nat\nh : LE.le c ‚Üën\n‚ä¢ Exists fun m => And (LE.le m n) (Eq c ‚Üëm)","decl":"theorem exists_nat_eq_of_le_nat {c : Cardinal} {n : ‚Ñï} (h : c ‚â§ n) : ‚àÉ m, m ‚â§ n ‚àß c = m := by\n  lift c to ‚Ñï using h.trans_lt (nat_lt_aleph0 _)\n  exact ‚ü®c, mod_cast h, rfl‚ü©\n\n"}
{"name":"Cardinal.mk_int","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Int) Cardinal.aleph0","decl":"theorem mk_int : #‚Ñ§ = ‚Ñµ‚ÇÄ :=\n  mk_denumerable ‚Ñ§\n\n"}
{"name":"Cardinal.mk_pNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk PNat) Cardinal.aleph0","decl":"theorem mk_pNat : #‚Ñï+ = ‚Ñµ‚ÇÄ :=\n  mk_denumerable ‚Ñï+\n\n"}
{"name":"Cardinal.mk_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Empty) 0","decl":"theorem mk_empty : #Empty = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_pempty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk PEmpty.{u_1 + 1}) 0","decl":"theorem mk_pempty : #PEmpty = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_punit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk PUnit.{u_1 + 1}) 1","decl":"theorem mk_punit : #PUnit = 1 :=\n  mk_eq_one PUnit\n\n"}
{"name":"Cardinal.mk_unit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk Unit) 1","decl":"theorem mk_unit : #Unit = 1 :=\n  mk_punit\n\n"}
{"name":"Cardinal.mk_additive","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (Additive Œ±)) (Cardinal.mk Œ±)","decl":"@[simp] theorem mk_additive : #(Additive Œ±) = #Œ± := rfl\n\n"}
{"name":"Cardinal.mk_multiplicative","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (Multiplicative Œ±)) (Cardinal.mk Œ±)","decl":"@[simp] theorem mk_multiplicative : #(Multiplicative Œ±) = #Œ± := rfl\n\n"}
{"name":"Cardinal.mk_addOpposite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (AddOpposite Œ±)) (Cardinal.mk Œ±)","decl":"@[to_additive (attr := simp)] theorem mk_mulOpposite : #(MulOpposite Œ±) = #Œ± :=\n  mk_congr MulOpposite.opEquiv.symm\n\n"}
{"name":"Cardinal.mk_mulOpposite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (MulOpposite Œ±)) (Cardinal.mk Œ±)","decl":"@[to_additive (attr := simp)] theorem mk_mulOpposite : #(MulOpposite Œ±) = #Œ± :=\n  mk_congr MulOpposite.opEquiv.symm\n\n"}
{"name":"Cardinal.mk_singleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nx : Œ±\n‚ä¢ Eq (Cardinal.mk ‚Üë(Singleton.singleton x)) 1","decl":"theorem mk_singleton {Œ± : Type u} (x : Œ±) : #({x} : Set Œ±) = 1 :=\n  mk_eq_one _\n\n"}
{"name":"Cardinal.mk_plift_true","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk (PLift True)) 1","decl":"theorem mk_plift_true : #(PLift True) = 1 :=\n  mk_eq_one _\n\n"}
{"name":"Cardinal.mk_plift_false","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"‚ä¢ Eq (Cardinal.mk (PLift False)) 0","decl":"theorem mk_plift_false : #(PLift False) = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_vector","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\n‚ä¢ Eq (Cardinal.mk (List.Vector Œ± n)) (HPow.hPow (Cardinal.mk Œ±) n)","decl":"@[simp]\ntheorem mk_vector (Œ± : Type u) (n : ‚Ñï) : #(List.Vector Œ± n) = #Œ± ^ n :=\n  (mk_congr (Equiv.vectorEquivFin Œ± n)).trans <| by simp\n\n"}
{"name":"Cardinal.mk_list_eq_sum_pow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk (List Œ±)) (Cardinal.sum fun n => HPow.hPow (Cardinal.mk Œ±) n)","decl":"theorem mk_list_eq_sum_pow (Œ± : Type u) : #(List Œ±) = sum fun n : ‚Ñï => #Œ± ^ n :=\n  calc\n    #(List Œ±) = #(Œ£n, List.Vector Œ± n) := mk_congr (Equiv.sigmaFiberEquiv List.length).symm\n    _ = sum fun n : ‚Ñï => #Œ± ^ n := by simp\n\n"}
{"name":"Cardinal.mk_quot_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ LE.le (Cardinal.mk (Quot r)) (Cardinal.mk Œ±)","decl":"theorem mk_quot_le {Œ± : Type u} {r : Œ± ‚Üí Œ± ‚Üí Prop} : #(Quot r) ‚â§ #Œ± :=\n  mk_le_of_surjective Quot.exists_rep\n\n"}
{"name":"Cardinal.mk_quotient_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Setoid Œ±\n‚ä¢ LE.le (Cardinal.mk (Quotient s)) (Cardinal.mk Œ±)","decl":"theorem mk_quotient_le {Œ± : Type u} {s : Setoid Œ±} : #(Quotient s) ‚â§ #Œ± :=\n  mk_quot_le\n\n"}
{"name":"Cardinal.mk_subtype_le_of_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\np q : Œ± ‚Üí Prop\nh : ‚àÄ ‚¶Éx : Œ±‚¶Ñ, p x ‚Üí q x\n‚ä¢ LE.le (Cardinal.mk (Subtype p)) (Cardinal.mk (Subtype q))","decl":"theorem mk_subtype_le_of_subset {Œ± : Type u} {p q : Œ± ‚Üí Prop} (h : ‚àÄ ‚¶Éx‚¶Ñ, p x ‚Üí q x) :\n    #(Subtype p) ‚â§ #(Subtype q) :=\n  ‚ü®Embedding.subtypeMap (Embedding.refl Œ±) h‚ü©\n\n"}
{"name":"Cardinal.mk_emptyCollection","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk ‚ÜëEmptyCollection.emptyCollection) 0","decl":"theorem mk_emptyCollection (Œ± : Type u) : #(‚àÖ : Set Œ±) = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_emptyCollection_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Iff (Eq (Cardinal.mk ‚Üës) 0) (Eq s EmptyCollection.emptyCollection)","decl":"theorem mk_emptyCollection_iff {Œ± : Type u} {s : Set Œ±} : #s = 0 ‚Üî s = ‚àÖ := by\n  constructor\n  ¬∑ intro h\n    rw [mk_eq_zero_iff] at h\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => h.elim' ‚ü®x, hx‚ü©\n  ¬∑ rintro rfl\n    exact mk_emptyCollection _\n\n"}
{"name":"Cardinal.mk_univ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Cardinal.mk ‚ÜëSet.univ) (Cardinal.mk Œ±)","decl":"@[simp]\ntheorem mk_univ {Œ± : Type u} : #(@univ Œ±) = #Œ± :=\n  mk_congr (Equiv.Set.univ Œ±)\n\n"}
{"name":"Cardinal.mk_setProd","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\ns : Set Œ±\nt : Set Œ≤\n‚ä¢ Eq (Cardinal.mk ‚Üë(SProd.sprod s t)) (HMul.hMul (Cardinal.mk ‚Üës) (Cardinal.mk ‚Üët))","decl":"@[simp] lemma mk_setProd {Œ± Œ≤ : Type u} (s : Set Œ±) (t : Set Œ≤) : #(s √óÀ¢ t) = #s * #t := by\n  rw [mul_def, mk_congr (Equiv.Set.prod ..)]\n\n"}
{"name":"Cardinal.mk_image_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.image f s)) (Cardinal.mk ‚Üës)","decl":"theorem mk_image_le {Œ± Œ≤ : Type u} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} : #(f '' s) ‚â§ #s :=\n  mk_le_of_surjective surjective_onto_image\n\n"}
{"name":"Cardinal.mk_image2_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ Œ≥ : Type u\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\ns : Set Œ±\nt : Set Œ≤\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.image2 f s t)) (HMul.hMul (Cardinal.mk ‚Üës) (Cardinal.mk ‚Üët))","decl":"lemma mk_image2_le {Œ± Œ≤ Œ≥ : Type u} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : Set Œ±} {t : Set Œ≤} :\n    #(image2 f s t) ‚â§ #s * #t := by\n  rw [‚Üê image_uncurry_prod, ‚Üê mk_setProd]\n  exact mk_image_le\n\n"}
{"name":"Cardinal.mk_image_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üës))","decl":"theorem mk_image_le_lift {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    lift.{u} #(f '' s) ‚â§ lift.{v} #s :=\n  lift_mk_le.{0}.mpr ‚ü®Embedding.ofSurjective _ surjective_onto_image‚ü©\n\n"}
{"name":"Cardinal.mk_range_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.range f)) (Cardinal.mk Œ±)","decl":"theorem mk_range_le {Œ± Œ≤ : Type u} {f : Œ± ‚Üí Œ≤} : #(range f) ‚â§ #Œ± :=\n  mk_le_of_surjective surjective_onto_range\n\n"}
{"name":"Cardinal.mk_range_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\n‚ä¢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.range f))) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"theorem mk_range_le_lift {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} :\n    lift.{u} #(range f) ‚â§ lift.{v} #Œ± :=\n  lift_mk_le.{0}.mpr ‚ü®Embedding.ofSurjective _ surjective_onto_range‚ü©\n\n"}
{"name":"Cardinal.mk_range_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\nh : Function.Injective f\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.range f)) (Cardinal.mk Œ±)","decl":"theorem mk_range_eq (f : Œ± ‚Üí Œ≤) (h : Injective f) : #(range f) = #Œ± :=\n  mk_congr (Equiv.ofInjective f h).symm\n\n"}
{"name":"Cardinal.mk_range_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ Eq (Cardinal.lift.{max u w, v} (Cardinal.mk ‚Üë(Set.range f))) (Cardinal.lift.{max v w, u} (Cardinal.mk Œ±))","decl":"theorem mk_range_eq_lift {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} (hf : Injective f) :\n    lift.{max u w} #(range f) = lift.{max v w} #Œ± :=\n  lift_mk_eq.{v,u,w}.mpr ‚ü®(Equiv.ofInjective f hf).symm‚ü©\n\n"}
{"name":"Cardinal.mk_range_eq_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.range f))) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"theorem mk_range_eq_of_injective {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} (hf : Injective f) :\n    lift.{u} #(range f) = lift.{v} #Œ± :=\n  lift_mk_eq'.mpr ‚ü®(Equiv.ofInjective f hf).symm‚ü©\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk Œ±)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))","decl":"lemma lift_mk_le_lift_mk_of_injective {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} (hf : Injective f) :\n    Cardinal.lift.{v} (#Œ±) ‚â§ Cardinal.lift.{u} (#Œ≤) := by\n  rw [‚Üê Cardinal.mk_range_eq_of_injective hf]\n  exact Cardinal.lift_le.2 (Cardinal.mk_set_le _)\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_of_surjective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\nhf : Function.Surjective f\n‚ä¢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk Œ≤)) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"lemma lift_mk_le_lift_mk_of_surjective {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} (hf : Surjective f) :\n    Cardinal.lift.{u} (#Œ≤) ‚â§ Cardinal.lift.{v} (#Œ±) :=\n  lift_mk_le_lift_mk_of_injective (injective_surjInv hf)\n\n"}
{"name":"Cardinal.mk_image_eq_of_injOn","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nh : Set.InjOn f s\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.image f s)) (Cardinal.mk ‚Üës)","decl":"theorem mk_image_eq_of_injOn {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (h : InjOn f s) :\n    #(f '' s) = #s :=\n  mk_congr (Equiv.Set.imageOfInjOn f s h).symm\n\n"}
{"name":"Cardinal.mk_image_eq_of_injOn_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nh : Set.InjOn f s\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üës))","decl":"theorem mk_image_eq_of_injOn_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±)\n    (h : InjOn f s) : lift.{u} #(f '' s) = lift.{v} #s :=\n  lift_mk_eq.{v, u, 0}.mpr ‚ü®(Equiv.Set.imageOfInjOn f s h).symm‚ü©\n\n"}
{"name":"Cardinal.mk_image_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : Function.Injective f\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.image f s)) (Cardinal.mk ‚Üës)","decl":"theorem mk_image_eq {Œ± Œ≤ : Type u} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (hf : Injective f) : #(f '' s) = #s :=\n  mk_image_eq_of_injOn _ _ hf.injOn\n\n"}
{"name":"Cardinal.mk_image_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nh : Function.Injective f\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üës))","decl":"theorem mk_image_eq_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (h : Injective f) :\n    lift.{u} #(f '' s) = lift.{v} #s :=\n  mk_image_eq_of_injOn_lift _ _ h.injOn\n\n"}
{"name":"Cardinal.mk_image_embedding_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Function.Embedding Œ± Œ≤\ns : Set Œ±\n‚ä¢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ‚Üë(Set.image (‚áëf) s))) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üës))","decl":"@[simp]\ntheorem mk_image_embedding_lift {Œ≤ : Type v} (f : Œ± ‚Ü™ Œ≤) (s : Set Œ±) :\n    lift.{u} #(f '' s) = lift.{v} #s :=\n  mk_image_eq_lift _ _ f.injective\n\n"}
{"name":"Cardinal.mk_image_embedding","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Function.Embedding Œ± Œ≤\ns : Set Œ±\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.image (‚áëf) s)) (Cardinal.mk ‚Üës)","decl":"@[simp]\ntheorem mk_image_embedding (f : Œ± ‚Ü™ Œ≤) (s : Set Œ±) : #(f '' s) = #s := by\n  simpa using mk_image_embedding_lift f s\n\n"}
{"name":"Cardinal.mk_iUnion_le_sum_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œπ : Type u\nf : Œπ ‚Üí Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.iUnion fun i => f i)) (Cardinal.sum fun i => Cardinal.mk ‚Üë(f i))","decl":"theorem mk_iUnion_le_sum_mk {Œ± Œπ : Type u} {f : Œπ ‚Üí Set Œ±} : #(‚ãÉ i, f i) ‚â§ sum fun i => #(f i) :=\n  calc\n    #(‚ãÉ i, f i) ‚â§ #(Œ£i, f i) := mk_le_of_surjective (Set.sigmaToiUnion_surjective f)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_le_sum_mk_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒπ : Type v\nf : Œπ ‚Üí Set Œ±\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.iUnion fun i => f i))) (Cardinal.sum fun i => Cardinal.mk ‚Üë(f i))","decl":"theorem mk_iUnion_le_sum_mk_lift {Œ± : Type u} {Œπ : Type v} {f : Œπ ‚Üí Set Œ±} :\n    lift.{v} #(‚ãÉ i, f i) ‚â§ sum fun i => #(f i) :=\n  calc\n    lift.{v} #(‚ãÉ i, f i) ‚â§ #(Œ£i, f i) :=\n      mk_le_of_surjective <| ULift.up_surjective.comp (Set.sigmaToiUnion_surjective f)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_eq_sum_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œπ : Type u\nf : Œπ ‚Üí Set Œ±\nh : Pairwise (Function.onFun Disjoint f)\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.iUnion fun i => f i)) (Cardinal.sum fun i => Cardinal.mk ‚Üë(f i))","decl":"theorem mk_iUnion_eq_sum_mk {Œ± Œπ : Type u} {f : Œπ ‚Üí Set Œ±}\n    (h : Pairwise (Disjoint on f)) : #(‚ãÉ i, f i) = sum fun i => #(f i) :=\n  calc\n    #(‚ãÉ i, f i) = #(Œ£i, f i) := mk_congr (Set.unionEqSigmaOfDisjoint h)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_eq_sum_mk_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒπ : Type v\nf : Œπ ‚Üí Set Œ±\nh : Pairwise (Function.onFun Disjoint f)\n‚ä¢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.iUnion fun i => f i))) (Cardinal.sum fun i => Cardinal.mk ‚Üë(f i))","decl":"theorem mk_iUnion_eq_sum_mk_lift {Œ± : Type u} {Œπ : Type v} {f : Œπ ‚Üí Set Œ±}\n    (h : Pairwise (Disjoint on f)) :\n    lift.{v} #(‚ãÉ i, f i) = sum fun i => #(f i) :=\n  calc\n    lift.{v} #(‚ãÉ i, f i) = #(Œ£i, f i) :=\n      mk_congr <| .trans Equiv.ulift (Set.unionEqSigmaOfDisjoint h)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œπ : Type u\nf : Œπ ‚Üí Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.iUnion fun i => f i)) (HMul.hMul (Cardinal.mk Œπ) (iSup fun i => Cardinal.mk ‚Üë(f i)))","decl":"theorem mk_iUnion_le {Œ± Œπ : Type u} (f : Œπ ‚Üí Set Œ±) : #(‚ãÉ i, f i) ‚â§ #Œπ * ‚®Ü i, #(f i) :=\n  mk_iUnion_le_sum_mk.trans (sum_le_iSup _)\n\n"}
{"name":"Cardinal.mk_iUnion_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒπ : Type v\nf : Œπ ‚Üí Set Œ±\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.iUnion fun i => f i))) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk Œπ)) (iSup fun i => Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(f i))))","decl":"theorem mk_iUnion_le_lift {Œ± : Type u} {Œπ : Type v} (f : Œπ ‚Üí Set Œ±) :\n    lift.{v} #(‚ãÉ i, f i) ‚â§ lift.{u} #Œπ * ‚®Ü i, lift.{v} #(f i) := by\n  refine mk_iUnion_le_sum_mk_lift.trans <| Eq.trans_le ?_ (sum_le_iSup_lift _)\n  rw [‚Üê lift_sum, lift_id'.{_,u}]\n\n"}
{"name":"Cardinal.mk_sUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nA : Set (Set Œ±)\n‚ä¢ LE.le (Cardinal.mk ‚ÜëA.sUnion) (HMul.hMul (Cardinal.mk ‚ÜëA) (iSup fun s => Cardinal.mk ‚Üë‚Üës))","decl":"theorem mk_sUnion_le {Œ± : Type u} (A : Set (Set Œ±)) : #(‚ãÉ‚ÇÄ A) ‚â§ #A * ‚®Ü s : A, #s := by\n  rw [sUnion_eq_iUnion]\n  apply mk_iUnion_le\n\n"}
{"name":"Cardinal.mk_biUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œπ Œ± : Type u\nA : Œπ ‚Üí Set Œ±\ns : Set Œπ\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.iUnion fun x => Set.iUnion fun h => A x)) (HMul.hMul (Cardinal.mk ‚Üës) (iSup fun x => Cardinal.mk ‚Üë(A ‚Üëx)))","decl":"theorem mk_biUnion_le {Œπ Œ± : Type u} (A : Œπ ‚Üí Set Œ±) (s : Set Œπ) :\n    #(‚ãÉ x ‚àà s, A x) ‚â§ #s * ‚®Ü x : s, #(A x.1) := by\n  rw [biUnion_eq_iUnion]\n  apply mk_iUnion_le\n\n"}
{"name":"Cardinal.mk_biUnion_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒπ : Type v\nA : Œπ ‚Üí Set Œ±\ns : Set Œπ\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.iUnion fun x => Set.iUnion fun h => A x))) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk ‚Üës)) (iSup fun x => Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(A ‚Üëx))))","decl":"theorem mk_biUnion_le_lift {Œ± : Type u} {Œπ : Type v} (A : Œπ ‚Üí Set Œ±) (s : Set Œπ) :\n    lift.{v} #(‚ãÉ x ‚àà s, A x) ‚â§ lift.{u} #s * ‚®Ü x : s, lift.{v} #(A x.1) := by\n  rw [biUnion_eq_iUnion]\n  apply mk_iUnion_le_lift\n\n"}
{"name":"Cardinal.finset_card_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Finset Œ±\n‚ä¢ LT.lt (Cardinal.mk ‚Üë‚Üës) Cardinal.aleph0","decl":"theorem finset_card_lt_aleph0 (s : Finset Œ±) : #(‚Üës : Set Œ±) < ‚Ñµ‚ÇÄ :=\n  lt_aleph0_of_finite _\n\n"}
{"name":"Cardinal.mk_set_eq_nat_iff_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ns : Set Œ±\nn : Nat\n‚ä¢ Iff (Eq (Cardinal.mk ‚Üës) ‚Üën) (Exists fun t => And (Eq (‚Üët) s) (Eq t.card n))","decl":"theorem mk_set_eq_nat_iff_finset {Œ±} {s : Set Œ±} {n : ‚Ñï} :\n    #s = n ‚Üî ‚àÉ t : Finset Œ±, (t : Set Œ±) = s ‚àß t.card = n := by\n  constructor\n  ¬∑ intro h\n    lift s to Finset Œ± using lt_aleph0_iff_set_finite.1 (h.symm ‚ñ∏ nat_lt_aleph0 n)\n    simpa using h\n  ¬∑ rintro ‚ü®t, rfl, rfl‚ü©\n    exact mk_coe_finset\n\n"}
{"name":"Cardinal.mk_eq_nat_iff_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) ‚Üën) (Exists fun t => And (Eq (‚Üët) Set.univ) (Eq t.card n))","decl":"theorem mk_eq_nat_iff_finset {n : ‚Ñï} :\n    #Œ± = n ‚Üî ‚àÉ t : Finset Œ±, (t : Set Œ±) = univ ‚àß t.card = n := by\n  rw [‚Üê mk_univ, mk_set_eq_nat_iff_finset]\n\n"}
{"name":"Cardinal.mk_eq_nat_iff_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) ‚Üën) (Exists fun h => Eq (Fintype.card Œ±) n)","decl":"theorem mk_eq_nat_iff_fintype {n : ‚Ñï} : #Œ± = n ‚Üî ‚àÉ h : Fintype Œ±, @Fintype.card Œ± h = n := by\n  rw [mk_eq_nat_iff_finset]\n  constructor\n  ¬∑ rintro ‚ü®t, ht, hn‚ü©\n    exact ‚ü®‚ü®t, eq_univ_iff_forall.1 ht‚ü©, hn‚ü©\n  ¬∑ rintro ‚ü®‚ü®t, ht‚ü©, hn‚ü©\n    exact ‚ü®t, eq_univ_iff_forall.2 ht, hn‚ü©\n\n"}
{"name":"Cardinal.mk_union_add_mk_inter","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS T : Set Œ±\n‚ä¢ Eq (HAdd.hAdd (Cardinal.mk ‚Üë(Union.union S T)) (Cardinal.mk ‚Üë(Inter.inter S T))) (HAdd.hAdd (Cardinal.mk ‚ÜëS) (Cardinal.mk ‚ÜëT))","decl":"theorem mk_union_add_mk_inter {Œ± : Type u} {S T : Set Œ±} :\n    #(S ‚à™ T : Set Œ±) + #(S ‚à© T : Set Œ±) = #S + #T := by\n  classical\n  exact Quot.sound ‚ü®Equiv.Set.unionSumInter S T‚ü©\n\n"}
{"name":"Cardinal.mk_union_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS T : Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Union.union S T)) (HAdd.hAdd (Cardinal.mk ‚ÜëS) (Cardinal.mk ‚ÜëT))","decl":"/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem mk_union_le {Œ± : Type u} (S T : Set Œ±) : #(S ‚à™ T : Set Œ±) ‚â§ #S + #T :=\n  @mk_union_add_mk_inter Œ± S T ‚ñ∏ self_le_add_right #(S ‚à™ T : Set Œ±) #(S ‚à© T : Set Œ±)\n\n"}
{"name":"Cardinal.mk_union_of_disjoint","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS T : Set Œ±\nH : Disjoint S T\n‚ä¢ Eq (Cardinal.mk ‚Üë(Union.union S T)) (HAdd.hAdd (Cardinal.mk ‚ÜëS) (Cardinal.mk ‚ÜëT))","decl":"theorem mk_union_of_disjoint {Œ± : Type u} {S T : Set Œ±} (H : Disjoint S T) :\n    #(S ‚à™ T : Set Œ±) = #S + #T := by\n  classical\n  exact Quot.sound ‚ü®Equiv.Set.union H‚ü©\n\n"}
{"name":"Cardinal.mk_insert","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\na : Œ±\nh : Not (Membership.mem s a)\n‚ä¢ Eq (Cardinal.mk ‚Üë(Insert.insert a s)) (HAdd.hAdd (Cardinal.mk ‚Üës) 1)","decl":"theorem mk_insert {Œ± : Type u} {s : Set Œ±} {a : Œ±} (h : a ‚àâ s) :\n    #(insert a s : Set Œ±) = #s + 1 := by\n  rw [‚Üê union_singleton, mk_union_of_disjoint, mk_singleton]\n  simpa\n\n"}
{"name":"Cardinal.mk_insert_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\na : Œ±\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Insert.insert a s)) (HAdd.hAdd (Cardinal.mk ‚Üës) 1)","decl":"theorem mk_insert_le {Œ± : Type u} {s : Set Œ±} {a : Œ±} : #(insert a s : Set Œ±) ‚â§ #s + 1 := by\n  by_cases h : a ‚àà s\n  ¬∑ simp only [insert_eq_of_mem h, self_le_add_right]\n  ¬∑ rw [mk_insert h]\n\n"}
{"name":"Cardinal.mk_sum_compl","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ns : Set Œ±\n‚ä¢ Eq (HAdd.hAdd (Cardinal.mk ‚Üës) (Cardinal.mk ‚Üë(HasCompl.compl s))) (Cardinal.mk Œ±)","decl":"theorem mk_sum_compl {Œ±} (s : Set Œ±) : #s + #(s·∂ú : Set Œ±) = #Œ± := by\n  classical\n  exact mk_congr (Equiv.Set.sumCompl s)\n\n"}
{"name":"Cardinal.mk_le_mk_of_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\ns t : Set Œ±\nh : HasSubset.Subset s t\n‚ä¢ LE.le (Cardinal.mk ‚Üës) (Cardinal.mk ‚Üët)","decl":"theorem mk_le_mk_of_subset {Œ±} {s t : Set Œ±} (h : s ‚äÜ t) : #s ‚â§ #t :=\n  ‚ü®Set.embeddingOfSubset s t h‚ü©\n\n"}
{"name":"Cardinal.mk_le_iff_forall_finset_subset_card_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nn : Nat\nt : Set Œ±\n‚ä¢ Iff (LE.le (Cardinal.mk ‚Üët) ‚Üën) (‚àÄ (s : Finset Œ±), HasSubset.Subset (‚Üës) t ‚Üí LE.le s.card n)","decl":"theorem mk_le_iff_forall_finset_subset_card_le {Œ± : Type u} {n : ‚Ñï} {t : Set Œ±} :\n    #t ‚â§ n ‚Üî ‚àÄ s : Finset Œ±, (s : Set Œ±) ‚äÜ t ‚Üí s.card ‚â§ n := by\n  refine ‚ü®fun H s hs ‚Ü¶ by simpa using (mk_le_mk_of_subset hs).trans H, fun H ‚Ü¶ ?_‚ü©\n  apply card_le_of (fun s ‚Ü¶ ?_)\n  classical\n  let u : Finset Œ± := s.image Subtype.val\n  have : u.card = s.card := Finset.card_image_of_injOn Subtype.coe_injective.injOn\n  rw [‚Üê this]\n  apply H\n  simp only [u, Finset.coe_image, image_subset_iff, Subtype.coe_preimage_self, subset_univ]\n\n"}
{"name":"Cardinal.mk_subtype_mono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\np q : Œ± ‚Üí Prop\nh : ‚àÄ (x : Œ±), p x ‚Üí q x\n‚ä¢ LE.le (Cardinal.mk (Subtype fun x => p x)) (Cardinal.mk (Subtype fun x => q x))","decl":"theorem mk_subtype_mono {p q : Œ± ‚Üí Prop} (h : ‚àÄ x, p x ‚Üí q x) :\n    #{ x // p x } ‚â§ #{ x // q x } :=\n  ‚ü®embeddingOfSubset _ _ h‚ü©\n\n"}
{"name":"Cardinal.le_mk_diff_add_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS T : Set Œ±\n‚ä¢ LE.le (Cardinal.mk ‚ÜëS) (HAdd.hAdd (Cardinal.mk ‚Üë(SDiff.sdiff S T)) (Cardinal.mk ‚ÜëT))","decl":"theorem le_mk_diff_add_mk (S T : Set Œ±) : #S ‚â§ #(S \\ T : Set Œ±) + #T :=\n  (mk_le_mk_of_subset <| subset_diff_union _ _).trans <| mk_union_le _ _\n\n"}
{"name":"Cardinal.mk_diff_add_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nS T : Set Œ±\nh : HasSubset.Subset T S\n‚ä¢ Eq (HAdd.hAdd (Cardinal.mk ‚Üë(SDiff.sdiff S T)) (Cardinal.mk ‚ÜëT)) (Cardinal.mk ‚ÜëS)","decl":"theorem mk_diff_add_mk {S T : Set Œ±} (h : T ‚äÜ S) : #(S \\ T : Set Œ±) + #T = #S := by\n  refine (mk_union_of_disjoint <| ?_).symm.trans <| by rw [diff_union_of_subset h]\n  exact disjoint_sdiff_self_left\n\n"}
{"name":"Cardinal.mk_union_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\nP Q : Set Œ±\n‚ä¢ Iff (LE.le (Cardinal.mk ‚Üë(Union.union P Q)) Cardinal.aleph0) (And (LE.le (Cardinal.mk ‚ÜëP) Cardinal.aleph0) (LE.le (Cardinal.mk ‚ÜëQ) Cardinal.aleph0))","decl":"theorem mk_union_le_aleph0 {Œ±} {P Q : Set Œ±} :\n    #(P ‚à™ Q : Set Œ±) ‚â§ ‚Ñµ‚ÇÄ ‚Üî #P ‚â§ ‚Ñµ‚ÇÄ ‚àß #Q ‚â§ ‚Ñµ‚ÇÄ := by\n  simp only [le_aleph0_iff_subtype_countable, mem_union, setOf_mem_eq, Set.union_def,\n    ‚Üê countable_union]\n\n"}
{"name":"Cardinal.mk_subtype_of_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\np : Œ≤ ‚Üí Prop\ne : Equiv Œ± Œ≤\n‚ä¢ Eq (Cardinal.mk (Subtype fun a => p (e a))) (Cardinal.mk (Subtype fun b => p b))","decl":"theorem mk_subtype_of_equiv {Œ± Œ≤ : Type u} (p : Œ≤ ‚Üí Prop) (e : Œ± ‚âÉ Œ≤) :\n    #{ a : Œ± // p (e a) } = #{ b : Œ≤ // p b } :=\n  mk_congr (Equiv.subtypeEquivOfSubtype e)\n\n"}
{"name":"Cardinal.mk_sep","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\ns : Set Œ±\nt : Œ± ‚Üí Prop\n‚ä¢ Eq (Cardinal.mk ‚Üë(setOf fun x => And (Membership.mem s x) (t x))) (Cardinal.mk ‚Üë(setOf fun x => t ‚Üëx))","decl":"theorem mk_sep (s : Set Œ±) (t : Œ± ‚Üí Prop) : #({ x ‚àà s | t x } : Set Œ±) = #{ x : s | t x.1 } :=\n  mk_congr (Equiv.Set.sep s t)\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : Function.Injective f\n‚ä¢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.preimage f s))) (Cardinal.lift.{u, v} (Cardinal.mk ‚Üës))","decl":"theorem mk_preimage_of_injective_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ≤)\n    (h : Injective f) : lift.{v} #(f ‚Åª¬π' s) ‚â§ lift.{u} #s := by\n  rw [lift_mk_le.{0}]\n  -- Porting note: Needed to insert `mem_preimage.mp` below\n  use Subtype.coind (fun x => f x.1) fun x => mem_preimage.mp x.2\n  apply Subtype.coind_injective; exact h.comp Subtype.val_injective\n\n"}
{"name":"Cardinal.mk_preimage_of_subset_range_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : HasSubset.Subset s (Set.range f)\n‚ä¢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ‚Üës)) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.preimage f s)))","decl":"theorem mk_preimage_of_subset_range_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ≤)\n    (h : s ‚äÜ range f) : lift.{u} #s ‚â§ lift.{v} #(f ‚Åª¬π' s) := by\n  rw [‚Üê image_preimage_eq_iff] at h\n  nth_rewrite 1 [‚Üê h]\n  apply mk_image_le_lift\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_of_subset_range_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : Function.Injective f\nh2 : HasSubset.Subset s (Set.range f)\n‚ä¢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.preimage f s))) (Cardinal.lift.{u, v} (Cardinal.mk ‚Üës))","decl":"theorem mk_preimage_of_injective_of_subset_range_lift {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ≤)\n    (h : Injective f) (h2 : s ‚äÜ range f) : lift.{v} #(f ‚Åª¬π' s) = lift.{u} #s :=\n  le_antisymm (mk_preimage_of_injective_lift f s h) (mk_preimage_of_subset_range_lift f s h2)\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_of_subset_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : Function.Injective f\nh2 : HasSubset.Subset s (Set.range f)\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.preimage f s)) (Cardinal.mk ‚Üës)","decl":"theorem mk_preimage_of_injective_of_subset_range (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (h : Injective f)\n    (h2 : s ‚äÜ range f) : #(f ‚Åª¬π' s) = #s := by\n  convert mk_preimage_of_injective_of_subset_range_lift.{u, u} f s h h2 using 1 <;> rw [lift_id]\n\n"}
{"name":"Cardinal.mk_preimage_equiv_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Equiv Œ± Œ≤\ns : Set Œ≤\n‚ä¢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(Set.preimage (‚áëf) s))) (Cardinal.lift.{u, v} (Cardinal.mk ‚Üës))","decl":"@[simp]\ntheorem mk_preimage_equiv_lift {Œ≤ : Type v} (f : Œ± ‚âÉ Œ≤) (s : Set Œ≤) :\n    lift.{v} #(f ‚Åª¬π' s) = lift.{u} #s := by\n  apply mk_preimage_of_injective_of_subset_range_lift _ _ f.injective\n  rw [f.range_eq_univ]\n  exact fun _ _ ‚Ü¶ ‚ü®‚ü©\n\n"}
{"name":"Cardinal.mk_preimage_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Equiv Œ± Œ≤\ns : Set Œ≤\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.preimage (‚áëf) s)) (Cardinal.mk ‚Üës)","decl":"@[simp]\ntheorem mk_preimage_equiv (f : Œ± ‚âÉ Œ≤) (s : Set Œ≤) : #(f ‚Åª¬π' s) = #s := by\n  simpa using mk_preimage_equiv_lift f s\n\n"}
{"name":"Cardinal.mk_preimage_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : Function.Injective f\n‚ä¢ LE.le (Cardinal.mk ‚Üë(Set.preimage f s)) (Cardinal.mk ‚Üës)","decl":"theorem mk_preimage_of_injective (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (h : Injective f) :\n    #(f ‚Åª¬π' s) ‚â§ #s := by\n  rw [‚Üê lift_id #(‚Üë(f ‚Åª¬π' s)), ‚Üê lift_id #(‚Üës)]\n  exact mk_preimage_of_injective_lift f s h\n\n"}
{"name":"Cardinal.mk_preimage_of_subset_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\nh : HasSubset.Subset s (Set.range f)\n‚ä¢ LE.le (Cardinal.mk ‚Üës) (Cardinal.mk ‚Üë(Set.preimage f s))","decl":"theorem mk_preimage_of_subset_range (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (h : s ‚äÜ range f) :\n    #s ‚â§ #(f ‚Åª¬π' s) := by\n  rw [‚Üê lift_id #(‚Üë(f ‚Åª¬π' s)), ‚Üê lift_id #(‚Üës)]\n  exact mk_preimage_of_subset_range_lift f s h\n\n"}
{"name":"Cardinal.mk_subset_ge_of_subset_image_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nt : Set Œ≤\nh : HasSubset.Subset t (Set.image f s)\n‚ä¢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ‚Üët)) (Cardinal.lift.{v, u} (Cardinal.mk ‚Üë(setOf fun x => And (Membership.mem s x) (Membership.mem t (f x)))))","decl":"theorem mk_subset_ge_of_subset_image_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) {s : Set Œ±}\n    {t : Set Œ≤} (h : t ‚äÜ f '' s) : lift.{u} #t ‚â§ lift.{v} #({ x ‚àà s | f x ‚àà t } : Set Œ±) := by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range_lift _ _ h using 1\n  rw [mk_sep]\n  rfl\n\n"}
{"name":"Cardinal.mk_subset_ge_of_subset_image","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nt : Set Œ≤\nh : HasSubset.Subset t (Set.image f s)\n‚ä¢ LE.le (Cardinal.mk ‚Üët) (Cardinal.mk ‚Üë(setOf fun x => And (Membership.mem s x) (Membership.mem t (f x))))","decl":"theorem mk_subset_ge_of_subset_image (f : Œ± ‚Üí Œ≤) {s : Set Œ±} {t : Set Œ≤} (h : t ‚äÜ f '' s) :\n    #t ‚â§ #({ x ‚àà s | f x ‚àà t } : Set Œ±) := by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range _ _ h using 1\n  rw [mk_sep]\n  rfl\n\n"}
{"name":"Cardinal.le_mk_iff_exists_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\nŒ± : Type u\ns : Set Œ±\n‚ä¢ Iff (LE.le c (Cardinal.mk ‚Üës)) (Exists fun p => And (HasSubset.Subset p s) (Eq (Cardinal.mk ‚Üëp) c))","decl":"theorem le_mk_iff_exists_subset {c : Cardinal} {Œ± : Type u} {s : Set Œ±} :\n    c ‚â§ #s ‚Üî ‚àÉ p : Set Œ±, p ‚äÜ s ‚àß #p = c := by\n  rw [le_mk_iff_exists_set, ‚Üê Subtype.exists_set_subtype]\n  apply exists_congr; intro t; rw [mk_image_eq]; apply Subtype.val_injective\n\n"}
{"name":"Cardinal.mk_range_inl","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.range Sum.inl)) (Cardinal.lift.{v, u} (Cardinal.mk Œ±))","decl":"@[simp]\ntheorem mk_range_inl {Œ± : Type u} {Œ≤ : Type v} : #(range (@Sum.inl Œ± Œ≤)) = lift.{v} #Œ± := by\n  rw [‚Üê lift_id'.{u, v} #_, (Equiv.Set.rangeInl Œ± Œ≤).lift_cardinal_eq, lift_umax.{u, v}]\n\n"}
{"name":"Cardinal.mk_range_inr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\n‚ä¢ Eq (Cardinal.mk ‚Üë(Set.range Sum.inr)) (Cardinal.lift.{u, v} (Cardinal.mk Œ≤))","decl":"@[simp]\ntheorem mk_range_inr {Œ± : Type u} {Œ≤ : Type v} : #(range (@Sum.inr Œ± Œ≤)) = lift.{u} #Œ≤ := by\n  rw [‚Üê lift_id'.{v, u} #_, (Equiv.Set.rangeInr Œ± Œ≤).lift_cardinal_eq, lift_umax.{v, u}]\n\n"}
{"name":"Cardinal.two_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (LE.le 2 (Cardinal.mk Œ±)) (Exists fun x => Exists fun y => Ne x y)","decl":"theorem two_le_iff : (2 : Cardinal) ‚â§ #Œ± ‚Üî ‚àÉ x y : Œ±, x ‚â† y := by\n  rw [‚Üê Nat.cast_two, nat_succ, succ_le_iff, Nat.cast_one, one_lt_iff_nontrivial, nontrivial_iff]\n\n"}
{"name":"Cardinal.two_le_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nx : Œ±\n‚ä¢ Iff (LE.le 2 (Cardinal.mk Œ±)) (Exists fun y => Ne y x)","decl":"theorem two_le_iff' (x : Œ±) : (2 : Cardinal) ‚â§ #Œ± ‚Üî ‚àÉ y : Œ±, y ‚â† x := by\n  rw [two_le_iff, ‚Üê nontrivial_iff, nontrivial_iff_exists_ne x]\n\n"}
{"name":"Cardinal.mk_eq_two_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq (Insert.insert x (Singleton.singleton y)) Set.univ))","decl":"theorem mk_eq_two_iff : #Œ± = 2 ‚Üî ‚àÉ x y : Œ±, x ‚â† y ‚àß ({x, y} : Set Œ±) = univ := by\n  classical\n  simp only [‚Üê @Nat.cast_two Cardinal, mk_eq_nat_iff_finset, Finset.card_eq_two]\n  constructor\n  ¬∑ rintro ‚ü®t, ht, x, y, hne, rfl‚ü©\n    exact ‚ü®x, y, hne, by simpa using ht‚ü©\n  ¬∑ rintro ‚ü®x, y, hne, h‚ü©\n    exact ‚ü®{x, y}, by simpa using h, x, y, hne, rfl‚ü©\n\n"}
{"name":"Cardinal.mk_eq_two_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u\nx : Œ±\n‚ä¢ Iff (Eq (Cardinal.mk Œ±) 2) (ExistsUnique fun y => Ne y x)","decl":"theorem mk_eq_two_iff' (x : Œ±) : #Œ± = 2 ‚Üî ‚àÉ! y, y ‚â† x := by\n  rw [mk_eq_two_iff]; constructor\n  ¬∑ rintro ‚ü®a, b, hne, h‚ü©\n    simp only [eq_univ_iff_forall, mem_insert_iff, mem_singleton_iff] at h\n    rcases h x with (rfl | rfl)\n    exacts [‚ü®b, hne.symm, fun z => (h z).resolve_left‚ü©, ‚ü®a, hne, fun z => (h z).resolve_right‚ü©]\n  ¬∑ rintro ‚ü®y, hne, hy‚ü©\n    exact ‚ü®x, y, hne.symm, eq_univ_of_forall fun z => or_iff_not_imp_left.2 (hy z)‚ü©\n\n"}
{"name":"Cardinal.exists_not_mem_of_length_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\nl : List Œ±\nh : LT.lt (‚Üël.length) (Cardinal.mk Œ±)\n‚ä¢ Exists fun z => Not (Membership.mem l z)","decl":"theorem exists_not_mem_of_length_lt {Œ± : Type*} (l : List Œ±) (h : ‚Üël.length < #Œ±) :\n    ‚àÉ z : Œ±, z ‚àâ l := by\n  classical\n  contrapose! h\n  calc\n    #Œ± = #(Set.univ : Set Œ±) := mk_univ.symm\n    _ ‚â§ #l.toFinset := mk_le_mk_of_subset fun x _ => List.mem_toFinset.mpr (h x)\n    _ = l.toFinset.card := Cardinal.mk_coe_finset\n    _ ‚â§ l.length := Nat.cast_le.mpr (List.toFinset_card_le l)\n\n"}
{"name":"Cardinal.three_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"Œ± : Type u_1\nh : LE.le 3 (Cardinal.mk Œ±)\nx y : Œ±\n‚ä¢ Exists fun z => And (Ne z x) (Ne z y)","decl":"theorem three_le {Œ± : Type*} (h : 3 ‚â§ #Œ±) (x : Œ±) (y : Œ±) : ‚àÉ z : Œ±, z ‚â† x ‚àß z ‚â† y := by\n  have : ‚Üë(3 : ‚Ñï) ‚â§ #Œ± := by simpa using h\n  have : ‚Üë(2 : ‚Ñï) < #Œ± := by rwa [‚Üê succ_le_iff, ‚Üê Cardinal.nat_succ]\n  have := exists_not_mem_of_length_lt [x, y] this\n  simpa [not_or] using this\n\n"}
{"name":"Cardinal.le_powerlt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"b c a : Cardinal.{u}\nh : LT.lt c b\n‚ä¢ LE.le (HPow.hPow a c) (a.powerlt b)","decl":"theorem le_powerlt {b c : Cardinal.{u}} (a) (h : c < b) : (a^c) ‚â§ a ^< b := by\n  refine le_ciSup (f := fun y : Iio b => a ^ (y : Cardinal)) ?_ ‚ü®c, h‚ü©\n  rw [‚Üê image_eq_range]\n  exact bddAbove_image.{u, u} _ bddAbove_Iio\n\n"}
{"name":"Cardinal.powerlt_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u}\n‚ä¢ Iff (LE.le (a.powerlt b) c) (‚àÄ (x : Cardinal.{u}), LT.lt x b ‚Üí LE.le (HPow.hPow a x) c)","decl":"theorem powerlt_le {a b c : Cardinal.{u}} : a ^< b ‚â§ c ‚Üî ‚àÄ x < b, a ^ x ‚â§ c := by\n  rw [powerlt, ciSup_le_iff']\n  ¬∑ simp\n  ¬∑ rw [‚Üê image_eq_range]\n    exact bddAbove_image.{u, u} _ bddAbove_Iio\n\n"}
{"name":"Cardinal.powerlt_le_powerlt_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\nh : LE.le b c\n‚ä¢ LE.le (a.powerlt b) (a.powerlt c)","decl":"theorem powerlt_le_powerlt_left {a b c : Cardinal} (h : b ‚â§ c) : a ^< b ‚â§ a ^< c :=\n  powerlt_le.2 fun _ hx => le_powerlt a <| hx.trans_le h\n\n"}
{"name":"Cardinal.powerlt_mono_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Monotone fun c => a.powerlt c","decl":"theorem powerlt_mono_left (a) : Monotone fun c => a ^< c := fun _ _ => powerlt_le_powerlt_left\n\n"}
{"name":"Cardinal.powerlt_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nh : Ne a 0\n‚ä¢ Eq (a.powerlt (Order.succ b)) (HPow.hPow a b)","decl":"theorem powerlt_succ {a b : Cardinal} (h : a ‚â† 0) : a ^< succ b = a ^ b :=\n  (powerlt_le.2 fun _ h' => power_le_power_left h <| le_of_lt_succ h').antisymm <|\n    le_powerlt a (lt_succ b)\n\n"}
{"name":"Cardinal.powerlt_min","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n‚ä¢ Eq (a.powerlt (Min.min b c)) (Min.min (a.powerlt b) (a.powerlt c))","decl":"theorem powerlt_min {a b c : Cardinal} : a ^< min b c = min (a ^< b) (a ^< c) :=\n  (powerlt_mono_left a).map_min\n\n"}
{"name":"Cardinal.powerlt_max","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n‚ä¢ Eq (a.powerlt (Max.max b c)) (Max.max (a.powerlt b) (a.powerlt c))","decl":"theorem powerlt_max {a b c : Cardinal} : a ^< max b c = max (a ^< b) (a ^< c) :=\n  (powerlt_mono_left a).map_max\n\n"}
{"name":"Cardinal.zero_powerlt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\nh : Ne a 0\n‚ä¢ Eq (Cardinal.powerlt 0 a) 1","decl":"theorem zero_powerlt {a : Cardinal} (h : a ‚â† 0) : 0 ^< a = 1 := by\n  apply (powerlt_le.2 fun c _ => zero_power_le _).antisymm\n  rw [‚Üê power_zero]\n  exact le_powerlt 0 (pos_iff_ne_zero.2 h)\n\n"}
{"name":"Cardinal.powerlt_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n‚ä¢ Eq (a.powerlt 0) 0","decl":"@[simp]\ntheorem powerlt_zero {a : Cardinal} : a ^< 0 = 0 := by\n  convert Cardinal.iSup_of_empty _\n  exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt\n\n"}
