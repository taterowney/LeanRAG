{"name":"Cardinal.canLiftCardinalType","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ CanLift Cardinal.{u} (Type u) Cardinal.mk fun x => True","decl":"instance canLiftCardinalType : CanLift Cardinal.{u} (Type u) mk fun _ => True :=\n  ⟨fun c _ => Quot.inductionOn c fun α => ⟨α, rfl⟩⟩\n\n"}
{"name":"Cardinal.inductionOn","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} → Prop\nc : Cardinal.{u_1}\nh : ∀ (α : Type u_1), p (Cardinal.mk α)\n⊢ p c","decl":"@[elab_as_elim]\ntheorem inductionOn {p : Cardinal → Prop} (c : Cardinal) (h : ∀ α, p #α) : p c :=\n  Quotient.inductionOn c h\n\n"}
{"name":"Cardinal.inductionOn₂","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} → Cardinal.{u_2} → Prop\nc₁ : Cardinal.{u_1}\nc₂ : Cardinal.{u_2}\nh : ∀ (α : Type u_1) (β : Type u_2), p (Cardinal.mk α) (Cardinal.mk β)\n⊢ p c₁ c₂","decl":"@[elab_as_elim]\ntheorem inductionOn₂ {p : Cardinal → Cardinal → Prop} (c₁ : Cardinal) (c₂ : Cardinal)\n    (h : ∀ α β, p #α #β) : p c₁ c₂ :=\n  Quotient.inductionOn₂ c₁ c₂ h\n\n"}
{"name":"Cardinal.inductionOn₃","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"p : Cardinal.{u_1} → Cardinal.{u_2} → Cardinal.{u_3} → Prop\nc₁ : Cardinal.{u_1}\nc₂ : Cardinal.{u_2}\nc₃ : Cardinal.{u_3}\nh : ∀ (α : Type u_1) (β : Type u_2) (γ : Type u_3), p (Cardinal.mk α) (Cardinal.mk β) (Cardinal.mk γ)\n⊢ p c₁ c₂ c₃","decl":"@[elab_as_elim]\ntheorem inductionOn₃ {p : Cardinal → Cardinal → Cardinal → Prop} (c₁ : Cardinal) (c₂ : Cardinal)\n    (c₃ : Cardinal) (h : ∀ α β γ, p #α #β #γ) : p c₁ c₂ c₃ :=\n  Quotient.inductionOn₃ c₁ c₂ c₃ h\n\n"}
{"name":"Cardinal.induction_on_pi","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\np : (ι → Cardinal.{v}) → Prop\nf : ι → Cardinal.{v}\nh : ∀ (f : ι → Type v), p fun i => Cardinal.mk (f i)\n⊢ p f","decl":"theorem induction_on_pi {ι : Type u} {p : (ι → Cardinal.{v}) → Prop}\n    (f : ι → Cardinal.{v}) (h : ∀ f : ι → Type v, p fun i ↦ #(f i)) : p f :=\n  Quotient.induction_on_pi f h\n\n"}
{"name":"Cardinal.eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\n⊢ Iff (Eq (Cardinal.mk α) (Cardinal.mk β)) (Nonempty (Equiv α β))","decl":"protected theorem eq : #α = #β ↔ Nonempty (α ≃ β) :=\n  Quotient.eq'\n\n"}
{"name":"Cardinal.mk'_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Quotient.mk Cardinal.isEquivalent α) (Cardinal.mk α)","decl":"/-- Avoid using `Quotient.mk` to construct a `Cardinal` directly -/\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-24\")]\ntheorem mk'_def (α : Type u) : @Eq Cardinal ⟦α⟧ #α :=\n  rfl\n\n"}
{"name":"Cardinal.mk_out","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq (Cardinal.mk (Quotient.out c)) c","decl":"@[simp]\ntheorem mk_out (c : Cardinal) : #c.out = c :=\n  Quotient.out_eq _\n\n"}
{"name":"Cardinal.mk_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\ne : Equiv α β\n⊢ Eq (Cardinal.mk α) (Cardinal.mk β)","decl":"theorem mk_congr (e : α ≃ β) : #α = #β :=\n  Quot.sound ⟨e⟩\n\n"}
{"name":"Equiv.cardinal_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\ne : Equiv α β\n⊢ Eq (Cardinal.mk α) (Cardinal.mk β)","decl":"alias _root_.Equiv.cardinal_eq := mk_congr\n\n"}
{"name":"Cardinal.map_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Type u → Type v\nhf : (α β : Type u) → Equiv α β → Equiv (f α) (f β)\nα : Type u\n⊢ Eq (Cardinal.map f hf (Cardinal.mk α)) (Cardinal.mk (f α))","decl":"@[simp]\ntheorem map_mk (f : Type u → Type v) (hf : ∀ α β, α ≃ β → f α ≃ f β) (α : Type u) :\n    map f hf #α = #(f α) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_uLift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (ULift.{v, u} α)) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"@[simp]\ntheorem mk_uLift (α) : #(ULift.{v, u} α) = lift.{v} #α :=\n  rfl\n\n"}
{"name":"Cardinal.lift_umax","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq Cardinal.lift.{max u v, u} Cardinal.lift.{v, u}","decl":"/-- `lift.{max u v, u}` equals `lift.{v, u}`.\n\nUnfortunately, the simp lemma doesn't work. -/\ntheorem lift_umax : lift.{max u v, u} = lift.{v, u} :=\n  funext fun a => inductionOn a fun _ => (Equiv.ulift.trans Equiv.ulift.symm).cardinal_eq\n\n"}
{"name":"Cardinal.lift_umax'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq Cardinal.lift.{max v u, u} Cardinal.lift.{v, u}","decl":"/-- `lift.{max v u, u}` equals `lift.{v, u}`. -/\n@[deprecated lift_umax (since := \"2024-10-24\")]\ntheorem lift_umax' : lift.{max v u, u} = lift.{v, u} :=\n  lift_umax\n\n"}
{"name":"Cardinal.lift_id'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{max u v}\n⊢ Eq (Cardinal.lift.{u, max u v} a) a","decl":"/-- A cardinal lifted to a lower or equal universe equals itself.\n\nUnfortunately, the simp lemma doesn't work. -/\ntheorem lift_id' (a : Cardinal.{max u v}) : lift.{u} a = a :=\n  inductionOn a fun _ => mk_congr Equiv.ulift\n\n"}
{"name":"Cardinal.lift_id","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{u, u} a) a","decl":"/-- A cardinal lifted to the same universe equals itself. -/\n@[simp]\ntheorem lift_id (a : Cardinal) : lift.{u, u} a = a :=\n  lift_id'.{u, u} a\n\n"}
{"name":"Cardinal.lift_uzero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{0, u} a) a","decl":"/-- A cardinal lifted to the zero universe equals itself. -/\n@[simp]\ntheorem lift_uzero (a : Cardinal.{u}) : lift.{0} a = a :=\n  lift_id'.{0, u} a\n\n"}
{"name":"Cardinal.lift_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (Cardinal.lift.{w, max v u_1} (Cardinal.lift.{v, u_1} a)) (Cardinal.lift.{max v w, u_1} a)","decl":"@[simp]\ntheorem lift_lift.{u_1} (a : Cardinal.{u_1}) : lift.{w} (lift.{v} a) = lift.{max v w} a :=\n  inductionOn a fun _ => (Equiv.ulift.trans <| Equiv.ulift.trans Equiv.ulift.symm).cardinal_eq\n\n"}
{"name":"Cardinal.out_lift_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Nonempty (Equiv (Quotient.out (Cardinal.lift.{v, u} a)) (Quotient.out a))","decl":"theorem out_lift_equiv (a : Cardinal.{u}) : Nonempty ((lift.{v} a).out ≃ a.out) := by\n  rw [← mk_out a, ← mk_uLift, mk_out]\n  exact ⟨outMkEquiv.trans Equiv.ulift⟩\n\n"}
{"name":"Cardinal.mk_preimage_down","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Cardinal.mk ↑(Set.preimage ULift.down s)) (Cardinal.lift.{v, u} (Cardinal.mk ↑s))","decl":"@[simp]\nlemma mk_preimage_down {s : Set α} : #(ULift.down.{v} ⁻¹' s) = lift.{v} (#s) := by\n  rw [← mk_uLift, Cardinal.eq]\n  constructor\n  let f : ULift.down ⁻¹' s → ULift s := fun x ↦ ULift.up (restrictPreimage s ULift.down x)\n  have : Function.Bijective f :=\n    ULift.up_bijective.comp (restrictPreimage_bijective _ (ULift.down_bijective))\n  exact Equiv.ofBijective f this\n\n"}
{"name":"Cardinal.lift_mk_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Iff (Eq (Cardinal.lift.{max v w, u} (Cardinal.mk α)) (Cardinal.lift.{max u w, v} (Cardinal.mk β))) (Nonempty (Equiv α β))","decl":"theorem lift_mk_eq {α : Type u} {β : Type v} :\n    lift.{max v w} #α = lift.{max u w} #β ↔ Nonempty (α ≃ β) :=\n  Quotient.eq'.trans\n    ⟨fun ⟨f⟩ => ⟨Equiv.ulift.symm.trans <| f.trans Equiv.ulift⟩, fun ⟨f⟩ =>\n      ⟨Equiv.ulift.trans <| f.trans Equiv.ulift.symm⟩⟩\n\n"}
{"name":"Cardinal.lift_mk_eq'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Iff (Eq (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β))) (Nonempty (Equiv α β))","decl":"/-- A variant of `Cardinal.lift_mk_eq` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_eq' {α : Type u} {β : Type v} : lift.{v} #α = lift.{u} #β ↔ Nonempty (α ≃ β) :=\n  lift_mk_eq.{u, v, 0}\n\n"}
{"name":"Cardinal.mk_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β))","decl":"theorem mk_congr_lift {α : Type u} {β : Type v} (e : α ≃ β) : lift.{v} #α = lift.{u} #β :=\n  lift_mk_eq'.2 ⟨e⟩\n\n"}
{"name":"Equiv.lift_cardinal_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β))","decl":"alias _root_.Equiv.lift_cardinal_eq := mk_congr_lift\n\n-- Porting note: simpNF is not happy with universe levels.\n"}
{"name":"Cardinal.lift_mk_shrink","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Small.{v, u} α\n⊢ Eq (Cardinal.lift.{max u w, v} (Cardinal.mk (Shrink.{v, u} α))) (Cardinal.lift.{max v w, u} (Cardinal.mk α))","decl":"@[simp, nolint simpNF]\ntheorem lift_mk_shrink (α : Type u) [Small.{v} α] :\n    Cardinal.lift.{max u w} #(Shrink.{v} α) = Cardinal.lift.{max v w} #α :=\n  lift_mk_eq.2 ⟨(equivShrink α).symm⟩\n\n"}
{"name":"Cardinal.lift_mk_shrink'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Small.{v, u} α\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, u} α))) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"@[simp]\ntheorem lift_mk_shrink' (α : Type u) [Small.{v} α] :\n    Cardinal.lift.{u} #(Shrink.{v} α) = Cardinal.lift.{v} #α :=\n  lift_mk_shrink.{u, v, 0} α\n\n"}
{"name":"Cardinal.lift_mk_shrink''","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type (max u v)\ninst✝ : Small.{v, max u v} α\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, max u v} α))) (Cardinal.mk α)","decl":"@[simp]\ntheorem lift_mk_shrink'' (α : Type max u v) [Small.{v} α] :\n    Cardinal.lift.{u} #(Shrink.{v} α) = #α := by\n  rw [← lift_umax, lift_mk_shrink.{max u v, v, 0} α, ← lift_umax, lift_id]\n\n"}
{"name":"Cardinal.le_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\n⊢ Iff (LE.le (Cardinal.mk α) (Cardinal.mk β)) (Nonempty (Function.Embedding α β))","decl":"theorem le_def (α β : Type u) : #α ≤ #β ↔ Nonempty (α ↪ β) :=\n  Iff.rfl\n\n"}
{"name":"Cardinal.mk_le_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\nhf : Function.Injective f\n⊢ LE.le (Cardinal.mk α) (Cardinal.mk β)","decl":"theorem mk_le_of_injective {α β : Type u} {f : α → β} (hf : Injective f) : #α ≤ #β :=\n  ⟨⟨f, hf⟩⟩\n\n"}
{"name":"Function.Embedding.cardinal_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : Function.Embedding α β\n⊢ LE.le (Cardinal.mk α) (Cardinal.mk β)","decl":"theorem _root_.Function.Embedding.cardinal_le {α β : Type u} (f : α ↪ β) : #α ≤ #β :=\n  ⟨f⟩\n\n"}
{"name":"Cardinal.mk_le_of_surjective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\nhf : Function.Surjective f\n⊢ LE.le (Cardinal.mk β) (Cardinal.mk α)","decl":"theorem mk_le_of_surjective {α β : Type u} {f : α → β} (hf : Surjective f) : #β ≤ #α :=\n  ⟨Embedding.ofSurjective f hf⟩\n\n"}
{"name":"Cardinal.le_mk_iff_exists_set","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\nα : Type u\n⊢ Iff (LE.le c (Cardinal.mk α)) (Exists fun p => Eq (Cardinal.mk ↑p) c)","decl":"theorem le_mk_iff_exists_set {c : Cardinal} {α : Type u} : c ≤ #α ↔ ∃ p : Set α, #p = c :=\n  ⟨inductionOn c fun _ ⟨⟨f, hf⟩⟩ => ⟨Set.range f, (Equiv.ofInjective f hf).cardinal_eq.symm⟩,\n    fun ⟨_, e⟩ => e ▸ ⟨⟨Subtype.val, fun _ _ => Subtype.eq⟩⟩⟩\n\n"}
{"name":"Cardinal.mk_subtype_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ LE.le (Cardinal.mk (Subtype p)) (Cardinal.mk α)","decl":"theorem mk_subtype_le {α : Type u} (p : α → Prop) : #(Subtype p) ≤ #α :=\n  ⟨Embedding.subtype p⟩\n\n"}
{"name":"Cardinal.mk_set_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ LE.le (Cardinal.mk ↑s) (Cardinal.mk α)","decl":"theorem mk_set_le (s : Set α) : #s ≤ #α :=\n  mk_subtype_le s\n\n"}
{"name":"Cardinal.out_embedding","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c c' : Cardinal.{u_1}\n⊢ Iff (LE.le c c') (Nonempty (Function.Embedding (Quotient.out c) (Quotient.out c')))","decl":"theorem out_embedding {c c' : Cardinal} : c ≤ c' ↔ Nonempty (c.out ↪ c'.out) := by\n  conv_lhs => rw [← Cardinal.mk_out c, ← Cardinal.mk_out c', le_def]\n\n"}
{"name":"Cardinal.lift_mk_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type v\nβ : Type w\n⊢ Iff (LE.le (Cardinal.lift.{max u w, v} (Cardinal.mk α)) (Cardinal.lift.{max u v, w} (Cardinal.mk β))) (Nonempty (Function.Embedding α β))","decl":"theorem lift_mk_le {α : Type v} {β : Type w} :\n    lift.{max u w} #α ≤ lift.{max u v} #β ↔ Nonempty (α ↪ β) :=\n  ⟨fun ⟨f⟩ => ⟨Embedding.congr Equiv.ulift Equiv.ulift f⟩, fun ⟨f⟩ =>\n    ⟨Embedding.congr Equiv.ulift.symm Equiv.ulift.symm f⟩⟩\n\n"}
{"name":"Cardinal.lift_mk_le'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Iff (LE.le (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β))) (Nonempty (Function.Embedding α β))","decl":"/-- A variant of `Cardinal.lift_mk_le` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n-/\ntheorem lift_mk_le' {α : Type u} {β : Type v} : lift.{v} #α ≤ lift.{u} #β ↔ Nonempty (α ↪ β) :=\n  lift_mk_le.{0}\n\n"}
{"name":"Cardinal.liftInitialSeg_toFun","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Eq (Cardinal.liftInitialSeg c) (Cardinal.lift.{v, u} c)","decl":"/-- `Cardinal.lift` as an `InitialSeg`. -/\n@[simps!]\ndef liftInitialSeg : Cardinal.{u} ≤i Cardinal.{max u v} := by\n  refine ⟨(OrderEmbedding.ofMapLEIff lift ?_).ltEmbedding, ?_⟩ <;> intro a b\n  · refine inductionOn₂ a b fun _ _ ↦ ?_\n    rw [← lift_umax, lift_mk_le.{v, u, u}, le_def]\n  · refine inductionOn₂ a b fun α β h ↦ ?_\n    obtain ⟨e⟩ := h.le\n    replace e := e.congr (Equiv.refl β) Equiv.ulift\n    refine ⟨#(range e), mk_congr (Equiv.ulift.trans <| Equiv.symm ?_)⟩\n    apply (e.codRestrict _ mem_range_self).equivOfSurjective\n    rintro ⟨a, ⟨b, rfl⟩⟩\n    exact ⟨b, rfl⟩\n\n"}
{"name":"Cardinal.mem_range_lift_of_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\na✝ : LE.le b (Cardinal.lift.{v, u} a)\n⊢ Membership.mem (Set.range Cardinal.lift.{v, u}) b","decl":"theorem mem_range_lift_of_le {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ≤ lift.{v, u} a → b ∈ Set.range lift.{v, u} :=\n  liftInitialSeg.mem_range_of_le\n\n"}
{"name":"Cardinal.lift_down","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\na✝ : LE.le b (Cardinal.lift.{v, u} a)\n⊢ Exists fun a' => Eq (Cardinal.lift.{v, u} a') b","decl":"@[deprecated mem_range_lift_of_le (since := \"2024-10-07\")]\ntheorem lift_down {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ≤ lift.{v, u} a → ∃ a', lift.{v, u} a' = b :=\n  mem_range_lift_of_le\n\n"}
{"name":"Cardinal.lift_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Function.Injective Cardinal.lift.{u, v}","decl":"theorem lift_injective : Injective lift.{u, v} :=\n  liftInitialSeg.injective\n\n"}
{"name":"Cardinal.lift_inj","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b)) (Eq a b)","decl":"@[simp]\ntheorem lift_inj {a b : Cardinal.{u}} : lift.{v, u} a = lift.{v, u} b ↔ a = b :=\n  lift_injective.eq_iff\n\n"}
{"name":"Cardinal.lift_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n⊢ Iff (LE.le (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b)) (LE.le a b)","decl":"@[simp]\ntheorem lift_le {a b : Cardinal.{v}} : lift.{u} a ≤ lift.{u} b ↔ a ≤ b :=\n  liftInitialSeg.le_iff_le\n\n"}
{"name":"Cardinal.lift_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Iff (LT.lt (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b)) (LT.lt a b)","decl":"@[simp]\ntheorem lift_lt {a b : Cardinal.{u}} : lift.{v, u} a < lift.{v, u} b ↔ a < b :=\n  liftInitialSeg.lt_iff_lt\n\n"}
{"name":"Cardinal.lift_strictMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ StrictMono Cardinal.lift.{u_2, u_1}","decl":"theorem lift_strictMono : StrictMono lift := fun _ _ => lift_lt.2\n\n"}
{"name":"Cardinal.lift_monotone","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Monotone Cardinal.lift.{u_2, u_1}","decl":"theorem lift_monotone : Monotone lift :=\n  lift_strictMono.monotone\n\n"}
{"name":"Cardinal.lift_min","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} (Min.min a b)) (Min.min (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_min {a b : Cardinal} : lift.{u, v} (min a b) = min (lift.{u, v} a) (lift.{u, v} b) :=\n  lift_monotone.map_min\n\n"}
{"name":"Cardinal.lift_max","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} (Max.max a b)) (Max.max (Cardinal.lift.{u, v} a) (Cardinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_max {a b : Cardinal} : lift.{u, v} (max a b) = max (lift.{u, v} a) (lift.{u, v} b) :=\n  lift_monotone.map_max\n\n-- Porting note: simpNF is not happy with universe levels.\n"}
{"name":"Cardinal.lift_umax_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{v}\n⊢ Iff (Eq (Cardinal.lift.{max v w, u} a) (Cardinal.lift.{max u w, v} b)) (Eq (Cardinal.lift.{v, u} a) (Cardinal.lift.{u, v} b))","decl":"@[simp, nolint simpNF]\ntheorem lift_umax_eq {a : Cardinal.{u}} {b : Cardinal.{v}} :\n    lift.{max v w} a = lift.{max u w} b ↔ lift.{v} a = lift.{u} b := by\n  rw [← lift_lift.{v, w, u}, ← lift_lift.{u, w, v}, lift_inj]\n\n"}
{"name":"Cardinal.le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\n⊢ Iff (LE.le b (Cardinal.lift.{v, u} a)) (Exists fun a' => And (LE.le a' a) (Eq (Cardinal.lift.{v, u} a') b))","decl":"theorem le_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b ≤ lift.{v, u} a ↔ ∃ a' ≤ a, lift.{v, u} a' = b :=\n  liftInitialSeg.le_apply_iff\n\n"}
{"name":"Cardinal.lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{max u v}\n⊢ Iff (LT.lt b (Cardinal.lift.{v, u} a)) (Exists fun a' => And (LT.lt a' a) (Eq (Cardinal.lift.{v, u} a') b))","decl":"theorem lt_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b < lift.{v, u} a ↔ ∃ a' < a, lift.{v, u} a' = b :=\n  liftInitialSeg.lt_apply_iff\n\n"}
{"name":"Cardinal.mk_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : IsEmpty α\n⊢ Eq (Cardinal.mk α) 0","decl":"@[simp]\ntheorem mk_eq_zero (α : Type u) [IsEmpty α] : #α = 0 :=\n  (Equiv.equivOfIsEmpty α (ULift (Fin 0))).cardinal_eq\n\n"}
{"name":"Cardinal.lift_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.lift.{u_2, u_1} 0) 0","decl":"@[simp]\ntheorem lift_zero : lift 0 = 0 := mk_eq_zero _\n\n"}
{"name":"Cardinal.lift_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{v}\n⊢ Iff (Eq (Cardinal.lift.{u, v} a) 0) (Eq a 0)","decl":"@[simp]\ntheorem lift_eq_zero {a : Cardinal.{v}} : lift.{u} a = 0 ↔ a = 0 :=\n  lift_injective.eq_iff' lift_zero\n\n"}
{"name":"Cardinal.mk_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Eq (Cardinal.mk α) 0) (IsEmpty α)","decl":"theorem mk_eq_zero_iff {α : Type u} : #α = 0 ↔ IsEmpty α :=\n  ⟨fun e =>\n    let ⟨h⟩ := Quotient.exact e\n    h.isEmpty,\n    @mk_eq_zero α⟩\n\n"}
{"name":"Cardinal.mk_ne_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Ne (Cardinal.mk α) 0) (Nonempty α)","decl":"theorem mk_ne_zero_iff {α : Type u} : #α ≠ 0 ↔ Nonempty α :=\n  (not_iff_not.2 mk_eq_zero_iff).trans not_isEmpty_iff\n\n"}
{"name":"Cardinal.mk_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Ne (Cardinal.mk α) 0","decl":"@[simp]\ntheorem mk_ne_zero (α : Type u) [Nonempty α] : #α ≠ 0 :=\n  mk_ne_zero_iff.2 ‹_›\n\n"}
{"name":"Cardinal.instNontrivial","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Nontrivial Cardinal.{u}","decl":"instance : Nontrivial Cardinal.{u} :=\n  ⟨⟨1, 0, mk_ne_zero _⟩⟩\n\n"}
{"name":"Cardinal.mk_eq_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝¹ : Subsingleton α\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk α) 1","decl":"theorem mk_eq_one (α : Type u) [Subsingleton α] [Nonempty α] : #α = 1 :=\n  let ⟨_⟩ := nonempty_unique α; (Equiv.ofUnique α (ULift (Fin 1))).cardinal_eq\n\n"}
{"name":"Cardinal.le_one_iff_subsingleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LE.le (Cardinal.mk α) 1) (Subsingleton α)","decl":"theorem le_one_iff_subsingleton {α : Type u} : #α ≤ 1 ↔ Subsingleton α :=\n  ⟨fun ⟨f⟩ => ⟨fun _ _ => f.injective (Subsingleton.elim _ _)⟩, fun ⟨h⟩ =>\n    ⟨fun _ => ULift.up 0, fun _ _ _ => h _ _⟩⟩\n\n"}
{"name":"Cardinal.mk_le_one_iff_set_subsingleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (LE.le (Cardinal.mk ↑s) 1) s.Subsingleton","decl":"@[simp]\ntheorem mk_le_one_iff_set_subsingleton {s : Set α} : #s ≤ 1 ↔ s.Subsingleton :=\n  le_one_iff_subsingleton.trans s.subsingleton_coe\n\n"}
{"name":"Set.Subsingleton.cardinalMk_le_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Subsingleton\n⊢ LE.le (Cardinal.mk ↑s) 1","decl":"alias ⟨_, _root_.Set.Subsingleton.cardinalMk_le_one⟩ := mk_le_one_iff_set_subsingleton\n\n"}
{"name":"Set.Subsingleton.cardinal_mk_le_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Subsingleton\n⊢ LE.le (Cardinal.mk ↑s) 1","decl":"@[deprecated (since := \"2024-11-10\")]\nalias _root_.Set.Subsingleton.cardinal_mk_le_one := Set.Subsingleton.cardinalMk_le_one\n\n"}
{"name":"Cardinal.add_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\n⊢ Eq (HAdd.hAdd (Cardinal.mk α) (Cardinal.mk β)) (Cardinal.mk (Sum α β))","decl":"theorem add_def (α β : Type u) : #α + #β = #(α ⊕ β) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk (Sum α β)) (HAdd.hAdd (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β)))","decl":"@[simp]\ntheorem mk_sum (α : Type u) (β : Type v) : #(α ⊕ β) = lift.{v, u} #α + lift.{u, v} #β :=\n  mk_congr (Equiv.ulift.symm.sumCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.mk_option","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (Option α)) (HAdd.hAdd (Cardinal.mk α) 1)","decl":"@[simp]\ntheorem mk_option {α : Type u} : #(Option α) = #α + 1 := by\n  rw [(Equiv.optionEquivSumPUnit.{u, u} α).cardinal_eq, mk_sum, mk_eq_one PUnit, lift_id, lift_id]\n\n"}
{"name":"Cardinal.mk_psum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk (PSum α β)) (HAdd.hAdd (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β)))","decl":"@[simp]\ntheorem mk_psum (α : Type u) (β : Type v) : #(α ⊕' β) = lift.{v} #α + lift.{u} #β :=\n  (mk_congr (Equiv.psumEquivSum α β)).trans (mk_sum α β)\n\n"}
{"name":"Cardinal.mk_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nh : Fintype α\n⊢ Eq (Cardinal.mk α) ↑(Fintype.card α)","decl":"@[simp]\ntheorem mk_fintype (α : Type u) [h : Fintype α] : #α = Fintype.card α :=\n  mk_congr (Fintype.equivOfCardEq (by simp))\n\n"}
{"name":"Cardinal.mul_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\n⊢ Eq (HMul.hMul (Cardinal.mk α) (Cardinal.mk β)) (Cardinal.mk (Prod α β))","decl":"theorem mul_def (α β : Type u) : #α * #β = #(α × β) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk (Prod α β)) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β)))","decl":"@[simp]\ntheorem mk_prod (α : Type u) (β : Type v) : #(α × β) = lift.{v, u} #α * lift.{u, v} #β :=\n  mk_congr (Equiv.ulift.symm.prodCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.power_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\n⊢ Eq (HPow.hPow (Cardinal.mk α) (Cardinal.mk β)) (Cardinal.mk (β → α))","decl":"theorem power_def (α β : Type u) : #α ^ #β = #(β → α) :=\n  rfl\n\n"}
{"name":"Cardinal.mk_arrow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk (α → β)) (HPow.hPow (Cardinal.lift.{u, v} (Cardinal.mk β)) (Cardinal.lift.{v, u} (Cardinal.mk α)))","decl":"theorem mk_arrow (α : Type u) (β : Type v) : #(α → β) = (lift.{u} #β^lift.{v} #α) :=\n  mk_congr (Equiv.ulift.symm.arrowCongr Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.lift_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (HPow.hPow a b)) (HPow.hPow (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_power (a b : Cardinal.{u}) : lift.{v} (a ^ b) = lift.{v} a ^ lift.{v} b :=\n  inductionOn₂ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.ulift.arrowCongr Equiv.ulift).symm\n\n"}
{"name":"Cardinal.power_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (HPow.hPow a 0) 1","decl":"@[simp]\ntheorem power_zero (a : Cardinal) : a ^ (0 : Cardinal) = 1 :=\n  inductionOn a fun _ => mk_eq_one _\n\n"}
{"name":"Cardinal.power_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Eq (HPow.hPow a 1) a","decl":"@[simp]\ntheorem power_one (a : Cardinal.{u}) : a ^ (1 : Cardinal) = a :=\n  inductionOn a fun α => mk_congr (Equiv.funUnique (ULift.{u} (Fin 1)) α)\n\n"}
{"name":"Cardinal.power_add","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n⊢ Eq (HPow.hPow a (HAdd.hAdd b c)) (HMul.hMul (HPow.hPow a b) (HPow.hPow a c))","decl":"theorem power_add (a b c : Cardinal) : a ^ (b + c) = a ^ b * a ^ c :=\n  inductionOn₃ a b c fun α β γ => mk_congr <| Equiv.sumArrowEquivProdArrow β γ α\n\n"}
{"name":"Cardinal.one_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (HPow.hPow 1 a) 1","decl":"@[simp]\ntheorem one_power {a : Cardinal} : (1 : Cardinal) ^ a = 1 :=\n  inductionOn a fun _ => mk_eq_one _\n\n"}
{"name":"Cardinal.mk_bool","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Bool) 2","decl":"theorem mk_bool : #Bool = 2 := by simp\n\n"}
{"name":"Cardinal.mk_Prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Prop) 2","decl":"theorem mk_Prop : #Prop = 2 := by simp\n\n"}
{"name":"Cardinal.zero_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\na✝ : Ne a 0\n⊢ Eq (HPow.hPow 0 a) 0","decl":"@[simp]\ntheorem zero_power {a : Cardinal} : a ≠ 0 → (0 : Cardinal) ^ a = 0 :=\n  inductionOn a fun _ heq =>\n    mk_eq_zero_iff.2 <|\n      isEmpty_pi.2 <|\n        let ⟨a⟩ := mk_ne_zero_iff.1 heq\n        ⟨a, inferInstance⟩\n\n"}
{"name":"Cardinal.power_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\na✝ : Ne a 0\n⊢ Ne (HPow.hPow a b) 0","decl":"theorem power_ne_zero {a : Cardinal} (b : Cardinal) : a ≠ 0 → a ^ b ≠ 0 :=\n  inductionOn₂ a b fun _ _ h =>\n    let ⟨a⟩ := mk_ne_zero_iff.1 h\n    mk_ne_zero_iff.2 ⟨fun _ => a⟩\n\n"}
{"name":"Cardinal.mul_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n⊢ Eq (HPow.hPow (HMul.hMul a b) c) (HMul.hMul (HPow.hPow a c) (HPow.hPow b c))","decl":"theorem mul_power {a b c : Cardinal} : (a * b) ^ c = a ^ c * b ^ c :=\n  inductionOn₃ a b c fun α β γ => mk_congr <| Equiv.arrowProdEquivProdArrow α β γ\n\n"}
{"name":"Cardinal.power_mul","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n⊢ Eq (HPow.hPow a (HMul.hMul b c)) (HPow.hPow (HPow.hPow a b) c)","decl":"theorem power_mul {a b c : Cardinal} : a ^ (b * c) = (a ^ b) ^ c := by\n  rw [mul_comm b c]\n  exact inductionOn₃ a b c fun α β γ => mk_congr <| Equiv.curry γ β α\n\n"}
{"name":"Cardinal.power_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n⊢ Eq (HPow.hPow a ↑n) (HPow.hPow a n)","decl":"@[simp, norm_cast]\ntheorem power_natCast (a : Cardinal.{u}) (n : ℕ) : a ^ (↑n : Cardinal.{u}) = a ^ n :=\n  rfl\n\n"}
{"name":"Cardinal.power_cast_right","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n⊢ Eq (HPow.hPow a ↑n) (HPow.hPow a n)","decl":"@[deprecated (since := \"2024-10-16\")]\nalias power_cast_right := power_natCast\n\n"}
{"name":"Cardinal.lift_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.lift.{u_2, u_1} 1) 1","decl":"@[simp]\ntheorem lift_one : lift 1 = 1 := mk_eq_one _\n\n"}
{"name":"Cardinal.lift_eq_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{v}\n⊢ Iff (Eq (Cardinal.lift.{u, v} a) 1) (Eq a 1)","decl":"@[simp]\ntheorem lift_eq_one {a : Cardinal.{v}} : lift.{u} a = 1 ↔ a = 1 :=\n  lift_injective.eq_iff' lift_one\n\n"}
{"name":"Cardinal.lift_add","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (HAdd.hAdd a b)) (HAdd.hAdd (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_add (a b : Cardinal.{u}) : lift.{v} (a + b) = lift.{v} a + lift.{v} b :=\n  inductionOn₂ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.sumCongr Equiv.ulift Equiv.ulift).symm\n\n"}
{"name":"Cardinal.lift_mul","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (HMul.hMul a b)) (HMul.hMul (Cardinal.lift.{v, u} a) (Cardinal.lift.{v, u} b))","decl":"@[simp]\ntheorem lift_mul (a b : Cardinal.{u}) : lift.{v} (a * b) = lift.{v} a * lift.{v} b :=\n  inductionOn₂ a b fun _ _ =>\n    mk_congr <| Equiv.ulift.trans (Equiv.prodCongr Equiv.ulift Equiv.ulift).symm\n\n"}
{"name":"Cardinal.lift_two","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.lift.{u, v} 2) 2","decl":"theorem lift_two : lift.{u, v} 2 = 2 := by simp [← one_add_one_eq_two]\n\n"}
{"name":"Cardinal.mk_set","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (Set α)) (HPow.hPow 2 (Cardinal.mk α))","decl":"@[simp]\ntheorem mk_set {α : Type u} : #(Set α) = 2 ^ #α := by simp [← one_add_one_eq_two, Set, mk_arrow]\n\n"}
{"name":"Cardinal.mk_powerset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Cardinal.mk ↑s.powerset) (HPow.hPow 2 (Cardinal.mk ↑s))","decl":"/-- A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. -/\n@[simp]\ntheorem mk_powerset {α : Type u} (s : Set α) : #(↥(𝒫 s)) = 2 ^ #(↥s) :=\n  (mk_congr (Equiv.Set.powerset s)).trans mk_set\n\n"}
{"name":"Cardinal.lift_two_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (Cardinal.lift.{v, u_1} (HPow.hPow 2 a)) (HPow.hPow 2 (Cardinal.lift.{v, u_1} a))","decl":"theorem lift_two_power (a : Cardinal) : lift.{v} (2 ^ a) = 2 ^ lift.{v} a := by\n  simp [← one_add_one_eq_two]\n\n"}
{"name":"Cardinal.zero_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ LE.le 0 a","decl":"protected theorem zero_le : ∀ a : Cardinal, 0 ≤ a := by\n  rintro ⟨α⟩\n  exact ⟨Embedding.ofIsEmpty⟩\n\n"}
{"name":"Cardinal.addLeftMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ AddLeftMono Cardinal.{u_1}","decl":"instance addLeftMono : AddLeftMono Cardinal :=\n  ⟨fun _ _ _ => add_le_add' le_rfl⟩\n\n"}
{"name":"Cardinal.addRightMono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ AddRightMono Cardinal.{u_1}","decl":"instance addRightMono : AddRightMono Cardinal :=\n  ⟨fun _ _ _ h => add_le_add' h le_rfl⟩\n\n"}
{"name":"Cardinal.canonicallyOrderedAdd","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ CanonicallyOrderedAdd Cardinal.{u}","decl":"instance canonicallyOrderedAdd : CanonicallyOrderedAdd Cardinal.{u} where\n  exists_add_of_le {a b} :=\n    inductionOn₂ a b fun α β ⟨⟨f, hf⟩⟩ =>\n      have : α ⊕ ((range f)ᶜ : Set β) ≃ β := by\n        classical\n        exact (Equiv.sumCongr (Equiv.ofInjective f hf) (Equiv.refl _)).trans <|\n          Equiv.Set.sumCompl (range f)\n      ⟨#(↥(range f)ᶜ), mk_congr this.symm⟩\n  le_self_add a _ := (add_zero a).ge.trans <| add_le_add_left (Cardinal.zero_le _) _\n\n"}
{"name":"Cardinal.noZeroDivisors","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ NoZeroDivisors Cardinal.{u}","decl":"instance noZeroDivisors : NoZeroDivisors Cardinal.{u} where\n  eq_zero_or_eq_zero_of_mul_eq_zero := fun {a b} =>\n    inductionOn₂ a b fun α β => by\n      simpa only [mul_def, mk_eq_zero_iff, isEmpty_prod] using id\n\n"}
{"name":"Cardinal.zero_power_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ LE.le (HPow.hPow 0 c) 1","decl":"theorem zero_power_le (c : Cardinal.{u}) : (0 : Cardinal.{u}) ^ c ≤ 1 := by\n  by_cases h : c = 0\n  · rw [h, power_zero]\n  · rw [zero_power h]\n    apply zero_le\n\n"}
{"name":"Cardinal.power_le_power_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\na✝¹ : Ne a 0\na✝ : LE.le b c\n⊢ LE.le (HPow.hPow a b) (HPow.hPow a c)","decl":"theorem power_le_power_left : ∀ {a b c : Cardinal}, a ≠ 0 → b ≤ c → a ^ b ≤ a ^ c := by\n  rintro ⟨α⟩ ⟨β⟩ ⟨γ⟩ hα ⟨e⟩\n  let ⟨a⟩ := mk_ne_zero_iff.1 hα\n  exact ⟨@Function.Embedding.arrowCongrLeft _ _ _ ⟨a⟩ e⟩\n\n"}
{"name":"Cardinal.self_le_power","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nhb : LE.le 1 b\n⊢ LE.le a (HPow.hPow a b)","decl":"theorem self_le_power (a : Cardinal) {b : Cardinal} (hb : 1 ≤ b) : a ≤ a ^ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact zero_le _\n  · convert power_le_power_left ha hb\n    exact (power_one a).symm\n\n"}
{"name":"Cardinal.cantor","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ LT.lt a (HPow.hPow 2 a)","decl":"/-- **Cantor's theorem** -/\ntheorem cantor (a : Cardinal.{u}) : a < 2 ^ a := by\n  induction' a using Cardinal.inductionOn with α\n  rw [← mk_set]\n  refine ⟨⟨⟨singleton, fun a b => singleton_eq_singleton_iff.1⟩⟩, ?_⟩\n  rintro ⟨⟨f, hf⟩⟩\n  exact cantor_injective f hf\n\n"}
{"name":"Cardinal.instNoMaxOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ NoMaxOrder Cardinal.{u}","decl":"instance : NoMaxOrder Cardinal.{u} where exists_gt a := ⟨_, cantor a⟩\n\n-- short-circuit type class inference\n"}
{"name":"Cardinal.one_lt_iff_nontrivial","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LT.lt 1 (Cardinal.mk α)) (Nontrivial α)","decl":"theorem one_lt_iff_nontrivial {α : Type u} : 1 < #α ↔ Nontrivial α := by\n  rw [← not_le, le_one_iff_subsingleton, ← not_nontrivial_iff_subsingleton, Classical.not_not]\n\n"}
{"name":"Cardinal.power_le_max_power_one","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\nh : LE.le b c\n⊢ LE.le (HPow.hPow a b) (Max.max (HPow.hPow a c) 1)","decl":"theorem power_le_max_power_one {a b c : Cardinal} (h : b ≤ c) : a ^ b ≤ max (a ^ c) 1 := by\n  by_cases ha : a = 0\n  · simp [ha, zero_power_le]\n  · exact (power_le_power_left ha h).trans (le_max_left _ _)\n\n"}
{"name":"Cardinal.power_le_power_right","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\na✝ : LE.le a b\n⊢ LE.le (HPow.hPow a c) (HPow.hPow b c)","decl":"theorem power_le_power_right {a b c : Cardinal} : a ≤ b → a ^ c ≤ b ^ c :=\n  inductionOn₃ a b c fun _ _ _ ⟨e⟩ => ⟨Embedding.arrowCongrRight e⟩\n\n"}
{"name":"Cardinal.power_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt 0 a\n⊢ LT.lt 0 (HPow.hPow a b)","decl":"theorem power_pos {a : Cardinal} (b : Cardinal) (ha : 0 < a) : 0 < a ^ b :=\n  (power_ne_zero _ ha.ne').bot_lt\n\n"}
{"name":"Cardinal.lt_wf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"protected theorem lt_wf : @WellFounded Cardinal.{u} (· < ·) :=\n  ⟨fun a =>\n    by_contradiction fun h => by\n      let ι := { c : Cardinal // ¬Acc (· < ·) c }\n      let f : ι → Cardinal := Subtype.val\n      haveI hι : Nonempty ι := ⟨⟨_, h⟩⟩\n      obtain ⟨⟨c : Cardinal, hc : ¬Acc (· < ·) c⟩, ⟨h_1 : ∀ j, (f ⟨c, hc⟩).out ↪ (f j).out⟩⟩ :=\n        Embedding.min_injective fun i => (f i).out\n      refine hc (Acc.intro _ fun j h' => by_contradiction fun hj => h'.2 ?_)\n      have : #_ ≤ #_ := ⟨h_1 ⟨j, hj⟩⟩\n      simpa only [mk_out] using this⟩\n\n"}
{"name":"Cardinal.instWellFoundedLT","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ WellFoundedLT Cardinal.{u}","decl":"instance : WellFoundedLT Cardinal.{u} :=\n  ⟨Cardinal.lt_wf⟩\n\n"}
{"name":"Cardinal.sInf_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf (∅ : Set Cardinal.{u}) = 0 :=\n  dif_neg Set.not_nonempty_empty\n\n"}
{"name":"Cardinal.sInf_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u_1}\n⊢ Iff (Eq (InfSet.sInf s) 0) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun a => And (Membership.mem s a) (Eq a 0)))","decl":"lemma sInf_eq_zero_iff {s : Set Cardinal} : sInf s = 0 ↔ s = ∅ ∨ ∃ a ∈ s, a = 0 := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases s.eq_empty_or_nonempty with rfl | hne\n    · exact Or.inl rfl\n    · exact Or.inr ⟨sInf s, csInf_mem hne, h⟩\n  · rcases h with rfl | ⟨a, ha, rfl⟩\n    · exact Cardinal.sInf_empty\n    · exact eq_bot_iff.2 (csInf_le' ha)\n\n"}
{"name":"Cardinal.iInf_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Sort u_1\nf : ι → Cardinal.{u_2}\n⊢ Iff (Eq (iInf fun i => f i) 0) (Or (IsEmpty ι) (Exists fun i => Eq (f i) 0))","decl":"lemma iInf_eq_zero_iff {ι : Sort*} {f : ι → Cardinal} :\n    (⨅ i, f i) = 0 ↔ IsEmpty ι ∨ ∃ i, f i = 0 := by\n  simp [iInf, sInf_eq_zero_iff]\n\n"}
{"name":"Cardinal.iSup_of_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Sort u_1\nf : ι → Cardinal.{u_2}\ninst✝ : IsEmpty ι\n⊢ Eq (iSup f) 0","decl":"/-- A variant of `ciSup_of_empty` but with `0` on the RHS for convenience -/\nprotected theorem iSup_of_empty {ι} (f : ι → Cardinal) [IsEmpty ι] : iSup f = 0 :=\n  ciSup_of_empty f\n\n"}
{"name":"Cardinal.lift_sInf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} (InfSet.sInf s)) (InfSet.sInf (Set.image Cardinal.lift.{u, v} s))","decl":"@[simp]\ntheorem lift_sInf (s : Set Cardinal) : lift.{u, v} (sInf s) = sInf (lift.{u, v} '' s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · simp\n  · exact lift_monotone.map_csInf hs\n\n"}
{"name":"Cardinal.lift_iInf","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Sort u_1\nf : ι → Cardinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} (iInf f)) (iInf fun i => Cardinal.lift.{u, v} (f i))","decl":"@[simp]\ntheorem lift_iInf {ι} (f : ι → Cardinal) : lift.{u, v} (iInf f) = ⨅ i, lift.{u, v} (f i) := by\n  unfold iInf\n  convert lift_sInf (range f)\n  simp_rw [← comp_apply (f := lift), range_comp]\n\n"}
{"name":"Cardinal.succ_def","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Eq (Order.succ c) (InfSet.sInf (setOf fun c' => LT.lt c c'))","decl":"theorem succ_def (c : Cardinal) : succ c = sInf { c' | c < c' } :=\n  dif_neg <| not_isMax c\n\n"}
{"name":"Cardinal.succ_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ LT.lt 0 (Order.succ c)","decl":"theorem succ_pos : ∀ c : Cardinal, 0 < succ c :=\n  bot_lt_succ\n\n"}
{"name":"Cardinal.succ_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Ne (Order.succ c) 0","decl":"theorem succ_ne_zero (c : Cardinal) : succ c ≠ 0 :=\n  (succ_pos _).ne'\n\n"}
{"name":"Cardinal.add_one_le_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ LE.le (HAdd.hAdd c 1) (Order.succ c)","decl":"theorem add_one_le_succ (c : Cardinal.{u}) : c + 1 ≤ succ c := by\n  -- Porting note: rewrote the next three lines to avoid defeq abuse.\n  have : Set.Nonempty { c' | c < c' } := exists_gt c\n  simp_rw [succ_def, le_csInf_iff'' this, mem_setOf]\n  intro b hlt\n  rcases b, c with ⟨⟨β⟩, ⟨γ⟩⟩\n  cases' le_of_lt hlt with f\n  have : ¬Surjective f := fun hn => (not_le_of_lt hlt) (mk_le_of_surjective hn)\n  simp only [Surjective, not_forall] at this\n  rcases this with ⟨b, hb⟩\n  calc\n    #γ + 1 = #(Option γ) := mk_option.symm\n    _ ≤ #β := (f.optionElim b hb).cardinal_le\n\n"}
{"name":"Cardinal.lift_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Eq (Cardinal.lift.{v, u} (Order.succ a)) (Order.succ (Cardinal.lift.{v, u} a))","decl":"@[simp]\ntheorem lift_succ (a) : lift.{v, u} (succ a) = succ (lift.{v, u} a) :=\n  le_antisymm\n    (le_of_not_gt fun h => by\n      rcases lt_lift_iff.1 h with ⟨b, h, e⟩\n      rw [lt_succ_iff, ← lift_le, e] at h\n      exact h.not_lt (lt_succ _))\n    (succ_le_of_lt <| lift_lt.2 <| lt_succ a)\n\n"}
{"name":"Cardinal.ne_zero_of_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Nat\nh : Order.IsSuccLimit c\n⊢ Ne c 0","decl":"theorem ne_zero_of_isSuccLimit {c} (h : IsSuccLimit c) : c ≠ 0 :=\n  h.ne_bot\n\n"}
{"name":"Cardinal.isSuccPrelimit_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Order.IsSuccPrelimit 0","decl":"theorem isSuccPrelimit_zero : IsSuccPrelimit (0 : Cardinal) :=\n  isSuccPrelimit_bot\n\n"}
{"name":"Cardinal.isSuccLimit_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (Order.IsSuccLimit c) (And (Ne c 0) (Order.IsSuccPrelimit c))","decl":"protected theorem isSuccLimit_iff {c : Cardinal} : IsSuccLimit c ↔ c ≠ 0 ∧ IsSuccPrelimit c :=\n  isSuccLimit_iff\n\n"}
{"name":"Cardinal.IsLimit.isSuccPrelimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n⊢ Order.IsSuccPrelimit c","decl":"set_option linter.deprecated false in\n@[deprecated IsSuccLimit.isSuccPrelimit (since := \"2024-09-17\")]\nprotected theorem IsLimit.isSuccPrelimit {c} (h : IsLimit c) : IsSuccPrelimit c :=\n  h.2\n\n"}
{"name":"Cardinal.IsLimit.ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n⊢ Ne c 0","decl":"set_option linter.deprecated false in\n@[deprecated ne_zero_of_isSuccLimit (since := \"2024-09-17\")]\nprotected theorem IsLimit.ne_zero {c} (h : IsLimit c) : c ≠ 0 :=\n  h.1\n\n"}
{"name":"Cardinal.IsLimit.isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n⊢ Order.IsSuccPrelimit c","decl":"set_option linter.deprecated false in\n@[deprecated IsLimit.isSuccPrelimit (since := \"2024-09-05\")]\nalias IsLimit.isSuccLimit := IsLimit.isSuccPrelimit\n\n"}
{"name":"Cardinal.IsLimit.succ_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"x c : Cardinal.{u_1}\nh : c.IsLimit\na✝ : LT.lt x c\n⊢ LT.lt (Order.succ x) c","decl":"set_option linter.deprecated false in\n@[deprecated IsSuccLimit.succ_lt (since := \"2024-09-17\")]\ntheorem IsLimit.succ_lt {x c} (h : IsLimit c) : x < c → succ x < c :=\n  h.isSuccPrelimit.succ_lt\n\n"}
{"name":"Cardinal.isSuccLimit_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Order.IsSuccPrelimit 0","decl":"@[deprecated isSuccPrelimit_zero (since := \"2024-09-05\")]\nalias isSuccLimit_zero := isSuccPrelimit_zero\n\n"}
{"name":"Cardinal.le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{max u_1 u_2}\ni : ι\n⊢ LE.le (f i) (Cardinal.sum f)","decl":"theorem le_sum {ι} (f : ι → Cardinal) (i) : f i ≤ sum f := by\n  rw [← Quotient.out_eq (f i)]\n  exact ⟨⟨fun a => ⟨i, a⟩, fun a b h => by injection h⟩⟩\n\n"}
{"name":"Cardinal.iSup_le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{max u_1 u_2}\n⊢ LE.le (iSup f) (Cardinal.sum f)","decl":"theorem iSup_le_sum {ι} (f : ι → Cardinal) : iSup f ≤ sum f :=\n  ciSup_le' <| le_sum _\n\n"}
{"name":"Cardinal.mk_sigma","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_2\nf : ι → Type u_1\n⊢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.sum fun i => Cardinal.mk (f i))","decl":"@[simp]\ntheorem mk_sigma {ι} (f : ι → Type*) : #(Σ i, f i) = sum fun i => #(f i) :=\n  mk_congr <| Equiv.sigmaCongrRight fun _ => outMkEquiv.symm\n\n"}
{"name":"Cardinal.mk_sigma_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nι' : Type v'\nf : ι → Type w\ng : ι' → Type w'\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.lift.{w', w} (Cardinal.mk (f i))) (Cardinal.lift.{w, w'} (Cardinal.mk (g (e i))))\n⊢ Eq (Cardinal.lift.{max v' w', max w v} (Cardinal.mk (Sigma fun i => f i))) (Cardinal.lift.{max v w, max w' v'} (Cardinal.mk (Sigma fun i => g i)))","decl":"theorem mk_sigma_congr_lift {ι : Type v} {ι' : Type v'} {f : ι → Type w} {g : ι' → Type w'}\n    (e : ι ≃ ι') (h : ∀ i, lift.{w'} #(f i) = lift.{w} #(g (e i))) :\n    lift.{max v' w'} #(Σ i, f i) = lift.{max v w} #(Σ i, g i) :=\n  Cardinal.lift_mk_eq'.2 ⟨.sigmaCongr e fun i ↦ Classical.choice <| Cardinal.lift_mk_eq'.1 (h i)⟩\n\n"}
{"name":"Cardinal.mk_sigma_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι ι' : Type u\nf : ι → Type v\ng : ι' → Type v\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n⊢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"theorem mk_sigma_congr {ι ι' : Type u} {f : ι → Type v} {g : ι' → Type v} (e : ι ≃ ι')\n    (h : ∀ i, #(f i) = #(g (e i))) : #(Σ i, f i) = #(Σ i, g i) :=\n  mk_congr <| Equiv.sigmaCongr e fun i ↦ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_congr'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Type (max w u v)\ng : ι' → Type (max w u v)\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n⊢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"/-- Similar to `mk_sigma_congr` with indexing types in different universes. This is not a strict\ngeneralization. -/\ntheorem mk_sigma_congr' {ι : Type u} {ι' : Type v} {f : ι → Type max w (max u v)}\n    {g : ι' → Type max w (max u v)} (e : ι ≃ ι')\n    (h : ∀ i, #(f i) = #(g (e i))) : #(Σ i, f i) = #(Σ i, g i) :=\n  mk_congr <| Equiv.sigmaCongr e fun i ↦ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf g : ι → Type v\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n⊢ Eq (Cardinal.mk (Sigma fun i => f i)) (Cardinal.mk (Sigma fun i => g i))","decl":"theorem mk_sigma_congrRight {ι : Type u} {f g : ι → Type v} (h : ∀ i, #(f i) = #(g i)) :\n    #(Σ i, f i) = #(Σ i, g i) :=\n  mk_sigma_congr (Equiv.refl ι) h\n\n"}
{"name":"Cardinal.mk_psigma_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf g : ι → Type v\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n⊢ Eq (Cardinal.mk (PSigma fun i => f i)) (Cardinal.mk (PSigma fun i => g i))","decl":"theorem mk_psigma_congrRight {ι : Type u} {f g : ι → Type v} (h : ∀ i, #(f i) = #(g i)) :\n    #(Σ' i, f i) = #(Σ' i, g i) :=\n  mk_congr <| .psigmaCongrRight fun i => Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_psigma_congrRight_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Prop\nf g : ι → Type v\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n⊢ Eq (Cardinal.mk (PSigma fun i => f i)) (Cardinal.mk (PSigma fun i => g i))","decl":"theorem mk_psigma_congrRight_prop {ι : Prop} {f g : ι → Type v} (h : ∀ i, #(f i) = #(g i)) :\n    #(Σ' i, f i) = #(Σ' i, g i) :=\n  mk_congr <| .psigmaCongrRight fun i => Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_sigma_arrow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_3\nα : Type u_1\nf : ι → Type u_2\n⊢ Eq (Cardinal.mk (Sigma f → α)) (Cardinal.mk ((i : ι) → f i → α))","decl":"theorem mk_sigma_arrow {ι} (α : Type*) (f : ι → Type*) :\n    #(Sigma f → α) = #(Π i, f i → α) := mk_congr <| Equiv.piCurry fun _ _ ↦ α\n\n"}
{"name":"Cardinal.sum_const","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\na : Cardinal.{v}\n⊢ Eq (Cardinal.sum fun x => a) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk ι)) (Cardinal.lift.{u, v} a))","decl":"@[simp]\ntheorem sum_const (ι : Type u) (a : Cardinal.{v}) :\n    (sum fun _ : ι => a) = lift.{v} #ι * lift.{u} a :=\n  inductionOn a fun α =>\n    mk_congr <|\n      calc\n        (Σ _ : ι, Quotient.out #α) ≃ ι × Quotient.out #α := Equiv.sigmaEquivProd _ _\n        _ ≃ ULift ι × ULift α := Equiv.ulift.symm.prodCongr (outMkEquiv.trans Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.sum_const'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\na : Cardinal.{u}\n⊢ Eq (Cardinal.sum fun x => a) (HMul.hMul (Cardinal.mk ι) a)","decl":"theorem sum_const' (ι : Type u) (a : Cardinal.{u}) : (sum fun _ : ι => a) = #ι * a := by simp\n\n"}
{"name":"Cardinal.sum_add_distrib","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf g : ι → Cardinal.{u_2}\n⊢ Eq (Cardinal.sum (HAdd.hAdd f g)) (HAdd.hAdd (Cardinal.sum f) (Cardinal.sum g))","decl":"@[simp]\ntheorem sum_add_distrib {ι} (f g : ι → Cardinal) : sum (f + g) = sum f + sum g := by\n  have := mk_congr (Equiv.sigmaSumDistrib (Quotient.out ∘ f) (Quotient.out ∘ g))\n  simp only [comp_apply, mk_sigma, mk_sum, mk_out, lift_id] at this\n  exact this\n\n"}
{"name":"Cardinal.sum_add_distrib'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf g : ι → Cardinal.{u_2}\n⊢ Eq (Cardinal.sum fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (Cardinal.sum f) (Cardinal.sum g))","decl":"@[simp]\ntheorem sum_add_distrib' {ι} (f g : ι → Cardinal) :\n    (Cardinal.sum fun i => f i + g i) = sum f + sum g :=\n  sum_add_distrib f g\n\n"}
{"name":"Cardinal.lift_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\n⊢ Eq (Cardinal.lift.{w, max v u} (Cardinal.sum f)) (Cardinal.sum fun i => Cardinal.lift.{w, v} (f i))","decl":"@[simp]\ntheorem lift_sum {ι : Type u} (f : ι → Cardinal.{v}) :\n    Cardinal.lift.{w} (Cardinal.sum f) = Cardinal.sum fun i => Cardinal.lift.{w} (f i) :=\n  Equiv.cardinal_eq <|\n    Equiv.ulift.trans <|\n      Equiv.sigmaCongrRight fun a =>\n    -- Porting note: Inserted universe hint .{_,_,v} below\n        Nonempty.some <| by rw [← lift_mk_eq.{_,_,v}, mk_out, mk_out, lift_lift]\n\n"}
{"name":"Cardinal.sum_le_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf g : ι → Cardinal.{u_2}\nH : ∀ (i : ι), LE.le (f i) (g i)\n⊢ LE.le (Cardinal.sum f) (Cardinal.sum g)","decl":"theorem sum_le_sum {ι} (f g : ι → Cardinal) (H : ∀ i, f i ≤ g i) : sum f ≤ sum g :=\n  ⟨(Embedding.refl _).sigmaMap fun i =>\n      Classical.choice <| by have := H i; rwa [← Quot.out_eq (f i), ← Quot.out_eq (g i)] at this⟩\n\n"}
{"name":"Cardinal.mk_le_mk_mul_of_mk_preimage_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nc : Cardinal.{u}\nf : α → β\nhf : ∀ (b : β), LE.le (Cardinal.mk ↑(Set.preimage f (Singleton.singleton b))) c\n⊢ LE.le (Cardinal.mk α) (HMul.hMul (Cardinal.mk β) c)","decl":"theorem mk_le_mk_mul_of_mk_preimage_le {c : Cardinal} (f : α → β) (hf : ∀ b : β, #(f ⁻¹' {b}) ≤ c) :\n    #α ≤ #β * c := by\n  simpa only [← mk_congr (@Equiv.sigmaFiberEquiv α β f), mk_sigma, ← sum_const'] using\n    sum_le_sum _ _ hf\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nc : Cardinal.{max u v}\nf : α → β\nhf : ∀ (b : β), LE.le (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.preimage f (Singleton.singleton b)))) c\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk α)) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk β)) c)","decl":"theorem lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le {α : Type u} {β : Type v} {c : Cardinal}\n    (f : α → β) (hf : ∀ b : β, lift.{v} #(f ⁻¹' {b}) ≤ c) : lift.{v} #α ≤ lift.{u} #β * c :=\n  (mk_le_mk_mul_of_mk_preimage_le fun x : ULift.{v} α => ULift.up.{u} (f x.1)) <|\n    ULift.forall.2 fun b =>\n      (mk_congr <|\n            (Equiv.ulift.image _).trans\n              (Equiv.trans\n                (by\n                  rw [Equiv.image_eq_preimage]\n                  /- Porting note: Need to insert the following `have` b/c bad fun coercion\n                   behaviour for Equivs -/\n                  have : DFunLike.coe (Equiv.symm (Equiv.ulift (α := α))) = ULift.up (α := α) := rfl\n                  rw [this]\n                  simp only [preimage, mem_singleton_iff, ULift.up_inj, mem_setOf_eq, coe_setOf]\n                  exact Equiv.refl _)\n                Equiv.ulift.symm)).trans_le\n        (hf b)\n\n"}
{"name":"Cardinal.sum_nat_eq_add_sum_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Nat → Cardinal.{u}\n⊢ Eq (Cardinal.sum f) (HAdd.hAdd (f 0) (Cardinal.sum fun i => f (HAdd.hAdd i 1)))","decl":"theorem sum_nat_eq_add_sum_succ (f : ℕ → Cardinal.{u}) :\n    Cardinal.sum f = f 0 + Cardinal.sum fun i => f (i + 1) := by\n  refine (Equiv.sigmaNatSucc fun i => Quotient.out (f i)).cardinal_eq.trans ?_\n  simp only [mk_sum, mk_out, lift_id, mk_sigma]\n\n"}
{"name":"nonempty_embedding_to_cardinal","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Nonempty (Function.Embedding α Cardinal.{u})","decl":"open Cardinal in\ntheorem nonempty_embedding_to_cardinal : Nonempty (α ↪ Cardinal.{u}) :=\n  (Embedding.total _ _).resolve_left fun ⟨⟨f, hf⟩⟩ =>\n    let g : α → Cardinal.{u} := invFun f\n    let ⟨x, (hx : g x = 2 ^ sum g)⟩ := invFun_surjective hf (2 ^ sum g)\n    have : g x ≤ sum g := le_sum.{u, u} g x\n    not_le_of_gt (by rw [hx]; exact cantor _) this\n\n"}
{"name":"WellOrderingRel.isWellOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ IsWellOrder α WellOrderingRel","decl":"instance WellOrderingRel.isWellOrder : IsWellOrder α WellOrderingRel :=\n  (RelEmbedding.preimage _ _).isWellOrder\n\n"}
{"name":"IsWellOrder.subtype_nonempty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Nonempty (Subtype fun r => IsWellOrder α r)","decl":"instance IsWellOrder.subtype_nonempty : Nonempty { r // IsWellOrder α r } :=\n  ⟨⟨WellOrderingRel, inferInstance⟩⟩\n\n"}
{"name":"exists_wellOrder","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Exists fun x => WellFoundedLT α","decl":"variable (α) in\n/-- The **well-ordering theorem** (or **Zermelo's theorem**): every type has a well-order -/\ntheorem exists_wellOrder : ∃ (_ : LinearOrder α), WellFoundedLT α := by\n  classical\n  exact ⟨linearOrderOfSTO WellOrderingRel, WellOrderingRel.isWellOrder.toIsWellFounded⟩\n\n"}
{"name":"Cardinal.small_Iic","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Iic a)","decl":"instance small_Iic (a : Cardinal.{u}) : Small.{u} (Iic a) := by\n  rw [← mk_out a]\n  apply @small_of_surjective (Set a.out) (Iic #a.out) _ fun x => ⟨#x, mk_set_le x⟩\n  rintro ⟨x, hx⟩\n  simpa using le_mk_iff_exists_set.1 hx\n\n"}
{"name":"Cardinal.small_Iio","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Iio a)","decl":"instance small_Iio (a : Cardinal.{u}) : Small.{u} (Iio a) := small_subset Iio_subset_Iic_self\n"}
{"name":"Cardinal.small_Icc","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Icc a b)","decl":"instance small_Icc (a b : Cardinal.{u}) : Small.{u} (Icc a b) := small_subset Icc_subset_Iic_self\n"}
{"name":"Cardinal.small_Ico","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ico a b)","decl":"instance small_Ico (a b : Cardinal.{u}) : Small.{u} (Ico a b) := small_subset Ico_subset_Iio_self\n"}
{"name":"Cardinal.small_Ioc","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ioc a b)","decl":"instance small_Ioc (a b : Cardinal.{u}) : Small.{u} (Ioc a b) := small_subset Ioc_subset_Iic_self\n"}
{"name":"Cardinal.small_Ioo","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Small.{u, u + 1} ↑(Set.Ioo a b)","decl":"instance small_Ioo (a b : Cardinal.{u}) : Small.{u} (Ioo a b) := small_subset Ioo_subset_Iio_self\n\n"}
{"name":"Cardinal.bddAbove_iff_small","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u}\n⊢ Iff (BddAbove s) (Small.{u, u + 1} ↑s)","decl":"/-- A set of cardinals is bounded above iff it's small, i.e. it corresponds to a usual ZFC set. -/\ntheorem bddAbove_iff_small {s : Set Cardinal.{u}} : BddAbove s ↔ Small.{u} s :=\n  ⟨fun ⟨a, ha⟩ => @small_subset _ (Iic a) s (fun _ h => ha h) _, by\n    rintro ⟨ι, ⟨e⟩⟩\n    use sum.{u, u} fun x ↦ e.symm x\n    intro a ha\n    simpa using le_sum (fun x ↦ e.symm x) (e ⟨a, ha⟩)⟩\n\n"}
{"name":"Cardinal.bddAbove_of_small","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u}\nh : Small.{u, u + 1} ↑s\n⊢ BddAbove s","decl":"theorem bddAbove_of_small (s : Set Cardinal.{u}) [h : Small.{u} s] : BddAbove s :=\n  bddAbove_iff_small.2 h\n\n"}
{"name":"Cardinal.bddAbove_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Cardinal.{u}\n⊢ BddAbove (Set.range f)","decl":"theorem bddAbove_range {ι : Type*} [Small.{u} ι] (f : ι → Cardinal.{u}) : BddAbove (Set.range f) :=\n  bddAbove_of_small _\n\n"}
{"name":"Cardinal.bddAbove_image","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"f : Cardinal.{u} → Cardinal.{max u v}\ns : Set Cardinal.{u}\nhs : BddAbove s\n⊢ BddAbove (Set.image f s)","decl":"theorem bddAbove_image (f : Cardinal.{u} → Cardinal.{max u v}) {s : Set Cardinal.{u}}\n    (hs : BddAbove s) : BddAbove (f '' s) := by\n  rw [bddAbove_iff_small] at hs ⊢\n  exact small_lift _\n\n"}
{"name":"Cardinal.bddAbove_range_comp","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\nhf : BddAbove (Set.range f)\ng : Cardinal.{v} → Cardinal.{max v w}\n⊢ BddAbove (Set.range (Function.comp g f))","decl":"theorem bddAbove_range_comp {ι : Type u} {f : ι → Cardinal.{v}} (hf : BddAbove (range f))\n    (g : Cardinal.{v} → Cardinal.{max v w}) : BddAbove (range (g ∘ f)) := by\n  rw [range_comp]\n  exact bddAbove_image g hf\n\n"}
{"name":"Cardinal.sum_le_iSup_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf : ι → Cardinal.{max u v}\n⊢ LE.le (Cardinal.sum f) (HMul.hMul (Cardinal.lift.{v, u} (Cardinal.mk ι)) (iSup f))","decl":"theorem sum_le_iSup_lift {ι : Type u}\n    (f : ι → Cardinal.{max u v}) : sum f ≤ Cardinal.lift #ι * iSup f := by\n  rw [← (iSup f).lift_id, ← lift_umax, lift_umax.{max u v, u}, ← sum_const]\n  exact sum_le_sum _ _ (le_ciSup <| bddAbove_of_small _)\n\n"}
{"name":"Cardinal.sum_le_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf : ι → Cardinal.{u}\n⊢ LE.le (Cardinal.sum f) (HMul.hMul (Cardinal.mk ι) (iSup f))","decl":"theorem sum_le_iSup {ι : Type u} (f : ι → Cardinal.{u}) : sum f ≤ #ι * iSup f := by\n  rw [← lift_id #ι]\n  exact sum_le_iSup_lift f\n\n"}
{"name":"Cardinal.lift_sSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"s : Set Cardinal.{u_1}\nhs : BddAbove s\n⊢ Eq (Cardinal.lift.{u, u_1} (SupSet.sSup s)) (SupSet.sSup (Set.image Cardinal.lift.{u, u_1} s))","decl":"/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_sSup {s : Set Cardinal} (hs : BddAbove s) :\n    lift.{u} (sSup s) = sSup (lift.{u} '' s) := by\n  apply ((le_csSup_iff' (bddAbove_image.{_,u} _ hs)).2 fun c hc => _).antisymm (csSup_le' _)\n  · intro c hc\n    by_contra h\n    obtain ⟨d, rfl⟩ := Cardinal.mem_range_lift_of_le (not_le.1 h).le\n    simp_rw [lift_le] at h hc\n    rw [csSup_le_iff' hs] at h\n    exact h fun a ha => lift_le.1 <| hc (mem_image_of_mem _ ha)\n  · rintro i ⟨j, hj, rfl⟩\n    exact lift_le.2 (le_csSup hs hj)\n\n"}
{"name":"Cardinal.lift_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nf : ι → Cardinal.{w}\nhf : BddAbove (Set.range f)\n⊢ Eq (Cardinal.lift.{u, w} (iSup f)) (iSup fun i => Cardinal.lift.{u, w} (f i))","decl":"/-- The lift of a supremum is the supremum of the lifts. -/\ntheorem lift_iSup {ι : Type v} {f : ι → Cardinal.{w}} (hf : BddAbove (range f)) :\n    lift.{u} (iSup f) = ⨆ i, lift.{u} (f i) := by\n  rw [iSup, iSup, lift_sSup hf, ← range_comp]\n  simp [Function.comp_def]\n\n"}
{"name":"Cardinal.lift_iSup_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nf : ι → Cardinal.{w}\nt : Cardinal.{max u w}\nhf : BddAbove (Set.range f)\nw : ∀ (i : ι), LE.le (Cardinal.lift.{u, w} (f i)) t\n⊢ LE.le (Cardinal.lift.{u, w} (iSup f)) t","decl":"/-- To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. -/\ntheorem lift_iSup_le {ι : Type v} {f : ι → Cardinal.{w}} {t : Cardinal} (hf : BddAbove (range f))\n    (w : ∀ i, lift.{u} (f i) ≤ t) : lift.{u} (iSup f) ≤ t := by\n  rw [lift_iSup hf]\n  exact ciSup_le' w\n\n"}
{"name":"Cardinal.lift_iSup_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nf : ι → Cardinal.{w}\nhf : BddAbove (Set.range f)\nt : Cardinal.{max u w}\n⊢ Iff (LE.le (Cardinal.lift.{u, w} (iSup f)) t) (∀ (i : ι), LE.le (Cardinal.lift.{u, w} (f i)) t)","decl":"@[simp]\ntheorem lift_iSup_le_iff {ι : Type v} {f : ι → Cardinal.{w}} (hf : BddAbove (range f))\n    {t : Cardinal} : lift.{u} (iSup f) ≤ t ↔ ∀ i, lift.{u} (f i) ≤ t := by\n  rw [lift_iSup hf]\n  exact ciSup_le_iff' (bddAbove_range_comp.{_,_,u} hf _)\n\n"}
{"name":"Cardinal.lift_iSup_le_lift_iSup","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nι' : Type v'\nf : ι → Cardinal.{w}\nf' : ι' → Cardinal.{w'}\nhf : BddAbove (Set.range f)\nhf' : BddAbove (Set.range f')\ng : ι → ι'\nh : ∀ (i : ι), LE.le (Cardinal.lift.{w', w} (f i)) (Cardinal.lift.{w, w'} (f' (g i)))\n⊢ LE.le (Cardinal.lift.{w', w} (iSup f)) (Cardinal.lift.{w, w'} (iSup f'))","decl":"/-- To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum.\n-/\ntheorem lift_iSup_le_lift_iSup {ι : Type v} {ι' : Type v'} {f : ι → Cardinal.{w}}\n    {f' : ι' → Cardinal.{w'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) {g : ι → ι'}\n    (h : ∀ i, lift.{w'} (f i) ≤ lift.{w} (f' (g i))) : lift.{w'} (iSup f) ≤ lift.{w} (iSup f') := by\n  rw [lift_iSup hf, lift_iSup hf']\n  exact ciSup_mono' (bddAbove_range_comp.{_,_,w} hf' _) fun i => ⟨_, h i⟩\n\n"}
{"name":"Cardinal.lift_iSup_le_lift_iSup'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nι' : Type v'\nf : ι → Cardinal.{v}\nf' : ι' → Cardinal.{v'}\nhf : BddAbove (Set.range f)\nhf' : BddAbove (Set.range f')\ng : ι → ι'\nh : ∀ (i : ι), LE.le (Cardinal.lift.{v', v} (f i)) (Cardinal.lift.{v, v'} (f' (g i)))\n⊢ LE.le (Cardinal.lift.{v', v} (iSup f)) (Cardinal.lift.{v, v'} (iSup f'))","decl":"/-- A variant of `lift_iSup_le_lift_iSup` with universes specialized via `w = v` and `w' = v'`.\nThis is sometimes necessary to avoid universe unification issues. -/\ntheorem lift_iSup_le_lift_iSup' {ι : Type v} {ι' : Type v'} {f : ι → Cardinal.{v}}\n    {f' : ι' → Cardinal.{v'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) (g : ι → ι')\n    (h : ∀ i, lift.{v'} (f i) ≤ lift.{v} (f' (g i))) : lift.{v'} (iSup f) ≤ lift.{v} (iSup f') :=\n  lift_iSup_le_lift_iSup hf hf' h\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\nω : Cardinal.{v}\nhω : Not (Order.IsSuccPrelimit ω)\nh : Eq (iSup fun i => f i) ω\n⊢ Exists fun i => Eq (f i) ω","decl":"lemma exists_eq_of_iSup_eq_of_not_isSuccPrelimit\n    {ι : Type u} (f : ι → Cardinal.{v}) (ω : Cardinal.{v})\n    (hω : ¬ IsSuccPrelimit ω)\n    (h : ⨆ i : ι, f i = ω) : ∃ i, f i = ω := by\n  subst h\n  refine (isLUB_csSup' ?_).exists_of_not_isSuccPrelimit hω\n  contrapose! hω with hf\n  rw [iSup, csSup_of_not_bddAbove hf, csSup_empty]\n  exact isSuccPrelimit_bot\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nhι : Nonempty ι\nf : ι → Cardinal.{v}\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\nhc : Not (Order.IsSuccLimit c)\nh : Eq (iSup fun i => f i) c\n⊢ Exists fun i => Eq (f i) c","decl":"lemma exists_eq_of_iSup_eq_of_not_isSuccLimit\n    {ι : Type u} [hι : Nonempty ι] (f : ι → Cardinal.{v}) (hf : BddAbove (range f))\n    {c : Cardinal.{v}} (hc : ¬ IsSuccLimit c)\n    (h : ⨆ i, f i = c) : ∃ i, f i = c := by\n  rw [Cardinal.isSuccLimit_iff] at hc\n  refine (not_and_or.mp hc).elim (fun e ↦ ⟨hι.some, ?_⟩)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f c · h)\n  cases not_not.mp e\n  rw [← le_zero_iff] at h ⊢\n  exact (le_ciSup hf _).trans h\n\n"}
{"name":"Cardinal.exists_eq_of_iSup_eq_of_not_isLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nhι : Nonempty ι\nf : ι → Cardinal.{v}\nhf : BddAbove (Set.range f)\nω : Cardinal.{v}\nhω : Not ω.IsLimit\nh : Eq (iSup fun i => f i) ω\n⊢ Exists fun i => Eq (f i) ω","decl":"set_option linter.deprecated false in\n@[deprecated exists_eq_of_iSup_eq_of_not_isSuccLimit (since := \"2024-09-17\")]\nlemma exists_eq_of_iSup_eq_of_not_isLimit\n    {ι : Type u} [hι : Nonempty ι] (f : ι → Cardinal.{v}) (hf : BddAbove (range f))\n    (ω : Cardinal.{v}) (hω : ¬ ω.IsLimit)\n    (h : ⨆ i : ι, f i = ω) : ∃ i, f i = ω := by\n  refine (not_and_or.mp hω).elim (fun e ↦ ⟨hι.some, ?_⟩)\n    (Cardinal.exists_eq_of_iSup_eq_of_not_isSuccPrelimit.{u, v} f ω · h)\n  cases not_not.mp e\n  rw [← le_zero_iff] at h ⊢\n  exact (le_ciSup hf _).trans h\n\n"}
{"name":"Cardinal.mk_pi","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nα : ι → Type v\n⊢ Eq (Cardinal.mk ((i : ι) → α i)) (Cardinal.prod fun i => Cardinal.mk (α i))","decl":"@[simp]\ntheorem mk_pi {ι : Type u} (α : ι → Type v) : #(Π i, α i) = prod fun i => #(α i) :=\n  mk_congr <| Equiv.piCongrRight fun _ => outMkEquiv.symm\n\n"}
{"name":"Cardinal.mk_pi_congr_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type v\nι' : Type v'\nf : ι → Type w\ng : ι' → Type w'\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.lift.{w', w} (Cardinal.mk (f i))) (Cardinal.lift.{w, w'} (Cardinal.mk (g (e i))))\n⊢ Eq (Cardinal.lift.{max v' w', max v w} (Cardinal.mk ((i : ι) → f i))) (Cardinal.lift.{max v w, max v' w'} (Cardinal.mk ((i : ι') → g i)))","decl":"theorem mk_pi_congr_lift {ι : Type v} {ι' : Type v'} {f : ι → Type w} {g : ι' → Type w'}\n    (e : ι ≃ ι') (h : ∀ i, lift.{w'} #(f i) = lift.{w} #(g (e i))) :\n    lift.{max v' w'} #(Π i, f i) = lift.{max v w} #(Π i, g i) :=\n  Cardinal.lift_mk_eq'.2 ⟨.piCongr e fun i ↦ Classical.choice <| Cardinal.lift_mk_eq'.1 (h i)⟩\n\n"}
{"name":"Cardinal.mk_pi_congr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι ι' : Type u\nf : ι → Type v\ng : ι' → Type v\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n⊢ Eq (Cardinal.mk ((i : ι) → f i)) (Cardinal.mk ((i : ι') → g i))","decl":"theorem mk_pi_congr {ι ι' : Type u} {f : ι → Type v} {g : ι' → Type v} (e : ι ≃ ι')\n    (h : ∀ i, #(f i) = #(g (e i))) : #(Π i, f i) = #(Π i, g i) :=\n  mk_congr <| Equiv.piCongr e fun i ↦ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congr_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι ι' : Prop\nf : ι → Type v\ng : ι' → Type v\ne : Iff ι ι'\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g ⋯))\n⊢ Eq (Cardinal.mk ((i : ι) → f i)) (Cardinal.mk ((i : ι') → g i))","decl":"theorem mk_pi_congr_prop {ι ι' : Prop} {f : ι → Type v} {g : ι' → Type v} (e : ι ↔ ι')\n    (h : ∀ i, #(f i) = #(g (e.mp i))) : #(Π i, f i) = #(Π i, g i) :=\n  mk_congr <| Equiv.piCongr (.ofIff e) fun i ↦ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congr'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Type (max w u v)\ng : ι' → Type (max w u v)\ne : Equiv ι ι'\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g (e i)))\n⊢ Eq (Cardinal.mk ((i : ι) → f i)) (Cardinal.mk ((i : ι') → g i))","decl":"/-- Similar to `mk_pi_congr` with indexing types in different universes. This is not a strict\ngeneralization. -/\ntheorem mk_pi_congr' {ι : Type u} {ι' : Type v} {f : ι → Type max w (max u v)}\n    {g : ι' → Type max w (max u v)} (e : ι ≃ ι')\n    (h : ∀ i, #(f i) = #(g (e i))) : #(Π i, f i) = #(Π i, g i) :=\n  mk_congr <| Equiv.piCongr e fun i ↦ Classical.choice <| Cardinal.eq.mp (h i)\n\n"}
{"name":"Cardinal.mk_pi_congrRight","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nf g : ι → Type v\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n⊢ Eq (Cardinal.mk ((i : ι) → f i)) (Cardinal.mk ((i : ι) → g i))","decl":"theorem mk_pi_congrRight {ι : Type u} {f g : ι → Type v} (h : ∀ i, #(f i) = #(g i)) :\n    #(Π i, f i) = #(Π i, g i) :=\n  mk_pi_congr (Equiv.refl ι) h\n\n"}
{"name":"Cardinal.mk_pi_congrRight_prop","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Prop\nf g : ι → Type v\nh : ∀ (i : ι), Eq (Cardinal.mk (f i)) (Cardinal.mk (g i))\n⊢ Eq (Cardinal.mk ((i : ι) → f i)) (Cardinal.mk ((i : ι) → g i))","decl":"theorem mk_pi_congrRight_prop {ι : Prop} {f g : ι → Type v} (h : ∀ i, #(f i) = #(g i)) :\n    #(Π i, f i) = #(Π i, g i) :=\n  mk_pi_congr_prop Iff.rfl h\n\n"}
{"name":"Cardinal.prod_const","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\na : Cardinal.{v}\n⊢ Eq (Cardinal.prod fun x => a) (HPow.hPow (Cardinal.lift.{u, v} a) (Cardinal.lift.{v, u} (Cardinal.mk ι)))","decl":"@[simp]\ntheorem prod_const (ι : Type u) (a : Cardinal.{v}) :\n    (prod fun _ : ι => a) = lift.{u} a ^ lift.{v} #ι :=\n  inductionOn a fun _ =>\n    mk_congr <| Equiv.piCongr Equiv.ulift.symm fun _ => outMkEquiv.trans Equiv.ulift.symm\n\n"}
{"name":"Cardinal.prod_const'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\na : Cardinal.{u}\n⊢ Eq (Cardinal.prod fun x => a) (HPow.hPow a (Cardinal.mk ι))","decl":"theorem prod_const' (ι : Type u) (a : Cardinal.{u}) : (prod fun _ : ι => a) = a ^ #ι :=\n  inductionOn a fun _ => (mk_pi _).symm\n\n"}
{"name":"Cardinal.prod_le_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf g : ι → Cardinal.{u_2}\nH : ∀ (i : ι), LE.le (f i) (g i)\n⊢ LE.le (Cardinal.prod f) (Cardinal.prod g)","decl":"theorem prod_le_prod {ι} (f g : ι → Cardinal) (H : ∀ i, f i ≤ g i) : prod f ≤ prod g :=\n  ⟨Embedding.piCongrRight fun i =>\n      Classical.choice <| by have := H i; rwa [← mk_out (f i), ← mk_out (g i)] at this⟩\n\n"}
{"name":"Cardinal.prod_eq_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{u}\n⊢ Iff (Eq (Cardinal.prod f) 0) (Exists fun i => Eq (f i) 0)","decl":"@[simp]\ntheorem prod_eq_zero {ι} (f : ι → Cardinal.{u}) : prod f = 0 ↔ ∃ i, f i = 0 := by\n  lift f to ι → Type u using fun _ => trivial\n  simp only [mk_eq_zero_iff, ← mk_pi, isEmpty_pi]\n\n"}
{"name":"Cardinal.prod_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{u_2}\n⊢ Iff (Ne (Cardinal.prod f) 0) (∀ (i : ι), Ne (f i) 0)","decl":"theorem prod_ne_zero {ι} (f : ι → Cardinal) : prod f ≠ 0 ↔ ∀ i, f i ≠ 0 := by simp [prod_eq_zero]\n\n"}
{"name":"Cardinal.power_sum","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\na : Cardinal.{max u_1 u_2}\nf : ι → Cardinal.{max u_1 u_2}\n⊢ Eq (HPow.hPow a (Cardinal.sum f)) (Cardinal.prod fun i => HPow.hPow a (f i))","decl":"theorem power_sum {ι} (a : Cardinal) (f : ι → Cardinal) :\n    a ^ sum f = prod fun i ↦ a ^ f i := by\n  induction a using Cardinal.inductionOn with | _ α =>\n  induction f using induction_on_pi with | _ f =>\n  simp_rw [prod, sum, power_def]\n  apply mk_congr\n  refine (Equiv.piCurry fun _ _ => α).trans ?_\n  refine Equiv.piCongrRight fun b => ?_\n  refine (Equiv.arrowCongr outMkEquiv (Equiv.refl α)).trans ?_\n  exact outMkEquiv.symm\n\n"}
{"name":"Cardinal.lift_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\nc : ι → Cardinal.{v}\n⊢ Eq (Cardinal.lift.{w, max v u} (Cardinal.prod c)) (Cardinal.prod fun i => Cardinal.lift.{w, v} (c i))","decl":"@[simp]\ntheorem lift_prod {ι : Type u} (c : ι → Cardinal.{v}) :\n    lift.{w} (prod c) = prod fun i => lift.{w} (c i) := by\n  lift c to ι → Type v using fun _ => trivial\n  simp only [← mk_pi, ← mk_uLift]\n  exact mk_congr (Equiv.ulift.trans <| Equiv.piCongrRight fun i => Equiv.ulift.symm)\n\n"}
{"name":"Cardinal.prod_eq_of_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nh : Fintype α\nf : α → Cardinal.{v}\n⊢ Eq (Cardinal.prod f) (Cardinal.lift.{u, v} (Finset.univ.prod fun i => f i))","decl":"theorem prod_eq_of_fintype {α : Type u} [h : Fintype α] (f : α → Cardinal.{v}) :\n    prod f = Cardinal.lift.{u} (∏ i, f i) := by\n  revert f\n  refine Fintype.induction_empty_option ?_ ?_ ?_ α (h_fintype := h)\n  · intro α β hβ e h f\n    letI := Fintype.ofEquiv β e.symm\n    rw [← e.prod_comp f, ← h]\n    exact mk_congr (e.piCongrLeft _).symm\n  · intro f\n    rw [Fintype.univ_pempty, Finset.prod_empty, lift_one, Cardinal.prod, mk_eq_one]\n  · intro α hα h f\n    rw [Cardinal.prod, mk_congr Equiv.piOptionEquivProd, mk_prod, lift_umax.{v, u}, mk_out, ←\n        Cardinal.prod, lift_prod, Fintype.prod_option, lift_mul, ← h fun a => f (some a)]\n    simp only [lift_id]\n\n"}
{"name":"Cardinal.sum_lt_prod","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u_1\nf g : ι → Cardinal.{u_2}\nH : ∀ (i : ι), LT.lt (f i) (g i)\n⊢ LT.lt (Cardinal.sum f) (Cardinal.prod g)","decl":"/-- **König's theorem** -/\ntheorem sum_lt_prod {ι} (f g : ι → Cardinal) (H : ∀ i, f i < g i) : sum f < prod g :=\n  lt_of_not_ge fun ⟨F⟩ => by\n    have : Inhabited (∀ i : ι, (g i).out) := by\n      refine ⟨fun i => Classical.choice <| mk_ne_zero_iff.1 ?_⟩\n      rw [mk_out]\n      exact (H i).ne_bot\n    let G := invFun F\n    have sG : Surjective G := invFun_surjective F.2\n    choose C hc using\n      show ∀ i, ∃ b, ∀ a, G ⟨i, a⟩ i ≠ b by\n        intro i\n        simp only [not_exists.symm, not_forall.symm]\n        refine fun h => (H i).not_le ?_\n        rw [← mk_out (f i), ← mk_out (g i)]\n        exact ⟨Embedding.ofSurjective _ h⟩\n    let ⟨⟨i, a⟩, h⟩ := sG C\n    exact hc i a (congr_fun h _)\n\n"}
{"name":"Cardinal.mk_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Nat) Cardinal.aleph0","decl":"theorem mk_nat : #ℕ = ℵ₀ :=\n  (lift_id _).symm\n\n"}
{"name":"Cardinal.aleph0_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Ne Cardinal.aleph0 0","decl":"theorem aleph0_ne_zero : ℵ₀ ≠ 0 :=\n  mk_ne_zero _\n\n"}
{"name":"Cardinal.aleph0_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ LT.lt 0 Cardinal.aleph0","decl":"theorem aleph0_pos : 0 < ℵ₀ :=\n  pos_iff_ne_zero.2 aleph0_ne_zero\n\n"}
{"name":"Cardinal.lift_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.lift.{u_1, u_2} Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem lift_aleph0 : lift ℵ₀ = ℵ₀ :=\n  lift_lift _\n\n"}
{"name":"Cardinal.aleph0_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LE.le Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (LE.le Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_le_lift {c : Cardinal.{u}} : ℵ₀ ≤ lift.{v} c ↔ ℵ₀ ≤ c := by\n  simpa using lift_le (a := ℵ₀)\n\n"}
{"name":"Cardinal.lift_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LE.le (Cardinal.lift.{v, u} c) Cardinal.aleph0) (LE.le c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ := by\n  simpa using lift_le (b := ℵ₀)\n\n"}
{"name":"Cardinal.aleph0_lt_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LT.lt Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (LT.lt Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_lt_lift {c : Cardinal.{u}} : ℵ₀ < lift.{v} c ↔ ℵ₀ < c := by\n  simpa using lift_lt (a := ℵ₀)\n\n"}
{"name":"Cardinal.lift_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LT.lt (Cardinal.lift.{v, u} c) Cardinal.aleph0) (LT.lt c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_lt_aleph0 {c : Cardinal.{u}} : lift.{v} c < ℵ₀ ↔ c < ℵ₀ := by\n  simpa using lift_lt (b := ℵ₀)\n\n"}
{"name":"Cardinal.aleph0_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq Cardinal.aleph0 (Cardinal.lift.{v, u} c)) (Eq Cardinal.aleph0 c)","decl":"@[simp]\ntheorem aleph0_eq_lift {c : Cardinal.{u}} : ℵ₀ = lift.{v} c ↔ ℵ₀ = c := by\n  simpa using lift_inj (a := ℵ₀)\n\n"}
{"name":"Cardinal.lift_eq_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.lift.{v, u} c) Cardinal.aleph0) (Eq c Cardinal.aleph0)","decl":"@[simp]\ntheorem lift_eq_aleph0 {c : Cardinal.{u}} : lift.{v} c = ℵ₀ ↔ c = ℵ₀ := by\n  simpa using lift_inj (b := ℵ₀)\n\n"}
{"name":"Cardinal.mk_fin","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (Cardinal.mk (Fin n)) ↑n","decl":"theorem mk_fin (n : ℕ) : #(Fin n) = n := by simp\n\n"}
{"name":"Cardinal.lift_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (Cardinal.lift.{u, v} ↑n) ↑n","decl":"@[simp]\ntheorem lift_natCast (n : ℕ) : lift.{u} (n : Cardinal.{v}) = n := by induction n <;> simp [*]\n\n"}
{"name":"Cardinal.lift_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Cardinal.lift.{u, v} (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem lift_ofNat (n : ℕ) [n.AtLeastTwo] :\n    lift.{u} (ofNat(n) : Cardinal.{v}) = OfNat.ofNat n :=\n  lift_natCast n\n\n"}
{"name":"Cardinal.lift_eq_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n⊢ Iff (Eq (Cardinal.lift.{v, u} a) ↑n) (Eq a ↑n)","decl":"@[simp]\ntheorem lift_eq_nat_iff {a : Cardinal.{u}} {n : ℕ} : lift.{v} a = n ↔ a = n :=\n  lift_injective.eq_iff' (lift_natCast n)\n\n"}
{"name":"Cardinal.lift_eq_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (Eq a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_eq_ofNat_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    lift.{v} a = ofNat(n) ↔ a = OfNat.ofNat n :=\n  lift_eq_nat_iff\n\n"}
{"name":"Cardinal.nat_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n⊢ Iff (Eq (↑n) (Cardinal.lift.{v, u} a)) (Eq (↑n) a)","decl":"@[simp]\ntheorem nat_eq_lift_iff {n : ℕ} {a : Cardinal.{u}} :\n    (n : Cardinal) = lift.{v} a ↔ (n : Cardinal) = a := by\n  rw [← lift_natCast.{v,u} n, lift_inj]\n\n"}
{"name":"Cardinal.zero_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (Eq 0 (Cardinal.lift.{v, u} a)) (Eq 0 a)","decl":"@[simp]\ntheorem zero_eq_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) = lift.{v} a ↔ 0 = a := by\n  simpa using nat_eq_lift_iff (n := 0)\n\n"}
{"name":"Cardinal.one_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (Eq 1 (Cardinal.lift.{v, u} a)) (Eq 1 a)","decl":"@[simp]\ntheorem one_eq_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) = lift.{v} a ↔ 1 = a := by\n  simpa using nat_eq_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_eq_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (Eq (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_eq_lift_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) = lift.{v} a ↔ (OfNat.ofNat n : Cardinal) = a :=\n  nat_eq_lift_iff\n\n"}
{"name":"Cardinal.lift_le_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n⊢ Iff (LE.le (Cardinal.lift.{v, u} a) ↑n) (LE.le a ↑n)","decl":"@[simp]\ntheorem lift_le_nat_iff {a : Cardinal.{u}} {n : ℕ} : lift.{v} a ≤ n ↔ a ≤ n := by\n  rw [← lift_natCast.{v,u}, lift_le]\n\n"}
{"name":"Cardinal.lift_le_one_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (LE.le (Cardinal.lift.{v, u} a) 1) (LE.le a 1)","decl":"@[simp]\ntheorem lift_le_one_iff {a : Cardinal.{u}} :\n    lift.{v} a ≤ 1 ↔ a ≤ 1 := by\n  simpa using lift_le_nat_iff (n := 1)\n\n"}
{"name":"Cardinal.lift_le_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (LE.le a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_le_ofNat_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    lift.{v} a ≤ ofNat(n) ↔ a ≤ OfNat.ofNat n :=\n  lift_le_nat_iff\n\n"}
{"name":"Cardinal.nat_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n⊢ Iff (LE.le (↑n) (Cardinal.lift.{v, u} a)) (LE.le (↑n) a)","decl":"@[simp]\ntheorem nat_le_lift_iff {n : ℕ} {a : Cardinal.{u}} : n ≤ lift.{v} a ↔ n ≤ a := by\n  rw [← lift_natCast.{v,u}, lift_le]\n\n"}
{"name":"Cardinal.one_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (LE.le 1 (Cardinal.lift.{v, u} a)) (LE.le 1 a)","decl":"@[simp]\ntheorem one_le_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) ≤ lift.{v} a ↔ 1 ≤ a := by\n  simpa using nat_le_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_le_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (LE.le (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_le_lift_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) ≤ lift.{v} a ↔ (OfNat.ofNat n : Cardinal) ≤ a :=\n  nat_le_lift_iff\n\n"}
{"name":"Cardinal.lift_lt_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\n⊢ Iff (LT.lt (Cardinal.lift.{v, u} a) ↑n) (LT.lt a ↑n)","decl":"@[simp]\ntheorem lift_lt_nat_iff {a : Cardinal.{u}} {n : ℕ} : lift.{v} a < n ↔ a < n := by\n  rw [← lift_natCast.{v,u}, lift_lt]\n\n"}
{"name":"Cardinal.lift_lt_ofNat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (Cardinal.lift.{v, u} a) (OfNat.ofNat n)) (LT.lt a (OfNat.ofNat n))","decl":"@[simp]\ntheorem lift_lt_ofNat_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    lift.{v} a < ofNat(n) ↔ a < OfNat.ofNat n :=\n  lift_lt_nat_iff\n\n"}
{"name":"Cardinal.nat_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u}\n⊢ Iff (LT.lt (↑n) (Cardinal.lift.{v, u} a)) (LT.lt (↑n) a)","decl":"@[simp]\ntheorem nat_lt_lift_iff {n : ℕ} {a : Cardinal.{u}} : n < lift.{v} a ↔ n < a := by\n  rw [← lift_natCast.{v,u}, lift_lt]\n\n"}
{"name":"Cardinal.zero_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (LT.lt 0 (Cardinal.lift.{v, u} a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem zero_lt_lift_iff {a : Cardinal.{u}} :\n    (0 : Cardinal) < lift.{v} a ↔ 0 < a := by\n  simpa using nat_lt_lift_iff (n := 0)\n\n"}
{"name":"Cardinal.one_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\n⊢ Iff (LT.lt 1 (Cardinal.lift.{v, u} a)) (LT.lt 1 a)","decl":"@[simp]\ntheorem one_lt_lift_iff {a : Cardinal.{u}} :\n    (1 : Cardinal) < lift.{v} a ↔ 1 < a := by\n  simpa using nat_lt_lift_iff (n := 1)\n\n"}
{"name":"Cardinal.ofNat_lt_lift_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (OfNat.ofNat n) (Cardinal.lift.{v, u} a)) (LT.lt (OfNat.ofNat n) a)","decl":"@[simp]\ntheorem ofNat_lt_lift_iff {a : Cardinal.{u}} {n : ℕ} [n.AtLeastTwo] :\n    (ofNat(n) : Cardinal) < lift.{v} a ↔ (OfNat.ofNat n : Cardinal) < a :=\n  nat_lt_lift_iff\n\n"}
{"name":"Cardinal.lift_mk_fin","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (Cardinal.lift.{u_1, 0} (Cardinal.mk (Fin n))) ↑n","decl":"theorem lift_mk_fin (n : ℕ) : lift #(Fin n) = n := rfl\n\n"}
{"name":"Cardinal.mk_coe_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ Eq (Cardinal.mk (Subtype fun x => Membership.mem s x)) ↑s.card","decl":"theorem mk_coe_finset {α : Type u} {s : Finset α} : #s = ↑(Finset.card s) := by simp\n\n"}
{"name":"Cardinal.mk_finset_of_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Fintype α\n⊢ Eq (Cardinal.mk (Finset α)) (HPow.hPow 2 (Fintype.card α))","decl":"theorem mk_finset_of_fintype [Fintype α] : #(Finset α) = 2 ^ Fintype.card α := by\n  simp [Pow.pow]\n\n"}
{"name":"Cardinal.card_le_of_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ LE.le (↑s.card) (Cardinal.mk α)","decl":"theorem card_le_of_finset {α} (s : Finset α) : (s.card : Cardinal) ≤ #α :=\n  @mk_coe_finset _ s ▸ mk_set_le _\n\n"}
{"name":"Cardinal.instCharZero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ CharZero Cardinal.{u_1}","decl":"instance : CharZero Cardinal := by\n  refine ⟨fun a b h ↦ ?_⟩\n  rwa [← lift_mk_fin, ← lift_mk_fin, lift_inj, Cardinal.eq, ← Fintype.card_eq,\n    Fintype.card_fin, Fintype.card_fin] at h\n\n"}
{"name":"Cardinal.natCast_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[deprecated Nat.cast_le (since := \"2024-10-16\")]\ntheorem natCast_le {m n : ℕ} : (m : Cardinal) ≤ n ↔ m ≤ n := Nat.cast_le\n\n"}
{"name":"Cardinal.natCast_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[deprecated Nat.cast_lt (since := \"2024-10-16\")]\ntheorem natCast_lt {m n : ℕ} : (m : Cardinal) < n ↔ m < n := Nat.cast_lt\n\n"}
{"name":"Cardinal.natCast_inj","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[deprecated Nat.cast_inj (since := \"2024-10-16\")]\ntheorem natCast_inj {m n : ℕ} : (m : Cardinal) = n ↔ m = n := Nat.cast_inj\n\n"}
{"name":"Cardinal.natCast_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Function.Injective Nat.cast","decl":"@[deprecated Nat.cast_injective (since := \"2024-10-16\")]\ntheorem natCast_injective : Injective ((↑) : ℕ → Cardinal) := Nat.cast_injective\n\n"}
{"name":"Cardinal.natCast_pow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"m n : Nat\n⊢ Eq (↑(HPow.hPow m n)) (HPow.hPow ↑m ↑n)","decl":"@[deprecated Nat.cast_pow (since := \"2024-10-16\")]\ntheorem natCast_pow {m n : ℕ} : (↑(m ^ n) : Cardinal) = (↑m : Cardinal) ^ (↑n : Cardinal) :=\n  Nat.cast_pow m n\n\n"}
{"name":"Cardinal.nat_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n.succ) (Order.succ ↑n)","decl":"@[norm_cast]\ntheorem nat_succ (n : ℕ) : (n.succ : Cardinal) = succ ↑n := by\n  rw [Nat.cast_succ]\n  refine (add_one_le_succ _).antisymm (succ_le_of_lt ?_)\n  rw [← Nat.cast_succ]\n  exact Nat.cast_lt.2 (Nat.lt_succ_self _)\n\n"}
{"name":"Cardinal.succ_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (Order.succ ↑n) (HAdd.hAdd (↑n) 1)","decl":"lemma succ_natCast (n : ℕ) : Order.succ (n : Cardinal) = n + 1 := by\n  rw [← Cardinal.nat_succ]\n  norm_cast\n\n"}
{"name":"Cardinal.natCast_add_one_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nc : Cardinal.{u_1}\n⊢ Iff (LE.le (HAdd.hAdd (↑n) 1) c) (LT.lt (↑n) c)","decl":"lemma natCast_add_one_le_iff {n : ℕ} {c : Cardinal} : n + 1 ≤ c ↔ n < c := by\n  rw [← Order.succ_le_iff, Cardinal.succ_natCast]\n\n"}
{"name":"Cardinal.two_le_iff_one_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LE.le 2 c) (LT.lt 1 c)","decl":"lemma two_le_iff_one_lt {c : Cardinal} : 2 ≤ c ↔ 1 < c := by\n  convert natCast_add_one_le_iff\n  norm_cast\n\n"}
{"name":"Cardinal.succ_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Order.succ 0) 1","decl":"@[simp]\ntheorem succ_zero : succ (0 : Cardinal) = 1 := by norm_cast\n\n-- This works generally to prove inequalities between numeric cardinals.\n"}
{"name":"Cardinal.one_lt_two","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ LT.lt 1 2","decl":"theorem one_lt_two : (1 : Cardinal) < 2 := by norm_cast\n\n"}
{"name":"Cardinal.exists_finset_le_card","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\nn : Nat\nh : LE.le (↑n) (Cardinal.mk α)\n⊢ Exists fun s => LE.le n s.card","decl":"theorem exists_finset_le_card (α : Type*) (n : ℕ) (h : n ≤ #α) :\n    ∃ s : Finset α, n ≤ s.card := by\n  obtain hα|hα := finite_or_infinite α\n  · let hα := Fintype.ofFinite α\n    use Finset.univ\n    simpa only [mk_fintype, Nat.cast_le] using h\n  · obtain ⟨s, hs⟩ := Infinite.exists_subset_card_eq α n\n    exact ⟨s, hs.ge⟩\n\n"}
{"name":"Cardinal.card_le_of","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\nH : ∀ (s : Finset α), LE.le s.card n\n⊢ LE.le (Cardinal.mk α) ↑n","decl":"theorem card_le_of {α : Type u} {n : ℕ} (H : ∀ s : Finset α, s.card ≤ n) : #α ≤ n := by\n  contrapose! H\n  apply exists_finset_le_card α (n+1)\n  simpa only [nat_succ, succ_le_iff] using H\n\n"}
{"name":"Cardinal.cantor'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nhb : LT.lt 1 b\n⊢ LT.lt a (HPow.hPow b a)","decl":"theorem cantor' (a) {b : Cardinal} (hb : 1 < b) : a < b ^ a := by\n  rw [← succ_le_iff, (by norm_cast : succ (1 : Cardinal) = 2)] at hb\n  exact (cantor a).trans_le (power_le_power_right hb)\n\n"}
{"name":"Cardinal.one_le_iff_pos","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LE.le 1 c) (LT.lt 0 c)","decl":"theorem one_le_iff_pos {c : Cardinal} : 1 ≤ c ↔ 0 < c := by\n  rw [← succ_zero, succ_le_iff]\n\n"}
{"name":"Cardinal.one_le_iff_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LE.le 1 c) (Ne c 0)","decl":"theorem one_le_iff_ne_zero {c : Cardinal} : 1 ≤ c ↔ c ≠ 0 := by\n  rw [one_le_iff_pos, pos_iff_ne_zero]\n\n"}
{"name":"Cardinal.lt_one_iff_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LT.lt c 1) (Eq c 0)","decl":"@[simp]\ntheorem lt_one_iff_zero {c : Cardinal} : c < 1 ↔ c = 0 := by\n  simpa using lt_succ_bot_iff (a := c)\n\n"}
{"name":"Cardinal.nat_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ LT.lt (↑n) Cardinal.aleph0","decl":"theorem nat_lt_aleph0 (n : ℕ) : (n : Cardinal.{u}) < ℵ₀ :=\n  succ_le_iff.1\n    (by\n      rw [← nat_succ, ← lift_mk_fin, aleph0, lift_mk_le.{u}]\n      exact ⟨⟨(↑), fun a b => Fin.ext⟩⟩)\n\n"}
{"name":"Cardinal.one_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ LT.lt 1 Cardinal.aleph0","decl":"@[simp]\ntheorem one_lt_aleph0 : 1 < ℵ₀ := by simpa using nat_lt_aleph0 1\n\n"}
{"name":"Cardinal.one_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ LE.le 1 Cardinal.aleph0","decl":"@[simp]\ntheorem one_le_aleph0 : 1 ≤ ℵ₀ :=\n  one_lt_aleph0.le\n\n"}
{"name":"Cardinal.lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LT.lt c Cardinal.aleph0) (Exists fun n => Eq c ↑n)","decl":"theorem lt_aleph0 {c : Cardinal} : c < ℵ₀ ↔ ∃ n : ℕ, c = n :=\n  ⟨fun h => by\n    rcases lt_lift_iff.1 h with ⟨c, h', rfl⟩\n    rcases le_mk_iff_exists_set.1 h'.1 with ⟨S, rfl⟩\n    suffices S.Finite by\n      lift S to Finset ℕ using this\n      simp\n    contrapose! h'\n    haveI := Infinite.to_subtype h'\n    exact ⟨Infinite.natEmbedding S⟩, fun ⟨_, e⟩ => e.symm ▸ nat_lt_aleph0 _⟩\n\n"}
{"name":"Cardinal.succ_eq_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : LT.lt c Cardinal.aleph0\n⊢ Eq (Order.succ c) (HAdd.hAdd c 1)","decl":"lemma succ_eq_of_lt_aleph0 {c : Cardinal} (h : c < ℵ₀) : Order.succ c = c + 1 := by\n  obtain ⟨n, hn⟩ := Cardinal.lt_aleph0.mp h\n  rw [hn, succ_natCast]\n\n"}
{"name":"Cardinal.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 c) (∀ (n : Nat), LE.le (↑n) c)","decl":"theorem aleph0_le {c : Cardinal} : ℵ₀ ≤ c ↔ ∀ n : ℕ, ↑n ≤ c :=\n  ⟨fun h _ => (nat_lt_aleph0 _).le.trans h, fun h =>\n    le_of_not_lt fun hn => by\n      rcases lt_aleph0.1 hn with ⟨n, rfl⟩\n      exact (Nat.lt_succ_self _).not_le (Nat.cast_le.1 (h (n + 1)))⟩\n\n"}
{"name":"Cardinal.isSuccPrelimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Order.IsSuccPrelimit Cardinal.aleph0","decl":"theorem isSuccPrelimit_aleph0 : IsSuccPrelimit ℵ₀ :=\n  isSuccPrelimit_of_succ_lt fun a ha => by\n    rcases lt_aleph0.1 ha with ⟨n, rfl⟩\n    rw [← nat_succ]\n    apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.isSuccLimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Order.IsSuccLimit Cardinal.aleph0","decl":"theorem isSuccLimit_aleph0 : IsSuccLimit ℵ₀ := by\n  rw [Cardinal.isSuccLimit_iff]\n  exact ⟨aleph0_ne_zero, isSuccPrelimit_aleph0⟩\n\n"}
{"name":"Cardinal.not_isSuccLimit_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Not (Order.IsSuccLimit ↑n)","decl":"lemma not_isSuccLimit_natCast : (n : ℕ) → ¬ IsSuccLimit (n : Cardinal.{u})\n  | 0, e => e.1 isMin_bot\n  | Nat.succ n, e => Order.not_isSuccPrelimit_succ _ (nat_succ n ▸ e.2)\n\n"}
{"name":"Cardinal.not_isSuccLimit_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : LT.lt c Cardinal.aleph0\n⊢ Not (Order.IsSuccLimit c)","decl":"theorem not_isSuccLimit_of_lt_aleph0 {c : Cardinal} (h : c < ℵ₀) : ¬ IsSuccLimit c := by\n  obtain ⟨n, rfl⟩ := lt_aleph0.1 h\n  exact not_isSuccLimit_natCast n\n\n"}
{"name":"Cardinal.aleph0_le_of_isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : Order.IsSuccLimit c\n⊢ LE.le Cardinal.aleph0 c","decl":"theorem aleph0_le_of_isSuccLimit {c : Cardinal} (h : IsSuccLimit c) : ℵ₀ ≤ c := by\n  contrapose! h\n  exact not_isSuccLimit_of_lt_aleph0 h\n\n"}
{"name":"Cardinal.isLimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Cardinal.aleph0.IsLimit","decl":"set_option linter.deprecated false in\n@[deprecated isSuccLimit_aleph0 (since := \"2024-09-17\")]\ntheorem isLimit_aleph0 : IsLimit ℵ₀ :=\n  ⟨aleph0_ne_zero, isSuccPrelimit_aleph0⟩\n\n"}
{"name":"Cardinal.not_isLimit_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Not (↑n).IsLimit","decl":"set_option linter.deprecated false in\n@[deprecated not_isSuccLimit_natCast (since := \"2024-09-17\")]\nlemma not_isLimit_natCast : (n : ℕ) → ¬ IsLimit (n : Cardinal.{u})\n  | 0, e => e.1 rfl\n  | Nat.succ n, e => Order.not_isSuccPrelimit_succ _ (nat_succ n ▸ e.2)\n\n"}
{"name":"Cardinal.IsLimit.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nh : c.IsLimit\n⊢ LE.le Cardinal.aleph0 c","decl":"set_option linter.deprecated false in\n@[deprecated aleph0_le_of_isSuccLimit (since := \"2024-09-17\")]\ntheorem IsLimit.aleph0_le {c : Cardinal} (h : IsLimit c) : ℵ₀ ≤ c := by\n  by_contra! h'\n  rcases lt_aleph0.1 h' with ⟨n, rfl⟩\n  exact not_isLimit_natCast n h\n\n"}
{"name":"Cardinal.exists_eq_natCast_of_iSup_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι : Type u\ninst✝ : Nonempty ι\nf : ι → Cardinal.{v}\nhf : BddAbove (Set.range f)\nn : Nat\nh : Eq (iSup fun i => f i) ↑n\n⊢ Exists fun i => Eq (f i) ↑n","decl":"lemma exists_eq_natCast_of_iSup_eq {ι : Type u} [Nonempty ι] (f : ι → Cardinal.{v})\n    (hf : BddAbove (range f)) (n : ℕ) (h : ⨆ i, f i = n) : ∃ i, f i = n :=\n  exists_eq_of_iSup_eq_of_not_isSuccLimit.{u, v} f hf (not_isSuccLimit_natCast n) h\n\n"}
{"name":"Cardinal.range_natCast","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Set.range Nat.cast) (Set.Iio Cardinal.aleph0)","decl":"@[simp]\ntheorem range_natCast : range ((↑) : ℕ → Cardinal) = Iio ℵ₀ :=\n  ext fun x => by simp only [mem_Iio, mem_range, eq_comm, lt_aleph0]\n\n"}
{"name":"Cardinal.mk_eq_nat_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\n⊢ Iff (Eq (Cardinal.mk α) ↑n) (Nonempty (Equiv α (Fin n)))","decl":"theorem mk_eq_nat_iff {α : Type u} {n : ℕ} : #α = n ↔ Nonempty (α ≃ Fin n) := by\n  rw [← lift_mk_fin, ← lift_uzero #α, lift_mk_eq']\n\n"}
{"name":"Cardinal.lt_aleph0_iff_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LT.lt (Cardinal.mk α) Cardinal.aleph0) (Finite α)","decl":"theorem lt_aleph0_iff_finite {α : Type u} : #α < ℵ₀ ↔ Finite α := by\n  simp only [lt_aleph0, mk_eq_nat_iff, finite_iff_exists_equiv_fin]\n\n"}
{"name":"Cardinal.lt_aleph0_iff_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LT.lt (Cardinal.mk α) Cardinal.aleph0) (Nonempty (Fintype α))","decl":"theorem lt_aleph0_iff_fintype {α : Type u} : #α < ℵ₀ ↔ Nonempty (Fintype α) :=\n  lt_aleph0_iff_finite.trans (finite_iff_nonempty_fintype _)\n\n"}
{"name":"Cardinal.lt_aleph0_of_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Finite α\n⊢ LT.lt (Cardinal.mk α) Cardinal.aleph0","decl":"theorem lt_aleph0_of_finite (α : Type u) [Finite α] : #α < ℵ₀ :=\n  lt_aleph0_iff_finite.2 ‹_›\n\n"}
{"name":"Cardinal.lt_aleph0_iff_set_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS : Set α\n⊢ Iff (LT.lt (Cardinal.mk ↑S) Cardinal.aleph0) S.Finite","decl":"theorem lt_aleph0_iff_set_finite {S : Set α} : #S < ℵ₀ ↔ S.Finite :=\n  lt_aleph0_iff_finite.trans finite_coe_iff\n\n"}
{"name":"Set.Finite.lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS : Set α\na✝ : S.Finite\n⊢ LT.lt (Cardinal.mk ↑S) Cardinal.aleph0","decl":"alias ⟨_, _root_.Set.Finite.lt_aleph0⟩ := lt_aleph0_iff_set_finite\n\n"}
{"name":"Cardinal.lt_aleph0_iff_subtype_finite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Iff (LT.lt (Cardinal.mk (Subtype fun x => p x)) Cardinal.aleph0) (setOf fun x => p x).Finite","decl":"@[simp]\ntheorem lt_aleph0_iff_subtype_finite {p : α → Prop} : #{ x // p x } < ℵ₀ ↔ { x | p x }.Finite :=\n  lt_aleph0_iff_set_finite\n\n"}
{"name":"Cardinal.mk_le_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LE.le (Cardinal.mk α) Cardinal.aleph0) (Countable α)","decl":"theorem mk_le_aleph0_iff : #α ≤ ℵ₀ ↔ Countable α := by\n  rw [countable_iff_nonempty_embedding, aleph0, ← lift_uzero #α, lift_mk_le']\n\n"}
{"name":"Cardinal.mk_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ LE.le (Cardinal.mk α) Cardinal.aleph0","decl":"@[simp]\ntheorem mk_le_aleph0 [Countable α] : #α ≤ ℵ₀ :=\n  mk_le_aleph0_iff.mpr ‹_›\n\n"}
{"name":"Cardinal.le_aleph0_iff_set_countable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (LE.le (Cardinal.mk ↑s) Cardinal.aleph0) s.Countable","decl":"theorem le_aleph0_iff_set_countable {s : Set α} : #s ≤ ℵ₀ ↔ s.Countable := mk_le_aleph0_iff\n\n"}
{"name":"Set.Countable.le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Countable\n⊢ LE.le (Cardinal.mk ↑s) Cardinal.aleph0","decl":"alias ⟨_, _root_.Set.Countable.le_aleph0⟩ := le_aleph0_iff_set_countable\n\n"}
{"name":"Cardinal.le_aleph0_iff_subtype_countable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Iff (LE.le (Cardinal.mk (Subtype fun x => p x)) Cardinal.aleph0) (setOf fun x => p x).Countable","decl":"@[simp]\ntheorem le_aleph0_iff_subtype_countable {p : α → Prop} :\n    #{ x // p x } ≤ ℵ₀ ↔ { x | p x }.Countable :=\n  le_aleph0_iff_set_countable\n\n"}
{"name":"Cardinal.aleph0_lt_mk_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LT.lt Cardinal.aleph0 (Cardinal.mk α)) (Uncountable α)","decl":"theorem aleph0_lt_mk_iff : ℵ₀ < #α ↔ Uncountable α := by\n  rw [← not_le, ← not_countable_iff, not_iff_not, mk_le_aleph0_iff]\n\n"}
{"name":"Cardinal.aleph0_lt_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Uncountable α\n⊢ LT.lt Cardinal.aleph0 (Cardinal.mk α)","decl":"@[simp]\ntheorem aleph0_lt_mk [Uncountable α] : ℵ₀ < #α :=\n  aleph0_lt_mk_iff.mpr ‹_›\n\n"}
{"name":"Cardinal.canLiftCardinalNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ CanLift Cardinal.{u_1} Nat Nat.cast fun x => LT.lt x Cardinal.aleph0","decl":"instance canLiftCardinalNat : CanLift Cardinal ℕ (↑) fun x => x < ℵ₀ :=\n  ⟨fun _ hx =>\n    let ⟨n, hn⟩ := lt_aleph0.mp hx\n    ⟨n, hn.symm⟩⟩\n\n"}
{"name":"Cardinal.add_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n⊢ LT.lt (HAdd.hAdd a b) Cardinal.aleph0","decl":"theorem add_lt_aleph0 {a b : Cardinal} (ha : a < ℵ₀) (hb : b < ℵ₀) : a + b < ℵ₀ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [← Nat.cast_add]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.add_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (LT.lt (HAdd.hAdd a b) Cardinal.aleph0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))","decl":"theorem add_lt_aleph0_iff {a b : Cardinal} : a + b < ℵ₀ ↔ a < ℵ₀ ∧ b < ℵ₀ :=\n  ⟨fun h => ⟨(self_le_add_right _ _).trans_lt h, (self_le_add_left _ _).trans_lt h⟩,\n   fun ⟨h1, h2⟩ => add_lt_aleph0 h1 h2⟩\n\n"}
{"name":"Cardinal.aleph0_le_add_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 (HAdd.hAdd a b)) (Or (LE.le Cardinal.aleph0 a) (LE.le Cardinal.aleph0 b))","decl":"theorem aleph0_le_add_iff {a b : Cardinal} : ℵ₀ ≤ a + b ↔ ℵ₀ ≤ a ∨ ℵ₀ ≤ b := by\n  simp only [← not_lt, add_lt_aleph0_iff, not_and_or]\n\n"}
{"name":"Cardinal.nsmul_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u_1}\n⊢ Iff (LT.lt (HSMul.hSMul n a) Cardinal.aleph0) (Or (Eq n 0) (LT.lt a Cardinal.aleph0))","decl":"/-- See also `Cardinal.nsmul_lt_aleph0_iff_of_ne_zero` if you already have `n ≠ 0`. -/\ntheorem nsmul_lt_aleph0_iff {n : ℕ} {a : Cardinal} : n • a < ℵ₀ ↔ n = 0 ∨ a < ℵ₀ := by\n  cases n with\n  | zero => simpa using nat_lt_aleph0 0\n  | succ n =>\n      simp only [Nat.succ_ne_zero, false_or]\n      induction' n with n ih\n      · simp\n      rw [succ_nsmul, add_lt_aleph0_iff, ih, and_self_iff]\n\n"}
{"name":"Cardinal.nsmul_lt_aleph0_iff_of_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\na : Cardinal.{u_1}\nh : Ne n 0\n⊢ Iff (LT.lt (HSMul.hSMul n a) Cardinal.aleph0) (LT.lt a Cardinal.aleph0)","decl":"/-- See also `Cardinal.nsmul_lt_aleph0_iff` for a hypothesis-free version. -/\ntheorem nsmul_lt_aleph0_iff_of_ne_zero {n : ℕ} {a : Cardinal} (h : n ≠ 0) : n • a < ℵ₀ ↔ a < ℵ₀ :=\n  nsmul_lt_aleph0_iff.trans <| or_iff_right h\n\n"}
{"name":"Cardinal.mul_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n⊢ LT.lt (HMul.hMul a b) Cardinal.aleph0","decl":"theorem mul_lt_aleph0 {a b : Cardinal} (ha : a < ℵ₀) (hb : b < ℵ₀) : a * b < ℵ₀ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [← Nat.cast_mul]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.mul_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (LT.lt (HMul.hMul a b) Cardinal.aleph0) (Or (Eq a 0) (Or (Eq b 0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))))","decl":"theorem mul_lt_aleph0_iff {a b : Cardinal} : a * b < ℵ₀ ↔ a = 0 ∨ b = 0 ∨ a < ℵ₀ ∧ b < ℵ₀ := by\n  refine ⟨fun h => ?_, ?_⟩\n  · by_cases ha : a = 0\n    · exact Or.inl ha\n    right\n    by_cases hb : b = 0\n    · exact Or.inl hb\n    right\n    rw [← Ne, ← one_le_iff_ne_zero] at ha hb\n    constructor\n    · rw [← mul_one a]\n      exact (mul_le_mul' le_rfl hb).trans_lt h\n    · rw [← one_mul b]\n      exact (mul_le_mul' ha le_rfl).trans_lt h\n  rintro (rfl | rfl | ⟨ha, hb⟩) <;> simp only [*, mul_lt_aleph0, aleph0_pos, zero_mul, mul_zero]\n\n"}
{"name":"Cardinal.aleph0_le_mul_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 (HMul.hMul a b)) (And (Ne a 0) (And (Ne b 0) (Or (LE.le Cardinal.aleph0 a) (LE.le Cardinal.aleph0 b))))","decl":"/-- See also `Cardinal.aleph0_le_mul_iff`. -/\ntheorem aleph0_le_mul_iff {a b : Cardinal} : ℵ₀ ≤ a * b ↔ a ≠ 0 ∧ b ≠ 0 ∧ (ℵ₀ ≤ a ∨ ℵ₀ ≤ b) := by\n  let h := (@mul_lt_aleph0_iff a b).not\n  rwa [not_lt, not_or, not_or, not_and_or, not_lt, not_lt] at h\n\n"}
{"name":"Cardinal.aleph0_le_mul_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u}\n⊢ Iff (LE.le Cardinal.aleph0 (HMul.hMul a b)) (Or (And (Ne a 0) (LE.le Cardinal.aleph0 b)) (And (LE.le Cardinal.aleph0 a) (Ne b 0)))","decl":"/-- See also `Cardinal.aleph0_le_mul_iff'`. -/\ntheorem aleph0_le_mul_iff' {a b : Cardinal.{u}} : ℵ₀ ≤ a * b ↔ a ≠ 0 ∧ ℵ₀ ≤ b ∨ ℵ₀ ≤ a ∧ b ≠ 0 := by\n  have : ∀ {a : Cardinal.{u}}, ℵ₀ ≤ a → a ≠ 0 := fun a => ne_bot_of_le_ne_bot aleph0_ne_zero a\n  simp only [aleph0_le_mul_iff, and_or_left, and_iff_right_of_imp this, @and_left_comm (a ≠ 0)]\n  simp only [and_comm, or_comm]\n\n"}
{"name":"Cardinal.mul_lt_aleph0_iff_of_ne_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : Ne a 0\nhb : Ne b 0\n⊢ Iff (LT.lt (HMul.hMul a b) Cardinal.aleph0) (And (LT.lt a Cardinal.aleph0) (LT.lt b Cardinal.aleph0))","decl":"theorem mul_lt_aleph0_iff_of_ne_zero {a b : Cardinal} (ha : a ≠ 0) (hb : b ≠ 0) :\n    a * b < ℵ₀ ↔ a < ℵ₀ ∧ b < ℵ₀ := by simp [mul_lt_aleph0_iff, ha, hb]\n\n"}
{"name":"Cardinal.power_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n⊢ LT.lt (HPow.hPow a b) Cardinal.aleph0","decl":"theorem power_lt_aleph0 {a b : Cardinal} (ha : a < ℵ₀) (hb : b < ℵ₀) : a ^ b < ℵ₀ :=\n  match a, b, lt_aleph0.1 ha, lt_aleph0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by rw [power_natCast, ← Nat.cast_pow]; apply nat_lt_aleph0\n\n"}
{"name":"Cardinal.eq_one_iff_unique","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Cardinal.mk α) 1) (And (Subsingleton α) (Nonempty α))","decl":"theorem eq_one_iff_unique {α : Type*} : #α = 1 ↔ Subsingleton α ∧ Nonempty α :=\n  calc\n    #α = 1 ↔ #α ≤ 1 ∧ 1 ≤ #α := le_antisymm_iff\n    _ ↔ Subsingleton α ∧ Nonempty α :=\n      le_one_iff_subsingleton.and (one_le_iff_ne_zero.trans mk_ne_zero_iff)\n\n"}
{"name":"Cardinal.infinite_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Infinite α) (LE.le Cardinal.aleph0 (Cardinal.mk α))","decl":"theorem infinite_iff {α : Type u} : Infinite α ↔ ℵ₀ ≤ #α := by\n  rw [← not_lt, lt_aleph0_iff_finite, not_finite_iff_infinite]\n\n"}
{"name":"Cardinal.aleph0_le_mk_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LE.le Cardinal.aleph0 (Cardinal.mk α)) (Infinite α)","decl":"lemma aleph0_le_mk_iff : ℵ₀ ≤ #α ↔ Infinite α := infinite_iff.symm\n"}
{"name":"Cardinal.mk_lt_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LT.lt (Cardinal.mk α) Cardinal.aleph0) (Finite α)","decl":"lemma mk_lt_aleph0_iff : #α < ℵ₀ ↔ Finite α := by simp [← not_le, aleph0_le_mk_iff]\n\n"}
{"name":"Cardinal.aleph0_le_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ LE.le Cardinal.aleph0 (Cardinal.mk α)","decl":"@[simp]\ntheorem aleph0_le_mk (α : Type u) [Infinite α] : ℵ₀ ≤ #α :=\n  infinite_iff.1 ‹_›\n\n"}
{"name":"Cardinal.mk_eq_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Countable α\ninst✝ : Infinite α\n⊢ Eq (Cardinal.mk α) Cardinal.aleph0","decl":"@[simp]\ntheorem mk_eq_aleph0 (α : Type*) [Countable α] [Infinite α] : #α = ℵ₀ :=\n  mk_le_aleph0.antisymm <| aleph0_le_mk _\n\n"}
{"name":"Cardinal.denumerable_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Nonempty (Denumerable α)) (Eq (Cardinal.mk α) Cardinal.aleph0)","decl":"theorem denumerable_iff {α : Type u} : Nonempty (Denumerable α) ↔ #α = ℵ₀ :=\n  ⟨fun ⟨h⟩ => mk_congr ((@Denumerable.eqv α h).trans Equiv.ulift.symm), fun h => by\n    cases' Quotient.exact h with f\n    exact ⟨Denumerable.mk' <| f.trans Equiv.ulift⟩⟩\n\n"}
{"name":"Cardinal.mk_denumerable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ninst✝ : Denumerable α\n⊢ Eq (Cardinal.mk α) Cardinal.aleph0","decl":"theorem mk_denumerable (α : Type u) [Denumerable α] : #α = ℵ₀ :=\n  denumerable_iff.1 ⟨‹_›⟩\n\n"}
{"name":"Set.countable_infinite_iff_nonempty_denumerable","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (And s.Countable s.Infinite) (Nonempty (Denumerable ↑s))","decl":"theorem _root_.Set.countable_infinite_iff_nonempty_denumerable {α : Type*} {s : Set α} :\n    s.Countable ∧ s.Infinite ↔ Nonempty (Denumerable s) := by\n  rw [nonempty_denumerable_iff, ← Set.infinite_coe_iff, countable_coe_iff]\n\n"}
{"name":"Cardinal.aleph0_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (HAdd.hAdd Cardinal.aleph0 Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_aleph0 : ℵ₀ + ℵ₀ = ℵ₀ :=\n  mk_denumerable _\n\n"}
{"name":"Cardinal.aleph0_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (HMul.hMul Cardinal.aleph0 Cardinal.aleph0) Cardinal.aleph0","decl":"theorem aleph0_mul_aleph0 : ℵ₀ * ℵ₀ = ℵ₀ :=\n  mk_denumerable _\n\n"}
{"name":"Cardinal.nat_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (HMul.hMul (↑n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem nat_mul_aleph0 {n : ℕ} (hn : n ≠ 0) : ↑n * ℵ₀ = ℵ₀ :=\n  le_antisymm (lift_mk_fin n ▸ mk_le_aleph0) <|\n    le_mul_of_one_le_left (zero_le _) <| by\n      rwa [← Nat.cast_one, Nat.cast_le, Nat.one_le_iff_ne_zero]\n\n"}
{"name":"Cardinal.aleph0_mul_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (HMul.hMul Cardinal.aleph0 ↑n) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_mul_nat {n : ℕ} (hn : n ≠ 0) : ℵ₀ * n = ℵ₀ := by rw [mul_comm, nat_mul_aleph0 hn]\n\n"}
{"name":"Cardinal.ofNat_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HMul.hMul (OfNat.ofNat n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem ofNat_mul_aleph0 {n : ℕ} [Nat.AtLeastTwo n] : ofNat(n) * ℵ₀ = ℵ₀ :=\n  nat_mul_aleph0 (NeZero.ne n)\n\n"}
{"name":"Cardinal.aleph0_mul_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HMul.hMul Cardinal.aleph0 (OfNat.ofNat n)) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_mul_ofNat {n : ℕ} [Nat.AtLeastTwo n] : ℵ₀ * ofNat(n) = ℵ₀ :=\n  aleph0_mul_nat (NeZero.ne n)\n\n"}
{"name":"Cardinal.add_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c₁ c₂ : Cardinal.{u_1}\n⊢ Iff (LE.le (HAdd.hAdd c₁ c₂) Cardinal.aleph0) (And (LE.le c₁ Cardinal.aleph0) (LE.le c₂ Cardinal.aleph0))","decl":"@[simp]\ntheorem add_le_aleph0 {c₁ c₂ : Cardinal} : c₁ + c₂ ≤ ℵ₀ ↔ c₁ ≤ ℵ₀ ∧ c₂ ≤ ℵ₀ :=\n  ⟨fun h => ⟨le_self_add.trans h, le_add_self.trans h⟩, fun h =>\n    aleph0_add_aleph0 ▸ add_le_add h.1 h.2⟩\n\n"}
{"name":"Cardinal.aleph0_add_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd Cardinal.aleph0 ↑n) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_nat (n : ℕ) : ℵ₀ + n = ℵ₀ :=\n  (add_le_aleph0.2 ⟨le_rfl, (nat_lt_aleph0 n).le⟩).antisymm le_self_add\n\n"}
{"name":"Cardinal.nat_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem nat_add_aleph0 (n : ℕ) : ↑n + ℵ₀ = ℵ₀ := by rw [add_comm, aleph0_add_nat]\n\n"}
{"name":"Cardinal.ofNat_add_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HAdd.hAdd (OfNat.ofNat n) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp]\ntheorem ofNat_add_aleph0 {n : ℕ} [Nat.AtLeastTwo n] : ofNat(n) + ℵ₀ = ℵ₀ :=\n  nat_add_aleph0 n\n\n"}
{"name":"Cardinal.aleph0_add_ofNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HAdd.hAdd Cardinal.aleph0 (OfNat.ofNat n)) Cardinal.aleph0","decl":"@[simp]\ntheorem aleph0_add_ofNat {n : ℕ} [Nat.AtLeastTwo n] : ℵ₀ + ofNat(n) = ℵ₀ :=\n  aleph0_add_nat n\n\n"}
{"name":"Cardinal.exists_nat_eq_of_le_nat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u_1}\nn : Nat\nh : LE.le c ↑n\n⊢ Exists fun m => And (LE.le m n) (Eq c ↑m)","decl":"theorem exists_nat_eq_of_le_nat {c : Cardinal} {n : ℕ} (h : c ≤ n) : ∃ m, m ≤ n ∧ c = m := by\n  lift c to ℕ using h.trans_lt (nat_lt_aleph0 _)\n  exact ⟨c, mod_cast h, rfl⟩\n\n"}
{"name":"Cardinal.mk_int","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Int) Cardinal.aleph0","decl":"theorem mk_int : #ℤ = ℵ₀ :=\n  mk_denumerable ℤ\n\n"}
{"name":"Cardinal.mk_pNat","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk PNat) Cardinal.aleph0","decl":"theorem mk_pNat : #ℕ+ = ℵ₀ :=\n  mk_denumerable ℕ+\n\n"}
{"name":"Cardinal.mk_empty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Empty) 0","decl":"theorem mk_empty : #Empty = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_pempty","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk PEmpty.{u_1 + 1}) 0","decl":"theorem mk_pempty : #PEmpty = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_punit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk PUnit.{u_1 + 1}) 1","decl":"theorem mk_punit : #PUnit = 1 :=\n  mk_eq_one PUnit\n\n"}
{"name":"Cardinal.mk_unit","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk Unit) 1","decl":"theorem mk_unit : #Unit = 1 :=\n  mk_punit\n\n"}
{"name":"Cardinal.mk_additive","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (Additive α)) (Cardinal.mk α)","decl":"@[simp] theorem mk_additive : #(Additive α) = #α := rfl\n\n"}
{"name":"Cardinal.mk_multiplicative","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (Multiplicative α)) (Cardinal.mk α)","decl":"@[simp] theorem mk_multiplicative : #(Multiplicative α) = #α := rfl\n\n"}
{"name":"Cardinal.mk_addOpposite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (AddOpposite α)) (Cardinal.mk α)","decl":"@[to_additive (attr := simp)] theorem mk_mulOpposite : #(MulOpposite α) = #α :=\n  mk_congr MulOpposite.opEquiv.symm\n\n"}
{"name":"Cardinal.mk_mulOpposite","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (MulOpposite α)) (Cardinal.mk α)","decl":"@[to_additive (attr := simp)] theorem mk_mulOpposite : #(MulOpposite α) = #α :=\n  mk_congr MulOpposite.opEquiv.symm\n\n"}
{"name":"Cardinal.mk_singleton","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (Cardinal.mk ↑(Singleton.singleton x)) 1","decl":"theorem mk_singleton {α : Type u} (x : α) : #({x} : Set α) = 1 :=\n  mk_eq_one _\n\n"}
{"name":"Cardinal.mk_plift_true","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk (PLift True)) 1","decl":"theorem mk_plift_true : #(PLift True) = 1 :=\n  mk_eq_one _\n\n"}
{"name":"Cardinal.mk_plift_false","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"⊢ Eq (Cardinal.mk (PLift False)) 0","decl":"theorem mk_plift_false : #(PLift False) = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_vector","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (Cardinal.mk (List.Vector α n)) (HPow.hPow (Cardinal.mk α) n)","decl":"@[simp]\ntheorem mk_vector (α : Type u) (n : ℕ) : #(List.Vector α n) = #α ^ n :=\n  (mk_congr (Equiv.vectorEquivFin α n)).trans <| by simp\n\n"}
{"name":"Cardinal.mk_list_eq_sum_pow","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (List α)) (Cardinal.sum fun n => HPow.hPow (Cardinal.mk α) n)","decl":"theorem mk_list_eq_sum_pow (α : Type u) : #(List α) = sum fun n : ℕ => #α ^ n :=\n  calc\n    #(List α) = #(Σn, List.Vector α n) := mk_congr (Equiv.sigmaFiberEquiv List.length).symm\n    _ = sum fun n : ℕ => #α ^ n := by simp\n\n"}
{"name":"Cardinal.mk_quot_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nr : α → α → Prop\n⊢ LE.le (Cardinal.mk (Quot r)) (Cardinal.mk α)","decl":"theorem mk_quot_le {α : Type u} {r : α → α → Prop} : #(Quot r) ≤ #α :=\n  mk_le_of_surjective Quot.exists_rep\n\n"}
{"name":"Cardinal.mk_quotient_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Setoid α\n⊢ LE.le (Cardinal.mk (Quotient s)) (Cardinal.mk α)","decl":"theorem mk_quotient_le {α : Type u} {s : Setoid α} : #(Quotient s) ≤ #α :=\n  mk_quot_le\n\n"}
{"name":"Cardinal.mk_subtype_le_of_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\np q : α → Prop\nh : ∀ ⦃x : α⦄, p x → q x\n⊢ LE.le (Cardinal.mk (Subtype p)) (Cardinal.mk (Subtype q))","decl":"theorem mk_subtype_le_of_subset {α : Type u} {p q : α → Prop} (h : ∀ ⦃x⦄, p x → q x) :\n    #(Subtype p) ≤ #(Subtype q) :=\n  ⟨Embedding.subtypeMap (Embedding.refl α) h⟩\n\n"}
{"name":"Cardinal.mk_emptyCollection","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk ↑EmptyCollection.emptyCollection) 0","decl":"theorem mk_emptyCollection (α : Type u) : #(∅ : Set α) = 0 :=\n  mk_eq_zero _\n\n"}
{"name":"Cardinal.mk_emptyCollection_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq (Cardinal.mk ↑s) 0) (Eq s EmptyCollection.emptyCollection)","decl":"theorem mk_emptyCollection_iff {α : Type u} {s : Set α} : #s = 0 ↔ s = ∅ := by\n  constructor\n  · intro h\n    rw [mk_eq_zero_iff] at h\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => h.elim' ⟨x, hx⟩\n  · rintro rfl\n    exact mk_emptyCollection _\n\n"}
{"name":"Cardinal.mk_univ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk ↑Set.univ) (Cardinal.mk α)","decl":"@[simp]\ntheorem mk_univ {α : Type u} : #(@univ α) = #α :=\n  mk_congr (Equiv.Set.univ α)\n\n"}
{"name":"Cardinal.mk_setProd","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\ns : Set α\nt : Set β\n⊢ Eq (Cardinal.mk ↑(SProd.sprod s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"@[simp] lemma mk_setProd {α β : Type u} (s : Set α) (t : Set β) : #(s ×ˢ t) = #s * #t := by\n  rw [mul_def, mk_congr (Equiv.Set.prod ..)]\n\n"}
{"name":"Cardinal.mk_image_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set α\n⊢ LE.le (Cardinal.mk ↑(Set.image f s)) (Cardinal.mk ↑s)","decl":"theorem mk_image_le {α β : Type u} {f : α → β} {s : Set α} : #(f '' s) ≤ #s :=\n  mk_le_of_surjective surjective_onto_image\n\n"}
{"name":"Cardinal.mk_image2_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β γ : Type u\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ LE.le (Cardinal.mk ↑(Set.image2 f s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"lemma mk_image2_le {α β γ : Type u} {f : α → β → γ} {s : Set α} {t : Set β} :\n    #(image2 f s t) ≤ #s * #t := by\n  rw [← image_uncurry_prod, ← mk_setProd]\n  exact mk_image_le\n\n"}
{"name":"Cardinal.mk_image_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ↑s))","decl":"theorem mk_image_le_lift {α : Type u} {β : Type v} {f : α → β} {s : Set α} :\n    lift.{u} #(f '' s) ≤ lift.{v} #s :=\n  lift_mk_le.{0}.mpr ⟨Embedding.ofSurjective _ surjective_onto_image⟩\n\n"}
{"name":"Cardinal.mk_range_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\n⊢ LE.le (Cardinal.mk ↑(Set.range f)) (Cardinal.mk α)","decl":"theorem mk_range_le {α β : Type u} {f : α → β} : #(range f) ≤ #α :=\n  mk_le_of_surjective surjective_onto_range\n\n"}
{"name":"Cardinal.mk_range_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.range f))) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"theorem mk_range_le_lift {α : Type u} {β : Type v} {f : α → β} :\n    lift.{u} #(range f) ≤ lift.{v} #α :=\n  lift_mk_le.{0}.mpr ⟨Embedding.ofSurjective _ surjective_onto_range⟩\n\n"}
{"name":"Cardinal.mk_range_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\nh : Function.Injective f\n⊢ Eq (Cardinal.mk ↑(Set.range f)) (Cardinal.mk α)","decl":"theorem mk_range_eq (f : α → β) (h : Injective f) : #(range f) = #α :=\n  mk_congr (Equiv.ofInjective f h).symm\n\n"}
{"name":"Cardinal.mk_range_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Cardinal.lift.{max u w, v} (Cardinal.mk ↑(Set.range f))) (Cardinal.lift.{max v w, u} (Cardinal.mk α))","decl":"theorem mk_range_eq_lift {α : Type u} {β : Type v} {f : α → β} (hf : Injective f) :\n    lift.{max u w} #(range f) = lift.{max v w} #α :=\n  lift_mk_eq.{v,u,w}.mpr ⟨(Equiv.ofInjective f hf).symm⟩\n\n"}
{"name":"Cardinal.mk_range_eq_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.range f))) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"theorem mk_range_eq_of_injective {α : Type u} {β : Type v} {f : α → β} (hf : Injective f) :\n    lift.{u} #(range f) = lift.{v} #α :=\n  lift_mk_eq'.mpr ⟨(Equiv.ofInjective f hf).symm⟩\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Injective f\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β))","decl":"lemma lift_mk_le_lift_mk_of_injective {α : Type u} {β : Type v} {f : α → β} (hf : Injective f) :\n    Cardinal.lift.{v} (#α) ≤ Cardinal.lift.{u} (#β) := by\n  rw [← Cardinal.mk_range_eq_of_injective hf]\n  exact Cardinal.lift_le.2 (Cardinal.mk_set_le _)\n\n"}
{"name":"Cardinal.lift_mk_le_lift_mk_of_surjective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Surjective f\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk β)) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"lemma lift_mk_le_lift_mk_of_surjective {α : Type u} {β : Type v} {f : α → β} (hf : Surjective f) :\n    Cardinal.lift.{u} (#β) ≤ Cardinal.lift.{v} (#α) :=\n  lift_mk_le_lift_mk_of_injective (injective_surjInv hf)\n\n"}
{"name":"Cardinal.mk_image_eq_of_injOn","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set α\nh : Set.InjOn f s\n⊢ Eq (Cardinal.mk ↑(Set.image f s)) (Cardinal.mk ↑s)","decl":"theorem mk_image_eq_of_injOn {α β : Type u} (f : α → β) (s : Set α) (h : InjOn f s) :\n    #(f '' s) = #s :=\n  mk_congr (Equiv.Set.imageOfInjOn f s h).symm\n\n"}
{"name":"Cardinal.mk_image_eq_of_injOn_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nh : Set.InjOn f s\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ↑s))","decl":"theorem mk_image_eq_of_injOn_lift {α : Type u} {β : Type v} (f : α → β) (s : Set α)\n    (h : InjOn f s) : lift.{u} #(f '' s) = lift.{v} #s :=\n  lift_mk_eq.{v, u, 0}.mpr ⟨(Equiv.Set.imageOfInjOn f s h).symm⟩\n\n"}
{"name":"Cardinal.mk_image_eq","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set α\nhf : Function.Injective f\n⊢ Eq (Cardinal.mk ↑(Set.image f s)) (Cardinal.mk ↑s)","decl":"theorem mk_image_eq {α β : Type u} {f : α → β} {s : Set α} (hf : Injective f) : #(f '' s) = #s :=\n  mk_image_eq_of_injOn _ _ hf.injOn\n\n"}
{"name":"Cardinal.mk_image_eq_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nh : Function.Injective f\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.image f s))) (Cardinal.lift.{v, u} (Cardinal.mk ↑s))","decl":"theorem mk_image_eq_lift {α : Type u} {β : Type v} (f : α → β) (s : Set α) (h : Injective f) :\n    lift.{u} #(f '' s) = lift.{v} #s :=\n  mk_image_eq_of_injOn_lift _ _ h.injOn\n\n"}
{"name":"Cardinal.mk_image_embedding_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Function.Embedding α β\ns : Set α\n⊢ Eq (Cardinal.lift.{u, v} (Cardinal.mk ↑(Set.image (⇑f) s))) (Cardinal.lift.{v, u} (Cardinal.mk ↑s))","decl":"@[simp]\ntheorem mk_image_embedding_lift {β : Type v} (f : α ↪ β) (s : Set α) :\n    lift.{u} #(f '' s) = lift.{v} #s :=\n  mk_image_eq_lift _ _ f.injective\n\n"}
{"name":"Cardinal.mk_image_embedding","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : Function.Embedding α β\ns : Set α\n⊢ Eq (Cardinal.mk ↑(Set.image (⇑f) s)) (Cardinal.mk ↑s)","decl":"@[simp]\ntheorem mk_image_embedding (f : α ↪ β) (s : Set α) : #(f '' s) = #s := by\n  simpa using mk_image_embedding_lift f s\n\n"}
{"name":"Cardinal.mk_iUnion_le_sum_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α ι : Type u\nf : ι → Set α\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun i => f i)) (Cardinal.sum fun i => Cardinal.mk ↑(f i))","decl":"theorem mk_iUnion_le_sum_mk {α ι : Type u} {f : ι → Set α} : #(⋃ i, f i) ≤ sum fun i => #(f i) :=\n  calc\n    #(⋃ i, f i) ≤ #(Σi, f i) := mk_le_of_surjective (Set.sigmaToiUnion_surjective f)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_le_sum_mk_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nι : Type v\nf : ι → Set α\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.iUnion fun i => f i))) (Cardinal.sum fun i => Cardinal.mk ↑(f i))","decl":"theorem mk_iUnion_le_sum_mk_lift {α : Type u} {ι : Type v} {f : ι → Set α} :\n    lift.{v} #(⋃ i, f i) ≤ sum fun i => #(f i) :=\n  calc\n    lift.{v} #(⋃ i, f i) ≤ #(Σi, f i) :=\n      mk_le_of_surjective <| ULift.up_surjective.comp (Set.sigmaToiUnion_surjective f)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_eq_sum_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α ι : Type u\nf : ι → Set α\nh : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (Cardinal.mk ↑(Set.iUnion fun i => f i)) (Cardinal.sum fun i => Cardinal.mk ↑(f i))","decl":"theorem mk_iUnion_eq_sum_mk {α ι : Type u} {f : ι → Set α}\n    (h : Pairwise (Disjoint on f)) : #(⋃ i, f i) = sum fun i => #(f i) :=\n  calc\n    #(⋃ i, f i) = #(Σi, f i) := mk_congr (Set.unionEqSigmaOfDisjoint h)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_eq_sum_mk_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nι : Type v\nf : ι → Set α\nh : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.iUnion fun i => f i))) (Cardinal.sum fun i => Cardinal.mk ↑(f i))","decl":"theorem mk_iUnion_eq_sum_mk_lift {α : Type u} {ι : Type v} {f : ι → Set α}\n    (h : Pairwise (Disjoint on f)) :\n    lift.{v} #(⋃ i, f i) = sum fun i => #(f i) :=\n  calc\n    lift.{v} #(⋃ i, f i) = #(Σi, f i) :=\n      mk_congr <| .trans Equiv.ulift (Set.unionEqSigmaOfDisjoint h)\n    _ = sum fun i => #(f i) := mk_sigma _\n\n"}
{"name":"Cardinal.mk_iUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α ι : Type u\nf : ι → Set α\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun i => f i)) (HMul.hMul (Cardinal.mk ι) (iSup fun i => Cardinal.mk ↑(f i)))","decl":"theorem mk_iUnion_le {α ι : Type u} (f : ι → Set α) : #(⋃ i, f i) ≤ #ι * ⨆ i, #(f i) :=\n  mk_iUnion_le_sum_mk.trans (sum_le_iSup _)\n\n"}
{"name":"Cardinal.mk_iUnion_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nι : Type v\nf : ι → Set α\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.iUnion fun i => f i))) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk ι)) (iSup fun i => Cardinal.lift.{v, u} (Cardinal.mk ↑(f i))))","decl":"theorem mk_iUnion_le_lift {α : Type u} {ι : Type v} (f : ι → Set α) :\n    lift.{v} #(⋃ i, f i) ≤ lift.{u} #ι * ⨆ i, lift.{v} #(f i) := by\n  refine mk_iUnion_le_sum_mk_lift.trans <| Eq.trans_le ?_ (sum_le_iSup_lift _)\n  rw [← lift_sum, lift_id'.{_,u}]\n\n"}
{"name":"Cardinal.mk_sUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nA : Set (Set α)\n⊢ LE.le (Cardinal.mk ↑A.sUnion) (HMul.hMul (Cardinal.mk ↑A) (iSup fun s => Cardinal.mk ↑↑s))","decl":"theorem mk_sUnion_le {α : Type u} (A : Set (Set α)) : #(⋃₀ A) ≤ #A * ⨆ s : A, #s := by\n  rw [sUnion_eq_iUnion]\n  apply mk_iUnion_le\n\n"}
{"name":"Cardinal.mk_biUnion_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"ι α : Type u\nA : ι → Set α\ns : Set ι\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun x => Set.iUnion fun h => A x)) (HMul.hMul (Cardinal.mk ↑s) (iSup fun x => Cardinal.mk ↑(A ↑x)))","decl":"theorem mk_biUnion_le {ι α : Type u} (A : ι → Set α) (s : Set ι) :\n    #(⋃ x ∈ s, A x) ≤ #s * ⨆ x : s, #(A x.1) := by\n  rw [biUnion_eq_iUnion]\n  apply mk_iUnion_le\n\n"}
{"name":"Cardinal.mk_biUnion_le_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nι : Type v\nA : ι → Set α\ns : Set ι\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.iUnion fun x => Set.iUnion fun h => A x))) (HMul.hMul (Cardinal.lift.{u, v} (Cardinal.mk ↑s)) (iSup fun x => Cardinal.lift.{v, u} (Cardinal.mk ↑(A ↑x))))","decl":"theorem mk_biUnion_le_lift {α : Type u} {ι : Type v} (A : ι → Set α) (s : Set ι) :\n    lift.{v} #(⋃ x ∈ s, A x) ≤ lift.{u} #s * ⨆ x : s, lift.{v} #(A x.1) := by\n  rw [biUnion_eq_iUnion]\n  apply mk_iUnion_le_lift\n\n"}
{"name":"Cardinal.finset_card_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ LT.lt (Cardinal.mk ↑↑s) Cardinal.aleph0","decl":"theorem finset_card_lt_aleph0 (s : Finset α) : #(↑s : Set α) < ℵ₀ :=\n  lt_aleph0_of_finite _\n\n"}
{"name":"Cardinal.mk_set_eq_nat_iff_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\n⊢ Iff (Eq (Cardinal.mk ↑s) ↑n) (Exists fun t => And (Eq (↑t) s) (Eq t.card n))","decl":"theorem mk_set_eq_nat_iff_finset {α} {s : Set α} {n : ℕ} :\n    #s = n ↔ ∃ t : Finset α, (t : Set α) = s ∧ t.card = n := by\n  constructor\n  · intro h\n    lift s to Finset α using lt_aleph0_iff_set_finite.1 (h.symm ▸ nat_lt_aleph0 n)\n    simpa using h\n  · rintro ⟨t, rfl, rfl⟩\n    exact mk_coe_finset\n\n"}
{"name":"Cardinal.mk_eq_nat_iff_finset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\n⊢ Iff (Eq (Cardinal.mk α) ↑n) (Exists fun t => And (Eq (↑t) Set.univ) (Eq t.card n))","decl":"theorem mk_eq_nat_iff_finset {n : ℕ} :\n    #α = n ↔ ∃ t : Finset α, (t : Set α) = univ ∧ t.card = n := by\n  rw [← mk_univ, mk_set_eq_nat_iff_finset]\n\n"}
{"name":"Cardinal.mk_eq_nat_iff_fintype","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\n⊢ Iff (Eq (Cardinal.mk α) ↑n) (Exists fun h => Eq (Fintype.card α) n)","decl":"theorem mk_eq_nat_iff_fintype {n : ℕ} : #α = n ↔ ∃ h : Fintype α, @Fintype.card α h = n := by\n  rw [mk_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨t, ht, hn⟩\n    exact ⟨⟨t, eq_univ_iff_forall.1 ht⟩, hn⟩\n  · rintro ⟨⟨t, ht⟩, hn⟩\n    exact ⟨t, eq_univ_iff_forall.2 ht, hn⟩\n\n"}
{"name":"Cardinal.mk_union_add_mk_inter","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS T : Set α\n⊢ Eq (HAdd.hAdd (Cardinal.mk ↑(Union.union S T)) (Cardinal.mk ↑(Inter.inter S T))) (HAdd.hAdd (Cardinal.mk ↑S) (Cardinal.mk ↑T))","decl":"theorem mk_union_add_mk_inter {α : Type u} {S T : Set α} :\n    #(S ∪ T : Set α) + #(S ∩ T : Set α) = #S + #T := by\n  classical\n  exact Quot.sound ⟨Equiv.Set.unionSumInter S T⟩\n\n"}
{"name":"Cardinal.mk_union_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS T : Set α\n⊢ LE.le (Cardinal.mk ↑(Union.union S T)) (HAdd.hAdd (Cardinal.mk ↑S) (Cardinal.mk ↑T))","decl":"/-- The cardinality of a union is at most the sum of the cardinalities\nof the two sets. -/\ntheorem mk_union_le {α : Type u} (S T : Set α) : #(S ∪ T : Set α) ≤ #S + #T :=\n  @mk_union_add_mk_inter α S T ▸ self_le_add_right #(S ∪ T : Set α) #(S ∩ T : Set α)\n\n"}
{"name":"Cardinal.mk_union_of_disjoint","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS T : Set α\nH : Disjoint S T\n⊢ Eq (Cardinal.mk ↑(Union.union S T)) (HAdd.hAdd (Cardinal.mk ↑S) (Cardinal.mk ↑T))","decl":"theorem mk_union_of_disjoint {α : Type u} {S T : Set α} (H : Disjoint S T) :\n    #(S ∪ T : Set α) = #S + #T := by\n  classical\n  exact Quot.sound ⟨Equiv.Set.union H⟩\n\n"}
{"name":"Cardinal.mk_insert","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\na : α\nh : Not (Membership.mem s a)\n⊢ Eq (Cardinal.mk ↑(Insert.insert a s)) (HAdd.hAdd (Cardinal.mk ↑s) 1)","decl":"theorem mk_insert {α : Type u} {s : Set α} {a : α} (h : a ∉ s) :\n    #(insert a s : Set α) = #s + 1 := by\n  rw [← union_singleton, mk_union_of_disjoint, mk_singleton]\n  simpa\n\n"}
{"name":"Cardinal.mk_insert_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\na : α\n⊢ LE.le (Cardinal.mk ↑(Insert.insert a s)) (HAdd.hAdd (Cardinal.mk ↑s) 1)","decl":"theorem mk_insert_le {α : Type u} {s : Set α} {a : α} : #(insert a s : Set α) ≤ #s + 1 := by\n  by_cases h : a ∈ s\n  · simp only [insert_eq_of_mem h, self_le_add_right]\n  · rw [mk_insert h]\n\n"}
{"name":"Cardinal.mk_sum_compl","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (HAdd.hAdd (Cardinal.mk ↑s) (Cardinal.mk ↑(HasCompl.compl s))) (Cardinal.mk α)","decl":"theorem mk_sum_compl {α} (s : Set α) : #s + #(sᶜ : Set α) = #α := by\n  classical\n  exact mk_congr (Equiv.Set.sumCompl s)\n\n"}
{"name":"Cardinal.mk_le_mk_of_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (Cardinal.mk ↑s) (Cardinal.mk ↑t)","decl":"theorem mk_le_mk_of_subset {α} {s t : Set α} (h : s ⊆ t) : #s ≤ #t :=\n  ⟨Set.embeddingOfSubset s t h⟩\n\n"}
{"name":"Cardinal.mk_le_iff_forall_finset_subset_card_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nn : Nat\nt : Set α\n⊢ Iff (LE.le (Cardinal.mk ↑t) ↑n) (∀ (s : Finset α), HasSubset.Subset (↑s) t → LE.le s.card n)","decl":"theorem mk_le_iff_forall_finset_subset_card_le {α : Type u} {n : ℕ} {t : Set α} :\n    #t ≤ n ↔ ∀ s : Finset α, (s : Set α) ⊆ t → s.card ≤ n := by\n  refine ⟨fun H s hs ↦ by simpa using (mk_le_mk_of_subset hs).trans H, fun H ↦ ?_⟩\n  apply card_le_of (fun s ↦ ?_)\n  classical\n  let u : Finset α := s.image Subtype.val\n  have : u.card = s.card := Finset.card_image_of_injOn Subtype.coe_injective.injOn\n  rw [← this]\n  apply H\n  simp only [u, Finset.coe_image, image_subset_iff, Subtype.coe_preimage_self, subset_univ]\n\n"}
{"name":"Cardinal.mk_subtype_mono","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\np q : α → Prop\nh : ∀ (x : α), p x → q x\n⊢ LE.le (Cardinal.mk (Subtype fun x => p x)) (Cardinal.mk (Subtype fun x => q x))","decl":"theorem mk_subtype_mono {p q : α → Prop} (h : ∀ x, p x → q x) :\n    #{ x // p x } ≤ #{ x // q x } :=\n  ⟨embeddingOfSubset _ _ h⟩\n\n"}
{"name":"Cardinal.le_mk_diff_add_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS T : Set α\n⊢ LE.le (Cardinal.mk ↑S) (HAdd.hAdd (Cardinal.mk ↑(SDiff.sdiff S T)) (Cardinal.mk ↑T))","decl":"theorem le_mk_diff_add_mk (S T : Set α) : #S ≤ #(S \\ T : Set α) + #T :=\n  (mk_le_mk_of_subset <| subset_diff_union _ _).trans <| mk_union_le _ _\n\n"}
{"name":"Cardinal.mk_diff_add_mk","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nS T : Set α\nh : HasSubset.Subset T S\n⊢ Eq (HAdd.hAdd (Cardinal.mk ↑(SDiff.sdiff S T)) (Cardinal.mk ↑T)) (Cardinal.mk ↑S)","decl":"theorem mk_diff_add_mk {S T : Set α} (h : T ⊆ S) : #(S \\ T : Set α) + #T = #S := by\n  refine (mk_union_of_disjoint <| ?_).symm.trans <| by rw [diff_union_of_subset h]\n  exact disjoint_sdiff_self_left\n\n"}
{"name":"Cardinal.mk_union_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\nP Q : Set α\n⊢ Iff (LE.le (Cardinal.mk ↑(Union.union P Q)) Cardinal.aleph0) (And (LE.le (Cardinal.mk ↑P) Cardinal.aleph0) (LE.le (Cardinal.mk ↑Q) Cardinal.aleph0))","decl":"theorem mk_union_le_aleph0 {α} {P Q : Set α} :\n    #(P ∪ Q : Set α) ≤ ℵ₀ ↔ #P ≤ ℵ₀ ∧ #Q ≤ ℵ₀ := by\n  simp only [le_aleph0_iff_subtype_countable, mem_union, setOf_mem_eq, Set.union_def,\n    ← countable_union]\n\n"}
{"name":"Cardinal.mk_subtype_of_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\np : β → Prop\ne : Equiv α β\n⊢ Eq (Cardinal.mk (Subtype fun a => p (e a))) (Cardinal.mk (Subtype fun b => p b))","decl":"theorem mk_subtype_of_equiv {α β : Type u} (p : β → Prop) (e : α ≃ β) :\n    #{ a : α // p (e a) } = #{ b : β // p b } :=\n  mk_congr (Equiv.subtypeEquivOfSubtype e)\n\n"}
{"name":"Cardinal.mk_sep","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\ns : Set α\nt : α → Prop\n⊢ Eq (Cardinal.mk ↑(setOf fun x => And (Membership.mem s x) (t x))) (Cardinal.mk ↑(setOf fun x => t ↑x))","decl":"theorem mk_sep (s : Set α) (t : α → Prop) : #({ x ∈ s | t x } : Set α) = #{ x : s | t x.1 } :=\n  mk_congr (Equiv.Set.sep s t)\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : Function.Injective f\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.preimage f s))) (Cardinal.lift.{u, v} (Cardinal.mk ↑s))","decl":"theorem mk_preimage_of_injective_lift {α : Type u} {β : Type v} (f : α → β) (s : Set β)\n    (h : Injective f) : lift.{v} #(f ⁻¹' s) ≤ lift.{u} #s := by\n  rw [lift_mk_le.{0}]\n  -- Porting note: Needed to insert `mem_preimage.mp` below\n  use Subtype.coind (fun x => f x.1) fun x => mem_preimage.mp x.2\n  apply Subtype.coind_injective; exact h.comp Subtype.val_injective\n\n"}
{"name":"Cardinal.mk_preimage_of_subset_range_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : HasSubset.Subset s (Set.range f)\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ↑s)) (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.preimage f s)))","decl":"theorem mk_preimage_of_subset_range_lift {α : Type u} {β : Type v} (f : α → β) (s : Set β)\n    (h : s ⊆ range f) : lift.{u} #s ≤ lift.{v} #(f ⁻¹' s) := by\n  rw [← image_preimage_eq_iff] at h\n  nth_rewrite 1 [← h]\n  apply mk_image_le_lift\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_of_subset_range_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : Function.Injective f\nh2 : HasSubset.Subset s (Set.range f)\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.preimage f s))) (Cardinal.lift.{u, v} (Cardinal.mk ↑s))","decl":"theorem mk_preimage_of_injective_of_subset_range_lift {β : Type v} (f : α → β) (s : Set β)\n    (h : Injective f) (h2 : s ⊆ range f) : lift.{v} #(f ⁻¹' s) = lift.{u} #s :=\n  le_antisymm (mk_preimage_of_injective_lift f s h) (mk_preimage_of_subset_range_lift f s h2)\n\n"}
{"name":"Cardinal.mk_preimage_of_injective_of_subset_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set β\nh : Function.Injective f\nh2 : HasSubset.Subset s (Set.range f)\n⊢ Eq (Cardinal.mk ↑(Set.preimage f s)) (Cardinal.mk ↑s)","decl":"theorem mk_preimage_of_injective_of_subset_range (f : α → β) (s : Set β) (h : Injective f)\n    (h2 : s ⊆ range f) : #(f ⁻¹' s) = #s := by\n  convert mk_preimage_of_injective_of_subset_range_lift.{u, u} f s h h2 using 1 <;> rw [lift_id]\n\n"}
{"name":"Cardinal.mk_preimage_equiv_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Equiv α β\ns : Set β\n⊢ Eq (Cardinal.lift.{v, u} (Cardinal.mk ↑(Set.preimage (⇑f) s))) (Cardinal.lift.{u, v} (Cardinal.mk ↑s))","decl":"@[simp]\ntheorem mk_preimage_equiv_lift {β : Type v} (f : α ≃ β) (s : Set β) :\n    lift.{v} #(f ⁻¹' s) = lift.{u} #s := by\n  apply mk_preimage_of_injective_of_subset_range_lift _ _ f.injective\n  rw [f.range_eq_univ]\n  exact fun _ _ ↦ ⟨⟩\n\n"}
{"name":"Cardinal.mk_preimage_equiv","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : Equiv α β\ns : Set β\n⊢ Eq (Cardinal.mk ↑(Set.preimage (⇑f) s)) (Cardinal.mk ↑s)","decl":"@[simp]\ntheorem mk_preimage_equiv (f : α ≃ β) (s : Set β) : #(f ⁻¹' s) = #s := by\n  simpa using mk_preimage_equiv_lift f s\n\n"}
{"name":"Cardinal.mk_preimage_of_injective","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set β\nh : Function.Injective f\n⊢ LE.le (Cardinal.mk ↑(Set.preimage f s)) (Cardinal.mk ↑s)","decl":"theorem mk_preimage_of_injective (f : α → β) (s : Set β) (h : Injective f) :\n    #(f ⁻¹' s) ≤ #s := by\n  rw [← lift_id #(↑(f ⁻¹' s)), ← lift_id #(↑s)]\n  exact mk_preimage_of_injective_lift f s h\n\n"}
{"name":"Cardinal.mk_preimage_of_subset_range","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set β\nh : HasSubset.Subset s (Set.range f)\n⊢ LE.le (Cardinal.mk ↑s) (Cardinal.mk ↑(Set.preimage f s))","decl":"theorem mk_preimage_of_subset_range (f : α → β) (s : Set β) (h : s ⊆ range f) :\n    #s ≤ #(f ⁻¹' s) := by\n  rw [← lift_id #(↑(f ⁻¹' s)), ← lift_id #(↑s)]\n  exact mk_preimage_of_subset_range_lift f s h\n\n"}
{"name":"Cardinal.mk_subset_ge_of_subset_image_lift","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nt : Set β\nh : HasSubset.Subset t (Set.image f s)\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk ↑t)) (Cardinal.lift.{v, u} (Cardinal.mk ↑(setOf fun x => And (Membership.mem s x) (Membership.mem t (f x)))))","decl":"theorem mk_subset_ge_of_subset_image_lift {α : Type u} {β : Type v} (f : α → β) {s : Set α}\n    {t : Set β} (h : t ⊆ f '' s) : lift.{u} #t ≤ lift.{v} #({ x ∈ s | f x ∈ t } : Set α) := by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range_lift _ _ h using 1\n  rw [mk_sep]\n  rfl\n\n"}
{"name":"Cardinal.mk_subset_ge_of_subset_image","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α β : Type u\nf : α → β\ns : Set α\nt : Set β\nh : HasSubset.Subset t (Set.image f s)\n⊢ LE.le (Cardinal.mk ↑t) (Cardinal.mk ↑(setOf fun x => And (Membership.mem s x) (Membership.mem t (f x))))","decl":"theorem mk_subset_ge_of_subset_image (f : α → β) {s : Set α} {t : Set β} (h : t ⊆ f '' s) :\n    #t ≤ #({ x ∈ s | f x ∈ t } : Set α) := by\n  rw [image_eq_range] at h\n  convert mk_preimage_of_subset_range _ _ h using 1\n  rw [mk_sep]\n  rfl\n\n"}
{"name":"Cardinal.le_mk_iff_exists_subset","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"c : Cardinal.{u}\nα : Type u\ns : Set α\n⊢ Iff (LE.le c (Cardinal.mk ↑s)) (Exists fun p => And (HasSubset.Subset p s) (Eq (Cardinal.mk ↑p) c))","decl":"theorem le_mk_iff_exists_subset {c : Cardinal} {α : Type u} {s : Set α} :\n    c ≤ #s ↔ ∃ p : Set α, p ⊆ s ∧ #p = c := by\n  rw [le_mk_iff_exists_set, ← Subtype.exists_set_subtype]\n  apply exists_congr; intro t; rw [mk_image_eq]; apply Subtype.val_injective\n\n"}
{"name":"Cardinal.mk_range_inl","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk ↑(Set.range Sum.inl)) (Cardinal.lift.{v, u} (Cardinal.mk α))","decl":"@[simp]\ntheorem mk_range_inl {α : Type u} {β : Type v} : #(range (@Sum.inl α β)) = lift.{v} #α := by\n  rw [← lift_id'.{u, v} #_, (Equiv.Set.rangeInl α β).lift_cardinal_eq, lift_umax.{u, v}]\n\n"}
{"name":"Cardinal.mk_range_inr","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq (Cardinal.mk ↑(Set.range Sum.inr)) (Cardinal.lift.{u, v} (Cardinal.mk β))","decl":"@[simp]\ntheorem mk_range_inr {α : Type u} {β : Type v} : #(range (@Sum.inr α β)) = lift.{u} #β := by\n  rw [← lift_id'.{v, u} #_, (Equiv.Set.rangeInr α β).lift_cardinal_eq, lift_umax.{v, u}]\n\n"}
{"name":"Cardinal.two_le_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (LE.le 2 (Cardinal.mk α)) (Exists fun x => Exists fun y => Ne x y)","decl":"theorem two_le_iff : (2 : Cardinal) ≤ #α ↔ ∃ x y : α, x ≠ y := by\n  rw [← Nat.cast_two, nat_succ, succ_le_iff, Nat.cast_one, one_lt_iff_nontrivial, nontrivial_iff]\n\n"}
{"name":"Cardinal.two_le_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nx : α\n⊢ Iff (LE.le 2 (Cardinal.mk α)) (Exists fun y => Ne y x)","decl":"theorem two_le_iff' (x : α) : (2 : Cardinal) ≤ #α ↔ ∃ y : α, y ≠ x := by\n  rw [two_le_iff, ← nontrivial_iff, nontrivial_iff_exists_ne x]\n\n"}
{"name":"Cardinal.mk_eq_two_iff","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\n⊢ Iff (Eq (Cardinal.mk α) 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq (Insert.insert x (Singleton.singleton y)) Set.univ))","decl":"theorem mk_eq_two_iff : #α = 2 ↔ ∃ x y : α, x ≠ y ∧ ({x, y} : Set α) = univ := by\n  classical\n  simp only [← @Nat.cast_two Cardinal, mk_eq_nat_iff_finset, Finset.card_eq_two]\n  constructor\n  · rintro ⟨t, ht, x, y, hne, rfl⟩\n    exact ⟨x, y, hne, by simpa using ht⟩\n  · rintro ⟨x, y, hne, h⟩\n    exact ⟨{x, y}, by simpa using h, x, y, hne, rfl⟩\n\n"}
{"name":"Cardinal.mk_eq_two_iff'","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u\nx : α\n⊢ Iff (Eq (Cardinal.mk α) 2) (ExistsUnique fun y => Ne y x)","decl":"theorem mk_eq_two_iff' (x : α) : #α = 2 ↔ ∃! y, y ≠ x := by\n  rw [mk_eq_two_iff]; constructor\n  · rintro ⟨a, b, hne, h⟩\n    simp only [eq_univ_iff_forall, mem_insert_iff, mem_singleton_iff] at h\n    rcases h x with (rfl | rfl)\n    exacts [⟨b, hne.symm, fun z => (h z).resolve_left⟩, ⟨a, hne, fun z => (h z).resolve_right⟩]\n  · rintro ⟨y, hne, hy⟩\n    exact ⟨x, y, hne.symm, eq_univ_of_forall fun z => or_iff_not_imp_left.2 (hy z)⟩\n\n"}
{"name":"Cardinal.exists_not_mem_of_length_lt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\nl : List α\nh : LT.lt (↑l.length) (Cardinal.mk α)\n⊢ Exists fun z => Not (Membership.mem l z)","decl":"theorem exists_not_mem_of_length_lt {α : Type*} (l : List α) (h : ↑l.length < #α) :\n    ∃ z : α, z ∉ l := by\n  classical\n  contrapose! h\n  calc\n    #α = #(Set.univ : Set α) := mk_univ.symm\n    _ ≤ #l.toFinset := mk_le_mk_of_subset fun x _ => List.mem_toFinset.mpr (h x)\n    _ = l.toFinset.card := Cardinal.mk_coe_finset\n    _ ≤ l.length := Nat.cast_le.mpr (List.toFinset_card_le l)\n\n"}
{"name":"Cardinal.three_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"α : Type u_1\nh : LE.le 3 (Cardinal.mk α)\nx y : α\n⊢ Exists fun z => And (Ne z x) (Ne z y)","decl":"theorem three_le {α : Type*} (h : 3 ≤ #α) (x : α) (y : α) : ∃ z : α, z ≠ x ∧ z ≠ y := by\n  have : ↑(3 : ℕ) ≤ #α := by simpa using h\n  have : ↑(2 : ℕ) < #α := by rwa [← succ_le_iff, ← Cardinal.nat_succ]\n  have := exists_not_mem_of_length_lt [x, y] this\n  simpa [not_or] using this\n\n"}
{"name":"Cardinal.le_powerlt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"b c a : Cardinal.{u}\nh : LT.lt c b\n⊢ LE.le (HPow.hPow a c) (a.powerlt b)","decl":"theorem le_powerlt {b c : Cardinal.{u}} (a) (h : c < b) : (a^c) ≤ a ^< b := by\n  refine le_ciSup (f := fun y : Iio b => a ^ (y : Cardinal)) ?_ ⟨c, h⟩\n  rw [← image_eq_range]\n  exact bddAbove_image.{u, u} _ bddAbove_Iio\n\n"}
{"name":"Cardinal.powerlt_le","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u}\n⊢ Iff (LE.le (a.powerlt b) c) (∀ (x : Cardinal.{u}), LT.lt x b → LE.le (HPow.hPow a x) c)","decl":"theorem powerlt_le {a b c : Cardinal.{u}} : a ^< b ≤ c ↔ ∀ x < b, a ^ x ≤ c := by\n  rw [powerlt, ciSup_le_iff']\n  · simp\n  · rw [← image_eq_range]\n    exact bddAbove_image.{u, u} _ bddAbove_Iio\n\n"}
{"name":"Cardinal.powerlt_le_powerlt_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\nh : LE.le b c\n⊢ LE.le (a.powerlt b) (a.powerlt c)","decl":"theorem powerlt_le_powerlt_left {a b c : Cardinal} (h : b ≤ c) : a ^< b ≤ a ^< c :=\n  powerlt_le.2 fun _ hx => le_powerlt a <| hx.trans_le h\n\n"}
{"name":"Cardinal.powerlt_mono_left","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Monotone fun c => a.powerlt c","decl":"theorem powerlt_mono_left (a) : Monotone fun c => a ^< c := fun _ _ => powerlt_le_powerlt_left\n\n"}
{"name":"Cardinal.powerlt_succ","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b : Cardinal.{u_1}\nh : Ne a 0\n⊢ Eq (a.powerlt (Order.succ b)) (HPow.hPow a b)","decl":"theorem powerlt_succ {a b : Cardinal} (h : a ≠ 0) : a ^< succ b = a ^ b :=\n  (powerlt_le.2 fun _ h' => power_le_power_left h <| le_of_lt_succ h').antisymm <|\n    le_powerlt a (lt_succ b)\n\n"}
{"name":"Cardinal.powerlt_min","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n⊢ Eq (a.powerlt (Min.min b c)) (Min.min (a.powerlt b) (a.powerlt c))","decl":"theorem powerlt_min {a b c : Cardinal} : a ^< min b c = min (a ^< b) (a ^< c) :=\n  (powerlt_mono_left a).map_min\n\n"}
{"name":"Cardinal.powerlt_max","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a b c : Cardinal.{u_1}\n⊢ Eq (a.powerlt (Max.max b c)) (Max.max (a.powerlt b) (a.powerlt c))","decl":"theorem powerlt_max {a b c : Cardinal} : a ^< max b c = max (a ^< b) (a ^< c) :=\n  (powerlt_mono_left a).map_max\n\n"}
{"name":"Cardinal.zero_powerlt","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\nh : Ne a 0\n⊢ Eq (Cardinal.powerlt 0 a) 1","decl":"theorem zero_powerlt {a : Cardinal} (h : a ≠ 0) : 0 ^< a = 1 := by\n  apply (powerlt_le.2 fun c _ => zero_power_le _).antisymm\n  rw [← power_zero]\n  exact le_powerlt 0 (pos_iff_ne_zero.2 h)\n\n"}
{"name":"Cardinal.powerlt_zero","module":"Mathlib.SetTheory.Cardinal.Basic","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (a.powerlt 0) 0","decl":"@[simp]\ntheorem powerlt_zero {a : Cardinal} : a ^< 0 = 0 := by\n  convert Cardinal.iSup_of_empty _\n  exact Subtype.isEmpty_of_false fun x => mem_Iio.not.mpr (Cardinal.zero_le x).not_lt\n\n"}
