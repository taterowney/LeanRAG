{"name":"YoungDiagram.ext","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"x y : YoungDiagram\ncells : Eq x.cells y.cells\n⊢ Eq x y","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.isLowerSet","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"self : YoungDiagram\n⊢ IsLowerSet ↑self.cells","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.mk.inj","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"cells✝ : Finset (Prod Nat Nat)\nisLowerSet✝ : IsLowerSet ↑cells✝\ncells : Finset (Prod Nat Nat)\nisLowerSet : IsLowerSet ↑cells\nx✝ : Eq { cells := cells✝, isLowerSet := isLowerSet✝ } { cells := cells, isLowerSet := isLowerSet }\n⊢ Eq cells✝ cells","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"cells : Finset (Prod Nat Nat)\nisLowerSet : IsLowerSet ↑cells\n⊢ Eq (SizeOf.sizeOf { cells := cells, isLowerSet := isLowerSet }) (HAdd.hAdd 1 (SizeOf.sizeOf cells))","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.mk.injEq","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"cells✝ : Finset (Prod Nat Nat)\nisLowerSet✝ : IsLowerSet ↑cells✝\ncells : Finset (Prod Nat Nat)\nisLowerSet : IsLowerSet ↑cells\n⊢ Eq (Eq { cells := cells✝, isLowerSet := isLowerSet✝ } { cells := cells, isLowerSet := isLowerSet }) (Eq cells✝ cells)","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.ext_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"x y : YoungDiagram\n⊢ Iff (Eq x y) (Eq x.cells y.cells)","decl":"/-- A Young diagram is a finite collection of cells on the `ℕ × ℕ` grid such that whenever\na cell is present, so are all the ones above and to the left of it. Like matrices, an `(i, j)` cell\nis a cell in row `i` and column `j`, where rows are enumerated downward and columns rightward.\n\nYoung diagrams are modeled as finite sets in `ℕ × ℕ` that are lower sets with respect to the\nstandard order on products. -/\n@[ext]\nstructure YoungDiagram where\n  /-- A finite set which represents a finite collection of cells on the `ℕ × ℕ` grid. -/\n  cells : Finset (ℕ × ℕ)\n  /-- Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `ℕ × ℕ`. -/\n  isLowerSet : IsLowerSet (cells : Set (ℕ × ℕ))\n\n"}
{"name":"YoungDiagram.mem_cells","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nc : Prod Nat Nat\n⊢ Iff (Membership.mem μ.cells c) (Membership.mem μ c)","decl":"@[simp]\ntheorem mem_cells {μ : YoungDiagram} (c : ℕ × ℕ) : c ∈ μ.cells ↔ c ∈ μ :=\n  Iff.rfl\n\n"}
{"name":"YoungDiagram.mem_mk","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"c : Prod Nat Nat\ncells : Finset (Prod Nat Nat)\nisLowerSet : IsLowerSet ↑cells\n⊢ Iff (Membership.mem { cells := cells, isLowerSet := isLowerSet } c) (Membership.mem cells c)","decl":"@[simp]\ntheorem mem_mk (c : ℕ × ℕ) (cells) (isLowerSet) :\n    c ∈ YoungDiagram.mk cells isLowerSet ↔ c ∈ cells :=\n  Iff.rfl\n\n"}
{"name":"YoungDiagram.up_left_mem","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni1 i2 j1 j2 : Nat\nhi : LE.le i1 i2\nhj : LE.le j1 j2\nhcell : Membership.mem μ { fst := i2, snd := j2 }\n⊢ Membership.mem μ { fst := i1, snd := j1 }","decl":"/-- In \"English notation\", a Young diagram is drawn so that (i1, j1) ≤ (i2, j2)\n    means (i1, j1) is weakly up-and-left of (i2, j2). -/\ntheorem up_left_mem (μ : YoungDiagram) {i1 i2 j1 j2 : ℕ} (hi : i1 ≤ i2) (hj : j1 ≤ j2)\n    (hcell : (i2, j2) ∈ μ) : (i1, j1) ∈ μ :=\n  μ.isLowerSet (Prod.mk_le_mk.mpr ⟨hi, hj⟩) hcell\n\n"}
{"name":"YoungDiagram.cells_subset_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Iff (HasSubset.Subset μ.cells ν.cells) (LE.le μ ν)","decl":"@[simp]\ntheorem cells_subset_iff {μ ν : YoungDiagram} : μ.cells ⊆ ν.cells ↔ μ ≤ ν :=\n  Iff.rfl\n\n"}
{"name":"YoungDiagram.cells_ssubset_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Iff (HasSSubset.SSubset μ.cells ν.cells) (LT.lt μ ν)","decl":"@[simp]\ntheorem cells_ssubset_iff {μ ν : YoungDiagram} : μ.cells ⊂ ν.cells ↔ μ < ν :=\n  Iff.rfl\n\n"}
{"name":"YoungDiagram.cells_sup","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Eq (Max.max μ ν).cells (Union.union μ.cells ν.cells)","decl":"@[simp]\ntheorem cells_sup (μ ν : YoungDiagram) : (μ ⊔ ν).cells = μ.cells ∪ ν.cells :=\n  rfl\n\n"}
{"name":"YoungDiagram.coe_sup","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Eq (↑(Max.max μ ν)) (Union.union ↑μ ↑ν)","decl":"@[simp, norm_cast]\ntheorem coe_sup (μ ν : YoungDiagram) : ↑(μ ⊔ ν) = (μ ∪ ν : Set (ℕ × ℕ)) :=\n  Finset.coe_union _ _\n\n"}
{"name":"YoungDiagram.mem_sup","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\nx : Prod Nat Nat\n⊢ Iff (Membership.mem (Max.max μ ν) x) (Or (Membership.mem μ x) (Membership.mem ν x))","decl":"@[simp]\ntheorem mem_sup {μ ν : YoungDiagram} {x : ℕ × ℕ} : x ∈ μ ⊔ ν ↔ x ∈ μ ∨ x ∈ ν :=\n  Finset.mem_union\n\n"}
{"name":"YoungDiagram.cells_inf","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Eq (Min.min μ ν).cells (Inter.inter μ.cells ν.cells)","decl":"@[simp]\ntheorem cells_inf (μ ν : YoungDiagram) : (μ ⊓ ν).cells = μ.cells ∩ ν.cells :=\n  rfl\n\n"}
{"name":"YoungDiagram.coe_inf","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Eq (↑(Min.min μ ν)) (Inter.inter ↑μ ↑ν)","decl":"@[simp, norm_cast]\ntheorem coe_inf (μ ν : YoungDiagram) : ↑(μ ⊓ ν) = (μ ∩ ν : Set (ℕ × ℕ)) :=\n  Finset.coe_inter _ _\n\n"}
{"name":"YoungDiagram.mem_inf","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\nx : Prod Nat Nat\n⊢ Iff (Membership.mem (Min.min μ ν) x) (And (Membership.mem μ x) (Membership.mem ν x))","decl":"@[simp]\ntheorem mem_inf {μ ν : YoungDiagram} {x : ℕ × ℕ} : x ∈ μ ⊓ ν ↔ x ∈ μ ∧ x ∈ ν :=\n  Finset.mem_inter\n\n"}
{"name":"YoungDiagram.cells_bot","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"⊢ Eq Bot.bot.cells EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem cells_bot : (⊥ : YoungDiagram).cells = ∅ :=\n  rfl\n\n"}
{"name":"YoungDiagram.not_mem_bot","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"x : Prod Nat Nat\n⊢ Not (Membership.mem Bot.bot x)","decl":"@[simp]\ntheorem not_mem_bot (x : ℕ × ℕ) : x ∉ (⊥ : YoungDiagram) :=\n  Finset.not_mem_empty x\n\n"}
{"name":"YoungDiagram.coe_bot","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[norm_cast]\ntheorem coe_bot : (⊥ : YoungDiagram) = (∅ : Set (ℕ × ℕ)) := by\n  ext; simp\n\n"}
{"name":"YoungDiagram.mem_transpose","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nc : Prod Nat Nat\n⊢ Iff (Membership.mem μ.transpose c) (Membership.mem μ c.swap)","decl":"@[simp]\ntheorem mem_transpose {μ : YoungDiagram} {c : ℕ × ℕ} : c ∈ μ.transpose ↔ c.swap ∈ μ := by\n  simp [transpose]\n\n"}
{"name":"YoungDiagram.transpose_transpose","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq μ.transpose.transpose μ","decl":"@[simp]\ntheorem transpose_transpose (μ : YoungDiagram) : μ.transpose.transpose = μ := by\n  ext x\n  simp\n\n"}
{"name":"YoungDiagram.transpose_eq_iff_eq_transpose","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Iff (Eq μ.transpose ν) (Eq μ ν.transpose)","decl":"theorem transpose_eq_iff_eq_transpose {μ ν : YoungDiagram} : μ.transpose = ν ↔ μ = ν.transpose := by\n  constructor <;>\n    · rintro rfl\n      simp\n\n"}
{"name":"YoungDiagram.transpose_eq_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Iff (Eq μ.transpose ν.transpose) (Eq μ ν)","decl":"@[simp]\ntheorem transpose_eq_iff {μ ν : YoungDiagram} : μ.transpose = ν.transpose ↔ μ = ν := by\n  rw [transpose_eq_iff_eq_transpose]\n  simp\n\n-- This is effectively both directions of `transpose_le_iff` below.\n"}
{"name":"YoungDiagram.le_of_transpose_le","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\nh_le : LE.le μ.transpose ν\n⊢ LE.le μ ν.transpose","decl":"protected theorem le_of_transpose_le {μ ν : YoungDiagram} (h_le : μ.transpose ≤ ν) :\n    μ ≤ ν.transpose := fun c hc => by\n  simp only [mem_cells, mem_transpose]\n  apply h_le\n  simpa\n\n"}
{"name":"YoungDiagram.transpose_le_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\n⊢ Iff (LE.le μ.transpose ν.transpose) (LE.le μ ν)","decl":"@[simp]\ntheorem transpose_le_iff {μ ν : YoungDiagram} : μ.transpose ≤ ν.transpose ↔ μ ≤ ν :=\n  ⟨fun h => by\n    convert YoungDiagram.le_of_transpose_le h\n    simp, fun h => by\n    rw [← transpose_transpose μ] at h\n    exact YoungDiagram.le_of_transpose_le h ⟩\n\n"}
{"name":"YoungDiagram.transpose_mono","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ ν : YoungDiagram\nh_le : LE.le μ ν\n⊢ LE.le μ.transpose ν.transpose","decl":"@[mono]\nprotected theorem transpose_mono {μ ν : YoungDiagram} (h_le : μ ≤ ν) : μ.transpose ≤ ν.transpose :=\n  transpose_le_iff.mpr h_le\n\n"}
{"name":"YoungDiagram.transposeOrderIso_symm_apply","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq ((RelIso.symm YoungDiagram.transposeOrderIso) μ) μ.transpose","decl":"/-- Transposing Young diagrams is an `OrderIso`. -/\n@[simps]\ndef transposeOrderIso : YoungDiagram ≃o YoungDiagram :=\n  ⟨⟨transpose, transpose, fun _ => by simp, fun _ => by simp⟩, by simp⟩\n\n"}
{"name":"YoungDiagram.transposeOrderIso_apply","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq (YoungDiagram.transposeOrderIso μ) μ.transpose","decl":"/-- Transposing Young diagrams is an `OrderIso`. -/\n@[simps]\ndef transposeOrderIso : YoungDiagram ≃o YoungDiagram :=\n  ⟨⟨transpose, transpose, fun _ => by simp, fun _ => by simp⟩, by simp⟩\n\n"}
{"name":"YoungDiagram.mem_row_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\nc : Prod Nat Nat\n⊢ Iff (Membership.mem (μ.row i) c) (And (Membership.mem μ c) (Eq c.1 i))","decl":"theorem mem_row_iff {μ : YoungDiagram} {i : ℕ} {c : ℕ × ℕ} : c ∈ μ.row i ↔ c ∈ μ ∧ c.fst = i := by\n  simp [row]\n\n"}
{"name":"YoungDiagram.mk_mem_row_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni j : Nat\n⊢ Iff (Membership.mem (μ.row i) { fst := i, snd := j }) (Membership.mem μ { fst := i, snd := j })","decl":"theorem mk_mem_row_iff {μ : YoungDiagram} {i j : ℕ} : (i, j) ∈ μ.row i ↔ (i, j) ∈ μ := by simp [row]\n\n"}
{"name":"YoungDiagram.exists_not_mem_row","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\n⊢ Exists fun j => Not (Membership.mem μ { fst := i, snd := j })","decl":"protected theorem exists_not_mem_row (μ : YoungDiagram) (i : ℕ) : ∃ j, (i, j) ∉ μ := by\n  obtain ⟨j, hj⟩ :=\n    Infinite.exists_not_mem_finset\n      (μ.cells.preimage (Prod.mk i) fun _ _ _ _ h => by\n        cases h\n        rfl)\n  rw [Finset.mem_preimage] at hj\n  exact ⟨j, hj⟩\n\n"}
{"name":"YoungDiagram.mem_iff_lt_rowLen","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni j : Nat\n⊢ Iff (Membership.mem μ { fst := i, snd := j }) (LT.lt j (μ.rowLen i))","decl":"theorem mem_iff_lt_rowLen {μ : YoungDiagram} {i j : ℕ} : (i, j) ∈ μ ↔ j < μ.rowLen i := by\n  rw [rowLen, Nat.lt_find_iff]\n  push_neg\n  exact ⟨fun h _ hmj => μ.up_left_mem (by rfl) hmj h, fun h => h _ (by rfl)⟩\n\n"}
{"name":"YoungDiagram.row_eq_prod","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\n⊢ Eq (μ.row i) (SProd.sprod (Singleton.singleton i) (Finset.range (μ.rowLen i)))","decl":"theorem row_eq_prod {μ : YoungDiagram} {i : ℕ} : μ.row i = {i} ×ˢ Finset.range (μ.rowLen i) := by\n  ext ⟨a, b⟩\n  simp only [Finset.mem_product, Finset.mem_singleton, Finset.mem_range, mem_row_iff,\n    mem_iff_lt_rowLen, and_comm, and_congr_right_iff]\n  rintro rfl\n  rfl\n\n"}
{"name":"YoungDiagram.rowLen_eq_card","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\n⊢ Eq (μ.rowLen i) (μ.row i).card","decl":"theorem rowLen_eq_card (μ : YoungDiagram) {i : ℕ} : μ.rowLen i = (μ.row i).card := by\n  simp [row_eq_prod]\n\n"}
{"name":"YoungDiagram.rowLen_anti","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni1 i2 : Nat\nhi : LE.le i1 i2\n⊢ LE.le (μ.rowLen i2) (μ.rowLen i1)","decl":"@[mono]\ntheorem rowLen_anti (μ : YoungDiagram) (i1 i2 : ℕ) (hi : i1 ≤ i2) : μ.rowLen i2 ≤ μ.rowLen i1 := by\n  by_contra! h_lt\n  rw [← lt_self_iff_false (μ.rowLen i1)]\n  rw [← mem_iff_lt_rowLen] at h_lt ⊢\n  exact μ.up_left_mem hi (by rfl) h_lt\n\n"}
{"name":"YoungDiagram.mem_col_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj : Nat\nc : Prod Nat Nat\n⊢ Iff (Membership.mem (μ.col j) c) (And (Membership.mem μ c) (Eq c.2 j))","decl":"theorem mem_col_iff {μ : YoungDiagram} {j : ℕ} {c : ℕ × ℕ} : c ∈ μ.col j ↔ c ∈ μ ∧ c.snd = j := by\n  simp [col]\n\n"}
{"name":"YoungDiagram.mk_mem_col_iff","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni j : Nat\n⊢ Iff (Membership.mem (μ.col j) { fst := i, snd := j }) (Membership.mem μ { fst := i, snd := j })","decl":"theorem mk_mem_col_iff {μ : YoungDiagram} {i j : ℕ} : (i, j) ∈ μ.col j ↔ (i, j) ∈ μ := by simp [col]\n\n"}
{"name":"YoungDiagram.exists_not_mem_col","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj : Nat\n⊢ Exists fun i => Not (Membership.mem μ.cells { fst := i, snd := j })","decl":"protected theorem exists_not_mem_col (μ : YoungDiagram) (j : ℕ) : ∃ i, (i, j) ∉ μ.cells := by\n  convert μ.transpose.exists_not_mem_row j using 1\n  simp\n\n"}
{"name":"YoungDiagram.colLen_transpose","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj : Nat\n⊢ Eq (μ.transpose.colLen j) (μ.rowLen j)","decl":"@[simp]\ntheorem colLen_transpose (μ : YoungDiagram) (j : ℕ) : μ.transpose.colLen j = μ.rowLen j := by\n  simp [rowLen, colLen]\n\n"}
{"name":"YoungDiagram.rowLen_transpose","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\n⊢ Eq (μ.transpose.rowLen i) (μ.colLen i)","decl":"@[simp]\ntheorem rowLen_transpose (μ : YoungDiagram) (i : ℕ) : μ.transpose.rowLen i = μ.colLen i := by\n  simp [rowLen, colLen]\n\n"}
{"name":"YoungDiagram.mem_iff_lt_colLen","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni j : Nat\n⊢ Iff (Membership.mem μ { fst := i, snd := j }) (LT.lt i (μ.colLen j))","decl":"theorem mem_iff_lt_colLen {μ : YoungDiagram} {i j : ℕ} : (i, j) ∈ μ ↔ i < μ.colLen j := by\n  rw [← rowLen_transpose, ← mem_iff_lt_rowLen]\n  simp\n\n"}
{"name":"YoungDiagram.col_eq_prod","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj : Nat\n⊢ Eq (μ.col j) (SProd.sprod (Finset.range (μ.colLen j)) (Singleton.singleton j))","decl":"theorem col_eq_prod {μ : YoungDiagram} {j : ℕ} : μ.col j = Finset.range (μ.colLen j) ×ˢ {j} := by\n  ext ⟨a, b⟩\n  simp only [Finset.mem_product, Finset.mem_singleton, Finset.mem_range, mem_col_iff,\n    mem_iff_lt_colLen, and_comm, and_congr_right_iff]\n  rintro rfl\n  rfl\n\n"}
{"name":"YoungDiagram.colLen_eq_card","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj : Nat\n⊢ Eq (μ.colLen j) (μ.col j).card","decl":"theorem colLen_eq_card (μ : YoungDiagram) {j : ℕ} : μ.colLen j = (μ.col j).card := by\n  simp [col_eq_prod]\n\n"}
{"name":"YoungDiagram.colLen_anti","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nj1 j2 : Nat\nhj : LE.le j1 j2\n⊢ LE.le (μ.colLen j2) (μ.colLen j1)","decl":"@[mono]\ntheorem colLen_anti (μ : YoungDiagram) (j1 j2 : ℕ) (hj : j1 ≤ j2) : μ.colLen j2 ≤ μ.colLen j1 := by\n  convert μ.transpose.rowLen_anti j1 j2 hj using 1 <;> simp\n\n"}
{"name":"YoungDiagram.get_rowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\ni : Nat\nh : LT.lt i μ.rowLens.length\n⊢ Eq (GetElem.getElem μ.rowLens i ⋯) (μ.rowLen i)","decl":"@[simp]\ntheorem get_rowLens {μ : YoungDiagram} {i : Nat} {h : i < μ.rowLens.length} :\n    μ.rowLens[i] = μ.rowLen i := by simp only [rowLens, List.getElem_range, List.getElem_map]\n\n"}
{"name":"YoungDiagram.length_rowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq μ.rowLens.length (μ.colLen 0)","decl":"@[simp]\ntheorem length_rowLens {μ : YoungDiagram} : μ.rowLens.length = μ.colLen 0 := by\n  simp only [rowLens, List.length_map, List.length_range]\n\n"}
{"name":"YoungDiagram.rowLens_sorted","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ List.Sorted (fun x1 x2 => GE.ge x1 x2) μ.rowLens","decl":"theorem rowLens_sorted (μ : YoungDiagram) : μ.rowLens.Sorted (· ≥ ·) :=\n  (List.pairwise_le_range _).map _ μ.rowLen_anti\n\n"}
{"name":"YoungDiagram.pos_of_mem_rowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\nx : Nat\nhx : Membership.mem μ.rowLens x\n⊢ LT.lt 0 x","decl":"theorem pos_of_mem_rowLens (μ : YoungDiagram) (x : ℕ) (hx : x ∈ μ.rowLens) : 0 < x := by\n  rw [rowLens, List.mem_map] at hx\n  obtain ⟨i, hi, rfl : μ.rowLen i = x⟩ := hx\n  rwa [List.mem_range, ← mem_iff_lt_colLen, mem_iff_lt_rowLen] at hi\n\n"}
{"name":"YoungDiagram.mem_cellsOfRowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"w : List Nat\nc : Prod Nat Nat\n⊢ Iff (Membership.mem (YoungDiagram.cellsOfRowLens w) c) (Exists fun h => LT.lt c.2 (GetElem.getElem w c.1 ⋯))","decl":"protected theorem mem_cellsOfRowLens {w : List ℕ} {c : ℕ × ℕ} :\n    c ∈ YoungDiagram.cellsOfRowLens w ↔ ∃ h : c.fst < w.length, c.snd < w[c.fst] := by\n  induction' w with w_hd w_tl w_ih generalizing c <;> rw [YoungDiagram.cellsOfRowLens]\n  · simp [YoungDiagram.cellsOfRowLens]\n  · rcases c with ⟨⟨_, _⟩, _⟩ <;> simp_all\n\n"}
{"name":"YoungDiagram.mem_ofRowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"w : List Nat\nhw : List.Sorted (fun x1 x2 => GE.ge x1 x2) w\nc : Prod Nat Nat\n⊢ Iff (Membership.mem (YoungDiagram.ofRowLens w hw) c) (Exists fun h => LT.lt c.2 (GetElem.getElem w c.1 ⋯))","decl":"theorem mem_ofRowLens {w : List ℕ} {hw : w.Sorted (· ≥ ·)} {c : ℕ × ℕ} :\n    c ∈ ofRowLens w hw ↔ ∃ h : c.fst < w.length, c.snd < w[c.fst] :=\n  YoungDiagram.mem_cellsOfRowLens\n\n"}
{"name":"YoungDiagram.rowLens_length_ofRowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"w : List Nat\nhw : List.Sorted (fun x1 x2 => GE.ge x1 x2) w\nhpos : ∀ (x : Nat), Membership.mem w x → LT.lt 0 x\n⊢ Eq (YoungDiagram.ofRowLens w hw).rowLens.length w.length","decl":"/-- The number of rows in `ofRowLens w hw` is the length of `w` -/\ntheorem rowLens_length_ofRowLens {w : List ℕ} {hw : w.Sorted (· ≥ ·)} (hpos : ∀ x ∈ w, 0 < x) :\n    (ofRowLens w hw).rowLens.length = w.length := by\n  simp only [length_rowLens, colLen, Nat.find_eq_iff, mem_cells, mem_ofRowLens,\n    lt_self_iff_false, IsEmpty.exists_iff, Classical.not_not]\n  exact ⟨not_false, fun n hn => ⟨hn, hpos _ (List.getElem_mem hn)⟩⟩\n\n"}
{"name":"YoungDiagram.rowLen_ofRowLens","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"w : List Nat\nhw : List.Sorted (fun x1 x2 => GE.ge x1 x2) w\ni : Fin w.length\n⊢ Eq ((YoungDiagram.ofRowLens w hw).rowLen ↑i) (GetElem.getElem w i ⋯)","decl":"/-- The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` -/\ntheorem rowLen_ofRowLens {w : List ℕ} {hw : w.Sorted (· ≥ ·)} (i : Fin w.length) :\n    (ofRowLens w hw).rowLen i = w[i] := by\n  simp [rowLen, Nat.find_eq_iff, mem_ofRowLens]\n\n"}
{"name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq (YoungDiagram.ofRowLens μ.rowLens ⋯) μ","decl":"/-- The left_inv direction of the equivalence -/\ntheorem ofRowLens_to_rowLens_eq_self {μ : YoungDiagram} : ofRowLens _ (rowLens_sorted μ) = μ := by\n  ext ⟨i, j⟩\n  simp only [mem_cells, mem_ofRowLens, length_rowLens, get_rowLens]\n  simpa [← mem_iff_lt_colLen, mem_iff_lt_rowLen] using j.zero_le.trans_lt\n\n"}
{"name":"YoungDiagram.rowLens_ofRowLens_eq_self","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"w : List Nat\nhw : List.Sorted (fun x1 x2 => GE.ge x1 x2) w\nhpos : ∀ (x : Nat), Membership.mem w x → LT.lt 0 x\n⊢ Eq (YoungDiagram.ofRowLens w hw).rowLens w","decl":"/-- The right_inv direction of the equivalence -/\ntheorem rowLens_ofRowLens_eq_self {w : List ℕ} {hw : w.Sorted (· ≥ ·)} (hpos : ∀ x ∈ w, 0 < x) :\n    (ofRowLens w hw).rowLens = w :=\n  List.ext_get (rowLens_length_ofRowLens hpos) fun i h₁ h₂ =>\n    (get_rowLens (h := h₁)).trans <| rowLen_ofRowLens ⟨i, h₂⟩\n\n"}
{"name":"YoungDiagram.equivListRowLens_apply_coe","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"μ : YoungDiagram\n⊢ Eq (↑(YoungDiagram.equivListRowLens μ)) μ.rowLens","decl":"/-- Equivalence between Young diagrams and weakly decreasing lists of positive natural numbers.\nA Young diagram `μ` is equivalent to a list of row lengths. -/\n@[simps]\ndef equivListRowLens : YoungDiagram ≃ { w : List ℕ // w.Sorted (· ≥ ·) ∧ ∀ x ∈ w, 0 < x } where\n  toFun μ := ⟨μ.rowLens, μ.rowLens_sorted, μ.pos_of_mem_rowLens⟩\n  invFun ww := ofRowLens ww.1 ww.2.1\n  left_inv _ := ofRowLens_to_rowLens_eq_self\n  right_inv := fun ⟨_, hw⟩ => Subtype.mk_eq_mk.mpr (rowLens_ofRowLens_eq_self hw.2)\n\n"}
{"name":"YoungDiagram.equivListRowLens_symm_apply","module":"Mathlib.Combinatorics.Young.YoungDiagram","initialProofState":"ww : Subtype fun w => And (List.Sorted (fun x1 x2 => GE.ge x1 x2) w) (∀ (x : Nat), Membership.mem w x → LT.lt 0 x)\n⊢ Eq (YoungDiagram.equivListRowLens.symm ww) (YoungDiagram.ofRowLens ↑ww ⋯)","decl":"/-- Equivalence between Young diagrams and weakly decreasing lists of positive natural numbers.\nA Young diagram `μ` is equivalent to a list of row lengths. -/\n@[simps]\ndef equivListRowLens : YoungDiagram ≃ { w : List ℕ // w.Sorted (· ≥ ·) ∧ ∀ x ∈ w, 0 < x } where\n  toFun μ := ⟨μ.rowLens, μ.rowLens_sorted, μ.pos_of_mem_rowLens⟩\n  invFun ww := ofRowLens ww.1 ww.2.1\n  left_inv _ := ofRowLens_to_rowLens_eq_self\n  right_inv := fun ⟨_, hw⟩ => Subtype.mk_eq_mk.mpr (rowLens_ofRowLens_eq_self hw.2)\n\n"}
