{"name":"AlgebraicGeometry.Scheme.Cover.overEquiv_generate_toPresieveOver_eq_ofArrows","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\nX : CategoryTheory.Over S\nğ’° : AlgebraicGeometry.Scheme.Cover P X.left\ninstâœ : AlgebraicGeometry.Scheme.Cover.Over S ğ’°\nâŠ¢ Eq ((CategoryTheory.Sieve.overEquiv X) (CategoryTheory.Sieve.generate ğ’°.toPresieveOver)) (CategoryTheory.Sieve.ofArrows ğ’°.obj ğ’°.map)","decl":"lemma Cover.overEquiv_generate_toPresieveOver_eq_ofArrows {X : Over S} (ğ’° : Cover.{u} P X.left)\n    [ğ’°.Over S] : Sieve.overEquiv X (Sieve.generate ğ’°.toPresieveOver) =\n      Sieve.ofArrows ğ’°.obj ğ’°.map := by\n  ext V f\n  simp only [Sieve.overEquiv_iff, Functor.const_obj_obj, Sieve.generate_apply]\n  constructor\n  Â· rintro âŸ¨U, h, g, âŸ¨kâŸ©, hcompâŸ©\n    exact âŸ¨ğ’°.obj k, h.left, ğ’°.map k, âŸ¨kâŸ©, congrArg CommaMorphism.left hcompâŸ©\n  Â· rintro âŸ¨U, h, g, âŸ¨kâŸ©, hcompâŸ©\n    have : ğ’°.map k â‰« X.hom = ğ’°.obj k â†˜ S := comp_over (ğ’°.map k) S\n    refine âŸ¨(ğ’°.obj k).asOver S, Over.homMk h (by simp [â† hcomp, this]), (ğ’°.map k).asOver S, âŸ¨kâŸ©, ?_âŸ©\n    ext : 1\n    simpa\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.toPresieveOver_le_arrows_iff","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\nX : CategoryTheory.Over S\nR : CategoryTheory.Sieve X\nğ’° : AlgebraicGeometry.Scheme.Cover P X.left\ninstâœ : AlgebraicGeometry.Scheme.Cover.Over S ğ’°\nâŠ¢ Iff (LE.le ğ’°.toPresieveOver R.arrows) (LE.le (CategoryTheory.Presieve.ofArrows ğ’°.obj ğ’°.map) ((CategoryTheory.Sieve.overEquiv X) R).arrows)","decl":"lemma Cover.toPresieveOver_le_arrows_iff {X : Over S} (R : Sieve X) (ğ’° : Cover.{u} P X.left)\n    [ğ’°.Over S] :\n    ğ’°.toPresieveOver â‰¤ R.arrows â†”\n      Presieve.ofArrows ğ’°.obj ğ’°.map â‰¤ (Sieve.overEquiv X R).arrows := by\n  simp_rw [â† Sieve.giGenerate.gc.le_iff_le, â† Sieve.overEquiv_le_overEquiv_iff]\n  rw [overEquiv_generate_toPresieveOver_eq_ofArrows]\n\n"}
{"name":"AlgebraicGeometry.Scheme.overGrothendieckTopology_eq_toGrothendieck_overPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœÂ³ : P.IsMultiplicative\ninstâœÂ² : P.RespectsIso\ninstâœÂ¹ : P.IsStableUnderBaseChange\ninstâœ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nâŠ¢ Eq (AlgebraicGeometry.Scheme.overGrothendieckTopology P S) (CategoryTheory.Pretopology.toGrothendieck (CategoryTheory.Over S) (AlgebraicGeometry.Scheme.overPretopology P S))","decl":"lemma overGrothendieckTopology_eq_toGrothendieck_overPretopology :\n    S.overGrothendieckTopology P = (S.overPretopology P).toGrothendieck := by\n  ext X R\n  rw [GrothendieckTopology.mem_over_iff, Pretopology.mem_toGrothendieck]\n  constructor\n  Â· rintro âŸ¨T, âŸ¨ğ’°, rflâŸ©, hTâŸ©\n    letI (i : ğ’°.J) : (ğ’°.obj i).Over S := { hom := ğ’°.map i â‰« X.hom }\n    letI : ğ’°.Over S :=\n      { over := inferInstance\n        isOver_map := fun i â†¦ âŸ¨rflâŸ© }\n    use ğ’°.toPresieveOver, âŸ¨ğ’°, inferInstance, rflâŸ©\n    rwa [Cover.toPresieveOver_le_arrows_iff]\n  Â· rintro âŸ¨T, âŸ¨ğ’°, h, rflâŸ©, hTâŸ©\n    use Presieve.ofArrows ğ’°.obj ğ’°.map, âŸ¨ğ’°, rflâŸ©\n    rwa [Cover.toPresieveOver_le_arrows_iff] at hT\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_overGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœÂ³ : P.IsMultiplicative\ninstâœÂ² : P.RespectsIso\ninstâœÂ¹ : P.IsStableUnderBaseChange\ninstâœ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX : CategoryTheory.Over S\nR : CategoryTheory.Sieve X\nâŠ¢ Iff (Membership.mem ((AlgebraicGeometry.Scheme.overGrothendieckTopology P S) X) R) (Exists fun ğ’° => Exists fun x => LE.le ğ’°.toPresieveOver R.arrows)","decl":"lemma mem_overGrothendieckTopology (X : Over S) (R : Sieve X) :\n    R âˆˆ S.overGrothendieckTopology P X â†”\n      âˆƒ (ğ’° : Cover.{u} P X.left) (_ : ğ’°.Over S), ğ’°.toPresieveOver â‰¤ R.arrows := by\n  rw [overGrothendieckTopology_eq_toGrothendieck_overPretopology]\n  constructor\n  Â· rintro âŸ¨T, âŸ¨ğ’°, h, rflâŸ©, hleâŸ©\n    use ğ’°, h\n  Â· rintro âŸ¨ğ’°, hğ’°, hleâŸ©\n    exact âŸ¨ğ’°.toPresieveOver, âŸ¨ğ’°, hğ’°, rflâŸ©, hleâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.locallyCoverDense_of_le","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœâ´ : P.IsMultiplicative\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninstâœ : Q.IsStableUnderComposition\nhPQ : LE.le P Q\nâŠ¢ (CategoryTheory.MorphismProperty.Over.forget Q Top.top S).LocallyCoverDense (AlgebraicGeometry.Scheme.overGrothendieckTopology P S)","decl":"variable (S) {P Q} in\nlemma locallyCoverDense_of_le (hPQ : P â‰¤ Q) :\n    (MorphismProperty.Over.forget Q âŠ¤ S).LocallyCoverDense (overGrothendieckTopology P S) where\n  functorPushforward_functorPullback_mem X := by\n    intro âŸ¨T, hTâŸ©\n    rw [mem_overGrothendieckTopology] at hT âŠ¢\n    obtain âŸ¨ğ’°, h, hleâŸ© := hT\n    use ğ’°, h\n    rintro - - âŸ¨iâŸ©\n    have p : Q (ğ’°.obj i â†˜ S) := by\n      rw [â† comp_over (ğ’°.map i) S]\n      exact Q.comp_mem _ _ (hPQ _ <| ğ’°.map_prop i) X.prop\n    use (ğ’°.obj i).asOverProp S p, MorphismProperty.Over.homMk (ğ’°.map i) (comp_over (ğ’°.map i) S), ğŸ™ _\n    exact âŸ¨hle _ âŸ¨iâŸ©, rflâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.instLocallyCoverDenseOverTopMorphismPropertyOverForgetOverGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœÂ³ : P.IsMultiplicative\ninstâœÂ² : P.RespectsIso\ninstâœÂ¹ : P.IsStableUnderBaseChange\ninstâœ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nâŠ¢ (CategoryTheory.MorphismProperty.Over.forget P Top.top S).LocallyCoverDense (AlgebraicGeometry.Scheme.overGrothendieckTopology P S)","decl":"instance : (MorphismProperty.Over.forget P âŠ¤ S).LocallyCoverDense (overGrothendieckTopology P S) :=\n  locallyCoverDense_of_le S le_rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœâ¶ : P.IsMultiplicative\ninstâœâµ : P.RespectsIso\ninstâœâ´ : P.IsStableUnderBaseChange\ninstâœÂ³ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninstâœÂ² : Q.IsStableUnderComposition\ninstâœÂ¹ : Q.IsStableUnderBaseChange\ninstâœ : Q.HasOfPostcompProperty Q\nhPQ : LE.le P Q\nâŠ¢ Eq (S.smallGrothendieckTopologyOfLE hPQ) (CategoryTheory.Pretopology.toGrothendieck (Q.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P Q))","decl":"variable (S) {P Q} in\nlemma smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology (hPQ : P â‰¤ Q) :\n    S.smallGrothendieckTopologyOfLE hPQ = (S.smallPretopology P Q).toGrothendieck := by\n  ext X R\n  simp only [Pretopology.mem_toGrothendieck, Functor.mem_inducedTopology_sieves_iff,\n    MorphismProperty.Comma.forget_obj, mem_overGrothendieckTopology]\n  constructor\n  Â· intro âŸ¨ğ’°, h, leâŸ©\n    have hj (j : ğ’°.J) : Q (ğ’°.obj j â†˜ S) := by\n      rw [â† comp_over (ğ’°.map j)]\n      exact Q.comp_mem _ _ (hPQ _ <| ğ’°.map_prop _) X.prop\n    refine âŸ¨ğ’°.toPresieveOverProp hj, ?_, ?_âŸ©\n    Â· use ğ’°, h, hj\n    Â· rintro - - âŸ¨iâŸ©\n      let fi : (ğ’°.obj i).asOverProp S (hj i) âŸ¶ X := (ğ’°.map i).asOverProp S\n      have : R.functorPushforward _ ((MorphismProperty.Over.forget Q âŠ¤ S).map fi) := le _ âŸ¨iâŸ©\n      rwa [Sieve.functorPushforward_apply,\n        Sieve.mem_functorPushforward_iff_of_full_of_faithful] at this\n  Â· rintro âŸ¨T, âŸ¨ğ’°, h, p, rflâŸ©, leâŸ©\n    use ğ’°, h\n    rintro - - âŸ¨iâŸ©\n    exact âŸ¨(ğ’°.obj i).asOverProp S (p i), (ğ’°.map i).asOverProp S, ğŸ™ _, le _ âŸ¨iâŸ©, rflâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.smallGrothendieckTopology_eq_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœâ´ : P.IsMultiplicative\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninstâœ : P.HasOfPostcompProperty P\nâŠ¢ Eq (AlgebraicGeometry.Scheme.smallGrothendieckTopology P) (CategoryTheory.Pretopology.toGrothendieck (P.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P P))","decl":"lemma smallGrothendieckTopology_eq_toGrothendieck_smallPretopology [P.HasOfPostcompProperty P] :\n    S.smallGrothendieckTopology P = (S.smallPretopology P P).toGrothendieck :=\n  S.smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology le_rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœâ¶ : P.IsMultiplicative\ninstâœâµ : P.RespectsIso\ninstâœâ´ : P.IsStableUnderBaseChange\ninstâœÂ³ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninstâœÂ² : Q.IsStableUnderComposition\ninstâœÂ¹ : Q.IsStableUnderBaseChange\ninstâœ : Q.HasOfPostcompProperty Q\nX : Q.Over Top.top S\nR : CategoryTheory.Sieve X\nâŠ¢ Iff (Membership.mem ((CategoryTheory.Pretopology.toGrothendieck (Q.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P Q)) X) R) (âˆ€ (x : â†‘â†‘X.left.toPresheafedSpace), Exists fun Y => Exists fun f => Exists fun y => And (R.arrows f) (And (P f.left) (Eq (f.left.base y) x)))","decl":"lemma mem_toGrothendieck_smallPretopology (X : Q.Over âŠ¤ S) (R : Sieve X) :\n    R âˆˆ (S.smallPretopology P Q).toGrothendieck _ X â†”\n      âˆ€ x : X.left, âˆƒ (Y : Q.Over âŠ¤ S) (f : Y âŸ¶ X) (y : Y.left),\n        R f âˆ§ P f.left âˆ§ f.left.base y = x := by\n  rw [Pretopology.mem_toGrothendieck]\n  refine âŸ¨?_, fun h â†¦ ?_âŸ©\n  Â· rintro âŸ¨T, âŸ¨ğ’°, h, p, rflâŸ©, hleâŸ©\n    intro x\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers x\n    refine âŸ¨(ğ’°.obj (ğ’°.f x)).asOverProp S (p _), (ğ’°.map (ğ’°.f x)).asOverProp S, y, hle _ ?_,\n      ğ’°.map_prop _, hyâŸ©\n    use ğ’°.f x\n  Â· choose Y f y hf hP hy using h\n    let ğ’° : X.left.Cover P :=\n      { J := X.left,\n        obj := fun i â†¦ (Y i).left\n        map := fun i â†¦ (f i).left\n        map_prop := hP\n        f := id\n        covers := fun i â†¦ âŸ¨y i, hy iâŸ© }\n    letI : ğ’°.Over S :=\n      { over := fun i â†¦ inferInstance\n        isOver_map := fun i â†¦ inferInstance }\n    refine âŸ¨ğ’°.toPresieveOverProp fun i â†¦ MorphismProperty.Comma.prop _, ?_, ?_âŸ©\n    Â· use ğ’°, inferInstance, fun i â†¦ MorphismProperty.Comma.prop _\n    Â· rintro - - âŸ¨iâŸ©\n      exact hf i\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_smallGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninstâœâ´ : P.IsMultiplicative\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninstâœ : P.HasOfPostcompProperty P\nX : P.Over Top.top S\nR : CategoryTheory.Sieve X\nâŠ¢ Iff (Membership.mem ((AlgebraicGeometry.Scheme.smallGrothendieckTopology P) X) R) (Exists fun ğ’° => Exists fun x => Exists fun h => LE.le (ğ’°.toPresieveOverProp h) R.arrows)","decl":"lemma mem_smallGrothendieckTopology [P.HasOfPostcompProperty P] (X : P.Over âŠ¤ S) (R : Sieve X) :\n    R âˆˆ S.smallGrothendieckTopology P X â†”\n      âˆƒ (ğ’° : Cover.{u} P X.left) (_ : ğ’°.Over S) (h : âˆ€ j, P (ğ’°.obj j â†˜ S)),\n          ğ’°.toPresieveOverProp h â‰¤ R.arrows := by\n  rw [smallGrothendieckTopology_eq_toGrothendieck_smallPretopology]\n  constructor\n  Â· rintro âŸ¨T, âŸ¨ğ’°, h, p, rflâŸ©, hleâŸ©\n    use ğ’°, h, p\n  Â· rintro âŸ¨ğ’°, hğ’°, p, hleâŸ©\n    exact âŸ¨ğ’°.toPresieveOverProp p, âŸ¨ğ’°, hğ’°, p, rflâŸ©, hleâŸ©\n\n"}
