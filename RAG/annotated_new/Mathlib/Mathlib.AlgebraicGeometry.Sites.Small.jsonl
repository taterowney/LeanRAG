{"name":"AlgebraicGeometry.Scheme.Cover.overEquiv_generate_toPresieveOver_eq_ofArrows","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\nX : CategoryTheory.Over S\n𝒰 : AlgebraicGeometry.Scheme.Cover P X.left\ninst✝ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\n⊢ Eq ((CategoryTheory.Sieve.overEquiv X) (CategoryTheory.Sieve.generate 𝒰.toPresieveOver)) (CategoryTheory.Sieve.ofArrows 𝒰.obj 𝒰.map)","decl":"lemma Cover.overEquiv_generate_toPresieveOver_eq_ofArrows {X : Over S} (𝒰 : Cover.{u} P X.left)\n    [𝒰.Over S] : Sieve.overEquiv X (Sieve.generate 𝒰.toPresieveOver) =\n      Sieve.ofArrows 𝒰.obj 𝒰.map := by\n  ext V f\n  simp only [Sieve.overEquiv_iff, Functor.const_obj_obj, Sieve.generate_apply]\n  constructor\n  · rintro ⟨U, h, g, ⟨k⟩, hcomp⟩\n    exact ⟨𝒰.obj k, h.left, 𝒰.map k, ⟨k⟩, congrArg CommaMorphism.left hcomp⟩\n  · rintro ⟨U, h, g, ⟨k⟩, hcomp⟩\n    have : 𝒰.map k ≫ X.hom = 𝒰.obj k ↘ S := comp_over (𝒰.map k) S\n    refine ⟨(𝒰.obj k).asOver S, Over.homMk h (by simp [← hcomp, this]), (𝒰.map k).asOver S, ⟨k⟩, ?_⟩\n    ext : 1\n    simpa\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.toPresieveOver_le_arrows_iff","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\nX : CategoryTheory.Over S\nR : CategoryTheory.Sieve X\n𝒰 : AlgebraicGeometry.Scheme.Cover P X.left\ninst✝ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\n⊢ Iff (LE.le 𝒰.toPresieveOver R.arrows) (LE.le (CategoryTheory.Presieve.ofArrows 𝒰.obj 𝒰.map) ((CategoryTheory.Sieve.overEquiv X) R).arrows)","decl":"lemma Cover.toPresieveOver_le_arrows_iff {X : Over S} (R : Sieve X) (𝒰 : Cover.{u} P X.left)\n    [𝒰.Over S] :\n    𝒰.toPresieveOver ≤ R.arrows ↔\n      Presieve.ofArrows 𝒰.obj 𝒰.map ≤ (Sieve.overEquiv X R).arrows := by\n  simp_rw [← Sieve.giGenerate.gc.le_iff_le, ← Sieve.overEquiv_le_overEquiv_iff]\n  rw [overEquiv_generate_toPresieveOver_eq_ofArrows]\n\n"}
{"name":"AlgebraicGeometry.Scheme.overGrothendieckTopology_eq_toGrothendieck_overPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝³ : P.IsMultiplicative\ninst✝² : P.RespectsIso\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\n⊢ Eq (AlgebraicGeometry.Scheme.overGrothendieckTopology P S) (CategoryTheory.Pretopology.toGrothendieck (CategoryTheory.Over S) (AlgebraicGeometry.Scheme.overPretopology P S))","decl":"lemma overGrothendieckTopology_eq_toGrothendieck_overPretopology :\n    S.overGrothendieckTopology P = (S.overPretopology P).toGrothendieck := by\n  ext X R\n  rw [GrothendieckTopology.mem_over_iff, Pretopology.mem_toGrothendieck]\n  constructor\n  · rintro ⟨T, ⟨𝒰, rfl⟩, hT⟩\n    letI (i : 𝒰.J) : (𝒰.obj i).Over S := { hom := 𝒰.map i ≫ X.hom }\n    letI : 𝒰.Over S :=\n      { over := inferInstance\n        isOver_map := fun i ↦ ⟨rfl⟩ }\n    use 𝒰.toPresieveOver, ⟨𝒰, inferInstance, rfl⟩\n    rwa [Cover.toPresieveOver_le_arrows_iff]\n  · rintro ⟨T, ⟨𝒰, h, rfl⟩, hT⟩\n    use Presieve.ofArrows 𝒰.obj 𝒰.map, ⟨𝒰, rfl⟩\n    rwa [Cover.toPresieveOver_le_arrows_iff] at hT\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_overGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝³ : P.IsMultiplicative\ninst✝² : P.RespectsIso\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX : CategoryTheory.Over S\nR : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((AlgebraicGeometry.Scheme.overGrothendieckTopology P S) X) R) (Exists fun 𝒰 => Exists fun x => LE.le 𝒰.toPresieveOver R.arrows)","decl":"lemma mem_overGrothendieckTopology (X : Over S) (R : Sieve X) :\n    R ∈ S.overGrothendieckTopology P X ↔\n      ∃ (𝒰 : Cover.{u} P X.left) (_ : 𝒰.Over S), 𝒰.toPresieveOver ≤ R.arrows := by\n  rw [overGrothendieckTopology_eq_toGrothendieck_overPretopology]\n  constructor\n  · rintro ⟨T, ⟨𝒰, h, rfl⟩, hle⟩\n    use 𝒰, h\n  · rintro ⟨𝒰, h𝒰, hle⟩\n    exact ⟨𝒰.toPresieveOver, ⟨𝒰, h𝒰, rfl⟩, hle⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.locallyCoverDense_of_le","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁴ : P.IsMultiplicative\ninst✝³ : P.RespectsIso\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninst✝ : Q.IsStableUnderComposition\nhPQ : LE.le P Q\n⊢ (CategoryTheory.MorphismProperty.Over.forget Q Top.top S).LocallyCoverDense (AlgebraicGeometry.Scheme.overGrothendieckTopology P S)","decl":"variable (S) {P Q} in\nlemma locallyCoverDense_of_le (hPQ : P ≤ Q) :\n    (MorphismProperty.Over.forget Q ⊤ S).LocallyCoverDense (overGrothendieckTopology P S) where\n  functorPushforward_functorPullback_mem X := by\n    intro ⟨T, hT⟩\n    rw [mem_overGrothendieckTopology] at hT ⊢\n    obtain ⟨𝒰, h, hle⟩ := hT\n    use 𝒰, h\n    rintro - - ⟨i⟩\n    have p : Q (𝒰.obj i ↘ S) := by\n      rw [← comp_over (𝒰.map i) S]\n      exact Q.comp_mem _ _ (hPQ _ <| 𝒰.map_prop i) X.prop\n    use (𝒰.obj i).asOverProp S p, MorphismProperty.Over.homMk (𝒰.map i) (comp_over (𝒰.map i) S), 𝟙 _\n    exact ⟨hle _ ⟨i⟩, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.instLocallyCoverDenseOverTopMorphismPropertyOverForgetOverGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝³ : P.IsMultiplicative\ninst✝² : P.RespectsIso\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\n⊢ (CategoryTheory.MorphismProperty.Over.forget P Top.top S).LocallyCoverDense (AlgebraicGeometry.Scheme.overGrothendieckTopology P S)","decl":"instance : (MorphismProperty.Over.forget P ⊤ S).LocallyCoverDense (overGrothendieckTopology P S) :=\n  locallyCoverDense_of_le S le_rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁶ : P.IsMultiplicative\ninst✝⁵ : P.RespectsIso\ninst✝⁴ : P.IsStableUnderBaseChange\ninst✝³ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninst✝² : Q.IsStableUnderComposition\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.HasOfPostcompProperty Q\nhPQ : LE.le P Q\n⊢ Eq (S.smallGrothendieckTopologyOfLE hPQ) (CategoryTheory.Pretopology.toGrothendieck (Q.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P Q))","decl":"variable (S) {P Q} in\nlemma smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology (hPQ : P ≤ Q) :\n    S.smallGrothendieckTopologyOfLE hPQ = (S.smallPretopology P Q).toGrothendieck := by\n  ext X R\n  simp only [Pretopology.mem_toGrothendieck, Functor.mem_inducedTopology_sieves_iff,\n    MorphismProperty.Comma.forget_obj, mem_overGrothendieckTopology]\n  constructor\n  · intro ⟨𝒰, h, le⟩\n    have hj (j : 𝒰.J) : Q (𝒰.obj j ↘ S) := by\n      rw [← comp_over (𝒰.map j)]\n      exact Q.comp_mem _ _ (hPQ _ <| 𝒰.map_prop _) X.prop\n    refine ⟨𝒰.toPresieveOverProp hj, ?_, ?_⟩\n    · use 𝒰, h, hj\n    · rintro - - ⟨i⟩\n      let fi : (𝒰.obj i).asOverProp S (hj i) ⟶ X := (𝒰.map i).asOverProp S\n      have : R.functorPushforward _ ((MorphismProperty.Over.forget Q ⊤ S).map fi) := le _ ⟨i⟩\n      rwa [Sieve.functorPushforward_apply,\n        Sieve.mem_functorPushforward_iff_of_full_of_faithful] at this\n  · rintro ⟨T, ⟨𝒰, h, p, rfl⟩, le⟩\n    use 𝒰, h\n    rintro - - ⟨i⟩\n    exact ⟨(𝒰.obj i).asOverProp S (p i), (𝒰.map i).asOverProp S, 𝟙 _, le _ ⟨i⟩, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.smallGrothendieckTopology_eq_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁴ : P.IsMultiplicative\ninst✝³ : P.RespectsIso\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninst✝ : P.HasOfPostcompProperty P\n⊢ Eq (AlgebraicGeometry.Scheme.smallGrothendieckTopology P) (CategoryTheory.Pretopology.toGrothendieck (P.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P P))","decl":"lemma smallGrothendieckTopology_eq_toGrothendieck_smallPretopology [P.HasOfPostcompProperty P] :\n    S.smallGrothendieckTopology P = (S.smallPretopology P P).toGrothendieck :=\n  S.smallGrothendieckTopologyOfLE_eq_toGrothendieck_smallPretopology le_rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_toGrothendieck_smallPretopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁶ : P.IsMultiplicative\ninst✝⁵ : P.RespectsIso\ninst✝⁴ : P.IsStableUnderBaseChange\ninst✝³ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninst✝² : Q.IsStableUnderComposition\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.HasOfPostcompProperty Q\nX : Q.Over Top.top S\nR : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((CategoryTheory.Pretopology.toGrothendieck (Q.Over Top.top S) (AlgebraicGeometry.Scheme.smallPretopology P Q)) X) R) (∀ (x : ↑↑X.left.toPresheafedSpace), Exists fun Y => Exists fun f => Exists fun y => And (R.arrows f) (And (P f.left) (Eq (f.left.base y) x)))","decl":"lemma mem_toGrothendieck_smallPretopology (X : Q.Over ⊤ S) (R : Sieve X) :\n    R ∈ (S.smallPretopology P Q).toGrothendieck _ X ↔\n      ∀ x : X.left, ∃ (Y : Q.Over ⊤ S) (f : Y ⟶ X) (y : Y.left),\n        R f ∧ P f.left ∧ f.left.base y = x := by\n  rw [Pretopology.mem_toGrothendieck]\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨T, ⟨𝒰, h, p, rfl⟩, hle⟩\n    intro x\n    obtain ⟨y, hy⟩ := 𝒰.covers x\n    refine ⟨(𝒰.obj (𝒰.f x)).asOverProp S (p _), (𝒰.map (𝒰.f x)).asOverProp S, y, hle _ ?_,\n      𝒰.map_prop _, hy⟩\n    use 𝒰.f x\n  · choose Y f y hf hP hy using h\n    let 𝒰 : X.left.Cover P :=\n      { J := X.left,\n        obj := fun i ↦ (Y i).left\n        map := fun i ↦ (f i).left\n        map_prop := hP\n        f := id\n        covers := fun i ↦ ⟨y i, hy i⟩ }\n    letI : 𝒰.Over S :=\n      { over := fun i ↦ inferInstance\n        isOver_map := fun i ↦ inferInstance }\n    refine ⟨𝒰.toPresieveOverProp fun i ↦ MorphismProperty.Comma.prop _, ?_, ?_⟩\n    · use 𝒰, inferInstance, fun i ↦ MorphismProperty.Comma.prop _\n    · rintro - - ⟨i⟩\n      exact hf i\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_smallGrothendieckTopology","module":"Mathlib.AlgebraicGeometry.Sites.Small","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁴ : P.IsMultiplicative\ninst✝³ : P.RespectsIso\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\ninst✝ : P.HasOfPostcompProperty P\nX : P.Over Top.top S\nR : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((AlgebraicGeometry.Scheme.smallGrothendieckTopology P) X) R) (Exists fun 𝒰 => Exists fun x => Exists fun h => LE.le (𝒰.toPresieveOverProp h) R.arrows)","decl":"lemma mem_smallGrothendieckTopology [P.HasOfPostcompProperty P] (X : P.Over ⊤ S) (R : Sieve X) :\n    R ∈ S.smallGrothendieckTopology P X ↔\n      ∃ (𝒰 : Cover.{u} P X.left) (_ : 𝒰.Over S) (h : ∀ j, P (𝒰.obj j ↘ S)),\n          𝒰.toPresieveOverProp h ≤ R.arrows := by\n  rw [smallGrothendieckTopology_eq_toGrothendieck_smallPretopology]\n  constructor\n  · rintro ⟨T, ⟨𝒰, h, p, rfl⟩, hle⟩\n    use 𝒰, h, p\n  · rintro ⟨𝒰, h𝒰, p, hle⟩\n    exact ⟨𝒰.toPresieveOverProp p, ⟨𝒰, h𝒰, p, rfl⟩, hle⟩\n\n"}
