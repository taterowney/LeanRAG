{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : HomotopyCategory D (ComplexShape.down Nat)\nh : Quiver.Hom (F.leftDerivedToHomotopyCategory.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).inv (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ)) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedToHomotopyCategoryObj F).inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    (P.isoLeftDerivedToHomotopyCategoryObj F).inv ‚â´ F.leftDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ ‚â´\n        (Q.isoLeftDerivedToHomotopyCategoryObj F).inv := by\n  dsimp [Functor.leftDerivedToHomotopyCategory, isoLeftDerivedToHomotopyCategoryObj]\n  rw [assoc, ‚Üê Functor.map_comp, iso_inv_naturality f P Q œÜ comm, Functor.map_comp]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.down ‚Ñï)).inv.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).inv (F.leftDerivedToHomotopyCategory.map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomotopyCategory.quotient D (ComplexShape.down Nat))).map œÜ) (Q.isoLeftDerivedToHomotopyCategoryObj F).inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    (P.isoLeftDerivedToHomotopyCategoryObj F).inv ‚â´ F.leftDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ ‚â´\n        (Q.isoLeftDerivedToHomotopyCategoryObj F).inv := by\n  dsimp [Functor.leftDerivedToHomotopyCategory, isoLeftDerivedToHomotopyCategoryObj]\n  rw [assoc, ‚Üê Functor.map_comp, iso_inv_naturality f P Q œÜ comm, Functor.map_comp]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.down ‚Ñï)).inv.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) (Q.isoLeftDerivedToHomotopyCategoryObj F).hom) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomotopyCategory.quotient D (ComplexShape.down Nat))).map œÜ))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    F.leftDerivedToHomotopyCategory.map f ‚â´ (Q.isoLeftDerivedToHomotopyCategoryObj F).hom =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ := by\n    dsimp\n    rw [‚Üê cancel_epi (P.isoLeftDerivedToHomotopyCategoryObj F).inv, Iso.inv_hom_id_assoc,\n      isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc f P Q œÜ comm F,\n      Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : HomotopyCategory D (ComplexShape.down Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient D (ComplexShape.down Nat)).obj ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj Q.complex)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedToHomotopyCategoryObj F).hom h)) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ)) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    F.leftDerivedToHomotopyCategory.map f ‚â´ (Q.isoLeftDerivedToHomotopyCategoryObj F).hom =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ := by\n    dsimp\n    rw [‚Üê cancel_epi (P.isoLeftDerivedToHomotopyCategoryObj F).inv, Iso.inv_hom_id_assoc,\n      isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc f P Q œÜ comm F,\n      Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).obj ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj Q.complex)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedObj F n).hom h)) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ)) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (F.leftDerived n).map f ‚â´ (Q.isoLeftDerivedObj F n).hom =\n      (P.isoLeftDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ := by\n  dsimp [isoLeftDerivedObj, Functor.leftDerived]\n  rw [assoc, ‚Üê Functor.map_comp_assoc,\n    ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality f P Q œÜ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ‚Ñï) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) (Q.isoLeftDerivedObj F n).hom) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map œÜ))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (F.leftDerived n).map f ‚â´ (Q.isoLeftDerivedObj F n).hom =\n      (P.isoLeftDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ := by\n  dsimp [isoLeftDerivedObj, Functor.leftDerived]\n  rw [assoc, ‚Üê Functor.map_comp_assoc,\n    ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality f P Q œÜ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ‚Ñï) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((F.leftDerived n).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).inv (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ)) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedObj F n).inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (P.isoLeftDerivedObj F n).inv ‚â´ (F.leftDerived n).map f =\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ ‚â´\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (Q.isoLeftDerivedObj F n).hom, assoc, assoc,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q œÜ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).inv ((F.leftDerived n).map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map œÜ) (Q.isoLeftDerivedObj F n).inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (P.isoLeftDerivedObj F n).inv ‚â´ (F.leftDerived n).map f =\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ ‚â´\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (Q.isoLeftDerivedObj F n).hom, assoc, assoc,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q œÜ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.isZero_leftDerived_obj_projective_succ","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nn : Nat\nX : C\ninst‚úù : CategoryTheory.Projective X\n‚ä¢ CategoryTheory.Limits.IsZero ((F.leftDerived (HAdd.hAdd n 1)).obj X)","decl":"/-- The higher derived functors vanish on projective objects. -/\nlemma Functor.isZero_leftDerived_obj_projective_succ\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) (X : C) [Projective X] :\n    IsZero ((F.leftDerived (n + 1)).obj X) := by\n  refine IsZero.of_iso ?_ ((ProjectiveResolution.self X).isoLeftDerivedObj F (n + 1))\n  erw [‚Üê HomologicalComplex.exactAt_iff_isZero_homology]\n  exact ShortComplex.exact_of_isZero_X‚ÇÇ _ (F.map_isZero (by apply isZero_zero))\n\n"}
{"name":"CategoryTheory.Functor.leftDerived_map_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\ng : Quiver.Hom P.complex Q.complex\nw : Eq (CategoryTheory.CategoryStruct.comp g Q.œÄ) (CategoryTheory.CategoryStruct.comp P.œÄ ((ChainComplex.single‚ÇÄ C).map f))\n‚ä¢ Eq ((F.leftDerived n).map f) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map g) (Q.isoLeftDerivedObj F n).inv))","decl":"/-- We can compute a left derived functor on a morphism using a descent of that morphism\nto a chain map between chosen projective resolutions.\n-/\ntheorem Functor.leftDerived_map_eq (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y)\n    {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : P.complex ‚ü∂ Q.complex)\n    (w : g ‚â´ Q.œÄ = P.œÄ ‚â´ (ChainComplex.single‚ÇÄ C).map f) :\n    (F.leftDerived n).map f =\n      (P.isoLeftDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map g ‚â´\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (Q.isoLeftDerivedObj F n).hom,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q g _ F n,\n    assoc, assoc, Iso.inv_hom_id, comp_id]\n  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,\n    ChainComplex.single‚ÇÄ_map_f_zero]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : G.Additive\nŒ± : Quiver.Hom F G\nX : C\nP : CategoryTheory.ProjectiveResolution X\n‚ä¢ Eq ((CategoryTheory.NatTrans.leftDerivedToHomotopyCategory Œ±).app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± (ComplexShape.down Nat)).app P.complex)) (P.isoLeftDerivedToHomotopyCategoryObj G).inv))","decl":"lemma ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq\n    {F G : C ‚•§ D} [F.Additive] [G.Additive] (Œ± : F ‚ü∂ G) {X : C} (P : ProjectiveResolution X) :\n    (NatTrans.leftDerivedToHomotopyCategory Œ±).app X =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ‚â´\n        (HomotopyCategory.quotient _ _).map\n          ((NatTrans.mapHomologicalComplex Œ± _).app P.complex) ‚â´\n          (P.isoLeftDerivedToHomotopyCategoryObj G).inv := by\n  rw [‚Üê cancel_mono (P.isoLeftDerivedToHomotopyCategoryObj G).hom, assoc, assoc,\n      Iso.inv_hom_id, comp_id]\n  dsimp [isoLeftDerivedToHomotopyCategoryObj, Functor.mapHomotopyCategoryFactors,\n    NatTrans.leftDerivedToHomotopyCategory]\n  rw [assoc]\n  erw [id_comp, comp_id]\n  obtain ‚ü®Œ≤, hŒ≤‚ü© := (HomotopyCategory.quotient _ _).map_surjective (iso P).hom\n  rw [‚Üê hŒ≤]\n  dsimp\n  simp only [‚Üê Functor.map_comp, NatTrans.mapHomologicalComplex_naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.leftDerivedToHomotopyCategory)","decl":"@[simp]\nlemma NatTrans.leftDerivedToHomotopyCategory_id (F : C ‚•§ D) [F.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (ùüô F) = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_comp","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\n‚ä¢ Eq (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory Œ±) (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory Œ≤))","decl":"@[simp, reassoc]\nlemma NatTrans.leftDerivedToHomotopyCategory_comp {F G H : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (Œ± ‚â´ Œ≤) =\n      NatTrans.leftDerivedToHomotopyCategory Œ± ‚â´\n        NatTrans.leftDerivedToHomotopyCategory Œ≤ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nZ : CategoryTheory.Functor C (HomotopyCategory D (ComplexShape.down Nat))\nh : Quiver.Hom H.leftDerivedToHomotopyCategory Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory Œ±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory Œ≤) h))","decl":"@[simp, reassoc]\nlemma NatTrans.leftDerivedToHomotopyCategory_comp {F G H : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (Œ± ‚â´ Œ≤) =\n      NatTrans.leftDerivedToHomotopyCategory Œ± ‚â´\n        NatTrans.leftDerivedToHomotopyCategory Œ≤ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.id F) n) (CategoryTheory.CategoryStruct.id (F.leftDerived n))","decl":"@[simp]\ntheorem NatTrans.leftDerived_id (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    NatTrans.leftDerived (ùüô F) n = ùüô (F.leftDerived n) := by\n  dsimp only [leftDerived]\n  simp only [leftDerivedToHomotopyCategory_id, whiskerRight_id']\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_comp","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nn : Nat\n‚ä¢ Eq (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.comp Œ± Œ≤) n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived Œ± n) (CategoryTheory.NatTrans.leftDerived Œ≤ n))","decl":"@[simp, reassoc]\ntheorem NatTrans.leftDerived_comp {F G H : C ‚•§ D} [F.Additive] [G.Additive] [H.Additive]\n    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (n : ‚Ñï) :\n    NatTrans.leftDerived (Œ± ‚â´ Œ≤) n = NatTrans.leftDerived Œ± n ‚â´ NatTrans.leftDerived Œ≤ n := by\n  simp [NatTrans.leftDerived]\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nn : Nat\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.leftDerived n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.comp Œ± Œ≤) n) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived Œ± n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived Œ≤ n) h))","decl":"@[simp, reassoc]\ntheorem NatTrans.leftDerived_comp {F G H : C ‚•§ D} [F.Additive] [G.Additive] [H.Additive]\n    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (n : ‚Ñï) :\n    NatTrans.leftDerived (Œ± ‚â´ Œ≤) n = NatTrans.leftDerived Œ± n ‚â´ NatTrans.leftDerived Œ≤ n := by\n  simp [NatTrans.leftDerived]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.leftDerived_app_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : G.Additive\nŒ± : Quiver.Hom F G\nX : C\nP : CategoryTheory.ProjectiveResolution X\nn : Nat\n‚ä¢ Eq ((CategoryTheory.NatTrans.leftDerived Œ± n).app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± (ComplexShape.down Nat)).app P.complex)) (P.isoLeftDerivedObj G n).inv))","decl":"/-- A component of the natural transformation between left-derived functors can be computed\nusing a chosen projective resolution. -/\nlemma leftDerived_app_eq\n    {F G : C ‚•§ D} [F.Additive] [G.Additive] (Œ± : F ‚ü∂ G) {X : C} (P : ProjectiveResolution X)\n    (n : ‚Ñï) : (NatTrans.leftDerived Œ± n).app X =\n      (P.isoLeftDerivedObj F n).hom ‚â´\n        (HomologicalComplex.homologyFunctor D (ComplexShape.down ‚Ñï) n).map\n        ((NatTrans.mapHomologicalComplex Œ± _).app P.complex) ‚â´\n        (P.isoLeftDerivedObj G n).inv := by\n  dsimp [NatTrans.leftDerived, isoLeftDerivedObj]\n  rw [ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq Œ± P,\n    Functor.map_comp, Functor.map_comp, assoc]\n  erw [‚Üê (HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ‚Ñï) n).hom.naturality_assoc\n    ((NatTrans.mapHomologicalComplex Œ± (ComplexShape.down ‚Ñï)).app P.complex)]\n  simp only [Functor.comp_map, Iso.hom_inv_id_app_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.pOpcycles_comp_fromLeftDerivedZero'_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex).pOpcycles 0) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (F.map (P.œÄ.f 0)) h)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_fromLeftDerivedZero' {C} [Category C] [Abelian C] {X : C}\n    (P : ProjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    HomologicalComplex.pOpcycles _ _ ‚â´ P.fromLeftDerivedZero' F = F.map (P.œÄ.f 0) := by\n  simp [fromLeftDerivedZero']\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.pOpcycles_comp_fromLeftDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex).pOpcycles 0) (P.fromLeftDerivedZero' F)) (F.map (P.œÄ.f 0))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_fromLeftDerivedZero' {C} [Category C] [Abelian C] {X : C}\n    (P : ProjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    HomologicalComplex.pOpcycles _ _ ‚â´ P.fromLeftDerivedZero' F = F.map (P.œÄ.f 0) := by\n  simp [fromLeftDerivedZero']\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero'_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ) 0) (Q.fromLeftDerivedZero' F)) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) (F.map f))","decl":"@[reassoc]\nlemma fromLeftDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex _).map œÜ) 0 ‚â´\n        Q.fromLeftDerivedZero' F = P.fromLeftDerivedZero' F ‚â´ F.map f := by\n  simp only [‚Üê cancel_epi (HomologicalComplex.pOpcycles _ _), ‚Üê F.map_comp, comm,\n    HomologicalComplex.p_opcyclesMap_assoc, Functor.mapHomologicalComplex_map_f,\n    pOpcycles_comp_fromLeftDerivedZero', pOpcycles_comp_fromLeftDerivedZero'_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero'_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nœÜ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (œÜ.f 0) (Q.œÄ.f 0)) (CategoryTheory.CategoryStruct.comp (P.œÄ.f 0) f)\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex (ComplexShape.down Nat)).map œÜ) 0) (CategoryTheory.CategoryStruct.comp (Q.fromLeftDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) (CategoryTheory.CategoryStruct.comp (F.map f) h))","decl":"@[reassoc]\nlemma fromLeftDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ‚ü∂ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (œÜ : P.complex ‚ü∂ Q.complex) (comm : œÜ.f 0 ‚â´ Q.œÄ.f 0 = P.œÄ.f 0 ‚â´ f)\n    (F : C ‚•§ D) [F.Additive] :\n    HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex _).map œÜ) 0 ‚â´\n        Q.fromLeftDerivedZero' F = P.fromLeftDerivedZero' F ‚â´ F.map f := by\n  simp only [‚Üê cancel_epi (HomologicalComplex.pOpcycles _ _), ‚Üê F.map_comp, comm,\n    HomologicalComplex.p_opcyclesMap_assoc, Functor.mapHomologicalComplex_map_f,\n    pOpcycles_comp_fromLeftDerivedZero', pOpcycles_comp_fromLeftDerivedZero'_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instIsIsoFromLeftDerivedZero'Self","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nX : C\ninst‚úù : CategoryTheory.Projective X\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.ProjectiveResolution.self X).fromLeftDerivedZero' F)","decl":"instance (F : C ‚•§ D) [F.Additive] (X : C) [Projective X] :\n    IsIso ((ProjectiveResolution.self X).fromLeftDerivedZero' F) := by\n  dsimp [ProjectiveResolution.fromLeftDerivedZero']\n  rw [ChainComplex.isIso_descOpcycles_iff]\n  refine ‚ü®ShortComplex.Splitting.exact ?_, inferInstance‚ü©\n  exact\n    { r := 0\n      s := ùüô _\n      f_r := (F.map_isZero (isZero_zero _)).eq_of_src _ _ }\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (F.fromLeftDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F 0).hom (CategoryTheory.CategoryStruct.comp (ChainComplex.isoHomologyŒπ‚ÇÄ ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex)).hom (P.fromLeftDerivedZero' F)))","decl":"lemma ProjectiveResolution.fromLeftDerivedZero_eq\n    {X : C} (P : ProjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    F.fromLeftDerivedZero.app X = (P.isoLeftDerivedObj F 0).hom ‚â´\n      (ChainComplex.isoHomologyŒπ‚ÇÄ _).hom ‚â´\n        P.fromLeftDerivedZero' F := by\n  dsimp [Functor.fromLeftDerivedZero, isoLeftDerivedObj]\n  have h‚ÇÅ := ProjectiveResolution.fromLeftDerivedZero'_naturality\n    (ùüô X) P (projectiveResolution X) (lift (ùüô X) _ _) (by simp) F\n  have h‚ÇÇ : (P.isoLeftDerivedToHomotopyCategoryObj F).inv =\n    (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map (lift (ùüô X) _ _) :=\n      id_comp _\n  simp only [Functor.map_id, comp_id] at h‚ÇÅ\n  rw [assoc, ‚Üê cancel_epi ((HomotopyCategory.homologyFunctor _ _ 0).map\n      (P.isoLeftDerivedToHomotopyCategoryObj F).inv), ‚Üê Functor.map_comp_assoc,\n      Iso.inv_hom_id, Functor.map_id, id_comp, ‚Üê h‚ÇÅ, h‚ÇÇ,\n      ‚Üê HomologicalComplex.homologyŒπ_naturality_assoc]\n  erw [‚Üê NatTrans.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.instIsIsoAppFromLeftDerivedZeroOfProjective","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nX : C\ninst‚úù : CategoryTheory.Projective X\n‚ä¢ CategoryTheory.IsIso (F.fromLeftDerivedZero.app X)","decl":"instance (F : C ‚•§ D) [F.Additive] (X : C) [Projective X] :\n    IsIso (F.fromLeftDerivedZero.app X) := by\n  rw [(ProjectiveResolution.self X).fromLeftDerivedZero_eq F]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFromLeftDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\nP : CategoryTheory.ProjectiveResolution X\n‚ä¢ CategoryTheory.IsIso (P.fromLeftDerivedZero' F)","decl":"instance {X : C} (P : ProjectiveResolution X) :\n    IsIso (P.fromLeftDerivedZero' F) := by\n  dsimp [ProjectiveResolution.fromLeftDerivedZero']\n  rw [ChainComplex.isIso_descOpcycles_iff, ShortComplex.exact_and_epi_g_iff_g_is_cokernel]\n  exact ‚ü®CokernelCofork.mapIsColimit _ (P.isColimitCokernelCofork) F‚ü©\n\n"}
{"name":"CategoryTheory.instIsIsoAppFromLeftDerivedZero","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\n‚ä¢ CategoryTheory.IsIso (F.fromLeftDerivedZero.app X)","decl":"instance (X : C) : IsIso (F.fromLeftDerivedZero.app X) := by\n  dsimp [Functor.fromLeftDerivedZero]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorFromLeftDerivedZero","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ CategoryTheory.IsIso F.fromLeftDerivedZero","decl":"instance : IsIso F.fromLeftDerivedZero :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq F.leftDerivedZeroIsoSelf.hom F.fromLeftDerivedZero","decl":"/-- The canonical isomorphism `F.leftDerived 0 ‚âÖ F` when `F` is right exact\n(i.e. preserves finite colimits). -/\n@[simps! hom]\nnoncomputable def leftDerivedZeroIsoSelf : F.leftDerived 0 ‚âÖ F :=\n  (asIso F.fromLeftDerivedZero)\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.leftDerived 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id :\n    F.fromLeftDerivedZero ‚â´ F.leftDerivedZeroIsoSelf.inv = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero F.leftDerivedZeroIsoSelf.inv) (CategoryTheory.CategoryStruct.id (F.leftDerived 0))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id :\n    F.fromLeftDerivedZero ‚â´ F.leftDerivedZeroIsoSelf.inv = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom F Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id :\n    F.leftDerivedZeroIsoSelf.inv ‚â´ F.fromLeftDerivedZero =  ùüô _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv F.fromLeftDerivedZero) (CategoryTheory.CategoryStruct.id F)","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id :\n    F.leftDerivedZeroIsoSelf.inv ‚â´ F.fromLeftDerivedZero =  ùüô _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_app","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) (F.leftDerivedZeroIsoSelf.inv.app X)) (CategoryTheory.CategoryStruct.id ((F.leftDerived 0).obj X))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.fromLeftDerivedZero.app X ‚â´ F.leftDerivedZeroIsoSelf.inv.app X = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\nZ : D\nh : Quiver.Hom ((F.leftDerived 0).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.fromLeftDerivedZero.app X ‚â´ F.leftDerivedZeroIsoSelf.inv.app X = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_app","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) (F.fromLeftDerivedZero.app X)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.leftDerivedZeroIsoSelf.inv.app X ‚â´ F.fromLeftDerivedZero.app X = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasProjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.leftDerivedZeroIsoSelf.inv.app X ‚â´ F.fromLeftDerivedZero.app X = ùüô _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
