{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : HomotopyCategory D (ComplexShape.down Nat)\nh : Quiver.Hom (F.leftDerivedToHomotopyCategory.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).inv (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ)) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedToHomotopyCategoryObj F).inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    (P.isoLeftDerivedToHomotopyCategoryObj F).inv ≫ F.leftDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ ≫\n        (Q.isoLeftDerivedToHomotopyCategoryObj F).inv := by\n  dsimp [Functor.leftDerivedToHomotopyCategory, isoLeftDerivedToHomotopyCategoryObj]\n  rw [assoc, ← Functor.map_comp, iso_inv_naturality f P Q φ comm, Functor.map_comp]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.down ℕ)).inv.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).inv (F.leftDerivedToHomotopyCategory.map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomotopyCategory.quotient D (ComplexShape.down Nat))).map φ) (Q.isoLeftDerivedToHomotopyCategoryObj F).inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    (P.isoLeftDerivedToHomotopyCategoryObj F).inv ≫ F.leftDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ ≫\n        (Q.isoLeftDerivedToHomotopyCategoryObj F).inv := by\n  dsimp [Functor.leftDerivedToHomotopyCategory, isoLeftDerivedToHomotopyCategoryObj]\n  rw [assoc, ← Functor.map_comp, iso_inv_naturality f P Q φ comm, Functor.map_comp]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.down ℕ)).inv.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) (Q.isoLeftDerivedToHomotopyCategoryObj F).hom) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomotopyCategory.quotient D (ComplexShape.down Nat))).map φ))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    F.leftDerivedToHomotopyCategory.map f ≫ (Q.isoLeftDerivedToHomotopyCategoryObj F).hom =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ := by\n    dsimp\n    rw [← cancel_epi (P.isoLeftDerivedToHomotopyCategoryObj F).inv, Iso.inv_hom_id_assoc,\n      isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc f P Q φ comm F,\n      Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : HomotopyCategory D (ComplexShape.down Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient D (ComplexShape.down Nat)).obj ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj Q.complex)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedToHomotopyCategory.map f) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedToHomotopyCategoryObj F).hom h)) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ)) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    F.leftDerivedToHomotopyCategory.map f ≫ (Q.isoLeftDerivedToHomotopyCategoryObj F).hom =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ := by\n    dsimp\n    rw [← cancel_epi (P.isoLeftDerivedToHomotopyCategoryObj F).inv, Iso.inv_hom_id_assoc,\n      isoLeftDerivedToHomotopyCategoryObj_inv_naturality_assoc f P Q φ comm F,\n      Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).obj ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj Q.complex)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedObj F n).hom h)) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ)) h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (F.leftDerived n).map f ≫ (Q.isoLeftDerivedObj F n).hom =\n      (P.isoLeftDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ := by\n  dsimp [isoLeftDerivedObj, Functor.leftDerived]\n  rw [assoc, ← Functor.map_comp_assoc,\n    ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality f P Q φ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ℕ) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) (Q.isoLeftDerivedObj F n).hom) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map φ))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (F.leftDerived n).map f ≫ (Q.isoLeftDerivedObj F n).hom =\n      (P.isoLeftDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ := by\n  dsimp [isoLeftDerivedObj, Functor.leftDerived]\n  rw [assoc, ← Functor.map_comp_assoc,\n    ProjectiveResolution.isoLeftDerivedToHomotopyCategoryObj_hom_naturality f P Q φ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ℕ) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((F.leftDerived n).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).inv (CategoryTheory.CategoryStruct.comp ((F.leftDerived n).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ)) (CategoryTheory.CategoryStruct.comp (Q.isoLeftDerivedObj F n).inv h))","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (P.isoLeftDerivedObj F n).inv ≫ (F.leftDerived n).map f =\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ ≫\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [← cancel_mono (Q.isoLeftDerivedObj F n).hom, assoc, assoc,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q φ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.isoLeftDerivedObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).inv ((F.leftDerived n).map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map φ) (Q.isoLeftDerivedObj F n).inv)","decl":"@[reassoc]\nlemma ProjectiveResolution.isoLeftDerivedObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (P.isoLeftDerivedObj F n).inv ≫ (F.leftDerived n).map f =\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ ≫\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [← cancel_mono (Q.isoLeftDerivedObj F n).hom, assoc, assoc,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q φ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.isZero_leftDerived_obj_projective_succ","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nn : Nat\nX : C\ninst✝ : CategoryTheory.Projective X\n⊢ CategoryTheory.Limits.IsZero ((F.leftDerived (HAdd.hAdd n 1)).obj X)","decl":"/-- The higher derived functors vanish on projective objects. -/\nlemma Functor.isZero_leftDerived_obj_projective_succ\n    (F : C ⥤ D) [F.Additive] (n : ℕ) (X : C) [Projective X] :\n    IsZero ((F.leftDerived (n + 1)).obj X) := by\n  refine IsZero.of_iso ?_ ((ProjectiveResolution.self X).isoLeftDerivedObj F (n + 1))\n  erw [← HomologicalComplex.exactAt_iff_isZero_homology]\n  exact ShortComplex.exact_of_isZero_X₂ _ (F.map_isZero (by apply isZero_zero))\n\n"}
{"name":"CategoryTheory.Functor.leftDerived_map_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\ng : Quiver.Hom P.complex Q.complex\nw : Eq (CategoryTheory.CategoryStruct.comp g Q.π) (CategoryTheory.CategoryStruct.comp P.π ((ChainComplex.single₀ C).map f))\n⊢ Eq ((F.leftDerived n).map f) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n)).map g) (Q.isoLeftDerivedObj F n).inv))","decl":"/-- We can compute a left derived functor on a morphism using a descent of that morphism\nto a chain map between chosen projective resolutions.\n-/\ntheorem Functor.leftDerived_map_eq (F : C ⥤ D) [F.Additive] (n : ℕ) {X Y : C} (f : X ⟶ Y)\n    {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : P.complex ⟶ Q.complex)\n    (w : g ≫ Q.π = P.π ≫ (ChainComplex.single₀ C).map f) :\n    (F.leftDerived n).map f =\n      (P.isoLeftDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map g ≫\n          (Q.isoLeftDerivedObj F n).inv := by\n  rw [← cancel_mono (Q.isoLeftDerivedObj F n).hom,\n    ProjectiveResolution.isoLeftDerivedObj_hom_naturality f P Q g _ F n,\n    assoc, assoc, Iso.inv_hom_id, comp_id]\n  rw [← HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,\n    ChainComplex.single₀_map_f_zero]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : G.Additive\nα : Quiver.Hom F G\nX : C\nP : CategoryTheory.ProjectiveResolution X\n⊢ Eq ((CategoryTheory.NatTrans.leftDerivedToHomotopyCategory α).app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.down Nat)).map ((CategoryTheory.NatTrans.mapHomologicalComplex α (ComplexShape.down Nat)).app P.complex)) (P.isoLeftDerivedToHomotopyCategoryObj G).inv))","decl":"lemma ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq\n    {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) {X : C} (P : ProjectiveResolution X) :\n    (NatTrans.leftDerivedToHomotopyCategory α).app X =\n      (P.isoLeftDerivedToHomotopyCategoryObj F).hom ≫\n        (HomotopyCategory.quotient _ _).map\n          ((NatTrans.mapHomologicalComplex α _).app P.complex) ≫\n          (P.isoLeftDerivedToHomotopyCategoryObj G).inv := by\n  rw [← cancel_mono (P.isoLeftDerivedToHomotopyCategoryObj G).hom, assoc, assoc,\n      Iso.inv_hom_id, comp_id]\n  dsimp [isoLeftDerivedToHomotopyCategoryObj, Functor.mapHomotopyCategoryFactors,\n    NatTrans.leftDerivedToHomotopyCategory]\n  rw [assoc]\n  erw [id_comp, comp_id]\n  obtain ⟨β, hβ⟩ := (HomotopyCategory.quotient _ _).map_surjective (iso P).hom\n  rw [← hβ]\n  dsimp\n  simp only [← Functor.map_comp, NatTrans.mapHomologicalComplex_naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.leftDerivedToHomotopyCategory)","decl":"@[simp]\nlemma NatTrans.leftDerivedToHomotopyCategory_id (F : C ⥤ D) [F.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (𝟙 F) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_comp","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasProjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\n⊢ Eq (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp α β)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory α) (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory β))","decl":"@[simp, reassoc]\nlemma NatTrans.leftDerivedToHomotopyCategory_comp {F G H : C ⥤ D} (α : F ⟶ G) (β : G ⟶ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (α ≫ β) =\n      NatTrans.leftDerivedToHomotopyCategory α ≫\n        NatTrans.leftDerivedToHomotopyCategory β := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerivedToHomotopyCategory_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasProjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nZ : CategoryTheory.Functor C (HomotopyCategory D (ComplexShape.down Nat))\nh : Quiver.Hom H.leftDerivedToHomotopyCategory Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp α β)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerivedToHomotopyCategory β) h))","decl":"@[simp, reassoc]\nlemma NatTrans.leftDerivedToHomotopyCategory_comp {F G H : C ⥤ D} (α : F ⟶ G) (β : G ⟶ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.leftDerivedToHomotopyCategory (α ≫ β) =\n      NatTrans.leftDerivedToHomotopyCategory α ≫\n        NatTrans.leftDerivedToHomotopyCategory β := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.id F) n) (CategoryTheory.CategoryStruct.id (F.leftDerived n))","decl":"@[simp]\ntheorem NatTrans.leftDerived_id (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    NatTrans.leftDerived (𝟙 F) n = 𝟙 (F.leftDerived n) := by\n  dsimp only [leftDerived]\n  simp only [leftDerivedToHomotopyCategory_id, whiskerRight_id']\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_comp","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasProjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nn : Nat\n⊢ Eq (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.comp α β) n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived α n) (CategoryTheory.NatTrans.leftDerived β n))","decl":"@[simp, reassoc]\ntheorem NatTrans.leftDerived_comp {F G H : C ⥤ D} [F.Additive] [G.Additive] [H.Additive]\n    (α : F ⟶ G) (β : G ⟶ H) (n : ℕ) :\n    NatTrans.leftDerived (α ≫ β) n = NatTrans.leftDerived α n ≫ NatTrans.leftDerived β n := by\n  simp [NatTrans.leftDerived]\n\n"}
{"name":"CategoryTheory.NatTrans.leftDerived_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasProjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nn : Nat\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.leftDerived n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived (CategoryTheory.CategoryStruct.comp α β) n) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived α n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftDerived β n) h))","decl":"@[simp, reassoc]\ntheorem NatTrans.leftDerived_comp {F G H : C ⥤ D} [F.Additive] [G.Additive] [H.Additive]\n    (α : F ⟶ G) (β : G ⟶ H) (n : ℕ) :\n    NatTrans.leftDerived (α ≫ β) n = NatTrans.leftDerived α n ≫ NatTrans.leftDerived β n := by\n  simp [NatTrans.leftDerived]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.leftDerived_app_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : G.Additive\nα : Quiver.Hom F G\nX : C\nP : CategoryTheory.ProjectiveResolution X\nn : Nat\n⊢ Eq ((CategoryTheory.NatTrans.leftDerived α n).app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.down Nat) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex α (ComplexShape.down Nat)).app P.complex)) (P.isoLeftDerivedObj G n).inv))","decl":"/-- A component of the natural transformation between left-derived functors can be computed\nusing a chosen projective resolution. -/\nlemma leftDerived_app_eq\n    {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) {X : C} (P : ProjectiveResolution X)\n    (n : ℕ) : (NatTrans.leftDerived α n).app X =\n      (P.isoLeftDerivedObj F n).hom ≫\n        (HomologicalComplex.homologyFunctor D (ComplexShape.down ℕ) n).map\n        ((NatTrans.mapHomologicalComplex α _).app P.complex) ≫\n        (P.isoLeftDerivedObj G n).inv := by\n  dsimp [NatTrans.leftDerived, isoLeftDerivedObj]\n  rw [ProjectiveResolution.leftDerivedToHomotopyCategory_app_eq α P,\n    Functor.map_comp, Functor.map_comp, assoc]\n  erw [← (HomotopyCategory.homologyFunctorFactors D (ComplexShape.down ℕ) n).hom.naturality_assoc\n    ((NatTrans.mapHomologicalComplex α (ComplexShape.down ℕ)).app P.complex)]\n  simp only [Functor.comp_map, Iso.hom_inv_id_app_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.pOpcycles_comp_fromLeftDerivedZero'_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex).pOpcycles 0) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (F.map (P.π.f 0)) h)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_fromLeftDerivedZero' {C} [Category C] [Abelian C] {X : C}\n    (P : ProjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    HomologicalComplex.pOpcycles _ _ ≫ P.fromLeftDerivedZero' F = F.map (P.π.f 0) := by\n  simp [fromLeftDerivedZero']\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.pOpcycles_comp_fromLeftDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex).pOpcycles 0) (P.fromLeftDerivedZero' F)) (F.map (P.π.f 0))","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_fromLeftDerivedZero' {C} [Category C] [Abelian C] {X : C}\n    (P : ProjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    HomologicalComplex.pOpcycles _ _ ≫ P.fromLeftDerivedZero' F = F.map (P.π.f 0) := by\n  simp [fromLeftDerivedZero']\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero'_naturality","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ) 0) (Q.fromLeftDerivedZero' F)) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) (F.map f))","decl":"@[reassoc]\nlemma fromLeftDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex _).map φ) 0 ≫\n        Q.fromLeftDerivedZero' F = P.fromLeftDerivedZero' F ≫ F.map f := by\n  simp only [← cancel_epi (HomologicalComplex.pOpcycles _ _), ← F.map_comp, comm,\n    HomologicalComplex.p_opcyclesMap_assoc, Functor.mapHomologicalComplex_map_f,\n    pOpcycles_comp_fromLeftDerivedZero', pOpcycles_comp_fromLeftDerivedZero'_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero'_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.ProjectiveResolution X\nQ : CategoryTheory.ProjectiveResolution Y\nφ : Quiver.Hom P.complex Q.complex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (φ.f 0) (Q.π.f 0)) (CategoryTheory.CategoryStruct.comp (P.π.f 0) f)\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex (ComplexShape.down Nat)).map φ) 0) (CategoryTheory.CategoryStruct.comp (Q.fromLeftDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (P.fromLeftDerivedZero' F) (CategoryTheory.CategoryStruct.comp (F.map f) h))","decl":"@[reassoc]\nlemma fromLeftDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ⟶ Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y)\n    (φ : P.complex ⟶ Q.complex) (comm : φ.f 0 ≫ Q.π.f 0 = P.π.f 0 ≫ f)\n    (F : C ⥤ D) [F.Additive] :\n    HomologicalComplex.opcyclesMap ((F.mapHomologicalComplex _).map φ) 0 ≫\n        Q.fromLeftDerivedZero' F = P.fromLeftDerivedZero' F ≫ F.map f := by\n  simp only [← cancel_epi (HomologicalComplex.pOpcycles _ _), ← F.map_comp, comm,\n    HomologicalComplex.p_opcyclesMap_assoc, Functor.mapHomologicalComplex_map_f,\n    pOpcycles_comp_fromLeftDerivedZero', pOpcycles_comp_fromLeftDerivedZero'_assoc]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instIsIsoFromLeftDerivedZero'Self","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nX : C\ninst✝ : CategoryTheory.Projective X\n⊢ CategoryTheory.IsIso ((CategoryTheory.ProjectiveResolution.self X).fromLeftDerivedZero' F)","decl":"instance (F : C ⥤ D) [F.Additive] (X : C) [Projective X] :\n    IsIso ((ProjectiveResolution.self X).fromLeftDerivedZero' F) := by\n  dsimp [ProjectiveResolution.fromLeftDerivedZero']\n  rw [ChainComplex.isIso_descOpcycles_iff]\n  refine ⟨ShortComplex.Splitting.exact ?_, inferInstance⟩\n  exact\n    { r := 0\n      s := 𝟙 _\n      f_r := (F.map_isZero (isZero_zero _)).eq_of_src _ _ }\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.fromLeftDerivedZero_eq","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX : C\nP : CategoryTheory.ProjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (F.fromLeftDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (P.isoLeftDerivedObj F 0).hom (CategoryTheory.CategoryStruct.comp (ChainComplex.isoHomologyι₀ ((F.mapHomologicalComplex (ComplexShape.down Nat)).obj P.complex)).hom (P.fromLeftDerivedZero' F)))","decl":"lemma ProjectiveResolution.fromLeftDerivedZero_eq\n    {X : C} (P : ProjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    F.fromLeftDerivedZero.app X = (P.isoLeftDerivedObj F 0).hom ≫\n      (ChainComplex.isoHomologyι₀ _).hom ≫\n        P.fromLeftDerivedZero' F := by\n  dsimp [Functor.fromLeftDerivedZero, isoLeftDerivedObj]\n  have h₁ := ProjectiveResolution.fromLeftDerivedZero'_naturality\n    (𝟙 X) P (projectiveResolution X) (lift (𝟙 X) _ _) (by simp) F\n  have h₂ : (P.isoLeftDerivedToHomotopyCategoryObj F).inv =\n    (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map (lift (𝟙 X) _ _) :=\n      id_comp _\n  simp only [Functor.map_id, comp_id] at h₁\n  rw [assoc, ← cancel_epi ((HomotopyCategory.homologyFunctor _ _ 0).map\n      (P.isoLeftDerivedToHomotopyCategoryObj F).inv), ← Functor.map_comp_assoc,\n      Iso.inv_hom_id, Functor.map_id, id_comp, ← h₁, h₂,\n      ← HomologicalComplex.homologyι_naturality_assoc]\n  erw [← NatTrans.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.instIsIsoAppFromLeftDerivedZeroOfProjective","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nX : C\ninst✝ : CategoryTheory.Projective X\n⊢ CategoryTheory.IsIso (F.fromLeftDerivedZero.app X)","decl":"instance (F : C ⥤ D) [F.Additive] (X : C) [Projective X] :\n    IsIso (F.fromLeftDerivedZero.app X) := by\n  rw [(ProjectiveResolution.self X).fromLeftDerivedZero_eq F]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFromLeftDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\nP : CategoryTheory.ProjectiveResolution X\n⊢ CategoryTheory.IsIso (P.fromLeftDerivedZero' F)","decl":"instance {X : C} (P : ProjectiveResolution X) :\n    IsIso (P.fromLeftDerivedZero' F) := by\n  dsimp [ProjectiveResolution.fromLeftDerivedZero']\n  rw [ChainComplex.isIso_descOpcycles_iff, ShortComplex.exact_and_epi_g_iff_g_is_cokernel]\n  exact ⟨CokernelCofork.mapIsColimit _ (P.isColimitCokernelCofork) F⟩\n\n"}
{"name":"CategoryTheory.instIsIsoAppFromLeftDerivedZero","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\n⊢ CategoryTheory.IsIso (F.fromLeftDerivedZero.app X)","decl":"instance (X : C) : IsIso (F.fromLeftDerivedZero.app X) := by\n  dsimp [Functor.fromLeftDerivedZero]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorFromLeftDerivedZero","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ CategoryTheory.IsIso F.fromLeftDerivedZero","decl":"instance : IsIso F.fromLeftDerivedZero :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasProjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq F.leftDerivedZeroIsoSelf.hom F.fromLeftDerivedZero","decl":"/-- The canonical isomorphism `F.leftDerived 0 ≅ F` when `F` is right exact\n(i.e. preserves finite colimits). -/\n@[simps! hom]\nnoncomputable def leftDerivedZeroIsoSelf : F.leftDerived 0 ≅ F :=\n  (asIso F.fromLeftDerivedZero)\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.leftDerived 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id :\n    F.fromLeftDerivedZero ≫ F.leftDerivedZeroIsoSelf.inv = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero F.leftDerivedZeroIsoSelf.inv) (CategoryTheory.CategoryStruct.id (F.leftDerived 0))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id :\n    F.fromLeftDerivedZero ≫ F.leftDerivedZeroIsoSelf.inv = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv (CategoryTheory.CategoryStruct.comp F.fromLeftDerivedZero h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id :\n    F.leftDerivedZeroIsoSelf.inv ≫ F.fromLeftDerivedZero =  𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.leftDerivedZeroIsoSelf.inv F.fromLeftDerivedZero) (CategoryTheory.CategoryStruct.id F)","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id :\n    F.leftDerivedZeroIsoSelf.inv ≫ F.fromLeftDerivedZero =  𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_app","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) (F.leftDerivedZeroIsoSelf.inv.app X)) (CategoryTheory.CategoryStruct.id ((F.leftDerived 0).obj X))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.fromLeftDerivedZero.app X ≫ F.leftDerivedZeroIsoSelf.inv.app X = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\nZ : D\nh : Quiver.Hom ((F.leftDerived 0).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.fromLeftDerivedZero.app X ≫ F.leftDerivedZeroIsoSelf.inv.app X = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_app","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) (F.fromLeftDerivedZero.app X)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.leftDerivedZeroIsoSelf.inv.app X ≫ F.fromLeftDerivedZero.app X = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Functor.leftDerivedZeroIsoSelf_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.LeftDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasProjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.leftDerivedZeroIsoSelf.inv.app X) (CategoryTheory.CategoryStruct.comp (F.fromLeftDerivedZero.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma leftDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.leftDerivedZeroIsoSelf.inv.app X ≫ F.fromLeftDerivedZero.app X = 𝟙 _ :=\n  F.leftDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
