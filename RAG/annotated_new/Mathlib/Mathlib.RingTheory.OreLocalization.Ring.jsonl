{"name":"OreLocalization.zero_smul","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddCommMonoid X\ninst✝ : Module R X\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul 0 x) 0","decl":"protected theorem zero_smul (x : X[S⁻¹]) : (0 : R[S⁻¹]) • x = 0 := by\n  induction' x with r s\n  rw [OreLocalization.zero_def, oreDiv_smul_char 0 r 1 s 0 1 (by simp)]; simp\n\n"}
{"name":"OreLocalization.add_smul","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddCommMonoid X\ninst✝ : Module R X\ny z : OreLocalization S R\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul (HAdd.hAdd y z) x) (HAdd.hAdd (HSMul.hSMul y x) (HSMul.hSMul z x))","decl":"protected theorem add_smul (y z : R[S⁻¹]) (x : X[S⁻¹]) :\n    (y + z) • x = y • x + z • x := by\n  induction' x with r₁ s₁\n  induction' y with r₂ s₂\n  induction' z with r₃ s₃\n  rcases oreDivAddChar' r₂ r₃ s₂ s₃ with ⟨ra, sa, ha, q⟩\n  rw [q]\n  clear q\n  rw [OreLocalization.expand' r₂ s₂ sa]\n  rcases oreDivSMulChar' (sa • r₂) r₁ (sa * s₂) s₁ with ⟨rb, sb, hb, q⟩\n  rw [q]\n  clear q\n  have hs₃rasb : sb * ra * s₃ ∈ S := by\n    rw [mul_assoc, ← ha]\n    norm_cast\n    apply SetLike.coe_mem\n  rw [OreLocalization.expand _ _ _ hs₃rasb]\n  have ha' : ↑((sb * sa) * s₂) = sb * ra * s₃ := by simp [ha, mul_assoc]\n  rw [← Subtype.coe_eq_of_eq_mk ha']\n  rcases oreDivSMulChar' ((sb * ra) • r₃) r₁ (sb * sa * s₂) s₁ with ⟨rc, sc, hc, hc'⟩\n  rw [hc']\n  rw [oreDiv_add_char _ _ 1 sc (by simp [mul_assoc])]\n  rw [OreLocalization.expand' (sa • r₂ + ra • r₃) (sa * s₂) (sc * sb)]\n  simp only [smul_eq_mul, one_smul, Submonoid.smul_def, mul_add, Submonoid.coe_mul] at hb hc ⊢\n  rw [mul_assoc, hb, mul_assoc, ← mul_assoc _ ra, hc, ← mul_assoc, ← add_mul]\n  rw [OreLocalization.smul_cancel']\n  simp only [add_smul, ← mul_assoc, smul_smul]\n\n"}
{"name":"OreLocalization.zero_mul","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx : OreLocalization S R\n⊢ Eq (HMul.hMul 0 x) 0","decl":"protected theorem zero_mul (x : R[S⁻¹]) : 0 * x = 0 :=\n  OreLocalization.zero_smul x\n\n"}
{"name":"OreLocalization.mul_zero","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx : OreLocalization S R\n⊢ Eq (HMul.hMul x 0) 0","decl":"protected theorem mul_zero (x : R[S⁻¹]) : x * 0 = 0 :=\n  OreLocalization.smul_zero x\n\n"}
{"name":"OreLocalization.left_distrib","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx y z : OreLocalization S R\n⊢ Eq (HMul.hMul x (HAdd.hAdd y z)) (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z))","decl":"protected theorem left_distrib (x y z : R[S⁻¹]) : x * (y + z) = x * y + x * z :=\n  OreLocalization.smul_add _ _ _\n\n"}
{"name":"OreLocalization.right_distrib","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx y z : OreLocalization S R\n⊢ Eq (HMul.hMul (HAdd.hAdd x y) z) (HAdd.hAdd (HMul.hMul x z) (HMul.hMul y z))","decl":"theorem right_distrib (x y z : R[S⁻¹]) : (x + y) * z = x * z + y * z :=\n  OreLocalization.add_smul _ _ _\n\n"}
{"name":"OreLocalization.nsmul_eq_nsmul","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddCommMonoid X\ninst✝ : Module R X\nn : Nat\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul n x) (HSMul.hSMul n x)","decl":"@[simp]\nlemma nsmul_eq_nsmul (n : ℕ) (x : X[S⁻¹]) :\n    letI inst := OreLocalization.instModuleOfIsScalarTower (R₀ := ℕ) (R := R) (X := X) (S := S)\n    HSMul.hSMul (self := @instHSMul _ _ inst.toSMul) n x = n • x := by\n  letI inst := OreLocalization.instModuleOfIsScalarTower (R₀ := ℕ) (R := R) (X := X) (S := S)\n  exact congr($(AddCommMonoid.uniqueNatModule.2 inst).smul n x)\n\n"}
{"name":"OreLocalization.numeratorRingHom_apply","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\n⊢ Eq (OreLocalization.numeratorRingHom r) (OreLocalization.oreDiv r 1)","decl":"/-- The ring homomorphism from `R` to `R[S⁻¹]`, mapping `r : R` to the fraction `r /ₒ 1`. -/\n@[simps!]\ndef numeratorRingHom : R →+* R[S⁻¹] where\n  __ := numeratorHom\n  map_zero' := by with_unfolding_all exact OreLocalization.zero_def\n  map_add' _ _ := add_oreDiv.symm\n\n"}
{"name":"OreLocalization.universalHom_apply","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_3\ninst✝ : Semiring T\nf : RingHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((OreLocalization.universalHom f fS hf) (OreLocalization.oreDiv r s)) (HMul.hMul (↑(Inv.inv (fS s))) (f r))","decl":"theorem universalHom_apply {r : R} {s : S} :\n    universalHom f fS hf (r /ₒ s) = ((fS s)⁻¹ : Units T) * f r :=\n  rfl\n\n"}
{"name":"OreLocalization.universalHom_commutes","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_3\ninst✝ : Semiring T\nf : RingHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\n⊢ Eq ((OreLocalization.universalHom f fS hf) (OreLocalization.numeratorHom r)) (f r)","decl":"theorem universalHom_commutes {r : R} : universalHom f fS hf (numeratorHom r) = f r := by\n  simp [numeratorHom_apply, universalHom_apply]\n\n"}
{"name":"OreLocalization.universalHom_unique","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_3\ninst✝ : Semiring T\nf : RingHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nφ : RingHom (OreLocalization S R) T\nhuniv : ∀ (r : R), Eq (φ (OreLocalization.numeratorHom r)) (f r)\n⊢ Eq φ (OreLocalization.universalHom f fS hf)","decl":"theorem universalHom_unique (φ : R[S⁻¹] →+* T) (huniv : ∀ r : R, φ (numeratorHom r) = f r) :\n    φ = universalHom f fS hf :=\n  RingHom.coe_monoidHom_injective <| universalMulHom_unique (RingHom.toMonoidHom f) fS hf (↑φ) huniv\n\n"}
{"name":"OreLocalization.zsmul_eq_zsmul","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Ring R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : AddCommGroup X\ninst✝ : Module R X\nn : Int\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul n x) (HSMul.hSMul n x)","decl":"@[simp]\nlemma zsmul_eq_zsmul (n : ℤ) (x : X[S⁻¹]) :\n    letI inst := OreLocalization.instModuleOfIsScalarTower (R₀ := ℤ) (R := R) (X := X) (S := S)\n    HSMul.hSMul (self := @instHSMul _ _ inst.toSMul) n x = n • x := by\n  letI inst := OreLocalization.instModuleOfIsScalarTower (R₀ := ℤ) (R := R) (X := X) (S := S)\n  exact congr($(AddCommGroup.uniqueIntModule.2 inst).smul n x)\n\n"}
{"name":"OreLocalization.numeratorHom_inj","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nhS : LE.le S (nonZeroDivisorsRight R)\n⊢ Function.Injective ⇑OreLocalization.numeratorHom","decl":"theorem numeratorHom_inj (hS : S ≤ nonZeroDivisorsRight R) :\n    Function.Injective (numeratorHom : R → R[S⁻¹]) :=\n  fun r₁ r₂ h => by\n  rw [numeratorHom_apply, numeratorHom_apply, oreDiv_eq_iff] at h\n  rcases h with ⟨u, v, h₁, h₂⟩\n  simp only [S.coe_one, mul_one, Submonoid.smul_def, smul_eq_mul] at h₁ h₂\n  rw [← h₂, ← sub_eq_zero, ← mul_sub] at h₁\n  exact (sub_eq_zero.mp (hS u.2 _ h₁)).symm\n\n"}
{"name":"OreLocalization.subsingleton_iff","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\n⊢ Iff (Subsingleton (OreLocalization S R)) (Membership.mem S 0)","decl":"theorem subsingleton_iff :\n    Subsingleton R[S⁻¹] ↔ 0 ∈ S := by\n  rw [← subsingleton_iff_zero_eq_one, OreLocalization.one_def,\n    OreLocalization.zero_def, oreDiv_eq_iff]\n  simp\n\n"}
{"name":"OreLocalization.nontrivial_iff","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\n⊢ Iff (Nontrivial (OreLocalization S R)) (Not (Membership.mem S 0))","decl":"theorem nontrivial_iff :\n    Nontrivial R[S⁻¹] ↔ 0 ∉ S := by\n  rw [← not_subsingleton_iff_nontrivial, subsingleton_iff]\n\n"}
{"name":"OreLocalization.nontrivial_of_nonZeroDivisors","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝² : Ring R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\ninst✝ : Nontrivial R\nhS : LE.le S (nonZeroDivisors R)\n⊢ Nontrivial (OreLocalization S R)","decl":"theorem nontrivial_of_nonZeroDivisors [Nontrivial R] (hS : S ≤ R⁰) :\n    Nontrivial R[S⁻¹] :=\n  nontrivial_iff.mpr (fun e ↦ one_ne_zero <| hS e 1 (mul_zero _))\n\n"}
{"name":"OreLocalization.nontrivial","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : Nontrivial R\ninst✝ : OreLocalization.OreSet (nonZeroDivisors R)\n⊢ Nontrivial (OreLocalization (nonZeroDivisors R) R)","decl":"instance nontrivial : Nontrivial R[R⁰⁻¹] :=\n  nontrivial_of_nonZeroDivisors (refl R⁰)\n\n"}
{"name":"OreLocalization.inv_def","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : Nontrivial R\ninst✝¹ : OreLocalization.OreSet (nonZeroDivisors R)\ninst✝ : NoZeroDivisors R\nr : R\ns : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Eq (Inv.inv (OreLocalization.oreDiv r s)) (dite (Eq r 0) (fun hr => 0) fun hr => OreLocalization.oreDiv ↑s ⟨r, ⋯⟩)","decl":"open Classical in\nprotected theorem inv_def {r : R} {s : R⁰} :\n    (r /ₒ s)⁻¹ =\n      if hr : r = (0 : R) then (0 : R[R⁰⁻¹])\n      else s /ₒ ⟨r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr⟩ := by\n  with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.mul_inv_cancel","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : Nontrivial R\ninst✝¹ : OreLocalization.OreSet (nonZeroDivisors R)\ninst✝ : NoZeroDivisors R\nx : OreLocalization (nonZeroDivisors R) R\nh : Ne x 0\n⊢ Eq (HMul.hMul x (Inv.inv x)) 1","decl":"protected theorem mul_inv_cancel (x : R[R⁰⁻¹]) (h : x ≠ 0) : x * x⁻¹ = 1 := by\n  induction' x with r s\n  rw [OreLocalization.inv_def, OreLocalization.one_def]\n  have hr : r ≠ 0 := by\n    rintro rfl\n    simp at h\n  simp only [hr]\n  with_unfolding_all apply OreLocalization.mul_inv ⟨r, _⟩\n\n"}
{"name":"OreLocalization.inv_zero","module":"Mathlib.RingTheory.OreLocalization.Ring","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : Nontrivial R\ninst✝¹ : OreLocalization.OreSet (nonZeroDivisors R)\ninst✝ : NoZeroDivisors R\n⊢ Eq (Inv.inv 0) 0","decl":"protected theorem inv_zero : (0 : R[R⁰⁻¹])⁻¹ = 0 := by\n  rw [OreLocalization.zero_def, OreLocalization.inv_def]\n  simp\n\n"}
