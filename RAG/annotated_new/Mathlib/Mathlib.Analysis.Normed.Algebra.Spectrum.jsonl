{"name":"spectrum.SpectralRadius.of_subsingleton","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : Subsingleton A\na : A\nâŠ¢ Eq (spectralRadius ğ•œ a) 0","decl":"@[simp]\ntheorem SpectralRadius.of_subsingleton [Subsingleton A] (a : A) : spectralRadius ğ•œ a = 0 := by\n  simp [spectralRadius]\n\n"}
{"name":"spectrum.spectralRadius_zero","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ Eq (spectralRadius ğ•œ 0) 0","decl":"@[simp]\ntheorem spectralRadius_zero : spectralRadius ğ•œ (0 : A) = 0 := by\n  nontriviality A\n  simp [spectralRadius]\n\n"}
{"name":"spectrum.mem_resolventSet_of_spectralRadius_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\na : A\nk : ğ•œ\nh : LT.lt (spectralRadius ğ•œ a) â†‘(NNNorm.nnnorm k)\nâŠ¢ Membership.mem (resolventSet ğ•œ a) k","decl":"theorem mem_resolventSet_of_spectralRadius_lt {a : A} {k : ğ•œ} (h : spectralRadius ğ•œ a < â€–kâ€–â‚Š) :\n    k âˆˆ Ï a :=\n  Classical.not_not.mp fun hn => h.not_le <| le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) k hn\n\n"}
{"name":"spectrum.isOpen_resolventSet","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ IsOpen (resolventSet ğ•œ a)","decl":"theorem isOpen_resolventSet (a : A) : IsOpen (Ï a) :=\n  Units.isOpen.preimage ((continuous_algebraMap ğ•œ A).sub continuous_const)\n\n"}
{"name":"spectrum.isClosed","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ IsClosed (spectrum ğ•œ a)","decl":"protected theorem isClosed (a : A) : IsClosed (Ïƒ a) :=\n  (isOpen_resolventSet a).isClosed_compl\n\n"}
{"name":"spectrum.mem_resolventSet_of_norm_lt_mul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nk : ğ•œ\nh : LT.lt (HMul.hMul (Norm.norm a) (Norm.norm 1)) (Norm.norm k)\nâŠ¢ Membership.mem (resolventSet ğ•œ a) k","decl":"theorem mem_resolventSet_of_norm_lt_mul {a : A} {k : ğ•œ} (h : â€–aâ€– * â€–(1 : A)â€– < â€–kâ€–) : k âˆˆ Ï a := by\n  rw [resolventSet, Set.mem_setOf_eq, Algebra.algebraMap_eq_smul_one]\n  nontriviality A\n  have hk : k â‰  0 :=\n    ne_zero_of_norm_ne_zero ((mul_nonneg (norm_nonneg _) (norm_nonneg _)).trans_lt h).ne'\n  letI ku := Units.map â†‘â‚.toMonoidHom (Units.mk0 k hk)\n  rw [â† inv_inv â€–(1 : A)â€–,\n    mul_inv_lt_iffâ‚€' (inv_pos.2 <| norm_pos_iff.2 (one_ne_zero : (1 : A) â‰  0))] at h\n  have hku : â€–-aâ€– < â€–(â†‘kuâ»Â¹ : A)â€–â»Â¹ := by simpa [ku, norm_algebraMap] using h\n  simpa [ku, sub_eq_add_neg, Algebra.algebraMap_eq_smul_one] using (ku.add (-a) hku).isUnit\n\n"}
{"name":"spectrum.mem_resolventSet_of_norm_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nk : ğ•œ\nh : LT.lt (Norm.norm a) (Norm.norm k)\nâŠ¢ Membership.mem (resolventSet ğ•œ a) k","decl":"theorem mem_resolventSet_of_norm_lt [NormOneClass A] {a : A} {k : ğ•œ} (h : â€–aâ€– < â€–kâ€–) : k âˆˆ Ï a :=\n  mem_resolventSet_of_norm_lt_mul (by rwa [norm_one, mul_one])\n\n"}
{"name":"spectrum.norm_le_norm_mul_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nk : ğ•œ\nhk : Membership.mem (spectrum ğ•œ a) k\nâŠ¢ LE.le (Norm.norm k) (HMul.hMul (Norm.norm a) (Norm.norm 1))","decl":"theorem norm_le_norm_mul_of_mem {a : A} {k : ğ•œ} (hk : k âˆˆ Ïƒ a) : â€–kâ€– â‰¤ â€–aâ€– * â€–(1 : A)â€– :=\n  le_of_not_lt <| mt mem_resolventSet_of_norm_lt_mul hk\n\n"}
{"name":"spectrum.norm_le_norm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nk : ğ•œ\nhk : Membership.mem (spectrum ğ•œ a) k\nâŠ¢ LE.le (Norm.norm k) (Norm.norm a)","decl":"theorem norm_le_norm_of_mem [NormOneClass A] {a : A} {k : ğ•œ} (hk : k âˆˆ Ïƒ a) : â€–kâ€– â‰¤ â€–aâ€– :=\n  le_of_not_lt <| mt mem_resolventSet_of_norm_lt hk\n\n"}
{"name":"spectrum.subset_closedBall_norm_mul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ HasSubset.Subset (spectrum ğ•œ a) (Metric.closedBall 0 (HMul.hMul (Norm.norm a) (Norm.norm 1)))","decl":"theorem subset_closedBall_norm_mul (a : A) : Ïƒ a âŠ† Metric.closedBall (0 : ğ•œ) (â€–aâ€– * â€–(1 : A)â€–) :=\n  fun k hk => by simp [norm_le_norm_mul_of_mem hk]\n\n"}
{"name":"spectrum.subset_closedBall_norm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nâŠ¢ HasSubset.Subset (spectrum ğ•œ a) (Metric.closedBall 0 (Norm.norm a))","decl":"theorem subset_closedBall_norm [NormOneClass A] (a : A) : Ïƒ a âŠ† Metric.closedBall (0 : ğ•œ) â€–aâ€– :=\n  fun k hk => by simp [norm_le_norm_of_mem hk]\n\n"}
{"name":"spectrum.isBounded","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Bornology.IsBounded (spectrum ğ•œ a)","decl":"theorem isBounded (a : A) : Bornology.IsBounded (Ïƒ a) :=\n  Metric.isBounded_closedBall.subset (subset_closedBall_norm_mul a)\n\n"}
{"name":"spectrum.isCompact","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : ProperSpace ğ•œ\na : A\nâŠ¢ IsCompact (spectrum ğ•œ a)","decl":"protected theorem isCompact [ProperSpace ğ•œ] (a : A) : IsCompact (Ïƒ a) :=\n  Metric.isCompact_of_isClosed_isBounded (spectrum.isClosed a) (isBounded a)\n\n"}
{"name":"spectrum.instCompactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : ProperSpace ğ•œ\na : A\nâŠ¢ CompactSpace â†‘(spectrum ğ•œ a)","decl":"instance instCompactSpace [ProperSpace ğ•œ] (a : A) : CompactSpace (spectrum ğ•œ a) :=\n  isCompact_iff_compactSpace.mp <| spectrum.isCompact a\n\n"}
{"name":"spectrum.instCompactSpaceNNReal","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na : A\ninstâœ : CompactSpace â†‘(spectrum Real a)\nâŠ¢ CompactSpace â†‘(spectrum NNReal a)","decl":"instance instCompactSpaceNNReal {A : Type*} [NormedRing A] [NormedAlgebra â„ A]\n    (a : A) [CompactSpace (spectrum â„ a)] : CompactSpace (spectrum â„â‰¥0 a) := by\n  rw [â† isCompact_iff_compactSpace] at *\n  rw [â† preimage_algebraMap â„]\n  exact isClosed_nonneg.isClosedEmbedding_subtypeVal.isCompact_preimage <| by assumption\n\n"}
{"name":"quasispectrum.isCompact","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NormedField ğ•œ\nB : Type u_3\ninstâœâµ : NonUnitalNormedRing B\ninstâœâ´ : NormedSpace ğ•œ B\ninstâœÂ³ : CompleteSpace B\ninstâœÂ² : IsScalarTower ğ•œ B B\ninstâœÂ¹ : SMulCommClass ğ•œ B B\ninstâœ : ProperSpace ğ•œ\na : B\nâŠ¢ IsCompact (quasispectrum ğ•œ a)","decl":"theorem _root_.quasispectrum.isCompact (a : B) : IsCompact (quasispectrum ğ•œ a) := by\n  rw [Unitization.quasispectrum_eq_spectrum_inr' ğ•œ ğ•œ,\n    â† AlgEquiv.spectrum_eq (WithLp.unitizationAlgEquiv ğ•œ).symm (a : Unitization ğ•œ B)]\n  exact spectrum.isCompact _\n\n"}
{"name":"quasispectrum.instCompactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NormedField ğ•œ\nB : Type u_3\ninstâœâµ : NonUnitalNormedRing B\ninstâœâ´ : NormedSpace ğ•œ B\ninstâœÂ³ : CompleteSpace B\ninstâœÂ² : IsScalarTower ğ•œ B B\ninstâœÂ¹ : SMulCommClass ğ•œ B B\ninstâœ : ProperSpace ğ•œ\na : B\nâŠ¢ CompactSpace â†‘(quasispectrum ğ•œ a)","decl":"instance _root_.quasispectrum.instCompactSpace (a : B) :\n    CompactSpace (quasispectrum ğ•œ a) :=\n  isCompact_iff_compactSpace.mp <| quasispectrum.isCompact a\n\n"}
{"name":"quasispectrum.instCompactSpaceNNReal","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"B : Type u_3\ninstâœâ´ : NonUnitalNormedRing B\ninstâœÂ³ : NormedSpace Real B\ninstâœÂ² : IsScalarTower Real B B\ninstâœÂ¹ : SMulCommClass Real B B\na : B\ninstâœ : CompactSpace â†‘(quasispectrum Real a)\nâŠ¢ CompactSpace â†‘(quasispectrum NNReal a)","decl":"instance _root_.quasispectrum.instCompactSpaceNNReal [NormedSpace â„ B] [IsScalarTower â„ B B]\n    [SMulCommClass â„ B B] (a : B) [CompactSpace (quasispectrum â„ a)] :\n    CompactSpace (quasispectrum â„â‰¥0 a) := by\n  rw [â† isCompact_iff_compactSpace] at *\n  rw [â† quasispectrum.preimage_algebraMap â„]\n  exact isClosed_nonneg.isClosedEmbedding_subtypeVal.isCompact_preimage <| by assumption\n\n"}
{"name":"spectrum.le_nnnorm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Real A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nr : NNReal\nhr : Membership.mem (spectrum NNReal a) r\nâŠ¢ LE.le r (NNNorm.nnnorm a)","decl":"theorem le_nnnorm_of_mem {a : A} {r : â„â‰¥0} (hr : r âˆˆ spectrum â„â‰¥0 a) :\n    r â‰¤ â€–aâ€–â‚Š := calc\n  r â‰¤ â€–(r : â„)â€– := Real.le_norm_self _\n  _ â‰¤ â€–aâ€–       := norm_le_norm_of_mem hr\n\n"}
{"name":"spectrum.coe_le_norm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Real A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nr : NNReal\nhr : Membership.mem (spectrum NNReal a) r\nâŠ¢ LE.le (â†‘r) (Norm.norm a)","decl":"theorem coe_le_norm_of_mem {a : A} {r : â„â‰¥0} (hr : r âˆˆ spectrum â„â‰¥0 a) :\n    r â‰¤ â€–aâ€– :=\n  coe_mono <| le_nnnorm_of_mem hr\n\n"}
{"name":"spectrum.spectralRadius_le_nnnorm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\na : A\nâŠ¢ LE.le (spectralRadius ğ•œ a) â†‘(NNNorm.nnnorm a)","decl":"theorem spectralRadius_le_nnnorm [NormOneClass A] (a : A) : spectralRadius ğ•œ a â‰¤ â€–aâ€–â‚Š := by\n  refine iSupâ‚‚_le fun k hk => ?_\n  exact mod_cast norm_le_norm_of_mem hk\n\n"}
{"name":"spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : ProperSpace ğ•œ\na : A\nha : (spectrum ğ•œ a).Nonempty\nâŠ¢ Exists fun k => And (Membership.mem (spectrum ğ•œ a) k) (Eq (â†‘(NNNorm.nnnorm k)) (spectralRadius ğ•œ a))","decl":"theorem exists_nnnorm_eq_spectralRadius_of_nonempty [ProperSpace ğ•œ] {a : A} (ha : (Ïƒ a).Nonempty) :\n    âˆƒ k âˆˆ Ïƒ a, (â€–kâ€–â‚Š : â„â‰¥0âˆ) = spectralRadius ğ•œ a := by\n  obtain âŸ¨k, hk, hâŸ© := (spectrum.isCompact a).exists_isMaxOn ha continuous_nnnorm.continuousOn\n  exact âŸ¨k, hk, le_antisymm (le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) k hk) (iSupâ‚‚_le <| mod_cast h)âŸ©\n\n"}
{"name":"spectrum.spectralRadius_lt_of_forall_lt_of_nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : ProperSpace ğ•œ\na : A\nha : (spectrum ğ•œ a).Nonempty\nr : NNReal\nhr : âˆ€ (k : ğ•œ), Membership.mem (spectrum ğ•œ a) k â†’ LT.lt (NNNorm.nnnorm k) r\nâŠ¢ LT.lt (spectralRadius ğ•œ a) â†‘r","decl":"theorem spectralRadius_lt_of_forall_lt_of_nonempty [ProperSpace ğ•œ] {a : A} (ha : (Ïƒ a).Nonempty)\n    {r : â„â‰¥0} (hr : âˆ€ k âˆˆ Ïƒ a, â€–kâ€–â‚Š < r) : spectralRadius ğ•œ a < r :=\n  sSup_image.symm.trans_lt <| ((spectrum.isCompact a).sSup_lt_iff_of_continuous ha\n    continuous_enorm.continuousOn (r : â„â‰¥0âˆ)).mpr (by simpa using hr)\n\n"}
{"name":"spectrum.spectralRadius_le_pow_nnnorm_pow_one_div","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nn : Nat\nâŠ¢ LE.le (spectralRadius ğ•œ a) (HMul.hMul (HPow.hPow (â†‘(NNNorm.nnnorm (HPow.hPow a (HAdd.hAdd n 1)))) (HDiv.hDiv 1 (HAdd.hAdd (â†‘n) 1))) (HPow.hPow (â†‘(NNNorm.nnnorm 1)) (HDiv.hDiv 1 (HAdd.hAdd (â†‘n) 1))))","decl":"theorem spectralRadius_le_pow_nnnorm_pow_one_div (a : A) (n : â„•) :\n    spectralRadius ğ•œ a â‰¤ (â€–a ^ (n + 1)â€–â‚Š : â„â‰¥0âˆ) ^ (1 / (n + 1) : â„) *\n      (â€–(1 : A)â€–â‚Š : â„â‰¥0âˆ) ^ (1 / (n + 1) : â„) := by\n  refine iSupâ‚‚_le fun k hk => ?_\n  -- apply easy direction of the spectral mapping theorem for polynomials\n  have pow_mem : k ^ (n + 1) âˆˆ Ïƒ (a ^ (n + 1)) := by\n    simpa only [one_mul, Algebra.algebraMap_eq_smul_one, one_smul, aeval_monomial, one_mul,\n      eval_monomial] using subset_polynomial_aeval a (@monomial ğ•œ _ (n + 1) (1 : ğ•œ)) âŸ¨k, hk, rflâŸ©\n  -- power of the norm is bounded by norm of the power\n  have nnnorm_pow_le : (â†‘(â€–kâ€–â‚Š ^ (n + 1)) : â„â‰¥0âˆ) â‰¤ â€–a ^ (n + 1)â€–â‚Š * â€–(1 : A)â€–â‚Š := by\n    simpa only [Real.toNNReal_mul (norm_nonneg _), norm_toNNReal, nnnorm_pow k (n + 1),\n      ENNReal.coe_mul] using coe_mono (Real.toNNReal_mono (norm_le_norm_mul_of_mem pow_mem))\n  -- take (n + 1)áµ—Ê° roots and clean up the left-hand side\n  have hn : 0 < ((n + 1 : â„•) : â„) := mod_cast Nat.succ_pos'\n  convert monotone_rpow_of_nonneg (one_div_pos.mpr hn).le nnnorm_pow_le using 1\n  all_goals dsimp\n  Â· rw [one_div, pow_rpow_inv_natCast]\n    positivity\n  rw [Nat.cast_succ, ENNReal.coe_mul_rpow]\n\n"}
{"name":"spectrum.spectralRadius_le_liminf_pow_nnnorm_pow_one_div","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ LE.le (spectralRadius ğ•œ a) (Filter.liminf (fun n => HPow.hPow (â†‘(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 â†‘n)) Filter.atTop)","decl":"theorem spectralRadius_le_liminf_pow_nnnorm_pow_one_div (a : A) :\n    spectralRadius ğ•œ a â‰¤ atTop.liminf fun n : â„• => (â€–a ^ nâ€–â‚Š : â„â‰¥0âˆ) ^ (1 / n : â„) := by\n  refine ENNReal.le_of_forall_lt_one_mul_le fun Îµ hÎµ => ?_\n  by_cases h : Îµ = 0\n  Â· simp only [h, zero_mul, zero_le']\n  simp only [ENNReal.mul_le_iff_le_inv h (hÎµ.trans_le le_top).ne, mul_comm Îµâ»Â¹,\n    liminf_eq_iSup_iInf_of_nat', ENNReal.iSup_mul]\n  conv_rhs => arg 1; intro i; rw [ENNReal.iInf_mul (by simp [h])]\n  rw [â† ENNReal.inv_lt_inv, inv_one] at hÎµ\n  obtain âŸ¨N, hNâŸ© := eventually_atTop.mp\n    (ENNReal.eventually_pow_one_div_le (ENNReal.coe_ne_top : â†‘â€–(1 : A)â€–â‚Š â‰  âˆ) hÎµ)\n  refine le_trans ?_ (le_iSup _ (N + 1))\n  refine le_iInf fun n => ?_\n  simp only [â† add_assoc]\n  refine (spectralRadius_le_pow_nnnorm_pow_one_div ğ•œ a (n + N)).trans ?_\n  norm_cast\n  exact mul_le_mul_left' (hN (n + N + 1) (by omega)) _\n\n"}
{"name":"spectrum.hasDerivAt_resolvent","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nk : ğ•œ\nhk : Membership.mem (resolventSet ğ•œ a) k\nâŠ¢ HasDerivAt (resolvent a) (Neg.neg (HPow.hPow (resolvent a k) 2)) k","decl":"theorem hasDerivAt_resolvent {a : A} {k : ğ•œ} (hk : k âˆˆ Ï a) :\n    HasDerivAt (resolvent a) (-resolvent a k ^ 2) k := by\n  have Hâ‚ : HasFDerivAt Ring.inverse _ (â†‘â‚ k - a) := hasFDerivAt_ring_inverse (ğ•œ := ğ•œ) hk.unit\n  have Hâ‚‚ : HasDerivAt (fun k => â†‘â‚ k - a) 1 k := by\n    simpa using (Algebra.linearMap ğ•œ A).hasDerivAt.sub_const a\n  simpa [resolvent, sq, hk.unit_spec, â† Ring.inverse_unit hk.unit] using Hâ‚.comp_hasDerivAt k Hâ‚‚\n\n-- refactored so this result was no longer necessary or useful\n\n"}
{"name":"spectrum.eventually_isUnit_resolvent","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Filter.Eventually (fun z => IsUnit (resolvent a z)) (Bornology.cobounded ğ•œ)","decl":"theorem eventually_isUnit_resolvent (a : A) : âˆ€á¶  z in cobounded ğ•œ, IsUnit (resolvent a z) := by\n  rw [atTop_basis_Ioi.cobounded_of_norm.eventually_iff]\n  exact âŸ¨â€–aâ€– * â€–(1 : A)â€–, trivial, fun _ â†¦ isUnit_resolvent.mp âˆ˜ mem_resolventSet_of_norm_lt_mulâŸ©\n\n"}
{"name":"spectrum.resolvent_isBigO_inv","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Asymptotics.IsBigO (Bornology.cobounded ğ•œ) (resolvent a) Inv.inv","decl":"theorem resolvent_isBigO_inv (a : A) : resolvent a =O[cobounded ğ•œ] Inv.inv :=\n  have h : (fun z â†¦ resolvent (zâ»Â¹ â€¢ a) (1 : ğ•œ)) =O[cobounded ğ•œ] (fun _ â†¦ (1 : â„)) := by\n    simpa [Function.comp_def, resolvent] using\n      (NormedRing.inverse_one_sub_norm (R := A)).comp_tendsto\n        (by simpa using (tendsto_invâ‚€_cobounded (Î± := ğ•œ)).smul_const a)\n  calc\n    resolvent a =á¶ [cobounded ğ•œ] fun z â†¦ zâ»Â¹ â€¢ resolvent (zâ»Â¹ â€¢ a) (1 : ğ•œ) := by\n      filter_upwards [isBounded_singleton (x := 0)] with z hz\n      lift z to ğ•œË£ using Ne.isUnit hz\n      simpa [Units.smul_def] using congr(zâ»Â¹ â€¢ $(units_smul_resolvent_self (r := z) (a := a)))\n    _ =O[cobounded ğ•œ] (Â· â»Â¹) := .of_norm_right <| by\n      simpa using (isBigO_refl (Â· â»Â¹) (cobounded ğ•œ)).norm_right.smul h\n\n"}
{"name":"spectrum.resolvent_tendsto_cobounded","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Filter.Tendsto (resolvent a) (Bornology.cobounded ğ•œ) (nhds 0)","decl":"theorem resolvent_tendsto_cobounded (a : A) : Tendsto (resolvent a) (cobounded ğ•œ) (ğ“ 0) :=\n  resolvent_isBigO_inv a |>.trans_tendsto tendsto_invâ‚€_cobounded\n\n"}
{"name":"spectrum.hasFPowerSeriesOnBall_inverse_one_sub_smul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : HasSummableGeomSeries A\na : A\nâŠ¢ HasFPowerSeriesOnBall (fun z => Ring.inverse (HSub.hSub 1 (HSMul.hSMul z a))) (fun n => ContinuousMultilinearMap.mkPiRing ğ•œ (Fin n) (HPow.hPow a n)) 0 (Inv.inv â†‘(NNNorm.nnnorm a))","decl":"/-- In a Banach algebra `A` over a nontrivially normed field `ğ•œ`, for any `a : A` the\npower series with coefficients `a ^ n` represents the function `(1 - z â€¢ a)â»Â¹` in a disk of\nradius `â€–aâ€–â‚Šâ»Â¹`. -/\ntheorem hasFPowerSeriesOnBall_inverse_one_sub_smul [HasSummableGeomSeries A] (a : A) :\n    HasFPowerSeriesOnBall (fun z : ğ•œ => Ring.inverse (1 - z â€¢ a))\n      (fun n => ContinuousMultilinearMap.mkPiRing ğ•œ (Fin n) (a ^ n)) 0 â€–aâ€–â‚Šâ»Â¹ :=\n  { r_le := by\n      refine le_of_forall_nnreal_lt fun r hr =>\n        le_radius_of_bound_nnreal _ (max 1 â€–(1 : A)â€–â‚Š) fun n => ?_\n      rw [â† norm_toNNReal, norm_mkPiRing, norm_toNNReal]\n      cases' n with n\n      Â· simp only [le_refl, mul_one, or_true, le_max_iff, pow_zero]\n      Â· refine\n          le_trans (le_trans (mul_le_mul_right' (nnnorm_pow_le' a n.succ_pos) (r ^ n.succ)) ?_)\n            (le_max_left _ _)\n        by_cases h : â€–aâ€–â‚Š = 0\n        Â· simp only [h, zero_mul, zero_le', pow_succ']\n        Â· rw [â† coe_inv h, coe_lt_coe, NNReal.lt_inv_iff_mul_lt h] at hr\n          simpa only [â† mul_pow, mul_comm] using pow_le_one' hr.le n.succ\n    r_pos := ENNReal.inv_pos.mpr coe_ne_top\n    hasSum := fun {y} hy => by\n      have norm_lt : â€–y â€¢ aâ€– < 1 := by\n        by_cases h : â€–aâ€–â‚Š = 0\n        Â· simp only [nnnorm_eq_zero.mp h, norm_zero, zero_lt_one, smul_zero]\n        Â· have nnnorm_lt : â€–yâ€–â‚Š < â€–aâ€–â‚Šâ»Â¹ := by\n            simpa only [â† coe_inv h, mem_ball_zero_iff, Metric.emetric_ball_nnreal] using hy\n          rwa [â† coe_nnnorm, â† Real.lt_toNNReal_iff_coe_lt, Real.toNNReal_one, nnnorm_smul,\n            â† NNReal.lt_inv_iff_mul_lt h]\n      simpa [â† smul_pow, (summable_geometric_of_norm_lt_one norm_lt).hasSum_iff] using\n        (NormedRing.inverse_one_sub _ norm_lt).symm }\n\n"}
{"name":"spectrum.isUnit_one_sub_smul_of_lt_inv_radius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra ğ•œ A\na : A\nz : ğ•œ\nh : LT.lt (â†‘(NNNorm.nnnorm z)) (Inv.inv (spectralRadius ğ•œ a))\nâŠ¢ IsUnit (HSub.hSub 1 (HSMul.hSMul z a))","decl":"theorem isUnit_one_sub_smul_of_lt_inv_radius {a : A} {z : ğ•œ} (h : â†‘â€–zâ€–â‚Š < (spectralRadius ğ•œ a)â»Â¹) :\n    IsUnit (1 - z â€¢ a) := by\n  by_cases hz : z = 0\n  Â· simp only [hz, isUnit_one, sub_zero, zero_smul]\n  Â· let u := Units.mk0 z hz\n    suffices hu : IsUnit (uâ»Â¹ â€¢ (1 : A) - a) by\n      rwa [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv u] at hu\n    rw [Units.smul_def, â† Algebra.algebraMap_eq_smul_one, â† mem_resolventSet_iff]\n    refine mem_resolventSet_of_spectralRadius_lt ?_\n    rwa [Units.val_inv_eq_inv_val, nnnorm_inv,\n      coe_inv (nnnorm_ne_zero_iff.mpr (Units.val_mk0 hz â–¸ hz : (u : ğ•œ) â‰  0)), lt_inv_iff_lt_inv]\n\n"}
{"name":"spectrum.differentiableOn_inverse_one_sub_smul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nr : NNReal\nhr : LT.lt (â†‘r) (Inv.inv (spectralRadius ğ•œ a))\nâŠ¢ DifferentiableOn ğ•œ (fun z => Ring.inverse (HSub.hSub 1 (HSMul.hSMul z a))) (Metric.closedBall 0 â†‘r)","decl":"/-- In a Banach algebra `A` over `ğ•œ`, for `a : A` the function `fun z â†¦ (1 - z â€¢ a)â»Â¹` is\ndifferentiable on any closed ball centered at zero of radius `r < (spectralRadius ğ•œ a)â»Â¹`. -/\ntheorem differentiableOn_inverse_one_sub_smul [CompleteSpace A] {a : A} {r : â„â‰¥0}\n    (hr : (r : â„â‰¥0âˆ) < (spectralRadius ğ•œ a)â»Â¹) :\n    DifferentiableOn ğ•œ (fun z : ğ•œ => Ring.inverse (1 - z â€¢ a)) (Metric.closedBall 0 r) := by\n  intro z z_mem\n  apply DifferentiableAt.differentiableWithinAt\n  have hu : IsUnit (1 - z â€¢ a) := by\n    refine isUnit_one_sub_smul_of_lt_inv_radius (lt_of_le_of_lt (coe_mono ?_) hr)\n    simpa only [norm_toNNReal, Real.toNNReal_coe] using\n      Real.toNNReal_mono (mem_closedBall_zero_iff.mp z_mem)\n  have Hâ‚ : Differentiable ğ•œ fun w : ğ•œ => 1 - w â€¢ a := (differentiable_id.smul_const a).const_sub 1\n  exact DifferentiableAt.comp z (differentiableAt_inverse hu) Hâ‚.differentiableAt\n\n"}
{"name":"spectrum.limsup_pow_nnnorm_pow_one_div_le_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ LE.le (Filter.limsup (fun n => HPow.hPow (â†‘(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 â†‘n)) Filter.atTop) (spectralRadius Complex a)","decl":"/-- The `limsup` relationship for the spectral radius used to prove `spectrum.gelfand_formula`. -/\ntheorem limsup_pow_nnnorm_pow_one_div_le_spectralRadius (a : A) :\n    limsup (fun n : â„• => (â€–a ^ nâ€–â‚Š : â„â‰¥0âˆ) ^ (1 / n : â„)) atTop â‰¤ spectralRadius â„‚ a := by\n  refine ENNReal.inv_le_inv.mp (le_of_forall_pos_nnreal_lt fun r r_pos r_lt => ?_)\n  simp_rw [inv_limsup, â† one_div]\n  let p : FormalMultilinearSeries â„‚ â„‚ A := fun n =>\n    ContinuousMultilinearMap.mkPiRing â„‚ (Fin n) (a ^ n)\n  suffices h : (r : â„â‰¥0âˆ) â‰¤ p.radius by\n    convert h\n    simp only [p, p.radius_eq_liminf, â† norm_toNNReal, norm_mkPiRing]\n    congr\n    ext n\n    rw [norm_toNNReal, ENNReal.coe_rpow_def â€–a ^ nâ€–â‚Š (1 / n : â„), if_neg]\n    exact fun ha => (lt_self_iff_false _).mp\n      (ha.2.trans_le (one_div_nonneg.mpr n.cast_nonneg : 0 â‰¤ (1 / n : â„)))\n  have Hâ‚ := (differentiableOn_inverse_one_sub_smul r_lt).hasFPowerSeriesOnBall r_pos\n  exact ((hasFPowerSeriesOnBall_inverse_one_sub_smul â„‚ a).exchange_radius Hâ‚).r_le\n\n"}
{"name":"spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Filter.Tendsto (fun n => HPow.hPow (â†‘(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 â†‘n)) Filter.atTop (nhds (spectralRadius Complex a))","decl":"/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectralRadius` of `a` is the limit of the sequence `â€–a ^ nâ€–â‚Š ^ (1 / n)`. -/\ntheorem pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : â„• => (â€–a ^ nâ€–â‚Š : â„â‰¥0âˆ) ^ (1 / n : â„)) atTop (ğ“ (spectralRadius â„‚ a)) :=\n  tendsto_of_le_liminf_of_limsup_le (spectralRadius_le_liminf_pow_nnnorm_pow_one_div â„‚ a)\n    (limsup_pow_nnnorm_pow_one_div_le_spectralRadius a)\n\n/- This is the same as `pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius` but for `norm`\ninstead of `nnnorm`. -/\n"}
{"name":"spectrum.pow_norm_pow_one_div_tendsto_nhds_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Complex A\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Filter.Tendsto (fun n => ENNReal.ofReal (HPow.hPow (Norm.norm (HPow.hPow a n)) (HDiv.hDiv 1 â†‘n))) Filter.atTop (nhds (spectralRadius Complex a))","decl":"/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectralRadius` of `a` is the limit of the sequence `â€–a ^ nâ€–â‚Š ^ (1 / n)`. -/\ntheorem pow_norm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : â„• => ENNReal.ofReal (â€–a ^ nâ€– ^ (1 / n : â„))) atTop\n      (ğ“ (spectralRadius â„‚ a)) := by\n  convert pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius a using 1\n  ext1\n  rw [â† ofReal_rpow_of_nonneg (norm_nonneg _) _, â† coe_nnnorm, coe_nnreal_eq]\n  exact one_div_nonneg.mpr (mod_cast zero_le _)\n\n"}
{"name":"spectrum.nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\na : A\nâŠ¢ (spectrum Complex a).Nonempty","decl":"/-- In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. -/\nprotected theorem nonempty : (spectrum â„‚ a).Nonempty := by\n  /- Suppose `Ïƒ a = âˆ…`, then resolvent set is `â„‚`, any `(z â€¢ 1 - a)` is a unit, and `resolvent a`\n    is differentiable on `â„‚`. -/\n  by_contra! h\n  have Hâ‚€ : resolventSet â„‚ a = Set.univ := by rwa [spectrum, Set.compl_empty_iff] at h\n  have Hâ‚ : Differentiable â„‚ fun z : â„‚ => resolvent a z := fun z =>\n    (hasDerivAt_resolvent (Hâ‚€.symm â–¸ Set.mem_univ z : z âˆˆ resolventSet â„‚ a)).differentiableAt\n  /- Since `resolvent a` tends to zero at infinity, by Liouville's theorem `resolvent a = 0`,\n  which contradicts that `resolvent a z` is invertible. -/\n  have Hâ‚ƒ := Hâ‚.apply_eq_of_tendsto_cocompact 0 <| by\n    simpa [Metric.cobounded_eq_cocompact] using resolvent_tendsto_cobounded a (ğ•œ := â„‚)\n  exact not_isUnit_zero <| Hâ‚ƒ â–¸ (isUnit_resolvent.mp <| Hâ‚€.symm â–¸ Set.mem_univ 0)\n\n"}
{"name":"spectrum.exists_nnnorm_eq_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\na : A\nâŠ¢ Exists fun z => And (Membership.mem (spectrum Complex a) z) (Eq (â†‘(NNNorm.nnnorm z)) (spectralRadius Complex a))","decl":"/-- In a complex Banach algebra, the spectral radius is always attained by some element of the\nspectrum. -/\ntheorem exists_nnnorm_eq_spectralRadius : âˆƒ z âˆˆ spectrum â„‚ a, (â€–zâ€–â‚Š : â„â‰¥0âˆ) = spectralRadius â„‚ a :=\n  exists_nnnorm_eq_spectralRadius_of_nonempty (spectrum.nonempty a)\n\n"}
{"name":"spectrum.spectralRadius_lt_of_forall_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\na : A\nr : NNReal\nhr : âˆ€ (z : Complex), Membership.mem (spectrum Complex a) z â†’ LT.lt (NNNorm.nnnorm z) r\nâŠ¢ LT.lt (spectralRadius Complex a) â†‘r","decl":"/-- In a complex Banach algebra, if every element of the spectrum has norm strictly less than\n`r : â„â‰¥0`, then the spectral radius is also strictly less than `r`. -/\ntheorem spectralRadius_lt_of_forall_lt {r : â„â‰¥0} (hr : âˆ€ z âˆˆ spectrum â„‚ a, â€–zâ€–â‚Š < r) :\n    spectralRadius â„‚ a < r :=\n  spectralRadius_lt_of_forall_lt_of_nonempty (spectrum.nonempty a) hr\n\n"}
{"name":"spectrum.map_polynomial_aeval","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\na : A\np : Polynomial Complex\nâŠ¢ Eq (spectrum Complex ((Polynomial.aeval a) p)) (Set.image (fun k => Polynomial.eval k p) (spectrum Complex a))","decl":"/-- The **spectral mapping theorem** for polynomials in a Banach algebra over `â„‚`. -/\ntheorem map_polynomial_aeval (p : â„‚[X]) :\n    spectrum â„‚ (aeval a p) = (fun k => eval k p) '' spectrum â„‚ a :=\n  map_polynomial_aeval_of_nonempty a p (spectrum.nonempty a)\n\n"}
{"name":"spectrum.map_pow","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra Complex A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : Nontrivial A\na : A\nn : Nat\nâŠ¢ Eq (spectrum Complex (HPow.hPow a n)) (Set.image (fun x => HPow.hPow x n) (spectrum Complex a))","decl":"/-- A specialization of the spectral mapping theorem for polynomials in a Banach algebra over `â„‚`\nto monic monomials. -/\nprotected theorem map_pow (n : â„•) :\n    spectrum â„‚ (a ^ n) = (Â· ^ n) '' spectrum â„‚ a := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval a (X ^ n)\n\n"}
{"name":"spectrum.algebraMap_eq_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra Complex A\nhA : âˆ€ {a : A}, Iff (IsUnit a) (Ne a 0)\na : A\nz : Complex\nh : Membership.mem (spectrum Complex a) z\nâŠ¢ Eq ((algebraMap Complex A) z) a","decl":"theorem algebraMap_eq_of_mem {a : A} {z : â„‚} (h : z âˆˆ Ïƒ a) : algebraMap â„‚ A z = a := by\n  rwa [mem_iff, hA, Classical.not_not, sub_eq_zero] at h\n\n"}
{"name":"NormedRing.algEquivComplexOfComplete_symm_apply","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Complex A\nhA : âˆ€ {a : A}, Iff (IsUnit a) (Ne a 0)\ninstâœ : CompleteSpace A\na : A\nâŠ¢ Eq ((NormedRing.algEquivComplexOfComplete hA).symm a) â‹¯.some","decl":"/-- **Gelfand-Mazur theorem**: For a complex Banach division algebra, the natural `algebraMap â„‚ A`\nis an algebra isomorphism whose inverse is given by selecting the (unique) element of\n`spectrum â„‚ a`. In addition, `algebraMap_isometry` guarantees this map is an isometry.\n\nNote: because `NormedDivisionRing` requires the field `norm_mul' : âˆ€ a b, â€–a * bâ€– = â€–aâ€– * â€–bâ€–`, we\ndon't use this type class and instead opt for a `NormedRing` in which the nonzero elements are\nprecisely the units. This allows for the application of this isomorphism in broader contexts, e.g.,\nto the quotient of a complex Banach algebra by a maximal ideal. In the case when `A` is actually a\n`NormedDivisionRing`, one may fill in the argument `hA` with the lemma `isUnit_iff_ne_zero`. -/\n@[simps]\nnoncomputable def _root_.NormedRing.algEquivComplexOfComplete [CompleteSpace A] : â„‚ â‰ƒâ‚[â„‚] A :=\n  let nt : Nontrivial A := âŸ¨âŸ¨1, 0, hA.mp âŸ¨âŸ¨1, 1, mul_one _, mul_one _âŸ©, rflâŸ©âŸ©âŸ©\n  { Algebra.ofId â„‚ A with\n    toFun := algebraMap â„‚ A\n    invFun := fun a => (@spectrum.nonempty _ _ _ _ nt a).some\n    left_inv := fun z => by\n      simpa only [@scalar_eq _ _ _ _ _ nt _] using\n        (@spectrum.nonempty _ _ _ _ nt <| algebraMap â„‚ A z).some_mem\n    right_inv := fun a => algebraMap_eq_of_mem (@hA) (@spectrum.nonempty _ _ _ _ nt a).some_mem }\n\n"}
{"name":"NormedRing.algEquivComplexOfComplete_apply","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Complex A\nhA : âˆ€ {a : A}, Iff (IsUnit a) (Ne a 0)\ninstâœ : CompleteSpace A\na : Complex\nâŠ¢ Eq ((NormedRing.algEquivComplexOfComplete hA) a) ((algebraMap Complex A) a)","decl":"/-- **Gelfand-Mazur theorem**: For a complex Banach division algebra, the natural `algebraMap â„‚ A`\nis an algebra isomorphism whose inverse is given by selecting the (unique) element of\n`spectrum â„‚ a`. In addition, `algebraMap_isometry` guarantees this map is an isometry.\n\nNote: because `NormedDivisionRing` requires the field `norm_mul' : âˆ€ a b, â€–a * bâ€– = â€–aâ€– * â€–bâ€–`, we\ndon't use this type class and instead opt for a `NormedRing` in which the nonzero elements are\nprecisely the units. This allows for the application of this isomorphism in broader contexts, e.g.,\nto the quotient of a complex Banach algebra by a maximal ideal. In the case when `A` is actually a\n`NormedDivisionRing`, one may fill in the argument `hA` with the lemma `isUnit_iff_ne_zero`. -/\n@[simps]\nnoncomputable def _root_.NormedRing.algEquivComplexOfComplete [CompleteSpace A] : â„‚ â‰ƒâ‚[â„‚] A :=\n  let nt : Nontrivial A := âŸ¨âŸ¨1, 0, hA.mp âŸ¨âŸ¨1, 1, mul_one _, mul_one _âŸ©, rflâŸ©âŸ©âŸ©\n  { Algebra.ofId â„‚ A with\n    toFun := algebraMap â„‚ A\n    invFun := fun a => (@spectrum.nonempty _ _ _ _ nt a).some\n    left_inv := fun z => by\n      simpa only [@scalar_eq _ _ _ _ _ nt _] using\n        (@spectrum.nonempty _ _ _ _ nt <| algebraMap â„‚ A z).some_mem\n    right_inv := fun a => algebraMap_eq_of_mem (@hA) (@spectrum.nonempty _ _ _ _ nt a).some_mem }\n\n"}
{"name":"spectrum.exp_mem_exp","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\na : A\nz : ğ•œ\nhz : Membership.mem (spectrum ğ•œ a) z\nâŠ¢ Membership.mem (spectrum ğ•œ (NormedSpace.exp ğ•œ a)) (NormedSpace.exp ğ•œ z)","decl":"/-- For `ğ•œ = â„` or `ğ•œ = â„‚`, `exp ğ•œ` maps the spectrum of `a` into the spectrum of `exp ğ•œ a`. -/\ntheorem exp_mem_exp [RCLike ğ•œ] [NormedRing A] [NormedAlgebra ğ•œ A] [CompleteSpace A] (a : A)\n    {z : ğ•œ} (hz : z âˆˆ spectrum ğ•œ a) : exp ğ•œ z âˆˆ spectrum ğ•œ (exp ğ•œ a) := by\n  have hexpmul : exp ğ•œ a = exp ğ•œ (a - â†‘â‚ z) * â†‘â‚ (exp ğ•œ z) := by\n    rw [algebraMap_exp_comm z, â† exp_add_of_commute (Algebra.commutes z (a - â†‘â‚ z)).symm,\n      sub_add_cancel]\n  let b := âˆ‘' n : â„•, ((n + 1).factorialâ»Â¹ : ğ•œ) â€¢ (a - â†‘â‚ z) ^ n\n  have hb : Summable fun n : â„• => ((n + 1).factorialâ»Â¹ : ğ•œ) â€¢ (a - â†‘â‚ z) ^ n := by\n    refine .of_norm_bounded_eventually _ (Real.summable_pow_div_factorial â€–a - â†‘â‚ zâ€–) ?_\n    filter_upwards [Filter.eventually_cofinite_ne 0] with n hn\n    rw [norm_smul, mul_comm, norm_inv, RCLike.norm_natCast, â† div_eq_mul_inv]\n    exact div_le_divâ‚€ (pow_nonneg (norm_nonneg _) n) (norm_pow_le' (a - â†‘â‚ z) (zero_lt_iff.mpr hn))\n      (mod_cast Nat.factorial_pos n) (mod_cast Nat.factorial_le (lt_add_one n).le)\n  have hâ‚€ : (âˆ‘' n : â„•, ((n + 1).factorialâ»Â¹ : ğ•œ) â€¢ (a - â†‘â‚ z) ^ (n + 1)) = (a - â†‘â‚ z) * b := by\n    simpa only [mul_smul_comm, pow_succ'] using hb.tsum_mul_left (a - â†‘â‚ z)\n  have hâ‚ : (âˆ‘' n : â„•, ((n + 1).factorialâ»Â¹ : ğ•œ) â€¢ (a - â†‘â‚ z) ^ (n + 1)) = b * (a - â†‘â‚ z) := by\n    simpa only [pow_succ, Algebra.smul_mul_assoc] using hb.tsum_mul_right (a - â†‘â‚ z)\n  have hâ‚ƒ : exp ğ•œ (a - â†‘â‚ z) = 1 + (a - â†‘â‚ z) * b := by\n    rw [exp_eq_tsum]\n    convert tsum_eq_zero_add (expSeries_summable' (ğ•‚ := ğ•œ) (a - â†‘â‚ z))\n    Â· simp only [Nat.factorial_zero, Nat.cast_one, inv_one, pow_zero, one_smul]\n    Â· exact hâ‚€.symm\n  rw [spectrum.mem_iff, IsUnit.sub_iff, â† one_mul (â†‘â‚ (exp ğ•œ z)), hexpmul, â† _root_.sub_mul,\n    Commute.isUnit_mul_iff (Algebra.commutes (exp ğ•œ z) (exp ğ•œ (a - â†‘â‚ z) - 1)).symm,\n    sub_eq_iff_eq_add'.mpr hâ‚ƒ, Commute.isUnit_mul_iff (hâ‚€ â–¸ hâ‚ : (a - â†‘â‚ z) * b = b * (a - â†‘â‚ z))]\n  exact not_and_of_not_left _ (not_and_of_not_left _ ((not_iff_not.mpr IsUnit.sub_iff).mp hz))\n\n"}
{"name":"AlgHom.instContinuousLinearMapClassOfAlgHomClass","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\nF : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : NormedRing A\ninstâœÂ³ : NormedAlgebra ğ•œ A\ninstâœÂ² : CompleteSpace A\ninstâœÂ¹ : FunLike F A ğ•œ\ninstâœ : AlgHomClass F ğ•œ A ğ•œ\nâŠ¢ ContinuousLinearMapClass F ğ•œ A ğ•œ","decl":"instance (priority := 100) [FunLike F A ğ•œ] [AlgHomClass F ğ•œ A ğ•œ] :\n    ContinuousLinearMapClass F ğ•œ A ğ•œ :=\n  { AlgHomClass.linearMapClass with\n    map_continuous := fun Ï† =>\n      AddMonoidHomClass.continuous_of_bound Ï† â€–(1 : A)â€– fun a =>\n        mul_comm â€–aâ€– â€–(1 : A)â€– â–¸ spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum Ï† _) }\n\n"}
{"name":"AlgHom.coe_toContinuousLinearMap","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : CompleteSpace A\nÏ† : AlgHom ğ•œ A ğ•œ\nâŠ¢ Eq â‡‘Ï†.toContinuousLinearMap â‡‘Ï†","decl":"@[simp]\ntheorem coe_toContinuousLinearMap (Ï† : A â†’â‚[ğ•œ] ğ•œ) : â‡‘Ï†.toContinuousLinearMap = Ï† :=\n  rfl\n\n"}
{"name":"AlgHom.norm_apply_le_self_mul_norm_one","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\nF : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : NormedRing A\ninstâœÂ³ : NormedAlgebra ğ•œ A\ninstâœÂ² : CompleteSpace A\ninstâœÂ¹ : FunLike F A ğ•œ\ninstâœ : AlgHomClass F ğ•œ A ğ•œ\nf : F\na : A\nâŠ¢ LE.le (Norm.norm (f a)) (HMul.hMul (Norm.norm a) (Norm.norm 1))","decl":"theorem norm_apply_le_self_mul_norm_one [FunLike F A ğ•œ] [AlgHomClass F ğ•œ A ğ•œ] (f : F) (a : A) :\n    â€–f aâ€– â‰¤ â€–aâ€– * â€–(1 : A)â€– :=\n  spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum f _)\n\n"}
{"name":"AlgHom.norm_apply_le_self","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\nF : Type u_3\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : NormedRing A\ninstâœâ´ : NormedAlgebra ğ•œ A\ninstâœÂ³ : CompleteSpace A\ninstâœÂ² : NormOneClass A\ninstâœÂ¹ : FunLike F A ğ•œ\ninstâœ : AlgHomClass F ğ•œ A ğ•œ\nf : F\na : A\nâŠ¢ LE.le (Norm.norm (f a)) (Norm.norm a)","decl":"theorem norm_apply_le_self [NormOneClass A] [FunLike F A ğ•œ] [AlgHomClass F ğ•œ A ğ•œ]\n    (f : F) (a : A) : â€–f aâ€– â‰¤ â€–aâ€– :=\n  spectrum.norm_le_norm_of_mem (apply_mem_spectrum f _)\n\n"}
{"name":"AlgHom.toContinuousLinearMap_norm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\nÏ† : AlgHom ğ•œ A ğ•œ\nâŠ¢ Eq (Norm.norm Ï†.toContinuousLinearMap) 1","decl":"@[simp]\ntheorem toContinuousLinearMap_norm [NormOneClass A] (Ï† : A â†’â‚[ğ•œ] ğ•œ) :\n    â€–Ï†.toContinuousLinearMapâ€– = 1 :=\n  ContinuousLinearMap.opNorm_eq_of_bounds zero_le_one\n    (fun a => (one_mul â€–aâ€–).symm â–¸ spectrum.norm_le_norm_of_mem (apply_mem_spectrum Ï† _))\n    fun _ _ h => by simpa only [coe_toContinuousLinearMap, map_one, norm_one, mul_one] using h 1\n\n"}
{"name":"WeakDual.CharacterSpace.equivAlgHom_coe","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormedAlgebra ğ•œ A\nf : â†‘(WeakDual.characterSpace ğ•œ A)\nâŠ¢ Eq â‡‘(WeakDual.CharacterSpace.equivAlgHom f) â‡‘f","decl":"@[simp]\ntheorem equivAlgHom_coe (f : characterSpace ğ•œ A) : â‡‘(equivAlgHom f) = f :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.equivAlgHom_symm_coe","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormedAlgebra ğ•œ A\nf : AlgHom ğ•œ A ğ•œ\nâŠ¢ Eq â‡‘(WeakDual.CharacterSpace.equivAlgHom.symm f) â‡‘f","decl":"@[simp]\ntheorem equivAlgHom_symm_coe (f : A â†’â‚[ğ•œ] ğ•œ) : â‡‘(equivAlgHom.symm f) = f :=\n  rfl\n\n"}
{"name":"Subalgebra.isUnit_of_isUnit_val_of_eventually","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâµ : NormedRing A\ninstâœâ´ : CompleteSpace A\ninstâœÂ³ : SetLike SA A\ninstâœÂ² : SubringClass SA A\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra ğ•œ A\ninstSMulMem : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nl : Filter (Subtype fun x => Membership.mem S x)\na : Subtype fun x => Membership.mem S x\nha : IsUnit â†‘a\nhla : LE.le l (nhds a)\nhl : Filter.Eventually (fun x => IsUnit x) l\nhl' : l.NeBot\nâŠ¢ IsUnit a","decl":"open SubalgebraClass in\ninclude instSMulMem in\n/-- Let `S` be a closed subalgebra of a Banach algebra `A`. If `a : S` is invertible in `A`,\nand for all `x : S` sufficiently close to `a` within some filter `l`, `x` is invertible in `S`,\nthen `a` is invertible in `S` as well. -/\nlemma _root_.Subalgebra.isUnit_of_isUnit_val_of_eventually {l : Filter S} {a : S}\n    (ha : IsUnit (a : A)) (hla : l â‰¤ ğ“ a) (hl : âˆ€á¶  x in l, IsUnit x) (hl' : l.NeBot) :\n    IsUnit a := by\n  have hlaâ‚‚ : Tendsto Ring.inverse (map (val S) l) (ğ“ (â†‘ha.unitâ»Â¹ : A)) := by\n    rw [â† Ring.inverse_unit]\n    exact (NormedRing.inverse_continuousAt _).tendsto.comp <|\n      continuousAt_subtype_val.tendsto.comp <| map_mono hla\n  suffices mem : (â†‘ha.unitâ»Â¹ : A) âˆˆ S by\n    refine âŸ¨âŸ¨a, âŸ¨(â†‘ha.unitâ»Â¹ : A), memâŸ©, ?_, ?_âŸ©, rflâŸ©\n    all_goals ext; simp\n  apply hS.mem_of_tendsto hlaâ‚‚\n  rw [Filter.eventually_map]\n  apply hl.mono fun x hx â†¦ ?_\n  suffices Ring.inverse (val S x) = (val S â†‘hx.unitâ»Â¹) from this â–¸ Subtype.property _\n  rw [â† (hx.map (val S)).unit_spec, Ring.inverse_unit (hx.map (val S)).unit, val]\n  apply Units.mul_eq_one_iff_inv_eq.mp\n  simpa [-IsUnit.mul_val_inv] using congr(($hx.mul_val_inv : A))\n\n"}
{"name":"Subalgebra.frontier_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâµ : NormedRing A\ninstâœâ´ : CompleteSpace A\ninstâœÂ³ : SetLike SA A\ninstâœÂ² : SubringClass SA A\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra ğ•œ A\ninstSMulMem : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nx : Subtype fun x => Membership.mem S x\nâŠ¢ HasSubset.Subset (frontier (spectrum ğ•œ x)) (spectrum ğ•œ â†‘x)","decl":"/-- If `S : Subalgebra ğ•œ A` is a closed subalgebra of a Banach algebra `A`, then for any\n`x : S`, the boundary of the spectrum of `x` relative to `S` is a subset of the spectrum of\n`â†‘x : A` relative to `A`. -/\nlemma _root_.Subalgebra.frontier_spectrum : frontier (Ïƒ ğ•œ x) âŠ† Ïƒ ğ•œ (x : A) := by\n  have : CompleteSpace S := hS.completeSpace_coe\n  intro Î¼ hÎ¼\n  by_contra h\n  rw [spectrum.not_mem_iff] at h\n  rw [â† frontier_compl, (spectrum.isClosed _).isOpen_compl.frontier_eq, mem_diff] at hÎ¼\n  obtain âŸ¨hÎ¼â‚, hÎ¼â‚‚âŸ© := hÎ¼\n  rw [mem_closure_iff_clusterPt] at hÎ¼â‚\n  apply hÎ¼â‚‚\n  rw [mem_compl_iff, spectrum.not_mem_iff]\n  refine Subalgebra.isUnit_of_isUnit_val_of_eventually S h ?_ ?_ <| .map hÎ¼â‚ (algebraMap ğ•œ S Â· - x)\n  Â· calc\n      _ â‰¤ map _ (ğ“ Î¼) := map_mono (by simp)\n      _ â‰¤ _ := by rw [â† Filter.Tendsto, â† ContinuousAt]; fun_prop\n  Â· rw [eventually_map]\n    apply Eventually.filter_mono inf_le_right\n    simp [spectrum.not_mem_iff]\n\n"}
{"name":"Subalgebra.frontier_subset_frontier","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâµ : NormedRing A\ninstâœâ´ : CompleteSpace A\ninstâœÂ³ : SetLike SA A\ninstâœÂ² : SubringClass SA A\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra ğ•œ A\ninstSMulMem : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nx : Subtype fun x => Membership.mem S x\nâŠ¢ HasSubset.Subset (frontier (spectrum ğ•œ x)) (frontier (spectrum ğ•œ â†‘x))","decl":"/-- If `S` is a closed subalgebra of a Banach algebra `A`, then for any `x : S`, the boundary of\nthe spectrum of `x` relative to `S` is a subset of the boundary of the spectrum of `â†‘x : A`\nrelative to `A`. -/\nlemma Subalgebra.frontier_subset_frontier :\n    frontier (Ïƒ ğ•œ x) âŠ† frontier (Ïƒ ğ•œ (x : A)) := by\n  rw [frontier_eq_closure_inter_closure (s := Ïƒ ğ•œ (x : A)),\n    (spectrum.isClosed (x : A)).closure_eq]\n  apply subset_inter (frontier_spectrum S x)\n  rw [frontier_eq_closure_inter_closure]\n  exact inter_subset_right |>.trans <|\n    closure_mono <| compl_subset_compl.mpr <| spectrum.subset_subalgebra x\n\n"}
{"name":"Subalgebra.spectrum_sUnion_connectedComponentIn","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâµ : NormedRing A\ninstâœâ´ : CompleteSpace A\ninstâœÂ³ : SetLike SA A\ninstâœÂ² : SubringClass SA A\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra ğ•œ A\ninstSMulMem : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nx : Subtype fun x => Membership.mem S x\nâŠ¢ Eq (spectrum ğ•œ x) (Union.union (spectrum ğ•œ â†‘x) (Set.iUnion fun z => Set.iUnion fun h => connectedComponentIn (HasCompl.compl (spectrum ğ•œ â†‘x)) z))","decl":"/-- If `S` is a closed subalgebra of a Banach algebra `A`, then for any `x : S`, the spectrum of `x`\nis the spectrum of `â†‘x : A` along with the connected components of the complement of the spectrum of\n`â†‘x : A` which contain an element of the spectrum of `x : S`. -/\nlemma Subalgebra.spectrum_sUnion_connectedComponentIn :\n    Ïƒ ğ•œ x = Ïƒ ğ•œ (x : A) âˆª (â‹ƒ z âˆˆ (Ïƒ ğ•œ x \\ Ïƒ ğ•œ (x : A)), connectedComponentIn (Ïƒ ğ•œ (x : A))á¶œ z) := by\n  suffices IsClopen ((Ïƒ ğ•œ (x : A))á¶œ â†“âˆ© (Ïƒ ğ•œ x \\ Ïƒ ğ•œ (x : A))) by\n    rw [â† this.biUnion_connectedComponentIn (diff_subset_compl _ _),\n      union_diff_cancel (spectrum.subset_subalgebra x)]\n  have : CompleteSpace S := hS.completeSpace_coe\n  have h_open : IsOpen (Ïƒ ğ•œ x \\ Ïƒ ğ•œ (x : A)) := by\n    rw [â† (spectrum.isClosed (ğ•œ := ğ•œ) x).closure_eq, closure_eq_interior_union_frontier,\n      union_diff_distrib, diff_eq_empty.mpr (frontier_spectrum S x),\n      diff_eq_compl_inter, union_empty]\n    exact (spectrum.isClosed _).isOpen_compl.inter isOpen_interior\n  apply isClopen_preimage_val h_open\n  suffices h_frontier : frontier (Ïƒ ğ•œ x \\ Ïƒ ğ•œ (x : A)) âŠ† frontier (Ïƒ ğ•œ (x : A)) from\n    disjoint_of_subset_left h_frontier <| disjoint_compl_right.frontier_left\n      (spectrum.isClosed _).isOpen_compl\n  rw [diff_eq_compl_inter]\n  apply (frontier_inter_subset _ _).trans\n  rw [frontier_compl]\n  apply union_subset <| inter_subset_left\n  refine inter_subset_inter_right _ ?_ |>.trans <| inter_subset_right\n  exact frontier_subset_frontier S x\n\n"}
{"name":"Subalgebra.spectrum_isBounded_connectedComponentIn","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâµ : NormedRing A\ninstâœâ´ : CompleteSpace A\ninstâœÂ³ : SetLike SA A\ninstâœÂ² : SubringClass SA A\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra ğ•œ A\ninstSMulMem : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nx : Subtype fun x => Membership.mem S x\nz : ğ•œ\nhz : Membership.mem (spectrum ğ•œ x) z\nâŠ¢ Bornology.IsBounded (connectedComponentIn (HasCompl.compl (spectrum ğ•œ â†‘x)) z)","decl":"/-- Let `S` be a closed subalgebra of a Banach algebra `A`, and let `x : S`. If `z` is in the\nspectrum of `x`, then the connected component of `z` in the complement of the spectrum of `â†‘x : A`\nis bounded (or else `z` actually belongs to the spectrum of `â†‘x : A`). -/\nlemma Subalgebra.spectrum_isBounded_connectedComponentIn {z : ğ•œ} (hz : z âˆˆ Ïƒ ğ•œ x) :\n    Bornology.IsBounded (connectedComponentIn (Ïƒ ğ•œ (x : A))á¶œ z) := by\n  by_cases hz' : z âˆˆ Ïƒ ğ•œ (x : A)\n  Â· simp [connectedComponentIn_eq_empty (show z âˆ‰ (Ïƒ ğ•œ (x : A))á¶œ from not_not.mpr hz')]\n  Â· have : CompleteSpace S := hS.completeSpace_coe\n    suffices connectedComponentIn (Ïƒ ğ•œ (x : A))á¶œ z âŠ† Ïƒ ğ•œ x from spectrum.isBounded x |>.subset this\n    rw [spectrum_sUnion_connectedComponentIn S]\n    exact subset_biUnion_of_mem (mem_diff_of_mem hz hz') |>.trans subset_union_right\n\n"}
{"name":"Subalgebra.spectrum_eq_of_isPreconnected_compl","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œ : Type u_3\nA : Type u_4\nSA : Type u_5\ninstâœâ¶ : NormedRing A\ninstâœâµ : CompleteSpace A\ninstâœâ´ : SetLike SA A\ninstâœÂ³ : SubringClass SA A\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : SMulMemClass SA ğ•œ A\nS : SA\nhS : IsClosed â†‘S\nx : Subtype fun x => Membership.mem S x\nh : IsPreconnected (HasCompl.compl (spectrum ğ•œ â†‘x))\nâŠ¢ Eq (spectrum ğ•œ x) (spectrum ğ•œ â†‘x)","decl":"/-- Let `S` be a closed subalgebra of a Banach algebra `A`. If for `x : S` the complement of the\nspectrum of `â†‘x : A` is connected, then `spectrum ğ•œ x = spectrum ğ•œ (x : A)`. -/\nlemma Subalgebra.spectrum_eq_of_isPreconnected_compl (h : IsPreconnected (Ïƒ ğ•œ (x : A))á¶œ) :\n    Ïƒ ğ•œ x = Ïƒ ğ•œ (x : A) := by\n  nontriviality A\n  suffices Ïƒ ğ•œ x \\ Ïƒ ğ•œ (x : A) = âˆ… by\n    rw [spectrum_sUnion_connectedComponentIn, this]\n    simp\n  refine eq_empty_of_forall_not_mem fun z hz â†¦ NormedSpace.unbounded_univ ğ•œ ğ•œ ?_\n  obtain âŸ¨hz, hz'âŸ© := mem_diff _ |>.mp hz\n  have := (spectrum.isBounded (x : A)).union <|\n    h.connectedComponentIn hz' â–¸ spectrum_isBounded_connectedComponentIn S x hz\n  simpa\n\n"}
{"name":"SpectrumRestricts.spectralRadius_eq","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"ğ•œâ‚ : Type u_3\nğ•œâ‚‚ : Type u_4\nA : Type u_5\ninstâœâ¶ : NormedField ğ•œâ‚\ninstâœâµ : NormedField ğ•œâ‚‚\ninstâœâ´ : NormedRing A\ninstâœÂ³ : NormedAlgebra ğ•œâ‚ A\ninstâœÂ² : NormedAlgebra ğ•œâ‚‚ A\ninstâœÂ¹ : NormedAlgebra ğ•œâ‚ ğ•œâ‚‚\ninstâœ : IsScalarTower ğ•œâ‚ ğ•œâ‚‚ A\nf : ğ•œâ‚‚ â†’ ğ•œâ‚\na : A\nh : SpectrumRestricts a f\nâŠ¢ Eq (spectralRadius ğ•œâ‚ a) (spectralRadius ğ•œâ‚‚ a)","decl":"/-- If `ğ•œâ‚` is a normed field contained as subfield of a larger normed field `ğ•œâ‚‚`, and if `a : A`\nis an element whose `ğ•œâ‚‚` spectrum restricts to `ğ•œâ‚`, then the spectral radii over each scalar\nfield coincide. -/\nlemma spectralRadius_eq {ğ•œâ‚ ğ•œâ‚‚ A : Type*} [NormedField ğ•œâ‚] [NormedField ğ•œâ‚‚]\n    [NormedRing A] [NormedAlgebra ğ•œâ‚ A] [NormedAlgebra ğ•œâ‚‚ A] [NormedAlgebra ğ•œâ‚ ğ•œâ‚‚]\n    [IsScalarTower ğ•œâ‚ ğ•œâ‚‚ A] {f : ğ•œâ‚‚ â†’ ğ•œâ‚} {a : A} (h : SpectrumRestricts a f) :\n    spectralRadius ğ•œâ‚ a = spectralRadius ğ•œâ‚‚ a := by\n  rw [spectralRadius, spectralRadius]\n  have := algebraMap_isometry ğ•œâ‚ ğ•œâ‚‚ |>.nnnorm_map_of_map_zero (map_zero _)\n  apply le_antisymm\n  all_goals apply iSupâ‚‚_le fun x hx â†¦ ?_\n  Â· refine congr_arg ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) (this x) |>.symm.trans_le <| le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) _ ?_\n    exact (spectrum.algebraMap_mem_iff _).mpr hx\n  Â· have âŸ¨y, hy, hy'âŸ© := h.algebraMap_image.symm â–¸ hx\n    subst hy'\n    exact this y â–¸ le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) y hy\n\n"}
{"name":"SpectrumRestricts.nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nâŠ¢ Iff (SpectrumRestricts a â‡‘ContinuousMap.realToNNReal) (âˆ€ (x : Real), Membership.mem (spectrum Real a) x â†’ LE.le 0 x)","decl":"lemma nnreal_iff [Algebra â„ A] {a : A} :\n    SpectrumRestricts a ContinuousMap.realToNNReal â†” âˆ€ x âˆˆ spectrum â„ a, 0 â‰¤ x := by\n  refine âŸ¨fun h x hx â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· obtain âŸ¨x, -, rflâŸ© := h.algebraMap_image.symm â–¸ hx\n    exact coe_nonneg x\n  Â· exact .of_subset_range_algebraMap (fun _ â†¦ Real.toNNReal_coe) fun x hx â†¦ âŸ¨âŸ¨x, h x hxâŸ©, rflâŸ©\n\n"}
{"name":"SpectrumRestricts.nnreal_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninstâœÂ³ : Ring A\ninstâœÂ² : PartialOrder A\ninstâœÂ¹ : Algebra Real A\ninstâœ : NonnegSpectrumClass Real A\na : A\nha : LE.le 0 a\nâŠ¢ SpectrumRestricts a â‡‘ContinuousMap.realToNNReal","decl":"lemma nnreal_of_nonneg {A : Type*} [Ring A] [PartialOrder A] [Algebra â„ A]\n    [NonnegSpectrumClass â„ A] {a : A} (ha : 0 â‰¤ a) :\n    SpectrumRestricts a ContinuousMap.realToNNReal :=\n  nnreal_iff.mpr <| spectrum_nonneg_of_nonneg ha\n\n"}
{"name":"SpectrumRestricts.real_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Complex A\na : A\nâŠ¢ Iff (SpectrumRestricts a â‡‘Complex.reCLM) (âˆ€ (x : Complex), Membership.mem (spectrum Complex a) x â†’ Eq x â†‘x.re)","decl":"lemma real_iff [Algebra â„‚ A] {a : A} :\n    SpectrumRestricts a Complex.reCLM â†” âˆ€ x âˆˆ spectrum â„‚ a, x = x.re := by\n  refine âŸ¨fun h x hx â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· obtain âŸ¨x, -, rflâŸ© := h.algebraMap_image.symm â–¸ hx\n    simp\n  Â· exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx â†¦ âŸ¨x.re, (h x hx).symmâŸ©\n\n"}
{"name":"SpectrumRestricts.nnreal_le_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nha : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (spectrum NNReal a) x â†’ LE.le r x) (âˆ€ (x : Real), Membership.mem (spectrum Real a) x â†’ LE.le (â†‘r) x)","decl":"lemma nnreal_le_iff [Algebra â„ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ spectrum â„â‰¥0 a, r â‰¤ x) â†” âˆ€ x âˆˆ spectrum â„ a, r â‰¤ x := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.nnreal_lt_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nha : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (spectrum NNReal a) x â†’ LT.lt r x) (âˆ€ (x : Real), Membership.mem (spectrum Real a) x â†’ LT.lt (â†‘r) x)","decl":"lemma nnreal_lt_iff [Algebra â„ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ spectrum â„â‰¥0 a, r < x) â†” âˆ€ x âˆˆ spectrum â„ a, r < x := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.le_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nha : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (spectrum NNReal a) x â†’ LE.le x r) (âˆ€ (x : Real), Membership.mem (spectrum Real a) x â†’ LE.le x â†‘r)","decl":"lemma le_nnreal_iff [Algebra â„ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ spectrum â„â‰¥0 a, x â‰¤ r) â†” âˆ€ x âˆˆ spectrum â„ a, x â‰¤ r := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.lt_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nha : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (spectrum NNReal a) x â†’ LT.lt x r) (âˆ€ (x : Real), Membership.mem (spectrum Real a) x â†’ LT.lt x â†‘r)","decl":"lemma lt_nnreal_iff [Algebra â„ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ spectrum â„â‰¥0 a, x < r) â†” âˆ€ x âˆˆ spectrum â„ a, x < r := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.nnreal_iff_spectralRadius_le","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ¹ : Ring A\ninstâœ : Algebra Real A\na : A\nt : NNReal\nht : LE.le (spectralRadius Real a) â†‘t\nâŠ¢ Iff (SpectrumRestricts a â‡‘ContinuousMap.realToNNReal) (LE.le (spectralRadius Real (HSub.hSub ((algebraMap Real A) â†‘t) a)) â†‘t)","decl":"lemma nnreal_iff_spectralRadius_le [Algebra â„ A] {a : A} {t : â„â‰¥0} (ht : spectralRadius â„ a â‰¤ t) :\n    SpectrumRestricts a ContinuousMap.realToNNReal â†”\n      spectralRadius â„ (algebraMap â„ A t - a) â‰¤ t := by\n  have : spectrum â„ a âŠ† Set.Icc (-t) t := by\n    intro x hx\n    rw [Set.mem_Icc, â† abs_le, â† Real.norm_eq_abs, â† coe_nnnorm, NNReal.coe_le_coe,\n      â† ENNReal.coe_le_coe]\n    exact le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) x hx |>.trans ht\n  rw [nnreal_iff]\n  refine âŸ¨fun h â†¦ iSupâ‚‚_le fun x hx â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rw [â† spectrum.singleton_sub_eq] at hx\n    obtain âŸ¨y, hy, rflâŸ© : âˆƒ y âˆˆ spectrum â„ a, â†‘t - y = x := by simpa using hx\n    obtain âŸ¨hty, hytâŸ© := Set.mem_Icc.mp <| this hy\n    lift y to â„â‰¥0 using h y hy\n    rw [â† NNReal.coe_sub (by exact_mod_cast hyt)]\n    simp\n  Â· replace h : âˆ€ x âˆˆ spectrum â„ a, â€–t - xâ€–â‚Š â‰¤ t := by\n      simpa [spectralRadius, iSupâ‚‚_le_iff, â† spectrum.singleton_sub_eq] using h\n    peel h with x hx h_le\n    rw [â† NNReal.coe_le_coe, coe_nnnorm, Real.norm_eq_abs, abs_le] at h_le\n    linarith [h_le.2]\n\n"}
{"name":"NNReal.spectralRadius_mem_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\ninstâœ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\nha' : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nâŠ¢ Membership.mem (spectrum NNReal a) (spectralRadius Real a).toNNReal","decl":"lemma _root_.NNReal.spectralRadius_mem_spectrum {A : Type*} [NormedRing A] [NormedAlgebra â„ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum â„ a).Nonempty)\n    (ha' : SpectrumRestricts a ContinuousMap.realToNNReal) :\n    (spectralRadius â„ a).toNNReal âˆˆ spectrum â„â‰¥0 a := by\n  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty ha\n  rw [â† hxâ‚‚, ENNReal.toNNReal_coe, â† spectrum.algebraMap_mem_iff â„, NNReal.algebraMap_eq_coe]\n  have : 0 â‰¤ x := ha'.rightInvOn hxâ‚ â–¸ NNReal.zero_le_coe\n  convert hxâ‚\n  simpa\n\n"}
{"name":"Real.spectralRadius_mem_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\ninstâœ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\nha' : SpectrumRestricts a â‡‘ContinuousMap.realToNNReal\nâŠ¢ Membership.mem (spectrum Real a) (spectralRadius Real a).toReal","decl":"lemma _root_.Real.spectralRadius_mem_spectrum {A : Type*} [NormedRing A] [NormedAlgebra â„ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum â„ a).Nonempty)\n    (ha' : SpectrumRestricts a ContinuousMap.realToNNReal) :\n    (spectralRadius â„ a).toReal âˆˆ spectrum â„ a :=\n  NNReal.spectralRadius_mem_spectrum ha ha'\n\n"}
{"name":"Real.spectralRadius_mem_spectrum_or","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\ninstâœ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\nâŠ¢ Or (Membership.mem (spectrum Real a) (spectralRadius Real a).toReal) (Membership.mem (spectrum Real a) (Neg.neg (spectralRadius Real a).toReal))","decl":"lemma _root_.Real.spectralRadius_mem_spectrum_or {A : Type*} [NormedRing A] [NormedAlgebra â„ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum â„ a).Nonempty) :\n    (spectralRadius â„ a).toReal âˆˆ spectrum â„ a âˆ¨ -(spectralRadius â„ a).toReal âˆˆ spectrum â„ a := by\n  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty ha\n  simp only [â† hxâ‚‚, ENNReal.coe_toReal, coe_nnnorm, Real.norm_eq_abs]\n  exact abs_choice x |>.imp (fun h â†¦ by rwa [h]) (fun h â†¦ by simpa [h])\n\n"}
{"name":"QuasispectrumRestricts.compactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœÂ¹â° : Semifield R\ninstâœâ¹ : Field S\ninstâœâ¸ : NonUnitalRing A\ninstâœâ· : Algebra R S\ninstâœâ¶ : Module R A\ninstâœâµ : Module S A\ninstâœâ´ : IsScalarTower S A A\ninstâœÂ³ : SMulCommClass S A A\ninstâœÂ² : IsScalarTower R S A\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSpace S\na : A\nf : ContinuousMap S R\nh : QuasispectrumRestricts a â‡‘f\nh_cpct : CompactSpace â†‘(quasispectrum S a)\nâŠ¢ CompactSpace â†‘(quasispectrum R a)","decl":"lemma compactSpace {R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A]\n    [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A] [SMulCommClass S A A]\n    [IsScalarTower R S A] [TopologicalSpace R] [TopologicalSpace S] {a : A} (f : C(S, R))\n    (h : QuasispectrumRestricts a f) [h_cpct : CompactSpace (Ïƒâ‚™ S a)] :\n    CompactSpace (Ïƒâ‚™ R a) := by\n  rw [â† isCompact_iff_compactSpace] at h_cpct âŠ¢\n  exact h.image â–¸ h_cpct.image (map_continuous f)\n\n"}
{"name":"QuasispectrumRestricts.nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module Real A\ninstâœÂ¹ : IsScalarTower Real A A\ninstâœ : SMulCommClass Real A A\na : A\nâŠ¢ Iff (QuasispectrumRestricts a â‡‘ContinuousMap.realToNNReal) (âˆ€ (x : Real), Membership.mem (quasispectrum Real a) x â†’ LE.le 0 x)","decl":"lemma nnreal_iff [Module â„ A] [IsScalarTower â„ A A] [SMulCommClass â„ A A] {a : A} :\n    QuasispectrumRestricts a ContinuousMap.realToNNReal â†” âˆ€ x âˆˆ Ïƒâ‚™ â„ a, 0 â‰¤ x := by\n  rw [quasispectrumRestricts_iff_spectrumRestricts_inr,\n    Unitization.quasispectrum_eq_spectrum_inr' _ â„, SpectrumRestricts.nnreal_iff]\n\n"}
{"name":"QuasispectrumRestricts.nnreal_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœâµ : NonUnitalRing A\ninstâœâ´ : Module Real A\ninstâœÂ³ : IsScalarTower Real A A\ninstâœÂ² : SMulCommClass Real A A\ninstâœÂ¹ : PartialOrder A\ninstâœ : NonnegSpectrumClass Real A\na : A\nha : LE.le 0 a\nâŠ¢ QuasispectrumRestricts a â‡‘ContinuousMap.realToNNReal","decl":"lemma nnreal_of_nonneg [Module â„ A] [IsScalarTower â„ A A] [SMulCommClass â„ A A] [PartialOrder A]\n    [NonnegSpectrumClass â„ A] {a : A} (ha : 0 â‰¤ a) :\n    QuasispectrumRestricts a ContinuousMap.realToNNReal :=\n  nnreal_iff.mpr <| quasispectrum_nonneg_of_nonneg _ ha\n\n"}
{"name":"QuasispectrumRestricts.real_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module Complex A\ninstâœÂ¹ : IsScalarTower Complex A A\ninstâœ : SMulCommClass Complex A A\na : A\nâŠ¢ Iff (QuasispectrumRestricts a â‡‘Complex.reCLM) (âˆ€ (x : Complex), Membership.mem (quasispectrum Complex a) x â†’ Eq x â†‘x.re)","decl":"lemma real_iff [Module â„‚ A] [IsScalarTower â„‚ A A] [SMulCommClass â„‚ A A] {a : A} :\n    QuasispectrumRestricts a Complex.reCLM â†” âˆ€ x âˆˆ Ïƒâ‚™ â„‚ a, x = x.re := by\n  rw [quasispectrumRestricts_iff_spectrumRestricts_inr,\n    Unitization.quasispectrum_eq_spectrum_inr' _ â„‚, SpectrumRestricts.real_iff]\n\n"}
{"name":"QuasispectrumRestricts.le_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module Real A\ninstâœÂ¹ : IsScalarTower Real A A\ninstâœ : SMulCommClass Real A A\na : A\nha : QuasispectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (quasispectrum NNReal a) x â†’ LE.le x r) (âˆ€ (x : Real), Membership.mem (quasispectrum Real a) x â†’ LE.le x â†‘r)","decl":"lemma le_nnreal_iff [Module â„ A] [IsScalarTower â„ A A] [SMulCommClass â„ A A] {a : A}\n    (ha : QuasispectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ quasispectrum â„â‰¥0 a, x â‰¤ r) â†” âˆ€ x âˆˆ quasispectrum â„ a, x â‰¤ r := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"QuasispectrumRestricts.lt_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : NonUnitalRing A\ninstâœÂ² : Module Real A\ninstâœÂ¹ : IsScalarTower Real A A\ninstâœ : SMulCommClass Real A A\na : A\nha : QuasispectrumRestricts a â‡‘ContinuousMap.realToNNReal\nr : NNReal\nâŠ¢ Iff (âˆ€ (x : NNReal), Membership.mem (quasispectrum NNReal a) x â†’ LT.lt x r) (âˆ€ (x : Real), Membership.mem (quasispectrum Real a) x â†’ LT.lt x â†‘r)","decl":"lemma lt_nnreal_iff [Module â„ A] [IsScalarTower â„ A A] [SMulCommClass â„ A A] {a : A}\n    (ha : QuasispectrumRestricts a ContinuousMap.realToNNReal) {r : â„â‰¥0} :\n    (âˆ€ x âˆˆ quasispectrum â„â‰¥0 a, x < r) â†” âˆ€ x âˆˆ quasispectrum â„ a, x < r := by\n  simp [â† ha.algebraMap_image]\n\n"}
{"name":"coe_mem_spectrum_real_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninstâœÂ³ : Ring A\ninstâœÂ² : PartialOrder A\ninstâœÂ¹ : Algebra Real A\ninstâœ : NonnegSpectrumClass Real A\na : A\nx : NNReal\nha : autoParam (LE.le 0 a) _autoâœ\nâŠ¢ Iff (Membership.mem (spectrum Real a) â†‘x) (Membership.mem (spectrum NNReal a) x)","decl":"lemma coe_mem_spectrum_real_of_nonneg [Algebra â„ A] [NonnegSpectrumClass â„ A] {a : A} {x : â„â‰¥0}\n    (ha : 0 â‰¤ a := by cfc_tac) :\n    (x : â„) âˆˆ spectrum â„ a â†” x âˆˆ spectrum â„â‰¥0 a := by\n  simp [â† (SpectrumRestricts.nnreal_of_nonneg ha).algebraMap_image, Set.mem_image,\n    NNReal.algebraMap_eq_coe]\n"}
