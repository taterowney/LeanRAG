{"name":"spectrum.SpectralRadius.of_subsingleton","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : Subsingleton A\na : A\n⊢ Eq (spectralRadius 𝕜 a) 0","decl":"@[simp]\ntheorem SpectralRadius.of_subsingleton [Subsingleton A] (a : A) : spectralRadius 𝕜 a = 0 := by\n  simp [spectralRadius]\n\n"}
{"name":"spectrum.spectralRadius_zero","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ Eq (spectralRadius 𝕜 0) 0","decl":"@[simp]\ntheorem spectralRadius_zero : spectralRadius 𝕜 (0 : A) = 0 := by\n  nontriviality A\n  simp [spectralRadius]\n\n"}
{"name":"spectrum.mem_resolventSet_of_spectralRadius_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\na : A\nk : 𝕜\nh : LT.lt (spectralRadius 𝕜 a) ↑(NNNorm.nnnorm k)\n⊢ Membership.mem (resolventSet 𝕜 a) k","decl":"theorem mem_resolventSet_of_spectralRadius_lt {a : A} {k : 𝕜} (h : spectralRadius 𝕜 a < ‖k‖₊) :\n    k ∈ ρ a :=\n  Classical.not_not.mp fun hn => h.not_le <| le_iSup₂ (α := ℝ≥0∞) k hn\n\n"}
{"name":"spectrum.isOpen_resolventSet","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ IsOpen (resolventSet 𝕜 a)","decl":"theorem isOpen_resolventSet (a : A) : IsOpen (ρ a) :=\n  Units.isOpen.preimage ((continuous_algebraMap 𝕜 A).sub continuous_const)\n\n"}
{"name":"spectrum.isClosed","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ IsClosed (spectrum 𝕜 a)","decl":"protected theorem isClosed (a : A) : IsClosed (σ a) :=\n  (isOpen_resolventSet a).isClosed_compl\n\n"}
{"name":"spectrum.mem_resolventSet_of_norm_lt_mul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nk : 𝕜\nh : LT.lt (HMul.hMul (Norm.norm a) (Norm.norm 1)) (Norm.norm k)\n⊢ Membership.mem (resolventSet 𝕜 a) k","decl":"theorem mem_resolventSet_of_norm_lt_mul {a : A} {k : 𝕜} (h : ‖a‖ * ‖(1 : A)‖ < ‖k‖) : k ∈ ρ a := by\n  rw [resolventSet, Set.mem_setOf_eq, Algebra.algebraMap_eq_smul_one]\n  nontriviality A\n  have hk : k ≠ 0 :=\n    ne_zero_of_norm_ne_zero ((mul_nonneg (norm_nonneg _) (norm_nonneg _)).trans_lt h).ne'\n  letI ku := Units.map ↑ₐ.toMonoidHom (Units.mk0 k hk)\n  rw [← inv_inv ‖(1 : A)‖,\n    mul_inv_lt_iff₀' (inv_pos.2 <| norm_pos_iff.2 (one_ne_zero : (1 : A) ≠ 0))] at h\n  have hku : ‖-a‖ < ‖(↑ku⁻¹ : A)‖⁻¹ := by simpa [ku, norm_algebraMap] using h\n  simpa [ku, sub_eq_add_neg, Algebra.algebraMap_eq_smul_one] using (ku.add (-a) hku).isUnit\n\n"}
{"name":"spectrum.mem_resolventSet_of_norm_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\nk : 𝕜\nh : LT.lt (Norm.norm a) (Norm.norm k)\n⊢ Membership.mem (resolventSet 𝕜 a) k","decl":"theorem mem_resolventSet_of_norm_lt [NormOneClass A] {a : A} {k : 𝕜} (h : ‖a‖ < ‖k‖) : k ∈ ρ a :=\n  mem_resolventSet_of_norm_lt_mul (by rwa [norm_one, mul_one])\n\n"}
{"name":"spectrum.norm_le_norm_mul_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nk : 𝕜\nhk : Membership.mem (spectrum 𝕜 a) k\n⊢ LE.le (Norm.norm k) (HMul.hMul (Norm.norm a) (Norm.norm 1))","decl":"theorem norm_le_norm_mul_of_mem {a : A} {k : 𝕜} (hk : k ∈ σ a) : ‖k‖ ≤ ‖a‖ * ‖(1 : A)‖ :=\n  le_of_not_lt <| mt mem_resolventSet_of_norm_lt_mul hk\n\n"}
{"name":"spectrum.norm_le_norm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\nk : 𝕜\nhk : Membership.mem (spectrum 𝕜 a) k\n⊢ LE.le (Norm.norm k) (Norm.norm a)","decl":"theorem norm_le_norm_of_mem [NormOneClass A] {a : A} {k : 𝕜} (hk : k ∈ σ a) : ‖k‖ ≤ ‖a‖ :=\n  le_of_not_lt <| mt mem_resolventSet_of_norm_lt hk\n\n"}
{"name":"spectrum.subset_closedBall_norm_mul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ HasSubset.Subset (spectrum 𝕜 a) (Metric.closedBall 0 (HMul.hMul (Norm.norm a) (Norm.norm 1)))","decl":"theorem subset_closedBall_norm_mul (a : A) : σ a ⊆ Metric.closedBall (0 : 𝕜) (‖a‖ * ‖(1 : A)‖) :=\n  fun k hk => by simp [norm_le_norm_mul_of_mem hk]\n\n"}
{"name":"spectrum.subset_closedBall_norm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\n⊢ HasSubset.Subset (spectrum 𝕜 a) (Metric.closedBall 0 (Norm.norm a))","decl":"theorem subset_closedBall_norm [NormOneClass A] (a : A) : σ a ⊆ Metric.closedBall (0 : 𝕜) ‖a‖ :=\n  fun k hk => by simp [norm_le_norm_of_mem hk]\n\n"}
{"name":"spectrum.isBounded","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ Bornology.IsBounded (spectrum 𝕜 a)","decl":"theorem isBounded (a : A) : Bornology.IsBounded (σ a) :=\n  Metric.isBounded_closedBall.subset (subset_closedBall_norm_mul a)\n\n"}
{"name":"spectrum.isCompact","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : ProperSpace 𝕜\na : A\n⊢ IsCompact (spectrum 𝕜 a)","decl":"protected theorem isCompact [ProperSpace 𝕜] (a : A) : IsCompact (σ a) :=\n  Metric.isCompact_of_isClosed_isBounded (spectrum.isClosed a) (isBounded a)\n\n"}
{"name":"spectrum.instCompactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : ProperSpace 𝕜\na : A\n⊢ CompactSpace ↑(spectrum 𝕜 a)","decl":"instance instCompactSpace [ProperSpace 𝕜] (a : A) : CompactSpace (spectrum 𝕜 a) :=\n  isCompact_iff_compactSpace.mp <| spectrum.isCompact a\n\n"}
{"name":"spectrum.instCompactSpaceNNReal","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na : A\ninst✝ : CompactSpace ↑(spectrum Real a)\n⊢ CompactSpace ↑(spectrum NNReal a)","decl":"instance instCompactSpaceNNReal {A : Type*} [NormedRing A] [NormedAlgebra ℝ A]\n    (a : A) [CompactSpace (spectrum ℝ a)] : CompactSpace (spectrum ℝ≥0 a) := by\n  rw [← isCompact_iff_compactSpace] at *\n  rw [← preimage_algebraMap ℝ]\n  exact isClosed_nonneg.isClosedEmbedding_subtypeVal.isCompact_preimage <| by assumption\n\n"}
{"name":"quasispectrum.isCompact","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NormedField 𝕜\nB : Type u_3\ninst✝⁵ : NonUnitalNormedRing B\ninst✝⁴ : NormedSpace 𝕜 B\ninst✝³ : CompleteSpace B\ninst✝² : IsScalarTower 𝕜 B B\ninst✝¹ : SMulCommClass 𝕜 B B\ninst✝ : ProperSpace 𝕜\na : B\n⊢ IsCompact (quasispectrum 𝕜 a)","decl":"theorem _root_.quasispectrum.isCompact (a : B) : IsCompact (quasispectrum 𝕜 a) := by\n  rw [Unitization.quasispectrum_eq_spectrum_inr' 𝕜 𝕜,\n    ← AlgEquiv.spectrum_eq (WithLp.unitizationAlgEquiv 𝕜).symm (a : Unitization 𝕜 B)]\n  exact spectrum.isCompact _\n\n"}
{"name":"quasispectrum.instCompactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NormedField 𝕜\nB : Type u_3\ninst✝⁵ : NonUnitalNormedRing B\ninst✝⁴ : NormedSpace 𝕜 B\ninst✝³ : CompleteSpace B\ninst✝² : IsScalarTower 𝕜 B B\ninst✝¹ : SMulCommClass 𝕜 B B\ninst✝ : ProperSpace 𝕜\na : B\n⊢ CompactSpace ↑(quasispectrum 𝕜 a)","decl":"instance _root_.quasispectrum.instCompactSpace (a : B) :\n    CompactSpace (quasispectrum 𝕜 a) :=\n  isCompact_iff_compactSpace.mp <| quasispectrum.isCompact a\n\n"}
{"name":"quasispectrum.instCompactSpaceNNReal","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"B : Type u_3\ninst✝⁴ : NonUnitalNormedRing B\ninst✝³ : NormedSpace Real B\ninst✝² : IsScalarTower Real B B\ninst✝¹ : SMulCommClass Real B B\na : B\ninst✝ : CompactSpace ↑(quasispectrum Real a)\n⊢ CompactSpace ↑(quasispectrum NNReal a)","decl":"instance _root_.quasispectrum.instCompactSpaceNNReal [NormedSpace ℝ B] [IsScalarTower ℝ B B]\n    [SMulCommClass ℝ B B] (a : B) [CompactSpace (quasispectrum ℝ a)] :\n    CompactSpace (quasispectrum ℝ≥0 a) := by\n  rw [← isCompact_iff_compactSpace] at *\n  rw [← quasispectrum.preimage_algebraMap ℝ]\n  exact isClosed_nonneg.isClosedEmbedding_subtypeVal.isCompact_preimage <| by assumption\n\n"}
{"name":"spectrum.le_nnnorm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Real A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\nr : NNReal\nhr : Membership.mem (spectrum NNReal a) r\n⊢ LE.le r (NNNorm.nnnorm a)","decl":"theorem le_nnnorm_of_mem {a : A} {r : ℝ≥0} (hr : r ∈ spectrum ℝ≥0 a) :\n    r ≤ ‖a‖₊ := calc\n  r ≤ ‖(r : ℝ)‖ := Real.le_norm_self _\n  _ ≤ ‖a‖       := norm_le_norm_of_mem hr\n\n"}
{"name":"spectrum.coe_le_norm_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Real A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\nr : NNReal\nhr : Membership.mem (spectrum NNReal a) r\n⊢ LE.le (↑r) (Norm.norm a)","decl":"theorem coe_le_norm_of_mem {a : A} {r : ℝ≥0} (hr : r ∈ spectrum ℝ≥0 a) :\n    r ≤ ‖a‖ :=\n  coe_mono <| le_nnnorm_of_mem hr\n\n"}
{"name":"spectrum.spectralRadius_le_nnnorm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\na : A\n⊢ LE.le (spectralRadius 𝕜 a) ↑(NNNorm.nnnorm a)","decl":"theorem spectralRadius_le_nnnorm [NormOneClass A] (a : A) : spectralRadius 𝕜 a ≤ ‖a‖₊ := by\n  refine iSup₂_le fun k hk => ?_\n  exact mod_cast norm_le_norm_of_mem hk\n\n"}
{"name":"spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : ProperSpace 𝕜\na : A\nha : (spectrum 𝕜 a).Nonempty\n⊢ Exists fun k => And (Membership.mem (spectrum 𝕜 a) k) (Eq (↑(NNNorm.nnnorm k)) (spectralRadius 𝕜 a))","decl":"theorem exists_nnnorm_eq_spectralRadius_of_nonempty [ProperSpace 𝕜] {a : A} (ha : (σ a).Nonempty) :\n    ∃ k ∈ σ a, (‖k‖₊ : ℝ≥0∞) = spectralRadius 𝕜 a := by\n  obtain ⟨k, hk, h⟩ := (spectrum.isCompact a).exists_isMaxOn ha continuous_nnnorm.continuousOn\n  exact ⟨k, hk, le_antisymm (le_iSup₂ (α := ℝ≥0∞) k hk) (iSup₂_le <| mod_cast h)⟩\n\n"}
{"name":"spectrum.spectralRadius_lt_of_forall_lt_of_nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : ProperSpace 𝕜\na : A\nha : (spectrum 𝕜 a).Nonempty\nr : NNReal\nhr : ∀ (k : 𝕜), Membership.mem (spectrum 𝕜 a) k → LT.lt (NNNorm.nnnorm k) r\n⊢ LT.lt (spectralRadius 𝕜 a) ↑r","decl":"theorem spectralRadius_lt_of_forall_lt_of_nonempty [ProperSpace 𝕜] {a : A} (ha : (σ a).Nonempty)\n    {r : ℝ≥0} (hr : ∀ k ∈ σ a, ‖k‖₊ < r) : spectralRadius 𝕜 a < r :=\n  sSup_image.symm.trans_lt <| ((spectrum.isCompact a).sSup_lt_iff_of_continuous ha\n    continuous_enorm.continuousOn (r : ℝ≥0∞)).mpr (by simpa using hr)\n\n"}
{"name":"spectrum.spectralRadius_le_pow_nnnorm_pow_one_div","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nn : Nat\n⊢ LE.le (spectralRadius 𝕜 a) (HMul.hMul (HPow.hPow (↑(NNNorm.nnnorm (HPow.hPow a (HAdd.hAdd n 1)))) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))) (HPow.hPow (↑(NNNorm.nnnorm 1)) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))))","decl":"theorem spectralRadius_le_pow_nnnorm_pow_one_div (a : A) (n : ℕ) :\n    spectralRadius 𝕜 a ≤ (‖a ^ (n + 1)‖₊ : ℝ≥0∞) ^ (1 / (n + 1) : ℝ) *\n      (‖(1 : A)‖₊ : ℝ≥0∞) ^ (1 / (n + 1) : ℝ) := by\n  refine iSup₂_le fun k hk => ?_\n  -- apply easy direction of the spectral mapping theorem for polynomials\n  have pow_mem : k ^ (n + 1) ∈ σ (a ^ (n + 1)) := by\n    simpa only [one_mul, Algebra.algebraMap_eq_smul_one, one_smul, aeval_monomial, one_mul,\n      eval_monomial] using subset_polynomial_aeval a (@monomial 𝕜 _ (n + 1) (1 : 𝕜)) ⟨k, hk, rfl⟩\n  -- power of the norm is bounded by norm of the power\n  have nnnorm_pow_le : (↑(‖k‖₊ ^ (n + 1)) : ℝ≥0∞) ≤ ‖a ^ (n + 1)‖₊ * ‖(1 : A)‖₊ := by\n    simpa only [Real.toNNReal_mul (norm_nonneg _), norm_toNNReal, nnnorm_pow k (n + 1),\n      ENNReal.coe_mul] using coe_mono (Real.toNNReal_mono (norm_le_norm_mul_of_mem pow_mem))\n  -- take (n + 1)ᵗʰ roots and clean up the left-hand side\n  have hn : 0 < ((n + 1 : ℕ) : ℝ) := mod_cast Nat.succ_pos'\n  convert monotone_rpow_of_nonneg (one_div_pos.mpr hn).le nnnorm_pow_le using 1\n  all_goals dsimp\n  · rw [one_div, pow_rpow_inv_natCast]\n    positivity\n  rw [Nat.cast_succ, ENNReal.coe_mul_rpow]\n\n"}
{"name":"spectrum.spectralRadius_le_liminf_pow_nnnorm_pow_one_div","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ LE.le (spectralRadius 𝕜 a) (Filter.liminf (fun n => HPow.hPow (↑(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 ↑n)) Filter.atTop)","decl":"theorem spectralRadius_le_liminf_pow_nnnorm_pow_one_div (a : A) :\n    spectralRadius 𝕜 a ≤ atTop.liminf fun n : ℕ => (‖a ^ n‖₊ : ℝ≥0∞) ^ (1 / n : ℝ) := by\n  refine ENNReal.le_of_forall_lt_one_mul_le fun ε hε => ?_\n  by_cases h : ε = 0\n  · simp only [h, zero_mul, zero_le']\n  simp only [ENNReal.mul_le_iff_le_inv h (hε.trans_le le_top).ne, mul_comm ε⁻¹,\n    liminf_eq_iSup_iInf_of_nat', ENNReal.iSup_mul]\n  conv_rhs => arg 1; intro i; rw [ENNReal.iInf_mul (by simp [h])]\n  rw [← ENNReal.inv_lt_inv, inv_one] at hε\n  obtain ⟨N, hN⟩ := eventually_atTop.mp\n    (ENNReal.eventually_pow_one_div_le (ENNReal.coe_ne_top : ↑‖(1 : A)‖₊ ≠ ∞) hε)\n  refine le_trans ?_ (le_iSup _ (N + 1))\n  refine le_iInf fun n => ?_\n  simp only [← add_assoc]\n  refine (spectralRadius_le_pow_nnnorm_pow_one_div 𝕜 a (n + N)).trans ?_\n  norm_cast\n  exact mul_le_mul_left' (hN (n + N + 1) (by omega)) _\n\n"}
{"name":"spectrum.hasDerivAt_resolvent","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nk : 𝕜\nhk : Membership.mem (resolventSet 𝕜 a) k\n⊢ HasDerivAt (resolvent a) (Neg.neg (HPow.hPow (resolvent a k) 2)) k","decl":"theorem hasDerivAt_resolvent {a : A} {k : 𝕜} (hk : k ∈ ρ a) :\n    HasDerivAt (resolvent a) (-resolvent a k ^ 2) k := by\n  have H₁ : HasFDerivAt Ring.inverse _ (↑ₐ k - a) := hasFDerivAt_ring_inverse (𝕜 := 𝕜) hk.unit\n  have H₂ : HasDerivAt (fun k => ↑ₐ k - a) 1 k := by\n    simpa using (Algebra.linearMap 𝕜 A).hasDerivAt.sub_const a\n  simpa [resolvent, sq, hk.unit_spec, ← Ring.inverse_unit hk.unit] using H₁.comp_hasDerivAt k H₂\n\n-- refactored so this result was no longer necessary or useful\n\n"}
{"name":"spectrum.eventually_isUnit_resolvent","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ Filter.Eventually (fun z => IsUnit (resolvent a z)) (Bornology.cobounded 𝕜)","decl":"theorem eventually_isUnit_resolvent (a : A) : ∀ᶠ z in cobounded 𝕜, IsUnit (resolvent a z) := by\n  rw [atTop_basis_Ioi.cobounded_of_norm.eventually_iff]\n  exact ⟨‖a‖ * ‖(1 : A)‖, trivial, fun _ ↦ isUnit_resolvent.mp ∘ mem_resolventSet_of_norm_lt_mul⟩\n\n"}
{"name":"spectrum.resolvent_isBigO_inv","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ Asymptotics.IsBigO (Bornology.cobounded 𝕜) (resolvent a) Inv.inv","decl":"theorem resolvent_isBigO_inv (a : A) : resolvent a =O[cobounded 𝕜] Inv.inv :=\n  have h : (fun z ↦ resolvent (z⁻¹ • a) (1 : 𝕜)) =O[cobounded 𝕜] (fun _ ↦ (1 : ℝ)) := by\n    simpa [Function.comp_def, resolvent] using\n      (NormedRing.inverse_one_sub_norm (R := A)).comp_tendsto\n        (by simpa using (tendsto_inv₀_cobounded (α := 𝕜)).smul_const a)\n  calc\n    resolvent a =ᶠ[cobounded 𝕜] fun z ↦ z⁻¹ • resolvent (z⁻¹ • a) (1 : 𝕜) := by\n      filter_upwards [isBounded_singleton (x := 0)] with z hz\n      lift z to 𝕜ˣ using Ne.isUnit hz\n      simpa [Units.smul_def] using congr(z⁻¹ • $(units_smul_resolvent_self (r := z) (a := a)))\n    _ =O[cobounded 𝕜] (· ⁻¹) := .of_norm_right <| by\n      simpa using (isBigO_refl (· ⁻¹) (cobounded 𝕜)).norm_right.smul h\n\n"}
{"name":"spectrum.resolvent_tendsto_cobounded","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\n⊢ Filter.Tendsto (resolvent a) (Bornology.cobounded 𝕜) (nhds 0)","decl":"theorem resolvent_tendsto_cobounded (a : A) : Tendsto (resolvent a) (cobounded 𝕜) (𝓝 0) :=\n  resolvent_isBigO_inv a |>.trans_tendsto tendsto_inv₀_cobounded\n\n"}
{"name":"spectrum.hasFPowerSeriesOnBall_inverse_one_sub_smul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : HasSummableGeomSeries A\na : A\n⊢ HasFPowerSeriesOnBall (fun z => Ring.inverse (HSub.hSub 1 (HSMul.hSMul z a))) (fun n => ContinuousMultilinearMap.mkPiRing 𝕜 (Fin n) (HPow.hPow a n)) 0 (Inv.inv ↑(NNNorm.nnnorm a))","decl":"/-- In a Banach algebra `A` over a nontrivially normed field `𝕜`, for any `a : A` the\npower series with coefficients `a ^ n` represents the function `(1 - z • a)⁻¹` in a disk of\nradius `‖a‖₊⁻¹`. -/\ntheorem hasFPowerSeriesOnBall_inverse_one_sub_smul [HasSummableGeomSeries A] (a : A) :\n    HasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))\n      (fun n => ContinuousMultilinearMap.mkPiRing 𝕜 (Fin n) (a ^ n)) 0 ‖a‖₊⁻¹ :=\n  { r_le := by\n      refine le_of_forall_nnreal_lt fun r hr =>\n        le_radius_of_bound_nnreal _ (max 1 ‖(1 : A)‖₊) fun n => ?_\n      rw [← norm_toNNReal, norm_mkPiRing, norm_toNNReal]\n      cases' n with n\n      · simp only [le_refl, mul_one, or_true, le_max_iff, pow_zero]\n      · refine\n          le_trans (le_trans (mul_le_mul_right' (nnnorm_pow_le' a n.succ_pos) (r ^ n.succ)) ?_)\n            (le_max_left _ _)\n        by_cases h : ‖a‖₊ = 0\n        · simp only [h, zero_mul, zero_le', pow_succ']\n        · rw [← coe_inv h, coe_lt_coe, NNReal.lt_inv_iff_mul_lt h] at hr\n          simpa only [← mul_pow, mul_comm] using pow_le_one' hr.le n.succ\n    r_pos := ENNReal.inv_pos.mpr coe_ne_top\n    hasSum := fun {y} hy => by\n      have norm_lt : ‖y • a‖ < 1 := by\n        by_cases h : ‖a‖₊ = 0\n        · simp only [nnnorm_eq_zero.mp h, norm_zero, zero_lt_one, smul_zero]\n        · have nnnorm_lt : ‖y‖₊ < ‖a‖₊⁻¹ := by\n            simpa only [← coe_inv h, mem_ball_zero_iff, Metric.emetric_ball_nnreal] using hy\n          rwa [← coe_nnnorm, ← Real.lt_toNNReal_iff_coe_lt, Real.toNNReal_one, nnnorm_smul,\n            ← NNReal.lt_inv_iff_mul_lt h]\n      simpa [← smul_pow, (summable_geometric_of_norm_lt_one norm_lt).hasSum_iff] using\n        (NormedRing.inverse_one_sub _ norm_lt).symm }\n\n"}
{"name":"spectrum.isUnit_one_sub_smul_of_lt_inv_radius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\na : A\nz : 𝕜\nh : LT.lt (↑(NNNorm.nnnorm z)) (Inv.inv (spectralRadius 𝕜 a))\n⊢ IsUnit (HSub.hSub 1 (HSMul.hSMul z a))","decl":"theorem isUnit_one_sub_smul_of_lt_inv_radius {a : A} {z : 𝕜} (h : ↑‖z‖₊ < (spectralRadius 𝕜 a)⁻¹) :\n    IsUnit (1 - z • a) := by\n  by_cases hz : z = 0\n  · simp only [hz, isUnit_one, sub_zero, zero_smul]\n  · let u := Units.mk0 z hz\n    suffices hu : IsUnit (u⁻¹ • (1 : A) - a) by\n      rwa [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv u] at hu\n    rw [Units.smul_def, ← Algebra.algebraMap_eq_smul_one, ← mem_resolventSet_iff]\n    refine mem_resolventSet_of_spectralRadius_lt ?_\n    rwa [Units.val_inv_eq_inv_val, nnnorm_inv,\n      coe_inv (nnnorm_ne_zero_iff.mpr (Units.val_mk0 hz ▸ hz : (u : 𝕜) ≠ 0)), lt_inv_iff_lt_inv]\n\n"}
{"name":"spectrum.differentiableOn_inverse_one_sub_smul","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nr : NNReal\nhr : LT.lt (↑r) (Inv.inv (spectralRadius 𝕜 a))\n⊢ DifferentiableOn 𝕜 (fun z => Ring.inverse (HSub.hSub 1 (HSMul.hSMul z a))) (Metric.closedBall 0 ↑r)","decl":"/-- In a Banach algebra `A` over `𝕜`, for `a : A` the function `fun z ↦ (1 - z • a)⁻¹` is\ndifferentiable on any closed ball centered at zero of radius `r < (spectralRadius 𝕜 a)⁻¹`. -/\ntheorem differentiableOn_inverse_one_sub_smul [CompleteSpace A] {a : A} {r : ℝ≥0}\n    (hr : (r : ℝ≥0∞) < (spectralRadius 𝕜 a)⁻¹) :\n    DifferentiableOn 𝕜 (fun z : 𝕜 => Ring.inverse (1 - z • a)) (Metric.closedBall 0 r) := by\n  intro z z_mem\n  apply DifferentiableAt.differentiableWithinAt\n  have hu : IsUnit (1 - z • a) := by\n    refine isUnit_one_sub_smul_of_lt_inv_radius (lt_of_le_of_lt (coe_mono ?_) hr)\n    simpa only [norm_toNNReal, Real.toNNReal_coe] using\n      Real.toNNReal_mono (mem_closedBall_zero_iff.mp z_mem)\n  have H₁ : Differentiable 𝕜 fun w : 𝕜 => 1 - w • a := (differentiable_id.smul_const a).const_sub 1\n  exact DifferentiableAt.comp z (differentiableAt_inverse hu) H₁.differentiableAt\n\n"}
{"name":"spectrum.limsup_pow_nnnorm_pow_one_div_le_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\n⊢ LE.le (Filter.limsup (fun n => HPow.hPow (↑(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 ↑n)) Filter.atTop) (spectralRadius Complex a)","decl":"/-- The `limsup` relationship for the spectral radius used to prove `spectrum.gelfand_formula`. -/\ntheorem limsup_pow_nnnorm_pow_one_div_le_spectralRadius (a : A) :\n    limsup (fun n : ℕ => (‖a ^ n‖₊ : ℝ≥0∞) ^ (1 / n : ℝ)) atTop ≤ spectralRadius ℂ a := by\n  refine ENNReal.inv_le_inv.mp (le_of_forall_pos_nnreal_lt fun r r_pos r_lt => ?_)\n  simp_rw [inv_limsup, ← one_div]\n  let p : FormalMultilinearSeries ℂ ℂ A := fun n =>\n    ContinuousMultilinearMap.mkPiRing ℂ (Fin n) (a ^ n)\n  suffices h : (r : ℝ≥0∞) ≤ p.radius by\n    convert h\n    simp only [p, p.radius_eq_liminf, ← norm_toNNReal, norm_mkPiRing]\n    congr\n    ext n\n    rw [norm_toNNReal, ENNReal.coe_rpow_def ‖a ^ n‖₊ (1 / n : ℝ), if_neg]\n    exact fun ha => (lt_self_iff_false _).mp\n      (ha.2.trans_le (one_div_nonneg.mpr n.cast_nonneg : 0 ≤ (1 / n : ℝ)))\n  have H₁ := (differentiableOn_inverse_one_sub_smul r_lt).hasFPowerSeriesOnBall r_pos\n  exact ((hasFPowerSeriesOnBall_inverse_one_sub_smul ℂ a).exchange_radius H₁).r_le\n\n"}
{"name":"spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\n⊢ Filter.Tendsto (fun n => HPow.hPow (↑(NNNorm.nnnorm (HPow.hPow a n))) (HDiv.hDiv 1 ↑n)) Filter.atTop (nhds (spectralRadius Complex a))","decl":"/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectralRadius` of `a` is the limit of the sequence `‖a ^ n‖₊ ^ (1 / n)`. -/\ntheorem pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : ℕ => (‖a ^ n‖₊ : ℝ≥0∞) ^ (1 / n : ℝ)) atTop (𝓝 (spectralRadius ℂ a)) :=\n  tendsto_of_le_liminf_of_limsup_le (spectralRadius_le_liminf_pow_nnnorm_pow_one_div ℂ a)\n    (limsup_pow_nnnorm_pow_one_div_le_spectralRadius a)\n\n/- This is the same as `pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius` but for `norm`\ninstead of `nnnorm`. -/\n"}
{"name":"spectrum.pow_norm_pow_one_div_tendsto_nhds_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Complex A\ninst✝ : CompleteSpace A\na : A\n⊢ Filter.Tendsto (fun n => ENNReal.ofReal (HPow.hPow (Norm.norm (HPow.hPow a n)) (HDiv.hDiv 1 ↑n))) Filter.atTop (nhds (spectralRadius Complex a))","decl":"/-- **Gelfand's formula**: Given an element `a : A` of a complex Banach algebra, the\n`spectralRadius` of `a` is the limit of the sequence `‖a ^ n‖₊ ^ (1 / n)`. -/\ntheorem pow_norm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : ℕ => ENNReal.ofReal (‖a ^ n‖ ^ (1 / n : ℝ))) atTop\n      (𝓝 (spectralRadius ℂ a)) := by\n  convert pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius a using 1\n  ext1\n  rw [← ofReal_rpow_of_nonneg (norm_nonneg _) _, ← coe_nnnorm, coe_nnreal_eq]\n  exact one_div_nonneg.mpr (mod_cast zero_le _)\n\n"}
{"name":"spectrum.nonempty","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\na : A\n⊢ (spectrum Complex a).Nonempty","decl":"/-- In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. -/\nprotected theorem nonempty : (spectrum ℂ a).Nonempty := by\n  /- Suppose `σ a = ∅`, then resolvent set is `ℂ`, any `(z • 1 - a)` is a unit, and `resolvent a`\n    is differentiable on `ℂ`. -/\n  by_contra! h\n  have H₀ : resolventSet ℂ a = Set.univ := by rwa [spectrum, Set.compl_empty_iff] at h\n  have H₁ : Differentiable ℂ fun z : ℂ => resolvent a z := fun z =>\n    (hasDerivAt_resolvent (H₀.symm ▸ Set.mem_univ z : z ∈ resolventSet ℂ a)).differentiableAt\n  /- Since `resolvent a` tends to zero at infinity, by Liouville's theorem `resolvent a = 0`,\n  which contradicts that `resolvent a z` is invertible. -/\n  have H₃ := H₁.apply_eq_of_tendsto_cocompact 0 <| by\n    simpa [Metric.cobounded_eq_cocompact] using resolvent_tendsto_cobounded a (𝕜 := ℂ)\n  exact not_isUnit_zero <| H₃ ▸ (isUnit_resolvent.mp <| H₀.symm ▸ Set.mem_univ 0)\n\n"}
{"name":"spectrum.exists_nnnorm_eq_spectralRadius","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\na : A\n⊢ Exists fun z => And (Membership.mem (spectrum Complex a) z) (Eq (↑(NNNorm.nnnorm z)) (spectralRadius Complex a))","decl":"/-- In a complex Banach algebra, the spectral radius is always attained by some element of the\nspectrum. -/\ntheorem exists_nnnorm_eq_spectralRadius : ∃ z ∈ spectrum ℂ a, (‖z‖₊ : ℝ≥0∞) = spectralRadius ℂ a :=\n  exists_nnnorm_eq_spectralRadius_of_nonempty (spectrum.nonempty a)\n\n"}
{"name":"spectrum.spectralRadius_lt_of_forall_lt","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\na : A\nr : NNReal\nhr : ∀ (z : Complex), Membership.mem (spectrum Complex a) z → LT.lt (NNNorm.nnnorm z) r\n⊢ LT.lt (spectralRadius Complex a) ↑r","decl":"/-- In a complex Banach algebra, if every element of the spectrum has norm strictly less than\n`r : ℝ≥0`, then the spectral radius is also strictly less than `r`. -/\ntheorem spectralRadius_lt_of_forall_lt {r : ℝ≥0} (hr : ∀ z ∈ spectrum ℂ a, ‖z‖₊ < r) :\n    spectralRadius ℂ a < r :=\n  spectralRadius_lt_of_forall_lt_of_nonempty (spectrum.nonempty a) hr\n\n"}
{"name":"spectrum.map_polynomial_aeval","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\na : A\np : Polynomial Complex\n⊢ Eq (spectrum Complex ((Polynomial.aeval a) p)) (Set.image (fun k => Polynomial.eval k p) (spectrum Complex a))","decl":"/-- The **spectral mapping theorem** for polynomials in a Banach algebra over `ℂ`. -/\ntheorem map_polynomial_aeval (p : ℂ[X]) :\n    spectrum ℂ (aeval a p) = (fun k => eval k p) '' spectrum ℂ a :=\n  map_polynomial_aeval_of_nonempty a p (spectrum.nonempty a)\n\n"}
{"name":"spectrum.map_pow","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : Nontrivial A\na : A\nn : Nat\n⊢ Eq (spectrum Complex (HPow.hPow a n)) (Set.image (fun x => HPow.hPow x n) (spectrum Complex a))","decl":"/-- A specialization of the spectral mapping theorem for polynomials in a Banach algebra over `ℂ`\nto monic monomials. -/\nprotected theorem map_pow (n : ℕ) :\n    spectrum ℂ (a ^ n) = (· ^ n) '' spectrum ℂ a := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval a (X ^ n)\n\n"}
{"name":"spectrum.algebraMap_eq_of_mem","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra Complex A\nhA : ∀ {a : A}, Iff (IsUnit a) (Ne a 0)\na : A\nz : Complex\nh : Membership.mem (spectrum Complex a) z\n⊢ Eq ((algebraMap Complex A) z) a","decl":"theorem algebraMap_eq_of_mem {a : A} {z : ℂ} (h : z ∈ σ a) : algebraMap ℂ A z = a := by\n  rwa [mem_iff, hA, Classical.not_not, sub_eq_zero] at h\n\n"}
{"name":"NormedRing.algEquivComplexOfComplete_symm_apply","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Complex A\nhA : ∀ {a : A}, Iff (IsUnit a) (Ne a 0)\ninst✝ : CompleteSpace A\na : A\n⊢ Eq ((NormedRing.algEquivComplexOfComplete hA).symm a) ⋯.some","decl":"/-- **Gelfand-Mazur theorem**: For a complex Banach division algebra, the natural `algebraMap ℂ A`\nis an algebra isomorphism whose inverse is given by selecting the (unique) element of\n`spectrum ℂ a`. In addition, `algebraMap_isometry` guarantees this map is an isometry.\n\nNote: because `NormedDivisionRing` requires the field `norm_mul' : ∀ a b, ‖a * b‖ = ‖a‖ * ‖b‖`, we\ndon't use this type class and instead opt for a `NormedRing` in which the nonzero elements are\nprecisely the units. This allows for the application of this isomorphism in broader contexts, e.g.,\nto the quotient of a complex Banach algebra by a maximal ideal. In the case when `A` is actually a\n`NormedDivisionRing`, one may fill in the argument `hA` with the lemma `isUnit_iff_ne_zero`. -/\n@[simps]\nnoncomputable def _root_.NormedRing.algEquivComplexOfComplete [CompleteSpace A] : ℂ ≃ₐ[ℂ] A :=\n  let nt : Nontrivial A := ⟨⟨1, 0, hA.mp ⟨⟨1, 1, mul_one _, mul_one _⟩, rfl⟩⟩⟩\n  { Algebra.ofId ℂ A with\n    toFun := algebraMap ℂ A\n    invFun := fun a => (@spectrum.nonempty _ _ _ _ nt a).some\n    left_inv := fun z => by\n      simpa only [@scalar_eq _ _ _ _ _ nt _] using\n        (@spectrum.nonempty _ _ _ _ nt <| algebraMap ℂ A z).some_mem\n    right_inv := fun a => algebraMap_eq_of_mem (@hA) (@spectrum.nonempty _ _ _ _ nt a).some_mem }\n\n"}
{"name":"NormedRing.algEquivComplexOfComplete_apply","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_2\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Complex A\nhA : ∀ {a : A}, Iff (IsUnit a) (Ne a 0)\ninst✝ : CompleteSpace A\na : Complex\n⊢ Eq ((NormedRing.algEquivComplexOfComplete hA) a) ((algebraMap Complex A) a)","decl":"/-- **Gelfand-Mazur theorem**: For a complex Banach division algebra, the natural `algebraMap ℂ A`\nis an algebra isomorphism whose inverse is given by selecting the (unique) element of\n`spectrum ℂ a`. In addition, `algebraMap_isometry` guarantees this map is an isometry.\n\nNote: because `NormedDivisionRing` requires the field `norm_mul' : ∀ a b, ‖a * b‖ = ‖a‖ * ‖b‖`, we\ndon't use this type class and instead opt for a `NormedRing` in which the nonzero elements are\nprecisely the units. This allows for the application of this isomorphism in broader contexts, e.g.,\nto the quotient of a complex Banach algebra by a maximal ideal. In the case when `A` is actually a\n`NormedDivisionRing`, one may fill in the argument `hA` with the lemma `isUnit_iff_ne_zero`. -/\n@[simps]\nnoncomputable def _root_.NormedRing.algEquivComplexOfComplete [CompleteSpace A] : ℂ ≃ₐ[ℂ] A :=\n  let nt : Nontrivial A := ⟨⟨1, 0, hA.mp ⟨⟨1, 1, mul_one _, mul_one _⟩, rfl⟩⟩⟩\n  { Algebra.ofId ℂ A with\n    toFun := algebraMap ℂ A\n    invFun := fun a => (@spectrum.nonempty _ _ _ _ nt a).some\n    left_inv := fun z => by\n      simpa only [@scalar_eq _ _ _ _ _ nt _] using\n        (@spectrum.nonempty _ _ _ _ nt <| algebraMap ℂ A z).some_mem\n    right_inv := fun a => algebraMap_eq_of_mem (@hA) (@spectrum.nonempty _ _ _ _ nt a).some_mem }\n\n"}
{"name":"spectrum.exp_mem_exp","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\na : A\nz : 𝕜\nhz : Membership.mem (spectrum 𝕜 a) z\n⊢ Membership.mem (spectrum 𝕜 (NormedSpace.exp 𝕜 a)) (NormedSpace.exp 𝕜 z)","decl":"/-- For `𝕜 = ℝ` or `𝕜 = ℂ`, `exp 𝕜` maps the spectrum of `a` into the spectrum of `exp 𝕜 a`. -/\ntheorem exp_mem_exp [RCLike 𝕜] [NormedRing A] [NormedAlgebra 𝕜 A] [CompleteSpace A] (a : A)\n    {z : 𝕜} (hz : z ∈ spectrum 𝕜 a) : exp 𝕜 z ∈ spectrum 𝕜 (exp 𝕜 a) := by\n  have hexpmul : exp 𝕜 a = exp 𝕜 (a - ↑ₐ z) * ↑ₐ (exp 𝕜 z) := by\n    rw [algebraMap_exp_comm z, ← exp_add_of_commute (Algebra.commutes z (a - ↑ₐ z)).symm,\n      sub_add_cancel]\n  let b := ∑' n : ℕ, ((n + 1).factorial⁻¹ : 𝕜) • (a - ↑ₐ z) ^ n\n  have hb : Summable fun n : ℕ => ((n + 1).factorial⁻¹ : 𝕜) • (a - ↑ₐ z) ^ n := by\n    refine .of_norm_bounded_eventually _ (Real.summable_pow_div_factorial ‖a - ↑ₐ z‖) ?_\n    filter_upwards [Filter.eventually_cofinite_ne 0] with n hn\n    rw [norm_smul, mul_comm, norm_inv, RCLike.norm_natCast, ← div_eq_mul_inv]\n    exact div_le_div₀ (pow_nonneg (norm_nonneg _) n) (norm_pow_le' (a - ↑ₐ z) (zero_lt_iff.mpr hn))\n      (mod_cast Nat.factorial_pos n) (mod_cast Nat.factorial_le (lt_add_one n).le)\n  have h₀ : (∑' n : ℕ, ((n + 1).factorial⁻¹ : 𝕜) • (a - ↑ₐ z) ^ (n + 1)) = (a - ↑ₐ z) * b := by\n    simpa only [mul_smul_comm, pow_succ'] using hb.tsum_mul_left (a - ↑ₐ z)\n  have h₁ : (∑' n : ℕ, ((n + 1).factorial⁻¹ : 𝕜) • (a - ↑ₐ z) ^ (n + 1)) = b * (a - ↑ₐ z) := by\n    simpa only [pow_succ, Algebra.smul_mul_assoc] using hb.tsum_mul_right (a - ↑ₐ z)\n  have h₃ : exp 𝕜 (a - ↑ₐ z) = 1 + (a - ↑ₐ z) * b := by\n    rw [exp_eq_tsum]\n    convert tsum_eq_zero_add (expSeries_summable' (𝕂 := 𝕜) (a - ↑ₐ z))\n    · simp only [Nat.factorial_zero, Nat.cast_one, inv_one, pow_zero, one_smul]\n    · exact h₀.symm\n  rw [spectrum.mem_iff, IsUnit.sub_iff, ← one_mul (↑ₐ (exp 𝕜 z)), hexpmul, ← _root_.sub_mul,\n    Commute.isUnit_mul_iff (Algebra.commutes (exp 𝕜 z) (exp 𝕜 (a - ↑ₐ z) - 1)).symm,\n    sub_eq_iff_eq_add'.mpr h₃, Commute.isUnit_mul_iff (h₀ ▸ h₁ : (a - ↑ₐ z) * b = b * (a - ↑ₐ z))]\n  exact not_and_of_not_left _ (not_and_of_not_left _ ((not_iff_not.mpr IsUnit.sub_iff).mp hz))\n\n"}
{"name":"AlgHom.instContinuousLinearMapClassOfAlgHomClass","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\nF : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : NormedRing A\ninst✝³ : NormedAlgebra 𝕜 A\ninst✝² : CompleteSpace A\ninst✝¹ : FunLike F A 𝕜\ninst✝ : AlgHomClass F 𝕜 A 𝕜\n⊢ ContinuousLinearMapClass F 𝕜 A 𝕜","decl":"instance (priority := 100) [FunLike F A 𝕜] [AlgHomClass F 𝕜 A 𝕜] :\n    ContinuousLinearMapClass F 𝕜 A 𝕜 :=\n  { AlgHomClass.linearMapClass with\n    map_continuous := fun φ =>\n      AddMonoidHomClass.continuous_of_bound φ ‖(1 : A)‖ fun a =>\n        mul_comm ‖a‖ ‖(1 : A)‖ ▸ spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum φ _) }\n\n"}
{"name":"AlgHom.coe_toContinuousLinearMap","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : CompleteSpace A\nφ : AlgHom 𝕜 A 𝕜\n⊢ Eq ⇑φ.toContinuousLinearMap ⇑φ","decl":"@[simp]\ntheorem coe_toContinuousLinearMap (φ : A →ₐ[𝕜] 𝕜) : ⇑φ.toContinuousLinearMap = φ :=\n  rfl\n\n"}
{"name":"AlgHom.norm_apply_le_self_mul_norm_one","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\nF : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : NormedRing A\ninst✝³ : NormedAlgebra 𝕜 A\ninst✝² : CompleteSpace A\ninst✝¹ : FunLike F A 𝕜\ninst✝ : AlgHomClass F 𝕜 A 𝕜\nf : F\na : A\n⊢ LE.le (Norm.norm (f a)) (HMul.hMul (Norm.norm a) (Norm.norm 1))","decl":"theorem norm_apply_le_self_mul_norm_one [FunLike F A 𝕜] [AlgHomClass F 𝕜 A 𝕜] (f : F) (a : A) :\n    ‖f a‖ ≤ ‖a‖ * ‖(1 : A)‖ :=\n  spectrum.norm_le_norm_mul_of_mem (apply_mem_spectrum f _)\n\n"}
{"name":"AlgHom.norm_apply_le_self","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\nF : Type u_3\ninst✝⁶ : NormedField 𝕜\ninst✝⁵ : NormedRing A\ninst✝⁴ : NormedAlgebra 𝕜 A\ninst✝³ : CompleteSpace A\ninst✝² : NormOneClass A\ninst✝¹ : FunLike F A 𝕜\ninst✝ : AlgHomClass F 𝕜 A 𝕜\nf : F\na : A\n⊢ LE.le (Norm.norm (f a)) (Norm.norm a)","decl":"theorem norm_apply_le_self [NormOneClass A] [FunLike F A 𝕜] [AlgHomClass F 𝕜 A 𝕜]\n    (f : F) (a : A) : ‖f a‖ ≤ ‖a‖ :=\n  spectrum.norm_le_norm_of_mem (apply_mem_spectrum f _)\n\n"}
{"name":"AlgHom.toContinuousLinearMap_norm","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : NormOneClass A\nφ : AlgHom 𝕜 A 𝕜\n⊢ Eq (Norm.norm φ.toContinuousLinearMap) 1","decl":"@[simp]\ntheorem toContinuousLinearMap_norm [NormOneClass A] (φ : A →ₐ[𝕜] 𝕜) :\n    ‖φ.toContinuousLinearMap‖ = 1 :=\n  ContinuousLinearMap.opNorm_eq_of_bounds zero_le_one\n    (fun a => (one_mul ‖a‖).symm ▸ spectrum.norm_le_norm_of_mem (apply_mem_spectrum φ _))\n    fun _ _ h => by simpa only [coe_toContinuousLinearMap, map_one, norm_one, mul_one] using h 1\n\n"}
{"name":"WeakDual.CharacterSpace.equivAlgHom_coe","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : CompleteSpace A\ninst✝ : NormedAlgebra 𝕜 A\nf : ↑(WeakDual.characterSpace 𝕜 A)\n⊢ Eq ⇑(WeakDual.CharacterSpace.equivAlgHom f) ⇑f","decl":"@[simp]\ntheorem equivAlgHom_coe (f : characterSpace 𝕜 A) : ⇑(equivAlgHom f) = f :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.equivAlgHom_symm_coe","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedRing A\ninst✝¹ : CompleteSpace A\ninst✝ : NormedAlgebra 𝕜 A\nf : AlgHom 𝕜 A 𝕜\n⊢ Eq ⇑(WeakDual.CharacterSpace.equivAlgHom.symm f) ⇑f","decl":"@[simp]\ntheorem equivAlgHom_symm_coe (f : A →ₐ[𝕜] 𝕜) : ⇑(equivAlgHom.symm f) = f :=\n  rfl\n\n"}
{"name":"Subalgebra.isUnit_of_isUnit_val_of_eventually","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁵ : NormedRing A\ninst✝⁴ : CompleteSpace A\ninst✝³ : SetLike SA A\ninst✝² : SubringClass SA A\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra 𝕜 A\ninstSMulMem : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nl : Filter (Subtype fun x => Membership.mem S x)\na : Subtype fun x => Membership.mem S x\nha : IsUnit ↑a\nhla : LE.le l (nhds a)\nhl : Filter.Eventually (fun x => IsUnit x) l\nhl' : l.NeBot\n⊢ IsUnit a","decl":"open SubalgebraClass in\ninclude instSMulMem in\n/-- Let `S` be a closed subalgebra of a Banach algebra `A`. If `a : S` is invertible in `A`,\nand for all `x : S` sufficiently close to `a` within some filter `l`, `x` is invertible in `S`,\nthen `a` is invertible in `S` as well. -/\nlemma _root_.Subalgebra.isUnit_of_isUnit_val_of_eventually {l : Filter S} {a : S}\n    (ha : IsUnit (a : A)) (hla : l ≤ 𝓝 a) (hl : ∀ᶠ x in l, IsUnit x) (hl' : l.NeBot) :\n    IsUnit a := by\n  have hla₂ : Tendsto Ring.inverse (map (val S) l) (𝓝 (↑ha.unit⁻¹ : A)) := by\n    rw [← Ring.inverse_unit]\n    exact (NormedRing.inverse_continuousAt _).tendsto.comp <|\n      continuousAt_subtype_val.tendsto.comp <| map_mono hla\n  suffices mem : (↑ha.unit⁻¹ : A) ∈ S by\n    refine ⟨⟨a, ⟨(↑ha.unit⁻¹ : A), mem⟩, ?_, ?_⟩, rfl⟩\n    all_goals ext; simp\n  apply hS.mem_of_tendsto hla₂\n  rw [Filter.eventually_map]\n  apply hl.mono fun x hx ↦ ?_\n  suffices Ring.inverse (val S x) = (val S ↑hx.unit⁻¹) from this ▸ Subtype.property _\n  rw [← (hx.map (val S)).unit_spec, Ring.inverse_unit (hx.map (val S)).unit, val]\n  apply Units.mul_eq_one_iff_inv_eq.mp\n  simpa [-IsUnit.mul_val_inv] using congr(($hx.mul_val_inv : A))\n\n"}
{"name":"Subalgebra.frontier_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁵ : NormedRing A\ninst✝⁴ : CompleteSpace A\ninst✝³ : SetLike SA A\ninst✝² : SubringClass SA A\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra 𝕜 A\ninstSMulMem : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nx : Subtype fun x => Membership.mem S x\n⊢ HasSubset.Subset (frontier (spectrum 𝕜 x)) (spectrum 𝕜 ↑x)","decl":"/-- If `S : Subalgebra 𝕜 A` is a closed subalgebra of a Banach algebra `A`, then for any\n`x : S`, the boundary of the spectrum of `x` relative to `S` is a subset of the spectrum of\n`↑x : A` relative to `A`. -/\nlemma _root_.Subalgebra.frontier_spectrum : frontier (σ 𝕜 x) ⊆ σ 𝕜 (x : A) := by\n  have : CompleteSpace S := hS.completeSpace_coe\n  intro μ hμ\n  by_contra h\n  rw [spectrum.not_mem_iff] at h\n  rw [← frontier_compl, (spectrum.isClosed _).isOpen_compl.frontier_eq, mem_diff] at hμ\n  obtain ⟨hμ₁, hμ₂⟩ := hμ\n  rw [mem_closure_iff_clusterPt] at hμ₁\n  apply hμ₂\n  rw [mem_compl_iff, spectrum.not_mem_iff]\n  refine Subalgebra.isUnit_of_isUnit_val_of_eventually S h ?_ ?_ <| .map hμ₁ (algebraMap 𝕜 S · - x)\n  · calc\n      _ ≤ map _ (𝓝 μ) := map_mono (by simp)\n      _ ≤ _ := by rw [← Filter.Tendsto, ← ContinuousAt]; fun_prop\n  · rw [eventually_map]\n    apply Eventually.filter_mono inf_le_right\n    simp [spectrum.not_mem_iff]\n\n"}
{"name":"Subalgebra.frontier_subset_frontier","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁵ : NormedRing A\ninst✝⁴ : CompleteSpace A\ninst✝³ : SetLike SA A\ninst✝² : SubringClass SA A\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra 𝕜 A\ninstSMulMem : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nx : Subtype fun x => Membership.mem S x\n⊢ HasSubset.Subset (frontier (spectrum 𝕜 x)) (frontier (spectrum 𝕜 ↑x))","decl":"/-- If `S` is a closed subalgebra of a Banach algebra `A`, then for any `x : S`, the boundary of\nthe spectrum of `x` relative to `S` is a subset of the boundary of the spectrum of `↑x : A`\nrelative to `A`. -/\nlemma Subalgebra.frontier_subset_frontier :\n    frontier (σ 𝕜 x) ⊆ frontier (σ 𝕜 (x : A)) := by\n  rw [frontier_eq_closure_inter_closure (s := σ 𝕜 (x : A)),\n    (spectrum.isClosed (x : A)).closure_eq]\n  apply subset_inter (frontier_spectrum S x)\n  rw [frontier_eq_closure_inter_closure]\n  exact inter_subset_right |>.trans <|\n    closure_mono <| compl_subset_compl.mpr <| spectrum.subset_subalgebra x\n\n"}
{"name":"Subalgebra.spectrum_sUnion_connectedComponentIn","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁵ : NormedRing A\ninst✝⁴ : CompleteSpace A\ninst✝³ : SetLike SA A\ninst✝² : SubringClass SA A\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra 𝕜 A\ninstSMulMem : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (spectrum 𝕜 x) (Union.union (spectrum 𝕜 ↑x) (Set.iUnion fun z => Set.iUnion fun h => connectedComponentIn (HasCompl.compl (spectrum 𝕜 ↑x)) z))","decl":"/-- If `S` is a closed subalgebra of a Banach algebra `A`, then for any `x : S`, the spectrum of `x`\nis the spectrum of `↑x : A` along with the connected components of the complement of the spectrum of\n`↑x : A` which contain an element of the spectrum of `x : S`. -/\nlemma Subalgebra.spectrum_sUnion_connectedComponentIn :\n    σ 𝕜 x = σ 𝕜 (x : A) ∪ (⋃ z ∈ (σ 𝕜 x \\ σ 𝕜 (x : A)), connectedComponentIn (σ 𝕜 (x : A))ᶜ z) := by\n  suffices IsClopen ((σ 𝕜 (x : A))ᶜ ↓∩ (σ 𝕜 x \\ σ 𝕜 (x : A))) by\n    rw [← this.biUnion_connectedComponentIn (diff_subset_compl _ _),\n      union_diff_cancel (spectrum.subset_subalgebra x)]\n  have : CompleteSpace S := hS.completeSpace_coe\n  have h_open : IsOpen (σ 𝕜 x \\ σ 𝕜 (x : A)) := by\n    rw [← (spectrum.isClosed (𝕜 := 𝕜) x).closure_eq, closure_eq_interior_union_frontier,\n      union_diff_distrib, diff_eq_empty.mpr (frontier_spectrum S x),\n      diff_eq_compl_inter, union_empty]\n    exact (spectrum.isClosed _).isOpen_compl.inter isOpen_interior\n  apply isClopen_preimage_val h_open\n  suffices h_frontier : frontier (σ 𝕜 x \\ σ 𝕜 (x : A)) ⊆ frontier (σ 𝕜 (x : A)) from\n    disjoint_of_subset_left h_frontier <| disjoint_compl_right.frontier_left\n      (spectrum.isClosed _).isOpen_compl\n  rw [diff_eq_compl_inter]\n  apply (frontier_inter_subset _ _).trans\n  rw [frontier_compl]\n  apply union_subset <| inter_subset_left\n  refine inter_subset_inter_right _ ?_ |>.trans <| inter_subset_right\n  exact frontier_subset_frontier S x\n\n"}
{"name":"Subalgebra.spectrum_isBounded_connectedComponentIn","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁵ : NormedRing A\ninst✝⁴ : CompleteSpace A\ninst✝³ : SetLike SA A\ninst✝² : SubringClass SA A\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra 𝕜 A\ninstSMulMem : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nx : Subtype fun x => Membership.mem S x\nz : 𝕜\nhz : Membership.mem (spectrum 𝕜 x) z\n⊢ Bornology.IsBounded (connectedComponentIn (HasCompl.compl (spectrum 𝕜 ↑x)) z)","decl":"/-- Let `S` be a closed subalgebra of a Banach algebra `A`, and let `x : S`. If `z` is in the\nspectrum of `x`, then the connected component of `z` in the complement of the spectrum of `↑x : A`\nis bounded (or else `z` actually belongs to the spectrum of `↑x : A`). -/\nlemma Subalgebra.spectrum_isBounded_connectedComponentIn {z : 𝕜} (hz : z ∈ σ 𝕜 x) :\n    Bornology.IsBounded (connectedComponentIn (σ 𝕜 (x : A))ᶜ z) := by\n  by_cases hz' : z ∈ σ 𝕜 (x : A)\n  · simp [connectedComponentIn_eq_empty (show z ∉ (σ 𝕜 (x : A))ᶜ from not_not.mpr hz')]\n  · have : CompleteSpace S := hS.completeSpace_coe\n    suffices connectedComponentIn (σ 𝕜 (x : A))ᶜ z ⊆ σ 𝕜 x from spectrum.isBounded x |>.subset this\n    rw [spectrum_sUnion_connectedComponentIn S]\n    exact subset_biUnion_of_mem (mem_diff_of_mem hz hz') |>.trans subset_union_right\n\n"}
{"name":"Subalgebra.spectrum_eq_of_isPreconnected_compl","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜 : Type u_3\nA : Type u_4\nSA : Type u_5\ninst✝⁶ : NormedRing A\ninst✝⁵ : CompleteSpace A\ninst✝⁴ : SetLike SA A\ninst✝³ : SubringClass SA A\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : SMulMemClass SA 𝕜 A\nS : SA\nhS : IsClosed ↑S\nx : Subtype fun x => Membership.mem S x\nh : IsPreconnected (HasCompl.compl (spectrum 𝕜 ↑x))\n⊢ Eq (spectrum 𝕜 x) (spectrum 𝕜 ↑x)","decl":"/-- Let `S` be a closed subalgebra of a Banach algebra `A`. If for `x : S` the complement of the\nspectrum of `↑x : A` is connected, then `spectrum 𝕜 x = spectrum 𝕜 (x : A)`. -/\nlemma Subalgebra.spectrum_eq_of_isPreconnected_compl (h : IsPreconnected (σ 𝕜 (x : A))ᶜ) :\n    σ 𝕜 x = σ 𝕜 (x : A) := by\n  nontriviality A\n  suffices σ 𝕜 x \\ σ 𝕜 (x : A) = ∅ by\n    rw [spectrum_sUnion_connectedComponentIn, this]\n    simp\n  refine eq_empty_of_forall_not_mem fun z hz ↦ NormedSpace.unbounded_univ 𝕜 𝕜 ?_\n  obtain ⟨hz, hz'⟩ := mem_diff _ |>.mp hz\n  have := (spectrum.isBounded (x : A)).union <|\n    h.connectedComponentIn hz' ▸ spectrum_isBounded_connectedComponentIn S x hz\n  simpa\n\n"}
{"name":"SpectrumRestricts.spectralRadius_eq","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"𝕜₁ : Type u_3\n𝕜₂ : Type u_4\nA : Type u_5\ninst✝⁶ : NormedField 𝕜₁\ninst✝⁵ : NormedField 𝕜₂\ninst✝⁴ : NormedRing A\ninst✝³ : NormedAlgebra 𝕜₁ A\ninst✝² : NormedAlgebra 𝕜₂ A\ninst✝¹ : NormedAlgebra 𝕜₁ 𝕜₂\ninst✝ : IsScalarTower 𝕜₁ 𝕜₂ A\nf : 𝕜₂ → 𝕜₁\na : A\nh : SpectrumRestricts a f\n⊢ Eq (spectralRadius 𝕜₁ a) (spectralRadius 𝕜₂ a)","decl":"/-- If `𝕜₁` is a normed field contained as subfield of a larger normed field `𝕜₂`, and if `a : A`\nis an element whose `𝕜₂` spectrum restricts to `𝕜₁`, then the spectral radii over each scalar\nfield coincide. -/\nlemma spectralRadius_eq {𝕜₁ 𝕜₂ A : Type*} [NormedField 𝕜₁] [NormedField 𝕜₂]\n    [NormedRing A] [NormedAlgebra 𝕜₁ A] [NormedAlgebra 𝕜₂ A] [NormedAlgebra 𝕜₁ 𝕜₂]\n    [IsScalarTower 𝕜₁ 𝕜₂ A] {f : 𝕜₂ → 𝕜₁} {a : A} (h : SpectrumRestricts a f) :\n    spectralRadius 𝕜₁ a = spectralRadius 𝕜₂ a := by\n  rw [spectralRadius, spectralRadius]\n  have := algebraMap_isometry 𝕜₁ 𝕜₂ |>.nnnorm_map_of_map_zero (map_zero _)\n  apply le_antisymm\n  all_goals apply iSup₂_le fun x hx ↦ ?_\n  · refine congr_arg ((↑) : ℝ≥0 → ℝ≥0∞) (this x) |>.symm.trans_le <| le_iSup₂ (α := ℝ≥0∞) _ ?_\n    exact (spectrum.algebraMap_mem_iff _).mpr hx\n  · have ⟨y, hy, hy'⟩ := h.algebraMap_image.symm ▸ hx\n    subst hy'\n    exact this y ▸ le_iSup₂ (α := ℝ≥0∞) y hy\n\n"}
{"name":"SpectrumRestricts.nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\n⊢ Iff (SpectrumRestricts a ⇑ContinuousMap.realToNNReal) (∀ (x : Real), Membership.mem (spectrum Real a) x → LE.le 0 x)","decl":"lemma nnreal_iff [Algebra ℝ A] {a : A} :\n    SpectrumRestricts a ContinuousMap.realToNNReal ↔ ∀ x ∈ spectrum ℝ a, 0 ≤ x := by\n  refine ⟨fun h x hx ↦ ?_, fun h ↦ ?_⟩\n  · obtain ⟨x, -, rfl⟩ := h.algebraMap_image.symm ▸ hx\n    exact coe_nonneg x\n  · exact .of_subset_range_algebraMap (fun _ ↦ Real.toNNReal_coe) fun x hx ↦ ⟨⟨x, h x hx⟩, rfl⟩\n\n"}
{"name":"SpectrumRestricts.nnreal_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninst✝³ : Ring A\ninst✝² : PartialOrder A\ninst✝¹ : Algebra Real A\ninst✝ : NonnegSpectrumClass Real A\na : A\nha : LE.le 0 a\n⊢ SpectrumRestricts a ⇑ContinuousMap.realToNNReal","decl":"lemma nnreal_of_nonneg {A : Type*} [Ring A] [PartialOrder A] [Algebra ℝ A]\n    [NonnegSpectrumClass ℝ A] {a : A} (ha : 0 ≤ a) :\n    SpectrumRestricts a ContinuousMap.realToNNReal :=\n  nnreal_iff.mpr <| spectrum_nonneg_of_nonneg ha\n\n"}
{"name":"SpectrumRestricts.real_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Complex A\na : A\n⊢ Iff (SpectrumRestricts a ⇑Complex.reCLM) (∀ (x : Complex), Membership.mem (spectrum Complex a) x → Eq x ↑x.re)","decl":"lemma real_iff [Algebra ℂ A] {a : A} :\n    SpectrumRestricts a Complex.reCLM ↔ ∀ x ∈ spectrum ℂ a, x = x.re := by\n  refine ⟨fun h x hx ↦ ?_, fun h ↦ ?_⟩\n  · obtain ⟨x, -, rfl⟩ := h.algebraMap_image.symm ▸ hx\n    simp\n  · exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx ↦ ⟨x.re, (h x hx).symm⟩\n\n"}
{"name":"SpectrumRestricts.nnreal_le_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nha : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LE.le r x) (∀ (x : Real), Membership.mem (spectrum Real a) x → LE.le (↑r) x)","decl":"lemma nnreal_le_iff [Algebra ℝ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ spectrum ℝ≥0 a, r ≤ x) ↔ ∀ x ∈ spectrum ℝ a, r ≤ x := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.nnreal_lt_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nha : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LT.lt r x) (∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt (↑r) x)","decl":"lemma nnreal_lt_iff [Algebra ℝ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ spectrum ℝ≥0 a, r < x) ↔ ∀ x ∈ spectrum ℝ a, r < x := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.le_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nha : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LE.le x r) (∀ (x : Real), Membership.mem (spectrum Real a) x → LE.le x ↑r)","decl":"lemma le_nnreal_iff [Algebra ℝ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ spectrum ℝ≥0 a, x ≤ r) ↔ ∀ x ∈ spectrum ℝ a, x ≤ r := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.lt_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nha : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LT.lt x r) (∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt x ↑r)","decl":"lemma lt_nnreal_iff [Algebra ℝ A] {a : A}\n    (ha : SpectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ spectrum ℝ≥0 a, x < r) ↔ ∀ x ∈ spectrum ℝ a, x < r := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"SpectrumRestricts.nnreal_iff_spectralRadius_le","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra Real A\na : A\nt : NNReal\nht : LE.le (spectralRadius Real a) ↑t\n⊢ Iff (SpectrumRestricts a ⇑ContinuousMap.realToNNReal) (LE.le (spectralRadius Real (HSub.hSub ((algebraMap Real A) ↑t) a)) ↑t)","decl":"lemma nnreal_iff_spectralRadius_le [Algebra ℝ A] {a : A} {t : ℝ≥0} (ht : spectralRadius ℝ a ≤ t) :\n    SpectrumRestricts a ContinuousMap.realToNNReal ↔\n      spectralRadius ℝ (algebraMap ℝ A t - a) ≤ t := by\n  have : spectrum ℝ a ⊆ Set.Icc (-t) t := by\n    intro x hx\n    rw [Set.mem_Icc, ← abs_le, ← Real.norm_eq_abs, ← coe_nnnorm, NNReal.coe_le_coe,\n      ← ENNReal.coe_le_coe]\n    exact le_iSup₂ (α := ℝ≥0∞) x hx |>.trans ht\n  rw [nnreal_iff]\n  refine ⟨fun h ↦ iSup₂_le fun x hx ↦ ?_, fun h ↦ ?_⟩\n  · rw [← spectrum.singleton_sub_eq] at hx\n    obtain ⟨y, hy, rfl⟩ : ∃ y ∈ spectrum ℝ a, ↑t - y = x := by simpa using hx\n    obtain ⟨hty, hyt⟩ := Set.mem_Icc.mp <| this hy\n    lift y to ℝ≥0 using h y hy\n    rw [← NNReal.coe_sub (by exact_mod_cast hyt)]\n    simp\n  · replace h : ∀ x ∈ spectrum ℝ a, ‖t - x‖₊ ≤ t := by\n      simpa [spectralRadius, iSup₂_le_iff, ← spectrum.singleton_sub_eq] using h\n    peel h with x hx h_le\n    rw [← NNReal.coe_le_coe, coe_nnnorm, Real.norm_eq_abs, abs_le] at h_le\n    linarith [h_le.2]\n\n"}
{"name":"NNReal.spectralRadius_mem_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\nha' : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\n⊢ Membership.mem (spectrum NNReal a) (spectralRadius Real a).toNNReal","decl":"lemma _root_.NNReal.spectralRadius_mem_spectrum {A : Type*} [NormedRing A] [NormedAlgebra ℝ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum ℝ a).Nonempty)\n    (ha' : SpectrumRestricts a ContinuousMap.realToNNReal) :\n    (spectralRadius ℝ a).toNNReal ∈ spectrum ℝ≥0 a := by\n  obtain ⟨x, hx₁, hx₂⟩ := spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty ha\n  rw [← hx₂, ENNReal.toNNReal_coe, ← spectrum.algebraMap_mem_iff ℝ, NNReal.algebraMap_eq_coe]\n  have : 0 ≤ x := ha'.rightInvOn hx₁ ▸ NNReal.zero_le_coe\n  convert hx₁\n  simpa\n\n"}
{"name":"Real.spectralRadius_mem_spectrum","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\nha' : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\n⊢ Membership.mem (spectrum Real a) (spectralRadius Real a).toReal","decl":"lemma _root_.Real.spectralRadius_mem_spectrum {A : Type*} [NormedRing A] [NormedAlgebra ℝ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum ℝ a).Nonempty)\n    (ha' : SpectrumRestricts a ContinuousMap.realToNNReal) :\n    (spectralRadius ℝ a).toReal ∈ spectrum ℝ a :=\n  NNReal.spectralRadius_mem_spectrum ha ha'\n\n"}
{"name":"Real.spectralRadius_mem_spectrum_or","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_4\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : CompleteSpace A\na : A\nha : (spectrum Real a).Nonempty\n⊢ Or (Membership.mem (spectrum Real a) (spectralRadius Real a).toReal) (Membership.mem (spectrum Real a) (Neg.neg (spectralRadius Real a).toReal))","decl":"lemma _root_.Real.spectralRadius_mem_spectrum_or {A : Type*} [NormedRing A] [NormedAlgebra ℝ A]\n    [CompleteSpace A] {a : A} (ha : (spectrum ℝ a).Nonempty) :\n    (spectralRadius ℝ a).toReal ∈ spectrum ℝ a ∨ -(spectralRadius ℝ a).toReal ∈ spectrum ℝ a := by\n  obtain ⟨x, hx₁, hx₂⟩ := spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty ha\n  simp only [← hx₂, ENNReal.coe_toReal, coe_nnnorm, Real.norm_eq_abs]\n  exact abs_choice x |>.imp (fun h ↦ by rwa [h]) (fun h ↦ by simpa [h])\n\n"}
{"name":"QuasispectrumRestricts.compactSpace","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝¹⁰ : Semifield R\ninst✝⁹ : Field S\ninst✝⁸ : NonUnitalRing A\ninst✝⁷ : Algebra R S\ninst✝⁶ : Module R A\ninst✝⁵ : Module S A\ninst✝⁴ : IsScalarTower S A A\ninst✝³ : SMulCommClass S A A\ninst✝² : IsScalarTower R S A\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSpace S\na : A\nf : ContinuousMap S R\nh : QuasispectrumRestricts a ⇑f\nh_cpct : CompactSpace ↑(quasispectrum S a)\n⊢ CompactSpace ↑(quasispectrum R a)","decl":"lemma compactSpace {R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A]\n    [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A] [SMulCommClass S A A]\n    [IsScalarTower R S A] [TopologicalSpace R] [TopologicalSpace S] {a : A} (f : C(S, R))\n    (h : QuasispectrumRestricts a f) [h_cpct : CompactSpace (σₙ S a)] :\n    CompactSpace (σₙ R a) := by\n  rw [← isCompact_iff_compactSpace] at h_cpct ⊢\n  exact h.image ▸ h_cpct.image (map_continuous f)\n\n"}
{"name":"QuasispectrumRestricts.nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NonUnitalRing A\ninst✝² : Module Real A\ninst✝¹ : IsScalarTower Real A A\ninst✝ : SMulCommClass Real A A\na : A\n⊢ Iff (QuasispectrumRestricts a ⇑ContinuousMap.realToNNReal) (∀ (x : Real), Membership.mem (quasispectrum Real a) x → LE.le 0 x)","decl":"lemma nnreal_iff [Module ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] {a : A} :\n    QuasispectrumRestricts a ContinuousMap.realToNNReal ↔ ∀ x ∈ σₙ ℝ a, 0 ≤ x := by\n  rw [quasispectrumRestricts_iff_spectrumRestricts_inr,\n    Unitization.quasispectrum_eq_spectrum_inr' _ ℝ, SpectrumRestricts.nnreal_iff]\n\n"}
{"name":"QuasispectrumRestricts.nnreal_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝⁵ : NonUnitalRing A\ninst✝⁴ : Module Real A\ninst✝³ : IsScalarTower Real A A\ninst✝² : SMulCommClass Real A A\ninst✝¹ : PartialOrder A\ninst✝ : NonnegSpectrumClass Real A\na : A\nha : LE.le 0 a\n⊢ QuasispectrumRestricts a ⇑ContinuousMap.realToNNReal","decl":"lemma nnreal_of_nonneg [Module ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] [PartialOrder A]\n    [NonnegSpectrumClass ℝ A] {a : A} (ha : 0 ≤ a) :\n    QuasispectrumRestricts a ContinuousMap.realToNNReal :=\n  nnreal_iff.mpr <| quasispectrum_nonneg_of_nonneg _ ha\n\n"}
{"name":"QuasispectrumRestricts.real_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NonUnitalRing A\ninst✝² : Module Complex A\ninst✝¹ : IsScalarTower Complex A A\ninst✝ : SMulCommClass Complex A A\na : A\n⊢ Iff (QuasispectrumRestricts a ⇑Complex.reCLM) (∀ (x : Complex), Membership.mem (quasispectrum Complex a) x → Eq x ↑x.re)","decl":"lemma real_iff [Module ℂ A] [IsScalarTower ℂ A A] [SMulCommClass ℂ A A] {a : A} :\n    QuasispectrumRestricts a Complex.reCLM ↔ ∀ x ∈ σₙ ℂ a, x = x.re := by\n  rw [quasispectrumRestricts_iff_spectrumRestricts_inr,\n    Unitization.quasispectrum_eq_spectrum_inr' _ ℂ, SpectrumRestricts.real_iff]\n\n"}
{"name":"QuasispectrumRestricts.le_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NonUnitalRing A\ninst✝² : Module Real A\ninst✝¹ : IsScalarTower Real A A\ninst✝ : SMulCommClass Real A A\na : A\nha : QuasispectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (quasispectrum NNReal a) x → LE.le x r) (∀ (x : Real), Membership.mem (quasispectrum Real a) x → LE.le x ↑r)","decl":"lemma le_nnreal_iff [Module ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] {a : A}\n    (ha : QuasispectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ quasispectrum ℝ≥0 a, x ≤ r) ↔ ∀ x ∈ quasispectrum ℝ a, x ≤ r := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"QuasispectrumRestricts.lt_nnreal_iff","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : NonUnitalRing A\ninst✝² : Module Real A\ninst✝¹ : IsScalarTower Real A A\ninst✝ : SMulCommClass Real A A\na : A\nha : QuasispectrumRestricts a ⇑ContinuousMap.realToNNReal\nr : NNReal\n⊢ Iff (∀ (x : NNReal), Membership.mem (quasispectrum NNReal a) x → LT.lt x r) (∀ (x : Real), Membership.mem (quasispectrum Real a) x → LT.lt x ↑r)","decl":"lemma lt_nnreal_iff [Module ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] {a : A}\n    (ha : QuasispectrumRestricts a ContinuousMap.realToNNReal) {r : ℝ≥0} :\n    (∀ x ∈ quasispectrum ℝ≥0 a, x < r) ↔ ∀ x ∈ quasispectrum ℝ a, x < r := by\n  simp [← ha.algebraMap_image]\n\n"}
{"name":"coe_mem_spectrum_real_of_nonneg","module":"Mathlib.Analysis.Normed.Algebra.Spectrum","initialProofState":"A : Type u_3\ninst✝³ : Ring A\ninst✝² : PartialOrder A\ninst✝¹ : Algebra Real A\ninst✝ : NonnegSpectrumClass Real A\na : A\nx : NNReal\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (Membership.mem (spectrum Real a) ↑x) (Membership.mem (spectrum NNReal a) x)","decl":"lemma coe_mem_spectrum_real_of_nonneg [Algebra ℝ A] [NonnegSpectrumClass ℝ A] {a : A} {x : ℝ≥0}\n    (ha : 0 ≤ a := by cfc_tac) :\n    (x : ℝ) ∈ spectrum ℝ a ↔ x ∈ spectrum ℝ≥0 a := by\n  simp [← (SpectrumRestricts.nnreal_of_nonneg ha).algebraMap_image, Set.mem_image,\n    NNReal.algebraMap_eq_coe]\n"}
