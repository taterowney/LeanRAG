{"name":"Fintype.mem_piFinset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nt : (a : α) → Finset (δ a)\nf : (a : α) → δ a\n⊢ Iff (Membership.mem (Fintype.piFinset t) f) (∀ (a : α), Membership.mem (t a) (f a))","decl":"@[simp]\ntheorem mem_piFinset {t : ∀ a, Finset (δ a)} {f : ∀ a, δ a} : f ∈ piFinset t ↔ ∀ a, f a ∈ t a := by\n  constructor\n  · simp only [piFinset, mem_map, and_imp, forall_prop_of_true, exists_prop, mem_univ, exists_imp,\n      mem_pi]\n    rintro g hg hgf a\n    rw [← hgf]\n    exact hg a\n  · simp only [piFinset, mem_map, forall_prop_of_true, exists_prop, mem_univ, mem_pi]\n    exact fun hf => ⟨fun a _ => f a, hf, rfl⟩\n\n"}
{"name":"Fintype.coe_piFinset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nt : (a : α) → Finset (δ a)\n⊢ Eq (↑(Fintype.piFinset t)) (Set.univ.pi fun a => ↑(t a))","decl":"@[simp]\ntheorem coe_piFinset (t : ∀ a, Finset (δ a)) :\n    (piFinset t : Set (∀ a, δ a)) = Set.pi Set.univ fun a => t a :=\n  Set.ext fun x => by\n    rw [Set.mem_univ_pi]\n    exact Fintype.mem_piFinset\n\n"}
{"name":"Fintype.piFinset_subset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nt₁ t₂ : (a : α) → Finset (δ a)\nh : ∀ (a : α), HasSubset.Subset (t₁ a) (t₂ a)\n⊢ HasSubset.Subset (Fintype.piFinset t₁) (Fintype.piFinset t₂)","decl":"theorem piFinset_subset (t₁ t₂ : ∀ a, Finset (δ a)) (h : ∀ a, t₁ a ⊆ t₂ a) :\n    piFinset t₁ ⊆ piFinset t₂ := fun _ hg => mem_piFinset.2 fun a => h a <| mem_piFinset.1 hg a\n\n"}
{"name":"Fintype.piFinset_eq_empty","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nγ : α → Type u_3\ns : (a : α) → Finset (γ a)\n⊢ Iff (Eq (Fintype.piFinset s) EmptyCollection.emptyCollection) (Exists fun i => Eq (s i) EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem piFinset_eq_empty : piFinset s = ∅ ↔ ∃ i, s i = ∅ := by simp [piFinset]\n\n"}
{"name":"Fintype.piFinset_empty","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\ninst✝ : Nonempty α\n⊢ Eq (Fintype.piFinset fun x => EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem piFinset_empty [Nonempty α] : piFinset (fun _ => ∅ : ∀ i, Finset (δ i)) = ∅ := by simp\n\n"}
{"name":"Fintype.piFinset_nonempty","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nγ : α → Type u_3\ns : (a : α) → Finset (γ a)\n⊢ Iff (Fintype.piFinset s).Nonempty (∀ (a : α), (s a).Nonempty)","decl":"@[simp]\nlemma piFinset_nonempty : (piFinset s).Nonempty ↔ ∀ a, (s a).Nonempty := by simp [piFinset]\n\n"}
{"name":"Fintype.Aesop.piFinset_nonempty_of_forall_nonempty","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nγ : α → Type u_3\ns : (a : α) → Finset (γ a)\na✝ : ∀ (a : α), (s a).Nonempty\n⊢ (Fintype.piFinset s).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.piFinset_nonempty_of_forall_nonempty⟩ := piFinset_nonempty\n\n"}
{"name":"Finset.Nonempty.piFinset_const","module":"Mathlib.Data.Fintype.Pi","initialProofState":"β : Type u_2\nι : Type u_5\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ns : Finset β\nhs : s.Nonempty\n⊢ (Fintype.piFinset fun x => s).Nonempty","decl":"lemma _root_.Finset.Nonempty.piFinset_const {ι : Type*} [Fintype ι] [DecidableEq ι] {s : Finset β}\n    (hs : s.Nonempty) : (piFinset fun _ : ι ↦ s).Nonempty := piFinset_nonempty.2 fun _ ↦ hs\n\n"}
{"name":"Fintype.piFinset_of_isEmpty","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nγ : α → Type u_3\ninst✝ : IsEmpty α\ns : (a : α) → Finset (γ a)\n⊢ Eq (Fintype.piFinset s) Finset.univ","decl":"@[simp]\nlemma piFinset_of_isEmpty [IsEmpty α] (s : ∀ a, Finset (γ a)) : piFinset s = univ :=\n  eq_univ_of_forall fun _ ↦ by simp\n\n"}
{"name":"Fintype.piFinset_singleton","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nf : (i : α) → δ i\n⊢ Eq (Fintype.piFinset fun i => Singleton.singleton (f i)) (Singleton.singleton f)","decl":"@[simp]\ntheorem piFinset_singleton (f : ∀ i, δ i) : piFinset (fun i => {f i} : ∀ i, Finset (δ i)) = {f} :=\n  ext fun _ => by simp only [funext_iff, Fintype.mem_piFinset, mem_singleton]\n\n"}
{"name":"Fintype.piFinset_subsingleton","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nf : (i : α) → Finset (δ i)\nhf : ∀ (i : α), (↑(f i)).Subsingleton\n⊢ (↑(Fintype.piFinset f)).Subsingleton","decl":"theorem piFinset_subsingleton {f : ∀ i, Finset (δ i)} (hf : ∀ i, (f i : Set (δ i)).Subsingleton) :\n    (Fintype.piFinset f : Set (∀ i, δ i)).Subsingleton := fun _ ha _ hb =>\n  funext fun _ => hf _ (mem_piFinset.1 ha _) (mem_piFinset.1 hb _)\n\n"}
{"name":"Fintype.piFinset_disjoint_of_disjoint","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nδ : α → Type u_4\nt₁ t₂ : (a : α) → Finset (δ a)\na : α\nh : Disjoint (t₁ a) (t₂ a)\n⊢ Disjoint (Fintype.piFinset t₁) (Fintype.piFinset t₂)","decl":"theorem piFinset_disjoint_of_disjoint (t₁ t₂ : ∀ a, Finset (δ a)) {a : α}\n    (h : Disjoint (t₁ a) (t₂ a)) : Disjoint (piFinset t₁) (piFinset t₂) :=\n  disjoint_iff_ne.2 fun f₁ hf₁ f₂ hf₂ eq₁₂ =>\n    disjoint_iff_ne.1 h (f₁ a) (mem_piFinset.1 hf₁ a) (f₂ a) (mem_piFinset.1 hf₂ a)\n      (congr_fun eq₁₂ a)\n\n"}
{"name":"Fintype.piFinset_image","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nγ : α → Type u_3\nδ : α → Type u_4\ninst✝ : (a : α) → DecidableEq (δ a)\nf : (a : α) → γ a → δ a\ns : (a : α) → Finset (γ a)\n⊢ Eq (Fintype.piFinset fun a => Finset.image (f a) (s a)) (Finset.image (fun b a => f a (b a)) (Fintype.piFinset s))","decl":"lemma piFinset_image [∀ a, DecidableEq (δ a)] (f : ∀ a, γ a → δ a) (s : ∀ a, Finset (γ a)) :\n    piFinset (fun a ↦ (s a).image (f a)) = (piFinset s).image fun b a ↦ f _ (b a) := by\n  ext; simp only [mem_piFinset, mem_image, Classical.skolem, forall_and, funext_iff]\n\n"}
{"name":"Fintype.eval_image_piFinset_subset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\nt : (a : α) → Finset (δ a)\na : α\ninst✝ : DecidableEq (δ a)\n⊢ HasSubset.Subset (Finset.image (fun f => f a) (Fintype.piFinset t)) (t a)","decl":"lemma eval_image_piFinset_subset (t : ∀ a, Finset (δ a)) (a : α) [DecidableEq (δ a)] :\n    ((piFinset t).image fun f ↦ f a) ⊆ t a := image_subset_iff.2 fun _x hx ↦ mem_piFinset.1 hx _\n\n"}
{"name":"Fintype.eval_image_piFinset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\nt : (a : α) → Finset (δ a)\na : α\ninst✝ : DecidableEq (δ a)\nht : ∀ (b : α), Ne a b → (t b).Nonempty\n⊢ Eq (Finset.image (fun f => f a) (Fintype.piFinset t)) (t a)","decl":"lemma eval_image_piFinset (t : ∀ a, Finset (δ a)) (a : α) [DecidableEq (δ a)]\n    (ht : ∀ b, a ≠ b → (t b).Nonempty) : ((piFinset t).image fun f ↦ f a) = t a := by\n  refine (eval_image_piFinset_subset _ _).antisymm fun x h ↦ mem_image.2 ?_\n  choose f hf using ht\n  exact ⟨fun b ↦ if h : a = b then h ▸ x else f _ h, by aesop, by simp⟩\n\n"}
{"name":"Fintype.eval_image_piFinset_const","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nβ : Type u_5\ninst✝ : DecidableEq β\nt : Finset β\na : α\n⊢ Eq (Finset.image (fun f => f a) (Fintype.piFinset fun _i => t)) t","decl":"lemma eval_image_piFinset_const {β} [DecidableEq β] (t : Finset β) (a : α) :\n    ((piFinset fun _i : α ↦ t).image fun f ↦ f a) = t := by\n  obtain rfl | ht := t.eq_empty_or_nonempty\n  · haveI : Nonempty α := ⟨a⟩\n    simp\n  · exact eval_image_piFinset (fun _ ↦ t) a fun _ _ ↦ ht\n\n"}
{"name":"Fintype.filter_piFinset_of_not_mem","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\ninst✝ : (a : α) → DecidableEq (δ a)\nt : (a : α) → Finset (δ a)\na : α\nx : δ a\nhx : Not (Membership.mem (t a) x)\n⊢ Eq (Finset.filter (fun f => Eq (f a) x) (Fintype.piFinset t)) EmptyCollection.emptyCollection","decl":"lemma filter_piFinset_of_not_mem (t : ∀ a, Finset (δ a)) (a : α) (x : δ a) (hx : x ∉ t a) :\n    {f ∈ piFinset t | f a = x} = ∅ := by\n  simp only [filter_eq_empty_iff, mem_piFinset]; rintro f hf rfl; exact hx (hf _)\n\n-- TODO: This proof looks like a good example of something that `aesop` can't do but should\n"}
{"name":"Fintype.piFinset_update_eq_filter_piFinset_mem","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\ninst✝ : (a : α) → DecidableEq (δ a)\ns : (i : α) → Finset (δ i)\ni : α\nt : Finset (δ i)\nhts : HasSubset.Subset t (s i)\n⊢ Eq (Fintype.piFinset (Function.update s i t)) (Finset.filter (fun f => Membership.mem t (f i)) (Fintype.piFinset s))","decl":"lemma piFinset_update_eq_filter_piFinset_mem (s : ∀ i, Finset (δ i)) (i : α) {t : Finset (δ i)}\n    (hts : t ⊆ s i) : piFinset (Function.update s i t) = {f ∈ piFinset s | f i ∈ t} := by\n  ext f\n  simp only [mem_piFinset, mem_filter]\n  refine ⟨fun h ↦ ?_, fun h j ↦ ?_⟩\n  · have := by simpa using h i\n    refine ⟨fun j ↦ ?_, this⟩\n    obtain rfl | hji := eq_or_ne j i\n    · exact hts this\n    · simpa [hji] using h j\n  · obtain rfl | hji := eq_or_ne j i\n    · simpa using h.2\n    · simpa [hji] using h.1 j\n\n"}
{"name":"Fintype.piFinset_update_singleton_eq_filter_piFinset_eq","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nδ : α → Type u_4\ninst✝ : (a : α) → DecidableEq (δ a)\ns : (i : α) → Finset (δ i)\ni : α\na : δ i\nha : Membership.mem (s i) a\n⊢ Eq (Fintype.piFinset (Function.update s i (Singleton.singleton a))) (Finset.filter (fun f => Eq (f i) a) (Fintype.piFinset s))","decl":"lemma piFinset_update_singleton_eq_filter_piFinset_eq (s : ∀ i, Finset (δ i)) (i : α) {a : δ i}\n    (ha : a ∈ s i) :\n    piFinset (Function.update s i {a}) = {f ∈ piFinset s | f i = a} := by\n  simp [piFinset_update_eq_filter_piFinset_mem, ha]\n\n"}
{"name":"Fintype.piFinset_univ","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_3\nβ : α → Type u_4\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : (a : α) → Fintype (β a)\n⊢ Eq (Fintype.piFinset fun a => Finset.univ) Finset.univ","decl":"@[simp]\ntheorem Fintype.piFinset_univ {α : Type*} {β : α → Type*} [DecidableEq α] [Fintype α]\n    [∀ a, Fintype (β a)] :\n    (Fintype.piFinset fun a : α => (Finset.univ : Finset (β a))) =\n      (Finset.univ : Finset (∀ a, β a)) :=\n  rfl\n\n-- Porting note: this instance used to be computable in Lean3 and used `decidable_eq`, but\n-- it makes things a lot harder to work with here. in some ways that was because in Lean3\n-- we could make this instance irreducible when needed and in the worst case use `congr/convert`,\n-- but those don't work with subsingletons in lean4 as-is so we cannot do this here.\n"}
{"name":"Finset.univ_pi_univ","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_3\nβ : α → Type u_4\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : (a : α) → Fintype (β a)\n⊢ Eq (Finset.univ.pi fun a => Finset.univ) Finset.univ","decl":"@[simp]\ntheorem Finset.univ_pi_univ {α : Type*} {β : α → Type*} [DecidableEq α] [Fintype α]\n    [∀ a, Fintype (β a)] :\n    (Finset.univ.pi fun a : α => (Finset.univ : Finset (β a))) = Finset.univ := by\n  ext; simp\n\n"}
{"name":"Finset.piFinset_filter_const","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝² : DecidableEq (ι → α)\ns : Finset α\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ Eq (Finset.filter (fun f => Exists fun a => And (Membership.mem s a) (Eq (Function.const ι a) f)) (Fintype.piFinset fun x => s)) (s.piDiag ι)","decl":"lemma piFinset_filter_const [DecidableEq ι] [Fintype ι] :\n    {f ∈ Fintype.piFinset fun _ : ι ↦ s | ∃ a ∈ s, const ι a = f} = s.piDiag ι := by aesop\n\n"}
{"name":"Finset.piDiag_subset_piFinset","module":"Mathlib.Data.Fintype.Pi","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝² : DecidableEq (ι → α)\ns : Finset α\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ HasSubset.Subset (s.piDiag ι) (Fintype.piFinset fun x => s)","decl":"lemma piDiag_subset_piFinset [DecidableEq ι] [Fintype ι] :\n    s.piDiag ι ⊆ Fintype.piFinset fun _ ↦ s := by simp [← piFinset_filter_const]\n\n"}
{"name":"Set.Finite.pi","module":"Mathlib.Data.Fintype.Pi","initialProofState":"ι : Type u_3\ninst✝ : Finite ι\nκ : ι → Type u_4\nt : (i : ι) → Set (κ i)\nht : ∀ (i : ι), (t i).Finite\n⊢ (Set.univ.pi t).Finite","decl":"/-- Finite product of finite sets is finite -/\ntheorem Finite.pi (ht : ∀ i, (t i).Finite) : (pi univ t).Finite := by\n  cases nonempty_fintype ι\n  lift t to ∀ d, Finset (κ d) using ht\n  classical\n    rw [← Fintype.coe_piFinset]\n    apply Finset.finite_toSet\n\n"}
{"name":"Set.Finite.pi'","module":"Mathlib.Data.Fintype.Pi","initialProofState":"ι : Type u_3\ninst✝ : Finite ι\nκ : ι → Type u_4\nt : (i : ι) → Set (κ i)\nht : ∀ (i : ι), (t i).Finite\n⊢ (setOf fun f => ∀ (i : ι), Membership.mem (t i) (f i)).Finite","decl":"/-- Finite product of finite sets is finite. Note this is a variant of `Set.Finite.pi` without the\nextra `i ∈ univ` binder. -/\nlemma Finite.pi' (ht : ∀ i, (t i).Finite) : {f : ∀ i, κ i | ∀ i, f i ∈ t i}.Finite := by\n  simpa [Set.pi] using Finite.pi ht\n\n"}
{"name":"Set.forall_finite_image_eval_iff","module":"Mathlib.Data.Fintype.Pi","initialProofState":"δ : Type u_3\ninst✝ : Finite δ\nκ : δ → Type u_4\ns : Set ((d : δ) → κ d)\n⊢ Iff (∀ (d : δ), (Set.image (Function.eval d) s).Finite) s.Finite","decl":"theorem forall_finite_image_eval_iff {δ : Type*} [Finite δ] {κ : δ → Type*} {s : Set (∀ d, κ d)} :\n    (∀ d, (eval d '' s).Finite) ↔ s.Finite :=\n  ⟨fun h => (Finite.pi h).subset <| subset_pi_eval_image _ _, fun h _ => h.image _⟩\n\n"}
