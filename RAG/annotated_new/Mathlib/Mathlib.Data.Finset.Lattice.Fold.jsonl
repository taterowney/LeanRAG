{"name":"Finset.sup_def","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\n⊢ Eq (s.sup f) (Multiset.map f s.val).sup","decl":"theorem sup_def : s.sup f = (s.1.map f).sup :=\n  rfl\n\n"}
{"name":"Finset.sup_empty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nf : β → α\n⊢ Eq (EmptyCollection.emptyCollection.sup f) Bot.bot","decl":"@[simp]\ntheorem sup_empty : (∅ : Finset β).sup f = ⊥ :=\n  fold_empty\n\n"}
{"name":"Finset.sup_cons","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\nb : β\nh : Not (Membership.mem s b)\n⊢ Eq ((Finset.cons b s h).sup f) (Max.max (f b) (s.sup f))","decl":"@[simp]\ntheorem sup_cons {b : β} (h : b ∉ s) : (cons b s h).sup f = f b ⊔ s.sup f :=\n  fold_cons h\n\n"}
{"name":"Finset.sup_insert","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).sup f) (Max.max (f b) (s.sup f))","decl":"@[simp]\ntheorem sup_insert [DecidableEq β] {b : β} : (insert b s : Finset β).sup f = f b ⊔ s.sup f :=\n  fold_insert_idem\n\n"}
{"name":"Finset.sup_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\ng : β → α\n⊢ Eq ((Finset.image f s).sup g) (s.sup (Function.comp g f))","decl":"@[simp]\ntheorem sup_image [DecidableEq β] (s : Finset γ) (f : γ → β) (g : β → α) :\n    (s.image f).sup g = s.sup (g ∘ f) :=\n  fold_image_idem\n\n"}
{"name":"Finset.sup_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\n⊢ Eq ((Finset.map f s).sup g) (s.sup (Function.comp g ⇑f))","decl":"@[simp]\ntheorem sup_map (s : Finset γ) (f : γ ↪ β) (g : β → α) : (s.map f).sup g = s.sup (g ∘ f) :=\n  fold_map\n\n"}
{"name":"Finset.sup_singleton","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).sup f) (f b)","decl":"@[simp]\ntheorem sup_singleton {b : β} : ({b} : Finset β).sup f = f b :=\n  Multiset.sup_singleton\n\n"}
{"name":"Finset.sup_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf g : β → α\n⊢ Eq (s.sup (Max.max f g)) (Max.max (s.sup f) (s.sup g))","decl":"theorem sup_sup : s.sup (f ⊔ g) = s.sup f ⊔ s.sup g := by\n  induction s using Finset.cons_induction with\n  | empty => rw [sup_empty, sup_empty, sup_empty, bot_sup_eq]\n  | cons _ _ _ ih =>\n    rw [sup_cons, sup_cons, sup_cons, ih]\n    exact sup_sup_sup_comm _ _ _ _\n\n"}
{"name":"Finset.sup_congr","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns₁ s₂ : Finset β\nf g : β → α\nhs : Eq s₁ s₂\nhfg : ∀ (a : β), Membership.mem s₂ a → Eq (f a) (g a)\n⊢ Eq (s₁.sup f) (s₂.sup g)","decl":"theorem sup_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) :\n    s₁.sup f = s₂.sup g := by\n  subst hs\n  exact Finset.fold_congr hfg\n\n"}
{"name":"map_finset_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝⁵ : SemilatticeSup α\ninst✝⁴ : OrderBot α\ninst✝³ : SemilatticeSup β\ninst✝² : OrderBot β\ninst✝¹ : FunLike F α β\ninst✝ : SupBotHomClass F α β\nf : F\ns : Finset ι\ng : ι → α\n⊢ Eq (f (s.sup g)) (s.sup (Function.comp (⇑f) g))","decl":"@[simp]\ntheorem _root_.map_finset_sup [SemilatticeSup β] [OrderBot β]\n    [FunLike F α β] [SupBotHomClass F α β]\n    (f : F) (s : Finset ι) (g : ι → α) : f (s.sup g) = s.sup (f ∘ g) :=\n  Finset.cons_induction_on s (map_bot f) fun i s _ h => by\n    rw [sup_cons, sup_cons, map_sup, h, Function.comp_apply]\n\n"}
{"name":"Finset.sup_le_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\na : α\n⊢ Iff (LE.le (s.sup f) a) (∀ (b : β), Membership.mem s b → LE.le (f b) a)","decl":"@[simp]\nprotected theorem sup_le_iff {a : α} : s.sup f ≤ a ↔ ∀ b ∈ s, f b ≤ a := by\n  apply Iff.trans Multiset.sup_le\n  simp only [Multiset.mem_map, and_imp, exists_imp]\n  exact ⟨fun k b hb => k _ _ hb rfl, fun k a' b hb h => h ▸ k _ hb⟩\n\n"}
{"name":"Finset.sup_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\na : α\na✝ : ∀ (b : β), Membership.mem s b → LE.le (f b) a\n⊢ LE.le (s.sup f) a","decl":"protected alias ⟨_, sup_le⟩ := Finset.sup_le_iff\n\n"}
{"name":"Finset.sup_const_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\na : α\n⊢ LE.le (s.sup fun x => a) a","decl":"theorem sup_const_le : (s.sup fun _ => a) ≤ a :=\n  Finset.sup_le fun _ _ => le_rfl\n\n"}
{"name":"Finset.le_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\nb : β\nhb : Membership.mem s b\n⊢ LE.le (f b) (s.sup f)","decl":"theorem le_sup {b : β} (hb : b ∈ s) : f b ≤ s.sup f :=\n  Finset.sup_le_iff.1 le_rfl _ hb\n\n"}
{"name":"Finset.isLUB_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset α\n⊢ IsLUB (↑s) (s.sup id)","decl":"theorem isLUB_sup (s : Finset α) : IsLUB s (sup s id) :=\n  ⟨fun x h => id_eq x ▸ le_sup h, fun _ h => Finset.sup_le h⟩\n\n"}
{"name":"Finset.le_sup_of_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\na : α\nb : β\nhb : Membership.mem s b\nh : LE.le a (f b)\n⊢ LE.le a (s.sup f)","decl":"theorem le_sup_of_le {b : β} (hb : b ∈ s) (h : a ≤ f b) : a ≤ s.sup f := h.trans <| le_sup hb\n\n"}
{"name":"Finset.sup_union","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ns₁ s₂ : Finset β\nf : β → α\ninst✝ : DecidableEq β\n⊢ Eq ((Union.union s₁ s₂).sup f) (Max.max (s₁.sup f) (s₂.sup f))","decl":"theorem sup_union [DecidableEq β] : (s₁ ∪ s₂).sup f = s₁.sup f ⊔ s₂.sup f :=\n  eq_of_forall_ge_iff fun c => by simp [or_imp, forall_and]\n\n"}
{"name":"Finset.sup_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\nf : β → α\ninst✝ : DecidableEq β\ns : Finset γ\nt : γ → Finset β\n⊢ Eq ((s.biUnion t).sup f) (s.sup fun x => (t x).sup f)","decl":"@[simp]\ntheorem sup_biUnion [DecidableEq β] (s : Finset γ) (t : γ → Finset β) :\n    (s.biUnion t).sup f = s.sup fun x => (t x).sup f :=\n  eq_of_forall_ge_iff fun c => by simp [@forall_swap _ β]\n\n"}
{"name":"Finset.sup_const","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nh : s.Nonempty\nc : α\n⊢ Eq (s.sup fun x => c) c","decl":"theorem sup_const {s : Finset β} (h : s.Nonempty) (c : α) : (s.sup fun _ => c) = c :=\n  eq_of_forall_ge_iff (fun _ => Finset.sup_le_iff.trans h.forall_const)\n\n"}
{"name":"Finset.sup_bot","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\n⊢ Eq (s.sup fun x => Bot.bot) Bot.bot","decl":"@[simp]\ntheorem sup_bot (s : Finset β) : (s.sup fun _ => ⊥) = (⊥ : α) := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · exact sup_empty\n  · exact sup_const hs _\n\n"}
{"name":"Finset.sup_ite","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ns : Finset β\nf g : β → α\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (s.sup fun i => ite (p i) (f i) (g i)) (Max.max ((Finset.filter p s).sup f) ((Finset.filter (fun i => Not (p i)) s).sup g))","decl":"theorem sup_ite (p : β → Prop) [DecidablePred p] :\n    (s.sup fun i => ite (p i) (f i) (g i)) = (s.filter p).sup f ⊔ (s.filter fun i => ¬p i).sup g :=\n  fold_ite _\n\n"}
{"name":"Finset.sup_mono_fun","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf g : β → α\nh : ∀ (b : β), Membership.mem s b → LE.le (f b) (g b)\n⊢ LE.le (s.sup f) (s.sup g)","decl":"@[gcongr]\ntheorem sup_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ≤ g b) : s.sup f ≤ s.sup g :=\n  Finset.sup_le fun b hb => le_trans (h b hb) (le_sup hb)\n\n"}
{"name":"Finset.sup_mono","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns₁ s₂ : Finset β\nf : β → α\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (s₁.sup f) (s₂.sup f)","decl":"@[gcongr]\ntheorem sup_mono (h : s₁ ⊆ s₂) : s₁.sup f ≤ s₂.sup f :=\n  Finset.sup_le (fun _ hb => le_sup (h hb))\n\n"}
{"name":"Finset.sup_comm","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nt : Finset γ\nf : β → γ → α\n⊢ Eq (s.sup fun b => t.sup (f b)) (t.sup fun c => s.sup fun b => f b c)","decl":"protected theorem sup_comm (s : Finset β) (t : Finset γ) (f : β → γ → α) :\n    (s.sup fun b => t.sup (f b)) = t.sup fun c => s.sup fun b => f b c :=\n  eq_of_forall_ge_iff fun a => by simpa using forall₂_swap\n\n"}
{"name":"Finset.sup_attach","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\n⊢ Eq (s.attach.sup fun x => f ↑x) (s.sup f)","decl":"@[simp]\ntheorem sup_attach (s : Finset β) (f : β → α) : (s.attach.sup fun x => f x) = s.sup f :=\n  (s.attach.sup_map (Function.Embedding.subtype _) f).symm.trans <| congr_arg _ attach_map_val\n\n"}
{"name":"Finset.sup_product_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nt : Finset γ\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).sup f) (s.sup fun i => t.sup fun i' => f { fst := i, snd := i' })","decl":"/-- See also `Finset.product_biUnion`. -/\ntheorem sup_product_left (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (s ×ˢ t).sup f = s.sup fun i => t.sup fun i' => f ⟨i, i'⟩ :=\n  eq_of_forall_ge_iff fun a => by simp [@forall_swap _ γ]\n\n"}
{"name":"Finset.sup_product_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nt : Finset γ\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).sup f) (t.sup fun i' => s.sup fun i => f { fst := i, snd := i' })","decl":"theorem sup_product_right (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (s ×ˢ t).sup f = t.sup fun i' => s.sup fun i => f ⟨i, i'⟩ := by\n  rw [sup_product_left, Finset.sup_comm]\n\n"}
{"name":"Finset.sup_prodMap","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝³ : SemilatticeSup α\ninst✝² : SemilatticeSup β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq ((SProd.sprod s t).sup (Prod.map f g)) { fst := s.sup f, snd := t.sup g }","decl":"@[simp] lemma sup_prodMap (hs : s.Nonempty) (ht : t.Nonempty) (f : ι → α) (g : κ → β) :\n    sup (s ×ˢ t) (Prod.map f g) = (sup s f, sup t g) :=\n  eq_of_forall_ge_iff fun i ↦ by\n    obtain ⟨a, ha⟩ := hs\n    obtain ⟨b, hb⟩ := ht\n    simp only [Prod.map, Finset.sup_le_iff, mem_product, and_imp, Prod.forall, Prod.le_def]\n    exact ⟨fun h ↦ ⟨fun i hi ↦ (h _ _ hi hb).1, fun j hj ↦ (h _ _ ha hj).2⟩, by aesop⟩\n\n"}
{"name":"Finset.sup_erase_bot","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq ((s.erase Bot.bot).sup id) (s.sup id)","decl":"@[simp]\ntheorem sup_erase_bot [DecidableEq α] (s : Finset α) : (s.erase ⊥).sup id = s.sup id := by\n  refine (sup_mono (s.erase_subset _)).antisymm (Finset.sup_le_iff.2 fun a ha => ?_)\n  obtain rfl | ha' := eq_or_ne a ⊥\n  · exact bot_le\n  · exact le_sup (mem_erase.2 ⟨ha', ha⟩)\n\n"}
{"name":"Finset.sup_sdiff_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝ : GeneralizedBooleanAlgebra α\ns : Finset β\nf : β → α\na : α\n⊢ Eq (s.sup fun b => SDiff.sdiff (f b) a) (SDiff.sdiff (s.sup f) a)","decl":"theorem sup_sdiff_right {α β : Type*} [GeneralizedBooleanAlgebra α] (s : Finset β) (f : β → α)\n    (a : α) : (s.sup fun b => f b \\ a) = s.sup f \\ a := by\n  induction s using Finset.cons_induction with\n  | empty => rw [sup_empty, sup_empty, bot_sdiff]\n  | cons _ _ _ h => rw [sup_cons, sup_cons, h, sup_sdiff]\n\n"}
{"name":"Finset.comp_sup_eq_sup_comp","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SemilatticeSup α\ninst✝² : OrderBot α\ninst✝¹ : SemilatticeSup γ\ninst✝ : OrderBot γ\ns : Finset β\nf : β → α\ng : α → γ\ng_sup : ∀ (x y : α), Eq (g (Max.max x y)) (Max.max (g x) (g y))\nbot : Eq (g Bot.bot) Bot.bot\n⊢ Eq (g (s.sup f)) (s.sup (Function.comp g f))","decl":"theorem comp_sup_eq_sup_comp [SemilatticeSup γ] [OrderBot γ] {s : Finset β} {f : β → α} (g : α → γ)\n    (g_sup : ∀ x y, g (x ⊔ y) = g x ⊔ g y) (bot : g ⊥ = ⊥) : g (s.sup f) = s.sup (g ∘ f) :=\n  Finset.cons_induction_on s bot fun c t hc ih => by\n    rw [sup_cons, sup_cons, g_sup, ih, Function.comp_apply]\n\n"}
{"name":"Finset.sup_coe","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nP : α → Prop\nPbot : P Bot.bot\nPsup : ∀ ⦃x y : α⦄, P x → P y → P (Max.max x y)\nt : Finset β\nf : β → Subtype fun x => P x\n⊢ Eq (↑(t.sup f)) (t.sup fun x => ↑(f x))","decl":"/-- Computing `sup` in a subtype (closed under `sup`) is the same as computing it in `α`. -/\ntheorem sup_coe {P : α → Prop} {Pbot : P ⊥} {Psup : ∀ ⦃x y⦄, P x → P y → P (x ⊔ y)} (t : Finset β)\n    (f : β → { x : α // P x }) :\n    (@sup { x // P x } _ (Subtype.semilatticeSup Psup) (Subtype.orderBot Pbot) t f : α) =\n      t.sup fun x => ↑(f x) := by\n  letI := Subtype.semilatticeSup Psup\n  letI := Subtype.orderBot Pbot\n  apply comp_sup_eq_sup_comp Subtype.val <;> intros <;> rfl\n\n"}
{"name":"Finset.sup_toFinset","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Multiset β\n⊢ Eq (s.sup f).toFinset (s.sup fun x => (f x).toFinset)","decl":"@[simp]\ntheorem sup_toFinset {α β} [DecidableEq β] (s : Finset α) (f : α → Multiset β) :\n    (s.sup f).toFinset = s.sup fun x => (f x).toFinset :=\n  comp_sup_eq_sup_comp Multiset.toFinset toFinset_union rfl\n\n"}
{"name":"List.foldr_sup_eq_sup_toFinset","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (List.foldr (fun x1 x2 => Max.max x1 x2) Bot.bot l) (l.toFinset.sup id)","decl":"theorem _root_.List.foldr_sup_eq_sup_toFinset [DecidableEq α] (l : List α) :\n    l.foldr (· ⊔ ·) ⊥ = l.toFinset.sup id := by\n  rw [← coe_fold_r, ← Multiset.fold_dedup_idem, sup_def, ← List.toFinset_coe, toFinset_val,\n    Multiset.map_id]\n  rfl\n\n"}
{"name":"Finset.subset_range_sup_succ","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"s : Finset Nat\n⊢ HasSubset.Subset s (Finset.range (s.sup id).succ)","decl":"theorem subset_range_sup_succ (s : Finset ℕ) : s ⊆ range (s.sup id).succ := fun _ hn =>\n  mem_range.2 <| Nat.lt_succ_of_le <| @le_sup _ _ _ _ _ id _ hn\n\n"}
{"name":"Finset.sup_induction","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\np : α → Prop\nhb : p Bot.bot\nhp : ∀ (a₁ : α), p a₁ → ∀ (a₂ : α), p a₂ → p (Max.max a₁ a₂)\nhs : ∀ (b : β), Membership.mem s b → p (f b)\n⊢ p (s.sup f)","decl":"theorem sup_induction {p : α → Prop} (hb : p ⊥) (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p (a₁ ⊔ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.sup f) := by\n  induction s using Finset.cons_induction with\n  | empty => exact hb\n  | cons _ _ _ ih =>\n    simp only [sup_cons, forall_mem_cons] at hs ⊢\n    exact hp _ hs.1 _ (ih hs.2)\n\n"}
{"name":"Finset.sup_le_of_le_directed","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_7\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Set α\nhs : s.Nonempty\nhdir : DirectedOn (fun x1 x2 => LE.le x1 x2) s\nt : Finset α\na✝ : ∀ (x : α), Membership.mem t x → Exists fun y => And (Membership.mem s y) (LE.le x y)\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (t.sup id) x)","decl":"theorem sup_le_of_le_directed {α : Type*} [SemilatticeSup α] [OrderBot α] (s : Set α)\n    (hs : s.Nonempty) (hdir : DirectedOn (· ≤ ·) s) (t : Finset α) :\n    (∀ x ∈ t, ∃ y ∈ s, x ≤ y) → ∃ x ∈ s, t.sup id ≤ x := by\n  classical\n    induction' t using Finset.induction_on with a r _ ih h\n    · simpa only [forall_prop_of_true, and_true, forall_prop_of_false, bot_le, not_false_iff,\n        sup_empty, forall_true_iff, not_mem_empty]\n    · intro h\n      have incs : (r : Set α) ⊆ ↑(insert a r) := by\n        rw [Finset.coe_subset]\n        apply Finset.subset_insert\n      -- x ∈ s is above the sup of r\n      obtain ⟨x, ⟨hxs, hsx_sup⟩⟩ := ih fun x hx => h x <| incs hx\n      -- y ∈ s is above a\n      obtain ⟨y, hys, hay⟩ := h a (Finset.mem_insert_self a r)\n      -- z ∈ s is above x and y\n      obtain ⟨z, hzs, ⟨hxz, hyz⟩⟩ := hdir x hxs y hys\n      use z, hzs\n      rw [sup_insert, id, sup_le_iff]\n      exact ⟨le_trans hay hyz, le_trans hsx_sup hxz⟩\n\n-- If we acquire sublattices\n-- the hypotheses should be reformulated as `s : SubsemilatticeSupBot`\n"}
{"name":"Finset.sup_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Set α\nw₁ : Membership.mem s Bot.bot\nw₂ : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Membership.mem s (Max.max x y)\nι : Type u_7\nt : Finset ι\np : ι → α\nh : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Membership.mem s (t.sup p)","decl":"theorem sup_mem (s : Set α) (w₁ : ⊥ ∈ s) (w₂ : ∀ᵉ (x ∈ s) (y ∈ s), x ⊔ y ∈ s)\n    {ι : Type*} (t : Finset ι) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.sup p ∈ s :=\n  @sup_induction _ _ _ _ _ _ (· ∈ s) w₁ w₂ h\n\n"}
{"name":"Finset.sup_eq_bot_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nf : β → α\nS : Finset β\n⊢ Iff (Eq (S.sup f) Bot.bot) (∀ (s : β), Membership.mem S s → Eq (f s) Bot.bot)","decl":"@[simp]\nprotected theorem sup_eq_bot_iff (f : β → α) (S : Finset β) : S.sup f = ⊥ ↔ ∀ s ∈ S, f s = ⊥ := by\n  classical induction' S using Finset.induction with a S _ hi <;> simp [*]\n\n"}
{"name":"Finset.sup_eq_bot_of_isEmpty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : IsEmpty β\nf : β → α\nS : Finset β\n⊢ Eq (S.sup f) Bot.bot","decl":"@[simp]\ntheorem sup_eq_bot_of_isEmpty [IsEmpty β] (f : β → α) (S : Finset β) : S.sup f = ⊥ := by\n  rw [Finset.sup_eq_bot_iff]\n  exact fun x _ => False.elim <| IsEmpty.false x\n\n"}
{"name":"Finset.sup_eq_iSup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset α\nf : α → β\n⊢ Eq (s.sup f) (iSup fun a => iSup fun h => f a)","decl":"theorem sup_eq_iSup [CompleteLattice β] (s : Finset α) (f : α → β) : s.sup f = ⨆ a ∈ s, f a :=\n  le_antisymm\n    (Finset.sup_le (fun a ha => le_iSup_of_le a <| le_iSup (fun _ => f a) ha))\n    (iSup_le fun _ => iSup_le fun ha => le_sup ha)\n\n"}
{"name":"Finset.sup_id_eq_sSup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\ns : Finset α\n⊢ Eq (s.sup id) (SupSet.sSup ↑s)","decl":"theorem sup_id_eq_sSup [CompleteLattice α] (s : Finset α) : s.sup id = sSup s := by\n  simp [sSup_eq_iSup, sup_eq_iSup]\n\n"}
{"name":"Finset.sup_id_set_eq_sUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ns : Finset (Set α)\n⊢ Eq (s.sup id) (↑s).sUnion","decl":"theorem sup_id_set_eq_sUnion (s : Finset (Set α)) : s.sup id = ⋃₀ ↑s :=\n  sup_id_eq_sSup _\n\n"}
{"name":"Finset.sup_set_eq_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ns : Finset α\nf : α → Set β\n⊢ Eq (s.sup f) (Set.iUnion fun x => Set.iUnion fun h => f x)","decl":"@[simp]\ntheorem sup_set_eq_biUnion (s : Finset α) (f : α → Set β) : s.sup f = ⋃ x ∈ s, f x :=\n  sup_eq_iSup _ _\n\n"}
{"name":"Finset.sup_eq_sSup_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset α\nf : α → β\n⊢ Eq (s.sup f) (SupSet.sSup (Set.image f ↑s))","decl":"theorem sup_eq_sSup_image [CompleteLattice β] (s : Finset α) (f : α → β) :\n    s.sup f = sSup (f '' s) := by\n  classical rw [← Finset.coe_image, ← sup_id_eq_sSup, sup_image, Function.id_comp]\n\n"}
{"name":"Finset.inf_def","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\n⊢ Eq (s.inf f) (Multiset.map f s.val).inf","decl":"theorem inf_def : s.inf f = (s.1.map f).inf :=\n  rfl\n\n"}
{"name":"Finset.inf_empty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\nf : β → α\n⊢ Eq (EmptyCollection.emptyCollection.inf f) Top.top","decl":"@[simp]\ntheorem inf_empty : (∅ : Finset β).inf f = ⊤ :=\n  fold_empty\n\n"}
{"name":"Finset.inf_cons","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\nb : β\nh : Not (Membership.mem s b)\n⊢ Eq ((Finset.cons b s h).inf f) (Min.min (f b) (s.inf f))","decl":"@[simp]\ntheorem inf_cons {b : β} (h : b ∉ s) : (cons b s h).inf f = f b ⊓ s.inf f :=\n  @sup_cons αᵒᵈ _ _ _ _ _ _ h\n\n"}
{"name":"Finset.inf_insert","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).inf f) (Min.min (f b) (s.inf f))","decl":"@[simp]\ntheorem inf_insert [DecidableEq β] {b : β} : (insert b s : Finset β).inf f = f b ⊓ s.inf f :=\n  fold_insert_idem\n\n"}
{"name":"Finset.inf_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\ng : β → α\n⊢ Eq ((Finset.image f s).inf g) (s.inf (Function.comp g f))","decl":"@[simp]\ntheorem inf_image [DecidableEq β] (s : Finset γ) (f : γ → β) (g : β → α) :\n    (s.image f).inf g = s.inf (g ∘ f) :=\n  fold_image_idem\n\n"}
{"name":"Finset.inf_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\n⊢ Eq ((Finset.map f s).inf g) (s.inf (Function.comp g ⇑f))","decl":"@[simp]\ntheorem inf_map (s : Finset γ) (f : γ ↪ β) (g : β → α) : (s.map f).inf g = s.inf (g ∘ f) :=\n  fold_map\n\n"}
{"name":"Finset.inf_singleton","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).inf f) (f b)","decl":"@[simp]\ntheorem inf_singleton {b : β} : ({b} : Finset β).inf f = f b :=\n  Multiset.inf_singleton\n\n"}
{"name":"Finset.inf_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf g : β → α\n⊢ Eq (s.inf (Min.min f g)) (Min.min (s.inf f) (s.inf g))","decl":"theorem inf_inf : s.inf (f ⊓ g) = s.inf f ⊓ s.inf g :=\n  @sup_sup αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_congr","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns₁ s₂ : Finset β\nf g : β → α\nhs : Eq s₁ s₂\nhfg : ∀ (a : β), Membership.mem s₂ a → Eq (f a) (g a)\n⊢ Eq (s₁.inf f) (s₂.inf g)","decl":"theorem inf_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) :\n    s₁.inf f = s₂.inf g := by\n  subst hs\n  exact Finset.fold_congr hfg\n\n"}
{"name":"map_finset_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝⁵ : SemilatticeInf α\ninst✝⁴ : OrderTop α\ninst✝³ : SemilatticeInf β\ninst✝² : OrderTop β\ninst✝¹ : FunLike F α β\ninst✝ : InfTopHomClass F α β\nf : F\ns : Finset ι\ng : ι → α\n⊢ Eq (f (s.inf g)) (s.inf (Function.comp (⇑f) g))","decl":"@[simp]\ntheorem _root_.map_finset_inf [SemilatticeInf β] [OrderTop β]\n    [FunLike F α β] [InfTopHomClass F α β]\n    (f : F) (s : Finset ι) (g : ι → α) : f (s.inf g) = s.inf (f ∘ g) :=\n  Finset.cons_induction_on s (map_top f) fun i s _ h => by\n    rw [inf_cons, inf_cons, map_inf, h, Function.comp_apply]\n\n"}
{"name":"Finset.le_inf_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\na : α\n⊢ Iff (LE.le a (s.inf f)) (∀ (b : β), Membership.mem s b → LE.le a (f b))","decl":"@[simp] protected theorem le_inf_iff {a : α} : a ≤ s.inf f ↔ ∀ b ∈ s, a ≤ f b :=\n  @Finset.sup_le_iff αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.le_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\na : α\na✝ : ∀ (b : β), Membership.mem s b → LE.le a (f b)\n⊢ LE.le a (s.inf f)","decl":"protected alias ⟨_, le_inf⟩ := Finset.le_inf_iff\n\n"}
{"name":"Finset.le_inf_const_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\na : α\n⊢ LE.le a (s.inf fun x => a)","decl":"theorem le_inf_const_le : a ≤ s.inf fun _ => a :=\n  Finset.le_inf fun _ _ => le_rfl\n\n"}
{"name":"Finset.inf_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\nb : β\nhb : Membership.mem s b\n⊢ LE.le (s.inf f) (f b)","decl":"theorem inf_le {b : β} (hb : b ∈ s) : s.inf f ≤ f b :=\n  Finset.le_inf_iff.1 le_rfl _ hb\n\n"}
{"name":"Finset.isGLB_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset α\n⊢ IsGLB (↑s) (s.inf id)","decl":"theorem isGLB_inf (s : Finset α) : IsGLB s (inf s id) :=\n  ⟨fun x h => id_eq x ▸ inf_le h, fun _ h => Finset.le_inf h⟩\n\n"}
{"name":"Finset.inf_le_of_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\na : α\nb : β\nhb : Membership.mem s b\nh : LE.le (f b) a\n⊢ LE.le (s.inf f) a","decl":"theorem inf_le_of_le {b : β} (hb : b ∈ s) (h : f b ≤ a) : s.inf f ≤ a := (inf_le hb).trans h\n\n"}
{"name":"Finset.inf_union","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ns₁ s₂ : Finset β\nf : β → α\ninst✝ : DecidableEq β\n⊢ Eq ((Union.union s₁ s₂).inf f) (Min.min (s₁.inf f) (s₂.inf f))","decl":"theorem inf_union [DecidableEq β] : (s₁ ∪ s₂).inf f = s₁.inf f ⊓ s₂.inf f :=\n  eq_of_forall_le_iff fun c ↦ by simp [or_imp, forall_and]\n\n"}
{"name":"Finset.inf_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\nf : β → α\ninst✝ : DecidableEq β\ns : Finset γ\nt : γ → Finset β\n⊢ Eq ((s.biUnion t).inf f) (s.inf fun x => (t x).inf f)","decl":"@[simp] theorem inf_biUnion [DecidableEq β] (s : Finset γ) (t : γ → Finset β) :\n    (s.biUnion t).inf f = s.inf fun x => (t x).inf f :=\n  @sup_biUnion αᵒᵈ _ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_const","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nh : s.Nonempty\nc : α\n⊢ Eq (s.inf fun x => c) c","decl":"theorem inf_const (h : s.Nonempty) (c : α) : (s.inf fun _ => c) = c := @sup_const αᵒᵈ _ _ _ _ h _\n\n"}
{"name":"Finset.inf_top","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\n⊢ Eq (s.inf fun x => Top.top) Top.top","decl":"@[simp] theorem inf_top (s : Finset β) : (s.inf fun _ => ⊤) = (⊤ : α) := @sup_bot αᵒᵈ _ _ _ _\n\n"}
{"name":"Finset.inf_ite","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ns : Finset β\nf g : β → α\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (s.inf fun i => ite (p i) (f i) (g i)) (Min.min ((Finset.filter p s).inf f) ((Finset.filter (fun i => Not (p i)) s).inf g))","decl":"theorem inf_ite (p : β → Prop) [DecidablePred p] :\n    (s.inf fun i ↦ ite (p i) (f i) (g i)) = (s.filter p).inf f ⊓ (s.filter fun i ↦ ¬ p i).inf g :=\n  fold_ite _\n\n"}
{"name":"Finset.inf_mono_fun","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf g : β → α\nh : ∀ (b : β), Membership.mem s b → LE.le (f b) (g b)\n⊢ LE.le (s.inf f) (s.inf g)","decl":"@[gcongr]\ntheorem inf_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ≤ g b) : s.inf f ≤ s.inf g :=\n  Finset.le_inf fun b hb => le_trans (inf_le hb) (h b hb)\n\n"}
{"name":"Finset.inf_mono","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns₁ s₂ : Finset β\nf : β → α\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (s₂.inf f) (s₁.inf f)","decl":"@[gcongr]\ntheorem inf_mono (h : s₁ ⊆ s₂) : s₂.inf f ≤ s₁.inf f :=\n  Finset.le_inf (fun _ hb => inf_le (h hb))\n\n"}
{"name":"Finset.inf_comm","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nt : Finset γ\nf : β → γ → α\n⊢ Eq (s.inf fun b => t.inf (f b)) (t.inf fun c => s.inf fun b => f b c)","decl":"protected theorem inf_comm (s : Finset β) (t : Finset γ) (f : β → γ → α) :\n    (s.inf fun b => t.inf (f b)) = t.inf fun c => s.inf fun b => f b c :=\n  @Finset.sup_comm αᵒᵈ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_attach","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\n⊢ Eq (s.attach.inf fun x => f ↑x) (s.inf f)","decl":"theorem inf_attach (s : Finset β) (f : β → α) : (s.attach.inf fun x => f x) = s.inf f :=\n  @sup_attach αᵒᵈ _ _ _ _ _\n\n"}
{"name":"Finset.inf_product_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nt : Finset γ\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).inf f) (s.inf fun i => t.inf fun i' => f { fst := i, snd := i' })","decl":"theorem inf_product_left (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (s ×ˢ t).inf f = s.inf fun i => t.inf fun i' => f ⟨i, i'⟩ :=\n  @sup_product_left αᵒᵈ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_product_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nt : Finset γ\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).inf f) (t.inf fun i' => s.inf fun i => f { fst := i, snd := i' })","decl":"theorem inf_product_right (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (s ×ˢ t).inf f = t.inf fun i' => s.inf fun i => f ⟨i, i'⟩ :=\n  @sup_product_right αᵒᵈ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_prodMap","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝³ : SemilatticeInf α\ninst✝² : SemilatticeInf β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq ((SProd.sprod s t).inf (Prod.map f g)) { fst := s.inf f, snd := t.inf g }","decl":"@[simp] lemma inf_prodMap (hs : s.Nonempty) (ht : t.Nonempty) (f : ι → α) (g : κ → β) :\n    inf (s ×ˢ t) (Prod.map f g) = (inf s f, inf t g) :=\n  sup_prodMap (α := αᵒᵈ) (β := βᵒᵈ) hs ht _ _\n\n"}
{"name":"Finset.inf_erase_top","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq ((s.erase Top.top).inf id) (s.inf id)","decl":"@[simp]\ntheorem inf_erase_top [DecidableEq α] (s : Finset α) : (s.erase ⊤).inf id = s.inf id :=\n  @sup_erase_bot αᵒᵈ _ _ _ _\n\n"}
{"name":"Finset.comp_inf_eq_inf_comp","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : SemilatticeInf α\ninst✝² : OrderTop α\ninst✝¹ : SemilatticeInf γ\ninst✝ : OrderTop γ\ns : Finset β\nf : β → α\ng : α → γ\ng_inf : ∀ (x y : α), Eq (g (Min.min x y)) (Min.min (g x) (g y))\ntop : Eq (g Top.top) Top.top\n⊢ Eq (g (s.inf f)) (s.inf (Function.comp g f))","decl":"theorem comp_inf_eq_inf_comp [SemilatticeInf γ] [OrderTop γ] {s : Finset β} {f : β → α} (g : α → γ)\n    (g_inf : ∀ x y, g (x ⊓ y) = g x ⊓ g y) (top : g ⊤ = ⊤) : g (s.inf f) = s.inf (g ∘ f) :=\n  @comp_sup_eq_sup_comp αᵒᵈ _ γᵒᵈ _ _ _ _ _ _ _ g_inf top\n\n"}
{"name":"Finset.inf_coe","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\nP : α → Prop\nPtop : P Top.top\nPinf : ∀ ⦃x y : α⦄, P x → P y → P (Min.min x y)\nt : Finset β\nf : β → Subtype fun x => P x\n⊢ Eq (↑(t.inf f)) (t.inf fun x => ↑(f x))","decl":"/-- Computing `inf` in a subtype (closed under `inf`) is the same as computing it in `α`. -/\ntheorem inf_coe {P : α → Prop} {Ptop : P ⊤} {Pinf : ∀ ⦃x y⦄, P x → P y → P (x ⊓ y)} (t : Finset β)\n    (f : β → { x : α // P x }) :\n    (@inf { x // P x } _ (Subtype.semilatticeInf Pinf) (Subtype.orderTop Ptop) t f : α) =\n      t.inf fun x => ↑(f x) :=\n  @sup_coe αᵒᵈ _ _ _ _ Ptop Pinf t f\n\n"}
{"name":"List.foldr_inf_eq_inf_toFinset","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (List.foldr (fun x1 x2 => Min.min x1 x2) Top.top l) (l.toFinset.inf id)","decl":"theorem _root_.List.foldr_inf_eq_inf_toFinset [DecidableEq α] (l : List α) :\n    l.foldr (· ⊓ ·) ⊤ = l.toFinset.inf id := by\n  rw [← coe_fold_r, ← Multiset.fold_dedup_idem, inf_def, ← List.toFinset_coe, toFinset_val,\n    Multiset.map_id]\n  rfl\n\n"}
{"name":"Finset.inf_induction","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\np : α → Prop\nht : p Top.top\nhp : ∀ (a₁ : α), p a₁ → ∀ (a₂ : α), p a₂ → p (Min.min a₁ a₂)\nhs : ∀ (b : β), Membership.mem s b → p (f b)\n⊢ p (s.inf f)","decl":"theorem inf_induction {p : α → Prop} (ht : p ⊤) (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p (a₁ ⊓ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.inf f) :=\n  @sup_induction αᵒᵈ _ _ _ _ _ _ ht hp hs\n\n"}
{"name":"Finset.inf_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Set α\nw₁ : Membership.mem s Top.top\nw₂ : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Membership.mem s (Min.min x y)\nι : Type u_7\nt : Finset ι\np : ι → α\nh : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Membership.mem s (t.inf p)","decl":"theorem inf_mem (s : Set α) (w₁ : ⊤ ∈ s) (w₂ : ∀ᵉ (x ∈ s) (y ∈ s), x ⊓ y ∈ s)\n    {ι : Type*} (t : Finset ι) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.inf p ∈ s :=\n  @inf_induction _ _ _ _ _ _ (· ∈ s) w₁ w₂ h\n\n"}
{"name":"Finset.inf_eq_top_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\nf : β → α\nS : Finset β\n⊢ Iff (Eq (S.inf f) Top.top) (∀ (s : β), Membership.mem S s → Eq (f s) Top.top)","decl":"@[simp]\nprotected theorem inf_eq_top_iff (f : β → α) (S : Finset β) : S.inf f = ⊤ ↔ ∀ s ∈ S, f s = ⊤ :=\n  @Finset.sup_eq_bot_iff αᵒᵈ _ _ _ _ _\n\n"}
{"name":"Finset.toDual_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → α\n⊢ Eq (OrderDual.toDual (s.sup f)) (s.inf (Function.comp (⇑OrderDual.toDual) f))","decl":"@[simp]\ntheorem toDual_sup [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → α) :\n    toDual (s.sup f) = s.inf (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.toDual_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → α\n⊢ Eq (OrderDual.toDual (s.inf f)) (s.sup (Function.comp (⇑OrderDual.toDual) f))","decl":"@[simp]\ntheorem toDual_inf [SemilatticeInf α] [OrderTop α] (s : Finset β) (f : β → α) :\n    toDual (s.inf f) = s.sup (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.ofDual_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nf : β → OrderDual α\n⊢ Eq (OrderDual.ofDual (s.sup f)) (s.inf (Function.comp (⇑OrderDual.ofDual) f))","decl":"@[simp]\ntheorem ofDual_sup [SemilatticeInf α] [OrderTop α] (s : Finset β) (f : β → αᵒᵈ) :\n    ofDual (s.sup f) = s.inf (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.ofDual_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nf : β → OrderDual α\n⊢ Eq (OrderDual.ofDual (s.inf f)) (s.sup (Function.comp (⇑OrderDual.ofDual) f))","decl":"@[simp]\ntheorem ofDual_inf [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → αᵒᵈ) :\n    ofDual (s.inf f) = s.sup (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.sup_inf_distrib_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (Min.min a (s.sup f)) (s.sup fun i => Min.min a (f i))","decl":"theorem sup_inf_distrib_left (s : Finset ι) (f : ι → α) (a : α) :\n    a ⊓ s.sup f = s.sup fun i => a ⊓ f i := by\n  induction s using Finset.cons_induction with\n  | empty => simp_rw [Finset.sup_empty, inf_bot_eq]\n  | cons _ _ _ h => rw [sup_cons, sup_cons, inf_sup_left, h]\n\n"}
{"name":"Finset.sup_inf_distrib_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (Min.min (s.sup f) a) (s.sup fun i => Min.min (f i) a)","decl":"theorem sup_inf_distrib_right (s : Finset ι) (f : ι → α) (a : α) :\n    s.sup f ⊓ a = s.sup fun i => f i ⊓ a := by\n  rw [_root_.inf_comm, s.sup_inf_distrib_left]\n  simp_rw [_root_.inf_comm]\n\n"}
{"name":"Finset.disjoint_sup_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\n⊢ Iff (Disjoint a (s.sup f)) (∀ ⦃i : ι⦄, Membership.mem s i → Disjoint a (f i))","decl":"protected theorem disjoint_sup_right : Disjoint a (s.sup f) ↔ ∀ ⦃i⦄, i ∈ s → Disjoint a (f i) := by\n  simp only [disjoint_iff, sup_inf_distrib_left, Finset.sup_eq_bot_iff]\n\n"}
{"name":"Finset.disjoint_sup_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\n⊢ Iff (Disjoint (s.sup f) a) (∀ ⦃i : ι⦄, Membership.mem s i → Disjoint (f i) a)","decl":"protected theorem disjoint_sup_left : Disjoint (s.sup f) a ↔ ∀ ⦃i⦄, i ∈ s → Disjoint (f i) a := by\n  simp only [disjoint_iff, sup_inf_distrib_right, Finset.sup_eq_bot_iff]\n\n"}
{"name":"Finset.sup_inf_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\nκ : Type u_6\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\n⊢ Eq (Min.min (s.sup f) (t.sup g)) ((SProd.sprod s t).sup fun i => Min.min (f i.1) (g i.2))","decl":"theorem sup_inf_sup (s : Finset ι) (t : Finset κ) (f : ι → α) (g : κ → α) :\n    s.sup f ⊓ t.sup g = (s ×ˢ t).sup fun i => f i.1 ⊓ g i.2 := by\n  simp_rw [Finset.sup_inf_distrib_right, Finset.sup_inf_distrib_left, sup_product_left]\n\n"}
{"name":"Finset.inf_sup_distrib_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderTop α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (Max.max a (s.inf f)) (s.inf fun i => Max.max a (f i))","decl":"theorem inf_sup_distrib_left (s : Finset ι) (f : ι → α) (a : α) :\n    a ⊔ s.inf f = s.inf fun i => a ⊔ f i :=\n  @sup_inf_distrib_left αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_sup_distrib_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderTop α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (Max.max (s.inf f) a) (s.inf fun i => Max.max (f i) a)","decl":"theorem inf_sup_distrib_right (s : Finset ι) (f : ι → α) (a : α) :\n    s.inf f ⊔ a = s.inf fun i => f i ⊔ a :=\n  @sup_inf_distrib_right αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.codisjoint_inf_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderTop α\nf : ι → α\ns : Finset ι\na : α\n⊢ Iff (Codisjoint a (s.inf f)) (∀ ⦃i : ι⦄, Membership.mem s i → Codisjoint a (f i))","decl":"protected theorem codisjoint_inf_right :\n    Codisjoint a (s.inf f) ↔ ∀ ⦃i⦄, i ∈ s → Codisjoint a (f i) :=\n  @Finset.disjoint_sup_right αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.codisjoint_inf_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : DistribLattice α\ninst✝ : OrderTop α\nf : ι → α\ns : Finset ι\na : α\n⊢ Iff (Codisjoint (s.inf f) a) (∀ ⦃i : ι⦄, Membership.mem s i → Codisjoint (f i) a)","decl":"protected theorem codisjoint_inf_left :\n    Codisjoint (s.inf f) a ↔ ∀ ⦃i⦄, i ∈ s → Codisjoint (f i) a :=\n  @Finset.disjoint_sup_left αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_sup_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\nκ : Type u_6\ninst✝¹ : DistribLattice α\ninst✝ : OrderTop α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\n⊢ Eq (Max.max (s.inf f) (t.inf g)) ((SProd.sprod s t).inf fun i => Max.max (f i.1) (g i.2))","decl":"theorem inf_sup_inf (s : Finset ι) (t : Finset κ) (f : ι → α) (g : κ → α) :\n    s.inf f ⊔ t.inf g = (s ×ˢ t).inf fun i => f i.1 ⊔ g i.2 :=\n  @sup_inf_sup αᵒᵈ _ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.inf_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝² : DistribLattice α\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq ι\nκ : ι → Type u_7\ns : Finset ι\nt : (i : ι) → Finset (κ i)\nf : (i : ι) → κ i → α\n⊢ Eq (s.inf fun i => (t i).sup (f i)) ((s.pi t).sup fun g => s.attach.inf fun i => f (↑i) (g ↑i ⋯))","decl":"theorem inf_sup {κ : ι → Type*} (s : Finset ι) (t : ∀ i, Finset (κ i)) (f : ∀ i, κ i → α) :\n    (s.inf fun i => (t i).sup (f i)) =\n      (s.pi t).sup fun g => s.attach.inf fun i => f _ <| g _ i.2 := by\n  induction' s using Finset.induction with i s hi ih\n  · simp\n  rw [inf_insert, ih, attach_insert, sup_inf_sup]\n  refine eq_of_forall_ge_iff fun c => ?_\n  simp only [Finset.sup_le_iff, mem_product, mem_pi, and_imp, Prod.forall,\n    inf_insert, inf_image]\n  refine\n    ⟨fun h g hg =>\n      h (g i <| mem_insert_self _ _) (fun j hj => g j <| mem_insert_of_mem hj)\n        (hg _ <| mem_insert_self _ _) fun j hj => hg _ <| mem_insert_of_mem hj,\n      fun h a g ha hg => ?_⟩\n  -- TODO: This `have` must be named to prevent it being shadowed by the internal `this` in `simpa`\n  have aux : ∀ j : { x // x ∈ s }, ↑j ≠ i := fun j : s => ne_of_mem_of_not_mem j.2 hi\n  -- Porting note: `simpa` doesn't support placeholders in proof terms\n  have := h (fun j hj => if hji : j = i then cast (congr_arg κ hji.symm) a\n      else g _ <| mem_of_mem_insert_of_ne hj hji) (fun j hj => ?_)\n  · simpa only [cast_eq, dif_pos, Function.comp_def, Subtype.coe_mk, dif_neg, aux] using this\n  rw [mem_insert] at hj\n  obtain (rfl | hj) := hj\n  · simpa\n  · simpa [ne_of_mem_of_not_mem hj hi] using hg _ _\n\n"}
{"name":"Finset.sup_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝² : DistribLattice α\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq ι\nκ : ι → Type u_7\ns : Finset ι\nt : (i : ι) → Finset (κ i)\nf : (i : ι) → κ i → α\n⊢ Eq (s.sup fun i => (t i).inf (f i)) ((s.pi t).inf fun g => s.attach.sup fun i => f (↑i) (g ↑i ⋯))","decl":"theorem sup_inf {κ : ι → Type*} (s : Finset ι) (t : ∀ i, Finset (κ i)) (f : ∀ i, κ i → α) :\n    (s.sup fun i => (t i).inf (f i)) = (s.pi t).inf fun g => s.attach.sup fun i => f _ <| g _ i.2 :=\n  @inf_sup αᵒᵈ _ _ _ _ _ _ _ _\n\n"}
{"name":"Finset.sup_sdiff_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (s.sup fun b => SDiff.sdiff a (f b)) (SDiff.sdiff a (s.inf f))","decl":"theorem sup_sdiff_left (s : Finset ι) (f : ι → α) (a : α) :\n    (s.sup fun b => a \\ f b) = a \\ s.inf f := by\n  induction s using Finset.cons_induction with\n  | empty => rw [sup_empty, inf_empty, sdiff_top]\n  | cons _ _ _ h => rw [sup_cons, inf_cons, h, sdiff_inf]\n\n"}
{"name":"Finset.inf_sdiff_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (s.inf fun b => SDiff.sdiff a (f b)) (SDiff.sdiff a (s.sup f))","decl":"theorem inf_sdiff_left (hs : s.Nonempty) (f : ι → α) (a : α) :\n    (s.inf fun b => a \\ f b) = a \\ s.sup f := by\n  induction hs using Finset.Nonempty.cons_induction with\n  | singleton => rw [sup_singleton, inf_singleton]\n  | cons _ _ _ _ ih => rw [sup_cons, inf_cons, ih, sdiff_sup]\n\n"}
{"name":"Finset.inf_sdiff_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (s.inf fun b => SDiff.sdiff (f b) a) (SDiff.sdiff (s.inf f) a)","decl":"theorem inf_sdiff_right (hs : s.Nonempty) (f : ι → α) (a : α) :\n    (s.inf fun b => f b \\ a) = s.inf f \\ a := by\n  induction hs using Finset.Nonempty.cons_induction with\n  | singleton => rw [inf_singleton, inf_singleton]\n  | cons _ _ _ _ ih => rw [inf_cons, inf_cons, ih, inf_sdiff]\n\n"}
{"name":"Finset.inf_himp_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (s.inf fun b => HImp.himp (f b) a) (HImp.himp (s.sup f) a)","decl":"theorem inf_himp_right (s : Finset ι) (f : ι → α) (a : α) :\n    (s.inf fun b => f b ⇨ a) = s.sup f ⇨ a :=\n  @sup_sdiff_left αᵒᵈ _ _ _ _ _\n\n"}
{"name":"Finset.sup_himp_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (s.sup fun b => HImp.himp (f b) a) (HImp.himp (s.inf f) a)","decl":"theorem sup_himp_right (hs : s.Nonempty) (f : ι → α) (a : α) :\n    (s.sup fun b => f b ⇨ a) = s.inf f ⇨ a :=\n  @inf_sdiff_left αᵒᵈ _ _ _ hs _ _\n\n"}
{"name":"Finset.sup_himp_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (s.sup fun b => HImp.himp a (f b)) (HImp.himp a (s.sup f))","decl":"theorem sup_himp_left (hs : s.Nonempty) (f : ι → α) (a : α) :\n    (s.sup fun b => a ⇨ f b) = a ⇨ s.sup f :=\n  @inf_sdiff_right αᵒᵈ _ _ _ hs _ _\n\n"}
{"name":"Finset.compl_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nf : ι → α\n⊢ Eq (HasCompl.compl (s.sup f)) (s.inf fun i => HasCompl.compl (f i))","decl":"@[simp]\nprotected theorem compl_sup (s : Finset ι) (f : ι → α) : (s.sup f)ᶜ = s.inf fun i => (f i)ᶜ :=\n  map_finset_sup (OrderIso.compl α) _ _\n\n"}
{"name":"Finset.compl_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : BooleanAlgebra α\ns : Finset ι\nf : ι → α\n⊢ Eq (HasCompl.compl (s.inf f)) (s.sup fun i => HasCompl.compl (f i))","decl":"@[simp]\nprotected theorem compl_inf (s : Finset ι) (f : ι → α) : (s.inf f)ᶜ = s.sup fun i => (f i)ᶜ :=\n  map_finset_inf (OrderIso.compl α) _ _\n\n"}
{"name":"Finset.comp_sup_eq_sup_comp_of_is_total","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝³ : LinearOrder α\ninst✝² : OrderBot α\ns : Finset ι\nf : ι → α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ng : α → β\nmono_g : Monotone g\nbot : Eq (g Bot.bot) Bot.bot\n⊢ Eq (g (s.sup f)) (s.sup (Function.comp g f))","decl":"theorem comp_sup_eq_sup_comp_of_is_total [SemilatticeSup β] [OrderBot β] (g : α → β)\n    (mono_g : Monotone g) (bot : g ⊥ = ⊥) : g (s.sup f) = s.sup (g ∘ f) :=\n  comp_sup_eq_sup_comp g mono_g.map_sup bot\n\n"}
{"name":"Finset.le_sup_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\nha : LT.lt Bot.bot a\n⊢ Iff (LE.le a (s.sup f)) (Exists fun b => And (Membership.mem s b) (LE.le a (f b)))","decl":"@[simp]\nprotected theorem le_sup_iff (ha : ⊥ < a) : a ≤ s.sup f ↔ ∃ b ∈ s, a ≤ f b := by\n  apply Iff.intro\n  · induction s using cons_induction with\n    | empty => exact (absurd · (not_le_of_lt ha))\n    | cons c t hc ih =>\n      rw [sup_cons, le_sup_iff]\n      exact fun\n      | Or.inl h => ⟨c, mem_cons.2 (Or.inl rfl), h⟩\n      | Or.inr h => let ⟨b, hb, hle⟩ := ih h; ⟨b, mem_cons.2 (Or.inr hb), hle⟩\n  · exact fun ⟨b, hb, hle⟩ => le_trans hle (le_sup hb)\n\n"}
{"name":"Finset.sup_eq_top_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_5\nα : Type u_7\ninst✝² : LinearOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Nontrivial α\ns : Finset ι\nf : ι → α\n⊢ Iff (Eq (s.sup f) Top.top) (Exists fun b => And (Membership.mem s b) (Eq (f b) Top.top))","decl":"protected theorem sup_eq_top_iff {α : Type*} [LinearOrder α] [BoundedOrder α] [Nontrivial α]\n    {s : Finset ι} {f : ι → α} : s.sup f = ⊤ ↔ ∃ b ∈ s, f b = ⊤ := by\n  simp only [← top_le_iff]\n  exact Finset.le_sup_iff bot_lt_top\n\n"}
{"name":"Finset.Nonempty.sup_eq_top_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_5\nα : Type u_7\ninst✝¹ : LinearOrder α\ninst✝ : BoundedOrder α\ns : Finset ι\nf : ι → α\nhs : s.Nonempty\n⊢ Iff (Eq (s.sup f) Top.top) (Exists fun b => And (Membership.mem s b) (Eq (f b) Top.top))","decl":"protected theorem Nonempty.sup_eq_top_iff {α : Type*} [LinearOrder α] [BoundedOrder α]\n    {s : Finset ι} {f : ι → α} (hs : s.Nonempty) : s.sup f = ⊤ ↔ ∃ b ∈ s, f b = ⊤ := by\n  cases subsingleton_or_nontrivial α\n  · simpa [Subsingleton.elim _ (⊤ : α)]\n  · exact Finset.sup_eq_top_iff\n\n"}
{"name":"Finset.lt_sup_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\n⊢ Iff (LT.lt a (s.sup f)) (Exists fun b => And (Membership.mem s b) (LT.lt a (f b)))","decl":"@[simp]\nprotected theorem lt_sup_iff : a < s.sup f ↔ ∃ b ∈ s, a < f b := by\n  apply Iff.intro\n  · induction s using cons_induction with\n    | empty => exact (absurd · not_lt_bot)\n    | cons c t hc ih =>\n      rw [sup_cons, lt_sup_iff]\n      exact fun\n      | Or.inl h => ⟨c, mem_cons.2 (Or.inl rfl), h⟩\n      | Or.inr h => let ⟨b, hb, hlt⟩ := ih h; ⟨b, mem_cons.2 (Or.inr hb), hlt⟩\n  · exact fun ⟨b, hb, hlt⟩ => lt_of_lt_of_le hlt (le_sup hb)\n\n"}
{"name":"Finset.sup_lt_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na : α\nha : LT.lt Bot.bot a\n⊢ Iff (LT.lt (s.sup f) a) (∀ (b : ι), Membership.mem s b → LT.lt (f b) a)","decl":"@[simp]\nprotected theorem sup_lt_iff (ha : ⊥ < a) : s.sup f < a ↔ ∀ b ∈ s, f b < a :=\n  ⟨fun hs _ hb => lt_of_le_of_lt (le_sup hb) hs,\n    Finset.cons_induction_on s (fun _ => ha) fun c t hc => by\n      simpa only [sup_cons, sup_lt_iff, mem_cons, forall_eq_or_imp] using And.imp_right⟩\n\n"}
{"name":"Finset.sup_mem_of_nonempty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\nhs : s.Nonempty\n⊢ Membership.mem (Set.image f ↑s) (s.sup f)","decl":"theorem sup_mem_of_nonempty (hs : s.Nonempty) : s.sup f ∈ f '' s := by\n  classical\n  induction s using Finset.induction with\n  | empty => exfalso; simp only [Finset.not_nonempty_empty] at hs\n  | @insert a s _ h =>\n    rw [Finset.sup_insert (b := a) (s := s) (f := f)]\n    by_cases hs : s = ∅\n    · simp [hs]\n    · rw [← ne_eq, ← Finset.nonempty_iff_ne_empty] at hs\n      simp only [Finset.coe_insert]\n      rcases le_total (f a) (s.sup f) with (ha | ha)\n      · rw [sup_eq_right.mpr ha]\n        exact Set.image_mono (Set.subset_insert a s) (h hs)\n      · rw [sup_eq_left.mpr ha]\n        apply Set.mem_image_of_mem _ (Set.mem_insert a ↑s)\n\n"}
{"name":"Finset.comp_inf_eq_inf_comp_of_is_total","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝³ : LinearOrder α\ninst✝² : OrderTop α\ns : Finset ι\nf : ι → α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ng : α → β\nmono_g : Monotone g\ntop : Eq (g Top.top) Top.top\n⊢ Eq (g (s.inf f)) (s.inf (Function.comp g f))","decl":"theorem comp_inf_eq_inf_comp_of_is_total [SemilatticeInf β] [OrderTop β] (g : α → β)\n    (mono_g : Monotone g) (top : g ⊤ = ⊤) : g (s.inf f) = s.inf (g ∘ f) :=\n  comp_inf_eq_inf_comp g mono_g.map_inf top\n\n"}
{"name":"Finset.inf_le_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\ns : Finset ι\nf : ι → α\na : α\nha : LT.lt a Top.top\n⊢ Iff (LE.le (s.inf f) a) (Exists fun b => And (Membership.mem s b) (LE.le (f b) a))","decl":"@[simp]\nprotected theorem inf_le_iff (ha : a < ⊤) : s.inf f ≤ a ↔ ∃ b ∈ s, f b ≤ a :=\n  @Finset.le_sup_iff αᵒᵈ _ _ _ _ _ _ ha\n\n"}
{"name":"Finset.inf_eq_bot_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_5\nα : Type u_7\ninst✝² : LinearOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Nontrivial α\ns : Finset ι\nf : ι → α\n⊢ Iff (Eq (s.inf f) Bot.bot) (Exists fun b => And (Membership.mem s b) (Eq (f b) Bot.bot))","decl":"protected theorem inf_eq_bot_iff {α : Type*} [LinearOrder α] [BoundedOrder α] [Nontrivial α]\n    {s : Finset ι} {f : ι → α} : s.inf f = ⊥ ↔ ∃ b ∈ s, f b = ⊥ :=\n  Finset.sup_eq_top_iff (α := αᵒᵈ)\n\n"}
{"name":"Finset.Nonempty.inf_eq_bot_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_5\nα : Type u_7\ninst✝¹ : LinearOrder α\ninst✝ : BoundedOrder α\ns : Finset ι\nf : ι → α\nh : s.Nonempty\n⊢ Iff (Eq (s.inf f) Bot.bot) (Exists fun b => And (Membership.mem s b) (Eq (f b) Bot.bot))","decl":"protected theorem Nonempty.inf_eq_bot_iff {α : Type*} [LinearOrder α] [BoundedOrder α]\n    {s : Finset ι} {f : ι → α} (h : s.Nonempty) : s.inf f = ⊥ ↔ ∃ b ∈ s, f b = ⊥ :=\n  h.sup_eq_top_iff (α := αᵒᵈ)\n\n"}
{"name":"Finset.inf_lt_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\ns : Finset ι\nf : ι → α\na : α\n⊢ Iff (LT.lt (s.inf f) a) (Exists fun b => And (Membership.mem s b) (LT.lt (f b) a))","decl":"@[simp]\nprotected theorem inf_lt_iff : s.inf f < a ↔ ∃ b ∈ s, f b < a :=\n  @Finset.lt_sup_iff αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.lt_inf_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\ns : Finset ι\nf : ι → α\na : α\nha : LT.lt a Top.top\n⊢ Iff (LT.lt a (s.inf f)) (∀ (b : ι), Membership.mem s b → LT.lt a (f b))","decl":"@[simp]\nprotected theorem lt_inf_iff (ha : a < ⊤) : a < s.inf f ↔ ∀ b ∈ s, a < f b :=\n  @Finset.sup_lt_iff αᵒᵈ _ _ _ _ _ _ ha\n\n"}
{"name":"Finset.inf_eq_iInf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset α\nf : α → β\n⊢ Eq (s.inf f) (iInf fun a => iInf fun h => f a)","decl":"theorem inf_eq_iInf [CompleteLattice β] (s : Finset α) (f : α → β) : s.inf f = ⨅ a ∈ s, f a :=\n  @sup_eq_iSup _ βᵒᵈ _ _ _\n\n"}
{"name":"Finset.inf_id_eq_sInf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\ns : Finset α\n⊢ Eq (s.inf id) (InfSet.sInf ↑s)","decl":"theorem inf_id_eq_sInf [CompleteLattice α] (s : Finset α) : s.inf id = sInf s :=\n  @sup_id_eq_sSup αᵒᵈ _ _\n\n"}
{"name":"Finset.inf_id_set_eq_sInter","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ns : Finset (Set α)\n⊢ Eq (s.inf id) (↑s).sInter","decl":"theorem inf_id_set_eq_sInter (s : Finset (Set α)) : s.inf id = ⋂₀ ↑s :=\n  inf_id_eq_sInf _\n\n"}
{"name":"Finset.inf_set_eq_iInter","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ns : Finset α\nf : α → Set β\n⊢ Eq (s.inf f) (Set.iInter fun x => Set.iInter fun h => f x)","decl":"@[simp]\ntheorem inf_set_eq_iInter (s : Finset α) (f : α → Set β) : s.inf f = ⋂ x ∈ s, f x :=\n  inf_eq_iInf _ _\n\n"}
{"name":"Finset.inf_eq_sInf_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\ns : Finset α\nf : α → β\n⊢ Eq (s.inf f) (InfSet.sInf (Set.image f ↑s))","decl":"theorem inf_eq_sInf_image [CompleteLattice β] (s : Finset α) (f : α → β) :\n    s.inf f = sInf (f '' s) :=\n  @sup_eq_sSup_image _ βᵒᵈ _ _ _\n\n"}
{"name":"Finset.sup_of_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nf : β → α\nb : β\nh : Membership.mem s b\n⊢ Exists fun a => Eq (s.sup (Function.comp WithBot.some f)) ↑a","decl":"theorem sup_of_mem {s : Finset β} (f : β → α) {b : β} (h : b ∈ s) :\n    ∃ a : α, s.sup ((↑) ∘ f : β → WithBot α) = ↑a :=\n  Exists.imp (fun _ => And.left) (@le_sup (WithBot α) _ _ _ _ _ _ h (f b) rfl)\n\n"}
{"name":"Finset.coe_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\n⊢ Eq (↑(s.sup' H f)) (s.sup (Function.comp WithBot.some f))","decl":"@[simp]\ntheorem coe_sup' : ((s.sup' H f : α) : WithBot α) = s.sup ((↑) ∘ f) := by\n  rw [sup', WithBot.coe_unbot]\n\n"}
{"name":"Finset.sup'_cons","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\nb : β\nhb : Not (Membership.mem s b)\n⊢ Eq ((Finset.cons b s hb).sup' ⋯ f) (Max.max (f b) (s.sup' H f))","decl":"@[simp]\ntheorem sup'_cons {b : β} {hb : b ∉ s} :\n    (cons b s hb).sup' (cons_nonempty hb) f = f b ⊔ s.sup' H f := by\n  rw [← WithBot.coe_eq_coe]\n  simp [WithBot.coe_sup]\n\n"}
{"name":"Finset.sup'_insert","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).sup' ⋯ f) (Max.max (f b) (s.sup' H f))","decl":"@[simp]\ntheorem sup'_insert [DecidableEq β] {b : β} :\n    (insert b s).sup' (insert_nonempty _ _) f = f b ⊔ s.sup' H f := by\n  rw [← WithBot.coe_eq_coe]\n  simp [WithBot.coe_sup]\n\n"}
{"name":"Finset.sup'_singleton","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).sup' ⋯ f) (f b)","decl":"@[simp]\ntheorem sup'_singleton {b : β} : ({b} : Finset β).sup' (singleton_nonempty _) f = f b :=\n  rfl\n\n"}
{"name":"Finset.sup'_le_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\n⊢ Iff (LE.le (s.sup' H f) a) (∀ (b : β), Membership.mem s b → LE.le (f b) a)","decl":"@[simp]\ntheorem sup'_le_iff {a : α} : s.sup' H f ≤ a ↔ ∀ b ∈ s, f b ≤ a := by\n  simp_rw [← @WithBot.coe_le_coe α, coe_sup', Finset.sup_le_iff]; rfl\n\n"}
{"name":"Finset.sup'_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\na✝ : ∀ (b : β), Membership.mem s b → LE.le (f b) a\n⊢ LE.le (s.sup' H f) a","decl":"alias ⟨_, sup'_le⟩ := sup'_le_iff\n\n"}
{"name":"Finset.le_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nf : β → α\nb : β\nh : Membership.mem s b\n⊢ LE.le (f b) (s.sup' ⋯ f)","decl":"theorem le_sup' {b : β} (h : b ∈ s) : f b ≤ s.sup' ⟨b, h⟩ f :=\n  (sup'_le_iff ⟨b, h⟩ f).1 le_rfl b h\n\n"}
{"name":"Finset.isLUB_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : SemilatticeSup α\ns : Finset α\nhs : s.Nonempty\n⊢ IsLUB (↑s) (s.sup' hs id)","decl":"set_option linter.docPrime false in\ntheorem isLUB_sup' {s : Finset α} (hs : s.Nonempty) : IsLUB s (sup' s hs id) :=\n  ⟨fun x h => id_eq x ▸ le_sup' id h, fun _ h => Finset.sup'_le hs id h⟩\n\n"}
{"name":"Finset.le_sup'_of_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nf : β → α\na : α\nb : β\nhb : Membership.mem s b\nh : LE.le a (f b)\n⊢ LE.le a (s.sup' ⋯ f)","decl":"theorem le_sup'_of_le {a : α} {b : β} (hb : b ∈ s) (h : a ≤ f b) : a ≤ s.sup' ⟨b, hb⟩ f :=\n  h.trans <| le_sup' _ hb\n\n"}
{"name":"Finset.sup'_eq_of_forall","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\nh : ∀ (b : β), Membership.mem s b → Eq (f b) a\n⊢ Eq (s.sup' H f) a","decl":"lemma sup'_eq_of_forall {a : α} (h : ∀ b ∈ s, f b = a) : s.sup' H f = a :=\n  le_antisymm (sup'_le _ _ (fun _ hb ↦ (h _ hb).le))\n    (le_sup'_of_le _ H.choose_spec (h _ H.choose_spec).ge)\n\n"}
{"name":"Finset.sup'_const","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\na : α\n⊢ Eq (s.sup' H fun x => a) a","decl":"@[simp]\ntheorem sup'_const (a : α) : s.sup' H (fun _ => a) = a := by\n  apply le_antisymm\n  · apply sup'_le\n    intros\n    exact le_rfl\n  · apply le_sup' (fun _ => a) H.choose_spec\n\n"}
{"name":"Finset.sup'_union","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : DecidableEq β\ns₁ s₂ : Finset β\nh₁ : s₁.Nonempty\nh₂ : s₂.Nonempty\nf : β → α\n⊢ Eq ((Union.union s₁ s₂).sup' ⋯ f) (Max.max (s₁.sup' h₁ f) (s₂.sup' h₂ f))","decl":"theorem sup'_union [DecidableEq β] {s₁ s₂ : Finset β} (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty)\n    (f : β → α) :\n    (s₁ ∪ s₂).sup' (h₁.mono subset_union_left) f = s₁.sup' h₁ f ⊔ s₂.sup' h₂ f :=\n  eq_of_forall_ge_iff fun a => by simp [or_imp, forall_and]\n\n"}
{"name":"Finset.sup'_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\nf : β → α\ninst✝ : DecidableEq β\ns : Finset γ\nHs : s.Nonempty\nt : γ → Finset β\nHt : ∀ (b : γ), (t b).Nonempty\n⊢ Eq ((s.biUnion t).sup' ⋯ f) (s.sup' Hs fun b => (t b).sup' ⋯ f)","decl":"theorem sup'_biUnion [DecidableEq β] {s : Finset γ} (Hs : s.Nonempty) {t : γ → Finset β}\n    (Ht : ∀ b, (t b).Nonempty) :\n    (s.biUnion t).sup' (Hs.biUnion fun b _ => Ht b) f = s.sup' Hs (fun b => (t b).sup' (Ht b) f) :=\n  eq_of_forall_ge_iff fun c => by simp [@forall_swap _ β]\n\n"}
{"name":"Finset.sup'_comm","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeSup α\ns : Finset β\nt : Finset γ\nhs : s.Nonempty\nht : t.Nonempty\nf : β → γ → α\n⊢ Eq (s.sup' hs fun b => t.sup' ht (f b)) (t.sup' ht fun c => s.sup' hs fun b => f b c)","decl":"protected theorem sup'_comm {t : Finset γ} (hs : s.Nonempty) (ht : t.Nonempty) (f : β → γ → α) :\n    (s.sup' hs fun b => t.sup' ht (f b)) = t.sup' ht fun c => s.sup' hs fun b => f b c :=\n  eq_of_forall_ge_iff fun a => by simpa using forall₂_swap\n\n"}
{"name":"Finset.sup'_product_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeSup α\ns : Finset β\nt : Finset γ\nh : (SProd.sprod s t).Nonempty\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).sup' h f) (s.sup' ⋯ fun i => t.sup' ⋯ fun i' => f { fst := i, snd := i' })","decl":"theorem sup'_product_left {t : Finset γ} (h : (s ×ˢ t).Nonempty) (f : β × γ → α) :\n    (s ×ˢ t).sup' h f = s.sup' h.fst fun i => t.sup' h.snd fun i' => f ⟨i, i'⟩ :=\n  eq_of_forall_ge_iff fun a => by simp [@forall_swap _ γ]\n\n"}
{"name":"Finset.sup'_product_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeSup α\ns : Finset β\nt : Finset γ\nh : (SProd.sprod s t).Nonempty\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).sup' h f) (t.sup' ⋯ fun i' => s.sup' ⋯ fun i => f { fst := i, snd := i' })","decl":"theorem sup'_product_right {t : Finset γ} (h : (s ×ˢ t).Nonempty) (f : β × γ → α) :\n    (s ×ˢ t).sup' h f = t.sup' h.snd fun i' => s.sup' h.fst fun i => f ⟨i, i'⟩ := by\n  rw [sup'_product_left, Finset.sup'_comm]\n\n"}
{"name":"Finset.prodMk_sup'_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq { fst := s.sup' hs f, snd := t.sup' ht g } ((SProd.sprod s t).sup' ⋯ (Prod.map f g))","decl":"/-- See also `Finset.sup'_prodMap`. -/\nlemma prodMk_sup'_sup' (hs : s.Nonempty) (ht : t.Nonempty) (f : ι → α) (g : κ → β) :\n    (sup' s hs f, sup' t ht g) = sup' (s ×ˢ t) (hs.product ht) (Prod.map f g) :=\n  eq_of_forall_ge_iff fun i ↦ by\n    obtain ⟨a, ha⟩ := hs\n    obtain ⟨b, hb⟩ := ht\n    simp only [Prod.map, sup'_le_iff, mem_product, and_imp, Prod.forall, Prod.le_def]\n    exact ⟨by aesop, fun h ↦ ⟨fun i hi ↦ (h _ _ hi hb).1, fun j hj ↦ (h _ _ ha hj).2⟩⟩\n\n"}
{"name":"Finset.sup'_prodMap","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\ns : Finset ι\nt : Finset κ\nhst : (SProd.sprod s t).Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq ((SProd.sprod s t).sup' hst (Prod.map f g)) { fst := s.sup' ⋯ f, snd := t.sup' ⋯ g }","decl":"/-- See also `Finset.prodMk_sup'_sup'`. -/\n-- @[simp] -- TODO: Why does `Prod.map_apply` simplify the LHS?\nlemma sup'_prodMap (hst : (s ×ˢ t).Nonempty) (f : ι → α) (g : κ → β) :\n    sup' (s ×ˢ t) hst (Prod.map f g) = (sup' s hst.fst f, sup' t hst.snd g) :=\n  (prodMk_sup'_sup' _ _ _ _).symm\n\n"}
{"name":"Finset.sup'_induction","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nf : β → α\np : α → Prop\nhp : ∀ (a₁ : α), p a₁ → ∀ (a₂ : α), p a₂ → p (Max.max a₁ a₂)\nhs : ∀ (b : β), Membership.mem s b → p (f b)\n⊢ p (s.sup' H f)","decl":"theorem sup'_induction {p : α → Prop} (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p (a₁ ⊔ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.sup' H f) := by\n  show @WithBot.recBotCoe α (fun _ => Prop) True p ↑(s.sup' H f)\n  rw [coe_sup']\n  refine sup_induction trivial (fun a₁ h₁ a₂ h₂ ↦ ?_) hs\n  match a₁, a₂ with\n  | ⊥, _ => rwa [bot_sup_eq]\n  | (a₁ : α), ⊥ => rwa [sup_bot_eq]\n  | (a₁ : α), (a₂ : α) => exact hp a₁ h₁ a₂ h₂\n\n"}
{"name":"Finset.sup'_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : SemilatticeSup α\ns : Set α\nw : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Membership.mem s (Max.max x y)\nι : Type u_7\nt : Finset ι\nH : t.Nonempty\np : ι → α\nh : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Membership.mem s (t.sup' H p)","decl":"theorem sup'_mem (s : Set α) (w : ∀ᵉ (x ∈ s) (y ∈ s), x ⊔ y ∈ s) {ι : Type*}\n    (t : Finset ι) (H : t.Nonempty) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.sup' H p ∈ s :=\n  sup'_induction H p w h\n\n"}
{"name":"Finset.sup'_congr","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nH : s.Nonempty\nt : Finset β\nf g : β → α\nh₁ : Eq s t\nh₂ : ∀ (x : β), Membership.mem s x → Eq (f x) (g x)\n⊢ Eq (s.sup' H f) (t.sup' ⋯ g)","decl":"@[congr]\ntheorem sup'_congr {t : Finset β} {f g : β → α} (h₁ : s = t) (h₂ : ∀ x ∈ s, f x = g x) :\n    s.sup' H f = t.sup' (h₁ ▸ H) g := by\n  subst s\n  refine eq_of_forall_ge_iff fun c => ?_\n  simp +contextual only [sup'_le_iff, h₂]\n\n"}
{"name":"Finset.comp_sup'_eq_sup'_comp","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup γ\ns : Finset β\nH : s.Nonempty\nf : β → α\ng : α → γ\ng_sup : ∀ (x y : α), Eq (g (Max.max x y)) (Max.max (g x) (g y))\n⊢ Eq (g (s.sup' H f)) (s.sup' H (Function.comp g f))","decl":"theorem comp_sup'_eq_sup'_comp [SemilatticeSup γ] {s : Finset β} (H : s.Nonempty) {f : β → α}\n    (g : α → γ) (g_sup : ∀ x y, g (x ⊔ y) = g x ⊔ g y) : g (s.sup' H f) = s.sup' H (g ∘ f) := by\n  refine H.cons_induction ?_ ?_ <;> intros <;> simp [*]\n\n"}
{"name":"map_finset_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝³ : SemilatticeSup α\ninst✝² : SemilatticeSup β\ninst✝¹ : FunLike F α β\ninst✝ : SupHomClass F α β\nf : F\ns : Finset ι\nhs : s.Nonempty\ng : ι → α\n⊢ Eq (f (s.sup' hs g)) (s.sup' hs (Function.comp (⇑f) g))","decl":"@[simp]\ntheorem _root_.map_finset_sup' [SemilatticeSup β] [FunLike F α β] [SupHomClass F α β]\n    (f : F) {s : Finset ι} (hs) (g : ι → α) :\n    f (s.sup' hs g) = s.sup' hs (f ∘ g) := by\n  refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]\n\n"}
{"name":"Finset.sup'_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\nhs : (Finset.image f s).Nonempty\ng : β → α\n⊢ Eq ((Finset.image f s).sup' hs g) (s.sup' ⋯ (Function.comp g f))","decl":"/-- To rewrite from right to left, use `Finset.sup'_comp_eq_image`. -/\n@[simp]\ntheorem sup'_image [DecidableEq β] {s : Finset γ} {f : γ → β} (hs : (s.image f).Nonempty)\n    (g : β → α) :\n    (s.image f).sup' hs g = s.sup' hs.of_image (g ∘ f) := by\n  rw [← WithBot.coe_eq_coe]; simp only [coe_sup', sup_image, WithBot.coe_sup]; rfl\n\n"}
{"name":"Finset.sup'_comp_eq_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\nhs : s.Nonempty\ng : β → α\n⊢ Eq (s.sup' hs (Function.comp g f)) ((Finset.image f s).sup' ⋯ g)","decl":"/-- A version of `Finset.sup'_image` with LHS and RHS reversed.\nAlso, this lemma assumes that `s` is nonempty instead of assuming that its image is nonempty. -/\nlemma sup'_comp_eq_image [DecidableEq β] {s : Finset γ} {f : γ → β} (hs : s.Nonempty) (g : β → α) :\n    s.sup' hs (g ∘ f) = (s.image f).sup' (hs.image f) g :=\n  .symm <| sup'_image _ _\n\n"}
{"name":"Finset.sup'_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeSup α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\nhs : (Finset.map f s).Nonempty\n⊢ Eq ((Finset.map f s).sup' hs g) (s.sup' ⋯ (Function.comp g ⇑f))","decl":"/-- To rewrite from right to left, use `Finset.sup'_comp_eq_map`. -/\n@[simp]\ntheorem sup'_map {s : Finset γ} {f : γ ↪ β} (g : β → α) (hs : (s.map f).Nonempty) :\n    (s.map f).sup' hs g = s.sup' (map_nonempty.1 hs) (g ∘ f) := by\n  rw [← WithBot.coe_eq_coe, coe_sup', sup_map, coe_sup']\n  rfl\n\n"}
{"name":"Finset.sup'_comp_eq_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeSup α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\nhs : s.Nonempty\n⊢ Eq (s.sup' hs (Function.comp g ⇑f)) ((Finset.map f s).sup' ⋯ g)","decl":"/-- A version of `Finset.sup'_map` with LHS and RHS reversed.\nAlso, this lemma assumes that `s` is nonempty instead of assuming that its image is nonempty. -/\nlemma sup'_comp_eq_map {s : Finset γ} {f : γ ↪ β} (g : β → α) (hs : s.Nonempty) :\n    s.sup' hs (g ∘ f) = (s.map f).sup' (map_nonempty.2 hs) g :=\n  .symm <| sup'_map _ _\n\n\n"}
{"name":"Finset.sup'_mono","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\nf : β → α\ns₁ s₂ : Finset β\nh : HasSubset.Subset s₁ s₂\nh₁ : s₁.Nonempty\n⊢ LE.le (s₁.sup' h₁ f) (s₂.sup' ⋯ f)","decl":"@[gcongr]\ntheorem sup'_mono {s₁ s₂ : Finset β} (h : s₁ ⊆ s₂) (h₁ : s₁.Nonempty) :\n    s₁.sup' h₁ f ≤ s₂.sup' (h₁.mono h) f :=\n  Finset.sup'_le h₁ _ (fun _ hb => le_sup' _ (h hb))\n\n"}
{"name":"Finset.sup'_mono_fun","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeSup α\ns : Finset β\nhs : s.Nonempty\nf g : β → α\nh : ∀ (b : β), Membership.mem s b → LE.le (f b) (g b)\n⊢ LE.le (s.sup' hs f) (s.sup' hs g)","decl":"@[gcongr]\nlemma sup'_mono_fun {hs : s.Nonempty} {f g : β → α} (h : ∀ b ∈ s, f b ≤ g b) :\n    s.sup' hs f ≤ s.sup' hs g := sup'_le _ _ fun b hb ↦ (h b hb).trans (le_sup' _ hb)\n\n"}
{"name":"Finset.inf_of_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nf : β → α\nb : β\nh : Membership.mem s b\n⊢ Exists fun a => Eq (s.inf (Function.comp WithTop.some f)) ↑a","decl":"theorem inf_of_mem {s : Finset β} (f : β → α) {b : β} (h : b ∈ s) :\n    ∃ a : α, s.inf ((↑) ∘ f : β → WithTop α) = ↑a :=\n  @sup_of_mem αᵒᵈ _ _ _ f _ h\n\n"}
{"name":"Finset.coe_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\n⊢ Eq (↑(s.inf' H f)) (s.inf (Function.comp WithTop.some f))","decl":"@[simp]\ntheorem coe_inf' : ((s.inf' H f : α) : WithTop α) = s.inf ((↑) ∘ f) :=\n  @coe_sup' αᵒᵈ _ _ _ H f\n\n"}
{"name":"Finset.inf'_cons","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\nb : β\nhb : Not (Membership.mem s b)\n⊢ Eq ((Finset.cons b s hb).inf' ⋯ f) (Min.min (f b) (s.inf' H f))","decl":"@[simp]\ntheorem inf'_cons {b : β} {hb : b ∉ s} :\n    (cons b s hb).inf' (cons_nonempty hb) f = f b ⊓ s.inf' H f :=\n  @sup'_cons αᵒᵈ _ _ _ H f _ _\n\n"}
{"name":"Finset.inf'_insert","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).inf' ⋯ f) (Min.min (f b) (s.inf' H f))","decl":"@[simp]\ntheorem inf'_insert [DecidableEq β] {b : β} :\n    (insert b s).inf' (insert_nonempty _ _) f = f b ⊓ s.inf' H f :=\n  @sup'_insert αᵒᵈ _ _ _ H f _ _\n\n"}
{"name":"Finset.inf'_singleton","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).inf' ⋯ f) (f b)","decl":"@[simp]\ntheorem inf'_singleton {b : β} : ({b} : Finset β).inf' (singleton_nonempty _) f = f b :=\n  rfl\n\n"}
{"name":"Finset.le_inf'_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\n⊢ Iff (LE.le a (s.inf' H f)) (∀ (b : β), Membership.mem s b → LE.le a (f b))","decl":"@[simp]\ntheorem le_inf'_iff {a : α} : a ≤ s.inf' H f ↔ ∀ b ∈ s, a ≤ f b :=\n  sup'_le_iff (α := αᵒᵈ) H f\n\n"}
{"name":"Finset.le_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\nhs : ∀ (b : β), Membership.mem s b → LE.le a (f b)\n⊢ LE.le a (s.inf' H f)","decl":"theorem le_inf' {a : α} (hs : ∀ b ∈ s, a ≤ f b) : a ≤ s.inf' H f :=\n  sup'_le (α := αᵒᵈ) H f hs\n\n"}
{"name":"Finset.inf'_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nf : β → α\nb : β\nh : Membership.mem s b\n⊢ LE.le (s.inf' ⋯ f) (f b)","decl":"theorem inf'_le {b : β} (h : b ∈ s) : s.inf' ⟨b, h⟩ f ≤ f b :=\n  le_sup' (α := αᵒᵈ) f h\n\n"}
{"name":"Finset.isGLB_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : SemilatticeInf α\ns : Finset α\nhs : s.Nonempty\n⊢ IsGLB (↑s) (s.inf' hs id)","decl":"set_option linter.docPrime false in\ntheorem isGLB_inf' {s : Finset α} (hs : s.Nonempty) : IsGLB s (inf' s hs id) :=\n  ⟨fun x h => id_eq x ▸ inf'_le id h, fun _ h => Finset.le_inf' hs id h⟩\n\n"}
{"name":"Finset.inf'_le_of_le","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nf : β → α\na : α\nb : β\nhb : Membership.mem s b\nh : LE.le (f b) a\n⊢ LE.le (s.inf' ⋯ f) a","decl":"theorem inf'_le_of_le {a : α} {b : β} (hb : b ∈ s) (h : f b ≤ a) :\n    s.inf' ⟨b, hb⟩ f ≤ a := (inf'_le _ hb).trans h\n\n"}
{"name":"Finset.inf'_eq_of_forall","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\na : α\nh : ∀ (b : β), Membership.mem s b → Eq (f b) a\n⊢ Eq (s.inf' H f) a","decl":"lemma inf'_eq_of_forall {a : α} (h : ∀ b ∈ s, f b = a) : s.inf' H f = a :=\n  sup'_eq_of_forall (α := αᵒᵈ) H f h\n\n"}
{"name":"Finset.inf'_const","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\na : α\n⊢ Eq (s.inf' H fun x => a) a","decl":"@[simp]\ntheorem inf'_const (a : α) : (s.inf' H fun _ => a) = a :=\n  sup'_const (α := αᵒᵈ) H a\n\n"}
{"name":"Finset.inf'_union","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : DecidableEq β\ns₁ s₂ : Finset β\nh₁ : s₁.Nonempty\nh₂ : s₂.Nonempty\nf : β → α\n⊢ Eq ((Union.union s₁ s₂).inf' ⋯ f) (Min.min (s₁.inf' h₁ f) (s₂.inf' h₂ f))","decl":"theorem inf'_union [DecidableEq β] {s₁ s₂ : Finset β} (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty)\n    (f : β → α) :\n    (s₁ ∪ s₂).inf' (h₁.mono subset_union_left) f = s₁.inf' h₁ f ⊓ s₂.inf' h₂ f :=\n  @sup'_union αᵒᵈ _ _ _ _ _ h₁ h₂ _\n\n"}
{"name":"Finset.inf'_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\nf : β → α\ninst✝ : DecidableEq β\ns : Finset γ\nHs : s.Nonempty\nt : γ → Finset β\nHt : ∀ (b : γ), (t b).Nonempty\n⊢ Eq ((s.biUnion t).inf' ⋯ f) (s.inf' Hs fun b => (t b).inf' ⋯ f)","decl":"theorem inf'_biUnion [DecidableEq β] {s : Finset γ} (Hs : s.Nonempty) {t : γ → Finset β}\n    (Ht : ∀ b, (t b).Nonempty) :\n    (s.biUnion t).inf' (Hs.biUnion fun b _ => Ht b) f = s.inf' Hs (fun b => (t b).inf' (Ht b) f) :=\n  sup'_biUnion (α := αᵒᵈ) _ Hs Ht\n\n"}
{"name":"Finset.inf'_comm","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeInf α\ns : Finset β\nt : Finset γ\nhs : s.Nonempty\nht : t.Nonempty\nf : β → γ → α\n⊢ Eq (s.inf' hs fun b => t.inf' ht (f b)) (t.inf' ht fun c => s.inf' hs fun b => f b c)","decl":"protected theorem inf'_comm {t : Finset γ} (hs : s.Nonempty) (ht : t.Nonempty) (f : β → γ → α) :\n    (s.inf' hs fun b => t.inf' ht (f b)) = t.inf' ht fun c => s.inf' hs fun b => f b c :=\n  @Finset.sup'_comm αᵒᵈ _ _ _ _ _ hs ht _\n\n"}
{"name":"Finset.inf'_product_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeInf α\ns : Finset β\nt : Finset γ\nh : (SProd.sprod s t).Nonempty\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).inf' h f) (s.inf' ⋯ fun i => t.inf' ⋯ fun i' => f { fst := i, snd := i' })","decl":"theorem inf'_product_left {t : Finset γ} (h : (s ×ˢ t).Nonempty) (f : β × γ → α) :\n    (s ×ˢ t).inf' h f = s.inf' h.fst fun i => t.inf' h.snd fun i' => f ⟨i, i'⟩ :=\n  sup'_product_left (α := αᵒᵈ) h f\n\n"}
{"name":"Finset.inf'_product_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeInf α\ns : Finset β\nt : Finset γ\nh : (SProd.sprod s t).Nonempty\nf : Prod β γ → α\n⊢ Eq ((SProd.sprod s t).inf' h f) (t.inf' ⋯ fun i' => s.inf' ⋯ fun i => f { fst := i, snd := i' })","decl":"theorem inf'_product_right {t : Finset γ} (h : (s ×ˢ t).Nonempty) (f : β × γ → α) :\n    (s ×ˢ t).inf' h f = t.inf' h.snd fun i' => s.inf' h.fst fun i => f ⟨i, i'⟩ :=\n  sup'_product_right (α := αᵒᵈ) h f\n\n"}
{"name":"Finset.prodMk_inf'_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq { fst := s.inf' hs f, snd := t.inf' ht g } ((SProd.sprod s t).inf' ⋯ (Prod.map f g))","decl":"/-- See also `Finset.inf'_prodMap`. -/\nlemma prodMk_inf'_inf' (hs : s.Nonempty) (ht : t.Nonempty) (f : ι → α) (g : κ → β) :\n    (inf' s hs f, inf' t ht g) = inf' (s ×ˢ t) (hs.product ht) (Prod.map f g) :=\n  prodMk_sup'_sup' (α := αᵒᵈ) (β := βᵒᵈ) hs ht _ _\n\n"}
{"name":"Finset.inf'_prodMap","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"ι : Type u_7\nκ : Type u_8\nα : Type u_9\nβ : Type u_10\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\ns : Finset ι\nt : Finset κ\nhst : (SProd.sprod s t).Nonempty\nf : ι → α\ng : κ → β\n⊢ Eq ((SProd.sprod s t).inf' hst (Prod.map f g)) { fst := s.inf' ⋯ f, snd := t.inf' ⋯ g }","decl":"/-- See also `Finset.prodMk_inf'_inf'`. -/\n-- @[simp] -- TODO: Why does `Prod.map_apply` simplify the LHS?\nlemma inf'_prodMap (hst : (s ×ˢ t).Nonempty) (f : ι → α) (g : κ → β) :\n    inf' (s ×ˢ t) hst (Prod.map f g) = (inf' s hst.fst f, inf' t hst.snd g) :=\n  (prodMk_inf'_inf' _ _ _ _).symm\n\n"}
{"name":"Finset.comp_inf'_eq_inf'_comp","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf γ\ns : Finset β\nH : s.Nonempty\nf : β → α\ng : α → γ\ng_inf : ∀ (x y : α), Eq (g (Min.min x y)) (Min.min (g x) (g y))\n⊢ Eq (g (s.inf' H f)) (s.inf' H (Function.comp g f))","decl":"theorem comp_inf'_eq_inf'_comp [SemilatticeInf γ] {s : Finset β} (H : s.Nonempty) {f : β → α}\n    (g : α → γ) (g_inf : ∀ x y, g (x ⊓ y) = g x ⊓ g y) : g (s.inf' H f) = s.inf' H (g ∘ f) :=\n  comp_sup'_eq_sup'_comp (α := αᵒᵈ) (γ := γᵒᵈ) H g g_inf\n\n"}
{"name":"Finset.inf'_induction","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nf : β → α\np : α → Prop\nhp : ∀ (a₁ : α), p a₁ → ∀ (a₂ : α), p a₂ → p (Min.min a₁ a₂)\nhs : ∀ (b : β), Membership.mem s b → p (f b)\n⊢ p (s.inf' H f)","decl":"theorem inf'_induction {p : α → Prop} (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p (a₁ ⊓ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.inf' H f) :=\n  sup'_induction (α := αᵒᵈ) H f hp hs\n\n"}
{"name":"Finset.inf'_mem","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : SemilatticeInf α\ns : Set α\nw : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Membership.mem s (Min.min x y)\nι : Type u_7\nt : Finset ι\nH : t.Nonempty\np : ι → α\nh : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Membership.mem s (t.inf' H p)","decl":"theorem inf'_mem (s : Set α) (w : ∀ᵉ (x ∈ s) (y ∈ s), x ⊓ y ∈ s) {ι : Type*}\n    (t : Finset ι) (H : t.Nonempty) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.inf' H p ∈ s :=\n  inf'_induction H p w h\n\n"}
{"name":"Finset.inf'_congr","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\ns : Finset β\nH : s.Nonempty\nt : Finset β\nf g : β → α\nh₁ : Eq s t\nh₂ : ∀ (x : β), Membership.mem s x → Eq (f x) (g x)\n⊢ Eq (s.inf' H f) (t.inf' ⋯ g)","decl":"@[congr]\ntheorem inf'_congr {t : Finset β} {f g : β → α} (h₁ : s = t) (h₂ : ∀ x ∈ s, f x = g x) :\n    s.inf' H f = t.inf' (h₁ ▸ H) g :=\n  sup'_congr (α := αᵒᵈ) H h₁ h₂\n\n"}
{"name":"map_finset_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝³ : SemilatticeInf α\ninst✝² : SemilatticeInf β\ninst✝¹ : FunLike F α β\ninst✝ : InfHomClass F α β\nf : F\ns : Finset ι\nhs : s.Nonempty\ng : ι → α\n⊢ Eq (f (s.inf' hs g)) (s.inf' hs (Function.comp (⇑f) g))","decl":"@[simp]\ntheorem _root_.map_finset_inf' [SemilatticeInf β] [FunLike F α β] [InfHomClass F α β]\n    (f : F) {s : Finset ι} (hs) (g : ι → α) :\n    f (s.inf' hs g) = s.inf' hs (f ∘ g) := by\n  refine hs.cons_induction ?_ ?_ <;> intros <;> simp [*]\n\n"}
{"name":"Finset.inf'_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\nhs : (Finset.image f s).Nonempty\ng : β → α\n⊢ Eq ((Finset.image f s).inf' hs g) (s.inf' ⋯ (Function.comp g f))","decl":"/-- To rewrite from right to left, use `Finset.inf'_comp_eq_image`. -/\n@[simp]\ntheorem inf'_image [DecidableEq β] {s : Finset γ} {f : γ → β} (hs : (s.image f).Nonempty)\n    (g : β → α)  :\n    (s.image f).inf' hs g = s.inf' hs.of_image (g ∘ f) :=\n  @sup'_image αᵒᵈ _ _ _ _ _ _ hs _\n\n"}
{"name":"Finset.inf'_comp_eq_image","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → β\nhs : s.Nonempty\ng : β → α\n⊢ Eq (s.inf' hs (Function.comp g f)) ((Finset.image f s).inf' ⋯ g)","decl":"/-- A version of `Finset.inf'_image` with LHS and RHS reversed.\nAlso, this lemma assumes that `s` is nonempty instead of assuming that its image is nonempty. -/\nlemma inf'_comp_eq_image [DecidableEq β] {s : Finset γ} {f : γ → β} (hs : s.Nonempty) (g : β → α) :\n    s.inf' hs (g ∘ f) = (s.image f).inf' (hs.image f) g :=\n  sup'_comp_eq_image (α := αᵒᵈ) hs g\n\n"}
{"name":"Finset.inf'_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeInf α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\nhs : (Finset.map f s).Nonempty\n⊢ Eq ((Finset.map f s).inf' hs g) (s.inf' ⋯ (Function.comp g ⇑f))","decl":"/-- To rewrite from right to left, use `Finset.inf'_comp_eq_map`. -/\n@[simp]\ntheorem inf'_map {s : Finset γ} {f : γ ↪ β} (g : β → α) (hs : (s.map f).Nonempty) :\n    (s.map f).inf' hs g = s.inf' (map_nonempty.1 hs) (g ∘ f) :=\n  sup'_map (α := αᵒᵈ) _ hs\n\n"}
{"name":"Finset.inf'_comp_eq_map","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : SemilatticeInf α\ns : Finset γ\nf : Function.Embedding γ β\ng : β → α\nhs : s.Nonempty\n⊢ Eq (s.inf' hs (Function.comp g ⇑f)) ((Finset.map f s).inf' ⋯ g)","decl":"/-- A version of `Finset.inf'_map` with LHS and RHS reversed.\nAlso, this lemma assumes that `s` is nonempty instead of assuming that its image is nonempty. -/\nlemma inf'_comp_eq_map {s : Finset γ} {f : γ ↪ β} (g : β → α) (hs : s.Nonempty) :\n    s.inf' hs (g ∘ f) = (s.map f).inf' (map_nonempty.2 hs) g :=\n  sup'_comp_eq_map (α := αᵒᵈ) g hs\n\n"}
{"name":"Finset.inf'_mono","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SemilatticeInf α\nf : β → α\ns₁ s₂ : Finset β\nh : HasSubset.Subset s₁ s₂\nh₁ : s₁.Nonempty\n⊢ LE.le (s₂.inf' ⋯ f) (s₁.inf' h₁ f)","decl":"@[gcongr]\ntheorem inf'_mono {s₁ s₂ : Finset β} (h : s₁ ⊆ s₂) (h₁ : s₁.Nonempty) :\n    s₂.inf' (h₁.mono h) f ≤ s₁.inf' h₁ f :=\n  Finset.le_inf' h₁ _ (fun _ hb => inf'_le _ (h hb))\n\n"}
{"name":"Finset.sup'_eq_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nH : s.Nonempty\nf : β → α\n⊢ Eq (s.sup' H f) (s.sup f)","decl":"theorem sup'_eq_sup {s : Finset β} (H : s.Nonempty) (f : β → α) : s.sup' H f = s.sup f :=\n  le_antisymm (sup'_le H f fun _ => le_sup) (Finset.sup_le fun _ => le_sup' f)\n\n"}
{"name":"Finset.coe_sup_of_nonempty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Finset β\nh : s.Nonempty\nf : β → α\n⊢ Eq (↑(s.sup f)) (s.sup (Function.comp WithBot.some f))","decl":"theorem coe_sup_of_nonempty {s : Finset β} (h : s.Nonempty) (f : β → α) :\n    (↑(s.sup f) : WithBot α) = s.sup ((↑) ∘ f) := by simp only [← sup'_eq_sup h, coe_sup' h]\n\n"}
{"name":"Finset.inf'_eq_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nH : s.Nonempty\nf : β → α\n⊢ Eq (s.inf' H f) (s.inf f)","decl":"theorem inf'_eq_inf {s : Finset β} (H : s.Nonempty) (f : β → α) : s.inf' H f = s.inf f :=\n  sup'_eq_sup (α := αᵒᵈ) H f\n\n"}
{"name":"Finset.coe_inf_of_nonempty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Finset β\nh : s.Nonempty\nf : β → α\n⊢ Eq (↑(s.inf f)) (s.inf (Function.comp WithTop.some f))","decl":"theorem coe_inf_of_nonempty {s : Finset β} (h : s.Nonempty) (f : β → α) :\n    (↑(s.inf f) : WithTop α) = s.inf ((↑) ∘ f) :=\n  coe_sup_of_nonempty (α := αᵒᵈ) h f\n\n"}
{"name":"Finset.sup_apply","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nC : β → Type u_7\ninst✝¹ : (b : β) → SemilatticeSup (C b)\ninst✝ : (b : β) → OrderBot (C b)\ns : Finset α\nf : α → (b : β) → C b\nb : β\n⊢ Eq (s.sup f b) (s.sup fun a => f a b)","decl":"@[simp]\nprotected theorem sup_apply {C : β → Type*} [∀ b : β, SemilatticeSup (C b)]\n    [∀ b : β, OrderBot (C b)] (s : Finset α) (f : α → ∀ b : β, C b) (b : β) :\n    s.sup f b = s.sup fun a => f a b :=\n  comp_sup_eq_sup_comp (fun x : ∀ b : β, C b => x b) (fun _ _ => rfl) rfl\n\n"}
{"name":"Finset.inf_apply","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nC : β → Type u_7\ninst✝¹ : (b : β) → SemilatticeInf (C b)\ninst✝ : (b : β) → OrderTop (C b)\ns : Finset α\nf : α → (b : β) → C b\nb : β\n⊢ Eq (s.inf f b) (s.inf fun a => f a b)","decl":"@[simp]\nprotected theorem inf_apply {C : β → Type*} [∀ b : β, SemilatticeInf (C b)]\n    [∀ b : β, OrderTop (C b)] (s : Finset α) (f : α → ∀ b : β, C b) (b : β) :\n    s.inf f b = s.inf fun a => f a b :=\n  Finset.sup_apply (C := fun b => (C b)ᵒᵈ) s f b\n\n"}
{"name":"Finset.sup'_apply","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nC : β → Type u_7\ninst✝ : (b : β) → SemilatticeSup (C b)\ns : Finset α\nH : s.Nonempty\nf : α → (b : β) → C b\nb : β\n⊢ Eq (s.sup' H f b) (s.sup' H fun a => f a b)","decl":"@[simp]\nprotected theorem sup'_apply {C : β → Type*} [∀ b : β, SemilatticeSup (C b)]\n    {s : Finset α} (H : s.Nonempty) (f : α → ∀ b : β, C b) (b : β) :\n    s.sup' H f b = s.sup' H fun a => f a b :=\n  comp_sup'_eq_sup'_comp H (fun x : ∀ b : β, C b => x b) fun _ _ => rfl\n\n"}
{"name":"Finset.inf'_apply","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nC : β → Type u_7\ninst✝ : (b : β) → SemilatticeInf (C b)\ns : Finset α\nH : s.Nonempty\nf : α → (b : β) → C b\nb : β\n⊢ Eq (s.inf' H f b) (s.inf' H fun a => f a b)","decl":"@[simp]\nprotected theorem inf'_apply {C : β → Type*} [∀ b : β, SemilatticeInf (C b)]\n    {s : Finset α} (H : s.Nonempty) (f : α → ∀ b : β, C b) (b : β) :\n    s.inf' H f b = s.inf' H fun a => f a b :=\n  Finset.sup'_apply (C := fun b => (C b)ᵒᵈ) H f b\n\n"}
{"name":"Finset.toDual_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : SemilatticeSup α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\n⊢ Eq (OrderDual.toDual (s.sup' hs f)) (s.inf' hs (Function.comp (⇑OrderDual.toDual) f))","decl":"@[simp]\ntheorem toDual_sup' [SemilatticeSup α] {s : Finset ι} (hs : s.Nonempty) (f : ι → α) :\n    toDual (s.sup' hs f) = s.inf' hs (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.toDual_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : SemilatticeInf α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\n⊢ Eq (OrderDual.toDual (s.inf' hs f)) (s.sup' hs (Function.comp (⇑OrderDual.toDual) f))","decl":"@[simp]\ntheorem toDual_inf' [SemilatticeInf α] {s : Finset ι} (hs : s.Nonempty) (f : ι → α) :\n    toDual (s.inf' hs f) = s.sup' hs (toDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.ofDual_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : SemilatticeInf α\ns : Finset ι\nhs : s.Nonempty\nf : ι → OrderDual α\n⊢ Eq (OrderDual.ofDual (s.sup' hs f)) (s.inf' hs (Function.comp (⇑OrderDual.ofDual) f))","decl":"@[simp]\ntheorem ofDual_sup' [SemilatticeInf α] {s : Finset ι} (hs : s.Nonempty) (f : ι → αᵒᵈ) :\n    ofDual (s.sup' hs f) = s.inf' hs (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.ofDual_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : SemilatticeSup α\ns : Finset ι\nhs : s.Nonempty\nf : ι → OrderDual α\n⊢ Eq (OrderDual.ofDual (s.inf' hs f)) (s.sup' hs (Function.comp (⇑OrderDual.ofDual) f))","decl":"@[simp]\ntheorem ofDual_inf' [SemilatticeSup α] {s : Finset ι} (hs : s.Nonempty) (f : ι → αᵒᵈ) :\n    ofDual (s.inf' hs f) = s.sup' hs (ofDual ∘ f) :=\n  rfl\n\n"}
{"name":"Finset.sup'_inf_distrib_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DistribLattice α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (Min.min a (s.sup' hs f)) (s.sup' hs fun i => Min.min a (f i))","decl":"theorem sup'_inf_distrib_left (f : ι → α) (a : α) :\n    a ⊓ s.sup' hs f = s.sup' hs fun i ↦ a ⊓ f i := by\n  induction hs using Finset.Nonempty.cons_induction with\n  | singleton => simp\n  | cons _ _ _ hs ih => simp_rw [sup'_cons hs, inf_sup_left, ih]\n\n"}
{"name":"Finset.sup'_inf_distrib_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DistribLattice α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (Min.min (s.sup' hs f) a) (s.sup' hs fun i => Min.min (f i) a)","decl":"theorem sup'_inf_distrib_right (f : ι → α) (a : α) :\n    s.sup' hs f ⊓ a = s.sup' hs fun i => f i ⊓ a := by\n  rw [inf_comm, sup'_inf_distrib_left]; simp_rw [inf_comm]\n\n"}
{"name":"Finset.sup'_inf_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\nκ : Type u_6\ninst✝ : DistribLattice α\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → α\n⊢ Eq (Min.min (s.sup' hs f) (t.sup' ht g)) ((SProd.sprod s t).sup' ⋯ fun i => Min.min (f i.1) (g i.2))","decl":"theorem sup'_inf_sup' (f : ι → α) (g : κ → α) :\n    s.sup' hs f ⊓ t.sup' ht g = (s ×ˢ t).sup' (hs.product ht) fun i => f i.1 ⊓ g i.2 := by\n  simp_rw [Finset.sup'_inf_distrib_right, Finset.sup'_inf_distrib_left, sup'_product_left]\n\n"}
{"name":"Finset.inf'_sup_distrib_left","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DistribLattice α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (Max.max a (s.inf' hs f)) (s.inf' hs fun i => Max.max a (f i))","decl":"theorem inf'_sup_distrib_left (f : ι → α) (a : α) : a ⊔ s.inf' hs f = s.inf' hs fun i => a ⊔ f i :=\n  @sup'_inf_distrib_left αᵒᵈ _ _ _ hs _ _\n\n"}
{"name":"Finset.inf'_sup_distrib_right","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DistribLattice α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\na : α\n⊢ Eq (Max.max (s.inf' hs f) a) (s.inf' hs fun i => Max.max (f i) a)","decl":"theorem inf'_sup_distrib_right (f : ι → α) (a : α) : s.inf' hs f ⊔ a = s.inf' hs fun i => f i ⊔ a :=\n  @sup'_inf_distrib_right αᵒᵈ _ _ _ hs _ _\n\n"}
{"name":"Finset.inf'_sup_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\nκ : Type u_6\ninst✝ : DistribLattice α\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → α\ng : κ → α\n⊢ Eq (Max.max (s.inf' hs f) (t.inf' ht g)) ((SProd.sprod s t).inf' ⋯ fun i => Max.max (f i.1) (g i.2))","decl":"theorem inf'_sup_inf' (f : ι → α) (g : κ → α) :\n    s.inf' hs f ⊔ t.inf' ht g = (s ×ˢ t).inf' (hs.product ht) fun i => f i.1 ⊔ g i.2 :=\n  @sup'_inf_sup' αᵒᵈ _ _ _ _ _ hs ht _ _\n\n"}
{"name":"Finset.comp_sup_eq_sup_comp_of_nonempty","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Type u_5\ninst✝³ : LinearOrder α\ns : Finset ι\nf : ι → α\ninst✝² : OrderBot α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ng : α → β\nmono_g : Monotone g\nH : s.Nonempty\n⊢ Eq (g (s.sup f)) (s.sup (Function.comp g f))","decl":"theorem comp_sup_eq_sup_comp_of_nonempty [OrderBot α] [SemilatticeSup β] [OrderBot β]\n    {g : α → β} (mono_g : Monotone g) (H : s.Nonempty) : g (s.sup f) = s.sup (g ∘ f) := by\n  rw [← Finset.sup'_eq_sup H, ← Finset.sup'_eq_sup H]\n  exact Finset.comp_sup'_eq_sup'_comp H g (fun x y ↦ Monotone.map_sup mono_g x y)\n\n"}
{"name":"Finset.le_sup'_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LE.le a (s.sup' H f)) (Exists fun b => And (Membership.mem s b) (LE.le a (f b)))","decl":"@[simp]\ntheorem le_sup'_iff : a ≤ s.sup' H f ↔ ∃ b ∈ s, a ≤ f b := by\n  rw [← WithBot.coe_le_coe, coe_sup', Finset.le_sup_iff (WithBot.bot_lt_coe a)]\n  exact exists_congr (fun _ => and_congr_right' WithBot.coe_le_coe)\n\n"}
{"name":"Finset.lt_sup'_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LT.lt a (s.sup' H f)) (Exists fun b => And (Membership.mem s b) (LT.lt a (f b)))","decl":"@[simp]\ntheorem lt_sup'_iff : a < s.sup' H f ↔ ∃ b ∈ s, a < f b := by\n  rw [← WithBot.coe_lt_coe, coe_sup', Finset.lt_sup_iff]\n  exact exists_congr (fun _ => and_congr_right' WithBot.coe_lt_coe)\n\n"}
{"name":"Finset.sup'_lt_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LT.lt (s.sup' H f) a) (∀ (i : ι), Membership.mem s i → LT.lt (f i) a)","decl":"@[simp]\ntheorem sup'_lt_iff : s.sup' H f < a ↔ ∀ i ∈ s, f i < a := by\n  rw [← WithBot.coe_lt_coe, coe_sup', Finset.sup_lt_iff (WithBot.bot_lt_coe a)]\n  exact forall₂_congr (fun _ _ => WithBot.coe_lt_coe)\n\n"}
{"name":"Finset.inf'_le_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LE.le (s.inf' H f) a) (Exists fun i => And (Membership.mem s i) (LE.le (f i) a))","decl":"@[simp]\ntheorem inf'_le_iff : s.inf' H f ≤ a ↔ ∃ i ∈ s, f i ≤ a :=\n  le_sup'_iff (α := αᵒᵈ) H\n\n"}
{"name":"Finset.inf'_lt_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LT.lt (s.inf' H f) a) (Exists fun i => And (Membership.mem s i) (LT.lt (f i) a))","decl":"@[simp]\ntheorem inf'_lt_iff : s.inf' H f < a ↔ ∃ i ∈ s, f i < a :=\n  lt_sup'_iff (α := αᵒᵈ) H\n\n"}
{"name":"Finset.lt_inf'_iff","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\na : α\n⊢ Iff (LT.lt a (s.inf' H f)) (∀ (i : ι), Membership.mem s i → LT.lt a (f i))","decl":"@[simp]\ntheorem lt_inf'_iff : a < s.inf' H f ↔ ∀ i ∈ s, a < f i :=\n  sup'_lt_iff (α := αᵒᵈ) H\n\n"}
{"name":"Finset.exists_mem_eq_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\n⊢ Exists fun i => And (Membership.mem s i) (Eq (s.sup' H f) (f i))","decl":"theorem exists_mem_eq_sup' (f : ι → α) : ∃ i, i ∈ s ∧ s.sup' H f = f i := by\n  induction H using Finset.Nonempty.cons_induction with\n  | singleton c =>  exact ⟨c, mem_singleton_self c, rfl⟩\n  | cons c s hcs hs ih =>\n    rcases ih with ⟨b, hb, h'⟩\n    rw [sup'_cons hs, h']\n    cases le_total (f b) (f c) with\n    | inl h => exact ⟨c, mem_cons.2 (Or.inl rfl), sup_eq_left.2 h⟩\n    | inr h => exact ⟨b, mem_cons.2 (Or.inr hb), sup_eq_right.2 h⟩\n\n"}
{"name":"Finset.exists_mem_eq_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : LinearOrder α\ns : Finset ι\nH : s.Nonempty\nf : ι → α\n⊢ Exists fun i => And (Membership.mem s i) (Eq (s.inf' H f) (f i))","decl":"theorem exists_mem_eq_inf' (f : ι → α) : ∃ i, i ∈ s ∧ s.inf' H f = f i :=\n  exists_mem_eq_sup' (α := αᵒᵈ) H f\n\n"}
{"name":"Finset.exists_mem_eq_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset ι\nh : s.Nonempty\nf : ι → α\n⊢ Exists fun i => And (Membership.mem s i) (Eq (s.sup f) (f i))","decl":"theorem exists_mem_eq_sup [OrderBot α] (s : Finset ι) (h : s.Nonempty) (f : ι → α) :\n    ∃ i, i ∈ s ∧ s.sup f = f i :=\n  sup'_eq_sup h f ▸ exists_mem_eq_sup' h f\n\n"}
{"name":"Finset.exists_mem_eq_inf","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\ns : Finset ι\nh : s.Nonempty\nf : ι → α\n⊢ Exists fun i => And (Membership.mem s i) (Eq (s.inf f) (f i))","decl":"theorem exists_mem_eq_inf [OrderTop α] (s : Finset ι) (h : s.Nonempty) (f : ι → α) :\n    ∃ i, i ∈ s ∧ s.inf f = f i :=\n  exists_mem_eq_sup (α := αᵒᵈ) s h f\n\n"}
{"name":"Multiset.map_finset_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Finset γ\nf : γ → Multiset β\ng : β → α\nhg : Function.Injective g\n⊢ Eq (Multiset.map g (s.sup f)) (s.sup (Function.comp (Multiset.map g) f))","decl":"theorem map_finset_sup [DecidableEq α] [DecidableEq β] (s : Finset γ) (f : γ → Multiset β)\n    (g : β → α) (hg : Function.Injective g) : map g (s.sup f) = s.sup (map g ∘ f) :=\n  Finset.comp_sup_eq_sup_comp _ (fun _ _ => map_union hg) (map_zero _)\n\n"}
{"name":"Multiset.count_finset_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Multiset β\nb : β\n⊢ Eq (Multiset.count b (s.sup f)) (s.sup fun a => Multiset.count b (f a))","decl":"theorem count_finset_sup [DecidableEq β] (s : Finset α) (f : α → Multiset β) (b : β) :\n    count b (s.sup f) = s.sup fun a => count b (f a) := by\n  letI := Classical.decEq α\n  refine s.induction ?_ ?_\n  · exact count_zero _\n  · intro i s _ ih\n    rw [Finset.sup_insert, sup_eq_union, count_union, Finset.sup_insert, ih]\n\n"}
{"name":"Multiset.mem_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Multiset β\nx : β\n⊢ Iff (Membership.mem (s.sup f) x) (Exists fun v => And (Membership.mem s v) (Membership.mem (f v) x))","decl":"theorem mem_sup {α β} [DecidableEq β] {s : Finset α} {f : α → Multiset β} {x : β} :\n    x ∈ s.sup f ↔ ∃ v ∈ s, x ∈ f v := by\n  induction s using Finset.cons_induction <;> simp [*]\n\n"}
{"name":"Finset.mem_sup'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\na : α\nhs : s.Nonempty\n⊢ Iff (Membership.mem (s.sup' hs f) a) (Exists fun i => And (Membership.mem s i) (Membership.mem (f i) a))","decl":"set_option linter.docPrime false in\n@[simp] lemma mem_sup' (hs) : a ∈ s.sup' hs f ↔ ∃ i ∈ s, a ∈ f i := by\n  induction' hs using Nonempty.cons_induction <;> simp [*]\n\n"}
{"name":"Finset.mem_inf'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\na : α\nhs : s.Nonempty\n⊢ Iff (Membership.mem (s.inf' hs f) a) (∀ (i : ι), Membership.mem s i → Membership.mem (f i) a)","decl":"set_option linter.docPrime false in\n@[simp] lemma mem_inf' (hs) : a ∈ s.inf' hs f ↔ ∀ i ∈ s, a ∈ f i := by\n  induction' hs using Nonempty.cons_induction <;> simp [*]\n\n"}
{"name":"Finset.mem_sup","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : DecidableEq α\ns : Finset ι\nf : ι → Finset α\na : α\n⊢ Iff (Membership.mem (s.sup f) a) (Exists fun i => And (Membership.mem s i) (Membership.mem (f i) a))","decl":"@[simp] lemma mem_sup : a ∈ s.sup f ↔ ∃ i ∈ s, a ∈ f i := by\n  induction' s using cons_induction <;> simp [*]\n\n"}
{"name":"Finset.sup_eq_biUnion","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝ : DecidableEq β\ns : Finset α\nt : α → Finset β\n⊢ Eq (s.sup t) (s.biUnion t)","decl":"theorem sup_eq_biUnion {α β} [DecidableEq β] (s : Finset α) (t : α → Finset β) :\n    s.sup t = s.biUnion t := by\n  ext\n  rw [mem_sup, mem_biUnion]\n\n"}
{"name":"Finset.sup_singleton''","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\ns : Finset β\nf : β → α\n⊢ Eq (s.sup fun b => Singleton.singleton (f b)) (Finset.image f s)","decl":"@[simp]\ntheorem sup_singleton'' (s : Finset β) (f : β → α) :\n    (s.sup fun b => {f b}) = s.image f := by\n  ext a\n  rw [mem_sup, mem_image]\n  simp only [mem_singleton, eq_comm]\n\n"}
{"name":"Finset.sup_singleton'","module":"Mathlib.Data.Finset.Lattice.Fold","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (s.sup Singleton.singleton) s","decl":"@[simp]\ntheorem sup_singleton' (s : Finset α) : s.sup singleton = s :=\n  (s.sup_singleton'' _).trans image_id\n\n"}
